<html><head></head><body><div id="sbo-rt-content" class="calibre1"><div id="_idContainer012" class="calibre2">
			<h1 id="_idParaDest-45" class="calibre5"><em class="italic"><a id="_idTextAnchor045" class="pcalibre calibre6 pcalibre1"/>Chapter 2</em>: Understanding SELinux Decisions and Logging</h1>
			<p class="calibre3">Once we enable SELinux on the system, it starts its access control functionality, as described in the previous chapter. Once it starts, administrators need to keep a close eye on its actions, and often need to deal with unexpected behavior if one or more applications are not acting according to the SELinux policy. Through SELinux logging, we learn how SELinux enforces its policies toward the applications on the system.</p>
			<p class="calibre3">Administrators have to know how to switch between SELinux in full-enforcement mode (resembling a host-based intrusion prevention system) versus its permissive, logging-only mode, and use its various methods to toggle the SELinux state (enabled or disabled; permissive or enforcing). Furthermore, we should know how to disable SELinux's enforcement for a single domain rather than an entire system, and learn to interpret the SELinux log events that describe which activities SELinux has prevented. We will finish with an overview of common methods for analyzing these logging events in day-to-day operations.</p>
			<p class="calibre3">In this chapter, we're going to cover the following main topics:</p>
			<ul class="calibre8">
				<li class="calibre9">Switching SELinux on and off</li>
				<li class="calibre9">SELinux logging and auditing</li>
				<li class="calibre9">Getting help with denials</li>
			</ul>
			<h1 id="_idParaDest-46" class="calibre5"><a id="_idTextAnchor046" class="pcalibre calibre6 pcalibre1"/>Technical requirements</h1>
			<p class="calibre3">Check out the following video to see the Code in Action: <a href="https://bit.ly/3dFaUXm" class="pcalibre calibre6 pcalibre1">https://bit.ly/3dFaUXm</a></p>
			<h1 id="_idParaDest-47" class="calibre5"><a id="_idTextAnchor047" class="pcalibre calibre6 pcalibre1"/>Switching SELinux on and off</h1>
			<p class="calibre3">This is <a id="_idIndexMarker087" class="pcalibre calibre6 pcalibre1"/>perhaps a weird section to begin with, but disabling SELinux is a commonly requested activity. Some vendors do not support their application running on a platform that has SELinux enabled, as those vendors do not have the expertise to develop SELinux policies for their own applications, or are not able to educate their own support lines to deal with SELinux.</p>
			<p class="calibre3">Furthermore, system administrators are generally reluctant to use security controls they do not understand or find too complex to maintain. Luckily, SELinux is becoming a de facto standard technology in several Linux distributions, which is increasing its exposure and understanding among administrators. SELinux is also capable of selectively disabling its access controls for a part of a system rather than requiring us to disable it for a complete system.</p>
			<h2 id="_idParaDest-48" class="calibre10"><a id="_idTextAnchor048" class="pcalibre calibre6 pcalibre1"/>Setting the global SELinux state</h2>
			<p class="calibre3">SELinux supports <a id="_idIndexMarker088" class="pcalibre calibre6 pcalibre1"/>three major states that it can be in: <strong class="source-inline">disabled</strong>, <strong class="source-inline">permissive</strong>, and <strong class="source-inline">enforcing</strong>. These states are set in the <strong class="source-inline">/etc/selinux/config</strong> file, through the <strong class="source-inline">SELINUX</strong> variable, as illustrated in the following code snippet:</p>
			<p class="source-code">$ grep ^SELINUX= /etc/selinux/config</p>
			<p class="source-code">SELINUX=enforcing</p>
			<p class="calibre3">When the <strong class="source-inline">init</strong> system process loads the SELinux policy, the SELinux code checks the state that the administrator has configured. The states are described as follows:</p>
			<ul class="calibre8">
				<li class="calibre9">If the state is <strong class="source-inline">disabled</strong>, then the SELinux code disables further support, booting the system further without activating SELinux.</li>
				<li class="calibre9">If the state is <strong class="source-inline">permissive</strong>, then SELinux is active but will not enforce its policy on the system. Instead, SELinux will report any violation against the policy, but will not prevent the action itself. This <a id="_idIndexMarker089" class="pcalibre calibre6 pcalibre1"/>is sometimes called <strong class="bold">host intrusion detection</strong> as it works in reporting-only mode.</li>
				<li class="calibre9">If the state is <strong class="source-inline">enforcing</strong>, then SELinux is active and will enforce its policy on the system. Violations <a id="_idIndexMarker090" class="pcalibre calibre6 pcalibre1"/>are reported and denied. This is sometimes called <strong class="bold">host intrusion prevention</strong>, as it enforces the rules while logging the actions it takes.</li>
			</ul>
			<p class="calibre3">We can use the <strong class="source-inline">getenforce</strong> command or the <strong class="source-inline">sestatus</strong> command to get information about the current state of SELinux, like so:</p>
			<p class="source-code">$ sestatus | grep mode</p>
			<p class="source-code">Current mode:	enforcing</p>
			<p class="source-code">$ getenforce</p>
			<p class="source-code">Enforcing</p>
			<p class="calibre3">It is also possible to query the <strong class="source-inline">/sys/fs/selinux/enforce</strong> pseudo-file to get similar information. If the file returns <strong class="source-inline">1</strong>, then SELinux is in enforcing mode. If it returns <strong class="source-inline">0</strong>, then it is in permissive mode. The following code snippet shows SELinux in enforcing mode:</p>
			<p class="source-code">$ cat /sys/fs/selinux/enforce</p>
			<p class="source-code">1</p>
			<p class="calibre3">When we change the <strong class="source-inline">/etc/selinux/config</strong> file, then we need to reboot the system for the changes to take effect. However, if we boot a system without SELinux support (<strong class="source-inline">disabled</strong>), re-enabling SELinux support alone will not suffice: the administrator will need to make sure that all files on the system are relabeled (the context of all files needs to be set). Without SELinux support, Linux will create and update files without updating or setting the SELinux labels on those files. When the system is later rebooted with SELinux support, SELinux will not have <a id="_idIndexMarker091" class="pcalibre calibre6 pcalibre1"/>any knowledge of the context of a file unless the labels are reset.</p>
			<p class="calibre3">Relabeling the filesystem is covered in <a href="B16276_04_Final_VK.xhtml#_idTextAnchor095" class="pcalibre calibre6 pcalibre1"><em class="italic">Chapter 4</em></a>, <em class="italic">Using File Contexts and Process Domains</em>.</p>
			<p class="calibre3">In many situations, administrators often want to disable SELinux when it starts preventing certain tasks. This is careless to say the least, and here's why:</p>
			<ul class="calibre8">
				<li class="calibre9">SELinux is a security componentâ€”part of the operating system. Disabling SELinux is like disabling a firewall because it is blocking some communication. It might help because it's a faster way of getting something to work again, but you're removing measures that were enabled to protect you.</li>
				<li class="calibre9">Just as with a firewall, SELinux is configurable by rules. If an application is prevented from working correctly, we need to update the rules for that application, just as with additional firewall rules that enable a particular network flow. We will start updating SELinux policy rules from <a href="B16276_05_Final_VK.xhtml#_idTextAnchor138" class="pcalibre calibre6 pcalibre1"><em class="italic">Chapter 5</em></a>, <em class="italic">Controlling Network Communications,</em> onward. </li>
				<li class="calibre9">In the worst case, when we want to allow every action an application performs unconditionally, we can still leave SELinux on and just run this application in an unrestricted SELinux domain, called a <em class="italic">permissive</em> domain.</li>
			</ul>
			<p class="calibre3">Distributions <a id="_idIndexMarker092" class="pcalibre calibre6 pcalibre1"/>put significant effort in the integration of SELinux within their products, and they have awesome support channels to help you out if all things fail.</p>
			<h2 id="_idParaDest-49" class="calibre10"><a id="_idTextAnchor049" class="pcalibre calibre6 pcalibre1"/>Switching to permissive or enforcing mode</h2>
			<p class="calibre3">Most distribution-provided Linux kernels allow switching between enforcing and permissive <a id="_idIndexMarker093" class="pcalibre calibre6 pcalibre1"/>mode through a simple administrative <a id="_idIndexMarker094" class="pcalibre calibre6 pcalibre1"/>command. This feature is called the <strong class="bold">SELinux development mode</strong> and is supported by the <strong class="source-inline">CONFIG_SECURITY_SELINUX_DEVELOP</strong> kernel configuration parameter. This kernel parameter, if set, also has the Linux kernel boot in permissive mode first, unless a specific boot option (<strong class="source-inline">enforcing=1</strong>) is set.</p>
			<p class="calibre3">Although we could consider this development mode a risk (all a malicious person would need to do is switch SELinux to permissive mode to disable its access controls), switching the mode requires strong administrative privileges (like the <strong class="source-inline">root</strong> user has), which most application domains don't have.</p>
			<p class="calibre3">The command to switch between permissive mode and enforcing mode is the <strong class="source-inline">setenforce</strong> command. It takes a single argument: <strong class="source-inline">0</strong> (permissive) or <strong class="source-inline">1</strong> (enforcing). The <strong class="source-inline">permissive</strong> and <strong class="source-inline">enforcing</strong> strings are allowed by the command as well.</p>
			<p class="calibre3">The change takes effect immediately. For instance, we can use the following command to switch to permissive mode:</p>
			<p class="source-code"># setenforce 0</p>
			<p class="calibre3">The effect of <strong class="source-inline">setenforce</strong> is the same as writing the right integer value into the <strong class="source-inline">/sys/fs/selinux/enforce</strong> pseudo-file, as illustrated in the following code snippet:</p>
			<p class="source-code"># echo 0 &gt; /sys/fs/selinux/enforce</p>
			<p class="calibre3">Switching between permissive and enforcing mode can be of interest for policy developers or system administrators who are modifying the system to use SELinux properly. We can also use it to quickly verify whether an application warning or error is due to SELinux access controls or notâ€”assuming the application is not SELinux-aware, which we will talk about in the <em class="italic">Understanding SELinux-aware applications</em> section.</p>
			<p class="calibre3">On production systems, it might be of interest to disable the ability to switch to permissive mode. Disabling this feature usually requires the Linux kernel to be rebuilt, but SELinux policy developers have also thought of a different way to disallow users from toggling the SELinux state. The privileges that users need to switch to permissive mode are conditional, and system administrators can easily toggle this to disable switching back from enforcing mode to permissive mode. The condition is implemented through an SELinux Boolean called <strong class="source-inline">secure_mode_policyload</strong> whose default value is <strong class="source-inline">off</strong> (meaning switching SELinux state is allowed).</p>
			<p class="calibre3"><strong class="bold">SELinux Booleans</strong> are <a id="_idIndexMarker095" class="pcalibre calibre6 pcalibre1"/>configurable options that take on a single value (<strong class="source-inline">on</strong> or <strong class="source-inline">off</strong>, although <strong class="source-inline">true</strong>/<strong class="source-inline">false</strong> and <strong class="source-inline">1</strong>/<strong class="source-inline">0</strong> are valid values as well) and manipulate parts of the active SELinux policy. The value of the conditionals can be persisted (meaning they survive reboots) or be kept only during the current boot session. We can persist the value across reboots by adding <strong class="source-inline">-P</strong> to the <strong class="source-inline">setsebool</strong> command, as follows:</p>
			<p class="source-code"># setsebool -P secure_mode_policyload on</p>
			<p class="calibre3">SELinux Booleans are covered in more depth in <a href="B16276_12_Final_VK.xhtml#_idTextAnchor312" class="pcalibre calibre6 pcalibre1"><em class="italic">Chapter 12</em></a>, <em class="italic">Tuning SELinux Policies</em>.</p>
			<p class="calibre3">The use of the <strong class="source-inline">secure_mode_policyload</strong> SELinux Boolean allows administrators to restrict switching from enforcing mode back to permissive mode. This does not disable SELinux completely, but only toggles whether it will act upon its policies or not.</p>
			<p class="calibre3">Switching <a id="_idIndexMarker096" class="pcalibre calibre6 pcalibre1"/>from a disabled state to a running state is not supported. However, the reverse is possible, but only under the following condition: if the Linux kernel is built with the <strong class="source-inline">SECURITY_SELINUX_DISABLE</strong> kernel configuration parameter, then services such as <strong class="source-inline">init</strong> can effectively disable SELinux at runtime, but only if no SELinux policy is loaded yet. This functionality, however, is not recommended to be actively used, and was only introduced for platforms where boot options are hard to use. The feature is marked as deprecated in recent kernels as such platforms are few in number.</p>
			<h2 id="_idParaDest-50" class="calibre10"><a id="_idTextAnchor050" class="pcalibre calibre6 pcalibre1"/>Using kernel boot parameters</h2>
			<p class="calibre3">Using the <strong class="source-inline">setenforce</strong> command makes sense when we want to switch to permissive or enforcing <a id="_idIndexMarker097" class="pcalibre calibre6 pcalibre1"/>mode at a point in time when we have interactive access to the system. But what if we need this on system boot? If the system refuses to boot properly due to SELinux access controls, we cannot edit the <strong class="source-inline">/etc/selinux/config</strong> file. Luckily, we can change the SELinux state through other means as well.</p>
			<p class="calibre3">The solution is to use kernel boot parameters. We can boot a Linux system with one or two parameters that take precedence over the <strong class="source-inline">/etc/selinux/config</strong> setting, as follows:</p>
			<ul class="calibre8">
				<li class="calibre9"><strong class="source-inline">selinux=0</strong>: This informs the system to disable SELinux completely, and has the same effect as setting <strong class="source-inline">SELINUX=disabled</strong> in the configuration file. When set, the other parameter (<strong class="source-inline">enforcing</strong>) is not consulted. Please remember that booting a system with SELinux disabled means that to enable it again, we need to relabel all files and resources on the filesystem. The <strong class="source-inline">selinux=</strong> parameter is supported through the <strong class="source-inline">CONFIG_SECURITY_SELINUX_BOOTPARAM</strong> kernel configuration.</li>
				<li class="calibre9"><strong class="source-inline">enforcing=0</strong>: This informs the system to run SELinux in permissive mode, and has the same effect as setting <strong class="source-inline">SELINUX=permissive</strong> in the configuration file.</li>
				<li class="calibre9"><strong class="source-inline">enforcing=1</strong>: This informs the system to run SELinux in enforcing mode, and has the same effect as setting <strong class="source-inline">SELINUX=enforcing</strong> in the configuration file.</li>
			</ul>
			<p class="calibre3">Consider a Linux system that uses GRUB2 as its boot loader, and we want to add <strong class="source-inline">enforcing=0</strong> to the boot entry. To accomplish this, we execute the following steps:</p>
			<ol class="calibre18">
				<li class="calibre9">Reboot the system until the GRUB2 boot screen comes up.</li>
				<li class="calibre9">Navigate with the arrow keys to the boot entry for which the SELinux state must be altered. This is usually the default boot entry and should be already selected.</li>
				<li class="calibre9">Press the <em class="italic">E</em> key to edit the boot entry line. Do this before the GRUB2 timer reaches zero; otherwise, the system will continue to boot.</li>
				<li class="calibre9">Use the arrow keys to go to the end of the line that starts with <strong class="source-inline">options</strong>. If no such line exists, go to the end of the line that starts with <strong class="source-inline">linux</strong>, <strong class="source-inline">linux16</strong>, or <strong class="source-inline">linuxefi</strong>.</li>
				<li class="calibre9">Add <strong class="source-inline">enforcing=0</strong> to the end of this line.</li>
				<li class="calibre9">Press <em class="italic">Ctrl</em> + <em class="italic">X</em> or <em class="italic">F10</em> to boot the entry.</li>
			</ol>
			<p class="calibre3">Other boot <a id="_idIndexMarker098" class="pcalibre calibre6 pcalibre1"/>loaders have similar approaches to changing the boot line without persisting it for every reboot. Consult your distribution documentation for more details.</p>
			<p class="calibre3">Alongside the SELinux-specific parameters, there are a few <strong class="bold">Linux Security Module</strong> (<strong class="bold">LSM</strong>)-related <a id="_idIndexMarker099" class="pcalibre calibre6 pcalibre1"/>boot parameters that can be useful to know, especially when you are combining multiple LSM modules on the same system. These are detailed as follows:</p>
			<ul class="calibre8">
				<li class="calibre9">The <strong class="source-inline">lsm.debug</strong> boot parameter enables LSM initialization debugging output, showing which LSM modules it effectively enables or ignores, and which LSM modules are considered as exclusive.</li>
				<li class="calibre9">The <strong class="source-inline">lsm=lsm1,â€¦,lsmN</strong> option chooses the order of LSM initialization. For instance, to initialize SELinux before lockdown, use <strong class="source-inline">lsm=selinux,lockdown</strong>.</li>
				<li class="calibre9">The <strong class="source-inline">security=</strong> boot parameter enables selection of the active, major/exclusive LSM module. This parameter, however, is deprecated, favoring the <strong class="source-inline">lsm=</strong> parameter.</li>
			</ul>
			<p class="calibre3">When using SELinux in production, it might be wise to properly protect the boot menuâ€”for instance, by password-protecting the menu and regularly verifying the integrity of the boot menu files.</p>
			<h2 id="_idParaDest-51" class="calibre10"><a id="_idTextAnchor051" class="pcalibre calibre6 pcalibre1"/>Disabling SELinux protections for a single service</h2>
			<p class="calibre3">Since policy version 23 (which came with Linux 2.6.26), SELinux also supports a more granular <a id="_idIndexMarker100" class="pcalibre calibre6 pcalibre1"/>approach to switching between permissive and enforcing mode: the use of permissive domains. As mentioned before, a domain is a term that SELinux uses for types (labels) assigned to processes. With <strong class="bold">permissive domains</strong>, we can <a id="_idIndexMarker101" class="pcalibre calibre6 pcalibre1"/>mark one or more domains as permissive (and, as such, not enforced by SELinux rules), even though the rest of the system is still running in enforcing mode.</p>
			<p class="calibre3">To make a domain permissive, we use the <strong class="source-inline">semanage</strong> command, as follows:</p>
			<p class="source-code"># semanage permissive -a minidlna_t</p>
			<p class="calibre3">With the same <strong class="source-inline">semanage</strong> command, we can list the currently defined permissive domains, like this:</p>
			<p class="source-code"># semanage permissive -l</p>
			<p class="source-code">Builtin Permissive Types</p>
			<p class="source-code">Customized Permissive Types</p>
			<p class="source-code">minidlna_t</p>
			<p class="calibre3">In the previous example, you will notice that there is also room for <em class="italic">built-in</em> permissive types. These are domains that have been marked as permissive by the policy dev<a id="_idTextAnchor052" class="pcalibre calibre6 pcalibre1"/>elopers of the <a id="_idIndexMarker102" class="pcalibre calibre6 pcalibre1"/>Linux distribution itself. Some distributions opt to introduce new application policies in permissive mode first, allowing users to test out the policies before enforcing them. When that is the case, you can find these permissive domains under <strong class="source-inline">Builtin Permissive Types</strong>.</p>
			<p class="calibre3">Another method for listing the custom permissive types (those not marked as permissive through the distribution) is to use the <strong class="source-inline">semodule</strong> command. In the previous chapter, we briefly touched on this command when talking about SELinux policy modules. We can use it to list the SELinux policy modules that have <strong class="source-inline">permissive_</strong> in their name because the <strong class="source-inline">semanage permissive</strong> command generates a small SELinux policy module to mark the domain as permissive, as illustrated in the following code snippet:</p>
			<p class="source-code"># semodule -l | grep permissive_</p>
			<p class="source-code">permissive_minidlna_t</p>
			<p class="calibre3">To remove the permissive mode from the domain, pass the <strong class="source-inline">-d</strong> argument to the <strong class="source-inline">semanage</strong> command. This is only possible for domains that the system administrator marked as permissive, thoughâ€”distribution-provided permissive domains cannot be switched to enforcing mode through this approach. This is illustrated in the following code snippet:</p>
			<p class="source-code"># semanage permissive -d minidlna_t</p>
			<p class="calibre3">When a domain is marked as permissive, the application should behave as if SELinux is not enabled on the system (SELinux will not be enforcing anything that particular application/domain does), making it easier for us to discover whether SELinux is really causing a <a id="_idIndexMarker103" class="pcalibre calibre6 pcalibre1"/>permission issue. Note, though, that other domains (including those that interact with a permissive domain) are themselves still governed and enforced through the SELinux access controls.</p>
			<h2 id="_idParaDest-52" class="calibre10"><a id="_idTextAnchor053" class="pcalibre calibre6 pcalibre1"/>Understanding SELinux-aware applications</h2>
			<p class="calibre3">Most applications <a id="_idIndexMarker104" class="pcalibre calibre6 pcalibre1"/>themselves do not have knowledge that they are running on an SELinux-enabled system. Without this knowledge, permissive mode truly means that the application behaves as if SELinux were not enabled to begin with. However, some applications actively rely on the SELinux policy to make access control decisions, or interact with SELinux for further information gathering. We call these applications <strong class="bold">SELinux-aware</strong> because they change their behavior based on the SELinux-related information available.</p>
			<p class="calibre3">Sadly, many of these SELinux-aware applications do not properly validate whether they are running in permissive mode or not. As a result, running these applications in a permissive domain (or the entire system in permissive mode) will generally not result in the application running as if SELinux were not active.</p>
			<p class="calibre3">Examples of <a id="_idIndexMarker105" class="pcalibre calibre6 pcalibre1"/>such applications are the <strong class="bold">Secure Shell</strong> (<strong class="bold">SSH</strong>) daemon, the system login service, the <strong class="source-inline">init</strong> system, and some cron daemons, as well as several core Linux utilities (such as <strong class="source-inline">ls</strong> and <strong class="source-inline">id</strong>). They might show permission failures or different behavior based on the SELinux policy, even if SELinux is not in enforcing mode.</p>
			<p class="calibre3">We can find out whether an application is SELinux-aware by checking whether the application is dynamically linked with the <strong class="source-inline">libselinux</strong> library. Such checks are possible with <strong class="source-inline">readelf</strong>, <strong class="source-inline">ldd</strong>, or <strong class="source-inline">objdump</strong>, as follows:</p>
			<p class="source-code">$ readelf -d /bin/ls | grep selinux</p>
			<p class="source-code">0x0000000000000001 (NEEDED)		Shared library: [libselinux.so.1]</p>
			<p class="source-code">$ ldd /bin/ls | grep selinux</p>
			<p class="source-code">libselinux.so.1 =&gt; /lib64/libselinux.so.1 (0x00005d415f3f03f0)</p>
			<p class="source-code">$ objdump -x /bin/ls | grep selinux</p>
			<p class="source-code">NEEDED	libselinux.so.1</p>
			<p class="calibre3">Knowing whether an application is SELinux-aware or not can help in troubleshooting failures, as the application's behavior might still be different between a disabled SELinux state and a permissive SELinux state.</p>
			<p class="calibre3">Up until now, we've focused on enabling or disabling SELinux, and thus on a granular or coarse-grained matter. Once it is enabled though, its interaction with the administrator will be through <a id="_idIndexMarker106" class="pcalibre calibre6 pcalibre1"/>policy enforcement and logging. So, let's look at how SELinux handles logging.</p>
			<h1 id="_idParaDest-53" class="calibre5"><a id="_idTextAnchor054" class="pcalibre calibre6 pcalibre1"/>SELinux logging and auditing</h1>
			<p class="calibre3">SELinux developers understand that a security-oriented subsystem such as SELinux can only succeed if <a id="_idIndexMarker107" class="pcalibre calibre6 pcalibre1"/>it is capable of enhanced logging andâ€”evenâ€”debugging. Every action that SELinux takes, as part of the LSM hooks that it implements, should be auditable. Denials (actions that SELinux prevents) should always be logged so that administrators can take due action. SELinux tuning and changes, such as loading new policies or altering SELinux Booleans, should always result in an audit event.</p>
			<h2 id="_idParaDest-54" class="calibre10"><a id="_idTextAnchor055" class="pcalibre calibre6 pcalibre1"/>Following audit events</h2>
			<p class="calibre3">By default, SELinux will send its messages to the Linux audit subsystem (assuming the Linux kernel is <a id="_idIndexMarker108" class="pcalibre calibre6 pcalibre1"/>configured with the audit subsystem enabled through the <strong class="source-inline">CONFIG_AUDIT</strong> kernel configuration). There, the messages are picked up by the Linux audit daemon (<strong class="source-inline">auditd</strong>) and logged in the <strong class="source-inline">/var/log/audit/audit.log</strong> file. Distributions and administrators can define additional handling rules by configuring the audit dispatcher process (<strong class="source-inline">audisp</strong>), which picks up audit events and dispatches them to one or more separate processes. The SELinux troubleshooting daemon (<strong class="source-inline">setroubleshootd</strong>), an optional service to provide help with troubleshooting SELinux events, uses this to get access to audit events.</p>
			<p class="calibre3">The audit event flow is shown in this diagram:</p>
			<div class="calibre13">
				<div id="_idContainer011" class="img---figure">
					<img src="Images/B16276_02_001.jpg" alt="Figure 2.1 â€“ Flow of audit events generated by SELinux " class="calibre19"/>
				</div>
			</div>
			<p class="figure-caption">Figure 2.1 â€“ Flow of audit events generated by SELinux</p>
			<p class="calibre3">With SELinux enabled, (almost) every permission check that results in a denial is logged. When Linux auditing is enabled, these denials are logged by the audit daemon in the <strong class="source-inline">audit.log</strong> file by default. If the audit daemon is unavailable, the events are stored in the Linux kernel message buffer, which we can consult using the <strong class="source-inline">dmesg</strong> command. The events in the kernel message buffer are also often captured through the system logger.</p>
			<p class="calibre3">If the SELinux <a id="_idIndexMarker109" class="pcalibre calibre6 pcalibre1"/>troubleshooting daemon is installed, then the audit daemon will, alongside its logging, also dispatch the events through the audit dispatch system toward the <strong class="source-inline">sedispatch</strong> command. This command will further handle the event and send it through D-Bus (a system bus implementation popular on Linux systems) to the SELinux troubleshooting daemon. This daemon will analyze the event and might suggest one or more fixes to the administrator. We will cover the SELinux troubleshooting daemon in the <em class="italic">Getting help with denials</em> section.</p>
			<p class="calibre3">Whenever SELinux verifies a particular access, it does not always go over the entire policy. Instead, it <a id="_idIndexMarker110" class="pcalibre calibre6 pcalibre1"/>has an <strong class="bold">access vector cache</strong> (<strong class="bold">AVC</strong>), in which it stores the results of previous access attempts. This cache ensures that SELinux can quickly react to activities without having a huge impact on performance. We notice the abbreviation of this cache as the message type for most SELinux events, as shown at the beginning of the following example:</p>
			<p class="source-code">type=AVC msg=audit(03/22/2020 12:15:38.557:2331): avc: denied { read } for pid=12569 comm="dmesg" name="xterm-256color" dev="sdb2" ino=131523 scontext=sysadm_u:sysadm_r:dmesg_t:s0-s0:c0.c1023 tcontext=system_u:object_r:etc_t:s0 tclass=file permissive=0</p>
			<p class="calibre3">When the Linux kernel checks a permission request, this request is represented as an <em class="italic">access vector</em>, and the cache is then consulted to quickly find the appropriate response. If the cache has the right access vector, then the decision is taken from the cache; otherwise, the SELinux <a id="_idIndexMarker111" class="pcalibre calibre6 pcalibre1"/>subsystem consults the policy itself and updates the cache. Of course, SELinux invalidates the cache when a new policy is loaded or the policy is dynamically adjusted. This ensures that all permission checks are in line with the active policy.</p>
			<p class="calibre3">This inner working of SELinux is less relevant to most administrators, but at least now we know where the term <em class="italic">AVC</em> comes from.</p>
			<h2 id="_idParaDest-55" class="calibre10"><a id="_idTextAnchor056" class="pcalibre calibre6 pcalibre1"/>Tuning the AVC</h2>
			<p class="calibre3">The AVC <a id="_idIndexMarker112" class="pcalibre calibre6 pcalibre1"/>can be slightly tuned, by setting the size of the cache or its related tables.</p>
			<p class="calibre3">We can configure the cache size itself through the <strong class="source-inline">/sys/fs/selinux/avc/cache_threshold</strong> pseudo-file (available if the <strong class="source-inline">CONFIG_SECURITY_SELINUX_AVC_STATS</strong> kernel configuration is set). For instance, to increase the cache size to 768 entries (the default is 512), the following command would be used:</p>
			<p class="source-code"># echo 768 &gt; /sys/fs/selinux/avc/cache_threshold</p>
			<p class="calibre3">To confirm the cache threshold, read the file, as follows:</p>
			<p class="source-code"># cat /sys/fs/selinux/avc/cache_threshold</p>
			<p class="source-code">768</p>
			<p class="calibre3">The AVC hash statistics are available through the <strong class="source-inline">hash_stats</strong> pseudo-file, as illustrated in the following code snippet:</p>
			<p class="source-code">$ cat /sys/fs/selinux/avc/hash_stats</p>
			<p class="source-code">entries: 506</p>
			<p class="source-code">buckets used: 233/512</p>
			<p class="source-code">longest chain: 5</p>
			<p class="calibre3">If you suspect that lower system performance is due to SELinux, then we advise you to look at the <strong class="source-inline">longest chain</strong> output in <strong class="source-inline">hash_stats</strong>. If it is longer than 10, then some performance impact can be expected, and updating the cache size might help.</p>
			<p class="calibre3">The <strong class="source-inline">avcstat</strong> command shows the evolution of the cache over time (the first number is the total since boot). When the number of cache misses is high or volatile, or the number of reclaims (obsoleting oldest cache entries and reusing them for new ones) is volatile, then the cache size might need to be increased. The command is illustrated in the following code snippet:</p>
			<p class="source-code">$ avcstat 5</p>
			<p class="source-code">lookups	hits		misses	allocs	reclaims	frees</p>
			<p class="source-code">58396334	58382324	14010		14010		10736		13511</p>
			<p class="source-code">591		591		0		0		0		0</p>
			<p class="source-code">1657		1653		4		4		0		0</p>
			<p class="calibre3">Recent kernels also allow the number of buckets used through a kernel configuration parameter to be set (<strong class="source-inline">CONFIG_SECURITY_SELINUX_SIDTAB_HASH_BITS</strong>), and its cache statistics can be viewed through the <strong class="source-inline">/sys/fs/selinux/ss/sidtab_hash_stats</strong> pseudo-file, as illustrated in the following code snippet:</p>
			<p class="source-code">$ cat /sys/fs/selinux/ss/sidtab_hash_stats</p>
			<p class="source-code">entries: 285</p>
			<p class="source-code">buckets use: 55/512</p>
			<p class="source-code">longest chain: 3</p>
			<p class="calibre3">Another <a id="_idIndexMarker113" class="pcalibre calibre6 pcalibre1"/>performance parameter is the size of the internal <strong class="bold">session ID</strong> (<strong class="bold">SID</strong>) (the internal identifier used to represent contexts) to the string cache. Sadly, we can <a id="_idIndexMarker114" class="pcalibre calibre6 pcalibre1"/>only configure this parameter at kernel build time, using the <strong class="source-inline">CONFIG_SECURITY_SELINUX_SID2STR_CACHE_SIZE</strong> setting.</p>
			<h2 id="_idParaDest-56" class="calibre10"><a id="_idTextAnchor057" class="pcalibre calibre6 pcalibre1"/>Uncovering more logging</h2>
			<p class="calibre3">There is an important SELinux policy directive that provides control over what is (not) audited, and that is <strong class="source-inline">dontaudit</strong>. A <strong class="source-inline">dontaudit</strong> rule in the SELinux policy tells SELinux that an access denial <a id="_idIndexMarker115" class="pcalibre calibre6 pcalibre1"/>should not be logged. This is the only example where SELinux won't log a denialâ€”the SELinux policy writer has explicitly disabled the auditing of events. This is usually done to remove clutter from the logs and hide cosmetic denials that have no influence on the security of the system.</p>
			<p class="calibre3">The <strong class="source-inline">seinfo</strong> utility can tell us how many of these rules, as well as its sibling rule <strong class="source-inline">auditallow</strong> (log events, even though they are allowed by the policy), are currently active, as illustrated in the following code snippet:</p>
			<p class="source-code">$ seinfo | grep -i audit</p>
			<p class="source-code">Auditallow:	1	Dontaudit:		5559</p>
			<p class="source-code">Auditallowxperm:	0	Dontauditxperm:	Â Â Â 0</p>
			<p class="calibre3">Luckily, we can disable these <strong class="source-inline">dontaudit</strong> rules at will. Through the following <strong class="source-inline">semodule</strong> command, these rules are removed from the active policy:</p>
			<p class="source-code"># semodule â€“-disable_dontaudit â€“-build</p>
			<p class="calibre3">The arguments can also be abbreviated to <strong class="source-inline">-D</strong> and <strong class="source-inline">-B</strong>, respectively. To re-enable the <strong class="source-inline">dontaudit</strong> rules, just rebuild the policy like so:</p>
			<p class="source-code"># semodule -B</p>
			<p class="calibre3">Disabling <a id="_idIndexMarker116" class="pcalibre calibre6 pcalibre1"/>the <strong class="source-inline">dontaudit</strong> rules can sometimes help in troubleshooting failures that do not result in any useful audit event. Generally speaking, though, audit events that policy writers mark as cosmetic are not the cause of a failure.</p>
			<h2 id="_idParaDest-57" class="calibre10"><a id="_idTextAnchor058" class="pcalibre calibre6 pcalibre1"/>Configuring Linux auditing</h2>
			<p class="calibre3">SELinux will try <a id="_idIndexMarker117" class="pcalibre calibre6 pcalibre1"/>to use the audit subsystem when available and will fall back to regular system logging when it isn't. This can either be because the Linux kernel audit subsystem is not configured or because the Linux audit daemon itself is not running.</p>
			<p class="calibre3">For a Linux audit, we usually do not need to configure anything as SELinux AVC denials are logged by default. You will find the denials in the audit log file (<strong class="source-inline">/var/log/audit/audit.log</strong>), usually together with the system call and other event messages related to the same action, as illustrated in the following code snippet:</p>
			<p class="source-code">type=PROCTITLE msg=audit(...) : proctitle=ping 8.8.8.8 </p>
			<p class="source-code">type=SYSCALL msg=audit(...) : arch=x86_64 syscall=socket success=no exit=EACCES(Permission denied) a0=inet a1=SOCK_DGRAM a2=icmp a3=0x7fffac013050 items=0 ppid=2685 pid=17292 auid=admin uid=root gid=root euid=root suid=root fsuid=root egid=root sgid=root fsgid=root tty=tty1 ses=1 comm=ping exe=/bin/ping subj=sysadm_u:sysadm_r:ping_t:s0-s0:c0.c1023 key=(null) </p>
			<p class="source-code"> type=AVC msg=audit(...) : avc:Â Â deniedÂ Â { create } forÂ Â pid=17292 comm=ping scontext=sysadm_u:sysadm_r:ping_t:s0-s0:c0.c1023 tcontext=sysadm_u:sysadm_r:ping_t:s0-s0:c0.c1023 tclass=icmp_socket permissive=0 </p>
			<p class="calibre3">To configure the target log file for the audit system, use the <strong class="source-inline">log_file</strong> parameter in <strong class="source-inline">/etc/audit/auditd.conf</strong>.</p>
			<p class="calibre3">To enable remote audit logging (to centralize audit events from multiple hosts on a single system), you have the option of either enabling syslog forwarding or enabling the <strong class="source-inline">audisp-remote</strong> plugin.</p>
			<p class="calibre3">With syslog forwarding, the audit dispatch daemon is configured to send audit events to the local system logger as well. It is then up to the administrator to configure the local system logger to pass on events toward a remote system.</p>
			<p class="callout-heading">Informational note</p>
			<p class="callout">The use of syslog forwarding has the advantage that no additional software deployments and daemons are needed on the servers to centralize their log events. The setup is hence also reusable in case hardened appliances are introduced to the environment. Of course, other log management solutions exist that can watch for log events and send those to the central server. These, however, require more configuration, and introduce an additional software agent to install.</p>
			<p class="calibre3">Edit the <strong class="source-inline">/etc/audit/plugins.d/syslog.conf</strong> file and set <strong class="source-inline">active</strong> to <strong class="source-inline">yes</strong>, as follows:</p>
			<p class="source-code"># vi /etc/audit/plugins.d/syslog.conf</p>
			<p class="source-code">active = yes</p>
			<p class="source-code">direction = out</p>
			<p class="source-code">path = /sbin/audisp-syslog</p>
			<p class="source-code">type = always</p>
			<p class="source-code">args = LOG_INFO</p>
			<p class="source-code">format = string</p>
			<p class="calibre3">Using the system logger to centralize audit events might not be the best option though, as system loggers generally use unencryptedâ€”and often not even guaranteedâ€”data delivery. With the <strong class="source-inline">audisp-remote</strong> plugin, we can even use an encrypted channel to send the audit events, and provide guaranteed delivery to a remote <strong class="source-inline">auditd</strong> server.</p>
			<p class="calibre3">First, configure <a id="_idIndexMarker118" class="pcalibre calibre6 pcalibre1"/>the audit daemon on the target (log) server to accept audit logs from remote hosts by enabling the audit daemon to listen on port <strong class="source-inline">60</strong>. We also change the event formatting to an enriched value and add hostnames to the events so that we can distinguish events from multiple hosts, as follows:</p>
			<p class="source-code"># vi /etc/audit/auditd.conf</p>
			<p class="source-code">tcp_listen_port = 60</p>
			<p class="source-code">log_format = ENRICHED</p>
			<p class="source-code">name_format = HOSTNAME</p>
			<p class="calibre3">Next, on the source systems, configure <strong class="source-inline">auditd.conf</strong> as shown in the previous code snippet, but without the port setting. Then, configure the <strong class="source-inline">audisp-remote</strong> plugin to connect to the target server's audit daemon, as follows:</p>
			<p class="source-code"># vi /etc/audit/audisp-remote.conf</p>
			<p class="source-code">remote_server = &lt;targethostname&gt;</p>
			<p class="source-code">port = 60</p>
			<p class="calibre3">Finally, enable the <strong class="source-inline">audisp-remote</strong> plugin, as follows:</p>
			<p class="source-code"># vi /etc/audit/plugins.d/au-remote.conf</p>
			<p class="source-code">active = yes</p>
			<p class="calibre3">Don't forget to restart the audit daemon so that the changes take effect.</p>
			<p class="calibre3">We can only recommend you always use the Linux audit subsystem. Not only does it integrate nicely with troubleshooting utilities; it also allows administrators to use the audit tools to query the audit logs or even generate reports, such as with <strong class="source-inline">aureport</strong>, as illustrated in the following code snippet:</p>
			<p class="source-code"># aureport --avc --start recent</p>
			<p class="source-code">AVC Report</p>
			<p class="source-code">===============================================================</p>
			<p class="source-code"># date time comm subj syscall class permission obj result event</p>
			<p class="source-code">===============================================================</p>
			<p class="source-code">...</p>
			<p class="source-code">7. 03/21/2020 19:40:55 sudo sysadm_u:sysadm_r:sysadm_sudo_t:s0-s0:c0.c1023 257 dir search sysadm_u:sysadm_r:sysadm_t:s0-s0:c0.c1023 denied 1067</p>
			<p class="source-code">...</p>
			<p class="source-code">10. 03/21/2020 19:48:19 dmesg sysadm_u:sysadm_r:dmesg_t:s0-s0:c0.c1023 21 file read system_u:object_r:etc_t:s0 denied 1080</p>
			<p class="calibre3">The Linux <a id="_idIndexMarker119" class="pcalibre calibre6 pcalibre1"/>audit system is an important aide for Linux administrators, and not just for SELinux troubleshooting. But next to the Linux audit system, events can also be directed toward the local system logger, as explained next.</p>
			<h2 id="_idParaDest-58" class="calibre10"><a id="_idTextAnchor059" class="pcalibre calibre6 pcalibre1"/>Configuring the local system logger</h2>
			<p class="calibre3">When auditing <a id="_idIndexMarker120" class="pcalibre calibre6 pcalibre1"/>is not enabled, or the Linux audit daemon is not running, then the system logger is responsible for capturing SELinux events. The system logger will log these events through the kernel logging facility (<strong class="source-inline">kern.*</strong>). Most system loggers will save these kernel log events in a general log file, such as <strong class="source-inline">/var/log/messages</strong>.</p>
			<p class="calibre3">We can configure the system logger to direct SELinux AVC messages into its own log file, such as <strong class="source-inline">/var/log/avc.log</strong>. For instance, for the <strong class="source-inline">rsyslog</strong> system logger, we can add in a configuration entry under <strong class="source-inline">/etc/rsyslog.d</strong> named <strong class="source-inline">99-selinux.conf</strong>, with the following content:</p>
			<p class="source-code"># vi /etc/rsyslog.d/99-selinux.conf</p>
			<p class="source-code">:msg, contains, "avc: "	-/var/log/avc.log</p>
			<p class="calibre3">After restarting the system logger, the AVC-related messages will show up in the <strong class="source-inline">/var/log/avc.log</strong> file.</p>
			<p class="calibre3">When the local system logger handles SELinux logging, an easy method to quickly obtain the latest AVC denials (or other messages) is through the <strong class="source-inline">dmesg</strong> command, as illustrated in the following code snippet:</p>
			<p class="source-code"># dmesg | grep avc | tail</p>
			<p class="calibre3">Be aware, though, that unlike the audit logs, many systems allow the <strong class="source-inline">dmesg</strong> content to be read by regular users. This might result in some information leakage to untrusted users. For this reason, some SELinux policies do not allow regular users to access the kernel ring buffer (and, as such, use <strong class="source-inline">dmesg</strong>) unless the <strong class="source-inline">user_dmesg</strong> SELinux Boolean is set to <strong class="source-inline">on</strong>, as illustrated in the following code snippet:</p>
			<p class="source-code"># setsebool user_dmesg on</p>
			<p class="calibre3">The <strong class="source-inline">user_dmesg</strong> SELinux Boolean is not available on CentOS, though. There, only the standard <a id="_idIndexMarker121" class="pcalibre calibre6 pcalibre1"/>unconfined user type and the administrative user type have access to the kernel ring buffer. To prevent other users from reading this information, you need to map these users to non-administrative SELinux users, such as <strong class="source-inline">user_u</strong> or <strong class="source-inline">(x)guest_u</strong>, which is something described further on in this book.</p>
			<h2 id="_idParaDest-59" class="calibre10"><a id="_idTextAnchor060" class="pcalibre calibre6 pcalibre1"/>Reading SELinux denials</h2>
			<p class="calibre3">The one thing every one of us will have to do several times with SELinux systems is to read and interpret <a id="_idIndexMarker122" class="pcalibre calibre6 pcalibre1"/>SELinux denial information. When SELinux prohibits access and there is no <strong class="source-inline">dontaudit</strong> rule in place to hide it, SELinux will log it. If nothing is logged, it was probably not SELinux that was responsible for the failure. Remember: SELinux <a id="_idIndexMarker123" class="pcalibre calibre6 pcalibre1"/>comes after Linux <strong class="bold">discretionary access control</strong> (<strong class="bold">DAC</strong>) checks, so if a regular permission doesn't allow a certain activity then SELinux is never consulted.</p>
			<p class="calibre3">SELinux denial messages are logged the moment SELinux prevents some access from occurring. When SELinux is in enforcing mode, the application usually returns a <strong class="bold">Permission denied</strong> error, although sometimes it might be a bit more obscure. An example of this can be seen in the following code snippet:</p>
			<p class="source-code">$ ls /proc/1</p>
			<p class="source-code">ls: cannot access '/proc/1': Permission denied</p>
			<p class="source-code"># ls -ldZ /proc/1</p>
			<p class="source-code">dr-xr-xr-x. 9 root system_u:system_r:init_t:s0 0 Mar 21 10:54 /proc/1</p>
			<p class="calibre3">So, what does a denial message look like? The following command output shows a denial from the audit subsystem, which we can query through the <strong class="source-inline">ausearch</strong> command:</p>
			<p class="source-code"># ausearch -m avc -ts recent -i</p>
			<p class="source-code">type=AVC msg=audit(03/22/2020 12:15:38.557:2331): avc: denied { read } for pid=12569 comm="dmesg" name="xterm-256color" dev="sdb2" ino=131523 scontext=sysadm_u:sysadm_r:dmesg_t:s0-s0:c0.c1023 tcontext=system_u:object_r:etc_t:s0 tclass=file permissive=0</p>
			<p class="calibre3">Let's break up this denial into its individual components. The following list gives more information about each part of the preceding denials. As an administrator, knowing how to read denials <a id="_idIndexMarker124" class="pcalibre calibre6 pcalibre1"/>is extremely important, so take enough time for this:</p>
			<ul class="calibre8">
				<li class="calibre9"><strong class="bold">SELinux action</strong>: The action that SELinux took or would take if run in <strong class="source-inline">enforcing</strong> mode. This <a id="_idIndexMarker125" class="pcalibre calibre6 pcalibre1"/>is usually <strong class="source-inline">denied</strong>, although some actions are explicitly marked to be audited as well and would result in <strong class="source-inline">granted</strong>. Example: <strong class="source-inline">denied</strong></li>
				<li class="calibre9"><strong class="bold">Permissions</strong>: The <a id="_idIndexMarker126" class="pcalibre calibre6 pcalibre1"/>checked permissions (action initiated by the process). This is usually a single permission, although it can sometimes be a set of permissions. Example: <strong class="source-inline">{ read }</strong></li>
				<li class="calibre9"><strong class="bold">Process ID (PID)</strong>: The ID <a id="_idIndexMarker127" class="pcalibre calibre6 pcalibre1"/>of the process that was performing the action. Example: <strong class="source-inline">pid=12569</strong></li>
				<li class="calibre9"><strong class="bold">Process name</strong>: The <a id="_idIndexMarker128" class="pcalibre calibre6 pcalibre1"/>process name (command). It doesn't display any arguments to the command, though. Example: <strong class="source-inline">comm="dmesg"</strong></li>
				<li class="calibre9"><strong class="bold">Target name</strong>: The <a id="_idIndexMarker129" class="pcalibre calibre6 pcalibre1"/>name of the target (resource) that the process is performing an action on. If the target is a file, then the name is usually the filename or directory. Example: <strong class="source-inline">name="xterm-256color"</strong></li>
				<li class="calibre9"><strong class="bold">Target device</strong>: The <a id="_idIndexMarker130" class="pcalibre calibre6 pcalibre1"/>device on which the target resource resides. Together with the next field (inode number) this allows us to uniquely identify the resource on a system. Example: <strong class="source-inline">dev="sdb2"</strong></li>
				<li class="calibre9"><strong class="bold">Target file inode number</strong>: The inode number of the target file or directory. Together <a id="_idIndexMarker131" class="pcalibre calibre6 pcalibre1"/>with the device, this allows us to find the file on the filesystem.Example: <strong class="source-inline">ino=131523</strong></li>
				<li class="calibre9"><strong class="bold">Source context</strong>: The <a id="_idIndexMarker132" class="pcalibre calibre6 pcalibre1"/>context in which the process resides (the domain of the process). Example: <strong class="source-inline">scontext=sysadm_u:sysadm_r:dmesg_t:s0-s0:c0.c1023</strong></li>
				<li class="calibre9"><strong class="bold">Target context</strong>: The <a id="_idIndexMarker133" class="pcalibre calibre6 pcalibre1"/>context of the target resources. Example: <strong class="source-inline">tcontext=system_u:object_r:etc_t:s0</strong></li>
				<li class="calibre9"><strong class="bold">Object class</strong>: The class of the target objectâ€”for instance, a directory, file, socket, node, pipe, file <a id="_idIndexMarker134" class="pcalibre calibre6 pcalibre1"/>descriptor, filesystem, or capability. Example: <strong class="source-inline">tclass=file</strong></li>
				<li class="calibre9"><strong class="bold">Permissive mode</strong>: The mode the domain was in when the action was executed. If set to <strong class="source-inline">0</strong>, then <a id="_idIndexMarker135" class="pcalibre calibre6 pcalibre1"/>SELinux was in enforcing mode; otherwise, it was permissive (either for the system or for the given domain).Example: <strong class="source-inline">permissive=0</strong></li>
			</ul>
			<p class="calibre3">We can interpret the previous denial like so: SELinux has denied the <strong class="source-inline">dmesg</strong> command to read a file named "<strong class="source-inline">xterm-256color</strong>". The file has inode number <strong class="source-inline">131523</strong> on device <strong class="source-inline">/dev/sdb2</strong> and is labeled as <strong class="source-inline">etc_t</strong>. The <strong class="source-inline">dmesg</strong> command has PID <strong class="source-inline">12569</strong> and is labeled as <strong class="source-inline">dmesg_t</strong>. The <strong class="source-inline">dmesg_t</strong> domain was not in permissive mode.</p>
			<p class="calibre3">Depending on the action and the target class, SELinux uses different fields to give all the information <a id="_idIndexMarker136" class="pcalibre calibre6 pcalibre1"/>we need to troubleshoot a problem. Consider the following denial:</p>
			<p class="source-code">type=AVC msg=audit(03/22/20 18:12:52.177:2326): avc:Â Â deniedÂ Â { name_bind } forÂ Â pid=15983 comm="nginx" src=89 scontext=system_u:system_r:httpd_t:s0 tcontext=system_u:object_r:reserved_port_t:s0 tclass=tcp_socket permissive=0</p>
			<p class="calibre3">The preceding denial came up because the nginx web server was configured to listen on a non-default port (89 instead of the default 80).</p>
			<p class="calibre3">Identifying the problem is a matter of understanding how the operations work and properly reading the denials. The denial logs give us enough to get us started, giving a clear idea of what was denied.</p>
			<p class="calibre3">Administrators might want to update the SELinux policy to allow a specific action (by adding an <strong class="source-inline">allow</strong> rule to the SELinux policy, as described further on in this book). This is, however, not always the right approach because other options exist and are usually better, such as these:</p>
			<ul class="calibre8">
				<li class="calibre9">Providing the right label on the target resource (usually the case when the target is a non-default port, non-default location, and so on)</li>
				<li class="calibre9">Switching Booleans (flags that manipulate the SELinux policy) to allow additional privileges</li>
				<li class="calibre9">Providing the right label on the source process (often the case when the acting application is not installed by the distribution package manager)</li>
				<li class="calibre9">Using the application as intended instead of through other means (as SELinux only allows expected behavior), such as starting a daemon through a service (<strong class="source-inline">init</strong> script or systemd unit) instead of through a command-line operation</li>
			</ul>
			<p class="calibre3">If the <a id="_idIndexMarker137" class="pcalibre calibre6 pcalibre1"/>preceding nginx example were a wanted configuration (using a non-default port), then we should label this port as a <strong class="bold">HyperText Transfer Protocol</strong> (<strong class="bold">HTTP</strong>) port <a id="_idIndexMarker138" class="pcalibre calibre6 pcalibre1"/>and not allow the <strong class="source-inline">httpd_t</strong> domain to bind on (many) other ports.</p>
			<h2 id="_idParaDest-60" class="calibre10"><a id="_idTextAnchor061" class="pcalibre calibre6 pcalibre1"/>Other SELinux-related event types</h2>
			<p class="calibre3">Although most <a id="_idIndexMarker139" class="pcalibre calibre6 pcalibre1"/>SELinux log events are AVC-related, they aren't the sole event types an administrator will have to deal with. Most audit events will show SELinux information as part of the event, even though SELinux has little to do with the event itself, but a few audit event types are directly concerned with SELinux.</p>
			<p class="callout-heading">Tip</p>
			<p class="callout">A full list of all possible audit events is available in the <strong class="source-inline">linux/audit.h</strong> header file, located in <strong class="source-inline">/usr/include</strong>.</p>
			<h3 class="calibre12">USER_AVC</h3>
			<p class="calibre3">A <strong class="source-inline">USER_AVC</strong> event resembles regular AVC audit events, but now the source is a user space <a id="_idIndexMarker140" class="pcalibre calibre6 pcalibre1"/>object manager. These are applications that use <a id="_idIndexMarker141" class="pcalibre calibre6 pcalibre1"/>SELinux policy rules, but they enforce these rules themselves rather than through the kernel.</p>
			<p class="calibre3">The following example is such an event, generated by D-Bus:</p>
			<p class="source-code">type=USER_AVC msg=audit(03/22/2020 11:25:56.123:154) : pid=540 uid=dbus auid=unset ses=unset subj=system_u:system_r:system_dbusd_t:s0-s0:c0.c1023 msg='avc:Â Â deniedÂ Â { acquire_svc } for service=com.redhat.tuned spid=1460 scontext=system_u:system_r:tuned_t:s0 tcontext=system_u:system_r:tunned_t:s0 tclass=dbus permissive=0Â Â exe=/usr/bin/dbus-daemon sauid=dbus hostname=? addr=? terminal=?'</p>
			<p class="calibre3">The event has two parts. Everything up to the <strong class="source-inline">msg=</strong> string is information about the user space object manager that generated the event, and is the first part of the event. The true event itself (which is the second part) is stored within the <strong class="source-inline">msg=</strong> part and includes similar fields, as we already know from regular AVCs.</p>
			<h3 class="calibre12">SELINUX_ERR</h3>
			<p class="calibre3">An <strong class="source-inline">SELINUX_ERR</strong> event comes up when SELinux detects a general policy violation rather than an <a id="_idIndexMarker142" class="pcalibre calibre6 pcalibre1"/>access control violation. It cannot be resolved <a id="_idIndexMarker143" class="pcalibre calibre6 pcalibre1"/>by SELinux policy writers by just allowing the operation. These events usually point to a misuse of applications and services that the policy is not tailored to accomplish, and an example is shown in the following code snippet:</p>
			<p class="source-code">type=PATH msg=audit(03/22/2020 12:25:53.104:2364) : item=0 name=/usr/sbin/rpc.nfsd inode=3019958 dev=08:12 mode=file,755 ouid=root ogid=root rdev=00:00 obj=system_u:object_r:nfsd_exec_t:s0 nametype=NORMAL cap_fp=none cap_fi=none cap_fe=0 cap_fver=0 cap_frootid=0</p>
			<p class="source-code">type=SELINUX_ERR msg=audit(03/22/2020 12:25:53.104:2364) : op=security_compute_sid invalid_context=sysadm_u:sysadm_r:nfsd_t:s0-s0:c0.c1023 scontext=sysadm_u:sysadm_r:sysadm_t:s0-s0:c0.c1023 tcontext=system_u:object_r:nfsd_exec_t:s0 tclass=process </p>
			<p class="calibre3">In the <a id="_idIndexMarker144" class="pcalibre calibre6 pcalibre1"/>preceding example, a user (running in the <strong class="source-inline">sysadm_t</strong> domain) was executing <strong class="source-inline">rpc.nfsd</strong> (with <strong class="source-inline">nfsd_exec_t</strong> as the label), and the policy wanted to transition <a id="_idIndexMarker145" class="pcalibre calibre6 pcalibre1"/>to the <strong class="source-inline">nfsd_t</strong> domain. However, that resulted in a full context of <strong class="source-inline">sysadm_u:sysadm_r:nfsd_t:s0-s0:c0.c1023</strong>, which is not a valid context. The <strong class="source-inline">sysadm_r</strong> SELinux role does not support the <strong class="source-inline">nfsd_t</strong> domain.</p>
			<h3 class="calibre12">MAC_POLICY_LOAD</h3>
			<p class="calibre3">A <strong class="source-inline">MAC_POLICY_LOAD</strong> event occurs whenever the system loads a new SELinux policy in memory. This <a id="_idIndexMarker146" class="pcalibre calibre6 pcalibre1"/>occurs when the administrator <a id="_idIndexMarker147" class="pcalibre calibre6 pcalibre1"/>loads a new or updated SELinux policy module, rebuilds the policy with the <strong class="source-inline">dontaudit</strong> rules disabled, or toggles an SELinux Boolean that the administrator wants to persist across reboots. Such an event is illustrated in the following code snippet:</p>
			<p class="source-code">type=MAC_POLICY_LOAD msg=audit(03/22/2020 12:28:17.077:2368) : auid=admin ses=1 lsm=selinux res=yes</p>
			<p class="calibre3">When a <strong class="source-inline">MAC_POLICY_LOAD</strong> event occurs, you might notice a subsequent <strong class="source-inline">USER_MAC_POLICY_LOAD</strong> event. This occurs when a user space object manager detects an update on the SELinux policy and takes action. Note that not all user space object managers will send out this event: some object managers will query the live policy and, as such, do not need to act when a new policy loads.</p>
			<h3 class="calibre12">MAC_CONFIG_CHANGE</h3>
			<p class="calibre3">When an <a id="_idIndexMarker148" class="pcalibre calibre6 pcalibre1"/>SELinux Boolean changes but doesn't persist, then a <strong class="source-inline">MAC_CONFIG_CHANGE</strong> event will be dispatched. This tells the administrator that the active policy has been instructed to change its behavior slightly, but within the bounds of the existing loaded policy. Such an event is illustrated in the following code snippet:</p>
			<p class="source-code">type=MAC_CONFIG_CHANGE msg=audit(03/22/2020 12:29:49.564:2370) : bool=virt_use_nfs val=0 old_val=1 auid=admin ses=1</p>
			<p class="calibre3">In the preceding example, the <strong class="source-inline">virt_use_nfs</strong> SELinux Boolean was changed from the value 1 (on) to 0 (off).</p>
			<h3 class="calibre12">MAC_STATUS</h3>
			<p class="calibre3">A <strong class="source-inline">MAC_STATUS</strong> event shows up when the SELinux enforcement state has been changed. For instance, when <a id="_idIndexMarker149" class="pcalibre calibre6 pcalibre1"/>an administrator uses <strong class="source-inline">setenforce 0</strong> to put <a id="_idIndexMarker150" class="pcalibre calibre6 pcalibre1"/>SELinux in permissive mode, then the following event occurs:</p>
			<p class="source-code">type=MAC_STATUS msg=audit(03/22/2020 12:30:45.200:2372) : enforcing=0 old_enforcing=1 auid=admin ses=1 enabled=1 old-enabled=1 lsm=selinux res=yes</p>
			<p class="calibre3"><strong class="source-inline">MAC_STATUS</strong> is also used to inform administrators when the SELinux state itself (enabled or disabled) is altered.</p>
			<h3 class="calibre12">NetLabel events</h3>
			<p class="calibre3">NetLabel is a <a id="_idIndexMarker151" class="pcalibre calibre6 pcalibre1"/>Linux kernel project to support labeled <a id="_idIndexMarker152" class="pcalibre calibre6 pcalibre1"/>network packets, allowing security contexts such as SELinux contexts to be passed on between hosts. One of the protocols that the NetLabel implementation <a id="_idIndexMarker153" class="pcalibre calibre6 pcalibre1"/>supports in Linux is <strong class="bold">Common IP Security Option</strong> (<strong class="bold">CIPSO</strong>) labeling, which we will cover in <a href="B16276_05_Final_VK.xhtml#_idTextAnchor138" class="pcalibre calibre6 pcalibre1"><em class="italic">Chapter 5</em></a>, <em class="italic">Controlling Network Communications</em>.</p>
			<p class="calibre3">The following audit events are related to the NetLabel capability:</p>
			<ul class="calibre8">
				<li class="calibre9"><strong class="source-inline">MAC_UNLBL_STCADD</strong> and <strong class="source-inline">MAC_UNLBL_STCDEL</strong> events are triggered when a static label is added or removed. Static labeling means that if a packet is received or sent and it does not have a label, then this "default" static label is assigned.</li>
				<li class="calibre9"><strong class="source-inline">MAC_MAP_ADD</strong> and <strong class="source-inline">MAC_MAP_DEL</strong> events are triggered when a mapping between a labeling protocol (such as CIPSO) and its parameters against an LSM (SELinux) domain is added or removed from the configuration.</li>
				<li class="calibre9"><strong class="source-inline">MAC_CIPSOV4_ADD</strong> and <strong class="source-inline">MAC_CIPSOV4_DEL</strong> events are triggered when a CIPSO (IPv4) configuration is added or removed.</li>
			</ul>
			<h3 class="calibre12">Labeled IPsec events</h3>
			<p class="calibre3">Another <a id="_idIndexMarker154" class="pcalibre calibre6 pcalibre1"/>labeled network protocol that Linux supports <a id="_idIndexMarker155" class="pcalibre calibre6 pcalibre1"/>is <strong class="bold">labeled IPsec</strong>, where <strong class="bold">IPsec</strong> is short for <strong class="bold">Information Protocol Security</strong>. Through this, the SELinux context of the source process (which is <a id="_idIndexMarker156" class="pcalibre calibre6 pcalibre1"/>communicating over the IPsec tunnel toward a target resource) is known by the IPsec daemons at both ends of the tunnel. Furthermore, SELinux will contain rules about which domains can communicate over an IPsec tunnel <a id="_idIndexMarker157" class="pcalibre calibre6 pcalibre1"/>and which domains can communicate <a id="_idIndexMarker158" class="pcalibre calibre6 pcalibre1"/>with each other network-wise.</p>
			<p class="calibre3">The following audit events are related to IPsec:</p>
			<ul class="calibre8">
				<li class="calibre9"><strong class="source-inline">MAC_IPSEC_ADDSA</strong> and <strong class="source-inline">MAC_IPSEC_DELSA</strong> events are used when a security association is added or removed (new IPsec tunnels are defined or deleted).</li>
				<li class="calibre9"><strong class="source-inline">MAC_IPSEC_ADDSPD</strong> and <strong class="source-inline">MAC_IPSEC_DELSPD</strong> events are used when a security policy definition is added or removed. Security policies generally describe whether network packets need to be handled by IPsec and, if so, through which security association.</li>
				<li class="calibre9">A <strong class="source-inline">MAC_IPSEC_EVENT</strong> event is a generic event for IPsec audit messages.</li>
			</ul>
			<p class="calibre3">SELinux support for labeled IPsec is described further on in this book.</p>
			<h2 id="_idParaDest-61" class="calibre10"><a id="_idTextAnchor062" class="pcalibre calibre6 pcalibre1"/>Using ausearch</h2>
			<p class="calibre3">The <strong class="source-inline">ausearch</strong> command, part <a id="_idIndexMarker159" class="pcalibre calibre6 pcalibre1"/>of the Linux audit framework, is a frequently used command for querying audit events stored on the system. We already briefly covered it when taking a first look at an AVC denial, but only briefly mentioning it won't do it justice.</p>
			<p class="calibre3">With <strong class="source-inline">ausearch</strong>, we can search for events that originated during or after a selected time period. We used the <strong class="source-inline">-ts recent</strong> (time start) option in the past, which displays events that occurred during the past 10 minutes. The argument can also be a timestamp. Other supported shorthand values are listed as follows:</p>
			<ul class="calibre8">
				<li class="calibre9"><strong class="source-inline">today</strong>, meaning starting at 1 second past midnight on the current day</li>
				<li class="calibre9"><strong class="source-inline">yesterday</strong>, meaning starting at 1 second past midnight the previous day</li>
				<li class="calibre9"><strong class="source-inline">this-week</strong>, <strong class="source-inline">this-month</strong>, or <strong class="source-inline">this-year</strong>, meaning starting at 1 second past midnight on the first day of the current week, current month, or current year</li>
				<li class="calibre9"><strong class="source-inline">checkpoint</strong>, which uses the timestamp mentioned in a checkpoint file created in a previous run</li>
				<li class="calibre9"><strong class="source-inline">boot</strong>, which implies only events since the system booted should be shown</li>
				<li class="calibre9"><strong class="source-inline">week-ago</strong>, meaning starting at 1 second after midnight exactly 7 days ago</li>
			</ul>
			<p class="calibre3">The use of <strong class="source-inline">checkpoint</strong> is particularly useful when troubleshooting SELinux issues as it allows us to show denials (and other SELinux events) since the last invocation of the <strong class="source-inline">ausearch</strong> command. This is illustrated in the following code snippet:</p>
			<p class="source-code"># ausearch --checkpoint /root/ausearch-checkpoint.txt -ts checkpoint</p>
			<p class="calibre3">This allows administrators to perform minor tweaks and reproduce the problem and only see the events since then, instead of going through all events over and over again.</p>
			<p class="calibre3">By default, the <strong class="source-inline">ausearch</strong> command displays all events stored in the audit log. On busy systems, this can be very verbose and may result in unwanted events being displayed as well. Luckily, users can limit the type of events queried through the <strong class="source-inline">ausearch</strong> command.</p>
			<p class="calibre3">For SELinux <a id="_idIndexMarker160" class="pcalibre calibre6 pcalibre1"/>troubleshooting, using <strong class="source-inline">avc,user_avc,selinux_err</strong> limits the events nicely to those needed for the job, as illustrated in the following code snippet:</p>
			<p class="source-code"># ausearch -m avc,user_avc,selinux_err -ts recent</p>
			<p class="calibre3">If the numeric display of fields such as user IDs and timestamps is too confusing, then it is possible for <strong class="source-inline">ausearch</strong> to look up and translate user IDs to usernames and timestamps to formatted time fields. Add the <strong class="source-inline">-i</strong> option to <strong class="source-inline">ausearch</strong> to have it interpret these fields and display the interpreted values instead.</p>
			<p class="calibre3">In this section, we've seen how SELinux notifies the system about its actions through log events, and where these log events are stored. In the next section, we'll look at how to act upon these events.</p>
			<h1 id="_idParaDest-62" class="calibre5"><a id="_idTextAnchor063" class="pcalibre calibre6 pcalibre1"/>Getting help with denials</h1>
			<p class="calibre3">On some <a id="_idIndexMarker161" class="pcalibre calibre6 pcalibre1"/>distributions, additional support tools are available that help us identify the cause of a denial. These tools have some knowledge of common mistakes (for instance, setting the right context on files to allow the web server to read them). Other distributions require us to use our experience to make proper decisions, supporting us through the distribution mailing lists, bug tracking sites, and other cooperation <a id="_idIndexMarker162" class="pcalibre calibre6 pcalibre1"/>locationsâ€”for example, <strong class="bold">Internet Relay Chat </strong>(<strong class="bold">IRC</strong>).</p>
			<h2 id="_idParaDest-63" class="calibre10"><a id="_idTextAnchor064" class="pcalibre calibre6 pcalibre1"/>Troubleshooting with setroubleshoot</h2>
			<p class="calibre3">In CentOS (and <a id="_idIndexMarker163" class="pcalibre calibre6 pcalibre1"/>other <strong class="bold">Red Hat Enterprise Linux</strong> (<strong class="bold">RHEL</strong>)-related <a id="_idIndexMarker164" class="pcalibre calibre6 pcalibre1"/>distributions such as Fedora), additional tools are present that help us troubleshoot denials. The tools work together to catch a denial, look for a plausible solution, and inform the administrator about the denial and its suggested resolutions.</p>
			<p class="calibre3">When used on a graphical workstation, denials can even result in popups that ask the administrator to review them immediately. Install the <strong class="source-inline">setroubleshoot</strong> package to get this support. On servers without a graphical environment, administrators can see the information in the system logs or can even configure the system to send out SELinux denial messages via email. Install the <strong class="source-inline">setroubleshoot-server</strong> package to get this support.</p>
			<p class="calibre3">Under the hood, it is the audit daemon that triggers its audit event dispatcher application (<strong class="source-inline">audispd</strong>). This application supports plugins, something the SELinux folks gratefully implemented. They built an application called <strong class="source-inline">sedispatch</strong> that will act as a plugin for <strong class="source-inline">audispd</strong>. The <strong class="source-inline">sedispatch</strong> application checks whether the audit event is an SELinux denial and, if so, forwards the events to D-Bus. D-Bus then forwards the events to the <strong class="source-inline">setroubleshootd</strong> application (or launches the application if it isn't running yet), which analyzes the denial and prepares feedback for the administrator.</p>
			<p class="calibre3">When <a id="_idIndexMarker165" class="pcalibre calibre6 pcalibre1"/>running on a workstation, <strong class="source-inline">seapplet</strong> is triggered to show a popup on the administrator workstation. The administrator can then select <strong class="bold">Show</strong> to view more details. Administrators don't need a graphical user interface to be informed about SELinux issues, though. You can find analyzed feedback on the filesystem, and in the system logs you can read how to easily reach this information, as illustrated in the following code snippet:</p>
			<p class="source-code">Mar 22 11:40:35 ppubssa3ed setroubleshoot[1544]: SELinux is preventing /usr/sbin/nginx from name_bind access on the tcp_socket port 89. For complete SELinux messages run: sealert -l f2914dba-04ef-44ca-9a0b-0f5e62ec72e4</p>
			<p class="calibre3">We can look at a complete explanation through the <strong class="source-inline">sealert</strong> command (as mentioned in the log), as follows:</p>
			<p class="source-code"># sealert -l f2914dba-04ef-44ca-9a0b-0f5e62ec72e4</p>
			<p class="source-code">SELinux is preventing /usr/sbin/nginx from name_bind access on the tcp_socket port 89.</p>
			<p class="source-code">*****Â Â Plugin bind_ports (99.5 confidence) suggestsÂ Â Â ************************</p>
			<p class="source-code">If you want to allow /usr/sbin/nginx to bind to network port 89</p>
			<p class="source-code">Then you need to modify the port type.</p>
			<p class="source-code">Do</p>
			<p class="source-code"># semanage port -a -t PORT_TYPE -p tcp 89</p>
			<p class="source-code">Â Â Â Â where PORT_TYPE is one of the following: http_cache_port_t, http_port_t, jboss_management_port_t, jboss_messaging_port_t, ntop_port_t, puppet_port_t.</p>
			<p class="source-code">*****Â Â Plugin catchall (1.49 confidence) suggestsÂ Â Â **************************</p>
			<p class="source-code">...</p>
			<p class="calibre3">The <strong class="source-inline">sealert</strong> application is a command-line application that parses the information stored by the <strong class="source-inline">setroubleshoot</strong> daemon (in <strong class="source-inline">/var/lib/setroubleshoot</strong>).</p>
			<p class="calibre3">This will provide us with a set of options to resolve the denial. In the case of the Apache-related denial shown earlier, <strong class="source-inline">sealert</strong> gives us one option with a certain confidence score. Depending on the problem, this tool might show multiple options, each with its own confidence figure (that is, how certain <strong class="source-inline">sealert</strong> is that this is the right resolution).</p>
			<p class="calibre3">As we can see from this example, the <strong class="source-inline">setroubleshoot</strong> application itself uses plugins to analyze denials. These plugins (offered through the <strong class="source-inline">setroubleshoot-plugins</strong> package) look at a <a id="_idIndexMarker166" class="pcalibre calibre6 pcalibre1"/>denial to check whether they match a particular, well-known use case (for example, when to change an SELinux Boolean or when a target resource has a wrong context) and give feedback to <strong class="source-inline">setroubleshoot</strong> about how certain the plugin is so that this denial can be resolved through its recommended method.</p>
			<h2 id="_idParaDest-64" class="calibre10"><a id="_idTextAnchor065" class="pcalibre calibre6 pcalibre1"/>Sending emails when SELinux denials occur</h2>
			<p class="calibre3">Once a system <a id="_idIndexMarker167" class="pcalibre calibre6 pcalibre1"/>is fine-tuned and denials no longer occur regularly, administrators can opt to have <strong class="source-inline">setroubleshootd</strong> send emails whenever a new denial comes up. This truly brings SELinux's host intrusion detection/prevention capabilities on top, as administrators do not need to constantly watch their logs for information. However, keep in mind that this could lead to a sudden burst in emails, which might <a id="_idIndexMarker168" class="pcalibre calibre6 pcalibre1"/>result in <strong class="bold">Denial of Service</strong> (<strong class="bold">DoS</strong>)-like behavior, if many denials are triggered. Administrators should only implement this if their email infrastructure <a id="_idIndexMarker169" class="pcalibre calibre6 pcalibre1"/>has rate limiting or other <strong class="bold">Quality of Service</strong> (<strong class="bold">QoS</strong>) controls in place.</p>
			<p class="calibre3">Open <strong class="source-inline">/etc/setroubleshoot/setroubleshoot.conf</strong> in a text editor and locate the <strong class="source-inline">[email]</strong> section. Update the parameters to match the local mailing infrastructure, as follows:</p>
			<p class="source-code"># vi /etc/setroubleshoot/setroubleshoot.conf</p>
			<p class="source-code">[email]</p>
			<p class="source-code">recipients_filepath = /var/lib/setroubleshoot/email_alert_recipients</p>
			<p class="source-code">smtp_port = 25</p>
			<p class="source-code">smtp_host = localhost</p>
			<p class="source-code">from_address = selinux@infra.example.com</p>
			<p class="source-code">subject = [infra] SELinux Alert for host infra.example.com</p>
			<p class="calibre3">Next, edit the <strong class="source-inline">email_alert_recipients</strong> file (as referenced through the <strong class="source-inline">recipients_filepath</strong> variable), and add the email addresses that need to be notified when an SELinux alert comes up.</p>
			<p class="calibre3">Finally, restart the D-Bus daemon, as follows:</p>
			<p class="source-code"># systemctl restart dbus</p>
			<p class="calibre3">When <a id="_idIndexMarker170" class="pcalibre calibre6 pcalibre1"/>working on a non-systemd system, use the following command instead:</p>
			<p class="source-code"># service dbus restart</p>
			<p class="calibre3">The D-Bus restart is needed as D-Bus manages the <strong class="source-inline">setroubleshootd</strong> daemon.</p>
			<h2 id="_idParaDest-65" class="calibre10"><a id="_idTextAnchor066" class="pcalibre calibre6 pcalibre1"/>Using audit2why</h2>
			<p class="calibre3">If <strong class="source-inline">setroubleshoot</strong> and <strong class="source-inline">sealert</strong> are not available in the Linux distribution, we can still get some <a id="_idIndexMarker171" class="pcalibre calibre6 pcalibre1"/>information about a denial. Although it isn't as extensive as the plugins offered by <strong class="source-inline">setroubleshoot</strong>, the <strong class="source-inline">audit2why</strong> utility (which is short for <strong class="source-inline">audit2allow -w</strong>) does provide some feedback on a denial. Sadly, it isn't always right in its deduction.</p>
			<p class="calibre3">Let's try it out against the same denial for which we used <strong class="source-inline">sealert</strong>, as follows:</p>
			<p class="source-code"># ausearch -m avc -ts recent | audit2why</p>
			<p class="source-code">type=AVC msg=audit(1584880436.644:385): avc:Â Â deniedÂ Â { name_bind } forÂ Â pid=5119 comm="nginx" src=89 scontext=system_u:system_r:httpd_t:s0 tcontext=system_u:object_r:reserved_port_t:s0 tclass=tcp_socket permissive=0</p>
			<p class="source-code">Â Â Was caused by:</p>
			<p class="source-code">Â Â Â Â Missing type enforcement (TE) allow rule.</p>
			<p class="source-code">Â Â Â Â You can use audit2allow to generate a loadable module to allow this access.</p>
			<p class="calibre3">The <strong class="source-inline">audit2why</strong> utility here didn't consider that the context of the target location was wrong, and it suggests that the policy be updated to allow the web server to bind to the <strong class="source-inline">unreserved_port_t</strong> type, unlike the information provided by <strong class="source-inline">setroubleshoot</strong>, which was more accurate, recommending that the target port be relabeled instead.</p>
			<p class="calibre3">As the output of the command mentions, another tool exists called <strong class="source-inline">audit2allow</strong>, which can convert a denial into an SELinux policy. We will cover <strong class="source-inline">audit2allow</strong> in <a href="B16276_12_Final_VK.xhtml#_idTextAnchor312" class="pcalibre calibre6 pcalibre1"><em class="italic">Chapter 12</em></a>, <em class="italic">Tuning SELinux Policies</em>.</p>
			<h2 id="_idParaDest-66" class="calibre10"><a id="_idTextAnchor067" class="pcalibre calibre6 pcalibre1"/>Interacting with systemd-journal</h2>
			<p class="calibre3">Alongside <a id="_idIndexMarker172" class="pcalibre calibre6 pcalibre1"/>the Linux audit system, which is used for most SELinux logging and events, we can also gather information through other logging systems. systemd's journal, for instance, captures SELinux context information with the events and allows administrators to use this information while querying the journal.</p>
			<p class="calibre3">For instance, to see the events in <strong class="source-inline">systemd-journal</strong> that are generated by an application associated with the <strong class="source-inline">system_u:system_r:sssd_t:s0</strong> context, the following command can be used:</p>
			<p class="source-code"># journalctl _SELINUX_CONTEXT="system_u:system_r:sssd_t:s0"</p>
			<p class="source-code">-- Logs begin at Sun 2020-03-22 10:43:48 UTC, end at Sun 2020-03-22 12:40:12 UTC. --</p>
			<p class="source-code">Mar 22 10:43:51 ppubssa3ed sssd[545]: Starting up</p>
			<p class="source-code">Mar 22 10:43:51 ppubssa3ed sssd[be[implicit_files]][623]: Starting up</p>
			<p class="source-code">Mar 22 10:43:51 ppubssa3ed sssd[nss][630]: Starting up</p>
			<p class="calibre3">Because <strong class="source-inline">systemd-journal</strong> adds the SELinux context of the originating application, it is harder for malicious applications to generate fake events. Whereas regular system loggers just capture <a id="_idIndexMarker173" class="pcalibre calibre6 pcalibre1"/>string events, <strong class="source-inline">systemd-journal</strong> retrieves the SELinux context from the system. Using the SELinux context, it is easy to group events across different but strongly related applications and have a higher guarantee that events come from a particular application.</p>
			<p class="calibre3">When the <strong class="source-inline">bash-completion</strong> package is installed, we can even use it to see which SELinux contexts are present in the <strong class="source-inline">systemd-journal</strong> logs, which makes querying the journal logs much easier, as follows:</p>
			<p class="source-code"># journalctl _SELINUX_CONTEXT=&lt;tab&gt;&lt;tab&gt;</p>
			<p class="source-code">kernel</p>
			<p class="source-code">system_u:system_r:auditd_t:s0</p>
			<p class="source-code">system_u:system_r:chronyd_t:s0</p>
			<p class="source-code">...</p>
			<p class="calibre3">To find messages related to nginx, use the embedded <strong class="source-inline">grep</strong> filter, as follows:</p>
			<p class="source-code"># journalctl -g nginx</p>
			<p class="source-code">-- Logs begin at Sun 2020-03-22 10:43:48 UTC, end at Sun 2020-03-22 12:52:26 UTC. --</p>
			<p class="source-code">Mar 22 11:40:32 ppubssa3ed systemd[1]: Starting The nginx HTTP and reverse proxy server...</p>
			<p class="source-code">Mar 22 11:40:32 ppubssa3ed nginx[1538]: nginx: the configuration file /etc/nginx/nginx.conf syntax is ok</p>
			<p class="source-code">Mar 22 11:40:32 ppubssa3ed nginx[1538]: nginx: [emerg] bind() to 0.0.0.0:89 failed (13: Permission denied)</p>
			<p class="source-code">...</p>
			<p class="source-code">Mar 22 11:40:35 ppubssa3ed setroubleshoot[1544]: SELinux is preventing /usr/sbin/nginx from name_bind access on the tcp_socket port 89. For complete SELinux messages run: sealert -l f2914dba-04ef-44ca-9a0b-0f5e62ec72e4</p>
			<p class="calibre3">The benefit of the embedded <strong class="source-inline">grep</strong> filter is that <strong class="source-inline">journalctl</strong> will still show the multiline messages, whereas <a id="_idIndexMarker174" class="pcalibre calibre6 pcalibre1"/>actually redirecting the <strong class="source-inline">journalctl</strong> output through <strong class="source-inline">grep</strong> would only show the individual lines that match the expression.</p>
			<h2 id="_idParaDest-67" class="calibre10"><a id="_idTextAnchor068" class="pcalibre calibre6 pcalibre1"/>Using common sense</h2>
			<p class="calibre3">Common sense is not easy to document, but reading a denial often leads to the right solution when <a id="_idIndexMarker175" class="pcalibre calibre6 pcalibre1"/>we have some experience with file labels (and what they are used for). If we get a denial about a web server failing to read its files, and the context of the file is (for instance) <strong class="source-inline">user_home_t</strong>, then that should ring a bell. End user home files, for instance, use the <strong class="source-inline">user_home_t</strong> context, which is not suitable for system files that the web server reads.</p>
			<p class="calibre3">One way to make sure that the context of the target resource is correct is to verify it with <strong class="source-inline">matchpathcon</strong>. This utility returns the context as it should be according to the SELinux policy, as follows:</p>
			<p class="source-code">$ matchpathcon /srv/www/html/index.html</p>
			<p class="source-code">/srv/www/html/index.html	system_u:object_r:httpd_sys_content_t:s0</p>
			<p class="calibre3">Performing this for denials related to files and directories might help in finding a proper solution quickly.</p>
			<p class="calibre3">Furthermore, many domains have specific manual pages that inform the reader about types commonly used for each domain, as well as how to deal with the domain in more detail (for example, the available booleans, common mistakes made, and so on). These manual pages start with the main service and are suffixed with <strong class="source-inline">_selinux</strong>, as illustrated here:</p>
			<p class="source-code">$ man ftpd_selinux</p>
			<p class="calibre3">In most <a id="_idIndexMarker176" class="pcalibre calibre6 pcalibre1"/>cases, the approach to handling denials can be best described as follows:</p>
			<ul class="calibre8">
				<li class="calibre9">Is the target resource label (such as the file label) the right one? Verify this with <strong class="source-inline">matchpathcon</strong>, or compare with labels of working (accessible) resources.</li>
				<li class="calibre9">Is the source label (the domain) the expected one? An SSH daemon should run in the <strong class="source-inline">sshd_t</strong> domain, not the <strong class="source-inline">init_t</strong> domain. If this is not the case, make sure that the labels of the application itself (such as its executable binary) are correct (again, use <strong class="source-inline">matchpathcon</strong> for this).</li>
				<li class="calibre9">Is the denial one that might be covered by an SELinux boolean? In that case, the policy might already have the appropriate rules in place, only requiring a change in an SELinux boolean value. <strong class="source-inline">setroubleshootd</strong> will report this if it is the case. Usually, the manual page of the domain (such as <strong class="source-inline">httpd_selinux</strong>) will also cover the available SELinux Booleans. We explain how to query and adjust SELinux Booleans in <a href="B16276_12_Final_VK.xhtml#_idTextAnchor312" class="pcalibre calibre6 pcalibre1"><em class="italic">Chapter 12</em></a><em class="italic">, Tuning SELinux Policies</em>.</li>
			</ul>
			<p class="calibre3">Changing file labels will be discussed in <a href="B16276_04_Final_VK.xhtml#_idTextAnchor095" class="pcalibre calibre6 pcalibre1"><em class="italic">Chapter 4</em></a><em class="italic">, Using File Contexts and Process Domains</em>.</p>
			<p class="calibre3">To close off this section, common sense will be your most prolific approach to managing SELinux denials, but the aforementioned tools will be of assistance to begin with.</p>
			<h1 id="_idParaDest-68" class="calibre5"><a id="_idTextAnchor069" class="pcalibre calibre6 pcalibre1"/>Summary</h1>
			<p class="calibre3">In this chapter, we saw how to enable and disable SELinux, both on a complete system level as well as a per-service level using various methods: kernel boot options, an SELinux configuration file, or plain commands. One such command is <strong class="source-inline">semanage permissive</strong>, which can disable SELinux protections for a single service.</p>
			<p class="calibre3">Next, we saw where SELinux logs its events and how to interpret them, which is one of the most common tasks an administrator has to undertake when dealing with SELinux. To assist us with this interpretation, we can use tools such as <strong class="source-inline">setroubleshoot</strong>, <strong class="source-inline">sealert</strong>, and <strong class="source-inline">audit2why</strong>. We also touched upon several utilities related to Linux auditing to help us sift through various events.</p>
			<p class="calibre3">In the next chapter, we will look at the first administrative task on SELinux systems: managing user accounts, their associated SELinux roles, and security clearances for the resources on the system.</p>
			<h1 id="_idParaDest-69" class="calibre5"><a id="_idTextAnchor070" class="pcalibre calibre6 pcalibre1"/>Questions</h1>
			<ol class="calibre18">
				<li value="1" class="calibre9">What should administrators try before disabling SELinux?</li>
				<li class="calibre9">Where can administrators find SELinux logs by default?</li>
				<li class="calibre9">How do we know whether an application is SELinux-aware?</li>
				<li class="calibre9">What is the purpose of the AVC?</li>
				<li class="calibre9">Are AVC events the only type of events for SELinux?</li>
			</ol>
		</div>
	</div></body></html>