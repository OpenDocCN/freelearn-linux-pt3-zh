<html><head></head><body><div id="sbo-rt-content" class="calibre1"><div id="_idContainer018" class="calibre2">
			<p class="calibre3"><a id="_idTextAnchor094" class="pcalibre calibre6 pcalibre1"/></p>
			<h1 id="_idParaDest-93" class="calibre5"><em class="italic"><a id="_idTextAnchor095" class="pcalibre calibre6 pcalibre1"/>Chapter 4</em>: Using File Contexts and Process Domains</h1>
			<p class="calibre3">SELinux-enabled systems are strongly dependent on the notion of contexts (on resources) and domains (on processes). The access controls that SELinux enforces use these contexts to identify the resources, and define the enforcement rules within the policy. Because of its inherent reliance on these contexts, this chapter will go into detail on file contexts, context definitions, and process domains.</p>
			<p class="calibre3">We will work with the file contexts and learn where they are stored so that you can easily adjust your system to work optimally with SELinux. We assign contexts to resources both temporarily (for testing purposes) and permanently, and learn how these contexts are used to automatically deduce the process domain. Once we know how to obtain process domain information, we will query the SELinux policy to learn about the current access controls.</p>
			<p class="calibre3">In this chapter, we're going to cover the following main topics:</p>
			<ul class="calibre8">
				<li class="calibre9">Introduction to SELinux file contexts</li>
				<li class="calibre9">Keeping or ignoring contexts</li>
				<li class="calibre9">SELinux file context expressions</li>
				<li class="calibre9">Modifying file contexts</li>
				<li class="calibre9">The context of a process</li>
				<li class="calibre9">Limiting the scope of transitions</li>
				<li class="calibre9">Types, permissions, and constraints</li>
			</ul>
			<h1 id="_idParaDest-94" class="calibre5"><a id="_idTextAnchor096" class="pcalibre calibre6 pcalibre1"/>Technical requirements</h1>
			<p class="calibre3">Check out the following video to see the Code in Action: <a href="https://bit.ly/3m3JzkP" class="pcalibre calibre6 pcalibre1">https://bit.ly/3m3JzkP</a></p>
			<h1 id="_idParaDest-95" class="calibre5"><a id="_idTextAnchor097" class="pcalibre calibre6 pcalibre1"/>Introduction to SELinux file contexts</h1>
			<p class="calibre3">SELinux file contexts <a id="_idIndexMarker219" class="pcalibre calibre6 pcalibre1"/>are the most important configuration that a system administrator will have to work with when working with SELinux on the system. Contexts for files are generally identified through a label that is assigned to the file. Mislabeled files are a constant source of headaches for sysadmins, and most common SELinux issues are resolved by correcting the SELinux context.</p>
			<p class="calibre3">Knowing where and how SELinux contexts are used is key to understanding and resolving SELinux related issues. The following diagram shows how contexts are applied on regular Linux resources, and how the LSM subsystem uses these contexts for decision making:</p>
			<div class="calibre13">
				<div id="_idContainer016" class="img---figure">
					<img src="Images/B16276_04_001.jpg" alt="Figure 4.1 – Distinction between contexts and regular Linux info " class="calibre21"/>
				</div>
			</div>
			<p class="figure-caption">Figure 4.1 – Distinction between contexts and regular Linux info</p>
			<p class="calibre3">Let's consider a web-based deployment as an example: DokuWiki. This is a popular PHP wiki that uses files rather than a database as its backend system, and is easy to install and manage. As a web hosting platform, we will use nginx.</p>
			<h2 id="_idParaDest-96" class="calibre10"><a id="_idTextAnchor098" class="pcalibre calibre6 pcalibre1"/>Getting context information</h2>
			<p class="calibre3">Let's <a id="_idIndexMarker220" class="pcalibre calibre6 pcalibre1"/>assume that the DokuWiki application will be hosted at <strong class="source-inline">/srv/web/localhost/htdocs/dokuwiki</strong> and that it will store its wiki pages (user content) in the <strong class="source-inline">data/</strong> subdirectory. We start by downloading the latest DokuWiki tarball from the project site, <a href="http://download.dokuwiki.org" class="pcalibre calibre6 pcalibre1">http://download.dokuwiki.org</a>, and extract it to this location:</p>
			<p class="source-code"># mkdir -p /srv/web/localhost/htdocs/</p>
			<p class="source-code"># tar -C /srv/web/localhost/htdocs/ -xvf dokuwiki.tgz</p>
			<p class="source-code"># chown -R nginx:nginx /srv/web/localhost/htdocs/dokuwiki</p>
			<p class="calibre3">While distributions might have prepackaged DokuWiki installations available, we will use the manual installation approach to show the various file context-related actions in this chapter.</p>
			<p class="calibre3">The contexts of files can easily be acquired using the <strong class="source-inline">-Z</strong> option of the <strong class="source-inline">ls</strong> command. Most utilities <a id="_idIndexMarker221" class="pcalibre calibre6 pcalibre1"/>that can provide feedback on contexts will try to do so using the <strong class="source-inline">-Z</strong> option, as we saw with the <strong class="source-inline">id</strong> utility in <a href="B16276_01_Final_VK.xhtml#_idTextAnchor018" class="pcalibre calibre6 pcalibre1"><em class="italic">Chapter 1</em></a>, <em class="italic">Fundamental SELinux Concepts</em>, and <a href="B16276_03_Final_VK.xhtml#_idTextAnchor071" class="pcalibre calibre6 pcalibre1"><em class="italic">Chapter 3</em></a>, <em class="italic">Managing User Logins</em>.</p>
			<p class="calibre3">Let's look at the current context of the <strong class="source-inline">dokuwiki</strong> directory itself:</p>
			<p class="source-code"># ls -dZ /srv/web/localhost/htdocs/dokuwiki</p>
			<p class="source-code">undefined_u:object_r:var_t:s0 /srv/web/localhost/htdocs/dokuwiki</p>
			<p class="calibre3">The context displayed here is <strong class="source-inline">var_t</strong>. In the <em class="italic">Keeping or ignoring contexts</em> section, we will change this to the correct context (as <strong class="source-inline">var_t</strong> is too generic and not meant for hosting web content).</p>
			<p class="calibre3">File and directory contexts are stored in the filesystem as extended attributes when the filesystem <a id="_idIndexMarker222" class="pcalibre calibre6 pcalibre1"/>supports this. An <strong class="bold">extended attribute</strong> (often abbreviated to <strong class="bold">xattr</strong>) is a key/value combination associated with a resource's inode (an information block that represents a file, directory, or symbolic link on a filesystem). Each resource can have multiple extended attributes, but only one value per unique key. When we talk about assigning a <strong class="bold">label</strong> to a file or directory (or relabeling a file), then we imply setting or updating this extended attribute, as it is the label that SELinux will use to obtain the SELinux context for the file.</p>
			<p class="callout-heading">Important note</p>
			<p class="callout">Filesystems that do not support extended attributes can still be used on SELinux-enabled systems. However, the entire filesystem (including all its files and directories) will then be shown with a single context, and differentiation across resources on the filesystem is not possible. We explain how to define file contexts on these filesystems in the <em class="italic">Using mount options to set SELinux contexts</em> subsection in this chapter.</p>
			<p class="calibre3">By convention, extended attributes on Linux use the following syntax:</p>
			<p class="source-code">&lt;namespace&gt;.&lt;attribute&gt;=&lt;value&gt;</p>
			<p class="calibre3">The namespace of an extended attribute allows for additional access controls or features. Of the currently supported extended attribute namespaces (<strong class="source-inline">security</strong>, <strong class="source-inline">system</strong>, <strong class="source-inline">trusted</strong>, and <strong class="source-inline">user</strong>), the <strong class="source-inline">security</strong> namespace enforces specific restrictions on manipulating the attribute: if no security module is loaded (for instance, SELinux is not enabled), then only processes with the <strong class="source-inline">CAP_SYS_ADMIN</strong> capability (basically root or similarly privileged processes) can modify this parameter.</p>
			<p class="calibre3">We can query the existing extended attributes using the <strong class="source-inline">getfattr</strong> application, as shown in the following example:</p>
			<p class="source-code">$ getfattr -m . -d dokuwiki</p>
			<p class="source-code"># file: dokuwiki</p>
			<p class="source-code">security.selinux="unconfined_u:object_r:var_t:s0"</p>
			<p class="calibre3">As we can see, the <strong class="source-inline">security.selinux</strong> extended attribute hosts the SELinux context. This ensures that non-administrative users cannot alter the SELinux context of a file when SELinux is <a id="_idIndexMarker223" class="pcalibre calibre6 pcalibre1"/>disabled and that the SELinux policy controls who can manipulate contexts when SELinux is enabled.</p>
			<p class="calibre3">The <strong class="source-inline">stat</strong> application can also be used to show SELinux contexts:</p>
			<p class="source-code">$ stat dokuwiki</p>
			<p class="source-code">  File: dokuwiki</p>
			<p class="source-code">  Size: 211		Blocks: 0		IO Block: 4096	</p>
			<p class="source-code">directory</p>
			<p class="source-code">Device: fd01h/64769d	Inode: 8512888	Links: 8</p>
			<p class="source-code">Access: (0755/drwxr-xr-x)	Uid: (	0/	root) Gid: (	0/	root)</p>
			<p class="source-code">Context: unconfined_u:object_r:var_t:s0</p>
			<p class="source-code">...</p>
			<p class="calibre3">Getting context information from a file or directory should be as common to an administrator as getting regular access control information (the read (<strong class="source-inline">r</strong>), write (<strong class="source-inline">w</strong>), and execute (<strong class="source-inline">x</strong>) flags).</p>
			<h2 id="_idParaDest-97" class="calibre10"><a id="_idTextAnchor099" class="pcalibre calibre6 pcalibre1"/>Interpreting SELinux context types</h2>
			<p class="calibre3">After using <a id="_idIndexMarker224" class="pcalibre calibre6 pcalibre1"/>SELinux for a while, the motive behind using file labels to assign an SELinux context to the file becomes somewhat clearer. SELinux contexts are named after their purpose, allowing administrators to more easily see whether a context is correctly assigned.</p>
			<p class="calibre3">Consider the context of a user file in its home directory (<strong class="source-inline">user_home_t</strong>), a directory in <strong class="source-inline">/tmp</strong> for a Java application (<strong class="source-inline">java_tmp_t</strong>), or a socket of <strong class="source-inline">rpcbind</strong> (<strong class="source-inline">rpcbind_var_run_t</strong>). All these files or directories have considerably different purposes on the filesystem, and this reflects itself in the assigned contexts.</p>
			<p class="calibre3">Policy writers will always try to name the context consistently, making it easier for us to understand the purpose of the file, but also to make the policy almost self-explanatory so that administrators can understand the purpose of the policy without additional documentation needs.</p>
			<p class="calibre3">For the regular filesystem, for instance, files are labeled with a context resembling their main location as they have similar security properties. For example, we find binaries in the <strong class="source-inline">/bin</strong> folder (and <strong class="source-inline">/usr/bin</strong>) to be associated with the <strong class="source-inline">bin_t</strong> type, boot files in <strong class="source-inline">/boot</strong> associated with <strong class="source-inline">boot_t</strong>, and generic system resources in <strong class="source-inline">/usr</strong> associated with <strong class="source-inline">usr_t</strong>.</p>
			<p class="calibre3">We can <a id="_idIndexMarker225" class="pcalibre calibre6 pcalibre1"/>also find more application-specific contexts. For instance, for the PostgreSQL database server, we have the following:</p>
			<ul class="calibre8">
				<li class="calibre9">The <strong class="source-inline">postgresql_t</strong> context is meant for the application itself (process type or domain).</li>
				<li class="calibre9">The <strong class="source-inline">postgresql_port_t</strong> context is meant for the TCP port on which the PostgreSQL daemon listens.</li>
				<li class="calibre9">The <strong class="source-inline">postgresql_server_packet_t</strong> and <strong class="source-inline">postgresql_client_packet_t</strong> contexts are types associated with network packets received (in case of the <strong class="source-inline">postgresql_server_packet_t</strong> type) or sent to the PostgreSQL port.</li>
				<li class="calibre9">The <strong class="source-inline">postgresql_exec_t</strong> type is assigned to the <strong class="source-inline">postgres</strong> binary.</li>
				<li class="calibre9">The various <strong class="source-inline">postgresql_*_t</strong> types for specific filesystem locations related to the daemon, such as <strong class="source-inline">postgresql_var_run_t</strong> (to apply to resources in <strong class="source-inline">/var/run</strong>), <strong class="source-inline">postgresql_etc_t</strong> (to apply to resources in <strong class="source-inline">/etc</strong>), <strong class="source-inline">postgresql_log_t</strong> (to apply to resources in <strong class="source-inline">/var/log</strong>), and <strong class="source-inline">postgresql_tmp_t</strong> (to apply to resources in <strong class="source-inline">/tmp</strong>).</li>
				<li class="calibre9">The <strong class="source-inline">mysqld_db_t</strong> type for the database files themselves.</li>
			</ul>
			<p class="calibre3">Based on the context of a file or resource, administrators can easily detect anomalies in the system setup. An example of an anomaly is when we move a file from the user's home directory to a web server location. When this occurs, the file retains the <strong class="source-inline">user_home_t</strong> context as extended attributes are moved with it. As the web server process isn't allowed to access <strong class="source-inline">user_home_t</strong> by default, it will not be able to serve this file to its users.</p>
			<p class="calibre3">Let's see how to properly set contexts during such copy or move operations.</p>
			<h1 id="_idParaDest-98" class="calibre5"><a id="_idTextAnchor100" class="pcalibre calibre6 pcalibre1"/>Keeping or ignoring contexts</h1>
			<p class="calibre3">Now that <a id="_idIndexMarker226" class="pcalibre calibre6 pcalibre1"/>we are aware that file contexts are stored as extended attributes, how do we ensure that files receive the correct label when they are written or modified? To set an SELinux context on a filesystem resource, a few guidelines exist, ranging from inheritance rules to explicit commands.</p>
			<h2 id="_idParaDest-99" class="calibre10"><a id="_idTextAnchor101" class="pcalibre calibre6 pcalibre1"/>Inheriting the default contexts</h2>
			<p class="calibre3">By default, the SELinux <a id="_idIndexMarker227" class="pcalibre calibre6 pcalibre1"/>security subsystem uses context inheritance to identify which context should be assigned to a file (or directory, socket, and so on) when it is created. A file created in a directory with a <strong class="source-inline">var_t</strong> context will be assigned the <strong class="source-inline">var_t</strong> context as well. This means that the file inherits the context from the parent directory and not from the context of the executing process.</p>
			<p class="calibre3">There are a few exceptions to this though:</p>
			<ul class="calibre8">
				<li class="calibre9">SELinux-aware applications can force the context of a file to be different (assuming the SELinux policy allows it, of course). As this is within the software code itself, this behavior cannot be generally configured.</li>
				<li class="calibre9">An application called <strong class="source-inline">restorecond</strong> can be used that enforces contexts on various paths/files based on SELinux's context rules. We will cover these rules and the <strong class="source-inline">restorecond</strong> application in the <em class="italic">SELinux file context expressions</em> and <em class="italic">Modifying file contexts</em> sections, respectively.</li>
				<li class="calibre9">The SELinux policy allows for transition rules that consider the context of the process creating new files or directories, as well as the name of the file the process is creating.</li>
			</ul>
			<p class="calibre3">It is these transition rules we will cover next.</p>
			<h2 id="_idParaDest-100" class="calibre10"><a id="_idTextAnchor102" class="pcalibre calibre6 pcalibre1"/>Querying transition rules</h2>
			<p class="calibre3">Type transition <a id="_idIndexMarker228" class="pcalibre calibre6 pcalibre1"/>rules are policy rules that force the use of a different type upon certain conditions. For file contexts, such a type transition rule can be as follows: if a process running in the <strong class="source-inline">httpd_t</strong> domain creates a file in a directory labeled with the <strong class="source-inline">var_log_t</strong> SELinux type, then the type identifier of the file becomes <strong class="source-inline">httpd_log_t</strong>.</p>
			<p class="calibre3">Basically, this rule assigns the <strong class="source-inline">httpd_log_t</strong> web server log context to any file placed in a log directory by web servers, rather than the default <strong class="source-inline">var_log_t</strong>, which would be the case when standard inheritance was used.</p>
			<p class="calibre3">We can query these type transition rules using <strong class="source-inline">sesearch</strong>. The <strong class="source-inline">sesearch</strong> application is one of the most important tools available to query the current SELinux policy. For the previous example, we need the (source) domain and the (target) context of the directory: <strong class="source-inline">httpd_t</strong> and <strong class="source-inline">var_log_t</strong>. In the following example, we use <strong class="source-inline">sesearch</strong> to find the type transition declaration related to the <strong class="source-inline">httpd_t</strong> domain toward the <strong class="source-inline">var_log_t</strong> context:</p>
			<p class="source-code">$ sesearch -T -s httpd_t -t var_log_t</p>
			<p class="source-code">type_transition httpd_t var_log_t:file httpd_log_t;</p>
			<p class="calibre3">The <strong class="source-inline">type_transition</strong> line is an SELinux policy rule, which maps perfectly to the description. Let's look at another set of type transition rules for the <strong class="source-inline">tmp_t</strong> type (assigned to the directory used for temporary files, such as <strong class="source-inline">/tmp</strong> and <strong class="source-inline">/var/tmp</strong>):</p>
			<p class="source-code">$ sesearch -T -s httpd_t -t tmp_t</p>
			<p class="source-code">type_transition httpd_t tmp_t:dir httpd_tmp_t;</p>
			<p class="source-code">type_transition httpd_t tmp_t:file httpd_tmp_t;</p>
			<p class="source-code">type_transition httpd_t tmp_t:file krb5_host_rcache_t HTTP_23;</p>
			<p class="source-code">type_transition httpd_t tmp_t:file krb5_host_rcache_t HTTP_48;</p>
			<p class="source-code">type_transition httpd_t tmp_t:lnk_file httpd_tmp_t;</p>
			<p class="source-code">type_transition httpd_t tmp_t:sock_file httpd_tmp_t;</p>
			<p class="calibre3">The policy tells us that, if a file, directory, symbolic link, or socket is created in a directory labeled <strong class="source-inline">tmp_t</strong>, then <a id="_idIndexMarker229" class="pcalibre calibre6 pcalibre1"/>this newly created resource gets the <strong class="source-inline">httpd_tmp_t</strong> context assigned (and thus not the default, inherited <strong class="source-inline">tmp_t</strong> one). Alongside these rules, it also contains two named file transitions, which are more flexible transition rules.</p>
			<p class="calibre3">With <strong class="bold">named file transitions</strong>, the policy can consider the name of the file (or directory) created to <a id="_idIndexMarker230" class="pcalibre calibre6 pcalibre1"/>select a more appropriate context. In the previous example, if a file named <strong class="source-inline">HTTP_23</strong> or <strong class="source-inline">HTTP_48</strong> is created in a directory labeled <strong class="source-inline">tmp_t</strong>, then it does not get the <strong class="source-inline">httpd_tmp_t</strong> context assigned (as would be implied by the regular type transition rules), but the <strong class="source-inline">krb5_host_rcache_t</strong> type (used for Kerberos implementations) instead.</p>
			<p class="calibre3">Type transitions not only give us insight into what labels (and thus also SELinux contexts) are going to be assigned, but also give us some clues as to which types are related to a particular domain. In the web server example, we found out by querying the policy that its log files are most likely labeled <strong class="source-inline">httpd_log_t</strong>, and its temporary files <strong class="source-inline">httpd_tmp_t</strong>.</p>
			<h2 id="_idParaDest-101" class="calibre10"><a id="_idTextAnchor103" class="pcalibre calibre6 pcalibre1"/>Copying and moving files</h2>
			<p class="calibre3">File contexts <a id="_idIndexMarker231" class="pcalibre calibre6 pcalibre1"/>can also be transferred together with the file itself <a id="_idIndexMarker232" class="pcalibre calibre6 pcalibre1"/>during copy or move operations. By default, Linux will do the following:</p>
			<ul class="calibre8">
				<li class="calibre9">Retain the file context in case of a move (<strong class="source-inline">mv</strong>) operation on the same filesystem (as this operation does not touch extended attributes, but merely adjusts the metadata of the file).</li>
				<li class="calibre9">Ignore the current file context in case of a move operation across a filesystem boundary, as this creates a new file, including content and extended attributes. Instead, it uses the inheritance (or file transition rules) to define the target context.</li>
				<li class="calibre9">Ignore the file context in case of a copy (<strong class="source-inline">cp</strong>) operation, instead using the inheritance (or file transition rules) to define the target context.</li>
			</ul>
			<p class="calibre3">Luckily, this is just default behavior (based on the extended attribute support of these utilities) that can be manipulated freely.</p>
			<p class="calibre3">We can use the <strong class="source-inline">-Z</strong> option to tell <strong class="source-inline">mv</strong> that the context of the file should be set to the default type associated with the target location. For instance, in the next example, two files are moved from <a id="_idIndexMarker233" class="pcalibre calibre6 pcalibre1"/>a user's home directory to the <strong class="source-inline">/srv</strong> directory. The <a id="_idIndexMarker234" class="pcalibre calibre6 pcalibre1"/>first example will retain its file context (<strong class="source-inline">user_home_t</strong> or <strong class="source-inline">admin_home_t</strong>), while the second one will receive the type associated with user files placed in <strong class="source-inline">/srv</strong> (<strong class="source-inline">var_t</strong>):</p>
			<p class="source-code"># touch test1 test2</p>
			<p class="source-code"># mv test1 /srv</p>
			<p class="source-code"># mv -Z test2 /srv</p>
			<p class="source-code"># ls -Z /srv/test*</p>
			<p class="source-code">staff_u:object_r:admin_home_t:s0 /srv/test1</p>
			<p class="source-code">staff_u:object_r:var_t:s0 /srv/test2</p>
			<p class="calibre3">Similarly, we can tell the <strong class="source-inline">cp</strong> command through the <strong class="source-inline">--preserve=context</strong> option to preserve the SELinux context while copying files. Using the same example, we now get the following:</p>
			<p class="source-code"># cp test1 /srv</p>
			<p class="source-code"># cp --preserve=context test2 /srv</p>
			<p class="source-code"># ls -Z /srv/test*</p>
			<p class="source-code">staff_u:object_r:var_t:s0 /srv/test1</p>
			<p class="source-code">staff_u:object_r:admin_home_t:s0 /srv/test2</p>
			<p class="calibre3">Most of the utilities provided through the <strong class="source-inline">coreutils</strong> package support the <strong class="source-inline">-Z</strong> option: <strong class="source-inline">mkdir</strong> (to create a directory), <strong class="source-inline">mknod</strong> (to create a device file), <strong class="source-inline">mkfifo</strong> (to create a named pipe), and so on.</p>
			<p class="callout-heading">Important note</p>
			<p class="callout">If the <strong class="source-inline">mv</strong> command returns <strong class="source-inline">failed to set the security context</strong> when using the <strong class="source-inline">-Z</strong> option, then it is very likely that the location either does not have a valid context associated with it, or that the filesystem does not support SELinux labels. The former is for instances applicable when moving files to <strong class="source-inline">/tmp</strong> as the CentOS SELinux policy does not have any default context set for files and directories inside <strong class="source-inline">/tmp</strong>. Newly created resources always need to have their own affiliated labels applied (such as <strong class="source-inline">user_tmp_t</strong>).</p>
			<p class="calibre3">Even more so, many of these utilities allow the user to explicitly provide a context through the <strong class="source-inline">--context</strong> option. For instance, to create a directory, <strong class="source-inline">/srv/foo</strong>, with the context <strong class="source-inline">user_home_t</strong>, using <strong class="source-inline">mkdir</strong> by default would not work, as the target context would be set to <strong class="source-inline">var_t</strong>. With the <strong class="source-inline">--context</strong> option, we can tell the utility to set a specific context:</p>
			<p class="source-code"># mkdir --context=user_u:object_r:user_home_t:s0 /srv/foo</p>
			<p class="source-code"># ls -dZ /srv/foo</p>
			<p class="source-code">user_u:object_r:user_home_t:s0 /srv/foo</p>
			<p class="calibre3">For other <a id="_idIndexMarker235" class="pcalibre calibre6 pcalibre1"/>utilities, it is best to consult the manual page and see <a id="_idIndexMarker236" class="pcalibre calibre6 pcalibre1"/>how the utility deals with extended attributes. For instance, the <strong class="source-inline">rsync</strong> command can preserve the extended attributes by using the <strong class="source-inline">-X</strong> or <strong class="source-inline">--xattrs</strong> option.</p>
			<h2 id="_idParaDest-102" class="calibre10"><a id="_idTextAnchor104" class="pcalibre calibre6 pcalibre1"/>Temporarily changing file contexts</h2>
			<p class="calibre3">We can <a id="_idIndexMarker237" class="pcalibre calibre6 pcalibre1"/>use the <strong class="source-inline">chcon</strong> tool to update the context of the file (or files) directly. In our previous example, we noticed the <strong class="source-inline">var_t</strong> label on the DokuWiki files. This is a generic type for variable data and is not the right context for web content. We can use <strong class="source-inline">chcon</strong> to put the <strong class="source-inline">httpd_sys_content_t</strong> label on these files, which would allow web servers to have read access on these resources:</p>
			<p class="source-code"># chcon -R -t httpd_sys_content_t /srv/web</p>
			<p class="calibre3">Another feature that <strong class="source-inline">chcon</strong> offers is to tell it to label a file or location with the same context as a different file. In the next example, we use <strong class="source-inline">chcon</strong> to label <strong class="source-inline">/srv/web</strong> and its resources with the same context as used for the <strong class="source-inline">/var/www</strong> directory:</p>
			<p class="source-code">$ chcon -R --reference /var/www /srv/www</p>
			<p class="calibre3">If we change the context of a file through <strong class="source-inline">chcon</strong> and set it to a context different from the one in the context list, then the context might be reverted later: package managers might reset the file contexts back to their intended value, or the system administrator might trigger a fill filesystem relabeling operation.</p>
			<p class="calibre3">Until now, we've only focused on the type part of a context. Contexts, however, also include a role part and an SELinux user part. If UBAC is not enabled, then the SELinux user has no influence on any decisions, and resetting it has little value. If UBAC is enabled, though, it might be necessary to reset the SELinux user values on files. Utilities such as <strong class="source-inline">chcon</strong> can set the SELinux user as well:</p>
			<p class="source-code"># chcon -u system_u -R /srv/web</p>
			<p class="calibre3">The role for a file is usually <strong class="source-inline">object_r</strong> as roles currently only make sense for users (processes).</p>
			<p class="calibre3">To be able to change contexts, we do need the proper SELinux privileges, named <strong class="source-inline">relabelfrom</strong> and <strong class="source-inline">relabelto</strong>. These rights are granted on domains to indicate whether the domain can <a id="_idIndexMarker238" class="pcalibre calibre6 pcalibre1"/>change a label from one type to another. If we find denials in the audit log related to these permissions, then this means that the policy prohibits the domain from changing the contexts.</p>
			<h2 id="_idParaDest-103" class="calibre10"><a id="_idTextAnchor105" class="pcalibre calibre6 pcalibre1"/>Placing categories on files and directories</h2>
			<p class="calibre3">We <a id="_idIndexMarker239" class="pcalibre calibre6 pcalibre1"/>focused primarily on changing types and briefly touched SELinux users, but another important part is to support categories and sensitivity levels. With <strong class="source-inline">chcon</strong>, we can add sensitivity levels and categories as follows:</p>
			<p class="source-code"># chcon -l s0:c0,c2 doku.php</p>
			<p class="calibre3">Another tool that can be used to assign categories is the <strong class="source-inline">chcat</strong> tool. With <strong class="source-inline">chcat</strong>, we can assign additional categories rather than having to reiterate them, as would be the case with <strong class="source-inline">chcon</strong>, and even enjoy the human-readable category levels provided by the <strong class="source-inline">setrans.conf</strong> file:</p>
			<p class="source-code"># chcat -- +Contracts doku.php</p>
			<p class="calibre3">To remove a category, just use the minus sign:</p>
			<p class="source-code"># chcat -- -Contracts doku.php</p>
			<p class="calibre3">To remove all categories, use the <strong class="source-inline">-d</strong> option:</p>
			<p class="source-code"># chcat -d doku.php</p>
			<p class="calibre3">Users and administrators should keep in mind that applications generally do not set categories themselves, so they need to be added ad hoc.</p>
			<h2 id="_idParaDest-104" class="calibre10"><a id="_idTextAnchor106" class="pcalibre calibre6 pcalibre1"/>Using multilevel security on files</h2>
			<p class="calibre3">When <a id="_idIndexMarker240" class="pcalibre calibre6 pcalibre1"/>the system uses an MLS policy, the <strong class="source-inline">chcon</strong> tool needs to be used. The syntax is the same as with categories. For instance, to set the sensitivity <strong class="source-inline">s1</strong> and category set <strong class="source-inline">c2</strong> and <strong class="source-inline">c4</strong> to <strong class="source-inline">c10</strong> on all files of a user's home directory, you'd do the following:</p>
			<p class="source-code">$ chcon -R -l s1:c2,c4.c10 /home/lisa</p>
			<p class="calibre3">Remember <a id="_idIndexMarker241" class="pcalibre calibre6 pcalibre1"/>that both the context of the user executing <strong class="source-inline">chcon</strong> and the context of the user who will use the data must be able to deal with the mentioned sensitivity.</p>
			<h2 id="_idParaDest-105" class="calibre10"><a id="_idTextAnchor107" class="pcalibre calibre6 pcalibre1"/>Backing up and restoring extended attributes</h2>
			<p class="calibre3">As with <a id="_idIndexMarker242" class="pcalibre calibre6 pcalibre1"/>the regular file operation <a id="_idIndexMarker243" class="pcalibre calibre6 pcalibre1"/>tools (such as <strong class="source-inline">mv</strong> and <strong class="source-inline">cp</strong>), backup software, too, needs to consider SELinux contexts. Two important requirements exist for a backup tool when working with SELinux-enabled systems:</p>
			<ul class="calibre8">
				<li class="calibre9">The backup tool must run in an SELinux context capable of reading all files in scope of the backup, and, of course, of restoring those files as well. If no specific SELinux policy for the backup tool exists, then it might need to run in an unconfined or highly privileged domain to succeed.</li>
				<li class="calibre9">The backup tool must be able to back up and restore extended attributes.</li>
			</ul>
			<p class="calibre3">A popular tool for taking backups (or archives) is the <strong class="source-inline">tar</strong> application, which supports SELinux contexts as follows:</p>
			<p class="source-code"># tar cjvf dokuwiki-20200405.tar.bz2 /srv/web --selinux</p>
			<p class="calibre3">When creating a tar archive, add <strong class="source-inline">--selinux</strong> to include SELinux contexts (both during the creation of the archive and when extracting files from the archive).</p>
			<h2 id="_idParaDest-106" class="calibre10"><a id="_idTextAnchor108" class="pcalibre calibre6 pcalibre1"/>Using mount options to set SELinux contexts</h2>
			<p class="calibre3">Not all <a id="_idIndexMarker244" class="pcalibre calibre6 pcalibre1"/>filesystems support extended attributes. When we use a filesystem without extended attribute support, then the SELinux context of a file is either based on the filesystem type itself (each filesystem has its own associated context) or is passed on to the system using a <strong class="source-inline">mount</strong> option.</p>
			<p class="calibre3">The most commonly used <strong class="source-inline">mount</strong> option in these situations is the <strong class="source-inline">context=</strong> option. When set, it will use the mentioned context as the context for all the resources in the filesystem. For instance, to mount an external USB drive that hosts a FAT filesystem while ensuring that end users can write to it, we could mount it with the <strong class="source-inline">user_home_t</strong> context:</p>
			<p class="source-code"># mount -o context="user_u:object_r:user_home_t:s0" /dev/sdc1 /media/usb</p>
			<p class="calibre3">If the filesystem supports extended attributes but doesn't have all files labeled yet, then we can use the <strong class="source-inline">defcontext=</strong> option to tell Linux that, if no SELinux context is available, then the default context provided should be used:</p>
			<p class="source-code"># mount -o defcontext="system_u:object_r:var_t:s0" /dev/sdc1 /srv/backups</p>
			<p class="calibre3">Another mount option is <strong class="source-inline">fscontext=</strong>. This assigns a context on the filesystem type rather than the context of the files on the filesystem. For instance, a CD/DVD filesystem can be ISO 9660, Joliet, or UDF. SELinux uses this type definition on a filesystem to map permissions such as mount operations and file creation. With the <strong class="source-inline">fscontext=</strong> option, the filesystem type can be set differently from what the default filesystem type would be.</p>
			<p class="calibre3">The last option that can be used when mounting filesystems is the <strong class="source-inline">rootcontext=</strong> option. This will force the root inode of the filesystem to have the given context even before the filesystem <a id="_idIndexMarker245" class="pcalibre calibre6 pcalibre1"/>is visible to the user space. Permission checks on the location during the mount operation itself can cause havoc when the location does not have the expected context (especially when filesystems are mounted outside their expected location). The <strong class="source-inline">rootcontext=</strong> option provides a reusable configuration option to set the expected context:</p>
			<p class="source-code"># mount -o rootcontext="system_u:object_r:tmp_t:s0" -t tmpfs none /var/tmp</p>
			<p class="calibre3">That's it – these are all the context-related mount options. A final note though: the <strong class="source-inline">context=</strong> option is mutually exclusive to the <strong class="source-inline">defcontext=</strong> and <strong class="source-inline">fscontext=</strong> options. So, while the <strong class="source-inline">defcontext=</strong> and <strong class="source-inline">fscontext=</strong> options can be used together, they cannot be used with the <strong class="source-inline">context=</strong> option. Assuming the target filesystem allows for extended attributes, then we can use the file context expressions, which we will cover in the next section.</p>
			<h1 id="_idParaDest-107" class="calibre5"><a id="_idTextAnchor109" class="pcalibre calibre6 pcalibre1"/>SELinux file context expressions</h1>
			<p class="calibre3">When we <a id="_idIndexMarker246" class="pcalibre calibre6 pcalibre1"/>think that the context of a file is wrong, we need to correct the context. SELinux offers several methods to do so, and some distributions even add in more. We can use tools such as <strong class="source-inline">chcon</strong>, <strong class="source-inline">restorecon</strong> (together with <strong class="source-inline">semanage</strong>), <strong class="source-inline">setfiles</strong>, <strong class="source-inline">rlpkg</strong> (Gentoo), and <strong class="source-inline">fixfiles</strong>. Of course, we could also use the <strong class="source-inline">setfattr</strong> command, but that would be the least user-friendly approach for setting contexts.</p>
			<p class="calibre3">Let's see how we can set context expressions in a more manageable way.</p>
			<h2 id="_idParaDest-108" class="calibre10"><a id="_idTextAnchor110" class="pcalibre calibre6 pcalibre1"/>Using context expressions</h2>
			<p class="calibre3">In the SELinux policy, a list of regular expressions is kept that informs the SELinux utilities and libraries <a id="_idIndexMarker247" class="pcalibre calibre6 pcalibre1"/>what the context of a file (or other filesystem resource) should be. Though this expression list is not enforced on the system directly, administrators and SELinux utilities use it to see whether a context is correct, and to reset contexts to what they are supposed to be. You can find the list itself in <strong class="source-inline">/etc/selinux/targeted/contexts/files</strong> in the various <strong class="source-inline">file_contexts.*</strong> files.</p>
			<p class="calibre3">As an administrator, we can query this list through <strong class="source-inline">semanage fcontext</strong> as follows:</p>
			<p class="source-code"># semanage fcontext -l</p>
			<p class="source-code">SELinux fcontext	type		Context</p>
			<p class="source-code">/			directory	system_u:object_r:root_t:s0</p>
			<p class="source-code">...</p>
			<p class="source-code">/vmlinuz.*		symbolic link	system_u:object_r:boot_t:s0</p>
			<p class="source-code">/xen(/.*)?		all files	system_u:object_r:xen_image_t:s0</p>
			<p class="source-code">...</p>
			<p class="calibre3">An example of a tool that queries this information is <strong class="source-inline">matchpathcon</strong>, which we introduced in <a href="B16276_02_Final_VK.xhtml#_idTextAnchor045" class="pcalibre calibre6 pcalibre1"><em class="italic">Chapter 2</em></a>, <em class="italic">Understanding SELinux Decisions and Logging</em>:</p>
			<p class="source-code"># matchpathcon /srv/web/localhost/htdocs/dokuwiki</p>
			<p class="source-code">/srv/web/localhost/htdocs/dokuwiki  system_u:object_r:var_t:s0</p>
			<p class="calibre3">Not all the entries are visible through the <strong class="source-inline">semanage</strong> application though. Entries related to specific user home directories (such as <strong class="source-inline">/home/lisa/.ssh</strong>) are not shown as these entries depend on the Linux user (and, more importantly, its associated SELinux user).</p>
			<p class="calibre3">But for <a id="_idIndexMarker248" class="pcalibre calibre6 pcalibre1"/>all other entries, the output of the command contains the following:</p>
			<ul class="calibre8">
				<li class="calibre9">A regular expression that matches one or more paths</li>
				<li class="calibre9">The classes to which the rule is applicable, but translated into a more human-readable format</li>
				<li class="calibre9">The context to assign to the resources that match the expression and class list</li>
			</ul>
			<p class="calibre3">The class list allows us to differentiate contexts based on the resource class. The <strong class="source-inline">semanage fcontext</strong> output uses human-readable identifiers: resource classes can be a regular file (<strong class="source-inline">--</strong>), a directory (<strong class="source-inline">-d</strong>), a socket (<strong class="source-inline">-s</strong>), a named pipe (<strong class="source-inline">-p</strong>), a block device (<strong class="source-inline">-b</strong>), a character device (<strong class="source-inline">-c</strong>), or a symbolic link (<strong class="source-inline">-l</strong>). When it says all files, the line is valid regardless of the class.</p>
			<p class="calibre3">Right now, we have not defined such rules yet, but after the next section, even defining custom SELinux context expressions will no longer hold any secrets. An important property of the context list is how SELinux prioritizes its application – after all, we could easily have two expressions that both match a certain resource or path. Within SELinux, the most specific rule wins. The logic used is as follows (in order):</p>
			<ol class="calibre18">
				<li class="calibre9">If line A has a regular expression and line B doesn't, then line B is more specific.</li>
				<li class="calibre9">If the number of characters before the first regular expression in line A is less than the number of characters before the first regular expression in line B, then line B is more specific.</li>
				<li class="calibre9">If the number of characters in line A is less than in line B, then line B is more specific.</li>
				<li class="calibre9">If line A does not map to a specific SELinux type (the policy editor has explicitly told SELinux not to assign a type) and line B does, then line B is more specific.</li>
			</ol>
			<p class="calibre3">There is a <a id="_idIndexMarker249" class="pcalibre calibre6 pcalibre1"/>caveat with the rule order, however. When additional rules are added through <strong class="source-inline">semanage</strong> (which we describe in the next section), then SELinux's utilities apply the rules in the order they were added rather than their specificity. So, instead of the most specific rule, the most recently added rule that matches the path is used.</p>
			<h2 id="_idParaDest-109" class="calibre10"><a id="_idTextAnchor111" class="pcalibre calibre6 pcalibre1"/>Registering file context changes</h2>
			<p class="calibre3">Because changing an SELinux context using <strong class="source-inline">chcon</strong> is often just a temporary measure, it is seriously <a id="_idIndexMarker250" class="pcalibre calibre6 pcalibre1"/>recommended to only use <strong class="source-inline">chcon</strong> when testing the impact of a context change. Once the change is acceptable, we need to register it through <strong class="source-inline">semanage</strong>. For instance, to permanently mark <strong class="source-inline">/srv/web</strong> (and all its subdirectories) as <strong class="source-inline">httpd_sys_content_t</strong>, and the DokuWiki <strong class="source-inline">data/</strong> and <strong class="source-inline">conf/</strong> folders as <strong class="source-inline">httpd_sys_rw_content_t</strong> (to allow the web server to modify these resources), we need to execute the following:</p>
			<p class="source-code"># semanage fcontext -a -t httpd_sys_content_t "/srv/web(/.*)?"</p>
			<p class="source-code"># semanage fcontext -a -t httpd_sys_rw_content_t "/srv/web/localhost/htdocs/dokuwiki/data(/.*)?"</p>
			<p class="source-code"># semanage fcontext -a -t httpd_sys_rw_content_t "/srv/web/localhost/htdocs/dokuwiki/conf(/.*)?"</p>
			<p class="source-code"># restorecon -Rv /srv/web</p>
			<p class="calibre3">What we do here is register <strong class="source-inline">/srv/web</strong> and its subdirectories as <strong class="source-inline">httpd_sys_content_t</strong> and the two writable directories as <strong class="source-inline">httpd_sys_rw_content_t</strong> through <strong class="source-inline">semanage</strong>. Then, we use <strong class="source-inline">restorecon</strong> to (recursively) reset the contexts of <strong class="source-inline">/srv/web</strong> to the value registered in the context list. This is the recommended approach for setting contexts on most resources.</p>
			<p class="calibre3">These registrations are local (custom) context expressions and are stored in a separate configuration file (<strong class="source-inline">file_contexts.local</strong>). Considering the priority of (locally added) expressions, it is important to have the <em class="italic">most specific entries added last</em>, as otherwise the more broadly defined rule for <strong class="source-inline">httpd_sys_content_t</strong> would be applied to the entire directory. This is unlike the priority rules for (policy added) expressions that do have the concept of <em class="italic">most specific rule wins</em>.</p>
			<p class="calibre3">The <strong class="source-inline">semanage fcontext</strong> application can also be used to inform SELinux that a part of the filesystem tree should be labeled similarly as a different location on the filesystem. Such an <strong class="bold">equivalency rule</strong> allows us to use different paths for application installations or file destinations and tell <strong class="source-inline">semanage</strong> to apply the same contexts as if the destination were the default.</p>
			<p class="calibre3">Let's make this <a id="_idIndexMarker251" class="pcalibre calibre6 pcalibre1"/>more visible through an example, and have everything under <strong class="source-inline">/srv/web</strong> be labeled in a similar manner to the files at <strong class="source-inline">/var/www</strong> (including subdirectories), so <strong class="source-inline">/srv/web/icons</strong> gets the same context as <strong class="source-inline">/var/www/icons</strong>. We use the <strong class="source-inline">-e</strong> option of <strong class="source-inline">semanage fcontext</strong> to create such an equivalency as follows:</p>
			<p class="source-code"># semanage fcontext -a -e /var/www /srv/web</p>
			<p class="source-code"># restorecon -Rv /srv/web</p>
			<p class="calibre3">This will create a substitution entry so that anything under <strong class="source-inline">/srv/web</strong> gets the same label as if it were at the same location under <strong class="source-inline">/var/www</strong>.</p>
			<p class="calibre3">Most distributions already configure a few equivalency rules that we can read as follows:</p>
			<p class="source-code"># cat /etc/selinux/targeted/contexts/files/file_contexts.subs_dist</p>
			<p class="source-code">/run /var/run</p>
			<p class="source-code">...</p>
			<p class="source-code">/sysroot/tmp /tmp</p>
			<p class="calibre3">The <strong class="source-inline">semanage fcontext -l</strong> command will show these equivalent locations at the end of its output as well.</p>
			<h2 id="_idParaDest-110" class="calibre10"><a id="_idTextAnchor112" class="pcalibre calibre6 pcalibre1"/>Optimizing recursive context operations</h2>
			<p class="calibre3">The <strong class="source-inline">restorecon</strong> application resets the SELinux context of files and other resources based on the <a id="_idIndexMarker252" class="pcalibre calibre6 pcalibre1"/>context definitions managed through the SELinux policy and <strong class="source-inline">semanage fcontext</strong>. When applying <strong class="source-inline">restorecon</strong> in a recursive fashion against directories, this might take a while. To improve performance in this situation, the SELinux authors support the skipping of <strong class="source-inline">restorecon</strong> operations.</p>
			<p class="calibre3">With the <strong class="source-inline">-D</strong> option to <strong class="source-inline">restorecon</strong>, an additional extended attribute will be written to the main directory that contains a hash of the file context definitions used when invoking the command:</p>
			<p class="source-code"># restorecon -RD /home</p>
			<p class="calibre3">Subsequent invocations of <strong class="source-inline">restorecon</strong> with <strong class="source-inline">-D</strong> will check this hash to see whether any of the file context definitions that impact this directory have been modified (using <strong class="source-inline">semanage fcontext</strong>). If there aren't, then the restore operation will be skipped:</p>
			<p class="source-code"># restorecon -RvD /home</p>
			<p class="source-code">Skipping restorecon as matching digest on: /home</p>
			<p class="calibre3">Once we update a definition that influences the given location, then <strong class="source-inline">restorecon</strong> will reset the <a id="_idIndexMarker253" class="pcalibre calibre6 pcalibre1"/>contexts appropriately:</p>
			<p class="source-code"># semanage fcontext -a -t httpd_user_content_t "/home/[^/]*/cgi-bin(/.*)?"</p>
			<p class="source-code"># restorecon -RvD /home</p>
			<p class="source-code">Relabeled /home/lisa/cgi-bin from staff_u:object_r:user_home_t:s0 to staff_u:object_r:httpd_user_content_t:s0</p>
			<p class="source-code">Updated digest for: /home</p>
			<p class="calibre3">The <strong class="source-inline">restorecon_xattr</strong> command can be used to manage these extended attributes (view or delete) and show how the attributes are formed:</p>
			<p class="source-code"># restorecon_xattr -v /home</p>
			<p class="source-code">specfiles SHA1 digest: 7ed69be330ad60811481e455ca8e5ab0b1556036</p>
			<p class="source-code">calculated using the following specfile(s):</p>
			<p class="source-code">/etc/selinux/targeted/contexts/files/file_contexts.subs_dist</p>
			<p class="source-code">...</p>
			<p class="source-code">/etc/selinux/targeted/contexts/files/file_contexts.local.bin</p>
			<p class="source-code">/home Digest: 7ed69be330ad60811481e455ca8e5ab0b1556036 Match</p>
			<p class="calibre3">The <strong class="source-inline">digest</strong> referenced is the <strong class="source-inline">security.restorecon_last</strong> or <strong class="source-inline">security.sehash</strong> extended attributes. More recent user space tools use the latter, and apply their logic to each subdirectory, whereas older user space utilities use the former and only apply their logic on the selected directory.</p>
			<p class="calibre3">The disadvantage of the <strong class="source-inline">security.restorecon_last</strong> usage is that it does not work with subdirectories: if we apply a recursive <strong class="source-inline">restorecon</strong> operation against <strong class="source-inline">/</strong>, then this tool will ignore the digest on <strong class="source-inline">/home</strong>. With the <strong class="source-inline">security.sehash</strong> usage, a recursive operation against <strong class="source-inline">/</strong> will check the digest for <strong class="source-inline">/home</strong> as well.</p>
			<h2 id="_idParaDest-111" class="calibre10"><a id="_idTextAnchor113" class="pcalibre calibre6 pcalibre1"/>Using customizable types</h2>
			<p class="calibre3">Some <a id="_idIndexMarker254" class="pcalibre calibre6 pcalibre1"/>SELinux types are meant for files whose paths cannot be accurately defined by administrators or where the administrator <a id="_idIndexMarker255" class="pcalibre calibre6 pcalibre1"/>does not want the context to be reset when a relabeling operation is triggered. For these purposes, SELinux supports what it calls <strong class="bold">customizable types</strong>. When tools that manage file contexts (such as <strong class="source-inline">restorecon</strong>) encounter a file with a customizable type set, they will not revert its context to the registered context definition.</p>
			<p class="calibre3">The customizable types are declared in the <strong class="source-inline">customizable_types</strong> file inside <strong class="source-inline">/etc/selinux/targeted/contexts</strong>. To have <strong class="source-inline">restorecon</strong> relabel such files, administrators need to pass the force reset option (<strong class="source-inline">-F</strong>) before the tool resets the contexts.</p>
			<p class="calibre3">Let's look at the contents of this <strong class="source-inline">customizable_types</strong> file:</p>
			<p class="source-code">$ cat /etc/selinux/targeted/contexts/customizable_types</p>
			<p class="source-code">container_file_t</p>
			<p class="source-code">sandbox_file_t</p>
			<p class="source-code">...</p>
			<p class="source-code">httpd_user_content_t</p>
			<p class="source-code">git_session_content_t</p>
			<p class="source-code">home_bin_t</p>
			<p class="source-code">user_tty_device_t</p>
			<p class="calibre3">As an <a id="_idIndexMarker256" class="pcalibre calibre6 pcalibre1"/>example, we can mark a file in a home directory as <strong class="source-inline">home_bin_t</strong>, which is a customizable type, and as such, this file will not be relabeled back to <strong class="source-inline">user_home_t</strong> when a filesystem relabeling operation is done:</p>
			<p class="source-code">$ chcon -t home_bin_t ~/convert.sh</p>
			<p class="calibre3">Marking other types as customizable requires updating the <strong class="source-inline">customizable_types</strong> file, as there is no user command that adds or removes type definitions from this list. Because this file can be overwritten when the distribution or administrator pushes out a new policy package, it needs to be governed carefully. </p>
			<p class="calibre3">That said, the use of customizable types has its advantages. As an administrator, we might want to create and support specific types as usable by end users who can use <strong class="source-inline">chcon</strong> to set the contexts of individual files in their home directory. By having those types marked as customizable types, a relabeling operation against <strong class="source-inline">/home</strong> will not reset those contexts.</p>
			<p class="calibre3">When the target type is not a customizable type, administrators generally prefer to use <strong class="source-inline">semanage fcontext</strong> to add an expression and <strong class="source-inline">restorecon</strong> to fix the context of the files. Most administrators will use directory-based labeling: this is much easier to maintain, and much easier to explain to end users. Many will even use this approach for customizable types:</p>
			<p class="source-code"># semanage fcontext -a -t home_bin_t "/home/[^/]*/bin(/.*)?"</p>
			<p class="calibre3">With this command, user binaries and scripts located in the <strong class="source-inline">~/bin</strong> directory will be labeled as <strong class="source-inline">home_bin_t</strong>.</p>
			<h2 id="_idParaDest-112" class="calibre10"><a id="_idTextAnchor114" class="pcalibre calibre6 pcalibre1"/>Compiling the different file_contexts files</h2>
			<p class="calibre3">Inside <a id="_idIndexMarker257" class="pcalibre calibre6 pcalibre1"/>the <strong class="source-inline">/etc/selinux/targeted/contexts/files</strong> directory, five different <strong class="source-inline">file_contexts</strong> files can be found:</p>
			<ul class="calibre8">
				<li class="calibre9">The <strong class="source-inline">file_contexts</strong> file itself (without any suffix) is the basic expression file provided by the SELinux policy offered through the Linux distribution.</li>
				<li class="calibre9">The <strong class="source-inline">file_contexts.local</strong> file contains the locally added rules (through the <strong class="source-inline">semanage fcontext</strong> command, which we covered earlier in this chapter).</li>
				<li class="calibre9">The <strong class="source-inline">file_contexts.homedirs</strong> file contains the expressions for the user home directories. When new user mappings are created and managed through <strong class="source-inline">semanage login</strong> and <strong class="source-inline">semanage user</strong>, this file is adjusted to reflect the new situation.</li>
				<li class="calibre9">The <strong class="source-inline">file_contexts.subs_dist</strong> file contains equivalency rules, provided by the distribution's SELinux policy, which tell SELinux to consider one part of the filesystem as having the same labeling rules as another location.</li>
				<li class="calibre9">The <strong class="source-inline">file_contexts.subs</strong> file contains locally managed equivalency rules (through the <strong class="source-inline">semanage fcontext</strong> command, covered earlier in this chapter).</li>
			</ul>
			<p class="calibre3">Alongside those files, you will find associated <strong class="source-inline">*.bin</strong> files (so <strong class="source-inline">file_contexts.bin</strong> for the <strong class="source-inline">file_contexts</strong> file, <strong class="source-inline">file_contexts.local.bin</strong> for the <strong class="source-inline">file_contexts.local</strong> file, and so on). These <strong class="source-inline">*.bin</strong> files are automatically created, but in case of a discrepancy, administrators can rebuild the files themselves as well using the <strong class="source-inline">sefcontext_compile</strong> command:</p>
			<p class="source-code"># cd /etc/selinux/targeted/contexts/files</p>
			<p class="source-code"># sefcontext_compile file_contexts.local</p>
			<p class="calibre3">These files contain the same information as the main file, but are precompiled to make lookups faster. Unless the tools detect that the <strong class="source-inline">*.bin</strong> files are older than their source files, the SELinux utilities will use the compiled versions of these files.</p>
			<h2 id="_idParaDest-113" class="calibre10"><a id="_idTextAnchor115" class="pcalibre calibre6 pcalibre1"/>Exchanging local modifications</h2>
			<p class="calibre3">When <a id="_idIndexMarker258" class="pcalibre calibre6 pcalibre1"/>local modifications are registered through <strong class="source-inline">semanage fcontext</strong>, they only apply to a single system. If local definitions need to be reapplied on various systems, administrators can extract the local modifications and import them on another system.</p>
			<p class="calibre3">To export the local modifications, use <strong class="source-inline">semanage export</strong>:</p>
			<p class="source-code"># semanage export -f local-mods.conf</p>
			<p class="calibre3">The file that contains the local modifications (<strong class="source-inline">local-mods.conf</strong> in the example) can be adjusted at will. This allows administrators to remove all lines except those they want to apply on other systems.</p>
			<p class="calibre3">With <a id="_idIndexMarker259" class="pcalibre calibre6 pcalibre1"/>the local modifications stored in the file, transport the file to the other system(s) and import the settings:</p>
			<p class="source-code"># semanage import -f ./local-mods.conf</p>
			<p class="calibre3">The imported settings are immediately registered. Of course, in case of filesystem changes (<strong class="source-inline">semanage fcontext</strong>), don't forget to run <strong class="source-inline">restorecon</strong> against the target directories.</p>
			<h1 id="_idParaDest-114" class="calibre5"><a id="_idTextAnchor116" class="pcalibre calibre6 pcalibre1"/>Modifying file contexts</h1>
			<p class="calibre3">We <a id="_idIndexMarker260" class="pcalibre calibre6 pcalibre1"/>now know how to set SELinux contexts, both directly through tools such as <strong class="source-inline">chcon</strong> as well as through the <strong class="source-inline">restorecon</strong> application, which queries the SELinux context list to know what context a file should have. Yet <strong class="source-inline">restorecon</strong> is not the only application that considers this context list.</p>
			<h2 id="_idParaDest-115" class="calibre10"><a id="_idTextAnchor117" class="pcalibre calibre6 pcalibre1"/>Using setfiles, rlpkg, and fixfiles</h2>
			<p class="calibre3">The <strong class="source-inline">setfiles</strong> application is an older one, which requires the path to the context list file itself to reset <a id="_idIndexMarker261" class="pcalibre calibre6 pcalibre1"/>contexts. It is often used under the hood <a id="_idIndexMarker262" class="pcalibre calibre6 pcalibre1"/>of other applications, so most administrators <a id="_idIndexMarker263" class="pcalibre calibre6 pcalibre1"/>do not need to call <strong class="source-inline">setfiles</strong> directly anymore:</p>
			<p class="source-code"># setfiles /etc/selinux/targeted/contexts/files/file_contexts /srv/web</p>
			<p class="calibre3">Another set of tools are the <strong class="source-inline">rlpkg</strong> (Gentoo) and <strong class="source-inline">fixfiles</strong> (CentOS and related distributions) applications. Both these applications have a nice feature: they can be used to reset the contexts of the files of an application rather than having to iterate over the files manually and run <strong class="source-inline">restorecon</strong> against them.</p>
			<p class="calibre3">In the next example, we're using these tools to restore the contexts of the files provided by the <strong class="source-inline">nginx</strong> package:</p>
			<p class="source-code"># rlpkg nginx</p>
			<p class="source-code"># fixfiles -R nginx restore</p>
			<p class="calibre3">Another feature of both applications is that they can be used to relabel the entire filesystem without <a id="_idIndexMarker264" class="pcalibre calibre6 pcalibre1"/>the need to perform a system reboot, like <a id="_idIndexMarker265" class="pcalibre calibre6 pcalibre1"/>so:</p>
			<p class="source-code"># rlpkg -a -r</p>
			<p class="source-code"># fixfiles -f -F relabel</p>
			<p class="calibre3">Of <a id="_idIndexMarker266" class="pcalibre calibre6 pcalibre1"/>course, this is not as fine-grained as the commands before.</p>
			<h2 id="_idParaDest-116" class="calibre10"><a id="_idTextAnchor118" class="pcalibre calibre6 pcalibre1"/>Relabeling the entire filesystem</h2>
			<p class="calibre3">The <strong class="source-inline">rlpkg</strong> and <strong class="source-inline">fixfiles</strong> commands as listed in the previous section are not the only available approaches <a id="_idIndexMarker267" class="pcalibre calibre6 pcalibre1"/>for relabeling the entire filesystem when working with a CentOS (or related) distribution. SELinux offers two other methods to ask the system to perform a full filesystem relabeling operation during (re)boot: placing a touch file (which the system reads at boot time) or configuring a boot parameter.</p>
			<p class="calibre3">The touch file is called <strong class="source-inline">.autorelabel</strong> and should be placed in the root filesystem. Once set, the system needs to be rebooted:</p>
			<p class="source-code"># touch /.autorelabel</p>
			<p class="source-code"># reboot</p>
			<p class="calibre3">We trigger the same behavior if we add the <strong class="source-inline">autorelabel=1</strong> parameter to the boot parameter list (like where we can set the <strong class="source-inline">selinux=</strong> and <strong class="source-inline">enforcing=</strong> parameters as discussed earlier).</p>
			<p class="calibre3">Asking the system to perform a full filesystem relabeling operation will take a while. When finished, the system will reboot again. Touch files will be removed automatically after the relabeling operation has finished.</p>
			<h2 id="_idParaDest-117" class="calibre10"><a id="_idTextAnchor119" class="pcalibre calibre6 pcalibre1"/>Automatically setting context with restorecond</h2>
			<p class="calibre3">Contexts can <a id="_idIndexMarker268" class="pcalibre calibre6 pcalibre1"/>also be applied by the <strong class="source-inline">restorecond</strong> daemon. The purpose of this daemon is to enforce the expression list rules onto a configurable set of locations, defined in the <strong class="source-inline">/etc/selinux/restorecond.conf</strong> file.</p>
			<p class="calibre3">The following set of files and directories is an example list of locations configured in the <strong class="source-inline">restorecond.conf</strong> file so that <strong class="source-inline">restorecond</strong> automatically applies the SELinux contexts on these files and directories whenever it detects a context change in them:</p>
			<p class="source-code">/etc/services</p>
			<p class="source-code">/etc/resolv.conf</p>
			<p class="source-code">/etc/samba/secrets.tdb</p>
			<p class="source-code">...</p>
			<p class="source-code">/root/.ssh/*</p>
			<p class="calibre3">In this case, if a process creates a file that matches any of the previously created paths, the Linux inotify subsystem will notify <strong class="source-inline">restorecond</strong> of it. <strong class="source-inline">restorecond</strong> will then relabel the file according to the expression list, applying the correct label regardless of the process (and context) that created the file.</p>
			<p class="calibre3">The use <a id="_idIndexMarker269" class="pcalibre calibre6 pcalibre1"/>of <strong class="source-inline">restorecond</strong> is primarily for historical reasons, when SELinux didn't support named file transitions. At that time, writing <strong class="source-inline">resolv.conf</strong> in <strong class="source-inline">/etc</strong> could not be differentiated from writing to the <strong class="source-inline">passwd</strong> file in <strong class="source-inline">/etc</strong>. The introduction of named file transitions has considerably reduced the need for <strong class="source-inline">restorecond</strong>.</p>
			<h2 id="_idParaDest-118" class="calibre10"><a id="_idTextAnchor120" class="pcalibre calibre6 pcalibre1"/>Setting SELinux context at boot with tmpfiles</h2>
			<p class="calibre3">If the Linux distribution uses <strong class="source-inline">systemd</strong>, then you can use <strong class="source-inline">systemd-tmpfiles</strong> to automatically set SELinux <a id="_idIndexMarker270" class="pcalibre calibre6 pcalibre1"/>context at boot. <strong class="source-inline">systemd</strong> uses the <strong class="source-inline">tmpfiles</strong> application to automatically create and manage volatile locations on the system, such as locations inside <strong class="source-inline">/run</strong> when <strong class="source-inline">/run</strong> is a <strong class="source-inline">tmpfs</strong>-mounted filesystem (an in-memory filesystem).</p>
			<p class="calibre3">Administrators can configure <strong class="source-inline">tmpfiles</strong> to automatically create files, directories, device files, symbolic links, and others at boot, and to reset the permissions on resources. It is through this reset operation that we can use <strong class="source-inline">tmpfiles</strong> to set the right SELinux context at boot time.</p>
			<p class="calibre3">In <a href="B16276_03_Final_VK.xhtml#_idTextAnchor071" class="pcalibre calibre6 pcalibre1"><em class="italic">Chapter 3</em></a>, <em class="italic">Managing User Logins</em>, we covered polyinstantiation, where users get their own private view on filesystem resources. The example we gave used a directory called <strong class="source-inline">/tmp/tmp-inst</strong>, which had to have the <strong class="source-inline">000</strong> permission set, and which will host the user-oriented <strong class="source-inline">/tmp</strong> views. Rather than having to create and set this permission each time, we can configure <strong class="source-inline">tmpfiles</strong> to do this for us, and define the right SELinux context up front:</p>
			<p class="source-code"># semanage fcontext -a -t tmp_t -f d "/tmp/tmp-inst"</p>
			<p class="calibre3">In <strong class="source-inline">/etc/tmpfiles.d</strong>, we create a file called <strong class="source-inline">selinux-polyinstantiation.conf</strong> with the following content:</p>
			<p class="source-code">d /tmp/tmp-inst 000 root root</p>
			<p class="calibre3">The name of the file can be chosen freely, but make sure it uses the <strong class="source-inline">.conf</strong> suffix. Every time the system boots, <strong class="source-inline">systemd-tmpfiles</strong> will ensure that the <strong class="source-inline">/tmp/tmp-inst</strong> directory is created with the appropriate permissions.</p>
			<p class="calibre3">If a location does not need to be created, but only its SELinux context reset, then you can use the <strong class="source-inline">z</strong> (one resource) or <strong class="source-inline">Z</strong> (recursively) options in the <strong class="source-inline">tmpfiles</strong> configuration. This is used, for instance, by the default SELinux <strong class="source-inline">tmpfiles</strong> configuration, <strong class="source-inline">selinux-policy.conf</strong>, in <strong class="source-inline">/usr/lib/tmpfiles.d</strong>:</p>
			<p class="source-code">z /sys/devices/system/cpu/online - - -</p>
			<p class="calibre3">The <strong class="source-inline">-</strong> used is <a id="_idIndexMarker271" class="pcalibre calibre6 pcalibre1"/>to inform <strong class="source-inline">tmpfiles</strong> not to adjust the permissions and ownership, and only to reset the SELinux context.</p>
			<h1 id="_idParaDest-119" class="calibre5"><a id="_idTextAnchor121" class="pcalibre calibre6 pcalibre1"/>The context of a process</h1>
			<p class="calibre3">As everything in <a id="_idIndexMarker272" class="pcalibre calibre6 pcalibre1"/>SELinux works with contexts, even processes are assigned a context, also known as the domain. Let's see how we can obtain this information, how SELinux transitions from one domain to another, and learn how to query the SELinux policy to find more information about these transitions.</p>
			<h2 id="_idParaDest-120" class="calibre10"><a id="_idTextAnchor122" class="pcalibre calibre6 pcalibre1"/>Getting a process context</h2>
			<p class="calibre3">We saw <a id="_idIndexMarker273" class="pcalibre calibre6 pcalibre1"/>that the <strong class="source-inline">nginx</strong> web server runs in the <strong class="source-inline">httpd_t</strong> domain, which can be seen with the <strong class="source-inline">ps -eZ</strong> command, as follows:</p>
			<p class="source-code"># ps -eZ | grep nginx</p>
			<p class="source-code">system_u:system_r:httpd_t:s0  3744 ?   00:00:00 nginx</p>
			<p class="calibre3">Several other ways exist to obtain the process context. Although the method with <strong class="source-inline">ps</strong> is the most obvious, these other methods can prove useful in scripted approaches or through monitoring services.</p>
			<p class="calibre3">A first approach is to read the <strong class="source-inline">/proc/&lt;pid&gt;/attr/current</strong> pseudo-file, which we've already encountered in <a href="B16276_01_Final_VK.xhtml#_idTextAnchor018" class="pcalibre calibre6 pcalibre1"><em class="italic">Chapter 1</em></a>, <em class="italic">Fundamental SELinux Concepts</em>. It displays a process's current security context:</p>
			<p class="source-code"># pidof nginx</p>
			<p class="source-code">3746 3745 3744</p>
			<p class="source-code"># cat /proc/3744/attr/current</p>
			<p class="source-code">system_u:system_r:httpd_t:s0</p>
			<p class="calibre3">To receive a somewhat more human-readable output, use the <strong class="source-inline">secon</strong> command for the given process ID:</p>
			<p class="source-code"># secon --pid 3744</p>
			<p class="source-code">user: system_u</p>
			<p class="source-code">role: system_r</p>
			<p class="source-code">type: httpd_t</p>
			<p class="source-code">sensitivity: s0</p>
			<p class="source-code">clearance: s0</p>
			<p class="source-code">mls-range: s0</p>
			<p class="calibre3">Finally, the SELinux user space project has a helper utility called <strong class="source-inline">getpidcon</strong>, which the <strong class="source-inline">libselinux</strong> library optionally provides. Although this utility is not available on CentOS (or related distributions), other distributions such as Gentoo do have it. The utility requires a single PID and returns its context:</p>
			<p class="source-code"># getpidcon 679</p>
			<p class="source-code">system_u:system_r:nginx_t:s0</p>
			<p class="calibre3">Now, the <a id="_idIndexMarker274" class="pcalibre calibre6 pcalibre1"/>Apache processes don't themselves inform SELinux that they need to run in the <strong class="source-inline">httpd_t</strong> (or, for Gentoo, the <strong class="source-inline">nginx_t</strong>) domain. For that, transition rules exist in the SELinux policy that govern when and how processes are executed in a specific domain.</p>
			<h2 id="_idParaDest-121" class="calibre10"><a id="_idTextAnchor123" class="pcalibre calibre6 pcalibre1"/>Transitioning toward a domain</h2>
			<p class="calibre3">Just as we <a id="_idIndexMarker275" class="pcalibre calibre6 pcalibre1"/>have seen with files, if a process forks and creates a new process, this process, by default, inherits the context of the parent process. For the web server, the main process is running in the <strong class="source-inline">httpd_t</strong> domain, so all the launched worker processes inherit the <strong class="source-inline">httpd_t</strong> domain from it.</p>
			<p class="calibre3">To differentiate <a id="_idIndexMarker276" class="pcalibre calibre6 pcalibre1"/>the domain of one process from another, domain transitions can be defined. A <strong class="bold">domain transition</strong> (also known as a process transition or type transition) is a rule in SELinux that tells SELinux another domain is to be used for a forked process (actually, it is when the parent process calls the <strong class="source-inline">execve()</strong> function, most likely after a <strong class="source-inline">fork()</strong> operation).</p>
			<p class="calibre3">Like the file-based transitions, domain transitions can be queried using <strong class="source-inline">sesearch</strong>. Let's investigate the domains allowed to transition to the <strong class="source-inline">httpd_t</strong> domain:</p>
			<p class="source-code">$ sesearch -T -t httpd_exec_t</p>
			<p class="source-code">type_transition certwatch_t httpd_exec_t:process httpd_t;</p>
			<p class="source-code">type_transition cluster_t httpd_exec_t:process httpd_t;</p>
			<p class="source-code">type_transition initrc_t httpd_exec_t:process httpd_t;</p>
			<p class="source-code">...</p>
			<p class="source-code">type_transition system_cronjob_t httpd_exec_t:process httpd_t;</p>
			<p class="calibre3">In this case, SELinux will switch the context of a launched web server to <strong class="source-inline">httpd_t</strong> if the parent process is running in one of the mentioned domains (such as the <strong class="source-inline">initrc_t</strong> domain) and is executing a file labeled as <strong class="source-inline">httpd_exec_t</strong> (the label assigned to the <strong class="source-inline">httpd</strong> and <strong class="source-inline">nginx</strong> binaries).</p>
			<p class="calibre3">But for this to truly happen, several other permissions (next to the domain transition) need to be in place. The following list describes these various permissions:</p>
			<ul class="calibre8">
				<li class="calibre9">The source process (such as <strong class="source-inline">initrc_t</strong>) needs to be allowed to transition to the <strong class="source-inline">httpd_t</strong> domain, governed by the transition privilege on the process class:<p class="source-code"><strong class="bold">$ sesearch -s initrc_t -t httpd_t -c process -p transition -A</strong></p></li>
				<li class="calibre9">The source process (such as <strong class="source-inline">initrc_t</strong>) needs to have the right of execution on the file it is launching (<strong class="source-inline">httpd_exec_t</strong>):<p class="source-code"><strong class="bold">$ sesearch -s initrc_t -t httpd_exec_t -c file -p execute -A</strong></p></li>
				<li class="calibre9">The <strong class="source-inline">httpd_exec_t</strong> type must be identified as an entry point for the <strong class="source-inline">httpd_t</strong> domain. SELinux uses an <strong class="bold">entry point</strong> to ensure that a domain transition only occurs when using the specified file context on the executing binary or script:<p class="source-code"><strong class="bold">$ sesearch -s httpd_t -t httpd_exec_t -c file -p entrypoint -A</strong></p></li>
				<li class="calibre9">The target domain must be allowed for the role that the parent process is in. In the case of system daemons, the role is <strong class="source-inline">system_r</strong>:<p class="source-code"><strong class="bold">$ seinfo -r system_r -x | grep httpd_t</strong></p></li>
			</ul>
			<p class="calibre3">A graphical <a id="_idIndexMarker277" class="pcalibre calibre6 pcalibre1"/>representation of these rights is as follows:</p>
			<div class="calibre13">
				<div id="_idContainer017" class="img---figure">
					<img src="Images/B16276_04_002.jpg" alt="Figure 4.2 – Graphical overview of the necessary transition permissions " class="calibre22"/>
				</div>
			</div>
			<p class="figure-caption">Figure 4.2 – Graphical overview of the necessary transition permissions</p>
			<p class="calibre3">Only when all these privileges are allowed will a domain transition occur. If not, then either the execution of the application fails (if the domain has no <strong class="source-inline">execute</strong> or <strong class="source-inline">execute_no_trans</strong> rights on the file), or it executes but remains running in the same domain as the parent process.</p>
			<p class="calibre3">Domain transitions are an important concept as they inform the administrator how an application gets into its privileged context. To analyze this, many security administrators look at how one context can transition to another. We explain policy analysis in <a href="B16276_13_Final_VK.xhtml#_idTextAnchor330" class="pcalibre calibre6 pcalibre1"><em class="italic">Chapter 13</em></a>, <em class="italic">Analyzing Policy Behavior</em>.</p>
			<p class="calibre3">For policy writers, deciding when to create a domain transition and when to keep the processes running in the same (source) context is a matter of design. Generally, policy developers <a id="_idIndexMarker278" class="pcalibre calibre6 pcalibre1"/>will try to keep the parent context confined so that every additional privilege is a source of consideration for switching to another domain (which has that privilege). Basically, policy developers will trigger a transition when the target application requires significantly more (or different) permissions than the source domain holds.</p>
			<p class="calibre3">That is also why the <strong class="source-inline">unconfined_t</strong> domain has fewer transitions when executing user applications compared to the confined user domains, <strong class="source-inline">user_t</strong> or <strong class="source-inline">guest_t</strong>: the <strong class="source-inline">unconfined_t</strong> domain already holds many privileges, so transitioning to a different domain has little value. Note that this is a decision made by the policy writers or Linux distribution, not by the SELinux technology itself. All SELinux does is enforce the policy rules.</p>
			<h2 id="_idParaDest-122" class="calibre10"><a id="_idTextAnchor124" class="pcalibre calibre6 pcalibre1"/>Verifying a target context</h2>
			<p class="calibre3">When executing applications, the SELinux policy might have the command run in a different domain. Although <a id="_idIndexMarker279" class="pcalibre calibre6 pcalibre1"/>we could start querying all rules with <strong class="source-inline">sesearch</strong>, a simpler command exists that tells us what the target context is when we execute a command or script: <strong class="source-inline">selinuxexeccon</strong>.</p>
			<p class="calibre3">This command requires at least one argument (the path of the binary or script that would be executed) and an optional second (the source context). If we omit the second argument, the tool will use the current context as the source context.</p>
			<p class="calibre3">For instance, to find out in which domain the <strong class="source-inline">passwd</strong> command would run when executed from the current context, we'd use this command:</p>
			<p class="source-code"># selinuxexeccon /usr/bin/passwd</p>
			<p class="source-code">unconfined_u:unconfined_r:passwd_t:s0-s0:c0.c1023</p>
			<p class="calibre3">The following example shows the target context when the <strong class="source-inline">init_t</strong> domain executes the <strong class="source-inline">nginx</strong> binary:</p>
			<p class="source-code"># selinuxexeccon /usr/sbin/nginx system_u:system_r:init_t:s0</p>
			<p class="source-code">system_u:system_r:httpd_t:s0</p>
			<p class="calibre3">Using <strong class="source-inline">selinuxexeccon</strong> is much faster than querying all appropriate permissions separately.</p>
			<h2 id="_idParaDest-123" class="calibre10"><a id="_idTextAnchor125" class="pcalibre calibre6 pcalibre1"/>Other supported transitions</h2>
			<p class="calibre3">Regular <a id="_idIndexMarker280" class="pcalibre calibre6 pcalibre1"/>domain transitions are the most common transitions in SELinux, but other transitions are possible as well. For instance, some applications (such as <strong class="source-inline">cron</strong> or <strong class="source-inline">login</strong>) are SELinux-aware and will specify which domain to transition to. These applications call the <strong class="source-inline">setexeccon()</strong> method (set execution context) to specify the target domain and do not use a type transition rule. The other privilege requirements, however, still hold.</p>
			<p class="calibre3">Some SELinux-aware applications are even able to change their <em class="italic">current</em> context (and not just the context of the application they execute). To accomplish this, the application domain needs the <strong class="source-inline">dyntransition</strong> privilege (one of the privileges supported for process-level activities). One example of such an application is OpenSSH, which, by default, runs in the <strong class="source-inline">sshd_t</strong> domain but can transition to the <strong class="source-inline">sftpd_t</strong> type.</p>
			<h2 id="_idParaDest-124" class="calibre10"><a id="_idTextAnchor126" class="pcalibre calibre6 pcalibre1"/>Querying initial contexts</h2>
			<p class="calibre3">When SELinux <a id="_idIndexMarker281" class="pcalibre calibre6 pcalibre1"/>does not have a label yet for a resource, it will <a id="_idIndexMarker282" class="pcalibre calibre6 pcalibre1"/>assign an initial context (or initial <strong class="bold">security ID</strong> (<strong class="bold">SID</strong>)) to the resource. For a few classes, the SELinux policy will have a default initial context from which it can further jumpstart and assign labels.</p>
			<p class="calibre3">The initial contexts for various SIDs can be queried using <strong class="source-inline">seinfo</strong>:</p>
			<p class="source-code"># seinfo --initalsid -x</p>
			<p class="source-code">Initial SIDs: 27</p>
			<p class="source-code">  sid any_socket system_u:object_r:unlabeled_t:s0</p>
			<p class="source-code">  sid devnull system_u:object_r:null_device_t:s0</p>
			<p class="source-code">...</p>
			<p class="source-code">  sid unlabeled system_u:object_r:unlabeled_t:s0</p>
			<p class="calibre3">As you can see, not all classes have a default context assigned, as other classes have their contexts derived from the contexts of the currently listed initial SIDs.</p>
			<h2 id="_idParaDest-125" class="calibre10"><a id="_idTextAnchor127" class="pcalibre calibre6 pcalibre1"/>Tweaking memory protections</h2>
			<p class="calibre3">Legacy binaries <a id="_idIndexMarker283" class="pcalibre calibre6 pcalibre1"/>on Linux systems might require execution permissions to be set on memory regions when these are used for reading, even when the execute permission is not actually used. This read-implies-exec is a nuisance for mandatory access controls such as SELinux because they need to document the appropriate permissions in their policy. If an application needs read access, does the policy then also have to include the implied execute rights? And if the policy does not include execute rights, should the read operation then fail because it implied execute permissions?</p>
			<p class="callout-heading">Informational note</p>
			<p class="callout">Read-implies-exec is a legacy support for running old binaries or binaries compiled for other Unix systems where applications do not explicitly mark their executable memory as executable, assuming that every memory region that is marked as readable is executable. This creates a security risk as malicious actors can load in executable code dynamically without the system being able to prevent the application to execute this code. Many operating systems nowadays have clear memory protection routines in place, including preventing data from becoming executable. Sadly, we often need to deal with legacy situations, so all operating systems have methods in place that selectively disable these memory controls, and within Linux this is done through its <strong class="bold">personalities</strong> support (see <strong class="source-inline">man personality</strong> for more information).</p>
			<p class="calibre3">SELinux developers allow administrators to select their most appropriate permission handling by introducing a memory protection check that can be tuned. The <strong class="source-inline">checkreqprot</strong> option can <a id="_idIndexMarker284" class="pcalibre calibre6 pcalibre1"/>be set to <strong class="source-inline">0</strong> to check protections as handled by the kernel, or <strong class="source-inline">1</strong> to check protections as asked by the application.</p>
			<p class="calibre3">On older systems, this option will be set to <strong class="source-inline">1</strong> to support these legacy binaries. Recent distributions, however, build their applications appropriately, and the more secure setting <strong class="source-inline">0</strong> is used, as displayed by the <strong class="source-inline">sestatus</strong> command:</p>
			<p class="source-code"># sestatus | grep Memory</p>
			<p class="source-code">Memory protection checking:   actual (secure)</p>
			<p class="calibre3">You can toggle this support through <strong class="source-inline">/sys/fs/selinux/checkreqprot</strong>:</p>
			<p class="source-code"># echo 1 &gt; /sys/fs/selinux/checkreqprot</p>
			<p class="source-code"># sestatus | grep Memory</p>
			<p class="source-code">Memory protection checking:   requested (insecure)</p>
			<p class="calibre3">The parameter's default value is configured when building the Linux kernel, through the <strong class="source-inline">CONFIG_SECURITY_SELINUX_CHECKREQPROT_VALUE</strong> kernel configuration parameter. Administrators can also boot the system with the <strong class="source-inline">checkreqprot=</strong> boot parameter to have the specified value set.</p>
			<h1 id="_idParaDest-126" class="calibre5"><a id="_idTextAnchor128" class="pcalibre calibre6 pcalibre1"/>Limiting the scope of transitions</h1>
			<p class="calibre3">For security <a id="_idIndexMarker285" class="pcalibre calibre6 pcalibre1"/>reasons, Linux systems can reduce the ability of processes to gain elevated privileges under certain situations or provide additional constraints to reduce the likelihood of vulnerabilities to be exploitable. SELinux developers, too, honor these situations.</p>
			<h2 id="_idParaDest-127" class="calibre10"><a id="_idTextAnchor129" class="pcalibre calibre6 pcalibre1"/>Sanitizing environments on transition</h2>
			<p class="calibre3">When we <a id="_idIndexMarker286" class="pcalibre calibre6 pcalibre1"/>execute a higher-privileged command (be it a <strong class="source-inline">setuid</strong> application or one where capabilities are added to the session), the <strong class="bold">GNU C library</strong> (<strong class="bold">glibc</strong>) will <a id="_idIndexMarker287" class="pcalibre calibre6 pcalibre1"/>sanitize the environment. This means that a set of security-sensitive environment variables are discarded to make sure that attackers, malicious persons, or malicious applications cannot negatively influence the session.</p>
			<p class="calibre3">This <a id="_idIndexMarker288" class="pcalibre calibre6 pcalibre1"/>secure execution is controlled through an <strong class="bold">Executable and Linkable Format</strong> (<strong class="bold">ELF</strong>) auxiliary <a id="_idIndexMarker289" class="pcalibre calibre6 pcalibre1"/>vector called <strong class="bold">AT_SECURE</strong>. When set, environment variables such as <strong class="source-inline">LD_PRELOAD</strong>, <strong class="source-inline">LD_AUDIT</strong>, <strong class="source-inline">LD_DEBUG</strong>, <strong class="source-inline">TMPDIR</strong>, and <strong class="source-inline">NLSPATH</strong> are removed from the session.</p>
			<p class="calibre3">SELinux will force this sanitation on domain transitions as well, ensuring that the newly executed domain does not have access to these sensitive environment variables. Of course, sometimes the transitioned domain requires these variables. Not all domains can deal with sanitized environments, or use these environment variables to pass along important information, so always dropping the environment variables might result in unusable application domains.</p>
			<p class="calibre3">To allow transitions without sanitizing the environment, the <strong class="source-inline">noatsecure</strong> permission can be granted to domain transitions. For instance, let's consider the execution of a Firefox plugin:</p>
			<p class="source-code"># sesearch -t mozilla_plugin_t -p noatsecure -A</p>
			<p class="source-code">...</p>
			<p class="source-code">allow unconfined_t mozilla_plugin_t:process { ... noatsecure ...};</p>
			<p class="source-code">...</p>
			<p class="calibre3">When an application running in the <strong class="source-inline">unconfined_t</strong> domain executes the plugin (which results in a domain transition to <strong class="source-inline">mozilla_plugin_t</strong>), the environment variables need to be kept as otherwise the plugin might not function properly. As such, the SELinux policy grants the <strong class="source-inline">noatsecure</strong> permission to the domains that invoke Firefox plugins.</p>
			<h2 id="_idParaDest-128" class="calibre10"><a id="_idTextAnchor130" class="pcalibre calibre6 pcalibre1"/>Disabling unconstrained transitions</h2>
			<p class="calibre3">A second <a id="_idIndexMarker290" class="pcalibre calibre6 pcalibre1"/>security constraint that Linux supports is to mount a filesystem with the <strong class="source-inline">nosuid</strong> option. When set, no <strong class="source-inline">setuid</strong> and <strong class="source-inline">setgid</strong> binaries on that filesystem will have any effect on the effective user or group ID of the executing session. Essentially, a <strong class="source-inline">setuid</strong> application on a filesystem mounted with <strong class="source-inline">nosuid</strong> will act as if no <strong class="source-inline">setuid</strong> bit is set.</p>
			<p class="calibre3">To ensure that transitions triggered by applications hosted on a <strong class="source-inline">nosuid</strong>-mounted filesystem do not allow for elevated privileges, SELinux policy developers must explicitly mark a transition as allowed for <strong class="source-inline">nosuid</strong>-mounted filesystems, using the <strong class="source-inline">nosuid_transition</strong> permission. This permission is part of the <strong class="source-inline">process2</strong> class:</p>
			<p class="source-code">$ sesearch -s unconfined_t -p nosuid_transition -A</p>
			<p class="source-code">allow unconfined_t initrc_t:process2 { nnp_transition nosuid_transition };</p>
			<p class="source-code">...</p>
			<p class="calibre3">This allows policy developers to differentiate regular domain transitions from <strong class="source-inline">nosuid</strong>-constrained domain transitions.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">SELinux has a limit on the number of privileges that can be assigned to a class. When the number of privileges exceeds 32, the SELinux developers will create a different class and the permissions continue in this second class. Right now, the two classes that have more than 32 permissions are the <strong class="source-inline">capability</strong> class and the <strong class="source-inline">process</strong> class.</p>
			<p class="calibre3">This permission-based approach might not be in place on all SELinux-enabled systems though. It is enabled when the <strong class="source-inline">nnp_nosuid_transition</strong> policy capability is defined and set to <strong class="source-inline">1</strong>:</p>
			<p class="source-code"># cat /sys/fs/selinux/policy_capabilities/nnp_nosuid_transition</p>
			<p class="source-code">1</p>
			<p class="calibre3">If this<a id="_idIndexMarker291" class="pcalibre calibre6 pcalibre1"/> capability value is <strong class="source-inline">0</strong>, then SELinux will use a concept called <strong class="bold">type bounds</strong> to support domain transitions for applications hosted on <strong class="source-inline">nosuid</strong>-mounted filesystems. Any executable with a file context that would result in a domain transition will only result in a domain transition if the target domain is bounded by the parent domain.</p>
			<p class="callout-heading">Note</p>
			<p class="callout"><strong class="bold">Policy capabilities</strong> cannot <a id="_idIndexMarker292" class="pcalibre calibre6 pcalibre1"/>be tweaked by administrators. They are used by policy developers to inform the Linux kernel which behavior it expects. For the <strong class="source-inline">nnp_nosuid_transition</strong> capability, the policy developer informs the kernel that the <strong class="source-inline">nosuid_transition</strong> and <strong class="source-inline">nnp_transition</strong> permission checks should be used rather than bounded domains, and that its policy will generally only include support for the transitions and not for the bounded domains.</p>
			<p class="calibre3">If it is not bounded, then the domain transition will not occur, and the session will remain in the current <a id="_idIndexMarker293" class="pcalibre calibre6 pcalibre1"/>context (or the command will fail to execute if the application is not allowed to run in the current context).</p>
			<p class="calibre3">A <strong class="bold">bounded domain</strong> is not just calculated live based on the permissions though. SELinux has an <a id="_idIndexMarker294" class="pcalibre calibre6 pcalibre1"/>explicit rule that enforces a target domain to be bounded by a parent domain. Even when permissions are later added to the bounded domain, they will be denied by the SELinux security subsystem if they aren't part of the parent domain.</p>
			<p class="calibre3">With <strong class="source-inline">seinfo</strong>, these type bounds can be listed as follows:</p>
			<p class="source-code"># seinfo --typebounds</p>
			<p class="calibre3">Most distributions, however, do not have bounded domains defined in their SELinux policy anymore, as the new <strong class="source-inline">nosuid_transition</strong> permission is much more flexible. The use of bounded domains required policy developers to extend the permissions of the parent domain every time the child domain needed to be extended, which was a major nuisance when the parent domain is a generic one (be it a container management platform or a system service daemon).</p>
			<h2 id="_idParaDest-129" class="calibre10"><a id="_idTextAnchor131" class="pcalibre calibre6 pcalibre1"/>Using Linux's NO_NEW_PRIVS</h2>
			<p class="calibre3">The use <a id="_idIndexMarker295" class="pcalibre calibre6 pcalibre1"/>of filesystems mounted with <strong class="source-inline">nosuid</strong> is a specific case of Linux's <strong class="bold">No New Privilege</strong> (<strong class="bold">NNP</strong>) support. NNP is a process-specific <a id="_idIndexMarker296" class="pcalibre calibre6 pcalibre1"/>attribute that tells the Linux kernel that the process is no longer to be granted additional privileges. From that point onward, the constraints as mentioned before hold, and SELinux will only allow domain transitions if it has the <strong class="source-inline">nnp_transition</strong> permission, or toward a bounded domain if the <strong class="source-inline">nnp_nosuid_transition</strong> policy capability is not set.</p>
			<p class="calibre3">The parameter can be set by applications themselves using the process control function <strong class="source-inline">prctl()</strong>, but the user can also influence this. The <strong class="source-inline">setpriv</strong> command can be used to launch applications with <strong class="source-inline">PR_SET_NO_NEW_PRIVS</strong> set (the parameter that applications can pass through the <strong class="source-inline">prctl()</strong> function).</p>
			<p class="calibre3">As an example, create the following simple Python-based CGI script in a <strong class="source-inline">cgi-bin</strong> directory inside a regular user's home directory:</p>
			<p class="source-code">#!/usr/bin/env python3</p>
			<p class="source-code">import sys, time</p>
			<p class="source-code">import subprocess</p>
			<p class="source-code">import cgi, cgitb</p>
			<p class="source-code">cgitb.enable()</p>
			<p class="source-code">print('Content-Type: text/html;charset=utf-8\n')</p>
			<p class="source-code">PIPE = subprocess.PIPE</p>
			<p class="source-code">STDOUT = subprocess.STDOUT</p>
			<p class="source-code">pd = subprocess.Popen(['ping', '-c', '1', 'localhost'], </p>
			<p class="source-code">stdout=PIPE, stderr=STDOUT)</p>
			<p class="source-code">while True:</p>
			<p class="source-code">  output = pd.stdout.read(1)</p>
			<p class="source-code">  if output == '' and pd.poll() != None:</p>
			<p class="source-code">    break</p>
			<p class="source-code">  if output != '':</p>
			<p class="source-code">    sys.stdout.write(output.decode('utf-8'))</p>
			<p class="source-code">    sys.stdout.flush()</p>
			<p class="calibre3">With this CGI script now available, first launch a simple CGI-capable web server (we will pick port <strong class="source-inline">6020</strong> as unprivileged users should be able to bind processes to this port) and connect to it:</p>
			<p class="source-code">$ python3 -m http.server --cgi 6020</p>
			<p class="calibre3">In a <a id="_idIndexMarker297" class="pcalibre calibre6 pcalibre1"/>different session, connect to the web server and call the newly created Python script (here named <strong class="source-inline">test.py</strong>):</p>
			<p class="source-code">$ curl http://localhost:6020/cgi-bin/test.py</p>
			<p class="source-code">PING localhost(localhost(::1)) 56 data bytes ...</p>
			<p class="calibre3">Now, launch the same CGI-capable web server, but with NNP enabled:</p>
			<p class="source-code">$ setpriv --no-new-privs python3 -m http.server --cgi 6020</p>
			<p class="calibre3">Again, connect to the web server and call the <strong class="source-inline">test.py</strong> CGI script:</p>
			<p class="source-code">$ curl http://localhost:6020/cgi-bin/test.py</p>
			<p class="source-code">ping: socket: Permission denied</p>
			<p class="calibre3">Because Linux's NNP is enabled, the <strong class="source-inline">ping</strong> command is not able to obtain the higher privileges needed to open the socket.</p>
			<p class="calibre3">Sometimes, you'll notice a denial for the <strong class="source-inline">execute_no_trans</strong> permission in the SELinux audit logs. This occurs when the SELinux policy does not allow an application to be executed without transitioning.</p>
			<h1 id="_idParaDest-130" class="calibre5"><a id="_idTextAnchor132" class="pcalibre calibre6 pcalibre1"/>Types, permissions, and constraints</h1>
			<p class="calibre3">Now that <a id="_idIndexMarker298" class="pcalibre calibre6 pcalibre1"/>we know more about types (for processes, files, and <a id="_idIndexMarker299" class="pcalibre calibre6 pcalibre1"/>other resources), let's explore how these are used in the SELinux <a id="_idIndexMarker300" class="pcalibre calibre6 pcalibre1"/>policy in more detail.</p>
			<h2 id="_idParaDest-131" class="calibre10"><a id="_idTextAnchor133" class="pcalibre calibre6 pcalibre1"/>Understanding type attributes</h2>
			<p class="calibre3">We have <a id="_idIndexMarker301" class="pcalibre calibre6 pcalibre1"/>discussed the <strong class="source-inline">sesearch</strong> application already and how it can be used to query the current SELinux policy. Let's look at a specific process transition:</p>
			<p class="source-code">$ sesearch -s initrc_t -t httpd_t -c process -p transition -A</p>
			<p class="source-code">allow initrc_domain daemon:process transition;</p>
			<p class="calibre3">Even though we asked for the rules related to the <strong class="source-inline">initrc_t</strong> source domain and the <strong class="source-inline">httpd_t</strong> target, we get a rule back for the <strong class="source-inline">initrc_domain</strong> source domain and the <strong class="source-inline">daemon</strong> target. What <strong class="source-inline">sesearch</strong> did here was show us how the SELinux policy allows the requested permission, but through <em class="italic">attributes</em> assigned to the <strong class="source-inline">initrc_t</strong> and <strong class="source-inline">httpd_t</strong> types.</p>
			<p class="calibre3"><strong class="bold">Type attributes</strong> in SELinux <a id="_idIndexMarker302" class="pcalibre calibre6 pcalibre1"/>are used to group multiple types and assign privileges to those groups rather than having to assign the privileges to each type individually. For <strong class="source-inline">initrc_domain</strong>, the following types are all tagged with this attribute, as can be seen through the <strong class="source-inline">seinfo</strong> application:</p>
			<p class="source-code">$ seinfo -a initrc_domain -x</p>
			<p class="source-code">Type Attributes: 1</p>
			<p class="source-code">  attribute initrc_domain;</p>
			<p class="source-code">    cluster_t;</p>
			<p class="source-code">    ...</p>
			<p class="source-code">    initrc_t;</p>
			<p class="source-code">    ...</p>
			<p class="source-code">    piranha_pulse_t;</p>
			<p class="calibre3">As we <a id="_idIndexMarker303" class="pcalibre calibre6 pcalibre1"/>can see, the <strong class="source-inline">initrc_t</strong> type is indeed one of the types tagged with <strong class="source-inline">initrc_domain</strong>. Similarly, the <strong class="source-inline">daemon</strong> attribute is assigned to several types (several hundred, even). So, the single allow rule mentioned earlier consolidates more than a thousand rules into one.</p>
			<p class="calibre3">Attributes are increasingly used in the policy as a way of consolidating and simplifying policy development. With <strong class="source-inline">seinfo -a</strong>, you can get an overview of all the attributes supported in the current policy. </p>
			<h2 id="_idParaDest-132" class="calibre10"><a id="_idTextAnchor134" class="pcalibre calibre6 pcalibre1"/>Querying domain permissions</h2>
			<p class="calibre3">The most <a id="_idIndexMarker304" class="pcalibre calibre6 pcalibre1"/>common rules in SELinux are the <strong class="source-inline">allow</strong> rules, informing the SELinux subsystem what permissions a domain has. <strong class="source-inline">allow</strong> rules use the following syntax:</p>
			<p class="source-code">allow &lt;source&gt; &lt;destination&gt; : &lt;class&gt; &lt;permissions&gt;;</p>
			<p class="calibre3">The <strong class="source-inline">&lt;source&gt;</strong> field is almost always a domain, whereas the <strong class="source-inline">&lt;destination&gt;</strong> field can be any type.</p>
			<p class="calibre3">The <strong class="source-inline">&lt;class&gt;</strong> field allows us to differentiate privileges based on the resource, whether it is for a regular file, a directory, a TCP socket, a capability, and so on. A full overview of all supported classes can be obtained from <strong class="source-inline">seinfo -c</strong>. Each class has a set of permissions assigned to it that SELinux can control. For instance, the <strong class="source-inline">sem</strong> class (used for semaphore access) has the following permissions associated with it:</p>
			<p class="source-code">$ seinfo -c sem -x</p>
			<p class="source-code">Classes: 1</p>
			<p class="source-code">  class sem</p>
			<p class="source-code">inherits ipc</p>
			<p class="calibre3">The reference to <strong class="source-inline">ipc</strong> in the output informs us that the class inherits permission from the common <strong class="source-inline">ipc</strong> class, which we can query as follows:</p>
			<p class="source-code">$ seinfo --common=ipc -x</p>
			<p class="source-code">Commons: 1</p>
			<p class="source-code">{</p>
			<p class="source-code">  write</p>
			<p class="source-code">  destroy</p>
			<p class="source-code">  ...</p>
			<p class="source-code">  create</p>
			<p class="source-code">}</p>
			<p class="calibre3">In the <strong class="source-inline">&lt;permissions&gt;</strong> field, most rules will bundle a set of permissions using curly brackets:</p>
			<p class="source-code">allow user_t etc_t : file { ioctl read getattr lock execute execute_no_trans open };</p>
			<p class="calibre3">This syntax <a id="_idIndexMarker305" class="pcalibre calibre6 pcalibre1"/>allows policy developers to make very fine-grained permission controls. We can use the <strong class="source-inline">sesearch</strong> command to query these rules. The more options are given to the <strong class="source-inline">sesearch</strong> command, the finer-grained our search parameters become. For instance, <strong class="source-inline">sesearch -A</strong> would give us all allow rules currently in place. Adding a source (<strong class="source-inline">-s</strong>) filters the output to only show the allow rules for this domain. Adding a destination or target (<strong class="source-inline">-t</strong>) filters the output even more. Other options that can be used to filter through allow rules with <strong class="source-inline">sesearch</strong> are the class (<strong class="source-inline">-c</strong>) and permission (<strong class="source-inline">-p</strong>) options.</p>
			<p class="calibre3">As you might have guessed by now, <strong class="source-inline">sesearch</strong> is an extremely versatile command for querying <a id="_idIndexMarker306" class="pcalibre calibre6 pcalibre1"/>the active policy, showing us the SELinux policy rules that match the options given.</p>
			<h2 id="_idParaDest-133" class="calibre10"><a id="_idTextAnchor135" class="pcalibre calibre6 pcalibre1"/>Learning about constraints</h2>
			<p class="calibre3">The <strong class="source-inline">allow</strong> statements in SELinux, however, only focus on type-related permissions. Sometimes <a id="_idIndexMarker307" class="pcalibre calibre6 pcalibre1"/>though, we need to restrict certain actions based on the user or role information. SELinux supports this through constraints.</p>
			<p class="calibre3"><strong class="bold">Constraints</strong> in SELinux <a id="_idIndexMarker308" class="pcalibre calibre6 pcalibre1"/>are rules applied against a class and a set of its permissions that must be true for SELinux to further allow the request. Consider the following constraint on process transitions:</p>
			<p class="source-code">constrain process</p>
			<p class="source-code">  { transition dyntransition noatsecure siginh rlimitinh }</p>
			<p class="source-code">  (</p>
			<p class="source-code">    u1 == u2 or</p>
			<p class="source-code">    (</p>
			<p class="source-code">      t1 == can_change_process_identity and</p>
			<p class="source-code">      t2 == process_user_target</p>
			<p class="source-code">    ) or (</p>
			<p class="source-code">      t1 == cron_source_domain and</p>
			<p class="source-code">      (</p>
			<p class="source-code">        t2 == cron_job_domain or</p>
			<p class="source-code">        u2 == system_u</p>
			<p class="source-code">      )</p>
			<p class="source-code">    ) or (</p>
			<p class="source-code">      t1 == can_system_change and</p>
			<p class="source-code">      u2 == system_u</p>
			<p class="source-code">    ) or (</p>
			<p class="source-code">      t1 == process_uncond_exempt</p>
			<p class="source-code">    )</p>
			<p class="source-code">  );</p>
			<p class="calibre3">This constraint says that at least one of the following rules must be true if a <strong class="source-inline">transition</strong>, <strong class="source-inline">dyntransition</strong>, or any of the other three mentioned process permissions is invoked:</p>
			<ul class="calibre8">
				<li class="calibre9">The SELinux user of the source (<strong class="source-inline">u1</strong>) and that of the target (<strong class="source-inline">u2</strong>) must be the same.</li>
				<li class="calibre9">The SELinux type of the source (<strong class="source-inline">t1</strong>) must have the <strong class="source-inline">can_change_process_identity</strong> attribute set, and the SELinux type of the target (<strong class="source-inline">t2</strong>) must have the <strong class="source-inline">process_user_target</strong> attribute set.</li>
				<li class="calibre9">The SELinux type of the source (<strong class="source-inline">t1</strong>) must have the <strong class="source-inline">cron_source_domain</strong> attribute set, and either the target type (<strong class="source-inline">t2</strong>) should have <strong class="source-inline">cron_job_domain</strong> as an attribute, or the target SELinux user (<strong class="source-inline">u2</strong>) should be <strong class="source-inline">system_u</strong>.</li>
				<li class="calibre9">The SELinux type of the source (<strong class="source-inline">t1</strong>) must have the <strong class="source-inline">can_system_change</strong> attribute set, and the SELinux user of the target (<strong class="source-inline">u2</strong>) must be <strong class="source-inline">system_u</strong>.</li>
				<li class="calibre9">The SELinux type of the source (<strong class="source-inline">t1</strong>) must have the <strong class="source-inline">process_uncond_exempt</strong> attribute set.</li>
			</ul>
			<p class="calibre3">It is <a id="_idIndexMarker309" class="pcalibre calibre6 pcalibre1"/>through constraints that UBAC is implemented as follows:</p>
			<p class="source-code">u1 == u2</p>
			<p class="source-code">or u1 == system_u</p>
			<p class="source-code">or u2 == system_u</p>
			<p class="source-code">or t1 != ubac_constrained_type</p>
			<p class="source-code">or t2 != ubac_constrained_type</p>
			<p class="calibre3">You can list the currently enabled constraints using <strong class="source-inline">seinfo --constrain</strong>. Multiple constraints can be active for the same class and permission set. In that case, all the constraints need to be true for the permission to go through.</p>
			<h1 id="_idParaDest-134" class="calibre5"><a id="_idTextAnchor136" class="pcalibre calibre6 pcalibre1"/>Summary</h1>
			<p class="calibre3">In this chapter, we learned how file contexts are stored as extended attributes on the filesystem and how we can manipulate the contexts of files and other filesystem resources. Next, we found out where SELinux keeps the definitions that describe which SELinux contexts to assign to the files.</p>
			<p class="calibre3">We also learned to work with the <strong class="source-inline">semanage</strong> tool to manipulate this information and worked with a few tools that use this information to enforce contexts on resources.</p>
			<p class="calibre3">On the process level, we got our first taste of SELinux policies, identifying when a process launches inside a certain SELinux domain. With it, we covered the <strong class="source-inline">sesearch</strong> and <strong class="source-inline">seinfo</strong> applications to query the SELinux policy. Finally, we looked at some of Linux's security implementations that limit the transition scope of applications, which also influences SELinux domain transitions.</p>
			<p class="calibre3">In the next chapter, we will expand our knowledge of protecting the operating system through the networking-related features of SELinux.</p>
			<h1 id="_idParaDest-135" class="calibre5"><a id="_idTextAnchor137" class="pcalibre calibre6 pcalibre1"/>Questions</h1>
			<ol class="calibre18">
				<li value="1" class="calibre9">What is the most common option for Linux tools to display or explicitly set SELinux contexts?</li>
				<li class="calibre9">How is an SELinux context for a file or directory stored on the system?</li>
				<li class="calibre9">Why is <strong class="source-inline">chcon</strong> not recommended to persist SELinux context changes?</li>
				<li class="calibre9">Is the order of context definitions using the <strong class="source-inline">semanage fcontext</strong> command important?</li>
				<li class="calibre9">How do you relabel files on the filesystem?</li>
				<li class="calibre9">What privileges does a domain need before it can transition to another domain?</li>
				<li class="calibre9">How do SELinux policies bundle multiple types together to facilitate policy development?</li>
			</ol>
		</div>
	</div></body></html>