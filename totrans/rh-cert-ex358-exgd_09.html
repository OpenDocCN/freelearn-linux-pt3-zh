<html><head></head><body>
		<div id="_idContainer256">
			<h1 id="_idParaDest-96" class="chapter-number"><a id="_idTextAnchor104"/>9</h1>
			<h1 id="_idParaDest-97"><a id="_idTextAnchor105"/>Comprehensive Review and Test Exam Questions</h1>
			<p>In this chapter, we will go over the different things we have learned throughout this book. We will be working through mock exam questions that will help familiarize you with the format of questions that you may encounter on the exam. We will attempt to cover all things that could possibly be on the exam per the public listed information by Red Hat, which can be found <span class="No-Break">here: </span><a href="https://www.redhat.com/en/services/training/ex358-red-hat-certified-specialist-services-management-automation-exam?section=Objectives"><span class="No-Break">https://www.redhat.com/en/services/training/ex358-red-hat-certified-specialist-services-management-automation-exam?section=Objectives</span></a><span class="No-Break">.</span></p>
			<p>The outcome of this chapter will be preparing you fully to take the exam confidently and give you the information needed for you to pass the exam. We will go into other things that may not have been touched on in the book until now but will explain each topic as we go. We will also be covering the request to complete each question manually and to also do so with Ansible Automation. Let’s <span class="No-Break">get started.</span></p>
			<p>In this chapter, we’re going to cover <span class="No-Break">the following:</span></p>
			<ul>
				<li>A comprehensive review of all exam objectives and mock exams for you to test your <span class="No-Break">newfound skills</span></li>
			</ul>
			<h1 id="_idParaDest-98"><a id="_idTextAnchor106"/>Technical requirements</h1>
			<p>We will be using the setup of the systems that is used in <a href="B18607_01.xhtml#_idTextAnchor016"><span class="No-Break"><em class="italic">Chapter 1</em></span></a>, <em class="italic">Block Storage – Learning How to Provision Block Storage on Red Hat Enterprise Linux</em>. We will utilize this setup along with the setup from the additional <strong class="bold">Network Interface Controllers</strong> (<strong class="bold">NICs</strong>) for the teaming exercise, which can be found in <a href="B18607_03.xhtml#_idTextAnchor039"><span class="No-Break"><em class="italic">Chapter 3</em></span></a>, <em class="italic">Link Aggregation Creation – Creating Your Own Link and Mastering the Networking Domain</em>. This will allow you to utilize all the upcoming questions as if you were in a <span class="No-Break">test environment.</span></p>
			<h2 id="_idParaDest-99"><a id="_idTextAnchor107"/>Setting up GitHub access</h2>
			<p>Please refer to the instructions found in <a href="B18607_01.xhtml#_idTextAnchor016"><span class="No-Break"><em class="italic">Chapter 1</em></span></a>, <em class="italic">Block Storage – Learning How to Provision Block Storage on Red Hat Enterprise Linux</em>, to gain access to GitHub for the book’s repo. You will find the Ansible Automation playbooks for this chapter at the following link: <a href="https://github.com/PacktPublishing/Red-Hat-Certified-Specialist-in-Services-Management-and-Automation-EX358-Exam-Guide/tree/main/Chapter09">https://github.com/PacktPublishing/Red-Hat-Certified-Specialist-in-Services-Management-and-Automation-EX358-Exam-Guide/tree/main/Chapter09</a>. Remember these are suggested playbooks and are not the only way you can write them to make them work <span class="No-Break">for you.</span></p>
			<p>You can always change them up using <strong class="source-inline">raw</strong>, <strong class="source-inline">shell</strong>, or <strong class="source-inline">cmd</strong> to achieve the same results, but we are demonstrating the best way to accomplish the goals. Also, keep in mind that we are not using the FCQN that is needed in future versions of Ansible, as that will not be supported in the exam, as it tests against <span class="No-Break">Ansible 2.9.</span></p>
			<h1 id="_idParaDest-100"><a id="_idTextAnchor108"/>A comprehensive review of all exam objectives and mock exams for you to test your newfound skills</h1>
			<p>We will present a mock exam with a mix of questions based on the skills you have learned throughout the entire book. We will go into more <a id="_idTextAnchor109"/>detail based on the items that you might run into in the exam itself. This will help prepare you to take the EX358 exam. These are not official<a id="_idIndexMarker540"/> questions; otherwise, they would not be provided in this book. Instead, they are theoretical scenarios you may face with differing information. Please set up your configuration as noted at the beginning of the chapter and then take note of your IP addresses, system names, and so on. This will allow you to grab the needed information fast for use within the exam so that you are not slowed down, as you only have <span class="No-Break">4 hours.</span></p>
			<p>Let’s get started with the exam. We will start with the information for my lab to give you an idea of how to write this out for <span class="No-Break">your setup:</span></p>
			<pre class="source-code">
Username: emcleroy
Password: redhat
Admin username: root
Admin password: redhat
Node1: rhel1.example.com 192.168.1.198
Node2: rhel2.example.com 192.168.1.133
Node3: rhel3.example.com 192.168.1.53   Ansible control node</pre>
			<p>You can see that I have access to the information I need. If you set up your configuration to use hostnames through either DNS or your host file, you can connect to your devices easily. This also makes using the inventory a little easier in the Ansible inventory, as you do not have to add the <strong class="source-inline">ansible_host</strong> parameter. For our purposes, I will still be using <strong class="source-inline">ansible_host</strong> in my <span class="No-Break">inventory file.</span></p>
			<p>Another thing that makes everything easier is setting up RSA keys and sharing them across the system instead of using passwords. This is shown in the <a href="B18607_01.xhtml#_idTextAnchor016"><span class="No-Break"><em class="italic">Chapter 1</em></span></a>, <em class="italic">Block Storage – Learning How to Provision Block Storage on Red Hat Enterprise Linux</em>, setup process as well. This makes running the playbooks easier, as they do not need to be run with the <strong class="source-inline">-u emcleroy -k --ask-become</strong> portion of the command added to pass the SSH and the <a id="_idIndexMarker541"/>escalated privilege password. We will be using the command with the extra parameters to make sure that you understand how to use the full command, if necessary, during <span class="No-Break">the exam.</span></p>
			<p>After you have set up your system as required, we will get started with the mock exam and go through each topic to review the items we have learned about. The questions will be in the order laid out by Red Hat on the objectives page found <span class="No-Break">here: </span><a href="https://www.redhat.com/en/services/training/ex358-red-hat-certified-specialist-services-management-automation-exam?section=Objectives"><span class="No-Break">https://www.redhat.com/en/services/training/ex358-red-hat-certified-specialist-services-management-automation-exam?section=Objectives</span></a><span class="No-Break">.</span></p>
			<p>The questions follow. The answers will come directly after the questions, but please try to answer the questions without looking at the answers. I recommend attempting the questions once by yourself before looking at the solution. If you get feel stuck, feel free to read the answers and go through the solution to refresh <span class="No-Break">your memory.</span></p>
			<h2 id="_idParaDest-101"><a id="_idTextAnchor110"/>Managing network services</h2>
			<p>Managing <a id="_idIndexMarker542"/>network services is our first objective as noted by Red Hat for <span class="No-Break">this exam.</span></p>
			<p>First up, we will set up IP connectivity for the <span class="No-Break">network interfaces.</span></p>
			<p><em class="italic">Question 1</em> – For this question, we would like you to provision the NICs on the servers with static addresses. Using the DHCP IP addresses, we would like you to change to the static IPs that were noted at the start of the instructions. (These will differ depending on <span class="No-Break">your network):</span></p>
			<pre class="source-code">
Rhel1 DHCP IP: 192.168.1.81
Rhel2 DHCP IP: 192.168.1.65
Rhel1 Static IP: 192.168.1.198
Rhel2 Static IP: 192.168.1.133
The subnet is 192.168.1.0/24</pre>
			<p>Once these are set up<a id="_idIndexMarker543"/> statically, you should be able to route between <span class="No-Break">the two.</span></p>
			<p><em class="italic">Answer 1</em> – To set a static IP up manually, we will need to SSH to the device using the DHCP IP addresses and then modify them to the <span class="No-Break">static addresses.</span></p>
			<p>First, we will use the <span class="No-Break"><strong class="source-inline">nmtui</strong></span><span class="No-Break"> command:</span></p>
			<div>
				<div id="_idContainer221" class="IMG---Figure">
					<img src="image/Figure_9.01_B18607.jpg" alt="Figure 9.1 – NetworkManager TUI initial display"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.1 – NetworkManager TUI initial display</p>
			<p>We will then choose<a id="_idIndexMarker544"/> to edit the connection and, from there, you will see the interfaces available, as shown in the <span class="No-Break">following screenshot:</span></p>
			<div>
				<div id="_idContainer222" class="IMG---Figure">
					<img src="image/Figure_9.02_B18607.jpg" alt="Figure 9.2 – NMTUI interface choices"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.2 – NMTUI interface choices</p>
			<p>After choosing which interface to <a id="_idIndexMarker545"/>change, we will then move on to the settings to enable a static IP, as shown in the <span class="No-Break">following screenshot:</span></p>
			<div>
				<div id="_idContainer223" class="IMG---Figure">
					<img src="image/Figure_9.03_B18607.jpg" alt="Figure 9.3 – Manual setting choice for the selected interface"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.3 – Manual setting choice for the selected interface</p>
			<p>We will then configure<a id="_idIndexMarker546"/> the required settings, such as the static IP, gateway, and DNS server, as shown in the <span class="No-Break">following screenshot:</span></p>
			<div>
				<div id="_idContainer224" class="IMG---Figure">
					<img src="image/Figure_9.04_B18607.jpg" alt="Figure 9.4 – Static IP, gateway, and DNS settings"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.4 – Static IP, gateway, and DNS settings</p>
			<p>After we have saved<a id="_idIndexMarker547"/> these settings, we will need to restart the network interface in order for it to change to the newly configured IP. We will do this by using the <span class="No-Break">following command:</span></p>
			<pre class="source-code">
[emcleroy@rhel1 ~]$ sudo systemctl restart NetworkManager</pre>
			<p>Next, we will test to ensure the new address is reachable, as shown using the <strong class="source-inline">ping</strong> test in the <span class="No-Break">following screenshot:</span></p>
			<div>
				<div id="_idContainer225" class="IMG---Figure">
					<img src="image/Figure_9.05_B18607.jpg" alt="Figure 9.5 – IP ping test to ensure connectivity"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.5 – IP ping test to ensure connectivity</p>
			<p>Next up, we will dig into setting up the IPV6 address configuration for previously configured <span class="No-Break">network</span><span class="No-Break"><a id="_idIndexMarker548"/></span><span class="No-Break"> interfaces.</span></p>
			<p><em class="italic">Question 2</em> – For this question, we would like you to set up an IPv6 address on the already-configured NIC while maintaining connectivity <span class="No-Break">via IPv4:</span></p>
			<pre class="source-code">
Rhel1 IPv6: fc65:8956:7254:6321::a7/64
Rhel2 IPv6: fc65:8956:7254:6321::a8/64
Subnet: fc65:8956:7254:6321::/64</pre>
			<p>These should be routable, and you should maintain IPv4 routable connectivity as well once the change has <span class="No-Break">been made.</span></p>
			<p><em class="italic">Answer 2</em> – We will use the <strong class="source-inline">nmtui</strong> command to set <span class="No-Break">this up:</span></p>
			<div>
				<div id="_idContainer226" class="IMG---Figure">
					<img src="image/Figure_9.06_B18607.jpg" alt="Figure 9.6 – NMTUI network menu"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.6 – NMTUI network menu</p>
			<p>After we initiate<a id="_idIndexMarker549"/> the <strong class="source-inline">nmtui</strong> menu, we will then choose to edit a connection, which will take you to the menu in the <span class="No-Break">following screenshot:</span></p>
			<div>
				<div id="_idContainer227" class="IMG---Figure">
					<img src="image/Figure_9.07_B18607.jpg" alt="Figure 9.7 – NMTUI interface selection screen"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.7 – NMTUI interface selection screen</p>
			<p>After choosing the correct<a id="_idIndexMarker550"/> interface – in our case, <strong class="bold">enp0s3</strong>, but in your setup, it may be different depending on your lab – we will then be able to make configuration changes, as shown in the <span class="No-Break">following screenshot:</span></p>
			<div>
				<div id="_idContainer228" class="IMG---Figure">
					<img src="image/Figure_9.08_B18607.jpg" alt="Figure 9.8 – NMTUI interface configuration settings"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.8 – NMTUI interface configuration settings</p>
			<p>After we <a id="_idIndexMarker551"/>choose <strong class="bold">Manual</strong> for <strong class="bold">IPv6 CONFIGURATION</strong>, we can then edit the values of the IPv6 address and gateway, as shown in the <span class="No-Break">following screenshot:</span></p>
			<div>
				<div id="_idContainer229" class="IMG---Figure">
					<img src="image/Figure_9.09_B18607.jpg" alt="Figure 9.9 – IPv6 interface settings"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.9 – IPv6 interface settings</p>
			<p>After we set up the <a id="_idIndexMarker552"/>configuration as shown, we will then save the configuration. In order for the changes to take effect, we will need to run the following command to refresh <span class="No-Break">the connectivity:</span></p>
			<pre class="source-code">
[emcleroy@rhel1 ~]$ sudo systemctl restart NetworkManager</pre>
			<p>After both servers have been configured, we can then run IPv6 <strong class="source-inline">ping</strong> tests across the two interfaces to ensure connectivity, as shown in the <span class="No-Break">following screenshot:</span></p>
			<div>
				<div id="_idContainer230" class="IMG---Figure">
					<img src="image/Figure_9.10_B18607.jpg" alt="Figure 9.10 – IPv6 ping tests"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.10 – IPv6 ping tests</p>
			<p>We have shown<a id="_idIndexMarker553"/> one way to solve the issue of configuring your network with the preceding information. Now, we will move on to working with <span class="No-Break">firewall services.</span></p>
			<h2 id="_idParaDest-102"><a id="_idTextAnchor111"/>Managing firewall services</h2>
			<p>In this section, we<a id="_idIndexMarker554"/> will go over setting up firewall rules. We will talk about rich rules and other items that will block specific connectivity and allow connectivity for network traffic that is not <span class="No-Break">currently allowed.</span></p>
			<p><em class="italic">Question 1</em> – For this question, we would like you to allow access to services and ports through the firewall. This will allow connectivity to web services that might be running on your servers in production. Please open access to <span class="No-Break">the following:</span></p>
			<pre class="source-code">
Services: http and https</pre>
			<p>Please do this manually and also set it up in an Ansible <span class="No-Break">Automation playbook.</span></p>
			<p><em class="italic">Answer 1</em> – We will use<a id="_idIndexMarker555"/> the following commands to set up the firewall to allow connectivity to <span class="No-Break">these services:</span></p>
			<div>
				<div id="_idContainer231" class="IMG---Figure">
					<img src="image/Figure_9.11_B18607.jpg" alt="Figure 9.11 – Firewall commands utilized to allow service connectivity"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.11 – Firewall commands utilized to allow service connectivity</p>
			<p>The Ansible playbook for setting up <strong class="source-inline">firewalld</strong> services is <span class="No-Break">as follows:</span></p>
			<pre class="source-code">
- name: firewalld configuration
  hosts: all
  become: true
  become_method: sudo
  tasks:
    - name: Enable Firewalld services
      firewalld:
        permanent: yes
        immediate: yes
        service: "{{ item }}"
        state: enabled
      loop:
        - http
        - https
    - name: Reload firewall
      command:
        cmd: firewall-cmd --reload
    - name: Show open services and ports
      command:
        cmd: firewall-cmd --list-all</pre>
			<p>Please see the following<a id="_idIndexMarker556"/> screenshot with the inventory for <span class="No-Break">your reference:</span></p>
			<div>
				<div id="_idContainer232" class="IMG---Figure">
					<img src="image/Figure_9.12_B18607.jpg" alt="Figure 9.12 – Playbook inventory for all labs"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.12 – Playbook inventory for all labs</p>
			<p>After we have set up<a id="_idIndexMarker557"/> and run the playbook with <strong class="source-inline">ansible-playbook -i inventory firewalld.yml -u emcleroy -k –ask-become -v</strong>, we will see the output in the <span class="No-Break">following screenshot:</span></p>
			<div>
				<div id="_idContainer233" class="IMG---Figure">
					<img src="image/Figure_9.13_B18607.jpg" alt="Figure 9.13 – Successful Ansible playbook completion"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.13 – Successful Ansible playbook completion</p>
			<p><em class="italic">Question 2</em> – For this <a id="_idIndexMarker558"/>question, we would like you to provide access to HTTP via the <strong class="source-inline">192.168.1.0</strong>/<strong class="source-inline">24</strong> domain, but block access via the <span class="No-Break"><strong class="source-inline">172.16.1.0/24</strong></span><span class="No-Break"> domain.</span></p>
			<p>Please do this manually and also set it up in an Ansible <span class="No-Break">Automation playbook.</span></p>
			<p><em class="italic">Answer 2</em> – We will use <strong class="source-inline">firewall-cmd</strong> rich rules to accomplish this change. We will use the following commands to successfully complete <span class="No-Break">this exercise:</span></p>
			<pre class="console">
[emcleroy@rhel1 ~]$ sudo firewall-cmd --permanent --add-rich-rule='rule family=ipv4 source address=192.168.1.0/24 service name=http accept'
success
[emcleroy@rhel1 ~]$ sudo firewall-cmd --permanent --add-rich-rule='rule family=ipv4 source address=172.16.1.0/24 service name=http reject'
success
[emcleroy@rhel1 ~]$ sudo firewall-cmd --list-rich-rules
rule family="ipv4" source address="192.168.1.0/24" service name="http" accept
rule family="ipv4" source address="172.16.1.0/24" service name="http" reject
[emcleroy@rhel1 ~]$ sudo firewall-cmd --reload
success</pre>
			<p>Now, let’s create an<a id="_idIndexMarker559"/> Ansible playbook to accomplish the same changes to the firewall rules, which can be seen in the <span class="No-Break">following playbook:</span></p>
			<pre class="console">
- name: Firewalld Rich Rule
  hosts: all
  become: true
  become_method: sudo
  tasks:
    - name: Set rich rules up on firewall
      firewalld:
        permanent: yes
        immediate: yes
        rich_rule: "{{ item }}"
        state: enabled
      loop:
       - 'rule family=ipv4 source address=192.168.1.0/24 service name="http"  accept'
       - 'rule family=ipv4 source address=172.16.1.0/24 service name="http" reject'
    - name: Show rich rules
      command:
        cmd: firewall-cmd --list-rich-rules
    - name: Reload firewall
      command:
        cmd: firewall-cmd --reload</pre>
			<p>After we have run the <a id="_idIndexMarker560"/>playbook using <strong class="source-inline">ansible-playbook -i inventory richrule.yml -u emcleroy -k –ask-become -v</strong>, we will see the output in the <span class="No-Break">following screenshot:</span></p>
			<div>
				<div id="_idContainer234" class="IMG---Figure">
					<img src="image/Figure_9.14_B18607.jpg" alt="Figure 9.14 – Successful Ansible playbook completion output"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.14 – Successful Ansible playbook completion output</p>
			<h2 id="_idParaDest-103"><a id="_idTextAnchor112"/>Managing SELinux</h2>
			<p>In this section, we will be<a id="_idIndexMarker561"/> working to fix SELinux issues when <a id="_idIndexMarker562"/>creating files and folders to ensure there are no <span class="No-Break">permission issues.</span></p>
			<p><em class="italic">Question 1</em> – For this question, we would like you to create a folder and text file in the root directory and then repair the SELinux contexts to the <span class="No-Break">correct permissions:</span></p>
			<pre class="source-code">
Folder: /srv/test
File: /srv/test/text.txt
File body: Testing SELinux contexts.</pre>
			<p>Please do this manually and also set it up in an Ansible <span class="No-Break">Automation playbook.</span></p>
			<p><em class="italic">Answer 1</em> – We will use the following commands to successfully create and resolve any SELinux <span class="No-Break">context issues:</span></p>
			<pre class="console">
[emcleroy@rhel1 ~]$ sudo mkdir /srv/test
[emcleroy@rhel1 ~]$ sudo vi /srv/test/text.txt
[emcleroy@rhel1 ~]$ restorecon -Rv /srv/test
[emcleroy@rhel1 ~]$ ls -lZ /srv/test
total 4
-rw-r--r--. 1 root root unconfined_u:object_r:var_t:s0 33 Oct  8 09:16 text.txt</pre>
			<p>Next, we will <a id="_idIndexMarker563"/>accomplish this action with an Ansible playbook <span class="No-Break">as follows:</span></p>
			<pre class="console">
- name: SELinux training
  hosts: all
  become: true
  become_method: sudo
  tasks:
    - name: Create directory
      file:
        path: /srv/test
        state: directory
        mode: '0755'
    - name: Create a file in the directory
      copy:
        dest: "/srv/test/text.txt"
        content: |
          Thank you for reading my book!!!
    - name: Restore any SELinux issues if they exist
      command:
        cmd: restorecon -Rv /srv/test
    - name: View attributes
      command:
        cmd: ls -lZ /srv/test</pre>
			<p>After we have<a id="_idIndexMarker564"/> created the Ansible playbook, we will run it with this command: <strong class="source-inline">ansible-playbook -i inventory selinux.yml -u emcleroy -k --ask-become -v</strong>. You can see the results in the <span class="No-Break">following screenshot:</span></p>
			<div>
				<div id="_idContainer235" class="IMG---Figure">
					<img src="image/Figure_9.15_B18607.jpg" alt="Figure 9.15 – Successful Ansible Automation playbook run output"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.15 – Successful Ansible Automation playbook run output</p>
			<p>We learned how to<a id="_idIndexMarker565"/> resolve SELinux issues with files and folders in this section with easy-to-remember commands that should address issues you run into in the exam. Next, we will showcase how to control system processes that are running on <span class="No-Break">your servers.</span></p>
			<h2 id="_idParaDest-104"><a id="_idTextAnchor113"/>Managing system processes</h2>
			<p>In this section, we will start and enable <a id="_idIndexMarker566"/>services. We will also install packages, as they are needed for us to start and enable a service that is not already running. We are using <strong class="source-inline">postgresql</strong> as an example, but this will work for all the services you install, such as DHCP, DNS, <span class="No-Break">and SMB.</span></p>
			<p><em class="italic">Question 1</em> – For this question, we would like you to install <strong class="source-inline">postgresql</strong> and start and enable it <span class="No-Break">on </span><span class="No-Break"><strong class="source-inline">rhel1</strong></span><span class="No-Break">.</span></p>
			<p>Please do this manually and also set it up in an Ansible <span class="No-Break">Automation playbook.</span></p>
			<p><em class="italic">Answer 1</em> – We will use the<a id="_idIndexMarker567"/> following commands to install, enable, and start <strong class="source-inline">postgresql</strong> <span class="No-Break">on </span><span class="No-Break"><strong class="source-inline">rhel1</strong></span><span class="No-Break">:</span></p>
			<pre class="source-code">
[emcleroy@rhel1 ~]$ sudo dnf install @postgresql
[emcleroy@rhel1 ~]$ sudo systemctl enable postgresql
[emcleroy@rhel1 ~]$ sudo postgresql-setup --initdb
 * Initializing database in '/var/lib/pgsql/data'
 * Initialized, logs are in /var/lib/pgsql/initdb_postgresql.log
[emcleroy@rhel1 ~]$ sudo systemctl start postgresql</pre>
			<p>After we have completed the installation and startup of <strong class="source-inline">postgresql</strong> manually, we need to uninstall <strong class="source-inline">postgresql</strong> so that Ansible can install it. We will use the following command to remove <strong class="source-inline">postgresql</strong>  <span class="No-Break">from </span><span class="No-Break"><strong class="source-inline">rhel1</strong></span><span class="No-Break">:</span></p>
			<pre class="source-code">
sudo dnf remove @postgresql</pre>
			<p>Once <strong class="source-inline">postgresql</strong> has been removed, we will set up an Ansible playbook as follows to install, enable, and start the <span class="No-Break"><strong class="source-inline">postgresql</strong></span><span class="No-Break"> service:</span></p>
			<pre class="console">
- name: Install package, enable and start it.
  hosts: rhel1.example.com
  become: true
  become_method: sudo
  tasks:
    - name: Install postgresql
      command:
        cmd: "dnf install @postgresql -y"
    - name: Initialize the database
      command:
        cmd: postgresql-setup --initdb
      ignore_errors: true
    - name: Enable and start postgresql service
      service:
        name: postgresql
        state: started
        enabled: true
    - name: Check to ensure service is started
      command:
        cmd: systemctl status postgresql</pre>
			<p>We have added <strong class="source-inline">ignore_errors</strong> to the initialization step due to possible failures that do not affect the starting or enabling of <span class="No-Break">the service.</span></p>
			<p>After we have completed <a id="_idIndexMarker568"/>writing the playbook, we will run it using the <strong class="source-inline">ansible-playbook -i inventory postgresql.yml -u emcleroy -k --ask-become -v</strong> command. The result of running the playbook is shown in the <span class="No-Break">following screenshot:</span></p>
			<div>
				<div id="_idContainer236" class="IMG---Figure">
					<img src="image/Figure_9.16_B18607.jpg" alt="Figure 9.16 – Successful run of the postgresql playbook"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.16 – Successful run of the postgresql playbook</p>
			<p>In this section, we learned <a id="_idIndexMarker569"/>how to install, start, and enable services with the <strong class="source-inline">postgresql</strong> service as an example. These commands can be used with all services that you can install on an RHEL 8.1 system. In the next section, we will delve into <span class="No-Break">network teaming.</span></p>
			<h2 id="_idParaDest-105"><a id="_idTextAnchor114"/>Managing link aggregation</h2>
			<p>In this section, we will set up <span class="No-Break">network teaming:</span></p>
			<p><em class="italic">Question 1</em> – For this <a id="_idIndexMarker570"/>question, we would like you to set up network teaming on the additional NICs that were provisioned in the <span class="No-Break">setup process:</span></p>
			<pre class="source-code">
Rhel1 IPv4: 192.168.1.225
Rhel2 IPv4: 192.168.1.226</pre>
			<p>My setup has the NICs as <strong class="bold">enp0s8</strong> and <strong class="bold">enp0s9</strong> – yours might be different depending on your setup. Set up the connectivity as round-robin runner. You should be able to connect to each server using these IPs once set up. You should have connectivity to the network team when both NICs are up and when one of the two goes down. The connectivity of your main SSH IP should remain up <span class="No-Break">and connected.</span></p>
			<p>Please do this manually and also set it up in an Ansible <span class="No-Break">Automation playbook.</span></p>
			<p><em class="italic">Answer 1</em> – We will be using the following commands to set up the team on both systems. Please make sure you use the correct IPv4 address <span class="No-Break">per server:</span></p>
			<pre class="source-code">
[emcleroy@rhel1 ~]$ sudo nmcli con add type team con-name team1 ifname team1 team.runner roundrobin
Connection 'team1' (58770e3c-89bf-4a87-9b26-e9ad581ef978) successfully added.
[emcleroy@rhel1 ~]$ sudo nmcli con add type ethernet slave-type team con-name team1-enp0s8 ifname enp0s8 master team1
Connection 'team1-enp0s8' (3886d9f8-2db6-4269-9d9b-2973b24f74ce) successfully added.
[emcleroy@rhel1 ~]$ sudo nmcli con add type ethernet slave-type team con-name team1-enp0s9 ifname enp0s9 master team1
Connection 'team1-enp0s9' (d845c4e1-b354-4c58-904d-f9cf0c3d1e59) successfully added.
[emcleroy@rhel1 ~]$ sudo nmcli con mod team1 ipv4.addresses 192.168.1.225/24
[emcleroy@rhel1 ~]$ sudo nmcli con mod team1 ipv4.method manual
[emcleroy@rhel1 ~]$ sudo ifdown team1
Connection 'team1' successfully deactivated (D-Bus active path: /org/freedesktop/NetworkManager/ActiveConnection/2)
[emcleroy@rhel1 ~]$ sudo ifup team1
Connection successfully activated (master waiting for slaves) (D-Bus active path: /org/freedesktop/NetworkManager/ActiveConnection/5)
[emcleroy@rhel1 ~]$ ifconfig
team1: flags=4163&lt;UP,BROADCAST,RUNNING,MULTICAST&gt;  mtu 1500
        inet 192.168.1.225  netmask 255.255.255.0  broadcast 192.168.1.255
        inet6 fe80::4036:4e32:d1af:fd0a  prefixlen 64  scopeid 0x20&lt;link&gt;
        ether 08:00:27:ad:b3:d8  txqueuelen 1000  (Ethernet)
        RX packets 159  bytes 8184 (7.9 KiB)
        RX errors 0  dropped 30  overruns 0  frame 0
        TX packets 8  bytes 688 (688.0 B)
        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0</pre>
			<p>Now, repeat the process for <strong class="source-inline">Rhel2</strong>. Once that is complete, you should have a <strong class="source-inline">team1</strong> interface that is<a id="_idIndexMarker571"/> up and running with <strong class="source-inline">roundrobin</strong> connectivity. You can use <strong class="source-inline">ping</strong> to test the interface, as shown in the <span class="No-Break">following screenshot:</span></p>
			<div>
				<div id="_idContainer237" class="IMG---Figure">
					<img src="image/Figure_9.17_B18607.jpg" alt="Figure 9.17 – ping tests to ensure connectivity to the newly set up team"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.17 – ping tests to ensure connectivity to the newly set up team</p>
			<p>After we have completed the<a id="_idIndexMarker572"/> team creation manually, we will set up an Ansible playbook as follows to create <span class="No-Break">the teams:</span></p>
			<pre class="source-code">
- name: Create a network team
  hosts: rhel1.example.com, rhel2.example.com
  become: true
  become_method: sudo
  tasks:
    - name: Create network team
      command:
        cmd: nmcli con add type team con-name team1 ifname team1 team.runner roundrobin
    - name: Add slave interfaces
      command:
        cmd: 'nmcli con add type ethernet slave-type team con-name team1-"{{ item }}" ifname "{{ item }}" master team1'
      loop:
        - enp0s8
        - enp0s9
    - name: Add Static IP to team1
      command:
        cmd: nmcli con mod team1 ipv4.addresses "{{ team_ip }}"
    - name: Add interface method
      command:
        cmd: nmcli con mod team1 ipv4.method manual</pre>
			<p>We will then add<a id="_idIndexMarker573"/> host variables to our inventory so that each server gets the correct IP, as shown in the <span class="No-Break">following screenshot:</span></p>
			<div>
				<div id="_idContainer238" class="IMG---Figure">
					<img src="image/Figure_9.18_B18607.jpg" alt="Figure 9.18 – Updated inventory file with host variables"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.18 – Updated inventory file with host variables</p>
			<p>After we have created <a id="_idIndexMarker574"/>the playbook, we can run it using the <strong class="source-inline">ansible-playbook -i inventory networkteam.yml -u emcleroy -k --ask-become -v</strong> command – the partial output is shown in the <span class="No-Break">following screenshot:</span></p>
			<div>
				<div id="_idContainer239" class="IMG---Figure">
					<img src="image/Figure_9.19_B18607.jpg" alt="Figure 9.19 – Successful network teaming playbook run"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.19 – Successful network teaming playbook run</p>
			<p>In this section, we<a id="_idIndexMarker575"/> learned how to team network interfaces together to provide redundancy across multiple NICs. In the next section, we will set up and manage <span class="No-Break">DNS services.</span></p>
			<h2 id="_idParaDest-106"><a id="_idTextAnchor115"/>Managing DNS</h2>
			<p>In this section, we will set up a<a id="_idIndexMarker576"/> <span class="No-Break">DNS server.</span></p>
			<p><em class="italic">Question 1</em> – For this question, we would like you to set up a DNS server. We would like you to add forward and reverse records for IPv4. We will set up the DNS server <span class="No-Break">on </span><span class="No-Break"><strong class="source-inline">rhel1.example.com</strong></span><span class="No-Break">.</span></p>
			<p>A and reverse aka PTR records will use the <span class="No-Break">following information:</span></p>
			<pre class="source-code">
rhel1.example.com – 192.168.1.198
rhel2.example.com – 192.168.1.133
rhel3.example.com – 192.168.1.53</pre>
			<p><em class="italic">Answer 1</em> – We will start by installing the <span class="No-Break"><strong class="source-inline">bind</strong></span><span class="No-Break"> package:</span></p>
			<pre class="source-code">
[emcleroy@rhel1 ~]$ sudo dnf install bind -y</pre>
			<p>Next, we will set up the firewall rules to allow for connectivity and the delivery of <span class="No-Break">DNS records:</span></p>
			<pre class="source-code">
[emcleroy@rhel1 ~]$ sudo firewall-cmd --permanent --add-service=dns
success
[emcleroy@rhel1 ~]$ sudo firewall-cmd --reload
Success</pre>
			<p>From installing the <a id="_idIndexMarker577"/>package to setting up firewall rules, we will now configure the config DNS file, <strong class="source-inline">/etc/named.conf</strong>. This file should look like the <span class="No-Break">following screenshot:</span></p>
			<div>
				<div id="_idContainer240" class="IMG---Figure">
					<img src="image/Figure_9.20_B18607.jpg" alt="Figure 9.20 – Configuration example settings"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.20 – Configuration example settings</p>
			<p>Make sure to include the<a id="_idIndexMarker578"/> new zones in the configuration file as shown in the <span class="No-Break">following screenshot:</span></p>
			<div>
				<div id="_idContainer241" class="IMG---Figure">
					<img src="image/Figure_9.21_B18607.jpg" alt="Figure 9.21 – Zone information in the configuration file"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.21 – Zone information in the configuration file</p>
			<p>Next, we need to<a id="_idIndexMarker579"/> create the zone files in the <strong class="source-inline">/var/named</strong> directory. These will include the forward and reverse zone records of <strong class="source-inline">192.168.1.zone</strong> and <strong class="source-inline">example.com.zone</strong>. We can see an example of each one in the <span class="No-Break">following screenshots:</span></p>
			<div>
				<div id="_idContainer242" class="IMG---Figure">
					<img src="image/Figure_9.22_B18607.jpg" alt="Figure 9.22 – DNS zone file setup"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.22 – DNS zone file setup</p>
			<p>After we have set <a id="_idIndexMarker580"/>up the forward zone, we will set up the reverse zone, as shown in the <span class="No-Break">following screenshot:</span></p>
			<div>
				<div id="_idContainer243" class="IMG---Figure">
					<img src="image/Figure_9.23_B18607.jpg" alt="Figure 9.23 – Reverse zone file"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.23 – Reverse zone file</p>
			<p>Next, we will start <a id="_idIndexMarker581"/>and enable the <strong class="source-inline">named</strong> service that the <strong class="source-inline">bind</strong> package installed for running the <span class="No-Break">DNS server:</span></p>
			<pre class="source-code">
[root@rhel1 named]# systemctl enable named
Created symlink /etc/systemd/system/multi-user.target.wants/named.service → /usr/lib/systemd/system/named.service.
[root@rhel1 named]# systemctl start named</pre>
			<p>Then, we will do a lookup to ensure that we are getting the right addresses back for <span class="No-Break">the names:</span></p>
			<pre class="source-code">
[root@rhel1 named]# nslookup rhel2.example.com 192.168.1.198
Server:          192.168.1.198
Address:  192.168.1.198#53
Name: rhel2.example.com
Address: 192.168.1.133</pre>
			<p>Next, we will install this by <a id="_idIndexMarker582"/>using Ansible Automation with the following playbook <span class="No-Break">and templates:</span></p>
			<pre class="source-code">
---
- name: Install and configure DNS
  hosts: rhel1.example.com
  become: true
  become_method: sudo
  tasks:
    - name: Install DNS server
      package:
        name: bind
        state: latest
    - name: Move bind configuration to named.conf
      template:
        src: "{{ playbook_dir }}/named.conf.j2"
        dest: "/etc/named.conf"
    - name: Move example.com.zone and 192.168.1.zone to /var/named
      template:
        src: "{{ playbook_dir}}/{{ item }}.j2"
        dest: "/var/named/{{ item }}"
      loop:
        - 'example.com.zone'
        - '192.168.1.zone'
    - name: Set firewall rules
      firewalld:
        service: dns
        permanent: true
        state: enabled
    - name: Reload firewall
      command:
        cmd: firewall-cmd --reload
    - name: Start and enable the DNS service
      service:
        name: named
        state: restarted
        enabled: true</pre>
			<p>The following are the templates that need to be in place for the correct configuration files to be successfully modified<a id="_idIndexMarker583"/> during the playbook execution as well. First, we have the <strong class="source-inline">named.conf.j2</strong> <span class="No-Break">configuration file:</span></p>
			<pre class="source-code">
//
// named.conf
//
// Provided by Red Hat bind package to configure the ISC BIND named(8) DNS
// server as a caching only nameserver (as a localhost DNS resolver only).
//
// See /usr/share/doc/bind*/sample/ for example named configuration files.
//
options {
     listen-on port 53 { 127.0.0.1; 192.168.1.198; };
     listen-on-v6 port 53 { ::1; };
     directory  "/var/named";
     dump-file  "/var/named/data/cache_dump.db";
     statistics-file "/var/named/data/named_stats.txt";
     memstatistics-file "/var/named/data/named_mem_stats.txt";
     secroots-file   "/var/named/data/named.secroots";
     recursing-file  "/var/named/data/named.recursing";
     allow-query     { localhost; 192.168.1.198; };
     recursion no;
     dnssec-enable yes;
     dnssec-validation yes;
     managed-keys-directory "/var/named/dynamic";
     pid-file "/run/named/named.pid";
     session-keyfile "/run/named/session.key";
     /* https://fedoraproject.org/wiki/Changes/CryptoPolicy */
     include "/etc/crypto-policies/back-ends/bind.config";
};
logging {
        channel default_debug {
                file "data/named.run";
                severity dynamic;
        };
};
zone "example.com" IN {
        type master;
        file "example.com.zone";
        forwarders {};
};
zone "192.168.1.in-addr.arpa" IN {
        type master;
        file "192.168.1.zone";
        forwarders {};
};
zone "." IN {
     type hint;
     file "named.ca";
};
include "/etc/named.rfc1912.zones";
include "/etc/named.root.key";</pre>
			<p>Then, we have the zone <a id="_idIndexMarker584"/>files that are needed in order to provide the DNS records. First up is the <span class="No-Break"><strong class="source-inline">example.com.zone.j2</strong></span><span class="No-Break"> file:</span></p>
			<pre class="source-code">
$TTL 3H
@       IN SOA rhel1.example.com. admin.example.com (
2; serial
65; refresh
75; retry
8000; expire
60) ; minimum
        NS      rhel1
        A       127.0.0.1
        AAAA    ::1
rhel1        IN  A 192.168.1.198
rhel2        IN  A 192.168.1.133
rhel3        IN  A 192.168.1.53</pre>
			<p>Finally, we will add in <strong class="source-inline">192.168.1.zone.j2</strong> for<a id="_idIndexMarker585"/> the <strong class="bold">Pointer Record</strong> (<strong class="bold">PTR</strong>) records, also known as the<a id="_idIndexMarker586"/> reverse lookup <span class="No-Break">zone file:</span></p>
			<pre class="source-code">
$TTL 3H
@       IN SOA rhel1.example.com. admin.example.com. (
                                        2       ; serial
                                        8000      ; refresh
                                        9000      ; retry
                                        10000      ; expire
                                        5000)    ; minimum
        NS      rhel1.example.com.
198        IN  PTR  rhel1.example.com.
133        IN  PTR  rhel2.example.com.
53         IN  PTR  rhel3.example.com.</pre>
			<p>After we create the playbook, we run the <strong class="source-inline">ansible-playbook -i /home/emcleroy/playbooks/inventory dns.yml -u emcleroy -k --ask-become -v</strong> command, and we can see the successful output in the <span class="No-Break">following screenshot:</span></p>
			<div>
				<div id="_idContainer244" class="IMG---Figure">
					<img src="image/Figure_9.24_B18607.jpg" alt="Figure 9.24 – Successful DNS server deployment via Ansible Automation"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.24 – Successful DNS server deployment via Ansible Automation</p>
			<h2 id="_idParaDest-107"><a id="_idTextAnchor116"/>Managing DHCP</h2>
			<p>In this section, we will be setting <a id="_idIndexMarker587"/>up a <span class="No-Break">DHCP server.</span></p>
			<p><em class="italic">Question 1</em> – For this question, we would like you to set up a DHCP server on <strong class="source-inline">rhel1.example.com</strong> that serves the <strong class="source-inline">192.168.1.0</strong>/<strong class="source-inline">24</strong> subnet with an available IP range of <strong class="source-inline">192.168.1.100</strong> – <strong class="source-inline">192.168.1.220</strong>. The DNS server is <strong class="source-inline">192.168.1.198</strong> or your <strong class="source-inline">rhel1.example.com</strong> IP address. We will want static entries for <span class="No-Break">the following:</span></p>
			<pre class="source-code">
rhel4.example.com MAC Address: 08:00:27:AB:81:10 IP: 192.168.1.120
rhel5.example.com MAC Address: 08:00:27:AB:81:11 IP: 192.168.1.121</pre>
			<p><em class="italic">Answer 1</em> – We will start by installing the <strong class="source-inline">dhcp-server</strong> package as shown in <span class="No-Break">the following:</span></p>
			<pre class="source-code">
[emcleroy@rhel1 ~]$ sudo dnf install dhcp-server -y</pre>
			<p>Next, we will set up the <strong class="source-inline">dhcp</strong> file to <a id="_idIndexMarker588"/>accommodate and provide the IP range in <strong class="source-inline">/etc/dhcp/dhcpd.conf</strong>, as seen in the <span class="No-Break">following screenshot:</span></p>
			<div>
				<div id="_idContainer245" class="IMG---Figure">
					<img src="image/Figure_9.25_B18607.jpg" alt="Figure 9.25 – DHCP server configuration file"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.25 – DHCP server configuration file</p>
			<p>Remember there is no need to remember all the lines, as there is an example provided after the installation found here: <strong class="source-inline">/usr/share/doc/dhcp-server/dhcpd.conf.example</strong>. After we have set up the DHCP configuration file, we will open the firewall rules <a id="_idIndexMarker589"/>and start and enable <strong class="source-inline">dhcp</strong> services for <span class="No-Break">the server:</span></p>
			<pre class="source-code">
[emcleroy@rhel1 ~]$ sudo firewall-cmd --permanent --add-service=dhcp
[emcleroy@rhel1 ~]$ firewall-cmd –reload
[emcleroy@rhel1 ~]$ sudo systemctl start dhcpd
[emcleroy@rhel1 ~]$ sudo systemctl enable dhcpd
Created symlink /etc/systemd/system/multi-user.target.wants/dhcpd.service → /usr/lib/systemd/system/dhcpd.service.</pre>
			<p>Now, let’s set up a DHCP server using Ansible Automation. We will start with the <span class="No-Break">following playbook:</span></p>
			<pre class="source-code">
---
- name: Install and configure DHCP
  hosts: rhel1.example.com
  become: true
  become_method: sudo
  tasks:
    - name: Install dhcp server
      package:
        name: dhcp-server
        state: latest
    - name: Copy the dhcpd.conf file to the server
      template:
        src: "{{ playbook_dir }}/dhcpd.conf.j2"
        dest: /etc/dhcp/dhcpd.conf
    - name: Open firewall rules
      firewalld:
        service: dhcp
        permanent: true
        state: enabled
    - name: Reload firewall rules
      command:
        cmd: firewall-cmd --reload
    - name: Start and enable dhcp server
      service:
        name: dhcpd
        enabled: true
        state: restarted</pre>
			<p>The following code<a id="_idIndexMarker590"/> displays the contents of the <span class="No-Break"><strong class="source-inline">dhcpd.conf.j2</strong></span><span class="No-Break"> file:</span></p>
			<pre class="source-code">
#
# DHCP Server Configuration file.
#   see /usr/share/doc/dhcp-server/dhcpd.conf.example
#   see dhcpd.conf(5) man page
#
authoritative;
subnet 192.168.1.0 netmask 255.255.255.0 {
  range 192.168.1.100 192.168.1.220;
  option broadcast-address 192.168.1.255;
  option domain-name-servers 192.168.1.198;
}
host rhel4 {
  hardware ethernet 08:00:27:AB:81:10;
  fixed-address 192.168.1.120;
}
host rhel5 {
  hardware ethernet 08:00:27:AB:81:11;
  fixed-address 192.168.1.121;
}</pre>
			<p>After we have created the <a id="_idIndexMarker591"/>playbook, we can run it using the <strong class="source-inline">ansible-playbook -i inventory dhcp.yml -u emcleroy -k --ask-become -v</strong> command to run an Ansible playbook successfully, as can be seen in the <span class="No-Break">following screenshot:</span></p>
			<div>
				<div id="_idContainer246" class="IMG---Figure">
					<img src="image/Figure_9.26_B18607.jpg" alt="Figure 9.26 – Successful DHCP server playbook run"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.26 – Successful DHCP server playbook run</p>
			<p>In this section, we learned how to <a id="_idIndexMarker592"/>set up a DHCP server, including static entries in the configuration files. In the next section, we will work with printers that are on your network at home <span class="No-Break">or work.</span></p>
			<h2 id="_idParaDest-108"><a id="_idTextAnchor117"/>Managing printers</h2>
			<p>In this section, we will be managing <span class="No-Break">networked printers.</span></p>
			<p><em class="italic">Question 1</em> – For this question, we<a id="_idIndexMarker593"/> would like you to set up a network printer on <strong class="source-inline">rhel1.example.com</strong>. Please set up a print queue named <strong class="source-inline">myqueue</strong>. If you have a network printer, you can test this. If not, you will not be able to test <span class="No-Break">this solution/answer.</span></p>
			<p><em class="italic">Answer 1</em> – We will start by installing <strong class="source-inline">cups</strong> on <span class="No-Break">the system:</span></p>
			<pre class="console">
[emcleroy@rhel1 ~]$ sudo dnf install cups -y</pre>
			<p>We will then enable and start <strong class="source-inline">cups</strong> <span class="No-Break">print services:</span></p>
			<pre class="console">
[emcleroy@rhel1 ~]$ sudo systemctl enable cups
[emcleroy@rhel1 ~]$ sudo systemctl start cups</pre>
			<p>Next, we will allow <strong class="source-inline">mdns</strong> firewall rules to allow access to the <span class="No-Break">printer services:</span></p>
			<pre class="console">
[emcleroy@rhel1 ~]$ sudo firewall-cmd --permanent --add-service=mdns
success
[emcleroy@rhel1 ~]$ sudo firewall-cmd --reload
success</pre>
			<p>We will use the <strong class="source-inline">ippfind</strong> command to<a id="_idIndexMarker594"/> find the printers available. In my case, I will <span class="No-Break">use </span><span class="No-Break"><strong class="source-inline">Brother</strong></span><span class="No-Break">:</span></p>
			<pre class="console">
[emcleroy@rhel1 ~]$ ippfind -T 5
ipp://BRW9C305BC2B044.local:631/ipp/print
ipp://BRW9C305BC2B044.local:631/ipp/print</pre>
			<p>Next, we will use the <strong class="source-inline">ipp</strong> address to create the print queue, <strong class="source-inline">myqueue</strong>, and add the printer to <span class="No-Break">the queue:</span></p>
			<pre class="console">
[emcleroy@rhel1 ~]$ lpadmin -p myqueue -v ipp://BRW9C305BC2B044.local:631/ipp/print -m everywhere -E</pre>
			<p>If you run into the <strong class="source-inline">lpadmin: Unable to connect to "BRW9C305BC2B044.local:631": Name or service not known</strong> error, make sure that your DNS can look up that local address, and if not, put the host record that directs the use of a shortname or URL to an IP address in your <strong class="source-inline">/</strong><span class="No-Break"><strong class="source-inline">etc/hosts</strong></span><span class="No-Break"> file.</span></p>
			<p>Finally, we will set the default queue destination <span class="No-Break">for printing:</span></p>
			<pre class="console">
[emcleroy@rhel1 ~]$ lpadmin -d myqueue</pre>
			<p>Next up, we will set up <a id="_idIndexMarker595"/>printers with Ansible Automation using the <span class="No-Break">following playbook:</span></p>
			<pre class="source-code">
---
- name: Install cups, print queue, and printer
  hosts: rhel1.example.com
  become: true
  become_method: sudo
  tasks:
    - name: Install cups
      package:
        name: cups
        state: latest
    - name: Enable firewall rules
      firewalld:
        permanent: true
        state: enabled
        service: mdns
    - name: Reload Firewall
      command:
        cmd: firewall-cmd --reload
    - name: Start and enable cups
      service:
        name: cups
        state: started
        enabled: true
    - name: Create print queue
      command:
        cmd: lpadmin -p myqueue -v ipp://BRW9C305BC2B044.local:631/ipp/print -m everywhere -E
    - name: Set default print destination
      command:
        cmd: lpadmin -d myqueue</pre>
			<p>After we have created the <a id="_idIndexMarker596"/>playbook, we can run it using the <strong class="source-inline">ansible-playbook -i inventory cups.yml -u emcleroy -k --ask-become -v</strong> command to run an Ansible playbook successfully, as can be seen in the <span class="No-Break">following screenshot:</span></p>
			<div>
				<div id="_idContainer247" class="IMG---Figure">
					<img src="image/Figure_9.27_B18607.jpg" alt="Figure 9.27 – Successful cups playbook run"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.27 – Successful cups playbook run</p>
			<p>In this section, we learned how to connect to a network printer that may be available to you to utilize for your<a id="_idIndexMarker597"/> everyday work. In the next section, we will show you how to set up email services on <span class="No-Break">your servers.</span></p>
			<h2 id="_idParaDest-109"><a id="_idTextAnchor118"/>Managing email services</h2>
			<p>In this section, we will be <a id="_idIndexMarker598"/>creating email services on <span class="No-Break">a server.</span></p>
			<p><em class="italic">Question 1</em> – For this question, we would like you to make a null zero client on <strong class="source-inline">rhel1.example.com</strong>. We would like any locally delivered mail to be forwarded to <strong class="source-inline">rhel2.example.com</strong> for normal delivery to the <span class="No-Break">mail services:</span></p>
			<pre class="source-code">
myorigin: example.com
relayhost: rhel2.example.com</pre>
			<p><em class="italic">Answer 1</em> – We will start by installing <strong class="source-inline">postfix</strong>. We will then set the correct parameters that are noted in the question and ensure that the mail server does not accept external or <span class="No-Break">internal </span><span class="No-Break"><a id="_idIndexMarker599"/></span><span class="No-Break">mail:</span></p>
			<pre class="source-code">
[root@rhel1 ~]# sudo dnf install postfix -y
[root@rhel1 ~]# sudo postconf -e "inet_interfaces = loopback-only"
[root@rhel1 ~]# sudo postconf -e "myorigin = example.com"
[root@rhel1 ~]# sudo postconf -e "inet_protocols = ipv4"
[root@rhel1 ~]# sudo postconf -e "mydestination ="
[root@rhel1 ~]# sudo postconf -e "mynetworks = 127.0.0.0/8"
[root@rhel1 ~]# sudo postconf -e "local_transport = error: no local delivery"
[root@rhel1 ~]# sudo postconf -e "relayhost = [rhel2.example.com]"
[root@rhel1 ~]# sudo systemctl start postfix
[root@rhel1 ~]# sudo systemctl enable postfix
Created symlink /etc/systemd/system/multi-user.target.wants/postfix.service → /usr/lib/systemd/system/postfix.service.</pre>
			<p>Keep in mind that if the exam has you set this for IPv6 as well, make sure to set up <strong class="source-inline">inet_protocols</strong> for both IPv4 <span class="No-Break">and IPv6.</span></p>
			<p>Next, we will create an Ansible playbook to complete this <span class="No-Break">same process:</span></p>
			<pre class="source-code">
 ---
- name: Configure Null Client Email Service
  become: true
  hosts: rhel1.example.com
  vars:
    postfix_conf:
      relayhost: "[??.example.com]"
      inet_interfaces: "loopback-only"
      mynetworks: "127.0.0.0/8"
      myorigin: "example.com"
      mydestination: ""
  roles:
    - linux-system-roles.postfix</pre>
			<p>After we have created <a id="_idIndexMarker600"/>the playbook, we will use the <strong class="source-inline">ansible-playbook -i inventory email.yml -u emcleroy -k --ask-become -v</strong> command and run an Ansible playbook successfully, as shown in the <span class="No-Break">following screenshot:</span></p>
			<div>
				<div id="_idContainer248" class="IMG---Figure">
					<img src="image/Figure_9.28_B18607.jpg" alt="Figure 9.28 – Successful Ansible playbook run for email services"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.28 – Successful Ansible playbook run for email services</p>
			<p>In this section, we showed <a id="_idIndexMarker601"/>you how to modify email services and provided an example of setting up a null client configuration. In the next section, we will be going over MariaDB configuration <span class="No-Break">and administration.</span></p>
			<h2 id="_idParaDest-110"><a id="_idTextAnchor119"/>Managing a MariaDB database server</h2>
			<p>In this section, we will <a id="_idIndexMarker602"/>be installing MariaDB, adding to tables, backing up, restoring the content that was previously stored in the columns and tables, and searching through <span class="No-Break">the database.</span></p>
			<p><em class="italic">Question 1</em> – For this question, we will install and securely set up MariaDB so that <strong class="source-inline">root</strong> can only access locally and the <strong class="source-inline">root</strong> password is <strong class="source-inline">redhat</strong>. We will also do <span class="No-Break">the following:</span></p>
			<ul>
				<li>Create a database <span class="No-Break">named </span><span class="No-Break"><strong class="source-inline">available_stock</strong></span></li>
				<li>Create the user <strong class="source-inline">fred</strong> with the password <strong class="source-inline">redhat</strong> with full user rights on <span class="No-Break">database inventory</span></li>
				<li>Create a backup of the <span class="No-Break">database inventory</span></li>
				<li>Restore the backup of the <span class="No-Break">database inventory</span></li>
			</ul>
			<p><em class="italic">Answer 1</em> – We will start by<a id="_idIndexMarker603"/> installing the <strong class="source-inline">mariadb</strong> server, starting and enabling it, after which we will secure <span class="No-Break">the installation:</span></p>
			<pre class="console">
[emcleroy@rhel1 ~]$ sudo dnf install @mariadb -y
[root@rhel1 ~]# systemctl start mariadb
[root@rhel1 ~]# systemctl enable mariadb
Created symlink /etc/systemd/system/mysql.service → /usr/lib/systemd/system/mariadb.service.
Created symlink /etc/systemd/system/mysqld.service → /usr/lib/systemd/system/mariadb.service.
Created symlink /etc/systemd/system/multi-user.target.wants/mariadb.service → /usr/lib/systemd/system/mariadb.service.
[root@rhel1 ~]# mysql_secure_installation</pre>
			<p>We will choose to only allow <strong class="source-inline">root</strong> locally during the secure installation. We will choose to remove the test database. We will set a password for <strong class="source-inline">root</strong> at this time <span class="No-Break">as well.</span></p>
			<p>After we have started MariaDB and secured the installation, we will log in and create the database <span class="No-Break">and user:</span></p>
			<pre class="console">
[root@rhel1 ~]# mysql -u root -p
MariaDB [(none)]&gt; CREATE DATABASE available_stock;
Query OK, 1 row affected (0.000 sec)
MariaDB [(none)]&gt; USE  available_stock;
Database changed
MariaDB [available_stock]&gt; CREATE USER fred@localhost identified by 'redhat';
Query OK, 0 rows affected (0.000 sec)
MariaDB [available_stock]&gt; GRANT INSERT, UPDATE, DELETE, SELECT on available_stock.* to fred@localhost;
Query OK, 0 rows affected (0.000 sec)</pre>
			<p>Next, we are going to take a <a id="_idIndexMarker604"/>backup of <span class="No-Break">the database:</span></p>
			<pre class="console">
[root@rhel1 ~]# mysqldump available_stock -u root -p
&gt; test.dump
Finally, to restore the dump we are going to simply change the direction of the symbol:
[root@rhel1 ~]# mysqldump -u root -p available_stock
&lt; test.dump</pre>
			<p>For the Ansible playbook, we are going to modify this, and in a slightly different way, we will set up just the database. We will now set up the MariaDB database using an Ansible Automation playbook <span class="No-Break">as follows:</span></p>
			<pre class="console">
---
- name: MariaDB install and configuration
  hosts: rhel2.example.com
  become: true
  become_method: sudo
  tasks:
    - name: Install MariaDB server
      package:
        name: '@mariadb:10.3/server'
        state: present
    - name: Install MariaDB client
      package:
        name: mariadb
        state: latest
    - name: Start and enable MariaDB
      service:
        name: mariadb
        state: started
        enabled: true
    - name: Open firewall rules for MariaDB
      firewalld:
        service: mysql
        permanent: true
        state: enabled
    - name: Reload firewall
      command:
        cmd: firewall-cmd --reload
    - name: Set root password for MariaDB
      mysql_user:
        name: root
        host_all: true
        update_password: always
        password: redhat
      no_log: true
      ignore_errors: true</pre>
			<p>After we have <a id="_idIndexMarker605"/>completed creating the playbook, we will run the <strong class="source-inline">ansible-playbook -i inventory mariadb.yml -u emcleroy -k --ask-become -v</strong> command and see the successful output of the playbook in the <span class="No-Break">following screenshot:</span></p>
			<div>
				<div id="_idContainer249" class="IMG---Figure">
					<img src="image/Figure_9.29_B18607.jpg" alt="Figure 9.29 – Successful MariaDB playbook run"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.29 – Successful MariaDB playbook run</p>
			<p>In this section, we <a id="_idIndexMarker606"/>learned how to configure MariaDB, including setting up users for the database. In the next section, we will be going over setting up <span class="No-Break">web servers.</span></p>
			<h2 id="_idParaDest-111"><a id="_idTextAnchor120"/>Managing web access</h2>
			<p>In this section, we will be<a id="_idIndexMarker607"/> setting up web hosts <span class="No-Break">using </span><span class="No-Break"><a id="_idIndexMarker608"/></span><span class="No-Break">Apache.</span></p>
			<p><em class="italic">Question 1</em> – For this question, you will need to set up an Apache web host that displays <strong class="bold">This server is working on Apache!!!</strong> when you navigate to the <strong class="source-inline">rhel1.example.com</strong> server on the browser via <span class="No-Break">port </span><span class="No-Break"><strong class="source-inline">80</strong></span><span class="No-Break">.</span></p>
			<p><em class="italic">Answer 1</em> – We will start by installing Apache via the <strong class="source-inline">httpd</strong> package on the <strong class="source-inline">rhel1.example.com</strong> server <a id="_idIndexMarker609"/>using the <span class="No-Break">following command:</span></p>
			<pre class="console">
[emcleroy@rhel1 ~]$ sudo dnf install httpd -y</pre>
			<p>After <strong class="source-inline">httpd</strong> has been<a id="_idIndexMarker610"/> successfully installed, we will create the <strong class="source-inline">index.html</strong> file in the default web page location of <strong class="source-inline">/var/www/html/index.html</strong>. Use your text editor of choice and create the file with <strong class="bold">This server is working on Apache!!!</strong> in it. Once we have created the file, we will then start and enable the service as displayed in the <span class="No-Break">following commands:</span></p>
			<pre class="console">
[emcleroy@rhel1 html]$ sudo systemctl enable httpd
[emcleroy@rhel1 html]$ sudo systemctl start httpd</pre>
			<p>After we have started and enabled the service, we will need to open the firewall rules to allow connectivity via HTTP using the <span class="No-Break">following commands:</span></p>
			<pre class="console">
[emcleroy@rhel1 html]$ sudo firewall-cmd --permanent --add-service=http
success
[emcleroy@rhel1 html]$ sudo firewall-cmd --reload
Success</pre>
			<p>Once we have opened the firewall rules, we will then be able to confirm that this is working by navigating to the web page via a browser. The following screenshot demonstrates a successful deployment of <span class="No-Break">Apache </span><span class="No-Break"><strong class="source-inline">httpd</strong></span><span class="No-Break">:</span></p>
			<div>
				<div id="_idContainer250" class="IMG---Figure">
					<img src="image/Figure_9.30_B18607.jpg" alt="Figure 9.30 – Successful web host serving the index.html file"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.30 – Successful web host serving the index.html file</p>
			<p>Now, we will set <a id="_idIndexMarker611"/>up Apache <strong class="source-inline">httpd</strong> via Ansible Automation using<a id="_idIndexMarker612"/> the <span class="No-Break">following playbook:</span></p>
			<pre class="source-code">
---
- name: Install and configure apache
  hosts: rhel1.example.com
  become: true
  become_method: sudo
  tasks:
    - name: Install apache httpd
      package:
        name: httpd
        state: latest
    - name: Ensure default directory exists
      file:
        path: /var/www/html
        state: directory
        recurse: yes
    - name: Copy index template
      template:
        src: "{{ playbook_dir }}/index.html.j2"
        dest: /var/www/html/index.html
    - name: Restore SELinux contexts
      sefcontext:
        target: /var/www/html
        setype: httpd_sys_content_t
        state: present
    - name: Open firewall rules
      command:
        cmd: firewall-cmd –permanent –add-service=http
    - name: Reload firewall
      command:
        cmd: firewall-cmd --reload
    - name: Start and enable apache httpd service
      service:
        name: httpd
        state: restarted
        enabled: true</pre>
			<p>Please ensure that <strong class="source-inline">index.html.j2</strong> is within your playbook directory so that it can be copied <span class="No-Break">over</span><span class="No-Break"><a id="_idIndexMarker613"/></span><span class="No-Break"> successfully.</span></p>
			<p>We will use the following<a id="_idIndexMarker614"/> command to run the playbook:  </p>
			<pre class="source-code">
<strong class="source-inline">ansible-playbook -i inventory apache_server.yml -u emcleroy -k --ask-become -v</strong></pre>
			<p>In this section, we set up web server access. In the next section, we will be working with NFS <span class="No-Break">file shares.</span></p>
			<h2 id="_idParaDest-112"><a id="_idTextAnchor121"/>Managing NFS</h2>
			<p>In this section, we will be going <span class="No-Break">over NFS.</span></p>
			<p><em class="italic">Question 1</em> – For this question, you will <a id="_idIndexMarker615"/>need to make an NFS export on <strong class="source-inline">rhel1.example.com</strong> of the <strong class="source-inline">/test</strong> folder with read-only privileges to the <strong class="source-inline">192.168.1.0/24</strong> network and no access for the <span class="No-Break"><strong class="source-inline">172.16.1.0/24</strong></span><span class="No-Break"> network.</span></p>
			<p><em class="italic">Question 2</em> – For this question, you will need to mount <strong class="source-inline">/test</strong> from <strong class="source-inline">rhel1.example.com</strong> on <strong class="source-inline">rhel2.example.com</strong> under <strong class="source-inline">/mnt/test</strong>, and you will need to ensure that it mounts <span class="No-Break">on startup.</span></p>
			<p><em class="italic">Answer 1</em> – We will start by installing <strong class="source-inline">nfs-utils</strong> using the <span class="No-Break">following command:</span></p>
			<pre class="source-code">
[emcleroy@rhel1 ~]$ sudo dnf install nfs-utils</pre>
			<p>After we install <strong class="source-inline">nfs-utils</strong>, we will need to enable and start the service. Then, we will ensure that it is running by using the <span class="No-Break">following commands:</span></p>
			<pre class="source-code">
[emcleroy@rhel1 ~]$ sudo systemctl enable nfs-server
Created symlink /etc/systemd/system/multi-user.target.wants/nfs-server.service → /usr/lib/systemd/system/nfs-server.service.
[emcleroy@rhel1 ~]$ sudo systemctl start nfs-server
[emcleroy@rhel1 ~]$ sudo systemctl status nfs-server
● nfs-server.service - NFS server and services
   Loaded: loaded (/usr/lib/systemd/system/nfs-server.service; enabled; vendor &gt;
   Active: active (exited) since Thu 2022-10-27 12:33:28 EDT; 10s ago
  Process: 71257 ExecStart=/bin/sh -c if systemctl -q is-active gssproxy; then &gt;
  Process: 71245 ExecStart=/usr/sbin/rpc.nfsd (code=exited, status=0/SUCCESS)
  Process: 71244 ExecStartPre=/usr/sbin/exportfs -r (code=exited, status=0/SUCC&gt;
 Main PID: 71257 (code=exited, status=0/SUCCESS)
Oct 27 12:33:28 rhel1.example.com systemd[1]: Starting NFS server and services.&gt;
Oct 27 12:33:28 rhel1.example.com systemd[1]: Started NFS server and services.
lines 1-10/10 (END)</pre>
			<p>After that, we will create the <strong class="source-inline">/test</strong> directory using the <span class="No-Break">following command:</span></p>
			<pre class="source-code">
[emcleroy@rhel1 ~]$ sudo mkdir /test</pre>
			<p>After that, we will add the<a id="_idIndexMarker616"/> folder to the <strong class="source-inline">/etc/exports</strong> file in order to export it with the proper privileges, allow access from the <strong class="source-inline">192.168.1.0/24</strong> domain, and, by default, block it from the rest of the networks, as shown in the <span class="No-Break">following screenshot:</span></p>
			<div>
				<div id="_idContainer251" class="IMG---Figure">
					<img src="image/Figure_9.31_B18607.jpg" alt="Figure 9.31 – exports file for NFS shares"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.31 – exports file for NFS shares</p>
			<p>After we add the folder<a id="_idIndexMarker617"/> to the <strong class="source-inline">exports</strong> list, we will use the following commands to expose the <span class="No-Break">NFS share:</span></p>
			<pre class="source-code">
[emcleroy@rhel1 /]$ sudo exportfs -rav
exporting 192.168.1.0/24:/test</pre>
			<p>Then, we will open the firewall rules to allow NFS services out to the world using the <span class="No-Break">following commands:</span></p>
			<pre class="source-code">
[emcleroy@rhel1 /]$ sudo firewall-cmd --permanent --add-service=nfs
success
[emcleroy@rhel1 /]$ sudo firewall-cmd --reload
success</pre>
			<p>For the Ansible solution, we will create the following playbook in order to complete the automated version<a id="_idIndexMarker618"/> of these <span class="No-Break">manual tasks:</span></p>
			<pre class="source-code">
---
- name: Configure nfs and share folder deployment
  hosts: rhel1.example.com
  become: true
  become_method: sudo
  tasks:
    - name: Install nfs-utils
      package:
        name: nfs-utils
        state: present
    - name: Start and enable nfs-server
      service:
        name: nfs-server
        state: started
        enabled: true
    - name: Firewall rules for nfs-server
      firewalld:
        service: nfs
        permanent: true
        state: enabled
    - name: Reload firewall
      command:
        cmd: firewall-cmd --reload
    - name: Create directory
      file:
        path: /test
        state: directory
        mode: '0755'
    - name: Add directory to exports list
      lineinfile:
        path: /etc/exports
        state: present
        line: '/test 192.168.1.0/24(ro)'
    - name: Export nfs shares
      command:
        cmd: exportfs -rav</pre>
			<p>We will use the following <a id="_idIndexMarker619"/>command to run the <strong class="source-inline">ansible-playbook -i inventory nfs_server.yml -u emcleroy -k --ask-become -v</strong> playbook and you can see a successful run of the Ansible playbook in the <span class="No-Break">following screenshot:</span></p>
			<div>
				<div id="_idContainer252" class="IMG---Figure">
					<img src="image/Figure_9.32_B18607.jpg" alt="Figure 9.32 – Successful playbook run creating an NFS share"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.32 – Successful playbook run creating an NFS share</p>
			<p><em class="italic">Answer 2</em> – After we have completed <em class="italic">Question 1</em>, we can dive into attaching the <strong class="source-inline">share</strong> folder to a new<a id="_idIndexMarker620"/> machine. On <strong class="source-inline">Rhel2</strong>, we will start by opening the firewall to allow NFS connectivity, as shown in the <span class="No-Break">following commands:</span></p>
			<pre class="source-code">
[emcleroy@rhel2 ~]$ sudo firewall-cmd --permanent --add-service=nfs
success
[emcleroy@rhel2 ~]$ sudo firewall-cmd --reload
success</pre>
			<p>Next, we are going to create the mount point folder in order to add the share to <strong class="source-inline">/etc/fstab</strong> and <span class="No-Break">mount it:</span></p>
			<pre class="source-code">
[emcleroy@rhel2 ~]$ sudo mkdir /mnt/test</pre>
			<p>After that, we are going to add the NFS share to the <strong class="source-inline">/etc/fstab</strong> file in order to set it to mount at startup. The file should look something like the following screenshot but may differ depending on how you set up your <span class="No-Break">test environment:</span></p>
			<div>
				<div id="_idContainer253" class="IMG---Figure">
					<img src="image/Figure_9.33_B18607.jpg" alt="Figure 9.33 – fstab showing the mounts to run at startup"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.33 – fstab showing the mounts to run at startup</p>
			<p>Once this has been <a id="_idIndexMarker621"/>added to <strong class="source-inline">fstab</strong>, we will then mount the items in <strong class="source-inline">fstab</strong> using the <span class="No-Break">following command:</span></p>
			<pre class="source-code">
[emcleroy@rhel2 ~]$ sudo mount -a -v
/                        : ignored
/boot                    : already mounted
swap                     : ignored
/mnt/test                : mounted</pre>
			<p>Now, to test that this is working, add a file to the <strong class="source-inline">test</strong> directory on <strong class="source-inline">rhel1</strong> using the <span class="No-Break">following command:</span></p>
			<pre class="source-code">
[emcleroy@rhel1 /]$ sudo touch /test/test.txt</pre>
			<p>Once you have done that, navigate to the folder mount point of <strong class="source-inline">/mnt/test</strong> and ensure you can view the file from <strong class="source-inline">rhel2</strong> using the <span class="No-Break">following commands:</span></p>
			<pre class="source-code">
[emcleroy@rhel2 ~]$ cd /mnt/test
[emcleroy@rhel2 test]$ ls -l
total 0
-rw-r--r--. 1 root root 0 Oct 27 13:05 test.txt
[emcleroy@rhel2 test]$</pre>
			<p>As you can see, you are able to view the file. Now, try to add a file to the <strong class="source-inline">/mnt/test</strong> folder on <strong class="source-inline">rhel2</strong> and you<a id="_idIndexMarker622"/> should receive an error message, such as the one shown in the following screenshot, as this is a <span class="No-Break">read-only share:</span></p>
			<div>
				<div id="_idContainer254" class="IMG---Figure">
					<img src="image/Figure_9.34_B18607.jpg" alt="Figure 9.34 – Demonstration of being unable to write to any file within the share from outside of the server"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.34 – Demonstration of being unable to write to any file within the share from outside of the server</p>
			<p>Now, you have successfully mounted the read-only share, which will persist through a reboot as <strong class="source-inline">fstab</strong> mounts the listed mounts <span class="No-Break">at startup.</span></p>
			<p>Next, we will complete<a id="_idIndexMarker623"/> these manual tasks using Ansible Automation. We will use the following playbook to accomplish the mounting of <span class="No-Break">the share:</span></p>
			<pre class="source-code">
---
- name: Mount nfs share
  hosts: rhel2.example.com
  become: true
  become_method: sudo
  tasks:
    - name: Create mount directory
      file:
        path: /mnt/test
        state: directory
        mode: '0755'
    - name: Add fstab mount information
      lineinfile:
        path: /etc/fstab
        state: present
        line: '192.168.1.198:/test /mnt/test nfs defaults 0 0'
    - name: Remount fstab shares
      command:
        cmd: mount -a -v</pre>
			<p>After we have created the playbook, we will run it with the <strong class="source-inline">ansible-playbook -i inventory nfs_client.yml -u emcleroy -k --ask-become -v</strong> command. The following <a id="_idIndexMarker624"/>screenshot shows the successful execution of <span class="No-Break">the playbook:</span></p>
			<div>
				<div id="_idContainer255" class="IMG---Figure">
					<img src="image/Figure_9.35_B18607.jpg" alt="Figure 9.35 – Successful playbook run to mount NFS share"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.35 – Successful playbook run to mount NFS share</p>
			<h1 id="_idParaDest-113"><a id="_idTextAnchor122"/>Summary</h1>
			<p>In this chapter, we presented you with mock exam questions that you may be asked in some form on the exam itself. We explored what we have learned throughout this book through this comprehensive review. New ways of completing tasks were also shown in order for you to further enhance your abilities to answer the exam questions with ease. In the next chapter, we will look over some exam tips to save you both time and stress when taking the exam. We will go over different ways to approach the exam to effectively meet the requirements and pass. I look forward to providing these tips and tricks, and hope you benefit in some way from them and my own experience of taking these exams over <span class="No-Break">the years.</span></p>
		</div>
	</body></html>