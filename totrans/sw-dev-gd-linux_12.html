<html><head></head><body>
<div class="Basic-Text-Frame" id="_idContainer065">
<h1 class="chapterNumber"><span class="koboSpan" id="kobo.1.1">12</span></h1>
<h1 class="chapterTitle" id="_idParaDest-240"><span class="koboSpan" id="kobo.2.1">Automating Tasks with Shell Scripts</span></h1>
<p class="normal"><span class="koboSpan" id="kobo.3.1">Sometimes, you’ll find yourself repeating the same few commands over and over, perhaps with slight variations. </span><span class="koboSpan" id="kobo.3.2">You reach the point of frustration, and say, “That’s it; I’m scripting this.” </span><span class="koboSpan" id="kobo.3.3">Being a CLI wizard, you do the following:</span></p>
<ol class="numberedList" style="list-style-type: decimal;">
<li class="numberedList" value="1"><span class="koboSpan" id="kobo.4.1">Run </span><code class="inlineCode"><span class="koboSpan" id="kobo.5.1">tail -n 20 ~/.bash_history &gt; myscript.sh</span></code><span class="koboSpan" id="kobo.6.1"> to create a file that contains the last 20 Bash commands you ran.</span></li>
<li class="numberedList"><span class="koboSpan" id="kobo.7.1">Then run </span><code class="inlineCode"><span class="koboSpan" id="kobo.8.1">bash myscript.sh</span></code><span class="koboSpan" id="kobo.9.1"> to execute it.</span></li>
</ol>
<p class="normal"><span class="koboSpan" id="kobo.10.1">Although this isn’t the recommended procedure (we’ll get to that in this chapter), it’s a perfectly valid way to create and run a Bash script.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.11.1">This chapter is a Bash scripting crash course. </span><span class="koboSpan" id="kobo.11.2">Like any programming crash course, it is completely useless unless you actually follow along, type in all the code yourself, and run it in your own Linux environment. </span><span class="koboSpan" id="kobo.11.3">In addition to showing you the subset of Bash’s syntax which is considered modern and best-practice, we’ll give you plenty of tips from our hard-earned experience over the years, calling out common pitfalls and sharp edges.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.12.1">Bash isn’t our favorite language, but sometimes it’s exactly the right tool for the problem you face. </span><span class="koboSpan" id="kobo.12.2">We’ll try to give you an understanding of this as well.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.13.1">In this chapter, we will cover the following:</span></p>
<ul>
<li class="bulletList"><span class="koboSpan" id="kobo.14.1">Bash scripting basics</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.15.1">Bash versus other shells</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.16.1">Shebangs and executable text files</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.17.1">Testing</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.18.1">Conditionals</span></li>
</ul>
<h1 class="heading-1" id="_idParaDest-241"><span class="koboSpan" id="kobo.19.1">Why you need Bash scripting basics</span></h1>
<p class="normal"><span class="koboSpan" id="kobo.20.1">Shell scripts</span><a id="_idIndexMarker397"/><span class="koboSpan" id="kobo.21.1"> are </span><a id="_idIndexMarker398"/><span class="koboSpan" id="kobo.22.1">an indispensable tool for any developer; even if you’re not writing scripts on a weekly basis, you’ll be reading them. </span><span class="koboSpan" id="kobo.22.2">In this chapter, we’ll cover the basics you need to know so that you feel comfortable when, for example:</span></p>
<ul>
<li class="bulletList"><span class="koboSpan" id="kobo.23.1">You’re confronted by a shell script that someone wrote a few years ago, for example “Can you check to see if we can reuse the automation scripts that Steve wrote before he left for Google?”</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.24.1">You see an opportunity to write your own shell script, when you have a job that existing shell programs already solve (filtering, searching, sorting output, and feeding one program’s output into another one).</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.25.1">You want to control precisely what goes into each Docker layer as you build up an image.</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.26.1">You need to coordinate other software in the context of a Linux server’s operating system: startup ordering, error checking, aborting early between programs, and so on.</span></li>
</ul>
<p class="normal"><span class="koboSpan" id="kobo.27.1">There are innumerable use cases where a shell script is </span><em class="italic"><span class="koboSpan" id="kobo.28.1">just</span></em><span class="koboSpan" id="kobo.29.1"> the right size and shape for your problem space. </span><span class="koboSpan" id="kobo.29.2">After this chapter, you’ll have the skills you need to write that custom script.</span></p>
<h1 class="heading-1" id="_idParaDest-242"><span class="koboSpan" id="kobo.30.1">Basics</span></h1>
<p class="normal"><span class="koboSpan" id="kobo.31.1">Bash can be </span><a id="_idIndexMarker399"/><span class="koboSpan" id="kobo.32.1">learned like any other programming language. </span><span class="koboSpan" id="kobo.32.2">It’s got an environment (Unix or Linux), a kind of standard library (any CLI-driven program installed on the system), variables, control flow (loops, testing, and iteration), interpolation, a few built-in data structures (arrays, strings, and booleans – sort of), and more.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.33.1">This entire book assumes that you’re a software developer and, therefore, know how to program, so rather than teach you about these standard programming-language features, we’ll simply show you what they look like in Bash, along with some advice on idiomatic use (or common misuse).</span></p>
<h2 class="heading-2" id="_idParaDest-243"><span class="koboSpan" id="kobo.34.1">Variables</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.35.1">Like any</span><a id="_idIndexMarker400"/><span class="koboSpan" id="kobo.36.1"> programming language, Bash has variables that can either be empty or set to a value. </span><span class="koboSpan" id="kobo.36.2">Unset variables are simply “empty,” and Bash will happily use them without panicking unless you set the </span><code class="inlineCode"><span class="koboSpan" id="kobo.37.1">-u</span></code><span class="koboSpan" id="kobo.38.1"> (error on unset variables) option via </span><code class="inlineCode"><span class="koboSpan" id="kobo.39.1">set -u</span></code><span class="koboSpan" id="kobo.40.1">.</span></p>
<h3 class="heading-3" id="_idParaDest-244"><span class="koboSpan" id="kobo.41.1">Setting</span></h3>
<p class="normal"><span class="koboSpan" id="kobo.42.1">To set a variable, use the equals sign.</span></p>
<p class="normal"><code class="inlineCode"><span class="koboSpan" id="kobo.43.1">FOOBAR=nice</span></code><span class="koboSpan" id="kobo.44.1"> will set the </span><code class="inlineCode"><span class="koboSpan" id="kobo.45.1">FOOBAR</span></code><span class="koboSpan" id="kobo.46.1"> variable to the value </span><code class="inlineCode"><span class="koboSpan" id="kobo.47.1">nice</span></code><span class="koboSpan" id="kobo.48.1">.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.49.1">There are no types in Bash – it’s about as untyped as a programming language can get.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.50.1">A variable symbol itself can contain letters, numbers, and underscores, but may not start with a number.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.51.1">It is common practice to use uppercase variable names for environment variables and lowercase ones inside of Bash scripts. </span><span class="koboSpan" id="kobo.51.2">These variable names typically use underscores to separate individual words. </span><span class="koboSpan" id="kobo.51.3">When using numbers inside of variable names, avoid starting with digits. </span><span class="koboSpan" id="kobo.51.4">Bash forbids this. </span><span class="koboSpan" id="kobo.51.5">As with other languages, it’s a good practice for names to indicate what a variable is used for and whether it is a constant, or use a plural name for an array:</span></p>
<ul>
<li class="bulletList"><span class="koboSpan" id="kobo.52.1">Illegal: </span><code class="inlineCode"><span class="koboSpan" id="kobo.53.1">%foo&amp;bar=bad</span></code></li>
<li class="bulletList"><span class="koboSpan" id="kobo.54.1">Illegal: </span><code class="inlineCode"><span class="koboSpan" id="kobo.55.1">2foo_bar=bad</span></code></li>
<li class="bulletList"><span class="koboSpan" id="kobo.56.1">Legal but bad: </span><code class="inlineCode"><span class="koboSpan" id="kobo.57.1">foo_BAR123=still_very_bad</span></code></li>
<li class="bulletList"><span class="koboSpan" id="kobo.58.1">Good environment variable: </span><code class="inlineCode"><span class="koboSpan" id="kobo.59.1">PORT=443</span></code></li>
<li class="bulletList"><span class="koboSpan" id="kobo.60.1">Good: </span><code class="inlineCode"><span class="koboSpan" id="kobo.61.1">local_var=512</span></code></li>
<li class="bulletList"><span class="koboSpan" id="kobo.62.1">Good environment variable: </span><code class="inlineCode"><span class="koboSpan" id="kobo.63.1">FOO_BAR123=good</span></code></li>
<li class="bulletList"><span class="koboSpan" id="kobo.64.1">Good local array var: </span><code class="inlineCode"><span class="koboSpan" id="kobo.65.1">words=(foo bar baz)</span></code></li>
</ul>
<h2 class="heading-2" id="_idParaDest-245"><span class="koboSpan" id="kobo.66.1">Getting</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.67.1">To use a </span><a id="_idIndexMarker401"/><span class="koboSpan" id="kobo.68.1">variable, reference it with the </span><code class="inlineCode"><span class="koboSpan" id="kobo.69.1">$</span></code><span class="koboSpan" id="kobo.70.1"> character:</span></p>
<pre class="programlisting con"><code class="hljs-con"><span class="koboSpan" id="kobo.71.1">$ echo $FOOBAR
nice
</span></code></pre>
<h1 class="heading-1" id="_idParaDest-246"><span class="koboSpan" id="kobo.72.1">Bash versus other shells</span></h1>
<p class="normal"><span class="koboSpan" id="kobo.73.1">A huge variety of shell </span><a id="_idIndexMarker402"/><span class="koboSpan" id="kobo.74.1">programs exist for Unix-like environments; you could argue that one of the major reasons for Unix’s popularity is the fact that it’s always been an environment with essentially no barriers to scripting and automation.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.75.1">This chapter teaches you how to write your own scripts in Bash. </span><span class="koboSpan" id="kobo.75.2">Much of what you’ll learn here will also work on other shells (for example, </span><code class="inlineCode"><span class="koboSpan" id="kobo.76.1">ksh</span></code><span class="koboSpan" id="kobo.77.1"> and other common minimal shells that you’ll find at </span><code class="inlineCode"><span class="koboSpan" id="kobo.78.1">/bin/sh</span></code><span class="koboSpan" id="kobo.79.1">), but we’re focused on Bash here.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.80.1">If you’re writing a shell script, Bash strikes the perfect balance between wide availability and a language feature set that’s large enough to make it comfortable to write small programs.</span></p>
<h1 class="heading-1" id="_idParaDest-247"><span class="koboSpan" id="kobo.81.1">Shebangs and executable text files, aka scripts</span></h1>
<p class="normal"><span class="koboSpan" id="kobo.82.1">In Unix-like systems, a “script” is just an</span><a id="_idIndexMarker403"/><span class="koboSpan" id="kobo.83.1"> executable plaintext file. </span><span class="koboSpan" id="kobo.83.2">The operating system (often called “the kernel” in Linux) looks at the very first line to determine which interpreter to feed the file’s content into.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.84.1">That first line is the so-called “shebang” (or hashbang), and it consists of a hash and an exclamation mark (</span><code class="inlineCode"><span class="koboSpan" id="kobo.85.1">#!</span></code><span class="koboSpan" id="kobo.86.1">) character, followed</span><a id="_idIndexMarker404"/><span class="koboSpan" id="kobo.87.1"> by the path to the interpreter that is used to execute the file’s code. </span><span class="koboSpan" id="kobo.87.2">Here’s an example shebang line:</span></p>
<pre class="programlisting con"><code class="hljs-con"><span class="koboSpan" id="kobo.88.1">#!/usr/bin/env bash
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.89.1">When the kernels of Unix-like systems run a file with the executable bit set, they’ll take a look at the first bytes. </span><span class="koboSpan" id="kobo.89.2">This might contain a magic number. </span><span class="koboSpan" id="kobo.89.3">This number can be part of binary files or some human-readable character, like in the shebang. </span><span class="koboSpan" id="kobo.89.4">The kernel uses this information to know whether there is a proper way to execute it. </span><span class="koboSpan" id="kobo.89.5">This, for example, prevents situations where the kernel would try to execute an image file and crash. </span><span class="koboSpan" id="kobo.89.6">Depending on the system, the kernel or the shell will make sure that the command following is executed. </span><span class="koboSpan" id="kobo.89.7">The </span><code class="inlineCode"><span class="koboSpan" id="kobo.90.1">env</span></code><span class="koboSpan" id="kobo.91.1"> program will run the command and take the </span><code class="inlineCode"><span class="koboSpan" id="kobo.92.1">PATH</span></code><span class="koboSpan" id="kobo.93.1"> environment variable into account to find and execute </span><code class="inlineCode"><span class="koboSpan" id="kobo.94.1">bash</span></code><span class="koboSpan" id="kobo.95.1">.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.96.1">While a hash denotes a comment in most scripting languages and would, therefore, be ignored by the interpreter, this special comment at the beginning of a file tells the operating system which command to run to interpret the rest of the file. </span><span class="koboSpan" id="kobo.96.2">Here are some common examples you’ll see:</span></p>
<ul>
<li class="bulletList"><code class="inlineCode"><span class="koboSpan" id="kobo.97.1">#!/bin/sh</span></code><span class="koboSpan" id="kobo.98.1">: use this specific shell program at this specific filesystem location</span></li>
<li class="bulletList"><code class="inlineCode"><span class="koboSpan" id="kobo.99.1">#!/usr/bin/python3</span></code><span class="koboSpan" id="kobo.100.1">: use this specific Python binary</span></li>
<li class="bulletList"><code class="inlineCode"><span class="koboSpan" id="kobo.101.1">#!/usr/bin/env python</span></code><span class="koboSpan" id="kobo.102.1">: use the </span><code class="inlineCode"><span class="koboSpan" id="kobo.103.1">env</span></code><span class="koboSpan" id="kobo.104.1"> program to figure out which Python binary to use in this environment (different systems may have different versions of the same program installed, at different paths)</span></li>
</ul>
<p class="normal"><span class="koboSpan" id="kobo.105.1">While you will see all of these variants, the best option is to always use </span><code class="inlineCode"><span class="koboSpan" id="kobo.106.1">/usr/bin/env</span></code><span class="koboSpan" id="kobo.107.1"> for portability. </span><code class="inlineCode"><span class="koboSpan" id="kobo.108.1">/bin/sh</span></code><span class="koboSpan" id="kobo.109.1"> is the exception here, since every POSIX-compatible system is required to have a POSIX-compatible shell in this location.</span></p>
<h2 class="heading-2" id="_idParaDest-248"><span class="koboSpan" id="kobo.110.1">Common Bash settings (options/arguments)</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.111.1">Since the shebang line is </span><a id="_idIndexMarker405"/><span class="koboSpan" id="kobo.112.1">executed as a command, arguments may also be passed. </span><span class="koboSpan" id="kobo.112.2">And while it can be a good idea to keep things simple, a common theme is to pass extra arguments to shells, especially to Bash, which is often used for large scripts because it has extra features compared to the smaller shells usually found at </span><code class="inlineCode"><span class="koboSpan" id="kobo.113.1">/bin/sh</span></code><span class="koboSpan" id="kobo.114.1">.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.115.1">In Bash scripts, you will often see the </span><code class="inlineCode"><span class="koboSpan" id="kobo.116.1">-e</span></code><span class="koboSpan" id="kobo.117.1">, </span><code class="inlineCode"><span class="koboSpan" id="kobo.118.1">-u</span></code><span class="koboSpan" id="kobo.119.1">, </span><code class="inlineCode"><span class="koboSpan" id="kobo.120.1">-x</span></code><span class="koboSpan" id="kobo.121.1">, </span><code class="inlineCode"><span class="koboSpan" id="kobo.122.1">-o pipefail</span></code><span class="koboSpan" id="kobo.123.1"> arguments passed. </span><span class="koboSpan" id="kobo.123.2">You may find these arguments in the shebang line itself:</span></p>
<pre class="programlisting con"><code class="hljs-con"><span class="koboSpan" id="kobo.124.1">#!/usr/bin/env bash -euxo pipefail
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.125.1">Or, as the next statement, using the </span><code class="inlineCode"><span class="koboSpan" id="kobo.126.1">set</span></code><span class="koboSpan" id="kobo.127.1"> command in Bash, which sets arguments or options:</span></p>
<pre class="programlisting con"><code class="hljs-con"><span class="koboSpan" id="kobo.128.1">#!/usr/bin/env bash
set -eu -o pipefail
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.129.1">Setting these options makes Bash behave a bit more like the programming languages you’re used to, by:</span></p>
<ul>
<li class="bulletList"><span class="koboSpan" id="kobo.130.1">Exiting immediately if any component of a command pipeline fails, and</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.131.1">Treating unset variables as fatal errors.</span></li>
</ul>
<p class="normal"><span class="koboSpan" id="kobo.132.1">Here’s a breakdown of the documentation for these options, along with a useful debug option (</span><code class="inlineCode"><span class="koboSpan" id="kobo.133.1">-x</span></code><span class="koboSpan" id="kobo.134.1">) as a bonus:</span></p>
<ul>
<li class="bulletList"><code class="inlineCode"><span class="koboSpan" id="kobo.135.1">-o pipefail</span></code><span class="koboSpan" id="kobo.136.1">: When using pipes, this will make sure that errors happening in the pipeline will be passed on. </span><span class="koboSpan" id="kobo.136.2">If more than one error happens, the rightmost will be used.</span></li>
<li class="bulletList"><code class="inlineCode"><span class="koboSpan" id="kobo.137.1">-e</span></code><span class="koboSpan" id="kobo.138.1">: If there is an error or a command fails, this will make sure that the shell script exits immediately.</span></li>
<li class="bulletList"><code class="inlineCode"><span class="koboSpan" id="kobo.139.1">-u</span></code><span class="koboSpan" id="kobo.140.1">: throw an error if any unset variables are used.</span></li>
</ul>
<p class="normal"><span class="koboSpan" id="kobo.141.1">For debugging, </span><code class="inlineCode"><span class="koboSpan" id="kobo.142.1">-x</span></code><span class="koboSpan" id="kobo.143.1"> is useful:</span></p>
<ul>
<li class="bulletList"><code class="inlineCode"><span class="koboSpan" id="kobo.144.1">-x</span></code><span class="koboSpan" id="kobo.145.1">: This will enable tracing. </span><span class="koboSpan" id="kobo.145.2">This </span><a id="_idIndexMarker406"/><span class="koboSpan" id="kobo.146.1">means that each command will be written to standard error before executing it.</span></li>
</ul>
<p class="normal"><span class="koboSpan" id="kobo.147.1">All arguments, except </span><code class="inlineCode"><span class="koboSpan" id="kobo.148.1">–o pipefail</span></code><span class="koboSpan" id="kobo.149.1">, can be found in most Unix shells. </span><span class="koboSpan" id="kobo.149.2">For more information on the options that Bash contains, see its manual page: </span><a href="https://manpages.org/bash"><span class="url"><span class="koboSpan" id="kobo.150.1">https://manpages.org/bash</span></span></a><span class="koboSpan" id="kobo.151.1">.</span></p>
<h2 class="heading-2" id="_idParaDest-249"><span class="koboSpan" id="kobo.152.1">/usr/bin/env</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.153.1">Here’s something to</span><a id="_idIndexMarker407"/><span class="koboSpan" id="kobo.154.1"> keep in mind: </span><code class="inlineCode"><span class="koboSpan" id="kobo.155.1">/bin/sh</span></code><span class="koboSpan" id="kobo.156.1"> is a standardized path in POSIX leading to any POSIX-compatible shell. </span><span class="koboSpan" id="kobo.156.2">You can count on it to be there on ANY Linux or Unix system. </span><span class="koboSpan" id="kobo.156.3">Typically, this is not bash, but a more minimal shell, offering just enough functionality to satisfy the POSIX standard, which allows you to write very portable shell scripts. </span><span class="koboSpan" id="kobo.156.4">For all other shells and interpreters your script might need, it’s best practice to use the </span><code class="inlineCode"><span class="koboSpan" id="kobo.157.1">#!/usr/bin/env</span></code><span class="koboSpan" id="kobo.158.1"> prefix for any other case. </span><span class="koboSpan" id="kobo.158.2">This makes sure that the correct path from </span><code class="inlineCode"><span class="koboSpan" id="kobo.159.1">PATH</span></code><span class="koboSpan" id="kobo.160.1"> is used, and it will prevent a “command not found” error when the binary isn’t located in </span><code class="inlineCode"><span class="koboSpan" id="kobo.161.1">/usr/bin/</span></code><span class="koboSpan" id="kobo.162.1">.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.163.1">There are various scenarios in which </span><code class="inlineCode"><span class="koboSpan" id="kobo.164.1">/usr/bin/bash</span></code><span class="koboSpan" id="kobo.165.1"> or </span><code class="inlineCode"><span class="koboSpan" id="kobo.166.1">/bin/bash</span></code><span class="koboSpan" id="kobo.167.1"> wouldn’t be the right path. </span><span class="koboSpan" id="kobo.167.2">For example:</span></p>
<ul>
<li class="bulletList"><span class="koboSpan" id="kobo.168.1">A package manager or company-specific configuration scripts will often install the interpreter in a different place than it would be on your development system.</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.169.1">Someone installing software manually, for example, to work around or reproduce a bug, often places the resulting binary in </span><code class="inlineCode"><span class="koboSpan" id="kobo.170.1">/usr/local</span></code><span class="koboSpan" id="kobo.171.1">.</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.172.1">Virtual environments of various scripting languages will put binaries into a subdirectory of each source code </span><code class="inlineCode"><span class="koboSpan" id="kobo.173.1">project/repository</span></code><span class="koboSpan" id="kobo.174.1">.</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.175.1">People installing the interpreter without root permissions, for example, in their home directory.</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.176.1">People using a version manager for the interpreter (rvm, nvm, and so on).</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.177.1">Various Unix-like operating systems and some Linux distributions don’t install third-party packages into </span><code class="inlineCode"><span class="koboSpan" id="kobo.178.1">/usr/</span></code><span class="koboSpan" id="kobo.179.1">.</span></li>
</ul>
<p class="normal"><span class="koboSpan" id="kobo.180.1">While many people can’t imagine their script ever ending up in such a non-standard place, chances are good that you’ll run into this eventually. </span><span class="koboSpan" id="kobo.180.2">Instead of risking your software breaking in these cases, it’s a good idea to simply get into the habit of writing </span><code class="inlineCode"><span class="koboSpan" id="kobo.181.1">/usr/bin/env bash</span></code><span class="koboSpan" id="kobo.182.1"> (or whatever interpreter your code is written for) in your scripts. </span><span class="koboSpan" id="kobo.182.2">This prevents someone else – or your very tired future self, woken up by a pager at 3 in the morning – from</span><a id="_idIndexMarker408"/><span class="koboSpan" id="kobo.183.1"> having to notice, troubleshoot, find, or make such changes on source files when they break due to a minor change in the environment.</span></p>
<h2 class="heading-2" id="_idParaDest-250"><span class="koboSpan" id="kobo.184.1">Special characters and escaping</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.185.1">One special character you </span><a id="_idIndexMarker409"/><span class="koboSpan" id="kobo.186.1">should use often is the hash symbol (</span><code class="inlineCode"><span class="koboSpan" id="kobo.187.1">#</span></code><span class="koboSpan" id="kobo.188.1">), which makes everything on the line following the symbol a comment that the interpreter ignores.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.189.1">Other characters have special meaning in Bash, and they need to be escaped with a forward slash (</span><code class="inlineCode"><span class="koboSpan" id="kobo.190.1">\</span></code><span class="koboSpan" id="kobo.191.1">) when you use them as part of a variable’s value. </span><span class="koboSpan" id="kobo.191.2">Here are some of them:</span></p>
<ul>
<li class="bulletList"><span class="koboSpan" id="kobo.192.1">Quotes (</span><code class="inlineCode"><span class="koboSpan" id="kobo.193.1">"</span></code><span class="koboSpan" id="kobo.194.1"> and </span><code class="inlineCode"><span class="koboSpan" id="kobo.195.1">'</span></code><span class="koboSpan" id="kobo.196.1">)</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.197.1">Brackets and parentheses (</span><code class="inlineCode"><span class="koboSpan" id="kobo.198.1">{</span></code><span class="koboSpan" id="kobo.199.1">, </span><code class="inlineCode"><span class="koboSpan" id="kobo.200.1">}</span></code><span class="koboSpan" id="kobo.201.1">, </span><code class="inlineCode"><span class="koboSpan" id="kobo.202.1">[</span></code><span class="koboSpan" id="kobo.203.1">, </span><code class="inlineCode"><span class="koboSpan" id="kobo.204.1">]</span></code><span class="koboSpan" id="kobo.205.1">, and </span><code class="inlineCode"><span class="koboSpan" id="kobo.206.1">(</span></code><span class="koboSpan" id="kobo.207.1">, </span><code class="inlineCode"><span class="koboSpan" id="kobo.208.1">)</span></code><span class="koboSpan" id="kobo.209.1">)</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.210.1">Carets (</span><code class="inlineCode"><span class="koboSpan" id="kobo.211.1">&lt;</span></code><span class="koboSpan" id="kobo.212.1"> and </span><code class="inlineCode"><span class="koboSpan" id="kobo.213.1">&gt;</span></code><span class="koboSpan" id="kobo.214.1">)</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.215.1">Tilde: </span><code class="inlineCode"><span class="koboSpan" id="kobo.216.1">~</span></code></li>
<li class="bulletList"><span class="koboSpan" id="kobo.217.1">Asterisk (the “glob character” in Bash): </span><code class="inlineCode"><span class="koboSpan" id="kobo.218.1">*</span></code></li>
<li class="bulletList"><span class="koboSpan" id="kobo.219.1">Ampersand: </span><code class="inlineCode"><span class="koboSpan" id="kobo.220.1">&amp;</span></code></li>
<li class="bulletList"><span class="koboSpan" id="kobo.221.1">Question mark: </span><code class="inlineCode"><span class="koboSpan" id="kobo.222.1">?</span></code></li>
<li class="bulletList"><span class="koboSpan" id="kobo.223.1">Common operators: </span><code class="inlineCode"><span class="koboSpan" id="kobo.224.1">!</span></code><span class="koboSpan" id="kobo.225.1">, </span><code class="inlineCode"><span class="koboSpan" id="kobo.226.1">=</span></code><span class="koboSpan" id="kobo.227.1">, </span><code class="inlineCode"><span class="koboSpan" id="kobo.228.1">|</span></code><span class="koboSpan" id="kobo.229.1">, and so on</span></li>
</ul>
<p class="normal"><span class="koboSpan" id="kobo.230.1">Escape them like you do in most other programming languages:</span></p>
<pre class="programlisting con"><code class="hljs-con"><span class="koboSpan" id="kobo.231.1">$ FOO="jaa\$\'"
</span></code></pre>
<h2 class="heading-2" id="_idParaDest-251"><span class="koboSpan" id="kobo.232.1">Command substitution</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.233.1">One of the benefits and </span><a id="_idIndexMarker410"/><span class="koboSpan" id="kobo.234.1">major use cases of shell scripting is that any command is easily accessible. </span><span class="koboSpan" id="kobo.234.2">A very common example of this is command substitution. </span><span class="koboSpan" id="kobo.234.3">This is useful when you want to use the output of one or more commands. </span><span class="koboSpan" id="kobo.234.4">You can do this with command substitution:</span></p>
<pre class="programlisting con"><code class="hljs-con"><span class="koboSpan" id="kobo.235.1">echo "Right now, it's $(date)"
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.236.1">This executes those commands – in this case, just </span><code class="inlineCode"><span class="koboSpan" id="kobo.237.1">date</span></code><span class="koboSpan" id="kobo.238.1">, but it could also be a complex expression that you’ve piped together. </span><span class="koboSpan" id="kobo.238.2">Another way to do the same is to use backticks. </span><span class="koboSpan" id="kobo.238.3">The following </span><a id="_idIndexMarker411"/><span class="koboSpan" id="kobo.239.1">example will have the same output:</span></p>
<pre class="programlisting con"><code class="hljs-con"><span class="koboSpan" id="kobo.240.1">echo "Right now, it's `date`"
</span></code></pre>
<h1 class="heading-1" id="_idParaDest-252"><span class="koboSpan" id="kobo.241.1">Testing</span></h1>
<p class="normal"><span class="koboSpan" id="kobo.242.1">The testing commands</span><a id="_idIndexMarker412"/><span class="koboSpan" id="kobo.243.1"> shown here are usually used along with </span><code class="inlineCode"><span class="koboSpan" id="kobo.244.1">if/else</span></code><span class="koboSpan" id="kobo.245.1"> control flow statements. </span><span class="koboSpan" id="kobo.245.2">Both the string testing function (</span><code class="inlineCode"><span class="koboSpan" id="kobo.246.1">[[</span></code><span class="koboSpan" id="kobo.247.1">) and the arithmetic testing function (</span><code class="inlineCode"><span class="koboSpan" id="kobo.248.1">((</span></code><span class="koboSpan" id="kobo.249.1">) return 0 if the test evaluates to a </span><code class="inlineCode"><span class="koboSpan" id="kobo.250.1">true</span></code><span class="koboSpan" id="kobo.251.1"> value, or 1 if the test evaluates to </span><code class="inlineCode"><span class="koboSpan" id="kobo.252.1">false</span></code><span class="koboSpan" id="kobo.253.1">. </span><span class="koboSpan" id="kobo.253.2">This is due to the 0 exit code of commands indicating success, and it is different from other programming languages you might know that typically evaluate a zero value as false. </span><span class="koboSpan" id="kobo.253.3">There is no native </span><code class="inlineCode"><span class="koboSpan" id="kobo.254.1">boolean</span></code><span class="koboSpan" id="kobo.255.1"> data type in Bash; the integers 0 and 1 are used in boolean contexts like this one. </span><span class="koboSpan" id="kobo.255.2">Sometimes, the variables </span><code class="inlineCode"><span class="koboSpan" id="kobo.256.1">true</span></code><span class="koboSpan" id="kobo.257.1"> and </span><code class="inlineCode"><span class="koboSpan" id="kobo.258.1">false</span></code><span class="koboSpan" id="kobo.259.1"> are initialized and used throughout a script.</span></p>
<h2 class="heading-2" id="_idParaDest-253"><span class="koboSpan" id="kobo.260.1">Testing operators</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.261.1">Here are some basic boolean</span><a id="_idIndexMarker413"/><span class="koboSpan" id="kobo.262.1"> operators that you can use to construct statements in Bash – essentially, what you’re used to from other languages:</span></p>
<ul>
<li class="bulletList"><code class="inlineCode"><span class="koboSpan" id="kobo.263.1">!</span></code><span class="koboSpan" id="kobo.264.1"> – not (negation)</span></li>
<li class="bulletList"><code class="inlineCode"><span class="koboSpan" id="kobo.265.1">&amp;&amp;</span></code><span class="koboSpan" id="kobo.266.1"> – and</span></li>
<li class="bulletList"><code class="inlineCode"><span class="koboSpan" id="kobo.267.1">||</span></code><span class="koboSpan" id="kobo.268.1"> – or</span></li>
</ul>
<p class="normal"><span class="koboSpan" id="kobo.269.1">These operators can be used with both string and arithmetic test types:</span></p>
<ul>
<li class="bulletList"><code class="inlineCode"><span class="koboSpan" id="kobo.270.1">==</span></code><span class="koboSpan" id="kobo.271.1"> – is equal to</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.272.1">!= is not equal to</span></li>
</ul>
<h2 class="heading-2" id="_idParaDest-254"><span class="koboSpan" id="kobo.273.1">[[ file and string testing ]]</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.274.1">The </span><code class="inlineCode"><span class="koboSpan" id="kobo.275.1">[[</span></code><span class="koboSpan" id="kobo.276.1"> compound command allows you to perform (and combine) “string” comparisons. </span><span class="koboSpan" id="kobo.276.2">As mentioned before, Bash doesn’t have the kind of strict data types that you’re used to from other programming languages, so we’re calling them “string” or “string-like” comparisons because that’s a familiar concept to software developers.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.277.1">If the user’s home directory does not exist, create it:</span></p>
<pre class="programlisting con"><code class="hljs-con"><span class="koboSpan" id="kobo.278.1">if [[ ! </span><span class="koboSpan" id="kobo.278.2">-d $HOME ]]; then
    echo "Creating home directory: ${HOME}..."
    </span><span class="koboSpan" id="kobo.278.3">mkdir -p $HOME
    echo "done"
fi
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.279.1">That </span><code class="inlineCode"><span class="koboSpan" id="kobo.280.1">!</span></code><span class="koboSpan" id="kobo.281.1"> character is a Bash negation, so you can read the first line of this example as </span><code class="inlineCode"><span class="koboSpan" id="kobo.282.1">if NOT (test) is-a-directory $HOME, then…</span></code><span class="koboSpan" id="kobo.283.1">.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.284.1">Here’s a slightly more complicated example. </span><span class="koboSpan" id="kobo.284.2">If the user’s home directory does not exist, </span><code class="inlineCode"><span class="koboSpan" id="kobo.285.1">OR</span></code><span class="koboSpan" id="kobo.286.1"> if the </span><code class="inlineCode"><span class="koboSpan" id="kobo.287.1">ALWAYSCREATE</span></code><span class="koboSpan" id="kobo.288.1"> variable is set to </span><code class="inlineCode"><span class="koboSpan" id="kobo.289.1">yes</span></code><span class="koboSpan" id="kobo.290.1">, create the home directory:</span></p>
<pre class="programlisting con"><code class="hljs-con"><span class="koboSpan" id="kobo.291.1">ALWAYSCREATE=yes
if ! </span><span class="koboSpan" id="kobo.291.2">[[ -d $HOME ]] || [[ $ALWAYSCREATE == yes ]]; then
    echo "Creating home directory: ${HOME}..."
    </span><span class="koboSpan" id="kobo.291.3">mkdir -p $HOME
    echo "done"
fi
</span></code></pre>
<h3 class="heading-3" id="_idParaDest-255"><span class="koboSpan" id="kobo.292.1">Useful operators for string testing</span></h3>
<ul>
<li class="bulletList"><code class="inlineCode"><span class="koboSpan" id="kobo.293.1">-z</span></code><span class="koboSpan" id="kobo.294.1"> is </span><a id="_idIndexMarker414"/><span class="koboSpan" id="kobo.295.1">unset (used for variables)</span></li>
<li class="bulletList"><code class="inlineCode"><span class="koboSpan" id="kobo.296.1">-n</span></code><span class="koboSpan" id="kobo.297.1"> is non-zero (</span><code class="inlineCode"><span class="koboSpan" id="kobo.298.1">set</span></code><span class="koboSpan" id="kobo.299.1"> – used for variables)</span></li>
<li class="bulletList"><code class="inlineCode"><span class="koboSpan" id="kobo.300.1">=~</span></code><span class="koboSpan" id="kobo.301.1"> is a left operand that matches a regular expression (right operand), for example </span><code class="inlineCode"><span class="koboSpan" id="kobo.302.1">[[ foobar =~ f*bar ]]</span></code></li>
</ul>
<h3 class="heading-3" id="_idParaDest-256"><span class="koboSpan" id="kobo.303.1">Useful operators for file testing</span></h3>
<ul>
<li class="bulletList"><code class="inlineCode"><span class="koboSpan" id="kobo.304.1">-d</span></code><span class="koboSpan" id="kobo.305.1">: a directory</span></li>
<li class="bulletList"><code class="inlineCode"><span class="koboSpan" id="kobo.306.1">-e</span></code><span class="koboSpan" id="kobo.307.1">: exists</span></li>
<li class="bulletList"><code class="inlineCode"><span class="koboSpan" id="kobo.308.1">-f</span></code><span class="koboSpan" id="kobo.309.1">: a regular file</span></li>
<li class="bulletList"><code class="inlineCode"><span class="koboSpan" id="kobo.310.1">-S</span></code><span class="koboSpan" id="kobo.311.1">: a socket file</span></li>
<li class="bulletList"><code class="inlineCode"><span class="koboSpan" id="kobo.312.1">-w</span></code><span class="koboSpan" id="kobo.313.1">: writable, from the perspective of this Bash process</span></li>
</ul>
<h2 class="heading-2" id="_idParaDest-257"><span class="koboSpan" id="kobo.314.1">(( arithmetic testing ))</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.315.1">Arithmetic evaluated in a </span><code class="inlineCode"><span class="koboSpan" id="kobo.316.1">((</span></code><span class="koboSpan" id="kobo.317.1"> test will set the test’s exit value to 1 if the expression evaluates to 0; otherwise, it will return an exit status of 0. </span><span class="koboSpan" id="kobo.317.2">This makes testing quite intuitive, using operators you already know from virtually every other programming language:</span></p>
<ul>
<li class="bulletList"><code class="inlineCode"><span class="koboSpan" id="kobo.318.1">&gt;</span></code><span class="koboSpan" id="kobo.319.1"> and </span><code class="inlineCode"><span class="koboSpan" id="kobo.320.1">&gt;=</span></code><span class="koboSpan" id="kobo.321.1"> – greater-than and greater-than or equal-to</span></li>
<li class="bulletList"><code class="inlineCode"><span class="koboSpan" id="kobo.322.1">&lt;</span></code><span class="koboSpan" id="kobo.323.1"> and </span><code class="inlineCode"><span class="koboSpan" id="kobo.324.1">&lt;=</span></code><span class="koboSpan" id="kobo.325.1"> – less-than and less-than or equal-to</span></li>
<li class="bulletList"><code class="inlineCode"><span class="koboSpan" id="kobo.326.1">==</span></code><span class="koboSpan" id="kobo.327.1"> – test equality</span></li>
</ul>
<p class="normal"><code class="inlineCode"><span class="koboSpan" id="kobo.328.1">(( $SOME_NUMBER == 24 ))</span></code><span class="koboSpan" id="kobo.329.1"> is a fairly straightforward arithmetic test. </span><span class="koboSpan" id="kobo.329.2">Let’s see how it behaves.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.330.1">For the number 24:</span></p>
<pre class="programlisting con"><code class="hljs-con"><span class="koboSpan" id="kobo.331.1">→ SOME_NUMBER=24
→ (( $SOME_NUMBER == 24 ))
→ echo $?
</span><span class="koboSpan" id="kobo.331.2">0
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.332.1">The “</span><code class="inlineCode"><span class="koboSpan" id="kobo.333.1">echo $?</span></code><span class="koboSpan" id="kobo.334.1">" command prints out the exit status of the previous command, which lets us see what the arithmetic test actually evaluated to. </span><span class="koboSpan" id="kobo.334.2">For other values, including non-numeric ones:</span></p>
<pre class="programlisting con"><code class="hljs-con"><span class="koboSpan" id="kobo.335.1">→ SOME_NUMBER=foobar
→ (( $SOME_NUMBER == 24 ))
→ echo $?
</span><span class="koboSpan" id="kobo.335.2">1
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.336.1">If </span><code class="inlineCode"><span class="koboSpan" id="kobo.337.1">$SOME_NUMBER</span></code><span class="koboSpan" id="kobo.338.1"> is </span><a id="_idIndexMarker415"/><span class="koboSpan" id="kobo.339.1">unset (for example, </span><code class="inlineCode"><span class="koboSpan" id="kobo.340.1">[[ -z $SOME_NUMBER ]]</span></code><span class="koboSpan" id="kobo.341.1"> ):</span></p>
<pre class="programlisting con"><code class="hljs-con"><span class="koboSpan" id="kobo.342.1">→ unset SOME_NUMBER
→ (( $SOME_NUMBER == 24 ))
zsh: bad math expression: operand expected at `== 24 '
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.343.1">So, to review:</span></p>
<ul>
<li class="bulletList"><code class="inlineCode"><span class="koboSpan" id="kobo.344.1">(( $SOME_NUMBER == 24 ))</span></code><span class="koboSpan" id="kobo.345.1"> will evaluate to 0 if the </span><code class="inlineCode"><span class="koboSpan" id="kobo.346.1">SOME_NUMBER</span></code><span class="koboSpan" id="kobo.347.1"> variable is set to 24.</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.348.1">If </span><code class="inlineCode"><span class="koboSpan" id="kobo.349.1">$SOME_NUMBER</span></code><span class="koboSpan" id="kobo.350.1"> is set to a value </span><code class="inlineCode"><span class="koboSpan" id="kobo.351.1">OTHER THAN 24</span></code><span class="koboSpan" id="kobo.352.1"> (including a non-numeric value), it will evaluate to 1.</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.353.1">If </span><code class="inlineCode"><span class="koboSpan" id="kobo.354.1">$SOME_NUMBER</span></code><span class="koboSpan" id="kobo.355.1"> is </span><em class="italic"><span class="koboSpan" id="kobo.356.1">unset</span></em><span class="koboSpan" id="kobo.357.1">, you’ll get an error because your arithmetic test doesn’t have a left operand to use for the comparison.</span></li>
</ul>
<h1 class="heading-1" id="_idParaDest-258"><span class="koboSpan" id="kobo.358.1">Conditionals: if/then/else</span></h1>
<p class="normal"><span class="koboSpan" id="kobo.359.1">A Bash </span><code class="inlineCode"><span class="koboSpan" id="kobo.360.1">if</span></code><span class="koboSpan" id="kobo.361.1"> statement</span><a id="_idIndexMarker416"/><span class="koboSpan" id="kobo.362.1"> is usually found in this form:</span></p>
<p class="normal"><code class="inlineCode"><span class="koboSpan" id="kobo.363.1">if [[ $TEST ]]; then $STATEMENTS else $OTHER_STATEMENTS fi</span></code></p>
<p class="normal"><span class="koboSpan" id="kobo.364.1">Remember a few things about this form before we look at examples:</span></p>
<ul>
<li class="bulletList"><code class="inlineCode"><span class="koboSpan" id="kobo.365.1">if</span></code><span class="koboSpan" id="kobo.366.1"> and </span><code class="inlineCode"><span class="koboSpan" id="kobo.367.1">fi</span></code><span class="koboSpan" id="kobo.368.1"> begin and terminate the </span><code class="inlineCode"><span class="koboSpan" id="kobo.369.1">if</span></code><span class="koboSpan" id="kobo.370.1"> block, respectively.</span></li>
<li class="bulletList"><code class="inlineCode"><span class="koboSpan" id="kobo.371.1">;</span></code><span class="koboSpan" id="kobo.372.1"> delimits statements in Bash; add one right after the test.</span></li>
<li class="bulletList"><code class="inlineCode"><span class="koboSpan" id="kobo.373.1">[[</span></code><span class="koboSpan" id="kobo.374.1"> and </span><code class="inlineCode"><span class="koboSpan" id="kobo.375.1">]]</span></code><span class="koboSpan" id="kobo.376.1"> delimit your test expression.</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.377.1">The </span><code class="inlineCode"><span class="koboSpan" id="kobo.378.1">else</span></code><span class="koboSpan" id="kobo.379.1"> clause is optional.</span></li>
</ul>
<p class="normal"><span class="koboSpan" id="kobo.380.1">Here’s what the </span><code class="inlineCode"><span class="koboSpan" id="kobo.381.1">if</span></code><span class="koboSpan" id="kobo.382.1"> statement</span><a id="_idIndexMarker417"/><span class="koboSpan" id="kobo.383.1"> looks like in Bash:</span></p>
<pre class="programlisting con"><code class="hljs-con"><span class="koboSpan" id="kobo.384.1">if [[ -e "example.txt" ]]; then
    echo "The file exists!"
</span></code></pre>
<h3 class="heading-3" id="_idParaDest-259"><span class="koboSpan" id="kobo.385.1">ifelse</span></h3>
<p class="normal"><span class="koboSpan" id="kobo.386.1">If you want to</span><a id="_idIndexMarker418"/><span class="koboSpan" id="kobo.387.1"> tack an </span><code class="inlineCode"><span class="koboSpan" id="kobo.388.1">else</span></code><span class="koboSpan" id="kobo.389.1"> clause</span><a id="_idIndexMarker419"/><span class="koboSpan" id="kobo.390.1"> onto this structure, you can!</span></p>
<pre class="programlisting con"><code class="hljs-con"><span class="koboSpan" id="kobo.391.1">if [[ -e "example.txt" ]]; then
    echo "The file exists!"
</span><span class="koboSpan" id="kobo.391.2">else
    echo "The file does not exist!"
</span><span class="koboSpan" id="kobo.391.3">fi
</span></code></pre>
<h1 class="heading-1" id="_idParaDest-260"><span class="koboSpan" id="kobo.392.1">Loops</span></h1>
<p class="normal"><span class="koboSpan" id="kobo.393.1">Bash loops</span><a id="_idIndexMarker420"/><span class="koboSpan" id="kobo.394.1"> come in the general format </span><code class="inlineCode"><span class="koboSpan" id="kobo.395.1">for / do / done</span></code><span class="koboSpan" id="kobo.396.1">. </span><span class="koboSpan" id="kobo.396.2">They also support </span><code class="inlineCode"><span class="koboSpan" id="kobo.397.1">break</span></code><span class="koboSpan" id="kobo.398.1"> and </span><code class="inlineCode"><span class="koboSpan" id="kobo.399.1">continue</span></code><span class="koboSpan" id="kobo.400.1"> statements, which break out of the loop and skip to the next iteration, respectively.</span></p>
<h2 class="heading-2" id="_idParaDest-261"><span class="koboSpan" id="kobo.401.1">C-style loops</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.402.1">Bash supports</span><a id="_idIndexMarker421"/><span class="koboSpan" id="kobo.403.1"> C-style loops, with an initializer expression, a conditional </span><a id="_idIndexMarker422"/><span class="koboSpan" id="kobo.404.1">expression, and a counting expression:</span></p>
<pre class="programlisting con"><code class="hljs-con"><span class="koboSpan" id="kobo.405.1">for (( i=0; i&lt;=9; i++ ))
do  
  echo "Loop var i is currently $i"
done
</span></code></pre>
<h2 class="heading-2" id="_idParaDest-262"><span class="koboSpan" id="kobo.406.1">for…in</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.407.1">Let’s talk about </span><a id="_idIndexMarker423"/><span class="koboSpan" id="kobo.408.1">iteration </span><a id="_idIndexMarker424"/><span class="koboSpan" id="kobo.409.1">with </span><code class="inlineCode"><span class="koboSpan" id="kobo.410.1">for...in</span></code><span class="koboSpan" id="kobo.411.1"> loops. </span><span class="koboSpan" id="kobo.411.2">Try running the following in your shell:</span></p>
<pre class="programlisting con"><code class="hljs-con"><span class="koboSpan" id="kobo.412.1">for i in 1 2 3 4 5
do
  echo $i
done
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.413.1">Here’s a loop with some control flow inside:</span></p>
<pre class="programlisting con"><code class="hljs-con"><span class="koboSpan" id="kobo.414.1">for os in FreeBSD Linux NetBSD "macOS" DragonflyBSD
do
  echo "Checking out ${os}..."
  </span><span class="koboSpan" id="kobo.414.2">if [[ "$os" == 'NetBSD' ]]; then
    echo "(I'm pretty sure this would run on my toaster, actually)"
  fi
  sleep 1
done
</span></code></pre>
<h2 class="heading-2" id="_idParaDest-263"><span class="koboSpan" id="kobo.415.1">While</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.416.1">Another common control </span><a id="_idIndexMarker425"/><span class="koboSpan" id="kobo.417.1">structure you might be familiar with from other programming languages is the </span><code class="inlineCode"><span class="koboSpan" id="kobo.418.1">while</span></code><span class="koboSpan" id="kobo.419.1"> loop. </span><span class="koboSpan" id="kobo.419.2">In Bash, this</span><a id="_idIndexMarker426"/><span class="koboSpan" id="kobo.420.1"> works very similarly. </span><span class="koboSpan" id="kobo.420.2">To break out of a loop, the </span><code class="inlineCode"><span class="koboSpan" id="kobo.421.1">break</span></code><span class="koboSpan" id="kobo.422.1"> statement can be used.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.423.1">The following script will read the </span><code class="inlineCode"><span class="koboSpan" id="kobo.424.1">lines.txt</span></code><span class="koboSpan" id="kobo.425.1"> file line by line until it encounters the </span><code class="inlineCode"><span class="koboSpan" id="kobo.426.1">STOP</span></code><span class="koboSpan" id="kobo.427.1"> line. </span><span class="koboSpan" id="kobo.427.2">The last line also shows how you can pipe a file into a loop. </span><span class="koboSpan" id="kobo.427.3">The </span><code class="inlineCode"><span class="koboSpan" id="kobo.428.1">read</span></code><span class="koboSpan" id="kobo.429.1"> command will take care of processing the file line by line:</span></p>
<pre class="programlisting con"><code class="hljs-con"><span class="koboSpan" id="kobo.430.1">file="lines.txt"
while read line; do
    if [[ $line == "STOP" ]]; then
        echo "Encountered STOP. </span><span class="koboSpan" id="kobo.430.2">Exiting loop."
        </span><span class="koboSpan" id="kobo.430.3">break
    fi
    echo "Processing: $line"
    # Additional commands to process $line can be added here.
</span><span class="koboSpan" id="kobo.430.4">done &lt; "$file"
</span></code></pre>
<h2 class="heading-2" id="_idParaDest-264"><span class="koboSpan" id="kobo.431.1">Variable exporting</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.432.1">Exporting a variable by</span><a id="_idIndexMarker427"/><span class="koboSpan" id="kobo.433.1"> prefixing it with </span><code class="inlineCode"><span class="koboSpan" id="kobo.434.1">export</span></code><span class="koboSpan" id="kobo.435.1"> ensures that any subshells spawned from your script’s process will also have access to that variable’s value. </span><span class="koboSpan" id="kobo.435.2">It’s a way of ensuring that a variable is propagated down to any future sub-scopes (or sub-namespaces) of your current shell’s variable scope or namespace.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.436.1">Set a variable in your shell:</span></p>
<pre class="programlisting con"><code class="hljs-con"><span class="koboSpan" id="kobo.437.1">MYDIR=$HOME
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.438.1">Create and run this script (warning: this will fail!):</span></p>
<pre class="programlisting con"><code class="hljs-con"><span class="koboSpan" id="kobo.439.1">#!/usr/bin/env bash
LISTING=$(ls "${MYDIR}/Documents")
echo $LISTING
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.440.1">You’ll see an error, </span><code class="inlineCode"><span class="koboSpan" id="kobo.441.1">ls: /Documents: No such file or directory</span></code><span class="koboSpan" id="kobo.442.1">, because running this script spawned a subshell that did not have access to unexported variables in its parent shell (the shell that spawned it, in other words your interactive shell). </span><span class="koboSpan" id="kobo.442.2">Letting subshells access your variables must be done explicitly, via the </span><code class="inlineCode"><span class="koboSpan" id="kobo.443.1">export</span></code><span class="koboSpan" id="kobo.444.1"> keyword:</span></p>
<pre class="programlisting con"><code class="hljs-con"><span class="koboSpan" id="kobo.445.1">export MYDIR=$HOME
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.446.1">Rerun the example script now that you’ve exported the variable, and you’ll see that it can now access the </span><code class="inlineCode"><span class="koboSpan" id="kobo.447.1">MYDIR</span></code><span class="koboSpan" id="kobo.448.1"> variable.</span></p>
<h1 class="heading-1" id="_idParaDest-265"><span class="koboSpan" id="kobo.449.1">Functions</span></h1>
<p class="normal"><span class="koboSpan" id="kobo.450.1">We generally</span><a id="_idIndexMarker428"/><span class="koboSpan" id="kobo.451.1"> recommend that by the time you find yourself needing Bash functions, you will have found another language to write your growing program in. </span><span class="koboSpan" id="kobo.451.2">However, sometimes Bash is still the right language for a problem, and we want to show you the absolute basics, with a strong bias toward how we recommend using them.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.452.1">Define a function by using the </span><code class="inlineCode"><span class="koboSpan" id="kobo.453.1">function</span></code><span class="koboSpan" id="kobo.454.1"> keyword:</span></p>
<pre class="programlisting con"><code class="hljs-con"><span class="koboSpan" id="kobo.455.1">function my_great_function {
  $EXPRESSIONS
}
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.456.1">Call functions by simply invoking their name:</span></p>
<pre class="programlisting con"><code class="hljs-con"><span class="koboSpan" id="kobo.457.1">my_great_function
</span></code></pre>
<h2 class="heading-2" id="_idParaDest-266"><span class="koboSpan" id="kobo.458.1">Prefer local variables</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.459.1">Bash works with a </span><a id="_idIndexMarker429"/><span class="koboSpan" id="kobo.460.1">more-or-less global scope – more accurately, per (sub)shell. </span><span class="koboSpan" id="kobo.460.2">Many modern programming languages give you a separate function scope to work with, so function state doesn’t pollute global state after a function exits.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.461.1">Using </span><code class="inlineCode"><span class="koboSpan" id="kobo.462.1">local</span></code><span class="koboSpan" id="kobo.463.1"> variables in your functions will protect you from this, and we recommend you use them:</span></p>
<pre class="programlisting con"><code class="hljs-con"><span class="koboSpan" id="kobo.464.1">#!/usr/bin/env bash
important_var=somevalue
function local_var_example() {
    local important_var="changed this locally, don't worry"
    echo "local_var_example: ${important_var}"
}
function bad_example() {
    important_var="this is mutating the global var because I'm bad, and I should feel bad."
    </span><span class="koboSpan" id="kobo.464.2">echo "bad_example: ${important_var}"
}
echo "before functions: ${important_var}"
local_var_example
echo
echo "after local_var_example: ${important_var}"
echo
bad_example
echo "after bad_example: ${important_var}"
exit 0
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.465.1">Run this code yourself and see the difference that using local </span><code class="inlineCode"><span class="koboSpan" id="kobo.466.1">vars</span></code><span class="koboSpan" id="kobo.467.1"> makes.</span></p>
<h1 class="heading-1" id="_idParaDest-267"><span class="koboSpan" id="kobo.468.1">Input and output redirection</span></h1>
<p class="normal"><span class="koboSpan" id="kobo.469.1">When you run scripts, you’ll often want to redirect their output:</span></p>
<ul>
<li class="bulletList"><span class="koboSpan" id="kobo.470.1">To another program (via a pipe – </span><code class="inlineCode"><span class="koboSpan" id="kobo.471.1">|</span></code><span class="koboSpan" id="kobo.472.1"> – see </span><em class="chapterRef"><span class="koboSpan" id="kobo.473.1">Chapter 11</span></em><span class="koboSpan" id="kobo.474.1">, </span><em class="italic"><span class="koboSpan" id="kobo.475.1">Pipes and Redirection</span></em><span class="koboSpan" id="kobo.476.1">, for more details)</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.477.1">To a regular file (like a log file)</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.478.1">To a special location like </span><code class="inlineCode"><span class="koboSpan" id="kobo.479.1">/dev/null</span></code><span class="koboSpan" id="kobo.480.1">, which can act as a kind of black hole for data you don’t need</span></li>
</ul>
<p class="normal"><span class="koboSpan" id="kobo.481.1">Aside from pipes, here are the most common input/output redirection tricks you’ll see in the wild.</span></p>
<h2 class="heading-2" id="_idParaDest-268"><span class="koboSpan" id="kobo.482.1">&lt;: input redirection</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.483.1">This is often used to grab</span><a id="_idIndexMarker430"/><span class="koboSpan" id="kobo.484.1"> input from a file, instead of from the shell spawning a process:</span></p>
<pre class="programlisting con"><code class="hljs-con"><span class="koboSpan" id="kobo.485.1">grep foobar &lt; stuff.txt
</span></code></pre>
<h2 class="heading-2" id="_idParaDest-269"><span class="koboSpan" id="kobo.486.1">&gt; and &gt;&gt;: output redirection</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.487.1">The </span><code class="inlineCode"><span class="koboSpan" id="kobo.488.1">&gt;</span></code><span class="koboSpan" id="kobo.489.1"> symbol will stream output to</span><a id="_idIndexMarker431"/><span class="koboSpan" id="kobo.490.1"> wherever you point it, overwriting anything that’s already there if it’s a regular file:</span></p>
<pre class="programlisting con"><code class="hljs-con"><span class="koboSpan" id="kobo.491.1">ps aux | grep foo &gt; /var/log/foo_overwrite.log
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.492.1">Every time you run this, the output of </span><code class="inlineCode"><span class="koboSpan" id="kobo.493.1">ps aux | grep foo</span></code><span class="koboSpan" id="kobo.494.1"> will be written to </span><code class="inlineCode"><span class="koboSpan" id="kobo.495.1">/var/log/foo_overwrite.log</span></code><span class="koboSpan" id="kobo.496.1">, overwriting any existing file content.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.497.1">Using </span><code class="inlineCode"><span class="koboSpan" id="kobo.498.1">&gt;&gt;</span></code><span class="koboSpan" id="kobo.499.1"> instead will </span><em class="italic"><span class="koboSpan" id="kobo.500.1">append</span></em><span class="koboSpan" id="kobo.501.1"> to the output file, leaving any existing content intact. </span><span class="koboSpan" id="kobo.501.2">This is usually what you want for log files:</span></p>
<pre class="programlisting con"><code class="hljs-con"><span class="koboSpan" id="kobo.502.1">echo $(date &amp;&amp; cat /proc/stat) &gt;&gt; /var/log/kernelstate.log
</span></code></pre>
<h2 class="heading-2" id="_idParaDest-270"><span class="koboSpan" id="kobo.503.1">Use 2&gt;&amp;1 to redirect STDERR and STDOUT</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.504.1">Sometimes, you want to redirect both standard output and standard error to a file:</span></p>
<pre class="programlisting con"><code class="hljs-con"><span class="koboSpan" id="kobo.505.1">consul agent -dev &gt;&gt; /var/log/consul.log 2&gt;&amp;1 &amp;
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.506.1">This command runs Hashicorp’s Consul in </span><code class="inlineCode"><span class="koboSpan" id="kobo.507.1">dev-mode</span></code><span class="koboSpan" id="kobo.508.1"> and backgrounds the process (the </span><code class="inlineCode"><span class="koboSpan" id="kobo.509.1">&amp;</span></code><span class="koboSpan" id="kobo.510.1"> symbol at the end), redirecting</span><a id="_idIndexMarker432"/><span class="koboSpan" id="kobo.511.1"> standard output</span><a id="_idIndexMarker433"/><span class="koboSpan" id="kobo.512.1"> to a log file. </span><code class="inlineCode"><span class="koboSpan" id="kobo.513.1">2&gt;&amp;1</span></code><span class="koboSpan" id="kobo.514.1"> tells Bash to “redirect file descriptor 2 (</span><code class="inlineCode"><span class="koboSpan" id="kobo.515.1">STDERR</span></code><span class="koboSpan" id="kobo.516.1">) to the same place as 1 (</span><code class="inlineCode"><span class="koboSpan" id="kobo.517.1">STDOUT</span></code><span class="koboSpan" id="kobo.518.1">)” – in this case, that’s </span><code class="inlineCode"><span class="koboSpan" id="kobo.519.1">/var/log/consul.log</span></code><span class="koboSpan" id="kobo.520.1">.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.521.1">You already know about file descriptors – </span><code class="inlineCode"><span class="koboSpan" id="kobo.522.1">STDIN</span></code><span class="koboSpan" id="kobo.523.1">, </span><code class="inlineCode"><span class="koboSpan" id="kobo.524.1">STDOUT</span></code><span class="koboSpan" id="kobo.525.1">, and </span><code class="inlineCode"><span class="koboSpan" id="kobo.526.1">STDERR</span></code><span class="koboSpan" id="kobo.527.1">. </span><span class="koboSpan" id="kobo.527.2">What if you only want to redirect a standard error to a </span><em class="italic"><span class="koboSpan" id="kobo.528.1">different</span></em><span class="koboSpan" id="kobo.529.1"> file than a standard output?</span></p>
<h1 class="heading-1" id="_idParaDest-271"><span class="koboSpan" id="kobo.530.1">Variable interpolation syntax – ${}</span></h1>
<p class="normal"><span class="koboSpan" id="kobo.531.1">To </span><a id="_idIndexMarker434"/><span class="koboSpan" id="kobo.532.1">accomplish what’s known as “string interpolation” in most programming languages – substituting part of a string with the value of a variable – you want Bash’s variable interpolation, </span><code class="inlineCode"><span class="koboSpan" id="kobo.533.1">${}</span></code><span class="koboSpan" id="kobo.534.1">.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.535.1">Try it yourself:</span></p>
<pre class="programlisting con"><code class="hljs-con"><span class="koboSpan" id="kobo.536.1">MYNAME=dave
echo "I can't do that, ${MYNAME}."
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.537.1">There are other ways to interpolate variables in Bash, but this is our favorite way, since it has the lowest chance of breaking your program due to unexpectedly-shaped input (spaces, special characters, and so on).</span></p>
<p class="normal"><span class="koboSpan" id="kobo.538.1">If you are going to use a variable as a string-like value, use this syntax – even if that variable is by itself and doesn’t really need to be interpolated into another string:</span></p>
<pre class="programlisting con"><code class="hljs-con"><span class="koboSpan" id="kobo.539.1">NAME="${MYNAME}"
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.540.1">This will prevent many strange bugs and behaviors with Bash, so it’s a good habit to get into.</span></p>
<div class="note">
<p class="normal"><strong class="keyWord"><span class="koboSpan" id="kobo.541.1">Note</span></strong></p>
<p class="normal"><span class="koboSpan" id="kobo.542.1">When working with variable interpolation, you’ll almost always want to run Bash with the </span><code class="inlineCode"><span class="koboSpan" id="kobo.543.1">-u</span></code><span class="koboSpan" id="kobo.544.1"> option (either by calling it with </span><code class="inlineCode"><span class="koboSpan" id="kobo.545.1">-u</span></code><span class="koboSpan" id="kobo.546.1">, or by using </span><code class="inlineCode"><span class="koboSpan" id="kobo.547.1">set -euo pipefail</span></code><span class="koboSpan" id="kobo.548.1"> at the beginning of your scripts, as we recommend). </span><span class="koboSpan" id="kobo.548.2">This will prevent you from having to check for zero values before you use a variable.</span></p>
</div>
<h1 class="heading-1" id="_idParaDest-272"><span class="koboSpan" id="kobo.549.1">Limitations of shell scripts</span></h1>
<p class="normal"><span class="koboSpan" id="kobo.550.1">Bash has innumerable </span><a id="_idIndexMarker435"/><span class="koboSpan" id="kobo.551.1">features, many of which we’re not covering here. </span><span class="koboSpan" id="kobo.551.2">If you need to dig deeper into the Bash language and environment, there are many books and tons of free resources on the web. </span><span class="koboSpan" id="kobo.551.3">The Bash manpage (</span><code class="inlineCode"><span class="koboSpan" id="kobo.552.1">man bash</span></code><span class="koboSpan" id="kobo.553.1">) is a good start too, now that you’re oriented.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.554.1">We expect you to encounter many Bash scripts over the course of your career. </span><span class="koboSpan" id="kobo.554.2">However, it’s very likely that you’ll spend more time reading and deciphering existing scripts than writing large new Bash programs. </span><span class="koboSpan" id="kobo.554.3">Bash is an amazing fit for small problems and system tasks that lend themselves to being solved with existing software, which just needs to be tied together into a solution. </span><span class="koboSpan" id="kobo.554.4">It’s often a </span><em class="italic"><span class="koboSpan" id="kobo.555.1">terrible</span></em><span class="koboSpan" id="kobo.556.1"> fit for large problems that extend beyond tying together standard Linux and Unix programs.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.557.1">With Bash, we find that:</span></p>
<ul>
<li class="bulletList"><span class="koboSpan" id="kobo.558.1">Small is better than large</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.559.1">Clear is better than clever</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.560.1">Safe is better than sorry</span></li>
</ul>
<p class="normal"><span class="koboSpan" id="kobo.561.1">It’s not uncommon to</span><a id="_idIndexMarker436"/><span class="koboSpan" id="kobo.562.1"> replace Bash scripts with tools written in a different programming language (often Python) as they grow. </span><span class="koboSpan" id="kobo.562.2">That’s not a dig against Bash! </span><span class="koboSpan" id="kobo.562.3">It’s perfect at filling the niche that it occupies, which is why it’s been so widespread for so long. </span><span class="koboSpan" id="kobo.562.4">If you occasionally stop to ask yourself, “Is a Bash script still the right solution for this problem?” </span><span class="koboSpan" id="kobo.562.5">you’ll be just fine.</span></p>
<h1 class="heading-1" id="_idParaDest-273"><span class="koboSpan" id="kobo.563.1">Conclusion</span></h1>
<p class="normal"><span class="koboSpan" id="kobo.564.1">This chapter was a no-punches-pulled, drink-from-the-fire-hydrant Bash scripting crash course. </span><span class="koboSpan" id="kobo.564.2">It’s dense, but it covers all the basics you need to become an effective Bash scripter. </span><span class="koboSpan" id="kobo.564.3">Work through it more than once if you have to. </span><span class="koboSpan" id="kobo.564.4">In addition to the syntax, we covered what we think are best practices that make writing readable, maintainable real-world scripts easier (or at least possible).</span></p>
<p class="normal"><span class="koboSpan" id="kobo.565.1">Practice, practice, practice – preferably on real-world problems you have, not just toy examples. </span><span class="koboSpan" id="kobo.565.2">There’s no faster way to get good.</span></p>
<h1 class="heading-1" id="_idParaDest-274"><span class="koboSpan" id="kobo.566.1">Citations</span></h1>
<ul>
<li class="bulletList"><em class="italic"><span class="koboSpan" id="kobo.567.1">Bash Test and Comparison Functions</span></em><span class="koboSpan" id="kobo.568.1">. </span><span class="koboSpan" id="kobo.568.2">Used for [[ and (( option tables. </span><span class="koboSpan" id="kobo.568.3">Accessed Sept 25, 2022 </span><a href="https://developer.ibm.com/tutorials/l-bash-test/"><span class="url"><span class="koboSpan" id="kobo.569.1">https://developer.ibm.com/tutorials/l-bash-test/</span></span></a><span class="koboSpan" id="kobo.570.1">.</span></li>
</ul>
<h1 class="heading-1"><span class="koboSpan" id="kobo.571.1">Learn more on Discord</span></h1>
<p class="normal"><span class="koboSpan" id="kobo.572.1">To join the Discord community for this book – where you can share feedback, ask questions to the author, and learn about new releases – follow the QR code below:</span></p>
<p class="normal"><a href="https://packt.link/SecNet"><span class="url"><span class="koboSpan" id="kobo.573.1">https://packt.link/SecNet</span></span></a></p>
<p class="normal"><span class="koboSpan" id="kobo.574.1"><img alt="" role="presentation" src="../Images/QR_Code1768422420210094187.png"/></span></p>
</div>
</body></html>