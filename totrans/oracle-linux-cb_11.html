<html><head></head><body>
<div id="_idContainer295">
<h1 class="chapter-number" id="_idParaDest-233"><a id="_idTextAnchor316"/><span class="koboSpan" id="kobo.1.1">11</span></h1>
<h1 id="_idParaDest-234"><a id="_idTextAnchor317"/><span class="koboSpan" id="kobo.2.1">Lions, Tigers, and Containers – Oh My! </span><span class="koboSpan" id="kobo.2.2">Podman and Friends</span></h1>
<p><span class="koboSpan" id="kobo.3.1">These days, it’s all about containers. </span><span class="koboSpan" id="kobo.3.2">Docker made containers cool and brought them into the mainstream, and Podman is here to come to the rescue as an open source container runtime that is open and available to all. </span><span class="koboSpan" id="kobo.3.3">Oracle Linux 7 includes Oracle Container Runtime for Docker, whereas Oracle Linux 8 and beyond include </span><a id="_idTextAnchor318"/><span class="koboSpan" id="kobo.4.1">Podman, Buildah, </span><span class="No-Break"><span class="koboSpan" id="kobo.5.1">and Skopeo.</span></span></p>
<p><span class="koboSpan" id="kobo.6.1">With every new release, Podman </span><a id="_idIndexMarker989"/><span class="koboSpan" id="kobo.7.1">closes the gap between it and Docker. </span><span class="koboSpan" id="kobo.7.2">With Podman v2.0, it began offering a fully compliant build that enables technologies such as </span><strong class="source-inline"><span class="koboSpan" id="kobo.8.1">docker-compose</span></strong><span class="koboSpan" id="kobo.9.1"> to work interchangeably with Podman. </span><span class="koboSpan" id="kobo.9.2">With Podman v4.1.0, you are now able to seamlessly mount the host machine’s home directory into the Podman machine VM, making it available within container volume mounts. </span><span class="koboSpan" id="kobo.9.3">This chapter is largely intended for users who have some basic experience with Docker, and will help users understand the differences between Docker and Podman so that they can successfully migrate their workloads to this so-called “drop-in replacement.” </span><span class="koboSpan" id="kobo.9.4">If you’re not familiar with Docker or are new to the concept of containers, it may be helpful to peruse the Get Started guide from Docker, which can be found </span><span class="No-Break"><span class="koboSpan" id="kobo.10.1">here: </span></span><a href="https://docs.docker.com/get-started/"><span class="No-Break"><span class="koboSpan" id="kobo.11.1">https://docs.docker.com/get-started/</span></span></a><span class="No-Break"><span class="koboSpan" id="kobo.12.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.13.1">In this chapter, we’re going to cover the </span><span class="No-Break"><span class="koboSpan" id="kobo.14.1">following recipes:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.15.1">Ridding yourself of demons – err um – daemons, </span><span class="No-Break"><span class="koboSpan" id="kobo.16.1">with Podman</span></span></li>
<li><span class="koboSpan" id="kobo.17.1">Giving your containers a </span><span class="No-Break"><span class="koboSpan" id="kobo.18.1">root canal</span></span></li>
<li><span class="koboSpan" id="kobo.19.1">Creating handy-dandy </span><span class="No-Break"><span class="koboSpan" id="kobo.20.1">utility containers</span></span></li>
<li><span class="koboSpan" id="kobo.21.1">Docker Compose </span><span class="No-Break"><span class="koboSpan" id="kobo.22.1">with Podman</span></span></li>
<li><span class="koboSpan" id="kobo.23.1">Managing stacks </span><span class="No-Break"><span class="koboSpan" id="kobo.24.1">with pods</span></span></li>
<li><span class="No-Break"><span class="koboSpan" id="kobo.25.1">Containerized databases</span></span></li>
<li><span class="koboSpan" id="kobo.26.1">Buildah and Skopeo – Podman’s friends </span><span class="No-Break"><span class="koboSpan" id="kobo.27.1">with benefits</span></span></li>
</ul>
<h1 id="_idParaDest-235"><a id="_idTextAnchor319"/><span class="koboSpan" id="kobo.28.1">Technical requirements</span></h1>
<p><span class="koboSpan" id="kobo.29.1">Podman, Buildah, and Skopeo are all included in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.30.1">container-tools</span></strong><span class="koboSpan" id="kobo.31.1"> module from </span><span class="No-Break"><span class="koboSpan" id="kobo.32.1">application streams:</span></span></p>
<pre class="console"><span class="koboSpan" id="kobo.33.1">
$ sudo dnf module install container-tools</span></pre> <p><span class="koboSpan" id="kobo.34.1">The source code for the recipes in this chapter can be found </span><span class="No-Break"><span class="koboSpan" id="kobo.35.1">at </span></span><a href="https://github.com/PacktPublishing/Oracle-Linux-Cookbook"><span class="No-Break"><span class="koboSpan" id="kobo.36.1">https://github.com/PacktPublishing/Oracle-Linux-Cookbook</span></span></a><span class="No-Break"><span class="koboSpan" id="kobo.37.1">.</span></span></p>
<h1 id="_idParaDest-236"><a id="_idTextAnchor320"/><span class="koboSpan" id="kobo.38.1">Ridding yourself of demons – err um – daemons, with Podman</span></h1>
<p><span class="koboSpan" id="kobo.39.1">Docker and Podman are both tools that aim to make it easier to run and manage containers on a host machine. </span><span class="koboSpan" id="kobo.39.2">Since</span><a id="_idIndexMarker990"/><span class="koboSpan" id="kobo.40.1"> Podman is the new kid on the block, you may be wondering how you can switch from Docker to Podman. </span><span class="koboSpan" id="kobo.40.2">While technically it is possible to run both Docker and Podman together on the same system, there are very few practical reasons to do this. </span><span class="koboSpan" id="kobo.40.3">Since both tools provide the same core capabilities, I would advise you to choose one or </span><span class="No-Break"><span class="koboSpan" id="kobo.41.1">the other.</span></span></p>
<p><span class="koboSpan" id="kobo.42.1">One of the key benefits</span><a id="_idIndexMarker991"/><span class="koboSpan" id="kobo.43.1"> of switching to Podman is you will inherently lose the daemon that lurked behind the scenes of Docker. </span><span class="koboSpan" id="kobo.43.2">You see, Docker relies on a daemon that does all the heavy lifting of managing containers. </span><span class="koboSpan" id="kobo.43.3">This may not seem so bad on the surface, but there are some things to be aware of when it comes to </span><span class="No-Break"><span class="koboSpan" id="kobo.44.1">this architecture.</span></span></p>
<p><span class="koboSpan" id="kobo.45.1">For starters, having an extra daemon running in the background means there is one more point of failure. </span><span class="koboSpan" id="kobo.45.2">If that dedicated daemon for Docker crashes, you lose all your containers. </span><span class="koboSpan" id="kobo.45.3">The additional daemon also increases your attack surface, and because the Docker daemon has root access to the system, any compromise made to the Docker daemon puts your system at </span><span class="No-Break"><span class="koboSpan" id="kobo.46.1">greater risk.</span></span></p>
<p><span class="koboSpan" id="kobo.47.1">This recipe aims to exorcise those demons – err, um – discontinue the use of the Docker daemon. </span><span class="koboSpan" id="kobo.47.2">The best thing is, if you aren’t using Docker and you only ever installed Podman, you don’t need to worry about anything – that’s because Podman is rootless by default, and it leverages </span><strong class="bold"><span class="koboSpan" id="kobo.48.1">systemd</span></strong><span class="koboSpan" id="kobo.49.1"> to manage your</span><a id="_idIndexMarker992"/><span class="koboSpan" id="kobo.50.1"> containers. </span><strong class="bold"><span class="koboSpan" id="kobo.51.1">systemd</span></strong><span class="koboSpan" id="kobo.52.1"> is a tried-and-tested system-level daemon that provides an array of system components, including a system and service manager, parallelization capabilities, logging, and utilities to manage and maintain </span><span class="No-Break"><span class="koboSpan" id="kobo.53.1">system configuration.</span></span></p>
<p><span class="koboSpan" id="kobo.54.1">On the other hand, if you were previously using Docker, we’re going to show you how to switch. </span><span class="koboSpan" id="kobo.54.2">It’s really quite simple – all you need to do is remove Docker and </span><span class="No-Break"><span class="koboSpan" id="kobo.55.1">install Podman.</span></span></p>
<h2 id="_idParaDest-237"><a id="_idTextAnchor321"/><span class="koboSpan" id="kobo.56.1">Getting ready</span></h2>
<p><span class="koboSpan" id="kobo.57.1">I’m running on</span><a id="_idIndexMarker993"/><span class="koboSpan" id="kobo.58.1"> x86-64 bit architecture, but Oracle Linux and Podman also work on Arm. </span><span class="koboSpan" id="kobo.58.2">However, it’s important to know that not all containers are compiled in Arm, or vice versa. </span><span class="koboSpan" id="kobo.58.3">With that being said, it may be easier to follow this guide using an x86-64 </span><span class="No-Break"><span class="koboSpan" id="kobo.59.1">bit CPU:</span></span></p>
<ul>
<li><span class="No-Break"><span class="koboSpan" id="kobo.60.1">Oracle Linux</span></span></li>
<li><span class="No-Break"><span class="koboSpan" id="kobo.61.1">Podman</span></span></li>
</ul>
<h2 id="_idParaDest-238"><a id="_idTextAnchor322"/><span class="koboSpan" id="kobo.62.1">How to do it…</span></h2>
<ol>
<li><span class="koboSpan" id="kobo.63.1">Remove Docker by running the </span><span class="No-Break"><span class="koboSpan" id="kobo.64.1">following command:</span></span><pre class="source-code">
<strong class="bold"><span class="koboSpan" id="kobo.65.1">$ sudo dnf remove -y docker-ce docker-ce-cli containerd.io docker-compose-plugin</span></strong></pre></li> <li><span class="koboSpan" id="kobo.66.1">After this, you will be able to install Podman with </span><span class="No-Break"><span class="koboSpan" id="kobo.67.1">the following:</span></span><pre class="source-code">
<strong class="bold"><span class="koboSpan" id="kobo.68.1">$ sudo dnf module install container-tools</span></strong></pre></li> <li><span class="koboSpan" id="kobo.69.1">If you previously added your user to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.70.1">docker</span></strong><span class="koboSpan" id="kobo.71.1"> group, you may go ahead and delete that group because it is no </span><span class="No-Break"><span class="koboSpan" id="kobo.72.1">longer needed:</span></span><pre class="source-code">
<strong class="bold"><span class="koboSpan" id="kobo.73.1">$ sudo groupdel docker</span></strong></pre></li> </ol>
<p><span class="koboSpan" id="kobo.74.1">Now you’re running containers without the Docker daemon, and by default with Podman, </span><span class="No-Break"><span class="koboSpan" id="kobo.75.1">you’re rootless.</span></span></p>
<h1 id="_idParaDest-239"><a id="_idTextAnchor323"/><span class="koboSpan" id="kobo.76.1">Giving your containers a root canal</span></h1>
<p><span class="koboSpan" id="kobo.77.1">Straight from </span><a id="_idIndexMarker994"/><span class="koboSpan" id="kobo.78.1">the Docker documentation, you will find that “</span><em class="italic"><span class="koboSpan" id="kobo.79.1">The Docker daemon binds to a Unix socket instead of a TCP port. </span><span class="koboSpan" id="kobo.79.2">By default that Unix socket is owned by the user root and other users can only access it using sudo. </span><span class="koboSpan" id="kobo.79.3">The Docker daemon always runs as the </span></em><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.80.1">root user.</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.81.1">”</span></span></p>
<p><span class="koboSpan" id="kobo.82.1">The </span><a id="_idIndexMarker995"/><span class="koboSpan" id="kobo.83.1">documentation then proceeds to instruct you to add your user to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.84.1">docker</span></strong><span class="koboSpan" id="kobo.85.1"> group in order to use Docker without using </span><strong class="source-inline"><span class="koboSpan" id="kobo.86.1">sudo</span></strong><span class="koboSpan" id="kobo.87.1">. </span><span class="koboSpan" id="kobo.87.2">That sounds great, right? </span><span class="koboSpan" id="kobo.87.3">Well, the thing is, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.88.1">docker</span></strong><span class="koboSpan" id="kobo.89.1"> group grants privileges equivalent to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.90.1">root</span></strong><span class="koboSpan" id="kobo.91.1"> user. </span><span class="koboSpan" id="kobo.91.2">This can have dire consequences. </span><span class="koboSpan" id="kobo.91.3">For instance, any location on your host filesystem can be mounted into the container – and I do mean any! </span><span class="koboSpan" id="kobo.91.4">This even includes the </span><strong class="source-inline"><span class="koboSpan" id="kobo.92.1">/</span></strong><span class="koboSpan" id="kobo.93.1"> (root) directory and the container can then alter your host filesystem without any restrictions. </span><span class="koboSpan" id="kobo.93.2">There are several other security vulnerabilities that are a direct result of this architecture, but you get </span><span class="No-Break"><span class="koboSpan" id="kobo.94.1">the picture.</span></span></p>
<p><span class="koboSpan" id="kobo.95.1">What’s different </span><a id="_idIndexMarker996"/><span class="koboSpan" id="kobo.96.1">about Podman is that by default, it runs rootless; in other words, you can run containers using Podman without root privileges. </span><span class="koboSpan" id="kobo.96.2">When I first heard this, I thought it meant the user in the container was not root, but that’s not really the case. </span><span class="koboSpan" id="kobo.96.3">Rootless containers simply mean that the user instantiating the containers does not have root privileges. </span><span class="koboSpan" id="kobo.96.4">There are a few things to know about running a container without root privileges, and this recipe aims to instruct you how to run rootless containers, while at the same time explaining the differences between rootless </span><span class="No-Break"><span class="koboSpan" id="kobo.97.1">and rootful.</span></span></p>
<h2 id="_idParaDest-240"><a id="_idTextAnchor324"/><span class="koboSpan" id="kobo.98.1">Getting ready</span></h2>
<ul>
<li><span class="No-Break"><span class="koboSpan" id="kobo.99.1">Oracle Linux</span></span></li>
<li><span class="No-Break"><span class="koboSpan" id="kobo.100.1">Podman</span></span></li>
</ul>
<h2 id="_idParaDest-241"><a id="_idTextAnchor325"/><span class="koboSpan" id="kobo.101.1">How to do it…</span></h2>
<p><span class="koboSpan" id="kobo.102.1">To run rootless containers with Podman, all you need to do is use Podman as a user without root privileges. </span><span class="koboSpan" id="kobo.102.2">Also, do not append </span><strong class="source-inline"><span class="koboSpan" id="kobo.103.1">sudo</span></strong><span class="koboSpan" id="kobo.104.1"> to any Podman commands, because if you do, you would then be running the container as the </span><span class="No-Break"><span class="koboSpan" id="kobo.105.1">root user.</span></span></p>
<p><span class="koboSpan" id="kobo.106.1">What’s different about </span><span class="No-Break"><span class="koboSpan" id="kobo.107.1">rootless containers?</span></span></p>
<h3><span class="koboSpan" id="kobo.108.1">Network modes</span></h3>
<p><span class="koboSpan" id="kobo.109.1">There are three common network modes supported </span><span class="No-Break"><span class="koboSpan" id="kobo.110.1">by </span><a id="_idTextAnchor326"/><span class="koboSpan" id="kobo.111.1">Podman:</span></span></p>
<ul>
<li><span class="No-Break"><span class="koboSpan" id="kobo.112.1">Bridged</span></span></li>
<li><span class="No-Break"><span class="koboSpan" id="kobo.113.1">macvlan</span></span></li>
<li><span class="No-Break"><span class="koboSpan" id="kobo.114.1">slirp4netns</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.115.1">First, there’s a </span><strong class="bold"><span class="koboSpan" id="kobo.116.1">bridged</span></strong><span class="koboSpan" id="kobo.117.1"> network, which</span><a id="_idIndexMarker997"/><span class="koboSpan" id="kobo.118.1"> is the default used by rootful Podman. </span><span class="koboSpan" id="kobo.118.2">Bridged networking creates a network interface on the host and dedicates this interface to the container. </span><span class="koboSpan" id="kobo.118.3">Another </span><a id="_idIndexMarker998"/><span class="koboSpan" id="kobo.119.1">network mode is </span><strong class="bold"><span class="koboSpan" id="kobo.120.1">macvlan</span></strong><span class="koboSpan" id="kobo.121.1">, which</span><a id="_idIndexMarker999"/><span class="koboSpan" id="kobo.122.1"> is a virtual LAN that basically forwards an entire network interface from the host into the container. </span><span class="koboSpan" id="kobo.122.2">Finally, there is </span><strong class="bold"><span class="koboSpan" id="kobo.123.1">slirp4netns</span></strong><span class="koboSpan" id="kobo.124.1">, which </span><a id="_idIndexMarker1000"/><span class="koboSpan" id="kobo.125.1">enables you to connect a network namespace to the internet in a completely unprivileged way. </span><span class="koboSpan" id="kobo.125.2">Rootless Podman leverages </span><strong class="bold"><span class="koboSpan" id="kobo.126.1">slirp4netns</span></strong><span class="koboSpan" id="kobo.127.1"> because </span><a id="_idIndexMarker1001"/><span class="koboSpan" id="kobo.128.1">unprivileged users lack the ability to create network interfaces on the host. </span><span class="koboSpan" id="kobo.128.2">In order to bypass this limitation, </span><strong class="bold"><span class="koboSpan" id="kobo.129.1">slirp4netns</span></strong><span class="koboSpan" id="kobo.130.1"> instead creates a tunnel from the host and into the container in order to </span><span class="No-Break"><span class="koboSpan" id="kobo.131.1">forward traffic.</span></span></p>
<h3><span class="koboSpan" id="kobo.132.1">Network ports</span></h3>
<p><span class="koboSpan" id="kobo.133.1">When you</span><a id="_idIndexMarker1002"/><span class="koboSpan" id="kobo.134.1"> run your containers without root access, you may run into issues exposing certain network ports. </span><span class="koboSpan" id="kobo.134.2">For example, it is common for users to expose ports </span><strong class="source-inline"><span class="koboSpan" id="kobo.135.1">80</span></strong><span class="koboSpan" id="kobo.136.1"> and/or </span><strong class="source-inline"><span class="koboSpan" id="kobo.137.1">443</span></strong><span class="koboSpan" id="kobo.138.1"> when running containers; however, if you try to do this while running a rootless container, you will see a message like </span><span class="No-Break"><span class="koboSpan" id="kobo.139.1">the following:</span></span></p>
<pre class="console"><span class="koboSpan" id="kobo.140.1">
Error response from daemon: rootlessport cannot expose privileged port 80, you can add 'net.ipv4.ip_unprivileged_port_start=80' to /etc/sysctl.conf (currently 1024), or choose a larger port number (&gt;= 1024): listen tcp 0.0.0.0:80: bind: permission denied</span></pre> <p><span class="koboSpan" id="kobo.141.1">Rootless Podman is limited to exposing ports </span><strong class="source-inline"><span class="koboSpan" id="kobo.142.1">1024</span></strong><span class="koboSpan" id="kobo.143.1"> and above. </span><span class="koboSpan" id="kobo.143.2">If you wanted to expose a lower port, you would need to first configure this as root in order to allow unprivileged users to expose lower </span><span class="No-Break"><span class="koboSpan" id="kobo.144.1">port numbers.</span></span></p>
<p><span class="koboSpan" id="kobo.145.1">Let’s say you wanted to allow rootless Podman to expose the standard HTTP web port (port </span><strong class="source-inline"><span class="koboSpan" id="kobo.146.1">80</span></strong><span class="koboSpan" id="kobo.147.1">). </span><span class="koboSpan" id="kobo.147.2">In this case, you can run </span><span class="No-Break"><span class="koboSpan" id="kobo.148.1">this command:</span></span></p>
<pre class="console"><span class="koboSpan" id="kobo.149.1">
sudo sysctl net.ipv4.ip_unprivileged_port_start=80</span></pre> <p><span class="koboSpan" id="kobo.150.1">If you want these settings to persist, simply follow the guidance of the error message received earlier. </span><span class="koboSpan" id="kobo.150.2">That is, edit the </span><strong class="source-inline"><span class="koboSpan" id="kobo.151.1">/etc/sysctl.conf</span></strong><span class="koboSpan" id="kobo.152.1"> file and </span><span class="No-Break"><span class="koboSpan" id="kobo.153.1">append </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.154.1">net.ipv4.ip_unprivileged_port_start=80</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.155.1">.</span></span></p>
<h1 id="_idParaDest-242"><a id="_idTextAnchor327"/><span class="koboSpan" id="kobo.156.1">Creating handy-dandy utility containers</span></h1>
<p><span class="koboSpan" id="kobo.157.1">This recipe shows how to use Podman to quickly spin up a container to complete </span><span class="No-Break"><span class="koboSpan" id="kobo.158.1">useful tasks.</span></span></p>
<p><span class="koboSpan" id="kobo.159.1">This recipe will walk </span><a id="_idIndexMarker1003"/><span class="koboSpan" id="kobo.160.1">you through the process of creating super useful utilities leveraging containers. </span><span class="koboSpan" id="kobo.160.2">The basic principle of containers </span><a id="_idIndexMarker1004"/><span class="koboSpan" id="kobo.161.1">encourages us to formulate our containers to do only one thing – that is, to provide some form of utility and nothing more. </span><span class="koboSpan" id="kobo.161.2">You should not create a container that does too much. </span><span class="koboSpan" id="kobo.161.3">With that being said, most container images already exist to provide a useful utility. </span><span class="koboSpan" id="kobo.161.4">In this recipe, we are going to look at examples of containers that serve a useful purpose, and we’re going to explore how to make use </span><span class="No-Break"><span class="koboSpan" id="kobo.162.1">of this.</span></span></p>
<h2 id="_idParaDest-243"><a id="_idTextAnchor328"/><span class="koboSpan" id="kobo.163.1">Getting ready</span></h2>
<p><span class="koboSpan" id="kobo.164.1">We will require </span><span class="No-Break"><span class="koboSpan" id="kobo.165.1">the following:</span></span></p>
<ul>
<li><span class="No-Break"><span class="koboSpan" id="kobo.166.1">Oracle Linux</span></span></li>
<li><span class="No-Break"><span class="koboSpan" id="kobo.167.1">Podman</span></span></li>
</ul>
<h2 id="_idParaDest-244"><a id="_idTextAnchor329"/><span class="koboSpan" id="kobo.168.1">How to do it…</span></h2>
<p><span class="koboSpan" id="kobo.169.1">The main intention of this recipe is to show how we can use containers to achieve a function without installing additional packages on our local machine. </span><span class="koboSpan" id="kobo.169.2">Once you have Podman installed on your local machine, you can tap into an entire ecosystem of useful packages and utilities without installing more packages – instead, you simply run a container image that contains those packages, or, alternatively, you create a new container and install the desired </span><span class="No-Break"><span class="koboSpan" id="kobo.170.1">packages there.</span></span></p>
<p><span class="koboSpan" id="kobo.171.1">Why would anyone prefer to do this? </span><span class="koboSpan" id="kobo.171.2">For starters, it allows you to minimize the number of packages and dependencies you’re installing on your host machine. </span><span class="koboSpan" id="kobo.171.3">With fewer packages, you reduce your attack surface in terms of security. </span><span class="koboSpan" id="kobo.171.4">Additionally, your operating system’s repositories might be limited to access to certain packages, or it might not have access to the latest versions. </span><span class="koboSpan" id="kobo.171.5">Instead of going through the effort of adding potentially untrusted repositories to install the packages you need, why not simply launch a container that contains everything you need for the specific function you’re trying </span><span class="No-Break"><span class="koboSpan" id="kobo.172.1">to achieve?</span></span></p>
<p><span class="koboSpan" id="kobo.173.1">Before we try to tap into the true potential of containers, we first need to discuss a few important concepts that will make this process a </span><span class="No-Break"><span class="koboSpan" id="kobo.174.1">bit easier.</span></span></p>
<h3><span class="koboSpan" id="kobo.175.1">Entrypoint</span></h3>
<p><span class="koboSpan" id="kobo.176.1">The entrypoint </span><a id="_idIndexMarker1005"/><span class="koboSpan" id="kobo.177.1">of a container defines what command the container will run by default. </span><span class="koboSpan" id="kobo.177.2">You can find the entrypoint of a container by specifying the </span><strong class="source-inline"><span class="koboSpan" id="kobo.178.1">inspect</span></strong><span class="koboSpan" id="kobo.179.1"> command and piping that to </span><strong class="source-inline"><span class="koboSpan" id="kobo.180.1">jq</span></strong><span class="koboSpan" id="kobo.181.1"> to extract only </span><span class="No-Break"><span class="koboSpan" id="kobo.182.1">the entrypoint.</span></span></p>
<p><span class="koboSpan" id="kobo.183.1">First, pull the image if you don’t already have it on </span><span class="No-Break"><span class="koboSpan" id="kobo.184.1">your system:</span></span></p>
<pre class="console"><span class="koboSpan" id="kobo.185.1">
$ podman pull docker.io/pandoc/core</span></pre> <p><span class="koboSpan" id="kobo.186.1">Now let’s inspect the image and run </span><strong class="source-inline"><span class="koboSpan" id="kobo.187.1">jq</span></strong><span class="koboSpan" id="kobo.188.1"> to query for </span><span class="No-Break"><span class="koboSpan" id="kobo.189.1">the entrypoint:</span></span></p>
<pre class="console"><span class="koboSpan" id="kobo.190.1">
$ podman image inspect pandoc/core | jq -r '.[].Config.Entrypoint[0]'</span></pre> <p><strong class="bold"><span class="koboSpan" id="kobo.191.1">Bonus</span></strong><span class="koboSpan" id="kobo.192.1">: Let’s assume we do not have </span><strong class="source-inline"><span class="koboSpan" id="kobo.193.1">jq</span></strong><span class="koboSpan" id="kobo.194.1"> installed on our computer. </span><span class="koboSpan" id="kobo.194.2">In this case, we can pipe the output of </span><strong class="source-inline"><span class="koboSpan" id="kobo.195.1">inspect</span></strong><span class="koboSpan" id="kobo.196.1"> to a container that </span><span class="No-Break"><span class="koboSpan" id="kobo.197.1">contains </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.198.1">jq</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.199.1">:</span></span></p>
<pre class="console"><span class="koboSpan" id="kobo.200.1">
$ podman image inspect pandoc/core | podman run -i --rm stedolan/jq -r '.[].Config.Entrypoint[]'</span></pre> <p><span class="koboSpan" id="kobo.201.1">In either case, the output of this command will </span><span class="No-Break"><span class="koboSpan" id="kobo.202.1">be </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.203.1">/usr/local/bin/pandoc</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.204.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.205.1">This tells us that when we run the </span><strong class="source-inline"><span class="koboSpan" id="kobo.206.1">pandoc/core</span></strong><span class="koboSpan" id="kobo.207.1"> container, the default command that gets executed will </span><span class="No-Break"><span class="koboSpan" id="kobo.208.1">be </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.209.1">/usr/local/bin/pandoc</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.210.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.211.1">Sometimes, a container’s entrypoint might be a script. </span><span class="koboSpan" id="kobo.211.2">For example, you might check for the entrypoint and learn that the entrypoint is </span><strong class="source-inline"><span class="koboSpan" id="kobo.212.1">docker-entrypoint.sh</span></strong><span class="koboSpan" id="kobo.213.1">. </span><span class="koboSpan" id="kobo.213.2">You can reveal more about this file by overriding the entrypoint and using </span><strong class="source-inline"><span class="koboSpan" id="kobo.214.1">cat</span></strong><span class="koboSpan" id="kobo.215.1"> to see the contents of the file. </span><span class="koboSpan" id="kobo.215.2">For example, let’s say we were to inspect the </span><strong class="source-inline"><span class="koboSpan" id="kobo.216.1">node</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.217.1">container image:</span></span></p>
<pre class="console"><span class="koboSpan" id="kobo.218.1">
$ podman image inspect node | jq -r '.[].Config.Entrypoint[]'</span></pre> <p><span class="koboSpan" id="kobo.219.1">We would find that the entrypoint </span><span class="No-Break"><span class="koboSpan" id="kobo.220.1">is </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.221.1">docker-entrypoint.sh</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.222.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.223.1">Now, let’s override the entrypoint to examine the contents of </span><span class="No-Break"><span class="koboSpan" id="kobo.224.1">this file:</span></span></p>
<pre class="console"><span class="koboSpan" id="kobo.225.1">
$ podman run --rm --entrypoint=/bin/bash node -c 'cat docker-entrypoint.sh'</span></pre> <p><span class="koboSpan" id="kobo.226.1">In this case, the output is </span><span class="No-Break"><span class="koboSpan" id="kobo.227.1">the following:</span></span></p>
<pre class="console"><span class="koboSpan" id="kobo.228.1">
cat: docker-entrypoint.sh: No such file or directory</span></pre> <p><span class="koboSpan" id="kobo.229.1">This is </span><a id="_idIndexMarker1006"/><span class="koboSpan" id="kobo.230.1">because in the case of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.231.1">node</span></strong><span class="koboSpan" id="kobo.232.1"> image, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.233.1">docker-entrypoint.sh</span></strong><span class="koboSpan" id="kobo.234.1"> file is not in the working directory; instead, it is found in the path. </span><span class="koboSpan" id="kobo.234.2">So, we’ll try another way to examine </span><span class="No-Break"><span class="koboSpan" id="kobo.235.1">this file:</span></span></p>
<pre class="console"><span class="koboSpan" id="kobo.236.1">
$ podman run --rm --entrypoint=/bin/bash node -c 'cat $(which docker-entrypoint.sh)'</span></pre> <p><span class="koboSpan" id="kobo.237.1">The output will be </span><span class="No-Break"><span class="koboSpan" id="kobo.238.1">as follows:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer285">
<span class="koboSpan" id="kobo.239.1"><img alt="Figure 11.1 – Output of docker-entrypoint.sh" src="image/B18349_11_001.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.240.1">Figure 11.1 – Output of docker-entrypoint.sh</span></p>
<p><span class="koboSpan" id="kobo.241.1">Now that we know about the default entrypoint, we can use this as we determine what we’re going to do with the container. </span><span class="koboSpan" id="kobo.241.2">Sometimes we might want to use the default entry point as intended, whereas other times we might benefit from overriding the default entrypoint to use some other available packages within the container – it all depends on what we’re trying </span><span class="No-Break"><span class="koboSpan" id="kobo.242.1">to do.</span></span></p>
<h3><span class="koboSpan" id="kobo.243.1">Working directory</span></h3>
<p><span class="koboSpan" id="kobo.244.1">You’ll often </span><a id="_idIndexMarker1007"/><span class="koboSpan" id="kobo.245.1">want to specify the working directory inside the container, because that’s where the container is configured by default to perform its work. </span><span class="koboSpan" id="kobo.245.2">To get the working directory of a container, you can run </span><span class="No-Break"><span class="koboSpan" id="kobo.246.1">the following:</span></span></p>
<pre class="console"><span class="koboSpan" id="kobo.247.1">
$ podman image inspect pandoc/core | jq -r '.[].Config.WorkingDir'</span></pre> <p><span class="koboSpan" id="kobo.248.1">Again, you get bonus points if you do this without installing </span><strong class="source-inline"><span class="koboSpan" id="kobo.249.1">jq</span></strong><span class="koboSpan" id="kobo.250.1"> by </span><span class="No-Break"><span class="koboSpan" id="kobo.251.1">running this:</span></span></p>
<pre class="console"><span class="koboSpan" id="kobo.252.1">
$ podman image inspect pandoc/core | podman run -i --rm stedolan/jq -r '.[].Config.WorkingDir'</span></pre> <p><span class="koboSpan" id="kobo.253.1">In either case, the</span><a id="_idIndexMarker1008"/><span class="koboSpan" id="kobo.254.1"> output of this command will </span><span class="No-Break"><span class="koboSpan" id="kobo.255.1">be </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.256.1">/data</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.257.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.258.1">This tells us that when we run the </span><strong class="source-inline"><span class="koboSpan" id="kobo.259.1">pandoc/core</span></strong><span class="koboSpan" id="kobo.260.1"> container, the default working directory inside the container </span><span class="No-Break"><span class="koboSpan" id="kobo.261.1">is </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.262.1">/data</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.263.1">.</span></span></p>
<h3><span class="koboSpan" id="kobo.264.1">Volume mounting</span></h3>
<p><span class="koboSpan" id="kobo.265.1">In order </span><a id="_idIndexMarker1009"/><span class="koboSpan" id="kobo.266.1">to make use of a container that performs a task against files on your local machine, you’ll first need to mount a volume into the container. </span><span class="koboSpan" id="kobo.266.2">An easy way to do this is to specify your present working directory by specifying </span><strong class="source-inline"><span class="koboSpan" id="kobo.267.1">$(pwd)</span></strong><span class="koboSpan" id="kobo.268.1">. </span><span class="koboSpan" id="kobo.268.2">Another method might be to specify </span><strong class="source-inline"><span class="koboSpan" id="kobo.269.1">./</span></strong><span class="koboSpan" id="kobo.270.1">. </span><span class="koboSpan" id="kobo.270.2">The order in which this is done is by declaring the host machine’s directory first, and the container’s </span><span class="No-Break"><span class="koboSpan" id="kobo.271.1">directory second.</span></span></p>
<p><span class="koboSpan" id="kobo.272.1">For example, if you wanted to mount the present working directory of the host machine into the working directory of the container, you would run </span><strong class="source-inline"><span class="koboSpan" id="kobo.273.1">-v $(pwd):/data</span></strong><span class="koboSpan" id="kobo.274.1">. </span><span class="koboSpan" id="kobo.274.2">In this example, we are saying we want our present working directory on the host machine to be accessible inside the container at the </span><strong class="source-inline"><span class="koboSpan" id="kobo.275.1">/data</span></strong><span class="koboSpan" id="kobo.276.1"> path. </span><span class="koboSpan" id="kobo.276.2">Remember, we found the working directory of the container when we used the </span><strong class="source-inline"><span class="koboSpan" id="kobo.277.1">podman </span></strong><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.278.1">inspect</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.279.1"> command.</span></span></p>
<h3><span class="koboSpan" id="kobo.280.1">Super useful utility containers</span></h3>
<p><span class="koboSpan" id="kobo.281.1">Now that we’ve discussed some of the important concepts, I am going to list examples of useful utilities I’ve found in containers and then will expand on the practicality of leveraging containers for </span><span class="No-Break"><span class="koboSpan" id="kobo.282.1">these functions.</span></span></p>
<h4><span class="koboSpan" id="kobo.283.1">Converting a Markdown file to docx using pandoc</span></h4>
<p><span class="koboSpan" id="kobo.284.1">In this</span><a id="_idIndexMarker1010"/><span class="koboSpan" id="kobo.285.1"> example, let’s imagine we have a document that we want to convert to another type. </span><span class="koboSpan" id="kobo.285.2">There are many tools we can leverage to do this, but one such tool that comes to mind is pandoc. </span><span class="koboSpan" id="kobo.285.3">Rather than installing pandoc on my local machine, I’ll simply run the </span><strong class="source-inline"><span class="koboSpan" id="kobo.286.1">pandoc/core</span></strong><span class="koboSpan" id="kobo.287.1"> container, which has pandoc preinstalled. </span><span class="koboSpan" id="kobo.287.2">The entrypoint in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.288.1">pandoc</span></strong><span class="koboSpan" id="kobo.289.1"> container is </span><strong class="source-inline"><span class="koboSpan" id="kobo.290.1">/bash/pandoc</span></strong><span class="koboSpan" id="kobo.291.1">. </span><span class="koboSpan" id="kobo.291.2">This means that anything after the specification of the container image will automatically append to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.292.1">pandoc</span></strong><span class="koboSpan" id="kobo.293.1"> command inside </span><span class="No-Break"><span class="koboSpan" id="kobo.294.1">the container.</span></span></p>
<p><span class="koboSpan" id="kobo.295.1">We can run </span><strong class="source-inline"><span class="koboSpan" id="kobo.296.1">--help</span></strong><span class="koboSpan" id="kobo.297.1"> after the </span><strong class="source-inline"><span class="koboSpan" id="kobo.298.1">pandoc/core</span></strong><span class="koboSpan" id="kobo.299.1"> command to learn how to use the utility, </span><span class="No-Break"><span class="koboSpan" id="kobo.300.1">for example:</span></span></p>
<pre class="console"><span class="koboSpan" id="kobo.301.1">
$ podman run --rm pandoc/core --help</span></pre> <p><span class="koboSpan" id="kobo.302.1">From that (you can also view the man page maintained here: </span><a href="https://linux.die.net/man/1/pandoc"><span class="koboSpan" id="kobo.303.1">https://linux.die.net/man/1/pandoc</span></a><span class="koboSpan" id="kobo.304.1">), I now have some insight into how to use pandoc. </span><span class="koboSpan" id="kobo.304.2">In</span><a id="_idIndexMarker1011"/><span class="koboSpan" id="kobo.305.1"> this case, I can use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.306.1">pandoc</span></strong><span class="koboSpan" id="kobo.307.1"> command within the container by mounting my present working directory into the container and specifying my source document and what I want the output to be, </span><span class="No-Break"><span class="koboSpan" id="kobo.308.1">for example:</span></span></p>
<pre class="console"><span class="koboSpan" id="kobo.309.1">
$ podman run --rm -v $(pwd)/:/data pandoc/core -s input.md -o output.docx</span></pre> <p><span class="koboSpan" id="kobo.310.1">Since the working directory inside the container is </span><strong class="source-inline"><span class="koboSpan" id="kobo.311.1">/data</span></strong><span class="koboSpan" id="kobo.312.1">, and since I have that mounted to my host system, if the container creates a new file inside that directory, I will be able to find the output on my host </span><span class="No-Break"><span class="koboSpan" id="kobo.313.1">system. </span><span class="koboSpan" id="kobo.313.2">Cool!</span></span></p>
<h4><span class="koboSpan" id="kobo.314.1">Making a change to an image or video file using FFMPEG</span></h4>
<p><span class="koboSpan" id="kobo.315.1">In this example, we </span><a id="_idIndexMarker1012"/><span class="koboSpan" id="kobo.316.1">will leverage FFMPEG within a container in the same way we leveraged pandoc in the previous container. </span><span class="koboSpan" id="kobo.316.2">Using the FFMPEG container is especially handy because FFMPEG tends to rely on lots and lots of dependencies that I’d prefer not to install on my local machine. </span><span class="koboSpan" id="kobo.316.3">Additionally, it’s nice that the official FFMPEG container comes packaged with the latest version, and it </span><span class="No-Break"><span class="koboSpan" id="kobo.317.1">works great!</span></span></p>
<p><span class="koboSpan" id="kobo.318.1">Just like in the previous example, we can run </span><strong class="source-inline"><span class="koboSpan" id="kobo.319.1">--help</span></strong><span class="koboSpan" id="kobo.320.1"> after the </span><strong class="source-inline"><span class="koboSpan" id="kobo.321.1">ghcr.io/linuxserver/ffmpeg</span></strong><span class="koboSpan" id="kobo.322.1"> command to learn how to use FFMPEG, </span><span class="No-Break"><span class="koboSpan" id="kobo.323.1">for example:</span></span></p>
<pre class="console"><span class="koboSpan" id="kobo.324.1">
$ podman run --rm ghcr.io/linuxserver/ffmpeg --help</span></pre> <p><span class="koboSpan" id="kobo.325.1">From the output (you can also view the man page maintained here: </span><a href="https://linux.die.net/man/1/ffmpeg"><span class="koboSpan" id="kobo.326.1">https://linux.die.net/man/1/ffmpeg</span></a><span class="koboSpan" id="kobo.327.1">), I can see a plethora of options, but for the sake of brevity, I will simply show how you can use </span><strong class="source-inline"><span class="koboSpan" id="kobo.328.1">ffmpeg</span></strong><span class="koboSpan" id="kobo.329.1"> from a container to convert video within a container, </span><span class="No-Break"><span class="koboSpan" id="kobo.330.1">for example:</span></span></p>
<pre class="console"><span class="koboSpan" id="kobo.331.1">
$ podman run --rm -it -v $(pwd):/config \ 
ghcr.io/linuxserver/ffmpeg \
-ss 00:00:30 -t 5 -i /config/input.mkv \
-vcodec libx265 -crf 30 /config/output.mp4</span></pre> <p><span class="koboSpan" id="kobo.332.1">This </span><a id="_idIndexMarker1013"/><span class="koboSpan" id="kobo.333.1">command will start at 00 hours, 00 minutes, and 30 seconds (specified by </span><strong class="source-inline"><span class="koboSpan" id="kobo.334.1">-ss</span></strong><span class="koboSpan" id="kobo.335.1">) into the video, and will record 5 seconds (specified by </span><strong class="source-inline"><span class="koboSpan" id="kobo.336.1">-t</span></strong><span class="koboSpan" id="kobo.337.1">). </span><span class="koboSpan" id="kobo.337.2">It will then convert the video, and the output can be found </span><span class="No-Break"><span class="koboSpan" id="kobo.338.1">in </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.339.1">./config/output.mp4</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.340.1">.</span></span></p>
<h4><span class="koboSpan" id="kobo.341.1">Using Node.js within a container</span></h4>
<p><span class="koboSpan" id="kobo.342.1">Let’s say</span><a id="_idIndexMarker1014"/><span class="koboSpan" id="kobo.343.1"> we need to build a Node.js application. </span><span class="koboSpan" id="kobo.343.2">To do this, we’ll want to use Node and npm. </span><span class="koboSpan" id="kobo.343.3">In </span><a href="B18349_10.xhtml#_idTextAnchor304"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.344.1">Chapter 10</span></em></span></a><span class="koboSpan" id="kobo.345.1">, we discussed the usefulness of application streams and how you can leverage application streams to install different versions of Node.js. </span><span class="koboSpan" id="kobo.345.2">Well, just like anything else in life, there is </span><em class="italic"><span class="koboSpan" id="kobo.346.1">more than one way to skin </span></em><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.347.1">a cat</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.348.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.349.1">Rather than installing Node.js on your host system, why not leverage Node.js within a container instead? </span><span class="koboSpan" id="kobo.349.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.350.1">node</span></strong><span class="koboSpan" id="kobo.351.1"> container includes Node and npm. </span><span class="koboSpan" id="kobo.351.2">By default, when you run the </span><strong class="source-inline"><span class="koboSpan" id="kobo.352.1">node</span></strong><span class="koboSpan" id="kobo.353.1"> container, you are executing the </span><strong class="source-inline"><span class="koboSpan" id="kobo.354.1">node</span></strong><span class="koboSpan" id="kobo.355.1"> command, as this is the default entrypoint (as you may recall from earlier when we </span><span class="No-Break"><span class="koboSpan" id="kobo.356.1">discussed entrypoints).</span></span></p>
<p><span class="koboSpan" id="kobo.357.1">Let’s say we want to use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.358.1">npm</span></strong><span class="koboSpan" id="kobo.359.1"> command instead – we can do this by overriding the entrypoint. </span><span class="koboSpan" id="kobo.359.2">At this point, we know we can override the entrypoint by leveraging bash and appending a command at the end, but we also need to know where to mount our </span><span class="No-Break"><span class="koboSpan" id="kobo.360.1">host system:</span></span></p>
<pre class="console"><span class="koboSpan" id="kobo.361.1">
$ podman image inspect node | podman run -i --rm stedolan/jq -r '.[].Config.WorkingDir'</span></pre> <p><span class="koboSpan" id="kobo.362.1">From this, we can see that the default working directory within the container is null. </span><span class="koboSpan" id="kobo.362.2">Does that mean we can’t use the container the way we want? </span><span class="koboSpan" id="kobo.362.3">Of course not, because we can simply override the entrypoint and take matters into our own hands. </span><span class="koboSpan" id="kobo.362.4">In this scenario, I will mount the present working directory from my host system into an </span><strong class="source-inline"><span class="koboSpan" id="kobo.363.1">/app</span></strong><span class="koboSpan" id="kobo.364.1"> directory, and I’ll override the entry point to bash so I can instruct the container to change directory to </span><strong class="source-inline"><span class="koboSpan" id="kobo.365.1">/app</span></strong><span class="koboSpan" id="kobo.366.1"> before I run the </span><strong class="source-inline"><span class="koboSpan" id="kobo.367.1">npm</span></strong><span class="koboSpan" id="kobo.368.1"> command to build my Node.js application. </span><span class="koboSpan" id="kobo.368.2">Here’s how that can </span><span class="No-Break"><span class="koboSpan" id="kobo.369.1">be done:</span></span></p>
<pre class="console"><span class="koboSpan" id="kobo.370.1">
$ podman run --rm -v $(pwd):/app --entrypoint bash node -c 'cd /app &amp;&amp; npm run build'</span></pre> <p><span class="koboSpan" id="kobo.371.1">Once NPM completes the build, you’ll find your application binaries inside a directory called </span><strong class="source-inline"><span class="koboSpan" id="kobo.372.1">./build</span></strong><span class="koboSpan" id="kobo.373.1"> on your </span><span class="No-Break"><span class="koboSpan" id="kobo.374.1">host machine</span></span></p>
<p><span class="koboSpan" id="kobo.375.1">But </span><a id="_idIndexMarker1015"/><span class="koboSpan" id="kobo.376.1">wait, just as I mentioned earlier, there is </span><em class="italic"><span class="koboSpan" id="kobo.377.1">more than one way to skin a cat</span></em><span class="koboSpan" id="kobo.378.1">. </span><span class="koboSpan" id="kobo.378.2">A more elegant way to achieve the same thing might be to instead tell Podman where you want the working directory to be. </span><span class="koboSpan" id="kobo.378.3">If we do this, we don’t even need to set bash as our entry point – instead, we can jump straight into npm. </span><span class="koboSpan" id="kobo.378.4">This can be done with the </span><strong class="source-inline"><span class="koboSpan" id="kobo.379.1">-w</span></strong><span class="koboSpan" id="kobo.380.1"> (or </span><strong class="source-inline"><span class="koboSpan" id="kobo.381.1">--workdir</span></strong><span class="koboSpan" id="kobo.382.1">) command, </span><span class="No-Break"><span class="koboSpan" id="kobo.383.1">like so:</span></span></p>
<pre class="console"><span class="koboSpan" id="kobo.384.1">
$ podman run --rm -v $(pwd):/app --workdir /app --entrypoint npm node run build</span></pre> <p><span class="koboSpan" id="kobo.385.1">In my opinion, the second approach is cleaner, but the end result is </span><span class="No-Break"><span class="koboSpan" id="kobo.386.1">the same.</span></span></p>
<h4><span class="koboSpan" id="kobo.387.1">Running a lightweight NGINX web server to preview a web page locally</span></h4>
<p><span class="koboSpan" id="kobo.388.1">In this</span><a id="_idIndexMarker1016"/><span class="koboSpan" id="kobo.389.1"> example, we might as well continue from the last exercise, where we built a Node.js application. </span><span class="koboSpan" id="kobo.389.2">Now that we have our Node .js application built/compiled, let’s host it inside an NGINX container. </span><span class="koboSpan" id="kobo.389.3">We can do this by simply mounting the build directory into the </span><strong class="source-inline"><span class="koboSpan" id="kobo.390.1">/user/share/nginx/html</span></strong><span class="koboSpan" id="kobo.391.1"> directory inside the </span><span class="No-Break"><span class="koboSpan" id="kobo.392.1">NGINX container.</span></span></p>
<p><span class="koboSpan" id="kobo.393.1">How did I know to host it inside this specific directory? </span><span class="koboSpan" id="kobo.393.2">In this case, I had to read up on the NGINX documentation for the NGINX container. </span><span class="koboSpan" id="kobo.393.3">You can usually find this type of documentation on any container registry that hosts the container you’re looking </span><span class="No-Break"><span class="koboSpan" id="kobo.394.1">to run.</span></span></p>
<p><span class="koboSpan" id="kobo.395.1">The command to host our build directory locally is </span><span class="No-Break"><span class="koboSpan" id="kobo.396.1">the following:</span></span></p>
<pre class="console"><span class="koboSpan" id="kobo.397.1">
$ podman run --rm --name ol8cookbook -p 80:80 -v ${pwd}/build:/usr/share/nginx/html:ro -d nginx</span></pre> <p><span class="koboSpan" id="kobo.398.1">With Podman, the default setting for rootless ports cannot expose privileged port </span><strong class="source-inline"><span class="koboSpan" id="kobo.399.1">80</span></strong><span class="koboSpan" id="kobo.400.1">. </span><span class="koboSpan" id="kobo.400.2">If you have not changed this setting, you will see a message such </span><span class="No-Break"><span class="koboSpan" id="kobo.401.1">as this:</span></span></p>
<pre class="console"><span class="koboSpan" id="kobo.402.1">
Error: rootlessport cannot expose privileged port 80, you can add 'net.ipv4.ip_unprivileged_port_start=80' to /etc/sysctl.conf (currently 1024), or choose a larger port number (&gt;= 1024): listen tcp 0.0.0.0:80: bind: permission denied</span></pre> <p><span class="koboSpan" id="kobo.403.1">You can override this setting if you have root privileges, with </span><span class="No-Break"><span class="koboSpan" id="kobo.404.1">the following:</span></span></p>
<pre class="console"><span class="koboSpan" id="kobo.405.1">
$ sudo sysctl net.ipv4.ip_unprivileged_port_start=80</span></pre> <p><span class="koboSpan" id="kobo.406.1">Alternatively, you </span><a id="_idIndexMarker1017"/><span class="koboSpan" id="kobo.407.1">can simply choose to use a port number of </span><strong class="source-inline"><span class="koboSpan" id="kobo.408.1">1024</span></strong><span class="koboSpan" id="kobo.409.1"> or higher. </span><span class="koboSpan" id="kobo.409.2">Once you have the container running, you can preview the local website by navigating to </span><strong class="source-inline"><span class="koboSpan" id="kobo.410.1">http://localhost</span></strong><span class="koboSpan" id="kobo.411.1"> (if you’re using port </span><strong class="source-inline"><span class="koboSpan" id="kobo.412.1">80</span></strong><span class="koboSpan" id="kobo.413.1">) or </span><strong class="source-inline"><span class="koboSpan" id="kobo.414.1">http://localhost:8080</span></strong><span class="koboSpan" id="kobo.415.1"> (or whatever port that you assigned if you did not go with </span><span class="No-Break"><span class="koboSpan" id="kobo.416.1">port </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.417.1">80</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.418.1">).</span></span></p>
<h1 id="_idParaDest-245"><a id="_idTextAnchor330"/><span class="koboSpan" id="kobo.419.1">Docker Compose with Podman</span></h1>
<p><span class="koboSpan" id="kobo.420.1">Podman is a powerful container engine that is typically accessed via a </span><strong class="bold"><span class="koboSpan" id="kobo.421.1">command-line interface</span></strong><span class="koboSpan" id="kobo.422.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.423.1">CLI</span></strong><span class="koboSpan" id="kobo.424.1">) to </span><a id="_idIndexMarker1018"/><span class="koboSpan" id="kobo.425.1">facilitate the configuration and running of containers. </span><span class="koboSpan" id="kobo.425.2">It’s very handy to use the CLI to quickly launch a new container instance or to directly access existing containers, but what if you need to run multiple containers all at once? </span><span class="koboSpan" id="kobo.425.3">You could still use the CLI, but then you’ll probably get into the habit of copying and pasting long commands, which is not exactly the most ideal way of having a </span><a id="_idIndexMarker1019"/><span class="koboSpan" id="kobo.426.1">repeatable way of launching and deploying containers. </span><span class="koboSpan" id="kobo.426.2">Instead, why not use something such as Docker Compose? </span><span class="koboSpan" id="kobo.426.3">Docker Compose allows you to configure your container applications as code, in the popular </span><strong class="bold"><span class="koboSpan" id="kobo.427.1">Yet Another Markup Language</span></strong><span class="koboSpan" id="kobo.428.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.429.1">YAML</span></strong><span class="koboSpan" id="kobo.430.1">) format. </span><span class="koboSpan" id="kobo.430.2">YAML </span><a id="_idIndexMarker1020"/><span class="koboSpan" id="kobo.431.1">is designed to be declarative and human-readable. </span><span class="koboSpan" id="kobo.431.2">With Docker Compose, you can define your multiple containers’ attributes, including volumes, environment variables, networking information, and more, all in a single </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.432.1">docker-compose.yml</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.433.1"> file.</span></span></p>
<p><span class="koboSpan" id="kobo.434.1">While </span><a id="_idIndexMarker1021"/><span class="koboSpan" id="kobo.435.1">Docker Compose is a great utility for configuring your containers as code, it’s important to know that Docker Compose was designed to be used with Docker. </span><span class="koboSpan" id="kobo.435.2">With that being said, there are a few things to be aware of when using Docker Compose </span><span class="No-Break"><span class="koboSpan" id="kobo.436.1">with Podman.</span></span></p>
<h2 id="_idParaDest-246"><a id="_idTextAnchor331"/><span class="koboSpan" id="kobo.437.1">Getting ready</span></h2>
<p><span class="koboSpan" id="kobo.438.1">We will require </span><span class="No-Break"><span class="koboSpan" id="kobo.439.1">the following:</span></span></p>
<ul>
<li><span class="No-Break"><span class="koboSpan" id="kobo.440.1">Oracle Linux</span></span></li>
<li><span class="No-Break"><span class="koboSpan" id="kobo.441.1">Podman</span></span></li>
<li><span class="No-Break"><span class="koboSpan" id="kobo.442.1">Docker Compose</span></span></li>
</ul>
<h2 id="_idParaDest-247"><a id="_idTextAnchor332"/><span class="koboSpan" id="kobo.443.1">How to do it…</span></h2>
<p><span class="koboSpan" id="kobo.444.1">In this recipe, we’re going to talk about how you can use Docker Compose </span><span class="No-Break"><span class="koboSpan" id="kobo.445.1">with Podman.</span></span></p>
<p><span class="koboSpan" id="kobo.446.1">Since </span><a id="_idIndexMarker1022"/><span class="koboSpan" id="kobo.447.1">Compose files typically involve multiple containers and applications communicating with one another, I recommend the use of</span><a id="_idIndexMarker1023"/><span class="koboSpan" id="kobo.448.1"> the Netavark- and Aardvark-based network stack rather than the CNI-based stack. </span><span class="koboSpan" id="kobo.448.2">Netavark</span><a id="_idIndexMarker1024"/><span class="koboSpan" id="kobo.449.1"> and Aardvark are</span><a id="_idIndexMarker1025"/><span class="koboSpan" id="kobo.450.1"> new in Podman 4.0 and offer reduced overhead and significant performance enhancements. </span><span class="koboSpan" id="kobo.450.2">Additionally, I experienced issues with the default CNI-based stack, whereas switching to Netavark and Aardvark enabled my containers to communicate with each other </span><span class="No-Break"><span class="koboSpan" id="kobo.451.1">as expected:</span></span></p>
<ol>
<li><span class="koboSpan" id="kobo.452.1">To switch out your network stack, simply specify </span><strong class="source-inline"><span class="koboSpan" id="kobo.453.1">netavark</span></strong><span class="koboSpan" id="kobo.454.1"> as the network backend in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.455.1">/usr/share/containers/containers.conf</span></strong><span class="koboSpan" id="kobo.456.1"> file. </span><span class="koboSpan" id="kobo.456.2">You can do this quickly by running the following </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.457.1">sed</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.458.1"> command:</span></span><pre class="source-code">
<strong class="bold"><span class="koboSpan" id="kobo.459.1">sudo sed -i 's/network_backend = "cni"/network_backend = "netavark"/g' /usr/share/containers/containers.conf</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.460.1">sudo podman info | grep networkBackend</span></strong></pre></li> </ol>
<p class="callout-heading"><span class="koboSpan" id="kobo.461.1">Note</span></p>
<p class="callout"><span class="koboSpan" id="kobo.462.1">If you already running containers on your system, you will need to run </span><strong class="source-inline"><span class="koboSpan" id="kobo.463.1">sudo podman system reset</span></strong><span class="koboSpan" id="kobo.464.1"> in order to fully switch to the Netavark- and Aardvark-based network stack, but just be aware that this command will remove all your existing images, containers, pods, networks, </span><span class="No-Break"><span class="koboSpan" id="kobo.465.1">and volumes.</span></span></p>
<ol>
<li value="2"><span class="koboSpan" id="kobo.466.1">Now that is out of the way, let’s start by installing </span><span class="No-Break"><span class="koboSpan" id="kobo.467.1">Docker Compose:</span></span><pre class="source-code">
<strong class="bold"><span class="koboSpan" id="kobo.468.1">sudo curl -SL https://github.com/docker/compose/releases/download/v2.20.3/docker-compose-linux-x86_64 -o /usr/local/bin/docker-compose</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.469.1">sudo chmod +x /usr/local/bin/docker-compose</span></strong></pre></li> <li><span class="koboSpan" id="kobo.470.1">While we’re at it, since Docker Compose expects to make calls to Docker (rather than Podman), it </span><a id="_idIndexMarker1026"/><span class="koboSpan" id="kobo.471.1">might be a good idea to install the </span><strong class="source-inline"><span class="koboSpan" id="kobo.472.1">podman-docker</span></strong><span class="koboSpan" id="kobo.473.1"> package to ensure Podman is called anytime a reference to Docker is </span><span class="No-Break"><span class="koboSpan" id="kobo.474.1">being made:</span></span><pre class="source-code">
<strong class="bold"><span class="koboSpan" id="kobo.475.1">sudo dnf install podman-docker</span></strong></pre></li> <li><span class="koboSpan" id="kobo.476.1">Next, we </span><a id="_idIndexMarker1027"/><span class="koboSpan" id="kobo.477.1">need to enable the </span><span class="No-Break"><span class="koboSpan" id="kobo.478.1">Podman socket:</span></span><ul><li><span class="koboSpan" id="kobo.479.1">To use Docker Compose in a rootless manner, use </span><span class="No-Break"><span class="koboSpan" id="kobo.480.1">this command:</span></span><pre class="source-code">
<strong class="bold"><span class="koboSpan" id="kobo.481.1">systemctl --user enable --now podman.socket</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.482.1">export DOCKER_HOST=unix://$XDG_RUNTIME_DIR/podman/podman.sock</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.483.1">echo 'export DOCKER_HOST=unix://$XDG_RUNTIME_DIR/podman/podman.sock' &gt;&gt; ~/.bash_profile</span></strong></pre></li><li><span class="koboSpan" id="kobo.484.1">To use Docker Compose in a rootful manner, use </span><span class="No-Break"><span class="koboSpan" id="kobo.485.1">this command:</span></span><pre class="source-code"><strong class="bold"><span class="koboSpan" id="kobo.486.1">sudo systemctl enable --now podman.socket</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.487.1">sudo export DOCKER_HOST=unix:///run/podman/podman.sock</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.488.1">sudo echo 'export DOCKER_HOST=unix:///run/podman/podman.sock' &gt;&gt; /root/.bash_profile</span></strong></pre></li></ul></li> <li><span class="koboSpan" id="kobo.489.1">Now that Docker Compose is ready to go, we’ll need a Compose file to test things with. </span><span class="koboSpan" id="kobo.489.2">Let’s first examine a </span><span class="No-Break"><span class="koboSpan" id="kobo.490.1">Compose file:</span></span></li>
</ol>
<div>
<div class="IMG---Figure" id="_idContainer286">
<span class="koboSpan" id="kobo.491.1"><img alt="Figure 11.2 – Compose file for Portainer" src="image/B18349_11_002.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.492.1">Figure 11.2 – Compose file for Portainer</span></p>
<p class="list-inset"><span class="koboSpan" id="kobo.493.1">In a </span><strong class="source-inline"><span class="koboSpan" id="kobo.494.1">docker-compose.yml</span></strong><span class="koboSpan" id="kobo.495.1"> file, we define how we want Docker (or Podman in this case) to run multi-container applications. </span><span class="koboSpan" id="kobo.495.2">In the case of this </span><strong class="source-inline"><span class="koboSpan" id="kobo.496.1">docker-compose.yml</span></strong><span class="koboSpan" id="kobo.497.1"> file, we </span><a id="_idIndexMarker1028"/><span class="koboSpan" id="kobo.498.1">define the services and the volumes we want Podman to create, and we configure various parameters of the service to </span><span class="No-Break"><span class="koboSpan" id="kobo.499.1">our liking.</span></span></p>
<p class="callout-heading"><span class="koboSpan" id="kobo.500.1">Info</span></p>
<p class="callout"><span class="koboSpan" id="kobo.501.1">For a comprehensive overview of the entire Compose specification, </span><span class="No-Break"><span class="koboSpan" id="kobo.502.1">see </span></span><a href="https://docs.docker.com/compose/compose-file/"><span class="No-Break"><span class="koboSpan" id="kobo.503.1">https://docs.docker.com/compose/compose-file/</span></span></a><span class="No-Break"><span class="koboSpan" id="kobo.504.1">.</span></span></p>
<ol>
<li value="6"><span class="koboSpan" id="kobo.505.1">Now, let’s</span><a id="_idIndexMarker1029"/><span class="koboSpan" id="kobo.506.1"> test things and see if Docker Compose will work. </span><span class="koboSpan" id="kobo.506.2">Save the contents of the Compose file in a file </span><span class="No-Break"><span class="koboSpan" id="kobo.507.1">named </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.508.1">docker-compose.yml</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.509.1">.</span></span></li>
<li><span class="koboSpan" id="kobo.510.1">Using the terminal, change directory to the same directory you saved the </span><strong class="source-inline"><span class="koboSpan" id="kobo.511.1">docker-compose.yml</span></strong><span class="koboSpan" id="kobo.512.1"> file in and run </span><span class="No-Break"><span class="koboSpan" id="kobo.513.1">the following:</span></span><pre class="source-code">
<strong class="bold"><span class="koboSpan" id="kobo.514.1">docker-compose up -d</span></strong></pre><p class="list-inset"><span class="koboSpan" id="kobo.515.1">If all goes well, you should see some activity in the terminal indicating that Podman is downloading the container image, creating the volume, and finally, it will start to run the container just as we defined in the </span><span class="No-Break"><span class="koboSpan" id="kobo.516.1">Compose file.</span></span></p></li> <li><span class="koboSpan" id="kobo.517.1">Once the container</span><a id="_idIndexMarker1030"/><span class="koboSpan" id="kobo.518.1"> is running, navigate to the port we specified to see if it’s working as expected. </span><span class="koboSpan" id="kobo.518.2">To do this, simply point your browser </span><span class="No-Break"><span class="koboSpan" id="kobo.519.1">to </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.520.1">http://127.0.0.1:9000</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.521.1">.</span></span></li>
</ol>
<p><span class="koboSpan" id="kobo.522.1">Congratulations, you are</span><a id="_idIndexMarker1031"/><span class="koboSpan" id="kobo.523.1"> now using Docker Compose </span><span class="No-Break"><span class="koboSpan" id="kobo.524.1">with Podman.</span></span></p>
<h1 id="_idParaDest-248"><a id="_idTextAnchor333"/><span class="koboSpan" id="kobo.525.1">Managing stacks with pods</span></h1>
<p><span class="koboSpan" id="kobo.526.1">Keeping everything organized with stacks and prepping </span><span class="No-Break"><span class="koboSpan" id="kobo.527.1">for Kubernetes.</span></span></p>
<p><span class="koboSpan" id="kobo.528.1">Podman </span><a id="_idIndexMarker1032"/><span class="koboSpan" id="kobo.529.1">supports</span><a id="_idIndexMarker1033"/><span class="koboSpan" id="kobo.530.1"> concepts that do not exist in Docker. </span><span class="koboSpan" id="kobo.530.2">One of the big ones is pods – so I guess that’s where the name </span><em class="italic"><span class="koboSpan" id="kobo.531.1">Podman</span></em><span class="koboSpan" id="kobo.532.1"> derives from... </span><em class="italic"><span class="koboSpan" id="kobo.533.1">Podman = Pod Manager</span></em><span class="koboSpan" id="kobo.534.1">. </span><span class="koboSpan" id="kobo.534.2">In this recipe, you will learn how to keep things organized by managing stacks with Podman. </span><span class="koboSpan" id="kobo.534.3">We’ll achieve this functionality through the use of pods. </span><span class="koboSpan" id="kobo.534.4">Pods </span><a id="_idIndexMarker1034"/><span class="koboSpan" id="kobo.535.1">consist of one or more containers. </span><span class="koboSpan" id="kobo.535.2">Because pods are the smallest deployable units that you can create and manage in Kubernetes, familiarizing yourself with pods will help you bridge the gap between containers </span><span class="No-Break"><span class="koboSpan" id="kobo.536.1">and Kubernetes.</span></span></p>
<h2 id="_idParaDest-249"><a id="_idTextAnchor334"/><span class="koboSpan" id="kobo.537.1">Getting ready</span></h2>
<p><span class="koboSpan" id="kobo.538.1">We will require </span><span class="No-Break"><span class="koboSpan" id="kobo.539.1">the following:</span></span></p>
<ul>
<li><span class="No-Break"><span class="koboSpan" id="kobo.540.1">Oracle Linux</span></span></li>
<li><span class="No-Break"><span class="koboSpan" id="kobo.541.1">Podman</span></span></li>
<li><span class="No-Break"><span class="koboSpan" id="kobo.542.1">Docker Compose</span></span></li>
</ul>
<h2 id="_idParaDest-250"><a id="_idTextAnchor335"/><span class="koboSpan" id="kobo.543.1">How to do it…</span></h2>
<p><span class="koboSpan" id="kobo.544.1">Before we jump into the recipe, we should first discuss a little more about pods. </span><span class="koboSpan" id="kobo.544.2">As mentioned previously, pods consist of one or more containers. </span><span class="koboSpan" id="kobo.544.3">Pods will always contain an </span><strong class="source-inline"><span class="koboSpan" id="kobo.545.1">infra</span></strong><span class="koboSpan" id="kobo.546.1"> container, which, by default is based on the </span><strong class="source-inline"><span class="koboSpan" id="kobo.547.1">k8s.gcr.io/pause</span></strong><span class="koboSpan" id="kobo.548.1"> image. </span><span class="koboSpan" id="kobo.548.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.549.1">infra</span></strong><span class="koboSpan" id="kobo.550.1"> container basically does nothing but sleep – this ensures that the container continues to run even while idle, and it holds the port bindings, namespaces, and cgroups from the kernel. </span><span class="koboSpan" id="kobo.550.2">Once the pod is created, the attributes assigned to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.551.1">infra</span></strong><span class="koboSpan" id="kobo.552.1"> container cannot be changed. </span><span class="koboSpan" id="kobo.552.2">It’s important to remember that any ports that need to be exposed will need to be done during the initial creation of </span><span class="No-Break"><span class="koboSpan" id="kobo.553.1">the pod.</span></span></p>
<p><span class="koboSpan" id="kobo.554.1">Outside</span><a id="_idIndexMarker1035"/><span class="koboSpan" id="kobo.555.1"> of the pod exists a </span><strong class="bold"><span class="koboSpan" id="kobo.556.1">conmon</span></strong><span class="koboSpan" id="kobo.557.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.558.1">container monitor</span></strong><span class="koboSpan" id="kobo.559.1">) instance</span><a id="_idIndexMarker1036"/><span class="koboSpan" id="kobo.560.1"> that watches the primary process of the cont</span><a id="_idTextAnchor336"/><span class="koboSpan" id="kobo.561.1">ainer. </span><span class="koboSpan" id="kobo.561.2">Each container has its own instance </span><span class="No-Break"><span class="koboSpan" id="kobo.562.1">of conmon.</span></span></p>
<p><span class="koboSpan" id="kobo.563.1">The following diagram provides an architectural overview of what makes up </span><span class="No-Break"><span class="koboSpan" id="kobo.564.1">a pod.</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer287">
<span class="koboSpan" id="kobo.565.1"><img alt="Figure 11.3 – Architectural overview of a pod" src="image/B18349_11_003.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.566.1">Figure 11.3 – Architectural overview of a pod</span></p>
<p><span class="koboSpan" id="kobo.567.1">Here are the Podman commands that relate </span><span class="No-Break"><span class="koboSpan" id="kobo.568.1">to pods:</span></span></p>
<pre class="console"><span class="koboSpan" id="kobo.569.1">
Manage pods
Description:
  Pods are a group of one or more containers sharing the same network, pid and ipc namespaces.
</span><span class="koboSpan" id="kobo.569.2">Usage:
  podman pod [command]
Available Commands:
  clone       Clone an existing pod
  create      Create a new empty pod
  exists      Check if a pod exists in local storage
  inspect     Displays a pod configuration
  kill        Send the specified signal or SIGKILL to containers in pod
  logs        Fetch logs for pod with one or more containers
  pause       Pause one or more pods
  prune       Remove all stopped pods and their containers
  ps          List pods
  restart     Restart one or more pods
  rm          Remove one or more pods
  start       Start one or more pods
  stats       Display a live stream of resource usage statistics for the containers in one or more pods
  stop        Stop one or more pods
  top         Display the running processes of containers in a pod
  unpause     Unpause one or more pods</span></pre> <p><span class="koboSpan" id="kobo.570.1">As can be</span><a id="_idIndexMarker1037"/><span class="koboSpan" id="kobo.571.1"> seen from the preceding commands, you can use the Podman </span><a id="_idIndexMarker1038"/><span class="koboSpan" id="kobo.572.1">CLI to create a pod and run your containers within </span><span class="No-Break"><span class="koboSpan" id="kobo.573.1">the pod.</span></span></p>
<h3><span class="koboSpan" id="kobo.574.1">Manual pod creation</span></h3>
<p><span class="koboSpan" id="kobo.575.1">Let’s say we </span><a id="_idIndexMarker1039"/><span class="koboSpan" id="kobo.576.1">wanted to deploy Wiki.js inside a pod. </span><span class="koboSpan" id="kobo.576.2">Wiki.js is open source Wiki software built on Node.js and relies on a database backend. </span><span class="koboSpan" id="kobo.576.3">In other words, we want a pod that looks </span><span class="No-Break"><span class="koboSpan" id="kobo.577.1">like this:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer288">
<span class="koboSpan" id="kobo.578.1"><img alt="Figure 11.4 – Architecture of a Wiki.js pod" src="image/B18349_11_004.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.579.1">Figure 11.4 – Architecture of a Wiki.js pod</span></p>
<p><span class="koboSpan" id="kobo.580.1">We can construct this pod manually by following </span><span class="No-Break"><span class="koboSpan" id="kobo.581.1">these steps:</span></span></p>
<ol>
<li><span class="koboSpan" id="kobo.582.1">The first step is to create a pod. </span><span class="koboSpan" id="kobo.582.2">As we do this, we need to ensure we configure the port mappings to allow ingress into port </span><strong class="source-inline"><span class="koboSpan" id="kobo.583.1">3000</span></strong><span class="koboSpan" id="kobo.584.1">. </span><span class="koboSpan" id="kobo.584.2">We will do this using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.585.1">podman </span></strong><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.586.1">pod</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.587.1"> command:</span></span><pre class="source-code">
<strong class="bold"><span class="koboSpan" id="kobo.588.1">podman pod create -p 3000:3000 wikijs-pod</span></strong></pre></li> <li><span class="koboSpan" id="kobo.589.1">Next, we need to create our database container inside the pod. </span><span class="koboSpan" id="kobo.589.2">We can do this through the use of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.590.1">--</span></strong><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.591.1">pod</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.592.1"> tag:</span></span><pre class="source-code">
<strong class="bold"><span class="koboSpan" id="kobo.593.1">podman run -td --pod wikijs-pod --name wikijs-db --env POSTGRES_DB=postgres --env POSTGRES_PASSWORD=wikijsrocks --env POSTGRES_USER=postgres -v wikijs-db-data:/var/lib/postgresql/data postgres</span></strong></pre></li> <li><span class="koboSpan" id="kobo.594.1">Now that the database is up and running, we’ll need to create our application container inside the pod. </span><span class="koboSpan" id="kobo.594.2">Again, we’ll use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.595.1">--pod</span></strong><span class="koboSpan" id="kobo.596.1"> tag to ensure this container </span><a id="_idIndexMarker1040"/><span class="koboSpan" id="kobo.597.1">runs inside the same pod as </span><span class="No-Break"><span class="koboSpan" id="kobo.598.1">the database:</span></span><pre class="source-code">
<strong class="bold"><span class="koboSpan" id="kobo.599.1">podman run -td --pod wikijs-pod --name wikijs --env DB_TYPE=postgres --env DB_HOST=wikijs-db --env DB_PORT=5432 --env DB_USER=postgres --env DB_PASS=wikijsrocks --env DB_NAME=postgres ghcr.io/requarks/wiki</span></strong></pre></li> <li><span class="koboSpan" id="kobo.600.1">Now that the application is running, point your browser </span><span class="No-Break"><span class="koboSpan" id="kobo.601.1">to </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.602.1">http://127.0.0.1:3000/</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.603.1">.</span></span></li>
</ol>
<h3><span class="koboSpan" id="kobo.604.1">Automatic pod creation</span></h3>
<p><span class="koboSpan" id="kobo.605.1">Podman</span><a id="_idIndexMarker1041"/><span class="koboSpan" id="kobo.606.1"> allows you to create pods manually using the command-line interface, but another cool feature of Podman is that it natively supports Kubernetes manifests. </span><span class="koboSpan" id="kobo.606.2">Since pods are the smallest deployable units that you can create and manage in Kubernetes, this means that deploying Kubernetes manifests in Podman will result in the creation of pods </span><span class="No-Break"><span class="koboSpan" id="kobo.607.1">by default.</span></span></p>
<p><span class="koboSpan" id="kobo.608.1">Writing a full Kubernetes manifest is outside the scope of this recipe, but I’m going to show you how you can generate a Kubernetes manifest automatically using Podman, and subsequently use that manifest to deploy your containers into pods. </span><span class="koboSpan" id="kobo.608.2">Since we just learned about using Compose files in the previous recipe, we’re going to leverage them again here, and then we’ll supercharge them by converting them into </span><span class="No-Break"><span class="koboSpan" id="kobo.609.1">Kubernetes manifests:</span></span></p>
<ol>
<li><span class="koboSpan" id="kobo.610.1">The first thing to do is to deploy your containers from a Compose file. </span><span class="koboSpan" id="kobo.610.2">For this recipe, we’ll start with a Compose file </span><span class="No-Break"><span class="koboSpan" id="kobo.611.1">for Wiki.js.</span></span></li>
</ol>
<div>
<div class="IMG---Figure" id="_idContainer289">
<span class="koboSpan" id="kobo.612.1"><img alt="Figure 11.5 – Compose file for Wiki.js" src="image/B18349_11_005.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.613.1">Figure 11.5 – Compose file for Wiki.js</span></p>
<p class="list-inset"><span class="koboSpan" id="kobo.614.1">Wiki.js </span><a id="_idIndexMarker1042"/><span class="koboSpan" id="kobo.615.1">requires two containers, one for the application itself, and the other is a </span><span class="No-Break"><span class="koboSpan" id="kobo.616.1">PostgreSQL database.</span></span></p>
<ol>
<li value="2"><span class="koboSpan" id="kobo.617.1">Now that we have our Compose file, let’s use Docker Compose to deploy </span><span class="No-Break"><span class="koboSpan" id="kobo.618.1">the containers:</span></span><pre class="source-code">
<strong class="bold"><span class="koboSpan" id="kobo.619.1">docker-compose up -d</span></strong></pre><p class="list-inset"><span class="koboSpan" id="kobo.620.1">Wait as the container images are pulled in, and for the status of </span><strong class="source-inline"><span class="koboSpan" id="kobo.621.1">wikijs</span></strong><span class="koboSpan" id="kobo.622.1"> to change </span><span class="No-Break"><span class="koboSpan" id="kobo.623.1">to </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.624.1">Started</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.625.1">.</span></span></p></li> <li><span class="koboSpan" id="kobo.626.1">Once the</span><a id="_idIndexMarker1043"/><span class="koboSpan" id="kobo.627.1"> containers are running, verify that everything works by pointing your browser </span><span class="No-Break"><span class="koboSpan" id="kobo.628.1">to </span></span><span class="No-Break"><span class="koboSpan" id="kobo.629.1">http://127.0.0.1:3000</span></span><span class="No-Break"><span class="koboSpan" id="kobo.630.1">.</span></span></li>
<li><span class="koboSpan" id="kobo.631.1">If you see the Wiki.js setup screen, you’re good to go. </span><span class="koboSpan" id="kobo.631.2">At this point, we’re going to generate a Kubernetes manifest (called </span><strong class="source-inline"><span class="koboSpan" id="kobo.632.1">wikij</span><a id="_idTextAnchor337"/><span class="koboSpan" id="kobo.633.1">s.yaml</span></strong><span class="koboSpan" id="kobo.634.1">) from the two containers we </span><span class="No-Break"><span class="koboSpan" id="kobo.635.1">just launched:</span></span><pre class="source-code">
<strong class="bold"><span class="koboSpan" id="kobo.636.1">Podman generate kube -s -f wikijs.yaml wikijs wikijs-db</span></strong></pre></li> <li><span class="koboSpan" id="kobo.637.1">Now that the Kubernetes manifest is generated, let’s bring down the containers we </span><span class="No-Break"><span class="koboSpan" id="kobo.638.1">just launched:</span></span><pre class="source-code">
<strong class="bold"><span class="koboSpan" id="kobo.639.1">Docker-compose down</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.640.1">podman volume prune</span></strong></pre></li> <li><span class="koboSpan" id="kobo.641.1">The next step is to use </span><strong class="source-inline"><span class="koboSpan" id="kobo.642.1">podman play kube</span></strong><span class="koboSpan" id="kobo.643.1"> to bring up the containers in a pod using the Kubernetes manifest, but before we do that, we need to fix one of the hostnames specified in the </span><span class="No-Break"><span class="koboSpan" id="kobo.644.1">environment variables.</span></span><p class="list-inset"><span class="koboSpan" id="kobo.645.1">The reason we need to do that is the name of the pod is appended to the name of every container running within the pod. </span><span class="koboSpan" id="kobo.645.2">So instead of our database container being called </span><strong class="source-inline"><span class="koboSpan" id="kobo.646.1">wikijs-db</span></strong><span class="koboSpan" id="kobo.647.1">, it will be called </span><strong class="source-inline"><span class="koboSpan" id="kobo.648.1">wikijs-pod-wikijs-db</span></strong><span class="koboSpan" id="kobo.649.1">. </span><span class="koboSpan" id="kobo.649.2">If you look at the manifest, you’ll see that </span><strong class="source-inline"><span class="koboSpan" id="kobo.650.1">wikijs</span></strong><span class="koboSpan" id="kobo.651.1"> is configured to hook up to a database container called </span><strong class="source-inline"><span class="koboSpan" id="kobo.652.1">wikijs-db</span></strong><span class="koboSpan" id="kobo.653.1">, so we need to update the value of </span><strong class="source-inline"><span class="koboSpan" id="kobo.654.1">DB_HOST</span></strong><span class="koboSpan" id="kobo.655.1"> and change it </span><span class="No-Break"><span class="koboSpan" id="kobo.656.1">to </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.657.1">wikijs-pod-wikijs-db</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.658.1">.</span></span></p><p class="list-inset"><span class="koboSpan" id="kobo.659.1">You can do this reliably by using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.660.1">yq</span></strong><span class="koboSpan" id="kobo.661.1"> command. </span><span class="koboSpan" id="kobo.661.2">If you don’t have </span><strong class="source-inline"><span class="koboSpan" id="kobo.662.1">yq</span></strong><span class="koboSpan" id="kobo.663.1"> installed on your computer, no worries, just use a </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.664.1">yq</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.665.1"> container:</span></span></p><pre class="source-code">
<strong class="bold"><span class="koboSpan" id="kobo.666.1">Podman run –rm -v ${PWD}:/workdir docker.io/mikefarah/yq e -i '(select(.kind == "Pod").spec.containers[] | select(.name == "wikijs" ).env[] | select(.name == "DB_HOST")).value = "wikijs-pod-wikijs-db"' wikijs.yaml</span></strong></pre></li> </ol>
<p class="callout-heading"><span class="koboSpan" id="kobo.667.1">Note</span></p>
<p class="callout"><span class="koboSpan" id="kobo.668.1">Refer to the </span><em class="italic"><span class="koboSpan" id="kobo.669.1">Creating handy-dandy utility containers</span></em><span class="koboSpan" id="kobo.670.1"> recipe for more information on how to use a container as </span><span class="No-Break"><span class="koboSpan" id="kobo.671.1">a utility.</span></span></p>
<ol>
<li value="7"><span class="koboSpan" id="kobo.672.1">Once </span><a id="_idIndexMarker1044"/><span class="koboSpan" id="kobo.673.1">you’ve corrected the </span><strong class="source-inline"><span class="koboSpan" id="kobo.674.1">DB_HOST</span></strong><span class="koboSpan" id="kobo.675.1"> value, run the </span><span class="No-Break"><span class="koboSpan" id="kobo.676.1">following command:</span></span><pre class="source-code">
<strong class="bold"><span class="koboSpan" id="kobo.677.1">podman play kube wikijs.yaml</span></strong></pre></li> <li><span class="koboSpan" id="kobo.678.1">Verify that the pod </span><span class="No-Break"><span class="koboSpan" id="kobo.679.1">is running:</span></span><pre class="source-code">
<strong class="bold"><span class="koboSpan" id="kobo.680.1">podman pod ls</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.681.1">podman ps -ap</span></strong></pre><p class="list-inset"><span class="koboSpan" id="kobo.682.1">Finally, go ahead and navigate </span><span class="No-Break"><span class="koboSpan" id="kobo.683.1">to </span></span><span class="No-Break"><span class="koboSpan" id="kobo.684.1">http://127.0.0.1:3000</span></span><span class="No-Break"><span class="koboSpan" id="kobo.685.1">.</span></span></p></li> </ol>
<h1 id="_idParaDest-251"><a id="_idTextAnchor338"/><span class="koboSpan" id="kobo.686.1">Containerized databases</span></h1>
<p><span class="koboSpan" id="kobo.687.1">This recipe</span><a id="_idIndexMarker1045"/><span class="koboSpan" id="kobo.688.1"> discusses best practices regarding the use of </span><span class="No-Break"><span class="koboSpan" id="kobo.689.1">containerized databases.</span></span></p>
<h2 id="_idParaDest-252"><a id="_idTextAnchor339"/><span class="koboSpan" id="kobo.690.1">Getting ready</span></h2>
<p><span class="koboSpan" id="kobo.691.1">We will require </span><span class="No-Break"><span class="koboSpan" id="kobo.692.1">the following:</span></span></p>
<ul>
<li><span class="No-Break"><span class="koboSpan" id="kobo.693.1">Oracle Linux</span></span></li>
<li><span class="No-Break"><span class="koboSpan" id="kobo.694.1">Podman</span></span></li>
</ul>
<h2 id="_idParaDest-253"><a id="_idTextAnchor340"/><span class="koboSpan" id="kobo.695.1">How to do it…</span></h2>
<p><span class="koboSpan" id="kobo.696.1">Containers make databases a much easier pill to swallow for your everyday application deployments. </span><span class="koboSpan" id="kobo.696.2">There’s not a lot to discuss in this recipe, but there are a few best practices with containerized databases that will definitely be useful to </span><span class="No-Break"><span class="koboSpan" id="kobo.697.1">know about.</span></span></p>
<h3><span class="koboSpan" id="kobo.698.1">Do one thing and one thing only</span></h3>
<p><span class="koboSpan" id="kobo.699.1">Just as a </span><a id="_idIndexMarker1046"/><span class="koboSpan" id="kobo.700.1">core principle of containers is to do one thing and one thing only, the same principle applies to containerized databases. </span><span class="koboSpan" id="kobo.700.2">What do I mean by that? </span><span class="koboSpan" id="kobo.700.3">Well, for starters, you might be inclined to launch a containerized database and subsequently create multiple schemas within that database and/or multiple databases within that single container. </span><span class="koboSpan" id="kobo.700.4">Let’s say you have several applications that require a MySQL database, then it probably seems like a good idea to have a single MySQL database container with separate database schemas for each containerized application… something that looks a bit </span><span class="No-Break"><span class="koboSpan" id="kobo.701.1">like this:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer290">
<span class="koboSpan" id="kobo.702.1"><img alt="Figure 11.6 – What not to do with containerized databases" src="image/B18349_11_006.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.703.1">Figure 11.6 – What not to do with containerized databases</span></p>
<p><span class="koboSpan" id="kobo.704.1">The problem with this architecture is that it does not adhere well to the principle of doing one thing and one thing only. </span><span class="koboSpan" id="kobo.704.2">Instead, I recommend spinning up a separate container for each database an application needs. </span><span class="koboSpan" id="kobo.704.3">Name that container so that it is complementary to the application it’s paired with – something </span><span class="No-Break"><span class="koboSpan" id="kobo.705.1">like this:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer291">
<span class="koboSpan" id="kobo.706.1"><img alt="Figure 11.7 – A better way to use containerized databases" src="image/B18349_11_007.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.707.1">Figure 11.7 – A better way to use containerized databases</span></p>
<p><span class="koboSpan" id="kobo.708.1">For example, let’s say you have a WordPress container that requires a database. </span><span class="koboSpan" id="kobo.708.2">In this scenario, if you named your WordPress container </span><strong class="source-inline"><span class="koboSpan" id="kobo.709.1">wordpress01</span></strong><span class="koboSpan" id="kobo.710.1">, then you should name your MySQL container </span><strong class="source-inline"><span class="koboSpan" id="kobo.711.1">wordpress01-db</span></strong><span class="koboSpan" id="kobo.712.1">. </span><span class="koboSpan" id="kobo.712.2">Having a separate container for every database you </span><a id="_idIndexMarker1047"/><span class="koboSpan" id="kobo.713.1">want to run will make it easier to troubleshoot issues and will additionally serve as a more reliable architectural model for your deployed applications. </span><span class="koboSpan" id="kobo.713.2">If you need to take one containerized database down, you’re then only affecting one application, rather than all of them if you chose to run multiple databases within </span><span class="No-Break"><span class="koboSpan" id="kobo.714.1">one container.</span></span></p>
<h3><span class="koboSpan" id="kobo.715.1">Data storage</span></h3>
<p><span class="koboSpan" id="kobo.716.1">Persistent data is</span><a id="_idIndexMarker1048"/><span class="koboSpan" id="kobo.717.1"> something you’ll need to address when running databases in containers. </span><span class="koboSpan" id="kobo.717.2">With Podman, you have two primary options: volumes and bind mounts. </span><span class="koboSpan" id="kobo.717.3">With volumes, Podman will manage the storage of your database by writing the data to disk using its own internal volume management system. </span><span class="koboSpan" id="kobo.717.4">With bind mounts, you will need to specify a location on the host system and mount that into the container. </span><span class="koboSpan" id="kobo.717.5">Either option is fine, and typically volumes are easier because it requires less configuration by the user, but the downside is that the data can be more difficult to locate on the host system. </span><span class="koboSpan" id="kobo.717.6">Additionally, it is possible for the volumes to be deleted by mistake via careless use of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.718.1">podman volume prune</span></strong><span class="koboSpan" id="kobo.719.1"> command. </span><span class="koboSpan" id="kobo.719.2">With that being said, for demonstrations or quick tests, I like to use volumes, but for persistent data that is truly important, I prefer to use </span><span class="No-Break"><span class="koboSpan" id="kobo.720.1">bind mounts.</span></span></p>
<p><span class="koboSpan" id="kobo.721.1">Creating volumes is simple. </span><span class="koboSpan" id="kobo.721.2">There are a few ways in which Podman allows for the creation of volumes. </span><span class="koboSpan" id="kobo.721.3">You can create a volume manually from the command line via the </span><strong class="source-inline"><span class="koboSpan" id="kobo.722.1">podman volume create [NAME]</span></strong><span class="koboSpan" id="kobo.723.1"> command. </span><span class="koboSpan" id="kobo.723.2">You can also let Podman do the heavy lifting for you, as it is capable of creating volumes automatically during container creation. </span><span class="koboSpan" id="kobo.723.3">Podman can create a named volume if you specify the name; for example, running </span><strong class="source-inline"><span class="koboSpan" id="kobo.724.1">podman run -v my_data:/var/lib/mysql mysql:8-oracle</span></strong><span class="koboSpan" id="kobo.725.1"> will create a volume called </span><strong class="source-inline"><span class="koboSpan" id="kobo.726.1">my_data</span></strong><span class="koboSpan" id="kobo.727.1">. </span><span class="koboSpan" id="kobo.727.2">Podman can also create an anonymous volume if you leave out the </span><strong class="source-inline"><span class="koboSpan" id="kobo.728.1">-v my_data:/data</span></strong><span class="koboSpan" id="kobo.729.1"> specification and instead run </span><strong class="source-inline"><span class="koboSpan" id="kobo.730.1">podman run -</span></strong><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.731.1">it oraclelinux:8</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.732.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.733.1">If you want to use a bind mount instead, all you need to do is specify the location of where that mount should reside on the host system. </span><span class="koboSpan" id="kobo.733.2">For example, if you want to store your data in </span><strong class="source-inline"><span class="koboSpan" id="kobo.734.1">/mnt/hdd/podman/volumes/</span></strong><span class="koboSpan" id="kobo.735.1">, you would simply need to specify this location as the source location. </span><span class="koboSpan" id="kobo.735.2">I prefer to set my volume location as an environment variable called </span><strong class="source-inline"><span class="koboSpan" id="kobo.736.1">VOLUME_DIR</span></strong><span class="koboSpan" id="kobo.737.1"> so that I can reference it with </span><strong class="source-inline"><span class="koboSpan" id="kobo.738.1">${VOLUME_DIR}</span></strong><span class="koboSpan" id="kobo.739.1">. </span><span class="koboSpan" id="kobo.739.2">Then, when I specify creating a bind mount in the container, I simply use </span><strong class="source-inline"><span class="koboSpan" id="kobo.740.1">podman run -v ${VOLUME_DIR}/wordpress:/var/lib/mysql mysql:8-oracle</span></strong><span class="koboSpan" id="kobo.741.1">. </span><span class="koboSpan" id="kobo.741.2">This will ensure that all my </span><a id="_idIndexMarker1049"/><span class="koboSpan" id="kobo.742.1">data is stored in a predictable location on my system, and each container gets its dedicated folder within </span><span class="No-Break"><span class="koboSpan" id="kobo.743.1">that path.</span></span></p>
<h3><span class="koboSpan" id="kobo.744.1">Initialization scripts</span></h3>
<p><span class="koboSpan" id="kobo.745.1">Most containerized </span><a id="_idIndexMarker1050"/><span class="koboSpan" id="kobo.746.1">databases feature a way to facilitate the running of scripts after initial setup, which can be very handy. </span><span class="koboSpan" id="kobo.746.2">This is typically done by allowing the user to mount a directory from the host machine that contains </span><strong class="source-inline"><span class="koboSpan" id="kobo.747.1">.sql</span></strong><span class="koboSpan" id="kobo.748.1"> and/or </span><strong class="source-inline"><span class="koboSpan" id="kobo.749.1">.sh</span></strong><span class="koboSpan" id="kobo.750.1"> files into the </span><strong class="source-inline"><span class="koboSpan" id="kobo.751.1">/docker-entrypoint-initdb.d</span></strong><span class="koboSpan" id="kobo.752.1"> directory of the container. </span><span class="koboSpan" id="kobo.752.2">The scripts are generally executed in alphabetical order and thus can be easily controlled by adding a prefix with a number, for example, </span><strong class="source-inline"><span class="koboSpan" id="kobo.753.1">01_users.sql</span></strong><span class="koboSpan" id="kobo.754.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.755.1">02_permissions.sql</span></strong><span class="koboSpan" id="kobo.756.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.757.1">03_hostname.sh</span></strong><span class="koboSpan" id="kobo.758.1">, and </span><span class="No-Break"><span class="koboSpan" id="kobo.759.1">so forth:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.760.1">The </span><span class="No-Break"><span class="koboSpan" id="kobo.761.1">MySQL database:</span></span><p class="list-inset"><span class="koboSpan" id="kobo.762.1">The MySQL database supports </span><strong class="source-inline"><span class="koboSpan" id="kobo.763.1">*.sh</span></strong><span class="koboSpan" id="kobo.764.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.765.1">*.sql</span></strong><span class="koboSpan" id="kobo.766.1"> scripts in the following </span><span class="No-Break"><span class="koboSpan" id="kobo.767.1">mount points:</span></span></p><pre class="source-code">
<strong class="bold"><span class="koboSpan" id="kobo.768.1">/docker-entrypoint-initdb.d</span></strong></pre></li> <li><span class="koboSpan" id="kobo.769.1">The </span><span class="No-Break"><span class="koboSpan" id="kobo.770.1">PostgreSQL database:</span></span><p class="list-inset"><span class="koboSpan" id="kobo.771.1">The PostgreSQL database supports </span><strong class="source-inline"><span class="koboSpan" id="kobo.772.1">*.sh</span></strong><span class="koboSpan" id="kobo.773.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.774.1">*.sql</span></strong><span class="koboSpan" id="kobo.775.1">, and </span><strong class="source-inline"><span class="koboSpan" id="kobo.776.1">*.sql.gz</span></strong><span class="koboSpan" id="kobo.777.1"> scripts in the following </span><span class="No-Break"><span class="koboSpan" id="kobo.778.1">mount points:</span></span></p><pre class="source-code">
<strong class="bold"><span class="koboSpan" id="kobo.779.1">/docker-entrypoint-initdb.d</span></strong></pre></li> <li><span class="koboSpan" id="kobo.780.1">The </span><span class="No-Break"><span class="koboSpan" id="kobo.781.1">MongoDB database:</span></span><p class="list-inset"><span class="koboSpan" id="kobo.782.1">MongoDB supports </span><strong class="source-inline"><span class="koboSpan" id="kobo.783.1">*.sh</span></strong><span class="koboSpan" id="kobo.784.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.785.1">*.js</span></strong><span class="koboSpan" id="kobo.786.1"> scripts in the following </span><span class="No-Break"><span class="koboSpan" id="kobo.787.1">mount points:</span></span></p><pre class="source-code">
<strong class="bold"><span class="koboSpan" id="kobo.788.1">/docker-entrypoint-initdb.d</span></strong></pre></li> <li><span class="koboSpan" id="kobo.789.1">The </span><span class="No-Break"><span class="koboSpan" id="kobo.790.1">Oracle database:</span></span><p class="list-inset"><span class="koboSpan" id="kobo.791.1">The Oracle database supports </span><strong class="source-inline"><span class="koboSpan" id="kobo.792.1">*.sh</span></strong><span class="koboSpan" id="kobo.793.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.794.1">*.sql</span></strong><span class="koboSpan" id="kobo.795.1"> scripts in the following </span><span class="No-Break"><span class="koboSpan" id="kobo.796.1">mount points:</span></span></p><ul><li><strong class="source-inline"><span class="koboSpan" id="kobo.797.1">/opt/oracle/scripts/setup</span></strong><span class="koboSpan" id="kobo.798.1">: </span><span class="No-Break"><span class="koboSpan" id="kobo.799.1">Post-setup scripts</span></span></li><li><strong class="source-inline"><span class="koboSpan" id="kobo.800.1">/opt/oracle/scripts/startup</span></strong><span class="koboSpan" id="kobo.801.1">: </span><span class="No-Break"><span class="koboSpan" id="kobo.802.1">Post-startup scripts</span></span></li><li><strong class="source-inline"><span class="koboSpan" id="kobo.803.1">/docker-entrypoint-initdb.d</span></strong><span class="koboSpan" id="kobo.804.1">: Symbolic link representing the </span><span class="No-Break"><span class="koboSpan" id="kobo.805.1">aforementioned</span></span><span class="No-Break"><a id="_idIndexMarker1051"/></span><span class="No-Break"><span class="koboSpan" id="kobo.806.1"> directories</span></span></li></ul></li>
</ul>
<h3><span class="koboSpan" id="kobo.807.1">Controlling the startup order</span></h3>
<p><span class="koboSpan" id="kobo.808.1">Using a </span><a id="_idIndexMarker1052"/><span class="koboSpan" id="kobo.809.1">Compose file, you are able to control the startup order of your containers by using condition attributes. </span><span class="koboSpan" id="kobo.809.2">A nice way to ensure your database is up and running (and ready to accept connections) is to configure a health check against the database. </span><span class="koboSpan" id="kobo.809.3">Once the health check succeeds, the database container will become healthy. </span><span class="koboSpan" id="kobo.809.4">The application that requires the database can be configured not to start until the database container enters a healthy state. </span><span class="koboSpan" id="kobo.809.5">This can be done using the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.810.1">depends_on</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.811.1"> option.</span></span></p>
<p><span class="koboSpan" id="kobo.812.1">If you wanted to add a health check to a PostgreSQL database, you could configure that with </span><span class="No-Break"><span class="koboSpan" id="kobo.813.1">the following:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.814.1">
healthcheck:
  test: pg_isready
  start_period: 5s
  interval: 5s
  timeout: 5s
  retries: 55</span></pre> <p><span class="koboSpan" id="kobo.815.1">Then, for the application, you would simply specify the service name (in this </span><span class="No-Break"><span class="koboSpan" id="kobo.816.1">example, </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.817.1">wikijs-db</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.818.1">):</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.819.1">
depends_on:
  wikijs-db:
    condition: service_healthy</span></pre> <p><span class="koboSpan" id="kobo.820.1">When these options are configured properly, you will no longer see repeated connection failures as the application tries to connect to a database that isn’t ready, because the application container won’t even start until the database container </span><span class="No-Break"><span class="koboSpan" id="kobo.821.1">is healthy.</span></span></p>
<h3><span class="koboSpan" id="kobo.822.1">Tying it all together</span></h3>
<p><span class="koboSpan" id="kobo.823.1">Now that we’ve discussed these database best practices, it’s time to tie it all together with a</span><a id="_idIndexMarker1053"/><span class="koboSpan" id="kobo.824.1"> Compose file to deploy a WordPress website. </span><span class="koboSpan" id="kobo.824.2">WordPress</span><a id="_idIndexMarker1054"/><span class="koboSpan" id="kobo.825.1"> requires a MySQL database, so in the Compose file, we’re deploying two services: </span><strong class="source-inline"><span class="koboSpan" id="kobo.826.1">wordpress01</span></strong><span class="koboSpan" id="kobo.827.1"> (WordPress content management system) and </span><strong class="source-inline"><span class="koboSpan" id="kobo.828.1">wordpress01-db</span></strong><span class="koboSpan" id="kobo.829.1"> (</span><span class="No-Break"><span class="koboSpan" id="kobo.830.1">MySQL database).</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer292">
<span class="koboSpan" id="kobo.831.1"><img alt="Figure 11.8 – Visual topology of an application and its database" src="image/B18349_11_008.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.832.1">Figure 11.8 – Visual topology of an application and its database</span></p>
<p><span class="koboSpan" id="kobo.833.1">In the </span><strong class="source-inline"><span class="koboSpan" id="kobo.834.1">wordpress01</span></strong><span class="koboSpan" id="kobo.835.1"> service, we can easily reference the database host by the name label assigned to the service of the database – this is all thanks to the awesome name resolution capabilities supported by Podman </span><strong class="source-inline"><span class="koboSpan" id="kobo.836.1">dns</span></strong><span class="koboSpan" id="kobo.837.1"> plugins. </span><span class="koboSpan" id="kobo.837.2">You’ll also see that we are leveraging a health check on the </span><strong class="source-inline"><span class="koboSpan" id="kobo.838.1">wordpress01-db</span></strong><span class="koboSpan" id="kobo.839.1"> service so that it doesn’t become healthy until </span><strong class="source-inline"><span class="koboSpan" id="kobo.840.1">mysqladmin</span></strong><span class="koboSpan" id="kobo.841.1"> is able to get a response from pinging the database service, and </span><strong class="source-inline"><span class="koboSpan" id="kobo.842.1">wordpress01</span></strong><span class="koboSpan" id="kobo.843.1"> is configured with </span><strong class="source-inline"><span class="koboSpan" id="kobo.844.1">depends_on</span></strong><span class="koboSpan" id="kobo.845.1"> so that it will not try to start until </span><strong class="source-inline"><span class="koboSpan" id="kobo.846.1">wordpress01-db</span></strong><span class="koboSpan" id="kobo.847.1"> is in a healthy state. </span><span class="koboSpan" id="kobo.847.2">Since this example is intended to be a quick proof-of-concept deployment, I chose to use a named volume rather than a bind mount for the data, but you can also see the use of a bind mount for the initialization scripts. </span><span class="koboSpan" id="kobo.847.3">Last but not least, notice that we’re using a dedicated database container (</span><strong class="source-inline"><span class="koboSpan" id="kobo.848.1">wordpress01-db</span></strong><span class="koboSpan" id="kobo.849.1">) that is complementary to the application container (</span><strong class="source-inline"><span class="koboSpan" id="kobo.850.1">wordpress01</span></strong><span class="koboSpan" id="kobo.851.1">). </span><span class="koboSpan" id="kobo.851.2">The contents of the Compose file for this WordPress website might look something </span><span class="No-Break"><span class="koboSpan" id="kobo.852.1">like this:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer293">
<span class="koboSpan" id="kobo.853.1"><img alt="Figure 11.9 – Compose file for WordPress" src="image/B18349_11_009.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.854.1">Figure 11.9 – Compose file for WordPress</span></p>
<p><span class="koboSpan" id="kobo.855.1">Go ahead</span><a id="_idIndexMarker1055"/><span class="koboSpan" id="kobo.856.1"> and try to deploy this setup for yourself. </span><span class="koboSpan" id="kobo.856.2">You can view</span><a id="_idIndexMarker1056"/><span class="koboSpan" id="kobo.857.1"> the logs of the application with </span><strong class="source-inline"><span class="koboSpan" id="kobo.858.1">podman logs -f wordpress01</span></strong><span class="koboSpan" id="kobo.859.1"> to see that it connects to the database successfully on the first attempt. </span><span class="koboSpan" id="kobo.859.2">Let’s use Docker Compose to create and start the containers. </span><span class="koboSpan" id="kobo.859.3">You can do that just as we described in the earlier recipe on Docker Compose, by navigating to the directory where your </span><strong class="source-inline"><span class="koboSpan" id="kobo.860.1">docker-compose.yml</span></strong><span class="koboSpan" id="kobo.861.1"> file lives and running the </span><span class="No-Break"><span class="koboSpan" id="kobo.862.1">following command:</span></span></p>
<pre class="console"><span class="koboSpan" id="kobo.863.1">
docker-compose up -d</span></pre> <h1 id="_idParaDest-254"><a id="_idTextAnchor341"/><span class="koboSpan" id="kobo.864.1">Buildah and Skopeo – Podman’s friends with benefits</span></h1>
<p><span class="koboSpan" id="kobo.865.1">The title of this chapter mentions </span><em class="italic"><span class="koboSpan" id="kobo.866.1">Podman and Friends</span></em><span class="koboSpan" id="kobo.867.1">. </span><span class="koboSpan" id="kobo.867.2">Well, up until this point, you have probably noticed we didn’t talk much about Podman’s friends. </span><span class="koboSpan" id="kobo.867.3">Podman brings along a couple of companions to facilitate all your container management needs. </span><span class="koboSpan" id="kobo.867.4">These buddies of Podman are otherwise known as Buildah </span><span class="No-Break"><span class="koboSpan" id="kobo.868.1">and Skopeo.</span></span></p>
<p><span class="koboSpan" id="kobo.869.1">Where Podman is primarily focused on running containers, Buildah focuses on building them, and Skopeo</span><a id="_idIndexMarker1057"/><span class="koboSpan" id="kobo.870.1"> focuses on handling images and transferring them to/from remote </span><span class="No-Break"><span class="koboSpan" id="kobo.871.1">container registries.</span></span></p>
<h2 id="_idParaDest-255"><a id="_idTextAnchor342"/><span class="koboSpan" id="kobo.872.1">Getting ready</span></h2>
<p><span class="koboSpan" id="kobo.873.1">We will require </span><span class="No-Break"><span class="koboSpan" id="kobo.874.1">the following:</span></span></p>
<ul>
<li><span class="No-Break"><span class="koboSpan" id="kobo.875.1">Oracle Linux</span></span></li>
<li><span class="No-Break"><span class="koboSpan" id="kobo.876.1">Podman</span></span></li>
<li><span class="No-Break"><span class="koboSpan" id="kobo.877.1">Buildah</span></span></li>
<li><span class="No-Break"><span class="koboSpan" id="kobo.878.1">Skopeo</span></span></li>
</ul>
<h2 id="_idParaDest-256"><a id="_idTextAnchor343"/><span class="koboSpan" id="kobo.879.1">How to do it…</span></h2>
<p><span class="koboSpan" id="kobo.880.1">In this recipe, we’ll explore the basic usage of Buildah and Skopeo to reveal how these two friends of Podman can enhance your experience and workflow when dealing </span><span class="No-Break"><span class="koboSpan" id="kobo.881.1">with containers.</span></span></p>
<h3><span class="koboSpan" id="kobo.882.1">Building container images with Buildah</span></h3>
<p><span class="koboSpan" id="kobo.883.1">While Podman </span><a id="_idIndexMarker1058"/><span class="koboSpan" id="kobo.884.1">can be used for basic container image builds, Buildah is a utility that is fully focused on building OCI-compliant images. </span><span class="koboSpan" id="kobo.884.2">Not </span><a id="_idIndexMarker1059"/><span class="koboSpan" id="kobo.885.1">only can Buildah be used to build images from a Containerfile or Dockerfile, but it can also very neatly change existing </span><span class="No-Break"><span class="koboSpan" id="kobo.886.1">container images.</span></span></p>
<p><span class="koboSpan" id="kobo.887.1">First things first, let’s see how Buildah can be used to build images from a Containerfile. </span><span class="koboSpan" id="kobo.887.2">With Podman, we build images using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.888.1">podman build -t &lt;image_name&gt;.</span></strong><span class="koboSpan" id="kobo.889.1"> command. </span><span class="koboSpan" id="kobo.889.2">When we call on Podman to perform a build, it is actually using a subset of Buildah’s functionality to build the image. </span><span class="koboSpan" id="kobo.889.3">To use Buildah directly, we only need to use a slightly different command. </span><span class="koboSpan" id="kobo.889.4">For example, let’s say we have a file named </span><strong class="source-inline"><span class="koboSpan" id="kobo.890.1">Containerfile</span></strong><span class="koboSpan" id="kobo.891.1"> with the </span><span class="No-Break"><span class="koboSpan" id="kobo.892.1">following content:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.893.1">
FROM oraclelinux:8
RUN dnf install -y rhn-setup yum-utils &amp;&amp; dnf clean all
ENTRYPOINT ["/bin/bash"]</span></pre> <p><span class="koboSpan" id="kobo.894.1">In order to</span><a id="_idIndexMarker1060"/><span class="koboSpan" id="kobo.895.1"> build it with Buildah. </span><span class="koboSpan" id="kobo.895.2">You’ll enter </span><strong class="source-inline"><span class="koboSpan" id="kobo.896.1">buildah bud -t &lt;image_name&gt;</span></strong><span class="koboSpan" id="kobo.897.1">. </span><span class="koboSpan" id="kobo.897.2">In this example, I’m going to name the image </span><strong class="source-inline"><span class="koboSpan" id="kobo.898.1">ol-repo-sync</span></strong><span class="koboSpan" id="kobo.899.1">. </span><span class="koboSpan" id="kobo.899.2">Let’s do </span><span class="No-Break"><span class="koboSpan" id="kobo.900.1">this now:</span></span></p>
<pre class="console"><span class="koboSpan" id="kobo.901.1">
buildah bud -t ol-repo-sync .</span></pre> <p><span class="koboSpan" id="kobo.902.1">The results in this </span><a id="_idIndexMarker1061"/><span class="koboSpan" id="kobo.903.1">scenario are the same as if you were to do this with Podman. </span><span class="koboSpan" id="kobo.903.2">Where Buildah really shines, is its ability to make changes to working containers, and it can also create new images from </span><span class="No-Break"><span class="koboSpan" id="kobo.904.1">working containers.</span></span></p>
<p><span class="koboSpan" id="kobo.905.1">In order to keep things simple for this recipe, we’re going to replicate what was specified in </span><strong class="source-inline"><span class="koboSpan" id="kobo.906.1">Containerfile</span></strong><span class="koboSpan" id="kobo.907.1">, except instead of using </span><strong class="source-inline"><span class="koboSpan" id="kobo.908.1">Containerfile</span></strong><span class="koboSpan" id="kobo.909.1"> directly, we’re going to do things ad hoc with Buildah. </span><span class="koboSpan" id="kobo.909.2">So let’s make some changes to a pre-existing Oracle Linux 8 image and store it as a new image. </span><span class="koboSpan" id="kobo.909.3">First, we’re going to run </span><strong class="source-inline"><span class="koboSpan" id="kobo.910.1">buildah from</span></strong><span class="koboSpan" id="kobo.911.1"> to load up a working container </span><span class="No-Break"><span class="koboSpan" id="kobo.912.1">in Buildah:</span></span></p>
<pre class="console"><span class="koboSpan" id="kobo.913.1">
buildah from oraclelinux:8</span></pre> <p><span class="koboSpan" id="kobo.914.1">That’s going to return the </span><span class="No-Break"><span class="koboSpan" id="kobo.915.1">following output:</span></span></p>
<pre class="console"><span class="koboSpan" id="kobo.916.1">
oraclelinux-working-container</span></pre> <p><span class="koboSpan" id="kobo.917.1">This tells us the name of the newly created working container. </span><span class="koboSpan" id="kobo.917.2">Now that we have a Buildah container ready to work with, let’s add some packages to it. </span><span class="koboSpan" id="kobo.917.3">In this example, we’re going to add the same packages that </span><strong class="source-inline"><span class="koboSpan" id="kobo.918.1">Containerfile</span></strong><span class="koboSpan" id="kobo.919.1"> specified earlier. </span><span class="koboSpan" id="kobo.919.2">Enter the </span><span class="No-Break"><span class="koboSpan" id="kobo.920.1">following commands:</span></span></p>
<pre class="console"><span class="koboSpan" id="kobo.921.1">
buildah run oraclelinux-working-container dnf -y install rhn-setup yum-utils
buildah run oraclelinux-working-container dnf clean all</span></pre> <p><span class="koboSpan" id="kobo.922.1">You will see the DNF package manager do its thing, and afterward, you will be left with an Oracle Linux base image plus the new packages we installed as a result of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.923.1">buildah </span></strong><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.924.1">run</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.925.1"> command.</span></span></p>
<p><span class="koboSpan" id="kobo.926.1">Finally, we need to define the </span><strong class="source-inline"><span class="koboSpan" id="kobo.927.1">entrypoint</span></strong><span class="koboSpan" id="kobo.928.1"> into this container. </span><span class="koboSpan" id="kobo.928.2">We can do this by leveraging the </span><strong class="source-inline"><span class="koboSpan" id="kobo.929.1">buildah </span></strong><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.930.1">config</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.931.1"> command:</span></span></p>
<pre class="console"><span class="koboSpan" id="kobo.932.1">
buildah config --cmd '' oraclelinux-working-container
buildah config --entrypoint '["/bin/bash"]' oraclelinux-working-container</span></pre> <p class="callout-heading"><span class="koboSpan" id="kobo.933.1">Note</span></p>
<p class="callout"><span class="koboSpan" id="kobo.934.1">At the time of writing, there appears to be a bug in Buildah that populates the </span><strong class="source-inline"><span class="koboSpan" id="kobo.935.1">cmd</span></strong><span class="koboSpan" id="kobo.936.1"> value unless we explicitly give it an empty value first. </span><span class="koboSpan" id="kobo.936.2">This can lead to unexpected behavior of the resulting image. </span><span class="koboSpan" id="kobo.936.3">According to the documentation for Buildah, setting </span><strong class="source-inline"><span class="koboSpan" id="kobo.937.1">entrypoint</span></strong><span class="koboSpan" id="kobo.938.1"> without defining a value for </span><strong class="source-inline"><span class="koboSpan" id="kobo.939.1">cmd</span></strong><span class="koboSpan" id="kobo.940.1"> should clear out any assigned value for </span><strong class="source-inline"><span class="koboSpan" id="kobo.941.1">cmd</span></strong><span class="koboSpan" id="kobo.942.1">, but that was not the case in my testing of Buildah version </span><strong class="source-inline"><span class="koboSpan" id="kobo.943.1">1.29.1</span></strong><span class="koboSpan" id="kobo.944.1">. </span><span class="koboSpan" id="kobo.944.2">To circumvent this, I found it best to explicitly set </span><strong class="source-inline"><span class="koboSpan" id="kobo.945.1">cmd</span></strong><span class="koboSpan" id="kobo.946.1"> to an empty value before defining the entry point for </span><span class="No-Break"><span class="koboSpan" id="kobo.947.1">the image.</span></span></p>
<p><span class="koboSpan" id="kobo.948.1">In order to </span><a id="_idIndexMarker1062"/><span class="koboSpan" id="kobo.949.1">create a new image from this working container, all we need to do is run the </span><strong class="source-inline"><span class="koboSpan" id="kobo.950.1">buildah commit</span></strong><span class="koboSpan" id="kobo.951.1"> command. </span><span class="koboSpan" id="kobo.951.2">In this example, we’re </span><a id="_idIndexMarker1063"/><span class="koboSpan" id="kobo.952.1">going to</span><a id="_idTextAnchor344"/><span class="koboSpan" id="kobo.953.1"> name it </span><strong class="source-inline"><span class="koboSpan" id="kobo.954.1">ol-rep</span><a id="_idTextAnchor345"/><span class="koboSpan" id="kobo.955.1">o-sync-buildah</span></strong><span class="koboSpan" id="kobo.956.1"> so we can compare it with the image built from the </span><span class="No-Break"><span class="koboSpan" id="kobo.957.1">aforementioned </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.958.1">Containerfile</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.959.1">:</span></span></p>
<pre class="console"><span class="koboSpan" id="kobo.960.1">
buildah commit --rm oraclelinux-working-container ol-repo-sync-buildah</span></pre> <p><span class="koboSpan" id="kobo.961.1">Now that we’ve created the image using Buildah, we can run </span><strong class="source-inline"><span class="koboSpan" id="kobo.962.1">podman inspect</span></strong><span class="koboSpan" id="kobo.963.1"> against both </span><strong class="source-inline"><span class="koboSpan" id="kobo.964.1">ol-repo-sync</span></strong><span class="koboSpan" id="kobo.965.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.966.1">ol-repo-sync-buildah</span></strong><span class="koboSpan" id="kobo.967.1"> and we’ll see that the two are more or less identical. </span><span class="koboSpan" id="kobo.967.2">Also, take note of the size of the two images. </span><span class="koboSpan" id="kobo.967.3">We can check that by using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.968.1">buildah </span></strong><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.969.1">images</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.970.1"> command:</span></span></p>
<pre class="console"><span class="koboSpan" id="kobo.971.1">
$ buildah images</span></pre> <p><span class="koboSpan" id="kobo.972.1">The output will look something </span><span class="No-Break"><span class="koboSpan" id="kobo.973.1">like this:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer294">
<span class="koboSpan" id="kobo.974.1"><img alt="Figure 11.10 – Listing of Buildah images" src="image/B18349_11_010.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.975.1">Figure 11.10 – Listing of Buildah images</span></p>
<p><span class="koboSpan" id="kobo.976.1">This time around, we</span><a id="_idIndexMarker1064"/><span class="koboSpan" id="kobo.977.1"> can see that the size is a bit smaller because we leveraged the DNF package manager from the host system to install packages in the container via the </span><strong class="source-inline"><span class="koboSpan" id="kobo.978.1">buildah mount</span></strong><span class="koboSpan" id="kobo.979.1"> command. </span><span class="koboSpan" id="kobo.979.2">This is obviously not a huge difference in size, but it begins to show the benefits that Buildah brings to the table </span><span class="No-Break"><span class="koboSpan" id="kobo.980.1">with containers.</span></span></p>
<p><span class="koboSpan" id="kobo.981.1">As you can see, Buildah</span><a id="_idIndexMarker1065"/><span class="koboSpan" id="kobo.982.1"> grants us fine-tuned control of our container images and it can be a very powerful ally because it allows us to temporarily mount files and packages from the host system in the container to perform actions without ever actually installing said files and packages in the container. </span><span class="koboSpan" id="kobo.982.2">Ultimately, you’re able to achieve a leaner container image. </span><span class="koboSpan" id="kobo.982.3">Furthermore, Buildah provides the ability to script out your container image builds as it’s all done from the command line. </span><span class="koboSpan" id="kobo.982.4">This can prove to be very powerful when combined with things such as automation and/or CI/CD pipelines. </span><span class="koboSpan" id="kobo.982.5">It may take some time to get the hang of building your container images with Buildah, but the results can be rewarding if you stick </span><span class="No-Break"><span class="koboSpan" id="kobo.983.1">with it.</span></span></p>
<h3><span class="koboSpan" id="kobo.984.1">Inspecting remote images using Skopeo</span></h3>
<p><span class="koboSpan" id="kobo.985.1">Do you</span><a id="_idIndexMarker1066"/><span class="koboSpan" id="kobo.986.1"> remember when we talked about the need to pull an image before </span><a id="_idIndexMarker1067"/><span class="koboSpan" id="kobo.987.1">you can inspect it? </span><span class="koboSpan" id="kobo.987.2">This was covered in the </span><em class="italic"><span class="koboSpan" id="kobo.988.1">Creating handy-dandy utility containers</span></em><span class="koboSpan" id="kobo.989.1"> recipe. </span><span class="koboSpan" id="kobo.989.2">Well, what if I told you that we can leverage Skopeo to inspect images that are in remote repositories without needing to first pull them to our local machine? </span><span class="koboSpan" id="kobo.989.3">That is exactly what we’re going to </span><span class="No-Break"><span class="koboSpan" id="kobo.990.1">do here.</span></span></p>
<p><span class="koboSpan" id="kobo.991.1">In the </span><em class="italic"><span class="koboSpan" id="kobo.992.1">Creating handy-dandy utility containers</span></em><span class="koboSpan" id="kobo.993.1"> recipe, you were instructed to run </span><span class="No-Break"><span class="koboSpan" id="kobo.994.1">the following:</span></span></p>
<pre class="console"><span class="koboSpan" id="kobo.995.1">
podman pull docker.io/pandoc/core
podman image inspect pandoc/core | podman run -i --rm stedolan/jq -r '.[].Config.Entrypoint[]'</span></pre> <p><span class="koboSpan" id="kobo.996.1">That’s because if you tried to run </span><strong class="source-inline"><span class="koboSpan" id="kobo.997.1">podman image inspect</span></strong><span class="koboSpan" id="kobo.998.1"> without first pulling the container to your local machine, you would see the </span><span class="No-Break"><span class="koboSpan" id="kobo.999.1">following error:</span></span></p>
<p><strong class="source-inline"><span class="koboSpan" id="kobo.1000.1">Error: inspecting object: pandoc/core: image not known</span></strong><span class="koboSpan" id="kobo.1001.1">Skopeo allows us to work directly with container images living in remote repositories. </span><span class="koboSpan" id="kobo.1001.2">To illustrate how this works, let’s first get rid of our local </span><strong class="source-inline"><span class="koboSpan" id="kobo.1002.1">pandoc/core</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.1003.1">container image:</span></span></p>
<pre class="console"><span class="koboSpan" id="kobo.1004.1">
podman image rm pandoc/core</span></pre> <p><span class="koboSpan" id="kobo.1005.1">Now that the image is removed from our local machine, let’s use Skopeo to inspect the image directly from its </span><span class="No-Break"><span class="koboSpan" id="kobo.1006.1">remote repository:</span></span></p>
<pre class="console"><span class="koboSpan" id="kobo.1007.1">
skopeo inspect --config docker://docker.io/pandoc/core:latest | podman run -i --rm stedolan/jq -r '.config.Entrypoint[]'</span></pre> <p><span class="koboSpan" id="kobo.1008.1">Pretty nifty, right? </span><span class="koboSpan" id="kobo.1008.2">I did</span><a id="_idIndexMarker1068"/><span class="koboSpan" id="kobo.1009.1"> notice there were some minor </span><a id="_idIndexMarker1069"/><span class="koboSpan" id="kobo.1010.1">changes to the JSON paths that affected how I needed to structure my </span><strong class="source-inline"><span class="koboSpan" id="kobo.1011.1">jq</span></strong><span class="koboSpan" id="kobo.1012.1"> command to properly extract the entry point I was looking for, but all in all, leveraging Skopeo to inspect remote images yields the same information that you would get if you first pulled it in with Podman. </span><span class="koboSpan" id="kobo.1012.2">I can definitely see advantages to using Skopeo, especially when working with larger images and/or when needing to inspect images in an automated </span><span class="No-Break"><span class="koboSpan" id="kobo.1013.1">CICD pipeline.</span></span></p>
<h3><span class="koboSpan" id="kobo.1014.1">Handling remote images with Skopeo</span></h3>
<p><span class="koboSpan" id="kobo.1015.1">Skopeo </span><a id="_idIndexMarker1070"/><span class="koboSpan" id="kobo.1016.1">can also be used to transfer container images</span><a id="_idIndexMarker1071"/><span class="koboSpan" id="kobo.1017.1"> from one remote container repository to another, without needing to pull/download it locally first. </span><span class="koboSpan" id="kobo.1017.2">The syntax is similar to the standard Linux </span><strong class="source-inline"><span class="koboSpan" id="kobo.1018.1">cp</span></strong><span class="koboSpan" id="kobo.1019.1"> command. </span><span class="koboSpan" id="kobo.1019.2">In </span><strong class="source-inline"><span class="koboSpan" id="kobo.1020.1">cp</span></strong><span class="koboSpan" id="kobo.1021.1">, we use </span><strong class="source-inline"><span class="koboSpan" id="kobo.1022.1">cp &lt;source&gt; &lt;destination&gt;</span></strong><span class="koboSpan" id="kobo.1023.1">, and with Skopeo we use </span><strong class="source-inline"><span class="koboSpan" id="kobo.1024.1">skopeo copy &lt;source&gt; &lt;destination&gt;</span></strong><span class="koboSpan" id="kobo.1025.1">. </span><span class="koboSpan" id="kobo.1025.2">As an example, if we want to copy the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1026.1">pandoc/core</span></strong><span class="koboSpan" id="kobo.1027.1"> image from one registry to another, all we need to do is </span><span class="No-Break"><span class="koboSpan" id="kobo.1028.1">run this:</span></span></p>
<pre class="console"><span class="koboSpan" id="kobo.1029.1">
skopeo copy docker://docker.io/pandoc/core:latest docker://example.com/pandoc/core:latest</span></pre> <p><span class="koboSpan" id="kobo.1030.1">Likewise, we can also transfer it to our local Podman container storage through the use of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1031.1">containers-storage</span></strong><span class="koboSpan" id="kobo.1032.1"> prefix, </span><span class="No-Break"><span class="koboSpan" id="kobo.1033.1">for example:</span></span></p>
<pre class="console"><span class="koboSpan" id="kobo.1034.1">
skopeo copy docker://docker.io/pandoc/core:latest containers-storage:pandoc/core:latest</span></pre> <p><span class="koboSpan" id="kobo.1035.1">Additionally, if we wanted to specify some other location, we could simply use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1036.1">dir</span></strong><span class="koboSpan" id="kobo.1037.1"> prefix followed by the path. </span><span class="koboSpan" id="kobo.1037.2">But in this case, be sure the path exists prior and omit any characters that are incompatible with the Linux filesystem, </span><span class="No-Break"><span class="koboSpan" id="kobo.1038.1">for example:</span></span></p>
<pre class="console"><span class="koboSpan" id="kobo.1039.1">
mkdir -p $(pwd)/pandoc/core
skopeo copy docker://docker.io/pandoc/core:latest dir:$(pwd)/pandoc/core</span></pre> <p><span class="koboSpan" id="kobo.1040.1">Lastly, Skopeo</span><a id="_idIndexMarker1072"/><span class="koboSpan" id="kobo.1041.1"> can also be used to delete images from remote repositories or from local container storage. </span><span class="koboSpan" id="kobo.1041.2">To</span><a id="_idIndexMarker1073"/><span class="koboSpan" id="kobo.1042.1"> do this, simply run </span><span class="No-Break"><span class="koboSpan" id="kobo.1043.1">the following:</span></span></p>
<pre class="console"><span class="koboSpan" id="kobo.1044.1">
skopeo delete containers-storage:pandoc/core:latest</span></pre> </div>
</body></html>