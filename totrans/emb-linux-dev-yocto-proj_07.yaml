- en: '7'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Assimilating Packaging Support
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter presents the key concepts for understanding the aspects of Poky
    and BitBake related to packaging. We will learn about the supported binary package
    formats, shared state cache, package versioning components, how to set up and
    use binary package feeds to support our development process, and more.
  prefs: []
  type: TYPE_NORMAL
- en: Using supported package formats
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: From a Yocto Project perspective, a recipe may generate one or more output packages.
    A package wraps a set of files and metadata in a way that makes them available
    in the future. They can be installed into one or more images or deployed for later
    use.
  prefs: []
  type: TYPE_NORMAL
- en: Packages are critical to Poky, as they enable the build system to produce diverse
    types of artifacts, such as images and toolchains.
  prefs: []
  type: TYPE_NORMAL
- en: List of supported package formats
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Currently, BitBake supports four different package formats:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Red Hat Package Manager** (**RPM**): Originally named Red Hat Package Manager
    but now known as the RPM package format since its adoption by several other Linux
    distributions, this is a popular format in use in Linux distributions such as
    SuSE, OpenSuSE, Red Hat, Fedora, and CentOS.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Debian Package Manager** (**DEB**): This is a widespread format used in Debian
    and several other Debian-based distributions – Ubuntu Linux and Linux Mint are
    the most widely known.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`opkg` package manager, which supports the IPK format, is used in several distributions
    such as OpenEmbedded Core, OpenWRT, and Poky.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`tarball` file type used to group several files into just a single file.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Choosing a package format
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The support for formats is provided using a set of classes (i.e., `package_rpm`,
    `package_deb`, and `package_ipk`). We can select one or more formats using the
    `PACKAGE_CLASSES` variable, as shown in the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.1 – The variable used to configure which package format to use](img/Figure_7.01_B19361.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7.1 – The variable used to configure which package format to use
  prefs: []
  type: TYPE_NORMAL
- en: You can configure one or more package formats – for example, in the `build/conf/local.conf`
    file.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs: []
  type: TYPE_NORMAL
- en: The first package format in `PACKAGE_CLASSES` is the one used for image generation.
  prefs: []
  type: TYPE_NORMAL
- en: Poky defaults to the RPM package format, which uses the DNF package manager.
    However, the format choice depends on several factors, such as package format-specific
    features, memory, and resource usage. OpenEmbedded Core defaults to the IPK and
    `opkg` as the package manager, as it offers a smaller memory and resource usage
    footprint.
  prefs: []
  type: TYPE_NORMAL
- en: On the other hand, users familiar with Debian-based systems may prefer to use
    the APT and DEB package formats for their products.
  prefs: []
  type: TYPE_NORMAL
- en: Running code during package installation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Packages can use scripts as part of their installation and removal process.
    The included scripts are defined as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`preinst`: This executes before unpacking the package. If the package has services,
    it must stop them for installation or upgrade.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`postinst`: After unpacking, this typically completes any required configuration
    of the package. Many `postinst` scripts execute any command necessary to start
    or restart a service after installation or upgrade.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`prerm`: It usually stops any daemon associated with a package before removing
    files associated with the package.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`postrm`: This commonly modifies links or other files created by the package.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `preinst` and `prerm` scripts target complex use cases, such as data migration
    when updating packages. In the Yocto Project case, `postinst` and `postrm` are
    also responsible for stopping and starting the `systemd` or `sysvinit` services.
    A default script is provided when we use the `systemd` and `update-rc.d` classes.
    It can be customized to include any particular case.
  prefs: []
  type: TYPE_NORMAL
- en: 'The post-package installation (`postinst`) scripts are run during the `root`
    filesystem creation. The package is marked as installed if the script returns
    a success value. To add a `postinst` script for a package, we can use the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.2 – An example of the pkg_postinst script](img/Figure_7.02_B19361.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7.2 – An example of the pkg_postinst script
  prefs: []
  type: TYPE_NORMAL
- en: 'Sometimes, we need to ensure that `postinst` runs inside the target device
    itself. This can be done using the `postinst_ontarget` variant, such as the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.3 – An example of the pkg_postinst_ontarget script](img/Figure_7.03_B19361.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7.3 – An example of the pkg_postinst_ontarget script
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs: []
  type: TYPE_NORMAL
- en: Instead of using the package name itself, we can use the `PN` variable, which
    automatically expands the package name of the recipe.
  prefs: []
  type: TYPE_NORMAL
- en: All post-installation scripts must succeed when we generate an image with `read-only-rootfs`
    in `IMAGE_FEATURES`. Because it is impossible to write in a read-only `rootfs`,
    the check must occur during build time. It ensures that we identify the problem
    while building the image, rather than during the initial boot operation in the
    target device. If there is a requirement to run any script inside the target device,
    the `do_rootfs` task fails.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs: []
  type: TYPE_NORMAL
- en: Eventually, using a whole image as read-only is not an option. For example,
    some projects may need to persist some data or even allow some applications to
    write to a volatile directory. Such use cases are outside the scope of this book.
    However, you might find some helpful information in the *Yocto Project Reference
    Manual* for the `overlayfs` ([https://docs.yoctoproject.org/4.0.4/ref-manual/classes.html#overlayfs-bbclass](https://docs.yoctoproject.org/4.0.4/ref-manual/classes.html#overlayfs-bbclass))
    and `overlayfs-etc` ([https://docs.yoctoproject.org/4.0.4/ref-manual/classes.html#overlayfs-etc-bbclass](https://docs.yoctoproject.org/4.0.4/ref-manual/classes.html#overlayfs-etc-bbclass))
    classes.
  prefs: []
  type: TYPE_NORMAL
- en: 'One common oversight when creating post-installation scripts is the lack of
    the `D` variable in front of absolute paths. `D` has two traits:'
  prefs: []
  type: TYPE_NORMAL
- en: During `rootfs` generation, `D` is set to the root of the working directory
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Inside the device, `D` is empty
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Consequently, this ensures that paths are valid in both host and target environments.
    For example, consider the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.4 – Sample source code using the D variable](img/Figure_7.04_B19361.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7.4 – Sample source code using the D variable
  prefs: []
  type: TYPE_NORMAL
- en: In the example in *Figure 7**.4*, the `touch` command uses the `D` variable,
    so it works generically depending on its value.
  prefs: []
  type: TYPE_NORMAL
- en: Another common mistake is attempting to run processes specific to or dependent
    on the target architecture. The easiest solution, in this case, is to postpone
    the script execution to the target (using `pkg_postinst_ontarget`). However, as
    mentioned before, this prevents the use of read-only filesystems.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding shared state cache
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The default behavior of Poky is to build everything from scratch unless BitBake
    determines that a recipe does not need to be rebuilt. The main advantage of building
    everything from scratch is that the result is fresh, and there is no risk of previous
    data causing problems. However, rebuilding everything requires computational time
    and resources.
  prefs: []
  type: TYPE_NORMAL
- en: The strategy to determine whether a recipe must be rebuilt is complex. BitBake
    tries to track as much information as possible about every task, variable, and
    piece of code used in the build process. BitBake then generates a checksum for
    the information used by every task, including dependencies from other tasks. In
    summary, BitBake recursively tracks used variables, task source code, and dependencies
    for the recipes and their dependencies.
  prefs: []
  type: TYPE_NORMAL
- en: Poky uses all this information provided by BitBake to store snapshots of those
    tasks as a set of packaged data, generated in a cache called the shared state
    cache (`sstate-cache`). This cache wraps the contents of each task output in packages
    stored in the `SSTATE_DIR` directory. Whenever BitBake prepares to run a task,
    it first checks the existence of a `sstate-cache` package that matches the required
    computed checksum. If the package is present, BitBake uses the prebuilt package.
  prefs: []
  type: TYPE_NORMAL
- en: The whole shared state mechanism encompasses quite complex code, and the previous
    explanation simplifies it. For a detailed description, it is advised that you
    go through the *Shared State Cache* section of the *Yocto Project Overview and
    Concepts* *Manual* ([https://docs.yoctoproject.org/4.0.4/overview-manual/concepts.html#shared-state-cache](https://docs.yoctoproject.org/4.0.4/overview-manual/concepts.html#shared-state-cache)).
  prefs: []
  type: TYPE_NORMAL
- en: 'When using Poky for several builds, we must remember that `sstate-cache` needs
    cleaning from time to time, since it keeps growing after every build. There is
    a straightforward way of cleaning it. Use the following command from the `poky`
    directory:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.5 – The command line to remove a duplicated Shared State Cache](img/Figure_7.05_B19361.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7.5 – The command line to remove a duplicated Shared State Cache
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs: []
  type: TYPE_NORMAL
- en: 'When we need to rebuild from scratch, we can do either of the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Remove `build/tmp` so that we can use `sstate-cache` to speed up the build
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Remove both `build/tmp` and `sstate-cache` so that no cache is reused during
    the build
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Explaining package versioning
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Package versioning is used to differentiate the same package in distinct stages
    of its life cycle. From Poky’s perspective, it is also used as part of the equation
    that generates the checksum used by BitBake to verify whether a task must be rebuilt.
  prefs: []
  type: TYPE_NORMAL
- en: 'The package version, also known as `PV`, plays a leading role when we select
    which recipe to build. The default behavior of Poky is always to prefer the newest
    recipe version unless there is a different explicit preference, as discussed in
    [*Chapter 5*](B19361_05.xhtml#_idTextAnchor077), *Grasping the BitBake Tool*.
    For example, let’s suppose that we have two versions of the `myrecipe` recipe:'
  prefs: []
  type: TYPE_NORMAL
- en: '`myrecipe_1.0.bb`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`myrecipe_1.1.bb`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: BitBake, by default, builds the recipe with version `1.1`. Inside the recipe,
    we may have other variables that compose package versioning with the `PV` variable.
    These are the `PE`, and the `PR`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Those variables normally follow this pattern:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.6 – A complete versioning pattern](img/Figure_7.06_B19361.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7.6 – A complete versioning pattern
  prefs: []
  type: TYPE_NORMAL
- en: The `PE` variable has a default value of zero. It is used when the package version
    schema is changed, breaking the possibility of usual ordering. `PE` is prepended
    in the package version, forcing a higher number when needed.
  prefs: []
  type: TYPE_NORMAL
- en: For example, suppose a package uses the date to compose `PV` variables such
    as `20220101`, and there is a version schema change to release the `1.0` version.
    It is impossible to determine whether version `1.0` is higher than version `20220101`.
    So, `PE = "1"` is used to change the recipe epoch, forcing version `1.0` to be
    higher than `20220101`, since `1:1.0` is greater than `0:20220101`.
  prefs: []
  type: TYPE_NORMAL
- en: The `PR` variable has a default value of `r0` and is a part of package versioning.
    When it is updated, it forces BitBake to rebuild all tasks of a specific recipe.
    We can update it manually in the recipe metadata to force a rebuild we know is
    needed. Still, it is fragile because it relies on human interaction and knowledge.
    BitBake uses task checksums to control what needs to be rebuilt. The manual `PR`
    increment is only used in rare cases when the task checksum does not change.
  prefs: []
  type: TYPE_NORMAL
- en: Specifying runtime package dependencies
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The results of most recipes are packages managed by the package manager. As
    we saw in the previous sections, it requires information about all those packages
    and how they relate. For example, a package may depend on or conflict with another.
  prefs: []
  type: TYPE_NORMAL
- en: Constraints exist within multiple package relationships; however, those constraints
    are package format-specific, so BitBake has specific metadata to abstract those
    constraints.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is a list of the most used package runtime constraints:'
  prefs: []
  type: TYPE_NORMAL
- en: '`RDEPENDS`: The list of packages must be available at runtime, along with the
    package that defines it.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`RPROVIDES`: This is the list of symbolic names a package provides. By default,
    a package always includes the package name as a symbolic name. It can also include
    alternative symbolic names provided by that package.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`RCONFLICTS`: This is the list of packages known to conflict with the package.
    The final image must not include conflicting packages.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`RREPLACES`: This is a list of symbolic names that the package can replace.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'A full recipe, from `meta/recipes-devtools/python/python3-dbus_1.2.18.bb`,
    is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.7 – An example of how to use RDEPENDS](img/Figure_7.07_B19361.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7.7 – An example of how to use RDEPENDS
  prefs: []
  type: TYPE_NORMAL
- en: The recipe from *Figure 7**.6* shows that the `python3-dbus` package has a list
    of runtime dependencies on several Python modules, on line 21.
  prefs: []
  type: TYPE_NORMAL
- en: Using packages to generate a rootfs image
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'One of the most common uses of Poky is the `rootfs` image generation. The `rootfs`
    image should be seen as a ready-to-use root filesystem for a target. The image
    can be composed of one or more filesystems. It may include other artifacts available
    during its generation, such as the Linux kernel, the device tree, and bootloader
    binaries. The process of generating the image is composed of several steps. Its
    most common uses are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Generating the `rootfs` directory
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Creating the required files
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Wrapping the final filesystem according to the specific requirements (it may
    be a disk file with several partitions and contents)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Finally, compressing it, if applicable
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The sub-tasks of `do_rootfs` perform all these steps. `rootfs` is a directory
    with the desired packages installed, with the required tweaks applied afterward.
    The tweaks make minor adjustments to the `rootfs` contents – for example, when
    building a development image, `rootfs` is adjusted to allow us to log in as `root`
    without a password.
  prefs: []
  type: TYPE_NORMAL
- en: The list of packages to be installed into `rootfs` is defined by a union of
    packages listed by `IMAGE_INSTALL` and the packages included with `IMAGE_FEATURES`;
    image customization is detailed in [*Chapter 12*](B19361_12.xhtml#_idTextAnchor147),
    *Creating Custom Layers*. Each image feature can include extra packages for installation
    – for example, `dev-pkgs`, which installs development libraries and headers of
    all packages listed to be installed in `rootfs`.
  prefs: []
  type: TYPE_NORMAL
- en: The list of packages to be installed is now filtered by the `PACKAGE_EXCLUDE`
    variable, which lists the packages that should not be installed. The packages
    listed in `PACKAGE_EXCLUDE` are only excluded from the list of packages to be
    explicitly installed.
  prefs: []
  type: TYPE_NORMAL
- en: With the final set of packages to install, the `do_rootfs` task can initiate
    the process of unpacking and configuring each package, and its required dependencies,
    into the `rootfs` directory. The `rootfs` generation uses the local package feed,
    which we will cover in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: With the `rootfs` contents unpacked, the non-target post-installation scripts
    of the referred packages must run to avoid the penalty of running them during
    the first boot.
  prefs: []
  type: TYPE_NORMAL
- en: Now, the directory is ready to generate the filesystem. `IMAGE_FSTYPES` lists
    the filesystem to be generated – for example, **EXT4** or **UBIFS**.
  prefs: []
  type: TYPE_NORMAL
- en: After the `do_rootfs` task has finished, the generated image file is placed
    in `build/tmp/deploy/image/<machine>/`. The process of creating our image and
    the possible values for `IMAGE_FEATURES` and `IMAGE_FSTYPES` are described in
    [*Chapter 12*](B19361_12.xhtml#_idTextAnchor147), *Creating* *Custom Layers*.
  prefs: []
  type: TYPE_NORMAL
- en: Package feeds
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As discussed in [*Chapter 5*](B19361_05.xhtml#_idTextAnchor077), *Grasping the
    BitBake Tool*, packages play a vital role, as images and `do_rootfs` uses a local
    repository to fetch binary packages when generating those artifacts. This repository
    is known as a package feed.
  prefs: []
  type: TYPE_NORMAL
- en: 'There is no reason for this repository to be used just for the images or SDK
    build steps. Several valid reasons exist for making this repository remotely accessible,
    either internally in our development environment or publicly. Some of these reasons
    are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: You can easily test an updated application during the development stage, without
    requiring a complete system re-installation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can make additional packages more flexible so that they can be installed
    in a running image
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can update products in the field
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To produce a solid package feed, we must ensure that we have consistent increments
    in the package revision every time the package is changed. It is almost impossible
    to do this manually, and the Yocto Project has a `PR` service specifically designed
    to help with this.
  prefs: []
  type: TYPE_NORMAL
- en: The `PR` without human interaction every time BitBake detects a checksum change
    in a task. It injects a suffix in `PR` in the `${PR}.X` format. For example, if
    we have `PR = "r34"` after subsequent `PR` service interactions, the `PR` value
    becomes `r34.1`, `r34.2`, `r34.3`, and so on. The use of the `PR` service is critical
    for solid package feeds, as it requires the version to increase linearly.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs: []
  type: TYPE_NORMAL
- en: Even though we ought to use the `PR` service to have solid package versioning,
    it does not preclude the need to set `PR` manually in exceptional cases.
  prefs: []
  type: TYPE_NORMAL
- en: 'By default, the `PR` service is not enabled or running. We can enable it to
    run locally by adding the `PRSERV_HOST` variable in the BitBake configuration
    – for example, in `build/conf/local.conf`, as in the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.8 – How to configure a PR service to run locally](img/Figure_7.08_B19361.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7.8 – How to configure a PR service to run locally
  prefs: []
  type: TYPE_NORMAL
- en: This approach is adequate when the build happens on a single computer, which
    builds every package of the package feed. BitBake starts and stops the server
    at each build and automatically increases the required `PR` values.
  prefs: []
  type: TYPE_NORMAL
- en: 'For a more complex setup, with multiple computers working against a shared
    package feed, we must have a single `PR` service running, used by all building
    systems associated with the package feed. In this case, we need to start the `PR`
    service in the server using the `bitbake-prserv` command, shown as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.9 – The command line to initiate the PR service server](img/Figure_7.09_B19361.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7.9 – The command line to initiate the PR service server
  prefs: []
  type: TYPE_NORMAL
- en: In addition to manually-starting the service, we need to update the BitBake
    configuration file (for example, `build/conf/local.conf`) of each build system,
    which connects to a server using the `PRSERV_HOST` variable, as described earlier,
    so that each system points to the server `IP` and `port`.
  prefs: []
  type: TYPE_NORMAL
- en: Using package feeds
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To use package feeds, the following two components are required:'
  prefs: []
  type: TYPE_NORMAL
- en: The server provides access to the packages
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The client accesses the server and downloads the required packages
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The set of packages offered by the package feed is determined by the recipes
    we build. We can build one or more recipes and offer them, or build a set of images
    to generate the desired packages. Once satisfied with the packages offered, we
    must create the package index provided by the package feeds. The following command
    performs this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.10 – The command line to create the package index](img/Figure_7.10_B19361.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7.10 – The command line to create the package index
  prefs: []
  type: TYPE_NORMAL
- en: The packages are available inside the `build/tmp/deploy` directory. We must
    choose the respective sub-directory depending on the package format chosen. Poky
    uses RPM by default, so we must serve the content of the `build/tmp/deploy/rpm`
    directory.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs: []
  type: TYPE_NORMAL
- en: Make sure to run `bitbake package-index` after building all packages; otherwise,
    the package index will not include them.
  prefs: []
  type: TYPE_NORMAL
- en: 'The package index and packages must be made available through a transfer protocol
    such as HTTP. We can use any server we wish for this task, such as Apache, Nginx,
    and Lighttpd. A convenient way to make the packages available through HTTP for
    local development is by using the Python simple HTTP server, shown as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.11 – How to provide the package feed by using the Python simple
    HTTP server](img/Figure_7.11_B19361.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7.11 – How to provide the package feed by using the Python simple HTTP
    server
  prefs: []
  type: TYPE_NORMAL
- en: 'To add support for package management to the image, we have a couple of changes
    to make. We need to add `package-management` in `EXTRA_IMAGE_FEATURES` and set
    the URI for package fetching on `PACKAGE_FEED_URIS`. For example, we can add this
    to our `build/conf/local.conf`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.12 – How to configure a remote package feed](img/Figure_7.12_B19361.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7.12 – How to configure a remote package feed
  prefs: []
  type: TYPE_NORMAL
- en: We will detail the `IMAGE_FEATURES` and `EXTRA_IMAGE_FEATURES` variables in
    [*Chapter 12*](B19361_12.xhtml#_idTextAnchor147), *Creating Custom Layers*. If
    we want a small image with no package management support, we should omit `package-management`
    from `EXTRA_IMAGE_FEATURES`.
  prefs: []
  type: TYPE_NORMAL
- en: The `PACKAGE_FEED_URIS` and `EXTRA_IMAGE_FEATURES` configurations guarantee
    that the image on the client side can access the server and has the utilities
    needed to install, remove, and upgrade its packages. After these steps, we can
    use the runtwime package management in the target device.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, if we choose the RPM package format for the image, we can fetch
    the repository information using the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.13 – Command line to fetch the package feed repository](img/Figure_7.13_B19361.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7.13 – Command line to fetch the package feed repository
  prefs: []
  type: TYPE_NORMAL
- en: Use the `dnf search <package>`, and `dnf install <package>` commands to find
    and install packages from the repositories.
  prefs: []
  type: TYPE_NORMAL
- en: 'Depending on the package format chosen, the commands for the target to update
    the package index, search for, and install a package are different. See the available
    command lines for each package format in the following table:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Package format** | **RPM** | **IPK** | **DEB** |'
  prefs: []
  type: TYPE_TB
- en: '| Update the package index | `dnf check-updates` | `opkg update` | `apt-get
    update` |'
  prefs: []
  type: TYPE_TB
- en: '| Search for a package | `dnf search``<``package>` | `opkg search``<``package>`
    | `apt-cache search``<``package>` |'
  prefs: []
  type: TYPE_TB
- en: '| Install a package | `dnf install``<``package>` | `opkg install``<``package>`
    | `apt-get install``<``package>` |'
  prefs: []
  type: TYPE_TB
- en: '| System upgrade | `dnf upgrade` | `opkg upgrade` | `apt-get` `dist- upgrade`
    |'
  prefs: []
  type: TYPE_TB
- en: Table 7.1 – A package management command comparison
  prefs: []
  type: TYPE_NORMAL
- en: The use of package feeds are great to use in a local development phase because
    they enable us to install packages in an already deployed image.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: The use of package feeds for system upgrades in the field requires a huge test
    effort to guarantee that a system does not fall into a broken state. The testing
    effort is enormous to verify all different upgrade scenarios. Usually, full image
    upgrades are safer for production use.
  prefs: []
  type: TYPE_NORMAL
- en: The management of a package feed is much more complex. It involves several other
    aspects, such as package dependency chains and different upgrade scenarios. Creating
    a complex package feed external server is out of this book’s scope, so please
    refer to the Yocto Project documentation for further details.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter presented the basic concepts of packaging, which has a significant
    role in Poky and BitBake (package versioning), and how this impacts Poky’s behavior
    when rebuilding packages and package feeds. It also showed us how to configure
    an image to be updated using prebuilt packages provided by a remote server.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will learn about the BitBake metadata syntax and its
    operators and how to append, prepend, and remove content from variables, variable
    expansions, and so on. We will then be able to better understand the language
    used in Yocto Project engines.
  prefs: []
  type: TYPE_NORMAL
