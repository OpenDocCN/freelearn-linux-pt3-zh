<html><head></head><body>
<div id="sbo-rt-content"><div class="Basic-Text-Frame" id="_idContainer160">
<h1 class="chapterNumber">14</h1>
<h1 class="chapterTitle" id="_idParaDest-186">Serving Web Content</h1>
<p class="normal">The flexible nature of Ubuntu Server makes it an amazing platform on which to host your organization’s web presence. In this chapter, we’ll take a look at Apache and NGINX, which make up the leading web server software on the internet. We’ll go through installing, configuring, and <a id="_idIndexMarker736"/>extending both, as well as securing them with <strong class="keyWord">Transport Layer Security (TLS)</strong>. In addition, we’ll also take a look at installing Nextcloud, which is a great solution for setting up your very own cloud environment for your organization to use for collaboration and sharing files. As we work through concepts related to hosting web content on Ubuntu Server, we will cover:</p>
<ul>
<li class="bulletList">Installing and configuring Apache</li>
<li class="bulletList">Installing additional Apache modules</li>
<li class="bulletList">Securing Apache with TLS</li>
<li class="bulletList">Installing and configuring NGINX</li>
<li class="bulletList">Setting up and configuring Nextcloud</li>
</ul>
<p class="normal">To get us started, we’ll first look at configuring Apache, as well as some basic configuration.</p>
<h1 class="heading-1" id="_idParaDest-187">Installing and configuring Apache</h1>
<p class="normal">The best <a id="_idIndexMarker737"/>way to<a id="_idIndexMarker738"/> become familiar with any technology is to dive right in. We’ll begin this chapter by installing Apache. But first, what exactly is Apache? For those that aren’t already aware, Apache is a popular application that is typically run on Linux and Unix servers to serve web pages to users. It runs in the background, and serves HTML pages to those that request a URL that exists on your server.</p>
<p class="normal">Installing Apache is very easy; it’s simply a matter of installing the <code class="inlineCode">apache2</code> package:</p>
<pre class="programlisting con"><code class="hljs-con">sudo apt install apache2 
</code></pre>
<p class="normal">By default, Ubuntu will immediately start and enable the <code class="inlineCode">apache2</code> daemon as soon as its package is installed. You can confirm this yourself with the following command:</p>
<pre class="programlisting con"><code class="hljs-con">systemctl status apache2
</code></pre>
<p class="normal">In fact, at this point, you already have (for all intents and purposes) a fully functional web server. If you were to open a web browser and enter the IP address of the server you just <a id="_idIndexMarker739"/>installed<a id="_idIndexMarker740"/> Apache on, you should see Apache’s sample web page:</p>
<figure class="mediaobject"><img alt="" height="523" src="../Images/B18425_14_01.png" width="876"/></figure>
<p class="packt_figref">Figure 14.1: The default sample web page provided by Apache</p>
<p class="normal">There you go, you have officially served web content. All you needed to do was install the <code class="inlineCode">apache2</code> package, and your server was transformed into a web server. Chapter over, time to move on.</p>
<p class="normal">Of course, there’s more to Apache than simply installing it and having it present a sample web page. While you could certainly replace the content in the sample web page with your own and be all set when it comes to hosting content for your users, there’s much more to understand. For instance, there are several configuration files in the <code class="inlineCode">/etc/apache2</code> directory that govern how sites are hosted, as well as which directories Apache will look in to find web pages to host. Apache also features plugins, which we will go over as well.</p>
<p class="normal">The directory that Apache serves web pages from is<a id="_idIndexMarker741"/> known as the <strong class="keyWord">document root</strong>, with <code class="inlineCode">/var/www/html</code> being the default. Inside that directory, you’ll see an <code class="inlineCode">index.xhtml</code> file, which is actually the default page you see when you visit an unmodified Apache server. Essentially, this is a test page that is designed to show you that the server is working, as well as some tidbits of information regarding the default configuration.</p>
<p class="normal">You’re not limited to hosting just one website on a server, though. Apache supports the concept <a id="_idIndexMarker742"/>of a <strong class="keyWord">virtual host</strong>, which allows you to serve multiple websites from a single server. Each<a id="_idIndexMarker743"/> virtual <a id="_idIndexMarker744"/>host consists of an individual configuration file, which differentiates itself based on either name or IP address. </p>
<p class="normal">For example, you could have an Apache server with a single IP address that hosts two different websites, such as <code class="inlineCode">acmeconsulting.com</code> and <code class="inlineCode">acmesales.com</code>. These are hypothetical websites, but you get the idea. To set this up, you would create separate configuration files for <code class="inlineCode">acmeconsulting.com</code> and <code class="inlineCode">acmesales.com</code> and store them in your Apache configuration directory. Each configuration file would include a <code class="inlineCode">&lt;VirtualHost&gt;</code> stanza, where you would place an identifier such as a name or IP address that differentiates one from the other. When a request comes in, Apache will serve either <code class="inlineCode">acmeconsulting.com</code> or <code class="inlineCode">acmesales.com</code> to the user’s browser, depending on which criteria matched when the request came in. The configuration files for each site typically end with the <code class="inlineCode">.conf</code> filename extension and are stored in the <code class="inlineCode">/etc/apache2/sites-available</code> directory. We’ll go over all of this in more detail shortly, so don’t worry if you don’t understand this yet.</p>
<p class="normal">The basic workflow for setting up a new site (virtual host) will typically be similar to the following:</p>
<ul>
<li class="bulletList">The web developer creates the website and related files</li>
<li class="bulletList">These files are uploaded to Ubuntu Server, typically in a subdirectory of <code class="inlineCode">/var/www</code> or another directory the administrator has chosen</li>
<li class="bulletList">After adding the necessary files into the Document Root directory, the administrator will make sure that the <code class="inlineCode">www-data</code> user owns all of the files within (in the case of Apache)</li>
<li class="bulletList">The server administrator creates a configuration file for the site and copies it into the <code class="inlineCode">/etc/apache2/sites-available</code> directory</li>
<li class="bulletList">The administrator enables the site and reloads Apache</li>
</ul>
<p class="normal">Enabling virtual hosts is handled a bit differently in Debian and Ubuntu than on other platforms. In fact, there are two specific commands to handle this purpose: <code class="inlineCode">a2ensite</code> for enabling a site and <code class="inlineCode">a2dissite</code> for disabling a site. You won’t find these commands on distributions such as CentOS, for example. Configuration files for each site are stored in the <code class="inlineCode">/etc/apache2/sites-available/</code> directory, and we would use the <code class="inlineCode">a2ensite</code> command to enable each configuration. Assuming a site with the URL <a href="http://acmeconsulting.com"><span class="url">acmeconsulting.com</span></a> is to be hosted on our Ubuntu server, we would create the <code class="inlineCode">/etc/apache2/sites-available/acmeconsulting.com.conf</code> configuration file and enable the site with the following commands:</p>
<pre class="programlisting con"><code class="hljs-con">sudo a2ensite acmeconsulting.com.conf 
sudo systemctl reload apache2 
</code></pre>
<p class="normal">I’m not using<a id="_idIndexMarker745"/> absolute<a id="_idIndexMarker746"/> paths in my examples; as long as you’ve copied the configuration file to the correct place, the <code class="inlineCode">a2ensite</code> and <code class="inlineCode">a2dissite</code> commands will know where to find it.</p>
<p class="normal">If we wanted to disable the site for some reason, we would execute the <code class="inlineCode">a2dissite</code> command against the site’s configuration file:</p>
<pre class="programlisting con"><code class="hljs-con">sudo a2dissite acmeconsulting.com.conf 
sudo systemctl reload apache2 
</code></pre>
<p class="normal">If you’re curious about how this works behind the scenes, when the <code class="inlineCode">a2ensite</code> command is run against a configuration file, it basically creates a symbolic link to that file and stores it in the <code class="inlineCode">/etc/apache2/sites-enabled</code> directory. When you run <code class="inlineCode">a2dissite</code> to disable a site, this symbolic link is removed. </p>
<p class="normal">Apache, by default, will use any configuration files it finds in the <code class="inlineCode">/etc/apache2/sites-enabled</code> directory. After enabling or disabling a site, you’ll need to refresh Apache’s configuration, which is where the <code class="inlineCode">reload</code> option comes in. This command won’t restart Apache itself (so users who are using your existing sites won’t be disturbed) but it does give Apache a chance to reload its configuration files. If you replace <code class="inlineCode">reload</code> with <code class="inlineCode">restart</code> in the preceding commands, Apache will perform a full restart. You should only need to do that if you’re having an issue with Apache or enabling a new plugin, but in most cases the <code class="inlineCode">reload</code> option is preferred on a production system.</p>
<p class="normal">The main configuration file for Apache is located at <code class="inlineCode">/etc/apache2/apache2.conf</code>. Feel free to view the contents of this file; the comments contain a good overview of how Apache’s configuration is laid out. The following lines in this file are of special interest:</p>
<pre class="programlisting code"><code class="hljs-code"># Include the virtual host configurations: 
IncludeOptional sites-enabled/*.conf 
</code></pre>
<p class="normal">As you can see, this is how Ubuntu has configured Apache to look for enabled sites in the <code class="inlineCode">/etc/apache2/sites-enabled</code> directory. Any file stored there with the <code class="inlineCode">.conf</code> file extension is read by Apache. If you wish, you could actually remove those lines and Apache would then behave as it does on other platforms, and the <code class="inlineCode">a2ensite</code> and <code class="inlineCode">a2dissite</code> commands would no longer have any purpose. However, it’s best to keep the framework of Ubuntu’s implementation intact, as separating the configuration files makes logical sense and helps simplify the configuration. This chapter will go along with the Ubuntu way of managing configuration.</p>
<p class="normal">An additional virtual host is not required if you’re only hosting a single site. The contents of <code class="inlineCode">/var/www/html</code> are served by the default virtual host if you make no changes to Apache’s configuration. This is where the example site that ships with Apache comes from. If you only need<a id="_idIndexMarker747"/> to<a id="_idIndexMarker748"/> host one site, you could remove the default <code class="inlineCode">index.xhtml</code> file stored in this directory and replace it with the files required by your website. If you wish to test this for yourself, you can make a backup copy of the default <code class="inlineCode">index.xhtml</code> file and create a new one with some standard HTML. You should see the default page change to feature the content you just added to the file.</p>
<p class="normal">The <code class="inlineCode">000-default.conf</code> file is special, in that it’s basically the configuration file that controls the default Apache sample website. If you look at the contents of the <code class="inlineCode">/etc/apache2/sites-available</code> and <code class="inlineCode">/etc/apache2/sites-enabled</code> directories, you’ll see the <code class="inlineCode">000-default.conf</code> configuration file stored in <code class="inlineCode">sites-available</code> and <code class="inlineCode">symlinked</code> in <code class="inlineCode">sites-enabled</code>. This shows you that, by default, this site was included with Apache, and its configuration file was enabled as soon as Apache was installed. For all intents and purposes, the <code class="inlineCode">000-default.conf</code> configuration file is all you need if you only plan on hosting a single website on your server. The contents of this file are as follows, but I’ve stripped the comments out of the file in order to save space on this page:</p>
<pre class="programlisting code"><code class="hljs-code">&lt;VirtualHost *:80&gt; 
    ServerAdmin webmaster@localhost 
    DocumentRoot /var/www/html 
 
    ErrorLog ${APACHE_LOG_DIR}/error.log 
    CustomLog ${APACHE_LOG_DIR}/access.log combined 
&lt;/VirtualHost&gt; 
</code></pre>
<p class="normal">As you can see, this default virtual host is telling Apache to listen on port <code class="inlineCode">80</code> for requests and to serve content from <code class="inlineCode">/var/www/html</code> as soon as requests come in. The <code class="inlineCode">&lt;VirtualHost&gt;</code> declaration at the beginning is listening to everything (the asterisk is a <em class="italic">wildcard</em>) on port <code class="inlineCode">80</code>, so this is basically handling all web traffic that comes into the server from port <code class="inlineCode">80</code>. The <code class="inlineCode">ServerAdmin</code> clause specifies the email address that is displayed in any error messages shown if there is a problem with the site.</p>
<p class="normal">The <code class="inlineCode">DocumentRoot</code> setting tells Apache which directory to look for in order to find files to serve as connections to this virtual host. <code class="inlineCode">/var/www/html</code> is the default, but some administrators choose<a id="_idIndexMarker749"/> to<a id="_idIndexMarker750"/> customize this. This file also contains lines for where to<a id="_idIndexMarker751"/> send logging information. The <strong class="keyWord">access log</strong> contains information relating to HTTP requests that come in, which by default is stored in <code class="inlineCode">/var/log/access.log</code>. The <strong class="keyWord">error log</strong> is <a id="_idIndexMarker752"/>stored at <code class="inlineCode">/var/log/error.log</code> and contains information you can use whenever someone has trouble visiting your site. The <code class="inlineCode">${APACHE_LOG_DIR}</code> variable equates to <code class="inlineCode">/var/log</code> by default, and this is set in the <code class="inlineCode">/etc/apache2/envvars</code> file, in case for some reason you wish to change this (for example, you wish to use a custom logging directory).</p>
<p class="normal">If you wish to host another site on the same server by creating an additional virtual host, you can use the same framework as the original file, with some additional customizations. Virtual host files are stored in the <code class="inlineCode">/etc/apache2/sites-available</code> directory, with a filename ending in <code class="inlineCode">.conf</code>. Here’s an example of a hypothetical website, <code class="inlineCode">acmeconsulting.com</code>. A virtual host file such as this might be saved as <code class="inlineCode">/etc/apache2/sites-available/acmeconsulting.com.conf</code>:</p>
<pre class="programlisting code"><code class="hljs-code">&lt;VirtualHost <span class="code-highlight"><strong class="hljs-slc">192.168.1.104:80</strong></span>&gt; 
    ServerAdmin webmaster@localhost 
    <span class="code-highlight"><strong class="hljs-slc">DocumentRoot /var/www/acmeconsulting </strong></span>
 
    ErrorLog ${APACHE_LOG_DIR}/acmeconsulting.com-error.log 
    CustomLog ${APACHE_LOG_DIR}/acmeconsulting.com-access.log combined 
&lt;/VirtualHost&gt; 
</code></pre>
<p class="normal">To save time, I’ll generally copy another virtual host file, even the default one, and change it accordingly. In this particular example, I’ve emphasized some important differences. First, with this virtual host, I’m not listening for all connections coming in on port <code class="inlineCode">80</code>; instead, I’m specifically looking for incoming traffic going to IP address <code class="inlineCode">192.168.1.104</code> on port <code class="inlineCode">80</code>. This works because this server has two network cards, and therefore two IP addresses. With virtual hosts, I’m able to serve a different website, depending on which IP address the request is coming in on.</p>
<p class="normal">Next, I set <code class="inlineCode">DocumentRoot</code> to <code class="inlineCode">/var/www/acmeconsulting</code>. Each virtual host should have its own individual <code class="inlineCode">DocumentRoot</code> to keep each site separate from the others. On my servers, I will typically disable or remove the sample virtual host (the one that has the default <code class="inlineCode">DocumentRoot</code> of <code class="inlineCode">/var/www/html</code>). Instead, I use <code class="inlineCode">/var/www</code> as a base directory, and each virtual host gets its own directory as a subdirectory of this base.</p>
<p class="normal">Another change I find useful is to give each virtual host its own log files. Normally, Apache will use <code class="inlineCode">/var/log/apache2/error.log</code> and <code class="inlineCode">/var/log/apache2/access.log</code> to store log entries for all sites. If you only have a single site on your server, that is fine. However, when <a id="_idIndexMarker753"/>you’re<a id="_idIndexMarker754"/> serving multiple sites, I find it useful to give each site its own independent log files. That way, if you are having trouble with a particular site, you don’t have to scroll through unrelated log entries to find what you’re looking for when you’re troubleshooting. In my example, I inserted the website name in the log filenames, so this virtual host is logging errors in the <code class="inlineCode">/var/log/apache2/acmeconsulting.com-error.log</code> file, and the access log is being written to <code class="inlineCode">/var/log/apache2/acmeconsulting.com-access.log</code>. These log files will be created for you automatically as soon as you reload Apache.</p>
<p class="normal">With a server that only has a single IP address, you can still set up multiple virtual hosts. Instead of differentiating virtual hosts by IP, you can instead differentiate them by name. This is common <a id="_idIndexMarker755"/>on <strong class="keyWord">Virtual Private Server</strong> (<strong class="keyWord">VPS</strong>) installations of Ubuntu, where you’ll typically have a single IP address assigned to you by your VPS provider. For name-based virtual hosts, we would use the <code class="inlineCode">ServerName</code> option in our configuration. Refer to the following example to see how this would work. With this example, I’m adding name-based virtual hosts to their own files. I called mine <code class="inlineCode">000-virtual-hosts.conf</code> and stored it in the directory. The contents are as follows:</p>
<pre class="programlisting code"><code class="hljs-code">&lt;VirtualHost *:80&gt; 
    ServerName acmeconsulting.com 
    DocumentRoot /var/www/acmeconsulting 
&lt;/VirtualHost&gt; 
 
&lt;VirtualHost *:80&gt; 
    ServerName acmesales.com 
    DocumentRoot /var/www/acmesales 
&lt;/VirtualHost&gt; 
</code></pre>
<p class="normal">For each virtual host, I’m declaring a <code class="inlineCode">ServerName</code> with a matching <code class="inlineCode">DocumentRoot</code>. With the first example, any traffic coming into the server requesting <a href="http://acmeconsulting.com"><span class="url">acmeconsulting.com</span></a> will be provided a <code class="inlineCode">DocumentRoot</code> of <code class="inlineCode">/var/www/acmeconsulting</code>. The second example looks for traffic from <a href="http://acmesales.com"><span class="url">acmesales.com</span></a> and directs it to <code class="inlineCode">/var/www/acmesales</code>. You can list as many virtual hosts here as you’d like to host on your server. Providing your server has enough resources to handle traffic to each site, you can host as many as you need.</p>
<p class="normal">If you’re using domain names with virtual hosts, then this will only work if you set up networking such that the domain name referenced in the file resolves to the IP address of your server. Depending on your configuration, there are multiple ways to do this. If you’re using a VPS provider, such as DigitalOcean or Linode, your server will have an IP address already and you only need to edit <a id="_idIndexMarker756"/>the <strong class="keyWord">A Record</strong> on your DNS server to point to that IP. (The various types of DNS entries, such as an A Record, were covered in <em class="chapterRef">Chapter 11</em>, <em class="italic">Setting Up Network Services</em>.) </p>
<p class="normal">If you’re running your own DNS server, you would add the A Record there. If you’re using an external DNS provider, you would log in to the dashboard for your account and add the A Record there. For testing purposes, you can edit your <code class="inlineCode">/etc/hosts</code> file on your local workstation (not the server) to point to your new web server. If you’re not using a VPS provider, you would need to forward port <code class="inlineCode">80</code> in your firewall to point to your internal web server. This is beyond the scope of this book, as there are many different models of firewalls available and it’s impossible to cover them all.</p>
<p class="normal">As we continue through<a id="_idIndexMarker757"/> this <a id="_idIndexMarker758"/>chapter, we’ll perform some additional configurations for Apache. At this point though, you should have an understanding of the basics of how Apache is configured in Ubuntu Server. For extra practice, feel free to create additional virtual hosts and serve different pages for them.</p>
<h1 class="heading-1" id="_idParaDest-188">Installing additional Apache modules</h1>
<p class="normal">Apache features<a id="_idIndexMarker759"/> additional modules that can be installed that will extend its functionality. These modules can provide additional features such as adding support for things like Python or PHP. Ubuntu’s implementation of Apache includes two specific commands for enabling and disabling modules, <code class="inlineCode">a2enmod</code> and <code class="inlineCode">a2dismod</code>, respectively. Apache modules are generally installed via packages from Ubuntu’s repositories. To see a list of modules available for Apache, run the following command:</p>
<pre class="programlisting con"><code class="hljs-con">apt search libapache2-mod 
</code></pre>
<p class="normal">In the results, you’ll see various module packages available, such as <code class="inlineCode">libapache2-mod-python</code> (which adds Python support) and <code class="inlineCode">libapache2-mod-php8.1</code> (which adds PHP 8.1 support), among many others. Installing an Apache module is done the same way as any other package, with the <code class="inlineCode">apt install</code> command. In the case of PHP support, we can install the required package with the following command:</p>
<pre class="programlisting con"><code class="hljs-con">sudo apt install libapache2-mod-php8.1 
</code></pre>
<p class="normal">Installing a module package alone is not enough for a module to be usable in Apache, though. Modules must be enabled in order for Apache to be able to utilize them. As mentioned earlier, we can use the <code class="inlineCode">a2enmod</code> and <code class="inlineCode">a2dismod</code> commands for respectively enabling or disabling a module. You can view a list of modules that are built into Apache with the following command:</p>
<pre class="programlisting con"><code class="hljs-con">apache2 -l 
</code></pre>
<p class="normal">The modules shown in the output will be those that are built into Apache, so you won’t need to enable them. If the module your website requires is listed in the output, you’re all set.</p>
<p class="normal">To view a list of all modules that are installed and ready to be enabled, you can run the <code class="inlineCode">a2enmod</code> command by itself with no options:</p>
<figure class="mediaobject"><img alt="" height="434" src="../Images/B18425_14_02.png" width="876"/></figure>
<p class="packt_figref">Figure 14.2: The a2enmod command showing a list of available Apache modules</p>
<p class="normal">The end of the output of the <code class="inlineCode">a2enmod</code> command will ask you whether or not you’d like to enable any of the<a id="_idIndexMarker760"/> modules:</p>
<pre class="programlisting con"><code class="hljs-con">Which module(s) do you want to enable (wildcards ok)? 
</code></pre>
<p class="normal">If you wanted to, you could type the names of any additional modules you’d like to enable and then press <em class="keystroke">Enter</em>. Alternatively, you can press <em class="keystroke">Enter</em> without typing anything to simply return to the prompt.</p>
<p class="normal">If you give the <code class="inlineCode">a2enmod</code> command a module name as an option, it will enable it for you. To enable PHP 8.1 (which we’ll need later), you can run the following command:</p>
<pre class="programlisting con"><code class="hljs-con">sudo a2enmod php8.1
</code></pre>
<p class="normal">Chances are, though, if you’ve installed a package for an additional module, it was most likely enabled for you during installation. With Debian and Ubuntu, it’s very common for daemons and modules to be enabled as soon as their packages are installed, and Apache is no exception. In the case of the <code class="inlineCode">libapache2-mod-php8.1</code> package I used as an example, the module should’ve been enabled for you once the package was installed:</p>
<pre class="programlisting con"><code class="hljs-con">sudo a2enmod php8.1
</code></pre>
<p class="normal">If a module is already enabled, you will see output similar to the following when you try to enable it with <code class="inlineCode">a2enmod</code>:</p>
<pre class="programlisting con"><code class="hljs-con">Module php8.1 already enabled 
</code></pre>
<p class="normal">If the module wasn’t already enabled, we would see the following output:</p>
<pre class="programlisting con"><code class="hljs-con">Enabling module php8.1. 
To activate the new configuration, you need to run: 
systemctl restart apache2
</code></pre>
<p class="normal">As instructed, we’ll need to restart Apache in order for the enabling of a module to take effect. Keep in mind that restarting Apache will make any sites it may host become unavailable during the process. When it comes to disabling a module, the command syntax is fairly similar. To do so, you’ll use the <code class="inlineCode">a2dismod</code> command along with the name of the module you’d like to disable:</p>
<pre class="programlisting con"><code class="hljs-con">sudo a2dismod php8.1
</code></pre>
<p class="normal">Enabling a module that was already previously enabled will result in output similar to the following:</p>
<pre class="programlisting con"><code class="hljs-con">Module php8.1 disabled. 
</code></pre>
<p class="normal">To activate the new configuration, you need to run:</p>
<pre class="programlisting con"><code class="hljs-con">systemctl restart apache2
</code></pre>
<p class="normal">The modules you install and enable on your Apache server will depend on the needs of your website. For example, if you’re going to need support for Python, you’ll want to install the <code class="inlineCode">libapache2-mod-python</code> package. If you’re installing a third-party package, such as WordPress or Drupal, you’ll want to refer to the documentation for those packages in order to<a id="_idIndexMarker761"/> obtain a list of which modules are required for the solution to install and run properly. Once you have such a list, you’ll know which packages you’ll need to install and which modules to enable.</p>
<h1 class="heading-1" id="_idParaDest-189">Securing Apache with TLS</h1>
<p class="normal">Nowadays, it’s <a id="_idIndexMarker762"/>a great<a id="_idIndexMarker763"/> idea to ensure your organization’s website is encrypted and available over HTTPS. Encryption of web traffic has been historically achieved by utilizing <strong class="keyWord">Secure Sockets Layer</strong> (<strong class="keyWord">SSL</strong>) or, more recently, <strong class="keyWord">TLS</strong>, which is the successor to SSL. Both refer to a <a id="_idIndexMarker764"/>method of utilizing cryptography by installing signed certificates that protect and encrypt web traffic. The two functions are different, but the end result is the same. Going forward, it’s recommended to use TLS due to the additional security strength it offers, though it’s not uncommon to see SSL being used nowadays since it hasn’t been completely phased out.</p>
<p class="normal">Setting up and benefiting from TLS is not all that difficult to do, and will help protect your organization against common vulnerabilities being potentially exploited. Utilizing TLS doesn’t protect you from all exploits being used in the wild, but it does offer a layer of protection you’ll want to benefit from. Not only that, but your customers pretty much expect you to secure their communications nowadays. In this section, we’ll look at how to use TLS with our Apache installation. We’ll work through enabling it, generating certificates, and configuring Apache to use those certificates with both a single-site configuration and with virtual hosts.</p>
<p class="normal">By default, Ubuntu’s Apache configuration listens for traffic on port <code class="inlineCode">80</code>, but not port <code class="inlineCode">443</code> (HTTPS). You can check this yourself by running the following command:</p>
<pre class="programlisting con"><code class="hljs-con">sudo ss -tulpn | grep apache 
</code></pre>
<p class="normal">The<a id="_idIndexMarker765"/> results<a id="_idIndexMarker766"/> will look similar to the following and will show the ports that Apache is listening on, which is only port <code class="inlineCode">80</code> by default:</p>
<pre class="programlisting con"><code class="hljs-con">tcp   LISTEN 0      511                                    *:80               *:*    u
sers:(("apache2",pid=11521,fd=4),("apache2",pid=11520,fd=4),
("apache2",pid=11519,fd=4),("apache2",pid=11518,fd=4),("apache2",pid=11517,fd=4),
("apache2",pid=11513,fd=4)) 
</code></pre>
<p class="normal">If the server were listening on port <code class="inlineCode">443</code> as well, we would’ve seen the following within the output:</p>
<pre class="programlisting con"><code class="hljs-con">tcp   LISTEN 0      511                         *:443               *:* 
</code></pre>
<p class="normal">To enable support for HTTPS traffic, we need to first enable the <code class="inlineCode">ssl</code> module:</p>
<pre class="programlisting con"><code class="hljs-con">sudo a2enmod ssl  
</code></pre>
<p class="normal">Next, we need to restart Apache:</p>
<pre class="programlisting con"><code class="hljs-con">sudo systemctl restart apache2 
</code></pre>
<p class="normal">In addition to the sample website we discussed earlier, Ubuntu’s default Apache implementation also includes another site configuration file, <code class="inlineCode">/etc/apache2/sites-available/default-ssl.conf</code>. Unlike the sample site, this one is not enabled by default. This configuration file is similar to the sample site configuration, but it’s listening for connections on port <code class="inlineCode">443</code> and contains additional configuration items related to TLS. Here’s the<a id="_idIndexMarker767"/> content <a id="_idIndexMarker768"/>of that file, with the comments stripped out in order to save space on this page:</p>
<pre class="programlisting code"><code class="hljs-code">&lt;IfModule mod_ssl.c&gt; 
        &lt;VirtualHost _default_:443&gt; 
                ServerAdmin webmaster@localhost 
 
                DocumentRoot /var/www/html 
 
                ErrorLog ${APACHE_LOG_DIR}/error.log 
                CustomLog ${APACHE_LOG_DIR}/access.log combined 
 
                SSLEngine on 
 
                SSLCertificateFile      /etc/ssl/certs/ssl-cert-                
                snakeoil.pem 
                SSLCertificateKeyFile /etc/ssl/private/ssl-cert-                
                snakeoil.key 
 
                &lt;FilesMatch ".(cgi|shtml|phtml|php)$"&gt; 
                                SSLOptions +StdEnvVars 
                &lt;/FilesMatch&gt; 
                &lt;Directory /usr/lib/cgi-bin&gt; 
                                SSLOptions +StdEnvVars 
                &lt;/Directory&gt; 
 
        &lt;/VirtualHost&gt; 
&lt;/IfModule&gt; 
</code></pre>
<p class="normal">We already went over the <code class="inlineCode">ServerAdmin</code>, <code class="inlineCode">DocumentRoot</code>, <code class="inlineCode">ErrorLog</code>, and <code class="inlineCode">CustomLog</code> options earlier in this chapter, but there are additional options in this file that we haven’t seen yet. On the first line, we can see that this virtual host is listening on port <code class="inlineCode">443</code>. We also see <code class="inlineCode">_default_</code> listed here instead of an IP address. The <code class="inlineCode">_default_</code> option only applies to unspecified traffic, which in this case means any traffic coming into port <code class="inlineCode">443</code> that hasn’t been identified in any other virtual host. In addition, the <code class="inlineCode">SSLEngine on</code> option enables TLS traffic. Right after that, we have options for our TLS certificate file and key file, which we’ll get to a bit later.</p>
<p class="normal">We also have a <code class="inlineCode">&lt;Directory&gt;</code> clause, which allows us to apply specific options to a directory. In this case, the <code class="inlineCode">/usr/lib/cgi-bin</code> directory is having the <code class="inlineCode">SSLOptions +StdEnvVars</code> settings applied, which enables default environment variables for use with TLS. This option is also applied to files that have an extension of <code class="inlineCode">.cgi</code>, <code class="inlineCode">.shtml</code>, <code class="inlineCode">.phtml</code>, or <code class="inlineCode">.php</code> through the <code class="inlineCode">&lt;FilesMatch&gt;</code> option. The <code class="inlineCode">BrowserMatch</code> option allows you to set options for specific browsers, though it’s out of scope for this chapter. For now, just keep in mind that if you want to apply settings to specific browsers, you can.</p>
<p class="normal">By default, the <code class="inlineCode">default-ssl.conf</code> file is not enabled. In order to benefit from its configuration options, we’ll need to enable it, which we can do with the <code class="inlineCode">a2ensite</code> command as we would with any other virtual host:</p>
<pre class="programlisting con"><code class="hljs-con">sudo a2ensite default-ssl.conf 
</code></pre>
<p class="normal">Even though we just enabled TLS, our site isn’t secure just yet. We’ll need TLS certificates installed in order to secure our web server. We can do this in one of two ways, with self-signed certificates or certificates signed by a certificate authority. Both are implemented in <a id="_idIndexMarker769"/>very<a id="_idIndexMarker770"/> similar ways, and I’ll discuss both methods. For the purposes of testing, self-signed certificates are fine. In production, self-signed certificates would technically work, but most browsers won’t trust them by default and will give you an error when you go to their page. Therefore, it’s a good idea to refrain from using self-signed certificates on a production system. Users of a site with self-signed certificates would need to bypass an error page before continuing to the site, and seeing this error may cause them to avoid your site altogether. You can install the certificates into each user’s web browser, but that can be a headache. In production, it’s best to use certificates signed by a vendor.</p>
<p class="normal">Another method of setting up a certificate on your server is <strong class="keyWord">Let’s Encrypt</strong>, a popular (and free) service for encrypting web traffic. Consider checking out the instructions at the Let’s Encrypt website at <a href="http://letsencrypt.org/docs"><span class="url">letsencrypt.org/docs</span></a>, as well as the example article mentioned at the end of the chapter.</p>
<p class="normal">As we go through this process, I’ll first walk you through setting up TLS with a self-signed certificate so you can see how the process works. We’ll create the certificate and then install it into Apache. You won’t necessarily need to create a website to go through this process, since you could just secure the sample website that comes with Apache if you wanted something to use as a proof of concept. After we complete the process, we’ll take a look at installing certificates that were signed by a certificate authority.</p>
<p class="normal">To get the ball rolling, we’ll need a directory to house our certificates. I’ll use <code class="inlineCode">/etc/apache2/certs</code> in my examples, although you can use whatever directory you’d like, as long as you remember to update Apache’s configuration with your desired location and filenames:</p>
<pre class="programlisting con"><code class="hljs-con">sudo mkdir /etc/apache2/certs 
</code></pre>
<p class="normal">For a self-signed certificate and key, we can generate the pair with the following command. Feel free to change the name of the key and certificate files to match the name of your website:</p>
<pre class="programlisting con"><code class="hljs-con">sudo openssl req -x509 -nodes -days 365 -newkey rsa:2048 -keyout /etc/apache2/certs/mysite.key -out /etc/apache2/certs/mysite.crt 
</code></pre>
<p class="normal">You’ll be prompted to enter some information for generating the certificate. Answer each prompt as they come along. Here’s a list of the questions you’ll be asked, along with my responses for each. Change the answers to fit your server, environment, organization<a id="_idIndexMarker771"/> name, and <a id="_idIndexMarker772"/>location:</p>
<pre class="programlisting con"><code class="hljs-con">Country Name (2 letter code) [AU]:US 
State or Province Name (full name) [Some-State]:Michigan 
Locality Name (eg, city) []:Detroit 
Organization Name (eg, company) [Internet Widgits Pty Ltd]:My Company 
Organizational Unit Name (eg, section) []:IT 
Common Name (e.g. server FQDN or YOUR name) []:myserver.mydomain.com 
Email Address []:webmaster@mycompany.com 
</code></pre>
<p class="normal">Now, you should see that two files have been created in the <code class="inlineCode">/etc/apache2/certs</code> directory, <code class="inlineCode">mysite.crt</code> and <code class="inlineCode">mysite.key</code>, which represent the certificate and private key, respectively. Now that these files have been generated, the next thing for us to do is to configure Apache to use them. Look for the following two lines in the <code class="inlineCode">/etc/apache2/sites-available/default-ssl.conf</code> file:</p>
<pre class="programlisting code"><code class="hljs-code">SSLCertificateFile       /etc/ssl/certs/ssl-cert-snakeoil.pem 
SSLCertificateKeyFile  /etc/ssl/private/ssl-cert-snakeoil.key 
</code></pre>
<p class="normal">Comment these lines out by placing a <code class="inlineCode">#</code> symbol in front of both:</p>
<pre class="programlisting code"><code class="hljs-code"># SSLCertificateFile      /etc/ssl/certs/ssl-cert-snakeoil.pem 
# SSLCertificateKeyFile /etc/ssl/private/ssl-cert-snakeoil.key 
</code></pre>
<p class="normal">Next, add the following two lines underneath the lines you just commented out. Be sure to replace the target directories and certificate filenames with yours, if you followed your own naming convention:</p>
<pre class="programlisting code"><code class="hljs-code">SSLCertificateFile      /etc/apache2/certs/mysite.crt
SSLCertificateKeyFile /etc/apache2/certs/mysite.key
</code></pre>
<p class="normal">To make Apache benefit from the new configuration, reload the <code class="inlineCode">apache2</code> daemon:</p>
<pre class="programlisting con"><code class="hljs-con">sudo systemctl reload apache2 
</code></pre>
<p class="normal">With the new configuration in place, we’re not quite done but we’re close. We still have a small bit of configuration left to add. But before we get to that, let’s return to the topic of installing TLS certificates that were signed by a certificate authority. The process for installing signed TLS certificates is pretty much the same, but the main difference is how the certificate files are requested and obtained. Once you have them, you will copy them to your file server and configure Apache the same way as we just did. To start the process of obtaining a signed TLS certificate, you’ll need to create a <strong class="keyWord">Certificate Signing Request</strong> (<strong class="keyWord">CSR</strong>). A CSR<a id="_idIndexMarker773"/> is basically a request for a certificate in file form that you’ll supply to your certificate authority to start the process of requesting a signed certificate. A CSR can be easily generated with the following command:</p>
<pre class="programlisting con"><code class="hljs-con">openssl req -new -newkey rsa:2048 -nodes -keyout server.key -out server.csr 
</code></pre>
<p class="normal">With the CSR file that <a id="_idIndexMarker774"/>was <a id="_idIndexMarker775"/>generated, you can request a signed certificate. The CSR file should now be in your current working directory. The entire process differs from one provider to another, but in most cases, it’s fairly straightforward. You’ll send them the CSR, pay their fee, fill out a form or two on their website, prove that you are the owner of the website in question, and then the vendor will send you the files you need. It may sound complicated, but certificate authorities usually walk you through the entire process and make it clear what they need from you in order to proceed. Once you complete the process, the certificate authority will send you your certificate files, which you’ll then install on your server. Once you configure the <code class="inlineCode">SSLCertificateFile</code> and <code class="inlineCode">SSLCertificateKeyFile</code> options in <code class="inlineCode">/etc/apache2/sites-available/default-ssl.conf</code> to point to the new certificate files and reload Apache, you should be good to go.</p>
<p class="normal">There’s one more additional step we should perform for setting this up properly. At this point, our certificate files should be properly installed, but we’ll need to inform Apache of when to apply them. If you recall, the <code class="inlineCode">default-ssl.conf</code> file provided by the <code class="inlineCode">apache2</code> package is answering requests for any traffic not otherwise identified by a virtual host (the <code class="inlineCode">&lt;VirtualHost _default_:443&gt;</code> option). We will need to ensure that our web server is handling traffic for our existing websites when TLS is requested. We can add a <code class="inlineCode">ServerName</code> option to that file to ensure our site supports TLS.</p>
<p class="normal">Add the following option to the <code class="inlineCode">/etc/apache2/sites-available/default-ssl.conf</code> file, right underneath <code class="inlineCode">&lt;VirtualHost _default_:443&gt;</code>:</p>
<pre class="programlisting code"><code class="hljs-code">ServerName mydomain.com:443 
</code></pre>
<p class="normal">Now, when traffic comes into your server on port <code class="inlineCode">443</code> requesting a domain that matches the domain you typed for the <code class="inlineCode">ServerName</code> option, it should result in a secure browsing session for the client. You should see the green padlock icon in the address bar (this depends on your browser), which indicates that your session is secured. If you’re using self-signed certificates, you’ll probably see an error you’ll have to skip through first, and you may not get the green padlock icon. This doesn’t mean the encryption isn’t working; it just means your browser is skeptical of the certificate since it wasn’t signed by a known certificate authority. Your session will still be encrypted.</p>
<p class="normal">If you are<a id="_idIndexMarker776"/> planning<a id="_idIndexMarker777"/> on hosting multiple websites over HTTPS, you may want to consider using a separate virtual host file for each. An easy way to accomplish this is to use the <code class="inlineCode">/etc/apache2/sites-available/default-ssl.conf</code> file as a template and change <code class="inlineCode">DocumentRoot</code> to the directory that hosts the files for that site. In addition, be sure to update the <code class="inlineCode">SSLCertificateFile</code> and <code class="inlineCode">SSLCertificateKeyFile</code> options to point to the certificate files for the site and set <code class="inlineCode">ServerName</code> to the domain that corresponds to your site. Here’s an example virtual host file for a hypothetical site that uses TLS. I’ve highlighted lines that I’ve changed from the normal <code class="inlineCode">default-ssl.conf</code> file:</p>
<pre class="programlisting code"><code class="hljs-code">&lt;IfModule mod_ssl.c&gt; 
        &lt;VirtualHost *:443&gt; 
                ServerName acmeconsulting.com:443 
 
                ServerAdmin webmaster@localhost 
 
                DocumentRoot /var/www/acmeconsulting 
<span class="code-highlight"><strong class="hljs-slc">                ErrorLog ${APACHE_LOG_DIR}/acmeconsulting.com-error.log </strong></span>
<span class="code-highlight"><strong class="hljs-slc">                CustomLog ${APACHE_LOG_DIR}/acmeconsulting.com-access.                  </strong></span>
<span class="code-highlight"><strong class="hljs-slc">                log combined </strong></span>
<span class="code-highlight"><strong class="hljs-slc"> </strong></span>
<span class="code-highlight"><strong class="hljs-slc">                SSLEngine on </strong></span>
<span class="code-highlight"><strong class="hljs-slc">        SSLCertificateFile      /etc/apache2/certs/acmeconsulting/acme.           </strong></span>
<span class="code-highlight"><strong class="hljs-slc">        crt </strong></span>
<span class="code-highlight"><strong class="hljs-slc">        SSLCertificateKeyFile /etc/apache2/certs/acmeconsulting/acme.                </strong></span>
<span class="code-highlight"><strong class="hljs-slc">        key </strong></span>
 
                &lt;FilesMatch ".(cgi|shtml|phtml|php)$"&gt; 
                                SSLOptions +StdEnvVars 
                &lt;/FilesMatch&gt; 
                &lt;Directory /usr/lib/cgi-bin&gt; 
                                SSLOptions +StdEnvVars 
                &lt;/Directory&gt; 
 
        &lt;/VirtualHost&gt; 
&lt;/IfModule&gt; 
</code></pre>
<p class="normal">Basically, what I did was create a new virtual host configuration file (using the existing <code class="inlineCode">default-ssl.conf</code> file as a template). I called this new file <code class="inlineCode">acme-consulting.conf</code> and I stored it in the <code class="inlineCode">/etc/apache2/sites-available</code> directory. I changed the <code class="inlineCode">VirtualHost</code> line to listen for<a id="_idIndexMarker778"/> anything<a id="_idIndexMarker779"/> coming in on port <code class="inlineCode">443</code>. The line <code class="inlineCode">ServerName acmeconsulting.com:443</code> was added to make this file responsible for traffic coming in looking for <code class="inlineCode">acmeconsulting.com</code> on port <code class="inlineCode">443</code>. I also set <code class="inlineCode">DocumentRoot</code> to <code class="inlineCode">/var/www/acmeconsulting</code>. In addition, I customized the error and access logs so that it will be easier to find log messages relating to this new site, since its log entries will go to their own specific files.</p>
<p class="normal">In my experience, I find that a modular approach, such as what I’ve done with the sample virtual host file for HTTPS, works best when setting up a web server that’s intended to host multiple websites. With each site, I’ll typically give it its own document root, certificate files, and log files. Even if you’re only planning on hosting a single site on your server, using this modular approach is still a good idea, since you may want to host additional sites later on.</p>
<p class="normal">So, there you have it. You should now understand how to set up secure virtual hosts in Apache. </p>
<h1 class="heading-1" id="_idParaDest-190">Installing and configuring NGINX</h1>
<p class="normal">Apache isn’t<a id="_idIndexMarker780"/> the only <a id="_idIndexMarker781"/>technology that is capable of allowing you to host web content on your server. NGINX also serves the same purpose and is gaining popularity quite rapidly. Apache is still a great option, and even if that’s your chosen web server software, it’s a good idea to at least be familiar with NGINX and learn its basics. NGINX itself is a proxy server as well but is capable of also serving web content, which is why it competes with Apache.</p>
<p class="normal">Before we do so, I want to mention first that you can really only have one web server service running on a single web server. If you’ve been following along up to now, you currently have a functional Apache web server. If you were to also install NGINX, it probably wouldn’t start as the ports it wants to listen on (port <code class="inlineCode">80</code> and/or <code class="inlineCode">443</code>) will already be in use. You can run both on a single server, but that’s outside the scope of this book. Ideally, you’d want to use one or the other. Therefore, to continue with this section you’d either want to remove Apache or set up a separate web server for testing NGINX. I recommend the latter, because later on in this chapter we will take a look at hosting Nextcloud, and we will be using Apache to do so. If you remove Apache now, you’d have to add it back in order to follow along with that section. Theoretically, you’d only have to stop the <code class="inlineCode">apache2</code> process before starting <code class="inlineCode">nginx</code>, but the two resources sharing the same server have a lot of variables and may conflict.</p>
<p class="normal">To get started with NGINX, simply install it:</p>
<pre class="programlisting con"><code class="hljs-con">sudo apt install nginx
</code></pre>
<p class="normal">Just like with Apache, if we enter the IP address of our server in a browser, we’re presented with a sample page, but this time NGINX’s version instead of the one that ships with Apache. It certainly looks boring in comparison, but it works:</p>
<p class="packt_figref"><img alt="" height="380" src="../Images/B18425_14_03.png" width="818"/>Figure 14.3: The NGINX sample page</p>
<p class="normal">The default configuration files for <code class="inlineCode">nginx</code> are stored in the <code class="inlineCode">/etc/nginx</code> directory. Go ahead and <a id="_idIndexMarker782"/>peruse these files to get a general feel for how the configuration<a id="_idIndexMarker783"/> is presented. Similar to Apache, you also have <code class="inlineCode">sites-enabled</code> and <code class="inlineCode">sites-available</code> directories here, which serve the same purpose.</p>
<p class="normal">Just as with Apache, the <code class="inlineCode">sites-available</code> directory houses configuration files for sites that <em class="italic">can be</em> enabled, while the <code class="inlineCode">sites-enabled</code> directory stores configuration files for sites that are enabled. Unlike Apache, though, we don’t have dedicated commands to enable these sites. We have to link them manually. Although we haven’t even looked at NGINX configuration files yet, let’s just assume that we have created the following configuration file:</p>
<pre class="programlisting code"><code class="hljs-code">/etc/nginx/sites-available/acmesales.com
</code></pre>
<p class="normal">To enable that site, we would need to create a symbolic link for it and store that link in the <code class="inlineCode">/etc/nginx/sites-enabled</code> directory:</p>
<pre class="programlisting con"><code class="hljs-con">sudo ln -s /etc/nginx/sites-available/acmesales.com /etc/nginx/sites-enabled/acmesales.com
</code></pre>
<p class="normal">Then, we can reload <code class="inlineCode">nginx</code>:</p>
<pre class="programlisting con"><code class="hljs-con">sudo systemctl reload nginx
</code></pre>
<p class="normal">As it stands right now, a site configuration file named <code class="inlineCode">default</code> exists in <code class="inlineCode">/etc/nginx/sites-available</code> and a symbolic link to it is already present in <code class="inlineCode">/etc/nginx/sites-enabled</code>. If all we want to do is host a single site, we only need to replace the default content that NGINX serves, which is located in the <code class="inlineCode">/var/www/html</code> directory (the same as Apache) with the content for our site. After refreshing the page, we’re good to go.</p>
<p class="normal">If we want to serve more than one site from one server, the <code class="inlineCode">default</code> file is a great starting point for creating additional virtual hosts. We can start by copying it to a new name:</p>
<pre class="programlisting con"><code class="hljs-con">sudo cp /etc/nginx/sites-available/default /etc/nginx/sites-available/acmesales.com
</code></pre>
<p class="normal">Obviously, <code class="inlineCode">acmesales.com</code> is an example, so feel free to name this whatever you wish.</p>
<p class="normal">Now, we can edit this file and change it to serve additional content. First of all, only one site can be<a id="_idIndexMarker784"/> referred <a id="_idIndexMarker785"/>to as a <em class="italic">default</em> site. A default site in NGINX is one that answers if none of the other sites match a request. Therefore, we want to remove both occurrences of <code class="inlineCode">default_server</code> from our newly copied config. Find these lines:</p>
<pre class="programlisting code"><code class="hljs-code">listen 80 default_server;
listen [::]:80 default_server;
</code></pre>
<p class="normal">Change them to this:</p>
<pre class="programlisting code"><code class="hljs-code">listen 80;
listen [::]:80;
</code></pre>
<p class="normal">Next, we’ll need to adjust the <code class="inlineCode">server_name</code> option to refer to the name of our new site. Add this line:</p>
<pre class="programlisting code"><code class="hljs-code">server_name acmesales.com www.acmesales.com;
</code></pre>
<p class="normal">Now, we’ll need to change the document root to the directory that will store the files for our new site. Find this line:</p>
<pre class="programlisting code"><code class="hljs-code">root /var/www/html;
</code></pre>
<p class="normal">And change it to this:</p>
<pre class="programlisting code"><code class="hljs-code">root /var/www/acmesales.com;
</code></pre>
<p class="normal">The final file should look like the following at this point:</p>
<pre class="programlisting code"><code class="hljs-code">server { 
        listen 80; 
        listen [::]:80; 
 
        root /var/www/acmesales.com; 
 
        index index.xhtml index.htm index.nginx-debian.xhtml; 
 
        server_name acmesales.com www.acmesales.com; 
 
        location / { 
                try_files $uri $uri/ =404; 
        } 
}
</code></pre>
<p class="normal">You can probably see that the configuration format for NGINX configuration files is simpler than with Apache. I find this to be true, and I’ve noticed that sites I’ve configured with NGINX generally have fewer lines in their configuration files than Apache does.</p>
<p class="normal">At this point, assuming that you have the required content in <code class="inlineCode">/var/www/acmesales.com</code> and have a proper configuration file, the new site should respond as soon as you reload <code class="inlineCode">nginx</code>. But <a id="_idIndexMarker786"/>what<a id="_idIndexMarker787"/> about TLS? I recommend that we always secure our websites, regardless of which solution we’re using to serve it. With NGINX, we can add that feature easily. The certificate files themselves are the same regardless of whether we’re using Apache or NGINX. If you haven’t already created your certificate files, refer back to the section in this chapter where we did so. Assuming you already have certificate files, we just need to make additional changes to our configuration.</p>
<p class="normal">First, we change the first two lines to listen on port <code class="inlineCode">443</code> with TLS instead of standard port <code class="inlineCode">80</code>:</p>
<pre class="programlisting code"><code class="hljs-code">listen 443 ssl; 
listen [::]:443 ssl; 
</code></pre>
<p class="normal">Next, we’ll add the following two lines before the <code class="inlineCode">location</code> section:</p>
<pre class="programlisting code"><code class="hljs-code">ssl_certificate /etc/certs/cert.pem; 
ssl_certificate_key /etc/certs/cert.key; 
ssl_session_timeout 5m; 
</code></pre>
<p class="normal">For this to work, you’ll need to adjust the paths and the names of the <code class="inlineCode">cert</code> files to make sure they match what you called them on your server. The entire file should look similar to the following at this point:</p>
<pre class="programlisting code"><code class="hljs-code">server { 
        listen 443 ssl; 
        listen [::]:443 ssl; 
 
        root /var/www/html; 
 
        index index.xhtml index.htm index.nginx-debian.xhtml; 
 
        server_name acmesales.com www.acmesales.com; 
 
        ssl_certificate /etc/certs/cert.pem; 
        ssl_certificate_key /etc/certs/cert.key; 
        ssl_session_timeout 5m; 
        location / { 
                try_files $uri $uri/ =404; 
        } 
} 
</code></pre>
<p class="normal">Finally, a potential problem is that users may access our site via port <code class="inlineCode">80</code>, instead of utilizing HTTPS. We can tell NGINX to forward these people to the secure version of our site automatically. To do that, we can edit the default configuration file (<code class="inlineCode">/etc/nginx/sites-available/default</code>) and add the following line just after the two <code class="inlineCode">listen</code> directives:</p>
<pre class="programlisting code"><code class="hljs-code">return 301 https://$host$request_uri; 
</code></pre>
<p class="normal">Now, anytime a user visits the HTTP version of our site, they’ll be redirected to the secure HTTPS<a id="_idIndexMarker788"/> version <a id="_idIndexMarker789"/>automatically.</p>
<p class="normal">Now that we’ve looked at serving web content with both Apache and NGINX, let’s take a look at setting up our very own Nextcloud server.</p>
<h1 class="heading-1" id="_idParaDest-191">Setting up and configuring Nextcloud</h1>
<p class="normal">I figured we’d<a id="_idIndexMarker790"/> end <a id="_idIndexMarker791"/>this chapter with a fun activity: setting up our very own Nextcloud server. Nextcloud is a very useful web application that’s handy for any organization. Even if you’re not working on a company network, Nextcloud is a great asset for even a single user. You can use it to synchronize files between machines, store and sync contacts, keep track of tasks you’re working on, fetch email from a mail server, and more. To complete this activity, you’ll need a web server to work with. Nextcloud supports multiple different web server platforms, but in this example, we’ll be using Apache.</p>
<p class="normal">You’ll also need an installation of MySQL or MariaDB, as Nextcloud will need its own database. We went over installing and managing MariaDB databases in <em class="chapterRef">Chapter 13</em>, <em class="italic">Managing Databases</em>. I’ll give you all the commands you’ll need to set up the database in this section, but refer back to <em class="chapterRef">Chapter 13</em>, <em class="italic">Managing Databases</em>, if any of these commands confuse you.</p>
<p class="normal">To get started, we need to download Nextcloud. To do so, head on over to the project’s website at <a href="https://www.nextcloud.com"><span class="url">https://www.nextcloud.com</span></a> and navigate to the <strong class="screenText">Download</strong> section. The layout of this site may change from time to time, but at the time of writing, the first link to click on is a button labeled <strong class="screenText">Get Nextcloud</strong>, which will take you to the download page. As of the time of writing, the direct URL for the download page for Nextcloud is currently <a href="https://nextcloud.com/install"><span class="url">https://nextcloud.com/install</span></a>.</p>
<p class="normal">Once there, look for the <strong class="screenText">Archive File</strong> heading, and expand it. Underneath that, you should see<a id="_idIndexMarker792"/> a <a id="_idIndexMarker793"/>button that reads <strong class="screenText">Download for Server</strong>, but don’t click on it just yet. Instead, right-click on it and click <strong class="screenText">Copy link address</strong> or a similarly named option, depending on the browser you use.</p>
<p class="normal">This should copy the link for the download to your clipboard. If the Nextcloud website layout has changed since publication, you’re essentially just looking for the URL to the ZIP file to download Nextcloud, and you’ll want to copy it to your computer’s clipboard.</p>
<p class="normal">Next, open an SSH session to your web server. Make sure you’re currently working from your home directory, and execute the following command:</p>
<pre class="programlisting con"><code class="hljs-con">wget &lt;URL of Nextcloud&gt;
</code></pre>
<p class="normal">To get the Nextcloud URL, simply paste the URL into your terminal after typing <code class="inlineCode">wget</code>. Your entire command will look similar to the following:</p>
<pre class="programlisting con"><code class="hljs-con">wget https://download.nextcloud.com/server/releases/latest.zip
</code></pre>
<p class="normal">This command will download the Nextcloud software locally to your current working directory. Next, we’ll need to <code class="inlineCode">unzip</code> the archive:</p>
<pre class="programlisting con"><code class="hljs-con">unzip latest.zip
</code></pre>
<p class="normal">If you get an error message insinuating that the <code class="inlineCode">unzip</code> command is not available, you may need to install it:</p>
<pre class="programlisting con"><code class="hljs-con">sudo apt install unzip
</code></pre>
<p class="normal">Now, let’s move the newly extracted <code class="inlineCode">nextcloud</code> directory to <code class="inlineCode">/var/www/html</code>:</p>
<pre class="programlisting con"><code class="hljs-con">sudo mv nextcloud /var/www/html/nextcloud
</code></pre>
<p class="normal">In order for Nextcloud to function, the user account that Apache uses to serve content will need full access to it. Let’s use the following command to give the user <code class="inlineCode">www-data</code> ownership of the <code class="inlineCode">nextcloud</code> directory:</p>
<pre class="programlisting con"><code class="hljs-con">sudo chown www-data:www-data -R /var/www/html/nextcloud
</code></pre>
<p class="normal">Now, you should<a id="_idIndexMarker794"/> have <a id="_idIndexMarker795"/>the required files for the Nextcloud software installed on the server in the <code class="inlineCode">/var/www/nextcloud</code> directory. In order for this to work, though, Apache will need a configuration file that includes <code class="inlineCode">/var/www/nextcloud</code> as its document root. We can create the file we need at the following location:</p>
<pre class="programlisting code"><code class="hljs-code">/etc/apache2/sites-available/nextcloud.conf
</code></pre>
<p class="normal">Example content to include in that file is as follows:</p>
<pre class="programlisting code"><code class="hljs-code">Alias /nextcloud "/var/www/html/nextcloud/" 
 
&lt;Directory /var/www/html/nextcloud/&gt; 
   Options +FollowSymlinks 
   AllowOverride All 
 
    &lt;IfModule mod_dav.c&gt; 
        Dav off 
    &lt;/IfModule&gt; 
 
    SetEnv HOME /var/www/html/nextcloud 
    SetEnv HTTP_HOME /var/www/html/nextcloud 
&lt;/Directory&gt; 
</code></pre>
<p class="normal">Similar to our earlier discussion on Apache, we’re adding a config file here specifically for Nextcloud that sets up an alias to point to <code class="inlineCode">/nextcloud</code> to <code class="inlineCode">www.mydomain.com/nextcloud</code>. Essentially, it allows Nextcloud to be reached at your domain name, plus <code class="inlineCode">/nextcloud</code> added to the end. The rest of the file disables WebDAV (a means of allowing a web server to act as a file server, not needed in our case) and then enables environment variables to set <code class="inlineCode">HOME</code> and <code class="inlineCode">HTTP_HOME</code> to the document root for Nextcloud, which in our case is <code class="inlineCode">/var/www/html/nextcloud</code>.</p>
<p class="normal">Next, we enable the new site:</p>
<pre class="programlisting con"><code class="hljs-con">sudo a2ensite nextcloud.conf 
</code></pre>
<p class="normal">Next, we’ll need to make a change to Apache. First, we’ll need to ensure that the <code class="inlineCode">libapache2-mod-php8.1</code> package is installed since Nextcloud requires PHP, but we’ll need some additional packages as well. You can install Nextcloud’s prerequisite packages with the following command:</p>
<pre class="programlisting con"><code class="hljs-con">sudo apt install libapache2-mod-php8.1 php8.1-curl php8.1-gd php8.1-intl php8.1-mbstring php8.1-mysql php8.1-xml php8.1-zip
</code></pre>
<p class="normal">Next, restart Apache so that it can take advantage of the new PHP plugin:</p>
<pre class="programlisting con"><code class="hljs-con">sudo systemctl restart apache2
</code></pre>
<p class="normal">At this point, we’ll<a id="_idIndexMarker796"/> need <a id="_idIndexMarker797"/>a MySQL or MariaDB database for Nextcloud to use. This database can exist on another server, or you can share it on the same server you installed Nextcloud on. If you haven’t already set up MariaDB, a walk-through was covered during <em class="chapterRef">Chapter 13</em>, <em class="italic">Managing Databases</em>. At this point, it’s assumed that you already have MariaDB installed and running.</p>
<p class="normal">Log in to your MariaDB instance as your <code class="inlineCode">root</code> user, or a user with full root privileges. You can create the Nextcloud database with the following command:</p>
<pre class="programlisting con"><code class="hljs-con">CREATE DATABASE nextcloud;
</code></pre>
<p class="normal">Next, we’ll need to add a new user to MariaDB for Nextcloud and give that user full access to the <code class="inlineCode">nextcloud</code> database. We can take care of both with the following command:</p>
<pre class="programlisting con"><code class="hljs-con">GRANT ALL ON nextcloud.* to 'nextcloud'@'localhost' IDENTIFIED BY 'super_secret_password';
</code></pre>
<p class="normal">Make sure to change <code class="inlineCode">super_secret_password</code> to a very strong (preferably randomly generated) password. Make sure you save this password in a safe place.</p>
<p class="normal">Now we have all we need in order to configure Nextcloud. You should now be able to visit your Nextcloud instance in a web browser. Just enter a URL similar to the following, replacing the sample IP address with the one for your server:</p>
<pre class="programlisting code"><code class="hljs-code">http://172.16.250.133/nextcloud 
</code></pre>
<p class="normal">If you’re using a subdomain and gave Nextcloud its own virtual host, that URL would then be something like this:</p>
<pre class="programlisting code"><code class="hljs-code">http://nextcloud.yourdomain.com/nextcloud 
</code></pre>
<p class="normal">You should see <a id="_idIndexMarker798"/>a <a id="_idIndexMarker799"/>page asking you to configure Nextcloud:</p>
<figure class="mediaobject"><img alt="" height="444" src="../Images/B18425_14_04.png" width="875"/></figure>
<p class="packt_figref">Figure 14.4: Nextcloud configuration page</p>
<p class="normal">If you do not see this page, make sure that the <code class="inlineCode">/var/www/html/nextcloud</code> directory is accessible via Apache. Also, make sure you have an appropriate virtual host for Nextcloud referencing this directory as its Document Root.</p>
<p class="normal">This page will ask you for several pieces of information. First, you’ll see <strong class="screenText">Username</strong> and <strong class="screenText">Password</strong>. This is not asking you for a pre-existing account, but actually to set up a brand-new administrator account. This shouldn’t be an account you’ll use on a day-to-day basis, but instead an admin account you’ll use only when you want to add users and maintain your system. Please note that it won’t ask you to confirm the password, so you’ll want to make certain you’re entering the password you think you are. It’s perhaps safer to type the password in a text editor, and then copy and paste the password into the <strong class="screenText">Password</strong> box to make sure you don’t lock yourself out.</p>
<p class="normal"><strong class="screenText">Data folder</strong> will default to <code class="inlineCode">/var/www/html/nextcloud/data</code>. This default is normally fine, but if you have configured your server to have a separate data partition, you can configure that here. If you plan on storing a large amount of data on your Nextcloud server, setting up a <a id="_idIndexMarker800"/>separate <a id="_idIndexMarker801"/>partition for it may be a good idea. If you do, you can set that here. Otherwise, leave the default.</p>
<p class="normal">In the next section, you’ll be asked to fill in information for the Nextcloud database we created earlier. <strong class="screenText">Database user</strong> and <strong class="screenText">Database password</strong> will use the values we created when we set up the MariaDB database for Nextcloud earlier. In my examples, I used <code class="inlineCode">nextcloud</code> for the username as well as <strong class="screenText">Database name</strong>. The password will be whatever it is you used for the password when we set up the database user account and granted privileges. Finally, the database server defaults to <code class="inlineCode">localhost</code>, which is correct as long as you set up the database on the same machine as the Nextcloud server. If not, enter the address of your database server here, if it’s somewhere else. The following screenshot shows the initial form completely filled out with the example values we’ve used so far in this section:</p>
<figure class="mediaobject"><img alt="" height="757" src="../Images/B18425_14_05.png" width="573"/></figure>
<p class="packt_figref">Figure 14.5: Nextcloud configuration page</p>
<p class="normal">That’s it! Assuming <a id="_idIndexMarker802"/>all<a id="_idIndexMarker803"/> went well, Nextcloud will set itself up in the background and you’ll then continue to the main screen. Since you only created an <code class="inlineCode">admin</code> account so far, I recommend you create an account for yourself, as well as any friends or colleagues you’d like to check out your Nextcloud server. To do so, go to the top-right corner of the Nextcloud page, where it shows an icon that resembles a gear. When you click on this icon, you’ll see an option for <strong class="screenText">Users</strong>:</p>
<figure class="mediaobject"><img alt="" height="669" src="../Images/B18425_14_06.png" width="314"/></figure>
<p class="packt_figref">Figure 14.6: Nextcloud menu</p>
<p class="normal">On the <strong class="screenText">Users</strong> screen, you’ll <a id="_idIndexMarker804"/>be <a id="_idIndexMarker805"/>able to add additional users to access Nextcloud. Click on the <strong class="screenText">New User</strong> button. Simply fill out the <strong class="screenText">Username</strong> and <strong class="screenText">Password</strong> fields at the top of the screen, and then click on the blue checkmark icon to finish the process:</p>
<figure class="mediaobject"><img alt="" height="643" src="../Images/B18425_14_07.png" width="552"/></figure>
<p class="packt_figref">Figure 14.7: Adding a new user to Nextcloud</p>
<p class="normal">As an administrative <a id="_idIndexMarker806"/>user, you <a id="_idIndexMarker807"/>can enable or disable various apps that are used by your users. Out of the box, Nextcloud has a basic suite of apps enabled, such as the <strong class="screenText">File Sharing</strong> and <strong class="screenText">Photos</strong> plugins. There are many more apps that you can enable in order to extend its functionality. In the top-right corner of the main screen of Nextcloud, you’ll find an icon that looks like a gear, and if you click on it, you will find a link to <strong class="screenText">Apps</strong>, which will allow you to add additional functionality. Feel free to enable additional apps to extend Nextcloud’s capabilities. Some of my must-haves include <strong class="screenText">Notes</strong> and <strong class="screenText">Tasks</strong>.</p>
<p class="normal">Now, you have your very own Nextcloud server. I find Nextcloud to be a very useful platform. Some Linux desktop environments (such as GNOME) have built-in integrations that allow you to add your Nextcloud account right to your desktop, which will allow calendar and contact syncing with your computer. There are also standalone client apps available for Linux, Windows, and macOS that you can download from the same URL that we’ve downloaded Nextcloud itself from.</p>
<p class="normal">I’m sure you’ll <a id="_idIndexMarker808"/>agree<a id="_idIndexMarker809"/> that Nextcloud is a very useful asset to have available. For more information on using Nextcloud, check out the manual. In fact, it’s available in the <strong class="keyWord">Files</strong> app from within the application itself.</p>
<h1 class="heading-1" id="_idParaDest-192">Summary</h1>
<p class="normal">In this action-packed chapter, we looked at serving web pages with Apache. We started out by installing and configuring Apache, and then added additional modules. We also covered the concept of virtual hosts, which allow us to serve multiple websites on a single server, even if we only have a single network interface. Then, we walked through securing our Apache server with TLS. With Apache, we can use self-signed certificates, or we can purchase TLS certificates from a vendor for a fee. We looked at both possibilities. We even set up NGINX, which is a very powerful application that is growing in popularity. Finally, we closed out the chapter with a guide to installing Nextcloud, which is an application I’m sure you’ll find incredibly useful.</p>
<p class="normal">In the next chapter of our journey, we’ll take a look at the process of automating server configuration with Ansible, which is a lot of fun.</p>
<h1 class="heading-1" id="_idParaDest-193">Relevant videos</h1>
<ul>
<li class="bulletList">Nextcloud setup walk-through: <a href="https://linux.video/nextcloud-setup"><span class="url">https://linux.video/nextcloud-setup</span></a> </li>
</ul>
<h1 class="heading-1" id="_idParaDest-194">Further reading</h1>
<ul>
<li class="bulletList">NGINX documentation: <a href="https://nginx.org/en/docs/"><span class="url">https://nginx.org/en/docs/</span></a> </li>
<li class="bulletList">NGINX documentation from the Ubuntu community wiki: <a href="https://help.ubuntu.com/community/Nginx"><span class="url">https://help.ubuntu.com/community/Nginx</span></a></li>
<li class="bulletList">Apache HTTP server documentation: <a href="https://httpd.apache.org/docs/"><span class="url">https://httpd.apache.org/docs/</span></a> </li>
<li class="bulletList">Nextcloud administration manual: <a href="https://docs.nextcloud.com/server/latest/admin_manual/"><span class="url">https://docs.nextcloud.com/server/latest/admin_manual/</span></a> </li>
<li class="bulletList">Certbot instructions: <a href="https://certbot.eff.org/instructions"><span class="url">https://certbot.eff.org/instructions</span></a></li>
</ul>
<h1 class="heading-1">Join our community on Discord</h1>
<p class="normal">Join our community’s Discord space for discussions with the author and other readers: </p>
<p class="normal"><a href="https://packt.link/LWaZ0"><span class="url">https://packt.link/LWaZ0</span></a></p>
<p class="normal"><img alt="" height="177" src="../Images/QR_Code50046724-1955875156.png" width="177"/></p>
</div>
</div></body></html>