- en: '*Chapter 11*: Working with Variables'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`if` statements.'
  prefs: []
  type: TYPE_NORMAL
- en: 'We will cover the following recipes in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Using shell variables
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using variables in shell scripting
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Quoting in the shell
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Performing operations on variables
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Variables via external commands
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We are going to cover the most important things you need to know about variables,
    but as with almost everything else, this chapter will require you to practice.
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The machine you can use for these recipes is the same as in the previous chapters
    on scripting—basically, anything that can run bash is going to work. In our case,
    we are using a **virtual machine** (**VM**) with Linux and Ubuntu 20.10 installed.
  prefs: []
  type: TYPE_NORMAL
- en: So, start your VM, and let's get cracking!
  prefs: []
  type: TYPE_NORMAL
- en: Using shell variables
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Variables are something that you probably understand, even if only conceptually.
    We are not talking about programming here; our everyday life is full of variables.
    Basically, a variable is something that holds a value and that can provide us
    with that value once we need it.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In everyday language, we could say an activity such as driving is full of variables.
    This means that the weather temperature, the amount of ambient light, the quality
    of the road surface, and many other things are going to change as you move along.
    Even though they are changing all the time, it is important that at any given
    point, we are able to see what the actual *value* of the weather is, what is the
    actual value of the temperature, how much light we have, and how the road behaves
    or how it is structured.
  prefs: []
  type: TYPE_NORMAL
- en: This is what we mean by variables and looking variables up.
  prefs: []
  type: TYPE_NORMAL
- en: As soon as we establish what the weather is actually like, it stops being a
    variable since it has an actual value. Variables work the same way when we're
    talking about programming. What we do is we give a name to a space that we are
    going to use to store some value. In our code, we refer to this space to store
    and read values from it. Depending on the language, this *space* can *hold* different
    things, but right now, we just refer to the variable as something that can hold
    a value.
  prefs: []
  type: TYPE_NORMAL
- en: In `bash`, variables are a lot simpler than in many other languages, and they
    can basically hold two different types of values. One is a string; it can be any
    sequence of numbers and letters, and it can include special characters.
  prefs: []
  type: TYPE_NORMAL
- en: Another one is a number, and the only reason that there is a difference between
    those two types of variables is that some operators and some operations are different
    when we are dealing with strings or dealing with numbers.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When you start to work with variables, there are two things that you need to
    learn.
  prefs: []
  type: TYPE_NORMAL
- en: First, you need to know how to assign a value to a variable. This is usually
    called *assigning* a variable or *instancing* a variable. A variable has a name
    and a value. In `bash`, when we want to create a variable, we are simply going
    to choose a name and assign a value to it. After that, our shell knows that this
    is a variable, and it keeps track of the value or values we assign to it. Before
    we assign a value, a variable simply does not exist, and any reference to it will
    be invalid.
  prefs: []
  type: TYPE_NORMAL
- en: So, how do you choose a name for a variable?
  prefs: []
  type: TYPE_NORMAL
- en: Every variable has its own name, which is used to reference a variable inside
    the script or inside your working environment in the shell. The choice of name
    is completely up to you. The name should be something that you can easily remember
    and something that you will not confuse with other variables. A good choice is
    usually either something that identifies what purpose the variable has or a completely
    abstract name that will hint at what the meaning is of the variable.
  prefs: []
  type: TYPE_NORMAL
- en: One thing that you should always avoid using when naming variables are keywords,
    especially those that already have a meaning in `bash`. For example, we cannot
    use `continue` as a variable name since this is the name of a command. This will
    inevitably generate an error since the shell is going to get confused about what
    to do with the variable itself.
  prefs: []
  type: TYPE_NORMAL
- en: We mentioned environment variables. In an interactive shell, there are quite
    a few variables that are used to store information about your environment. This
    information describes different things that are required by different applications—things
    such as the username, your shell, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s do a few quick examples. We assign a variable exactly as we mentioned,
    by giving a value to a name. In our case, we are going to assign a `value` string
    value to a variable called `VAR1`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'That was easy. Now, let''s read from the variable we just created:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: As we can see, in order to read the variable, we need to prefix the variable
    name with the `$` character. Also, we need to use the same case in the variable
    name that we used when creating the variable itself, as names are case-sensitive.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we don''t do that, we are not going to get any useful value out of our `echo`
    command, but be very aware that neither of these examples gave us any errors:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: We made these errors on purpose to make a few small points. When using an `echo`
    command, we tell it to display a string. If the string contains a variable name,
    it has to be prefixed; otherwise, the `echo` command is just going to output it
    directly as it was written, without the variable value.
  prefs: []
  type: TYPE_NORMAL
- en: As we said, names are case-sensitive, but if we make a mistake, there won't
    be any errors displayed—we will simply get an empty line. This can be changed,
    and we will deal with this behavior later when we start using variables in scripts.
  prefs: []
  type: TYPE_NORMAL
- en: Let's now do something else—we'll try to use our variable in a script. Remember
    that we assigned a variable in the shell, but now, we are going to reference it
    in a script.
  prefs: []
  type: TYPE_NORMAL
- en: 'The script is going to be the simplest possible—create a file, name it `referencing.sh`,
    and enter the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'What happens when we run it? Let''s have a look:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: We see we have a problem. When we are reading the variable from the command
    line, everything is fine, but this variable does not exist inside our scripts.
    The reason is not as simple as it seems, though. We mentioned contexts and environment
    variables before. Each variable exists in the current environment and is not implicitly
    inherited by any command. When we start a script, we are actually creating a new
    environment and a new context that inherits all the variables that are marked
    as inheritable. Since we just assigned a value to our variable and didn't do anything
    else to it, this variable will remain visible only to our shell, and not to any
    commands or scripts that we run from it.
  prefs: []
  type: TYPE_NORMAL
- en: 'To fix this, we will need to *export* a variable. Exporting means flagging
    our variable to tell the environment that we want the value of the variable to
    be available to the commands and scripts that are running as its child processes.
    To do that, we need to use a command called `export`. The syntax couldn''t be
    simpler:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: As we can see, our script now knows the value of our variable, and it got inherited
    from the `bash` shell.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we just type in `export`, we will see a list of all the variables that are
    exported and available to our scripts:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.1 – Different exported variables exist for every user'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_11.1_B16269.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 11.1 – Different exported variables exist for every user
  prefs: []
  type: TYPE_NORMAL
- en: 'Notice one important thing: every line starts with the `declare -x` command,
    followed by a variable name and value. This points us to another extremely useful
    command: `declare`.'
  prefs: []
  type: TYPE_NORMAL
- en: When we are creating a variable and giving it a value, we are using only part
    of what can be done with variables in `bash`. Remember how we exported the variable?
    Variables have attributes that are additional information about how the variable
    should behave. Having a variable being exported is one of the attributes, but
    we can also make a variable read-only, change the variable name case, and even
    change the type of information that the variable holds. For all that, we use `declare`.
  prefs: []
  type: TYPE_NORMAL
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The only thing left to do is to give you more information about environment
    variables.
  prefs: []
  type: TYPE_NORMAL
- en: The environment can be, depending on your system and its configuration, huge.
    It contains a lot of things, and it is different from system to system because
    variables in the environment and their values are dependent on different programs
    and options installed on your particular system. For example, if you use a shell
    other than `bash`, you may have different variables specific to that shell. If
    you use `declare -p` or `env`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The difference between those two is very important. The `declare` statement
    is a `bash` built-in command. It will read every variable there is in the environment
    and show you all of them. `env`, on the other hand, is an application. It will
    run, create its own environment to run in, and then show you all the variables
    in that environment:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.2 – The environment can be checked at least two ways, but we usually
    use the env command'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_11.2_B16269.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 11.2 – The environment can be checked at least two ways, but we usually
    use the env command
  prefs: []
  type: TYPE_NORMAL
- en: 'We are going to mention some of those most important:'
  prefs: []
  type: TYPE_NORMAL
- en: '`USER`—Holds the username of the current user. This is extremely important
    if you need to check under which user the script is running. An alternative to
    this is to run the `whoami` command.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`PWD`—Holds the absolute path to the current directory. This is also important
    to any script since it can help you find which running directory the script was
    called from. An alternative to this command is `pwd`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`LOGNAME`—Provides the same information as `USER`, specifically the username
    of the logged-on user, hence the name.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`SHELL`—Contains the entire path to the current user''s login shell. This is
    not the same as the running shell; we can run any shell and work from it, and
    this variable returns what our login shell is set to. This value comes from the
    `/etc/passwd` file.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`SHLVL`—When you run your shell initially, you are one level into your environment.
    What this means is that there is nothing else running *above* your shell—or, to
    be more precise, your shell was started by your system directly. As you work,
    you can run other shells, scripts, and even shells inside shells. Each time you
    run a shell inside your shell, you increase your `SHLVL`. This is useful when
    trying to find out whether your script was run from another shell or directly
    by the system.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`PATH`—`PATH` contains a list of directories that your shell is going to look
    in when trying to find any command that you try to execute. Since almost everything
    on Linux is a command, this piece of information is crucial—if a certain path
    is not in the `PATH` variable, it won''t be searched, and commands from it can
    only be executed if you reference them directly. This is useful if you don''t
    want to reference commands directly all the time, or you have some reasons to
    prefer a command in one directory over another.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Before we go on to the next recipe, there is another way to get variables listed,
    and that is by using `set` without any parameter:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.3 – set not only shows you variables but is also capable of configuring
    the shell'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_11.3_B16269.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 11.3 – set not only shows you variables but is also capable of configuring
    the shell
  prefs: []
  type: TYPE_NORMAL
- en: 'Of course, since there is a lot of variables active at any given time, it is
    much better to use some sort of filtering:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.4 – The only way to quickly find things is to use grep'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_11.4_B16269.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 11.4 – The only way to quickly find things is to use grep
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We are going to give you just the place to start since this topic is massive:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://tldp.org/HOWTO/Bash-Prog-Intro-HOWTO-5.html](https://tldp.org/HOWTO/Bash-Prog-Intro-HOWTO-5.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://ryanstutorials.net/bash-scripting-tutorial/bash-variables.php](https://ryanstutorials.net/bash-scripting-tutorial/bash-variables.php)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using variables in shell scripting
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Variables sometimes look simple enough—they are there to enable you to put a
    changing value in your code. The problem is that in this simplicity, there are
    a couple of things you should know about where you actually place a variable—in
    something called a context. We are going to deal with that in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When we're talking about scripting, things are a little different than they
    are when we are working in an interactive environment. Every environment variable
    that is available to you when you use the interactive shell is also available
    to you in the script. There is, however, one important thing you must always remember.
    As we said earlier, your script is running in a certain context. This context
    is defined by the user that has run the script. In a previous chapter, we wanted
    you to make sure that you have appropriate permissions to do tasks that you need
    in the script.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, we are going to make sure you understand this also applies to
    variables. Unless we have explicitly set the variable in our script, we need to
    make sure that the one we got from the environment is something that we expect.
    Also, a lot of times, we will simply check if the variable is there in the first
    place since it may not be exported from the shell and will hence be invisible
    to us.
  prefs: []
  type: TYPE_NORMAL
- en: There is also a special class of variables that are set right at the moment
    the script is run and contain a certain amount of information very important to
    successfully running a script.
  prefs: []
  type: TYPE_NORMAL
- en: What we are going to do is to start with how the script interacts with the shell
    using variables.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We are, as always, going to start simple. First, we are going to do the most
    basic thing we can do—`Hello World`, but with variables:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: This is basically what we mentioned before but in a script. We have created
    a variable, assigned it a value, and then used that value to output text.
  prefs: []
  type: TYPE_NORMAL
- en: Now, let's try something more useful. When writing scripts, there are things
    that we need to calculate or prepare in some way so that we can use them in different
    parts of the script. Variables are a good way to do this clearly so that they
    can be reused in the code.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, we can create a string that will contain today''s date. We can
    then use a variable instead of running the appropriate command every time to create
    a date in a given format over and over again:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'After we run this one, the output is going to be interesting:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: We can see that the file was created correctly and that our date looks OK. What
    we didn't expect was the error. The reason for the error is simple—`tar` starts
    creating files by first creating an output file and then reading the directory
    it must archive. If the archive file is created in the directory it is trying
    to archive, this means that the `tar` command will try to run on the archive itself,
    creating this error. This is normal in these circumstances but try to avoid doing
    this archive loop. The solution is to archive to a place outside of the directory
    we are archiving.
  prefs: []
  type: TYPE_NORMAL
- en: Now for the fun part—passing arguments to your scripts. Up to this point, we
    have made scripts that were completely unaware of their surroundings. We need
    to change that since we need to be able to both pass information to our script
    and make our script report back what has happened.
  prefs: []
  type: TYPE_NORMAL
- en: Any script, regardless of the way it was executed, can have arguments. This
    is so common that we usually don't even think about it. Arguments are basically
    strings that come after the script name when we execute the script.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is precisely how arguments work in scripts—the shell takes whatever is
    in the command line that started the script and passes it along using a variable
    that has a number as the name. Here''s an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, here''s how we can run it in a few different ways:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'If we don''t give it any parameters, everything works as well as if we give
    it three parameters we expect:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'But let''s try to use more than three:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: We see a problem here. Variables that hold the parameter value are *positional*,
    and it is up to us to correctly reference everything in the parameter line. The
    way to do it is to read the number of `arguments` variable, and then create a
    loop of some kind to read the arguments.
  prefs: []
  type: TYPE_NORMAL
- en: 'You may be wondering: *What about $0?* Programmers tend to count from zero,
    not from one, and this is no exception—there is a variable called `$0` and it
    contains the name of the script itself. This is extremely convenient for scripting.
    We are creating a script called `parameters1.sh` and running it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'As we can see, this script could not be simpler. But in this simplicity is
    one neat trick:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: The point we are trying to make here is that the variable holds a value that
    contains not only the name of the script but also the entire path that was used
    to run the script. This can be used to determine how the script was run if we
    are running from `crontab` or another script.
  prefs: []
  type: TYPE_NORMAL
- en: To continue, we need to learn about a new concept—the `shift` statement.
  prefs: []
  type: TYPE_NORMAL
- en: There are two ways to parse arguments to a script—one is by using a loop that
    is going to run for `$#` iterations, which means that we are going to run for
    each argument that the script has once. This is a completely valid way, but there
    is also another, rather more elegant way to deal with this problem. `shift` is
    an in-built statement that enables you to parse your arguments one at a time without
    knowing how many of them there are.
  prefs: []
  type: TYPE_NORMAL
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The way shifting works is completely intuitive once you understand what it
    does. Let''s quote from the `help` page:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Basically, we only need to read the `$1` parameter and then invoke `shift`.
    The command is going to delete this parameter and shift all of them to the left,
    making the next one `$1`, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: 'This enables us to do these kinds of things:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'We need to explain a few things here. The reason we are using `shift` instead
    of a f`or` loop is that we are parsing arguments that can be different options.
    Our script has three possible switches: `-n` that can be written down as `—name`,
    `-s` that can also be used as `-surname`, and `-h` or `—help`. After the first
    two arguments, our script expects to have some string. If none of the arguments
    is used or we choose `-h`, our script is going to write a small reminder on the
    usage parameters.'
  prefs: []
  type: TYPE_NORMAL
- en: If you tried to do this in a `for` loop, you would have a problem—we would need
    to read the option, store it somewhere, read the `option` parameters in the next
    loop, and then loop again, trying to decide if what follows is an option or an
    argument.
  prefs: []
  type: TYPE_NORMAL
- en: By using `shift`, things are much simpler—we read an argument, and if we find
    any option we shift it; the parameters then become stored in `$1` and we can print
    and use them.
  prefs: []
  type: TYPE_NORMAL
- en: If we don't find an option, we simply ignore what is inside the variable.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The topic of using arguments is very complicated and is needed in almost every
    script. So, there are open source solutions for that, such as these:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://dev.to/unfor19/parsing-command-line-arguments-in-bash-3b51](https://dev.to/unfor19/parsing-command-line-arguments-in-bash-3b51)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://www.baeldung.com/linux/use-command-line-arguments-in-bash-script](https://www.baeldung.com/linux/use-command-line-arguments-in-bash-script)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Quoting in the shell
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Quotes are something that we take for granted, not only in Linux but also in
    a lot of other applications. In this recipe, we are going to deal with how quotes
    work, which quotes to use, and how to make sure that your quoted part of the script
    behaves as you intended.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Using quotes is incredibly important in Linux, not only in shell scripts but
    also in any other application that uses text. In this context, quotes behave pretty
    much the same way as brackets do in mathematical expressions—they offer us the
    way to change how an expression is evaluated. Almost all command-line tools use
    a space as a delimiter that tells the tool where one string ends and another one
    begins. You probably ran into this when you tried to use a file or a directory
    that has a space in its name. Usually, we solve this problem by using an escape
    character (`\`), but it makes it much easier to read if we apply quotes.
  prefs: []
  type: TYPE_NORMAL
- en: This is not the only reason we use quotes, so we are going to pay much more
    attention to them right now.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we must define different quotation symbols that we can use and outline
    what they mean:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Double quotation marks: `""""`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Used to quote strings and stop a shell from using a space as a delimiter. This
    quotation style will use shell expansion characters such as `$`, `` ` ``, `\`,
    and `!` as expansion characters, not quoting them but instead replacing them in
    the normal way. You will use this quotation style all the time.
  prefs: []
  type: TYPE_NORMAL
- en: 'Single quotation marks: `''`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: These behave almost exactly the same as double quotes, but with an important
    twist. Everything inside single quotation marks is treated *as is* and will not
    be changed in any way. Even if you use special characters, this will have no influence—they
    are going to be used as part of a string.
  prefs: []
  type: TYPE_NORMAL
- en: 'Backticks: ``"`"``'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The backtick character is sometimes considered a quote and often mistaken for
    a single quote.Note that this is a completely separate character—on a standard
    **United States** (**US**) keyboard, you can find it in the upper row, on the
    key left of the number *1* key, furthest to the left. The difference is in the
    slope of the character, so the name *backtick* really means that it is oriented
    differently than the quote character. In the shell, it is used to run a command—or,
    to be more precise, to run a command and then use its output in its place.
  prefs: []
  type: TYPE_NORMAL
- en: Even though backticks are not strictly quotes, in most learning materials you
    may find them mentioned as such. This is either because they look like quotes,
    or because they are the most probable character to get changed automatically to
    a quote in any text editor.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To understand quotes, we are going to make a few script examples, starting
    with a simple `if` statement, just to remind you what it looks like. We are going
    to create a file called `quotes1.sh` using this code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Once we run this, the results are as we expected:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let''s just make one small change in `quotes1.sh` and save it as `quotes2.sh`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'In this case, when we run the command, the result is going to be quite different.
    Since we used single quotes, the shell is not displaying our variable, and instead,
    we are seeing our actual variable name with its prefix:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'There is also a special case that we need to mention, and that is when we use
    double quotes inside single quotes and the other way around. In the case of double
    quotes being outside, they will negate the single quotes, so we get the usual
    expansion of variables. This time, create a file called `undeterdouble.sh` and
    get this code typed into it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'When we run it, we get this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Notice that the shell inserted another set of quotes to separate the variable
    value and the rest of the string.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we turn it the other way around, we are going to end up with everything
    being quoted, since the single quotes mean just that:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Notice there are no additional quotes in the string:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The shell needs to know when to expand variables and when not to do this. Spaces
    are also a big problem in scripting—more often than not, your script is going
    to completely miss some part of the string because it will cut it up into single
    words divided by spaces.
  prefs: []
  type: TYPE_NORMAL
- en: Both quotes have their uses, but you are going to be using double quotes most
    of the time. The reason is that you will usually have a string with spaces but
    also with different variables in it. By using double quotes, you will have your
    variables expanded while keeping the text.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'When it comes to single and double quotes, there are only a couple of resources
    since they are straightforward:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://bash.cyberciti.biz/guide/Quoting](https://bash.cyberciti.biz/guide/Quoting)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://www.gnu.org/software/bash/manual/html_node/Quoting.html](https://www.gnu.org/software/bash/manual/html_node/Quoting.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Performing operations on variables
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Variables are great since they can hold any value that we can think of. Often,
    we need more than just holding a value inside a variable. In this recipe, we are
    going to deal with a lot of different things that we can do to a variable, sometimes
    changing it and sometimes completely replacing it.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In order to be able to change variables, you will need to understand one simple
    concept. `bash` cannot change the variable itself; we are going to mention this
    a little later, but if you need to change something in a variable, you will have
    to reassign it.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There is a lot of things that can be done to a variable. Sometimes, we want
    to know more about what it contains; sometimes, we need to change something in
    order to use it later; or, we may simply want to know if the variable even has
    a value.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, we are going to use the command line a lot since it makes explaining
    things much easier.
  prefs: []
  type: TYPE_NORMAL
- en: 'Before we begin, we are going to introduce one thing we haven''t mentioned
    yet: arrays.'
  prefs: []
  type: TYPE_NORMAL
- en: An array is a variable that holds separate strings divided by spaces. You could
    say it's a string itself, but for a lot of reasons to do with flexibility, `bash`
    is able to address different parts of the array individually, keeping the values
    in one variable.
  prefs: []
  type: TYPE_NORMAL
- en: 'We are going to define an array that will have four strings in it. The way
    to define a variable is by using brackets and enclosing strings inside them:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: Now, we can see how many elements there are in our array. This is where things
    get a little strange. Remember when we said that counting in `bash` starts at
    zero?
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: We see that we got the right information—our array has exactly four elements.
    The way we got this was by using curly brackets together with some special characters.
    Our expression starts with `$ {`, which tells `bash` that we are going to do something
    with an array. Then comes the `#` sign, which means that we are expecting a count
    of something, either the length or number of elements. After that, we have our
    array name followed by square brackets and the `@` sign inside brackets. In shell
    syntax, this tells `bash` that we want all elements in the array.
  prefs: []
  type: TYPE_NORMAL
- en: 'Translated into plain English, this command says: show me the count of how
    many elements there are in the `TestArray` array.'
  prefs: []
  type: TYPE_NORMAL
- en: 'But beware—things are extremely sensitive when it comes to syntax. For example,
    if you omit the `[@]` part, this is a completely valid command, but it gives you
    also completely different information:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'The number we get is actually the length of the first string in the array,
    not the array itself. This is because if we try to just use the array name, we
    are going to get only the first string as a result:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'To avoid this, we should always use square brackets and a number inside them.
    This is the right way of referencing the positions of strings in our array. Have
    in mind that the first string has an index of `0`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that we have seen how to reference arrays and their parts, let''s see if
    a variable even exists and what is the way to check its length. We already know
    how to do that—we just need to use `${#variablename}` to have the shell output
    the length:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: As we can see, since we put a string in the quotes, our variable contains all
    the spaces and characters in a single string. The length is then correctly calculated.
  prefs: []
  type: TYPE_NORMAL
- en: What about checking if a variable exists by looking at its length?
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: The length is in this particular case `0`. If you are not used to this kind
    of calculation, you will probably expect not to get a valid number but to have
    the shell report that the variable is not defined, but `bash` does it differently.
  prefs: []
  type: TYPE_NORMAL
- en: 'The next thing we can do is do substitutions of variables. An extremely useful
    thing is being able to check if a variable has a value, and if it doesn''t have
    a value, just substitute another value in its place. In other words, before you
    use a variable, always make sure it has a value since `bash` is by default going
    to return an empty result if the variable is not defined. Here''s an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: What we are doing here is testing if the `TEST` variable has a value. If not,
    we are going to output `empty` as a string. As soon as our variable is set, the
    output is going to revert to the value of the variable.
  prefs: []
  type: TYPE_NORMAL
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The things we have mentioned up to now were simple substitutions of a whole
    variable. What is much more common is having to change something inside a variable.
    This can be done using a special syntax. What we can do is extract strings from
    our variable. This is not going to change the variable itself; instead, we need
    to save this string into another variable if we need it for something later. The
    syntax we are going to use is shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: '`VAR` is the variable name. `OFFSET` and `LENGTH` are self-explanatory—they
    basically mean *take this many characters starting from this exact position*.
    The easiest way to explain this functionality is to show you a couple of examples:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: Notice that we can also use negative numbers. If we do that, we are going to
    get the part of the string from the given offset up to the last *X* characters,
    *X* being the negative number we used.
  prefs: []
  type: TYPE_NORMAL
- en: 'The last thing we wanted to show you is replacing patterns in variables. For
    that, we use this syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'The same things apply as when we talked about extracting parts of the variable—we
    are not changing the variable itself, we are just modifying the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Variable operations contain a lot more possibilities. Check them out here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://tldp.org/LDP/Bash-Beginners-Guide/html/sect_10_03.html](https://tldp.org/LDP/Bash-Beginners-Guide/html/sect_10_03.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://opensource.com/article/18/5/you-dont-know-bash-intro-bash-arrays](https://opensource.com/article/18/5/you-dont-know-bash-intro-bash-arrays)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Variables via external commands
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Sometimes, while writing a script, you will have to run a certain command and
    then use its output to do something in your script. A complicated way to do that
    is by using redirection. We say *complicated* because once you have to use redirection,
    you are unable to use it for other things. You could redirect to different file
    descriptors, but that is going to complicate things even more.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You will soon notice that it is hard to separate different things related to
    shell commands and functions. The reason for this is that there are a few fundamental
    rules that then get repeated in a different way. We are going to mention some
    of them a few times through this book, not because we like redundancy but because
    you need to completely understand those rules to be able to write good scripts.
  prefs: []
  type: TYPE_NORMAL
- en: This is why shell expansion exists, and there are two ways to put it into action
    to accomplish our task.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'There are two syntaxes we can use for this. One is by enclosing the command
    with all its parameters into backticks, like this: `command`. Another is by using
    `$(command)`. Both have the same result—whatever is the output of the command
    is going to get translated into a group of strings and used instead of the original
    command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'This was just to show you how this sort of expansion behaves. Using a single
    `echo` command makes no sense; we are going to try with something more complicated:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'What we are doing is getting a list of files from the current directory, and
    then using this list to try different extensions. This way of working with files
    is the most common thing you will use in your scripts. When iterating like this,
    there are going to be either files or lines in the file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'This shell capability is amazing but it has its own limitations, the main one
    being that the output of the command inside brackets has to be *clean*. By cleanliness,
    we mean that it has to contain only the information that can be directly used
    as parameters. Consider this minuscule change in our script:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'We changed two characters in the `ls` command by adding `-l` to make it output
    in a long format. If we now run it, this is not even remotely what we expected:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: We stopped the output here.
  prefs: []
  type: TYPE_NORMAL
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This way of getting information from one command is probably one of the simplest
    things to understand in entire `bash` scripting. What the shell does is execute
    the command, get its output, and then behave as if it is a long list of separate
    strings using a space as a separator.
  prefs: []
  type: TYPE_NORMAL
- en: This is also the reason why we have to pay special attention to what is going
    to be the output of the application. The shell is unable to *understand* what
    we want out of it; it simply parses whatever it sees and treats spaces as separators.
    What will happen then rests entirely on you—the command that you embedded this
    expression in can treat the end result completely differently.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[https://tldp.org/HOWTO/Bash-Prompt-HOWTO/x279.html](https://tldp.org/HOWTO/Bash-Prompt-HOWTO/x279.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[http://www.compciv.org/topics/bash/variables-and-substitution/](http://www.compciv.org/topics/bash/variables-and-substitution/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
