- en: 8\. Using the Bash Shell on CentOS 8
  id: totrans-0
  prefs: []
  type: TYPE_NORMAL
- en: An important part of learning to work with CentOS 8, and Linux distributions
    in general, involves gaining proficiency in working in the shell environment.
    While the graphical desktop environments such as GNOME included with Linux provide
    a user friendly interface to the operating system, in practice the shell environment
    provides far greater capabilities, flexibility and automation than can ever be
    achieved using graphical desktop tools. The shell environment also provides a
    means for interacting with the operating system when a desktop environment is
    not available; a common occurrence when working with a server-based operating
    system such as CentOS 8 or a damaged system that will not fully boot.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
- en: The goal of this chapter, therefore, is to provide an overview of the default
    shell environment on CentOS 8 (specifically the Bash shell).
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
- en: 8.1 What is a Shell?
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
- en: The shell is an interactive command interpreter environment within which commands
    may be typed at a prompt or entered into a file in the form of a script and executed.
    The origins of the shell can be traced back to the early days of the UNIX operating
    system. In fact, in the early days of Linux before the introduction of graphical
    desktops the shell was the only way for a user to interact with the operating
    system.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
- en: A variety of shell environments have been developed over the years. The first
    widely used shell was the Bourne shell, written by Stephen Bourne at Bell Labs.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
- en: Yet another early creation was the C shell which shared some syntax similarities
    with the C Programming Language and introduced usability enhancements such as
    command-line editing and history.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
- en: The Korn shell (developed by David Korn at Bell Labs) is based on features provided
    by both the Bourne shell and the C shell.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
- en: The default shell on CentOS 8 is the Bash shell (shorthand for Bourne Again
    SHell). This shell, which began life as an open source version of the Bourne shell,
    was developed for the GNU Project by Brian Fox and is based on features provided
    by both the Bourne shell and the C shell.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
- en: 8.2 Gaining Access to the Shell
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
- en: From within the GNOME desktop environment, the shell prompt may be accessed
    from a Terminal window by selecting the Activities option in the top bar, entering
    Terminal into the search bar and clicking on the Terminal icon.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
- en: When remotely logging into a CentOS 8 server, for example using SSH, the user
    is also presented with a shell prompt. Details on accessing a remote server using
    SSH will be covered in the chapter entitled [“Configuring SSH Key-based Authentication
    on CentOS 8”](../Text/SSH_Authentication.xhtml#_idTextAnchor181). When booting
    a server-based system in which a desktop environment has not been installed, the
    shell is entered immediately after the user completes the login procedure at the
    physical console terminal or remote login session.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
- en: 8.3 Entering Commands at the Prompt
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
- en: 'Commands are entered at the shell command prompt simply by typing the command
    and pressing the Enter key. While some commands perform tasks silently, most will
    display some form of output before returning to the prompt. For example, the ls
    command can be used to display the files and directories in the current working
    directory:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
- en: $ ls
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
- en: Desktop Documents Downloads Music Pictures Public Templates Videos
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
- en: 'The available commands are either built into the shell itself, or reside on
    the physical file system. The location on the file system of a command may be
    identified using the which command. For example, to find out where the ls executable
    resides on the file system:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
- en: $ which ls
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
- en: alias ls=’ls --color=auto’
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
- en: /usr/bin/ls
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
- en: 'Clearly the ls command resides in the /usr/bin directory. Note also that an
    alias is configured, a topic which will be covered later in this chapter. Using
    the which command to locate the path to commands that are built into the shell
    will result in a message indicating the executable cannot be found. For example,
    attempting to find the location of the history command (which is actually built
    into the shell rather than existing as an executable on the file system) will
    result in output similar to the following:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
- en: $ which history
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
- en: '/usr/bin/which: no history in (/home/demo/.local/bin:/home/demo/bin:/usr/share/Modules/bin:/usr/local/bin:/usr/bin:/usr/local/sbin:/usr/sbin)'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
- en: 8.4 Getting Information about a Command
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
- en: 'Many of the commands available to the Linux shell can seem cryptic to begin
    with. To find out detailed information about what a command does and how to use
    it, use the man command specifying the name of the command as an argument. For
    example, to learn more about the pwd command:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
- en: $ man pwd
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
- en: 'When the above command is executed, a detailed description of the pwd command
    will be displayed. Many commands will also provide additional information when
    run with the --help command-line option:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
- en: $ wc --help
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
- en: 8.5 Bash Command-line Editing
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
- en: 'Early shell environments did not provide any form of line editing capabilities.
    This meant that if you spotted an error at the beginning of a long command-line
    you were typing, you had to delete all the following characters, correct the error
    and then re-enter the remainder of the command. Fortunately Bash provides a wide
    range of command-line editing options as outlined in the following table:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
- en: '| Key Sequence | Action |'
  id: totrans-30
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  id: totrans-31
  prefs: []
  type: TYPE_TB
- en: '| Ctrl-b or Left Arrow | Move cursor back one position |'
  id: totrans-32
  prefs: []
  type: TYPE_TB
- en: '| Ctrl-f or Right Arrow | Move cursor forward one position |'
  id: totrans-33
  prefs: []
  type: TYPE_TB
- en: '| Delete | Delete character currently beneath the cursor |'
  id: totrans-34
  prefs: []
  type: TYPE_TB
- en: '| Backspace | Delete character to the left of the cursor |'
  id: totrans-35
  prefs: []
  type: TYPE_TB
- en: '| Ctrl-_ | Undo previous change (can be repeated to undo all previous changes)
    |'
  id: totrans-36
  prefs: []
  type: TYPE_TB
- en: '| Ctrl-a | Move cursor to the start of the line |'
  id: totrans-37
  prefs: []
  type: TYPE_TB
- en: '| Ctrl-e | Move cursor to the end of the line |'
  id: totrans-38
  prefs: []
  type: TYPE_TB
- en: '| Meta-f or Esc then f | Move cursor forward one word |'
  id: totrans-39
  prefs: []
  type: TYPE_TB
- en: '| Meta-b or Esc then b | Move cursor back one word |'
  id: totrans-40
  prefs: []
  type: TYPE_TB
- en: '| Ctrl-l | Clear the screen of everything except current command |'
  id: totrans-41
  prefs: []
  type: TYPE_TB
- en: '| Ctrl-k | Delete to end of line from current cursor position |'
  id: totrans-42
  prefs: []
  type: TYPE_TB
- en: '| Meta-d or Esc then d | Delete to end of current word |'
  id: totrans-43
  prefs: []
  type: TYPE_TB
- en: '| Meta-DEL or Esc then DEL | Delete beginning to current word |'
  id: totrans-44
  prefs: []
  type: TYPE_TB
- en: '| Ctrl-w | Delete from current cursor position to previous white space |'
  id: totrans-45
  prefs: []
  type: TYPE_TB
- en: Table 8-1
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
- en: 8.6 Working with the Shell History
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
- en: 'In addition to command-line editing features, the Bash shell also provides
    command-line history support. A list of previously executed commands may be viewed
    using the history command:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
- en: $ history
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
- en: 1 ps
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
- en: 2 ls
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
- en: 3 ls –l /
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
- en: 4 ls
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
- en: 5 man pwd
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
- en: 6 man apropos
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
- en: In addition, Ctrl-p (or up arrow) and Ctrl-n (or down arrow) may be used to
    scroll back and forth through previously entered commands. When the desired command
    from the history is displayed, press the Enter key to execute it.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
- en: Another option is to enter the ‘!’ character followed by the first few characters
    of the command to be repeated followed by the Enter key.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
- en: 8.7 Filename Shorthand
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
- en: 'Many shell commands take one or more filenames as arguments. For example, to
    display the content of a text file named list.txt, the cat command would be used
    as follows:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
- en: $ cat list.txt
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
- en: 'Similarly, the content of multiple text files could be displayed by specifying
    all the file names as arguments:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
- en: $ cat list.txt list2.txt list3.txt list4.txt
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
- en: 'Instead of typing in each name, pattern matching can be used to specify all
    files with names matching certain criteria. For example, the ‘*’ wildcard character
    can be used to simplify the above example:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
- en: $ cat *.txt
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
- en: 'The above command will display the content of all files ending with a .txt
    extension. This could be further restricted to any file names beginning with list
    and ending in .txt:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
- en: $ cat list*.txt
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
- en: 'Single character matches may be specified using the ‘?’ character:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
- en: $ cat list?.txt
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
- en: 8.8 Filename and Path Completion
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
- en: Rather than typing in an entire file name or path, or using pattern matching
    to reduce the amount of typing, the shell provides the filename completion feature.
    In order to use filename completion, simply enter the first few characters of
    the file or path name and then press the Esc key twice. The shell will then complete
    the filename for you with the first file or path name in the directory that matches
    the characters you entered. To obtain a list of possible matches, press Esc =
    after entering the first few characters.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
- en: 8.9 Input and Output Redirection
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
- en: As previously mentioned, many shell commands output information when executed.
    By default this output goes to a device file called stdout which is essentially
    the terminal window or console in which the shell is running. Conversely, the
    shell takes input from a device file named stdin, which by default is the keyboard.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
- en: 'Output from a command can be redirected from stdout to a physical file on the
    file system using the ‘>’ character. For example, to redirect the output from
    an ls command to a file named files.txt, the following command would be required:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
- en: $ ls *.txt > files.txt
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
- en: 'Upon completion, files.txt will contain the list of files in the current directory.
    Similarly, the contents of a file may be fed into a command in place of stdin.
    For example, to redirect the contents of a file as input to a command:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
- en: $ wc –l < files.txt
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
- en: The above command will display the number of lines contained in the files.txt
    file.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
- en: 'It is important to note that the ‘>’ redirection operator creates a new file,
    or truncates an existing file when used. In order to append to an existing file,
    use the ‘>>’ operator:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
- en: $ ls *.dat >> files.txt
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
- en: 'In addition to standard output, the shell also provides standard error output
    using stderr. While output from a command is directed to stdout, any error messages
    generated by the command are directed to stderr. This means that if stdout is
    directed to a file, error messages will still appear in the terminal. This is
    generally the desired behavior, though stderr may also be redirected if desired
    using the ‘2>’ operator:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
- en: $ ls dkjfnvkjdnf 2> errormsg
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
- en: On completion of the command, an error reporting the fact that the file named
    dkjfnvkjdnf could not be found will be contained in the errormsg file.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
- en: 'Both stderr and stdout may be redirected to the same file using the &> operator:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
- en: $ ls /etc dkjfnvkjdnf &> alloutput
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
- en: On completion of execution, the alloutput file will contain both a listing of
    the contents of the /etc directory, and the error message associated with the
    attempt to list a non-existent file.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
- en: 8.10 Working with Pipes in the Bash Shell
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
- en: 'In addition to I/O redirection, the shell also allows output from one command
    to be piped directly as input to another command. A pipe operation is achieved
    by placing the ‘|’ character between two or more commands on a command-line. For
    example, to count the number of processes running on a system, the output from
    the ps command can be piped through to the wc command:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
- en: $ ps –ef | wc –l
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
- en: 'There is no limit to the number of pipe operations that can be performed on
    a command-line. For example, to find the number of lines in a file which contain
    the name Smith:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
- en: $ cat namesfile | grep Smith | wc –l
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
- en: 8.11 Configuring Aliases
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
- en: 'As you gain proficiency with the shell environment it is likely that you will
    find yourself frequently issuing commands with the same arguments. For example,
    you may often use the ls command with the l and t options:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
- en: $ ls –lt
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
- en: 'To reduce the amount of typing involved in issuing a command, it is possible
    to create an alias that maps to the command and arguments. For example, to create
    an alias such that entering the letter l will cause the ls –lt command to be executed,
    the following statement would be used:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
- en: $ alias l="ls –lt"
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
- en: Entering l at the command prompt will now execute the original statement.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
- en: 8.12 Environment Variables
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
- en: 'Shell environment variables provide temporary storage of data and configuration
    settings. The shell itself sets up a number of environment variables that may
    be changed by the user to modify the behavior of the shell. A listing of currently
    defined variables may be obtained using the env command:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
- en: $ env
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
- en: SSH_CONNECTION=192.168.0.19 61231 192.168.0.28 22
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
- en: MODULES_RUN_QUARANTINE=LD_LIBRARY_PATH
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
- en: LANG=en_US.UTF-8
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
- en: HISTCONTROL=ignoredups
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
- en: HOSTNAME=-pc.ebookfrenzy.com
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
- en: XDG_SESSION_ID=15
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
- en: MODULES_CMD=/usr/share/Modules/libexec/modulecmd.tcl
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
- en: USER=demo
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
- en: ENV=/usr/share/Modules/init/profile.sh
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
- en: SELINUX_ROLE_REQUESTED=
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
- en: PWD=/home/demo
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
- en: HOME=/home/demo
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
- en: SSH_CLIENT=192.168.0.19 61231 22
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
- en: SELINUX_LEVEL_REQUESTED=
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
- en: .
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
- en: .
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
- en: .
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
- en: 'Perhaps the most useful environment variable is PATH. This defines the directories
    in which the shell will search for commands entered at the command prompt, and
    the order in which it will do so. The PATH environment variable for a user account
    on a newly installed CentOS 8 system will likely be configured as follows:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
- en: $ echo $PATH
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
- en: /home/demo/.local/bin:/home/demo/bin:/usr/share/Modules/bin:/usr/local/bin:/usr/bin:/usr/local/sbin:/usr/sbin
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
- en: 'Another useful variable is HOME which specifies the home directory of the current
    user. If, for example, you wanted the shell to also look for commands in the scripts
    directory located in your home directory, you would modify the PATH variable as
    follows:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
- en: $ export PATH=$PATH:$HOME/scripts
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
- en: 'The current value of an existing environment variable may be displayed using
    the echo command:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
- en: $ echo $PATH
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
- en: 'You can create your own environment variables using the export command. For
    example:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
- en: $ export DATAPATH=/data/files
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
- en: 'A useful trick to assign the output from a command to an environment variable
    involves the use of back quotes (`) around the command. For example, to assign
    the current date and time to an environment variable called NOW:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
- en: $ export NOW=`date`
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
- en: $ echo $NOW
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
- en: Tue Apr 2 13:48:40 EDT 2019
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
- en: 'If there are environment variable or alias settings that you need to be configured
    each time you enter the shell environment, they may be added to a file in your
    home directory named .bashrc. For example, the following example .bashrc file
    is configured to set up the DATAPATH environment variable and an alias:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
- en: .bashrc
  id: totrans-131
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Source global definitions
  id: totrans-132
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: if [ -f /etc/bashrc ]; then
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
- en: . /etc/bashrc
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
- en: fi
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
- en: User specific environment
  id: totrans-136
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: PATH="$HOME/.local/bin:$HOME/bin:$PATH"
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
- en: export PATH
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
- en: 'Uncomment the following line if you don''t like systemctl''s auto-paging feature:'
  id: totrans-139
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: export SYSTEMD_PAGER=
  id: totrans-140
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: User specific aliases and functions
  id: totrans-141
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: export DATAPATH=/data/files
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
- en: alias l="ls -lt"
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
- en: 8.13 Writing Shell Scripts
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
- en: So far we have focused exclusively on the interactive nature of the Bash shell.
    By interactive we mean manually entering commands at the prompt one by one and
    executing them. In fact, this is only a small part of what the shell is capable
    of. Arguably one of the most powerful aspects of the shell involves the ability
    to create shell scripts. Shell scripts are essentially text files containing sequences
    of statements that can be executed within the shell environment to perform tasks.
    In addition to the ability to execute commands, the shell provides many of the
    programming constructs such as for and do loops and if statements that you might
    reasonably expect to find in a scripting language.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
- en: Unfortunately a detailed overview of shell scripting is beyond the scope of
    this chapter. There are, however, many books and web resources dedicated to shell
    scripting that do the subject much more justice than we could ever hope to achieve
    here. In this section, therefore, we will only be providing a very small taste
    of shell scripting.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
- en: 'The first step in creating a shell script is to create a file (for the purposes
    of this example we name it simple.sh) and add the following as the first line:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
- en: '#!/bin/sh'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
- en: 'The #! is called the “shebang” and is a special sequence of characters indicating
    that the path to the interpreter needed to execute the script is the next item
    on the line (in this case the sh executable located in /bin). This could equally
    be, for example, /bin/csh or /bin/ksh if either were the interpreter you wanted
    to use.'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
- en: 'The next step is to write a simple script:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
- en: '#!/bin/sh'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
- en: for i in *
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
- en: do
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
- en: echo $i
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
- en: done
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
- en: 'All this script does is iterate through all the files in the current directory
    and display the name of each file. This may be executed by passing the name of
    the script through as an argument to sh:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
- en: $ sh simple.sh
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to make the file executable (thereby negating the need to pass it
    through to the sh command) the chmod command can be used:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
- en: $ chmod +x simple.sh
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
- en: 'Once the execute bit has been set on the file’s permissions, it may be executed
    directly. For example:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
- en: $ ./simple.sh
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
- en: 8.14 Summary
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter of CentOS 8 Essentials we have taken a brief tour of the Bash
    shell environment. In the world of graphical desktop environments it is easy to
    forget that the true power and flexibility of an operating system can often only
    be utilized by dropping down below the user friendly desktop interface and using
    a shell environment. Moreover, familiarity with the shell is a necessity when
    required to administer and maintain server-based systems that do not have the
    desktop installed or when attempting to repair a system that is damaged to the
    point that the desktop or Cockpit interface will no longer launch.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
- en: The capabilities of the shell go far beyond the areas covered in this chapter.
    If you are new to the shell then we strongly encourage you to seek out additional
    resources. Once familiar with the concepts you will quickly find that it is quicker
    to perform many tasks using the shell in a terminal window than it is to wade
    through menus and dialogs on the desktop.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: Shell 的能力远远超出了本章涵盖的范围。如果你是 Shell 的新手，我们强烈建议你寻找额外的资源。一旦熟悉了这些概念，你会很快发现，在终端窗口中使用
    Shell 来执行许多任务比在桌面上浏览菜单和对话框要快得多。
