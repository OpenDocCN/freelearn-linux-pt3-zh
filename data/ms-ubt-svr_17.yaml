- en: '17'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '17'
- en: Running Containers
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 运行容器
- en: 'The IT industry never ceases to amaze me. Back when the concept of virtualization
    came about, it revolutionized the data center. Virtualization allowed us to run
    many small **Virtual Machines** (**VMs**) on one server, effectively allowing
    us to consolidate the equipment in our server racks. And just when we thought
    it couldn’t get any better, the concept of containerization took the IT world
    by storm, allowing us to build portable instances of our software that not only
    improved how we deploy applications but also changed the way we develop them.
    In this chapter, we will cover the exciting world of containerization. This exploration
    will include:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 信息技术行业总是让我感到惊讶。当虚拟化的概念出现时，它彻底改变了数据中心。虚拟化使我们能够在一台服务器上运行许多小型**虚拟机**（**VMs**），有效地将我们的服务器机架中的设备进行整合。就在我们以为这已经是极限时，容器化的概念掀起了IT界的风暴，允许我们构建便捷的、可移植的软件实例，这不仅改善了我们部署应用程序的方式，还改变了我们开发应用程序的方式。在这一章中，我们将探索令人兴奋的容器化世界。这个探索将包括：
- en: What is containerization?
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 什么是容器化？
- en: Understanding the differences between Docker and LXD
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解 Docker 和 LXD 之间的区别
- en: Installing Docker
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 安装 Docker
- en: Managing Docker containers
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 管理 Docker 容器
- en: Automating Docker image creation with Dockerfiles
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Dockerfile 自动创建 Docker 镜像
- en: Managing LXD containers
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 管理 LXD 容器
- en: To begin, let’s explore what containerization is, how it differs from virtualization,
    and some considerations around how this technology might be implemented.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们探索容器化是什么，它与虚拟化有何不同，以及如何实施这项技术的一些注意事项。
- en: What is containerization?
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 什么是容器化？
- en: In the last chapter, we covered virtualization. Virtualization allows us to
    run multiple *virtual* servers on one physical piece of hardware. We allocate
    CPU, RAM, and disk space to these VMs, and they run as if they were real servers.
    In fact, for all intents and purposes, a VM is a real server.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们介绍了虚拟化。虚拟化允许我们在一台物理硬件上运行多个*虚拟*服务器。我们将 CPU、RAM 和磁盘空间分配给这些虚拟机，它们的运行方式就像是实际的服务器。实际上，从所有实用角度来看，虚拟机就是一台真实的服务器。
- en: However, there are also weaknesses with VMs. Perhaps the most glaringly obvious
    is the fact that at least some of the resources you allocate to a VM are likely
    being wasted. For example, perhaps you’ve allocated 512 MB of RAM to a VM. What
    if the application only rarely uses more than 100 MB of RAM? That means most of
    the time, 412 MB of RAM that could otherwise be used for a useful purpose is just
    sitting idle. The same can be said of CPU usage. Nowadays, VM solutions do have
    ways of sharing unused resources, but effectively, resource efficiency is a natural
    weakness of the platform.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，虚拟机也有一些弱点。或许最明显的问题是，您分配给虚拟机的某些资源可能会被浪费。例如，假设您为虚拟机分配了 512 MB 的 RAM。如果该应用程序很少使用超过
    100 MB 的内存，那么意味着大多数时候，剩余的 412 MB 内存可以用来做其他事情，但它却处于空闲状态。CPU 使用率也可以说是类似的情况。如今，虚拟机解决方案确实有共享未使用资源的方法，但从根本上讲，资源效率是该平台的一个天然弱点。
- en: Containers, unlike VMs, are not actual servers. At least, not in the way you
    typically think about them (in terms of hardware). While VMs typically have one
    or more virtualized CPUs, containers share the CPU with the host. VMs also have
    their own kernel, but containers share the kernel of the host. Containers are
    still segregated, though. Just as a VM cannot access the host filesystem, a container
    can’t either (unless you explicitly set it up to do so).
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 与虚拟机不同，容器并不是真正的服务器。至少，从硬件角度来说，它们并不像你通常认为的那样。虚拟机通常有一个或多个虚拟化的 CPU，而容器与宿主共享 CPU。虚拟机还有自己的内核，而容器则共享宿主的内核。尽管如此，容器仍然是隔离的。就像虚拟机无法访问宿主的文件系统一样，容器也不能访问（除非你明确设置允许访问）。
- en: What is a container, then? It’s probably best to think of a container as a filesystem
    rather than a VM. The container itself contains a file structure that matches
    that of the distribution it’s based on. A container based on Ubuntu Server, for
    example, will have the same filesystem layout as a real Ubuntu Server installation
    on a VM or physical hardware. Imagine copying all the files and folders from an
    Ubuntu installation, putting them all in a single segregated directory, and having
    the binary contents of the filesystem executed as a program, without an actual
    operating system running.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，什么是容器呢？最好将容器看作是一个文件系统，而不是虚拟机。容器本身包含一个与其所基于的发行版匹配的文件结构。例如，一个基于Ubuntu Server的容器，将具有与在虚拟机或物理硬件上安装的真正Ubuntu
    Server相同的文件系统布局。想象一下，将所有Ubuntu安装的文件和文件夹复制过来，放入一个单独的隔离目录中，然后执行文件系统的二进制内容作为一个程序，而没有实际运行操作系统。
- en: To be fair, that description was an oversimplification of how containers actually
    run on an Ubuntu server, as the technology utilizes the functionality of the Linux
    kernel to isolate various components of a container from the rest of the system.
    However, a full discussion of those technologies is beyond the scope of this book.
    But understanding that such isolation exists within containers is something you
    should keep in mind, as keeping processes that are running within a container
    separate from other processes running on the host server is an important benefit.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 公平地说，这种描述是对容器在Ubuntu服务器上实际运行方式的过度简化，因为该技术利用Linux内核的功能来隔离容器的各个组件与系统其他部分。然而，关于这些技术的详细讨论超出了本书的范围。但理解容器内存在这样的隔离性是你需要记住的事情，因为将容器内运行的进程与主机服务器上运行的其他进程分开是一个重要的优势。
- en: Portability is another strength of **containerization**. With a container, you
    can literally pass it around to various members of your development team, and
    then push the container into production when everyone agrees that it’s ready.
    The container itself will run exactly the same on each workstation, regardless
    of which operating system the workstation uses. To be fair, you can export and
    import VMs on any number of hosts, but containers make this process extremely
    easy. In fact, portability is at the core of the design of this technology.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: '**容器化**的另一个优势是便捷性。通过容器，你可以把它传给你开发团队的其他成员，然后当每个人都同意它已经准备好时，就可以将容器推向生产环境。容器本身将在每个工作站上以完全相同的方式运行，无论工作站使用的是哪个操作系统。公平地说，你可以在任何数量的主机上导入和导出虚拟机，但容器让这个过程变得极其简单。事实上，便捷性是该技术设计的核心。'
- en: The concept of containerization is not necessarily new. When Docker hit the
    scene, it took the IT world by storm, but it was by no means the first solution
    to offer containerization. LXC, and other technologies, predate it. It was, however,
    a clever marketing tactic with a cool-sounding brand that launched containerization
    into mainstream popularity. By no means am I saying that Docker is all hype, though.
    It’s an awesome technology with many benefits. It’s definitely worth using, and
    you may even find yourself preferring it to VMs.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 容器化的概念并不一定是新的。当Docker出现时，它让IT界为之震动，但它并不是第一个提供容器化的解决方案。LXC和其他技术比它更早出现。然而，它的确是一种聪明的营销策略，凭借一个听起来很酷的品牌，使得容器化成为了主流的流行趋势。不过，我并不是说Docker全是炒作，它是一项很棒的技术，具有许多优点。它绝对值得使用，甚至你可能会发现自己更喜欢它而不是虚拟机。
- en: The main difference with containerization is that each container generally does
    one thing. For example, perhaps a container holds a hosted website or contains
    a single application. VMs are often created to do many tasks, such as a web server
    that hosts ten websites. Containers, on the other hand, are generally used for
    one task each, though depending on the implementation you may see others going
    against this norm.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 容器化的主要区别在于，每个容器通常只做一件事。例如，一个容器可能承载一个网站，或者包含一个单一的应用程序。虚拟机通常用于完成多项任务，比如一个托管十个网站的web服务器。而容器则一般用于完成一项任务，尽管根据不同的实现方式，你可能会看到一些容器打破这一常规。
- en: When should you use containers? I recommend you consider containers any time
    you’re running a web app or some sort of service and you’d benefit from saving
    resources. The truth is, not all applications will run well in a container, but
    it’s at least something to consider. Any time you’re running an application that
    is typically accessed via a web browser, it’s probably better off in a container
    rather than a VM. As an administrator, you’ll most likely experiment with the
    different tools available to you and decide on the best tool for the job based
    on your findings.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 什么时候应该使用容器？我建议你在运行Web应用程序或某种服务，并且能够从节省资源中受益时考虑使用容器。事实上，并非所有应用程序都能在容器中运行得很好，但至少值得考虑。每当你运行一个通常通过Web浏览器访问的应用程序时，它可能更适合放在容器中而不是虚拟机中。作为管理员，你很可能会试验不同的工具，并根据你的发现决定最佳工具。
- en: Now that we understand the core concepts surrounding containers, let’s explore
    the differences between two container technologies.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经理解了容器的核心概念，让我们来探讨两种容器技术之间的区别。
- en: Understanding the differences between Docker and LXD
  id: totrans-21
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解Docker和LXD之间的区别
- en: In this chapter, we’re going to explore both Docker and LXD and see examples
    of containers running in both. Before we start working on that though, it’s a
    good idea to understand some of the things that set each solution apart from the
    other.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将探讨Docker和LXD，并查看在这两者中运行容器的示例。但在我们开始之前，了解一些将每个解决方案与其他解决方案区分开来的因素是个好主意。
- en: '**Docker** is probably the technology most of my readers have heard of. It
    seems as though you can’t visit a single IT conference nowadays without it at
    least being mentioned. Docker is everywhere, and it runs on pretty much any platform.
    There’s lots of documentation available for Docker and various resources you can
    utilize to deploy it. Docker utilizes a *layered* approach to containerization.
    Every change you make to the container creates a new layer, and these layers can
    form the base of other containers, thus saving disk space. More on that later.'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: '**Docker**可能是我读者中大多数人听说过的技术。现在似乎没有哪个IT会议不提到它。Docker无处不在，并且可以在几乎任何平台上运行。关于Docker有很多文档资源，你可以利用它们来进行部署。Docker采用了*分层*的容器化方法。你对容器所做的每个更改都会创建一个新的层，而这些层可以作为其他容器的基础，从而节省磁盘空间。稍后我们会详细介绍。'
- en: '**LXD** (pronounced Lex-D) finds its roots in **LXC**, so it’s important to
    understand that first before we talk about LXD. LXC (pronounced Lex-C) is short
    for **Linux Containers** and is another implementation of containerization, similar
    to Docker. This technology, like similar solutions, uses the **control groups**
    (**cgroups**) feature of the Linux kernel, which isolates processes and is able
    to segregate them from one another. This enhances security, as processes should
    not be able to read data from other processes unless there’s a good reason to.'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: '**LXD**（发音为Lex-D）源自**LXC**，因此在讨论LXD之前，理解LXC非常重要。LXC（发音为Lex-C）是**Linux容器**的缩写，是另一种容器化实现，类似于Docker。这项技术像类似的解决方案一样，使用Linux内核的**控制组**（**cgroups**）特性，能够将进程隔离开并彼此隔离。这增强了安全性，因为进程不应该能够读取其他进程的数据，除非有充分的理由。'
- en: LXC takes the concept of segregation even further, by creating an implementation
    of virtualization based solely on running applications in an isolated environment
    that matches the environment of an operating system. You can run LXC containers
    on just about every distribution of Linux available today.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: LXC进一步推动了隔离的概念，通过创建一种完全基于在隔离环境中运行应用程序的虚拟化实现，这种环境与操作系统的环境相匹配。你几乎可以在今天的每个Linux发行版上运行LXC容器。
- en: LXD is also available for many Linux distributions, but it’s treated as a first-class
    citizen in Ubuntu. This is because Canonical (the company behind Ubuntu) had a
    major hand in its development, and also offers commercial support for it. Since
    the software that makes LXD itself work is distributed via `snap` packages, that
    essentially means that any distribution of Linux that is able to install `snap`
    packages should be able to install LXD.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: LXD也适用于许多Linux发行版，但在Ubuntu中被视为一等公民。这是因为Canonical（Ubuntu背后的公司）在其开发中发挥了重要作用，并且还提供商业支持。由于使LXD本身工作的软件是通过`snap`包分发的，这基本上意味着任何能够安装`snap`包的Linux发行版都应该能够安装LXD。
- en: LXD takes LXC and gives it additional features that it otherwise wouldn’t have,
    such as snapshots, ZFS support, and migration. LXD doesn’t replace LXC; it actually
    utilizes it to provide its base technology. Perhaps the best way to think of LXD
    is as LXC with an additional management layer on top that adds additional features.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: LXD 在 LXC 的基础上增加了额外的功能，这些功能在 LXC 中是没有的，比如快照、ZFS 支持和迁移。LXD 并没有替代 LXC；它实际上利用 LXC
    提供其基础技术。或许，最好的理解方式是把 LXD 看作是在 LXC 之上增加了一个管理层，提供了更多的功能。
- en: How does LXD/LXC differ from Docker? The main difference is that while they
    are both container solutions and solve the same goal in a very similar way, LXD
    is more similar to an actual VM while Docker tries harder to differentiate itself
    from that. In comparison, Docker containers are transactional (like I’ve already
    mentioned) and you generally have an `ENTRYPOINT` command that is run inside the
    container when you launch it. Essentially, LXD has a filesystem that you can directly
    access from the host operating system and has a simpler approach to containerization.
    You can think of LXC as a form of *machine* container that closely emulates a
    VM, and a Docker container is an *application* container that provides the foundation
    needed to run an application. Regardless of these differences, the technologies
    can be used in the same way and provide support for identical use cases.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: LXD/LXC 和 Docker 有什么不同？主要区别在于，尽管它们都是容器解决方案，并且以非常相似的方式解决了相同的目标，LXD 更像一个实际的虚拟机，而
    Docker 则更加努力地与其区分开来。相比之下，Docker 容器是事务性的（正如我之前提到的），你通常会有一个在启动容器时运行的 `ENTRYPOINT`
    命令。从本质上讲，LXD 有一个你可以从主机操作系统直接访问的文件系统，并且采用了更简单的容器化方法。你可以把 LXC 想象成一种*机器*容器，它非常接近虚拟机，而
    Docker 容器则是一个*应用*容器，为运行应用程序提供所需的基础。尽管有这些区别，这些技术可以以相同的方式使用，并支持相同的使用场景。
- en: When should you use Docker and when should you use LXD? I actually recommend
    you practice both since they’re not overly difficult to learn. We will go over
    the basics of these technologies in this chapter. But to answer the question at
    hand, there are a few use cases where one technology may make more sense than
    the other. Docker is more of a general-purpose tool. You can run Docker containers
    on Linux, macOS, and even Windows. It’s, therefore, a good choice if you want
    to create a container that runs everywhere. LXD is generally best for Linux environments,
    though Docker runs great in Linux too. The operating system you’re running your
    container solution on is of little importance nowadays, since most people use
    a container service to run containers rather than an actual server that you manage
    yourself. In the future, if you get heavily into containerization, you may find
    yourself forgoing the operating system altogether and just running them in a service
    such as Amazon’s **Elastic Container Service** (**ECS**), which is one of a handful
    of cloud services that allow you to run containers without having to manage the
    underlying server.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该什么时候使用 Docker，什么时候使用 LXD？实际上，我建议你同时练习这两者，因为它们并不难学。在本章中，我们将介绍这些技术的基础知识。但为了回答这个问题，有一些使用场景可能会使其中一种技术比另一种更合适。Docker
    是一个更通用的工具。你可以在 Linux、macOS，甚至 Windows 上运行 Docker 容器。因此，如果你想创建一个可以在任何地方运行的容器，它是一个不错的选择。LXD
    通常更适合 Linux 环境，尽管 Docker 在 Linux 上也运行得很好。如今，容器解决方案运行在哪个操作系统上已经不那么重要了，因为大多数人使用容器服务来运行容器，而不是自己管理的实际服务器。未来，如果你深入容器化领域，可能会发现自己完全放弃操作系统，直接在像亚马逊的**弹性容器服务**（**ECS**）这样的服务中运行容器，这是少数几种允许你在不管理底层服务器的情况下运行容器的云服务之一。
- en: Another benefit of Docker is **Docker Hub**, which you can use to download containers
    others have made or even upload your own for others to use. The benefit here is
    that if someone has already solved the goal you’re trying to achieve, you can
    benefit from their work rather than starting from scratch, and they can also benefit
    from your work as well. This saves time and is often better than creating a solution
    by hand.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: Docker 的另一个好处是**Docker Hub**，你可以用它下载别人创建的容器，甚至上传自己的容器供他人使用。这里的好处在于，如果有人已经解决了你要实现的目标，你可以利用他们的成果，而不是从头开始，他们也可以从你的工作中受益。这节省了时间，通常比手动创建解决方案要好。
- en: Always make sure to audit third-party resources before you put them to use in
    your organization. This includes (but isn’t limited to) containers developed by
    a third party. You should understand how the container image was built, how secure
    the settings are, and whether or not there’s anything built-in that might impose
    a security risk. Basically, some administrators will happily accept a container
    image as-is, but that practice can be very risky. Never deploy a container image
    that hasn’t been audited for security.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 在将第三方资源投入使用之前，始终确保审计它们的安全性。这包括（但不限于）由第三方开发的容器。你应该了解容器镜像是如何构建的、设置的安全性如何，以及是否有任何内置内容可能会带来安全风险。基本上，一些管理员会心安理得地接受一个未经审计的容器镜像，但这种做法非常有风险。永远不要部署一个未经安全审计的容器镜像。
- en: Now that we understand not only the core concepts but the differences between
    the two containerization standards, let’s take a look at Docker.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们不仅理解了核心概念，还了解了这两种容器化标准之间的区别，那么让我们来看看 Docker。
- en: Installing Docker
  id: totrans-33
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 安装 Docker
- en: 'Installing Docker is very fast and easy, so much so that it barely constitutes
    its own section. In the last chapter, we had to install several packages in order
    to get a **Kernel-based Virtual Machine** (**KVM**) virtualization server up and
    running as well as tweak some configuration files. In comparison, installing Docker
    is effortless, as you only need to install the `docker.io` package:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 安装 Docker 非常快速且简单，以至于几乎不需要单独列出一个章节。在上一章中，我们为了让 **基于内核的虚拟机**（**KVM**）虚拟化服务器启动并运行，还需要安装多个软件包，并且调整一些配置文件。相比之下，安装
    Docker 轻松得多，你只需要安装 `docker.io` 软件包：
- en: '[PRE0]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Yes, that’s all there is to it. Installing Docker was definitely much easier
    than setting up KVM, as we did in the previous chapter. Ubuntu includes Docker
    in its default repositories, so it’s only a matter of installing this one package
    and its dependencies. You’ll now have a new service installed on your machine,
    simply titled `docker`. In order to be useful, the service needs to be running.
    You can check to see whether or not it’s already running with the following command:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 是的，仅此而已。安装 Docker 绝对比设置 KVM 更简单，就像我们在上一章所做的那样。Ubuntu 将 Docker 包含在默认的仓库中，所以只需安装这一软件包及其依赖项。你现在会在你的机器上安装一个名为
    `docker` 的新服务。为了能够使用它，服务必须正在运行。你可以使用以下命令来检查它是否已经在运行：
- en: '[PRE1]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Check the output of the previous command to see if the `docker` service is
    running. You should also check to see if the service is enabled. If not, you can
    start the service and also enable it at the same time with the following command:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 查看上一条命令的输出，检查 `docker` 服务是否正在运行。你还应该检查服务是否已启用。如果没有，你可以通过以下命令同时启动并启用该服务：
- en: '[PRE2]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'We also have the `docker` command available to us now, which allows us to manage
    our containers. By default, it does require `root` privileges, so you’ll need
    to use `sudo` to use it. To make this easier, I recommend that you add your user
    account to the `docker` group before going any further. This will eliminate the
    need to use `sudo` every time you run a `docker` command. The following command
    will add your user account to the appropriate group:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在也可以使用 `docker` 命令来管理容器了。默认情况下，它确实需要 `root` 权限，因此你需要使用 `sudo` 来执行它。为了简化操作，我建议你在继续之前将用户帐户添加到
    `docker` 组中。这样，你就不需要每次执行 `docker` 命令时都使用 `sudo`。以下命令将把你的用户帐户添加到相应的组：
- en: '[PRE3]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: After you log out and then log in again, you’ll be able to manage Docker much
    more easily.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 登出并重新登录后，你将能够更轻松地管理 Docker。
- en: You can verify your group membership by simply running the groups command with
    no options, which should now show your user as a member of the `docker` group.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过运行 `groups` 命令来验证你的组成员身份，执行该命令时不需要任何选项，命令输出中应该会显示你的用户是 `docker` 组的成员。
- en: Well, that’s it. Docker is installed, and your user account is a member of the
    `docker` group, so you’re good to go. Wow, that was easy!
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 好了，就这样。Docker 已经安装完毕，你的用户帐户也已经是 `docker` 组的成员，所以你可以开始使用了。哇，真是太简单了！
- en: Now that we have Docker installed, let’s start using it. It’s a fun technology
    to learn, and in the next section, we’ll explore a few examples.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们已经安装了 Docker，那么就开始使用它吧。这是一项有趣的技术，在接下来的章节中，我们将探索一些示例。
- en: Managing Docker containers
  id: totrans-46
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 管理 Docker 容器
- en: 'Now that Docker is installed and running, let’s take it for a test drive. After
    installing Docker, we have the `docker` command available to use now, which has
    various sub-commands to perform different functions with containers. First, let’s
    try out `docker search`:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 现在 Docker 已经安装并运行了，让我们来试试它。安装 Docker 后，我们现在可以使用 `docker` 命令，该命令有各种子命令可以执行与容器相关的不同功能。首先，让我们尝试
    `docker search`：
- en: '[PRE4]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: With Docker, containers are created from images. There are many pre-existing
    container images we can use, or we can build our own. The `docker search` command
    allows us to search for a container image that already exists and has been made
    available to us. Once we’ve chosen an image, we can download it locally and create
    container instances from it.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 Docker，容器是从镜像创建的。我们可以使用许多现有的容器镜像，或者我们可以自己构建。`docker search` 命令允许我们搜索已经存在并且已经提供给我们的容器镜像。一旦我们选择了一个镜像，我们可以将其下载到本地并从中创建容器实例。
- en: The ability of administrators to search for (and download) an existing container
    is just one of many great features Docker offers us. Although we can definitely
    build our own container images (and we will do so, right here in this chapter),
    sometimes it might make sense to use a pre-existing container image, rather than
    create a new one from scratch.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 管理员可以搜索（和下载）现有的容器的能力只是 Docker 提供给我们的众多优秀功能之一。虽然我们肯定可以构建自己的容器镜像（我们将在本章节中这样做），但有时使用现有的容器镜像可能比从头开始创建更合理。
- en: For example, you can install an NGINX container, simply named `nginx`. This
    is actually an official container image, so it should be trustworthy. We can tell
    that a container image is trustworthy by the verbiage **DOCKER OFFICIAL IMAGE**
    being present if you were to look up the image on the Docker Hub website at [https://hub.docker.com](https://hub.docker.com).
    If we wanted to deploy a container running NGINX, doing so via the official image
    would save us a lot of time, especially compared to creating one from scratch.
    After all, why reinvent the wheel if you don’t have to?
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，您可以安装一个名为 `nginx` 的 NGINX 容器。这实际上是一个官方的容器镜像，所以应该是可信的。如果您在 Docker Hub 网站上查找该镜像，会看到
    **DOCKER OFFICIAL IMAGE** 的字样。如果我们想部署一个运行 NGINX 的容器，通过官方镜像可以节省大量时间，特别是与从头开始创建相比。毕竟，如果不必要，为什么要重新发明轮子呢？
- en: However, even if the container image comes from a trustworthy source, you should
    still audit it. With the NGINX example, we can be fairly confident that the image
    is safe and doesn’t contain any unwanted objects, such as malware. However, there’s
    no such thing as 100% trustworthy when it comes to security, so we should audit
    them anyway.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，即使容器镜像来自一个可信的源，您仍然应该对其进行审计。以 NGINX 为例，我们可以相当有信心地认为该镜像是安全的，不包含任何不需要的对象，比如恶意软件。但是，当涉及到安全性时，没有
    100% 的可信度，所以我们仍然应该进行审计。
- en: But how does this work? The `docker search` command will search Docker Hub,
    which is an online repository that hosts containers for others to download and
    utilize. You could search for containers based on other applications, or even
    other distributions such as Fedora or AlmaLinux, if you wanted to experiment.
    The command will return a list of Docker images available that meet your search
    criteria.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 那么这是如何工作的呢？`docker search` 命令将搜索 Docker Hub，这是一个在线仓库，用于存储供他人下载和使用的容器。您可以根据其他应用程序或者其他发行版（如
    Fedora 或 AlmaLinux）搜索容器。该命令将返回符合您搜索条件的 Docker 镜像列表。
- en: So what do we do with these images? An image in Docker is its closest equivalent
    to a VM or hardware image. It’s a snapshot that contains the filesystem of a particular
    operating system or Linux distribution, along with some changes the author included
    to make it perform a specific task. This image can then be downloaded and customized
    to suit your purposes. You can choose to upload your customized image back to
    Docker Hub if you would like to contribute upstream. Every image you download
    will be stored on your machine so that you won’t have to re-download it every
    time you wish to create a new container.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 那么我们用这些镜像做什么呢？在 Docker 中，镜像是其最接近虚拟机或硬件镜像的等价物。它是一个快照，包含特定操作系统或 Linux 发行版的文件系统，以及作者包含的一些更改，使其执行特定任务。可以下载该镜像并自定义以满足您的需求。如果您希望贡献上游，可以选择将您的定制镜像上传回
    Docker Hub。您下载的每个镜像都将存储在您的计算机上，这样您每次创建新容器时就不必重新下载它。
- en: 'To pull down a Docker image for our use, we can use the `docker pull` command,
    along with one of the image names we saw in the output of our `search` command:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 要拉取Docker镜像以供使用，我们可以使用`docker pull`命令，后面跟着我们在`search`命令的输出中看到的某个镜像名称：
- en: '[PRE5]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'With the preceding command, we’re pulling down the latest Ubuntu container
    image available on Docker Hub. The image will now be stored locally, and we’ll
    be able to create new containers from it. The process will look similar to the
    following screenshot:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 使用前面的命令，我们正在从Docker Hub拉取最新的Ubuntu容器镜像。镜像现在将被存储在本地，并且我们可以从中创建新容器。该过程将类似于以下截图：
- en: '![](img/B18425_17_01.png)'
  id: totrans-58
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B18425_17_01.png)'
- en: 'Figure 17.1: Downloading an Ubuntu container image'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 图17.1：下载Ubuntu容器镜像
- en: 'If you’re curious as to which images you have saved locally, you can execute
    `docker images` to get a list of the Docker container images you have stored on
    your server:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你对本地保存的镜像感到好奇，可以执行`docker images`来获取你在服务器上存储的Docker容器镜像列表：
- en: '[PRE6]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The output will look similar to this:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 输出将类似于这样：
- en: '![](img/B18425_17_02.png)'
  id: totrans-63
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B18425_17_02.png)'
- en: 'Figure 17.2: Listing installed Docker images'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 图17.2：列出已安装的Docker镜像
- en: 'Notice the `IMAGE ID` in the output. If for some reason you want to remove
    an image, you can do so with the `docker rmi` command, and you’ll need to use
    the ID as an argument to tell the command what to delete. The syntax would look
    similar to this if I was removing the image with the ID shown in the screenshot:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 注意输出中的`IMAGE ID`。如果由于某些原因你想删除一个镜像，可以使用`docker rmi`命令来删除，并且需要使用该ID作为参数来告诉命令删除哪个镜像。如果我要删除截图中显示的ID的镜像，语法会像这样：
- en: '[PRE7]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Once you have a container image downloaded to your server, you can create a
    new container from it by running the `docker run` command, followed by the name
    of your image and an application within the image to run. An application run from
    within a Docker container is known as an `ENTRYPOINT`, which is just a fancy term
    to describe an application a particular container is configured to run. You’re
    not limited to the `ENTRYPOINT` though, and not all containers actually have an
    `ENTRYPOINT`. You can use any command in the container that you would normally
    be able to run in that distribution. In the case of the Ubuntu container image
    we downloaded earlier, we can run `bash` with the following command so that we
    can get a prompt and enter any command(s) we wish:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你将容器镜像下载到服务器上，你可以通过运行`docker run`命令来创建一个新容器，后跟你的镜像名称和要在镜像中运行的应用程序。从Docker容器中运行的应用程序被称为`ENTRYPOINT`，这是一个用来描述特定容器配置为运行的应用程序的术语。不过，你并不局限于`ENTRYPOINT`，并非所有容器都有`ENTRYPOINT`。你可以在容器中运行任何通常能够在该发行版中运行的命令。以我们之前下载的Ubuntu容器镜像为例，我们可以使用以下命令运行`bash`，以便获取提示符并输入我们希望运行的任何命令：
- en: '[PRE8]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Once you run that command, you’re now interacting with a shell prompt from within
    your container. From here, you can run commands you would normally run within
    a real Ubuntu machine, such as installing new packages, changing configuration
    files, and more. Go ahead and play around with the container, and then we’ll continue
    with a bit more theory on how this is actually working.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你运行了该命令，你就会从容器内与Shell提示符进行交互。在这里，你可以运行你通常会在实际Ubuntu机器中运行的命令，比如安装新包、修改配置文件等。尽管如此，可以继续在容器中进行操作，然后我们将继续进行更多关于其实际工作的理论讲解。
- en: There are some potentially confusing aspects of Docker we should get out of
    the way first before we continue with additional examples. The thing that’s most
    likely to confuse newcomers to Docker is how containers are created and destroyed.
    When you execute the `docker run` command against an image you’ve downloaded,
    you’re actually creating a container. Therefore, the image you downloaded with
    the `docker pull` command wasn’t an actual container itself, but it becomes a
    container when you run an instance of it. When the command that’s being run inside
    the container finishes, the container goes away. Therefore, if you were to run
    `/bin/bash` in a container and install a bunch of packages, those packages would
    be wiped out as soon as you exited the container.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 在继续更多示例之前，我们应该先弄清楚Docker中可能让人困惑的一些方面。最有可能让Docker新手感到困惑的是容器是如何创建和销毁的。当你对已下载的镜像执行`docker
    run`命令时，你实际上是在创建一个容器。因此，你通过`docker pull`命令下载的镜像并不是一个实际的容器，而是当你运行它的实例时，它才会成为容器。当容器内执行的命令完成后，容器就会消失。因此，如果你在容器中运行`/bin/bash`并安装了一堆包，那么当你退出容器时，这些包会被清除。
- en: You can think of a Docker image as a “blueprint” for a container that can be
    used to create running containers. Every container you run has a container ID
    that differentiates it from others. If you want to remove a persistent container,
    for example, you would need to reference this ID with the `docker rm` command.
    This is very similar to the `docker rmi` command that’s used to remove container
    images.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以把Docker镜像看作是容器的“蓝图”，可以用它来创建运行中的容器。你运行的每个容器都有一个容器ID，用来区分它与其他容器。如果你想删除一个持久化的容器，例如，你需要使用`docker
    rm`命令引用这个ID。这与用来删除容器镜像的`docker rmi`命令非常相似。
- en: To see the container ID for yourself, you’ll first need to exit the container
    if you’re currently running one. There are two ways of doing so. First, you could
    press *Ctrl* + *d* to disconnect, or even type `exit` and press *Enter*. When
    you exit the container, you’re removing it (Docker containers only typically exist
    while running). When you run the `docker ps` command (which is the command you’ll
    use any time you want a list of containers on your system), you won’t see it listed.
    Instead, you can add the `-a` option to see all containers listed, even those
    that have been stopped.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看容器ID，首先你需要退出当前运行的容器。有两种方法可以做到这一点。首先，你可以按*Ctrl* + *d*断开连接，或者输入`exit`并按*Enter*键。当你退出容器时，你实际上是在移除它（Docker容器通常只在运行时存在）。当你运行`docker
    ps`命令时（这是你每次想查看系统中容器列表时使用的命令），你不会看到它的列出。相反，你可以添加`-a`选项，查看所有容器，包括那些已经停止的。
- en: You’re probably wondering, then, how to exit a container and not have it go
    away. To do so, while you’re attached to a container, press *Ctrl* + *p* and then
    press *q* (don’t let go of the *Ctrl* key while you press these two letters).
    This will drop you out of the container, and when you run the `docker ps` command
    (even without the `-a` option), you’ll see that it’s still running.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，你可能会想，如何退出一个容器并保持它不消失。要做到这一点，在你连接到容器时，按下*Ctrl* + *p*，然后按下*q*（按这两个字母时不要松开*Ctrl*键）。这样你就会退出容器，而当你运行`docker
    ps`命令时（即使没有使用`-a`选项），你会看到它仍然在运行。
- en: The `docker ps` command deserves some attention. The output will give you some
    very useful information about the containers on your server, including the `CONTAINER
    ID` that was mentioned earlier. In addition, the output will contain the `IMAGE`
    it was created from, the `COMMAND` being run when the container was `CREATED`,
    and its `STATUS`, as well as any `PORTS` you may have forwarded. The output will
    also display randomly generated names for each container, which are usually quite
    comical. As I was going through the process of creating containers while writing
    this section, the code names for my containers were `tender_cori`, `serene_mcnulty`,
    and `high_goldwasser`. This is just one of the many quirks of Docker, and some
    of these can be quite humorous.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: '`docker ps`命令值得关注。它的输出将提供关于你服务器上容器的非常有用的信息，包括之前提到的`CONTAINER ID`。此外，输出还会包含容器的`IMAGE`、容器创建时运行的`COMMAND`、容器的`CREATED`时间和其`STATUS`，以及你可能转发的任何`PORTS`。输出还会显示每个容器的随机生成名称，这些名称通常非常有趣。当我在写这一部分时，我的容器的代码名分别是`tender_cori`、`serene_mcnulty`和`high_goldwasser`。这只是Docker的众多奇特之处之一，有些名字甚至非常搞笑。'
- en: The important output of the `docker ps -a` command is the `CONTAINER ID`, the
    `COMMAND`, and the `STATUS`. The ID, which we already discussed, allows you to
    reference a specific container to enable you to run commands against it. `COMMAND`
    lets you know what command was being run. In our example, we executed `/bin/bash`
    when we started our containers.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: '`docker ps -a`命令的主要输出是`CONTAINER ID`、`COMMAND`和`STATUS`。我们已经讨论过的ID可以让你引用特定的容器，以便对其执行命令。`COMMAND`让你知道正在运行的是什么命令。在我们的例子中，当我们启动容器时，执行了`/bin/bash`命令。'
- en: 'If we have any containers that were stopped, we can resume a container with
    the `docker start` command, giving it a container ID as an argument. Your command
    will end up looking similar to this:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们有任何停止的容器，可以使用`docker start`命令恢复容器，给它传递容器ID作为参数。你的命令将会类似这样：
- en: '[PRE9]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'The output will simply return the ID of the container, and then drop you back
    to your shell prompt—not the shell prompt of your container, but that of your
    server. You might be wondering at this point, how do I get back to the shell prompt
    for the container? We can use `docker attach` for that:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 输出将仅返回容器的ID，然后将你带回到你的Shell提示符——不是容器的Shell提示符，而是服务器的Shell提示符。此时你可能会想，如何返回到容器的Shell提示符呢？我们可以使用`docker
    attach`来实现：
- en: '[PRE10]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The `docker attach` command is useful because it allows you to attach your shell
    to a container that is already running. Most of the time, containers are started
    automatically instead of starting with `/bin/bash` as we have done. If something
    were to go wrong, we may want to use something like `docker attach` to browse
    through the running container to look for error messages. It’s very useful.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: '`docker attach`命令很有用，因为它允许你将你的 shell 附加到一个已经在运行的容器。大多数时候，容器会自动启动，而不是像我们之前所做的那样以`/bin/bash`启动。如果出现问题，我们可能想使用类似`docker
    attach`的命令来浏览运行中的容器，查找错误信息。这非常有用。'
- en: Speaking of useful, another great command is `docker info`. This command will
    give you information about your implementation of Docker, such as letting you
    know how many containers you have on your system, which should be the number of
    times you’ve run the `docker run` command unless you cleaned up the previously
    run containers with `docker` `rm`. Feel free to take a look at its output and
    see what you can learn from it.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 说到有用的命令，另一个很棒的命令是`docker info`。这个命令会提供有关 Docker 实现的信息，例如让你知道系统上有多少个容器，通常这应该是你执行`docker
    run`命令的次数，除非你用`docker rm`清理了之前运行的容器。随便看看它的输出，看看能学到什么。
- en: 'Getting deeper into the subject of containers, it’s important to understand
    what a Docker container is and what it isn’t. A container is not a service running
    in the background, at least not inherently. A container is a collection of namespaces,
    such as a namespace for its filesystem or users. As discussed earlier in this
    chapter, containers are isolated from the rest of the server by utilizing technology
    within the Linux kernel. When you disconnect without a process running within
    the container, there’s no reason for it to run, since its namespace is empty.
    Thus, it stops. If you’d like to run a container in a way that is similar to a
    service (it keeps running in the background), you would want to run the container
    in **detached mode**. Basically, this is a way of telling your container to run
    this process and to not stop running it until you tell it to. Here’s an example
    of creating a container and running it in detached mode:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 更深入地了解容器的主题时，理解 Docker 容器是什么以及不是很重要。容器不是在后台运行的服务，至少从本质上来说不是。容器是一个命名空间的集合，比如它的文件系统或用户命名空间。正如本章早些时候讨论的，容器通过利用
    Linux 内核中的技术与服务器的其余部分隔离开来。当你在容器中没有运行任何进程时，它就没有理由继续运行，因为它的命名空间是空的。因此，它会停止。如果你希望以类似于服务的方式运行容器（即它在后台持续运行），你需要以**分离模式**运行容器。基本上，这是一种告诉容器运行该进程，并且在你告诉它停止之前不停止运行的方式。下面是一个创建容器并以分离模式运行的例子：
- en: '[PRE11]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: After running the previous command, Docker will print a container ID, and then
    drop back to your command prompt. You can then see that the container is running
    with the `docker ps` command, so use `docker attach` along with the container
    ID to connect to it and run commands.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 运行前一个命令后，Docker 会打印出一个容器 ID，然后返回到你的命令提示符。你可以使用`docker ps`命令查看容器是否正在运行，然后使用`docker
    attach`命令结合容器 ID 连接到容器并执行命令。
- en: Normally, we use the `-it` options to create a container. This is what we used
    a few examples ago. The `-i` option triggers interactive mode, while the `-t`
    option gives us a `pseudo-TTY`. At the end of the command, we tell the container
    to run the Bash shell. The `-d` option runs the container in the background.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，我们使用`-it`选项来创建容器。这是我们之前几个例子中使用的选项。`-i`选项启用交互模式，而`-t`选项为我们提供一个`伪终端`。命令的最后，我们告诉容器运行
    Bash shell。`-d`选项让容器在后台运行。
- en: 'It may seem relatively useless to have another Bash shell running in the background
    that isn’t actually performing a task. But these are just simple examples to help
    you get the hang of Docker. A more common use case may be to run a specific application.
    In fact, you can even serve a website from a Docker container by installing and
    configuring Apache within the container, including a virtual host. The question
    then becomes: how do you access the container’s instance of Apache within a web
    browser? The answer is **port redirection**, which Docker also supports. Let’s
    give this a try.'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 看似没有实际任务执行的后台 Bash shell 可能显得相对没有用。但这些只是一些简单的例子，帮助你熟悉 Docker。一个更常见的用例可能是运行一个特定的应用程序。实际上，你甚至可以通过在容器中安装和配置
    Apache 来为一个网站提供服务，包括设置虚拟主机。那么问题就变成了：如何在浏览器中访问容器内 Apache 的实例？答案是**端口重定向**，Docker
    也支持这一功能。我们来试试吧。
- en: 'First, let’s create a new container in detached mode. Let’s also redirect port
    `80` within the container to port `8080` on the host:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们以分离模式创建一个新的容器。我们还将把容器中的`80`端口重定向到主机的`8080`端口：
- en: '[PRE12]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'The command will output a container ID. This ID will be much longer than you’re
    accustomed to seeing. This is because when we run `docker ps -a`, it only shows
    shortened container IDs. You don’t need to use the entire container ID when you
    attach; you can simply use part of it as long as it’s long enough to be different
    from other IDs:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 该命令将输出一个容器ID。这个ID会比你习惯看到的要长得多。因为当我们运行`docker ps -a`时，它只显示缩短的容器ID。你不需要使用整个容器ID进行附加；只要它足够长，与你的其他ID不同，就可以仅使用其中的一部分：
- en: '[PRE13]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Here, I’ve attached to a container with an ID that begins with `dfb3e`. This
    will connect my shell to a Bash shell within the container.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，我已经附加到一个ID以`dfb3e`开头的容器。这将把我的Shell连接到容器中的Bash Shell。
- en: 'Let’s install Apache. We’ve done this before, but there are a few differences
    that you’ll see. First, if you simply run the following command to install the
    `apache2` package as we would normally do, it may fail for one or two reasons:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们安装Apache。我们之前做过这件事，但你会看到一些不同之处。首先，如果你简单地运行以下命令来安装`apache2`包，就像我们通常做的那样，它可能会因为一两个原因失败：
- en: '[PRE14]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'The two problems here are first that `sudo` isn’t included by default in the
    Ubuntu container, so it won’t even recognize the `sudo` part of the command. When
    you run `docker attach`, you’re actually attaching to the container as the `root`
    user, so the lack of `sudo` won’t be an issue anyway. Second, the repository index
    in the container may be out of date, if it’s even present at all. This means that
    `apt` within the container won’t even find the `apache2` package. To solve this,
    we’ll first update the repository index:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有两个问题，第一个是`sudo`在Ubuntu容器中默认没有包含，因此它甚至无法识别命令中的`sudo`部分。当你运行`docker attach`时，你实际上是以`root`用户附加到容器中，因此缺少`sudo`不会成为问题。第二，容器中的仓库索引可能已经过时，甚至根本没有。这意味着容器中的`apt`甚至找不到`apache2`包。为了解决这个问题，我们将首先更新仓库索引：
- en: '[PRE15]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Then, install `apache2` using the following command:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，使用以下命令安装`apache2`：
- en: '[PRE16]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: You may be asked to set your time zone or geographic location during the installation
    of packages. If so, go ahead and enter each prompt accordingly.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 在安装包时，你可能会被要求设置时区或地理位置。如果是这样，请根据提示输入相应信息。
- en: 'Now we have Apache installed in our container. We don’t need to worry about
    configuring the default sample web page or making it look nice. We just want to
    verify that it works. Let’s start the service:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们已经在容器中安装了Apache。我们不需要担心配置默认的示例网页或让它看起来更漂亮。我们只是想验证它是否正常工作。让我们启动服务：
- en: '[PRE17]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: After running that command, Apache should be running within the container.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 运行该命令后，Apache应该已经在容器内运行。
- en: The previous command is definitely not our normal way of starting services.
    Typically, we’d use a command like `systemctl start apache2`, but there’s no actual
    init system inside a container, so running `systemctl` commands will not work
    as they normally would. Always refer to any documentation that may exist for a
    container you’re attempting to run, regarding how to start an application it may
    contain.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的命令绝对不是我们通常启动服务的方式。通常，我们会使用像`systemctl start apache2`这样的命令，但容器内并没有实际的初始化系统，因此运行`systemctl`命令将无法像通常那样工作。始终参考你试图运行的容器可能存在的任何文档，了解如何启动其中可能包含的应用程序。
- en: Apache should be running within the container. Now, press *Ctrl* + *p* and then
    press *q* (don’t let go of the *Ctrl* key while you press these two letters) to
    exit the container, but allow it to keep running in the background. You should
    be able to visit the sample Apache web page for the container by navigating to
    `localhost:8080` in your web browser. You should see the default `It works!` page
    of Apache.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: Apache应该在容器内运行。现在，按下*Ctrl* + *p*，然后按*q*（在按这两个字母时，保持按住*Ctrl*键）退出容器，但让它继续在后台运行。你应该能够通过在浏览器中导航到`localhost:8080`来访问容器的示例Apache网页。你应该看到Apache的默认`It
    works!`页面。
- en: 'Congratulations, you’re officially running an application within a container:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 恭喜，你已经在容器内成功运行了一个应用程序：
- en: '![](img/B18425_17_03.png)'
  id: totrans-105
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B18425_17_03.png)'
- en: 'Figure 17.3: The default Apache start page, running from within a container'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 图17.3：默认的Apache启动页面，运行在容器内
- en: As your Docker knowledge grows, you’ll want to look deeper into the concept
    of an `ENTRYPOINT`. An `ENTRYPOINT` is a preferred way of starting applications
    in a Docker container. In our examples so far, we’ve used an `ENTRYPOINT` of `/bin/bash`.
    While that’s perfectly valid, an `ENTRYPOINT` is generally a Bash script that
    is configured to run the desired application and is launched by the container.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 随着你对Docker知识的深入，你可能会更想了解`ENTRYPOINT`的概念。`ENTRYPOINT`是启动Docker容器中应用程序的首选方式。在我们到目前为止的示例中，我们使用了`/bin/bash`作为`ENTRYPOINT`。虽然这完全有效，但`ENTRYPOINT`通常是一个配置好的Bash脚本，用于启动所需的应用程序，并由容器启动。
- en: 'Our Apache container is running happily in the background, responding to HTTP
    requests over port `8080` on the host. But what should we do with it at this point?
    We can create our own image from it so that we can simplify deploying it later.
    To be fair, we’ve only installed Apache inside the container, so it’s not saving
    us that much work. In a real production environment, you may have a container
    running that needed quite a few commands to set it up. With an image, we can have
    all of that work baked into the image, so we won’t have to run any setup commands
    we may have each time we want to create a container. To create a container image,
    let’s grab the container ID of a running container by running the `docker ps`
    command. Once we have that, we can now create a new image of the container with
    the `docker commit` command:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的Apache容器在后台愉快地运行，响应主机上`8080`端口的HTTP请求。但现在我们该怎么办呢？我们可以从它创建我们自己的镜像，以便以后简化部署。公平地说，我们在容器内仅安装了Apache，因此它并没有为我们节省太多工作。在实际的生产环境中，可能会有一个容器正在运行，且需要执行许多命令来设置它。使用镜像后，我们可以将所有这些工作都“烘焙”到镜像中，这样每次我们想创建容器时，就不需要再运行任何设置命令。要创建一个容器镜像，我们可以先通过运行`docker
    ps`命令获取正在运行的容器ID。一旦获取到容器ID，我们可以使用`docker commit`命令来创建该容器的新镜像：
- en: '[PRE18]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: That command will return us the ID of our new image. To view all the Docker
    images available on our machine, we can run the `docker images` command to have
    Docker return a list. You should see the original Ubuntu image we downloaded,
    along with the one we just created. We’ll first see a column for the repository
    the image came from; in our case, it is Ubuntu. Next, we see the tag. Our original
    Ubuntu image (the one we used `docker pull` to download) has a tag of `latest`.
    We didn’t specify that when we first downloaded it; it just defaulted to `latest`.
    In addition, we see an image ID for both, as well as the size.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 该命令将返回我们新镜像的ID。要查看我们机器上所有可用的Docker镜像，我们可以运行`docker images`命令，Docker将返回一个列表。你应该能看到我们下载的原始Ubuntu镜像，以及我们刚刚创建的镜像。我们首先会看到镜像来源的仓库列，在我们的例子中是Ubuntu。接下来，我们看到标签。我们原始的Ubuntu镜像（即我们用`docker
    pull`下载的那个）标签是`latest`。当我们最初下载它时并没有指定标签，它只是默认使用了`latest`。此外，我们还会看到两个镜像的ID以及它们的大小。
- en: 'To create a new container from our new image, we just need to use `docker run`,
    but specify the tag and name of our new image. Note that we may already have a
    container listening on port `8080`, so this command may fail if that container
    hasn’t been stopped:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 要从我们的新镜像创建一个新的容器，我们只需要使用`docker run`，但是需要指定新镜像的标签和名称。请注意，可能已经有一个容器在监听`8080`端口，所以如果该容器没有停止，这个命令可能会失败：
- en: '[PRE19]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Speaking of stopping a container, I should probably show you how to do that
    as well. As you can probably guess, the command is `docker stop` followed by a
    container ID:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 说到停止容器，我可能也应该展示一下如何操作。正如你可能猜到的，命令是`docker stop`，后跟容器ID：
- en: '[PRE20]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: This will send the `SIGTERM` signal to the container, followed by `SIGKILL`
    if it doesn’t stop on its own after a delay.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 这将向容器发送`SIGTERM`信号，如果容器在延迟后没有自行停止，将接着发送`SIGKILL`信号。
- en: Admittedly, the Apache container example was fairly simplistic, but it does
    the job as far as showing you a working example of a container that is actually
    somewhat useful. Before continuing on, think for a moment of all the use cases
    you can use Docker for in your organization. It may seem like a very simple concept
    (and it is), but it allows you to do some very powerful things. Perhaps you’ll
    want to try to containerize your organization’s intranet page or some sort of
    application. The concept of Docker sure is simple, but it can go a long way with
    the right imagination.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 诚然，Apache容器的示例相对简单，但它能够有效地展示一个实际有用的工作容器。在继续之前，先想一想在你的组织中可以用Docker做哪些事情。它看起来是一个非常简单的概念（确实如此），但它让你能够做一些非常强大的事情。也许你想尝试将你组织的内网页面或某些应用程序容器化。Docker的概念确实很简单，但只要有足够的想象力，它可以带来长远的影响。
- en: Before I close out this section, I’ll give you a personal example of how I implemented
    a container at a previous job. At this organization, I worked with some Embedded
    Linux software engineers who each had their own personal favorite Linux distribution.
    Some preferred Ubuntu, others preferred Debian, and a few even ran Gentoo. This
    in and of itself wasn’t necessarily an issue—sometimes it’s fun to try out other
    distributions. But for developers, a platform change can introduce inconsistency,
    and that’s not good for a software project. The included build tools are different
    in each distribution of Linux because they all ship different versions of all
    the development packages and libraries. The application this particular organization
    developed was only known to compile properly in Debian, and newer versions of
    the compiler posed a problem for the application. My solution was to provide each
    developer with a Docker container based on Debian, with all the build tools that
    they needed to perform their job baked in. At this point, it no longer mattered
    which distribution they ran on their workstations. The container was the same
    no matter what they were running. Regardless of what their underlying operating
    system was, they all had the same tools. This gave each developer the freedom
    to run their preferred distribution of Linux (or even macOS), and it didn’t impact
    their ability to do their job. I’m sure there are some clever use cases you can
    come up with for implementing containerization.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 在结束这一部分之前，我将给你一个我在之前的工作中如何实现容器的个人示例。在这个组织里，我与一些嵌入式 Linux 软件工程师合作，他们每个人都有自己喜欢的
    Linux 发行版。有些人喜欢 Ubuntu，其他人喜欢 Debian，还有一些甚至使用 Gentoo。单纯来看，这并不一定是个问题——有时尝试其他发行版是很有趣的。但对开发人员来说，平台的改变可能会引入不一致性，这对软件项目来说是不利的。不同的
    Linux 发行版中包含的构建工具各不相同，因为它们都提供不同版本的开发包和库。这个特定组织开发的应用程序只能在 Debian 中正确编译，而较新的编译器版本会对应用程序造成问题。我的解决方案是为每个开发人员提供一个基于
    Debian 的 Docker 容器，并将他们所需的所有构建工具打包其中。到这个时候，无论他们的工作站上运行的是哪个发行版，都不再重要。容器在他们的操作系统上都相同。无论底层操作系统是什么，每个人都拥有相同的工具。这使每个开发人员能够自由选择自己喜欢的
    Linux 发行版（甚至是 macOS），并且不会影响他们的工作能力。我相信，你也可以为实现容器化想出一些聪明的用例。
- en: Now that we understand the basics of Docker, let’s take a look at automating
    the process of building containers.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经了解了 Docker 的基础知识，接下来让我们看看如何自动化构建容器的过程。
- en: Automating Docker image creation with Dockerfiles
  id: totrans-119
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Dockerfile 自动化创建 Docker 镜像
- en: I’ve mentioned previously in this book that anything worth having a server do
    more than once should be automated, and building a Docker container is no exception.
    A Dockerfile is a neat way of automating the building of Docker images by creating
    a text file with a set of instructions for their creation. Docker is able to take
    this file, execute the commands it contains, and build a container. It’s magic.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 我在本书中之前提到过，任何值得让服务器做超过一次的事情都应该自动化，而构建 Docker 容器也不例外。Dockerfile 是一种通过创建包含一组指令的文本文件来自动化
    Docker 镜像构建的简便方法。Docker 可以读取这个文件，执行其中的命令，并构建一个容器。真是神奇。
- en: 'The easiest way to set up a `Dockerfile` is to create a directory, preferably
    with a descriptive name for the image you’d like to create (you can name it whatever
    you wish, though), and inside it create a text file named `Dockerfile`. For a
    quick example, copy this text into your `Dockerfile` and I’ll explain how it works:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 设置 `Dockerfile` 的最简单方法是创建一个目录，最好给它起一个描述性名称，以便你能知道要创建什么样的镜像（不过你可以随意命名），然后在其中创建一个名为
    `Dockerfile` 的文本文件。为了快速示范，把这段文本复制到你的 `Dockerfile` 中，我会解释它是如何工作的：
- en: '[PRE21]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Let’s go through this Dockerfile line by line to get a better understanding
    of what it’s doing:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们逐行了解这个 Dockerfile，帮助我们更好地理解它在做什么：
- en: '[PRE22]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: We need an image to base our new image on, so we’re using Ubuntu as a starting
    point.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要一个镜像来作为我们新镜像的基础，因此我们使用 Ubuntu 作为起点。
- en: This will cause Docker to download the `ubuntu:latest` image from Docker Hub,
    if we haven’t already downloaded it locally. If we do have it locally, it will
    just use the locally cached version.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 这将导致 Docker 从 Docker Hub 下载 `ubuntu:latest` 镜像，前提是我们还没有在本地下载过它。如果我们本地已经有它，Docker
    会直接使用本地缓存的版本。
- en: '[PRE23]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Here, we’re setting the maintainer of the image. Basically, we’re declaring
    its author. This is optional, so you don’t need to include that if you don’t want
    to.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们设置镜像的维护者。基本上，我们在声明镜像的作者。这是可选项，如果不想包括，也可以省略。
- en: '[PRE24]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Lines beginning with a hash symbol (`#`) are ignored, so we are able to create
    comments within the Dockerfile. This is recommended to give others a good idea
    of what your Dockerfile is doing.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 以井号符号（`#`）开头的行会被忽略，因此我们可以在Dockerfile中添加注释。推荐这样做，以便让其他人清楚地了解你的Dockerfile在做什么。
- en: '[PRE25]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Here, we’re setting an environment variable that, in this case, sets the environment
    to `noninteractive`. The reason we do this is that the process of installing a
    package while building a Docker container should be automatic; if a prompt comes
    up while a package is being installed and asks you a question, your input will
    not pass through and the process will hang.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们设置了一个环境变量，在这种情况下，它将环境设置为`noninteractive`。这样做的原因是，在构建Docker容器时安装软件包的过程应该是自动的；如果在安装软件包时出现提示并询问你问题，你的输入将无法传递，过程将会挂起。
- en: With this environment variable, we’re clarifying that we want to be in `noninteractive`
    mode so that the default answers to any questions that come up will be used and
    we won’t be prompted.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这个环境变量，我们明确表示我们希望处于`noninteractive`模式，以便任何出现的问题都能使用默认答案，而不会提示我们。
- en: '[PRE26]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: With the `RUN` command, we’re telling Docker to run a specific command while
    the image is being created. In this case, we’re updating the image’s repository
    index and performing a full package update to ensure the resulting image is as
    fresh as can be. The `-y` option is provided to suppress any requests for confirmation
    while installing the packages. Despite the fact that we set `noninteractive` mode
    earlier, `apt` will still try to confirm changes interactively, and the `-y` option
    suppresses that.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 通过`RUN`命令，我们告诉Docker在创建镜像时执行一个特定的命令。在这种情况下，我们更新镜像的仓库索引并进行完整的软件包更新，以确保生成的镜像尽可能是最新的。`-y`选项用于在安装包时抑制任何确认请求。尽管我们之前设置了`noninteractive`模式，`apt`仍然会尝试交互式确认更改，而`-y`选项会抑制这一点。
- en: '[PRE27]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Next, we’re installing both `apache2` and `vim-nox`. The `vim-nox` package isn’t
    required, but I personally like to make sure all of my servers and containers
    have it installed. I mainly included it here to show you that you can install
    multiple packages in one line.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们安装了`apache2`和`vim-nox`。`vim-nox`包不是必须的，但我个人喜欢确保所有服务器和容器都安装了它。我在这里主要是为了展示你可以在一行中安装多个包。
- en: '[PRE28]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: I mentioned the concept of an `ENTRYPOINT` earlier, which again is where we
    clarify which application should run when the container starts. The `apache2ctl`
    command is a wrapper command for Apache that allows administrators to control
    the finer points of running the Apache daemon. A full walk-through of this command
    is beyond the scope of this chapter, but we’re using it here because we want Apache
    to automatically start with the container, and `apache2ctl` is one method of doing
    that without relying on `systemctl` (which the container doesn’t have).
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 我之前提到过`ENTRYPOINT`的概念，这就是我们在容器启动时明确应该运行哪个应用程序的地方。`apache2ctl`命令是一个用于Apache的包装命令，它允许管理员控制运行Apache守护进程的细节。对该命令的详细讲解超出了本章的范围，但我们在这里使用它是因为我们希望Apache能随着容器自动启动，而`apache2ctl`是实现这一点的方法之一，而不依赖于`systemctl`（容器中没有这个命令）。
- en: 'Great, now we have a Dockerfile. So what do we do with it? Well, turn it into
    an image of course! To do so, we can use the `docker build` command, which can
    be executed from within the directory that contains the Dockerfile. Here’s an
    example of using the `docker build` command to create an image tagged `packt/apache-server:1.0`:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 很好，现在我们有了Dockerfile。那么接下来我们该怎么做？当然是将它转化为镜像！为此，我们可以使用`docker build`命令，可以在包含Dockerfile的目录中执行。以下是使用`docker
    build`命令创建一个标签为`packt/apache-server:1.0`的镜像的示例：
- en: '[PRE29]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Once you run that command, you’ll see Docker create the image for you, running
    each of the commands you asked it to. The image will be set up just the way you
    like. Basically, we just automated the entire creation of the Apache container
    we used as an example in this section. If anything goes wrong, Docker will print
    an error to your shell. You can then fix the error in your Dockerfile and run
    it again, and it will continue where it left off.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你运行该命令，你会看到Docker为你创建镜像，执行你要求的每个命令。镜像将按你的要求设置。基本上，我们只是自动化了创建这个我们在本节中作为示例使用的Apache容器的整个过程。如果出现任何问题，Docker会在你的Shell中打印错误信息。你可以在Dockerfile中修复错误并重新运行，它将从上次停止的地方继续。
- en: 'Once complete, we can create a container from our new image:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 完成后，我们可以从新的镜像创建一个容器：
- en: '[PRE30]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Almost immediately after running the container, the sample Apache site will
    be available on `localhost:8080` on the host. With a Dockerfile, you’ll be able
    to automate the creation of your Docker images. That was easy, wasn’t it? There’s
    much more you can do with Dockerfiles; feel free to peruse Docker’s official documentation
    to learn more. Exploration is key, so give it a try and experiment with it.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 几乎在运行容器后立即，示例 Apache 网站将可以通过主机上的`localhost:8080`访问。通过使用 Dockerfile，你可以自动化创建
    Docker 镜像的过程。这很简单，对吧？使用 Dockerfile，你可以做的事情远不止这些；可以随时浏览 Docker 官方文档，了解更多内容。探索是关键，赶紧试一试，进行一些实验吧。
- en: Managing LXD containers
  id: totrans-146
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 管理 LXD 容器
- en: 'With Docker out of the way, let’s take a look at how to run containers with
    LXD. Let’s dive right in and install the required package:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 在解决了 Docker 之后，让我们来看看如何使用 LXD 运行容器。我们直接开始，安装所需的包：
- en: '[PRE31]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'As you can see, installing LXD is just as easy as installing Docker. In fact,
    managing containers with LXD is very straightforward as well, as you’ll soon see.
    Installing LXD gives us the `lxc` command, which is the command we’ll use to manage
    LXD containers. Before we get going though, we should add our user account to
    the `lxd` group:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，安装 LXD 和安装 Docker 一样简单。实际上，使用 LXD 管理容器也非常直观，正如你很快会看到的那样。安装 LXD 后，我们将获得
    `lxc` 命令，这是我们用来管理 LXD 容器的命令。不过，在开始之前，我们应该将用户账户添加到 `lxd` 组：
- en: '[PRE32]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Make sure you log out and log in for the changes to take effect. Just like with
    the `docker` group with Docker, the `lxd` group will allow our user account to
    manage LXD containers.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 确保你退出并重新登录，以使更改生效。就像 Docker 的 `docker` 组一样，`lxd` 组将允许我们的用户账户管理 LXD 容器。
- en: 'Next, we need to initialize our new LXD installation. We’ll do that with the
    `lxd init` command:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要初始化我们的 LXD 安装。我们将通过 `lxd init` 命令来完成：
- en: '[PRE33]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'The process will look similar to the following screenshot:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 该过程将与以下截图类似：
- en: '![](img/B18425_17_04.png)'
  id: totrans-155
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B18425_17_04.png)'
- en: 'Figure 17.4: Setting up LXD with the lxd init command'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 图 17.4：使用 lxd init 命令设置 LXD
- en: The `lxd init` command will ask us a series of questions regarding how we’d
    like to set up LXD. The defaults are mostly fine for everything, and for the size
    of the pool, I just used the default of 30 GB, but you can use whatever size you
    want to. I set `ipv6` to `none` during the setup since my network doesn’t utilize
    that, and I also decided to make `lxd` available over the network.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: '`lxd init` 命令会问我们一系列关于如何设置 LXD 的问题。大多数默认设置都可以，存储池的大小我只是使用了默认的 30 GB，但你可以根据需要使用任何大小。在设置过程中，我将
    `ipv6` 设置为 `none`，因为我的网络不使用它，并且我决定通过网络启用 `lxd`。'
- en: Even though we chose the defaults for most of the questions, they’ll give you
    a general consensus of some of the different options that LXD makes available
    for us. For example, we can see that LXD supports the concept of a storage pool,
    which is one of its neater features.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 即使我们为大多数问题选择了默认值，这些设置也会给你一个关于 LXD 可用的一些不同选项的大致共识。例如，我们可以看到 LXD 支持存储池的概念，这是它的一个很酷的功能。
- en: Here, we’re creating a default storage pool with a filesystem format of `zfs`,
    which is a filesystem that is used on actual hard disks. During the setup process,
    LXD sets up the storage pool, network bridge, IP address scheme, and basically
    everything we need to get started.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们正在创建一个默认的存储池，文件系统格式为 `zfs`，这是一种用于实际硬盘的文件系统。在设置过程中，LXD 会设置存储池、网络桥接、IP 地址方案，基本上是我们开始所需的一切。
- en: 'Now that LXD is installed and set up, we can configure our first container:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 现在 LXD 已经安装并设置完成，我们可以配置第一个容器了：
- en: '[PRE34]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: With that simple command, LXD will now download the root filesystem for this
    container and set it up for us. Once done, we’ll have an LXD container based on
    Ubuntu 22.04 running and available for use. This is different than Docker, which
    only sets up an image by default, making us run it manually. During this process,
    we gave the container the name of `mycontainer`. The process should be fairly
    easy to follow so far.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这个简单的命令，LXD 现在将下载此容器的根文件系统，并为我们进行设置。完成后，我们将有一个基于 Ubuntu 22.04 运行并可供使用的 LXD
    容器。这与 Docker 不同，Docker 默认只设置一个镜像，需要我们手动运行它。在此过程中，我们为容器命名为 `mycontainer`。到目前为止，过程应该很容易跟随。
- en: You might be wondering why we used a `lxc` command to create a container since
    we’re learning about LXD here. As I mentioned earlier, LXD is an improvement over
    LXC, and as such, it uses `lxc` commands for management. Commands that are specific
    to the LXD layer will be `lxd`, and anything specific to container management
    will be done with `lxc`.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会想，既然我们在学习 LXD，为什么还使用了 `lxc` 命令来创建容器呢？正如我之前提到的，LXD 是对 LXC 的改进，因此它使用 `lxc`
    命令进行管理。特定于 LXD 层的命令将是 `lxd`，而任何与容器管理相关的操作则由 `lxc` 来完成。
- en: 'When it comes to managing containers, there are several types of operations
    you will want to perform, such as listing containers, starting a container, stopping
    a container, deleting a container, and so on. The `lxc` command suite is very
    easy and straightforward. Here is a table listing some of the most common commands
    you can use, and I’m sure you’ll agree that the command syntax is very logical.
    For each example, you substitute `<container>` with the name of the container
    you created:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 在管理容器时，你将需要执行几种常见操作，例如列出容器、启动容器、停止容器、删除容器等等。`lxc` 命令集非常简单直观。以下是列出一些常用命令的表格，我相信你会同意这些命令的语法非常合逻辑。对于每个例子，你只需将
    `<container>` 替换为你创建的容器的名称：
- en: '| **Goal** | **Command** |'
  id: totrans-165
  prefs: []
  type: TYPE_TB
  zh: '| **目标** | **命令** |'
- en: '| `List the containers` | `lxc list` |'
  id: totrans-166
  prefs: []
  type: TYPE_TB
  zh: '| `列出容器` | `lxc list` |'
- en: '| `Start a container` | `lxc start <container>` |'
  id: totrans-167
  prefs: []
  type: TYPE_TB
  zh: '| `启动容器` | `lxc start <container>` |'
- en: '| `Stop a container` | `lxc stop <container>` |'
  id: totrans-168
  prefs: []
  type: TYPE_TB
  zh: '| `停止容器` | `lxc stop <container>` |'
- en: '| `Remove a container` | `lxc delete <container>` |'
  id: totrans-169
  prefs: []
  type: TYPE_TB
  zh: '| `删除容器` | `lxc delete <container>` |'
- en: '| `List the downloaded images` | `lxc image list` |'
  id: totrans-170
  prefs: []
  type: TYPE_TB
  zh: '| `列出已下载的镜像` | `lxc image list` |'
- en: '| `Remove an image` | `lxc image delete <image_name>` |'
  id: totrans-171
  prefs: []
  type: TYPE_TB
  zh: '| `删除镜像` | `lxc image delete <image_name>` |'
- en: 'With all the basics out of the way, let’s jump into our container and play
    around with it. To open a shell to the container we just created, we would run
    the following:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 了解完所有基本操作后，我们可以进入容器并进行一些操作。要打开我们刚刚创建的容器的 shell，可以执行以下命令：
- en: '[PRE35]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: In the preceding command, `exec` tells the container we want to execute a command,
    `mycontainer` is the name of the container that we want to execute something against,
    and the specific command we want to execute is `bash`. After you execute that
    command, it immediately runs `bash` from the container as `root`. From here, you
    can configure the container as you need to by installing packages, setting up
    services, or whatever else you may need to do in order to make the container conform
    to the purpose you have for it. In fact, the process of customizing the container
    for redeployment is actually easier than it is with Docker.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的命令中，`exec` 告诉容器我们要执行一个命令，`mycontainer` 是我们要在其上执行命令的容器名称，而具体的命令是 `bash`。执行该命令后，它会立即以
    `root` 身份从容器中运行 `bash`。从这里，你可以根据需要配置容器，比如安装软件包、设置服务，或做其他任何使容器符合你需求的操作。事实上，定制容器以便重新部署的过程比
    Docker 更加简单。
- en: Unlike with Docker, changes are not wiped when you exit a container, and you
    don’t have to exit it in a particular way to avoid losing your changes. We also
    don’t have layers to deal with in LXD, which you may or may not be happy about
    (layers in Docker containers can make deployments faster, but when previously
    run containers aren’t cleaned up, the number of layers can look messy).
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 与 Docker 不同，退出容器时不会丢失更改，而且你无需以特定的方式退出容器来避免丢失更改。在 LXD 中，我们也不需要处理层（layers），这点你可能会觉得有些不同（Docker
    容器中的层可以加速部署，但如果之前运行的容器没有被清理，层数就会显得混乱）。
- en: 'The Ubuntu image we used to create our container includes a default user account,
    `ubuntu`. This is similar to some VPS providers, which also include an `ubuntu`
    user account by default (Amazon EC2 is an example of this). If you prefer to log
    in as this user rather than `root`, you can do that with this command:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 我们用来创建容器的 Ubuntu 镜像包括一个默认的用户帐户 `ubuntu`。这与一些 VPS 提供商类似，后者也默认包含 `ubuntu` 用户帐户（例如
    Amazon EC2）。如果你更喜欢以此用户登录，而非 `root`，可以使用以下命令：
- en: '[PRE36]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: The `ubuntu` user has access to `sudo`, so you’ll be able to run privileged
    tasks with no issue.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: '`ubuntu` 用户有 `sudo` 权限，因此你可以毫不困难地执行特权任务。'
- en: 'To exit the container, you can press *Ctrl* + *d* on your keyboard, or simply
    type `exit`. Feel free to log in to the container and make some changes and experiment.
    Once you have the container set up the way you like it, you may want the container
    to automatically start up when you boot your server. This is actually very easy
    to do:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 要退出容器，你可以按键盘上的*Ctrl* + *d*，或者直接输入`exit`。你可以随意登录到容器中进行一些更改和实验。一旦你设置好了容器，按照你的喜好，你可能希望容器在启动服务器时自动启动。其实，这个操作非常简单：
- en: '[PRE37]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: With the preceding command, we’re setting `boot.autostart` to `1`, which turns
    on that particular feature. Similar to a Boolean variable for those that are familiar
    with programming, `1` means “on” and `0` means “off.” After setting this config
    value, your newly created container will now start up with the server anytime
    it’s booted.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 使用前面的命令，我们将`boot.autostart`设置为`1`，这将开启这个特定的功能。对于熟悉编程的朋友来说，`1`代表“开启”，`0`代表“关闭”，就像布尔变量一样。在设置了这个配置值之后，你新创建的容器将在每次服务器启动时自动启动。
- en: 'Now, let’s have a bit of fun. Feel free to install the `apache2` package in
    your container. Similar to Docker, I’ve found that you will probably want to run
    `apt update` to update your package listings first, as I’ve seen failures installing
    packages on a fresh container solely because the indexes were stale. So just run
    this to be safe:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们玩得开心一点。你可以随意在容器中安装`apache2`包。与Docker类似，我发现你可能需要先运行`apt update`来更新软件包列表，因为我曾见过在一个新容器中安装包失败，仅仅是因为索引信息已经过时。所以，为了安全起见，请先运行此命令：
- en: '[PRE38]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Now, you should have Apache installed and running in the container. Next, we
    need to grab the IP address of the container. Yes, you read that right, LXD has
    its own IP address space for its containers, which is very neat. Simply run `ip
    addr show` (the same command you’d run in a normal server), and it will display
    the IP address information. On the same machine that’s running the container,
    you can visit this IP address to see the default Apache web page. If you’re running
    the container on a server with no graphical user interface, you can use the `curl`
    command to verify that it’s working:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你应该已经在容器中安装并运行了Apache。接下来，我们需要获取容器的IP地址。没错，你没看错，LXD为其容器分配了自己的IP地址空间，这非常方便。只需运行`ip
    addr show`（与在普通服务器中运行的命令相同），它会显示IP地址信息。在运行容器的同一台机器上，你可以访问这个IP地址来查看默认的Apache网页。如果你在没有图形用户界面的服务器上运行容器，可以使用`curl`命令来验证它是否正常工作：
- en: '[PRE39]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Although we have Apache running in our container, we can see that it’s not very
    useful yet. The web page is only available from the machine that’s hosting the
    container. This doesn’t help us much if we want users in our local network or
    even from the outside internet to be able to reach our site. We could set up firewall
    rules to route traffic to it, but there’s an easier way—creating a profile for
    external access.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然我们在容器中运行了Apache，但我们可以看到它现在还不是很有用。网页仅能从托管容器的机器上访问。如果我们希望本地网络中的用户，甚至是外部互联网的用户都能访问我们的网站，这样就没什么帮助了。我们可以设置防火墙规则来路由流量，但还有一种更简单的方法——为外部访问创建一个配置文件。
- en: I mentioned earlier that even though LXD is a containerization technology, it
    shares some of its feature set with VMs, basically giving you VM-like features
    in a non-VM environment. With LXD, we can create a profile to allow it to get
    an IP address from your DHCP server and route traffic directly through your LAN,
    just as with a physical device that you connect to your network.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 我之前提到过，尽管LXD是一种容器化技术，但它与虚拟机共享一些功能集，基本上可以在非虚拟机环境中提供类似虚拟机的功能。通过LXD，我们可以创建一个配置文件，允许它从你的DHCP服务器获取IP地址，并像物理设备一样通过局域网直接路由流量到容器。
- en: Before continuing, you’ll need a bridge connection set up on your server. This
    is done in software via Netplan and was discussed as part of the previous chapter.
    If you list your network interfaces (`ip addr show`), you should see a `br0` connection.
    If you don’t have this configured, refer back to *Chapter 16*, *Virtualization*,
    and refer to the *Bridging the VM network* section there. Once you’ve created
    this connection, you can continue on.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 在继续之前，你需要在服务器上设置桥接连接。这是通过Netplan软件完成的，在前一章节中有提到。如果你列出你的网络接口（`ip addr show`），你应该能看到一个`br0`连接。如果你没有配置这个，参考*第16章*，*虚拟化*，并查阅其中的*桥接虚拟机网络*部分。创建好这个连接后，你就可以继续了。
- en: Some network cards do not support bridging, especially with some Wi-Fi cards.
    If you’re unable to create a bridge on your hardware, the following section may
    not work for you. Consult the documentation for your hardware to ensure your network
    card supports bridging.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 一些网络卡不支持桥接，尤其是某些 Wi-Fi 网络卡。如果你的硬件无法创建桥接，以下部分可能对你无效。请查阅你硬件的文档，确保你的网络卡支持桥接。
- en: 'To create the profile we’ll need in order to enable external access to our
    containers, we’ll use the following command:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 为了创建我们需要的配置文件，以启用容器的外部访问，我们将使用以下命令：
- en: '[PRE40]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'We should see output similar to the following:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 我们应该看到类似如下的输出：
- en: '[PRE41]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Next, we’ll need to edit the profile we just created. The following command
    will open the profile in a text editor so that you can edit it:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要编辑刚刚创建的配置文件。以下命令将打开配置文件，以便你进行编辑：
- en: '[PRE42]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Inside the profile, we’ll replace its text with this:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 在配置文件中，我们将用以下内容替换其文本：
- en: '[PRE43]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'From this point forward, we can launch new containers with this profile with
    the following command:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 从此时起，我们可以使用以下命令，通过这个配置文件启动新容器：
- en: '[PRE44]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: Notice how we’re applying two profiles, `default` and then `external`. We do
    this so that the values in `default` can be loaded first, followed by the second
    profile so that it overrides any conflicting parameters that may be present.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 注意我们正在应用两个配置文件，`default` 和 `external`。我们这样做是为了先加载 `default` 中的值，然后加载第二个配置文件，以便它覆盖任何可能存在的冲突参数。
- en: 'We already have a container, though, so you may be curious how we can edit
    the existing one to take advantage of our new profile. That’s simple:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 不过我们已经有一个容器了，或许你会好奇如何编辑现有的容器来利用我们的新配置文件。这很简单：
- en: '[PRE45]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: From this point forward, assuming the host bridge on your server has been configured
    properly, the container should be accessible via your local LAN. You should be
    able to host a resource, such as a website, and have others be able to access
    it. This resource could be a local intranet site or even an internet-facing website.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 从此时起，假设你的服务器上的主机桥接已经正确配置，容器应该可以通过本地 LAN 访问。你应该能够托管一个资源，比如网站，并让其他人能够访问它。这个资源可以是本地内网站点，甚至是面向互联网的网站。
- en: As far as getting started with LXD is concerned, that’s essentially it. LXD
    is very simple to use, and its command structure is very logical and easy to understand.
    With just a few simple commands, we can create a container, and even make it externally
    accessible. Canonical has many examples and tutorials available online to help
    you push your knowledge even further, but with what you’ve learned so far, you
    should have enough practical knowledge to roll out this solution in your organization.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 就 LXD 的入门而言，基本上就是这些。LXD 非常简单易用，其命令结构也非常合乎逻辑且容易理解。只需要几个简单的命令，我们就能创建一个容器，甚至让它对外可访问。Canonical
    在线上提供了很多示例和教程，可以帮助你进一步深入了解，但根据目前所学，你应该已经掌握了足够的实用知识，可以在你的组织中部署这个解决方案了。
- en: Summary
  id: totrans-205
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: Containers are a wonderful method of hosting applications. You can spin up more
    containers on your hardware than you’d be able to with VMs, which will definitely
    save resources. While not all applications can be run inside containers, it’s
    a very useful tool to have available. In this chapter, we looked at both Docker
    and LXD. While Docker is better for cross-platform applications, LXD is simpler
    to use but is very flexible. We started out by discussing the differences between
    these two solutions, then we experimented with both creating containers and looking
    at how to manage them.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 容器是一种托管应用程序的绝佳方式。相比虚拟机，你可以在硬件上启动更多容器，这无疑可以节省资源。虽然并非所有应用都能在容器中运行，但容器是一个非常实用的工具。在本章中，我们探讨了
    Docker 和 LXD。虽然 Docker 更适用于跨平台应用，但 LXD 更简单易用，同时非常灵活。我们首先讨论了这两者之间的区别，然后实验了创建容器并管理容器的方法。
- en: In the next chapter, we will expand our knowledge of containers even further
    and take a look at orchestration, which allows us to manage multiple containers
    more efficiently. This will be the chapter where all of the concepts relating
    to containers come together.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章，我们将进一步扩展对容器的了解，探索编排技术，使我们能够更高效地管理多个容器。这将是将所有与容器相关的概念结合在一起的一章。
- en: Relevant videos
  id: totrans-208
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 相关视频
- en: 'Docker Essentials tutorial series (LearnLinuxTV): [https://linux.video/docker-essentials](https://linux.video/docker-essentials)'
  id: totrans-209
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Docker Essentials 教程系列（LearnLinuxTV）：[https://linux.video/docker-essentials](https://linux.video/docker-essentials)
- en: 'Getting started with LXD (LearnLinuxTV): [https://linux.video/lxd-guide](https://linux.video/lxd-guide)'
  id: totrans-210
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 开始使用LXD（LearnLinuxTV）：[https://linux.video/lxd-guide](https://linux.video/lxd-guide)
- en: Further reading
  id: totrans-211
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: 'Docker documentation page: [https://learnlinux.link/d-docs](https://learnlinux.link/d-docs)'
  id: totrans-212
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Docker文档页面：[https://learnlinux.link/d-docs](https://learnlinux.link/d-docs)
- en: 'LXD introduction: [https://learnlinux.link/lxd-intro](https://learnlinux.link/lxd-intro)'
  id: totrans-213
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: LXD简介：[https://learnlinux.link/lxd-intro](https://learnlinux.link/lxd-intro)
- en: 'LXD documentation: [https://learnlinux.link/c-lxd](https://learnlinux.link/c-lxd)'
  id: totrans-214
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: LXD文档：[https://learnlinux.link/c-lxd](https://learnlinux.link/c-lxd)
- en: Join our community on Discord
  id: totrans-215
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 加入我们社区的Discord
- en: 'Join our community’s Discord space for discussions with the author and other
    readers:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 加入我们社区的Discord空间，与作者和其他读者进行讨论：
- en: '[https://packt.link/LWaZ0](https://packt.link/LWaZ0)'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://packt.link/LWaZ0](https://packt.link/LWaZ0)'
- en: '![](img/QR_Code50046724-1955875156.png)'
  id: totrans-218
  prefs: []
  type: TYPE_IMG
  zh: '![](img/QR_Code50046724-1955875156.png)'
