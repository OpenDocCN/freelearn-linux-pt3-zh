- en: '20'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '20'
- en: Automating Cloud Deployments with Terraform
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Terraform自动化云部署
- en: 'The previous chapter was especially fun: we were able to deploy Ubuntu in the
    cloud, utilizing **Amazon Web Services** (**AWS**). Deploying infrastructure in
    the cloud is very powerful and allows us to accomplish things that are not normally
    possible (or are very tedious) with physical infrastructure. We can spin up Ubuntu
    instances in minutes, and even set up auto-healing to cover us in situations that
    would normally result in complete service disruption.'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 上一章尤为有趣：我们能够在云中部署Ubuntu，利用**亚马逊网络服务**（**AWS**）。在云中部署基础设施非常强大，允许我们完成通常无法实现（或非常繁琐）的事情。我们可以在几分钟内启动Ubuntu实例，甚至设置自动恢复，以应对通常会导致完全服务中断的情况。
- en: This time around, we’re going to work with cloud deployments again, and check
    out an awesome tool called **Terraform** that will allow us to automate the provisioning
    of our cloud resources. We’ve already explored the concept of automation back
    in *Chapter 15,* *Automating Server Configuration with Ansible*, when we learned
    about the basics of Ansible. Terraform allows us to take our automation to the
    next level and even interact with providers such as AWS directly.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 这一次，我们将再次处理云部署，并了解一个名为**Terraform**的强大工具，它将允许我们自动化我们的云资源的配置。在*第15章*，*使用Ansible自动化服务器配置*中，我们已经探讨了自动化的概念，并了解了Ansible的基础知识。Terraform使我们能够将我们的自动化提升到一个新的水平，甚至可以直接与AWS等服务提供商进行交互。
- en: 'In this chapter, we’ll explore the following concepts:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将探讨以下概念：
- en: Why it’s important to automate your infrastructure
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为什么自动化基础设施很重要
- en: Introduction to Terraform and how it can fit within your workflow
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 简介Terraform及其如何在您的工作流中适用
- en: Installing Terraform
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 安装Terraform
- en: Automating an EC2 instance deployment
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 自动化EC2实例部署
- en: Managing security groups with Terraform
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Terraform管理安全组
- en: Using Terraform to destroy unused resources
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Terraform销毁未使用的资源
- en: Combining Ansible with Terraform for a full deployment solution
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将Ansible与Terraform结合以实现完整的部署解决方案
- en: Why automate the building of our infrastructure? There are many benefits of
    doing so, and we’ll take a look at some of those benefits in the next section.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么自动化基础设施的构建如此重要？这样做有许多好处，我们将在下一节中看到其中一些好处。
- en: Why it’s important to automate your infrastructure
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为什么自动化基础设施很重要
- en: Automation with regards to infrastructure is an expansive topic, and it easily
    deserves a book of its own. In fact, there are not only books dedicated to it
    but entire online courses as well. There are many different utilities you can
    use, each with its own pros and cons. We have configuration management tools,
    such as Ansible, Chef, and Puppet. We looked at Ansible earlier in the book and
    worked through some examples to see how powerful it is. When we worked with that
    earlier, I’m sure you immediately saw the benefit—not having to build a solution
    manually is a beautiful thing.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 关于基础设施自动化的话题非常广泛，它很容易就能值得一本书来讲述。事实上，不仅有专门的书籍，还有整个在线课程也是专门讲这个的。您可以使用许多不同的实用程序，每个都有其优缺点。我们有配置管理工具，如Ansible、Chef和Puppet。我们在本书的早期已经看过Ansible，并通过一些示例来了解其强大之处。当我们早些时候使用它时，我相信您立即看到了好处——不必手动构建解决方案是一件美妙的事情。
- en: The importance of not having to build solutions manually cannot be overstated.
    Perhaps the most obvious benefit is the fact that it can save you hours, or even
    days of work. When I first started working in IT, setting up servers was always
    a manual task. Sure, you could create a Bash script and automate some tasks that
    way, but tools specifically designed to automate will handle the task much more
    efficiently. An IT staff that would normally be overwhelmed at the thought of
    setting up a large number of servers would be able to perform the same task much
    quicker with automation. And with all the time that’s saved, IT staff members
    can focus on other tasks rather than spending the majority of their time on one
    task.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 不得不强调不需要手动构建解决方案的重要性。也许最明显的好处是它可以节省你数小时甚至数天的工作时间。当我刚开始从事IT工作时，设置服务器总是一个手动任务。当然，你可以创建一个Bash脚本并通过这种方式自动化一些任务，但专门设计用于自动化的工具将更有效地处理任务。一个通常会因为设置大量服务器而感到不知所措的IT员工，通过自动化可以更快地完成相同的任务。并且通过节省的所有时间，IT员工可以专注于其他任务，而不是将大部分时间花在一个任务上。
- en: Another benefit of automation is that the likelihood of human error is much
    lower. While you’re building your automation solution, making mistakes is unavoidable.
    You may mistype something while writing a script that causes a syntax error, or
    perhaps something doesn’t get created quite the way you expected. But after you’ve
    spent the time building your automation scripts and verified there are no errors,
    then you can run them again and again and the infrastructure will get created
    the same way each time. Compare that to having to manually set up servers each
    time you wish to implement a new solution, and you can imagine how often it may
    happen that there may be mistakes to fix. Some of which you may not even discover
    until later on.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 自动化的另一个好处是人为错误的可能性大大降低。当你构建自动化解决方案时，犯错误是不可避免的。你在编写脚本时可能会输入错误，导致语法错误，或者某些东西没有按照你预期的方式创建。但在你花时间构建并验证自动化脚本没有错误后，你可以反复运行它们，每次基础设施都会以相同的方式创建。对比每次手动设置服务器以实施新解决方案时，错误可能会发生的频率，你可以想象有多少次可能需要修正的错误，其中一些甚至可能直到后期才被发现。
- en: Automation also has another benefit you may not expect, **Disaster Recovery**.
    While we will cover disaster recovery in *Chapter 23*, *Preventing Disasters*,
    it’s worth mentioning now because an effective automation solution will make the
    process of recovery quicker. It’s an administrator’s worst nightmare to even think
    that a server that’s important to your organization may someday fail, but it’s
    a fact of life.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 自动化还有一个你可能没有预料到的好处——**灾难恢复**。虽然我们将在*第23章*《防止灾难》中详细讨论灾难恢复，但现在值得一提的是，制定一个有效的自动化解决方案将使恢复过程更加迅速。作为管理员，最糟糕的噩梦之一就是想象对组织至关重要的服务器某天可能会出现故障，但这却是生活的一个事实。
- en: Our organization may have a very complex application that consists of one or
    more web servers, a load balancer, security settings, and more. It could take
    hours to rebuild a solution like that manually. But with automation, you would
    simply run your scripts to recreate the same solution in mere minutes. Automation
    itself won’t protect you from losing data (which would be an even scarier problem)
    but at the very least it can help you to provision replacement resources quicker
    than if you had to do the same manually. Not only that, I presume your clients
    (as well as your boss) will prefer your organization’s application to come back
    online in minutes, rather than hours or days.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的组织可能有一个非常复杂的应用程序，包含一个或多个 Web 服务器、负载均衡器、安全设置等。手动重建这样的解决方案可能需要几个小时。但通过自动化，你只需要运行你的脚本，就能在几分钟内重建相同的解决方案。自动化本身无法保护你免于丢失数据（这将是一个更可怕的问题），但至少它可以帮助你比手动操作更快地配置替代资源。不仅如此，我推测你的客户（以及你的上司）会更希望你的组织的应用程序在几分钟内恢复上线，而不是几个小时或几天。
- en: In addition, your automation scripts can serve as a form of living blueprint.
    Even if you aren’t planning on reprovisioning your servers and related infrastructure,
    another administrator can look at your automation scripts and understand better
    which components make up the overall solution, allowing them to get up to speed
    quicker if they’re taking over the management of infrastructure from someone else.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，你的自动化脚本可以作为一种活文档形式存在。即使你不打算重新配置你的服务器和相关基础设施，其他管理员也可以查看你的自动化脚本，更好地理解整体解决方案中包含哪些组件，这样如果他们接管了基础设施的管理工作，也能更快地上手。
- en: Automation is one of those things that I probably won’t have to try too hard
    to sell to you, because if you already have experience working in IT, then you
    already know how tedious it can be to manually rebuild servers.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 自动化是那种我可能不需要费力推销的东西，因为如果你已经有过 IT 工作经验，你自然知道手动重建服务器是多么繁琐。
- en: Sometimes, it may feel as though we have more tasks to complete than we have
    hours in the workday. But with automation, we can get some of that time back and
    possibly even lower our stress level a bit. And it’s not the first time we’ve
    worked with automation; we did take a look at Ansible earlier in the book, so
    you are probably well aware of the benefits. But what we’re going to do in this
    chapter is implement automation at a lower level than Ansible, and we’ll do so
    with a solution known as **Terraform**. What is Terraform, you may ask? In science,
    terraforming is an amazing process of taking a planet that is uninhabitable and
    converting it into one that is able to support life as we know it. But for our
    purposes, Terraform is the name of an awesome utility we can use to automate an
    entire cloud computing implementation. In the next section, we’ll define it even
    more.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 有时候，可能会感觉我们要完成的任务比工作日里的小时数还多。但是通过自动化，我们可以找回一些时间，甚至可能稍微降低一点压力。而且这并不是我们第一次使用自动化；我们在本书的早些章节已经看过
    Ansible，所以你大概已经非常清楚它的好处。不过，在本章中，我们将实现比 Ansible 更低层次的自动化，我们将使用一个叫做**Terraform**的解决方案。你可能会问，Terraform
    是什么？在科学领域，地球化学是一项令人惊叹的过程，它将一个无法居住的星球转变为一个能够支持我们已知生命的星球。但在我们的用途中，Terraform 是一个我们可以用来自动化整个云计算实现的强大工具。接下来的部分，我们会更详细地定义它。
- en: Introduction to Terraform and how it can fit within your workflow
  id: totrans-22
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Terraform 介绍以及它如何融入你的工作流
- en: Terraform is an amazing tool created by a company called Hashicorp that can
    automate your infrastructure at a level lower than Ansible, Puppet, or other configuration
    management solutions. In fact, Terraform typically doesn’t replace those but complements
    them. With configuration management tools, we generally have to create the initial
    server and set up the operating system first before we can implement them. With
    Ansible, there are actually methods of using it to create infrastructure components,
    but that’s beyond the scope of the book.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: Terraform 是由一家名为 Hashicorp 的公司创建的一个令人惊叹的工具，它可以在比 Ansible、Puppet 或其他配置管理解决方案更低的层次上自动化你的基础设施。事实上，Terraform
    通常不会替代这些工具，而是与它们互补。使用配置管理工具时，我们通常需要首先创建初始服务器并设置操作系统，然后才能实现它们。虽然 Ansible 实际上有方法可以用来创建基础设施组件，但这超出了本书的范围。
- en: Not only that, but while Ansible is able to create some types of infrastructure,
    that’s not what it does best. To understand where something like Terraform fits,
    it’s best to think of Terraform as making things exist and Ansible as taking things
    that already exist and ensuring they’re configured properly.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 不仅如此，虽然 Ansible 可以创建某些类型的基础设施，但这并不是它最擅长的。为了理解像 Terraform 这样的工具的作用，最好将 Terraform
    看作是用来创建事物的存在，而 Ansible 则是用来处理已经存在的事物，确保它们的配置正确。
- en: When it comes to Terraform itself, it allows you to take advantage of a neat
    concept, **Infrastructure as Code**. In the previous chapter, we set up an entire
    load-balanced application in AWS. We created an EC2 instance, as well as an AMI,
    and then we built the load balancer along with Auto Scaling. While that process
    was incredibly fun, it was a manual one. If you made mistakes during the process,
    you had to go and fix them. After you were done, your solution was created and
    working. What Terraform allows us to do is write code that represents our desired
    end state. When it runs, it checks the cloud provider and performs an inventory.
    If something we’ve added to our scripts isn’t present with the cloud provider,
    it will make sure that the current state matches the desired end state in our
    code. We can even provision an entire cloud solution without even logging in to
    AWS beyond the first time.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Terraform 本身方面，它让你能够利用一个非常棒的概念——**基础设施即代码**。在上一章，我们在 AWS 中设置了一个完整的负载均衡应用。我们创建了一个
    EC2 实例，以及一个 AMI，然后建立了负载均衡器和自动扩展功能。尽管这个过程非常有趣，但它是手动的。如果在过程中犯了错误，你必须去修复它们。完成后，你的解决方案已经创建并正常运行。Terraform
    让我们能够编写代码，表示我们想要的最终状态。当它运行时，它会检查云提供商并进行库存检查。如果我们在脚本中添加的内容在云提供商处不存在，它会确保当前状态与我们代码中的最终状态一致。我们甚至可以在首次登录
    AWS 后，不再登录，直接提供整个云解决方案。
- en: 'An important consideration when it comes to automation tools is whether or
    not the tool is **cross-platform**. Many cloud providers feature built-in tools
    to do the same thing that Terraform does. For example, AWS has a feature called
    **CloudFormation** that allows you to script infrastructure builds, just as you
    can with Terraform. But the problem is that CloudFormation is specific to AWS.
    You can’t utilize that service to build infrastructure in Microsoft Azure or Google
    Cloud. A tool that’s cross-platform can run in any environment. We already saw
    this with Ansible earlier in the book: Ansible doesn’t mind if the servers you’re
    having it configure reside in AWS or even if they’re physical machines in a rack.
    To Ansible, Ubuntu is Ubuntu, regardless of where it’s running. This allows you
    to use the same tool in multiple environments, without having to recreate a new
    set of automation scripts for each one. Terraform is also a cross-platform tool.'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 在选择自动化工具时，一个重要的考虑因素是工具是否**跨平台**。许多云服务提供商都有内置工具，可以实现 Terraform 所做的相同功能。例如，AWS
    有一个叫做 **CloudFormation** 的功能，允许你像使用 Terraform 一样脚本化基础设施的构建。但问题在于，CloudFormation
    只针对 AWS 特定设计。你无法使用该服务在微软 Azure 或 Google Cloud 中构建基础设施。跨平台工具可以在任何环境中运行。我们之前在本书中已经看到过
    Ansible：Ansible 不在乎你配置的服务器是位于 AWS，还是即使它们是机架中的物理机器。对 Ansible 来说，Ubuntu 就是 Ubuntu，无论它运行在哪个环境中。这让你可以在多个环境中使用相同的工具，而无需为每个环境重新创建一套自动化脚本。Terraform
    同样也是一个跨平台工具。
- en: Why does it matter if a tool is cross-platform? If you have to maintain several
    completely different tools that all do the same thing, it’s a waste of time. If
    you can learn one tool and use it in every environment you support, then it’s
    less of a maintenance burden. This is why I always recommend avoiding platform-specific
    tools, such as CloudFormation in AWS. There’s even a tool within AWS called **OpsWorks**
    that’s used for the same purpose as Ansible (configuration management), but again
    is specific to AWS.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么工具是否跨平台很重要？如果你需要维护多个完全不同的工具来执行相同的任务，那就是浪费时间。如果你能够学会使用一个工具，并且能够在你支持的每个环境中使用它，那么维护负担会小得多。这也是我一直建议避免使用平台特定工具的原因，比如
    AWS 中的 CloudFormation。AWS 里甚至还有一个名为 **OpsWorks** 的工具，它用于与 Ansible 相同的目的（配置管理），但同样只限于
    AWS。
- en: A typical organization will pivot in different directions multiple times throughout
    the life of the company. An organization that is using AWS for 100% of its infrastructure
    may someday decide to support other cloud providers. Sometimes, all it takes is
    the right client or situation to make the company consider using a cloud provider
    for a project that would normally not be considered.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 一个典型的组织会在公司发展的不同阶段多次进行调整。一个100%使用 AWS 基础设施的组织，有一天可能会决定支持其他云服务提供商。有时候，正是因为遇到了合适的客户或情况，才会促使公司考虑在一个通常不考虑的项目中使用其他云服务提供商。
- en: It could also be the case that a company might change primary providers due
    to a change made with the current platform that increases cost, or some other
    reason. If you use cross-platform tools, then you can take those tools with you
    (for the most part) if you change providers. Also, being able to support multiple
    providers not only makes you a more powerful administrator but also offers additional
    value to your organization.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 也有可能是因为当前平台发生了变动导致成本增加，或者其他原因，企业可能会更换主要的服务提供商。如果你使用跨平台工具，那么在更换服务提供商时，你大部分的工具仍然可以带走。此外，能够支持多个服务提供商不仅使你成为一个更强大的管理员，还能为你的组织提供额外的价值。
- en: Terraform itself is not going to be 100% identical between cloud platforms,
    though. The syntax does change from one cloud provider to another. Currently,
    there doesn’t seem to be a solution available for Infrastructure as Code that
    is 100% portable between environments. But considering solutions such as CloudFormation
    are 0% transferable to other platforms, then Terraform still wins out in comparison
    since it is a tool you can use with multiple providers. The general consensus
    of how Terraform works will remain the same with each provider, so it’s going
    to still save you time if you use it and then switch providers.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 不过，Terraform 在不同云平台之间并不会 100% 一致。其语法会根据云服务提供商的不同而有所变化。目前，似乎还没有一个可以在不同环境之间 100%
    可移植的基础设施即代码（IaC）解决方案。但考虑到像 CloudFormation 这样的解决方案在其他平台间是完全不可转移的，Terraform 相比之下仍然占优，因为它是一个可以在多个服务提供商间使用的工具。Terraform
    的通用工作原理在每个提供商之间都保持一致，因此即便你更换服务提供商，使用它依然能够节省时间。
- en: How does Terraform work? We’ll install it in the next section and actually use
    it to deploy an EC2 instance in the section after that. But in a nutshell, Terraform
    is a utility you can download to your local laptop or desktop, and use to turn
    script files into actual infrastructure. It supports many different cloud platforms,
    such as AWS, GCP, and others. It even supports VPS providers, such as Digital
    Ocean and Linode. Terraform refers to each of those platforms as a provider and
    gives you the ability to download the appropriate plugin within Terraform to support
    your chosen provider(s).
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: Terraform 是如何工作的？我们将在下一节安装 Terraform，并在随后的节中使用它来部署 EC2 实例。但简而言之，Terraform 是一个你可以下载到本地笔记本电脑或台式机的工具，使用它将脚本文件转化为实际的基础设施。它支持许多不同的云平台，如
    AWS、GCP 等。它甚至支持虚拟私人服务器（VPS）提供商，如 Digital Ocean 和 Linode。Terraform 将每个平台称为提供商，并允许你在
    Terraform 中下载适当的插件，以支持你选择的提供商。
- en: As you’ll see later in the chapter, Terraform allows you to test your configuration
    first, and preview the changes it will make. Then, if you accept the changes,
    it will connect to your provider and create the infrastructure as you’ve defined
    it in your code. Although we won’t cover version control in this chapter, typical
    organizations will store their Terraform code within a Git repository or some
    other version control system, so that the code is safe from being accidentally
    deleted. In a typical organization, one or more administrators will work with
    the Terraform code and push their changes into the repository.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 正如本章后面所提到的，Terraform 允许你先测试配置，并预览它将进行的更改。然后，如果你接受这些更改，它将连接到你的服务提供商，并根据你在代码中定义的方式创建基础设施。尽管我们本章不会涉及版本控制，但典型的组织会将其
    Terraform 代码存储在 Git 仓库或其他版本控制系统中，以防止代码被意外删除。在典型的组织中，一个或多个管理员将与 Terraform 代码一起工作，并将他们的更改推送到仓库中。
- en: In the next section, we’ll walk through the process of installing Terraform
    so we will have everything we need in order to get started and build some automation
    around our infrastructure.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将详细介绍安装 Terraform 的过程，这样我们就可以准备好一切，开始围绕我们的基础设施构建自动化。
- en: Installing Terraform
  id: totrans-34
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 安装 Terraform
- en: The process of running Terraform and using it to provision your cloud resources
    is generally initiated on your local laptop or desktop. Terraform itself is downloaded
    from its website, and it’s available for all of the leading operating systems.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 运行 Terraform 并使用它来配置云资源的过程通常是在本地笔记本电脑或台式机上启动的。Terraform 本身是从其官方网站下载的，并且适用于所有主流操作系统。
- en: 'Unlike the majority of applications, there’s no installer. Terraform is run
    directly from the file you download; there’s no installation process to go through.
    You can install it system-wide if you want to do so, but you can run it from any
    directory you wish. Download files for Terraform are located at the following
    website: [https://www.terraform.io/](https://www.terraform.io/).'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 与大多数应用程序不同，Terraform 没有安装程序。Terraform 是直接从你下载的文件运行的；没有需要经过的安装过程。如果你愿意，你可以将其安装到系统范围内，但你也可以从任何你希望的目录中运行它。Terraform
    的下载文件位于以下网址：[https://www.terraform.io/](https://www.terraform.io/)。
- en: 'Once there, you should see a **Download** button:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 到达该网站后，你应该能看到一个 **下载** 按钮：
- en: '![](img/B18425_20_01.png)'
  id: totrans-38
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B18425_20_01.png)'
- en: 'Figure 20.1: The Terraform website'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 图 20.1：Terraform 网站
- en: 'After clicking the **Download** button, you’ll see a new page that will offer
    Terraform for six different operating systems, including the usual suspects such
    as Linux, macOS, and Windows. Most likely, it will automatically select the operating
    system that the computer you’re visiting the site from is using. For example,
    here’s what the page looks like while downloading the macOS version:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 点击 **下载** 按钮后，你会看到一个新页面，提供适用于六种不同操作系统的 Terraform，包括常见的 Linux、macOS 和 Windows。大多数情况下，它会自动选择你访问该网站时使用的操作系统。例如，以下是下载
    macOS 版本时页面的样子：
- en: '![](img/B18425_20_02.png)'
  id: totrans-41
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B18425_20_02.png)'
- en: 'Figure 20.2: The Terraform website, downloading for macOS'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 图 20.2：Terraform 网站，macOS 下载页面
- en: At this point, all you’ll have to do is download a version of Terraform specific
    to your operating system. Most computers sold nowadays are 64-bit, so it should
    be straightforward to choose which one to download. If you’d like to run Terraform
    from a Raspberry Pi, choose the Arm version for Linux. Once you download it, you’ll
    have a ZIP file locally that you can extract. Inside, you’ll find a binary file
    simply titled `terraform` and that’s all you’ll actually need.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 此时，你只需下载适合你操作系统的Terraform版本。如今大多数电脑都是64位的，所以选择要下载的版本应该很简单。如果你想在树莓派上运行Terraform，请选择适用于Linux的Arm版本。下载后，你将得到一个本地的ZIP文件，解压后，你会找到一个名为`terraform`的二进制文件，这就是你实际需要的全部。
- en: 'You’ll be able to run `terraform` right from the command prompt of your operating
    system:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 你将能够直接在操作系统的命令提示符中运行`terraform`：
- en: '![](img/B18425_20_03.png)'
  id: totrans-45
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B18425_20_03.png)'
- en: 'Figure 20.3: Running terraform from a terminal window with no options'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 图20.3：在终端窗口中运行terraform，无任何选项
- en: In the screenshot, I typed out the entire path to the downloaded and extracted
    `terraform` file, which was saved in my home directory under the `downloads` folder.
    I ran it with no options, so it printed out the help page.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 在截图中，我输入了下载并解压后的`terraform`文件的完整路径，该文件保存在我的主目录下的`downloads`文件夹中。我没有使用任何选项运行它，因此它打印出了帮助页面。
- en: 'If you’d like to install it system-wide, you can move `terraform` into the
    `/usr/local/bin` directory if you’re running Linux or macOS:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想系统范围内安装它，可以将`terraform`移到`/usr/local/bin`目录下，如果你使用的是Linux或macOS：
- en: '[PRE0]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The `/usr/local/bin` directory is recognized by both Linux and macOS as a directory
    that is searched for binary files. This concept is referred to as your `$PATH`,
    which is a special variable that holds all the directories your profile is set
    to look into when attempting to execute a command. The method of adding a new
    directory to your `$PATH` differs from one operating system to another, but in
    terms of macOS and Linux, `/usr/local/bin` is already recognized, so when you
    copy `terraform` into that directory, you should be able to simply type `terraform`
    in your terminal without needing to type the full path each time you wish to use
    Terraform. This is optional, but it makes it simpler.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: '`/usr/local/bin`目录被Linux和macOS都识别为会搜索二进制文件的目录。这个概念被称为你的`$PATH`，它是一个特殊的变量，包含了你个人资料设置中定义的所有目录，用于执行命令时查找。这种将新目录添加到`$PATH`的方法在不同操作系统间有所不同，但对于macOS和Linux来说，`/usr/local/bin`已经被识别，因此当你将`terraform`复制到该目录时，你应该能够直接在终端中输入`terraform`，而不需要每次都输入完整的路径。这个操作是可选的，但它使得操作更简便。'
- en: In order for Terraform to be able to work with AWS, we’ll need to generate an
    API key for it. This is done inside the AWS Management Console, which you should
    sign into now so we can create what we need. In the previous chapter, we discussed
    IAM, which is a service within AWS that allows you to not only create user accounts
    for fellow administrators but also lets you create keys for programmatic access.
    The latter will be how we allow Terraform to connect to our AWS account in order
    to perform tasks on our behalf.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 为了让Terraform能够与AWS配合使用，我们需要为它生成一个API密钥。这是在AWS管理控制台中完成的，你现在应该登录到控制台，以便我们创建所需的内容。在上一章中，我们讨论了IAM，这是AWS中的一项服务，它不仅允许你为其他管理员创建用户账户，还能为程序化访问创建密钥。后者将是我们允许Terraform连接到我们的AWS账户，并代表我们执行任务的方式。
- en: 'Inside the IAM section of the AWS management console, click on the **Users**
    link that you should see in the left-hand menu, followed by the blue **Add User**
    button that you should see on that page. The following form will appear:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 在AWS管理控制台的IAM部分，点击左侧菜单中的**用户**链接，然后点击该页面上你应该能看到的蓝色**添加用户**按钮。接下来会出现如下表单：
- en: '![](img/B18425_20_04.png)'
  id: totrans-53
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B18425_20_04.png)'
- en: 'Figure 20.4: Creating an IAM user for the purpose of running Terraform'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 图20.4：创建用于运行Terraform的IAM用户
- en: 'In my case, I decided to call my user `terraform-provisioner`, but you can
    use whatever name you’d like. I checked the box next to **Programmatic access**
    and I left the second unchecked, because I do not want this user to be able to
    log in to the console. Click **Next: Permissions** to continue. On the next screen
    that comes up, we’ll set the policy that the user will have access to:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 在我的情况下，我决定将用户命名为`terraform-provisioner`，但你可以使用任何你喜欢的名称。我勾选了**程序访问**旁边的框，并且没有勾选第二个框，因为我不希望该用户能够登录到控制台。点击**下一步：权限**继续。在接下来的页面中，我们将设置用户能够访问的策略：
- en: '![](img/B18425_20_05.png)'
  id: totrans-56
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B18425_20_05.png)'
- en: 'Figure 20.5: Creating an IAM user for Terraform (continued)'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 图 20.5：为 Terraform 创建 IAM 用户（继续）
- en: For this screen, click on the box that reads **Attach existing policies directly**
    to highlight it, and check the box below to add the **AdministratorAccess** policy
    to this object. This is the policy that will grant Terraform its ability to interact
    with AWS.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个界面中，点击**直接附加现有策略**的框以选中它，并勾选下面的框来为该对象添加**AdministratorAccess**策略。这是授予 Terraform
    与 AWS 交互权限的策略。
- en: 'Click **Next: Tags** to continue, then on the next screen, you can skip adding
    tags (unless you’d like to add them) and you can click **Next: Review** and then
    **Create Use****r** to finish the process.'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 点击**下一步：标签**继续，然后在下一个界面，你可以跳过添加标签（除非你想添加它们），接着点击**下一步：审查**，然后点击**创建用户**完成该过程。
- en: 'The final screen that appears should report that the process was successful,
    and the **Download .csv** button gives you the ability to download your key. You
    can also reveal the secret access key by clicking the **Show** button, as I’ve
    done in *Figure 20.6*:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 最终显示的界面应该会报告过程成功，并且**下载 .csv**按钮可以让你下载密钥。你也可以通过点击**显示**按钮查看密钥，如我在*图 20.6*中所做的那样：
- en: '![](img/B18425_20_06.png)'
  id: totrans-61
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B18425_20_06.png)'
- en: 'Figure 20.6: Creating an IAM user for Terraform (final screen)'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 图 20.6：为 Terraform 创建 IAM 用户（最终界面）
- en: I’d like to give you a few warnings about the key, though. First, whether you
    download the key or reveal it by clicking the **Show** button, this is the last
    time you’ll ever see it. You won’t be given another opportunity to download the
    full key. I recommend you download the key and store it in a safe place. You should
    protect the key and not let anyone have access to it, and you should definitely
    not upload it to a version control repository or any other resource that’s publicly
    available. And you should absolutely not show the key in clear text in a book
    that a bunch of people is going to read. If this key falls into the wrong hands,
    then anyone that has it will be able to interact with your AWS account. Treat
    this key with care. The only reason I show mine here is because I want you to
    see what the process actually looks like. I’ll delete it from my AWS account before
    the publishing process of this book is finalized. On your end, definitely don’t
    let this key leak!
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 不过，我想先提醒你一些关于密钥的注意事项。首先，无论你是下载密钥还是点击**显示**按钮查看密钥，这是你唯一一次看到它的机会。你将不会再有机会下载完整的密钥。我建议你下载密钥并将其存储在一个安全的地方。你应该保护密钥，不让任何人访问它，绝对不要将它上传到版本控制仓库或任何其他公开资源中。你也绝对不要在书中以明文形式展示密钥，让很多人都能看到。如果这个密钥落入不法分子之手，那么任何拥有它的人都能与你的
    AWS 账户交互。请小心保管这个密钥。我之所以在这里展示它，是因为我想让你看到整个过程的实际情况。在这本书的出版过程完成之前，我会从我的 AWS 账户中删除它。至于你，绝对不要让这个密钥泄漏！
- en: Now we have everything we need to proceed to build AWS resources with Terraform.
    In the next section, we’ll create an EC2 instance.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了一切所需的资源，可以继续使用 Terraform 构建 AWS 资源了。在下一节中，我们将创建一个 EC2 实例。
- en: Automating an EC2 instance deployment
  id: totrans-65
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 自动化 EC2 实例部署
- en: 'Let’s take a look at an example Terraform configuration file that will allow
    us to build an EC2 instance:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看一个示例 Terraform 配置文件，它将帮助我们构建一个 EC2 实例：
- en: '[PRE1]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Terraform files are saved with a `.tf` filename extension, and as for the actual
    name, you can call it whatever you wish. I named mine `terraform_example_1.tf`.
    The underscores in the filename aren’t required but make it easier to use on the
    command line since you won’t have to escape spaces. I placed my `terraform_example_1.tf`
    file inside a directory of its own, which is recommended. Your Terraform configuration
    files should be separate from other files, so having a dedicated directory for
    such files is ideal.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: Terraform 文件以 `.tf` 文件扩展名保存，至于文件名，你可以随意命名。我将它命名为 `terraform_example_1.tf`。文件名中的下划线并不是必须的，但它能使命令行操作更方便，因为你不需要对空格进行转义。我将我的
    `terraform_example_1.tf` 文件放在一个专门的目录中，这是推荐的做法。你的 Terraform 配置文件应该与其他文件分开，因此为这些文件创建一个专门的目录是理想的。
- en: 'As for the actual code itself, let’s explore it section by section:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 至于实际的代码，让我们一节一节地来看：
- en: '[PRE2]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The `provider` block tells Terraform what type of provider we’ll be working
    with. We’re setting that to `aws` here. As mentioned earlier, Terraform is able
    to work with various cloud providers, of which AWS is only one. Underneath that,
    we’re setting the `region` variable to `us-east-1`. On your end, I recommend setting
    this to whatever region you were using in the previous chapter; that will make
    the process easier for us since we already have some resources there that we can
    reuse for now.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: '`provider` 块告诉 Terraform 我们将使用的提供程序类型。我们在这里设置为 `aws`。 正如前面提到的，Terraform 能够与各种云提供商合作，其中
    AWS 只是其中之一。在此之下，我们将 `region` 变量设置为 `us-east-1`。建议您设置与上一章节使用的区域相同，这将使我们的过程更加简单，因为我们已经有一些可以重复使用的资源。'
- en: '[PRE3]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Here, we’re starting a new resource block. Each provider has its own building
    blocks (resources), and specific to AWS, we can use `aws_instance`. On this line,
    we’re also naming the instance, and calling it `my-server-1`.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们开始一个新的资源块。每个提供程序都有自己的构建块（资源），特别是针对 AWS，我们可以使用 `aws_instance`。在这一行中，我们还给实例命名，并称其为
    `my-server-1`。
- en: Note that this is a name within Terraform we’re providing, not the actual name
    that will be used in AWS itself. Within Terraform, we’ll want to have some sort
    of name to refer back to this particular AWS instance if we need to refer to it
    again elsewhere.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，这是我们在 Terraform 中提供的名称，而不是在 AWS 中实际使用的名称。在 Terraform 中，我们希望有一些名称来引用此特定的
    AWS 实例，以便在其他地方需要引用时使用。
- en: '[PRE4]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Next, we’re choosing the AMI we’d like to use for our instance. As discussed
    in the previous chapter, an AMI is an image we can use to build a server in AWS.
    The instance ID that I used here is for the official Ubuntu 22.04 AMI that comes
    as default with AWS. AMIs are specific to the region they were created in, so
    the instance ID here is specific to `us-east-1`.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们选择要用于我们实例的 AMI。如前一章节讨论的，AMI 是我们可以用来在 AWS 中构建服务器的映像。我在这里使用的实例 ID 是与 AWS
    默认提供的官方 Ubuntu 22.04 AMI 相关联的。AMI 是特定于创建它们的区域，因此这里的实例 ID 是特定于 `us-east-1` 的。
- en: 'If you’re also using `us-east-1`, you can use the above AMI ID as-is (so long
    as it’s not replaced by AWS with a newer one in the future). If in doubt, you
    can go into the AWS console, then navigate to the EC2 console, and go through
    the process as if you were going to manually create an EC2 instance based on Ubuntu,
    and copy the AMI ID from there. Perhaps even easier, you can use the Amazon EC2
    AMI Locator (provided directly by Canonical) to find an AMI ID to use: [https://cloud-images.ubuntu.com/locator/ec2/](https://cloud-images.ubuntu.com/locator/ec2/).'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您也在使用 `us-east-1`，则可以直接使用上述的 AMI ID（只要未来 AWS 没有用新的替换它）。如果有疑问，您可以进入 AWS 控制台，然后导航到
    EC2 控制台，并按照手动创建基于 Ubuntu 的 EC2 实例的过程，从那里复制 AMI ID。甚至更简单的方法是，您可以使用由 Canonical 直接提供的
    Amazon EC2 AMI Locator 来查找要使用的 AMI ID：[https://cloud-images.ubuntu.com/locator/ec2/](https://cloud-images.ubuntu.com/locator/ec2/)。
- en: You’re able to filter that list by Ubuntu version as well as location. That
    way, you can find the AMI ID for an Ubuntu 22.04 AMI that’s within your chosen
    region. Change the AMI ID in the example code to the one you wish to use.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以按 Ubuntu 版本和位置过滤该列表。这样，您可以找到符合您选择区域的 Ubuntu 22.04 AMI 的 AMI ID。将示例代码中的 AMI
    ID 更改为您希望使用的 AMI ID。
- en: Also, you’ll probably notice that there are quite a few spaces in between `ami`
    and `=` `"ami-09d56f8956ab235b3"`. It’s common practice with Terraform syntax
    to align the equal sign of every line within a block, which makes the code look
    cleaner. This isn’t required, and nothing bad will happen if you don’t line everything
    up perfectly, but some may argue that the overall script looks cleaner that way.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能会注意到 `ami` 和 `=` `"ami-09d56f8956ab235b3"` 之间有很多空格。在 Terraform 语法中，将每行的等号对齐是一种常见的做法，这样可以使代码看起来更整洁。虽然不是必需的，如果您不完全对齐，也不会出现问题，但有些人可能会认为整体脚本看起来更清晰。
- en: '[PRE5]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: With this line, we’re deciding to utilize a public IP address with our instance,
    which is required if we wish to be able to access it remotely.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这行，我们决定在我们的实例中使用公共 IP 地址，如果我们希望能够远程访问它，则需要这样做。
- en: '[PRE6]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Here, we’re setting the desired instance type for our newly created server.
    As discussed in the previous chapter, there are multiple instance types available,
    each with a different cost. The `t2.micro` instance type is eligible for the free
    tier, so that’s the reason I chose it.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们设置了我们新创建的服务器的所需实例类型。如前一章节讨论的，有多种实例类型可用，每种类型都有不同的成本。`t2.micro` 实例类型符合免费层条件，这就是我选择它的原因。
- en: '[PRE7]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: In the previous chapter, when we created an EC2 instance manually, part of that
    process was creating an OpenSSH key. The key that you’ve created is registered
    to your AWS account, so you can refer to it by the name you gave it. I called
    mine `jay_ssh`, but you’ll want to change this to whatever you named yours. You
    can see a list of your OpenSSH keys in the EC2 dashboard within AWS; there’s a
    section in the menu called **Key Pairs** where you can remind yourself what you’ve
    named your key if you forgot.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 在前一章中，当我们手动创建 EC2 实例时，其中的一部分过程是创建 OpenSSH 密钥。你创建的密钥已经注册到你的 AWS 账户，因此你可以通过你给它命名的名称来引用它。我将它命名为`jay_ssh`，但你需要将其更改为你为自己的密钥起的名字。你可以在
    AWS 的 EC2 控制台中查看你的 OpenSSH 密钥列表；在菜单中有一个叫做**密钥对**的部分，如果你忘记了密钥的名字，可以在那里找到它。
- en: '[PRE8]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: During the last chapter, we created a security group that allowed both Apache
    and OpenSSH to communicate with our instance. When you create a security group,
    it’s designated with its own security group ID. The security group ID I used in
    the example was the one that was generated for me, so it won’t work for you. If
    you access the **Security Groups** section of the EC2 console, you can find the
    security group ID for the one that you’ve created. The ID for it should start
    with `sg-`, followed by a series of characters. Add yours in place of what I have
    for mine in the example.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们创建了一个安全组，允许 Apache 和 OpenSSH 与我们的实例通信。当你创建安全组时，它会被指定一个安全组 ID。我在示例中使用的安全组
    ID 是系统为我生成的，因此对你无效。如果你访问 EC2 控制台中的**安全组**部分，你可以找到你创建的安全组的 ID。它的 ID 应该以`sg-`开头，后面跟着一串字符。将你的
    ID 替换我示例中的 ID。
- en: '[PRE9]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: In the last section of the example, we’re setting a tag. As discussed in the
    previous chapter, AWS allows you to create tags that are useful information you
    can have attached to an instance, which can give you additional information about
    its intended use. The `Name` tag is a special tag that changes the name that you
    see for the instance in the AWS EC2 list. You can name yours whatever you’d like.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 在示例的最后部分，我们正在设置一个标签。如前一章所述，AWS 允许你创建标签，这些标签可以附加到实例上，提供关于其预期用途的附加信息。`Name`标签是一个特殊的标签，它会更改你在
    AWS EC2 列表中看到的实例名称。你可以将其命名为任何你喜欢的名字。
- en: 'At this point, we should be all set to go ahead and run Terraform to create
    our instance using our Terraform file as a blueprint. First, we need to set the
    access and secret access keys for Terraform to use. In your terminal, you can
    enter the following commands to do this:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 此时，我们应该已经准备好运行 Terraform，使用我们的 Terraform 文件作为蓝图来创建实例。首先，我们需要为 Terraform 设置访问密钥和秘密访问密钥。在你的终端中，你可以输入以下命令来完成此操作：
- en: '[PRE10]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Those commands are simply run from your terminal and create environment variables
    containing the required keys. Terraform will look for the existence of the `AWS_ACCESS_KEY_ID`
    and `AWS_SECRET_ACCESS_KEY` variables when it runs, and by exporting them, we’re
    making them available in our session. There’s actually a way you can add the keys
    right into the Terraform file itself, but we don’t want to do that, because then
    the key might get uploaded somewhere public if we do upload the entire file somewhere.
    There’s also a way to set up variables within the Terraform file to include these
    keys, but that’s beyond the scope of this chapter.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 这些命令只是从你的终端运行，并创建包含所需密钥的环境变量。当 Terraform 运行时，它会查找`AWS_ACCESS_KEY_ID`和`AWS_SECRET_ACCESS_KEY`变量的存在，通过导出它们，我们让它们在当前会话中可用。实际上，你也可以将密钥直接添加到
    Terraform 文件中，但我们不建议这么做，因为如果我们将整个文件上传到公共场所，密钥可能会被泄露。你也可以在 Terraform 文件中设置变量来包含这些密钥，但那超出了本章的讨论范围。
- en: 'After exporting the variables, we need to initialize Terraform to ensure it
    has the required components it needs to interact with AWS:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 导出变量后，我们需要初始化 Terraform，以确保它拥有与 AWS 交互所需的所有组件：
- en: '[PRE11]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: With that example, you can add the full path to the `terraform` utility if it’s
    not in a shared `$PATH` location, such as `/usr/local/bin`, which is a recommended
    location that I mentioned earlier. If you did copy it to `/usr/local/bin`, then
    you should be able to simply type `terraform` instead of the full path.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这个示例，如果`terraform`工具不在共享的 `$PATH` 路径中，你可以添加完整路径，例如 `/usr/local/bin`，这是我之前提到的推荐位置。如果你将它复制到`/usr/local/bin`，那么你应该可以直接输入
    `terraform`，而不需要完整路径。
- en: 'The `terraform init` command instructs Terraform to initialize itself. It will
    look at any Terraform files you have in your current working directory and look
    for the `provider` line. In our case, that’s at the beginning of the file. We
    set it to `aws`. This will trigger Terraform to download the provider add-on for
    AWS:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: '`terraform init` 命令指示 Terraform 进行初始化。它会查看您当前工作目录中的所有 Terraform 文件，并查找 `provider`
    行。在我们的案例中，这一行位于文件的开头。我们设置为 `aws`。这将触发 Terraform 下载 AWS 的提供程序插件：'
- en: '![](img/B18425_20_07.png)'
  id: totrans-97
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B18425_20_07.png)'
- en: 'Figure 20.7: Initializing Terraform'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 图 20.7：初始化 Terraform
- en: As you can see from *Figure 20.7*, when I ran the command on my end, it downloaded
    the AWS provider to prepare it for use.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 从*图 20.7*中可以看到，当我在本地运行该命令时，它下载了 AWS 提供程序，以便进行后续使用。
- en: 'Next, we should run what’s known as a **Terraform plan**. Running a plan instructs
    Terraform to *not* make any changes but instead to check your syntax and ensure
    that you haven’t mistyped anything:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们应该运行一个叫做**Terraform 计划**的命令。运行该命令会指示 Terraform *不*进行任何更改，而是检查您的语法并确保您没有输入错误：
- en: '[PRE12]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The `terraform plan` command doesn’t just check syntax, it will connect to your
    provider, in our case AWS, to do an inventory and compare the changes in the configuration
    file to the current state of the provider. If it’s unable to connect to the provider,
    an error will be returned. If the connection is successful, Terraform will list
    all the changes it would’ve made if you instructed it to actually perform the
    tasks. In `plan` mode, it will never actually carry out any instructions but merely
    provide you with a preview.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: '`terraform plan` 命令不仅仅是检查语法，它还会连接到您的提供者，在我们这个例子中是 AWS，进行清单盘点，并将配置文件中的更改与提供者的当前状态进行比较。如果无法连接到提供者，则会返回错误。如果连接成功，Terraform
    会列出它本来会做出的所有更改，前提是您指示它执行这些任务。在 `plan` 模式下，它永远不会实际执行任何指令，而只是为您提供预览。'
- en: 'If for some reason Terraform can’t connect to your AWS account, you should
    make sure you’ve run the two `export` commands earlier, and that you’ve done so
    with the appropriate values. If you close your terminal window, you’ll need to
    run those `export` commands again since those environment variables do not persist
    between terminal sessions. If successful, the Terraform plan will run:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 如果由于某种原因 Terraform 无法连接到您的 AWS 账户，您应确保之前已运行过两个 `export` 命令，并且使用了正确的值。如果您关闭了终端窗口，您需要重新运行这些
    `export` 命令，因为这些环境变量不会在终端会话之间持久化。如果成功，Terraform 计划将会运行：
- en: '![](img/B18425_20_08.png)'
  id: totrans-104
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B18425_20_08.png)'
- en: 'Figure 20.8: Running a Terraform plan'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 图 20.8：运行 Terraform 计划
- en: In *Figure 20.8*, I’ve left off quite a bit of output. If your plan run was
    successful, Terraform will provide you with an overview of all the changes Terraform
    would’ve made if you were actually telling it to provision infrastructure.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 在*图 20.8*中，我已经省略了大量输出。如果您的计划运行成功，Terraform 会提供有关所有更改的概览，这些更改本来会在您实际指示它来配置基础设施时发生。
- en: 'If you would like to actually perform the changes, you can run a Terraform
    `apply` command. Before you do that though, always make it a habit to look at
    the output of the plan first. Notice the following line in the output:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想要实际执行这些更改，您可以运行 Terraform `apply` 命令。然而，在执行之前，始终养成先查看计划输出的习惯。请注意输出中的以下一行：
- en: '[PRE13]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: In our case, it’s not going to destroy or change anything, but it’s going to
    add something if it were to run. If you scroll up, you can find additional detail
    about the changes it might make if we were to run an `apply`. Pay special attention
    to what it might want to destroy. For some changes, Terraform may deem it necessary
    to delete something and recreate it from scratch. If you’re using Terraform to
    update an existing server, you most likely won’t want that server to be deleted.
    In that case, don’t continue and run an `apply`. Always scrutinize the changes
    Terraform wants to make *before* you proceed and have it actually perform tasks.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的例子中，它不会销毁或更改任何内容，但如果运行，它会添加一些内容。如果您向上滚动，您可以找到更多关于它可能会做出的更改的详细信息，特别是如果我们运行
    `apply` 的话。特别注意它可能想要销毁的内容。对于某些更改，Terraform 可能认为有必要删除某些内容并从头开始重新创建。如果您使用 Terraform
    更新现有服务器，您很可能不希望删除该服务器。在这种情况下，请不要继续运行 `apply`。在您继续并实际让它执行任务之前，始终仔细审查 Terraform
    想要做的更改*before*。
- en: 'Next, assuming we’re comfortable with the changes, we’ll proceed with an `apply`.
    Keep in mind that although running a plan with Terraform will cause it to look
    for and report syntax errors, passing the plan process with no syntax errors reported
    doesn’t mean that there aren’t any. There’s only so much Terraform can do before
    you actually run it, so there may be errors that it can only catch during an `apply`.
    As you can guess, the command to run the `apply` is fairly obvious:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，假设我们对更改已经感到满意，我们将继续执行 `apply`。请记住，虽然通过 Terraform 运行计划时，它会查找并报告语法错误，但计划过程通过且没有报告语法错误并不意味着没有错误。在实际运行之前，Terraform
    能做的检查有限，因此可能存在它只能在 `apply` 过程中捕捉到的错误。正如你可以猜到的，运行 `apply` 的命令非常显而易见：
- en: '[PRE14]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'When it runs, the `terraform apply` command will run another sanity check,
    show the number of changes again, and ask if you’d like to continue:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 当运行时，`terraform apply` 命令会再次进行健康检查，重新显示更改的数量，并询问你是否希望继续：
- en: '![](img/B18425_20_09.png)'
  id: totrans-113
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B18425_20_09.png)'
- en: 'Figure 20.9: Running the terraform apply command'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 图 20.9：运行 terraform apply 命令
- en: 'To proceed, type `yes` and press *Enter*. As it runs, you can actually see
    the resources you’re having Terraform create show up in the AWS console as they’re
    being provisioned. In the case of an EC2 instance as we’re doing here, we’ll be
    able to see the new instance in the list as it comes up:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，输入 `yes` 并按 *Enter*。在运行过程中，你实际上可以看到正在创建的资源出现在 AWS 控制台中，随着它们的配置完成。在这里，以创建
    EC2 实例为例，我们可以看到新的实例出现在列表中：
- en: '![](img/B18425_20_10.png)'
  id: totrans-116
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B18425_20_10.png)'
- en: 'Figure 20.10: An instance showing up in the EC2 list in AWS, created by Terraform'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 图 20.10：由 Terraform 创建的 EC2 实例在 AWS 中的实例列表中显示
- en: 'If all goes well, Terraform itself will report the process as being successful:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一切顺利，Terraform 本身会报告进程成功：
- en: '![](img/B18425_20_11.png)'
  id: totrans-119
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B18425_20_11.png)'
- en: 'Figure 20.11: A successful terraform apply'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 图 20.11：成功的 terraform apply 过程
- en: Now we’ve created an EC2 instance in AWS, and we did so by utilizing automation.
    Sure, it hasn’t done all that much for us yet, but this is just a proof of concept.
    There are many things we can do with Terraform.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经在 AWS 中创建了一个 EC2 实例，并且是通过自动化实现的。虽然目前它对我们帮助不大，但这只是一个概念验证。我们可以通过 Terraform
    做很多事情。
- en: There’s something missing, though—security! We should also automate the process
    of adding a security group to the instance, which will provide us with the access
    we need to be able to connect to it and manage it. We’re able to access the instance
    now, but it’s very possible that it doesn’t have external internet access yet.
    In the next section, we’ll configure the security group for the instance as well,
    which will allow us to configure which ports are open and which IP addresses are
    able to communicate with our instance.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 不过，缺少了一样东西——安全性！我们还应该自动化将安全组添加到实例的过程，这样我们就能获取连接并管理实例所需的访问权限。现在我们能够访问该实例，但很可能它还没有外部互联网访问权限。在下一节中，我们将为实例配置安全组，这样我们就可以配置哪些端口是开放的，哪些
    IP 地址能够与我们的实例进行通信。
- en: Managing security groups with Terraform
  id: totrans-123
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Terraform 管理安全组
- en: Security groups, as you learned in the previous chapter, allow you to control
    what is able to communicate with your resources. In the previous section, we reused
    the security group that we created last time, but it would be useful to understand
    how to create one from scratch.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 安全组，如你在前一章中学到的，允许你控制哪些资源可以与其他资源进行通信。在上一节中，我们复用了上次创建的安全组，但理解如何从头开始创建一个安全组也是很有用的。
- en: 'Here’s the example Terraform file again, with some new code added:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 这是更新后的示例 Terraform 文件，添加了一些新的代码：
- en: '[PRE15]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'I’ve added an entirely new section to the file, but before we get to that,
    I also changed a line from the previous example. It’s the tenth line down:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 我在文件中添加了一个全新的章节，但在进入这一部分之前，我还修改了之前示例中的一行。它是第十行：
- en: '[PRE16]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Previously, we set the security group ID for this line in the file to the security
    group ID that already existed, the one we created in the previous chapter. The
    configuration I’ve added further down will create a new security group, and here
    I’m setting the security group ID to a variable instead. The `${aws_security_group.external_access.id}`
    variable that was set here is known to Terraform as an **output variable**. We
    use an output variable for the security group ID because we have no idea what
    the security group ID will be since the new security group hasn’t even been created
    yet. Therefore, we use an output variable here and reference the name of the security
    group we’ll be creating (`external_access`) with `.id` at the end, which will
    reference the security group ID once it’s created. That way, we can reference
    a security group here and assign it to the instance, without having to know ahead
    of time what its ID will be.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 之前，我们将文件中的这一行的安全组ID设置为已经存在的安全组ID，也就是我们在上一章创建的那个安全组ID。接下来我所添加的配置将在文件的后面创建一个新的安全组，并且这里我将安全组ID设置为一个变量。`${aws_security_group.external_access.id}`变量在这里被Terraform视为**输出变量**。我们使用输出变量来表示安全组ID，因为我们无法预知安全组ID是什么，因为新的安全组还没有创建。所以，我们在这里使用输出变量，并通过`.id`来引用我们将要创建的安全组（`external_access`）的ID，这样一旦安全组创建完成，我们就可以引用它的ID。这样，我们就可以在这里引用一个安全组并将其分配给实例，而不需要事先知道它的ID。
- en: 'Further down the file, we begin a new section:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 在文件的后面，我们开始了一个新部分：
- en: '[PRE17]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: With that line, we’re telling Terraform we’d like to create another new resource,
    this time a security group. We’re giving this security group a name of `external_access`,
    which is just a name within Terraform we can reference it as, not an actual name
    it will be called within AWS.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这一行，我们告诉Terraform我们希望创建另一个新的资源，这次是一个安全组。我们给这个安全组起了一个名为`external_access`的名字，这只是Terraform中的一个引用名称，并不是它在AWS中实际使用的名字。
- en: '[PRE18]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Here, we’re giving the security group its actual name, the name we’ll see it
    shown as within AWS outside of Terraform.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，我们为安全组指定了它的实际名称，这是我们在AWS中看到的名称，而不是Terraform内部的名称。
- en: '[PRE19]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'For the `description` line, there’s nothing too surprising here: we’re giving
    it a description we can use to describe its purpose and what the security group
    will be used for. Similar to the security group we’ve created manually in the
    previous chapter, we’ll be opening up OpenSSH and Apache with this security group.'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 对于`description`行，这里没有什么令人惊讶的地方：我们给它一个描述，用来解释其用途和安全组将要执行的功能。与我们在上一章手动创建的安全组类似，我们将通过这个安全组打开OpenSSH和Apache。
- en: '[PRE20]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: The `ingress` block allows us to set a port to allow connections to come in
    from; in this case, we’re allowing connections from port `22`, which, as you probably
    already know, is the default port for OpenSSH. We don’t want to open this port
    up to receive connections from the entire public internet, so we’re allowing the
    incoming traffic to this port only if it’s coming from an IP address of `172.11.59.105/32`.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: '`ingress`块允许我们设置一个端口，允许从该端口接收连接；在这种情况下，我们允许从`22`端口接收连接，正如你可能已经知道的，`22`端口是OpenSSH的默认端口。我们不希望将此端口对所有公开互联网开放，因此我们只允许来自`172.11.59.105/32`
    IP地址的流量进入该端口。'
- en: In your case, you can replace that with the public IP address of your home office
    or organization.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 在你的情况下，你可以将其替换为你家庭办公室或组织的公共IP地址。
- en: 'The second `ingress` block is the same as the first, only this time it’s allowing
    connections to port `80` for Apache:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个`ingress`块与第一个相同，只是这次它允许连接到`80`端口用于Apache：
- en: '[PRE21]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'We also add an `egress` security group rule as well because, without this,
    our instance will not be able to reach the internet:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还添加了一个`egress`安全组规则，因为如果没有这个规则，我们的实例将无法访问互联网：
- en: '[PRE22]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: As with the previous example, we’ll need to run a plan and then an `apply` to
    transform our new code into reality. I’ll leave it up to you to run both; as long
    as you haven’t mistyped anything, it should apply the changes and add the new
    security group. Inside AWS, you should see the new security group in the console,
    and also see it applied to your EC2 instance. Unless you reused the AMI from the
    previous chapter with Apache built in, you won’t be able to connect to the instance
    via port `80` since Apache is probably not installed, but I added it just to show
    you an example.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 和之前的示例一样，我们需要先运行一个计划，然后再运行 `apply`，将我们的新代码变成现实。具体的操作我交给你来完成；只要没有输入错误，它应该会应用更改并添加新的安全组。在
    AWS 中，你应该能在控制台看到新的安全组，并且它应该已应用到你的 EC2 实例上。除非你重复使用了上一章节中带有 Apache 的 AMI，否则你无法通过端口
    `80` 连接到该实例，因为 Apache 很可能没有安装，但我添加了它来给你一个示例。
- en: At this point, I recommend that you play around with the Terraform script we
    have so far, to get a feel for its syntax. Feel free to implement something extra;
    you can refer to the Terraform documentation for additional resources you can
    create with Terraform.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个阶段，我建议你先尝试一下我们目前的 Terraform 脚本，熟悉它的语法。你可以随意增加一些额外内容；可以参考 Terraform 文档，了解你可以使用
    Terraform 创建的其他资源。
- en: Congratulations on using Terraform to provision your infrastructure. Now, let’s
    use Terraform to destroy stuff.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 恭喜你成功使用 Terraform 来配置基础设施。现在，让我们用 Terraform 来销毁资源。
- en: Using Terraform to destroy unused resources
  id: totrans-147
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Terraform 销毁未使用的资源
- en: Although Terraform’s primary purpose is to create infrastructure, it can also
    be used to delete infrastructure as well. This function is known as a **Terraform
    destroy**. With `destroy`, Terraform will attempt to remove all infrastructure
    that’s defined in your configuration file. At this point, our configuration file
    creates an EC2 instance, as well as a security group. If we run `destroy` against
    it, then both resources will be removed.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管 Terraform 的主要目的是创建基础设施，但它也可以用于删除基础设施。这一功能被称为**Terraform destroy**。使用 `destroy`
    命令时，Terraform 会尝试删除配置文件中定义的所有基础设施。在此阶段，我们的配置文件创建了一个 EC2 实例以及一个安全组。如果我们运行 `destroy`，这两个资源都将被删除。
- en: Removing infrastructure with Terraform will likely be a use case you won’t utilize
    as often as creating resources. One of the values of the `destroy` functionality,
    though, is that you can use it to “reset” a test environment, by removing everything
    defined in the file. Then you’re free to use the same script to create everything
    again. On my end, I learn a lot faster by breaking things and fixing them repeatedly.
    You really shouldn’t run a `destroy` job against production infrastructure that
    you care about, but if you’re just using Terraform in a test account that doesn’t
    have any important instances inside it, then you can continually build and dismantle
    your test resources over and over as you learn. Another benefit is that an organization
    may test a Terraform build for a client in a test account first before implementing
    it in production, and you can verify that everything will be built correctly before
    performing the actual work for the client.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 Terraform 删除基础设施可能不会像创建资源那样频繁。但是，`destroy` 功能的一个价值在于，你可以通过删除文件中定义的所有内容来“重置”一个测试环境。然后，你可以使用同一脚本重新创建所有资源。在我这里，我通过不断打破和修复事物来加速学习。你真的不应该在生产环境中运行
    `destroy`，尤其是对于那些你关心的基础设施，但如果你只是在一个没有重要实例的测试账户中使用 Terraform，那么你可以在学习过程中反复构建和拆解你的测试资源。另一个好处是，一个组织可以先在测试账户中为客户测试
    Terraform 构建，然后再将其实施到生产环境中，你可以在为客户执行实际工作之前验证一切是否能够正确构建。
- en: 'Performing a `destroy` within Terraform is just as simple as previous examples:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Terraform 中执行 `destroy` 和之前的示例一样简单：
- en: '[PRE23]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Just like before, we’ll get confirmation first before it removes everything,
    showing us exactly what Terraform wants to remove when a `destroy` task is run:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 就像之前一样，我们首先会获得确认，然后它会告诉我们当运行 `destroy` 任务时，Terraform 想要删除哪些内容：
- en: '![](img/B18425_20_12.png)'
  id: totrans-153
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B18425_20_12.png)'
- en: 'Figure 20.12: Preparing to run terraform destroy to remove resources'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 图 20.12：准备运行 terraform destroy 来删除资源
- en: 'Pay careful attention to what Terraform wants to delete when you run it with
    the `destroy` option. The screenshot doesn’t show the full output; it’s quite
    long. Similar to `apply`, if you scroll up, you’ll see that the output will contain
    detail about what in particular will be removed if we agree to continue. If you
    type `yes` and press *Enter*, the resources identified will be destroyed, and
    you’ll receive a confirmation message confirming that the task was carried out:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B18425_20_13.png)'
  id: totrans-156
  prefs: []
  type: TYPE_IMG
- en: 'Figure 20.13: Final confirmation after destroying previously provisioned resources'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
- en: Basic usage of the `terraform` command is logically structured; we looked at
    how to run a `plan` as well as an `apply`, and now we know how to destroy our
    resources as well so we can start over with a clean slate. The majority of the
    time spent learning Terraform will be a matter of learning the syntax of its config
    files, but that will come in time. At this point in our journey, we should have
    a solid foundation we can build upon.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
- en: However, we’re not done yet! I’ve referenced Ansible several times in this chapter,
    reminding you about the fact that we used it in the past to configure a server.
    But what if I told you we can combine Terraform and Ansible? We certainly can,
    and we’ll do so in the next section.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
- en: Combining Ansible with Terraform for a full deployment solution
  id: totrans-160
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'One of the best things about automation tools is that they can often be combined
    to offer a shared benefit. Ansible is one of my favorite tools: you can automate
    the installation of packages, the creation of users, the copying of files, or
    most other tasks you can think of. If you are able to perform a task on the command
    line, chances are Ansible can automate it. Terraform, as you just saw, is really
    good at creating new infrastructure and automating the initial setup of servers,
    as well as networks and settings for AWS and other platforms. If we combine the
    two, it gets even better.'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
- en: I find the duo of Terraform and Ansible to be a great fit. Combining these two
    solutions works well in my experience; we can use Terraform to create our initial
    server and infrastructure builds, and then use Ansible to automate future enhancements.
    But it’s actually even better than that; we can configure Terraform to actually
    launch the initial Ansible run for us, so we only have to run a single script.
    After Terraform creates the infrastructure, provisioning of additional settings
    is handed off to Ansible. It’s a great combination.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
- en: 'How does it work? In the previous chapter, we explored the concept of user
    data, which is a feature within AWS that allows you to run a script as an instance
    is being created. We used it to install all the patches and then proceed and install
    Apache. The example we went over was a simple Bash script and wasn’t very exciting
    in and of itself. Sure, it did work, but we can implement a better solution. And
    you know what? We already have. In *Chapter 15*, *Automating Server Configuration
    with Ansible*, we were able to utilize Ansible Pull, a special mode of Ansible
    that allows us to pull code from a repository, and run it locally on our instance.
    The Ansible playbook we wrote installs Apache for us, the same as our Bash script
    did in the previous chapter. As a refresher, we are able to run the following
    command to trigger Ansible Pull:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Of course, this requires Ansible itself to be installed, and the repository
    needs to already exist. If you have already followed along in that chapter and
    you still have the repository we’ve created, then you already have what you need
    to combine Ansible with Terraform.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
- en: 'To save you the trouble of flipping back to *Chapter 15*, *Automating Server
    Configuration with Ansible*, here’s the final `local.yml` file we ended up with:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'As you can see, this playbook is installing Apache, starting it, and also copying
    an `index.xhtml` file to replace the default web page. It’s fairly easy to implement
    this in Terraform. Here’s our Terraform script again, with a new line added, shown
    in bold:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'The new addition to the file is on line #11\. We’re referencing a bootstrap
    script, and in that script, we’ll add any commands we wish to run on the newly
    created instance:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: '`bootstrap.sh` will need to exist in the same directory as the Terraform configuration
    file itself. The file doesn’t exist yet though, so go ahead and create it, and
    inside you can place the following lines:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: We haven’t made an overly complex change to the file, but what we did add gives
    us a great deal of benefits. The `user_data` option allows us to leverage the
    same user data function that’s built into AWS and schedule commands to run when
    an instance is first created. In this example, we utilize the `user_data` option
    to run a series of commands against the new instance, which will install Ansible
    and then launch `ansible-pull` to download a repository containing an Ansible
    playbook and run it locally. The playbook itself was set up in *Chapter 15*, *Automating
    Server Configuration with Ansible*, so we’re just leveraging what we’ve already
    created in the past, and we’re having Terraform kick off the Ansible job for us
    when it brings up the instance.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
- en: That brings us to the end of this chapter. I hope setting up automation with
    Terraform was a fun experience; I definitely enjoy working with it.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-176
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are many configuration management and provisioning tools available for
    automating our infrastructure builds. In this chapter, we took a look at Terraform,
    and then we even combined it with Ansible, which we were already using. Using
    Terraform, we were able to automate the creation of an EC2 instance in AWS, along
    with a security group to control how it can be accessed. Terraform is a very large
    subject, and the concepts contained in this chapter are only the beginning. There’s
    so much more you can do with Terraform, and I highly recommend you keep practicing
    with it and coming up to speed.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 有许多配置管理和资源提供工具可用于自动化我们的基础设施构建。在这一章中，我们介绍了 Terraform，并且将其与我们已经在使用的 Ansible 结合起来。通过使用
    Terraform，我们能够自动化在 AWS 中创建一个 EC2 实例，并设置一个安全组来控制如何访问它。Terraform 是一个非常庞大的话题，本章中的概念只是一个开始。你可以用
    Terraform 做很多事情，我强烈推荐你继续练习，尽快掌握它。
- en: In the next chapter, we’re going to learn some methods we can utilize to add
    additional security to our Ubuntu servers. While no server is bulletproof, there’s
    a basic level of security we can implement that will make it less likely for our
    server to be compromised. It will be a very important chapter, so you won’t want
    to miss it.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将学习一些可以用来为我们的 Ubuntu 服务器添加额外安全性的方式。虽然没有任何服务器是百分百安全的，但我们可以实施一些基本的安全措施，使服务器被攻破的可能性降低。这将是一个非常重要的章节，你一定不想错过。
- en: Join our community on Discord
  id: totrans-179
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 加入我们在 Discord 的社区
- en: 'Join our community’s Discord space for discussions with the author and other
    readers:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 加入我们社区的 Discord 空间，与作者和其他读者进行讨论：
- en: '[https://packt.link/LWaZ0](https://packt.link/LWaZ0)'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://packt.link/LWaZ0](https://packt.link/LWaZ0)'
- en: '![](img/QR_Code50046724-1955875156.png)'
  id: totrans-182
  prefs: []
  type: TYPE_IMG
  zh: '![](img/QR_Code50046724-1955875156.png)'
