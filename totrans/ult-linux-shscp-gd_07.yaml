- en: '7'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Text Stream Filters – Part 2
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we’ll continue our look at various text-stream filters. As
    you go through this chapter, I challenge you to use your imagination. Instead
    of thinking of these filter utilities as something you have to learn because I
    said so, or because you need to learn them for a Linux certification exam, try
    to imagine the ways in which each of these utilities can help you format your
    own text files and reports. Trust me, you’ll never know when one or more of these
    utilities could come in handy.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are the topics that we’ll cover in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Using `expand`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using `unexpand`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using `nl`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using `head`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using `tail`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using `head` and `tail` together
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using `od`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using `uniq`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using `wc`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using `fmt`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using `split`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using `tr`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using `xargs`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using `pr`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Printing from the Command-line
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: They’re not hard to master, but there is a lot to cover. So if you’re ready,
    let’s get started.
  prefs: []
  type: TYPE_NORMAL
- en: Technical Requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Use either of your virtual machines, because things will work the same on either
    of them. Or, if your host machine is running either Linux or macOS, feel free
    to use it instead of a virtual machine. I won’t be providing an actual hands-on
    lab, so feel free to follow along on your own machine as you read through the
    chapter. And, as before, you can download the text files that you’ll need from
    the GitHub repository.
  prefs: []
  type: TYPE_NORMAL
- en: Using expand
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There may be times when a text document that you create with columnar data just
    won’t display correctly under certain circumstances. It may be because you separated
    the columns with tabs instead of with spaces. Sometimes, tabs won’t display correctly,
    and you’ll need to replace them with spaces.
  prefs: []
  type: TYPE_NORMAL
- en: 'To look at this, create the `expand.txt` text file. There will be three columns
    of data with two tabs between each column. The file will look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, expand the file and note the output. It should look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Since I still have this creepy habit of reading your mind, I know that you’re
    wondering what’s really going on, since the expanded output looks the same as
    the original file. This is where looks can be deceiving. When you expanded the
    file, each tab that you placed between the columns was replaced by a number of
    blank spaces. The number of spaces varies from line-to-line, depending upon how
    many characters are in each text string. That way, the columns will still all
    line up evenly.
  prefs: []
  type: TYPE_NORMAL
- en: Actually, expand replaces each whole tab character with eight spaces. But when
    you have text strings of varying lengths, it doesn’t appear to do that. That’s
    because expand adjusts the number of blank spaces it inserts to keep all of the
    columns lined up. If you have a text file with more than one tab between the columns
    and with varying length text strings, all but one of the tabs will be replaced
    by exactly eight spaces.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you want to prove this, save the expanded output to a new file, and then
    open the new file with your favorite text editor. In my case, I’ll use `vim`,
    like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Now, move your cursor to the blank area between two of the columns. Move to
    the left or right between the columns, and you’ll see that you’ll only move one
    space at a time. Close this file, and open the original file. When you move the
    cursor between the columns of this file, you’ll see that it moves by the length
    of a tab, instead of by just one space.
  prefs: []
  type: TYPE_NORMAL
- en: There are two options that you can use with expand. The first is the `-t` option.
    This lets you set the number of spaces you want to use in place of the tabs, instead
    of using the default of eight. Here, we want to replace each tab with only two
    blank spaces.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: With only two spaces replacing each tab, `expand` failed to keep the columns
    properly aligned. Feel free to experiment with other `-t` values to see how things
    turn out.
  prefs: []
  type: TYPE_NORMAL
- en: 'With the `-i` switch, you can instruct `expand` to only replace tabs that are
    at the beginning of each line. Subsequent tabs in each line will remain unaltered.
    To see how it works, copy the `expand_1.txt` file to the `expand_1a.txt` file,
    like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Open expand_1a.txt in your text editor, and insert one tab at the beginning
    of line 1, two tabs at the beginning of line 2, and three tabs at the beginning
    of line 3\. The edited file should now look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Using the -i option, expand this file into the expand_1b.txt file, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Open `expand_1b.txt` in your text editor, and verify that only the tabs that
    preceded each line were replaced with blank spaces.
  prefs: []
  type: TYPE_NORMAL
- en: Guess what? That’s all I have to say about `expand`. Now, let’s go in the opposite
    direction.
  prefs: []
  type: TYPE_NORMAL
- en: Using unexpand
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that I’ve told you what `expand` does, do I really need to tell you what
    `unexpand` does? That’s right, you guessed it. `unexpand` removes the blank spaces
    from between columns, and replaces them with tabs. There are a couple of slight
    catches, though. By default, `unexpand` only operates on spaces that are at the
    beginning of a line. That’s just the opposite of how expand works with tabs. So,
    if you want to replace all spaces in a line with tabs, you’ll need to use the
    `-a` switch. The second catch is that by default, `unexpand` only works if it
    sees eight consecutive blank spaces. Any grouping of fewer than eight consecutive
    blank spaces won’t get converted to tabs. (You can change that behavior with the
    `-t` switch, as you’ll see in a few moments.)
  prefs: []
  type: TYPE_NORMAL
- en: 'I’ll demonstrate by unexpanding the `expand_2.txt` file that I’ve just created
    in the `expand` section, using the `-a` option, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Again, you can’t really tell the difference. To see the difference, save the
    results to a new file, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Open the new file in your favorite text editor. Now, when you move your cursor
    between the columns, you’ll see that it jumps by the length of a tab, instead
    of by just one space. In other words, it’s now just like the original file that
    I expanded in the previous section.
  prefs: []
  type: TYPE_NORMAL
- en: This works because when I used `expand` to create the `expand_2.txt` file, the
    tabs between the columns were all replaced by eight or more blank spaces.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, I told you before that by default, `unexpand` only operates on the blank
    spaces that are at the beginning of a line. To see that, open the `expand_3.txt`
    file, which will look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: It’s rather ugly because nothing is in alignment, but in this case that’s what
    we want. The first line is preceded by eight blank spaces, the second line is
    preceded by four blank spaces, and the third line is preceded by two blank spaces.
    Between the columns are varying numbers of blank spaces.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, create the `unexpand_2.txt` file by unexpanding the `expand_3.txt` file,
    like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Open the `unexpand_2.txt` file in your text editor and verify that only the
    eight blank spaces at the beginning of the first line were replaced by a tab.
    Close the file and repeat the command with the `-t4` option, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: This time, you should see that the blank spaces at the beginning of both lines
    1 and 2 have been replaced by tabs. Try this again with the `-t2` option, and
    you’ll see that the blank spaces that precede all three lines are replaced by
    tabs. Finally, run these commands again with the `-a` option to perform a global
    replacement of the blank spaces.
  prefs: []
  type: TYPE_NORMAL
- en: I have to confess that for a long time, I never thought that I would use either
    `expand` or `unexpand` for anything. But, I was wrong. Several years ago, a former
    client tasked me with teaching a Kali Linux course. The book that I was using
    had a shell script that was supposed to automatically extract the IP address from
    the output of the `ifconfig` command. The script didn’t work though, because after
    the author wrote the book someone changed the `ifconfig` code so that the output
    would be formatted differently.
  prefs: []
  type: TYPE_NORMAL
- en: I had to modify the script to make it work, and I used either `expand` or `unexpand`
    as part of the fix. (That was long ago, so I don’t remember which one I used.
    But, that doesn’t matter.) So, it goes to show that you just never know. (Yes,
    I am a poet.)
  prefs: []
  type: TYPE_NORMAL
- en: Okay, enough of expanding and unexpanding. Let’s do some numbering.
  prefs: []
  type: TYPE_NORMAL
- en: Using nl
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `nl` utility is used for numbering lines of a text file. It’s easy to use,
    and there are only a few options that you need to remember. Let’s start by creating
    a file with ten consecutive lines, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Let’s number the lines in the file, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Now, let’s create another file just like this one, except that we’ll insert
    a few blank lines.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Again, we’ll number this file without specifying any options.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: If you don’t specify any options, only the non-blank lines will be numbered.
    Use the `-b` switch with the appropriate options to change that behavior. With
    the `a` option, you can number all lines, including the blanks. (By the way, the
    `-b` switch stands for **body**. In other words, this switch sets the way in which
    `nl` numbers lines in the body of the file. In just a moment, I’ll show you how
    this comes into play.)
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: The `-bt` option causes `nl` to only number non-empty lines in the text file
    body, while the `-bn` option tells `nl` not to number lines at all in the text
    file body. This may sound a bit strange to you, since the first option defines
    what is already default behavior, and the second option seems to defeat the whole
    purpose of using `nl`. I’ll clarify all of this in just a moment.
  prefs: []
  type: TYPE_NORMAL
- en: When you create a text file, you can use a special set of delimiters to define
    a header, a body, and a footer that will be used by `nl`.
  prefs: []
  type: TYPE_NORMAL
- en: As you can see in the following diagram, you do this by placing the appropriate
    series of backslashes and colons at the start of each section.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B21693_07_01.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 7.1: The header, body, and footer sections of a text file'
  prefs: []
  type: TYPE_NORMAL
- en: 'Three of each character defines the header, two of each defines the body, and
    one of each defines the footer. The `nl` utility allows you to number each of
    these sections in its own way. Put this to the test by creating your own three-section
    text file, which will look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'When using `nl` without specifying any options, only the non-blank lines in
    the body will get numbered, as you see here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'To number lines in the header and footer, you would use the `-h` and the `-f`
    switches. The options that go with those switches are the same as the ones that
    go with the `-b` switch. So, to number all lines in the header as well as the
    non-blank lines in the body, you would use the `-ha` option, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'To number only non-blank lines in the header and non-blank lines in the body,
    use the `-ht` option, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, let’s number all lines in the footer, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'This time, the footer got numbered, but the header didn’t. In both cases, the
    non-blank lines in the body got numbered, even though I didn’t specify for `nl`
    to do that. To prevent `nl` from numbering lines in the body while numbering all
    lines in both the header and footer, include the `-bn` option, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'You can also have `nl` search for lines that contain a certain text string,
    and number only those lines. For this, you would use the `p` option. Let’s take
    our first text file, which we’ll call `lines.txt`, and number only the line that
    contains the word `seven`. (Note that you can’t have a space between the `p` and
    the string for which you’re searching.) It will look something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Now, let’s create a file that’s a tad bit more realistic. We’ll even go all
    out and give it header, body, and footer.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, number every line in the body that contains the word `MacGruder`, like
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'If you specify for `nl` to only number the `MacGruder` lines for the header
    and/or the footer without specifying anything for the body, `nl` will also number
    all non-blank body lines by default, as you see here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Include the `-bn` option to only number the `MacGruder` lines in the header
    and/or footer, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: And now, you’re wondering when you would ever create a text file with these
    `nl`-style headers and footers. Well, the answer is--drum-roll, please--I have
    no idea. After some rather extensive research, I’ve not found any other utility
    that displays these headers and footers as actual headers and footers. In fact,
    the utilities I’ve found that convert text files to other formats can insert their
    own headers and footers, but they’ll display the `nl`-style headers and footers
    as just part of the normal document.
  prefs: []
  type: TYPE_NORMAL
- en: However, `nl` is still useful for times when you need to insert line numbers
    into files that consist of nothing but a body. Also, if you plan to take a Linux
    certification exam, you’ll need to know about the header, body, and footer concept
    of `nl`-style text files, because you just might see some questions about it.
  prefs: []
  type: TYPE_NORMAL
- en: 'The man page for `nl` is seriously deficient, so you’ll instead want to consult
    the info page for more `nl` information and options. The command to run for that
    is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: That does it for `nl`. Let’s move on ahead.
  prefs: []
  type: TYPE_NORMAL
- en: Using head
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If you only want to view a certain number of lines from the beginning of a text
    file, use the `head` utility. To demonstrate, I’ll be showing you files that are
    here on my Fedora workstation. If you don’t have the same exact files on your
    own machine, feel free to use others.
  prefs: []
  type: TYPE_NORMAL
- en: By default, `head` displays the first ten lines of a file. I’ll show you in
    just a bit how to change that.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s start by entering the `/var/log/` directory, and looking at the first
    ten lines of the `boot.log` file, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Use the `-n` switch to change the number of lines that you want to see. To
    only see the first five lines, enter this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'In this case, the `-n` is optional. You’ll get the same results by running
    the command like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: The dash in front of the number means that the number is an option. It doesn’t
    mean that the number is negative. But, as you’ll see in a moment, some commands
    will require you to use the `-n`.
  prefs: []
  type: TYPE_NORMAL
- en: You can choose to view the first lines from more than one file at the same time
    by including multiple filenames in your command. Here, we’re looking at the first
    five lines of the `boot.log` file and the `cron` file.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: Use the `-q` option to enable quiet mode. That way, when you view lines from
    more than one file at a time, you won’t see the header lines for the files. (This
    could come in handy if you’re running `head` from within a shell script.)
  prefs: []
  type: TYPE_NORMAL
- en: 'Also, note how you can combine options with only one dash. In this case, use
    of the `-n` is mandatory if you want to set the number of lines that you want
    to see. Here’s what it looks like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'Use the `-n` option with a negative number to see all but the last `n` lines
    of a file. If you want to see all but the last 20 lines of the `boot.log` file,
    enter this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: Again, in this case, use of the `-n` is mandatory.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can look at a number of either bytes, kilobytes, or megabytes from the
    beginning of a file with the `-c` option. Here, we’re looking at the first 30
    bytes of the `boot.log` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: You see that the `-c` option has a slight quirk to it. For some reason, the
    newline command isn’t issued, and your new command prompt will end up on the same
    line as your output.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let’s look at the first two kilobytes of `boot.log` by placing a `k` after
    the `2`, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'To view the first two megabytes of this file, you would have placed an `m`
    after the `2`, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: If you’re wondering why a `c` is used to denote the number of bytes, it’s because
    *c* stands for *character*. One character just happens to be one byte in size.
    So, when you tell `head` or `tail` how many bytes you want to see, you’re really
    telling it how many characters you want to see.
  prefs: []
  type: TYPE_NORMAL
- en: That’s all for `head`. Let’s move back to the `tail`.
  prefs: []
  type: TYPE_NORMAL
- en: Using tail
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As you may have guessed, `tail` allows you to view lines from the end of a
    file. By default, it will display the last ten lines. Let’s take another look
    at the `boot.log` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: To specify the number of lines or bytes that you want to see, just use the same
    options that you used for `head`. There are however, a few options that `head`
    doesn’t have. For example, if you place a `+` in front of a number, you’ll be
    able to start your display from a certain line. Here, I’ve decided to view everything
    from line 33 to the end of the file.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: Note that the `-n` is mandatory for this.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can use the same trick to start the display at two kilobytes into the file,
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: If you’re wondering why a `c` is used to denote the number of bytes, it’s because
    *c* stands for *character*. One character just happens to be one byte in size.
    So, when you tell `head` or `tail` how many bytes you want to see, you’re really
    telling it how many characters you want to see.
  prefs: []
  type: TYPE_NORMAL
- en: 'The last option for tail is the `-f` option, which stands for *follow*. This
    option provides a running, changing display of a log file. For example, to view
    the last ten lines of the `secure` log file here on my Fedora machine, with the
    display changing as new events are added, I would enter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: When you’re through, just hit *Ctrl-c* to exit.
  prefs: []
  type: TYPE_NORMAL
- en: This could come in handy if you suspect that some nefarious activity may be
    taking place on your system, because it allows you to constantly monitor for security
    events as they pop up. Or, if you need to troubleshoot something, use this option
    to monitor your normal system log.
  prefs: []
  type: TYPE_NORMAL
- en: For our next trick, let’s see about using `head` and `tail` together.
  prefs: []
  type: TYPE_NORMAL
- en: Using Head And Tail Together
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You’ve seen how to use `head` to view lines from the beginning of a file, and
    how to use `tail` to view lines from the end of a file.
  prefs: []
  type: TYPE_NORMAL
- en: That’s all well and good, but what if you want to view selected lines from somewhere
    in the middle of a file? That’s easy. Just use `head` and `tail` together. Here’s
    how it works.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s say that you want to view lines 11 through 20 of a file with 39 lines.
    Just enter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'You can use `nl` to prove that you’re really seeing lines 11 through 20, like
    so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'You can make a lot of other combinations besides this one. (Again I say, you’re
    only limited by your own imagination.) If you want to look at lines 10 through
    15 of `boot.log`, enter this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'Again, you can use `nl` to prove that you’re looking at the correct lines,
    like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: And, that does it for `head` and `tail`. Let’s now have some real fun by doing
    some octal dumping.
  prefs: []
  type: TYPE_NORMAL
- en: Using od
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The **octal dump** (`od`) utility has a lot of options, and it would require
    quite a few pages to fully explore them. But, unless you’re a hard-core programmer,
    you’ll probably have need for only a very few of these options.
  prefs: []
  type: TYPE_NORMAL
- en: If you take a Linux certification exam, you may see a question or two about
    `od`. However, you probably won’t see any questions that cover `od` in any amount
    of depth. So for now, I’ll just cover the basics.
  prefs: []
  type: TYPE_NORMAL
- en: The name of this utility is a bit misleading. It does, by default, display file
    contents as octal byte-code. But, that’s not all that it does. By using the appropriate
    option switches, you can also use `od` to display file contents in several other
    formats. `od` is normally used to display the contents of binary files, but you
    can also use it to display non-printing characters in normal text files.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can display the contents of an entire file, or limit the amount of the
    file contents that you want to display. If you choose to display an entire file,
    you may want to either pipe the output into `less`, or redirect the output to
    a new text file. Let’s start by looking at part of the `od` output from the `echo`
    binary file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: Note how the left column starts at zero, and increments by 20 (octal) from one
    line to the next. Think of this column as the address column. The addresses can
    be used to mark and later find some particular data within the file. The rest
    of each line represents the actual data.
  prefs: []
  type: TYPE_NORMAL
- en: 'To view the file in other formats, use the `-t` switch with the appropriate
    option. For example, you can view the `echo` binary in hexadecimal format like
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: Note how the first column remained the same. Only the other columns changed.
  prefs: []
  type: TYPE_NORMAL
- en: If you’re a normal user, you may not need `od` for much else besides viewing
    non-printing characters in text files. You may need, for example, to find new-line
    or carriage return characters. For this, you can use the `-tc` option and look
    for characters that are preceded with a backslash. In the example that we’re about
    to examine, `\n` represents newline characters, and `\r` represents carriage return
    characters.
  prefs: []
  type: TYPE_NORMAL
- en: 'I’ll be performing the demos with a Project Gutenberg ebook file that’s titled,
    *How to Speak and Write Correctly*. You can download it from here: [https://www.gutenberg.org/cache/epub/6409/pg6409.txt](https://www.gutenberg.org/cache/epub/6409/pg6409.txt)'
  prefs: []
  type: TYPE_NORMAL
- en: Or, you can also just get it from the Github repository. Either way, the filename
    will be `pg6409.txt`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let’s look at the first ten lines of our file, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: You see that there are multiple `\n` and `\r` characters in this file. But,
    what does that mean? First, it means that the file was created with a Windows-based
    text editor, such as Notepad or Wordpad. For some bizarre reason, Windows text
    editors insert both newline characters (`\n`) and carriage return characters (`\r`)
    at the end of each line.
  prefs: []
  type: TYPE_NORMAL
- en: Unix and Linux text editors only insert a newline character at the end of each
    line. If you’re on a Unix or Linux machine and just want to read a text file that
    has carriage return characters, everything will work just fine. But, if you want
    to search for something in the text file, the carriage return characters might
    prevent the search from performing correctly.
  prefs: []
  type: TYPE_NORMAL
- en: Also, Unix and Linux operating systems won’t correctly read shell scripts or
    configuration files if they contain any carriage returns.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can use the `-ta` option to view non-printable characters by their official
    ASCII names, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: This time, the newlines and carriage returns are represented by `nl` and `cr`
    instead of by `\n` and `\r`.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you want to begin the display from somewhere other than the beginning of
    the file, use the `-j` switch. For example, if you want to begin viewing from
    address `0000640,` enter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'If you want to read in only a certain portion of the file, use the `-N` switch.
    Here, I’m reading in the first `0000640` bytes worth of our text file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, let’s combine these two options. Let’s start at address `0000400`
    and read in `0000640` bytes worth of the file, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: Keep in mind that the numbers in the address column are in octal format. That’s
    why you need to use something like `0000640` in the addressing options. If you
    were to use `640` instead, `od` would look at it as a decimal number, and would
    give you different results from what you expected.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: '`A`s you see, this isn’t what you want.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s an example of how you might be able to use `od`. Suppose that you have
    a couple of text files that you need to `cat` together, but they just don’t line
    up correctly. To demonstrate, create a text file that has tabs at the beginning
    of several lines, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a second file just like it, except without the tabs, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, pretend that you don’t know about the tabs that are in the first file.
    Furthermore, pretend that it’s such a large file that you haven’t been able to
    look through it in order to notice the tabs. With that in mind, try to `cat` the
    two files together, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'So now, you’re scratching your head, wondering why things aren’t lining up
    correctly. A quick way to find out what’s going on would be to pipe the output
    through `od` with the `-ta` switch, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: All of the `ht` instances you see indicate the presence of a hard tab, which
    gives you a clue about how to fix the alignment issues. You can also `od` each
    file separately to find where you need to edit.
  prefs: []
  type: TYPE_NORMAL
- en: There are still more `od` options that you might find useful. To see them, consult
    either the `od` man page or the `od` info page.
  prefs: []
  type: TYPE_NORMAL
- en: In real life, you can use od to help troubleshoot problems with either shell
    scripts or Linux/Unix configuration files. Remember that if scripts or configuration
    files contain any carriage return characters, the operating system won’t be able
    to read them. Also, Linux operating systems have begun making more extensive use
    of .yaml files in recent years. In addition to the carriage return problem, `.yaml`
    files also require that each line be indented in a specific way. Using `od` can
    help determine if each line is indented with the correct number of tabs or spaces.
  prefs: []
  type: TYPE_NORMAL
- en: Next, let’s look at something that’s uniquely different.
  prefs: []
  type: TYPE_NORMAL
- en: Using uniq
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Use the `uniq` utility with files that have consecutive, identical lines. Its
    default behavior is to only show one copy of any line that is duplicated. Let’s
    begin by creating the `fruit.txt` file, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: 'Using `uniq` without any options gives you this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: 'This got rid of the duplicates that were identical in case. But you still have
    some consecutive words that are the same, except for case. Use the `-i` switch
    to make this operation case-insensitive, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: Of the two duplicate pairs, whichever word was on top was the one that stayed.
    In the `Peach` pair, the upper-case `Peach` was on top, so it stayed. In the `Apricot`
    pair, the lower-case `apricot` was on top, so it stayed.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can get a count of how many consecutive duplicate lines there are with
    the `-c` switch. Combine it with the `-i` switch to make the count case-insensitive.
    Here’s how that works:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: 'The `-u` switch allows you to only display lines that aren’t repeated. You
    can also make this case-insensitive by combining it with the `-i` switch. Here’s
    what that looks like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: 'Use the `-d` switch to show one copy of each line that is repeated, and to
    not show any line that isn’t repeated. Again, you can combine this with the `-i`
    switch, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: 'You can also have `uniq` perform its comparisons on partial lines, instead
    of whole lines. To demo this, create a file of two sets of statements. Have some
    of the statements differ in only the first word, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: 'A default `uniq` operation would yield this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: 'Use the `-f` switch to tell `uniq` to ignore fields in its comparison. In this
    case, a field is a word in a sentence. The number after the `-f` tells `uniq`
    how many fields to ignore. For now, let’s make `uniq` ignore the first word, like
    so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: You can use the `-c` switch in the same manner, except that it would have `uniq`
    skip a number of characters, instead of fields. This could be handy if you have
    lines with leading blank spaces.
  prefs: []
  type: TYPE_NORMAL
- en: If you want `uniq` to end its comparisons before it gets to the end of the lines,
    use the `-w` switch. The number after the `-w` tells `uniq` how many characters
    into the line to perform its comparison. If a `-c` or a `-f` switch is specified,
    the count doesn’t begin until after the `-c` or `-f` switch is satisfied.
  prefs: []
  type: TYPE_NORMAL
- en: 'To demo this, create yet another text file that will look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: 'This time, we want our comparison to begin on the second word of each sentence,
    and to end on the 14^(th) character of the comparison. Here’s how that works:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: Okay, easy enough so far, right?
  prefs: []
  type: TYPE_NORMAL
- en: 'For the next demo, create a pair of files so that you can use `join` and `uniq`
    together. First, create the `actorfile_9.txt` file, which will look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, create the `actorfile_10.txt` file, which will look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: 'Join the two files together to see what happens:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: 'Notice that when the key field is the same on two consecutive lines, `join`
    thinks that it has to list each of those lines twice in the combined output. You
    can take care of that by piping the output through `uniq`, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: Okay, that’s it for `uniq`. Let’s now do some counting.
  prefs: []
  type: TYPE_NORMAL
- en: Using wc
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This easy-to-use utility gives you a quick way to count the number of lines,
    words, and/or bytes in a text file. So, if you’re typing a document that can only
    contain a certain number of words, you don’t have to sit there and manually try
    to count the words as you scroll the document up your screen. Just use `wc`, instead.
  prefs: []
  type: TYPE_NORMAL
- en: 'The default output for `wc` shows you the number of lines, followed by the
    number of words, and then by the number of bytes. Finally, it shows the name of
    the input file. Here’s how that looks:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: So, the `actorfile_1.txt` file contains five lines, ten words, and 67 bytes.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you specify more than one file, `wc` will tell give you information for
    each individual file, and the total for all of the files, which looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: 'Use the `-l` (that’s a lower-case L) switch if you only want to see the number
    of lines in your files. Here’s how that looks:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: 'The `-w` switch shows the number of words in a file, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: 'Use the `-c` switch to show only the number of bytes, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: 'To see the numbers of characters in a file, use `-m`, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: 'Theoretically, the `-c` and the `-m` outputs should be identical as you see
    above, because one character is one byte in size. However, the outputs might differ
    slightly for large text files, as you see here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: I have no idea of why that is, because I’ve never found any explanation about
    it.
  prefs: []
  type: TYPE_NORMAL
- en: 'The last switch is the `-L` switch, which shows you the length of the longest
    line in your input file, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: 'You can combine `wc` with other utilities. Suppose that you have a text file
    that contains a lot of duplicate lines. Combine `wc` with `uniq` to see how eliminating
    the blank lines would affect the size of the `pg6409.txt` file that you downloaded
    from Project Gutenberg, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: You see that `uniq` has reduced the number of lines, but the word count remains
    the same. This tells us that all of the duplicate lines are blank lines. The byte-count
    has also gone down, because even empty spaces count as characters, which are one
    byte in size.
  prefs: []
  type: TYPE_NORMAL
- en: If you’re a systems administrator, you can use `wc` to help with your security
    audits. If you know how many users are supposed to be authorized for your system,
    you can periodically check the number of lines in the `/etc/passwd` file. (Remember,
    each line represents one user.) This gives you a good way to recognize if a user
    has been added behind your back.
  prefs: []
  type: TYPE_NORMAL
- en: All righty, we’re through counting. It’s time now to do some formatting.
  prefs: []
  type: TYPE_NORMAL
- en: Using fmt
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `fmt` utility works by attempting to make all non-blank lines in a text
    file the same length. Its default action is to set a target length of 75 characters
    for each line. However, you can change that if your file is either too narrow
    or too wide to display properly. The slight catch is that it doesn’t work well
    with every file. If your file has things like tables, indices, or tables of contents,
    `fmt` can mess up their formatting. (That’s ironic, considering that `fmt` is
    short for *format*.) You would then have to go back and manually edit them to
    make them look right.
  prefs: []
  type: TYPE_NORMAL
- en: I should point out for all of these examples to work on a virtual machine, you’ll
    need to have the virtual machine window set to a wider-than-default width. You
    can do that by opening the Virtualbox **View** menu for the virtual machine, and
    selecting the **Scaled Mode** option. That will allow you to resize the virtual
    machine window to suit your needs.
  prefs: []
  type: TYPE_NORMAL
- en: Another option is to just remotely log into the virtual machine from your host
    machine’s terminal. You’ll then be able to resize the terminal window as you desire.
  prefs: []
  type: TYPE_NORMAL
- en: 'We’ll start by looking at an excerpt from the `pg6409.txt` ebook file that
    you’ve already downloaded from the Project Gutenberg site. Here’s what the unformatted
    excerpt file looks like:'
  prefs: []
  type: TYPE_NORMAL
- en: '![B21693_7_2](img/B21693_07_02.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 7.2: The unformatted text'
  prefs: []
  type: TYPE_NORMAL
- en: 'I’ve decided that that’s a bit too wide, so I’ll use `fmt` with its default
    target setting of 75 characters per line, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '![B21693_7_3](img/B21693_07_03.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 7.3: Using fmt with the default width'
  prefs: []
  type: TYPE_NORMAL
- en: 'It still seems a bit too wide. So, let’s use the `-w` switch to narrow it down
    to a width of 60 characters, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '![B21693_7_4](img/B21693_07_04.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 7.4: Setting a width of 60 characters'
  prefs: []
  type: TYPE_NORMAL
- en: 'On second thought, let’s try it with a line width of 90 characters, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![B21693_7_5](img/B21693_07_05.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 7.5: Setting a width of 90 characters'
  prefs: []
  type: TYPE_NORMAL
- en: 'The `-u` switch ensures that you always have one space between each word, and
    two spaces between each sentence, which looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![B21693_7_6](img/B21693_07_06.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 7.6: Using the -u option'
  prefs: []
  type: TYPE_NORMAL
- en: 'Use the `-s` switch if you want to make long lines shorter, but you don’t want
    to make short lines longer. (Note that you can use a single dash to combine switches.)
    Here’s how that looks:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: Yeah, the `-s` doesn’t work so well with this particular file, and I’ve never
    really found a use for it myself. But, that doesn’t mean that you’ll never find
    a use for it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once you’ve finally decided that you like what you see, use a redirector to
    save the output to a new file, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE83]'
  prefs: []
  type: TYPE_PRE
- en: Now that we’ve had enough of formatting, let’s do some splitting.
  prefs: []
  type: TYPE_NORMAL
- en: Using split
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'You can use `split` to break one large text file into two or more smaller ones.
    By default, it takes a large file and splits it into smaller files of 1,000 lines
    each. (Of course, the last file may be smaller.) Also by default, the names of
    these new small files will be `xaa`, `xab`, `xac`, and so on. Let’s begin by looking
    at the line-count of the public-domain ebook file that you downloaded from Project
    Gutenberg, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE84]'
  prefs: []
  type: TYPE_PRE
- en: 'Since there are 6,019 lines in this file, `split` will break it into six files
    of 1,000 lines each, and one file of only 19 lines. Here’s how it works:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE85]'
  prefs: []
  type: TYPE_PRE
- en: 'To verify that this works, use `wc` to perform a line-count of each file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE86]'
  prefs: []
  type: TYPE_PRE
- en: Use the `-a` option to change the length of the new filenames. The following
    command will give you a five-character suffix for the filenames.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE87]'
  prefs: []
  type: TYPE_PRE
- en: 'You can also change the filename prefix from `x` to whatever you want. Just
    add the desired prefix to the end of the command, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE88]'
  prefs: []
  type: TYPE_PRE
- en: 'If you don’t want to use letters for the filename suffixes, use the `-d` option
    to use numeric prefixes. (Again, notice how you can combine switches with only
    a single dash.) Do it like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE89]'
  prefs: []
  type: TYPE_PRE
- en: 'But, what if 1,000 lines is too long for your files? Then, use the `-l` switch
    to change it to something else. Here, I’m creating files of 400 lines each:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE90]'
  prefs: []
  type: TYPE_PRE
- en: Note that whenever you use two or more option switches that each take a numeric
    option, you have to use a separate dash for each option.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can use the `-b` switch to create files that are a specific number of bytes
    in size. Here, I’m breaking the file into chunks of 900 bytes each:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE91]'
  prefs: []
  type: TYPE_PRE
- en: 'Add either a `k` or an `m` after the numeric option for the `-b` switch, and
    you can specify either kilobytes or megabytes, instead of the default bytes. In
    this example, I’m going back in time and pretending that I have to divide the
    file into two parts so that I can store it on two old-fashioned 180-Kbyte floppy
    disks:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE92]'
  prefs: []
  type: TYPE_PRE
- en: I’ll wrap up the `split` write-up by making a confession, in order to unburden
    my soul. As I hinted in the previous paragraph, the original purpose of `split`
    was to split up text files that are too large to store on a single old-fashioned
    floppy disk.
  prefs: []
  type: TYPE_NORMAL
- en: In the modern age, we have hard drives and solid-state drives that have multiple
    Terabytes of capacity, and USB memory sticks that have multiple Gigabytes of capacity.
    So, you’ll likely find that `split` isn’t as useful as it used to be. But, do
    keep it in mind if you plan to take a Linux certification exam, because you just
    might see some questions about it.
  prefs: []
  type: TYPE_NORMAL
- en: Okay, we’ve had enough of splitting, so let’s do some translating.
  prefs: []
  type: TYPE_NORMAL
- en: Using tr
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You can use `tr` for a variety of translation chores. (After all, `tr` does
    stand for *translate*.) Rather than translating from one language to another,
    `tr` translates from one character to another, from a range of characters to another,
    or from one class of characters to another. You can also delete selected characters
    from a file or eliminate duplicate characters.
  prefs: []
  type: TYPE_NORMAL
- en: Compared to the utilities that we’ve looked at so far, there’s a big difference
    with how `tr` operates. The other utilities that we’ve looked at so far can get
    their input from arguments that you would supply on the command-line. So, you
    don’t need to use the `stdin` redirector with them. The `tr` utility can’t use
    arguments, so you’ll either have to use a `stdin` redirector or pipe its input
    in from another command.
  prefs: []
  type: TYPE_NORMAL
- en: 'For the first example, create the file `translation.txt`, and use `tr` to change
    every occurrence of a single character. Make the file look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE93]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let’s do the actual translation, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE94]'
  prefs: []
  type: TYPE_PRE
- en: After the `tr`, I placed two text strings within single quotes. The first string
    represents what I want to find and change. The second string represents what we
    want the first string to become. In this case, I want to change all lower-case
    a’s into upper-case A’s.
  prefs: []
  type: TYPE_NORMAL
- en: You can translate multiple characters by either listing them individually or
    by specifying ranges of characters. In this next example, I’ve chosen to convert
    a’s to A’s and l’s to L’s.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE95]'
  prefs: []
  type: TYPE_PRE
- en: 'Separate the characters with a dash to specify a range of characters, like
    so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE96]'
  prefs: []
  type: TYPE_PRE
- en: 'You can specify more than one range, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE97]'
  prefs: []
  type: TYPE_PRE
- en: 'Other types of conversion are also possible. Here, I’m converting the letters
    a through e to the numbers 1 through 5:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE98]'
  prefs: []
  type: TYPE_PRE
- en: 'As is the case with many of these utilities, `tr` gives you multiple ways to
    perform certain operations. For example, to convert all lower-case letters in
    a file to upper-case letters, you can specify the ranges ‘a-z’ and ‘A-Z’ in your
    command, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE99]'
  prefs: []
  type: TYPE_PRE
- en: 'You can also use character classes to perform this conversion. A **character
    class** consists of the name of a type of characters placed within the square
    bracket and colon characters. For example, the character class for lower-case
    characters is represented by `[:lower:]`, and the character class for upper-case
    letters is represented by `[:upper:]`. So, the preceding command could be typed
    in like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE100]'
  prefs: []
  type: TYPE_PRE
- en: Here’s a table of the rest of the character classes.
  prefs: []
  type: TYPE_NORMAL
- en: '| **Class Name** | **What It Means** |'
  prefs: []
  type: TYPE_TB
- en: '| `[:alnum:]` | Letters and digits. (In other words, alphanumeric.) |'
  prefs: []
  type: TYPE_TB
- en: '| `[:alpha:]` | Letters |'
  prefs: []
  type: TYPE_TB
- en: '| `[:blank:]` | Whitespace |'
  prefs: []
  type: TYPE_TB
- en: '| `[:cntrl:]` | Control characters |'
  prefs: []
  type: TYPE_TB
- en: '| `[:digit:]` | Digits |'
  prefs: []
  type: TYPE_TB
- en: '| `[:graph:]` | All printable characters except for spaces |'
  prefs: []
  type: TYPE_TB
- en: '| `[:lower:]` | All lower-case letters |'
  prefs: []
  type: TYPE_TB
- en: '| `[:print:]` | All printable characters, including spaces |'
  prefs: []
  type: TYPE_TB
- en: '| `[:punct:]` | All punctuation characters |'
  prefs: []
  type: TYPE_TB
- en: '| `[:space:]` | Either veritcal or horizontal whitespace |'
  prefs: []
  type: TYPE_TB
- en: '| `[:upper:]` | All upper-case letters |'
  prefs: []
  type: TYPE_TB
- en: '| `[:xdigit:]` | Hexadecimal digits |'
  prefs: []
  type: TYPE_TB
- en: 'Table 7.1: Character classes'
  prefs: []
  type: TYPE_NORMAL
- en: 'This looks easy enough, right? Unfortunately though, there’s a bit of a catch.
    Watch what happens when I try to translate digits to hexadecimal digits:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE101]'
  prefs: []
  type: TYPE_PRE
- en: The answer to this dilemma is in the `tr` man page, where it says that “while
    translating, `[:lower:]` and `[:upper:]` may be used in pairs to specify case
    conversion”. Granted, it doesn’t say that *only* `[:lower:]` and `[:upper:]` can
    be used in pairs, but that is the implication. However, you can use these other
    character classes in other types of `tr` operations, which we’ll get to in just
    a bit.
  prefs: []
  type: TYPE_NORMAL
- en: If you want to delete certain characters from a text stream, use the `-d` switch.
    In this example, I’ll delete all vowels from the text.
  prefs: []
  type: TYPE_NORMAL
- en: Note that with the `-d` switch, you only need to specify one text string or
    character class.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s how that looks:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE102]'
  prefs: []
  type: TYPE_PRE
- en: 'Add the `-c` switch, and you can make `tr` operate on everything except what
    you specify. Here, I’ll remove all the consonants, punctuation, spaces, and newline
    characters. That is, I’ll remove everything that isn’t a vowel. Prepare to be
    amazed at what you’re about to see:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE103]'
  prefs: []
  type: TYPE_PRE
- en: When I say that this removes everything but the vowels, I do mean *everything*,
    including the invisible newline characters. This explains why all of the vowels
    are on one line, and why the command prompt is now on the same line as the output.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can do the same things by specifying character classes instead of characters
    or ranges of characters. In this example, I’m removing everything except for lower-case
    letters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE104]'
  prefs: []
  type: TYPE_PRE
- en: 'This time, let’s remove all of the non-printable control characters, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE105]'
  prefs: []
  type: TYPE_PRE
- en: 'Of course, the only control characters in this file are newline characters,
    but that’s okay. If you have a file that also contained other types of control
    characters, and you only want to delete all of the newline characters, just do
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE106]'
  prefs: []
  type: TYPE_PRE
- en: 'If you have sequential occurrences of a given character or character class,
    you can use the `-s` switch to replace them with only a single occurrence. Here’s
    how that looks:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE107]'
  prefs: []
  type: TYPE_PRE
- en: 'If you specify two strings with the `-s` switch, `tr` will first replace the
    characters in the first string with the characters in the second string. Then,
    it will squeeze out the resultant consecutive characters. As before, prepare to
    be amazed at what you’ll see here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE108]'
  prefs: []
  type: TYPE_PRE
- en: So, I turned *tennessee* into *serene*. (Perform this trick at your next party
    in case you need to liven things up a bit.)
  prefs: []
  type: TYPE_NORMAL
- en: 'You can combine `tr` with other text-stream utilities, which would look something
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE109]'
  prefs: []
  type: TYPE_PRE
- en: 'Here’s a more practical use for `tr`. Let’s say that you’ve been given a text
    file of columnar data that you need to format for printing. But, the columns are
    all separated with a single space and nothing lines up correctly, as you see here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE110]'
  prefs: []
  type: TYPE_PRE
- en: You can’t use `unexpand` to replace the spaces with tabs, because you need at
    least two spaces between the columns for `unexpand` to work.
  prefs: []
  type: TYPE_NORMAL
- en: In this case, you can use `tr` to replace the spaces with tabs. (Note that there
    is a blank space between the first set of single quotes. So yes, you can quote
    spaces.)
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE111]'
  prefs: []
  type: TYPE_PRE
- en: 'Even if you do have more than one space between the columns, `unexpand` still
    might not be the best choice. Here, I’ve placed two spaces between the columns:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE112]'
  prefs: []
  type: TYPE_PRE
- en: 'I’ll use `unexpand` with the `-t2` switch so that it will only take two spaces
    to make a tab, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE113]'
  prefs: []
  type: TYPE_PRE
- en: 'That’s somewhat better, but things still look a bit ragged. So, I’ll use `tr`
    to replace the spaces with tabs, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE114]'
  prefs: []
  type: TYPE_PRE
- en: 'Much nicer, eh? But, since there were originally two spaces between columns,
    I now have two tabs between columns. I only want one tab between columns, so I’ll
    use the `-s` switch to squeeze out the excess tabs, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE115]'
  prefs: []
  type: TYPE_PRE
- en: 'For the final example, consider the Project Gutenberg file that I showed you
    earlier. Remember that it contains carriage return characters, indicating that
    it was created on a Windows computer. Here’s how that looks:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE116]'
  prefs: []
  type: TYPE_PRE
- en: 'As I pointed out before, each `\r` represents a carriage return. Now, let’s
    pretend that this is a Linux configuration file, and that we need to strip out
    the carriage returns so that Linux will properly read it. Save the output to a
    new file, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE117]'
  prefs: []
  type: TYPE_PRE
- en: 'Did it work? Let’s see:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE118]'
  prefs: []
  type: TYPE_PRE
- en: I don’t see any carriage returns, so it worked just fine.
  prefs: []
  type: TYPE_NORMAL
- en: In reality, most people just use the `dos2unix` utility to strip out the carriage
    returns. But, if you plan to take any Linux certification exams, you might also
    want to know how to do it with `tr`.
  prefs: []
  type: TYPE_NORMAL
- en: The next utility we’ll look at will make you want to talk like a pirate.
  prefs: []
  type: TYPE_NORMAL
- en: Using xargs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: It’s fitting that I’m writing this on *International Talk Like a Pirate Day*,
    because when you pronounce the name of this utility just right, it really does
    sound like something that a pirate would say. So, all together now, in your best
    pirate voice. . .
  prefs: []
  type: TYPE_NORMAL
- en: '*Xaaaaarrrrrgs!*'
  prefs: []
  type: TYPE_NORMAL
- en: Okay, enough silliness. Let’s get to work.
  prefs: []
  type: TYPE_NORMAL
- en: Seriously, `xargs` is a handy utility that can be used in a few different ways.
    Since the current topic is text-stream filters though, we’ll only look at it in
    that context for the time being. Later on, I’ll show you other uses for it.
  prefs: []
  type: TYPE_NORMAL
- en: '`xargs` doesn’t work by itself, and is always used with another utility. Its
    purpose is to take output from one source and use it as arguments for the other
    command. It works somewhat like the `-exec` option with `find`, but with a few
    differences. That is, `xargs` can be used with other utilities besides `find`,
    it has more options, and it’s more efficient. Let’s look at a few examples.'
  prefs: []
  type: TYPE_NORMAL
- en: 'If you want to sort multiple files, you can list them all on the command-line
    when you invoke `sort`. To demo this, let’s review the `actorfile_1.txt` file
    and the `actorfile_6.txt` file that I already had you create:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE119]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let’s sort them together, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE120]'
  prefs: []
  type: TYPE_PRE
- en: That works fine if you only have two files to sort. But, what if you have a
    whole bunch of files that you want to sort? And, what if you need to update those
    files on a regular basis and sort them again after each update? Listing every
    file in a `sort` command would soon become tiresome and a bit unwieldy. To simplify
    the job, you can either write a shell script with the names of all of the files,
    or use `xargs` with a list of all the files. Since we haven’t yet looked at writing
    shell scripts, let’s look at `xargs`.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, create a file with a list of the files that you want to sort, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE121]'
  prefs: []
  type: TYPE_PRE
- en: As you see, the filenames can all be on the same line, with only a single space
    between them. Or, if you prefer, you can place each filename on its own line.
    Either way works equally well.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, use `xargs` and `sort` to read in the list of files, and then to sort
    the actual files, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE122]'
  prefs: []
  type: TYPE_PRE
- en: As I said, this would be handy if you have a lot of files that you have to update
    and sort on a frequent basis. Just build the list of the files that you need to
    sort, so that you don’t always have to type the names of all of the files.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s now create a file with a list of names, and use `xargs` to feed the list
    into the `echo` command, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE123]'
  prefs: []
  type: TYPE_PRE
- en: Pretty slick, eh? (I know that you’re just dying to show this trick at your
    next party.) But, there’s more.
  prefs: []
  type: TYPE_NORMAL
- en: You can use the `-i` switch and a set of curly braces to place the arguments
    wherever you want in the output string.
  prefs: []
  type: TYPE_NORMAL
- en: Note that for this example to work properly, each name will have to be on its
    own line in the input file. That’s because `-i` also causes the command to invoke
    once for each line in the input file.
  prefs: []
  type: TYPE_NORMAL
- en: 'Anyway, here’s how it works:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE124]'
  prefs: []
  type: TYPE_PRE
- en: If we use the `-n num` switch, we can tell `xargs` to execute the associated
    command once for every *num* lines of input.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE125]'
  prefs: []
  type: TYPE_PRE
- en: That didn’t work out so well, so let’s try with `-n2` to see if it makes a difference.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE126]'
  prefs: []
  type: TYPE_PRE
- en: That looks much better.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we can use the `-l num` switch to determine the number of lines we
    want for our output. Here, we’re creating two lines of output.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE127]'
  prefs: []
  type: TYPE_PRE
- en: That’s about it for now. There are still other uses for `xargs`, which I’ll
    cover a bit later. Next, let’s add some final polish to your important text files.
  prefs: []
  type: TYPE_NORMAL
- en: Using pr
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You’ve been working hard, using various text-stream filters to extract meaningful
    data from your text files, and creating formatted reports. Now, it’s time to make
    that hard work pay off by committing your work to paper. Sure, you can print your
    files without using `pr`. But for a nice professional look, `pr` can give you
    just the right finishing touch.
  prefs: []
  type: TYPE_NORMAL
- en: With `pr`, you can effortlessly prepare your files for printing by breaking
    them into pages, and by adding headers and page numbers. In that regard, it’s
    better than using a regular text editor. In fact, it’s almost like using a mini
    word processor. It also gives you other formatting options that text editors won’t
    give you. (You’ll see some examples in just a few moments.)
  prefs: []
  type: TYPE_NORMAL
- en: Once you’ve used `pr` to perform your final formatting, you can print directly
    from the command-line by either piping `pr`'s output into the `lpr` utility, or
    by invoking `lpr` with your filename as an argument. (I’ll tell you more about
    `lpr` in just a bit.) There are a few reasons why you want to know how to do that.
  prefs: []
  type: TYPE_NORMAL
- en: If you work with a Linux or Unix server that doesn’t have a GUI installed, you
    will need to know how to print from the command-line, because text-mode text editors
    don’t include a print function. Also, if you know how to print from the command-line,
    you’ll be able to set up batch jobs that can print multiple files at once, and
    automate your printing by setting print jobs up with either a `cron` job or a
    `systemd` timer. That could come in handy if you need to automatically print log
    files or reports on a nightly basis.
  prefs: []
  type: TYPE_NORMAL
- en: 'By default, `pr` breaks your files into single-spaced pages of 66 lines each.
    It also places the file’s last modification date and time, the filename, and the
    page number into the header of every page, which is followed by a trailer of blank
    lines. With the appropriate switches however, all of this can be changed. Let’s
    start by looking at an example of `pr`''s default behavior. Here’s an excerpt
    from the public-domain e-book, *How to Speak and Write Correctly*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![B21693_7_7](img/B21693_07_07.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 7.7: Using pr with default settings'
  prefs: []
  type: TYPE_NORMAL
- en: What I can’t show you due to book formatting concerns is that there are a lot
    of blank lines after the last line of text. That’s because `pr` recognizes that
    this short excerpt doesn’t fill the page.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can use the `-h` option to replace the filename with a header of your choice,
    like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '![B21693_7_8](img/B21693_07_08.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 7.8: Setting a custom header with pr'
  prefs: []
  type: TYPE_NORMAL
- en: 'If you don’t need to place headers in your output but still need to use `pr`''s
    other features, use the `-t` switch to omit the header, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![B21693_7_9](img/B21693_07_09.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 7.9: Using the -t option'
  prefs: []
  type: TYPE_NORMAL
- en: 'The `-d` option will double-space your output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![B21693_7_10](img/B21693_07_10.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 7.10: Using the -d option'
  prefs: []
  type: TYPE_NORMAL
- en: 'Use the `-o` option with a number to set the left margin. (The number represents
    the number of spaces to indent the left margin.) Here, I’m setting a margin of
    eight spaces:'
  prefs: []
  type: TYPE_NORMAL
- en: '![B21693_7_11](img/B21693_07_11.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 7.11: Setting the left margin'
  prefs: []
  type: TYPE_NORMAL
- en: 'As I’ve already said, the default page length is 66 lines. You can change that
    with the `-l` option. To set a page length of 80 lines, enter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE128]'
  prefs: []
  type: TYPE_PRE
- en: 'By default, `pr` separates pages by inserting multiple newline characters at
    the end of each page. Use the `-f` option to insert a single form-feed character
    between pages, instead. If you need to insert line numbers, use the `-n` option.
    Here, I’m combining both of these options with a single dash:'
  prefs: []
  type: TYPE_NORMAL
- en: '![B21693_7_12](img/B21693_07_12.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 7.12: Using form feeds and adding line numbers'
  prefs: []
  type: TYPE_NORMAL
- en: 'To work with a range of pages, just place a `+` in front of the first page
    number, and prefix the last page number with a colon. Here, I’ve chosen to look
    at pages 10 through 12 of the full `pg6409.txt` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE129]'
  prefs: []
  type: TYPE_PRE
- en: 'If you omit the last page number, you’ll see everything from the first page
    until the end of the file. Here, I’m looking at everything from page 103 until
    the end:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE130]'
  prefs: []
  type: TYPE_PRE
- en: I’ve saved the columns and merge options until last, because they’re the trickiest
    to use.
  prefs: []
  type: TYPE_NORMAL
- en: 'The columns option allows you to output your text in multiple columns. You
    set it by using a `-` followed by a number. The trick is, that you’ll first have
    to format your text so that it’s not too wide for the columns. Here’s what you
    get if you try to output our sample text as a two-column page:'
  prefs: []
  type: TYPE_NORMAL
- en: '![B21693_7_13](img/B21693_07_13.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 7.13: The first attempt at using two columns'
  prefs: []
  type: TYPE_NORMAL
- en: 'You can see that that’s not real useful, because too much got left out. The
    easiest way to handle this is to change the line width with `fmt`, and then pipe
    the output to `pr`, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '![B21693_7_14](img/B21693_07_14.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 7.14: Combining fmt and pr'
  prefs: []
  type: TYPE_NORMAL
- en: Of course, you might have to experiment with the line-width until you get what
    you want.
  prefs: []
  type: TYPE_NORMAL
- en: 'You’ll have the same problem with the merge option. Here, I’m using the `-m`
    switch to show two files side-by-side:'
  prefs: []
  type: TYPE_NORMAL
- en: '![B21693_7_15](img/B21693_07_15.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 7.15: First attempt at merging two files'
  prefs: []
  type: TYPE_NORMAL
- en: 'Again, you see that the lines are too wide to fit properly in two columns.
    The best way to handle this is to narrow the lines with `fmt`, but save the output
    to two intermediate files. Then, use `pr` to merge the two new files. Here what
    that process looks like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE131]'
  prefs: []
  type: TYPE_PRE
- en: '![B21693_7_16](img/B21693_07_16.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 7.16: Merging the two formatted files'
  prefs: []
  type: TYPE_NORMAL
- en: Once you have everything looking good on-screen, you’re ready to redirect your
    `pr` output into a new text file, and then print it.
  prefs: []
  type: TYPE_NORMAL
- en: Printing from the Command-line
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As I’ve already mentioned a few times, it is possible to print text files from
    the command-line. (Actually, you can also print PostScript files, `.pdf` files,
    image files, and a few other types of document files from the command line. For
    now though, we’re only interested in printing text files.) To do this, your Linux,
    Unix, or Unix-like machine needs to have the following two things installed on
    it:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Common Unix Printing Software** (**CUPS**): This is normally installed by
    default on desktop implementations of Linux, but not on text-mode server implementations
    of Linux.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**The proper driver for your printer**: CUPS includes a wide-range of printer
    drivers that are ready to go. However, your particular printer might not be included.
    If that’s the case, you’ll need to obtain the proper driver from the printer manufacturer
    and follow their instructions for installing it.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Installing CUPS is generally quite easy, because it’s included in the repositories
    of most Linux distros. On any type of Red Hat-style machine, such as Fedora, AlmaLinux,
    Rocky Linux, Oracle Linux, or RHEL, just do:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE132]'
  prefs: []
  type: TYPE_PRE
- en: 'On Debian or any of its derivatives, you’ll need two packages. To install them,
    just do:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE133]'
  prefs: []
  type: TYPE_PRE
- en: Next, you’ll need to find out if CUPS includes the driver for your printer.
    Do that with the `lpinfo -m` command on a Red Hat-type system, and with the `sudo
    lpinfo -m` command on a Debian-type system.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can pipe the output into `less` if you want to scroll through the whole
    list. Or, pipe it into `grep` if you want to search for a specific printer manufacturer,
    which will look something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE134]'
  prefs: []
  type: TYPE_PRE
- en: 'So, the Debian implementation of CUPS doesn’t include drivers for any Brother
    printer. But, as you see here, CUPS on my Fedora workstation has quite a wide
    selection of Brother printer drivers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE135]'
  prefs: []
  type: TYPE_PRE
- en: 'The only catch was that the Fedora workstation didn’t have the drivers for
    my Brother MFC7460DN printer, so I had to download the driver from the Brother
    website and install it myself. (The driver that I installed is represented by
    the last two items in this list.) The `lpstat -p -d` command shows me the status
    of my printer, as you see here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE136]'
  prefs: []
  type: TYPE_PRE
- en: Cool. It’s ready to go.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once you’ve set everything up, you’re ready to print with either `lp` or `lpr`.
    (They’re two different utilities that both do the same thing, but with different
    option switches. To make things simple, I’m just going to show you `lpr`.) To
    print to a specific printer, do something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE137]'
  prefs: []
  type: TYPE_PRE
- en: 'The `-P` option directs the print job to the desired printer. If you don’t
    want to always have to specify a printer, you can set a default printer, like
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE138]'
  prefs: []
  type: TYPE_PRE
- en: (Note that this will require `sudo` privileges on a Debian-type system. )
  prefs: []
  type: TYPE_NORMAL
- en: 'Once you’ve assigned a default printer, you can run a print job like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE139]'
  prefs: []
  type: TYPE_PRE
- en: 'If you have multiple files that you need to print out, there’s no need to issue
    multiple `lpr` commands. Instead, just place the names of the files that you want
    to print into a separate text file, and then use `xargs` to read the list. That
    will look something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE140]'
  prefs: []
  type: TYPE_PRE
- en: Easy, right? Well, there are actually a lot more print options that you can
    use with either `lp` or `lpr`, but for now we’ll just go with the basics. To see
    a complete tutorial on printing with `lp` and `lpr`, your best bet is to pull
    up a web browser on a Linux desktop machine, and navigate to `http://localhost:631`.
    In addition to the tutorial, you’ll see that you can also perform certain administrative
    functions from the web interface.
  prefs: []
  type: TYPE_NORMAL
- en: All right, I think that will do for this chapter. Let’s wrap things up and move
    on.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, I showed you a lot more utilities that you can use to format
    text files as either you or your employer might require. Finally, at the end,
    I showed you the basics of setting up a printer on a text-mode server.
  prefs: []
  type: TYPE_NORMAL
- en: The beauty of all this is that you can create shell scripts that will automatically
    obtain information from various sources, create properly-formatted text files,
    and then print them. You can even have the scripts run automatically by creating
    either a `cron` job or a `systemd` timer.
  prefs: []
  type: TYPE_NORMAL
- en: Oh, but I haven’t shown you how to create a shell script, have I? That’s okay,
    because that will be the subject of the next chapter. I’ll see you there.
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Which two of the following commands would you use to see if a text file contains
    carriage return characters? (Select two.)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`od -tx filename.txt`'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '`od -tc filename.txt`'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '`od -ta filename.txt`'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '`od -td filename.txt`'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: You’ve created a text file that contains a list of other text files. And now,
    you want to sort all of the files that are contained in that list, and save the
    output to one new file. Which of the following commands would you use for that?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`sort sort_list.txt > combined_sorted.txt`'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '`xargs sort sort_list.txt > combined_sorted.txt`'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '`xargs sort < sort_list.txt > combined_sorted.txt`'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '`sort < sort_list.txt > combined_sorted.txt`'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Which of the following commands will number all lines in the body of a text
    file?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`nl -a file.txt`'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '`nl file.txt`'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '`nl -bn file.txt`'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '`nl -ba file.txt`'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Which utility would you most likely use for the final step of preparing a text
    file for printing?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`fmt`'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '`pr`'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '`lp`'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '`lpr`'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Which of the following commands would you use to verify that the driver for
    your printer is installed on your computer?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`lpinfo -m`'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '`lpstat -p -d`'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '`lpr -i`'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '`lp -i`'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Further Reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'nl Command in Linux with Examples: [https://linuxconfig.org/nl](https://linuxconfig.org/nl)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'head Command in Linux (5 Essential Examples: [https://linuxhandbook.com/head-command/](https://linuxhandbook.com/head-command/
    )'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Using od to See How Text isFormatted: [https://bash-prompt.net/guides/od/](https://bash-prompt.net/guides/od/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'wc Command in Linux with Examples: [https://www.geeksforgeeks.org/wc-command-linux-examples/](https://www.geeksforgeeks.org/wc-command-linux-examples/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'tr Command in Linux with Examples: [https://linuxize.com/post/linux-tr-command/](https://linuxize.com/post/linux-tr-command/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'How to use the Linux tr Command: [https://www.howtogeek.com/886723/how-to-use-the-linux-tr-command/](https://www.howtogeek.com/886723/how-to-use-the-linux-tr-command/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Talk Like a Pirate Day: [https://nationaltoday.com/talk-like-a-pirate-day/](https://nationaltoday.com/talk-like-a-pirate-day/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'How to Use the xargs Command on Linux: [https://www.howtogeek.com/435164/how-to-use-the-xargs-command-on-linux/](https://www.howtogeek.com/435164/how-to-use-the-xargs-command-on-linux/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'How I use the Linux fmt command to format text: [https://opensource.com/article/22/7/fmt-trivial-text-formatter](https://opensource.com/article/22/7/fmt-trivial-text-formatter)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'pr command in Linux: [https://www.geeksforgeeks.org/pr-command-in-linux/](https://www.geeksforgeeks.org/pr-command-in-linux/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Master the Linux “pr” Command: A Comprehensive Guide: [https://hopeness.medium.com/master-the-linux-pr-command-a-comprehensive-guide-b166865c933e](https://hopeness.medium.com/master-the-linux-pr-command-a-comprehensive-guide-b166865c933e)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Answers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: b and c
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: c
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: d
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: b
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: a
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Join our community on Discord!
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Read this book alongside other users, Linux experts, and the author himself.
  prefs: []
  type: TYPE_NORMAL
- en: Ask questions, provide solutions to other readers, chat with the author via
    Ask Me Anything sessions, and much more. Scan the QR code or visit the link to
    join the community.
  prefs: []
  type: TYPE_NORMAL
- en: '[https://packt.link/SecNet](https://packt.link/SecNet)'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/QR_Code10596186092701843.png)'
  prefs: []
  type: TYPE_IMG
