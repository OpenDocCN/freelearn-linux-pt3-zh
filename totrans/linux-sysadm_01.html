<html><head></head><body>
<div id="sbo-rt-content"><div id="_idContainer007">
<h1 class="chapter-number" id="_idParaDest-14"><a id="_idTextAnchor013"/>1</h1>
<h1 id="_idParaDest-15"><a id="_idTextAnchor014"/>Getting to Know Linux</h1>
<p>Linux is a family of operating systems based on the same kernel. Since it’s a family of independently developed systems that have different design principles, goals, and implementation details, it’s important to understand what makes that very situation possible and how those systems are structured. In this chapter, we will discuss the concept of Linux distributions and open source software licensing and see how Linux-based systems are used. We will cover the <span class="No-Break">following topics:</span></p>
<ul>
<li>The structure of a <span class="No-Break">Linux system</span></li>
<li>Open source <span class="No-Break">software licenses</span></li>
<li>Linux usage in the <span class="No-Break">modern world</span></li>
</ul>
<h1 id="_idParaDest-16"><a id="_idTextAnchor015"/>The structure of a Linux system</h1>
<p>Linux and its <a id="_idIndexMarker000"/>multiple distributions often seem complicated for beginners. To clarify this, let’s examine the structure and evolution of operating systems <span class="No-Break">in general.</span></p>
<h2 id="_idParaDest-17"><a id="_idTextAnchor016"/>The Linux kernel and Linux-based operating systems</h2>
<p>When people say <em class="italic">Linux</em>, they may mean different things. In the narrow sense, Linux is an operating <a id="_idIndexMarker001"/>system kernel that was created in the early 90s by Linus <a id="_idIndexMarker002"/>Torvalds and is now developed and maintained <a id="_idIndexMarker003"/>by a large international community. However, when people say they are using Linux, they usually mean a family of operating <a id="_idIndexMarker004"/>systems that use that kernel and usually (but not always) a set of system libraries and utilities created by the GNU project, which is why some insist that such systems should be referred to as <span class="No-Break">GNU/Linux instead.</span></p>
<p class="callout-heading">Note</p>
<p class="callout">The GNU project is a free software project that was launched in 1983 by Richard Stallman. His goal was to create a complete Unix-like operating system composed entirely of <a id="_idIndexMarker005"/>free software. <strong class="bold">GNU</strong> stands for <strong class="bold">GNU’s Not Unix</strong>, which reflects the project’s goal of creating a free software alternative to the proprietary Unix <span class="No-Break">operating system.</span></p>
<p>To fully understand how that unusual situation became possible, let’s briefly discuss the history of <span class="No-Break">operating systems.</span></p>
<h2 id="_idParaDest-18"><a id="_idTextAnchor017"/>Kernel versus user space</h2>
<p>The earliest computers had very low computational power, so they would only have one program in <a id="_idIndexMarker006"/>their memory at a time, and that program had complete control over the hardware. As computing power increased, it became feasible to have multiple users use the same computer at the same time and <a id="_idIndexMarker007"/>run multiple programs – an idea known as time-sharing or multitasking. Shared computers would run a program known as a supervisor <a id="_idIndexMarker008"/>that would allocate resources to end user programs. A set of supervisor programs and system utilities became known as an operating system. The earliest time-sharing systems used cooperative multitasking, where programs were expected to transfer control back to the supervisor on their own. However, if a programming mistake made a program run into an endless loop or write data to a wrong memory address, such a program could cause the entire computer to hang or corrupt the memory of another program, including <span class="No-Break">the supervisor.</span></p>
<p>To make multitasking more reliable, newer generations of hardware introduced protection mechanisms that allowed a supervisor program to take control of the CPU back from end user programs and forcibly terminate programs that tried to write something to memory that belonged to other programs or the <span class="No-Break">supervisor itself.</span></p>
<p>That brought a separation between the operating system kernel and user space programs. End user programs physically couldn’t control the hardware directly anymore, and neither could they access memory that wasn’t explicitly allocated to them. Those privileges were reserved for the kernel – the code that includes a process scheduler (serving the same purpose as old supervisor programs) and <span class="No-Break">device drivers.</span></p>
<p>Inside a single program, programmers are free to organize their code as they see fit. However, when multiple independently developed components need to work together, there needs to be a well-defined interface between them. Since no one writes directly in machine code <a id="_idIndexMarker009"/>anymore, for modern systems, this means two interfaces: the <strong class="bold">Application Programming Interface</strong> (<strong class="bold">API</strong>) and the <strong class="bold">Application Binary Interface</strong> (<strong class="bold">ABI</strong>). The API is for programmers who write source code <a id="_idIndexMarker010"/>and define function names they can call and parameter lists for those functions. After compilation, such function calls are translated into executable code that loads parameters into the correct places in memory and transfers control to the code to be called – where to load those parameters and how to transfer control is defined by <span class="No-Break">the ABI.</span></p>
<p>Interfaces <a id="_idIndexMarker011"/>between user space programs and libraries <a id="_idIndexMarker012"/>are heavily influenced by the programming language <a id="_idIndexMarker013"/>they are <span class="No-Break">written in.</span></p>
<p>On the contrary, interfaces between kernels and user space programs look more similar to hardware interfaces. They are completely independent of the programming language and use software interrupts or dedicated <em class="italic">system call</em> CPU instructions rather than the function calls familiar to <span class="No-Break">application programmers.</span></p>
<p class="callout-heading">Note</p>
<p class="callout">A system call in <a id="_idIndexMarker014"/>Linux is a mechanism that allows user-level processes to request services from the kernel, which is the core of the operating system. These services can access hardware devices, manage processes and threads, allocate memory, and perform other low-level tasks that require <span class="No-Break">privileged access.</span></p>
<p>Those interfaces are also very low-level: for example, if you want to use the <strong class="source-inline">write()</strong> system call to print a string to standard output, you must always specify how many bytes to write – it has no <a id="_idIndexMarker015"/>concept of a <em class="italic">string variable</em> or a convention for determining <span class="No-Break">its length.</span></p>
<p>For this reason, operating systems include standard libraries for one or more programming languages, which provide an abstraction layer and a stable API for end <span class="No-Break">user programs.</span></p>
<p>Most operating systems have the kernel, the standard libraries for programming languages, and often the basic system utilities developed by a single group of people in close collaboration, and all those components are versioned and distributed together. In that case, the kernel interface is usually treated as purely internal and isn’t guaranteed to <span class="No-Break">remain stable.</span></p>
<h2 id="_idParaDest-19"><a id="_idTextAnchor018"/>The Linux kernel and the GNU project</h2>
<p>Linux is unique in that it was developed to provide a replacement kernel for an existing user space <a id="_idIndexMarker016"/>part of an operating system. Linus Torvalds, the founder of the project, originally developed it to improve the functionality of MINIX – an intentionally simplified Unix-like operating system meant for instruction rather than production use. He’s since been using the GNU C compiler and user space programs from the GNU project – the project that Richard Stallman started with the goal to create a complete Unix-like operating system that would be free (as in freedom) and open source, and thus available for everyone to use, improve, <span class="No-Break">and redistribute.</span></p>
<p>At the time, the GNU project had <a id="_idIndexMarker017"/>all the user space parts of an operating system, but not a usable kernel. There were other open source Unix projects, but they were derived from the BSD Unix code base, and in the early 90s, they were targets of lawsuits for alleged copyright infringement. The Linux kernel came at a perfect time since Linus Torvalds and various contributors developed it completely independently <a id="_idIndexMarker018"/>and published it under the same license as the GNU project software – the GNU <strong class="bold">General Public License</strong> (<strong class="bold">GPL</strong>). Due to this, a set of GNU software packages, plus the Linux kernel, became a possible basis for a completely open source <span class="No-Break">operating system.</span></p>
<p>However, Linus Torvalds wasn’t a GNU project member, and the Linux kernel remained independent <a id="_idIndexMarker019"/>from the <strong class="bold">Free Software Foundation</strong> (<strong class="bold">FSF</strong>) – it just used a license that the FSF developed for the GNU project, but that any other person could also use, and <span class="No-Break">many did.</span></p>
<p>Thus, to keep new Linux kernel versions useful together with the GNU C library and software that relied on that library, developers had to keep the kernel <span class="No-Break">interface stable.</span></p>
<p>The GNU C library wasn’t developed to work with a specific kernel either – when that project started, there wasn’t a working GNU kernel, and GNU software was usually run on other Unix-like <span class="No-Break">operating systems.</span></p>
<p>As a result, both Linux and the GNU software can be and still are used together and in different combinations. The GNU user space software set can also be used with the still-experimental GNU hard kernel, and other operating systems use it as system or add-on software. For example, Apple macOS used GNU Bash as its system shell for a long time, until it was replaced <span class="No-Break">by zsh.</span></p>
<p>The stability guarantees of the Linux kernel interface make it attractive to use as a basis for custom operating systems that may be nothing like Unix – some of them just have a single program run on top of the kernel. People have also created alternative standard libraries for <a id="_idIndexMarker020"/>different programming languages <a id="_idIndexMarker021"/>to use with Linux, such as Musl and Bionic for the C programming language, which use more permissive licenses and facilitate static linking. But to understand those licensing differences, we need to discuss the concept <a id="_idTextAnchor019"/>of <span class="No-Break">software licenses.</span></p>
<h1 id="_idParaDest-20"><a id="_idTextAnchor020"/>Open source software licenses</h1>
<p>A software license is an agreement between a copyright holder and a recipient of the software. Modern copyright laws are designed to give authors complete control over the use and <a id="_idIndexMarker022"/>distribution of their work – copyright automatically exists from the moment a piece of work is fixed on any medium and no one can use or copy that work without explicit permission from the author. Thus, a license agreement is required to grant a user some of the permissions that are reserved for the author by default. Authors are free to specify any conditions, and many individuals and companies use that to restrict what users can do – for example, only permit non-commercial use. A license agreement is also normally made between an author or a copyright holder and a <span class="No-Break">specific person.</span></p>
<p>However, in the late 1980s, programmers and lawyers came up with the idea to use authors’ unlimited control over their works to ensure that anyone can use, distribute, and modify them rather than prevent that. They introduced <em class="italic">public licenses</em>, which grant permissions to everyone rather than just people who signed or otherwise accepted the agreement, and wrote several reusable license agreements that anyone could apply to their software. That concept <a id="_idIndexMarker023"/>became known as <strong class="bold">copyleft</strong> – a reversal of copyright. Those licenses became known as open source licenses because they explicitly permit the distribution and modification of software <span class="No-Break">source code.</span></p>
<p>All the <em class="italic">classic</em> licenses <a id="_idIndexMarker024"/>were born in that period: the MIT license, the BSD license, the GNU GPL, and the GNU <strong class="bold">Lesser/Library General Public License</strong> (<strong class="bold">LGPL</strong>). None of those licenses limit users’ rights to use software distributed under them. Conditions, if any, apply only to the distribution and modification of exec<a id="_idTextAnchor021"/>utables and <span class="No-Break">source code.</span></p>
<h2 id="_idParaDest-21"><a id="_idTextAnchor022"/>Permissive and copyleft licenses</h2>
<p>When it comes to distribution, two schools of thought differ in their approach to <span class="No-Break">distribution conditions.</span></p>
<p>Proponents <a id="_idIndexMarker025"/>of permissive licenses believe that recipients of software must have absolute freedom to do anything with it, even to <a id="_idIndexMarker026"/>incorporate it into other software that isn’t open source or to create closed source derivatives. The MIT and BSD licenses are typical examples of permissive open <span class="No-Break">source licenses.</span></p>
<p>Proponents of <a id="_idIndexMarker027"/>copyleft believe that it’s <a id="_idIndexMarker028"/>important to protect open source software from attempts to appropriate the work of its authors and create a closed source derivative. The GNU GPL is the purest example of this – if anyone distributes executables of programs under the GPL or programs that link with libraries under the GPL, they must also distribute the source code of that program under that license. This is the most radical approach <a id="_idIndexMarker029"/>and is known as <span class="No-Break"><em class="italic">strong copyleft</em></span><span class="No-Break">.</span></p>
<p>Licenses that allow you to link libraries to programs under any other license but require library code modifications to <a id="_idIndexMarker030"/>be under the same license are known as <em class="italic">weak copyleft</em> licenses. The most widely<a id="_idTextAnchor023"/> used example is the <span class="No-Break">GNU LGPL.</span></p>
<h2 id="_idParaDest-22"><a id="_idTextAnchor024"/>Patent grant, tivoization, and SaaS concerns</h2>
<p>The GNU GPL was created as a response to the rise of proprietary software distributed without source <a id="_idIndexMarker031"/>code, which prevented end users from improving it and sharing their improvements. However, the software industry is evolving, and new trends are appearing that some see as threats to the existence or financial sustainability of open <span class="No-Break">source software.</span></p>
<p>One such threat is <em class="italic">patent trolling</em> – the use <a id="_idIndexMarker032"/>of software patents (in jurisdictions where they exist) in bad faith. As a response to it, some newer licenses and new versions <a id="_idIndexMarker033"/>of old licenses, such as the Apache license and the GNU GPLv3, introduced a patent grant clause. Such a clause prevents contributors to the source code of software from making patent claims against its users. If they make such legal threats, their licenses <span class="No-Break">are revoked.</span></p>
<p>A more controversial point of the GPLv3 is its attempts to protect users’ rights to run modified versions on their hardware. The practice of preventing hardware from running custom software through digital signatures and similar mechanisms is sometimes called <em class="italic">tivoization</em>, after a Linux-based <a id="_idIndexMarker034"/>digital video recorder named TiVo that was an early example of such lock-in. While some projects supported <a id="_idIndexMarker035"/>the idea to prevent it, for others, the GPLv3 clause was a reason not to switch from GPLv2 – the Linux kernel is among those projects that stayed at the old <span class="No-Break">GPL version.</span></p>
<p>Finally, all classic licenses were written in a time when all software was deployed on-premises, while in the modern world, a lot of software is delivered over a network and its executables aren’t <a id="_idIndexMarker036"/>accessible to end users – an approach known as <strong class="bold">Software-as-a-Service</strong> (<strong class="bold">SaaS</strong>). Since the GPL says that every recipient of <a id="_idIndexMarker037"/>a binary executable is entitled to receive its source code, it does not apply to SaaS since the user never receives any executables. This allows vendors to create modified versions of the software under the GPL without sharing their improvements with the community. Several licenses were developed in response to that trend, such as the <span class="No-Break">Affero GPL.</span></p>
<p>In the last few years, big technology companies that provide hosted versions of open source software started to be seen as undermining project maintainers’ ability to earn money from services since it’s very difficult to compete on price with effective monopolies. In response, some projects started switching to licenses that have restrictions on usage, which many argue are no longer open source licenses, even though the source code is still available. The future <a id="_idTextAnchor025"/>of such licenses is an <span class="No-Break">open question.</span></p>
<h1 id="_idParaDest-23"><a id="_idTextAnchor026"/>Linux distributions</h1>
<p>The fact that software under open source licenses is free to modify and distribute made it possible to assemble complete operating systems with kernels, system libraries, and utilities, as well as <a id="_idIndexMarker038"/>a selection of application software. Since open source licenses have no restrictions on usage, there is no need to make the user accept a license agreement for <span class="No-Break">each component.</span></p>
<p>In the early days of Linux, setting up a usable Linux environment was a complicated and tedious endeavor. To make that process simpler, Linux enthusiasts started preparing the first <em class="italic">distributions</em> – sets of packages and scripts to automate their installation. Many of those early distributions, such as Softlanding Linux System and Yggdrasil, are now defunct, but some are still maintained – S<a id="_idTextAnchor027"/>lackware Linux is a <span class="No-Break">prominent example.</span></p>
<h2 id="_idParaDest-24"><a id="_idTextAnchor028"/>Package managers and package repositories</h2>
<p>Early distributions had a relatively humble goal, which was to provide users with a working barebones <a id="_idIndexMarker039"/>system that they could then install their application software on. However, later distributions set out to rethink the process <a id="_idIndexMarker040"/>of software installations. The number of open source software projects was growing, and CD drives and internet connections were also becoming more affordable, so it was feasible to include much more software in a distribution than <span class="No-Break">ever before.</span></p>
<p>However, many applications depend on shared libraries or other applications. Traditionally, installation packages would either include all dependencies or leave that dependency <a id="_idIndexMarker041"/>management to the user. Since distribution is managed by a single group of maintainers, developers came up with the idea of sharing dependencies between all packages that need them and automatically installing all dependencies when a user requested the installation of a package. That gave rise to package managers and package repositories – collections of files in a special format, including compiled binaries and metadata such as the package version and <span class="No-Break">its dependencies.</span></p>
<p>The two most popular <a id="_idIndexMarker042"/>package formats and package managers that work with them were developed in the mid-90s and are still in use today. One is <a id="_idIndexMarker043"/>the DEB format, which is used with the dpkg utility, developed by Debian. The other is <strong class="bold">Red Hat Package Manager</strong> (<strong class="bold">RPM</strong>), which is used with the rpm utility and is developed by <span class="No-Break">Red Hat.</span></p>
<p>The dpkg and rpm tools are responsible for installing package files on local machines. To install a package, the user needs to retrieve the package itself and all packages it depends on. To automate that process, distributions developed high-level package managers that can automatically download packages from online repositories, check for updates, search metadata, and more. Those high-level package managers usually rely on low-level ones <a id="_idIndexMarker044"/>to manage the installation. Debian’s <strong class="bold">Advanced Packaging Tool</strong> (<strong class="bold">APT</strong>) usually works with DEB packages, although it’s technically possible to use it with RPM. High-level package managers that primarily use the RPM format are more numerous: YUM and DNF, which are maintained by Red Hat, zypper from openSUSE, and urpmi, which is developed for the now-defunct Mandrake Linux and still used by <span class="No-Break">its forks.</span></p>
<p>Many of the currently existing distributions have either been actively maintained since the 90s or are forks that split off at different points in time. For example, Ubuntu Linux was forked from Debian GNU/Linux in the early 2000s, while Rocky Linux is a Red Hat Enterprise Linux derivative that started <span class="No-Break">in 2021.</span></p>
<p>However, completely independent distributions also appear once in a while. Some of them are special-purpose systems that have requirements that classic general-purpose distributions <a id="_idIndexMarker045"/>cannot fulfill. For example, OpenWrt is a Linux-based system for consumer routers, originally developed for the Linksys WRT-54G device, hence the name. Such devices often have just a few megabytes of flash <a id="_idIndexMarker046"/>drive space, so operating systems for them have to be very compact, and they also have to use special filesystems such as JFFS that are designed for NAND <span class="No-Break">flash drives.</span></p>
<p>Other independent <a id="_idIndexMarker047"/>distributions experiment with different package <a id="_idIndexMarker048"/>management and installation principles. For example, NixOS and GNU Guix use an approach that allows the user to revert system updates if anything goes wrong with new <span class="No-Break">package versions.</span></p>
<p>In this book, we will focus on Debian/Ubuntu and Red Hat-based systems because they have been the most popular d<a id="_idTextAnchor029"/>istributions for a long time and <span class="No-Break">remain popular.</span></p>
<h2 id="_idParaDest-25"><a id="_idTextAnchor030"/>Differences between distributions</h2>
<p>The differences between distributions do not stop at package managers. Configuration file locations may differ, and default configurations for the same packages may also differ dramatically. For example, the configuration file directory for the Apache HTTP server is <strong class="source-inline">/etc/httpd</strong> on Red Hat Linux derivatives, but <strong class="source-inline">/etc/apache2</strong> on <span class="No-Break">Debian derivatives.</span></p>
<p>Some distributions <a id="_idIndexMarker049"/>also use high-level configuration tools and you may take them <span class="No-Break">into account.</span></p>
<p>The choice of software and its ease of installation may also differ. Debian, Fedora, and many other distributions leave the choice of a desktop environment to the user and make it easy to install multiple different desktop environments on the same system so that you can switch between GNOME3, KDE, MATE, or anything else for different login sessions. In contrast, the Ubuntu family of distributions includes multiple flavors for different desktop environments and expects that if you don’t like its default choice (the Unity desktop environment), you should use Kubuntu for KDE, for example, rather than the default Ubuntu. Finally, some distributions come with a custom desktop environment and don’t support anything else, such as <span class="No-Break">elementary OS.</span></p>
<p>However, experienced Linux users can<a id="_idTextAnchor031"/> usually find their way around <span class="No-Break">any distribution.</span></p>
<h1 id="_idParaDest-26"><a id="_idTextAnchor032"/>Linux usage in the modern world</h1>
<p>The open source nature of the Linux kernel and its support for multiple hardware architectures made it a very popular choice for custom operating systems, while general-purpose <a id="_idIndexMarker050"/>Linux distributions also found wide use in every niche where proprietary Unix systems were <span class="No-Break">used before.</span></p>
<p>The most popular Linux-based operating system in the world is Android. While most Android applications are written for a custom runtime and never use any functionality of the Linux kernel directly, it’s still a <span class="No-Break">Linux distribution.</span></p>
<p>Network devices are usually managed through a web GUI or a custom command-line interface, but they still often have Linux under the hood. This applies to consumer-grade Wi-Fi routers, as well as high-performance enterprise and data center routers and <span class="No-Break">switches alike.</span></p>
<p>General-purpose Linux distributions are also everywhere. Thanks to built-in support for running virtual machines (through Xen or KVM hypervisors), Linux powers the largest cloud computing platforms, including Amazon EC2, Google Cloud Platform, and DigitalOcean. A lot of guest systems are also Linux machines running web servers, database systems, and many <span class="No-Break">other applications.</span></p>
<p>Linux is also widely used in high-performance computing: all of the most powerful supercomputers in the world are now running Linux on their control and <span class="No-Break">I/O nodes.</span></p>
<p>Last but not least, the author of this chapter typed these words on a <span class="No-Break">Linux desktop.</span></p>
<h1 id="_idParaDest-27"><a id="_idTextAnchor033"/>Summary</h1>
<p>A Linux distribution is a complete operating system that includes the Linux kernel and a set of libraries and programs developed by various people and companies. The Linux kernel and core system libraries are not developed by the same group. Instead, the Linux kernel provides a stable ABI that allows anyone to develop a standard library for a programming language to run on top <span class="No-Break">of it.</span></p>
<p>Open source licenses come with different conditions, but they all allow anyone to use the software for any purpose and distribute its copies, and that’s what makes the existence of Linux <span class="No-Break">distributions possible.</span></p>
<p>Different distributions use different approaches to package management and configuration, but experienced users can learn how to use a new distribution fairly quickly if they know the fundamentals. These days, Linux can be found everywhere, from mobile phones to the most <span class="No-Break">powerful supercomputers.</span></p>
<p>In the next chapter, we will learn about the various shells available on Linux systems, as well as <span class="No-Break">basic commands.</span></p>
</div>
</div></body></html>