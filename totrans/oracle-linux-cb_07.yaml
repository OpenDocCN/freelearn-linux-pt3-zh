- en: '7'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Oracle Linux 8 – Patching Doesn’t Have to Mean Rebooting
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: I’ve rebooted when patching for my entire life, why change now?
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
- en: Since Linux was released back in 1991, when the kernel was patched, you had
    to reboot the system. At the time, even the IBM mainframes that dominated corporate
    IT needed to be rebooted when patched, so it was considered normal for all other
    systems to be rebooted when patched. This process appeared to work fine for almost
    the next 20 years, but the seeds of change were planted in 2005 when a **Massachusetts
    Institute of Technology** (**MIT**) student came up with a simple question. *What
    if you could patch without rebooting the system?* His team came up with an answer
    in 2009 when Ksplice was released, enabling the ability to patch a Linux kernel
    while the system was running.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will cover why you should start using Ksplice and how it
    is used to improve the security of your system.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
- en: 'This chapter contains the following recipes:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
- en: Setting up Ksplice with internet access
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using Ksplice with no internet access
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Installing and enabling Known Exploit Detection
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Setting up Ksplice with internet access
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Before we get into the recipe, let’s understand what’s all the fuss around Ksplice.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
- en: What’s all the fuss about Ksplice?
  id: totrans-11
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The first question is, *Why is this important to IT, and more importantly, to
    defending the applications running on the servers?* Before we get to that, you
    first need to understand the process that hackers use to compromise systems.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
- en: 'The basic process includes three main stages: reconnaissance, gaining access,
    and then maintaining access. Once a system is compromised, the process is repeated
    on other systems on the network:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.1 – Security life cycle](img/B18349_07_01.jpg)'
  id: totrans-14
  prefs: []
  type: TYPE_IMG
- en: Figure 7.1 – Security life cycle
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
- en: 'In the first phase, **reconnaissance**, hackers use a variety of methods to
    scan the system for vulnerabilities. Often, this attacking phase against servers
    starts after hackers have gained access to a low-level support account that has
    access to the server. Once there, it is a trivial task to look at the kernel version
    and identify what vulnerabilities the kernel is susceptible to. Oracle offers
    a free site ([https://ksplice.oracle.com/inspector](https://ksplice.oracle.com/inspector))
    that lets you easily check the vulnerabilities of the kernel. The results of such
    a check are shown in *Figure 7**.2*:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.2 – Ksplice Inspector](img/B18349_07_02.jpg)'
  id: totrans-17
  prefs: []
  type: TYPE_IMG
- en: Figure 7.2 – Ksplice Inspector
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
- en: The MITRE Corporation is a non-profit company funded by the US federal government
    that researches ways to improve safety across multiple industries, including aviation,
    healthcare, homeland security, defense, and cybersecurity. The **Common Vulnerabilities
    and Exposures** (**CVE**) program was launched in 1999 and quickly became the
    go-to location to track cybersecurity vulnerabilities. More information about
    the CVE program can be found at [https://cve.org](https://cve.org).
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
- en: Not only will the system identify the CVE that the kernel is susceptible to
    but it also links to the MITRE site with the CVE details. In the example report,
    you can see the kernel is susceptible to several CVEs, including a few that would
    allow the attacker to gain root access. Surprisingly, unlike other similar technologies,
    Ksplice also helps defend against this phase with its ability to detect attacks
    against the running kernel, seeking to gain privileged escalation using the **Known
    Exploit Detection** technology. This effectively turns every system using Ksplice
    into a free intrusion detection system for the kernel.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
- en: In the next phase, gaining access, the hacker exploits the vulnerability, gaining
    access to the data. This is often done weeks after the initial discovery phase.
    Hackers take their time; they do this to run under the radar, and they know that
    most environments are only patched on a quarterly basis at best. Additionally,
    many attacks come from inside the organization, from people who have limited access
    to systems as part of their normal role. Ksplice disrupts this pattern, enabling
    the system admin to easily patch daily, closing the window of opportunity for
    the hacker.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
- en: 'In the last phase, the hackers work to maintain access, often using the same
    vulnerability to continually mine the system for data. Ksplice allows this to
    also be shut down, as it closes the vulnerability not only for exploits post-patch
    but also shuts down the exploit for the attack while in progress. This is an important
    feature of Ksplice: the ability to patch the kernel and close the exploit while
    the exploit is being used. This shuts down the exploit mid-flight, significantly
    enhancing the system’s security.'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, about that patching effort – once a quarter at best? Kernel patches are
    released almost daily, yet systems can remain unpatched for almost a quarter of
    the year or more. This gives attackers a huge window of opportunity to compromise
    your systems. Not only is scheduling the patch a challenge for most mission-critical
    systems but the patch process itself is very time- and labor-intensive. Let’s
    look at why this is the case. As seen in the following diagram, there are many
    steps required to patch a server:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.3 – Legacy patch process](img/B18349_07_03.jpg)'
  id: totrans-25
  prefs: []
  type: TYPE_IMG
- en: Figure 7.3 – Legacy patch process
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
- en: 'The following list provides a short description of each of these steps:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
- en: '**Block users from accessing the application**: Disable load balancers or disable
    user logins to the application so users do not accidentally corrupt data.'
  id: totrans-28
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Shut down the application**: Shut down the databases, application servers,
    schedulers, load balancers, and so on. This is to prepare for the operating system
    reboot.'
  id: totrans-29
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Sanity reboot the servers**: Perform a reboot of the servers, with no other
    changes made. This is to verify that the servers can perform a clean reboot. Often
    in this step, a snapshot is made of the app servers.'
  id: totrans-30
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Restart the application**: Start the application back up to verify that it
    is working. This is to verify the sanity reboot.'
  id: totrans-31
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**重新启动应用程序**：重新启动应用程序以验证其是否正常工作。这是为了验证重启的合理性。'
- en: '**Test post sanity reboot**: Often, some changes get made to the application
    and/or its infrastructure that can cause issues with the application. This step
    verifies that there is a good system before the patches are applied.'
  id: totrans-32
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**测试重启后的合理性**：通常，一些更改会对应用程序和/或其基础设施产生影响，从而导致应用程序出现问题。此步骤验证在应用补丁之前系统是否处于良好状态。'
- en: '**Shut down the application**: Shut everything down again to prepare for the
    patching.'
  id: totrans-33
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**关闭应用程序**：再次关闭所有内容以准备进行修补。'
- en: '**Patch the servers**: Apply the operating system patches.'
  id: totrans-34
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**修补服务器**：应用操作系统的修补。'
- en: '**Reboot post patch**: Reboot so the patches take effect.'
  id: totrans-35
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**修补后重启**：重启以使修补生效。'
- en: '**Restart the application**: Restart the application again.'
  id: totrans-36
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**重新启动应用程序**：再次重新启动应用程序。'
- en: '**Test the application**: Test the application, and verify all is good.'
  id: totrans-37
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**测试应用程序**：测试应用程序，确认一切正常。'
- en: '**Let users back in**: Allow users back into the application.'
  id: totrans-38
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**允许用户重新进入**：允许用户重新进入应用程序。'
- en: Note
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Not every organization follows the full path process, skipping steps to save
    some time. While this can save some time in the short term, all it takes is one
    bad patch cycle where changes were made to the application and/or its infrastructure
    between patch cycles to make for a very bad, long night, or worse, long days.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 不是每个组织都遵循完整的流程，会跳过某些步骤以节省时间。虽然这可以在短期内节省一些时间，但只要有一个坏的修补周期，在修补周期之间对应用程序和/或其基础设施进行更改，就可能导致非常糟糕、漫长的夜晚，甚至更糟，变成漫长的几天。
- en: As you can see, properly patching takes a lot of time, and the more complex
    the application, the more people and time are required for each patch cycle. Most
    of this time and effort is caused due to the reboots required.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，正确地修补需要花费大量时间，而且应用程序越复杂，每个修补周期所需的人力和时间也就越多。大部分的时间和精力都是由于需要重启而造成的。
- en: When you avoid the reboot, the patch process is significantly simplified; as
    shown in the following diagram, there are only two steps!
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 当你避免重启时，修补过程会显著简化；如下图所示，只有两个步骤！
- en: '![Figure 7.4 – Ksplice patching process](img/B18349_07_04.jpg)'
  id: totrans-43
  prefs: []
  type: TYPE_IMG
  zh: '![图7.4 – Ksplice修补过程](img/B18349_07_04.jpg)'
- en: Figure 7.4 – Ksplice patching process
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.4 – Ksplice修补过程
- en: 'The following list provides a short description of these two steps:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 以下列表提供了这两个步骤的简短描述：
- en: '**Ksplice the servers**: Apply the kernel and user space patches with ksplice.'
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**对服务器进行Ksplice**：使用Ksplice应用内核和用户空间的修补。'
- en: '**Testing**: Test the application'
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**测试**：测试应用程序'
- en: By using Ksplice, your team can save a ton of time, reduce late nights, and
    improve security. Best of all, it’s easy to set up and use!
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Ksplice后，你的团队可以节省大量时间，减少加班夜晚，并提高安全性。最棒的是，它易于设置和使用！
- en: Discovering Ksplice
  id: totrans-49
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 发现Ksplice
- en: 'Ksplice is easy to configure. There are a few concepts and points you need
    to understand before Ksplicing your servers:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: Ksplice配置起来很容易。在对你的服务器进行Ksplice之前，有一些概念和要点需要你理解：
- en: If your servers are running on **Oracle Cloud Infrastructure** (**OCI**), using
    Oracle’s default platform images, all the Ksplice preparation work and access
    to the Ksplice repo is already performed to support online Ksplice usage. Systems
    will also need a route (usually done with a NAT gateway) to the Ksplice endpoint.
    This is automatically set up when using the **Virtual Cloud Network** (**VCN**)
    wizard.
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果你的服务器运行在**Oracle Cloud Infrastructure**（**OCI**）上，并使用Oracle的默认平台镜像，所有Ksplice的准备工作和访问Ksplice仓库的权限都已经完成，以支持在线使用Ksplice。系统还需要有一条通路（通常是通过NAT网关）到Ksplice的端点。当使用**虚拟云网络**（**VCN**）向导时，这会自动设置好。
- en: If you are using Autonomous Linux on OCI, your systems are already being Kspliced
    automatically.
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果你在OCI上使用自主Linux，你的系统已经在自动进行Ksplice操作。
- en: 'There are two Ksplice clients: the legacy Uptrack client and the Enhanced client.'
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Ksplice有两个客户端：传统的Uptrack客户端和增强版客户端。
- en: You do not need internet access to use Ksplice; you can use specially built
    Ksplice `.rpm` files using the offline mode. This will require that you mirror
    the ULN Ksplice repos on a local YUM server. This was covered in [*Chapter 5*](B18349_05.xhtml#_idTextAnchor135).
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Ksplice时无需互联网访问；你可以使用特别构建的Ksplice `.rpm` 文件来离线模式使用。这需要你在本地YUM服务器上镜像ULN Ksplice仓库。有关内容已在[*第5章*](B18349_05.xhtml#_idTextAnchor135)中讲解。
- en: Both the Enhanced client and the Uptrack client allow you to Ksplice the kernel,
    but the Enhanced client also offers the ability to Ksplice user space libraries,
    KVM hypervisors, and Arm-based systems and offers Known Exploit Detection on x86_64
    platforms. Most new users should use the Enhanced client.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
- en: The older Uptrack client does not offer the advantages the Enhanced client offers,
    but it does support the ability to patch some non-Oracle Linux systems.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
- en: 'Ksplice offers two different modes: the online mode and the offline mode. The
    online mode requires that each system registers to the Oracle ULN but offers a
    Ksplice web interface, the Ksplice Uptrack API, for advanced automation and the
    ability to patch a Xen hypervisor. However, since this requires every system to
    not only register with ULN but also for internet access, many system administrators
    use the offline mode.'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
- en: 'The offline mode allows the system to use Ksplice without internet access.
    This is most often used by Enterprise and Government environments where all servers
    do not have internet access. In these use cases, the most common method is to
    set up a ULN mirror, giving that system access to the internet, and the local
    Oracle Linux servers will pull from that mirror to use Ksplice:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.5 – Ksplice offline mode using RPMs](img/B18349_07_05.jpg)'
  id: totrans-59
  prefs: []
  type: TYPE_IMG
- en: Figure 7.5 – Ksplice offline mode using RPMs
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
- en: 'With the offline mode, only the local ULN mirror needs to be able to access
    the Oracle ULN, via the HTTPS protocol. This can be done via a basic firewall
    rule or a more advanced proxy server. Once the ULN mirror is registered and synced
    from the ULN, the servers behind the firewall can pull their RPMs via HTTP/HTTPS
    from the ULN mirror. There are a couple of advantages to the offline mode: less
    bandwidth is used for the internet and not every client needs to be registered.
    Of course, having no API, there are some limitations with more advanced automation.'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
- en: 'Regardless of what mode is used, the clients must have access to a few specific
    Ksplice channels. The following table describes the channels that are available
    for Ksplice in Oracle Linux:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
- en: '| **Channel Name** | **Enhanced** **Client** | **Channel Label** | **Description**
    |'
  id: totrans-63
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- |'
  id: totrans-64
  prefs: []
  type: TYPE_TB
- en: '| Ksplice for Oracle Linux 7 (x86_64) | Optional | `ol7_x86_64_ksplice` | Ksplice
    RPMs for Oracle Linux 7 on x86_64 systems |'
  id: totrans-65
  prefs: []
  type: TYPE_TB
- en: '| Ksplice for Oracle Linux 7 (aarch64) | Optional | `ol7_aarch64_ksplice` |
    Ksplice RPMs for Oracle Linux 7 on aarch64 systems |'
  id: totrans-66
  prefs: []
  type: TYPE_TB
- en: '| Ksplice for Oracle Linux 8 (x86_64) | Optional | `ol8_x86_64_ksplice` | Ksplice
    RPMs for Oracle Linux 8 on x86_64 systems |'
  id: totrans-67
  prefs: []
  type: TYPE_TB
- en: '| Ksplice for Oracle Linux 8 (aarch64) | Optional | `ol8_aarch64_ksplice` |
    Ksplice RPMs for Linux 8 on aarch64 systems |'
  id: totrans-68
  prefs: []
  type: TYPE_TB
- en: '| Ksplice-aware user space packages for Oracle Linux 7 (x86_64) | Required
    | `ol7_x86_64_userspace_ksplice` | Latest RPMs for Ksplice-aware user space packages
    for Oracle Linux 7 (x86_64) |'
  id: totrans-69
  prefs: []
  type: TYPE_TB
- en: '| Ksplice-aware user space packages for Oracle Linux 7 (aarch64) | Required
    | `ol7_aarch64_userspace_ksplice` | Latest RPMs for Ksplice-aware user space packages
    for Oracle Linux 7 (aarch64) |'
  id: totrans-70
  prefs: []
  type: TYPE_TB
- en: '| Ksplice-aware user space packages for Oracle Linux 8 (x86_64) | Required
    | `ol8_x86_64_userspace_ksplice` | Latest RPMs for Ksplice-aware user space packages
    for Oracle Linux 8 (x86_64) |'
  id: totrans-71
  prefs: []
  type: TYPE_TB
- en: '| Ksplice-aware user space packages for Oracle Linux 8 (aarch64) | Optional
    | `ol8_aarch64_userspace_ksplice` | Latest RPMs for Ksplice-aware user space packages
    for Oracle Linux 8 (aarch64) |'
  id: totrans-72
  prefs: []
  type: TYPE_TB
- en: Table 7.1 – Ksplice channels
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
- en: If `prelink` is installed, revert the pre-linked binaries to their original
    state (`prelink -au`) and then uninstall `prelink` (`dnf remove prelink -y`).
    While not often used, `prelink` is not compatible with Ksplice.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
- en: Now that you have an understanding of why you need to use Ksplice and the basics
    of how it works, let’s get to the recipe.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
- en: The easiest way to use Ksplice is to allow each system to access the Oracle
    Ksplice service directly. This is called online mode. This can be done via an
    internet proxy, direct access, or by running the systems in OCI.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  id: totrans-78
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To do this, you will need a test system, running Oracle Linux 8, with access
    to the internet.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  id: totrans-80
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'When using Ksplice, make sure you match each system for both the operating
    system version, and the user-space libraries. Do not use an Oracle Linux 9 repo
    for an Oracle Linux 8 system. An example of what a system should look like can
    be seen in the following screenshot:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.6 – Required channels](img/B18349_07_06.jpg)'
  id: totrans-82
  prefs: []
  type: TYPE_IMG
- en: Figure 7.6 – Required channels
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
- en: 'If you are using an internet proxy server, you will need to export some environmental
    variables to set the proxy servers:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Set `proxy_server_URL` to the proxy server, and `http_port` to the port the
    proxy server uses.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, Ksplice will be installed using `dnf`. Both the `ksplice` and `uptrack`
    packages are needed:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: When the installation is complete, please verify that your system is seen in
    the ULN and that an access key has been populated in `/etc/uptrack/uptrack.conf`.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
- en: 'The access key should be in the `[Auth]` section and should look similar to
    this:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Once done, perform a normal `dnf update` and then reboot the system. This `dnf
    update` is required so the Ksplice-aware user space libraries are loaded; it is
    only required the first time Ksplice is used.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
- en: Once the server is rebooted, Ksplice can now be used to patch user space libraries
    and the kernel.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
- en: 'To see what updates are available for the kernel, you can run the Ksplice `kernel
    upgrade` command, passing `-n` for no action:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The output from this command is seen in the following screenshot:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.7 – Ksplice available upgrades](img/B18349_07_07.jpg)'
  id: totrans-97
  prefs: []
  type: TYPE_IMG
- en: Figure 7.7 – Ksplice available upgrades
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
- en: 'In this system, only one update is available, patching `CVE-2021-4034`. To
    splice the system, run the same command, replacing `-n` with `-y` to say yes to
    applying the kernel path:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.8 – Ksplice updating the kernel](img/B18349_07_08.jpg)'
  id: totrans-100
  prefs: []
  type: TYPE_IMG
- en: Figure 7.8 – Ksplice updating the kernel
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
- en: From here, you can see that the CVE patch has now taken place without a reboot!
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
- en: The kernel that has been patched is referred to as the effective kernel. When
    you use the `ksplice kernel uname -r` command in Ksplice, it displays the effective
    kernel version, which indicates the current security status of the kernel based
    on the applied patches. This version typically varies from the initially booted
    kernel version and is meant to reflect the present condition of the kernel regarding
    any potential security threats or major issues.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
- en: 'You can now validate what your effective kernel is by using the following Ksplice
    command:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Note that the version of the running kernel and the installed kernel will not
    match! This is because when Ksplice splices the kernel, it splices the RAM of
    the running kernel with the new code. This patches the kernel (and selected user
    space libraries) but has the effect of `uname` no longer matching the effective
    kernel:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.9 – Ksplice uname](img/B18349_07_09.jpg)'
  id: totrans-107
  prefs: []
  type: TYPE_IMG
- en: Figure 7.9 – Ksplice uname
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
- en: Here, the installed kernel is `5.4.17-2136.302.7.2.1.el8uek.aarch64`, but the
    effective kernel that has been Kspliced is a newer kernel at version `5.4.17-2136.306.1.3.el8uek`.
    This is normal behavior with Ksplice.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
- en: 'User space libraries can be patched in the same way, replacing the kernel with
    the user. As a note, if the Ksplice user space libraries are *not* installed,
    the first time the command is run, you will be prompted to upgrade the user libraries
    to a Ksplice-compatible version:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.10 – Installing Ksplice user libraries for the first time](img/B18349_07_10.jpg)'
  id: totrans-111
  prefs: []
  type: TYPE_IMG
- en: Figure 7.10 – Installing Ksplice user libraries for the first time
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
- en: 'You can also check user space available packages to Ksplice with the `ksplice
    user show --available` command but if you did not install the Ksplice-aware packages,
    you will get this error:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
- en: '`No active user-space` `Ksplice targets`'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
- en: '`Have you installed Ksplice-aware libraries` `and rebooted?`'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
- en: 'You can also check what user space targets are currently running and can be
    patched. This is done with the following command:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The sample output is shown in the following screenshot:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.11 – Ksplice targets](img/B18349_07_11.jpg)'
  id: totrans-120
  prefs: []
  type: TYPE_IMG
- en: Figure 7.11 – Ksplice targets
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
- en: 'The Ksplice command can also be used to roll back a splice. By using the `ksplice
    kernel show` command, you can see all the splices currently installed:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.12 – Installed kernel patches](img/B18349_07_12.jpg)'
  id: totrans-123
  prefs: []
  type: TYPE_IMG
- en: Figure 7.12 – Installed kernel patches
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
- en: Each Ksplice patch has a unique **Ksplice identifier** (**KID**). The KID is
    also unique to the specific kernel build and patch, so when comparing KIDs across
    different kernels, be careful. If using automation to leverage the KID, make sure
    that you limit the automation to systems with the same kernel build and architecture.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
- en: 'This is the first column in the list of installed patches. If you need to uninstall
    a specific patch, it is possible. In this example, KID `qd1g4vxd` (CVE-2021-4149:
    denial-of-service in the BTRFS filesystem) will be uninstalled using the Ksplice
    `undo` command, passing the specific KID. You can also pass `-v` for verbose.
    Once uninstalled, check the list of installed KIDs to verify the removal of the
    single KID:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.13 – Ksplice undo](img/B18349_07_13.jpg)'
  id: totrans-127
  prefs: []
  type: TYPE_IMG
- en: Figure 7.13 – Ksplice undo
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
- en: 'Optionally, all installed KIDs can be removed from a running system by using
    the following command:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'This will remove all the KIDs from the running kernel in memory:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.14 – Ksplice remove](img/B18349_07_14.jpg)'
  id: totrans-132
  prefs: []
  type: TYPE_IMG
- en: Figure 7.14 – Ksplice remove
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
- en: Ksplice also allows for automatic updates. They can be enabled or disabled by
    simply touching a file, or removing a file. If the `/etc/uptrack/disable` file
    exists, Ksplice will not automatically update the system when you reboot. If the
    file is not there, then Ksplice will check on reboot for any new KIDs and apply
    them. You can also modify this behavior by updating the `uptrack.conf` file. This
    is covered later in this chapter.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
- en: How it works…
  id: totrans-135
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When you are using Ksplice with internet access, the Ksplice client connects
    to the Oracle ULN Ksplice system, and downloads and applies the required splices.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
- en: Using Ksplice with no internet access
  id: totrans-137
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Not all systems have internet access. That is fine, as it’s possible to use
    Ksplice against a local patch repository.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  id: totrans-139
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To do this, you will need a test system running Oracle Linux 8, with access
    to a local YUM repository on the network.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  id: totrans-141
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To install the client, make sure that your server is using an RPM repo that
    is mirrored locally. To install Ksplice, you must decide on either the online
    or offline client. As a reminder, the online client requires that the system be
    registered with ULN, and the offline client will use a local RPM repository.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
- en: 'To install the online client, run the following command:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'To install the offline client, run the following command:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'The output from this command is shown in the following screenshot:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.15 – Offline Ksplice installation](img/B18349_07_15.jpg)'
  id: totrans-148
  prefs: []
  type: TYPE_IMG
- en: Figure 7.15 – Offline Ksplice installation
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
- en: Once Ksplice is installed, you can now splice the server.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
- en: Since the Uptrack client has no advantages over the new client with Oracle Linux
    8 (or Oracle Linux 7 for that matter), we will focus on the Enhanced client. If
    you are using an older operating system, you may need to use the older Uptrack
    client.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
- en: 'Ksplice with the offline method is really easy; simply use `dnf` to patch the
    system:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: This will patch in both the normal way and then with Ksplice for the kernel
    and user libraries. If you want to disable this behavior, you can set `skip_apply_after_pkg_install`
    to `true` in `/``etc/uptrack/uptrack.conf`.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
- en: 'Before you patch, make sure you have added a Ksplice entry in `/etc/yum.repos.d`.
    A sample Ksplice entry may look like the following:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: How it works…
  id: totrans-158
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Ksplice is a tool that allows Linux systems to stay current with security fixes
    and vital updates without requiring system reboots. This is especially beneficial
    for servers and settings that need to stay up and running with little downtime.
    It’s worth noting that while Ksplice can handle many patches, some changes may
    be too intricate to apply in a live environment and will require a traditional
    reboot-based update.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
- en: Installing and enabling Known Exploit Detection
  id: totrans-160
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One of the most critical things to do to secure your system (and, more importantly,
    the data in the system) is to implement the ability to detect when the bad guys
    are trying to break in. Ksplice has a unique feature called **Known Exploit Detection**
    (**KED**) that will report on known attacks against the kernel. Normally, only
    exploits that allow the hacker to access additional privileges are instrumented
    for KED and, for these to trigger, the kernel should already have been spliced
    for the vulnerability.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  id: totrans-162
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To do this, you will need a test system running Oracle Linux 8, with Ksplice
    set up.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  id: totrans-164
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This is done via tripwire code, which is triggered when specific events are
    detected. Normally, only events that enable the attacker to gain privileged access
    are monitored. This package is available on both x86 and ARM systems.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
- en: 'To enable this, the pack must first be installed by using the following command:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Regardless of whether the installation is on an ARM or x64 server, the installation
    is almost identical, with the major differences being more about the software
    already installed on each system. This brings a point to mind: regardless of whether
    ARM or x64, the admin tasks are the same.'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
- en: When KED is installed, `postfix` is also installed to enable sending emails
    as part of the notification system.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
- en: 'The output from installing this on an ARM-based system is shown in the following
    screenshot:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.16 – KED installation on ARM](img/B18349_07_16.jpg)'
  id: totrans-172
  prefs: []
  type: TYPE_IMG
- en: Figure 7.16 – KED installation on ARM
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
- en: 'The output from installing this on an x86_64-based system is shown in the following
    screenshot:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.17 – KED installation on x64](img/B18349_07_17.jpg)'
  id: totrans-175
  prefs: []
  type: TYPE_IMG
- en: Figure 7.17 – KED installation on x64
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
- en: 'Once KED is installed, the feature needs to be enabled. This is done by adding
    the following lines to `/``etc/uptrack/uptrack.conf`:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Next, you will need to Ksplice the kernel to enable the feature in the running
    kernel:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The output for this is shown in the following screenshot:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.18 – Enabling KED in a running kernel](img/B18349_07_18.jpg)'
  id: totrans-182
  prefs: []
  type: TYPE_IMG
- en: Figure 7.18 – Enabling KED in a running kernel
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
- en: As a note, if no Ksplice patches are available, you will get a notification
    that the kernel is up to date, as shown in the preceding screenshot. But if the
    system requires patches, Ksplice will patch the kernel at this time while enabling
    KED.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
- en: 'To verify that KED is enabled, `cat /proc/sys/kernel/known_exploit_detection`
    and look for an output of `1`. If the file is missing or there is a zero there,
    KED is not enabled so won’t be monitoring your system:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.19 – Checking whether KED is enabled](img/B18349_07_19.jpg)'
  id: totrans-186
  prefs: []
  type: TYPE_IMG
- en: Figure 7.19 – Checking whether KED is enabled
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
- en: 'Notifications from KED are controlled from the `/etc/log-known-exploit.conf`
    configuration file. A sample configuration file is shown in the following screenshot:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.20 – KED notifications configuration](img/B18349_07_20.jpg)'
  id: totrans-189
  prefs: []
  type: TYPE_IMG
- en: Figure 7.20 – KED notifications configuration
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
- en: 'In the config file, you can control the following actions:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
- en: '`[syslog]`: Most admins log events to syslog for capture and analysis using
    log analytics tools such as OCI Log Analytics or Splunk. The `enabled: 0` setting
    will disable logging to syslog.'
  id: totrans-192
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`[email]`: This section allows you to enable emails to be sent when a tripwire
    is triggered. Add email addresses for recipients as needed. This will also require
    that the system can send emails, either through a cloud service such as the OCI
    Email Delivery Service or your own **Simple Mail Transport Protocol** (**SMTP**)
    relay.'
  id: totrans-193
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`[actions]`: You can specifically disable notifications for a specific CVE.
    This is helpful if you have an accidental false positive on a system. To disable
    a CVE, add a line with the CVE and `ignore`. The `default:` parameter sets the
    default behavior for all CVE.'
  id: totrans-194
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
- en: If you enable email notification, make sure your email subsystem is configured
    before enabling emails from KED.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
- en: 'You can also test the system with the `log-known-exploit` command. This will
    log a test message in the kernel:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'The test event will look like the following in `/var/log/messages`:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: In the log, you will see the time, the CVE that was triggered, and also the
    **Process ID** (**PID**) and **User ID** (**UID**) of the process and user that
    triggered the event.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
- en: How it works…
  id: totrans-202
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Ksplice installs a piece of tripwire code in the kernel for specific exploits,
    detecting when something tries to exploit the exploit. These triggers then kick
    off the notification subsystem, letting you know when an attack happens.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
