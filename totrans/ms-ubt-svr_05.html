<html><head></head><body>
<div id="sbo-rt-content"><div class="Basic-Text-Frame" id="_idContainer081">
<h1 class="chapterNumber">5</h1>
<h1 class="chapterTitle" id="_idParaDest-82">Managing Files and Directories</h1>
<p class="normal">In <em class="chapterRef">Chapter 4</em>, <em class="italic">Navigating and Essential Commands</em>, we started looking deeper into Linux commands. We went over the most essential commands and covered the filesystem layout, as well as various methods to view the contents of files. In this chapter (as well as the next), we’ll continue to expand on the command line and become more efficient while using the terminal. This time around, we’ll expand a bit further on file management, take a look at input/output streams, and we’ll also develop an understanding of symbolic links. Along the way, we will cover:</p>
<ul>
<li class="bulletList">Copying, moving, and renaming files and directories</li>
<li class="bulletList">Editing files with the Nano and Vim text editors</li>
<li class="bulletList">Input and output streams</li>
<li class="bulletList">Using symbolic and hard links</li>
</ul>
<p class="normal">Let’s begin the chapter by taking a look at some methods we can use to alter the files and directories in the filesystem, such as copying and moving them.</p>
<h1 class="heading-1" id="_idParaDest-83">Copying, moving, and renaming files and directories</h1>
<p class="normal">At this point, you<a id="_idIndexMarker242"/> should<a id="_idIndexMarker243"/> know how<a id="_idIndexMarker244"/> to move<a id="_idIndexMarker245"/> around <a id="_idIndexMarker246"/>within the<a id="_idIndexMarker247"/> filesystem (commands such as <code class="inlineCode">cd</code>), inspect the contents of directories (<code class="inlineCode">ls</code>), and even how to create empty files (the <code class="inlineCode">touch</code> command). We even know how to remove files as well, such as executing the <code class="inlineCode">rm</code> command against a file or directory. But until now, we haven’t looked at moving files around within your Ubuntu filesystem.</p>
<p class="normal">First, to make a copy of a file or directory, we use the <code class="inlineCode">cp</code> command. Copying a file is fairly easy, and such a command would look similar to the following:</p>
<pre class="programlisting con"><code class="hljs-con">cp file1 file2
</code></pre>
<p class="normal">In that example, <code class="inlineCode">file2</code> is created as an exact copy of <code class="inlineCode">file1</code>. Copying a file is useful in many situations, some of the most common of which are:</p>
<ul>
<li class="bulletList">Copying a file to a backup medium, such as an external drive or network share</li>
<li class="bulletList">Creating a copy of a file before making a change, such as before editing a very important text file</li>
<li class="bulletList">Duplicating a log file for a point-in-time analysis</li>
</ul>
<p class="normal">Let’s look at the last bullet point as another good example. We can capture a copy of the system log<a id="_idIndexMarker248"/> and<a id="_idIndexMarker249"/> store it in our current working directory <a id="_idIndexMarker250"/>by<a id="_idIndexMarker251"/> executing <a id="_idIndexMarker252"/>the<a id="_idIndexMarker253"/> following command:</p>
<pre class="programlisting con"><code class="hljs-con">sudo cp /var/log/syslog /home/&lt;username&gt;/syslog
</code></pre>
<p class="normal">The <code class="inlineCode">cp</code> command is fairly simple: we give it a path to a file to copy, and then we type the path to the destination and desired filename. We also use <code class="inlineCode">sudo</code> due to the fact that the <code class="inlineCode">syslog</code> may not be readable by normal users by default, depending on the configuration. In the case of this command, a copy of the original <code class="inlineCode">syslog</code> file will be saved in your current working directory.</p>
<p class="normal">For this particular example, log files are constantly being written to. It can sometimes be hard to troubleshoot an issue that occurred during a certain time if the file is continually expanding. That’s not the only reason though. We certainly wouldn’t want to make an accidental change to the log file and risk contaminating it or losing important information.</p>
<p class="normal">The previous command can actually be simplified a bit:</p>
<pre class="programlisting con"><code class="hljs-con">sudo cp /var/log/syslog .
</code></pre>
<p class="normal">In that example, we removed the target path and name and replaced it with a period. The reason this works is that the period represents our current working directory. This isn’t specific to the <code class="inlineCode">cp</code> command either. There actually is a directory named with a period in every directory, which is essentially a pointer to the current directory. Therefore, if you’re already inside the directory you want the file to be copied to, you don’t have to type the path. You don’t have to type the name either if you want the name of the file to be the same as the source.</p>
<p class="normal">Copying files (as well as moving them, which we’ll look at next) is potentially destructive. If the target path and name already exist, then the target will be overwritten. By default, you won’t see a confirmation before the target file is overwritten. As with all commands, take care that you really want to do whatever it is you’re telling the command-line interpreter to do.</p>
<p class="normal">When it comes to copying directories, the <code class="inlineCode">cp</code> command by itself won’t do the trick:</p>
<pre class="programlisting con"><code class="hljs-con">sudo cp /var/log/apt .
</code></pre>
<p class="normal">The <code class="inlineCode">/var/log/apt</code> directory contains log files that keep track of transactions performed with the <code class="inlineCode">apt</code> command. It<a id="_idIndexMarker254"/> can be useful to keep an eye on what your<a id="_idIndexMarker255"/> other <a id="_idIndexMarker256"/>admins<a id="_idIndexMarker257"/> are installing. When <a id="_idIndexMarker258"/>it<a id="_idIndexMarker259"/> comes to this example though, the previous command will fail with the following error:</p>
<pre class="programlisting con"><code class="hljs-con">cp: -r not specified; omitting directory '/var/log/apt'
</code></pre>
<p class="normal">The error literally tells you what to do about it, and essentially the error is telling you that directories are omitted by default. In order to copy directories, you’ll need to include the <code class="inlineCode">-r</code> option. This stands for <em class="italic">recursive</em>, which is an option you’ll see as a possibility for a handful of Linux commands. It tells the command-line interpreter to not only grab the object at the path you specified but to do so recursively and include child objects as well. Therefore, the following command will work:</p>
<pre class="programlisting con"><code class="hljs-con">sudo cp -r /var/log/apt .
</code></pre>
<p class="normal">With that command, a local copy of the <code class="inlineCode">/var/log/apt</code> directory will be stored in your current working directory, along with the contents.</p>
<p class="normal">When it comes to moving a file or directory from one place to another, we use the <code class="inlineCode">mv</code> command. The syntax is almost exactly the same as the <code class="inlineCode">cp</code> command. The difference is that instead of copying a file or directory, we’re moving it. In that regard, it’s probably self-explanatory how it works. Consider the following example commands:</p>
<pre class="programlisting con"><code class="hljs-con">mv file1 /path/to/new/directory/file1
mv file1 file2
</code></pre>
<p class="normal">With the first example, we’re assuming that <code class="inlineCode">file1</code> is in our current working directory. We’re grabbing that file and moving it to <code class="inlineCode">/path/to/new/directory</code> and giving it the same name of <code class="inlineCode">file1</code> in that new directory. Just like with the <code class="inlineCode">cp</code> command, we could’ve omitted the filename at the target, since it’s staying the same. If the file already exists in the target directory with that name, it will be overwritten. So, the <code class="inlineCode">mv</code> command is also potentially destructive, but more so when compared to <code class="inlineCode">cp</code> since you are moving, instead of copying.</p>
<p class="normal">The second <code class="inlineCode">mv</code> command is a bit more interesting, because in that example we’re renaming a file. In Linux, there’s no dedicated rename command, so the <code class="inlineCode">mv</code> command is used for that purpose. In fact, <code class="inlineCode">mv</code> is somewhat of a Swiss Army knife due to the fact it serves multiple purposes. With it, you can move a file or directory, rename it, and also move a file to overwrite another file in a different location. It all depends on the source and destination paths. If the target exists, it will be overwritten. If not, the file will be renamed and/or moved to that path.</p>
<p class="normal">When managing files, you’ll certainly come to a situation where you need to manage multiple files or directories. It’s worth noting that the <code class="inlineCode">cp</code> command, as well as the <code class="inlineCode">mv</code> command, can be used with multiple objects at once; for example, if you have three directories, such as <code class="inlineCode">dir1</code>, <code class="inlineCode">dir2</code>, and <code class="inlineCode">dir3</code>, and you need to move them into a new sub-directory. You could execute three <code class="inlineCode">mv</code> commands to move each one separately, but you can also move all three with a single <code class="inlineCode">mv</code> command:</p>
<pre class="programlisting con"><code class="hljs-con">mv dir1 dir2 dir3 /path/to/new/location
</code></pre>
<p class="normal">The same holds true with <code class="inlineCode">cp</code> and with files; both <code class="inlineCode">cp</code> and <code class="inlineCode">mv</code> are set up to allow you to move or copy multiple directories or files with a single command.</p>
<p class="normal">Now that<a id="_idIndexMarker260"/> we <a id="_idIndexMarker261"/>know <a id="_idIndexMarker262"/>how <a id="_idIndexMarker263"/>to move <a id="_idIndexMarker264"/>files around, we should also<a id="_idIndexMarker265"/> take a look at how to edit them. There are many text editors available to us on the Ubuntu platform, with Nano and Vim being among the most common. In the next section, we’ll go over the basics of both.</p>
<h1 class="heading-1" id="_idParaDest-84">Editing files with the Nano and Vim text editors</h1>
<p class="normal">Now that <a id="_idIndexMarker266"/>we<a id="_idIndexMarker267"/> know <a id="_idIndexMarker268"/>how<a id="_idIndexMarker269"/> to copy and move files, it would be useful to know how to edit them. There are multiple forms of text editors for Ubuntu, some available in the command line, and others in graphical environments such as the text editor in the desktop version.</p>
<p class="normal">Some may feel that command-line text editors are more complicated than <strong class="keyWord">Graphical User Interface</strong> (<strong class="keyWord">GUI</strong>) editors (and<a id="_idIndexMarker270"/> to be honest, they can be), but the main benefit is that you can use the same editor regardless of whether or not you have a GUI. In a way, this means the non-graphical editors are a bit more portable, and you can rely on them more. Almost all installations of Ubuntu will include the <code class="inlineCode">nano</code> text editor, and you can rely on that more often than something like a particular GUI editor being available. In addition, the <code class="inlineCode">vim</code> editor is another popular consideration. It’s a bit more advanced than <code class="inlineCode">nano</code>, but in my opinion, much <a id="_idIndexMarker271"/>more powerful. In<a id="_idIndexMarker272"/> the <a id="_idIndexMarker273"/>following <a id="_idIndexMarker274"/>sections, we’ll look at both <code class="inlineCode">nano</code> and <code class="inlineCode">vim</code>.</p>
<h2 class="heading-2" id="_idParaDest-85">Editing with Nano</h2>
<p class="normal">The <code class="inlineCode">nano</code> editor, while<a id="_idIndexMarker275"/> more basic in terms of features, still has a fairly strong following. Actually, if you haven’t already noticed, a person’s choice of editor can cause somewhat of a debate in the Linux community. To launch the <code class="inlineCode">nano</code> editor, it’s as simple as running the <code class="inlineCode">nano</code> command. If you don’t provide <code class="inlineCode">nano</code> with a filename, it simply starts with an empty window, as shown in the following screenshot:</p>
<figure class="mediaobject"><img alt="" height="521" src="../Images/B18425_05_01.png" width="873"/></figure>
<p class="packt_figref">Figure 5.1: The nano text editor, with no file selected</p>
<p class="normal">You can start typing right away, and when you want to save the file, you can simply press <em class="keystroke">Ctrl + o </em>to do so. On<a id="_idIndexMarker276"/> the bottom of the <code class="inlineCode">nano</code> screen, you’ll see an overview of shortcuts, including the method for saving the file I just mentioned (which it refers to as <strong class="screenText">Write Out</strong>). As you can see then<em class="keystroke">, Ctrl + x</em> is how you exit the editor and go back to the command line.</p>
<p class="normal">One trick that I love (which also works well with <code class="inlineCode">vim</code>) is pressing <em class="keystroke">t </em>and then <em class="keystroke">z</em> while holding <em class="keystroke">Ctrl</em> when you have <code class="inlineCode">nano</code> open, which will make it disappear. Normally, you don’t have to press <em class="keystroke">Ctrl</em> and <em class="keystroke">t</em> in order to background a process, but <code class="inlineCode">nano</code> is the exception in this case.</p>
<p class="normal">Effectively, it’s the same as minimizing it. You can bring the <code class="inlineCode">nano</code> window back by executing <code class="inlineCode">fg</code>, which is short for <em class="italic">foreground</em>. The ability to background and foreground an application in the terminal is part of process management, which is actually something we’ll talk about in <em class="chapterRef">Chapter 7</em>, <em class="italic">Controlling and Managing Processes</em>, but we’re giving you this tip ahead of time, to help you on your way! When it comes to editing files, sometimes it makes sense to send the editor to the background and bring it back later.</p>
<p class="normal">As you can probably guess, you can also use the <code class="inlineCode">nano</code> command, with a target path and filename, to have the editor come up with a file already open. For example:</p>
<pre class="programlisting con"><code class="hljs-con">sudo nano /var/log/syslog
</code></pre>
<p class="normal">This command will result in the file opening in <code class="inlineCode">nano</code>:</p>
<figure class="mediaobject"><img alt="" height="483" src="../Images/B18425_05_02.png" width="882"/></figure>
<p class="packt_figref">Figure 5.2: The nano text editor, with the syslog file open</p>
<p class="normal">To be fair, editing a <a id="_idIndexMarker277"/>log file directly is probably not a good idea in practice, but the example works. The syslog is a file you may want to open and inspect, but it would be a good idea to check the size of the syslog file with the <code class="inlineCode">ls -lh /var/log/syslog</code> command to make sure it’s not excessively large in size, which can slow down the server.</p>
<p class="normal">All of that aside, the takeaway here is that you can open a file with <code class="inlineCode">nano</code> directly by simply providing it with a path to something. Inside the editor window, you can move around with the arrow keys, just like you would in a graphical editor. You can also search for a specific string of text, by pressing <em class="keystroke">Ctrl + w</em> for <strong class="screenText">Where Is</strong>, as is mentioned in the list of actions near the bottom.</p>
<p class="normal">In addition, note the text in the screenshot that is highlighted in red. It’s simply telling us that we don’t have access to edit the file. In that example, I didn’t use <code class="inlineCode">sudo</code> because I didn’t intend on making any changes to the file. </p>
<p class="normal">Sometimes, I’ll open files in an editor that I don’t have write permission to make changes to, which serves as a fail-safe in case I accidentally do make a change (I won’t be able to save the file without <code class="inlineCode">sudo</code>). To make a real change, I can close the file and reopen it with <code class="inlineCode">sudo</code>.</p>
<p class="normal">Anyway, the <code class="inlineCode">nano</code> editor is fairly simplistic. Is there more to it than that? Sure, but the most important thing to know is how to open files, edit them, and save them, which we’ve covered in this section. Of course, you can practice with the actions that are presented to you at the <a id="_idIndexMarker278"/>bottom of the window to go beyond normal usage.</p>
<p class="normal">Now, let’s take a look at Vim.</p>
<h2 class="heading-2" id="_idParaDest-86">Editing with Vim</h2>
<p class="normal">Vim is my favorite <a id="_idIndexMarker279"/>editor, and the one I use most often. It’s a little on the advanced side, but it’s not to the point where it’s frustrating. By default, it’s not actually installed. Personally, I prefer the <code class="inlineCode">vim-nox</code> package, which can be installed by executing the following command:</p>
<pre class="programlisting con"><code class="hljs-con">sudo apt install vim-nox
</code></pre>
<p class="normal">It really doesn’t matter which of the variations of <code class="inlineCode">vim</code> you install. Each variation adds its own features. In the case of <code class="inlineCode">vim-nox</code>, it has built-in support for scripting languages but is not really all that different from standard <code class="inlineCode">vim</code> in other regards. The concepts you’ll learn here are not specific to this version. Just like <code class="inlineCode">nano</code>, the <code class="inlineCode">vim</code> editor can be called by itself by entering the command <code class="inlineCode">vim</code> with no options, or with a path to a file, such as <code class="inlineCode">vim /home/myuser/myfile.txt</code>. With no file chosen, <code class="inlineCode">vim</code> will display its default help text. It gives you some of the default commands, such as <code class="inlineCode">:q</code> for quitting the editor:</p>
<figure class="mediaobject"><img alt="" height="521" src="../Images/B18425_05_03.png" width="876"/></figure>
<p class="packt_figref">Figure 5.3: The vim text editor, with no file open</p>
<p class="normal">When you start <code class="inlineCode">vim</code>, you start in <em class="italic">command mode</em>, which is one of several different modes the editor<a id="_idIndexMarker280"/> can be in. In command mode, you can’t actually edit text. Command mode allows you to run commands, as the name implies, which can allow you to manipulate text in really neat ways.</p>
<div class="note">
<p class="normal">If you want to edit a file as you were already doing in <code class="inlineCode">nano</code>, you’ll need to switch to <em class="italic">insert mode</em> to do so. You can switch to insert mode by pressing the <em class="keystroke">Insert</em> key on your keyboard, or the <em class="keystroke">i</em> letter key. Once you’re in insert mode, you can start typing as you normally would in any other editor. You’ll move the cursor around with the arrow keys, and insert text wherever you want. Outside of insert mode, you can also navigate with the <em class="keystroke">h</em>, <em class="keystroke">j</em>, <em class="keystroke">k</em>, and <em class="keystroke">l</em> keys in place of the arrow keys (which some users actually prefer). To exit insert mode, you can press <em class="keystroke">Esc</em>. That will bring you back to command mode.</p>
</div>
<p class="normal">At first, the different modes of <code class="inlineCode">vim</code> can be a bit confusing to newcomers. For me, I see it as somewhat of a superpower. With <code class="inlineCode">vim</code>, you have a mode for editing text and another dedicated mode for manipulating it. When it comes to text manipulation, that’s one of the strongest features of <code class="inlineCode">vim</code>. For an example of this, consider the following hypothetical file:</p>
<figure class="mediaobject"><img alt="" height="527" src="../Images/B18425_05_04.png" width="880"/></figure>
<p class="packt_figref">Figure 5.4: The vim text editor, with a sample file</p>
<p class="normal">I don’t know why, but <a id="_idIndexMarker281"/>something about that file seems off to me. We’ll need to make a very important correction to try to fix it. First, you can see from the screenshot that the editor was left in insert mode. To do some text manipulation, we first need to press<em class="keystroke"> Esc</em> to go back to command mode. Once there, we can get ready to type a command. And the command we want to type is this one:</p>
<pre class="programlisting con"><code class="hljs-con">:%s/Windows/Linux/g
</code></pre>
<p class="normal">I don’t know about you, but personally, I think the file looks better now after running that command:</p>
<figure class="mediaobject"><img alt="" height="523" src="../Images/B18425_05_05.png" width="880"/></figure>
<p class="packt_figref">Figure 5.5: The vim text editor, after running a sample command</p>
<p class="normal">Technically, Linux is<a id="_idIndexMarker282"/> a kernel and not an operating system. Ubuntu, a distribution of Linux, is the closest equivalent of an operating system for us. But I’m willing to let that slide, for now. Other than that, in my opinion, this version of the file is more accurate!</p>
<p class="normal">This was a more advanced example of <code class="inlineCode">vim</code> usage that would normally be outside the scope of this book. I wanted to show you an example of the power of this amazing editor, and finding and replacing text is just one of the many things we can do with it. Some people (including <a id="_idIndexMarker283"/>myself) even go as far as to install plugins to essentially turn <code class="inlineCode">vim</code> into an <strong class="keyWord">Integrated Development Environment</strong> (<strong class="keyWord">IDE</strong>). In the example we’ve just used, we were able to find and replace all occurrences of a string with another string. This was also an example of the types of tasks we carry out in command mode, which allows us to manipulate text and enter more advanced commands. With this admittedly contrived example, you can immediately see the value of having multiple modes in <code class="inlineCode">vim</code>.</p>
<p class="normal">I’ve been using <code class="inlineCode">vim</code> for about a decade or so because I can never seem to figure out how to exit it. Okay, to be fair, that joke is getting to be a bit old now. If you’ve already been using Ubuntu or any other Linux distribution for a while, that joke probably made you cringe a little. If that was the first time you’ve seen it, then I’m glad I was the one that introduced you to it—for some reason, <code class="inlineCode">vim</code> has a reputation for being difficult to exit. But that’s not really true at all, it’s actually quite easy. In command mode, you simply enter <code class="inlineCode">:q</code> to exit the editor:</p>
<pre class="programlisting con"><code class="hljs-con">:q
</code></pre>
<p class="normal">If you’ve made changes, the <code class="inlineCode">:q</code> command won’t let you exit, but you can force exit if you add an exclamation mark, so the command becomes <code class="inlineCode">:q!</code>. If you’d also like to save changes while exiting, add <code class="inlineCode">w</code>, so the command inside <code class="inlineCode">vim</code> would become:</p>
<pre class="programlisting con"><code class="hljs-con">:wq
</code></pre>
<p class="normal">Essentially, we’re exiting the editor (<code class="inlineCode">q</code>) and writing the file at the same time (<code class="inlineCode">w</code>). In command mode, commands start with a colon (<code class="inlineCode">:</code>) and then the actual command. There are so many commands available that it’s impossible to talk about them all in one chapter. What I’ll do, then, is<a id="_idIndexMarker284"/> mention some that I consider to be the most important.</p>
<p class="normal">First, it’s actually possible to run a shell command without leaving <code class="inlineCode">vim</code> by using the following command:</p>
<pre class="programlisting con"><code class="hljs-con">:! &lt;shell command&gt;
</code></pre>
<p class="normal">The exclamation mark allows you to run a command, and then you type the actual command. For example:</p>
<pre class="programlisting con"><code class="hljs-con">:! ls -l /var/log
</code></pre>
<p class="normal">The previous example will show you the contents of the <code class="inlineCode">/var/log</code> directory, and then you can press <em class="keystroke">Enter</em> to return back to <code class="inlineCode">vim</code>. The <code class="inlineCode">:sp</code> command is short for <em class="italic">split</em>:</p>
<pre class="programlisting con"><code class="hljs-con">:sp /path/to/file
</code></pre>
<p class="normal">In this case, <code class="inlineCode">vim</code> is able to show you more than one file at a time in the same window, effectively splitting the window to show you both files. With <code class="inlineCode">:split</code>, or <code class="inlineCode">:sp</code> for short (both do the same thing), it will either split the file into two views (the same file open in each) or it will show a separate file in the other split if you give it a filename. This command will split the file horizontally:</p>
<figure class="mediaobject"><img alt="" height="448" src="../Images/B18425_05_06.png" width="877"/></figure>
<p class="packt_figref">Figure 5.6: The vim text editor, with two files open in the same window</p>
<p class="normal">The previous <a id="_idIndexMarker285"/>screenshot shows two files open, <code class="inlineCode">/var/log/apt/history.log</code> and <code class="inlineCode">/var/log/syslog</code>. You may also notice that the status bar for each file, at the bottom, shows <code class="inlineCode">RO</code>. As you can probably guess, this stands for <em class="italic">read only</em> and displays on the screen because I’m viewing files that only <code class="inlineCode">root</code> has access to change, and I didn’t use <code class="inlineCode">sudo</code>.</p>
<p class="normal">To switch between the two files, we can press the <em class="keystroke">w</em> key twice while holding <em class="keystroke">Ctrl</em>. When we do that, our insertion point moves from one split to the other. To exit each individual buffer (or the editor itself, if we only have one file open), we can press <em class="keystroke">Esc</em> to return to command mode, and then enter the <code class="inlineCode">:q</code> or <code class="inlineCode">:q!</code> command to exit without saving changes, or <code class="inlineCode">:wq</code> to exit while also saving changes, just like before.</p>
<p class="normal">An alternative to <code class="inlineCode">:split</code> is <code class="inlineCode">:vsplit</code>, or <code class="inlineCode">:vs</code> for short. It does the same thing as <code class="inlineCode">:split</code>, but it splits the window vertically. Considering most computer displays nowadays are widescreen (and even ultra-widescreen), a vertical split often works out better in a practical sense:</p>
<figure class="mediaobject"><img alt="" height="480" src="../Images/B18425_05_07.png" width="880"/></figure>
<p class="packt_figref">Figure 5.7: The vim text editor, with two files open in a vertical split</p>
<p class="normal">To be honest, the effect doesn’t look all that great in the previous screenshot, the reason being the width of a page in a book isn’t enough to really show the benefit. Go ahead and give it a <a id="_idIndexMarker286"/>shot and see for yourself.</p>
<p class="normal">So far, we’ve gone over two modes of <code class="inlineCode">vim</code>—command and insert mode. But there’s also another commonly used mode we haven’t discussed yet—<em class="italic">visual mode</em>. Visual mode allows you to select text, which then allows you to perform tasks such as copy and paste.</p>
<p class="normal">To do so, make sure you’re in command mode, and then start by moving the cursor to the first character in a series of text you want to copy. Then, press the <em class="keystroke">v </em>letter key on your keyboard, and move the selection with your arrow keys. </p>
<p class="normal">You’ll notice that you’ll highlight more text as you move the cursor. Once you’ve selected all the text that you’d like to copy, press the<em class="keystroke"> y</em> key and the highlight will go away. At this point, you’ve essentially copied the text you had highlighted into the <code class="inlineCode">vim</code> equivalent of the clipboard, similar to desktop operating systems. You can then (while also in command mode) press the <em class="keystroke">p</em> key to paste the text wherever the cursor is. It may take a few tries to get a hang of the workflow, but go ahead and give it a shot. If you make a mistake, you can press <em class="keystroke">u</em> while in command mode to <em class="italic">undo</em>, so you can revert any changes you make.</p>
<p class="normal">Again, <code class="inlineCode">vim</code> is a somewhat advanced editor. Learning the basic functions is fairly easy, so knowing how to open, edit, close, and save files is something you can learn fairly quickly. The feature set of <code class="inlineCode">vim</code> is so vast that I’m still learning new tricks many years after I started using it. To make sure you understand the basics though, let’s summarize the basic workflow of <code class="inlineCode">vim</code> to help you memorize it. It looks something like this:</p>
<ol class="numberedList" style="list-style-type: decimal;">
<li class="numberedList" value="1">Open Vim by either typing <code class="inlineCode">vim</code> by itself, or with a filename: <code class="inlineCode">vim &lt;filename&gt;</code>.</li>
<li class="numberedList">You start in <em class="italic">command mode</em>. This mode is great for running <code class="inlineCode">vim</code> commands. Press the<em class="keystroke"> Insert</em> or the <em class="keystroke">i</em> key to switch to <em class="italic">insert mode</em>.</li>
<li class="numberedList">While in insert mode, you can edit the text by typing with your keyboard and moving the cursor around with the arrow keys.</li>
<li class="numberedList">When you’re done editing the file, press <em class="keystroke">Esc</em> to return to command mode.</li>
<li class="numberedList">To exit without saving changes, enter the <code class="inlineCode">:q</code> or <code class="inlineCode">:q!</code> command. If you do want to save changes, enter <code class="inlineCode">:w</code> by itself to save and remain in the editor, or <code class="inlineCode">:wq</code> to save and quit <code class="inlineCode">vim</code> at the same time.</li>
</ol>
<p class="normal">Entire books could <a id="_idIndexMarker287"/>be written about <code class="inlineCode">vim</code> (and there have been), so it would be outside the scope of this book to go into exhaustive detail. In fact, I even have a dedicated video tutorial series about it at <a href="http://www.learnlinux.tv"><span class="url">www.learnlinux.tv</span></a> if you’re interested in learning more. But for now, I’ll leave you with a few more useful tips that I think you should know.</p>
<p class="normal">While in command mode, you can press the <em class="keystroke">x</em> key to delete a single character, wherever the cursor is. You can press the <em class="keystroke">d</em> letter key <em class="italic">twice</em> in succession to delete an entire line. When you do this, that line is also copied into the paste buffer; you can paste that line by pressing <em class="keystroke">p</em>.</p>
<p class="normal">In addition, I mentioned several times that you can switch to insert mode by pressing <em class="keystroke">i</em> or <em class="keystroke">Insert</em>. You can also do so by pressing the <em class="keystroke">a</em> letter key with or without holding <em class="keystroke">Shift</em>. If you don’t hold <em class="keystroke">Shift</em>, you’ll enter insert mode one character to the right. This isn’t very useful to me, but typing a capital <em class="keystroke">A</em> is something I find myself doing a lot, which enters you into insert mode while also taking you to the very end of the current line. Since I often want to start typing after the end of a sentence, this works well for me.</p>
<p class="normal">Also, while in command mode, you can type <em class="keystroke">Shift + g</em> to immediately go to the very end of the file. Alternatively, you can press the <em class="keystroke">g</em> key <em class="italic">twice</em> in succession to move to the very top of the file.</p>
<p class="normal">Another trick I like is to turn on line numbers. This is useful, especially if an error message in a log file is complaining about a file regarding a specific line. The following command turns on line numbers:</p>
<pre class="programlisting con"><code class="hljs-con">:set number
</code></pre>
<p class="normal">The following command disables line numbers:</p>
<pre class="programlisting con"><code class="hljs-con">:set nonumber
</code></pre>
<p class="normal">If you’d always like to see line numbers by default, you can edit the <code class="inlineCode">.vimrc</code> file inside your home directory. This file is read by <code class="inlineCode">vim</code> each time you start it.</p>
<p class="normal">Note that the <code class="inlineCode">.vimrc</code> file begins with a period, which means that the file is hidden. Hidden files aren’t normally shown to you when you use <code class="inlineCode">ls</code> to list the contents of a directory. Using the <code class="inlineCode">-a</code> option with the <code class="inlineCode">ls</code> command will show all files, including the ones that are normally hidden.</p>
<p class="normal">Go ahead and open the <code class="inlineCode">.vimrc</code> file in your editor:</p>
<pre class="programlisting con"><code class="hljs-con">vim ~/.vimrc
</code></pre>
<p class="normal">Most likely, this will be a blank file for you as a <code class="inlineCode">.vimrc</code> file doesn’t exist by default. There are many<a id="_idIndexMarker288"/> commands we can add to tweak the behavior of the <code class="inlineCode">vim</code> editor, too many to mention in a single chapter. The following line is very useful though, as it ensures that line numbers are enabled by default:</p>
<pre class="programlisting con"><code class="hljs-con">set number
</code></pre>
<p class="normal">Leaving out the colon at the beginning of the line is intentional; it’s not required inside the <code class="inlineCode">.vimrc</code> file. From this point forward, each new <code class="inlineCode">vim</code> session you open will start off with line numbers enabled. You can still disable line numbers as needed with the <code class="inlineCode">:set nonumber</code> command within <code class="inlineCode">vim</code> as we did earlier. In addition, you can add many more customizations to <code class="inlineCode">vim</code> with the <code class="inlineCode">.vimrc</code> file, but there are simply too many possibilities to mention here. For now, just know that customizing <code class="inlineCode">vim</code> with the config file is something that you can do.</p>
<p class="normal">Now that we know how to edit files, we should also take a closer look at streams, which allow us to manipulate both input and output in various ways.</p>
<h1 class="heading-1" id="_idParaDest-87">Input and output streams</h1>
<p class="normal">During our<a id="_idIndexMarker289"/> journey into <a id="_idIndexMarker290"/>Ubuntu Server so far, we’ve worked quite a bit within the terminal. We’ve been able to inspect the contents of files, insert text into files, and more. We’ve actually been <a id="_idIndexMarker291"/>working with <strong class="keyWord">streams</strong> the entire time without knowing it. In this section, we’re going to talk about this subject in more detail.</p>
<p class="normal">If you’ve studied computer science at all, then you probably already know that <em class="italic">output</em> refers to things that are printed out of the computer (for example, text being printed to the screen, or onto paper from a printer) and <em class="italic">input</em> refers to data that is being entered into a computer, whether that be on the command line, into a file, or similar.</p>
<p class="normal">Linux takes this concept a bit further. Streams in Linux refer to a special way to handle what’s going in or out, and beyond the input and output streams, we also have a third that refers to errors.</p>
<p class="normal">Output streams in Linux are referred<a id="_idIndexMarker292"/> to as <strong class="keyWord">Standard Output</strong>, and input streams are referred <a id="_idIndexMarker293"/>to as <strong class="keyWord">Standard Input</strong>. These are abbreviated <a id="_idIndexMarker294"/>as <strong class="keyWord">stdout</strong> and <strong class="keyWord">stdin</strong>, respectively. The <a id="_idIndexMarker295"/>reason for the expansion of the simple concept of input/output into a concept of its own is because, on the Linux shell, we can handle these streams differently and perform different tasks with them.</p>
<p class="normal">We’ve been working with standard output throughout the entire book so far. Everything that is printed to the terminal is standard output. For example, when you ran the <code class="inlineCode">sudo apt install vim-nox</code> command earlier, the results of that command (the flood of text showing the status of the package installation as it occurred) was standard output. When you use the <code class="inlineCode">cat /var/log/syslog</code> command to have the contents of <code class="inlineCode">/var/log/syslog</code> dumped onto the screen, the contents being displayed are standard output. By far, standard output is something you’ll work with the most.</p>
<p class="normal">To understand the concept of standard output better, let’s take a look at redirection. The following command is an example:</p>
<pre class="programlisting con"><code class="hljs-con">cat /var/log/syslog &gt; ~/logfile.txt
</code></pre>
<p class="normal">With that command, we’re using <code class="inlineCode">cat</code> to display the contents of <code class="inlineCode">/var/log/syslog</code>. But instead of simply showing the contents onscreen we use the <code class="inlineCode">&gt;</code> character to redirect standard output into a file, <code class="inlineCode">~/logfile.txt</code>. This means that standard output (showing the contents of the file) will not be shown at all, since we redirected that into a file. Similarly, we could have also run:</p>
<pre class="programlisting con"><code class="hljs-con">cat /var/log/syslog 1&gt; ~/logfile.txt
</code></pre>
<p class="normal">Notice that I added a <code class="inlineCode">1</code> right before the <em class="italic">greater-than</em> symbol. Standard output is designated by a file descriptor of 1. So, with that command, I’m specifically saying that I want to redirect standard output, and <em class="italic">only</em> standard output, into the file. Standard output is implied, so I didn’t need to include the <code class="inlineCode">1</code>. That’s why simply using the <em class="italic">greater-than</em> symbol works for redirecting standard output to a file.</p>
<p class="normal">If you want to append a file rather than completely overwrite it, you can use two <em class="italic">greater-than</em> symbols (<code class="inlineCode">&gt;&gt;</code>) to append, rather than overwrite. For example, the following command will add the contents of the <code class="inlineCode">syslog</code> file to the end of the <code class="inlineCode">logfile.txt</code> file, rather than overwrite the entire file:</p>
<pre class="programlisting con"><code class="hljs-con">cat /var/log/syslog &gt;&gt; ~/logfile.txt
</code></pre>
<p class="normal">Standard input also has a file descriptor, which is 0. Standard input is how commands receive data. Essentially, commands that accept input from the user do so by accepting <code class="inlineCode">stdin</code>. Standard<a id="_idIndexMarker296"/> input is a bit more challenging to show in an example, but the <a id="_idIndexMarker297"/>following works:</p>
<pre class="programlisting con"><code class="hljs-con">cat /var/log/syslog | grep -i &lt;keyword&gt;
</code></pre>
<p class="normal">With that command, I’m grabbing the contents of the <code class="inlineCode">/var/log/syslog</code> file and piping that into the <code class="inlineCode">grep</code> command, which allows me to display only the lines that include a specific term. No two <code class="inlineCode">syslog</code> files will be the same, since every server can be configured uniquely. But if you’re attempting to investigate a specific application or service, you can <code class="inlineCode">grep</code> the log for keywords you think might be appropriate. If you include the <code class="inlineCode">-i</code> option, then <code class="inlineCode">grep</code> will perform a search that’s case-insensitive. In this example, the output of the <code class="inlineCode">cat</code> command becomes standard input to the <code class="inlineCode">grep</code> command. This command can be executed with any search term of your choice.</p>
<p class="normal">I could have also run:</p>
<pre class="programlisting con"><code class="hljs-con">cat &lt; /var/log/syslog | grep Network
</code></pre>
<p class="normal">In that example, I’m using the <em class="italic">less-than</em> symbol to redirect the contents of <code class="inlineCode">/var/log/syslog</code> to be standard input to the <code class="inlineCode">cat</code> command. The <code class="inlineCode">cat</code> command normally prints whatever text is fed to it to the screen as standard output, but instead, I’m using the pipe symbol, <code class="inlineCode">|</code>, to grab that output and use it as standard input to the <code class="inlineCode">grep</code> command.</p>
<p class="normal">This concept can be a bit confusing at first, but if you keep practicing it, it will definitely make sense. Let’s look at another example, so we can understand standard error (<strong class="keyWord">stderr</strong>) as well:</p>
<pre class="programlisting con"><code class="hljs-con">find / -name "syslog"
</code></pre>
<p class="normal">The <code class="inlineCode">find</code> command allows you to find files that match particular criteria, such as looking for files that are named <code class="inlineCode">syslog</code> in this example. Here, we’re searching the entire filesystem, because we used <code class="inlineCode">/</code> to start the search from. The problem is I don’t have permission to read all the files on the filesystem, and I didn’t use <code class="inlineCode">sudo</code>. This is going to result in quite a few errors being printed to the screen, errors such as these:</p>
<pre class="programlisting con"><code class="hljs-con">find: '/var/lib/netdata/health': Permission denied
find: '/var/lib/netdata/registry': Permission denied
find: '/var/lib/netdata/cloud.d': Permission denied
find: '/var/lib/udisks2': Permission denied
</code></pre>
<p class="normal">Since the <code class="inlineCode">find</code> command was used to search the entire filesystem, including places I don’t have permission to look, our terminal will be flooded with errors. These errors are displayed using <a id="_idIndexMarker298"/>standard<a id="_idIndexMarker299"/> error, which has a file descriptor of 2. If we want to hide these errors, we can do this:</p>
<pre class="programlisting con"><code class="hljs-con">find / -name "syslog" 2&gt; /dev/null
</code></pre>
<p class="normal">With that command, no errors will show up when we run it. That’s because we instructed the interpreter to capture standard error and redirect it to <code class="inlineCode">/dev/null. /dev/null</code> is a special device where things disappear forever. If you move or redirect something there, it’s effectively deleted. Since a standard error has a file descriptor of 2, we combined that with the <em class="italic">greater-than</em> symbol to form <code class="inlineCode">2&gt;</code>, which basically instructs the shell to do a redirect, but to only redirect standard error and leave standard output alone. We can also choose to redirect more than one stream to different places within a single command:</p>
<pre class="programlisting con"><code class="hljs-con">find / -name "syslog" 1&gt; stdout.txt 2&gt; stderr.txt
</code></pre>
<p class="normal">With that variation, I’m redirecting successful output to <code class="inlineCode">stdout.txt</code>, and the errors to <code class="inlineCode">stderr.txt</code>. This allows us full control over where successful and unsuccessful messages are printed. This also helps us quite a bit when it comes to troubleshooting, because we may want to focus on only the errors, and getting rid of the success output may trim the number of lines we’ll have to look through.</p>
<p class="normal">I recommend that you go ahead and practice this concept as much as you can; it’s definitely something you’ll want to commit to memory. You don’t have to master this concept right now, but knowing the basics will provide a great foundation.</p>
<p class="normal">Next, let’s discuss another aspect of file management—links. Sometimes, you’ll need to link one thing <a id="_idIndexMarker300"/>to <a id="_idIndexMarker301"/>another, and there are a few ways to go about that along with some best-practice advice.</p>
<h1 class="heading-1" id="_idParaDest-88">Using symbolic and hard links</h1>
<p class="normal">If you’ve used a <a id="_idIndexMarker302"/>graphical <a id="_idIndexMarker303"/>operating system for more than a week, you’re probably more than familiar with the concept of shortcuts. Either on the desktop or within a menu, you will have shortcuts to files and applications. This could be a shortcut to your home or profile directory, a shortcut to an application, an individual file, and so on. We have the same concept in Linux.</p>
<p class="normal">With Linux, we can link files to other files, which gives us the ability to create our own shortcuts, which are effectively similar to shortcuts in graphical operating systems, but without the requirement of a GUI. This comes in the form of <em class="italic">symbolic and hard</em> links, which are two different methods by which we can link things. Symbolic and hard links are very similar, but <a id="_idIndexMarker304"/>to explain them, you’ll first need to understand the concept of <strong class="keyWord">inodes</strong>.</p>
<p class="normal">An inode is a data object that contains metadata regarding files within your filesystem. Although a full walkthrough of the concept of inodes would be quite long, think of an inode as a type of database object, containing metadata for the actual items you’re storing on your disk. Information stored in inodes includes details such as the owner of the file, permissions, last modified date, and type (whether it is a directory or a file). Inodes are represented by an integer number, which you can view with the <code class="inlineCode">-i</code> option of the <code class="inlineCode">ls</code> command. On my system, I created two files: <code class="inlineCode">file1</code> and <code class="inlineCode">file2</code>. These files are inodes <code class="inlineCode">265416</code> and <code class="inlineCode">266112</code>, respectively. You can see this output in the following screenshot where I run the <code class="inlineCode">ls -i</code> command. This information will come in handy shortly:</p>
<figure class="mediaobject"><img alt="" height="151" src="../Images/B18425_05_08.png" width="602"/></figure>
<p class="packt_figref">Figure 5.8: Output of ls -i</p>
<p class="normal">As I mentioned earlier, there are two types of links in Linux: the symbolic link and hard link. While the two types of links approach the concept differently, they pretty much serve the same purpose. Basically, a link allows us to reference a file somewhere else on our filesystem.</p>
<p class="normal">For a practical example, let’s create a hard link. In my case, I have a couple of files in a <code class="inlineCode">test</code> directory, so I can create a link to either of them. To create a link, we’ll use the <code class="inlineCode">ln</code> command:</p>
<pre class="programlisting con"><code class="hljs-con">ln file1 file3
</code></pre>
<p class="normal">Here, I’m creating a hard link (<code class="inlineCode">file3</code>) that is linked to <code class="inlineCode">file1</code>. To play around with this, go ahead and create <a id="_idIndexMarker305"/>a<a id="_idIndexMarker306"/> link to a file on your system. If we use <code class="inlineCode">ls</code> again with the <code class="inlineCode">-i</code> option, we’ll see something interesting:</p>
<figure class="mediaobject"><img alt="" height="184" src="../Images/B18425_05_09.png" width="617"/></figure>
<p class="packt_figref">Figure 5.9: Output of second ls -I command</p>
<p class="normal">If you look closely at the output, both <code class="inlineCode">file1</code> and <code class="inlineCode">file3</code> have the same inode number. Essentially, a hard link is a duplicate directory entry, where both entries point to the same data. In this case, we created a hard link that points to another file. With this hard link created, we can move <code class="inlineCode">file3</code> into another location on the filesystem and it will still be a link to <code class="inlineCode">file1</code>. Hard links have a couple of limitations, however. First, you cannot create a hard link to a directory, only a file. Second, this link cannot be moved to a different filesystem. That makes sense, considering each filesystem has its own inodes. Inode <code class="inlineCode">265416</code> on my system would, of course, not point to the same file on another system, if this inode number even exists at all.</p>
<p class="normal">To overcome these limitations, we can consider using a soft link instead. A soft link (also known <a id="_idIndexMarker307"/>as a <strong class="keyWord">symbolic link</strong> or <strong class="keyWord">symlink</strong>) is an entry that points to another directory<a id="_idIndexMarker308"/> or file. This is different from a hard link because a hard link is a duplicate entry that references an inode, while a symbolic link references a specific path. Symbolic links can not only be moved around between filesystems; we can also create a symbolic link to a directory as well. To illustrate <a id="_idIndexMarker309"/>how <a id="_idIndexMarker310"/>a symbolic link works, let’s create one. In my case, I’ll delete <code class="inlineCode">file3</code> and recreate it as a symbolic link. We’ll again use the <code class="inlineCode">ln</code> command:</p>
<pre class="programlisting con"><code class="hljs-con">rm file3
ln -s file1 file3
</code></pre>
<p class="normal">With the <code class="inlineCode">-s</code> option of <code class="inlineCode">ln</code>, I’m creating a symbolic link. First, I deleted the original hard link with the <code class="inlineCode">rm</code> command (which doesn’t disturb the original file, <code class="inlineCode">file1</code>) and then created a symbolic link, also named <code class="inlineCode">file3</code>. If we use <code class="inlineCode">ls -i</code> again, we’ll see that <code class="inlineCode">file3</code> does not have the same inode number as <code class="inlineCode">file1</code>:</p>
<figure class="mediaobject"><img alt="" height="215" src="../Images/B18425_05_10.png" width="623"/></figure>
<p class="packt_figref">Figure 5.10: Output of ls -i after creating a symbolic link</p>
<p class="normal">Notice that the inode numbers of each file are all different. At this point, the main difference compared with a hard link should become apparent. A symbolic link is not a clone of the original file; it’s simply a pointer to the original file’s path. Any commands you execute against <code class="inlineCode">file3</code> are actually being run against the target that the link is pointing to. Hard links, on<a id="_idIndexMarker311"/> the <a id="_idIndexMarker312"/>other hand, point directly to the file.</p>
<p class="normal">In practice, symbolic links are incredibly useful when it comes to server administration. However, it’s important not to go crazy and create a great number of symbolic links all over the filesystem. This certainly won’t be a problem for you if you are the only administrator on the server, but if you resign and someone takes your place, it will be a headache for them to figure out all of your symbolic links and map where they lead to. You can certainly create documentation for your symbolic links, but then you’d have to keep track of them and constantly update documentation. My recommendation is to only create symbolic links when there are no other options, or if doing so benefits your organization and streamlines your file layout.</p>
<p class="normal">Getting back to the subject of symbolic links versus hard links, you’re probably wondering which you should use and when to use them. The main benefit of a hard link is that you can move either file (the link or the original) to anywhere on the same filesystem and the link will not break. This is not true of symbolic links; however, if you move the original file, the symbolic link will be pointing to a file that no longer exists at that location. Hard links are basically duplicate entries pointing to the same object, and thus have the same inode number, so both will have the same file size and content. A symbolic link is a pointer to the file’s path—nothing more, nothing less.</p>
<p class="normal">However, even though I just spoke about the several benefits of hard links, I actually recommend symbolic links for most use cases. They can cross filesystems, can be linked to directories, and it’s easier to determine from the output where they lead. If you move hard links around, you may forget where they were originally located or which file actually points to which. Sure, with a few commands you can find them and map them easily. But overall, symbolic links are more convenient in the long run. As long as you’re mindful of recreating<a id="_idIndexMarker313"/> your<a id="_idIndexMarker314"/> symbolic link whenever you move the original file (and you use them only when you need to), you shouldn’t have an issue.</p>
<h1 class="heading-1" id="_idParaDest-89">Summary</h1>
<p class="normal">In this chapter, we elevated our terminal kung-fu to another level and looked at concepts such as moving and copying files. We continued into a discussion of two popular text editors, Nano and Vim. Then, we took a dive into the subject of streams, and finished off the chapter with an understanding of the differences between symbolic and hard links, as well as how to create them.</p>
<p class="normal">In <em class="chapterRef">Chapter 6</em>,<em class="chapterRef"> </em><em class="italic">Boosting Your Command-line Efficiency</em>, we’ll dive a bit deeper into command-line tips and tricks, which will include a discussion on Bash history, writing basic scripts, and more.</p>
<h1 class="heading-1" id="_idParaDest-90">Relevant videos</h1>
<ul>
<li class="bulletList">Linux Crash Course – Data Streams (LearnLinuxTV): <a href="https://linux.video/se-data-streams"><span class="url">https://linux.video/se-data-streams</span></a></li>
<li class="bulletList">Linux Crash Course – nano (LearnLinuxTV): <a href="https://linux.video/le-nano"><span class="url">https://linux.video/le-nano</span></a></li>
<li class="bulletList">Linux Crash Course – Symbolic Links (LearnLinuxTV): <a href="https://linux.video/se-symlinks%20"><span class="url">https://linux.video/se-symlinks</span></a></li>
<li class="bulletList">Vim Text Editor Tutorial Series: <a href="https://learnlinux.link/vim"><span class="url">https://learnlinux.link/vim</span></a></li>
</ul>
<h1 class="heading-1">Join our community on Discord</h1>
<p class="normal">Join our community’s Discord space for discussions with the author and other readers: </p>
<p class="normal"><a href="https://packt.link/LWaZ0"><span class="url">https://packt.link/LWaZ0</span></a></p>
<p class="normal"><img alt="" height="177" src="../Images/QR_Code50046724-1955875156.png" width="177"/></p>
</div>
</div></body></html>