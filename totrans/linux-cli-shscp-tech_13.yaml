- en: '*Chapter 13*: Using Arrays'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In one of the recipes in a previous chapter, we mentioned arrays as one of the
    possible compound data types that `bash` supports. We said that what `bash` has
    is two different data types (strings and numbers), but that there are ways that
    we can use more than that if we need to. Arrays are just that—something that we
    need to be able to use since we need something a little bit more complex than
    single-value variables to solve some problems.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we are going to cover two basic recipes connected to arrays:'
  prefs: []
  type: TYPE_NORMAL
- en: Basic array manipulation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Advanced array manipulation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can already see that we are being intentionally broad here; arrays are like
    that—simple on the surface, but with quite a few small tricks if we need to use
    them.
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As with all the chapters that cover scripting, we are using any machine that
    works, and things as fundamental as arrays are going to work on all machines that
    run `bash`. You will therefore need the following:'
  prefs: []
  type: TYPE_NORMAL
- en: A **virtual machine** (**VM**) with any distributuon of Linux (in our case,
    it's going to be **Ubuntu 20.10**)
  prefs: []
  type: TYPE_NORMAL
- en: So, start your VM!
  prefs: []
  type: TYPE_NORMAL
- en: Basic array manipulation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The thing with `bash` and variables in `bash` is that they look deceptively
    simple. There are no formal declarations of type, or basically declarations of
    any kind. Typing is done by the shell itself, and we can do a lot of things implicitly.
    This is especially true for *regular* variables. Arrays are a little bit more
    complex, and they offer a few syntactic peculiarities when used, but they are
    an extremely useful tool. You may wonder why we are even mentioning them in any
    context since they are nothing more than one value under the same variable name.
    Well, the main reason is that we often actually need exactly this. A lot of times,
    we must store multiple values that belong to some set of data. Typically, that
    will be something such as an unordered list of values in case it is something
    that we do not care about having in a particular order, or an ordered list of
    values if we do.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Usually, arrays are defined as *one-dimensional indexed arrays*, since they
    have an explicit order embedded in the very definition of an array. In essence,
    when we have any multi-value variable, it can be *ordered* and *unordered*. The
    difference is in whether we can define in which order the values are declared
    in the variable. If we can store values but are unable to get the order in which
    they are stored, that is called an unordered set. In `bash`, we only have ordered
    lists, which we call arrays. This means that every value in the variable has not
    only the value itself but a defined index or place. Not only can we add or remove
    values from an array, but we can also directly read any of them and we can reorder
    them if we need to.
  prefs: []
  type: TYPE_NORMAL
- en: We have two types of arrays at our disposal. Both are ordered but one is *indexed*,
    which means that we have a numerical value that defines a particular element of
    the array. We also have something named associative arrays, sometimes also called
    *hash tables*. This type of array is useful because it doesn't use a numeric value
    but instead uses a string key to define a particular array element. We will talk
    a lot about both.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The first thing we need to do is to declare a variable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'We are off to a bad start. Obviously, we declared our variable correctly since
    there were no errors, but as soon as we tried to print it, we ran into problems.
    We had those before when we tried to print arrays. The solution is to use a special
    character to denote the index and tell bash that we want to print not only the
    first value but all values in the array:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'This works as intended since `bash` understands it needs to do a quick loop
    and go through every index in the array, printing all the values. An alternative
    to that is to use the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: This has the exact same output as the previous command.
  prefs: []
  type: TYPE_NORMAL
- en: 'This should get you thinking: *Is there another way to use indexing?* Of course
    there is—we can use it to directly access a single value in the array:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Make a note we are *off by one* in this example since the first element in an
    array has an index of `0`. There is one more very interesting property rarely
    mentioned in terms of arrays. Before we show it, we need to explain another way
    of declaring an array.
  prefs: []
  type: TYPE_NORMAL
- en: 'Declaring a variable using simple brackets is the most common way to do this,
    but we can also do it by directly specifying elements in an array. The interesting
    thing is that we can do it in any order we want to:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'If we now try to print our array, the result is going to be more dangerous
    than surprising:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Our array has two values stored under indexes. We intentionally made an error
    in indexing—the value of `second` is stored under index number `2`, making it
    the third array element. What we didn''t do is declare the first element of our
    array. The reason we said that the result of the previous command is dangerous
    is that from its output, you cannot see the index of a particular element, so
    you have no idea what the actual index of a particular value is. This makes it
    easy to confuse the values—or, to make it more obvious, something such as this
    will not return a value, although we might think it should:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Things such as these are a common source of errors that we need to troubleshoot,
    and they are especially complicated to spot if we use the direct syntax of specifying
    both a value and its index.
  prefs: []
  type: TYPE_NORMAL
- en: What we are trying to say is to never use this way of declaring an array, unless
    you have a particular reason why you need it. Otherwise, things can become confusing
    later.
  prefs: []
  type: TYPE_NORMAL
- en: There is a third way to declare an array that is the least commonly used method.
    Using the `declare` statement and the `-a` switch, you explicitly declare that
    a particular variable is going to hold an array of values. The reason we rarely
    see this in code is that when we use either of the already mentioned implicit
    declarations, our variable will become appropriately typed, so there is simply
    no reason to do this twice unless you want to do so to make your code readable.
  prefs: []
  type: TYPE_NORMAL
- en: All of this was just different ways to create and print normal, indexed arrays.
    We mentioned that there is another type of array called an associative array,
    also known as a hash table, dictionary, or key-value paired array. This type was
    introduced in `bash` 4.0 and is still not available on some platforms; most notably,
    some versions of OS X require you to upgrade `bash` to be able to use this type.
  prefs: []
  type: TYPE_NORMAL
- en: 'Real life contains a lot of things that can be considered pairs of values.
    Things such as username/password, name/address, name/telephone number are naturally
    created pairs of data that are often used in scripts. Obviously, we could use
    a normal array to store this, but to do it in a way that enables us to understand
    which values are a part of a given pair, we would need not one but two separate
    arrays and a little bit of focus on how we declare indexes for them so that we
    can use the same index to get the first and the second value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'This is going to give us an output that looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'This looks and works fine if we need to print out all of the data. Imagine
    now that we have information that we need to search for—imagine we are looking
    for a telephone number of a particular person. If we needed to do this using regular
    arrays, something like this could be done:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'In order to check all the values, we need to go through every element of one
    array and then print pairs if we find a match. First, we are going to test this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Although this is working, it is not the right way to do it. Some of the downsides
    of this approach are obvious:'
  prefs: []
  type: TYPE_NORMAL
- en: An array is indexed, so it can hold the same content at different indexes.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In order to find something, we need to go through all values.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If we mess up any of the arrays, we can create invalid data.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The script is very complicated for a simple task.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: That other *associative* array type we mentioned is the solution to this and
    many more problems. While in normal arrays, the values we are using are indexed
    by numbers. In this particular array type, we use any value as a *key* to reference
    a specific value in an array.
  prefs: []
  type: TYPE_NORMAL
- en: 'Doing this requires an explicit declaration of the array type that has to be
    done using the `declare` statement and the `-A` switch. Be very careful about
    this switch since it uses a capital letter *A*, while *normal* arrays are declared
    using the same letter in lowercase. While you may implicitly declare an indexed
    array in multiple ways, an associative array can be declared only by using this
    method and must be declared explicitly. Before we can do a script to fully demonstrate
    that, we need to show you how to declare an array of this type. Besides the fact
    that we must use the `declare` statement, we also need to declare the indexes
    since they can be any string, not just a number. The output looks something like
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'There is also a way to declare these arrays in one line, by specifying pairs:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that we have defined this array in two ways, let''s do a small follow-up
    with other operations that we can carry out. We should be able to write out the
    array values. First, we will try the method we used with regular arrays:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'This is, of course, a problem, but we were expecting it. This syntax is designed
    for arrays that have a numerical index and is translated into something a human
    can understand, which means: *print all the values from an array called NAMES
    by using all possible indices*.'
  prefs: []
  type: TYPE_NORMAL
- en: The key here is that we are not printing the index of a value, just the value
    itself. Since we are using both the key and the value in our arrays, we need to
    be able to see what the key for a particular value is. This can be done using
    a `for` loop, but before we do that, we have a point to make—by design, arrays
    have multiple values, so not only can we redefine the whole array, but we can
    also add and remove elements from it. We already showed an example in which we
    added elements to a variable, and we did this by creating a new value under a
    new index.
  prefs: []
  type: TYPE_NORMAL
- en: 'All this applies not only to associative arrays but to arrays in general; however,
    we are going to use associative arrays just to make you more familiar with this
    type. We are going to repeat the example from before, but with a twist:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'What happened? First, we defined an array that consists of three value pairs.
    We did this by declaring every single pair by itself. After that, we used the
    alternative way of array declaration, but since we basically redeclared the array,
    the values we used completely replaced values that the array had before. What
    we should have done is *add* those values. There are two ways to do this—one is
    to just define the right values for the pairs again:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: We can now see our array has the expected number of values, although we still
    don't know how to get them printed.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another way to do this is by using addition. We are going to change only one
    character in our example to do this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Can you even notice the change? What we did is use the plus operator in front
    of the equals sign to tell `bash` that we want these pairs added to our array.
    This notation is completely the same as if we had used `NAMES=NAMES+([Ida]=11111
    ["That guy"]=122222)`—it is just a little shorter.
  prefs: []
  type: TYPE_NORMAL
- en: The last thing we need to know is how to remove a value from an array.
  prefs: []
  type: TYPE_NORMAL
- en: 'The solution to this is simple—there is a command called `unset` that simply
    removes the value associated with a particular index or a key. More often than
    not, this is used on key-value pairs since it makes much more sense there, but
    you can also do it on a regular array:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Now, we are going to tackle the big problem and rewrite our script from before,
    using our only associative array.
  prefs: []
  type: TYPE_NORMAL
- en: 'The idea of how to do this is based on the way `bash` uses sets of objects.
    We are going to create one such set out of all the keys, and then print both the
    key and the value it points to. To access keys directly, we can use an exclamation
    point:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: There are some small things you need to notice in this script. For example,
    quotes are important since our keys contain spaces. The general rule here is that
    as soon you are using any string as a value of anything, it should be enclosed
    in quotes to get the space parsed correctly.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `for` loop is going to go through keys one by one, and keys are going to
    be used as an entire key value, including a space. Some manuals will state that
    a key must be a single word, but officially it can be anything. The usage scenario
    for this type of variable is, however, that we will be using a word or two in
    most cases:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We have demonstrated the way arrays work in practice, how to create them, how
    to read from them, and how to delete individual elements inside an array. What
    makes arrays a little bit different from regular variables is that variables hold
    one value, so there are no operations that can modify that value. If we need to
    change it, we simply redeclare the entire value. When dealing with arrays, we
    are dealing with multiple values in one array, and that still means we must redeclare
    any that we need to change, but we are then changing just a single value out of
    many, not the entire array. This is the main reason we have operations that add
    and remove elements.
  prefs: []
  type: TYPE_NORMAL
- en: Some of you already familiar with different programming languages will probably
    be a little bit confused by the relaxed way some things are defined, especially
    when we are talking about regular arrays and the way they address individual values
    and print them. Probably the most confusing part is how you can completely skip
    a range of indexes and still get a valid array. We are going to talk a little
    bit more about this in the next recipe, but `bash` is inconsistently vague in
    some ways, and this is one of them.
  prefs: []
  type: TYPE_NORMAL
- en: Associative arrays are going to be something you will need from time to time,
    especially when you need to deal with objects that have some properties. It is
    not possible to store more than one property per key, but even this makes for
    a nice environment since this single value can, for example, be an indexed value
    that then points to different arrays containing everything else that we need to
    store about a particular object.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Arrays are complicated and, at the same time, very simple in their syntax.
    Check out these links for many more examples:'
  prefs: []
  type: TYPE_NORMAL
- en: https://www.shell-tips.com/bash/arrays/
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://opensource.com/article/18/5/you-dont-know-bash-intro-bash-arrays](https://opensource.com/article/18/5/you-dont-know-bash-intro-bash-arrays)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Advanced array manipulation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now we have finished dealing with the basics, we need to add much more to your
    knowledge of arrays. What we first need to do is to give you some ideas on how
    to make the arrays you create in your scripts more persistent, so we need to deal
    with storing and restoring them.
  prefs: []
  type: TYPE_NORMAL
- en: The reason why this is important is that arrays can be quite large, depending
    on the script you are creating. Dumping and reusing variables in scripts is easy
    since we can use the *source* to declare variables we stored in a file. Arrays
    make for more complicated work since they can contain multiple variables, and
    sometimes we even need to create them from another data source.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The thing with scripts is that they sometimes need to deal with a lot of data.
    In a lot of cases, we can use files to both store data in and load data from.
    There are, however, some cases where arrays—especially associative arrays—are
    a necessity for working with large amounts of data, and then we need to know how
    to save that data to the disk and reuse it. We are going to show you how to solve
    those problems and advise you when to do it.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When talking about all of this, we always need an example where a particular
    feature makes sense. Some of the `bash` features we dealt with were so generic
    that our examples also had to be generic. Associative arrays are not like that.
    Although they can be used for a number of things, some scenarios are so common
    that you will automatically start to declare an array even before you think how
    and why you are doing it.
  prefs: []
  type: TYPE_NORMAL
- en: The most common scenario is saving user settings.
  prefs: []
  type: TYPE_NORMAL
- en: Any larger script that deals with any task will have to be configurable. We
    mentioned that when we said that you can include files, and the most common ones
    are going to be the ones containing variables, storing values for different settings.
  prefs: []
  type: TYPE_NORMAL
- en: 'Most of the time, all the settings in a script look something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: These settings are just an example, but most scripts have a block of these either
    in a separate file or at the start of the script.
  prefs: []
  type: TYPE_NORMAL
- en: Notice that all of them have a format of `KEY=VALUE` and look like they are
    created to be used in an associative array. Having said that, we need to make
    a point about using any feature of any programming language—do what is best for
    the performance and clarity of a given solution and don't use a feature just because
    you *know* it is used in a particular situation.
  prefs: []
  type: TYPE_NORMAL
- en: This is where your experience is required. If a script has a set of settings
    that never change after we initially set them while loading and saving them from
    the disk, this makes no sense. The same goes for if a script only has a few variables
    defined when it starts—there is no point in using arrays here.
  prefs: []
  type: TYPE_NORMAL
- en: But if a script has more than a few things that change between different script
    executions, and if you are using them to store some important runtime operations
    that are needed not only when the script starts but also during its run, arrays
    may be a solution.
  prefs: []
  type: TYPE_NORMAL
- en: Our example is going to be a small script that will have a few settings it needs
    to remember, and we are going to use arrays to load them from disk, use them,
    and store them later back to disk. Working on this, we are also going to perform
    some tasks on a given array to demonstrate how to manipulate pairs in a script.
  prefs: []
  type: TYPE_NORMAL
- en: But before we do any of that, we need to go through a few advanced examples
    to show you how some things we previously glanced over work.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we are going to deal with the difference between using `*` and `@` operators
    to read indices and keys in arrays. We said that for a given array, those two
    operators are different ways of going through all indices. Here''s an example
    to illustrate this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'The same goes for associative arrays:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'So far, the results are at first glance identical. This is one of those things
    in `bash` that will sometimes make you pull your hair out in despair because when
    we use them for loops, there will be a big difference that we are going to show
    by creating a small example script:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'If we run this script and both of those expressions return the same set of
    values, the output should be identical. But if we actually run it, we get this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: We see that when we use `@`, we get what we expected, but as soon as we replace
    it with `*`, we can see the keys (or indices) but get no values in return.
  prefs: []
  type: TYPE_NORMAL
- en: The reason behind this is, as always, the way `bash` works. Using the `@` sign
    signals to `bash` that we are trying to get each index or key separately. Using
    the `*` sign, on the other hand, makes `bash` return all the indices or keys as
    a single string divided by spaces. So, our script in one case reads each element
    one by one, and the other loop is run only once. Since the value that we are trying
    to look up is different from any single key value in our array, this one run gets
    no results. In the end, those two expressions are not identical, but the simple
    printout is—don't let that fool you.
  prefs: []
  type: TYPE_NORMAL
- en: Now, we are going to create our master script for manipulating arrays and then
    add a few elements to it.
  prefs: []
  type: TYPE_NORMAL
- en: The obvious starting point is to create a file containing our array. There are
    multiple ways to do that, some more complicated than others, but almost all of
    them depend on using some loop to go through the array and either read it or write
    it to a file.
  prefs: []
  type: TYPE_NORMAL
- en: 'We are going to do it the canonical Linux way by using the `declare` statement.
    If we do the `-p` switch, we are telling it to print a particular variable with
    both its definition and the values stored in it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Obviously, this is great since this is the only thing we need to remember to
    have everything that is stored in the variable itself. To save it, we just redirect
    it to a file on disk:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'To show that this worked, we are going to unset the variable and verify it
    was deleted so that the values only exist in a file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let''s look at how to reload the script from a disk. Notice that the output
    of the `declare` statement was an actual `declare` statement defining the variable.
    If we load it from disk and execute it, everything should be fine:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: The internet is full of more complicated solutions, but for an array of a reasonable
    size, this should work great. At the same time, this is easy to read in a script,
    and the file that contains the data is in a universal format readable by any other
    `bash` version installed on any system (if it is `bash` 4.0 since that is when
    these types of arrays were introduced).
  prefs: []
  type: TYPE_NORMAL
- en: 'We now know how to read and write an array to disk, but what else can we do
    with it? In our example, we are going to switch to a regular array to show you
    some things you can do:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'So, we have created an array and we made an error. Since the array is already
    in the wrong order, we are going to reshuffle it even more (the `shuf` command
    randomizes the array):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: Although you could create your own solution for the randomization of values,
    using an external command is the simplest solution.
  prefs: []
  type: TYPE_NORMAL
- en: Shuffling is easy but it is not permanent. What the command is doing is taking
    our array as its input, shuffling the values, and then printing the result while
    the original array stays the same.
  prefs: []
  type: TYPE_NORMAL
- en: We reassigned the array to the result of the command. The main reason we also
    created another variable and printed it is that we had to show that shuffling
    happens in real time, and the results are different each time the `shuf` command
    is started.
  prefs: []
  type: TYPE_NORMAL
- en: Sorting an array is going to be more of a problem since it requires some sorting
    mechanism. Either you will create one yourself or you can, with a little care,
    use the `sort` command already included in `bash`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The next thing we are going to do is show you how to work with ranges of indices.
    We are going to reset our array and then show you some examples. When we declare
    ranges, in reality, we are using a mechanism built into `bash` that enables us
    to define a range of numbers. We already used that to create loops and iterators
    in them, so this will not be too much of a surprise to you:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: We are using standard notation in `bash`. The first number after the variable
    is the starting index we want to print, and the optional number after it is the
    number of values we need. Notice that negative numbers do not work here unlike
    in some other places; we cannot go back from the end of the array this way.
  prefs: []
  type: TYPE_NORMAL
- en: The next thing we can do is concatenate two arrays.
  prefs: []
  type: TYPE_NORMAL
- en: 'Depending on what you want to do, the result of that operation will not get
    you what you might have been expecting:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'Another operation we can do is count the number of values in an array. We also
    already did this before, so let''s check if our arrays were merged correctly:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: What happened here?
  prefs: []
  type: TYPE_NORMAL
- en: 'In our concatenation, we made a huge error. What we wanted to do is create
    a new array that will hold the values from both arrays. What we did is create
    a `string` variable that contains one huge string created from all values in the
    arrays. We need to fix this by using brackets:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: So, we created our array and checked how many values it holds. Since we wanted
    to be completely sure, we used the `declare` statement to show all the index/value
    pairs.
  prefs: []
  type: TYPE_NORMAL
- en: 'Before we move on, we need to make a small mistake by using a pair of quotation
    marks:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: What we did is create something extremely similar to our first example, but
    at the same time, completely wrong. One of the values is a combination of two
    strings, not two separate values. Try all different combinations of quotation
    marks to try to see how they work and if using either `@` or `*` makes a difference
    to the resulting array.
  prefs: []
  type: TYPE_NORMAL
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We have dealt with different things you can do to an array in detail. What''s
    left is to see what else is there to know about arrays and how to check if an
    array contains a value. The length—or, more precisely, the number of values is
    something we just looked at, and if you need to know if an array already exists,
    you should check if the length of it is longer than `0`. This will tell you that
    either the array you are testing is not defined or it contains no elements. If
    you explicitly want to check if the variable is defined, use the `declare` statement
    and count the results. In our example, we have a variable called `TEST1` and an
    undefined name, `TEST2`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: For most intents and purposes, just checking for the value count is enough,
    but sometimes you need to know if a variable is even defined.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another common thing to do is try to find if there is a particular value inside
    an array. You can do this by creating your own loop to check for the values, or
    you can use the built-in test that `bash` already has. For example, you could
    do something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: Once again, we used a one-line logical expression to quickly see the result.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, here''s a small script that will show some of the things we learned in
    this recipe:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: We already know most of this, but we will go through the script.
  prefs: []
  type: TYPE_NORMAL
- en: The first function in that script tests if a file exists. We could have done
    the same thing by using the `if` statement later in the code, but we wanted to
    remind you how to use functions and logical checks. The function returns `0` if
    the file is there, and `1` if it is not.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we have the function we called `assign_settings` that is used if the file
    is not found. What it does is simply create a new associative array that contains
    some data.
  prefs: []
  type: TYPE_NORMAL
- en: Then, we are in the main body of code in our script, and first, we are declaring
    our arrays since they cannot be declared implicitly. Then, we decide if we have
    our file saved and if we should load our array from there or whether we need to
    reassign the defaults.
  prefs: []
  type: TYPE_NORMAL
- en: After that, we are just printing out the values and then saving them to disk.
  prefs: []
  type: TYPE_NORMAL
- en: In a normal script, this would be a part of the script that does the importing
    and saving of important settings. The rest of the script would be right before
    the line that saves the variables.
  prefs: []
  type: TYPE_NORMAL
- en: 'We are going to start the script two times in a row. The result should be that
    it will detect we have no configuration and make it for us:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: When you are doing something such as this, we must also warn you that there
    may be big problems with local and global variables. Be very careful if you are
    declaring any variable that is supposed to be global in a function or—even worse—if
    you are sourcing it from a function since the scope will limit your values from
    propagating throughout the script.
  prefs: []
  type: TYPE_NORMAL
- en: This is where we will leave arrays and go on to more interesting stuff—starting
    to create some interfaces.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*How to use bash array in a shell script*: [https://linuxconfig.org/how-to-use-arrays-in-bash-script](https://linuxconfig.org/how-to-use-arrays-in-bash-script)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*The Ultimate Bash Array Tutorial with 15 Examples*: [https://www.thegeekstuff.com/2010/06/bash-array-tutorial/](https://www.thegeekstuff.com/2010/06/bash-array-tutorial/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
