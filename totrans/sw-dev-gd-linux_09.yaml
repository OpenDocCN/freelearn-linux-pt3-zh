- en: '9'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Managing Installed Software
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As you work in various Linux or Unix environments, you’ll need to add or remove
    software. This is usually done via package managers, although occasionally you’ll
    have to use other methods in a pinch.
  prefs: []
  type: TYPE_NORMAL
- en: You’re likely familiar with tools that manage libraries in your programming
    environment – `npm`, `gem`, `pip`, `go get`, `maven`, `gradle`, and so on. These
    package managers all operate on the same principles as the ones found in Linux
    and Unix.
  prefs: []
  type: TYPE_NORMAL
- en: Software **package managers** abstract away the many configuration and binary
    files that make up a piece of software and let you work with a single, neat “package”
    instead. This should feel familiar if you’re coming from Windows (`.exe` or `.msi`
    installers) or macOS (`.dmg` installers).
  prefs: []
  type: TYPE_NORMAL
- en: 'Additionally, most Linux package managers add a layer of security to the process,
    by:'
  prefs: []
  type: TYPE_NORMAL
- en: Using secure transport (TLS) for your download.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using cryptographic signing on the packages themselves, to prove that the authors
    are at least who they say they are (whether you implicitly trust them or not).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Various Linux distributions also pioneered the idea of searchable package repositories
    that help users find software to download, which inspired the Apple and Microsoft
    “App Stores” that exist today.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we’ll cover the following:'
  prefs: []
  type: TYPE_NORMAL
- en: What package managers are
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The most common package managers you’ll see
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The most important package management operations and the individual commands
    you’ll need to execute them, “translated” across package managers – this is 90%
    of what you’ll need to know in practice
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A popular procedure for downloading and executing custom install scripts
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A quick practical introduction to locally building and installing software yourself
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If you’re looking for instructions on installing software in Docker, please
    check out *Chapter 15*, *Containerizing Applications with Docker* instead.
  prefs: []
  type: TYPE_NORMAL
- en: 'First things first: as a developer, you’ll reach for package management commands
    when you want to do a few common things:'
  prefs: []
  type: TYPE_NORMAL
- en: Install new software packages, for example, dependencies that your application
    expects to be available in its execution environment.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Check for installed packages (for example, “Is the nginx web server already
    installed on this system?”).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Update the currently installed set of packages, to make sure you’ve got the
    latest versions of everything. This is common for addressing vulnerabilities that
    are discovered, or ensuring you’ve got all the latest features of a piece of software.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Remove a package – that is, uninstall it from the system.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let’s jump into how to achieve these practical goals and see the practical commands
    that you’ll be using.
  prefs: []
  type: TYPE_NORMAL
- en: Working with software packages
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Before we dive into practical commands, you should know that the exact commands
    you’ll use will differ based on the flavor of Unix (or distribution of Linux)
    that you’re using. Different Linux distributions use different package managers,
    and although their syntaxes diverge *just* enough to be annoying, they all work
    in an almost identical fashion. Common package managers include:'
  prefs: []
  type: TYPE_NORMAL
- en: '`homebrew` (macOS)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`apt` (reliably found on Ubuntu and Debian-based systems, even minimal ones
    that don’t have aptitude installed)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`pacman` (Arch)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`apk` (Alpine)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the rest of the practical sections that follow, we’ll introduce the high-level
    goal we want to achieve (such as “install a specific package”), and then show
    you the exact commands that accomplish that task, using the popular package managers
    we just named.
  prefs: []
  type: TYPE_NORMAL
- en: Update your local cache of repository state
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Before installing or deleting packages, you’ll want to make sure that your local
    package cache (your system’s record of the packages available on the internet)
    is up to date.
  prefs: []
  type: TYPE_NORMAL
- en: For example, if you’re trying to install the `nginx` web server, but the last
    time someone updated the local package cache was a month ago, you might unintentionally
    install an outdated version from last month, instead of the new release from this
    week.
  prefs: []
  type: TYPE_NORMAL
- en: 'To update the cache, find your package manager in the list below and run the
    corresponding command:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Package manager** | **Commands** |'
  prefs: []
  type: TYPE_TB
- en: '| `homebrew` | `brew update` |'
  prefs: []
  type: TYPE_TB
- en: '| `apt` | `apt update` |'
  prefs: []
  type: TYPE_TB
- en: '| `pacman` | `pacman -Sy` |'
  prefs: []
  type: TYPE_TB
- en: '| `apk` | `apk update` |'
  prefs: []
  type: TYPE_TB
- en: Your local cache of available packages will be updated, and then you can move
    on to the exciting work of finding and installing a package.
  prefs: []
  type: TYPE_NORMAL
- en: Search for a package
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Not all packages have the same name as the software they contain. Firefox may
    be available in the `firefox` package, but you might be disappointed if you try
    to install `ag` (package name: `silversearcher-ag`). Search for a description
    of the package you’re considering installing with the following package manager
    commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Package manager** | **Commands** |'
  prefs: []
  type: TYPE_TB
- en: '| `homebrew` | `brew search $PACKAGENAME` |'
  prefs: []
  type: TYPE_TB
- en: '| `apt` | `apt-cache search $PACKAGENAME` |'
  prefs: []
  type: TYPE_TB
- en: '| `pacman` | `pacman -Ss $PACKAGENAME` |'
  prefs: []
  type: TYPE_TB
- en: '| `apk` | `apk search $PACKAGENAME` |'
  prefs: []
  type: TYPE_TB
- en: This is a good way to confirm you’re getting what you expect but it can also
    be used to spread out your search and look for general software related to your
    problem. For example, on Ubuntu, I can search for grep-like tools with `apt-cache
    search grep`. Any package containing grep in the name or description will be shown.
  prefs: []
  type: TYPE_NORMAL
- en: Install a package
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Finally, the main event! Now that our repository cache is up to date *and*
    we know exactly which package we want to install, let’s run an `install` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Package manager** | **Commands** |'
  prefs: []
  type: TYPE_TB
- en: '| `homebrew` | `brew install $PACKAGENAME` |'
  prefs: []
  type: TYPE_TB
- en: '| `apt` | `apt install $PACKAGENAME` |'
  prefs: []
  type: TYPE_TB
- en: '| `pacman` | `pacman -Sy $PACKAGENAME` |'
  prefs: []
  type: TYPE_TB
- en: '| `apk` | `apk add $PACKAGENAME` |'
  prefs: []
  type: TYPE_TB
- en: If your package manager prompts you for confirmation, respond to the prompt
    and your package will be installed (along with any other packages it depends on).
  prefs: []
  type: TYPE_NORMAL
- en: Because some of these commands prompt for confirmation before installing a package,
    these can block a script. When you’re automating tasks with scripts, and you need
    to install a package, make sure to read the appropriate package manager man page
    for how to install packages in a noninteractive way. This is often done via an
    environment variable or an extra argument to the command.
  prefs: []
  type: TYPE_NORMAL
- en: Upgrade all packages that have available updates
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'On a long-running system, you’ll want to occasionally upgrade the installed
    packages to their latest versions. This fixes known vulnerabilities, gets you
    the newest features, and keeps different systems from having their state drift
    apart just because they were provisioned a few months before or after another
    system:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Package manager** | **Commands** |'
  prefs: []
  type: TYPE_TB
- en: '| `homebrew` | `brew upgrade` |'
  prefs: []
  type: TYPE_TB
- en: '| `apt` | `apt dist-upgrade` |'
  prefs: []
  type: TYPE_TB
- en: '| `pacman` | `pacman -Syu` |'
  prefs: []
  type: TYPE_TB
- en: '| `apk` | `apk upgrade` |'
  prefs: []
  type: TYPE_TB
- en: These commands will also prompt for confirmation, so if you’re using them in
    scripts, the same advice about adding an option to make them noninteractive applies.
    For example, `apt –y dist-upgrade` will not wait for manual confirmation, and
    will just perform the upgrade.
  prefs: []
  type: TYPE_NORMAL
- en: Remove a package (and any dependencies, provided other packages don’t need them)
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Sometimes you want to uninstall a package: maybe you were just trying it out,
    your application requirements have changed, or it’s known to be vulnerable without
    a fix in sight. All package managers have a command for removing an installed
    package:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Package manager** | **Commands** |'
  prefs: []
  type: TYPE_TB
- en: '| `homebrew` | `brew remove $PACKAGENAME` |'
  prefs: []
  type: TYPE_TB
- en: '| `apt` | `apt remove $PACKAGENAME` |'
  prefs: []
  type: TYPE_TB
- en: '| `pacman` | `pacman -Rs $PACKAGENAME` |'
  prefs: []
  type: TYPE_TB
- en: '| `apk` | `apk del $PACKAGENAME` |'
  prefs: []
  type: TYPE_TB
- en: One thing you may need to do before or after removing a package is verify that
    a package is even installed. Let’s see how to do that now.
  prefs: []
  type: TYPE_NORMAL
- en: Query installed packages
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'If you need to list all packages that are currently installed on a system,
    you can do that with a single command:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Package manager** | **Commands** |'
  prefs: []
  type: TYPE_TB
- en: '| `homebrew` | `brew list` |'
  prefs: []
  type: TYPE_TB
- en: '| `apt` | `dpkg –l` |'
  prefs: []
  type: TYPE_TB
- en: '| `pacman` | `pacman -Qi` |'
  prefs: []
  type: TYPE_TB
- en: '| `apk` | `apk info` |'
  prefs: []
  type: TYPE_TB
- en: 'Because this list is often hundreds or thousands of packages long, it’s a bit
    unwieldy. Narrow down the output by piping it into a search command like `grep`,
    to find just what you’re looking for:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: If you’re confused by how we’re using that pipe to feed the output of `dpkg`
    into the `grep` command, see *Chapter 1*, *How the Command Line Works* for the
    basics of chaining together commands with the pipe character (|). We’ll also take
    a much deeper dive into this mechanic in the upcoming *Chapter 11*, *Pipes and
    Redirection*.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we’ve covered the basic package management commands that you’ll be
    using 90% of the time, it’s time to demonstrate a few patterns you’ll use when
    there is no pre-built package available for the software you want to install.
  prefs: []
  type: TYPE_NORMAL
- en: Caution required – curl | bash
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Sometimes you won’t find a pre-built package for the software you need. And
    that’s okay! Many online sources – even trustworthy and popular ones like homebrew
    on macOS – recommend a command-line install process that looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: This uses the `curl` command to download content from the web, and then uses
    that content as the input (`|`, the pipe character, which we covered in *Chapter
    1*, *How the Command Line Works*) for running Bash. When you do this, you’re essentially
    running a script on the web instead of as a local file. This can be an extremely
    convenient way of installing software, but please make *absolutely* sure that
    it’s coming from a trustworthy source.
  prefs: []
  type: TYPE_NORMAL
- en: 'We recommend always at least *looking* at the script source, which you can
    see in the browser by visiting the script URL for this command (represented in
    the example below as `$SOMEURL`), or by splitting the single `curl $URL | bash`
    command into multiple commands, so that you can:'
  prefs: []
  type: TYPE_NORMAL
- en: Download the script.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Read through it in a local text editor to verify that it’s not doing anything
    malicious, and optionally edit the script to suit your requirements.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Run the script, now that you’ve verified it does only what you want it to do.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'To split something like this `curl $URL | bash` pattern into multiple commands,
    you’d take the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: By splitting this into multiple steps instead of just downloading an untrusted
    script and running it immediately, we give ourselves time to review the code we’re
    about to execute and verify that it’s safe. The end result is the same (the install
    script runs), but this approach gives us much more control and requires less blind
    trust.
  prefs: []
  type: TYPE_NORMAL
- en: There’s another way to get software installed on a system, even if there’s no
    pre-written install script available.
  prefs: []
  type: TYPE_NORMAL
- en: Compiling third-party software from source
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This is the most manual, and most time-honored, way to install software on a
    system – manual compilation and installation! It doesn’t have the many advantages
    of a package manager, like speed, repeatability, ease of managing the installed
    software, and cryptographic validation of the software binary you’re installing.
  prefs: []
  type: TYPE_NORMAL
- en: But in a pinch, it’s still the most reliable way to get something installed,
    with no real outside dependencies except for the basic software tools (compiler,
    linker, and make script) that you’re already familiar with as a developer.
  prefs: []
  type: TYPE_NORMAL
- en: 'You’ll find yourself manually compiling and installing software when:'
  prefs: []
  type: TYPE_NORMAL
- en: There is no pre-packaged version of the software in the package manager you
    have available. For example, If you’re using a minimal container distribution
    (such as, Alpine), you might not find what you need in the package manager. In
    that case, you can compile your own binary from source, and get it into your container
    image that way.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You need to add your own (or other custom) software to a Docker container.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You need the absolute latest, bleeding-edge version of a piece of software,
    for which a packaged version doesn’t yet exist. This can be the case for slower-moving
    projects that don’t always have new packages available, or for situations where
    a hotfix for a critical vulnerability needs to be rolled out *immediately*, before
    the hotfix has made its way through the packaging process.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This process involves a few steps, with slight variations depending on the software.
  prefs: []
  type: TYPE_NORMAL
- en: 'Usually, this involves:'
  prefs: []
  type: TYPE_NORMAL
- en: '`curl` or `wget` to download the compressed software archive.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`tar zxf downloadname` or `unzip downloadname` to unarchive and decompress
    the source code directory you just downloaded.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Changing directory into the source directory you downloaded and reading any
    included `README` files. This is where you’ll be informed of the exact process
    you need to follow to build the software, as well as any deviations from the norms
    we’re describing here.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Running `./configure`, followed by `make`, followed by `sudo make install` to
    build and install the binary.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: As with other ways of installing software, either manually or through a package
    manager, keep in mind that `configure` and `make` execute arbitrary code *by design*.
    This means that running `make install` as root will result in all of this arbitrary
    code running as `root`. This should worry you. Make sure to verify that the software’s
    source code is trustworthy and that you are downloading it from a trustworthy
    source.
  prefs: []
  type: TYPE_NORMAL
- en: 'Example: compiling and installing htop'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To run through a real example of this, we’re going to download, compile, and
    install `htop`, which is a small, extremely useful system monitoring tool (similar,
    but superior, to the built-in `top` command). For the record, this is easily available
    via almost every Linux distribution’s package manager, but we’re going to pretend
    that it’s a hard-to-find, custom program that is not widely distributed through
    package managers.
  prefs: []
  type: TYPE_NORMAL
- en: The system we’re doing this on is an Ubuntu 22.04 Linux server, so if you want
    to follow along without having to do any troubleshooting of your own, use that.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we check for the latest release from the official GitHub repository
    here: [https://github.com/htop-dev/htop/releases](https://github.com/htop-dev/htop/releases)
    – at the time of this writing, that’s version 3.2.2.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now you’ll want to make a directory for this build, just to keep things neat
    – I recommend something in the `/tmp` directory, which holds temporary files and
    has its contents deleted every time the system starts up:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: That way, we can delete everything once the build is complete, to prevent cluttering
    our system with junk files from old builds. Now we’re ready to get started.
  prefs: []
  type: TYPE_NORMAL
- en: Install prerequisites
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'First, we need to install the basic C development toolchain (compiler, linker,
    make, and other tooling – all the stuff you need to compile C code on Linux).
    On Ubuntu, this is accomplished by installing a *metapackage* – a package that
    is a kind of alias for multiple other packages – called `build-essential`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'We’ll also install a few other tools that we’ll use: `wget` to download files
    from the web and the `ncurses` dev library, which `htop` uses for a responsive
    command-line interface:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Download, verify, and unarchive the source code
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'First, we’re going to download the source code and verify its cryptographic
    signature to make sure it’s a genuine release signed with the developer’s key:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: That gets us the compressed, archived source code directory, which we’ll be
    compiling into a binary.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s now ensure that we have a developer-sanctioned release by checking the
    signature, which is just a `sha256` hash of the source code.
  prefs: []
  type: TYPE_NORMAL
- en: 'Download the file containing the expected hash for this release and print it
    to the terminal:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Provided you’re working with the same version as we are in this example, you’ll
    see this hash:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Now hash the source code we downloaded to verify that the hashes match, using
    the `sha256sum` tool:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Wonderful! We now know that the software we have is the same as the official
    release that we meant to download. Let’s unarchive the source code directory and
    step inside it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: If you’re interested, now is the time to read the `Readme` file (general information
    about the program) and the `INSTALL` file (instructions for how to build and install
    the program).
  prefs: []
  type: TYPE_NORMAL
- en: Now we’re ready to start configuring and compiling this piece of software!
  prefs: []
  type: TYPE_NORMAL
- en: Configure and compile htop
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Inside the source code directory, it’s time to run the `./configure` script.
    This script ensures that we’ve got any dependencies required for compilation (shared
    libraries, tooling, and so on) installed, and configures things for the compilation
    we’re about to do:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: This will produce output while the script runs, checking various dependencies
    and ensuring that your environment looks like it has everything needed for compilation.
  prefs: []
  type: TYPE_NORMAL
- en: 'If this script produces errors, read them carefully: usually, it will clearly
    tell you what’s wrong – a missing library or a problematic operating system setting.
    After fixing any problems it alerts you about, re-run it. When it has run successfully
    to completion, you’re ready to compile the `htop` binary:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'This will again produce reams of output while the compile script runs. If you’re
    totally new to makefiles, they are an extremely useful automation tool used widely
    by developers. Here’s an excellent tutorial: [https://makefiletutorial.com/](https://makefiletutorial.com/)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Once the compilation is complete, we can install the `htop` binary we just
    created (it’ll be in the main source directory, named `htop`). Usually, there’s
    an automated way to do this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: '`sudo` is required because you’re moving the compiled binary into a protected
    (root-owned) location. After that, you can verify that `htop` is installed and
    working by typing:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: You should see a beautiful terminal-based GUI (thanks to the `ncurses` library)
    showing you your system’s current CPU load, memory utilization, and process list.
  prefs: []
  type: TYPE_NORMAL
- en: 'For programs that don’t ship with a full-featured `install` command, you can
    rely on the fact that there’s no magic in Linux and simply install the binary
    by moving it into the `/user/local/bin/` directory, where locally compiled binaries
    belong:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Having seen how straightforward this process can be, you now have all the knowledge
    you need to go forth and compile!
  prefs: []
  type: TYPE_NORMAL
- en: Conclusion
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, you learned the basics of managing the software that’s installed
    in your Linux environment. First, we looked at how to accomplish this the easy
    way: software management via the package managers you’re most likely to encounter.
    Although this first approach should cover 90% of your needs, you then learned
    about the procedures you’ll need to apply to the last 10% of situations – careful
    vetting, followed by using custom install scripts or manual compilation and installation.'
  prefs: []
  type: TYPE_NORMAL
- en: Hopefully you followed along with the practical compilation example and tried
    out the `htop` system monitor. Thankfully, `htop` is available via package managers
    everywhere – it’s a really useful tool that a lot of system administrators find
    invaluable on long-running production systems.
  prefs: []
  type: TYPE_NORMAL
- en: You should now be comfortable with the high-level concepts and practical commands
    you’ll need to effectively use many Unix and Linux systems, in both development
    and production environments.
  prefs: []
  type: TYPE_NORMAL
- en: Learn more on Discord
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To join the Discord community for this book – where you can share feedback,
    ask questions to the author, and learn about new releases – follow the QR code
    below:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://packt.link/SecNet](https://packt.link/SecNet)'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/QR_Code1768422420210094187.png)'
  prefs: []
  type: TYPE_IMG
