- en: '*Chapter 8*: Understanding the systemd Boot Process'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第8章*：理解systemd启动过程'
- en: 'In this chapter, we''ll take a brief look at the `systemd` boot process. Now,
    you might think that this would be a bit dull, but I can assure you that it won''t
    be. Rather than lead you through a dull slog about all that happens during bootup,
    my aim is to give you practical information that can make bootups run more efficiently.
    After that, I''ll show you some ways in which `systemd` has been made somewhat
    backward-compatible with the legacy **System V** (**SysV**) stuff. Specific topics
    in this chapter include the following:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将简要了解`systemd`的启动过程。你可能觉得这有些枯燥，但我可以向你保证，它并不会。我的目标是给你提供一些实用信息，使得启动过程更高效，而不是让你经历一段枯燥无味的启动过程。之后，我还将展示一些`systemd`如何在一定程度上与传统的**System
    V** (**SysV**) 兼容。本章的具体内容包括以下几部分：
- en: Comparing SysV bootup and `systemd` bootup
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 比较SysV启动和`systemd`启动
- en: Analyzing bootup performance
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 分析启动性能
- en: Some differences on Ubuntu Server 20.04
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Ubuntu Server 20.04上的一些差异
- en: Understanding `systemd` generators
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解`systemd`生成器
- en: Note that we won't be talking about bootloaders in this chapter because we're
    saving that for later.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，本章不会讨论引导程序，因为我们会留到后面再讲。
- en: All right—if you're ready, let's get started.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 好了——如果你准备好了，我们就开始吧。
- en: Technical requirements
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: The technical requirements are the same as always—just have an Ubuntu and an
    Alma **virtual machine** (**VM**) fired up so that you can follow along.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 技术要求和以往一样——只需启动一个Ubuntu和一个Alma **虚拟机** (**VM**)，这样你就可以跟着操作。
- en: 'Check out the following link to see the Code in Action video: [https://bit.ly/3phdZ6o](https://bit.ly/3phdZ6o)'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 请查看以下链接，观看《代码实战》视频：[https://bit.ly/3phdZ6o](https://bit.ly/3phdZ6o)
- en: Comparing SysV bootup and systemd bootup
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 比较SysV启动和systemd启动
- en: Computer bootups all start pretty much the same way, regardless of which operating
    system is running. You turn on the power switch, then the machine's `systemd`
    bootup sequence.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 不管运行哪个操作系统，计算机的启动过程基本上都是一样的。你打开电源开关，然后进入机器的`systemd`启动序列。
- en: Understanding SysV and systemd bootup similarities
  id: totrans-13
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 理解SysV和systemd启动过程的相似性
- en: Once the machine can access the MBR of the machine's drive, the operating system
    begins to load. In the `/boot/` directory, you'll see a compressed Linux kernel
    file that generally has `vmlinuz` in its filename. You'll also see an `initramfs`
    or `initrd` in its filename. The first step of this process is for the Linux kernel
    image to get uncompressed and loaded into the system memory. At this stage, the
    kernel still can't access the root filesystem because it can't access the proper
    drivers for it. These drivers are in the initial RAM disk image. So, the next
    step is to load this initial RAM disk image, which will establish a temporary
    root filesystem that the kernel can access. Once the kernel has loaded the proper
    drivers, the image will unload. The boot process will then continue by accessing
    whatever it needs to access on the machine's root filesystem.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦机器能够访问到机器硬盘的MBR，操作系统就开始加载。在`/boot/`目录中，你会看到一个压缩的Linux内核文件，文件名通常包含`vmlinuz`。你还会看到文件名中有`initramfs`或`initrd`。该过程的第一步是将Linux内核镜像解压并加载到系统内存中。在此阶段，内核仍然无法访问根文件系统，因为它无法访问所需的驱动程序。这些驱动程序位于初始RAM磁盘镜像中。所以，下一步是加载这个初始RAM磁盘镜像，它将建立一个内核可以访问的临时根文件系统。一旦内核加载了适当的驱动程序，镜像将被卸载。启动过程接着继续，访问机器根文件系统中的所需内容。
- en: After this, things get different. To show how, let's take a whirlwind tour of
    the SysV bootup process.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，情况就不同了。为了展示如何不同，让我们快速浏览一下SysV启动过程。
- en: Understanding the SysV bootup process
  id: totrans-16
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 理解SysV启动过程
- en: I'm not going to go deep into the details of the SysV bootup process because
    there's no need to. All I want to do is to show you enough information so that
    you can understand how it differs from the `systemd` bootup.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 我不会深入探讨SysV启动过程的细节，因为没有必要。我只想给你提供足够的信息，让你能理解它与`systemd`启动的不同之处。
- en: The `init` process, which is always `PID 1`), is the first process to start.
    This `init` process will control the rest of the boot sequence with a series of
    complex, convoluted bash shell scripts in the `/etc/` directory. At some point,
    the `init` process will obtain information about the default run level from the
    `/etc/inittab` file. Once the basic system initialization has been completed,
    system services will get started from bash shell scripts in the `/etc/init.d/`
    directory, as determined by what's enabled for the default runlevel.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: '`init` 进程（始终为 `PID 1`）是第一个启动的进程。这个 `init` 进程将通过一系列复杂的、盘根错节的 bash 脚本来控制其余的启动过程，这些脚本位于
    `/etc/` 目录下。在某个时刻，`init` 进程将从 `/etc/inittab` 文件中获取关于默认运行级别的信息。一旦基本系统初始化完成，系统服务将根据默认运行级别启用的内容，从
    `/etc/init.d/` 目录下的 bash 脚本启动。'
- en: Bootups on a SysV machine can be rather slow because everything gets started
    in a serial mode—in other words, SysV can only start one service at a time during
    bootup. Of course, I may have made SysV sound worse than it really is. Although
    it's outdated by today's standards, it did work well for the hardware of its time.
    I mean, when you're talking about a server that's running with a pair of single-core
    750 **megahertz** (**MHz**) Pentium III processors and 512 **megabytes** (**MB**)
    of memory, there's not much you can do to speed it up in any case. (I still have
    a few of those old machines in my collection, but I haven't booted them up in
    ages.)
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 在 SysV 机器上，启动过程可能相当慢，因为所有服务都是串行启动的——换句话说，SysV 在启动时一次只能启动一个服务。当然，我可能把 SysV 描述得比实际情况更糟糕了。尽管按今天的标准它已经过时，但在其时代，它确实能很好地与当时的硬件配合工作。我的意思是，当你谈论的是一台配备单核
    750 **兆赫** (**MHz**) Pentium III 处理器和 512 **兆字节** (**MB**) 内存的服务器时，反正没有太多办法能加快它的速度。（我现在还收藏着几台这样的旧机器，但已经很久没启动过它们了。）
- en: As I said, this is a whirlwind tour. For our present purposes, this is all you
    need to know about SysV bootup. So, let's leave this topic and look at how the
    `systemd` bootup process works.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我所说的，这只是一次快速的概览。就我们当前的目的来说，这就是你需要了解的关于 SysV 启动的所有内容。接下来，让我们跳过这个话题，看看 `systemd`
    启动过程是如何工作的。
- en: Understanding the systemd bootup process
  id: totrans-21
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 理解 systemd 启动过程
- en: 'With `systemd`, the `systemd` process is the first process to start. It also
    runs as `PID 1`, as you can see here on the Alma machine:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `systemd` 中，`systemd` 进程是第一个启动的进程。它也以 `PID 1` 运行，就像我们在 Alma 机器上看到的那样：
- en: '[PRE0]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Curiously, `PID 1` still shows up as the `init` process on the Ubuntu machine,
    as we see here:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 奇怪的是，在 Ubuntu 机器上，`PID 1` 仍然显示为 `init` 进程，就像我们在这里看到的那样：
- en: '[PRE1]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'This is because the Ubuntu developers, for some bizarre reason, created an
    `init` symbolic link that points to the `systemd` executable, as we see here:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 这是因为 Ubuntu 开发者出于某种奇怪的原因，创建了一个指向 `systemd` 可执行文件的 `init` 符号链接，正如我们在这里看到的：
- en: '[PRE2]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: I have no idea why the Ubuntu developers thought they needed to do that. It
    works though, so it's all good.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 我不知道为什么 Ubuntu 开发者认为有必要这样做。不过它确实能工作，所以没问题。
- en: 'Instead of running complex bash shell scripts to initialize the system, `systemd`
    runs targets. It starts by looking at the `default.target` file to see if it''s
    set to `graphical` or `multi-user`. As I pointed out in [*Chapter 6*](B17491_06_Final_NM_ePub.xhtml#_idTextAnchor077),
    *Understanding systemd Targets*, there''s a chain of dependencies that begins
    with whatever the default target is and stretches backward. Let''s say that our
    machine has the graphical target set as its default. In the `graphical.target`
    file, we see the following line:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 与运行复杂的 bash 脚本初始化系统不同，`systemd` 运行目标（targets）。它首先查看 `default.target` 文件，检查它是设置为
    `graphical` 还是 `multi-user`。正如我在 [*第六章*](B17491_06_Final_NM_ePub.xhtml#_idTextAnchor077)
    中提到的，*理解 systemd 目标*，依赖关系链从默认目标开始并向后延伸。假设我们的机器将图形目标设为默认。在 `graphical.target` 文件中，我们会看到以下一行：
- en: '[PRE3]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'This means that the graphical target can''t start until after the multi-user
    target has started. In the `multi-user.target` file, we see this line:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着图形目标必须等到多用户目标启动后才能启动。在 `multi-user.target` 文件中，我们看到这一行：
- en: '[PRE4]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Now, if we keep tracing this chain back to its origin, we'll see that the basic
    target *Requires* the `sysinit.target` file, which in turn *Wants* the `local-fs.target`
    file, which in turn starts `after` the `local-fs-pre.target` file.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果我们继续追溯这个链条的起源，我们会发现基本目标 *Requires* `sysinit.target` 文件，而该文件又 *Wants* `local-fs.target`
    文件，后者会在 `local-fs-pre.target` 文件之后启动。
- en: 'So, what does all this mean? Well, it''s just that once the `systemd` process
    has determined what the default target is, it starts loading the bootup targets
    in the following order:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，这一切到底意味着什么呢？实际上，一旦`systemd`进程确定了默认目标，它会按照以下顺序加载启动目标：
- en: '`local-fs-pre.target`'
  id: totrans-35
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`local-fs-pre.target`'
- en: '`local-fs.target`'
  id: totrans-36
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`local-fs.target`'
- en: '`sysinit.target`'
  id: totrans-37
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`sysinit.target`'
- en: '`basic.target`'
  id: totrans-38
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`basic.target`'
- en: '`multi-user.target`'
  id: totrans-39
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`multi-user.target`'
- en: '`graphical.target` (if enabled)'
  id: totrans-40
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`graphical.target`（如果启用了的话）'
- en: 'Okay—I know. You''re now yelling: *But Donnie. You said that systemd starts
    its processes in parallel, not in sequence.* Indeed, `systemd` does start its
    bootup processes in parallel. Remember what I told you before. A target is a *collection*
    of other `systemd` units that are grouped together for a particular purpose. Within
    each target, processes start up in parallel.'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 好的—我知道了。你现在可能在喊：*但是Donnie，你说过systemd是并行启动进程，而不是按顺序启动的。* 的确，`systemd`会并行启动它的启动进程。记住我之前告诉过你的，目标是一个*集合*，由其他`systemd`单元组成，目的是为了特定的功能。在每个目标内，进程是并行启动的。
- en: Note
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: You can see a graphical representation of this bootup chain on the `bootup`
    man page.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在`bootup`手册页上看到这个启动链的图形化表示。
- en: 'I''ve also pointed out before that some of these targets are hardcoded into
    the `systemd` executable file. This means that some of these targets don''t have
    their own `.target` files, and others have `.target` files that seem to not do
    anything. There are a few ways to see what''s going on with these hardcoded targets.
    The first way is to look at a target with `systemctl list-dependencies`. Here''s
    what we see when we look at the `local-fs.target` file:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 我之前也提到过，其中一些目标是硬编码到`systemd`可执行文件中的。这意味着其中一些目标没有自己的`.target`文件，而其他的则有`.target`文件，似乎没有任何作用。有几种方法可以查看这些硬编码目标的情况。第一种方法是使用`systemctl
    list-dependencies`查看目标。以下是查看`local-fs.target`文件时的输出：
- en: '[PRE5]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: This target starts the services that mount the filesystems. We see that it mounts
    the `boot` partition, which is represented by `boot.mount`. It then mounts the
    `root` filesystem, which is represented by `-.mount`.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 这个目标启动了挂载文件系统的服务。我们看到它挂载了`boot`分区，表示为`boot.mount`。然后它挂载了`root`文件系统，表示为`-.mount`。
- en: 'I showed you before how to look at a list of targets that are hardcoded into
    the `systemd` executable file. We can also look for information that''s specific
    to just one target. Here''s how that looks for the `local-fs.target` file:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 我之前向你展示过如何查看硬编码到`systemd`可执行文件中的目标列表。我们也可以查找仅针对某个目标的特定信息。以下是查看`local-fs.target`文件的方式：
- en: '[PRE6]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: By default, `grep` only shows the line in which it finds the search term that
    you specify. The `-A` option makes it show a specified number of lines that come
    after the line in which the search term is found. The `-A 100` option that I'm
    using here tells `grep` to show me the next 100 lines that follow the line that
    contains `local-fs.target`. We don't see the exact program code like this, but
    the embedded text strings do give us some sense of what's going on. My choice
    of 100 lines was completely arbitrary, but you can keep increasing that if you
    like, until you start seeing lines that have nothing to do with mounting filesystems.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，`grep`只会显示它找到搜索词的行。`-A`选项使它显示搜索词所在行后指定数量的行。我这里使用的`-A 100`选项告诉`grep`显示`local-fs.target`所在行后面的100行。虽然我们看不到具体的程序代码，但嵌入的文本字符串能让我们大致了解发生了什么。我的100行选择完全是随意的，但你可以根据需要增加行数，直到看到与挂载文件系统无关的行。
- en: A third way to get information about these hardcoded targets is to look at the
    `bootup` and the `systemd.special` man pages. Neither of these man pages gives
    much detail, but you still might learn a little something from them.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 获取这些硬编码目标的第三种方式是查看`bootup`和`systemd.special`的手册页。虽然这两个手册页没有提供太多细节，但你仍然可以从中学到一些东西。
- en: Now, with this out of the way, let's look at how to analyze bootup problems.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，问题解决后，我们来看一下如何分析启动问题。
- en: Analyzing bootup performance
  id: totrans-52
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 分析启动性能
- en: Let's say that your server is taking longer than you think it should to boot
    up, and you want to know why. Fortunately, `systemd` comes with the built-in `systemd-analyze`
    tool that can help.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你的服务器启动时间比预期的要长，你想知道为什么。幸运的是，`systemd`附带了内置的`systemd-analyze`工具，可以帮助你。
- en: 'Let''s start by looking here at how long it took to boot up my AlmaLinux machine
    with its GNOME 3 desktop:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从这里开始，看看我的AlmaLinux机器启动GNOME 3桌面的时间：
- en: '[PRE7]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: If you don't specify an option, `systemd-analyze` just uses the `time` option.
    (You can type in `systemd-analyze time` if you really want to, but you'll get
    the same results that you see here.) The first line of output shows how long it
    took for the kernel, the initial RAM disk image, and the user space to load. The
    second line shows how long it took for the graphical target to come up. In reality,
    the total bootup time doesn't look too bad, especially when you consider the age
    of the host machine that I'm using to run this VM. (This host machine is a 2009-or-so
    vintage Dell, running with an old-fashioned Core 2 Quad **central processing unit**
    (**CPU**).) If I were either running this VM on a newer model host or running
    Alma on bare metal, the bootup time could possibly be a bit quicker. There's also
    the fact that this VM is running with the GNOME 3 desktop environment, which is
    somewhat resource-intensive. I personally prefer lighter-weight desktops, which
    could possibly cut the bootup time down a bit. Unfortunately, **Red Hat Enterprise
    Linux 8** (**RHEL 8**) and all of its free-of-charge offspring only come with
    GNOME 3\. (It is possible to install the lightweight **XForms Common Environment**
    (**XFCE**) desktop if you have the third-party **Extra Packages for Enterprise
    Linux** (**EPEL**) repository installed, but that's beyond the scope of this book.)
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你没有指定选项，`systemd-analyze`将默认使用`time`选项。（你如果真的想，也可以输入`systemd-analyze time`，但你会看到与这里相同的结果。）输出的第一行显示了内核、初始RAM磁盘镜像和用户空间加载所需的时间。第二行显示了图形目标启动所需的时间。实际上，整体启动时间看起来并不算太差，特别是考虑到我用来运行这个虚拟机的主机的年代。（这台主机大约是2009年左右的戴尔，搭载的是一颗老式的Core
    2 Quad **中央处理器**（**CPU**）。）如果我在一台较新的主机上运行这个虚拟机，或者直接在裸机上运行Alma，启动时间可能会稍微快一点。还有一个因素是，这个虚拟机运行的是资源消耗较大的GNOME
    3桌面环境。我个人更喜欢轻量级的桌面环境，可能会稍微缩短启动时间。不幸的是，**Red Hat Enterprise Linux 8**（**RHEL 8**）及其所有免费的子版本仅提供GNOME
    3桌面环境。（如果你安装了第三方的**Extra Packages for Enterprise Linux**（**EPEL**）库，确实可以安装轻量级的**XForms
    Common Environment**（**XFCE**）桌面，但这超出了本书的范围。）
- en: 'Now, let''s say that the bootup process on this machine really is too slow,
    and you want to speed it up if possible. First, let''s use the `blame` option
    to see who we want to *blame*:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，假设这台机器的启动过程确实太慢了，如果可能的话你想加速它。首先，我们使用`blame`选项来查看我们要*责怪*谁：
- en: '[PRE8]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'This `blame` option shows you all of the services that got started during the
    bootup, along with the time it took to start each service. The services are listed
    in descending order of how long it took each one to start. Look through the whole
    list, and see if there are any services that you can safely disable. For example,
    further down the list, you''ll see that the `wpa_supplicant.service` is running,
    as I show you here:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 这个`blame`选项会显示在启动过程中所有已启动的服务，以及每个服务启动所需的时间。服务按启动所需时间的降序排列。查看整个列表，看看是否有你可以安全禁用的服务。例如，在列表的下方，你会看到`wpa_supplicant.service`正在运行，正如我在这里所示：
- en: '[PRE9]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: That's great if you're working with either a desktop machine or a laptop where
    you might need to use a wireless adapter, but it's not necessary on a server that
    doesn't have wireless. So, you might consider disabling this service. (Of course,
    this service only took 710 **milliseconds** (**ms**) to start, but that's still
    something.)
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你使用的是桌面计算机或笔记本电脑，并且可能需要使用无线适配器，这样做是很好的，但如果是在没有无线功能的服务器上，则没有必要。因此，你可以考虑禁用这个服务。（当然，这个服务启动只用了710
    **毫秒**（**ms**），但这仍然是个时间。）
- en: Note
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Disabling unnecessary services is good for both performance and security. A
    basic tenet of security that's been around forever is that you should always minimize
    the number of running services on your system. This provides potential attackers
    with fewer attack vectors.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 禁用不必要的服务对性能和安全性都有好处。一个一直存在的安全基本原则是，你应该始终最小化系统上运行的服务数量。这可以减少潜在攻击者的攻击路径。
- en: 'If you want to see how long it took for each target to start during bootup,
    use the `critical-chain` option, like this:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想查看每个目标在启动过程中花了多长时间，可以使用`critical-chain`选项，如下所示：
- en: '[PRE10]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: For formatting reasons, I can only show you a small portion of the output, so
    try it for yourself to see how the whole thing looks.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 由于格式原因，我只能向你展示输出的一个小部分，所以请自己尝试一下，看看完整的输出内容。
- en: These commands work the same on an Ubuntu machine as they do here on the Alma
    machine, but there are a few differences with how the default target is set up
    on Ubuntu Server 20.04\. So, let's look at that.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 这些命令在 Ubuntu 机器上与在 Alma 机器上执行时相同，但在 Ubuntu Server 20.04 上默认目标的设置有所不同。让我们来看一下。
- en: Some differences on Ubuntu Server 20.04
  id: totrans-68
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Ubuntu Server 20.04 的一些差异
- en: 'My Ubuntu Server 20.04 machine, which runs purely in text mode, boots considerably
    faster, as you can see here:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 我的 Ubuntu Server 20.04 机器，完全以文本模式运行，启动速度明显更快，正如你在这里看到的：
- en: '[PRE11]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'I must confess that I haven''t worked that much with Ubuntu Server 20.04 since
    it''s been out, and I still encounter some new things about it that surprise me.
    Before I set up the VMs for this chapter, I had never before noticed that Ubuntu
    Server 20.04 comes with `graphical.target` as the default, even though no graphical
    interface is installed. The explanation for that is that the `accounts-daemon.service`
    file gets started by the graphical target, not by the multi-user target, as we
    can see here:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 我必须承认，自从 Ubuntu Server 20.04 发布以来，我并没有使用太多，我仍然会遇到一些让我惊讶的新特性。在为本章配置虚拟机之前，我从未注意到
    Ubuntu Server 20.04 默认使用 `graphical.target`，尽管没有安装图形界面。解释是，`accounts-daemon.service`
    文件是由图形目标启动的，而不是由多用户目标启动的，正如我们在这里看到的：
- en: '[PRE12]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'If you look in the `graphical.target` file, you''ll see that it only *Wants*
    the `display-manager.service` file and doesn''t *Require* it, as evidenced by
    this line:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你查看 `graphical.target` 文件，你会看到它只*想要* `display-manager.service` 文件，而不是*要求*它，正如这行所示：
- en: '[PRE13]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: So, even though the display manager doesn't exist on this VM, it still goes
    into the `graphical.target` just fine. But, let's get back to that `accounts-daemon.service`
    file. What is it, exactly? Well, according to the official documentation at [https://www.freedesktop.org/wiki/Software/AccountsService/](https://www.freedesktop.org/wiki/Software/AccountsService/),
    "*AccountsService is a D-Bus service for accessing the list of user accounts and
    information attached to those accounts.*" Yeah, I know—that isn't much of an explanation.
    A better explanation is that it's a service that allows you to manage users and
    user accounts from **graphical user interface** (**GUI**)-type utilities. So,
    why do we have it enabled on Ubuntu Server when there's no graphical interface?
    That's a good question, to which I don't have a good answer. It's not something
    that we need running on a text-mode server. That's okay, though. We'll take care
    of that in just a bit.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，即使该虚拟机上没有显示管理器，它仍然能够顺利进入 `graphical.target`。但让我们回到那个 `accounts-daemon.service`
    文件。它到底是什么呢？根据 [https://www.freedesktop.org/wiki/Software/AccountsService/](https://www.freedesktop.org/wiki/Software/AccountsService/)
    上的官方文档，"*AccountsService 是一个 D-Bus 服务，用于访问用户账户及与这些账户相关的信息。*" 是的，我知道——这并不是一个很好的解释。更好的解释是，它是一个服务，允许你通过
    **图形用户界面**（**GUI**）类型的工具来管理用户和用户账户。那么，为什么在没有图形界面的情况下，我们会在 Ubuntu Server 上启用它呢？这是个好问题，我没有一个很好的答案。这不是我们需要在文本模式服务器上运行的东西。不过，没关系，我们马上就会处理这个问题。
- en: So now, what's D-Bus?
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，D-Bus 到底是什么？
- en: '`accounts-daemon.service` file is one service that''s meant to be started by
    D-Bus messages. We can see that here in the `Type=dbus` line of the `[Service]`
    section of the `accounts-daemon.service` file:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: '`accounts-daemon.service` 文件是一个服务，旨在通过 D-Bus 消息启动。我们可以在 `accounts-daemon.service`
    文件的 `[Service]` 部分的 `Type=dbus` 行中看到这一点：'
- en: '[PRE14]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'However, we see here in the `[Install]` section that we''re still going to
    start this service during the bootup process for performance reasons:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，我们在 `[Install]` 部分看到，出于性能原因，我们仍然会在启动过程中启动这个服务：
- en: '[PRE15]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: (The `gdm` that's mentioned here stands for **GNOME Display Manager**, which
    handles user login operation for systems with the GNOME 3 desktop.)
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: （这里提到的 `gdm` 代表 **GNOME 显示管理器**，它负责具有 GNOME 3 桌面系统的用户登录操作。）
- en: 'As I said before, we don''t need this `accounts-daemon.service` file to run
    on a text-mode server. So, let''s set the `default.target` file to `multi-user`
    for this Ubuntu machine, which will prevent the `accounts-daemon.service` file
    from automatically starting when we boot up the machine. As you might remember,
    this is the command to do that:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 如我之前所说，我们不需要在文本模式服务器上运行这个 `accounts-daemon.service` 文件。所以，让我们将这个 Ubuntu 机器的
    `default.target` 文件设置为 `multi-user`，这将阻止 `accounts-daemon.service` 文件在我们启动机器时自动启动。你可能记得，这是执行该操作的命令：
- en: '[PRE16]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: When you reboot the machine now, you should see it boot a bit faster. On the
    off-chance that the `accounts-daemon.service` ever is needed, a D-Bus message
    would start it.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，当你重新启动机器时，你应该会发现它启动得更快。万一`accounts-daemon.service`被需要，D-Bus消息会启动它。
- en: Out of curiosity, I created a new AlmaLinux VM without the GNOME desktop, to
    see if it would also default to `graphical.target`. It turned out that that Alma
    without GNOME defaults to `multi-user.target` and doesn't even install the `AccountsService`
    package. (So, without GUI-type user management utilities, the `accounts-daemon.service`
    file isn't even needed.)
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 出于好奇，我创建了一个没有GNOME桌面的全新AlmaLinux虚拟机，看看它是否也会默认使用`graphical.target`。结果发现没有GNOME的Alma默认使用`multi-user.target`，并且甚至没有安装`AccountsService`包。（因此，没有GUI类型的用户管理工具，`accounts-daemon.service`文件甚至不需要。）
- en: Next, let's *generate* some real excitement with `systemd` generators.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们用`systemd`生成器*激发*一些真正的兴奋。
- en: Understanding systemd generators
  id: totrans-87
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解systemd生成器
- en: '`systemd` generators can make life somewhat easier for a busy administrator
    and also provide some backward compatibility with legacy SysV stuff. Let''s first
    look at how generators make disk and partition configuration easier.'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: '`systemd`生成器可以让忙碌的管理员的工作变得更轻松，还能提供与传统SysV的向后兼容性。我们首先来看看生成器如何简化磁盘和分区配置。'
- en: Understanding mount units
  id: totrans-89
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 理解挂载单元
- en: 'Look in the `/lib/systemd/system/` directory of either VM, and you''ll see
    several mount unit files that got created when you installed the operating system,
    as shown here on this Alma machine:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 查看任一虚拟机的`/lib/systemd/system/`目录，你会看到在安装操作系统时创建的几个挂载单元文件，下面是这台Alma机器的示例：
- en: '[PRE17]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'All of these mount units, except for the `tmp.mount` file, are for kernel functions
    and have nothing to do with the drives and partitions that we want to mount. Unlike
    Ubuntu, Alma mounts the `/tmp/` directory on its own partition, which is why you
    don''t see the `tmp.mount` file on the Ubuntu machine. Let''s peek inside the
    `tmp.mount` file to see what''s there. Here''s the `[Unit]` section:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 除了`tmp.mount`文件外，所有这些挂载单元都是内核功能，与我们想要挂载的磁盘和分区无关。与Ubuntu不同，Alma将`/tmp/`目录挂载在自己的分区上，这也是为什么在Ubuntu机器上看不到`tmp.mount`文件的原因。让我们瞥一眼`tmp.mount`文件，看看里面有什么。这里是`[Unit]`部分：
- en: '[PRE18]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: The `ConditionPathIsSymbolicLink=!/tmp` line prevents the system from mounting
    `/tmp/` if `/tmp` is found to be a symbolic link instead of the actual `mount`
    point directory. (Remember that the `!` sign negates an operation.) We then see
    that this mount unit `Conflicts` with the `umount.target` file, which means that
    a `umount` operation will *unmount* `/tmp/`.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: '`ConditionPathIsSymbolicLink=!/tmp`行防止系统挂载`/tmp/`，如果`/tmp`被发现是一个符号链接而不是实际的`mount`点目录。（记住，`!`符号表示否定操作。）接下来我们看到该挂载单元与`umount.target`文件存在`Conflicts`，这意味着`umount`操作将*卸载*`/tmp/`。'
- en: 'Next, let''s see what''s in the `[Mount]` section:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们来看看`[Mount]`部分的内容：
- en: '[PRE19]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'The `What=` and `Type=` lines denote this as a *temporary filesystem*. The
    `Where=` line defines the mountpoint directory. Finally, there''s the `Options=`
    line, with the following options:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: '`What=`和`Type=`行表示这是一个*临时文件系统*。`Where=`行定义了挂载点目录。最后是`Options=`行，其中包含以下选项：'
- en: '`mode=1777`: This sets the permissions value for the mountpoint directory.
    The `777` part sets full read, write, and execute permissions for everybody. The
    `1` part sets the *sticky bit*, which prevents users from deleting each others''
    files.'
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`mode=1777`：这个选项设置了挂载点目录的权限值。`777`部分为所有人设置了完全的读、写和执行权限。`1`部分设置了*粘滞位*，它防止用户删除彼此的文件。'
- en: '`strictatime`: This causes the kernel to maintain full access-time (`atime`)
    updates on all files on this partition.'
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`strictatime`：这个选项使得内核在此分区上的所有文件上保持完整的访问时间（`atime`）更新。'
- en: '`nosuid`: If any files on this partition have the **Set User ID** (**SUID**)
    bit set, this option prevents SUID from doing anything. (The SUID bit is a way
    to escalate privileges for non-privileged users and can be a security problem
    if it''s set on files that shouldn''t have it.)'
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`nosuid`：如果此分区上的任何文件设置了**设置用户ID**（**SUID**）位，此选项会阻止SUID执行任何操作。（SUID位是一种提升非特权用户权限的方式，如果它被设置在不应设置的文件上，可能会成为安全问题。）'
- en: '`nodev`: This security feature prevents the system from recognizing any character
    device or block device files that might be on this partition. (You should only
    see device files in the `/dev/` directory.)'
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`nodev`：这个安全功能防止系统识别此分区上的任何字符设备或块设备文件。（你应该只在`/dev/`目录下看到设备文件。）'
- en: 'Finally, we have the `[Install]` section, which looks like this:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们有`[Install]`部分，内容如下：
- en: '[PRE20]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: So, this partition gets mounted by the `local-fs.target` file, right at the
    beginning of the bootup process.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，这个分区是在启动过程一开始通过 `local-fs.target` 文件挂载的。
- en: 'Okay—you now have a basic understanding of what a mount unit file looks like.
    You''re now wondering: *Where are the mount unit files for our normal disk partitions?*
    Ah, I''m glad you asked.'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 好的——现在你已经基本了解了挂载单元文件的样子。你现在可能在想：*我们的普通磁盘分区的挂载单元文件在哪儿？* 啊，我很高兴你问了。
- en: 'It is possible to manually create mount unit files for your normal disk partitions,
    but it isn''t necessary. In fact, the `systemd.mount` man page recommends against
    this. Under the `FSTAB` section of this man page, you''ll see that it''s both
    possible and *recommended* to configure partitions in the `/etc/fstab` file, just
    like you''ve always done. A `systemd` generator will dynamically create the appropriate
    mount unit files, based on the information that''s in the `fstab` file. For example,
    here''s the `fstab` file from the Alma machine:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然可以手动为你的普通磁盘分区创建挂载单元文件，但这并非必要。事实上，`systemd.mount` 的手册页不推荐这样做。在该手册页的 `FSTAB`
    部分，你会看到，配置 `/etc/fstab` 文件中的分区是完全可能的，而且是*推荐*的，和你以往的做法一样。`systemd` 生成器会根据 `fstab`
    文件中的信息动态生成适当的挂载单元文件。例如，这是 Alma 机器的 `fstab` 文件：
- en: '[PRE21]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: The two `/dev/mapper` lines indicate that the root filesystem partition and
    the swap partition are mounted as logical volumes. We also see that the root partition
    is formatted as an `xfs` partition. The `UUID=` line indicates that the `/boot/`
    partition is mounted as a normal partition that's designated by its **universally
    unique identifier** (**UUID**) number. (That makes sense because Linux systems
    can't boot from a logical volume.)
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 这两行 `/dev/mapper` 表示根文件系统分区和交换分区以逻辑卷的形式挂载。我们还看到根分区格式化为 `xfs` 分区。`UUID=` 行表示
    `/boot/` 分区以普通分区的形式挂载，并由其**全局唯一标识符**（**UUID**）编号标识。（这很有道理，因为 Linux 系统无法从逻辑卷启动。）
- en: 'Okay—the SysV system would just take the information from the `fstab` file
    and use it directly. As I''ve already indicated, `systemd` will take this information
    and use it to dynamically generate the mount unit files under the `/run/systemd/generator/`
    directory, as we see here:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 好的——SysV 系统会直接从 `fstab` 文件获取信息并加以使用。正如我之前提到的，`systemd` 会使用这些信息并动态生成挂载单元文件，这些文件位于
    `/run/systemd/generator/` 目录下，正如我们在这里看到的：
- en: '[PRE22]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'It''s fairly obvious which of these files correspond to the `/boot/` and `swap`
    partitions. What isn''t so obvious is that the `-.mount` file corresponds to the
    root filesystem partition. Let''s peek into the `boot.mount` file to see what''s
    there:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 很明显，这些文件中哪些是对应 `/boot/` 和 `swap` 分区的。不是那么明显的是，`-.mount` 文件对应的是根文件系统分区。让我们来看一下
    `boot.mount` 文件，看看里面有什么：
- en: '[PRE23]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: From what you've already seen in the previous example and in the `fstab` file,
    you should be able to figure out what's going on here.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 从你在之前的示例和 `fstab` 文件中看到的内容，你应该能搞明白这里发生了什么。
- en: 'You might want to see what''s in the `-.mount` file, but you can''t do that
    the normal way. If you try it, you''ll get this:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能想看看 `-.mount` 文件里面的内容，但你不能像平常那样去查看。如果你尝试的话，会得到如下结果：
- en: '[PRE24]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'This will happen regardless of which command-line utility you try. That''s
    because the `–` sign that''s in the prefix of the filename makes the Bash shell
    think that we''re dealing with an option switch. To make this work, just precede
    the filename with `./` so that you''ll be working with an absolute path. The command
    will look like this:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 无论你尝试哪种命令行工具，这都会发生。这是因为文件名前缀中的 `–` 符号使得 Bash shell 认为我们正在处理一个选项开关。要使其正常工作，只需在文件名前加上
    `./`，这样你就会使用绝对路径。命令看起来会是这样的：
- en: '[PRE25]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Okay—I think that covers it for the mount units. Let's shift over to the Ubuntu
    Server 20.04 machine and check out one of the backward-compatibility features
    of `systemd`.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 好的——我想这已经涵盖了挂载单元的内容。现在让我们切换到 Ubuntu Server 20.04 机器，查看 `systemd` 的一个向后兼容性功能。
- en: Understanding backward compatibility
  id: totrans-119
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 理解向后兼容性
- en: 'You can also use `systemd` generators to control services from old-fashioned
    SysV `init` scripts. You won''t see much of that with Red Hat-type systems, but
    you will with Debian and Ubuntu systems. (For some strange reason, the Debian
    and Ubuntu maintainers still haven''t converted all of their services over to
    native `systemd` services.) To demonstrate, disable and stop the normal `ssh`
    service on the Ubuntu machine by doing:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以使用 `systemd` 生成器来控制来自老式 SysV `init` 脚本的服务。你在 Red Hat 类型的系统上可能不会看到这种情况，但在
    Debian 和 Ubuntu 系统上会看到。（出于某些奇怪的原因，Debian 和 Ubuntu 的维护者仍然没有将所有服务转换为原生的 `systemd`
    服务。）为了演示，可以通过以下方式禁用并停止 Ubuntu 机器上的正常 `ssh` 服务：
- en: '[PRE26]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Next, install `Dropbear`, which is a lightweight replacement for the normal
    OpenSSH package. Do that with the following two commands:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，安装 `Dropbear`，它是一个轻量级的替代 OpenSSH 的包。可以通过以下两条命令来安装：
- en: '[PRE27]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'When the installation completes, you should see that the Dropbear service is
    already enabled and running:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 安装完成后，你应该能看到 Dropbear 服务已经启用并正在运行：
- en: '[PRE28]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'So far, everything looks normal, except for the part about how it loaded the
    service from the `/etc/init.d/dropbear` `init` script. If you look for a `dropbear.service`
    file in the `/lib/systemd/system/` directory, you won''t find it. Instead, you''ll
    see the `dropbear` `init` script in the `/etc/init.d/` directory:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，一切看起来都正常，除了它如何通过 `/etc/init.d/dropbear` 的 `init` 脚本加载服务这一部分。如果你在 `/lib/systemd/system/`
    目录下查找 `dropbear.service` 文件，你是找不到的。相反，你会在 `/etc/init.d/` 目录下看到 `dropbear` 的 `init`
    脚本：
- en: '[PRE29]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'When the Dropbear service starts, `systemd` will generate a `dropbear.service`
    file in the `/run/systemd/generator.late/` directory, as you see here:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 当 Dropbear 服务启动时，`systemd` 会在 `/run/systemd/generator.late/` 目录下生成一个 `dropbear.service`
    文件，如下所示：
- en: '[PRE30]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'This file isn''t permanently saved to disk and only lasts as long as the system
    is running. Look inside, and you''ll see that it''s just a normal service unit
    file:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 这个文件并不是永久保存到磁盘的，它仅在系统运行时有效。查看文件，你会看到它只是一个普通的服务单元文件：
- en: '![](img/Figure_8.1_B17491.jpg)'
  id: totrans-131
  prefs: []
  type: TYPE_IMG
  zh: '![](img/Figure_8.1_B17491.jpg)'
- en: Figure 8.1 – A generated service file for the Dropbear service
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.1 – 生成的 Dropbear 服务文件
- en: Okay—maybe it's not *completely* normal. (I have no idea why it lists the `Before=multi-user.target`
    line three different times.) Also, it's missing the `[Install]` section because
    this is actually meant to be a static service.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 好吧——也许这并不是 *完全* 正常。（我不明白为什么它会把 `Before=multi-user.target` 这一行列出三次。）此外，它缺少 `[Install]`
    部分，因为这个文件实际上是用于静态服务的。
- en: 'If you really want to, you can trick the system into creating a normal `dropbear.service`
    file in the `/etc/systemd/system/` directory, just by doing a normal `sudo systemctl
    edit --full dropbear` command. Delete the `SourcePath=/etc/init.d/dropbear` line
    from the `[Unit]` section because you no longer need it. Next, insert the following
    line into the `[Service]` section:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你真的想要，你可以通过执行一个普通的 `sudo systemctl edit --full dropbear` 命令来让系统创建一个正常的 `dropbear.service`
    文件，放在 `/etc/systemd/system/` 目录下。删除 `[Unit]` 部分中的 `SourcePath=/etc/init.d/dropbear`
    行，因为你不再需要它。接着，将以下行插入到 `[Service]` 部分：
- en: '[PRE31]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: This will allow you to set certain Dropbear parameters in the `/etc/default/dropbear`
    file, which is already there. (Look at the `Dropbear` man page to see which options
    you can set.)
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 这将允许你在 `/etc/default/dropbear` 文件中设置某些 Dropbear 参数，该文件已经存在。（查看 `Dropbear` 手册页以了解可以设置哪些选项。）
- en: 'Then, add the `[Install]` section, which will look like this:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，添加 `[Install]` 部分，看起来应该像这样：
- en: '[PRE32]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Save the file and do a `sudo systemctl daemon-reload` command. Then, enable
    Dropbear and reboot the VM to verify that it works. Finally, look in the `/run/systemd/generator.late/`
    directory. You'll see that the `dropbear.service` file is no longer there because
    `systemd` is no longer using the `dropbear` `init` script. Instead, it's using
    the `dropbear.service` file that you just created in the `/etc/systemd/system/`
    directory. If you need to, you can now edit this service file the same way that
    you'd edit any other service file.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 保存文件并执行 `sudo systemctl daemon-reload` 命令。然后，启用 Dropbear 并重新启动虚拟机以验证它是否正常工作。最后，查看
    `/run/systemd/generator.late/` 目录。你会发现 `dropbear.service` 文件不再存在，因为 `systemd`
    不再使用 `dropbear` 的 `init` 脚本。相反，它正在使用你刚刚在 `/etc/systemd/system/` 目录下创建的 `dropbear.service`
    文件。如果需要，你现在可以像编辑其他服务文件一样编辑这个服务文件。
- en: Summary
  id: totrans-140
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: Yes indeed, ladies and gents, we've once again covered a lot of ground and looked
    at some cool stuff. We started with an overview of the SysV and `systemd` boot
    processes, and then looked at some ways to analyze bootup performance. We then
    looked at an oddity about the Ubuntu Server bootup configuration. Finally, we
    wrapped things up by looking at two uses for `systemd` generators.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 是的，女士们，先生们，我们再次涵盖了很多内容并看到了很酷的东西。我们从SysV和`systemd`的启动过程概述开始，然后了解了一些分析启动性能的方法。接着，我们探讨了Ubuntu
    Server启动配置的一个特殊情况。最后，我们总结了`systemd`生成器的两个用途。
- en: In the next chapter, we'll use some `systemd` utilities to set certain system
    parameters. I'll see you there.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章，我们将使用一些`systemd`工具来设置某些系统参数。到时候见。
- en: Questions
  id: totrans-143
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: How does `systemd` handle a service that still uses an old-fashioned `init`
    script?
  id: totrans-144
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`systemd`如何处理仍然使用传统`init`脚本的服务？'
- en: a. It just uses the `init` scripts directly.
  id: totrans-145
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: a. 它直接使用`init`脚本。
- en: b. It creates and saves a service unit file in the `/etc/systemd/system/` directory.
  id: totrans-146
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: b. 它在`/etc/systemd/system/`目录下创建并保存一个服务单元文件。
- en: c. It dynamically generates a service unit file in the `/run/systemd/generator.late/`
    directory.
  id: totrans-147
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: c. 它会在`/run/systemd/generator.late/`目录中动态生成一个服务单元文件。
- en: d. It won't run a service that only has an `init` script.
  id: totrans-148
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: d. 它不会运行只有`init`脚本的服务。
- en: What is the recommended way of configuring disk partitions on a `systemd` machine?
  id: totrans-149
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`systemd`系统上，推荐的磁盘分区配置方式是什么？
- en: a. Manually create a mount unit file for each partition.
  id: totrans-150
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: a. 为每个分区手动创建挂载单元文件。
- en: b. Edit the `/etc/fstab` file as you normally would.
  id: totrans-151
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: b. 按照通常的方式编辑`/etc/fstab`文件。
- en: c. Manually create partition device files in the `/dev/` directory.
  id: totrans-152
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: c. 手动在`/dev/`目录下创建分区设备文件。
- en: d. Use the `mount` utility.
  id: totrans-153
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: d. 使用`mount`工具。
- en: Which of the following files represents the root filesystem?
  id: totrans-154
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下哪个文件代表根文件系统？
- en: a. `root.mount`
  id: totrans-155
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: a. `root.mount`
- en: b. `-.mount`
  id: totrans-156
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: b. `-.mount`
- en: c. `/.mount`
  id: totrans-157
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: c. `/.mount`
- en: d. `rootfs.mount`
  id: totrans-158
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: d. `rootfs.mount`
- en: Which of the following commands would show you how long each service takes to
    start during bootup?
  id: totrans-159
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下哪个命令可以显示每个服务在启动过程中需要的时间？
- en: a. `systemctl blame`
  id: totrans-160
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: a. `systemctl blame`
- en: b. `systemctl time`
  id: totrans-161
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: b. `systemctl time`
- en: c. `systemd-analyze`
  id: totrans-162
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: c. `systemd-analyze`
- en: d. `systemd-analyze time`
  id: totrans-163
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: d. `systemd-analyze time`
- en: e. `systemd-analyze blame`
  id: totrans-164
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: e. `systemd-analyze blame`
- en: Answers
  id: totrans-165
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 答案
- en: c
  id: totrans-166
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: c
- en: b
  id: totrans-167
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: b
- en: b
  id: totrans-168
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: b
- en: e
  id: totrans-169
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: e
- en: Further reading
  id: totrans-170
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 深入阅读
- en: 'D-Bus documentation:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: D-Bus文档：
- en: '[https://www.freedesktop.org/wiki/Software/dbus/](https://www.freedesktop.org/wiki/Software/dbus/)'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://www.freedesktop.org/wiki/Software/dbus/](https://www.freedesktop.org/wiki/Software/dbus/)'
- en: '`AccountsService` documentation:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: '`AccountsService`文档：'
- en: '[https://www.freedesktop.org/wiki/Software/AccountsService/](https://www.freedesktop.org/wiki/Software/AccountsService/)'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://www.freedesktop.org/wiki/Software/AccountsService/](https://www.freedesktop.org/wiki/Software/AccountsService/)'
- en: 'Cleaning up the Linux startup process:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 清理Linux启动过程：
- en: '[https://www.linux.com/topic/desktop/cleaning-your-linux-startup-process/](https://www.linux.com/topic/desktop/cleaning-your-linux-startup-process/)'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://www.linux.com/topic/desktop/cleaning-your-linux-startup-process/](https://www.linux.com/topic/desktop/cleaning-your-linux-startup-process/)'
