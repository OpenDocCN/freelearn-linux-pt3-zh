- en: '*Chapter 15*: Using the Reference Policy'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Up until now, we've covered how to interact with the SELinux subsystem and gradually
    adjusted the SELinux policy to our liking. As we add more applications and users,
    we notice that developing custom SELinux policies might help us tune the system
    more to our liking. There are two main approaches to develop SELinux policies,
    and using reference policy style development is one of them. The other is discussed
    in [*Chapter 16*](B16276_16_Final_VK.xhtml#_idTextAnchor391), *SELinux Common
    Intermediate Language*.
  prefs: []
  type: TYPE_NORMAL
- en: 'To properly develop an SELinux policy, we''ll learn how to use and understand
    the macros that the reference policy provides, and apply the main coding and development
    style patterns that the project requires to ensure consistency across SELinux
    policy modules. We then apply this to two main types of modules: application policies
    and user policies.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we''re going to cover the following main topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Introducing the reference policy
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using and understanding the policy macros
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating application-level policies
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Getting help with supporting tools
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The code files for this chapter can be found in our Git repository at [https://github.com/PacktPublishing/SELinux-System-Administration-Third-Edition](https://github.com/PacktPublishing/SELinux-System-Administration-Third-Edition).
  prefs: []
  type: TYPE_NORMAL
- en: 'Check out the following video to see the Code in Action: [https://bit.ly/3jcBDvI](https://bit.ly/3jcBDvI)'
  prefs: []
  type: TYPE_NORMAL
- en: Introducing the reference policy
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The reference policy, available through [https://github.com/SELinuxProject/refpolicy](https://github.com/SELinuxProject/refpolicy),
    is the source SELinux policy for most, if not all, Linux distributions out there.
    While it is possible that the plain reference policy will not work out of the
    box for any Linux distribution (as many Linux distributions add their own touch
    to the policy, or adjust it so it fits the applications and support tooling installed),
    the development methodology, structure, and approach used by the reference policy
    are applicable to all major distribution policies.
  prefs: []
  type: TYPE_NORMAL
- en: 'We recommend checking out the SELinux policy of your distribution to see and
    easily modify SELinux policies for the system. In this chapter, we''ll use a checkout
    of the reference policy:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'The SELinux policy repositories for the Linux distributions should be documented
    by the distributions themselves. A few example repositories are listed next:'
  prefs: []
  type: TYPE_NORMAL
- en: For CentOS, the policy repository can be found at [https://github.com/fedora-selinux/selinux-policy](https://github.com/fedora-selinux/selinux-policy).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For Gentoo Linux, the policy repository can be found at [https://gitweb.gentoo.org/proj/hardened-refpolicy.git/](https://gitweb.gentoo.org/proj/hardened-refpolicy.git/).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For Debian, the policy repository can be found at [https://salsa.debian.org/cgzones/selinux-policy-debian](https://salsa.debian.org/cgzones/selinux-policy-debian).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For Arch Linux, the policy repository can be found at [https://github.com/archlinuxhardened/selinux-policy-arch/](https://github.com/archlinuxhardened/selinux-policy-arch/).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If the Linux distribution does not have a publicly reachable repository for
    its SELinux policy, we can often still obtain it through the packages themselves,
    as used in [*Chapter 12*](B16276_12_Final_VK.xhtml#_idTextAnchor312), *Working
    with SELinux Policies*.
  prefs: []
  type: TYPE_NORMAL
- en: While it is not the intention to do full policy rebuilds, we can easily copy
    over the necessary policy files to our own development environment and fine-tune
    or extend the policy as needed.
  prefs: []
  type: TYPE_NORMAL
- en: Navigating the policy
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'At its base directory, the reference policy hosts all the common files for
    building the policies, explaining how to install them, and so forth. The policy
    itself is in the `policy` folder, which contains three directories:'
  prefs: []
  type: TYPE_NORMAL
- en: '`flask` contains the initial definitions used to jumpstart SELinux, such as
    listing the supported classes, creating initial security identifiers, and more.
    We will not touch this location further.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`modules` contains the SELinux policy code and is the main location for all
    policy rules.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`support` contains macros and definitions that are reused across the policy
    and are not associated with a single policy module.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'If we enter the `modules` directory further, we get directories that represent
    the type of modules or policies contained. This representation by itself is merely
    to have some structure across the hundreds of modules that are developed:'
  prefs: []
  type: TYPE_NORMAL
- en: '`admin` contains system administration related policy modules.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`apps` contains general application policy modules.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`kernel` contains core system policy modules (not just kernel related ones).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`roles` contains SELinux role definitions and default user domain policy modules.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`services` contains general service policy modules (and is by far the largest
    set of policy modules).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`system` contains common system related policy modules.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The interpretation of which folder a policy is placed in is left to the reference
    policy project itself, and discussed on its mailing list when it is not obvious.
    As policy files are required to have a unique name, we can find the appropriate
    location easily. For instance, to see where the `ipsec` policy module is stored:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: While browsing, you'll notice that the policy modules are always represented
    by three files, which we describe next.
  prefs: []
  type: TYPE_NORMAL
- en: Structuring policy modules
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'If we analyze an SELinux policy module''s code, such as for the `dhcp` module
    in the `services` folder, we''ll notice that it has three files associated with
    it:'
  prefs: []
  type: TYPE_NORMAL
- en: '`dhcp.te`, which contains the type enforcement rules, and is the main area
    of attention for most changes'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`dhcp.fc`, which contains the file context definitions, informing the policy
    which files or resources need to be labeled with `dhcp` related SELinux types'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`dhcp.if`, which contains interface definitions, which are reusable functions
    or macros that can be used in the `dhcp` SELinux policy code as well as elsewhere'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let's quickly see how each of these files is structured.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding type enforcement files
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The type enforcement file, `dhcp.te` in our example, has the following structure:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Let's look at each of these areas with an example.
  prefs: []
  type: TYPE_NORMAL
- en: Declaring SELinux objects
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The `Declarations` section in a policy tells us what SELinux types, or other
    SELinux objects such as SELinux booleans and SELinux roles, are defined within
    this module.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following declarations are common in SELinux policies:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The first declaration in the `dhcp` SELinux policy declares an SELinux boolean
    for this module. It is best practice to start the boolean with the SELinux policy
    module name, although in this case the choice is made to explicitly use `dhcpd`
    rather than `dhcp` to make it obvious for administrators it is about the DHCP
    daemon and not possible clients or other use cases:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The SELinux boolean is accompanied by a specifically structured comment. Comments
    within the reference policy that use a double hash prefix (`##`) will be parsed
    by the build code and used to update information outside of the SELinux policy.
    In this case, the description of the SELinux boolean is created, which will be
    made visible later on through commands such as `semanage boolean`.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Once a module is loaded that defines an SELinux policy, other modules can use
    this boolean as well.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Some domains might also declare a role attribute, which allows easy management
    of which roles are allowed to use the domain:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The rest of the declarations in the `dhcp` SELinux policy declare the SELinux
    types that the policy owns:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: SELinux policy modules in the reference policy only declare the types and other
    objects that they own, not those they use. The objects used but defined by other
    modules should always be hidden away and interacted with through the interface
    calls.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: While other definitions can be added to the section as well, these are the most
    common. Next up are the local policy rules.
  prefs: []
  type: TYPE_NORMAL
- en: Adding the domain's local rules
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The local policy within the type enforcement defines the allowed behavior of
    the domains owned by the SELinux policy module. For the `dhcp` SELinux policy
    module, this is only focusing on the `dhcpd_t` SELinux domain. Other SELinux policy
    modules, especially if they offer a more fine-grained policy structure, will do
    this for several of its own SELinux domains, or even SELinux user roles.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s go through the SELinux policy rules for the `dhcp.te` example we are
    looking at:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The policy starts with the internal SELinux rules, which are interactions between
    the SELinux types owned by the SELinux policy module itself:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The most simple rules are the standard `allow` rules, similar to those that
    `audit2allow` would recommend. These `allow` rules can refer to support macros
    (such as `signal_perms`), which we'll discuss in the *Using and understanding
    the policy macros* section. The second line, which is a call to `manage_files_pattern`,
    is also a support macro.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'The second set of local policy definitions are the core interfaced SELinux
    rules:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: These calls use the code that another SELinux policy module has defined in its
    interface file. In the case of the `kernel_read_system_state` interface, this
    will grant the `dhcpd_t` SELinux domain the rights to read `proc_t` labeled resources.
    As `proc_t` is not defined by the `dhcp` SELinux policy module, an interface call
    has to be used.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Core interfaced SELinux rules are rules that should at all times be available
    to the system. Unlike application related SELinux policy modules, which can be
    disabled or unloaded, these core rules are associated with type definitions that
    cannot be removed from the system or disabled at will.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'The third set of local policy definitions are the SELinux boolean controlled
    calls:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Here, the SELinux interface calls (which can also be standard rules such as
    `allow` rules) are surrounded by a `tunable_policy()` call, which identifies the
    SELinux boolean (in our case `dhcpd_use_ldap`) that will influence the SELinux
    policy rules. Most policy modules will only have a single block (for the rules
    that are activated if the SELinux boolean is true) but it is possible to have
    two blocks, where the second one defines the rules in case the SELinux boolean
    is false.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'The final set of local policy definitions are the non-blocking interfaced SELinux
    rules:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: These are the calls that use definitions provided by other SELinux policy modules,
    but where these SELinux policy modules might not be loaded on the system.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: In our example, the `bind_read_dnssec_keys()` call allows the `dhcpd_t` SELinux
    domain to read `dnssec_t` labeled resources, as defined by the bind SELinux policy
    module. However, BIND might not be installed on the system, and the Linux distribution
    might thus not have its policy loaded. So this call is optional and only active
    if the bind SELinux policy module is loaded.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: The type enforcement file is the file that will change most often. The file
    context definition file, which we discuss next, is a close second.
  prefs: []
  type: TYPE_NORMAL
- en: Declaring file contexts
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The file context definition file, with the `.fc` suffix, tells the SELinux subsystem
    what SELinux types have to be associated with the file resources on the system.
    This information is used by tools such as `restorecon` to reset the context appropriately.
  prefs: []
  type: TYPE_NORMAL
- en: 'The rules inside the file are generally grouped based on the directory for
    which the rules apply. Each rule is structured like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s see what these entries imply:'
  prefs: []
  type: TYPE_NORMAL
- en: The *path expressions* are the same ones we saw in [*Chapter 4*](B16276_04_Final_VK.xhtml#_idTextAnchor095),
    *Using File Contexts and Process Domains*. Keep in mind that characters such as
    dot (`.`) have a specific meaning (in this case, it reflects any possible character)
    so that paths that really require a dot inside must escape the dot.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *type/class* is an optional setting. If omitted, then it means any possible
    class is used. The most common values to use are regular files (`--`), directories
    (`-d`), sockets (`-s`), and symbolic links (`-l`).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *context* is a reference to the target SELinux type for this resource. In
    the reference policy, these context references always need to be encased by the
    `gen_context()` macro, which will add or remove the sensitivity depending on the
    MLS or MCS support built inside the policy.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let''s look at a simple example from the `dhcp` SELinux policy module:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: In this example, the `/var/named/data` directory, and any resource below it,
    will be labeled with the `named_cache_t` SELinux type.
  prefs: []
  type: TYPE_NORMAL
- en: The last file that is associated with an SELinux policy module is the interface
    definition file.
  prefs: []
  type: TYPE_NORMAL
- en: Exposing SELinux rules through interfaces
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Interfaces within an SELinux policy module are meant to support a more flexible,
    modular development of SELinux policies across different modules. Whenever a domain
    or SELinux role needs to interact with resources that are defined in a different
    SELinux policy module, that module should create a properly named interface for
    the interaction.
  prefs: []
  type: TYPE_NORMAL
- en: Interfaces should be accompanied by a minimal amount of documentation, although
    this documentation is only used when building the documentation of the entire
    policy. When this is done, the resulting documentation is made available on the
    system, for instance in `/usr/share/doc/selinux-policy/html`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s look at the definition for the `dhcpd_domtrans()` interface:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: As is best practice, the interface name starts with the SELinux policy name
    and is followed by the action that is allowed. Sometimes, this action is suffixed
    with the target resource. The interface itself can reference the arguments passed
    along to the interface using `$1` (first argument), `$2` (second argument), and
    so on. So a call such as `dhcpd_domtrans(init_t)` will have the interface called,
    where `$1` is substituted with `init_t`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s look at a few examples with common actions:'
  prefs: []
  type: TYPE_NORMAL
- en: '`dhcpd_domtrans()`). If there are multiple domains, then the target resource
    will define which domain (as with `bind_domtrans_ndc()`) to allow a domain transition
    to the `ndc_t` SELinux domain.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`dhcpd_setattr_state_files()` allows the domain to set the attributes of the
    `dhcpd_state_t` labeled resources, whereas `bind_signal()` allows the domain to
    send signals to the `named_t` labeled processes. Most of the interface definitions
    will be permission interactions.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`dhcpd_admin()` role will allow managing the `dhcpd` related resources, starting
    and stopping the `dhcpd` service, and so on.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: While developing SELinux policies, it is recommended to look into the interface
    definitions of the SELinux policy modules to see which ones exist and what they
    provide. Policy developers will put often requested permissions in such interfaces,
    so the available interfaces give a good view of what you will most likely need
    for your own SELinux policy module.
  prefs: []
  type: TYPE_NORMAL
- en: 'The interface definitions are also made available on the system at `/usr/share/selinux/devel/include`
    so that you can create and modify SELinux policy modules even without checking
    out the main source repository. Whenever we build a reference policy style module,
    we use a command like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: This will cause the build process to look for the interfaces inside the `/usr/share/selinux/devel/include`
    location, as well as inside the current working directory.
  prefs: []
  type: TYPE_NORMAL
- en: Using and understanding the policy macros
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Across the various SELinux policy definitions, we have come across macros that
    are not tied to a specific SELinux policy module. These are support macros, available
    inside the `policy/support/*.spt` files.
  prefs: []
  type: TYPE_NORMAL
- en: The most common macros are those declared inside the `obj_perm_sets.spt` file
    (which group common permissions for the same class in a single definition) and
    the `*_patterns.spt` files (which group permissions across different classes in
    a single definition).
  prefs: []
  type: TYPE_NORMAL
- en: Making use of single-class permission groups
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`execute` permission. You also need the `open` and `read` permissions (as otherwise,
    the domain cannot read the executable) and the `map` permission (to allow mapping
    the file in memory).'
  prefs: []
  type: TYPE_NORMAL
- en: 'If you were to put all these permissions in your own SELinux policy module,
    then the rule could look like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: If, later on, the SELinux policy is extended with an additional permission that
    is associated with executing resources, then you will need to look for and update
    these permissions all over the different SELinux policy modules.
  prefs: []
  type: TYPE_NORMAL
- en: 'So the reference policy moves all these permissions in a macro called `exec_file_perms`,
    defined as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'With this macro defined, our policy line can be simplified as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: If at any point the permissions need to be extended, all that has to happen
    is to extend the macro definition itself, and the SELinux policy modules can be
    left untouched.
  prefs: []
  type: TYPE_NORMAL
- en: Calling permission groups
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: While single-class permission groups are a good use for simplifying policy development,
    **permission groups** that cover multiple classes are even more common.
  prefs: []
  type: TYPE_NORMAL
- en: For instance, if a domain needs full management privileges (implying `read`,
    `write`, as well as creating and removing resources) on resources inside `/var/lib/dhcpd`,
    then not only are these privileges needed on the files inside that directory (which
    are labeled with the `dhcpd_state_t` SELinux type), but you also need read/write
    permissions on the directory itself.
  prefs: []
  type: TYPE_NORMAL
- en: 'Such a privilege definition would result in something like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Rather than declaring these as separate calls, they can be put into a single
    one that groups the two:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: SELinux policy developers best get acquainted with the various macros available
    to allow for rapid and efficient SELinux policy development.
  prefs: []
  type: TYPE_NORMAL
- en: Creating application-level policies
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Application-level policies provide confinement for applications or services.
    There are a number of different types of application-level policies around:'
  prefs: []
  type: TYPE_NORMAL
- en: End user application policies, which focus on accessing end user data, and will
    often call various `userdom_*` interfaces (which are provided through the `system/userdomain.if`
    file). Most of these applications are inside the `apps/` directory).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Administration applications, which are still user-facing, are more likely to
    enable interacting with system services and resources.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Services, which are generally daemonized applications, often interact mostly
    with their own resources and have a simpler structure.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When we covered the `sepolicy generate` command in [*Chapter 14*](B16276_14_Final_VK.xhtml#_idTextAnchor354),
    *Dealing with New Applications*, we could select these types (and more) to generate
    a simple skeleton for those applications.
  prefs: []
  type: TYPE_NORMAL
- en: Let's look into some example policies and identify useful calls that you might
    need when developing your own policies.
  prefs: []
  type: TYPE_NORMAL
- en: Constructing network-facing service policies
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Services that are network-facing (meaning they can be interacted with from outside
    the system itself) are the first set of services that need to be confined. Hence,
    building SELinux policy modules for network-facing services should be a primary
    focus of any Linux administrator that needs to ensure the confinement of applications
    that do not have a working policy yet.
  prefs: []
  type: TYPE_NORMAL
- en: If we look at the OpenVPN service, then we find that there is an SELinux policy
    under `services/openvpn.te` that we can look into.
  prefs: []
  type: TYPE_NORMAL
- en: Identifying the resources that the service interacts with
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'As a policy starts with identifying the types and other SELinux objects, we
    need to consider the resources on the system that the service interacts with.
    When comparing service policies with each other, you''ll notice that the definitions
    are often very similar:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The main domain type and its entry point executable are declared first. Depending
    on the type of service, it contains a call as to how it would be started: as a
    system service (using `init_daemon_domain()`) or through the D-Bus system bus
    (using `dbus_system_domain()`).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The configuration files for the service (such as `openvpn_etc_t`), which could
    also differentiate between read-only files and read-write (such as `openvpn_etc_rw_t`).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Runtime files (which are generally stored in `/var/run`) such as `openvpn_runtime_t`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Temporary files (which are generally stored in `/tmp` or `/var/tmp`) such as
    `openvpn_tmp_t`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Log files (which are generally stored in `/var/log`) such as `openvpn_var_log_t`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Each of the type declarations is followed by a call that marks the type appropriately.
    For instance, the `logging_log_file()` call will associate the type with the logfile
    SELinux attribute. This allows general logfile management domains to deal with
    the newly created resource through this attribute.
  prefs: []
  type: TYPE_NORMAL
- en: Handling the internal SELinux rules
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: With the resources declared, we have to define the internal SELinux rules within
    the SELinux policy. These rules tell SELinux what the domain can do with its own
    resources, and how SELinux should behave when the resources are interacted with.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will generally have two sets of internal rules declared. One is the fine-grained
    permissions of the domain itself, such as if the domain is allowed to have any
    capabilities, creating sockets, and so on. The development of these rules is trial-and-error
    based: start with close to no permissions, see what AVC denials come up, extend
    the policy, and repeat.'
  prefs: []
  type: TYPE_NORMAL
- en: The other set of internal rules focuses on the interaction with the types declared
    earlier on. This not only includes which permissions the domain has (such as through
    the `manage_files_pattern()` calls) but also whether transitions have to occur.
  prefs: []
  type: TYPE_NORMAL
- en: 'Setting the right set of transitions is one of the more important first steps
    to take while developing application policies because `audit2allow` and AVC denials
    generally do not consider the fact that a target resource has the wrong type assigned.
    So when we have a service that creates files in `/tmp` (which is labeled as `tmp_t`),
    we really want the target files to be labeled correctly (such as `openvpn_tmp_t`)
    and not inherit the `tmp_t` label from the directory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'File transitions should be declared for all the resources involved. If a transition
    has to occur for both files and directories, you can mix the classes in a single
    call like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'We can also tell SELinux that a transition should only occur if a specific
    filename is used:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: It is really recommended to first consider the file transitions (and other resource
    transitions) before expanding the actual permissions for the domain to make sure
    that we are not tempted to allow the domain privileges to general types when that
    is not necessary.
  prefs: []
  type: TYPE_NORMAL
- en: Adding network related permissions
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: While developing and expanding the policy, several core functions will be added,
    such as the `kernel_*` calls to allow processes to interact with the `proc_t`
    resources, system control settings, and more. Tools such as `audit2allow` will
    reasonably be able to deduce the right interfaces to call, although it does not
    hurt to review the interfaces to make sure not too many privileges are assigned.
  prefs: []
  type: TYPE_NORMAL
- en: Network related permissions on the other hand might require some more attention.
    As we saw in [*Chapter 5*](B16276_05_Final_VK.xhtml#_idTextAnchor138), *Controlling
    Network Communications*, SELinux can dynamically address certain network flows
    based on the system configuration.
  prefs: []
  type: TYPE_NORMAL
- en: 'It is likely that systems who do not have specific controls in place, such
    as labelled networking or SECMARK, will find that three interface calls could
    allow the application to work as intended:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: These three interface calls allow the domain to be network-oriented (`corenet_tcp_bind_generic_node`),
    listen to the OpenVPN port (`corenet_tcp_bind_openvpn_port`), as well as connecting,
    as a client, to HTTP ports (`corenet_tcp_connect_http_port`).
  prefs: []
  type: TYPE_NORMAL
- en: But other calls exist that you might need to add, even though they are currently
    not detected. They might become necessary when the system is tuned further, such
    as adding support for labeled networking or introducing SECMARK filtering.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first set is to allow sending and receiving packets on generic nodes (hosts)
    and interfaces:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'For NetLabel support, you might need to add support to receive labeled network
    packets:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'For SECMARK support, you need to add support for sending and receiving SECMARK
    labeled packets:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: These calls might not show up in early tests, but could be needed later on,
    and it is recommended to consider the impact of labeled networking and SECMARK
    on your policy from the beginning.
  prefs: []
  type: TYPE_NORMAL
- en: Building the service interface methods
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We next focus our efforts on the interface methods. These are used to facilitate
    other SELinux policy modules to interact with the domain we're developing, although
    they can also be used to simplify policy development for your own policy.
  prefs: []
  type: TYPE_NORMAL
- en: 'The three most common interfaces to define, and which other policy developers
    will assume exist, are the following:'
  prefs: []
  type: TYPE_NORMAL
- en: A `openvpn_domtrans`, allowing the given SELinux domain to execute the appropriate
    binaries or scripts and have the executed commands or applications run in our
    domain (and as such transition from the source domain to ours).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A `openvpn_run`, which is like the domain transition interface (and in fact
    will call it) but also allows our domain for the role. Without this interface,
    some roles might not be able to transition even if they call the domain transition
    interface.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An `openvpn_admin`, which will be assigned to user roles/domains to allow them
    to administer our service. This will allow the user to interact with the processes
    of our domain (including killing the processes, tracing their actions, and so
    on) as well as to administer the files and resources used.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Within the interfaces, we need to declare the SELinux objects that we are going
    to explicitly reference. This allows the SELinux subsystem to validate whether
    the code is applicable or not: if the objects are not present in the current policy,
    then this interface is not valid and will not be used. Declaring objects is done
    with the `gen_require()` macro:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: Other interfaces can be added as needed. While you can add interfaces already
    just in case, be aware that once you define an interface it can be used by other
    policies, and you might not be made aware of this if you are not developing all
    policies yourself. If you, later on, want to change the behavior of interfaces
    or remove them, you might break other policies.
  prefs: []
  type: TYPE_NORMAL
- en: Addressing user applications
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'If we develop end user applications, their structure will be very similar to
    those for more service-oriented applications. Content-wise, however, there are
    a few areas of attention to consider. Let''s use the `apps/thunderbird.te` policy
    as an example:'
  prefs: []
  type: TYPE_NORMAL
- en: The first thing we notice is that many resource defining interfaces are prefixed
    with `userdom_`. For instance, a temporary file is not `files_tmp_file()` but
    `userdom_user_tmp_file()`. This will ensure that the resources are known as **user-managed**
    temporary files and not regular system temporary files.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Another important addition is the support for the `~/.cache`, application cache
    data is stored, whereas configuration data is in `~/.config`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: To easily establish user content access, user applications should also call
    the `userdom_user_content_access_template()` template. This will automatically
    create booleans as well, which administrators can toggle. For instance, for the
    thunderbird SELinux policy, this will create `thunderbird_manage_generic_user_content`.
    If set, then thunderbird can not only access the downloads-related resources but
    all user resources.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Another template that user application policies will need if they are graphical
    in nature, is `xserver_user_x_domain_template()`. This template will generate
    X server related SELinux objects for the application, and allow the application
    to use the graphical environment on the server.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Important note
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: The reference policy makes a distinction between regular interfaces and templates.
    Interfaces grant privileges to the domains and roles that are passed to it. Templates
    on the other hand will generate new objects, such as SELinux booleans, types,
    attributes, and more. Code-wise, templates cannot be part of boolean-triggered
    statements (as they do not just add type enforcement rules).
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: When the baseline of a user application policy is drafted, including the preceding
    templates, then expanding the policy through trial and error should suffice. Do
    make sure, however, that all resources on the user location for which you are
    testing the application are correctly labeled, as otherwise, the denials might
    trick you into granting more privileges to the domain than necessary.
  prefs: []
  type: TYPE_NORMAL
- en: Adding user-level policies
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'If we want to create custom user and role policies, then the most confusing
    choice is the choice of user template to pick. This template creates a role and
    user domain with a specific purpose in mind, and grants a number of permissions
    by default:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 15.1 – Relationship between user domain templates ](img/B16276_15_001.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 15.1 – Relationship between user domain templates
  prefs: []
  type: TYPE_NORMAL
- en: 'The most common templates to pick for user/role policies are the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '`userdom_restricted_user_template()` for (by default) unprivileged end user
    roles.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`userdom_admin_user_template()` for (by default) highly privileged end user
    roles.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The other templates can be used as well, especially if more fine-grained controls
    over the roles and user domains are needed. Note, however, that the privileges
    assigned by the templates are mentioned as *by default*. If we want to create
    a role and user domain for administrating a specific service, then we do not want
    to use `userdom_admin_user_template()`, as this will grant many more privileges
    than needed.
  prefs: []
  type: TYPE_NORMAL
- en: As an example, consider the `roles/dbadm.te` SELinux policy for the database
    administration role. This role is based upon the `userdom_base_user_template()`
    interface to ensure minimal permissions are granted. The role is not meant to
    be used in a direct fashion (login), but rather transitioned toward (for instance,
    through the `newrole` command, or through well-defined role transitions within
    the policy).
  prefs: []
  type: TYPE_NORMAL
- en: Getting help with supporting tools
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are tools out there that help in developing SELinux policies, and if needed
    we can build our own support tools as well. Let's see what support environments
    we can use.
  prefs: []
  type: TYPE_NORMAL
- en: Verifying code with selint
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: While SELinux policies can be functionally working, validating whether the code
    itself is proper and follows best practices is important to ensure that the code
    is maintainable in the long run.
  prefs: []
  type: TYPE_NORMAL
- en: 'One of the tools that support validating SELinux policy code is `selint`, as
    offered from [https://github.com/TresysTechnology/selint](https://github.com/TresysTechnology/selint).
    Once built and installed, `selint` offers insights into four main areas:'
  prefs: []
  type: TYPE_NORMAL
- en: Convention checks validate whether the SELinux policy follows the reference
    policy convention on how code should be structured and documented.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Style checks give hints for code style that might be wrong, and where the developer
    might have intended a different behavior.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Warnings are triggered when the code has bad calls that might trigger runtime
    issues or security issues.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Errors catch construction faults that will result in compile issues or runtime
    issues.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This allows the use of `selint` in automated build processes, as well as facilitating
    the development of policies.
  prefs: []
  type: TYPE_NORMAL
- en: 'Calling `selint` is simple:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: In this case, two convention malpractices were detected. One is in the ordering
    of permissions, while another has an explicit require block mentioned for a domain
    that is not part of that policy module.
  prefs: []
  type: TYPE_NORMAL
- en: Querying the interfaces and macros locally
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To help in finding the right interface or macro, we also want to quickly be
    able to show interface and macro information. With some shell scripting, we can
    create a few functions that help us along.
  prefs: []
  type: TYPE_NORMAL
- en: 'The functions are provided as code together with this book. You might want
    to change the path that the `POLICY_LOCATION` variable points to at the beginning
    of the script. By default, it points to the system-installed interface and macros,
    but you can point it to repository checkouts as well:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'Source the file to have access to the helper functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'The helper functions you can use are the following:'
  prefs: []
  type: TYPE_NORMAL
- en: With `sefindif` you can search for an SELinux interface that has a specific
    SELinux rule inside. You can use regular expressions to find the appropriate one.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: With `seshowif` the interface in its entirety (excluding the comment) is displayed.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: With `sefinddef` and `seshowdef`, the same is possible but for the supporting
    macros.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: While such functions do not offer the same versatility as a full-fledged policy
    editor suite would, they can help in quickly finding the right interface or macro.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The reference policy is the most common source for SELinux policy development,
    and with years of development effort and maintenance, it has grown to be a full
    policy set with a vivid development community, and active support by various tools
    (including `audit2allow`, as well as the `selint` application).
  prefs: []
  type: TYPE_NORMAL
- en: 'We''ve learned how policies are generally structured, and how to start building
    SELinux policy modules for the most common use cases: application services, end
    user applications, and user roles. To help us in developing these policies, we''ve
    seen that `selint` can do code-style analysis, whereas some shell scripts can
    help us parse the interface files for quick help.'
  prefs: []
  type: TYPE_NORMAL
- en: In our final chapter, we will look into CIL style SELinux development.
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Why don't Linux distributions use the reference policy natively?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What are the three main policy files needed for an SELinux module, and what
    is their purpose?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Why is a permission set such as `exec_file_perms` preferred over explicitly
    listing the permissions?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is the difference between interfaces and templates?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Why is the database administration role defined in `dbadm.te` not using `userdom_admin_user_template`?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
