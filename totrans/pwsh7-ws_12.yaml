- en: '12'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '12'
- en: Securing PowerShell
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 加固 PowerShell
- en: As we’ve seen, PowerShell is an incredibly powerful tool, and, to quote Uncle
    Ben, “*with great power comes great responsibility.*” If you don’t know who Uncle
    Ben is, ask your friendly neighborhood Spider-Man. PowerShell can wreak absolute
    havoc across a system or an organization. This damage can be deliberate, by someone
    setting out to cause damage, but it can just as easily be inadvertent.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所见，PowerShell 是一个极其强大的工具，引用本·叔叔的话：“*伟大的力量伴随着伟大的责任*。”如果你不知道本·叔叔是谁，可以问问你身边的蜘蛛侠。PowerShell
    能够在系统或组织内造成巨大的破坏。这种破坏可以是故意的，由某人故意制造损害，但同样也可能是无意的。
- en: We’re going to start this chapter by looking at one of the features that makes
    PowerShell so powerful – PowerShell remoting. We’ll continue by looking at how
    PowerShell protects against inadvertent mistakes, and then move on to the PowerShell
    features that protect us from deliberate attacks. We’ll then look at the features
    PowerShell has that let us analyze what has happened on the machine through logging,
    before wrapping up with a look at the things we can do to make the code we write
    more secure. Because of PowerShell’s history with Windows, many of these features
    are exclusive to Windows, or more fully developed in Windows. When this is the
    case, it will be acknowledged.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将从 PowerShell 的一个强大特性——PowerShell 远程功能开始讲解。接下来我们将介绍 PowerShell 如何防止无意的错误，然后继续讨论
    PowerShell 中可以保护我们免受故意攻击的功能。随后，我们将探索 PowerShell 提供的功能，这些功能能够通过日志分析机器上发生的事件，最后总结我们可以采取的措施来提升编写代码的安全性。由于
    PowerShell 与 Windows 的历史关系，其中许多功能仅限于 Windows，或者在 Windows 中得到了更充分的开发。当出现这种情况时，会特别提及。
- en: 'The main topics we will cover in this chapter are as follows:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖的主要主题如下：
- en: Why is security so important?
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为什么安全性如此重要？
- en: Securing PowerShell against inadvertent mistakes
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 防止无意错误对 PowerShell 的影响
- en: Running PowerShell securely
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 安全地运行 PowerShell
- en: PowerShell logging
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: PowerShell 日志记录
- en: Writing secure code
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编写安全代码
- en: Why is security so important?
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为什么安全性如此重要？
- en: We’ve seen that PowerShell is powerful, but we haven’t seen why it can be so
    dangerous. Everything we’ve done so far has required an interactive logon to the
    client we are using, which implies someone would need physical access to a device
    before attacking it. PowerShell, however, has the concept of **PowerShell remoting**,
    which allows us to log on to a remote device and run PowerShell code as if we
    were physically there. This is why it is such a powerful administration tool.
    We’ll not cover much about remoting in this book, as it is very much an admin
    tool, but it’s important to know the basics. Let’s take a closer look.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到 PowerShell 是多么强大，但还没有看到它为何如此危险。到目前为止，我们所做的一切都需要在我们使用的客户端进行交互式登录，这意味着在攻击之前，某人需要物理访问设备。然而，PowerShell
    有一个概念叫做 **PowerShell 远程功能**，它允许我们登录到远程设备并像在现场一样执行 PowerShell 代码。这就是它成为如此强大管理工具的原因。虽然本书不会详细讨论远程功能，因为它主要是管理员工具，但了解基础概念仍然很重要。让我们仔细看一看。
- en: A PowerShell remoting whistlestop tour
  id: totrans-12
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: PowerShell 远程功能速览
- en: Many older cmdlets in Windows PowerShell have a `-ComputerName` parameter, which
    allows PowerShell to query a remote machine for information. The trouble with
    this parameter is that it relies on the credentials under which we are running
    our PowerShell session having the authorization to query the remote machine. If
    we’re lucky, the cmdlet will have a `-Credential` parameter that we can use to
    supply alternate credentials. Quite often, we’re not lucky; see the following
    screenshot.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 许多较老的 Windows PowerShell cmdlet 都有一个 `-ComputerName` 参数，它允许 PowerShell 查询远程机器的信息。这个参数的问题在于，它依赖于我们运行
    PowerShell 会话时所使用的凭据必须具备查询远程机器的权限。如果我们幸运的话，cmdlet 会有一个 `-Credential` 参数，允许我们提供其他凭据。然而，很多时候我们并不幸运；请参见以下截图。
- en: '![Figure 12.1 – Get-Process does not feel lucky](img/B17600_12_001.jpg)'
  id: totrans-14
  prefs: []
  type: TYPE_IMG
  zh: '![图 12.1 – Get-Process 不走运](img/B17600_12_001.jpg)'
- en: Figure 12.1 – Get-Process does not feel lucky
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 图 12.1 – Get-Process 不走运
- en: As we can see, the `Get-Process` cmdlet has no `-Credential` parameter, so we
    just have to hope that our session credentials will work on the remote machine.
    If we don’t have the right credential on our PowerShell session, we can’t run
    `Get-Process` on a remote machine. Even if we do have the right credential, it’s
    quite possible that a remote firewall will block the request. In PowerShell 7.2
    and later, it doesn’t have a `–ComputerName` parameter either.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，`Get-Process` cmdlet没有`-Credential`参数，因此我们只能希望我们的会话凭据在远程计算机上有效。如果我们在 PowerShell
    会话中没有正确的凭据，就无法在远程计算机上运行`Get-Process`。即便我们有正确的凭据，远程防火墙也很可能会阻止该请求。在 PowerShell 7.2
    及更高版本中，它也没有`–ComputerName`参数。
- en: To get around this, PowerShell remoting was developed for Windows PowerShell
    3.0\. It uses the `5985` (HTTP) and `5986` (HTTPS), which means it can be encrypted
    using SSL. In enterprise configurations, where Active Directory is used, the traffic
    is also encrypted, using Kerberos. Obviously, Linux machines don’t include WinRM,
    so PowerShell 7.x helpfully includes support to run remote sessions over SSH.
    We’ll cover that in more detail later in this chapter, in the *Running PowerShell
    securely* section. Let’s have a look at how PowerShell remoting works in a Windows
    environment; we’ll start by enabling PowerShell remoting. Note that I’m running
    this on a Windows 10 client, and I have created a new local user called `Admin`,
    with a password and administrator rights.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 为了绕过这个问题，PowerShell 远程连接是在 Windows PowerShell 3.0中开发的。它使用`5985`（HTTP）和`5986`（HTTPS）端口，这意味着它可以使用
    SSL 加密。在使用 Active Directory 的企业配置中，流量也会被加密，使用的是 Kerberos。显然，Linux 机器不包括 WinRM，因此
    PowerShell 7.x 版本贴心地包括了通过 SSH 运行远程会话的支持。我们将在本章的*安全运行 PowerShell*部分中更详细地讨论这一点。现在我们来看看
    PowerShell 远程连接在 Windows 环境中的工作方式；我们将从启用 PowerShell 远程连接开始。请注意，我在一台 Windows 10
    客户端上运行此操作，并创建了一个名为`Admin`的新本地用户，并为其设置了密码和管理员权限。
- en: Enabling PowerShell remoting
  id: totrans-18
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 启用 PowerShell 远程连接
- en: 'By default, PowerShell remoting is enabled on all Windows servers. However,
    it’s disabled on Windows clients. The easiest way to get it running is to use
    the `Enable-PSRemoting` cmdlet. This cmdlet does everything we need, from enabling
    the endpoints to creating the correct rules in Windows Firewall. This needs to
    be run from an elevated admin prompt. Take a look at the following screenshot:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，PowerShell 远程连接在所有 Windows 服务器上启用。然而，它在 Windows 客户端上是禁用的。让它运行的最简单方法是使用`Enable-PSRemoting`
    cmdlet。这个 cmdlet 做了我们需要做的一切，从启用端点到创建正确的 Windows 防火墙规则。此命令需要从提升的管理员提示符中运行。看看下面的截图：
- en: '![Figure 12.2 – Enabling PowerShell remoting](img/B17600_12_002.jpg)'
  id: totrans-20
  prefs: []
  type: TYPE_IMG
  zh: '![图 12.2 – 启用 PowerShell 远程连接](img/B17600_12_002.jpg)'
- en: Figure 12.2 – Enabling PowerShell remoting
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 图 12.2 – 启用 PowerShell 远程连接
- en: As we can see, I’ve run `Enable-PSRemoting` with a couple of common parameters.
    The `-Force` parameter means we don’t get asked whether we’re sure we want to
    do this a bunch of times, and we’ve seen the parameter used this way before. The
    `-SkipNetworkProfileCheck` is an interesting one, however. Many people haven’t
    configured their network profile on standalone clients, and the default is public.
    However, PowerShell remoting won’t operate over a public network, by default.
    Using the `-SkipNetworkProfileCheck` bypasses the network profile check but creates
    a firewall rule that only allows remote sessions from the local subnet. This rule
    is easily edited, but it’s probably better to set the network profile up correctly,
    or to not try running remote sessions over a public network.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，我已使用几个常见参数运行了`Enable-PSRemoting`。`-Force`参数表示我们不会被反复询问是否确定要执行此操作，我们之前也见过这种用法。不过，`-SkipNetworkProfileCheck`是一个比较有趣的参数。许多人没有在独立客户端上配置网络配置文件，默认的网络类型是公共网络。然而，默认情况下，PowerShell
    远程连接无法在公共网络上运行。使用`-SkipNetworkProfileCheck`可以跳过网络配置文件检查，但会创建一条防火墙规则，仅允许来自本地子网的远程会话。这个规则可以很容易地进行编辑，但最好还是正确设置网络配置文件，或者避免在公共网络上尝试运行远程会话。
- en: Creating a session
  id: totrans-23
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建会话
- en: 'Now we’ve got remoting set up on our client, let’s create a session. We can
    do that with the `New-PSSession` cmdlet. I’m going to store my `Admin` user credentials
    in a variable called `$cred`, and then I’m going to run it like this:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经在客户端上设置了远程连接，让我们创建一个会话。我们可以使用`New-PSSession` cmdlet 来完成。我将把我的`Admin`用户凭据存储在名为`$cred`的变量中，然后像这样运行它：
- en: '[PRE0]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'And we can see the output we get here:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到这里得到的输出：
- en: '![Figure 12.3 – Creating a new remoting session](img/B17600_12_003.jpg)'
  id: totrans-27
  prefs: []
  type: TYPE_IMG
  zh: '![图 12.3 – 创建新的远程连接会话](img/B17600_12_003.jpg)'
- en: Figure 12.3 – Creating a new remoting session
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 图 12.3 – 创建新的远程连接会话
- en: This will create a persistent session that may be connected to and disconnected
    from as needed.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 这将创建一个持久会话，可以根据需要连接和断开连接。
- en: Joining and leaving a session
  id: totrans-30
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 加入和退出会话
- en: 'We can use the `Enter-PSSession` cmdlet to connect to a session like this:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用`Enter-PSSession` cmdlet 连接到一个会话，方法如下：
- en: '[PRE1]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The session we create is a PowerShell object (like everything else in PowerShell),
    and so we can also enter by passing the session through the pipeline:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建的会话是一个 PowerShell 对象（和 PowerShell 中的其他一切一样），因此我们也可以通过将会话传递给管道来进入：
- en: '[PRE2]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'This is how it looks on my machine:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我机器上的运行效果：
- en: '![Figure 12.4 – Entering and leaving a remoting session](img/B17600_12_004.jpg)'
  id: totrans-36
  prefs: []
  type: TYPE_IMG
  zh: '![图 12.4 – 进入和退出远程会话](img/B17600_12_004.jpg)'
- en: Figure 12.4 – Entering and leaving a remoting session
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 图 12.4 – 进入和退出远程会话
- en: In the first command, I’ve called the session by name. In the second command,
    I’ve passed the session object to `Enter-PSSession`. I’ve left the session by
    using the `exit` keyword. Note that once I am in a session, the PowerShell prompt
    changes to reflect `ComputerName` of the client I am connected to and the remote
    working directory.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一个命令中，我通过名称调用了会话。在第二个命令中，我将会话对象传递给了`Enter-PSSession`。我使用`exit`关键字退出了会话。请注意，一旦进入会话，PowerShell
    提示符会更改为反映我连接的客户端的`ComputerName`以及远程工作目录。
- en: This is called a one-to-one remoting session. Once we’re in this sort of session,
    it is the same as if we were directly connected to the remote machine. Only the
    PowerShell modules on the remote machine are available.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 这称为一对一远程会话。一旦进入这种会话，就等同于直接连接到远程机器。只有远程机器上的 PowerShell 模块可用。
- en: 'We can also enter an ad hoc session by not specifying an existing session when
    we use `Enter-PSSession`; instead, we specify a computer name and a credential
    like this:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以通过不指定现有会话来进入临时会话；相反，我们指定计算机名称和凭证，像这样：
- en: '[PRE3]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'As we can see here, creating a session this way means it ceases to exist when
    we exit it, rather than persisting:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所看到的，通过这种方式创建的会话在退出时会消失，而不是保持存在：
- en: '![Figure 12.5 – Ad hoc remoting](img/B17600_12_005.jpg)'
  id: totrans-43
  prefs: []
  type: TYPE_IMG
  zh: '![图 12.5 – 临时远程会话](img/B17600_12_005.jpg)'
- en: Figure 12.5 – Ad hoc remoting
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 图 12.5 – 临时远程会话
- en: In the first command in the preceding screenshot, I’m creating an ad hoc session,
    which I then `exit`. As we can see, after I type `exit`, the session is no longer
    available, as shown in the last command, where I run the `Get-PSSession` cmdlet.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的截图中的第一个命令里，我创建了一个临时会话，然后通过`exit`退出。正如我们所看到的，当我输入`exit`后，会话不再可用，在最后的命令中我运行了`Get-PSSession`
    cmdlet。
- en: 'To remove persistent sessions, we can either pass the session name to `Remove-PSSession`,
    like this:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 要移除持久化会话，我们可以将会话名称传递给`Remove-PSSession`，像这样：
- en: '[PRE4]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Alternatively, we pipe the session object:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，我们将会话对象通过管道传递：
- en: '[PRE5]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: If we run the preceding `Get-PSSession` cmdlet without specifying a session
    name, then all sessions will be removed.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们运行前面的`Get-PSSession` cmdlet，但不指定会话名称，那么所有会话都会被移除。
- en: One-to-many sessions
  id: totrans-51
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 一对多会话
- en: 'We can also run commands and scripts on multiple machines at once by using
    the `Invoke-Command` cmdlet, like this:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以通过使用`Invoke-Command` cmdlet，在多台机器上同时运行命令和脚本，方法如下：
- en: '[PRE6]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: This will run the commands or scripts in the scriptblock against the list of
    names specified in the `-ComputerName` parameter. This command uses PowerShell
    remoting the same as the previous `PSSession` cmdlets.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 这将把脚本块中的命令或脚本应用于`-ComputerName`参数中指定的计算机名称列表。这个命令使用 PowerShell 远程功能，和之前的`PSSession`
    cmdlet 一样。
- en: Being able to run commands on remote machines makes PowerShell an extremely
    useful administration tool, which unfortunately means that it is also a security
    risk. Let’s look now at the ways we can help prevent PowerShell from causing problems.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 能够在远程机器上运行命令，使得 PowerShell 成为一个极其有用的管理工具，但遗憾的是，这也意味着它存在一定的安全风险。现在，让我们来看看如何防止
    PowerShell 造成问题。
- en: Securing PowerShell against inadvertent mistakes
  id: totrans-56
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 保护 PowerShell 免受无意错误的影响
- en: The first set of tools we’ll look at are the ones that protect us from people
    doing things by accident. The most useful of these is a built-in execution policy
    that can be used to control how scripts can be run.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先要介绍的一组工具是那些能保护我们避免因为操作失误而造成问题的工具。其中最有用的工具之一是一个内置的执行策略，它可以用来控制脚本的运行方式。
- en: Execution policy
  id: totrans-58
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 执行策略
- en: We encountered the execution policy feature back in [*Chapter 8*](B17600_08.xhtml#_idTextAnchor162),
    *Writing Our First Script – Turning Simple Cmdlets into Reusable Code*, and noted
    that we would cover it in more detail in this chapter. The execution policy is
    a safety feature that controls how we can run scripts, but only in a Windows environment.
    Don Jones (the Don!) has described the execution policy as intended to “*…slow
    down an uninformed user who is unintentionally trying to run an untrusted script.*”
    There is a lot of unintentionality in that sentence. The execution policy will
    present a few obstacles to an educated user who is deliberately trying to run
    a script. The best way to stop a user from running a potentially destructive script
    is to make sure that they don’t have the permissions to carry out the commands
    in the script. I have seen customer environments where the number of domain admin
    accounts runs into the hundreds, many of them unused for years, but still enabled.
    These customers have much bigger problems than PowerShell’s execution policy.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在[*第8章*](B17600_08.xhtml#_idTextAnchor162)中遇到了执行策略功能，*编写我们的第一个脚本——将简单的 Cmdlet
    转换为可重用代码*，并提到我们将在本章中更详细地介绍它。执行策略是一个安全功能，控制我们如何运行脚本，但仅适用于 Windows 环境。Don Jones（那位
    Don！）曾描述执行策略的目的是“*…减缓一个没有经验的用户，防止他无意中运行一个不受信任的脚本*”。这句话里有很多无意的成分。执行策略会给有知识的用户带来一些障碍，他们是故意运行脚本的。防止用户运行潜在破坏性脚本的最佳方法是确保他们没有执行脚本中命令的权限。我曾在客户环境中看到，域管理员帐户数量达到数百个，其中许多多年未使用，但仍然启用。这些客户的问题比
    PowerShell 的执行策略要大得多。
- en: 'The execution policy has different levels of security and is applied at different
    scopes. The levels are determined by the script’s origin, and whether it is signed
    with a code signing certificate from a trusted certificate authority; we’ll discuss
    code signing certificates later in this chapter, in the *Signing scripts* section.
    Let’s look at the levels first:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 执行策略有不同的安全级别，并且应用于不同的作用域。级别由脚本的来源决定，以及它是否由受信任的证书颁发机构的代码签名证书签名；我们将在本章的*签名脚本*部分讨论代码签名证书。首先，让我们看看这些级别：
- en: '`Restricted`: This is the default policy on Windows client computers and prevents
    the running of scripts, including formatting files and modules – any files with
    the `.ps1xml`, `.psm1`, or `.ps1` extensions. Individual commands may be run at
    the terminal, but that’s it.'
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Restricted`：这是 Windows 客户端计算机上的默认策略，禁止运行脚本，包括格式化文件和模块——任何扩展名为 `.ps1xml`、`.psm1`
    或 `.ps1` 的文件。可以在终端运行单个命令，但仅此而已。'
- en: '`AllSigned`: This level allows scripts with a digital signature from a trusted
    publisher to be run; this includes scripts that were written on the computer.
    If it isn’t signed, it can’t run. If it is signed by an untrusted publisher, then
    PowerShell will prompt the user. Obviously, if a script is malicious and signed,
    then it can still be run.'
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`AllSigned`：此级别允许运行由受信任发布者签名的脚本；这包括在计算机上编写的脚本。如果脚本没有签名，则不能运行。如果它是由不受信任的发布者签名，PowerShell
    将提示用户。显然，如果脚本是恶意的并且已签名，它仍然可以运行。'
- en: '`RemoteSigned`: Scripts that originated elsewhere than the local machine need
    a digital signature, but scripts written on the local machine do not. Obviously,
    there are a number of clandestine ways around this that might involve opening
    Notepad and using copy and paste. This is the default policy for Windows server
    computers.'
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`RemoteSigned`：来自本地计算机之外的脚本需要数字签名，但在本地计算机上编写的脚本不需要。显然，有许多隐蔽的方式可以绕过这一点，可能涉及打开记事本并使用复制粘贴。这是
    Windows 服务器计算机的默认策略。'
- en: '`Default`: This sets the default policy. On a Windows client, the default policy
    is `Restricted`. On a Windows server, the default policy is `RemoteSigned`.'
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Default`：这是设置默认策略的选项。在 Windows 客户端上，默认策略是 `Restricted`。在 Windows 服务器上，默认策略是
    `RemoteSigned`。'
- en: '`Undefined`: This removes any execution policy that is set on the current scope.
    If we use this on all scopes, then the resulting policy is the default policy,
    as previously mentioned.'
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Undefined`：这将移除当前作用域上设置的任何执行策略。如果我们在所有作用域上使用此策略，那么结果将是默认策略，如前所述。'
- en: '`Unrestricted`: This is the default policy on non-Windows computers. Unsigned
    files from anywhere can be run; users may get a warning when running scripts that
    didn’t originate in the local network.'
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Unrestricted`：这是非 Windows 计算机上的默认策略。来自任何地方的未签名文件都可以运行；用户在运行未来自本地网络的脚本时，可能会收到警告。'
- en: '`Bypass`: Nothing is blocked, and there are no warnings. Execution policy is
    ignored. This can be set by calling the `-ExecutionPolicy` parameter of the `pwsh.exe`
    program. We can see how this looks in the following figure:'
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Bypass`：不阻止任何操作，也没有警告。执行策略被忽略。可以通过调用 `pwsh.exe` 程序的 `-ExecutionPolicy` 参数来设置。我们可以在下图中看到这种情况：'
- en: '![Figure 12.6 – Bypassing the execution policy](img/B17600_12_006.jpg)'
  id: totrans-68
  prefs: []
  type: TYPE_IMG
  zh: '![图 12.6 – 绕过执行策略](img/B17600_12_006.jpg)'
- en: Figure 12.6 – Bypassing the execution policy
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 图 12.6 – 绕过执行策略
- en: As we can see, the execution policy is only bypassed at the `pwsh.exe` process
    level but remains at the default for the other scopes. When this `pwsh` process
    ends, the execution policy bypass will lapse.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，执行策略仅在 `pwsh.exe` 进程级别被绕过，但在其他作用域中保持默认设置。当该 `pwsh` 进程结束时，执行策略绕过将失效。
- en: Let’s consider the scopes at which we can apply execution policies next.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们考虑可以应用执行策略的作用域。
- en: 'As we can see in *Figure 12**.6*, there are five scopes at which we can apply
    an execution policy. Each one has a different precedence level. The `MachinePolicy`
    and `UserPolicy` scopes can only be set in Group Policy – a feature of Windows
    Active Directory. Group Policy is an enterprise application for controlling the
    configuration of users and machines centrally, and we’re not going to worry too
    much about it here. There is a good introductory article on Group Policy here:
    [https://techcommunity.microsoft.com/t5/ask-the-performance-team/the-basics-of-group-policies/ba-p/372404](https://techcommunity.microsoft.com/t5/ask-the-performance-team/the-basics-of-group-policies/ba-p/372404).'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们在*图 12.6*中所见，我们可以在五个作用域中应用执行策略。每个作用域具有不同的优先级。`MachinePolicy` 和 `UserPolicy`
    作用域只能在组策略中设置——这是 Windows Active Directory 的一项功能。组策略是一个用于集中控制用户和机器配置的企业应用程序，我们在这里不需要过多关注它。这里有一篇关于组策略的优秀入门文章：[https://techcommunity.microsoft.com/t5/ask-the-performance-team/the-basics-of-group-policies/ba-p/372404](https://techcommunity.microsoft.com/t5/ask-the-performance-team/the-basics-of-group-policies/ba-p/372404)。
- en: 'Scopes have an order of precedence, and a scope at a lower level will be overridden
    by a scope at a higher level. In descending order of precedence, the scopes are
    as follows:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 作用域有优先级顺序，较低级别的作用域会被较高级别的作用域覆盖。作用域的优先级从高到低依次为：
- en: '`MachinePolicy`: This scope is set using a group policy and applies to all
    users of a machine.'
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`MachinePolicy`：此作用域通过组策略设置，适用于机器上的所有用户。'
- en: '`UserPolicy`: This scope is set by group policy and applies to the current
    user of a machine.'
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`UserPolicy`：此作用域通过组策略设置，适用于机器的当前用户。'
- en: '`Process`: This scope refers to the current PowerShell session. There is no
    registry location for this; it is governed by the content of the `$env:PSExecutionPolicyPreference`
    variable. When the session is closed, the content of the variable is removed.'
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Process`：此作用域指当前的 PowerShell 会话。没有与之关联的注册表位置；它由 `$env:PSExecutionPolicyPreference`
    变量的内容控制。当会话关闭时，变量的内容会被移除。'
- en: '`CurrentUser`: This only applies to the current user and is stored in the Windows
    registry, a database of machine settings.'
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CurrentUser`：此作用域仅适用于当前用户，并存储在 Windows 注册表中，这是一个包含机器设置的数据库。'
- en: '`LocalMachine`: This applies to all users on the machine and is also stored
    in the registry.'
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`LocalMachine`：此作用域适用于机器上的所有用户，也存储在注册表中。'
- en: In *Figure 12**.6*, we can see that the scopes are listed in order of precedence.
    Because the execution policy is `Undefined` at both the `MachinePolicy` and `UserPolicy`
    levels, the effective execution policy is `Bypass`, defined at the `Process` level.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 在*图 12.6*中，我们可以看到作用域按优先级顺序列出。由于在 `MachinePolicy` 和 `UserPolicy` 级别的执行策略是 `Undefined`，因此有效的执行策略是
    `Bypass`，它定义在 `Process` 级别。
- en: The two cmdlets we can use with the execution policy are `Get-ExecutionPolicy`
    and `Set-ExecutionPolicy`, which we saw back in [*Chapter 8*](B17600_08.xhtml#_idTextAnchor162),
    *Writing Our First Script – Turning Simple Cmdlets into Reusable Code*. Let’s
    briefly look at two other features of PowerShell that are intended to help prevent
    mistakes.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以与执行策略一起使用的两个 cmdlet 是 `Get-ExecutionPolicy` 和 `Set-ExecutionPolicy`，我们在[*第8章*](B17600_08.xhtml#_idTextAnchor162)，*编写我们的第一个脚本
    – 将简单的 Cmdlet 转化为可重用的代码*中见过。接下来，让我们简要地了解 PowerShell 的另外两个旨在帮助防止错误的功能。
- en: Other features
  id: totrans-81
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 其他功能
- en: These features only protect against someone accidentally running a script. Firstly,
    PowerShell extensions such as `.ps1` are associated with Notepad by default, rather
    than as executable files. This means that if someone double-clicks a script by
    accident, they will open it in Notepad, rather than run it. This is in contrast
    to earlier Windows script files such as batch files and Visual Basic script files,
    which would execute if clicked accidentally.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 这些功能仅防止有人不小心运行脚本。首先，PowerShell扩展名（如`.ps1`）默认与记事本关联，而不是作为可执行文件。这意味着如果有人不小心双击一个脚本，它会在记事本中打开，而不是直接运行。这与早期的Windows脚本文件（如批处理文件和Visual
    Basic脚本文件）不同，后者如果双击会直接执行。
- en: 'The other way we are protected against accidental execution is that PowerShell
    doesn’t search the current folder for script files, so either a relative path
    or absolute path must be provided to run a script at the terminal prompt, like
    this:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种防止意外执行的保护措施是，PowerShell不会在当前文件夹中搜索脚本文件，因此必须提供相对路径或绝对路径才能在终端提示符下运行脚本，例如这样：
- en: '![Figure 12.7 – Absolute and relative paths](img/B17600_12_007.jpg)'
  id: totrans-84
  prefs: []
  type: TYPE_IMG
  zh: '![图 12.7 – 绝对路径和相对路径](img/B17600_12_007.jpg)'
- en: Figure 12.7 – Absolute and relative paths
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 图 12.7 – 绝对路径和相对路径
- en: In the first line, I’ve used an absolute path to call a script called `HelloWorld.ps1`,
    which outputs the line `hello world`. In the second line, I switch to the folder
    containing the script, and in the third line, I attempt to call it by using `HelloWorld`,
    which would work for a program Windows recognizes as an executable, such as a
    batch file, but doesn’t for a PowerShell script. Note how PowerShell helpfully
    tells me what I was doing wrong. In the fourth line, I call it using a relative
    path by prefacing the full script name with `.\`, which is successful.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一行，我使用了绝对路径来调用一个名为`HelloWorld.ps1`的脚本，脚本输出`hello world`。在第二行，我切换到包含该脚本的文件夹，第三行，我尝试通过使用`HelloWorld`来调用它，这对Windows识别为可执行的程序（如批处理文件）有效，但对PowerShell脚本无效。注意PowerShell是如何友好地告诉我哪里出错了的。第四行，我通过在脚本名称前加上`.\`来使用相对路径调用它，成功运行了。
- en: That used to be it for PowerShell security. Thankfully, in recent versions,
    lots of new features have been added that are more proactive. Let’s explore how
    we can run PowerShell securely.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 过去，PowerShell的安全性就是这样了。幸运的是，在最近的版本中，添加了很多新的功能，这些功能更加主动。让我们来探讨一下如何安全地运行PowerShell。
- en: Running PowerShell securely
  id: totrans-88
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 安全地运行PowerShell
- en: PowerShell has several features that actively increase the security of our environments.
    Let’s start by looking at application control.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: PowerShell有几个功能可以主动提高我们环境的安全性。我们先来看一下应用程序控制。
- en: Application control
  id: totrans-90
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 应用程序控制
- en: Application control solutions prevent unauthorized applications from running.
    There are third-party applications, such as Trellix, but Windows 10 and later
    come with two built-in applications – **Windows Defender Application Control**
    (**WDAC**) and AppLocker. These can be used to create policies that enforce a
    whitelist of applications that are allowed to execute and prevent anything else
    from running. AppLocker is no longer under development, so WDAC is recommended.
    These solutions are intended for an enterprise environment and allow for centralized
    control. I am not aware of any solutions that work with PowerShell on Linux or
    macOS. When PowerShell runs under a default WDAC policy, then trusted modules
    and scripts are granted more access than untrusted ones, using a feature called
    language modes.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序控制解决方案可以防止未经授权的应用程序运行。市面上有第三方应用程序，如Trellix，但Windows 10及更高版本自带了两种内置应用程序——**Windows
    Defender 应用程序控制**（**WDAC**）和AppLocker。这些可以用来创建策略，强制执行允许执行的应用程序白名单，并阻止其他任何应用程序运行。由于AppLocker不再进行开发，因此推荐使用WDAC。这些解决方案主要用于企业环境，并允许集中控制。我并不清楚有任何能够与Linux或macOS上的PowerShell一起使用的解决方案。当PowerShell在默认的WDAC策略下运行时，受信任的模块和脚本将比不受信任的模块和脚本获得更多的访问权限，这得益于一种叫做语言模式的功能。
- en: Language modes
  id: totrans-92
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 语言模式
- en: 'Language modes are used to control how scripts can run in a PowerShell environment
    that is subject to an Application Control policy. It’s worth noting that there
    are lots of articles on the internet showing you how to set language modes using
    a variable; this is just for testing how code behaves under a particular mode
    and is not secure, as we’ll shortly. The only way to use language modes to enforce
    security policies is through an application such as WDAC, according to Microsoft.
    There are three language modes:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 语言模式用于控制如何在受应用程序控制策略影响的 PowerShell 环境中运行脚本。值得注意的是，网上有很多文章展示了如何通过变量设置语言模式；这只是用于测试代码在特定模式下的表现，并不安全，正如我们接下来所说的那样。根据微软的说法，唯一能够通过语言模式来强制执行安全策略的方法是通过像
    WDAC 这样的应用程序。共有三种语言模式：
- en: '`FullLanguage`: This is the default when not running under an Application Control
    policy.'
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`FullLanguage`：当未在应用程序控制策略下运行时，这是默认模式。'
- en: '`ConstrainedLanguage`: This prevents the creation and use of certain .NET types
    and restricts access to C# code from PowerShell. It also restricts access to features
    such as `ScheduledJob`. Many scripts will not run in constrained language mode;
    they will need to be signed, and the publishing authority will need to be added
    to the whitelist.'
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ConstrainedLanguage`：这会阻止创建和使用某些 .NET 类型，并限制从 PowerShell 访问 C# 代码。它还限制了对诸如
    `ScheduledJob` 等功能的访问。许多脚本在受限语言模式下无法运行；它们需要签名，并且发布授权机构需要被添加到白名单中。'
- en: '`NoLanguage`: This disables PowerShell scripting completely. Only native commands
    and cmdlets can run. `New-Object` is also disabled.'
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`NoLanguage`：此模式完全禁用 PowerShell 脚本。只能运行本地命令和 cmdlet。`New-Object` 也被禁用。'
- en: 'We can check the language mode of our session by calling the `$ExecutionContext.SessionState.LanguageMode`
    variable, like this:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过调用 `$ExecutionContext.SessionState.LanguageMode` 变量来检查会话的语言模式，如下所示：
- en: '![Figure 12.8 – Getting and setting the language mode](img/B17600_12_008.jpg)'
  id: totrans-98
  prefs: []
  type: TYPE_IMG
  zh: '![图 12.8 – 获取和设置语言模式](img/B17600_12_008.jpg)'
- en: Figure 12.8 – Getting and setting the language mode
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 图 12.8 – 获取和设置语言模式
- en: In the first line, I call the variable, and we can see that the language mode
    is set to `FullLanguage`. I then set the variable to `ConstrainedLanguage`; we
    can see that when I call the variable again, it is now set to `ConstrainedLanguage`.
    Unfortunately, when I try to set it back to `FullLanguage` in the third line,
    I can’t, because we’re in `ConstrainedLanguage` mode, and there is limited access
    to variables. The easiest way to get around this is to close the session and open
    a new one; the language mode will revert to `FullLanguage`. As we discussed previously,
    setting this variable does not make PowerShell secure.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一行，我调用了变量，可以看到语言模式已设置为 `FullLanguage`。然后，我将变量设置为 `ConstrainedLanguage`；我们可以看到，当我再次调用该变量时，它已被设置为
    `ConstrainedLanguage`。不幸的是，当我尝试在第三行将其恢复为 `FullLanguage` 时，失败了，因为我们处于 `ConstrainedLanguage`
    模式，访问变量的权限受限。解决此问题的最简单方法是关闭会话并重新打开一个新的会话；语言模式会恢复为 `FullLanguage`。如我们之前所讨论的，设置这个变量并不能使
    PowerShell 更加安全。
- en: Security servicing criteria
  id: totrans-101
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 安全服务标准
- en: PowerShell is subject to Microsoft’s Security Servicing Criteria for Windows,
    and so some features will receive security updates when vulnerabilities are detected.
    Unfortunately, those features that are included only operate on Windows, such
    as the execution policy and Application Control.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: PowerShell 受微软的 Windows 安全服务标准影响，因此当检测到漏洞时，某些功能会收到安全更新。不幸的是，这些仅在 Windows 上操作的功能，如执行策略和应用程序控制，才会受到影响。
- en: Software Bill of Materials
  id: totrans-103
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 软件材料清单
- en: A **Software Bill of Materials** (**SBOM**) helps provide transparency, integrity,
    and identity to a piece of software by identifying each resource used in its creation,
    and it provides code signing and software identities that can be used to associate
    the software with known vulnerabilities. SBOMs are required by many governments
    as a response to the SolarWinds supply chain attack of 2020\. This is applicable
    to both Windows and Linux/Mac.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: '**软件材料清单**（**SBOM**）通过识别软件创建过程中使用的每个资源，帮助为软件提供透明性、完整性和身份验证，并提供可以用于将软件与已知漏洞关联的代码签名和软件身份。许多政府要求使用
    SBOM，以响应 2020 年的 SolarWinds 供应链攻击。这适用于 Windows 和 Linux/Mac。'
- en: Windows Antimalware Scan Interface support
  id: totrans-105
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Windows 防恶意软件扫描接口支持
- en: PowerShell passes script blocks and .NET invocations to the Windows **Antimalware
    Scan Interface** (**AMSI**) API so that anti-malware applications, such as Windows
    Defender, can inspect them for malicious code. This is a Windows-only feature.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: PowerShell将脚本块和.NET调用传递给Windows **反恶意软件扫描接口**（**AMSI**）API，以便反恶意软件应用程序（如Windows
    Defender）可以检查是否存在恶意代码。这是一个仅适用于Windows的功能。
- en: Secure Shell (SSH) remoting
  id: totrans-107
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 安全外壳（SSH）远程访问
- en: The SSH protocol is a cryptographic protocol that supports secure network services
    over an unsecured network. It is cross-platform and works on both Windows and
    Linux/Mac systems. It relies on public key cryptography; we need to generate a
    key pair and pass the public key to the system we want to remote to. When we subsequently
    open a session, we specify the path to the private key on our machine, and SSH
    verifies that the public key on the remote machine is part of a pair with the
    local private key. At no point is the private key passed over the network. While
    setup is quite complex, using SSH once it is set up is very easy.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: SSH协议是一种加密协议，它支持在不安全的网络上提供安全的网络服务。它是跨平台的，能够在Windows和Linux/Mac系统上运行。它依赖于公钥加密；我们需要生成一对密钥，并将公钥传递给我们想要远程连接的系统。随后当我们打开会话时，我们指定私钥在本机上的路径，SSH会验证远程机器上的公钥是否与本地私钥配对。私钥在任何时候都不会通过网络传输。虽然设置过程相当复杂，但一旦设置完成，使用SSH非常简单。
- en: Just Enough Administration
  id: totrans-109
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 足够的管理权限
- en: '`Get-Process`, using the principle of least privilege, and exclude everything
    else from running, meaning they would be unable to run `Start-Process`. We can
    also configure the endpoint to use virtual privileged accounts so that a user
    doesn’t need to have an admin account at all to run the commands. This allows
    us to drastically reduce the number of users who have admin-privileged accounts.'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: '`Get-Process`，采用最小权限原则，排除其他一切进程运行，这意味着它们将无法运行`Start-Process`。我们还可以配置端点使用虚拟的特权账户，这样用户就不需要管理员账户来运行命令了。这使我们能够大幅度减少拥有管理员权限账户的用户数量。'
- en: As we’ve seen, nearly all of these features are only applicable to Windows environments.
    Luckily, everyone who uses Linux is entirely trustworthy. Let’s look at the features
    that are available to us to understand what PowerShell has been used for – logging.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所见，几乎所有这些功能仅适用于Windows环境。幸运的是，所有使用Linux的人都完全值得信任。让我们来看看可以使用的功能，以便了解PowerShell的用途——日志记录。
- en: PowerShell logging
  id: totrans-112
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: PowerShell日志记录
- en: PowerShell has a number of ways to record what we do with it. In this section,
    we’re going to look at three of them – over the shoulder logging, deep script
    block logging, and module logging.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: PowerShell有多种方式来记录我们使用它的操作。在本节中，我们将介绍其中的三种：肩膀旁的日志记录、深度脚本块日志记录和模块日志记录。
- en: Over the shoulder logging
  id: totrans-114
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 肩膀旁的日志记录
- en: PowerShell can record a transcript of a session, using the `Start-Transcript`
    and `Stop-Transcript` cmdlets. The transcript function will record everything
    that is displayed on the screen. This is useful for recording what we do and the
    output we get, and then sharing it with others.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: PowerShell可以记录会话的转录，通过使用`Start-Transcript`和`Stop-Transcript`命令。转录功能会记录屏幕上显示的所有内容。这对于记录我们所做的操作和获得的输出，并与他人分享非常有用。
- en: We can set the path where the transcript is saved using the `-Path` parameter,
    and we add to an existing transcript with the `-Append` parameter, followed by
    the name and path of an existing transcript. The `-InvocationHeader` parameter
    logs the time each command was run. When we want to stop recording, we can use
    the `Stop-Transcript` cmdlet.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用`-Path`参数设置转录文件的保存路径，并使用`-Append`参数向现有转录文件添加内容，后接现有转录文件的名称和路径。`-InvocationHeader`参数记录每个命令运行的时间。当我们想停止记录时，可以使用`Stop-Transcript`命令。
- en: 'In older versions of PowerShell, we had to perform some magic to ensure that
    transcription was turned on, and even then, it would only log interactive sessions
    in the console, but that is no longer the case. We can turn on automatic transcription
    in Windows systems by either using Group Policy or by editing the `powershell.config.json`
    file in the `$pshome` location – `C:\Program Files\PowerShell\7` in Windows. Editing
    the config file works for both Windows and Linux/Mac, although you may need to
    create it first. To enable transcription, we would need to add the following JSON
    to the file:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 在较早版本的 PowerShell 中，我们需要进行一些操作才能确保转录功能开启，即使如此，它也仅会记录控制台中的交互式会话，但现在情况已经不一样了。我们可以通过使用组策略或编辑位于
    `$pshome` 位置的 `powershell.config.json` 文件来在 Windows 系统中启用自动转录功能——在 Windows 中，该位置是
    `C:\Program Files\PowerShell\7`。编辑配置文件适用于 Windows 和 Linux/Mac，尽管你可能需要先创建该文件。要启用转录功能，我们需要将以下
    JSON 添加到文件中：
- en: '[PRE7]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: To stop transcription, delete the JSON entry.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 要停止转录，只需删除 JSON 条目。
- en: 'The transcript contains a useful header that includes the account the session
    was run under, whether the session was using `RunAs` credentials, such as administrator,
    which version of PowerShell was used, and the process number. Let’s take a look:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 转录文件包含一个有用的头部信息，其中包括会话运行时的账户、会话是否使用了 `RunAs` 凭据（例如管理员）、使用了哪个版本的 PowerShell 以及进程号。让我们来看一下：
- en: '![Figure 12.9 – The transcript header](img/B17600_12_009.jpg)'
  id: totrans-121
  prefs: []
  type: TYPE_IMG
  zh: '![图 12.9 – 转录头部](img/B17600_12_009.jpg)'
- en: Figure 12.9 – The transcript header
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 图 12.9 – 转录头部
- en: I’ve used `Get-Content` with the `-Head` parameter to call the first 19 lines
    of the transcript file, and we can see the information it contains. When I run
    `Stop-Transcript`, the name and path of the transcript file is displayed.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 我使用了带有 `-Head` 参数的 `Get-Content` 命令来调用转录文件的前 19 行，并且我们可以看到它包含的信息。当我运行 `Stop-Transcript`
    时，转录文件的名称和路径会显示出来。
- en: Over the shoulder logging is a very powerful tool for recording what is done
    with PowerShell, especially if transcripts are sent to a central shared location
    and then scanned by a **Security Information and Event Management** (**SIEM**)
    application. However, it doesn’t capture everything. Let’s look at the next technique,
    deep script block logging.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 旁路日志记录是一个非常强大的工具，能够记录 PowerShell 的使用情况，特别是当转录文件被发送到中央共享位置并由 **安全信息与事件管理** (**SIEM**)
    应用程序扫描时。然而，它并不能捕获所有内容。让我们看一下下一个技术——深度脚本块日志记录。
- en: Deep script block logging
  id: totrans-125
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 深度脚本块日志记录
- en: If we call a function or a script, the transcript will record that call, but
    it won’t tell us anything about the contents of the function or script. This is
    where we need deep script block logging, which will record the contents of the
    script and other pertinent information to the logging system. In Windows, this
    is the `PowerShellCore` log, under `/var/log/journal`.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们调用了一个函数或脚本，转录将记录该调用，但它不会告诉我们关于函数或脚本的内容。这时，我们需要启用深度脚本块日志记录，它会记录脚本的内容以及其他相关信息到日志系统中。在
    Windows 中，这就是 `PowerShellCore` 日志，位于 `/var/log/journal`。
- en: We can enable deep script block logging via group policy on Windows, or through
    the config file if the machine we use is not in an Active Directory domain.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过 Windows 上的组策略启用深度脚本块日志记录，或者如果我们使用的机器不在 Active Directory 域中，则可以通过配置文件启用。
- en: 'On my machine, I have edited the `PowerShell.config.json` file to include lines
    4–16 in the following screenshot:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 在我的机器上，我已经编辑了 `PowerShell.config.json` 文件，将第 4–16 行内容包含在以下截图中：
- en: '![Figure 12.10 – Enabling deep script block logging in PowerShell](img/B17600_12_010.jpg)'
  id: totrans-129
  prefs: []
  type: TYPE_IMG
  zh: '![图 12.10 – 在 PowerShell 中启用深度脚本块日志记录](img/B17600_12_010.jpg)'
- en: Figure 12.10 – Enabling deep script block logging in PowerShell
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 图 12.10 – 在 PowerShell 中启用深度脚本块日志记录
- en: Remember that this is JSON, so it is really important to get the syntax correct.
    VS Code will underline any syntax errors. We will also need admin privileges to
    save the file.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，这是 JSON 格式，因此正确的语法非常重要。VS Code 会将任何语法错误标出。我们还需要管理员权限才能保存文件。
- en: 'Now, if I open a new session and call the `HelloWorld.ps1` script that we used
    at the start of this chapter, I can expect to see events appear in my event log,
    like this:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果我打开一个新的会话并调用本章开始时使用的 `HelloWorld.ps1` 脚本，我可以期待在事件日志中看到类似的事件：
- en: '![Figure 12.11 – Script block logging events in the event log](img/B17600_12_011.jpg)'
  id: totrans-133
  prefs: []
  type: TYPE_IMG
  zh: '![图 12.11 – 事件日志中的脚本块日志记录事件](img/B17600_12_011.jpg)'
- en: Figure 12.11 – Script block logging events in the event log
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 图 12.11 – 事件日志中的脚本块日志记录事件
- en: Remember that the `HelloWorld.ps1` script was a single line of code – `Write-Output
    "hello world"`. We can see that line clearly in the preceding event. We can also
    see the account it was run under, when it was run, and on what machine.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，`HelloWorld.ps1`脚本只有一行代码——`Write-Output "hello world"`。我们可以在前面的事件中清楚地看到这一行代码。我们还可以看到运行该代码的账户、运行时间以及运行所在的机器。
- en: Module logging
  id: totrans-136
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 模块日志记录
- en: The final type of logging we’ll look at is module logging. This is similar to
    script block logging and tracks the modules that are being loaded and called in
    PowerShell. This can generate a lot of information quite quickly, so there is
    an option to only record specified modules. If we want to record all the modules,
    then we can use a wildcard (`*`) instead of an array of module names in the JSON
    we add to the config file. Again, if group policy is available, then we can use
    it to enable module logging.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将要查看的最后一种日志记录类型是模块日志记录。这类似于脚本块日志记录，跟踪PowerShell中加载和调用的模块。这可能会迅速生成大量信息，因此可以选择仅记录指定的模块。如果我们想记录所有模块，可以在添加到配置文件的JSON中使用通配符（`*`）而不是模块名称的数组。同样，如果有组策略可用，我们可以使用它来启用模块日志记录。
- en: There are other types of logging available, but they are quite specialized,
    such as protected event logging for events that may contain sensitive information,
    such as personal details. I’ve not needed to use them.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 还有其他类型的日志记录可用，但它们是相当专业化的，例如用于可能包含敏感信息（如个人详细信息）的事件的保护事件日志记录。我自己没有需要使用这些。
- en: That wraps up the security features we’re going to cover. Let’s move on to the
    final section of this chapter and look at ways we can write secure code.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是我们要介绍的安全功能。接下来让我们进入本章的最后部分，看看如何编写安全代码。
- en: Writing secure code
  id: totrans-140
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编写安全代码
- en: Most code has security flaws; it is our job to make sure that the code we write
    is as secure as possible. In this section, we will look at some ways to write
    more secure PowerShell code. We’ll look at how to store passwords our scripts
    might need, code signing scripts, and parameter validation.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数代码都有安全漏洞；我们的工作是确保我们编写的代码尽可能安全。在本节中，我们将探讨一些编写更安全PowerShell代码的方法。我们将看看如何存储脚本可能需要的密码、对脚本进行代码签名和参数验证。
- en: Storing passwords securely
  id: totrans-142
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 安全存储密码
- en: 'Quite often, we will write a script that contains commands that need to be
    run with a particular set of credentials. We saw how to store credentials in an
    XML file in [*Chapter 6*](B17600_06.xhtml#_idTextAnchor117), *PowerShell and Files
    – Reading, Writing, and Manipulating Data*. To recap, we can do it like this:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 很多时候，我们会编写一个包含需要使用特定凭证执行的命令的脚本。我们在[*第6章*](B17600_06.xhtml#_idTextAnchor117)，*PowerShell和文件——读取、写入和操作数据*中看到过如何将凭证存储在XML文件中。简单回顾一下，我们可以这样做：
- en: '[PRE8]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The credential is then stored in an XML object. This object contains an encrypted
    standard string, which is the password that was entered encrypted with a reversible
    encryption, based on the account and machine that the string was encrypted on.
    Let’s look at how this works.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 凭证随后存储在一个XML对象中。这个对象包含一个加密的标准字符串，它是通过基于账户和加密机器的可逆加密加密的密码。让我们看看它是如何工作的。
- en: 'I have a password that I want to save as a secure string:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 我有一个想要作为安全字符串保存的密码：
- en: '[PRE9]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'To turn it into a secure string, I use the `ConvertTo-SecureString` cmdlet:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 要将其转换为安全字符串，我使用`ConvertTo-SecureString` cmdlet：
- en: '[PRE10]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'The password is now encrypted, as we can see if we try this:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，密码已经被加密了，如果我们尝试这样做的话，可以看到这一点：
- en: '[PRE11]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Encryption, in this case, is based on the logged-on account and the machine,
    and the string cannot be decrypted by anyone other than the original user (or
    someone logged on as them) on the original machine. Let’s see how it looks:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，加密是基于登录账户和机器的，只有原始用户（或以原始用户身份登录的人）在原始机器上才能解密该字符串。让我们看看它的表现如何：
- en: '![Figure 12.12 – Putting a password in a secure string](img/B17600_12_012.jpg)'
  id: totrans-153
  prefs: []
  type: TYPE_IMG
  zh: '![图12.12 – 将密码放入安全字符串](img/B17600_12_012.jpg)'
- en: Figure 12.12 – Putting a password in a secure string
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.12 – 将密码放入安全字符串
- en: On line 1, I create a variable called `$pwd` that holds a string, `ILovePowerShell`.
    On line 2, I create a new variable, `$securepwd`, by piping `$pwd` to the `ConvertTo-SecureString`
    cmdlet, with the `-AsPlainText` parameter, and use the `-Force` parameter to suppress
    any prompts. On line 3, I convert the contents of `$securepwd` back from a secure
    string to text and store it in the `$encryptedpwd` variable. Finally, on line
    4, I write the contents of the `$encryptedpwd` variable, and as we can see, it
    is now an encrypted string, not the original password.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 在第1行，我创建了一个名为`$pwd`的变量，保存了一个字符串`ILovePowerShell`。在第2行，我通过将`$pwd`传递给`ConvertTo-SecureString`
    cmdlet，并使用`-AsPlainText`参数，再配合`-Force`参数以抑制任何提示，创建了一个新的变量`$securepwd`。在第3行，我将`$securepwd`的内容从安全字符串转换回文本，并将其存储在`$encryptedpwd`变量中。最后，在第4行，我输出`$encryptedpwd`变量的内容，正如我们所看到的，它现在是一个加密字符串，而不是原始密码。
- en: '`$encryptedpwd` can be stored in a file or in the registry, and it can be used
    to create a `PSCredential` object that can be passed to a cmdlet, using the `Add-Content`
    cmdlet:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: '`$encryptedpwd`可以存储在文件或注册表中，并且可以用来创建一个`PSCredential`对象，传递给cmdlet，使用`Add-Content`
    cmdlet：'
- en: '![Figure 12.13 – Adding a password to a PSCredential as a secure string](img/B17600_12_013.jpg)'
  id: totrans-157
  prefs: []
  type: TYPE_IMG
  zh: '![图 12.13 – 将密码作为安全字符串添加到PSCredential](img/B17600_12_013.jpg)'
- en: Figure 12.13 – Adding a password to a PSCredential as a secure string
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 图 12.13 – 将密码作为安全字符串添加到PSCredential
- en: On line 1, I add the content of `$encryptedpwd` to a file, `encryptedpwd.txt`.
    On line 2, I add the contents of the file to a variable, `$securepwd2`, after
    converting it to a secure string. On line 3, I create a new `PSCredential` object
    with two values – a username string and the `$securepwd2` variable. Finally, on
    line 4, I check the password property of the credential, and we can see it is
    `ILovePowerShell`, the string I originally started with, on line 5\. In this way,
    we can store passwords securely in a file on a machine, and they can’t be copied
    to another machine and decrypted. Of course, someone can remote into PowerShell
    on the machine and decrypt them, so it’s not bulletproof.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 在第1行，我将`$encryptedpwd`的内容添加到一个文件`encryptedpwd.txt`中。在第2行，我将该文件的内容转换为安全字符串并存入一个变量`$securepwd2`中。在第3行，我创建了一个新的`PSCredential`对象，包含两个值——用户名字符串和`$securepwd2`变量。最后，在第4行，我检查凭据的密码属性，正如我们所看到的，它是`ILovePowerShell`，即我最初使用的字符串，在第5行。通过这种方式，我们可以将密码安全地存储在计算机上的文件中，且无法将其复制到另一台计算机并进行解密。当然，有人可以远程连接到PowerShell并进行解密，所以这并非万无一失。
- en: So, what is the difference between a secure string and an encrypted string?
    An encrypted string is a plain text string that has been encrypted, as you can
    see if you look in the `encryptedpwd.txt` file. A secure string is an object of
    type `System.Security.SecureString`. They are two different types. Many PowerShell
    cmdlets will only accept passwords of type `System.Security.SecureString`, so
    it’s important to understand which type is needed.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，安全字符串和加密字符串之间有什么区别呢？加密字符串是一个明文字符串，它已经被加密，正如你在`encryptedpwd.txt`文件中看到的那样。安全字符串是`System.Security.SecureString`类型的对象。它们是两种不同的类型。许多PowerShell
    cmdlet只接受`System.Security.SecureString`类型的密码，因此理解需要哪种类型是非常重要的。
- en: Signing scripts
  id: totrans-161
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 签名脚本
- en: Earlier in this chapter, we discussed execution policies and how they rely on
    scripts being signed to determine their trustworthiness. A digital signature does
    two things – it provides assurance that the script was signed by a trusted source
    and verifies that the script has not been edited after it was signed.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章前面，我们讨论了执行策略以及它们如何依赖于脚本签名来确定脚本的可信度。数字签名有两个作用——它提供了脚本由可信来源签名的保证，并验证了脚本在签名后是否未被编辑。
- en: To sign a script, we need either a code-signing certificate from a trusted authority,
    such as VeriSign, that will be trusted by the majority of computers, a certificate
    from an Active Directory certificate authority that will be trusted by machines
    within that directory, or we can use a self-signed certificate that will only
    be trusted on the machine that was used to sign the script. Code-signing certificates
    are not cheap, and while there are a few companies that may be exploring such
    a thing, at the time of writing they’re not generally available.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 要签署一个脚本，我们需要一个来自可信机构的代码签名证书，例如VeriSign，它会被大多数计算机信任，或者来自Active Directory证书授权中心的证书，这会被该目录中的计算机信任，或者我们可以使用自签名证书，这种证书仅在用于签署脚本的计算机上有效。代码签名证书并不便宜，虽然有一些公司可能在探索这种方法，但截至写作时，这些证书还没有普遍可用。
- en: Once we have a code-signing certificate, we can use the `Set-AuthenticodeSignature`
    cmdlet to sign the script with our certificate. The signature includes a hash
    of the script, so any changes made after signing will break the signature and
    lead to the script not being trusted. This signing only works on Windows environments,
    much like the execution policy feature that makes use of it.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们拥有了代码签名证书，就可以使用`Set-AuthenticodeSignature` cmdlet通过证书对脚本进行签名。签名包括脚本的哈希值，因此签名后所做的任何更改都会破坏签名，导致脚本无法被信任。此签名仅在Windows环境中有效，类似于执行策略功能的使用方式。
- en: Parameter security
  id: totrans-165
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参数安全性
- en: 'We saw in [*Chapter 8*](B17600_08.xhtml#_idTextAnchor162), *PowerShell and
    Files – Reading, Writing, and Manipulating Data*, that we can use accelerators
    to force a parameter to only accept a specific type of input. We can also use
    regular expressions to ensure that the input is in the right format, such as a
    date string or IP address. This code will test a parameter and only accept date
    strings in the DD/MM/YYYY format:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 在[*第8章*](B17600_08.xhtml#_idTextAnchor162)，*PowerShell和文件——读取、写入和操作数据*中，我们看到可以使用加速器强制参数只接受特定类型的输入。我们还可以使用正则表达式来确保输入格式正确，例如日期字符串或IP地址。以下代码将测试一个参数，并且只接受DD/MM/YYYY格式的日期字符串：
- en: '[PRE12]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'We can see how it looks in the following screenshot:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在以下截图中看到它的效果：
- en: '![Figure 12.14 – Validating parameter input](img/B17600_12_014.jpg)'
  id: totrans-169
  prefs: []
  type: TYPE_IMG
  zh: '![图12.14 – 验证参数输入](img/B17600_12_014.jpg)'
- en: Figure 12.14 – Validating parameter input
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.14 – 验证参数输入
- en: I’ve created a `Test-Date` function that uses a regular expression to test whether
    the input is a valid date or not. When I pass a valid date in the correct format,
    the function returns `True`. When I pass an invalid date, `21/13/2023`, it returns
    `False`. We could use that return value to stop a script from continuing, or to
    prompt for valid input.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 我创建了一个`Test-Date`函数，使用正则表达式来测试输入是否为有效日期。当我传入一个格式正确的有效日期时，函数返回`True`。当我传入一个无效日期`21/13/2023`时，它返回`False`。我们可以利用返回值来阻止脚本继续执行，或者提示用户输入有效值。
- en: The preceding instance is trivial, but it is possible for unvalidated parameters
    to be used for malicious code injection, where code is inserted into the parameter
    and then executed. Parameter validation can help prevent this.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 上面的例子是微不足道的，但未经验证的参数可能会用于恶意代码注入，即代码被插入到参数中并执行。参数验证有助于防止这种情况。
- en: That wraps up what we are going to cover in this chapter. Let’s summarize what
    we’ve learned.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是本章内容的总结。让我们回顾一下我们学到的知识。
- en: Summary
  id: totrans-174
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: We started this chapter by looking at PowerShell remoting and saw how the feature
    can make PowerShell a security risk. We looked at how to create, join, and leave
    sessions and how to run expressions on multiple remote computers at once.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 本章开始时，我们研究了PowerShell远程执行功能，发现该功能可能使PowerShell成为安全风险。我们了解了如何创建、加入和离开会话，以及如何同时在多个远程计算机上执行表达式。
- en: We then moved on to see how we could secure PowerShell against inadvertent mistakes
    and saw how the execution policy can *“…slow down an uninformed user who is unintentionally
    trying to run an untrusted script.*” We also saw some of the other early security
    features, such as requiring an absolute or relative path for script execution.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 接着我们探讨了如何保护PowerShell免受无意错误的影响，了解到执行策略可以*“…减缓一个未受过培训的用户，他们无意间试图运行一个不受信任的脚本。”*
    我们还看到了一些其他早期的安全功能，比如要求脚本执行时使用绝对路径或相对路径。
- en: We then looked at more modern security features, many of which only apply to
    Windows, such as Application Control and language modes. Unfortunately, the security
    features for Linux and macOS are still sadly lacking.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们讨论了更现代的安全功能，其中许多仅适用于Windows，例如应用程序控制和语言模式。不幸的是，Linux和macOS的安全功能仍然缺乏。
- en: We looked at the different ways of recording what PowerShell is doing, with
    over the shoulder logging, script block logging, and module logging, and saw how
    to turn these features on and off and where to find the logs.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 我们了解了记录PowerShell操作的不同方式，包括肩膀日志、脚本块日志和模块日志，并了解了如何开启或关闭这些功能，以及在哪里查看日志。
- en: In the final section, we looked at three techniques for writing scripts more
    securely – storing passwords as encrypted strings, signing our scripts, and validating
    parameters.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 在最后一部分，我们探讨了三种编写更安全脚本的技术——将密码存储为加密字符串、签署我们的脚本和验证参数。
- en: That’s it for this chapter, and for this part of the book, where we’ve looked
    at scripting and tooling. In the final part of the book, we’ll be looking at how
    PowerShell works in three different environments – Windows, Linux/macOS, and ARM
    – finishing off with a chapter on using PowerShell with .NET, the underlying platform
    that PowerShell is built on. I’m looking forward to it.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的内容就到这里，这部分我们讨论了脚本编写和工具使用。在书的最后一部分，我们将探讨 PowerShell 在三个不同环境中的应用——Windows、Linux/macOS
    和 ARM，并以一章关于如何在 .NET 平台上使用 PowerShell 作为结束。很期待这部分内容。
- en: Exercises
  id: totrans-181
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 练习
- en: Which cmdlet is used to create a new PowerShell session for remote administration?
  id: totrans-182
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 哪个 cmdlet 用于创建一个新的 PowerShell 会话以进行远程管理？
- en: How can we use PowerShell remoting securely on Linux?
  id: totrans-183
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如何在 Linux 上安全地使用 PowerShell 远程操作？
- en: Which execution policy in PowerShell allows only signed scripts to run?
  id: totrans-184
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: PowerShell 中允许仅运行已签名脚本的执行策略是什么？
- en: What is the purpose of the `-ExecutionPolicy` `Bypass` switch?
  id: totrans-185
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`-ExecutionPolicy` `Bypass` 开关的目的是什么？'
- en: On Windows, what can be used to analyze and block known malicious scripts and
    configurations?
  id: totrans-186
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 Windows 上，如何分析并阻止已知的恶意脚本和配置？
- en: What is the purpose of the constrained language mode in PowerShell?
  id: totrans-187
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: PowerShell 中限制语言模式的目的是什么？
- en: How can you restrict the use of specific cmdlets for a particular user in PowerShell
    on Windows?
  id: totrans-188
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如何在 Windows 上限制特定用户使用 PowerShell 中的特定 cmdlet？
- en: What is script block logging in PowerShell, and why is it important for security?
  id: totrans-189
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: PowerShell 中的脚本块日志记录是什么？它为何对安全性重要？
- en: What is the difference between a secure string and an encrypted string?
  id: totrans-190
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 安全字符串和加密字符串有什么区别？
- en: Further reading
  id: totrans-191
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: 'PowerShell remoting:'
  id: totrans-192
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: PowerShell 远程操作：
- en: '[https://learn.microsoft.com/en-us/powershell/scripting/learn/ps101/08-powershell-remoting](https://learn.microsoft.com/en-us/powershell/scripting/learn/ps101/08-powershell-remoting)'
  id: totrans-193
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '[https://learn.microsoft.com/en-us/powershell/scripting/learn/ps101/08-powershell-remoting](https://learn.microsoft.com/en-us/powershell/scripting/learn/ps101/08-powershell-remoting)'
- en: 'Execution policies:'
  id: totrans-194
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 执行策略：
- en: '[https://learn.microsoft.com/en-us/powershell/module/microsoft.powershell.core/about/about_execution_policies](https://learn.microsoft.com/en-us/powershell/module/microsoft.powershell.core/about/about_execution_policies)'
  id: totrans-195
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '[https://learn.microsoft.com/en-us/powershell/module/microsoft.powershell.core/about/about_execution_policies](https://learn.microsoft.com/en-us/powershell/module/microsoft.powershell.core/about/about_execution_policies)'
- en: 'Application Control:'
  id: totrans-196
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应用控制：
- en: '[https://learn.microsoft.com/en-gb/Windows/security/application-security/application-control/Windows-defender-application-control/wdac](https://learn.microsoft.com/en-gb/Windows/security/application-security/application-control/Windows-defender-application-control/wdac)'
  id: totrans-197
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://learn.microsoft.com/en-gb/Windows/security/application-security/application-control/Windows-defender-application-control/wdac](https://learn.microsoft.com/en-gb/Windows/security/application-security/application-control/Windows-defender-application-control/wdac)'
- en: '[https://learn.microsoft.com/en-us/powershell/scripting/learn/application-control](https://learn.microsoft.com/en-us/powershell/scripting/learn/application-control)'
  id: totrans-198
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://learn.microsoft.com/en-us/powershell/scripting/learn/application-control](https://learn.microsoft.com/en-us/powershell/scripting/learn/application-control)'
- en: 'Language modes:'
  id: totrans-199
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 语言模式：
- en: '[https://learn.microsoft.com/en-us/powershell/module/microsoft.powershell.core/about/about_language_modes](https://learn.microsoft.com/en-us/powershell/module/microsoft.powershell.core/about/about_language_modes)'
  id: totrans-200
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '[https://learn.microsoft.com/en-us/powershell/module/microsoft.powershell.core/about/about_language_modes](https://learn.microsoft.com/en-us/powershell/module/microsoft.powershell.core/about/about_language_modes)'
- en: 'Security Servicing Criteria:'
  id: totrans-201
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 安全服务标准：
- en: '[https://www.microsoft.com/en-us/msrc/Windows-security-servicing-criteria](https://www.microsoft.com/en-us/msrc/Windows-security-servicing-criteria)'
  id: totrans-202
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '[https://www.microsoft.com/en-us/msrc/Windows-security-servicing-criteria](https://www.microsoft.com/en-us/msrc/Windows-security-servicing-criteria)'
- en: 'SBOM:'
  id: totrans-203
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: SBOM：
- en: '[https://devblogs.microsoft.com/engineering-at-microsoft/generating-software-bills-of-materials-sboms-with-spdx-at-microsoft/](https://devblogs.microsoft.com/engineering-at-microsoft/generating-software-bills-of-materials-sboms-with-spdx-at-microsoft/)'
  id: totrans-204
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '[https://devblogs.microsoft.com/engineering-at-microsoft/generating-software-bills-of-materials-sboms-with-spdx-at-microsoft/](https://devblogs.microsoft.com/engineering-at-microsoft/generating-software-bills-of-materials-sboms-with-spdx-at-microsoft/)'
- en: 'SSH:'
  id: totrans-205
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: SSH：
- en: '[https://en.wikipedia.org/wiki/Secure_Shell](https://en.wikipedia.org/wiki/Secure_Shell)'
  id: totrans-206
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://en.wikipedia.org/wiki/Secure_Shell](https://en.wikipedia.org/wiki/Secure_Shell)'
- en: '[https://learn.microsoft.com/en-us/powershell/scripting/learn/remoting/ssh-remoting-in-powershell-core](https://learn.microsoft.com/en-us/powershell/scripting/learn/remoting/ssh-remoting-in-powershell-core)'
  id: totrans-207
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://learn.microsoft.com/en-us/powershell/scripting/learn/remoting/ssh-remoting-in-powershell-core](https://learn.microsoft.com/en-us/powershell/scripting/learn/remoting/ssh-remoting-in-powershell-core)'
- en: 'JEA:'
  id: totrans-208
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: JEA：
- en: '[https://learn.microsoft.com/en-us/powershell/scripting/learn/remoting/jea/overview](https://learn.microsoft.com/en-us/powershell/scripting/learn/remoting/jea/overview)'
  id: totrans-209
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '[https://learn.microsoft.com/zh-cn/powershell/scripting/learn/remoting/jea/overview](https://learn.microsoft.com/zh-cn/powershell/scripting/learn/remoting/jea/overview)'
- en: 'A deep dive into PowerShell logging:'
  id: totrans-210
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 深入了解 PowerShell 日志记录：
- en: '[https://devblogs.microsoft.com/powershell/powershell-the-blue-team/](https://devblogs.microsoft.com/powershell/powershell-the-blue-team/)'
  id: totrans-211
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '[https://devblogs.microsoft.com/powershell/powershell-the-blue-team/](https://devblogs.microsoft.com/powershell/powershell-the-blue-team/)'
- en: Logging on Windows
  id: totrans-212
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Windows 上的日志记录
- en: '[https://learn.microsoft.com/en-us/powershell/module/microsoft.powershell.core/about/about_logging_Windows](https://learn.microsoft.com/en-us/powershell/module/microsoft.powershell.core/about/about_logging_Windows)'
  id: totrans-213
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '[https://learn.microsoft.com/zh-cn/powershell/module/microsoft.powershell.core/about/about_logging_Windows](https://learn.microsoft.com/zh-cn/powershell/module/microsoft.powershell.core/about/about_logging_Windows)'
- en: Logging on Linux and macOS
  id: totrans-214
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Linux 和 macOS 上的日志记录
- en: '[https://learn.microsoft.com/en-us/powershell/module/microsoft.powershell.core/about/about_logging_non-Windows](https://learn.microsoft.com/en-us/powershell/module/microsoft.powershell.core/about/about_logging_non-Windows)'
  id: totrans-215
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '[https://learn.microsoft.com/zh-cn/powershell/module/microsoft.powershell.core/about/about_logging_non-Windows](https://learn.microsoft.com/zh-cn/powershell/module/microsoft.powershell.core/about/about_logging_non-Windows)'
- en: 'Part 3: Using PowerShell'
  id: totrans-216
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第三部分：使用 PowerShell
- en: 'Now we understand how to use PowerShell 7, and how to write simple scripts
    and modules, it’s time to learn how to use it on different platforms. One of the
    defining features of PowerShell 7 is that it is cross-platform. This section will
    detail how to use PowerShell with a variety of platforms. This part has the following
    chapters:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经了解了如何使用 PowerShell 7，以及如何编写简单的脚本和模块，是时候学习如何在不同平台上使用它了。PowerShell 7 的一个重要特点是它是跨平台的。本节将详细介绍如何在各种平台上使用
    PowerShell。本部分包括以下章节：
- en: '[*Chapter 13*](B17600_13.xhtml#_idTextAnchor267), *Working with PowerShell
    7 and Windows*'
  id: totrans-218
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第13章*](B17600_13.xhtml#_idTextAnchor267)，*在 PowerShell 7 和 Windows 中工作*'
- en: '[*Chapter 14*](B17600_14.xhtml#_idTextAnchor280), *PowerShell 7 for Linux and
    macOS*'
  id: totrans-219
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第14章*](B17600_14.xhtml#_idTextAnchor280)，*PowerShell 7 在 Linux 和 macOS 上的使用*'
- en: '[*Chapter 15*](B17600_15.xhtml#_idTextAnchor302), *PowerShell 7 and the Raspberry
    Pi*'
  id: totrans-220
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第15章*](B17600_15.xhtml#_idTextAnchor302)，*PowerShell 7 和 Raspberry Pi*'
- en: '[*Chapter 16*](B17600_16.xhtml#_idTextAnchor320), *Working with PowerShell
    and .NET*'
  id: totrans-221
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第16章*](B17600_16.xhtml#_idTextAnchor320)，*在 PowerShell 和 .NET 中工作*'
