- en: '12'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '12'
- en: Prototyping with Add-On Boards
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用扩展板进行原型设计
- en: '**Custom board bring-up** is what embedded Linux engineers are called on to
    do time and time again. Say a consumer electronics manufacturer wants to build
    a new device and that device needs to run Linux. The process of assembling the
    Linux image starts before the hardware is ready and is done with prototypes pieced
    together from SBCs and add-on boards. Once a proof of concept has been validated
    then an initial run of prototype PCBs is fabricated with peripherals on board.
    There is no more satisfying experience than seeing a custom board boot into Linux
    for the very first time.'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: '**定制板的启用**是嵌入式 Linux 工程师一遍又一遍需要做的事情。假设一个消费电子产品制造商想要构建一款新设备，并且该设备需要运行 Linux。在硬件准备就绪之前，Linux
    镜像的组装过程就已经开始，并且通过将 SBC 和扩展板拼接在一起的原型来完成。验证了概念验证后，初步的原型 PCB 将与外设一起制作。没有什么比看到定制板首次启动到
    Linux 系统中更令人满意的经历了。'
- en: The BeaglePlay is unique among SBCs in that it has a mikroBUS socket for quick
    plug and play peripheral expansion. There is a MikroE Click add-on board for just
    about any hardware peripheral you can think of. In this chapter, we will integrate
    a GNSS receiver, environmental sensor module, and OLED display with the BeaglePlay.
    Leveraging mikroBUS eliminates the need to read schematics and wire up breadboards
    so that you spend less time troubleshooting hardware and more time coding your
    application.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: BeaglePlay 在单板计算机（SBC）中独树一帜，因为它具有一个 mikroBUS 插槽，可以快速实现即插即用的外设扩展。几乎任何硬件外设，都可以找到相应的
    MikroE Click 扩展板。在本章中，我们将集成 GNSS 接收器、环境传感器模块和 OLED 显示屏与 BeaglePlay。利用 mikroBUS
    消除了阅读原理图和布线面包板的需要，这样你就能将更多时间花在编写应用程序上，而不是在硬件调试上。
- en: Rapid prototyping with real hardware involves lots of trial and error. With
    a full Debian Linux distribution at our disposal, we can use mainstream tools
    such as `git`, `pip3`, and `python3` to develop software directly on the BeaglePlay.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 使用真实硬件进行快速原型设计涉及大量的试错。借助完整的 Debian Linux 发行版，我们可以使用主流工具，如 `git`、`pip3` 和 `python3`，直接在
    BeaglePlay 上开发软件。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下主题：
- en: Mapping schematics to pins
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将原理图映射到引脚
- en: Prototyping with add-on boards
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用扩展板进行原型设计
- en: Testing hardware peripherals
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 测试硬件外设
- en: Technical requirements
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'To follow along with the examples, make sure you have the following:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 为了跟随示例，确保你拥有以下设备：
- en: An Ubuntu 24.04 or later LTS host system
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一台 Ubuntu 24.04 或更高版本的 LTS 主机系统
- en: A microSD card reader and card
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个 microSD 卡读卡器和卡
- en: balenaEtcher for Linux
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 适用于 Linux 的 balenaEtcher
- en: A BeaglePlay
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个 BeaglePlay
- en: A 5V USB-C power supply capable of delivering 3A
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个能够提供 3A 电流的 5V USB-C 电源
- en: A USB to TTL serial cable with 3.3V logic level
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个带有 3.3V 逻辑电平的 USB 转 TTL 串口电缆
- en: An Ethernet cable and router with an available port for network connectivity
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一根以太网线和一个带有可用端口的路由器，用于网络连接
- en: A MikroE-5764 GNSS 7 Click add-on board
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个 MikroE-5764 GNSS 7 Click 扩展板
- en: An external active GNSS antenna
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个外部有源 GNSS 天线
- en: A MikroE-5546 Environment Click add-on board
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个 MikroE-5546 环境 Click 扩展板
- en: A MikroE-5545 OLED C Click add-on board
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个 MikroE-5545 OLED C Click 扩展板
- en: 'The code used in this chapter can be found in the chapter folder in this book’s
    GitHub repository: [https://github.com/PacktPublishing/Mastering-Embedded-Linux-Development/tree/main/Chapter12](https://github.com/PacktPublishing/Mastering-Embedded-Linux-Development/tree/main/Chapter12).'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 本章使用的代码可以在本书 GitHub 仓库的章节文件夹中找到：[https://github.com/PacktPublishing/Mastering-Embedded-Linux-Development/tree/main/Chapter12](https://github.com/PacktPublishing/Mastering-Embedded-Linux-Development/tree/main/Chapter12)。
- en: Mapping schematics to pins
  id: totrans-23
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将原理图映射到引脚
- en: Because the BeaglePlay’s **Bill Of Materials** (**BOM**), PCB design files,
    and schematics are all open source, anyone can manufacture a BeaglePlay as part
    of their consumer product. Since the BeaglePlay is intended for development, it
    contains several components that may not be needed for production, such as Ethernet
    ports, USB ports, and a microSD slot. As a dev board, the BeaglePlay may also
    be missing one or more peripherals needed for your application such as sensors,
    an LTE modem, or an OLED display.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 因为 BeaglePlay 的 **物料清单**（**BOM**）、PCB 设计文件和原理图都是开源的，任何人都可以将 BeaglePlay 制作为他们的消费产品的一部分。由于
    BeaglePlay 主要用于开发，它包含了一些生产中可能不需要的组件，例如以太网端口、USB 端口和 microSD 卡槽。作为开发板，BeaglePlay
    也可能缺少一个或多个应用所需的外设，例如传感器、LTE 调制解调器或 OLED 显示屏。
- en: The BeaglePlay is built around Texas Instruments’ AM6254, a quad-core 64-bit
    Arm Cortex-A53 SoC with **Programmable Real-Time Unit** (**PRU**) and M4 microcontrollers.
    Like the Raspberry Pi 4, the BeaglePlay has built-in Wi-Fi and Bluetooth. Unlike
    other SBCs, it also has a programmable radio capable of sub-GHz and 2.4 GHz low-power
    wireless communication. While the BeaglePlay is extremely versatile, at some point
    you may want to design your own custom PCB around the AM6254 to reduce the cost
    of your finished product.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: BeaglePlay 采用的是德州仪器的 AM6254 处理器，这是一款四核 64 位 Arm Cortex-A53 SoC，配备了**可编程实时单元**（**PRU**）和
    M4 微控制器。与 Raspberry Pi 4 相似，BeaglePlay 具有内置 Wi-Fi 和蓝牙。与其他 SBC 不同，它还具有一个可编程无线电，支持亚
    GHz 和 2.4 GHz 低功耗无线通信。虽然 BeaglePlay 非常多功能，但在某些情况下，你可能想围绕 AM6254 设计自己的定制 PCB，以降低最终产品的成本。
- en: In [*Chapter 11*](Chapter_11.xhtml#_idTextAnchor373), we looked at an example
    of how to bind an Ethernet adapter to a Linux device driver. Binding peripherals
    is done with device tree source or C structs known as platform data. Over the
    years, device tree source has become the preferred means of binding to Linux device
    drivers, especially on Arm SoCs. As with U-Boot, compiling device tree source
    into DTBs is also part of the Linux kernel build process.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [*第11章*](Chapter_11.xhtml#_idTextAnchor373) 中，我们讨论了如何将以太网适配器绑定到 Linux 设备驱动的示例。外设绑定通过设备树源代码或
    C 结构体（即平台数据）进行。多年来，设备树源代码已成为绑定到 Linux 设备驱动的首选方式，特别是在 Arm SoC 上。与 U-Boot 一样，将设备树源代码编译为
    DTB 也是 Linux 内核构建过程的一部分。
- en: If you need to transfer lots of packets from a local network to and from the
    cloud, then running Linux is a sensible choice since it has an extremely mature
    TCP/IP network stack. The BeaglePlay’s Arm Cortex-A53 CPU meets the requirements
    (enough addressable RAM and a memory management unit) for running mainstream Linux.
    This means your product can benefit from security and bug fixes that have been
    done to the Linux kernel.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你需要从本地网络到云端传输大量数据包，那么运行 Linux 是一个明智的选择，因为它具有非常成熟的 TCP/IP 网络栈。BeaglePlay 的
    Arm Cortex-A53 CPU 满足运行主流 Linux 的要求（足够的可寻址内存和内存管理单元）。这意味着你的产品可以受益于 Linux 内核的安全性和错误修复。
- en: Now that we have selected our SBC let’s look at the BeaglePlay’s schematic.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经选择了 SBC，接下来让我们看看 BeaglePlay 的原理图。
- en: Reading schematics
  id: totrans-29
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 阅读原理图
- en: The BeaglePlay has a mikroBUS socket as well as Grove and QWIIC connectors for
    add-on boards. Of the three standards, mikroBUS is the only one with UART, I2C,
    and SPI communications ports as well as **Analog to Digital Converter** (**ADC**),
    **Pulse Width Modulation** (**PWM**), and GPIO functionality. Consider I/O expansion
    options when selecting an SBC for development. More options mean more peripheral
    modules to choose from when prototyping.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: BeaglePlay 配备了 mikroBUS 插座以及 Grove 和 QWIIC 接口，用于连接附加板。在这三种标准中，mikroBUS 是唯一一个具有
    UART、I2C 和 SPI 通信端口，以及**模拟到数字转换器**（**ADC**）、**脉冲宽度调制**（**PWM**）和 GPIO 功能的标准。在选择
    SBC 进行开发时，可以考虑 I/O 扩展选项。更多选项意味着在原型设计时可以选择更多外设模块。
- en: When given the choice, I usually pick SPI over UART and I2C for production.
    UARTs are scarce on many SoCs and reserved for things such as Bluetooth and/or
    a serial console. I2C drivers and hardware can have serious bugs. Some I2C kernel
    drivers are so poorly implemented that the bus locks up when there are too many
    connected peripherals talking at once. Other times the bugs are in hardware. The
    I2C controllers found in Broadcom SoCs such as the one in the Raspberry Pi 4 are
    notorious for glitching when peripherals attempt to perform **clock stretching**.
    Clock stretching is when an I2C subnode device temporarily slows down or stops
    the bus clock.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 在有选择的情况下，我通常在生产中选择 SPI 而不是 UART 和 I2C。许多 SoC 上的 UART 数量有限，通常保留用于蓝牙和/或串行控制台。I2C
    驱动程序和硬件可能存在严重的 Bug。有些 I2C 内核驱动实现得非常糟糕，当连接过多外设同时通信时，总线可能会锁死。其他时候，Bug 可能出现在硬件上。广受诟病的
    Broadcom SoC 中的 I2C 控制器（例如 Raspberry Pi 4 中的控制器）在外设尝试执行**时钟拉伸**时容易出现故障。时钟拉伸是指
    I2C 子节点设备临时减慢或停止总线时钟。
- en: Every mikroBUS socket consists of two pairs of 1x8 female headers. We can find
    both header strips on page 22 of the BeaglePlay’s schematic ([https://github.com/beagleboard/beagleplay/blob/main/BeaglePlay_sch.pdf](https://github.com/beagleboard/beagleplay/blob/main/BeaglePlay_sch.pdf)).
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 每个 mikroBUS 插座由两对 1x8 母头排针组成。我们可以在 BeaglePlay 的原理图第 22 页找到这两个排针条（[https://github.com/beagleboard/beagleplay/blob/main/BeaglePlay_sch.pdf](https://github.com/beagleboard/beagleplay/blob/main/BeaglePlay_sch.pdf)）。
- en: 'Here is the right header strip of the BeaglePlay’s mikroBUS socket:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 这是 BeaglePlay 的 mikroBUS 插座的右侧排针：
- en: '![Figure 12.1 – mikroBUS socket (right header strip)](img/B18466_12_01.png)'
  id: totrans-34
  prefs: []
  type: TYPE_IMG
  zh: '![图12.1 – mikroBUS插槽（右侧接头条带）](img/B18466_12_01.png)'
- en: Figure 12.1 – mikroBUS socket (right header strip)
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.1 – mikroBUS插槽（右侧接头条带）
- en: Pin 1 is tied to ground and pin 2 outputs 5V. Pins 3 (I2C3_SDA) and 4 (I2C3_CL)
    are connected to the BeaglePlay’s I2C3 bus. Pins 5 (UART5_TXD) and 6 (UART5_RXD)
    are connected to UART5 on the BeaglePlay. Pins 7 (GPIO1_9) and 8 (GPIO1_11) are
    GPIOs, with pin 7 acting as an interrupt and pin 8 functioning as a PWM.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 引脚1连接地，引脚2输出5V。引脚3（I2C3_SDA）和引脚4（I2C3_CL）连接到BeaglePlay的I2C3总线。引脚5（UART5_TXD）和引脚6（UART5_RXD）连接到BeaglePlay的UART5。引脚7（GPIO1_9）和引脚8（GPIO1_11）是GPIO，其中引脚7作为中断使用，引脚8作为PWM使用。
- en: 'Here is the left header strip of the BeaglePlay’s mikroBUS socket:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 这是BeaglePlay的mikroBUS插槽左侧接头条带：
- en: '![Figure 12.2 – mikroBUS socket (left header strip)](img/B18466_12_02.png)'
  id: totrans-38
  prefs: []
  type: TYPE_IMG
  zh: '![图12.2 – mikroBUS插槽（左侧接头条带）](img/B18466_12_02.png)'
- en: Figure 12.2 – mikroBUS socket (left header strip)
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.2 – mikroBUS插槽（左侧接头条带）
- en: Pins 9 (GPIO1_10) and 10 (GPIO1_12) are GPIOs, with pin 9 acting as an analog
    input and pin 10 functioning as a reset. Pins 11 (SPI2_CS0), 12 (SPI2_CLK), 13
    (SPI2_D0), and 14 (SPI2_D1) are connected to the BeaglePlay’s SPI2 bus. Lastly,
    pin 15 outputs 3.3V, and pin 16 is tied to ground.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 引脚9（GPIO1_10）和引脚10（GPIO1_12）是GPIO，其中引脚9作为模拟输入，引脚10作为复位功能使用。引脚11（SPI2_CS0）、12（SPI2_CLK）、13（SPI2_D0）和14（SPI2_D1）连接到BeaglePlay的SPI2总线。最后，引脚15输出3.3V，引脚16连接地。
- en: Notice that the SPI2 bus has CS0, CLK, D0, and D1 lines. CS stands for chip
    select. Since each SPI bus is a main-subnode interface, pulling a CS signal line
    low typically selects which peripheral to transmit to on the bus. This kind of
    negative logic is known as **active low**. CLK stands for clock and is always
    generated by the bus main, which is the AM6254 in this case. Data transmitted
    over the SPI bus is synchronized to this CLK signal. SPI supports much higher
    clock frequencies than I2C. The D0 data line corresponds to main in, subnode out
    (MISO).
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，SPI2总线有CS0、CLK、D0和D1线路。CS代表芯片选择。由于每个SPI总线都是主从节点接口，拉低CS信号线通常用于选择总线上要传输的外设。此种负逻辑被称为**低有效**。CLK代表时钟，并且总是由总线主设备生成，在此案例中是AM6254。通过SPI总线传输的数据与此CLK信号同步。SPI支持比I2C更高的时钟频率。D0数据线对应主设备输入，从设备输出（MISO）。
- en: The D1 data line corresponds to main out, subnode in (MOSI). SPI is a full-duplex
    interface, which means that both the main and selected subnode can send data at
    the same time.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: D1数据线对应主设备输出，从设备输入（MOSI）。SPI是一个全双工接口，这意味着主设备和选中的从设备可以同时发送数据。
- en: 'Here is a block diagram showing the directions of all four SPI signals:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是一个块图，展示了四个SPI信号的方向：
- en: '![Figure 12.3 – SPI signals](img/B18466_12_03.png)'
  id: totrans-44
  prefs: []
  type: TYPE_IMG
  zh: '![图12.3 – SPI信号](img/B18466_12_03.png)'
- en: Figure 12.3 – SPI signals
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.3 – SPI信号
- en: Now let’s enable mikroBUS on the BeaglePlay. The quickest way to do this is
    to install a prebuilt Debian image from BeagleBoard.org.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们启用BeaglePlay上的mikroBUS。最快的方法是从BeagleBoard.org安装一个预构建的Debian镜像。
- en: Installing Debian on the BeaglePlay
  id: totrans-47
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在BeaglePlay上安装Debian
- en: '[BeagleBoard.org](https://BeagleBoard.org) provides Debian images for their
    various dev boards. Debian is a popular Linux distribution that includes a comprehensive
    set of open source software packages. It is a massive effort, with contributors
    from all over the world. Building Debian for the various BeagleBoards is unconventional
    by embedded Linux standards because the process does not rely on cross-compilation.
    Rather than attempting to build Debian for the BeaglePlay yourself, simply download
    a finished image directly from BeagleBoard.org.'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: '[BeagleBoard.org](https://BeagleBoard.org) 提供适用于其各种开发板的Debian镜像。Debian是一个流行的Linux发行版，包含了一个全面的开源软件包集合。它是一个庞大的项目，全球各地的贡献者共同参与。为各种BeagleBoard构建Debian的方式不同于嵌入式Linux的标准做法，因为这个过程不依赖于交叉编译。与其尝试为BeaglePlay自己构建Debian镜像，不如直接从BeagleBoard.org下载一个已经完成的镜像。'
- en: 'To download and decompress the Debian Bookworm minimal eMMC flasher image for
    the BeaglePlay, use the following command::'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 要下载并解压BeaglePlay的Debian Bookworm minimal eMMC flasher镜像，请使用以下命令：
- en: '[PRE0]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: If the above link is broken, visit [https://beagleboard.org/distros](https://beagleboard.org/distros)
    for a current list of Debian images available for download. [BeagleBoard.org](https://BeagleBoard.org)
    can decide to delete links to Debian images as those images age out. Long-term
    maintenance of Debian releases is costly and labor-intensive.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 如果上述链接损坏，请访问[https://beagleboard.org/distros](https://beagleboard.org/distros)获取当前可供下载的Debian镜像列表。[BeagleBoard.org](https://BeagleBoard.org)可能会删除一些过时的Debian镜像链接，因为长期维护Debian发布版本需要大量成本和劳动力。
- en: At the time of writing, 12.7 was the latest Debian image for AM6254-based BeaglePlay
    boards. The major version number of 12 indicates that 12.7 is a Bookworm LTS release
    of Debian. Since Debian 12.0 was originally released on June 10, 2023, Bookworm
    should receive updates for up to 5 years from that date.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 在撰写时，基于AM6254的BeaglePlay板的最新Debian映像为12.7。主版本号12表明12.7是Debian Bookworm LTS版本。由于Debian
    12.0最初发布于2023年6月10日，Bookworm应该从该日期起获得长达5年的更新。
- en: '**IMPORTANT NOTE**'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: '**重要提示**'
- en: If possible, download version 12.7 (also known as Bookworm) rather than the
    latest Debian image from [BeagleBoard.org](https://BeagleBoard.org) for the exercises
    in this chapter. The BeaglePlay bootloader, kernel, DTBs, and command-line tools
    are in constant flux, so the following instructions may not work with a later
    Debian release.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 如果可能，请在本章的练习中下载版本12.7（也称为Bookworm），而不是从[BeagleBoard.org](https://BeagleBoard.org)获取最新的Debian映像。BeaglePlay的引导加载程序、内核、DTB和命令行工具经常变化，因此后续说明可能无法与较新的Debian版本一起使用。
- en: 'Now that you have a Debian flasher image for the BeaglePlay, write it out to
    a microSD card:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，您有了BeaglePlay的Debian闪存映像，请将其写入microSD卡：
- en: Insert a microSD card into your Linux host machine.
  id: totrans-56
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将microSD卡插入Linux主机。
- en: Launch balenaEtcher.
  id: totrans-57
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 启动balenaEtcher。
- en: Click **Flash from file** from **Etcher**.
  id: totrans-58
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从**Etcher**中点击**从文件闪存**。
- en: Locate the `img` file that you downloaded from BeagleBoard.org and open it.
  id: totrans-59
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 找到您从BeagleBoard.org下载并打开的`img`文件。
- en: Click **Select target** from **Etcher**.
  id: totrans-60
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从**Etcher**中点击**选择目标**。
- en: Select the microSD card that you inserted in *step 1*.
  id: totrans-61
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择您在*步骤1*中插入的microSD卡。
- en: Click **Flash from Etcher** to write the image.
  id: totrans-62
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击**从Etcher闪存**以写入映像。
- en: Eject the microSD card when Etcher is done flashing.
  id: totrans-63
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当Etcher完成烧录后，请弹出microSD卡。
- en: Next, boot the flasher image from the microSD and flash Debian onto the BeaglePlay’s
    eMMC. Before proceeding, make sure that your USB to TTL serial cable has a 3.3
    V logic level. The three-pin UART connector is right next to the USB-C connector
    on the BeaglePlay. Do not connect any fourth red wire from your cable. A red wire
    typically indicates power, which is unnecessary in this instance and could damage
    the board.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，从microSD引导闪存映像，并将Debian闪存到BeaglePlay的eMMC。在继续之前，请确保您的USB到TTL串行电缆具有3.3 V逻辑电平。三针UART连接器位于BeaglePlay的USB-C连接器旁边。不要连接电缆的任何第四根红线。红线通常表示电源，在此情况下是不必要的，并可能损坏板子。
- en: 'To copy the Debian image from the microSD to the BeaglePlay’s eMMC:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 要将Debian映像从microSD复制到BeaglePlay的eMMC：
- en: Unplug the BeaglePlay from USB-C power.
  id: totrans-66
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 拔掉BeaglePlay的USB-C电源。
- en: Plug the USB side of your serial cable into your host machine.
  id: totrans-67
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将串行电缆的USB端插入主机。
- en: Connect the TX wire from the serial cable to the RX pin on the BeaglePlay.
  id: totrans-68
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将串行电缆的TX线连接到BeaglePlay的RX引脚。
- en: Connect the RX wire from the serial cable to the TX pin on the BeaglePlay.
  id: totrans-69
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将串行电缆的RX线连接到BeaglePlay的TX引脚。
- en: Connect the GND (black) wire from the serial cable to the GND pin on the BeaglePlay.
  id: totrans-70
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将串行电缆的GND（黑色）线连接到BeaglePlay的GND引脚。
- en: 'Start a suitable terminal program such as `gtkterm`, `minicom`, or `picocom`,
    and attach it to the port at 115,200 bits per second (bps) with no flow control.
    `gtkterm` is probably the easiest to set up and use:'
  id: totrans-71
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 启动适当的终端程序，如`gtkterm`、`minicom`或`picocom`，并以每秒115,200比特率（bps）无流控制的方式连接到端口。`gtkterm`可能是设置和使用最简单的：
- en: '[PRE1]'
  id: totrans-72
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Insert the microSD card into the BeaglePlay.
  id: totrans-73
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将microSD卡插入BeaglePlay。
- en: Press and hold the USR button on the BeaglePlay.
  id: totrans-74
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在BeaglePlay上按住USR按钮。
- en: Apply power to the BeaglePlay by way of the USB-C port.
  id: totrans-75
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过USB-C端口为BeaglePlay供电。
- en: Release the USR button once the BeaglePlay begins to boot from the microSD card.
  id: totrans-76
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦BeaglePlay开始从microSD卡引导，请释放USR按钮。
- en: 'Wait for the following prompt:'
  id: totrans-77
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 等待以下提示：
- en: '[PRE2]'
  id: totrans-78
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Enter `2`.
  id: totrans-79
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 输入`2`。
- en: It takes several minutes for the image to copy. Progress is reported on the
    serial console. If garbled or no output appears on the serial console, then swap
    the wires connected to the RX and TX pins on the BeaglePlay. Once the eMMC is
    done flashing, power off the BeaglePlay and remove the microSD card. Apply power
    to the BeaglePlay by way of the USB-C port. Plug an Ethernet cable from the BeaglePlay
    into a free port on your router. When the onboard Ethernet lights start blinking,
    the BeaglePlay should be online. Internet access allows us to install packages
    and fetch code from Git repos from within Debian.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 镜像复制需要几分钟时间。进度会在串行控制台上报告。如果串行控制台上出现乱码或没有输出，请交换 BeaglePlay 上 RX 和 TX 引脚连接的电缆。一旦
    eMMC 刷写完成，关闭 BeaglePlay 电源并取出 microSD 卡。通过 USB-C 端口为 BeaglePlay 供电。将以太网电缆从 BeaglePlay
    插入路由器的空闲端口。当板载以太网灯开始闪烁时，BeaglePlay 应该已经联网。互联网连接让我们可以安装包并从 Debian 内部获取 Git 仓库中的代码。
- en: 'To SSH into the BeaglePlay from your Linux host:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 从你的 Linux 主机通过 SSH 连接到 BeaglePlay：
- en: '[PRE3]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Enter `temppwd` at the `debian` user’s password prompt. Change the password
    when prompted. SSH and log in again with your new password when the connection
    closes.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `debian` 用户的密码提示符下输入 `temppwd`。按照提示更改密码。连接关闭后，使用新密码重新登录。
- en: Now that Debian is running on your target, let’s downgrade the Linux kernel
    to a version with the necessary mikroBUS driver.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 现在 Debian 已在你的目标设备上运行，我们来将 Linux 内核降级到带有必要 mikroBUS 驱动程序的版本。
- en: Prototyping with add-on boards
  id: totrans-85
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用扩展板进行原型设计
- en: ClickID is MikroE’s plug and play solution for MikroE Click add-on boards. ClickID
    enables Linux to automatically identify a Click add-on board and instructs the
    mikroBUS driver to load the correct interface driver (UART, I2C, SPI, ADC, or
    PWM) for communicating with the peripheral. All the information about a peripheral
    is located on an EEPROM chip soldered to the bottom right of the add-on board.
    Linux talks to this EEPROM via 1-Wire at startup to perform the plug and play
    process. Not all Click add-on boards have this EEPROM so only some support ClickID.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: ClickID 是 MikroE 为 MikroE Click 扩展板提供的即插即用解决方案。ClickID 使 Linux 能够自动识别 Click
    扩展板，并指示 mikroBUS 驱动程序加载正确的接口驱动程序（UART、I2C、SPI、ADC 或 PWM）以便与外设通信。关于外设的所有信息都存储在一个焊接在扩展板右下角的
    EEPROM 芯片中。Linux 在启动时通过 1-Wire 与这个 EEPROM 通信，从而执行即插即用过程。并非所有 Click 扩展板都具有这个 EEPROM，因此并非所有板卡都支持
    ClickID。
- en: Debian automatically upgrades packages including the Linux kernel without prompting
    the user. This is problematic because we will use an older Linux 5.10 kernel to
    talk to MikroE Click add-on boards.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: Debian 会自动升级包括 Linux 内核在内的包，而不会提示用户。这是一个问题，因为我们将使用较旧的 Linux 5.10 内核与 MikroE
    Click 扩展板进行通信。
- en: 'To disable auto-upgrades in Debian:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 要禁用 Debian 中的自动升级：
- en: '[PRE4]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'To downgrade the Linux kernel from 6.6 to 5.10:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 将 Linux 内核从 6.6 降级到 5.10：
- en: '[PRE5]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: SSH back into the BeaglePlay once it is back online.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦 BeaglePlay 恢复联网，重新 SSH 连接到 BeaglePlay。
- en: 'To confirm that the Linux kernel on the BeaglePlay was built with the necessary
    mikroBUS driver:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 要确认 BeaglePlay 上的 Linux 内核已构建了必要的 mikroBUS 驱动程序：
- en: '[PRE6]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Every ClickID EEPROM has a manifest section containing board specifics like
    pinout, interfaces, or Linux driver. Even if your Click add-on board does not
    have ClickID, a manifest may already exist for it.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 每个 ClickID EEPROM 都有一个清单部分，包含板卡特定信息，如引脚排列、接口或 Linux 驱动程序。即使你的 Click 扩展板没有 ClickID，可能也已经存在清单。
- en: 'To install the latest manifests on the BeaglePlay:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 要在 BeaglePlay 上安装最新的清单：
- en: '[PRE7]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'To view the complete list of manifest files installed on the BeaglePlay:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看安装在 BeaglePlay 上的完整清单文件列表：
- en: '[PRE8]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'To load a manifest with the mikroBUS driver, write that manifest to the `mikrobus-0/new_device`
    entry:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 要加载带有 mikroBUS 驱动程序的清单，将该清单写入 `mikrobus-0/new_device` 条目：
- en: '[PRE9]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The manifest doesn’t stick so you must reload it every time you reboot the BeaglePlay.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 清单不会持久化，因此每次重启 BeaglePlay 时，你必须重新加载它。
- en: Even if you can’t find a manifest for your Click add-on board, not all is lost.
    BeagleBoard.org has created a simple Python tool for creating new Click add-on
    manifests called Manifesto ([https://github.com/beagleboard/manifesto](https://github.com/beagleboard/manifesto)).
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 即使你找不到 Click 扩展板的清单，也不必担心。BeagleBoard.org 创建了一个简单的 Python 工具，名为 Manifesto，用于创建新的
    Click 扩展板清单（[https://github.com/beagleboard/manifesto](https://github.com/beagleboard/manifesto)）。
- en: '**IMPORTANT NOTE**'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: '**重要提示**'
- en: Loading the GNSS Click 7 manifest manually as shown is completely unnecessary
    because the GNSS Click 7 has a ClickID EEPROM built in.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 如图所示手动加载 GNSS Click 7 清单完全没有必要，因为 GNSS Click 7 内置了 ClickID EEPROM。
- en: Many Click add-on boards appear as Linux **Industrial I/O** (**IIO**) devices.
    The `iio_info` tool can be used to discover IIO driver-enabled devices.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 许多 Click 附加板显示为 Linux **工业 I/O**（**IIO**）设备。`iio_info` 工具可用于发现启用 IIO 驱动的设备。
- en: 'To install the `iio_info` tool:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 安装 `iio_info` 工具：
- en: '[PRE10]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'There are peripheral test scripts in the book’s code repository. Debian comes
    with Git installed, so you can clone the book’s repository to fetch the code:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 本书的代码仓库中有外设测试脚本。Debian 系统自带 Git，因此你可以克隆本书的仓库以获取代码：
- en: '[PRE11]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Now we are ready to test each Click add-on board.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们准备好测试每个 Click 附加板。
- en: Testing hardware peripherals
  id: totrans-112
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试硬件外设
- en: 'We will incorporate three peripherals into the BeaglePlay: a u-blox NEO-M9N
    GNSS receiver, a Bosch BME680 environmental sensor, and a Shenzhen Boxing World
    Technology PSP27801 OLED display. There are three test programs under *Chapter12*
    in the book’s code repository. The `parse_nmea.py` program tests the NEO-M9N;
    the `sensors.py` program tests the BME680; and the `display.py` program tests
    the PSP27801\. While it is possible to stack multiple Click add-on boards on a
    single mikroBUS socket, we will test each peripheral individually one at a time.'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将把三个外设连接到 BeaglePlay：一个 u-blox NEO-M9N GNSS 接收器，一个 Bosch BME680 环境传感器和一个深圳
    Boxing World Technology PSP27801 OLED 显示器。在本书的代码仓库中，*Chapter12* 下有三个测试程序。`parse_nmea.py`
    程序测试 NEO-M9N；`sensors.py` 程序测试 BME680；`display.py` 程序测试 PSP27801。虽然可以在单个 mikroBUS
    插槽上堆叠多个 Click 附加板，但我们将逐个测试每个外设。
- en: Attaching the GNSS Click 7 add-on board
  id: totrans-114
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 连接 GNSS Click 7 附加板。
- en: '**Global Navigation Satellite System** (**GNSS**) receivers send **National
    Marine Electronics Association** (**NMEA**) data over UART (serial port), I2C,
    or SPI. Many GNSS user space tools like `gpsd` only work with modules connected
    via serial port.'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: '**全球导航卫星系统**（**GNSS**）接收器通过 UART（串口）、I2C 或 SPI 发送 **国家海洋电子协会**（**NMEA**）数据。许多
    GNSS 用户空间工具（如 `gpsd`）仅支持与串口连接的模块。'
- en: Download the NEO-M9N series data sheet from u-blox’s product page at [https://www.u-blox.com/en/product/neo-m9n-module](https://www.u-blox.com/en/product/neo-m9n-module).
    Jump to the section describing SPI. It says that SPI is disabled by default because
    its pins are shared with the UART and I2C interfaces. To enable SPI on the NEO-M9N,
    we must connect the D_SEL pin to GND. Pulling down D_SEL converts the two UART
    and two 12C pins into four SPI pins. This explains why the GNSS 7 Click add-on
    board defaults to operating over I2C and UART. To select SPI communication on
    the GNSS 7 Click, you need to insert a jumper.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 从 u-blox 产品页面下载 NEO-M9N 系列数据表：[https://www.u-blox.com/en/product/neo-m9n-module](https://www.u-blox.com/en/product/neo-m9n-module)。跳转到描述
    SPI 的部分。该部分指出，由于 SPI 引脚与 UART 和 I2C 接口共享，SPI 默认为禁用。要启用 NEO-M9N 上的 SPI，我们必须将 D_SEL
    引脚连接到 GND。拉低 D_SEL 将两个 UART 和两个 I2C 引脚转换为四个 SPI 引脚。这也解释了为什么 GNSS 7 Click 附加板默认通过
    I2C 和 UART 进行操作。要选择 SPI 通信，必须插入跳线。
- en: 'To attach your GNSS Click 7 add-on board to the BeaglePlay:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 将 GNSS Click 7 附加板连接到 BeaglePlay：
- en: Unplug the BeaglePlay from USB-C power.
  id: totrans-118
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从 USB-C 电源断开 BeaglePlay。
- en: Insert the GNSS Click 7 add-on board into the mikroBUS socket on the BeaglePlay.
  id: totrans-119
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 GNSS Click 7 附加板插入 BeaglePlay 上的 mikroBUS 插槽。
- en: Screw the external active GNSS antenna onto the GNSS SMA connector.
  id: totrans-120
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将外部有源 GNSS 天线拧到 GNSS SMA 连接器上。
- en: Apply power to the BeaglePlay by way of the USB-C port.
  id: totrans-121
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过 USB-C 端口为 BeaglePlay 供电。
- en: Reconnect the Ethernet cable from the BeaglePlay to a free port on your router
    if disconnected.
  id: totrans-122
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果以太网电缆与 BeaglePlay 断开，请重新连接至路由器的空闲端口。
- en: SSH back into the BeaglePlay once it is back online.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦 BeaglePlay 重新上线，通过 SSH 重新连接至 BeaglePlay。
- en: 'To confirm that your GNSS Click 7 add-on board was correctly attached and recognized:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 确认 GNSS Click 7 附加板正确连接和识别：
- en: '[PRE12]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: If the output from `dmesg` looks like what’s above, then you have successfully
    attached your add-on board to the BeaglePlay.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 `dmesg` 的输出看起来像上面所示，那么你已经成功将附加板连接到 BeaglePlay。
- en: 'To examine your newly attached GNSS device:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 检查新连接的 GNSS 设备：
- en: '[PRE13]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: This means that a GNSS device is now available for use at `/dev/gnss0`.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着 GNSS 设备现在可以在 `/dev/gnss0` 中使用。
- en: Receiving NMEA messages
  id: totrans-130
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 接收 NMEA 消息
- en: Lastly, we will install the Python test program and run it on the target. This
    program simply outputs the live message stream from the GNSS module to the console.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将安装 Python 测试程序并在目标设备上运行。该程序仅仅将 GNSS 模块的实时消息流输出到控制台。
- en: NMEA is a data message format supported by most GNSS receivers. The NEO-M9N
    outputs NMEA sentences by default. These sentences are ASCII text starting with
    the `$` character followed by comma-separated fields. What we want to do first
    is read the stream of NMEA sentences from the NEO-M9N out of the `/dev/gnss0`
    interface. Raw NMEA messages are not always easy to read, so we will use a parser
    to add helpful annotations to the data fields.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: NMEA 是大多数 GNSS 接收器支持的数据消息格式。NEO-M9N 默认输出 NMEA 语句。这些语句是以 `$` 字符开头，后跟逗号分隔的字段的
    ASCII 文本。我们首先要做的是从 `/dev/gnss0` 接口读取 NMEA 语句流。原始的 NMEA 消息不容易阅读，因此我们将使用解析器为数据字段添加有用的注释。
- en: 'To stream the ASCII input from the GNSS module to `stdout`:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 将 GNSS 模块的 ASCII 输入流传输到 `stdout`：
- en: '[PRE14]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: You should see a spurt of NMEA sentences once every second. Hit *Ctrl + C* to
    cancel the stream and return to the command-line prompt.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 每秒钟您应该能看到一段 NMEA 语句。按 *Ctrl + C* 取消流并返回命令行提示符。
- en: An NMEA parser script is included in the GitHub repo. That `parse_nmea.py` script
    depends on the `pynmea2` library.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: GitHub 仓库中包含一个 NMEA 解析器脚本。`parse_nmea.py` 脚本依赖于 `pynmea2` 库。
- en: 'To install `pynmea2` on the BeaglePlay:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 在 BeaglePlay 上安装 `pynmea2`：
- en: '[PRE15]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'To pipe the output from `/dev/gnss0` into the NMEA parser:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 将 `/dev/gnss0` 的输出通过管道传输到 NMEA 解析器：
- en: '[PRE16]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'The parsed NMEA output looks like this:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 解析后的 NMEA 输出如下：
- en: '[PRE17]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Don’t be discouraged if your GNSS module can’t see any satellites or acquire
    a fixed position. This could be due to any number of reasons, such as choosing
    the wrong GNSS antenna or no clear line of sight to the sky. RF is complicated
    and the goal of this chapter was only to prove we could get communications with
    the GNSS module working. Now we can experiment with alternate GNSS antennas and
    more of the NEO-M9N’s advanced features, like the much richer UBX message protocol.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您的 GNSS 模块无法接收到卫星信号或获得固定位置，不要灰心。这可能有多种原因，例如选择了错误的 GNSS 天线，或者没有清晰的视距通向天空。射频很复杂，本章的目标只是证明我们能够让
    GNSS 模块的通信正常工作。现在，我们可以尝试使用其他 GNSS 天线，并探索 NEO-M9N 的更多高级功能，如更丰富的 UBX 消息协议。
- en: With NMEA data now streaming out to the terminal, our first project is finished.
    We succeeded in verifying that the AM6254 can communicate with the NEO-M9N via
    a combination of I2C and UART.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，NMEA 数据已经流入终端，我们的第一个项目完成了。我们成功验证了 AM6254 可以通过 I2C 和 UART 的组合与 NEO-M9N 进行通信。
- en: Attaching the Environment Click add-on board
  id: totrans-145
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 连接 Environment Click 附加板
- en: The BME680 environmental sensor measures temperature, relative humidity, pressure,
    and gas. It communicates with the AM6254 SoC over SPI or I2C from the Environment
    Click add-on board. Like the GNSS 7 Click, the Environment Click defaults to I2C.
    To select SPI communication on the Environment Click, you need to insert a jumper.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: BME680 环境传感器测量温度、相对湿度、压力和气体。它通过 SPI 或 I2C 从 Environment Click 附加板与 AM6254 SoC
    通信。与 GNSS 7 Click 相似，Environment Click 默认使用 I2C。要选择 SPI 通信，需要插入跳线。
- en: 'To attach your Environment Click add-on board to the BeaglePlay:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 将 Environment Click 附加板连接到 BeaglePlay：
- en: Unplug the BeaglePay from USB-C power.
  id: totrans-148
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 拔掉 BeaglePlay 的 USB-C 电源。
- en: Insert the Environment Click add-on board into the mikroBUS socket on the BeaglePlay.
  id: totrans-149
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 Environment Click 附加板插入 BeaglePlay 上的 mikroBUS 插槽。
- en: Apply power to the BeaglePlay by way of the USB-C port.
  id: totrans-150
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过 USB-C 端口为 BeaglePlay 供电。
- en: Reconnect the Ethernet cable from the BeaglePlay to a free port on your router
    if disconnected.
  id: totrans-151
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果已断开，重新连接 BeaglePlay 的以太网电缆到路由器上的空闲端口。
- en: SSH back into the BeaglePlay once it is back online.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: BeaglePlay 恢复在线后，重新 SSH 连接到 BeaglePlay。
- en: 'To confirm that your Environment Click add-on board was correctly attached
    and recognized:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 确认您的 Environment Click 附加板是否已正确连接和识别：
- en: '[PRE18]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: If the output from `dmesg` looks like what’s above, then you have successfully
    attached your add-on board to the BeaglePlay.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 `dmesg` 输出与上面显示的相似，则说明您已成功将附加板连接到 BeaglePlay。
- en: 'To examine your newly attached environmental sensor:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 检查您新连接的环境传感器：
- en: '[PRE19]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Notice that the `bme680` appears as `iio:device0`.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 注意 `bme680` 会显示为 `iio:device0`。
- en: Reading sensor values
  id: totrans-159
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 读取传感器值
- en: Like other Linux IIO devices, the BME680’s register values are accessible from
    `sysfs`.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 与其他 Linux IIO 设备一样，BME680 的寄存器值可以通过 `sysfs` 访问。
- en: 'To read the humidity, pressure, gas, and temperature values from the BME680:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 从 BME680 读取湿度、压力、气体和温度值：
- en: '[PRE20]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: A script to continually poll all four channels is included in the GitHub repo.
    That `sensors.py` script has no dependencies outside of the Python standard library.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 一个持续轮询所有四个通道的脚本已包含在 GitHub 仓库中。该 `sensors.py` 脚本除了 Python 标准库外，没有其他依赖项。
- en: 'To run the script:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 要运行脚本，请执行以下操作：
- en: '[PRE21]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: With sensor values now streaming out to the terminal, our second project is
    finished. We succeeded in verifying that the AM6254 can communicate with the BME680
    via I2C.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 随着传感器值流向终端，我们的第二个项目已经完成。我们成功验证了 AM6254 可以通过 I2C 与 BME680 通信。
- en: Attaching the OLED C Click add-on board
  id: totrans-167
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 连接 OLED C Click 扩展板
- en: 'The OLED C Click comes with a Solomon Systech SSD1351 controller to drive the
    PSP27801 OLED display. You write to the 128x128 pixel SRAM display buffer inside
    the SSD1351 over SPI. The SSD1351 supports two color modes: 65K (6:5:6) and 262K
    (6:6:6). An (r:g:b) triplet indicates how many bits are used to represent the
    individual RGB components of a pixel. The PSP27801 has a resolution of 96x96 pixels,
    noticeably less than that of the SD1351’s display buffer.'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: OLED C Click 配备了 Solomon Systech SSD1351 控制器，用于驱动 PSP27801 OLED 显示屏。你通过 SPI
    将数据写入 SSD1351 内部的 128x128 像素 SRAM 显示缓冲区。SSD1351 支持两种颜色模式：65K（6:5:6）和 262K（6:6:6）。(r:g:b)
    三元组表示每个像素的 RGB 组件使用了多少位。PSP27801 的分辨率为 96x96 像素，明显低于 SD1351 显示缓冲区的分辨率。
- en: 'To attach your OLED C Click add-on board to the BeaglePlay:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 要将 OLED C Click 扩展板连接到 BeaglePlay，请按照以下步骤操作：
- en: Unplug the BeaglePay from USB-C power.
  id: totrans-170
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从 USB-C 电源断开 BeaglePlay。
- en: Insert the OLED C Click add-on board into the mikroBUS socket on the BeaglePlay.
  id: totrans-171
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 OLED C Click 扩展板插入 BeaglePlay 的 mikroBUS 插槽。
- en: Apply power to the BeaglePlay by way of the USB-C port.
  id: totrans-172
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过 USB-C 端口为 BeaglePlay 供电。
- en: Reconnect the Ethernet cable from the BeaglePlay to a free port on your router
    if disconnected.
  id: totrans-173
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果以太网线从 BeaglePlay 断开，请将其重新连接到路由器的空闲端口。
- en: SSH back into the BeaglePlay once it is back online.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦 BeaglePlay 重新上线，通过 SSH 连接回 BeaglePlay。
- en: 'To confirm that your OLED C Click add-on board was correctly attached and recognized:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 要确认 OLED C Click 扩展板已正确连接并被识别，请执行以下操作：
- en: '[PRE22]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: If the output from `dmesg` looks like what’s above, then you have successfully
    attached your add-on board to the BeaglePlay.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 `dmesg` 输出的内容与上述相似，那么你已经成功将扩展板连接到 BeaglePlay。
- en: 'To examine your newly attached OLED display:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 要检查新连接的 OLED 显示屏，请按照以下步骤操作：
- en: '[PRE23]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Exposing the SSD1351 as a Linux framebuffer greatly simplifies how we interact
    with the OLED display. You do not need to link a mikroSDK library and deal with
    its clumsy C API. Just write directly to the `fb0` device any way you like.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 将 SSD1351 显示为 Linux 帧缓冲区，大大简化了我们与 OLED 显示屏的交互方式。你无需链接 mikroSDK 库并处理其笨重的 C API。只需直接以任何方式写入
    `fb0` 设备即可。
- en: Displaying an animation
  id: totrans-181
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 显示动画
- en: 'A test script for the OLED display is included in the GitHub repo. That `display.py`
    script depends on the `luma.core` and `numpy` libraries:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 一个 OLED 显示屏测试脚本已包含在 GitHub 仓库中。该 `display.py` 脚本依赖于 `luma.core` 和 `numpy` 库：
- en: 'To install `luma.core` and `numpy` on the BeaglePlay:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 要在 BeaglePlay 上安装 `luma.core` 和 `numpy`，请执行以下操作：
- en: '[PRE24]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'To run the test script:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 要运行测试脚本，请执行以下操作：
- en: '[PRE25]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: A continuous animation involving a red, a green, and a blue square appears on
    the OLED display. As the three squares move towards each other, they overlap to
    form a white square in the center. The squares then separate and move back to
    their starting places so that the animation repeats itself.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: OLED 显示屏上会显示一个连续的动画，涉及一个红色、一个绿色和一个蓝色的方块。当三个方块相互靠近时，它们重叠在一起形成一个位于中央的白色方块。然后，方块们分开并回到它们的起始位置，动画重复播放。
- en: Our third and final project is now done. We succeeded in verifying that the
    AM6254 can display moving images on the PSP27801 via SPI.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的第三个也是最后一个项目已经完成。我们成功地验证了 AM6254 可以通过 SPI 在 PSP27801 上显示动态图像。
- en: Summary
  id: totrans-189
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we learned how to integrate peripherals with an SoC. To do
    that, we first had to glean knowledge from schematics and data sheets. Without
    finished hardware in hand, we also had to select and plug in add-on boards. Lastly,
    we coded simple test programs in Python and ran them to verify peripheral functionality.
    Now that we have working hardware, we can begin to develop our embedded application.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一章中，我们学习了如何将外设与 SoC 集成。为了做到这一点，我们首先需要从原理图和数据手册中获取知识。没有现成的硬件时，我们还必须选择并插入扩展板。最后，我们编写了简单的
    Python 测试程序并运行，以验证外设功能。现在硬件已经正常工作，我们可以开始开发嵌入式应用程序了。
- en: The next two chapters are all about system startup and the different options
    you have for the `init` program, from the simple BusyBox `init` to more complex
    systems such as System V `init` and `systemd`. Your choice of `init` program can
    have a big impact on the user experience of your product, both in terms of boot
    times and fault tolerance.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来的两章将讲解系统启动及你可以选择的不同`init`程序，从简单的BusyBox `init`到更复杂的系统如System V `init`和`systemd`。你选择的`init`程序会对产品的用户体验产生重大影响，包括启动时间和故障容错能力。
- en: Further study
  id: totrans-192
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步学习
- en: '*Introduction to SPI Interface*, by Piyu Dhaker – [https://www.analog.com/en/analog-dialogue/articles/introduction-to-spi-interface.html](https://www.analog.com/en/analog-dialogue/articles/introduction-to-spi-interface.html%0D%0A)'
  id: totrans-193
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*SPI接口简介*，作者：Piyu Dhaker – [https://www.analog.com/en/analog-dialogue/articles/introduction-to-spi-interface.html](https://www.analog.com/en/analog-dialogue/articles/introduction-to-spi-interface.html%0D%0A)'
- en: '*Soldering is Easy*, by Mitch Altman, Andie Nordgren, and Jeff Keyzer – [https://mightyohm.com/blog/2011/04/soldering-is-easy-comic-book](https://mightyohm.com/blog/2011/04/soldering-is-easy-comic-book)'
  id: totrans-194
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*焊接很简单*，作者：Mitch Altman、Andie Nordgren 和 Jeff Keyzer – [https://mightyohm.com/blog/2011/04/soldering-is-easy-comic-book](https://mightyohm.com/blog/2011/04/soldering-is-easy-comic-book)'
