- en: '13'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Virtualization and Containers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Going back to the 1990s, most companies had physical servers and IT stacks from
    a single vendor that did not allow *legacy applications* to run on another vendor’s
    hardware. This led to large, multi-service server environments that were very
    complex to manage.
  prefs: []
  type: TYPE_NORMAL
- en: As companies upgraded their IT environments with less expensive servers, operating
    systems, and applications from a variety of vendors, they began to underutilize
    physical hardware. Each server could only run one specific task from one vendor.
  prefs: []
  type: TYPE_NORMAL
- en: '**Virtualization** was the natural solution to two problems: companies could
    partition their servers and run legacy applications on multiple types and versions
    of operating systems and servers began to be used more efficiently, reducing the
    costs associated with purchasing, installation, cooling, and maintenance.'
  prefs: []
  type: TYPE_NORMAL
- en: The next step was the containerization of these services. **Containerization**
    is a form of virtualization. The goal of virtualization is to run multiple instances
    of the operating system on a single server, while containerization runs a single
    instance of the operating system, with multiple user spaces to isolate the processes
    from each other and provide the service.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will take a brief tour of *virtualization* and *containerization*
    by covering the following main topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Virtualization with QEMU, KVM, and **libvirt**
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using GNOME Boxes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Discovering OCI containers with Podman
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To complete the topics mentioned in this chapter, you must install the packages
    indicated in each section. In each section, you will find instructions for the
    different types of installation for each package as required.
  prefs: []
  type: TYPE_NORMAL
- en: Virtualization with QEMU, KVM, and libvirt
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Fedora Linux comes with native support for virtualization extensions. This support
    is provided by **Kernel-based Virtual Machine** (**KVM**) and is available as
    a *kernel module*. **QEMU/KVM** in combination with the **Libvirt management toolkit**
    is the standard virtualization method in Fedora Linux.
  prefs: []
  type: TYPE_NORMAL
- en: '**Quick Emulator** (**QEMU**) is a full system emulator that works together
    with KVM and allows you to create virtual machines with hardware and peripherals.'
  prefs: []
  type: TYPE_NORMAL
- en: Finally, `libvirt` is the API layer and allows you to manage the infrastructure
    – that is, create and run virtual machines. It includes a local virtual network
    that enables secure communication between virtual guest systems with each other
    and with the host. libvirt’s default configuration also allows *NAT access* to
    the public network, which is useful for virtual machines or containers that don’t
    have direct access to the public interface.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following figure illustrates the QEMU/KVM architecture with `libvirt`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 13.1 – The QEMU/KVM architecture](img/B19121_13_1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 13.1 – The QEMU/KVM architecture
  prefs: []
  type: TYPE_NORMAL
- en: Let’s take a brief look at the management tools.
  prefs: []
  type: TYPE_NORMAL
- en: Management tools
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`libvirt` is a C toolkit that interacts with the virtualization capabilities
    of Fedora Linux. The main package includes the `libvirtd` server for exporting
    virtualization support.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The basic management tools are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**virsh**: This is the main interface for managing **virsh** guest domains.
    The program can *create*, *pause*, and *shutdown* domains. It also *lists* the
    current domains and their status.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Virt-manager**: This is a desktop tool for managing virtual machines. It
    provides *life cycle control* of current virtual machines (startup/shutdown, pause/resume,
    and suspend/restore), provisions new virtual machines and various types of storage,
    manages virtual networks, gives access to the graphical console of virtual machines,
    and generates performance statistics locally or remotely:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![Figure 13.2 – Virtual Machine Manager](img/B19121_13_2.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 13.2 – Virtual Machine Manager
  prefs: []
  type: TYPE_NORMAL
- en: '**virt-viewer**: This is a minimal tool for displaying the graphical console
    of a virtual machine. It accesses the console using the **VNC** or **SPICE** protocol.
    Refer to the virtual guest based on its *name*, *ID*, or *UUID*. If the guest
    is not running yet, the viewer could wait until it starts before attempting to
    connect to the console. The viewer could connect to remote hosts to look up console
    information, as well as connect to the remote console using the same network transport.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`virt-install` obtains the minimum files necessary to start the installation
    process, allowing the guest to get the rest of the operating system distribution
    as needed. PXE booting and importing an existing disk image (thus skipping the
    installation phase) are also supported.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: With the proper command-line arguments, `virt-install` can run completely unattended,
    with the guest “booting” itself. This allows for easy automation of the guest
    installation.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Using `virt-install` capabilities enables you to streamline the process of creating
    virtual machines, minimizing the installation time. Let’s learn how to perform
    this procedure.
  prefs: []
  type: TYPE_NORMAL
- en: Streamlining the creation of virtual machines
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'QEMU uses the `qcow` file format for disk image files. It stands for *QEMU
    Copy On Write*. The `qcow` format uses a disk storage optimization strategy that
    delays the allocation of storage until it is needed. Files within the `qcow` format
    could contain a variety of disk images that are generally associated with specific
    guest operating systems. There are three versions of the format: `qcow`, `qcow2`,
    and `qcow3`.'
  prefs: []
  type: TYPE_NORMAL
- en: At the time of writing, the vast majority of distributions, including Fedora
    Linux, offer a *cloud-ready* downloadable version. One of the available options
    is the `qcow2` image disk format.
  prefs: []
  type: TYPE_NORMAL
- en: '**OpenStack**, an *open standard cloud computing platform*, provides a web
    page that references cloud images for many distributions and operating systems
    (which you’ll find in the next example).'
  prefs: []
  type: TYPE_NORMAL
- en: Using the `virt-customize` command-line tool, you can modify the downloadable
    disk image to import it as a *ready-to-use* virtual machine.
  prefs: []
  type: TYPE_NORMAL
- en: 'Follow these steps to create a virtual machine in a short time with these three
    tools:'
  prefs: []
  type: TYPE_NORMAL
- en: Before starting, verify that your workstation runs virtualization-enabled from
    the **BIOS**/**UEFI**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: This process depends on the manufacturer of your workstation. Please refer to
    the manufacturer’s documentation to confirm that they have virtualization capability
    enabled in the BIOS/UEFI.
  prefs: []
  type: TYPE_NORMAL
- en: 'Confirm that the processor of your workstation has the flags that support virtualization:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Use the **sudo** command to install the packages required for virtualization:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**qemu-kvm**'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**virt-manager**'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**virt-viewer**'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**guestfs-tools**'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**virt-install**'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**genisoimage**:'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
- en: 'Use your browser to navigate to [https://docs.openstack.org/image-guide/obtain-images.html](https://docs.openstack.org/image-guide/obtain-images.html)
    and download the **qcow2** disk image of the chosen distribution/operating system:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 13.3 – OpenStack – Get images](img/B19121_13_3.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 13.3 – OpenStack – Get images
  prefs: []
  type: TYPE_NORMAL
- en: 'For this example, download the Fedora Linux image. Use your browser to navigate
    to [https://fedoraproject.org/cloud/download/](https://fedoraproject.org/cloud/download/):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 13.4 – The Fedora Cloud download page](img/B19121_13_4.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 13.4 – The Fedora Cloud download page
  prefs: []
  type: TYPE_NORMAL
- en: Download the `qcow2` image for `x86_64` architectures.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: Each image requires about 400 MB of disk space. Ensure that you have enough
    storage space to store them and let them grow as they get used.
  prefs: []
  type: TYPE_NORMAL
- en: 'Move the downloaded **qcow2** image to the **KVM** working directory in **/var/lib/libvirt/images**:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: 'A best practice is to copy the **qcow2** image with the virtual machine name
    instead of moving it. Reuse the original downloaded image to create many virtual
    machines:'
  prefs: []
  type: TYPE_NORMAL
- en: '**$ sudo cp** **Fedora-Cloud-Base-38-1.6.x86_64.qcow2 /var/lib/****libvirt/images/vmtest01.qcow2**'
  prefs: []
  type: TYPE_NORMAL
- en: 'Use the **virt-customize** command to modify the downloaded image:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: $ ssh-keygen -t ecdsa -b 521 -f labkey
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: 'For more information on the **ssh-keygen** command, refer to the command manual:
    **man ssh-keygen**.'
  prefs: []
  type: TYPE_NORMAL
- en: '**--uninstall** allows us to uninstall the software contained by default in
    the downloaded image.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**cloud-init** is a suite that helps initialize an image for use in OpenStack.
    In this case, it is not necessary since a basic functional level of customization
    works best here.'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: If the **cloud-init** package is not uninstalled, the VM will take a long time
    to boot as it waits for the parameters for initialization with **cloud-init scripts**.
  prefs: []
  type: TYPE_NORMAL
- en: 'Since it is a Fedora Linux image, the SELinux contexts must *relabel* with
    the **--selinux-relabel** option as several files must be changed or removed:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![Figure 13.5 – Customizing the qcow2 image](img/B19121_13_5.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 13.5 – Customizing the qcow2 image
  prefs: []
  type: TYPE_NORMAL
- en: Now that we’ve finished customizing, let’s import the disk image as a new virtual
    machine.
  prefs: []
  type: TYPE_NORMAL
- en: 'To import the disk image as a new virtual machine, use the **virt-install**
    command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Let’s look at each of the options we used in detail:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**virt-install** is the command-line tool for creating new VMs.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**--name** sets the name of the new guest VM instance. The name must remain
    *unique* among all guests known to the hypervisor on the connection, including
    those not currently active.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**--memory** indicates the memory to allocate for the guest in MiB.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**--vcpus** indicates the number of **vcpus** to configure for the guest.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**–disk** specifies the device to use as storage for the guest. In this case,
    this is the path to the disk image.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**--import** indicates that the disk image gets imported as a new VM building
    a guest around this disk image.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**--osinfo** optimizes the guest configuration for a specific operating system
    version or distribution. In this case, **fedora38** is indicated.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: To find the list of supported operating system name values, use the **virt-install**
    command – that is, **virt-install --****osinfo list**.
  prefs: []
  type: TYPE_NORMAL
- en: '**--noautoconsole** specifies not to try to connect to the guest console automatically:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![Figure 13.6 – Creating a new virtual machine](img/B19121_13_6.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 13.6 – Creating a new virtual machine
  prefs: []
  type: TYPE_NORMAL
- en: 'Verify the status of the created virtual machine:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Here’s the output:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 13.7 – Verifying the new virtual machine’s status](img/B19121_13_7.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 13.7 – Verifying the new virtual machine’s status
  prefs: []
  type: TYPE_NORMAL
- en: Now, let’s connect to the virtual machine via SSH.
  prefs: []
  type: TYPE_NORMAL
- en: 'Use the **virsh** command to find the IP address that was assigned by the virtualization
    **DHCP** service:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Here’s the output:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 13.8 – Finding the VM’s IP address](img/B19121_13_8.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 13.8 – Finding the VM’s IP address
  prefs: []
  type: TYPE_NORMAL
- en: 'Use the **ssh** command and the SSH key to access the virtual machine:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'You will get the following output:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 13.9 – Accessing the VM](img/B19121_13_9.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 13.9 – Accessing the VM
  prefs: []
  type: TYPE_NORMAL
- en: With that, you can get a working virtual machine up and running in a short time.
    Mastering these commands speeds up this task.
  prefs: []
  type: TYPE_NORMAL
- en: Before moving on to containerization, which is virtualization in miniature form,
    let’s look at the tool that GNOME includes as part of its desktop suite.
  prefs: []
  type: TYPE_NORMAL
- en: Using GNOME Boxes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**GNOME Boxes** is an application of the GNOME desktop environment that’s used
    to access remote or virtual systems. Boxes uses the QEMU, KVM, and Libvirt virtualization
    technologies.'
  prefs: []
  type: TYPE_NORMAL
- en: Besides the virtualization extensions seen in the previous section, Boxes requires
    at least *20 GB of storage space* and *500 MB of RAM* to allocate to virtual machines.
    GNOME recommends at least 8 GB of RAM and 20 GB of storage on the workstation
    to run Boxes efficiently. Boxes assigns resources to virtual machines *automatically*
    and *dynamically* based on the vendor’s recommendations.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s review the process of creating a virtual machine with **Boxes**:'
  prefs: []
  type: TYPE_NORMAL
- en: 'To access Boxes, open *Activities Overview* and type **Boxes**:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 13.10 – GNOME Boxes via Activities Overview](img/B19121_13_10.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 13.10 – GNOME Boxes via Activities Overview
  prefs: []
  type: TYPE_NORMAL
- en: 'The main Boxes window will appear. To create a new virtual machine, click on
    the *plus* (**+**) button in the top-left corner:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 13.11 – GNOME Boxes main window](img/B19121_13_11.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 13.11 – GNOME Boxes main window
  prefs: []
  type: TYPE_NORMAL
- en: 'Boxes offers two options for creating a new virtual machine:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 13.12 – Creating a new virtual machine with Boxes](img/B19121_13_12.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 13.12 – Creating a new virtual machine with Boxes
  prefs: []
  type: TYPE_NORMAL
- en: 'They are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Install from File**: When using this option, you must state the location
    of the **ISO** image of the operating system to install in the new virtual machine'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Download OS**: This option selects an operating system version or distribution
    and downloads the corresponding image for installation in the new virtual machine:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![Figure 13.13 – Selecting an operating system image](img/B19121_13_13.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 13.13 – Selecting an operating system image
  prefs: []
  type: TYPE_NORMAL
- en: For this example, let’s download the ISO image by ourselves.
  prefs: []
  type: TYPE_NORMAL
- en: 'Use your browser to navigate to [https://fedoraproject.org/workstation/download/](https://fedoraproject.org/workstation/download/):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 13.14 – Fedora Workstation download page](img/B19121_13_14.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 13.14 – Fedora Workstation download page
  prefs: []
  type: TYPE_NORMAL
- en: Download the `x86_64` architectures.
  prefs: []
  type: TYPE_NORMAL
- en: 'In **Boxes**, click on the *plus* sign (**+**) and select the **Install from
    File** option. Navigate to the location of the downloaded **ISO** image and click
    the **Open** button:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 13.15 – Creating a new virtual machine](img/B19121_13_15.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 13.15 – Creating a new virtual machine
  prefs: []
  type: TYPE_NORMAL
- en: Boxes will display the virtual machine creation options. Use the default options
    and click the **Create** button.
  prefs: []
  type: TYPE_NORMAL
- en: 'The installation of the downloaded image – in this case, Fedora Workstation
    – starts on a bare-metal machine:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 13.16 – Fedora Workstation live image](img/B19121_13_16.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 13.16 – Fedora Workstation live image
  prefs: []
  type: TYPE_NORMAL
- en: 'In the Fedora Workstation installation window, click the **Install Fedora**
    button and continue installing the operating system:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 13.17 – Fedora Linux installation window](img/B19121_13_17.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 13.17 – Fedora Linux installation window
  prefs: []
  type: TYPE_NORMAL
- en: 'Once the installation has finished, click on the **Finish installation** button
    and restart the virtual machine:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 13.18 – Finishing virtual machine installation](img/B19121_13_18.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 13.18 – Finishing virtual machine installation
  prefs: []
  type: TYPE_NORMAL
- en: 'Upon restarting the virtual machine, it will appear in the main **Boxes** window:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 13.19 – The Boxes main window](img/B19121_13_19.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 13.19 – The Boxes main window
  prefs: []
  type: TYPE_NORMAL
- en: 'Click on the virtual machine icon to access it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 13.20 – Accessing the virtual machine](img/B19121_13_191.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 13.20 – Accessing the virtual machine
  prefs: []
  type: TYPE_NORMAL
- en: 'The virtual machine window takes up the space of the main **Boxes** window
    and allows us to use it graphically, as a remote session:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 13.21 – Fedora Workstation virtual machine](img/B19121_13_20.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 13.21 – Fedora Workstation virtual machine
  prefs: []
  type: TYPE_NORMAL
- en: Now, use the virtual machine for the tasks assigned to it.
  prefs: []
  type: TYPE_NORMAL
- en: 'If the virtual machine gets turned off, it will appear in the main window,
    as shown in the following figure:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 13.22 – The virtual machine turned off in Boxes](img/B19121_13_21.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 13.22 – The virtual machine turned off in Boxes
  prefs: []
  type: TYPE_NORMAL
- en: 'Right-click on the virtual machine icon to access the administration options:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 13.23 – Virtual machine management options](img/B19121_13_22.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 13.23 – Virtual machine management options
  prefs: []
  type: TYPE_NORMAL
- en: To turn on the virtual machine, double-click its icon.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: GNOME Boxes is a simple application for accessing and managing virtual machines.
    It does not provide *granular management* and *automation facilities* of `virsh`,
    but it is a good tool to become familiar with the use of virtual machines.
  prefs: []
  type: TYPE_NORMAL
- en: A more granular method, with less creation time and better optimization of host
    resources, is to use containers.
  prefs: []
  type: TYPE_NORMAL
- en: Now, let’s learn how Fedora Linux implements the use of open containers.
  prefs: []
  type: TYPE_NORMAL
- en: Discovering OCI containers with Podman
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A Linux container, roughly speaking, works like the virtualization process,
    where we import a *pre-built image* of an operating system and create a virtual
    machine from it. In the case of containers, the image only packages the *programs
    and their minimal dependencies* needed for the operation of an application.
  prefs: []
  type: TYPE_NORMAL
- en: A container is a set of one or more processes that stand isolated from the rest
    of the system.
  prefs: []
  type: TYPE_NORMAL
- en: 'The kernel provides the following main components:'
  prefs: []
  type: TYPE_NORMAL
- en: '**namespaces** to ensure process isolation'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**cgroups** to control system resources'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**SELinux** to ensure separation between the host and container, as well as
    between containers'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The administration interface interacts with the kernel components and provides
    tools for *building and managing* containers. All the files needed to run a container
    come from an image.
  prefs: []
  type: TYPE_NORMAL
- en: Container images live in an external repository called a **registry**. To create
    a container, download the registry image and generate a runnable copy of the application
    on the host. These processes require a runtime and the image needs to be in a
    specific format to run.
  prefs: []
  type: TYPE_NORMAL
- en: The Linux Foundation sponsors the **Open Container Initiative** (**OCI**) project
    with the purpose of creating open industry standards around container formats
    and runtimes.
  prefs: []
  type: TYPE_NORMAL
- en: 'The OCI currently contains three specifications:'
  prefs: []
  type: TYPE_NORMAL
- en: The **Runtime Specification** (**runtime-spec**). This specifies how to run
    a filesystem bundle that is unpacked on disk.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The **Image Specification** **(image-spec**). This provides interoperable tools
    for building, transporting, and preparing a container image for running.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The **Distribution Specification** (**distribution-spec**). This defines an
    API protocol to ease and standardize content distribution.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An OCI implementation would download an OCI image and then unpack that image
    into an OCI runtime filesystem bundle.
  prefs: []
  type: TYPE_NORMAL
- en: Fedora Linux implements **Podman** for OCI container management.
  prefs: []
  type: TYPE_NORMAL
- en: 'Podman relies on an *OCI-compliant container runtime* (`runc`, `crun`, `runv`,
    and so on) to interact with the operating system and create the running containers
    via the command line:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 13.24 – Podman interaction](img/B19121_13_23.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 13.24 – Podman interaction
  prefs: []
  type: TYPE_NORMAL
- en: Containers controlled with Podman can be run by `root` or an *unprivileged user*.
    Podman manages the entire container ecosystem, including pods, containers, container
    images, and container volumes, using the `libpod` library.
  prefs: []
  type: TYPE_NORMAL
- en: 'To run containers as a non-root user, you must have some considerations about
    the resources you use:'
  prefs: []
  type: TYPE_NORMAL
- en: The container images get stored in the user’s home directory (**$HOME/.local/share/containers/storage/**)
    instead of **/var/lib/containers**
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Due to not having **root** privileges, these rules must be followed:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: No capability to access a port less than **1024**
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Storage must live on a local filesystem
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Let’s start by installing the utility.
  prefs: []
  type: TYPE_NORMAL
- en: 'Installing Podman requires administrator privileges. As the `root` user, run
    the `dnf` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let’s create an example container to exemplify the scope of the utility
    as a *non-root user*:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Verify rootless configuration:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'You should see the following output:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 13.25 – Podman rootless configuration](img/B19121_13_24.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 13.25 – Podman rootless configuration
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a base container. Use the **podman pull** command to download the image:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: The Red Hat **Universal Base Image** (**UBI**) enables you to build, share,
    and collaborate with containerized applications.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 13.26 – Obtaining the container image](img/B19121_13_25.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 13.26 – Obtaining the container image
  prefs: []
  type: TYPE_NORMAL
- en: After the download is complete, verify and inspect the image.
  prefs: []
  type: TYPE_NORMAL
- en: 'Use the **podman images** command to list the downloaded images:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Here’s the output:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 13.27 – Listing container images](img/B19121_13_26.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 13.27 – Listing container images
  prefs: []
  type: TYPE_NORMAL
- en: Use `image ID` to inspect it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Inspecting the downloaded image provides us with information on the creation
    and use of the image, besides the available variables to use on it. Use the **podman
    inspect** command with the name of the image or its ID:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'You will see the following output:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 13.28 – Inspecting the UBI image](img/B19121_13_27.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 13.28 – Inspecting the UBI image
  prefs: []
  type: TYPE_NORMAL
- en: Now, let’s create a container from the downloaded image.
  prefs: []
  type: TYPE_NORMAL
- en: 'Run a container of the UBI image to display the operating system version:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Here’s the output:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 13.29 – Running a container](img/B19121_13_28.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 13.29 – Running a container
  prefs: []
  type: TYPE_NORMAL
- en: The container is a base image of RHEL9 that’s running on Fedora Linux.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let’s create an example of a containerized service. Follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Use your browser to navigate to [https://registry.fedoraproject.org/](https://registry.fedoraproject.org/):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 13.30 – Fedora Project container image registry](img/B19121_13_29.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 13.30 – Fedora Project container image registry
  prefs: []
  type: TYPE_NORMAL
- en: 'Find the latest *web server image* (**httpd**) and copy its **pull** command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: Change the **pull** command so that it uses **podman** instead of **docker**.
  prefs: []
  type: TYPE_NORMAL
- en: 'Download the container image and verify it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'You should get the following output:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 13.31 – Getting the httpd image](img/B19121_13_30.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 13.31 – Getting the httpd image
  prefs: []
  type: TYPE_NORMAL
- en: 'Test run the container for the **httpd** image:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Here’s the output:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 13.32 – Running the httpd image container](img/B19121_13_31.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 13.32 – Running the httpd image container
  prefs: []
  type: TYPE_NORMAL
- en: Running the `httpd` image container in this way inhibits the use of the Terminal.
    Let’s run it with a custom name and in the background.
  prefs: []
  type: TYPE_NORMAL
- en: 'Run the **httpd** image container as **myapache** and in the background. Use
    the **--name** and **-d** options with the **podman** **run** command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'You should see the following output:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 13.33 – Running the container and verifying its status](img/B19121_13_32.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 13.33 – Running the container and verifying its status
  prefs: []
  type: TYPE_NORMAL
- en: Inspect the running container to find information you can use to access the
    service.
  prefs: []
  type: TYPE_NORMAL
- en: 'Use the **podman** **inspect** command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'You should see the following:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 13.34 – Looking for access to the containerized service](img/B19121_13_33.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 13.34 – Looking for access to the containerized service
  prefs: []
  type: TYPE_NORMAL
- en: The containerized service has no `IPAddress` assigned to it but opens ports
    `8080` and `8443`. Check the logs for more information.
  prefs: []
  type: TYPE_NORMAL
- en: 'Use the **podman logs** command to review the logs:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Here’s the output:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 13.35 – Reviewing service logs](img/B19121_13_34.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 13.35 – Reviewing service logs
  prefs: []
  type: TYPE_NORMAL
- en: In the logs of the containerized service, find the IP address that opens port
    `8443`. Verify access to the service with this information.
  prefs: []
  type: TYPE_NORMAL
- en: 'Verify access to the containerized service. Use the following **curl** command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Here’s the output:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 13.36 – Verifying access to the web service](img/B19121_13_35.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 13.36 – Verifying access to the web service
  prefs: []
  type: TYPE_NORMAL
- en: The service fails to answer on port `8443` or `8080`.
  prefs: []
  type: TYPE_NORMAL
- en: This is due to the container port not referring to a host port. Delete the container
    and recreate it with the reference to a local port.
  prefs: []
  type: TYPE_NORMAL
- en: 'Remove the container. First, use the **stop** option to interrupt the container
    run and then the **rm** option to delete the container with the **podman** command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'You should see the following output:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 13.37 – Removing the container](img/B19121_13_36.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 13.37 – Removing the container
  prefs: []
  type: TYPE_NORMAL
- en: Verify that the `myapache` container is not running anymore. Use the `podman
    ps` command to do so.
  prefs: []
  type: TYPE_NORMAL
- en: 'Recreate the **myapache** container by mapping the container’s port, **8080**,
    to local port **8080**. Add the **-p** option to the **podman run** command that
    we ran in *step 4*:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Here’s the output:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 13.38 – Mapping the container port to the local port](img/B19121_13_37.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 13.38 – Mapping the container port to the local port
  prefs: []
  type: TYPE_NORMAL
- en: Use the **podman ps** command to confirm that the port was mapped correctly.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Test the service again but on local port **8080**:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'You should see the following output:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 13.39 – Testing service access](img/B19121_13_38.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 13.39 – Testing service access
  prefs: []
  type: TYPE_NORMAL
- en: Now that the service is accessible, it shows the Apache test page.
  prefs: []
  type: TYPE_NORMAL
- en: An application that always runs on a single host accesses local disk storage
    to get the information it needs while running. These storage volumes remain both
    *logically* and *physically* persistent. Containerized dynamic and elastic deployments
    separate the logical and physical states of application storage.
  prefs: []
  type: TYPE_NORMAL
- en: A containerized application could be *logically resident but physically transient*
    due to the redistribution and scaling capabilities inherent in OCI technologies.
  prefs: []
  type: TYPE_NORMAL
- en: If a container resides on a host, but that container stops working, the container
    manager could start a new instance on another host. The application may need some
    data available when it is running; this is known as logical persistence. Since
    container information is ephemeral by default, the storage is physically transient.
  prefs: []
  type: TYPE_NORMAL
- en: In containerized storage in general, the trend is to integrate *persistent storage*
    with *ephemeral containers* as best as possible.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let’s learn how to add persistent storage to our containerized service.
    Follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Stop and remove the **myapache** container:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In the user’s home directory, create the working directory for persistent storage
    of the **myapache** container:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Now, let’s create a custom home page for our service.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Create the **index.html** file inside the persistent storage directory we created
    for the **myapache** container:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Regenerate the **myapache** container with the **-v** option to add persistent
    storage as a volume of the **myapache** container.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Run the container again with the option to attach the volume mentioned previously.
    As with the port, the local directory must be mapped to the container directory.
    In this case, since it deals with files, add the **-Z** option to apply the SELinux
    policy from the container directory to the local directory:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Verify that the container is running, as well as that you have access to the
    service:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 13.40 – Testing the container with persistent storage](img/B19121_13_39.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 13.40 – Testing the container with persistent storage
  prefs: []
  type: TYPE_NORMAL
- en: Now, our web service has persistent storage. This can be managed locally or
    independently of the container instance(s) running with the content.
  prefs: []
  type: TYPE_NORMAL
- en: This service could manage itself as a container and give this management to
    `systemd` as part of the system. Let’s learn how set up self-management.
  prefs: []
  type: TYPE_NORMAL
- en: 'Using the same `myapache` container from the previous example, follow these
    steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Stop and remove the **myapache** container:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'To make the **myapache** container self-managed, add a command that determines
    the health of the container. In our case, we will use the **curl** command from
    the previous example. Use the **--health-cmd** and **--health-interval** options
    to define them in the container:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Here’s the output:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 13.41 – Making the container self-managed](img/B19121_13_40.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 13.41 – Making the container self-managed
  prefs: []
  type: TYPE_NORMAL
- en: Verify the creation of the container. Then, use the `podman` `ps` command.
  prefs: []
  type: TYPE_NORMAL
- en: 'To check the health of the container, run the **podman healthcheck** **run**
    command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Here’s the output:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 13.42 – Reviewing the health of the container](img/B19121_13_41.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 13.42 – Reviewing the health of the container
  prefs: []
  type: TYPE_NORMAL
- en: 'The output of the preceding command should return nothing. Run an **echo**
    command on the special variable, **$?**, to get the output of the command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Thus, the `myapache` container indicates when it is working correctly – that
    is, it is self-managing. This management could delegate to the operating system
    as part of one of its services. For this, `systemd` must be set up to support
    services that are started from the user session. Follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'As **root**, enable user lingering by running the **loginctl** command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create a directory to host the containerized services and change to that directory:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Build the configuration files for **systemd** using the **podman** **generate**
    command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Here’s the output:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 13.43 – Containerized service configuration file](img/B19121_13_42.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 13.43 – Containerized service configuration file
  prefs: []
  type: TYPE_NORMAL
- en: The preceding command creates the `container-myapache.service` unit file with
    the configuration for `systemd` to manage.
  prefs: []
  type: TYPE_NORMAL
- en: 'Reload the user’s daemons by running the following **systemctl** command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Enable the user’s containerized service by running the following **systemctl**
    command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Verify the status of the containerized service by running the following **systemctl**
    command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'You should see the following output:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 13.44 – Verifying the containerized service](img/B19121_13_43.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 13.44 – Verifying the containerized service
  prefs: []
  type: TYPE_NORMAL
- en: Finally, verify that the containerized service continues to operate. Use the
    `curl` command we used previously.
  prefs: []
  type: TYPE_NORMAL
- en: With that, we’ve learned how to use OCI containers, from their simple use to
    creating a containerized service that’s managed by the operating system.
  prefs: []
  type: TYPE_NORMAL
- en: Fedora Linux implements the use of OCI containers as a way to ease service management.
    With this bouquet of possibilities, depending on the workload, we can choose a
    virtual machine, either created with a cloud-based image or created with its installation
    image traditionally. Alternatively, we can use containers if we only need to deploy
    a simple service such as `myapache`.
  prefs: []
  type: TYPE_NORMAL
- en: I hope these options can help you improve the performance of your day-to-day
    tasks as a Linux system administrator.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we provided a quick overview of the methods for creating a
    virtual machine. In my opinion, the easiest and fastest way is to rely on the
    use of pre-built cloud images. In a couple of steps, and with enough practice,
    we can have them working in a matter of minutes.
  prefs: []
  type: TYPE_NORMAL
- en: Besides that, we used Gnome Boxes as a traditional method of creating virtual
    machines with an installation image. This method is a bit slower but allows us
    to customize the guest operating system installation.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we looked at services, where we learned how to use OCI containers implemented
    by Fedora Linux. This is a simple option for creating containerized services because
    it gives us the power to customize them so that they meet our needs. For example,
    we can use them for persistent storage, self-management, or even to delegate a
    containerized service as a system service managed by `systemd`.
  prefs: []
  type: TYPE_NORMAL
- en: All these tools make up an arsenal that could ease the performance of a Linux
    system administrator’s day-to-day tasks. As we mentioned in [*Chapter 10*](B19121_10_split_000.xhtml#_idTextAnchor208),
    “*a good system administrator backs up, automates, and studies in their* *spare
    time*.”
  prefs: []
  type: TYPE_NORMAL
- en: Congratulations on making it to the end of this book! I hope you found it useful.
  prefs: []
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To learn more about the topics covered in this chapter, you can visit the following
    link:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Build a lab in 5 minutes with three simple* *commands*: [https://www.redhat.com/sysadmin/build-lab-quickly](https://www.redhat.com/sysadmin/build-lab-quickly)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
