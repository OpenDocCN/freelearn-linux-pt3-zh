- en: '9'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '9'
- en: Filtering Text with grep, sed, and Regular Expressions
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用`grep`、`sed`和正则表达式进行文本过滤
- en: So far, we’ve looked at how to perform file searches with `find`, and at how
    to use text-stream filter utilities to extract and present data from text files
    and program output streams. In this chapter we’ll be looking at two other utilities,
    `sed` and `grep`, that will allow you to supercharge both your searches and your
    text manipulations. Before that though, you need to understand about Regular Expressions.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经看过了如何使用`find`进行文件搜索，以及如何使用文本流过滤工具从文本文件和程序输出流中提取和呈现数据。在本章中，我们将研究另外两个工具，`sed`和`grep`，它们将使你的搜索和文本操作更加强大。不过，在此之前，你需要了解正则表达式。
- en: 'Topics in this chapter include:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的内容包括：
- en: Understanding Regular Expressions
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解正则表达式
- en: Understanding `sed`
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解`sed`
- en: Understanding `grep`
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解`grep`
- en: Using RegEx Buddy
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用RegEx Buddy
- en: Using RegEx101
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用RegEx101
- en: Looking at some real-world examples
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 查看一些实际案例
- en: If you’re ready, let’s get started.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你准备好了，我们就开始吧。
- en: Technical Requirements
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: Use any of your Linux virtual machines or your Linux host machine.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 使用任何一台Linux虚拟机或你的Linux主机。
- en: 'Also, as always, you can grab the scripts and text files from Github, like
    so:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 另外，像往常一样，你可以从Github获取脚本和文本文件，方法如下：
- en: '[PRE0]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Understanding Regular Expressions
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解正则表达式
- en: When you worked with the text-stream filters in *Chapter 6, Text Stream Filters
    Part 1* and *Chapter 7, Text Stream Filters Part 2*, you were manipulating simple
    text strings. That is, you were working with alphabetic characters, numbers, and
    the control characters that allow you to place tabs, spaces, and newlines into
    your text files. **Regular Expressions**, which you’ll sometimes see shortened
    to either **regexp** or **regex**, can include text strings, or even be a text
    string. They can also include special characters, collectively called **metacharacters**,
    which give such awesome power to the tools that understand them. In fact, you
    can think of Regular Expressions as a sort of programming language, with text
    strings as the words and metacharacters as the punctuation. Rather than just enabling
    you to search for simple text strings, regular expressions allow you to search
    for patterns. For example, if you need to search through a file for all telephone
    numbers or all credit card numbers, you can create a regular expression that searches
    for text strings that match those patterns.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 当你在*第六章，文本流过滤器第1部分*和*第七章，文本流过滤器第2部分*中使用文本流过滤器时，你操作的是简单的文本字符串。也就是说，你在处理字母字符、数字和允许你在文本文件中插入制表符、空格和换行符的控制字符。**正则表达式**（Regular
    Expressions），有时你会看到它缩写为**regexp**或**regex**，可以包括文本字符串，甚至可以是一个文本字符串。它们还可以包括特殊字符，统称为**元字符**，这些元字符赋予了理解它们的工具强大的功能。事实上，你可以把正则表达式看作一种编程语言，文本字符串是单词，元字符是标点符号。正则表达式不仅能让你搜索简单的文本字符串，它还允许你搜索模式。例如，如果你需要在文件中查找所有电话号码或所有信用卡号码，你可以创建一个正则表达式来查找与这些模式匹配的文本字符串。
- en: I need to clarify something that’s a bit confusing. *Regular Expressions*, always
    written in the plural form and with upper-case letters beginning each word, is
    the name of the pattern-matching language. That’s different from a *regular expression*,
    which is a pattern-matching construct that you would build with the *Regular Expressions*
    language.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 我需要澄清一件有些混淆的事情。*正则表达式*（Regular Expressions），总是以复数形式书写，并且每个单词的首字母都大写，是一种模式匹配语言的名称。它与*正则表达式*（regular
    expression）不同，后者是你可以用*正则表达式*语言构建的一个模式匹配结构。
- en: Understand, though, that the topic of Regular Expressionsis a huge one, and
    is a topic about which whole books are written. For now, I’ll just give you the
    basics that you need to understand how to use them with `grep` and `sed`. Let’s
    begin by looking at the two general types of characters that you would use in
    a regular expression.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 不过，要理解的是，正则表达式的主题是非常庞大的，关于它的内容甚至可以写成整本书。现在，我会给你一些基础知识，让你理解如何在`grep`和`sed`中使用它们。让我们首先来看一下正则表达式中你会使用的两类字符。
- en: Literals and Metacharacters
  id: totrans-19
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 字面量和元字符
- en: There are two types of characters that you’ll use in regular expressions. **Literals**
    are any character which is to be taken literally. In other words, literals are
    anything that you want to treat as just plain text. **Metacharacters** give you
    the ability to modify your pattern-matching according to your needs. You can,
    for example, use metacharacters to find a text pattern that occurs at either the
    beginning or end of a line, while leaving the pattern alone if it occurs somewhere
    else in the line. You can also use metacharacters to perform different types of
    wild-card pattern-matching.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 你将会使用两种类型的字符来构造正则表达式。**字面字符**是任何需要被按字面意思匹配的字符。换句话说，字面字符就是你希望当作普通文本对待的任何东西。**元字符**则使你能够根据需要修改模式匹配。例如，你可以使用元字符查找发生在行首或行尾的文本模式，而如果模式出现在行中的其他地方则不进行匹配。你还可以使用元字符执行不同类型的通配符模式匹配。
- en: 'There are three types of metacharacters, which are:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 有三种类型的元字符，它们是：
- en: '**Positional anchors**: These define where in either a file or a line that
    you would want to find a match.'
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**位置锚点**：这些定义了你希望在文件或行中的哪个位置找到匹配项。'
- en: '**Character sets**: These define either a range or a specific type of literal
    character that you want to match. In other words, if you want to find a text string
    that contains nothing but lower-case letters, you don’t have to list each lower-case
    letter in your regular expression. Instead, just use the lower-case letter character
    set.'
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**字符集**：这些定义了你想要匹配的字符范围或特定类型的字面字符。换句话说，如果你想找到一个只包含小写字母的文本字符串，你不必在正则表达式中列出每一个小写字母。相反，只需使用小写字母字符集。'
- en: '**Modifiers**: Mainly, these metacharacters allow you to define how many of
    any literal character or string of literal characters that you want to match at
    a time. The other modifiers are the or operator and the grouping operator.'
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**修饰符**：主要来说，这些元字符允许你定义你希望一次匹配的字面字符或字面字符串的个数。其他修饰符包括或操作符和分组操作符。'
- en: 'The **positional anchors**, are as you see in the following table:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: '**位置锚点**，如以下表格所示：'
- en: '| **Positional anchor** | **Description** |'
  id: totrans-26
  prefs: []
  type: TYPE_TB
  zh: '| **位置锚点** | **描述** |'
- en: '| `^` | This allows you to match a pattern that occurs at the beginning of
    a line. You would always place it to the left of the pattern that you want to
    match, like this: `^pattern` |'
  id: totrans-27
  prefs: []
  type: TYPE_TB
  zh: '| `^` | 这允许你匹配发生在行首的模式。你总是将其放置在你想要匹配的模式左侧，像这样：`^pattern` |'
- en: '| `$` | This allows you to match a pattern that occurs at the end of a line.
    You would always place it to the right of the pattern that you want to match,
    like this: `pattern$` |'
  id: totrans-28
  prefs: []
  type: TYPE_TB
  zh: '| `$` | 这允许你匹配发生在行尾的模式。你总是将其放置在你想要匹配的模式右侧，像这样：`pattern$` |'
- en: '| `\<pattern\>` | This pair of symbols marks word boundaries. For example,
    if you were to search for the pattern *and*, use of this metacharacter would only
    match with the whole word *and*, instead of with any word that contains the text
    string *and*. |'
  id: totrans-29
  prefs: []
  type: TYPE_TB
  zh: '| `\<pattern\>` | 这一对符号标记了单词边界。例如，如果你要搜索模式*and*，使用这个元字符将只匹配整个单词*and*，而不是包含文本字符串*and*的任何单词。
    |'
- en: The following table explains the about the various **character sets**.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 以下表格解释了各种**字符集**。
- en: '| **Character set examples** | **Description** |'
  id: totrans-31
  prefs: []
  type: TYPE_TB
  zh: '| **字符集示例** | **描述** |'
- en: '| `[abc]``[a-z]``[:lower:]``[:digit:]` | This should already be familiar to
    you. This defines either a set of characters or a range of characters to match
    in a pattern. You can also use the same character classes that you used with the
    text-stream filters. |'
  id: totrans-32
  prefs: []
  type: TYPE_TB
  zh: '| `[abc]``[a-z]``[:lower:]``[:digit:]` | 这应该已经对你来说是熟悉的了。它定义了一个字符集或字符范围，用于在模式中匹配。你还可以使用与文本流过滤器相同的字符类。
    |'
- en: '| `[^abc]``[^a-z]` | In the previous table, I showed you how the `^` can be
    used as a positional anchor. But, when used as the first character of a character
    set, the `^` acts as a negation operator. So, while `[abc]` matches everything
    with an a, b, or c in it, `[^abc]` matches everything without an a, b, or c in
    it. |'
  id: totrans-33
  prefs: []
  type: TYPE_TB
  zh: '| `[^abc]``[^a-z]` | 在前面的表格中，我向你展示了如何使用`^`作为位置锚点。但是，当`^`作为字符集的第一个字符时，它充当否定操作符。所以，虽然`[abc]`匹配包含a、b或c的任何内容，`[^abc]`则匹配不包含a、b或c的任何内容。
    |'
- en: 'The final type of metacharacters consists of the **modifiers**, as you see
    in this table:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 元字符的最后一种类型是**修饰符**，如表格所示：
- en: '| **Basic modifier** | **Extended modifier** | **Description** |'
  id: totrans-35
  prefs: []
  type: TYPE_TB
  zh: '| **基本修饰符** | **扩展修饰符** | **描述** |'
- en: '| `*` | `*` | Wild-card to match zero or more of the single character or single-character
    regular expression that precedes it. Note that this behavior is different from
    what you’re used to seeing with `*` in normal command-line operations, in commands
    such as `ls -l *.txt`. |'
  id: totrans-36
  prefs: []
  type: TYPE_TB
  zh: '| `*` | `*` | 匹配前面单个字符或单字符正则表达式的零次或多次出现的通配符。请注意，这种行为不同于你在正常命令行操作中看到的 `*`，例如在
    `ls -l *.txt` 命令中。 |'
- en: '| `\?` | `?` | Wild-card to match zero or one instance of the preceding single
    character or regular expression. |'
  id: totrans-37
  prefs: []
  type: TYPE_TB
  zh: '| `\?` | `?` | 匹配前面单个字符或正则表达式零次或一次出现的通配符。 |'
- en: '| `\+` | `+` | A wild-card that must have a match. Matches one or more instances
    of the preceding single character or regular expression. |'
  id: totrans-38
  prefs: []
  type: TYPE_TB
  zh: '| `\+` | `+` | 必须有匹配项的通配符。匹配前面单个字符或正则表达式的一次或多次出现。 |'
- en: '| `\{n\}` | `{n}` | Matches *n* occurrences of the preceding single character
    or regular expression. |'
  id: totrans-39
  prefs: []
  type: TYPE_TB
  zh: '| `\{n\}` | `{n}` | 匹配前面单个字符或正则表达式的*n*次出现。 |'
- en: '| `\{n,\}` | `{n,}` | Matches at least *n* occurrences of the preceding single
    character or regular expression. |'
  id: totrans-40
  prefs: []
  type: TYPE_TB
  zh: '| `\{n,\}` | `{n,}` | 匹配前面单个字符或正则表达式至少*n*次出现。 |'
- en: '| `\&#124;` | `&#124;` | It’s called an **alternation**, but think of it as
    an `or` operator. |'
  id: totrans-41
  prefs: []
  type: TYPE_TB
  zh: '| `\&#124;` | `&#124;` | 这叫做**交替**，但可以理解为 `or` 运算符。 |'
- en: '| `\(regex\)` | `(regex)` | This symbolizes grouping. It matches the regex
    that’s within the parentheses, but it can be modified as a whole. It can also
    be used in back-references. |'
  id: totrans-42
  prefs: []
  type: TYPE_TB
  zh: '| `\(regex\)` | `(regex)` | 这表示分组。它匹配括号内的正则表达式，但可以整体进行修改。它也可以用于反向引用。 |'
- en: Don’t worry about the difference between the **Basic Modifiers** and **Extended
    Modifiers** just yet. I’ll cover that when we get to the *Understanding grep*
    section.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 现在不必担心**基本修饰符**和**扩展修饰符**之间的区别。我会在我们讨论*理解 grep*这一部分时讲解这些内容。
- en: As I said before, the topic of Regular Expressions is quite vast and complex.
    I don’t have space to give a complete tutorial on the subject, so I’ll instead
    just provide examples of using various regular expressions in the `sed` and `grep`
    sections.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我之前所说，正则表达式的主题非常庞大和复杂。我没有足够的篇幅提供完整的教程，所以我会在 `sed` 和 `grep` 部分提供一些使用各种正则表达式的示例。
- en: 'You can find some more information on regular expressions by looking at the
    `regex` man page, which is in section 7 of the man pages. (Just don’t expect to
    become a regex expert by reading it.) View the proper man page by doing:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过查看 `regex` 的手册页面来获得更多关于正则表达式的信息，这个页面位于手册的第7节。（不过不要指望通过阅读它成为正则表达式专家。）你可以通过以下命令查看相应的手册页面：
- en: '`man 7 regex`'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: '`man 7 regex`'
- en: Now that I’ve introduced you to Regular Expressions and regular expressions,
    allow me to introduce you to a utility that uses them.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我已经向你介绍了正则表达式，现在让我向你介绍一个使用正则表达式的工具。
- en: Understanding sed
  id: totrans-48
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解 `sed`
- en: '`sed`, short for **Stream Editor**, is an extremely powerful utility, and is
    another subject on which whole books are written. The goal here is to help you
    learn the basics for now, and to whet your appetite to learn more later.'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: '`sed`，即**流编辑器**的缩写，是一个非常强大的工具，关于它有许多书籍专门进行讲解。这里的目标是帮助你学习基础知识，并激发你今后深入学习的兴趣。'
- en: If you’ve ever had to error-check or edit large text documents, you’ll appreciate
    the power of `sed`. For simple jobs, a one-line command, known as a **sed script**,
    might be all you need. For more complex jobs, such as when you might need to make
    multiple changes at a time to one or more documents, you can write lengthy program
    files and execute them with `sed`. The only limitation is your own imagination.
    But, before we can talk about the cool things you can do with `sed`, we need to
    take a brief intermission to talk about `sed` portability issues.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你曾经需要对大型文本文件进行错误检查或编辑，你会很欣赏 `sed` 的强大功能。对于简单的任务，一条命令——即所谓的**sed 脚本**——可能就足够了。对于更复杂的任务，比如你可能需要对一个或多个文档进行多次修改时，你可以编写较长的程序文件，并通过
    `sed` 执行它们。唯一的限制就是你自己的想象力。但在我们谈论如何用 `sed` 做酷炫的事情之前，我们需要简要讨论一下 `sed` 的可移植性问题。
- en: Understanding sed Portability Issues
  id: totrans-51
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 理解 `sed` 可移植性问题
- en: If you need to work with non-Linux operating systems, you’ll encounter two different
    implementations of `sed`. Linux operating systems use the GNU implementation,
    and the BSD implementation is used on macOS, the BSD distros, and OpenIndiana.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你需要使用非 Linux 操作系统，你将会遇到两种不同的 `sed` 实现。Linux 操作系统使用 GNU 实现，而 macOS、BSD 发行版和
    OpenIndiana 上使用的是 BSD 实现。
- en: BSD stands for **Berkeley Software Distribution**, and GNU is a recursive acronym
    that stands for **GNU is not Unix**.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: BSD 代表 **伯克利软件发行版**，而 GNU 是一个递归缩写，代表 **GNU 不是 Unix**。
- en: The difference is that the GNU implementation has really cool, advanced features
    that the BSD implementation lacks. So, many of the examples that I’m about to
    show you in this section—specifically the append (`a)`, insert (`i)`, and change
    (`c)` commands, as well as any command that uses a regular expression—won’t work
    on the BSD implementation. Fortunately though, there’s an easy fix for all of
    these operating systems. Just install the `gsed` package, and then create a `sed`
    alias that points to the `gsed` executable. Here are the directions for the various
    operating systems.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 区别在于，GNU 实现具有 BSD 实现所没有的非常酷的高级功能。因此，我将在本节中向你展示的许多示例——特别是附加（`a`）、插入（`i`）和更改（`c`）命令，以及任何使用正则表达式的命令——在
    BSD 实现中无法使用。不过幸运的是，所有这些操作系统都有一个简单的解决办法。只需安装 `gsed` 包，然后创建指向 `gsed` 可执行文件的 `sed`
    别名。以下是各操作系统的具体指引。
- en: Installing gsed on FreeBSD
  id: totrans-55
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 在 FreeBSD 上安装 gsed
- en: 'On FreeBSD, install `gsed` like this:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 在 FreeBSD 上，像这样安装 `gsed`：
- en: '[PRE1]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Then, edit the `.shrc` file that’s in your home directory, adding the following
    line to the alias section:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，编辑你主目录中的 `.shrc` 文件，在别名部分添加以下行：
- en: '[PRE2]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Log out of the terminal and then log back in again. Verify that the alias has
    taken effect by doing:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 注销终端，然后重新登录。通过执行以下命令验证别名是否已生效：
- en: '[PRE3]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Installing gsed on macOS
  id: totrans-62
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 在 macOS 上安装 gsed
- en: Installing `gsed` on macOS is just as easy, but you’ll first need to install
    the Homebrew system.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 在 macOS 上安装 `gsed` 同样简单，但你首先需要安装 Homebrew 系统。
- en: 'You’ll find directions on how to install Homebrew at: [https://brew.sh/](https://brew.sh/)'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在以下网站找到有关如何安装 Homebrew 的说明：[https://brew.sh/](https://brew.sh/)
- en: 'Then, install `gsed` by doing:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，执行以下命令安装 `gsed`：
- en: '[PRE4]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Add the alias to the `.zprofile` file that’s in your home directory, by adding
    this line:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 将别名添加到你主目录中的 `.zprofile` 文件，方法是添加以下行：
- en: '[PRE5]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Close your terminal window and then open it again. Then, verify that the alias
    has taken effect:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 关闭终端窗口，然后再打开它。然后，验证别名是否已生效：
- en: '[PRE6]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Installing gsed on OpenIndiana
  id: totrans-71
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 在 OpenIndiana 上安装 gsed
- en: 'OpenIndiana doesn’t have `gsed` in its normal software repository. So, you’ll
    need to install a third-party repository to get it. First, open Firefox on your
    OpenIndiana machine and navigate to: [http://buildfarm.opencsw.org/opencsw/official/](http://buildfarm.opencsw.org/opencsw/official/)'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: OpenIndiana 的正常软件库中没有 `gsed`。因此，你需要安装一个第三方库来获取它。首先，在你的 OpenIndiana 机器上打开 Firefox
    并访问：[http://buildfarm.opencsw.org/opencsw/official/](http://buildfarm.opencsw.org/opencsw/official/)
- en: Download the the `pkgutil.pkg` file that you’ll see there.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 下载你将看到的 `pkgutil.pkg` 文件。
- en: 'Install the package by doing:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 通过执行以下命令安装该包：
- en: '[PRE7]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'This will install `pkgutil` into the `/opt/csw/bin`/ directory, as you see
    here:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 这将把 `pkgutil` 安装到 `/opt/csw/bin/` 目录，如下所示：
- en: '[PRE8]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'This directory isn’t in your `PATH`, so you’ll need to fix that. The easiest
    way is to create a symbolic link in the `/usr/sbin/` directory, like so:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 这个目录不在你的 `PATH` 中，因此你需要修复它。最简单的方法是在 `/usr/sbin/` 目录中创建一个符号链接，如下所示：
- en: '[PRE9]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Next, install the `gsed` package, like this:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，安装 `gsed` 包，方法如下：
- en: '[PRE10]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Finally, you’re ready to create the alias. On OpenIndiana, you’ll need to create
    it in two different files. To enable the alias when you open a terminal on the
    local machine, you’ll need to add it to the `.bashrc` file in your home directory,
    like so:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，你准备好创建别名了。在 OpenIndiana 上，你需要在两个不同的文件中创建它。为了在本地机器上打开终端时启用别名，你需要将其添加到主目录中的
    `.bashrc` 文件中，如下所示：
- en: '[PRE11]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: To enable the alias when you login remotely via `ssh`, you’ll need to create
    the `.bash_profile` file in your home directory, and add the same alias line to
    it.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 为了在通过 `ssh` 远程登录时启用别名，你需要在主目录中创建 `.bash_profile` 文件，并将相同的别名行添加到其中。
- en: Now that you’ve installed `gsed` and created an alias on your non-Linux system,
    you’ll be able to run any `sed` command you want from the command-line. Unfortunately,
    this won’t work if you place any `sed` commands into your shell scripts, because
    shell scripts don’t read the `.bashrc`, `.shrc`, `.bash_profile`, or `.zprofile`
    files that contain the alias. That’s okay for now, because I’ll show you how to
    deal with that later. First though, I need to show you how to use the various
    `sed` commands.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经安装了`gsed`并在非Linux系统上创建了别名，你将能够从命令行运行任何`sed`命令。不幸的是，如果你将任何`sed`命令放入shell脚本中，这将无法工作，因为shell脚本不会读取包含别名的`.bashrc`、`.shrc`、`.bash_profile`或`.zprofile`文件。现在没关系，因为我稍后会告诉你如何解决这个问题。不过，首先，我需要向你展示如何使用各种`sed`命令。
- en: Now that that’s done, let’s look at how to actually use `sed`. There are several
    different `sed` functions that you need to know. Let’s start with the substitute
    function.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 既然已经完成了，让我们来看看如何实际使用`sed`。有几个不同的`sed`函数是你需要了解的。我们从替换函数开始。
- en: Substitution with sed
  id: totrans-87
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用sed进行替换
- en: In the diagram below, you see the breakdown of a typical `sed` substitution
    script.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 在下图中，你可以看到一个典型的`sed`替换脚本的结构。
- en: '![B21693_9_1](img/B21693_09_01.png)'
  id: totrans-89
  prefs: []
  type: TYPE_IMG
  zh: '![B21693_9_1](img/B21693_09_01.png)'
- en: 'Figure 9.1: A typical sed substitution script'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.1：一个典型的sed替换脚本
- en: Now, let’s look at some specific examples.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看一些具体的例子。
- en: 'Example 1: Modifying an Office Memo'
  id: totrans-92
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 示例1：修改办公室备忘录
- en: 'Let’s begin with a simple office memo. Create the `tom.txt` file, as you see
    here:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从一个简单的办公室备忘录开始。创建一个`tom.txt`文件，正如你所看到的那样：
- en: '[PRE12]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: You can see that the document has a few problems. The most obvious is that proper
    names aren’t always capitalized. We need a way to automate the process of making
    these corrections.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以看到文档中存在一些问题。最明显的一点是专有名词并没有总是大写。我们需要一种方法来自动化这些修改过程。
- en: 'It’s possible to make all corrections at once, but first, let’s just look at
    how to replace *tom* with *Tom*. Do it like this:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然可以一次性完成所有的修改，但首先，我们来看看如何将*tom*替换为*Tom*。你可以这样做：
- en: '[PRE13]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The first thing you see within the single quotes is the letter `s`. That’s what
    tells `sed` to perform a substitution. Next, you see the two patterns that you’re
    working with. The first is the pattern that you’re replacing, and the second is
    what you’re using as the replacement. After you close the expression with another
    single quote, list the text file that you want to modify. (Note that you don’t
    need a `stdin` redirector.)
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 在单引号中，你首先看到字母`s`。它告诉`sed`执行替换操作。接下来，你会看到你正在处理的两个模式。第一个是你要替换的模式，第二个是你用作替换的内容。关闭表达式后，列出你想要修改的文本文件。（注意，你不需要`stdin`重定向符。）
- en: 'Now, this did work for the most part, but we still have one lower-case *tom*
    in the last line of the body. That’s because by default, the `s` command for `sed`
    will only replace the first occurrence of a pattern in a given line. To fix this,
    use the `s` command with its global (`g`) option. That way, every occurrence of
    a pattern in any given line will be replaced. Here is what that looks like:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，这个方法在大多数情况下有效，但我们仍然在正文的最后一行有一个小写的*tom*。这是因为默认情况下，`sed`的`s`命令只会替换给定行中的第一个匹配项。为了修复这个问题，使用带有全局（`g`）选项的`s`命令。这样，给定行中的每一个匹配项都会被替换。以下是这样做的效果：
- en: '[PRE14]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'This works much better. But, we still have lower-case surnames to replace.
    Let’s combine two commands to replace both the first and last names at once, like
    this:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 这样效果好多了。但是，我们仍然需要替换小写的姓氏。让我们将两个命令结合起来，一次性替换姓和名，像这样：
- en: '[PRE15]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: All you have to do is create two separate `sed` scripts, and combine them with
    a semi-colon. You can place both scripts within only one set of single quotes.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 你只需要创建两个独立的`sed`脚本，并用分号将它们组合在一起。你可以将两个脚本放在一对单引号内。
- en: By default, `sed` will read in the text file that you want to modify, and send
    the entire modified file to `stdout`.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，`sed`会读取你想修改的文本文件，并将整个修改后的文件发送到`stdout`。
- en: What if you only want to see the lines that actually got modified?
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你只想查看实际被修改的行怎么办？
- en: 'For that, you would use the `-n` switch as the `sed` option, and the `p` switch
    as the `s` command option. First, let’s look at what happens when you use only
    one of these switches at a time. Here’s what happens if you use `-n` without the
    `p`:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 为此，你需要使用`-n`开关作为`sed`选项，`p`开关作为`s`命令选项。首先，我们来看看只使用其中一个开关时会发生什么。以下是如果你只使用`-n`而没有`p`的结果：
- en: '[PRE16]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Without the `p` switch for the `s` command, the `-n` switch will suppress all
    output, which isn’t what we want. This is because the `-n` switch is the *quiet*
    switch, which negates `sed`'s default behavior of passing the processed file to
    `stdout`.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 如果没有`s`命令的`p`开关，`-n`开关会抑制所有输出，这不是我们想要的效果。因为`-n`开关是*静默*开关，它会取消`sed`默认将处理后的文件输出到`stdout`的行为。
- en: 'Next, let’s try it with just the `p` and without the `-n`, which will look
    like this:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们尝试只用`p`而不加`-n`，它会是这样的：
- en: '[PRE17]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Without the `-n` option, the `p` option for the `s` command will cause `sed`
    to print its default output, in addition to printing the modified lines a second
    time. (Actually, we see here that two lines were printed a third time, since more
    than one replacement was done in each.) This is because without the quiet switch
    (`-n`), `sed` once again defaults to printing out the processed file. Then, the
    `p` option for the `s` command causes all modified lines to print out again.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 如果没有`-n`选项，`s`命令的`p`选项会导致`sed`打印默认输出，此外还会将修改后的行再次打印一次。（实际上，我们在这里看到有两行被打印了三次，因为每行做了多次替换。）这是因为没有静默选项（`-n`）时，`sed`默认会将处理过的文件打印出来。然后，`s`命令的`p`选项会导致所有被修改过的行再次打印出来。
- en: 'Now, to see only the modified lines, let’s combine the options, like this:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，为了只查看修改后的行，让我们将选项合并，像这样：
- en: '[PRE18]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: So the lesson here is that you must use `-n` and `p` together, because using
    just one of them won’t give you what you want.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 所以这里的教训是，你必须同时使用`-n`和`p`选项，因为只使用其中一个选项并不能达到你想要的效果。
- en: Wait though, you’re not through yet. It seems that your boss is a bit of a practical
    joker. So, he tells you to replace the last *Tinker* with *Stinker*. As he turns
    to leave, he winks and says, “Yeah, that’ll get him”. Here’s where the addressing
    option comes in handy.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 等等，不过你还没完呢。看来你的老板有点爱开玩笑。所以，他告诉你将最后一个*Tinker*替换为*Stinker*。他转身离开时，眨了眨眼，说：“是的，这样一定能让他生气。”这时，地址选项派上了用场。
- en: 'Since you know that the last *Tinker* is the last word in the last line of
    the file, you can direct `sed` to only replace that occurrence by placing the
    *end-of* metacharacter (`$`), in the address. Here’s how that looks:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 由于你知道最后一个*Tinker*是文件最后一行的最后一个单词，你可以通过在地址中放置*行尾*元字符（`$`）来指示`sed`只替换该出现。它看起来像这样：
- en: '[PRE19]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Okay, let’s move on to our next example.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，让我们进入下一个示例。
- en: 'Example 2: Modifying a List of Hollywood Actors'
  id: totrans-119
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 示例 2：修改好莱坞演员列表
- en: 'There are still plenty of other ways to perform substitutions with `sed`. To
    demonstrate, create the `actorsfile_11.txt` file with the following list of Hollywood
    actors:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 仍然有很多其他方法可以使用`sed`进行替换。为了演示，创建一个名为`actorsfile_11.txt`的文件，并填入以下好莱坞演员的名单：
- en: '[PRE20]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'You’ve decided that you want to replace Groucho Marx with his brother Zeppo.
    Search for all lines that begin with Marx, and make the replacement only on those
    lines, like this:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 你决定将Groucho Marx替换为他的兄弟Zeppo。查找所有以Marx开头的行，并且仅在这些行上进行替换，像这样：
- en: '[PRE21]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: In this example, you used a regular expression for an address. That is, you
    placed the literal string *Marx* within the default `sed` delimiters (the forward
    slashes), then preceded it with the `^` metacharacter. That causes the substitute
    command to look for only the occurrence of *Marx* at the beginning of a line.
    Note again how this address immediately precedes the `s` command. You don’t need
    to use the global option for the `s` command, because you already know that there’s
    only one occurrence of a given word in each line.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，你使用了一个正则表达式作为地址。也就是说，你将字面字符串*Marx*放在了`sed`的默认分隔符（正斜杠）内，然后在它前面加上了`^`元字符。这使得替换命令只查找以*Marx*开头的行中的*Marx*出现。再看一下这个地址是如何紧接在`s`命令之前的。你不需要为`s`命令使用全局选项，因为你已经知道每行中给定单词只有一个出现。
- en: 'You’ve now decided that you need to replace Joe Besser with Joe DeRita. (That’s
    appropriate, because in real life the Three Stooges really did replace Joe Besser
    with Joe DeRita, after Joe Besser left to care for his ailing wife.) This time,
    you want to search for lines that end with *Joe*, and make the replacement only
    on those lines, like this:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 你现在决定将Joe Besser替换为Joe DeRita。（这是合理的，因为在现实生活中，《三傻大闹宝莱坞》的确在Joe Besser离开照顾生病的妻子后，用Joe
    DeRita替换了Joe Besser。）这次，你想要查找以*Joe*结尾的行，并且仅在这些行上进行替换，像这样：
- en: '[PRE22]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: This time, you used the `$` metacharacter in the address to tell `s` to look
    at the end of the lines. Note how you had to place this metacharacter at the end
    of the literal string.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 这一次，你在地址中使用了`$`元字符来告诉`s`查看行尾。请注意，你必须将这个元字符放在字面字符串的末尾。
- en: Okay, enough of actors. Let’s look at some classic cars.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 好了，演员部分说完了。我们来看一些经典汽车。
- en: 'Example 3: Modifying Lists of Cars'
  id: totrans-129
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 示例 3：修改汽车列表
- en: 'You can also replace individual characters. Create the `cars_2.txt` file with
    the following contents:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以替换单个字符。创建一个名为`cars_2.txt`的文件，内容如下：
- en: '[PRE23]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'In thisfile, you see that you need to capitalize the names of some of the listed
    cars. For now, let’s just concentrate on capitalizing *Desoto*. If you tell `sed`
    to replace every *d* with a *D*, you’ll get this:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个文件中，你看到需要大写一些列出的汽车名称。现在，我们只关注将*Desoto*大写。如果你告诉`sed`将每个*d*替换为*D*，你会得到这个结果：
- en: '[PRE24]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'That’s not what you want. But, you know that there is a lower-case *desoto*
    only in lines four and five. So, you can tell `sed` to replace the lower-case
    *d* in only those two lines, like this:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 这不是你想要的。但是，你知道*desoto*只出现在第4行和第5行。因此，你可以告诉`sed`仅在这两行中替换小写的*d*，就像这样：
- en: '[PRE25]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Note that the comma between the two line numbers means *lines four through five*,
    not *lines four and five*.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，两个行号之间的逗号表示*第4行到第5行*，而不是*第4行和第5行*。
- en: 'You can tell `sed` to search for *desoto* at the beginning of a line, like
    this:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以告诉`sed`在行的开头查找*desoto*，像这样：
- en: '[PRE26]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Insert the `-n` and `p` switches if you only want to see the lines that changed,
    like so:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你只想查看更改的行，可以插入`-n`和`p`开关，如下所示：
- en: '[PRE27]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'There are three ways to save your modifications. You can use the `stdout` redirector
    to create a new file, like this:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 有三种方法可以保存你的修改。你可以使用`stdout`重定向器创建一个新文件，如下所示：
- en: '[PRE28]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'You can use the `w` switch with the `s` command to save to a new file, like
    this:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以将`w`开关与`s`命令一起使用，将修改保存到新文件中，如下所示：
- en: '[PRE29]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'The only catch with this is that even though the `w` switch shows the entire
    contents of the modified file on screen, it only saves the modified lines to a
    new file, as you see here:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 这里唯一的诀窍是，尽管`w`开关会在屏幕上显示整个修改后的文件内容，但它只会将修改后的行保存到新文件中，如你所见：
- en: '[PRE30]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'The final way to save your modifications is to use the `-i` switch to modify
    the original file, like so:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 保存修改的最终方法是使用`-i`开关来修改原始文件，如下所示：
- en: '[PRE31]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Unlike when you use the `w` switch, the `-i` saves the entire modified file,
    as you see here:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 与使用`w`开关时不同，`-i`会保存整个修改后的文件，如你所见：
- en: '[PRE32]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'If you want to create a backup of the original file before it gets modified,
    just put the suffix that you want to append to the backup filename after the `-i`
    switch, like so:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想在修改原始文件之前创建一个备份，只需在`-i`开关后添加你想要附加到备份文件名的后缀，如下所示：
- en: '[PRE33]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Note that you can’t have a blank space between the `-i` and the `.bak`. Verify
    that the operation worked, like this:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，`-i`和`.bak`之间不能有空格。验证操作是否成功，如下所示：
- en: '[PRE34]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Next, let’s do some whole-word substitutions.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们来做一些全字替换。
- en: 'Example 4: Performing a Whole-Word Substitution'
  id: totrans-156
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 示例 4：执行全字替换
- en: 'What if you have a pattern that can be part of other words, but you only want
    to perform substitutions on the pattern if it’s a whole word unto itself? To illustrate,
    create the `ing.txt` file with this somewhat corny story:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你有一个模式，它可能是其他单词的一部分，但你只想在它是一个完整单词时才执行替换呢？为此，创建一个名为`ing.txt`的文件，内容如下：
- en: '[PRE35]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Now, let’s say that you want to replace the word *ing* with the word *ING*.
    Try this command to see what you get:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，假设你想将单词*ing*替换为*ING*。尝试这个命令看看你会得到什么：
- en: '[PRE36]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'You really only wanted to replace the whole word *ing* with *ING*, but ended
    up replacing the *ing*’s that show up in other words, also. Here’s where you need
    to use word boundaries, like so:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 你原本只想将整个单词*ing*替换为*ING*，但也替换了其他单词中的*ing*。这时你需要使用词边界，如下所示：
- en: '[PRE37]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: All you had to do was to place the string that you wanted to replace inside
    of a of `\< \>` construct.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 你只需要将你想替换的字符串放入`\< \>`结构中。
- en: 'As you look at the metacharacter chart that I presented a few pages back, you
    may think, “Hey, I’ve discovered another way to do this. I can just use a wild-card
    character”. Indeed, in this case, it would work, as you see here:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 当你查看我几页前展示的元字符表时，你可能会想，“嘿，我发现了另一种方法。 我可以只使用通配符字符”。确实，在这种情况下，它会起作用，如你所见：
- en: '[PRE38]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Here, you used the `\+` metacharacter to replace all *ing*’s that are preceded
    by one or more blank spaces. (Note that I left a space between the first forward
    slash and the `\+` metacharacter in the `s` command. I also had to leave a blank
    space before the *ING* in order to also leave a space in the output.) However,
    in this case, this isn’t the most elegant solution, since it won’t work in all
    cases. To illustrate, create the `ing_2.txt` file, and make it look like this:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，你使用了 `\+` 元字符来替换所有前面有一个或多个空格的 *ing*。 （请注意，我在 `s` 命令中的第一个正斜杠和 `\+` 元字符之间留了一个空格。我还必须在
    *ING* 前面留一个空格，以便在输出中也能留出一个空格。）然而，在这种情况下，这并不是最优雅的解决方案，因为它并不适用于所有情况。为了说明这一点，创建 `ing_2.txt`
    文件，并使其如下所示：
- en: '[PRE39]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Perform the previous command again, and you should get this:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 再次执行前面的命令，你应该得到如下结果：
- en: '[PRE40]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: The *ing* in the last line didn’t get replaced, because it’s at the beginning
    of a line. Therefore, no blank spaces can precede it. Wild-card metacharacters
    are handy devices, and do have legitimate uses. But here, we find that they’re
    not the best solution.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一行中的 *ing* 没有被替换，因为它位于行首。因此，前面不能有空格。通配符元字符是很方便的工具，并且确实有它们的合法用途。但在这里，我们发现它们并不是最好的解决方案。
- en: That covers it for substitution. Let’s now do some deletions.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是替换的内容。接下来我们进行一些删除操作。
- en: Deletion with sed
  id: totrans-172
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 sed 删除
- en: You can use the `d` command to perform deletions. This is simpler than the substitution
    process, since all you really need is an address and the `d` command. We’ll begin
    by deleting some items from a list.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用 `d` 命令来执行删除操作。这比替换过程简单，因为你只需要地址和 `d` 命令。我们将从删除列表中的一些项开始。
- en: 'Example 1: Deleting Items from a List'
  id: totrans-174
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 示例 1：从列表中删除项
- en: 'Let’s take another look at our `cars_2.txt` file, and try to delete all references
    to Edsel. (We want to forget that the Edsel was ever made, as Ford Motor Company
    has tried to do ever since 1960.) First, as a reminder, here’s what the original
    file looks like:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们再看一下我们的 `cars_2.txt` 文件，并尝试删除所有与 Edsel 相关的内容。 （我们想忘记 Edsel 曾经被生产过，正如福特公司自
    1960 年以来一直试图做的那样。）首先，作为提醒，原始文件看起来是这样的：
- en: '[PRE41]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Well, it’s not exactly original, because I forgot that I had modified it to
    capitalize all of the *desoto*’s. But, that doesn’t matter. To delete all references
    to the Edsel, try this:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 好吧，这并不完全是原创的，因为我忘了之前修改它，使所有的 *desoto* 都大写了。不过，这不重要。要删除所有与 Edsel 相关的内容，请尝试这样做：
- en: '[PRE42]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'This command only deleted the lower-case *edsel*. But, I need a way to delete
    all references to Edsel. Fortunately, you can use a regular expression to specify
    multiple characters in the address, like this:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 这个命令只删除了小写的 *edsel*。但是，我需要一种方法来删除所有与 Edsel 相关的内容。幸运的是，你可以使用正则表达式在地址中指定多个字符，如下所示：
- en: '[PRE43]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: All you had to do was to put both *e* and *E* within brackets, and use that
    for the first character of the address.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 你只需将 *e* 和 *E* 放在括号中，并将其作为地址中的第一个字符。
- en: 'If you want to delete everything except for references to *Edsel*, use an `!`
    to invert the command. Now, you’d think that you’d want to put the inversion character
    in front of the address that you’re searching for, but that isn’t the case. Instead,
    place the inversion character in front of the command character itself. So, in
    this case, you would place the exclamation point in front of the `d`, like this:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想删除除了 *Edsel* 以外的所有内容，可以使用 `!` 来取反命令。现在，你可能认为应该把取反符号放在你正在查找的地址前面，但实际情况并非如此。相反，你需要将取反符号放在命令字符本身之前。所以，在这种情况下，你应该把感叹号放在
    `d` 前面，如下所示：
- en: '[PRE44]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: You’ve just seen an example of how things aren’t always implemented consistently
    across the various shell scripting tools. A while ago, you saw that the `^` is
    the inversion operator for Regular Expressions. Here, you see that the `!` is
    the inversion operator for `sed` commands. You’ve also seen that the `^` can also
    be used to indicate the beginning of a line. So yeah, things can get a bit confusing.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 你刚刚看到的示例展示了不同的 shell 脚本工具并非始终一致地实现功能。之前，你看到 `^` 是正则表达式的取反操作符。在这里，你看到 `!` 是 `sed`
    命令的取反操作符。你还看到 `^` 也可以用来表示行的开头。所以，是的，事情有时候确实会变得有些混乱。
- en: 'You can also choose a range of line numbers for the address. This time, let’s
    delete all references to Nash, which happen to be in lines eight through ten,
    like this:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以选择行号范围作为地址。这一次，我们删除所有与 Nash 相关的内容，它们正好出现在第八行到第十行之间，如下所示：
- en: '[PRE45]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Place an exclamation point in front of the `d` to delete everything except
    for lines eight through ten, like this:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `d` 前面加上感叹号，删除所有内容，除了第八行到第十行之间的内容，如下所示：
- en: '[PRE46]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: That does it for the classic cars. Next, I’ll show you what to do if your file
    has too many blank lines.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 到此为止，我们已经处理完经典车型。接下来，我将展示如果文件中有太多空行该怎么做。
- en: 'Example 2: Deleting Blank Lines'
  id: totrans-190
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 示例 2：删除空行
- en: 'For our last deletion trick, here’s how you can delete blank lines from a file.
    Just make an address with the start-of-line metacharacter (`^`) right next to
    the end-of-line metacharacter (`$`). Start by creating the `blank_lines.txt` file,
    like this:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们最后的删除技巧，下面是如何从文件中删除空行的。只需使用行首元字符（`^`）与行尾元字符（`$`）创建一个地址。首先创建`blank_lines.txt`文件，如下所示：
- en: '[PRE47]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Now, perform the deletion, with `^$` as the regular expression, like this:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，执行删除操作，使用`^$`作为正则表达式，如下所示：
- en: '[PRE48]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: Note the difference between this and the way we previously used the *end-of*
    metacharacter in the substitution script. Since we’re using two metacharacters
    together to form a regular expression, we have to place them between two forward
    slashes.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，这与我们之前在替换脚本中使用*行尾*元字符的方式不同。由于我们正在使用两个元字符组合形成正则表达式，因此必须将它们放在两个正斜杠之间。
- en: Now, for the next trick.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，进行下一个技巧。
- en: Appending and Inserting with sed
  id: totrans-197
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用sed进行追加和插入
- en: The `a` command for the Linux implementation of `sed` is used to append a line
    of text after another line of text. Let’s see how it works.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: '`a`命令在Linux实现的`sed`中用于在另一行文本后附加一行文本。让我们来看一下它是如何工作的。'
- en: 'Example 1: Appending Lines of Text'
  id: totrans-199
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 示例 1：追加文本行
- en: 'You can use that feature to add some model names to the cars list. Add the
    *Ambassador* model for the Nash line, like this:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用这个功能将一些模型名称添加到汽车列表中。像这样，为Nash车型添加*Ambassador*型号：
- en: '[PRE49]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'That’s good, but you can make it better. Start by indenting the model names.
    Do that by adding a preceding tab, like this:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 那很好，但你可以做得更好。首先通过缩进模型名称来改进。方法是添加一个制表符，如下所示：
- en: '[PRE50]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: Note that I can only show a partial output here, due to book formatting constraints.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，由于书籍排版的限制，我只能在这里显示部分输出。
- en: The control character for a tab is `\t`. Note though, that you had to add another
    backslash so that `sed` would properly recognize it.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 制表符的控制字符是`\t`。但请注意，你必须添加另一个反斜杠，这样`sed`才能正确识别它。
- en: 'You can do the same thing by using a line address. Let’s append a model name
    to line six, like so:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以通过使用行地址来做到这一点。让我们向第六行追加一个型号，如下所示：
- en: '[PRE51]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'But, that doesn’t cover all of the *Desoto*’s. Let’s append the model name
    to lines four through seven, like this:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，这还不能覆盖所有的*Desoto*车型。让我们向第四到第七行追加型号，如下所示：
- en: '[PRE52]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'Now, let’s combine some operations. Start by editing the `cars_2.txt` file
    so that it once again has some lower-case *desoto*’s. It should look like this:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们结合一些操作。首先编辑`cars_2.txt`文件，使其重新包含一些小写的*desoto*。它应该像这样：
- en: '[PRE53]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: But, you’re not limited to just performing one operation at a time. So, let’s
    see how we can combine operations.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，你不仅仅限于一次执行一个操作。那么，让我们看看如何将多个操作结合在一起。
- en: 'Example 2: Performing Multiple Operations at Once'
  id: totrans-213
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 示例 2：一次执行多个操作
- en: 'You’ll add a model to both the Edsel and Desoto lines, and delete every make
    that isn’t capitalized. Note that you can’t just place everything within one set
    of quotes, or use a semi-colon to separate the operations. For this, you have
    to give every operation its own set of quotes, and precede every operation with
    the `-e` switch. That’s because these operations are sequential, which means that
    the first operation must run to completion before the second one can begin. Here’s
    how it looks:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 你将为Edsel和Desoto车型添加一个新型号，并删除所有不是大写字母开头的车型。注意，你不能将所有内容放在一对引号中，或使用分号来分隔操作。为此，你必须为每个操作单独提供一组引号，并在每个操作前加上`-e`开关。因为这些操作是顺序执行的，这意味着第一个操作必须完成后，第二个操作才能开始。下面是它的样子：
- en: '[PRE54]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: Now that we’ve looked at appending text, let’s see how to insert text.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经看过了如何追加文本，让我们来看看如何插入文本。
- en: 'Example 3: Inserting Lines of Text'
  id: totrans-217
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 示例 3：插入文本行
- en: 'The `i` command works the same way, except that it will insert a line of text
    before another line of text, like this:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: '`i`命令与此相同，不同之处在于它会在另一行文本之前插入一行文本，如下所示：'
- en: '[PRE55]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: As a bonus, I’ve also shown you another way to get rid of all car names that
    begin with a lower-case letter.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 作为额外的奖励，我还展示了另一种去除所有以小写字母开头的车名的方法。
- en: That’s it for this trick. Let’s move on to the next one.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是这个技巧的全部内容。让我们继续下一个技巧。
- en: Changing with sed
  id: totrans-222
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用sed进行更改
- en: You would use the `c` command to change a string of text. (You can also change
    text with the `s` command, but this is a bit shorter to type.) Let’s see how it’s
    done.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用 `c` 命令来更改一串文本。（你也可以使用 `s` 命令来更改文本，但这个命令更简短。）让我们来看一下如何操作。
- en: 'Example 1: Changing Edsel to Studebaker'
  id: totrans-224
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 示例 1：将 Edsel 替换为 Studebaker
- en: 'As before, you’ll work with the `cars_2.txt` file. Begin by changing *Edsel*
    and *edsel* to *Studebaker*, like so:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 和之前一样，你将使用 `cars_2.txt` 文件。从将 *Edsel* 和 *edsel* 替换为 *Studebaker* 开始，像这样：
- en: '[PRE56]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'You can also specify the change to make by line numbers. Here’s what happens
    when you use the *edsel* and *Edsel* line numbers as the address:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以通过行号来指定要进行的更改。以下是使用 *edsel* 和 *Edsel* 行号作为地址时的效果：
- en: '[PRE57]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: You see that this worked a bit differently than before. Instead of making the
    change to each line separately, as happened with the other commands, here the
    command tells `sed` to replace the range of lines as a group.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 你会发现这次的操作与之前有所不同。与其他命令逐行修改不同，这里命令告诉 `sed` 将一组行整体替换。
- en: I know this looks amazing, but you haven’t seen anything yet. Check out this
    next amazing trick.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 我知道这看起来很惊艳，但你还没见识到真正的精彩。看看下一个令人惊叹的技巧吧。
- en: 'Example 2: Changing Entire Lines of Text'
  id: totrans-231
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 示例 2：更改整行文本
- en: 'For an even better example, create the `cars_4.txt` file, like this:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更好的示例，创建 `cars_4.txt` 文件，像这样：
- en: '[PRE58]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'Now, prepare to be amazed when you run this `sed` command:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，准备好惊叹吧，当你运行这个 `sed` 命令时：
- en: '[PRE59]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: So now, you see the biggest difference between the `s` and the `c` `sed` commands.
    Instead of just replacing the text string or pattern that you specify, the `c`
    command replaces the entire line in which the text string or pattern is found.
    In this case, every entire line that contains the text string *Edsel* was replaced
    with *1963 Studebaker Avanti*. Cool, right?
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 所以现在，你看到了 `s` 和 `c` 两个 `sed` 命令之间的最大区别。`c` 命令并不是仅仅替换你指定的文本字符串或模式，而是替换包含该文本字符串或模式的整个行。在这个例子中，所有包含文本字符串
    *Edsel* 的整行都被替换为 *1963 Studebaker Avanti*。很酷吧？
- en: Other Miscellaneous sed tricks
  id: totrans-237
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 其他杂项 `sed` 技巧
- en: We’re not done yet. Here are a few more cool tricks that you can do with `sed`.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还没结束。这里有几个你可以用 `sed` 做的很酷的技巧。
- en: 'Example 1: Using the q Command'
  id: totrans-239
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 示例 1：使用 q 命令
- en: 'The `q` command causes `sed` to behave just like the `head` utility. It tells
    `sed` to read in the designated number of lines, and then quit. If you want to
    show the first ten lines of our public domain e-book, enter this:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: '`q` 命令让 `sed` 像 `head` 工具一样工作。它告诉 `sed` 读取指定数量的行，然后退出。如果你想显示我们的公共领域电子书的前十行，可以输入以下命令：'
- en: '[PRE60]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'If you want to view selected lines from somewhere in the middle of a large
    file, you may find that `sed` is easier to use than the `head`/`tail` combination.
    Here’s how you can look at lines 1,005 through 1,010 of our e-book file:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想查看一个大文件中间的某些选定行，你会发现 `sed` 比 `head`/`tail` 组合更容易使用。以下是查看我们电子书文件中第 1,005
    行到第 1,010 行的方法：
- en: '[PRE61]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: Note that the `p` that I used here isn’t quite the same as the `p` option for
    the *substitute* command. This `print` command is a separate command unto itself.
    Still though, it has to be used together with the `-n` option for `sed` to get
    the results that you want.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我在这里使用的 `p` 与 *substitute* 命令中的 `p` 选项有所不同。这个 `print` 命令本身是一个独立的命令。不过，它必须与
    `sed` 的 `-n` 选项一起使用，才能获得你想要的结果。
- en: 'Example 2: Using the w Command'
  id: totrans-245
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 示例 2：使用 w 命令
- en: 'Use the `w` command to write selected lines of text to a new file. You can
    use a regular expression as an address, as you did above for the `p` command,
    or you can use line numbers, like this:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `w` 命令将选定的文本行写入新文件。你可以像上面对 `p` 命令那样使用正则表达式作为地址，或者也可以像这样使用行号：
- en: '[PRE62]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'If the preceding command looks a bit confusing, you can insert some spaces
    to make it more clear, like this:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 如果前面的命令看起来有点混乱，你可以插入一些空格，使其更清晰，像这样：
- en: '[PRE63]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'Although you see the the contents of the entire file on screen, only the selected
    content gets saved in your new file, as you see here:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管你看到的是整个文件的内容，但只有选中的内容会保存在你新建的文件中，如你所见：
- en: '[PRE64]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: The output will be the same as it was before. And, this demonstrates something
    that can be a bit confusing about `sed`. In some places of a `sed` script, blank
    spaces are optional. In other places, such as in a previous example when I showed
    you how to use the `-i` option with a filename suffix for the backup file, you
    can’t use a blank space. As I said before, there’s not always a lot of consistency
    with this stuff.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 输出将与之前一样。这展示了`sed`中可能让人困惑的一些地方。在`sed`脚本的某些位置，空格是可选的。而在其他地方，比如我之前展示如何使用`-i`选项和文件名后缀来备份文件时，就不能使用空格。正如我之前所说，关于这些规则，并不总是很一致。
- en: 'Example 3: Using the r Command'
  id: totrans-253
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 示例 3：使用`r`命令
- en: 'The `r` command will read a selected file and append it to the specified place
    in the file you’re working with. To see this, create the `cars_3.txt` file, like
    this:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: '`r`命令将读取一个选定的文件，并将其附加到你正在处理的文件中的指定位置。要查看这个效果，创建`cars_3.txt`文件，像这样：'
- en: '[PRE65]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'Now, insert the `cars_3.txt` file after the second line of the `cars_2.txt`
    file, like this:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，把`cars_3.txt`文件插入到`cars_2.txt`文件的第二行之后，像这样：
- en: '[PRE66]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'Again, if this is confusing to read, then use the optional spaces, like so:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，如果这让你读起来感到困惑，可以使用可选的空格，像这样：
- en: '[PRE67]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: Either way works equally well.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 无论哪种方式都能同样有效。
- en: Using sed program files
  id: totrans-261
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用`sed`程序文件
- en: If you have complex jobs that you perform on a regular basis, such as having
    to make multiple edits to either one or more documents at a time, you can create
    program files. Then, invoke `sed` with the `-f` switch to read the scripts from
    the file. Let’s look at a few examples
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你有需要定期执行的复杂任务，比如必须对一个或多个文档进行多次编辑，可以创建程序文件。然后，使用`-f`选项调用`sed`，从文件中读取脚本。让我们来看几个例子：
- en: 'Example 1: Appending Lines in a Text File'
  id: totrans-263
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 示例 1：在文本文件中追加行
- en: 'To see how this works, create the `myfile_3.txt` file, which will look like
    this:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 为了查看如何工作，创建`myfile_3.txt`文件，它看起来像这样：
- en: '[PRE68]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'Next, create the `demo_append.txt` file, which will serve as the `sed` program
    file. Make it look like this:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，创建`demo_append.txt`文件，它将作为`sed`程序文件。让它看起来像这样：
- en: '[PRE69]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'Invoke the program file, like this:'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 像这样调用程序文件：
- en: '[PRE70]'
  id: totrans-269
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: Note how I broke the single script in the program file into two lines. To make
    that work, I had to place a backslash at the end of the first line to let `sed`
    know that the script would continue on the next line. I’ll show you in a few moments
    why that is important.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 注意我如何将程序文件中的单个脚本拆分成两行。为了实现这一点，我必须在第一行末尾放一个反斜杠，告诉`sed`脚本将在下一行继续。稍后我会向你展示为什么这样做很重要。
- en: 'Now, let’s try a program file that will insert some lines. This time, I’ll
    use a text string for the address. Create the `demo_insert.txt` program file,
    like this:'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们尝试一个插入一些行的程序文件。这次，我将使用文本字符串作为地址。像这样创建`demo_insert.txt`程序文件：
- en: '[PRE71]'
  id: totrans-272
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'Invoke the program, and you’ll see this:'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 调用程序，你会看到如下结果：
- en: '[PRE72]'
  id: totrans-274
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 'Example 2: Changing Lines in a Text File'
  id: totrans-275
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 示例 2：更改文本文件中的行
- en: 'Now, let’s change lines four through six to something else. Create the `demo_change.txt`
    file, like so:'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们把第四到第六行改成其他内容。像这样创建`demo_change.txt`文件：
- en: '[PRE73]'
  id: totrans-277
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: 'Note that I again have to use backslashes to show that the script continues
    on the next line. Run the program, and you’ll see this:'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我再次必须使用反斜杠来表示脚本在下一行继续。运行程序，你会看到如下结果：
- en: '[PRE74]'
  id: totrans-279
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: 'Example 3: Substituting Text'
  id: totrans-280
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 示例 3：替换文本
- en: 'Next, let’s create the `demo_sub.txt` program file that will substitute *sentence*
    for *line*, and that will only send the modified lines to `stdout`. Make it look
    like this:'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，创建`demo_sub.txt`程序文件，它将*sentence*替换为*line*，并且只将修改过的行发送到`stdout`。让它看起来像这样：
- en: '[PRE75]'
  id: totrans-282
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: 'Invoke the program file, like this:'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 像这样调用程序文件：
- en: '[PRE76]'
  id: totrans-284
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: Note that I had to invoke the program with the `-n` option of `sed`, because
    I used the `p` option inside the program file.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我必须使用`-n`选项来调用`sed`程序，因为我在程序文件中使用了`p`选项。
- en: 'Try this again, except this time, use the write option to send the changed
    output to a new file. Create the `demo_write.txt` program file, like this:'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 再试一次，不过这次使用写入选项，将更改后的输出发送到新文件。像这样创建`demo_write.txt`程序文件：
- en: '[PRE77]'
  id: totrans-287
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: 'Invoke the program and view the new file, like this:'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 调用程序并查看新文件，像这样：
- en: '[PRE78]'
  id: totrans-289
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: 'Example 4: Copying Lines from One File to Another'
  id: totrans-290
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 示例 4：从一个文件复制行到另一个文件
- en: 'Finally, create the `demo_write_2.txt` program file, which will copy selected
    lines from one file to another file. Make it look like this:'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，创建`demo_write_2.txt`程序文件，它将把从一个文件中选定的行复制到另一个文件中。让它看起来像这样：
- en: '[PRE79]'
  id: totrans-292
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: 'Invoke it, and view the results, like this:'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 调用它，查看结果，像这样：
- en: '[PRE80]'
  id: totrans-294
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: That’s it for the simple program files. Let’s now compound things a bit.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是简单程序文件的内容。现在让我们稍微复杂一点。
- en: Compound Scripts in sed Program Files
  id: totrans-296
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '`sed` 程序文件中的复合脚本'
- en: 'So far, I’ve only shown you program files with one single `sed` script. You
    can also have program files with two or more scripts. Begin by creating the `demo_compound.txt`
    program file, which will look like this:'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我只向你展示了包含一个 `sed` 脚本的程序文件。你也可以拥有包含两个或更多脚本的程序文件。首先创建 `demo_compound.txt`
    程序文件，内容如下：
- en: '[PRE81]'
  id: totrans-298
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: 'Now, create the `riding.txt` file, which will look like this:'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，创建 `riding.txt` 文件，内容如下：
- en: '[PRE82]'
  id: totrans-300
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: 'Invoke the program file, like this:'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 按如下方式调用程序文件：
- en: '[PRE83]'
  id: totrans-302
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: 'Here’s the breakdown:'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 这是详细说明：
- en: This program first had `sed` replace *Edsel* with *Packard* in lines one through
    three.
  id: totrans-304
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这个程序首先让 `sed` 在第一到第三行中将 *Edsel* 替换为 *Packard*。
- en: In lines two through four, it had `sed` replace *Packard* with *Lasalle*.
  id: totrans-305
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在第二到第四行，它用 `sed` 将 *Packard* 替换为 *Lasalle*。
- en: Finally, the last script deleted line three. Note that you didn’t have to use
    backslashes here, since none of the scripts carried over on to the next line.
  id: totrans-306
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后，最后一个脚本删除了第三行。请注意，由于没有脚本延续到下一行，你不必在这里使用反斜杠。
- en: 'To see a second example, create the `demo_compound_2.txt` program file, like
    this:'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看第二个示例，请创建 `demo_compound_2.txt` 程序文件，如下所示：
- en: '[PRE84]'
  id: totrans-308
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: 'Invoke the program, like this:'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 按如下方式调用程序：
- en: '[PRE85]'
  id: totrans-310
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: This time, you have one script that appends two additional lines after line
    two, and a second script that causes line three to print a second time.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 这一次，你有一个脚本在第二行之后附加了两行新内容，另一个脚本使第三行重复打印一次。
- en: 'Just for fun, do the same thing again, except this time delete the second line.
    Create the `demo_compound_3.txt` program file, like this:'
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 只是为了好玩，再做一次相同的事情，不过这次删除第二行。创建 `demo_compound_3.txt` 程序文件，如下所示：
- en: '[PRE86]'
  id: totrans-313
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: 'Run the program, like this:'
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 按如下方式运行程序：
- en: '[PRE87]'
  id: totrans-315
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: Even though you deleted the second line, you were still able to append the new
    lines to it.
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 即使你删除了第二行，你仍然能够将新行附加到它之后。
- en: 'Let’s wrap up the `sed` discussion with something really fancy. Create the
    `tab.txt` program file, like this:'
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们用一些更复杂的内容来结束 `sed` 的讨论。创建 `tab.txt` 程序文件，如下所示：
- en: '[PRE88]'
  id: totrans-318
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: 'You’ll be amazed when you run this program. Here’s what you’ll see:'
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 当你运行这个程序时，你会感到非常惊讶。以下是你将看到的内容：
- en: '[PRE89]'
  id: totrans-320
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: The first script adds a tab to the beginning of every non-blank line. (The `^.`
    combination means to look for every line that begins with a non-blank character.
    The `&` after the tab character prevents `sed` from replacing the first character
    of each line with the tab. Instead, it just inserts the tab before the first character.)
    The second script changes the text in line eight. Finally, the third script deletes
    line one.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个脚本在每个非空行的开头添加一个制表符。（`^.` 组合意味着查找以非空字符开头的每一行。制表符后的 `&` 防止 `sed` 将每行的第一个字符替换为制表符。相反，它只是将制表符插入到第一个字符之前。）第二个脚本更改了第八行的文本。最后，第三个脚本删除了第一行。
- en: Using sed in Shell Scripts
  id: totrans-322
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在 Shell 脚本中使用 `sed`
- en: 'Using `sed` in shell scripts is easy, if you only intend to run your scripts
    on Linux systems. For example, you can do something like this `sed_test_0.sh`
    script:'
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你只打算在 Linux 系统上运行你的脚本，使用 `sed` 编写 Shell 脚本非常简单。例如，你可以像这样编写 `sed_test_0.sh`
    脚本：
- en: '[PRE90]'
  id: totrans-324
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: 'Here’s how it looks when I run it on my Fedora workstation:'
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我在我的 Fedora 工作站上运行它时的情况：
- en: '[PRE91]'
  id: totrans-326
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: 'But, this won’t work with the default implementation of `sed` that comes with
    FreeBSD, OpenIndiana, or macOS. In fact, here’s what the above script gives me
    on a FreeBSD machine:'
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，这在 FreeBSD、OpenIndiana 或 macOS 的默认 `sed` 实现中不起作用。事实上，以下是我在 FreeBSD 机器上运行上述脚本时得到的结果：
- en: '[PRE92]'
  id: totrans-328
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: According to the error message, I should be able to make this work by preceding
    *1958* with a backslash. But, I tried it, and it still doesn’t work.
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 根据错误信息，我应该能够通过在 *1958* 前加上反斜杠来使其生效。但我试过了，还是不行。
- en: 'As I mentioned in the *Understanding sed Portability Issues* section a few
    pages back, the implementation of `sed` that comes with most non-Linux systems
    lacks the capabilities of the Linux implementation. Specifically, the non-Linux
    implementation of `sed` lacks the ability to use the append (`a`), insert (`i`),
    and change (`c`) commands, as well as the ability to deal with regular expressions.
    So, you’ll need to install `gsed` on your non-Linux systems and create an alias
    in your shell configuration files if you want to experience the full power of
    `sed` on your non-Linux machines. The second problem is that your shell scripts
    won’t read the shell configuration files that are in your home directory. That
    in turn means that they won’t find the `sed` alias that you created in those configuration
    files. Here’s one solution for fixing that, in the `sed_test_1.sh` script:'
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我在前几页的*理解sed的可移植性问题*一节中提到的，大多数非Linux系统中自带的`sed`实现缺少Linux版本的一些功能。具体来说，非Linux版本的`sed`不支持使用追加（`a`）、插入（`i`）和更改（`c`）命令，也不能处理正则表达式。因此，如果你想在非Linux系统上体验`sed`的全部功能，你需要安装`gsed`，并在你的shell配置文件中创建一个别名。第二个问题是你的shell脚本无法读取你主目录中的shell配置文件，这意味着它们无法找到你在配置文件中创建的`sed`别名。这里有一个解决方案，可以在`sed_test_1.sh`脚本中修复这个问题：
- en: '[PRE93]'
  id: totrans-331
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: 'So, we want to invoke `sed` on our Linux machines, but we want to invoke `gsed`
    on everything else. To accomplish that, I’m using `$(uname)` to obtain the name
    of the operating system. In the first `if` statement, I’m using the `||` construct
    as an `or` operator. That way, I can test for Darwin, FreeBSD, or SunOS with just
    this one `if` statement. Then, I’m creating the `gsed` variable, and assigning
    either `gsed` or `sed`, as appropriate, as its value. Finally, in the `$gsed`
    line at the bottom, I’m calling back the value of the `gsed` variable to invoke
    either the `gsed` or the `sed` command. Does it work? Let’s see what it does on
    FreeBSD:'
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，我们想在Linux机器上调用`sed`，但希望在其他所有系统上调用`gsed`。为了实现这一点，我使用`$(uname)`获取操作系统的名称。在第一个`if`语句中，我使用`||`构造作为`or`运算符。这样，我就能用这一句`if`语句测试Darwin、FreeBSD或SunOS。然后，我创建了`gsed`变量，并根据需要将`gsed`或`sed`赋值给它。最后，在下面的`$gsed`行中，我调用`gsed`变量的值，以调用`gsed`或`sed`命令。它能工作吗？我们来看一下它在FreeBSD上的表现：
- en: '[PRE94]'
  id: totrans-333
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
- en: Oh, yeah. It works like a champ. I’ve also tested this on macOS, Linux, and
    OpenIndiana, and it works properly on all of them.
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 哦，没错。它工作得非常好。我也在macOS、Linux和OpenIndiana上测试过，它在这些系统上都能正常运行。
- en: I know, I’ve never before shown you that you can use a variable with a command
    as its assigned value. But, you see here that it’s a handy little trick that you
    might find very useful.
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 我知道，我以前从未向你展示过你可以用命令的变量赋值来调用它。不过，你可以看到，这个小技巧非常方便，你可能会发现它非常有用。
- en: And, this pretty much covers our discussion of `sed`. But, there’s still a lot
    to learn about `sed`. As I’ve said before, it’s another one of those topics about
    which whole books have been written. This will give you a good start, and will
    give you more than enough to pass the `sed` section of an introductory Linux certification
    exam.
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 这基本上涵盖了我们关于`sed`的讨论。不过，关于`sed`还有很多内容需要学习。正如我之前所说，它是一个可以写成整本书的主题。这个部分会为你提供一个很好的起点，足以让你通过入门级Linux认证考试中的`sed`部分。
- en: Next, let’s talk about `grep`.
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们来谈谈`grep`。
- en: Understanding grep
  id: totrans-338
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解grep
- en: I’ve already shown you some fancy ways to search for files on your system. But,
    what if you need to search for something that’s *in* a file? What if you don’t
    know exactly what you’re looking for? Worse yet, what if you don’t even know which
    file to look in? Not to worry, `grep` is here to help.
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 我已经向你展示了一些在系统上搜索文件的高级方法。那么，如果你需要在文件中搜索某些内容呢？如果你不知道自己到底在找什么呢？更糟糕的是，如果你甚至不知道该在哪个文件中查找呢？别担心，`grep`可以帮忙。
- en: '`grep`, short for *Global Regular Expression Print*, is a powerful command-line
    utility that comes packaged with just about every Unix or Unix-derived operating
    system. (This includes Linux and macOS.) There’s also an available version for
    Windows.'
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: '`grep`是*全球正则表达式打印*（Global Regular Expression Print）的缩写，它是一个强大的命令行工具，几乎在所有Unix或Unix衍生操作系统中都有提供。（包括Linux和macOS。）Windows也有可用版本。'
- en: You can direct `grep` to search through one file or many. You can also pipe
    in output from some other utility so that you’ll see only the information that
    you want to see. And, the fact that `grep` can use regular expressions allows
    you to perform searches even when you only have an approximate idea of what you’re
    searching for.
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以让`grep`搜索一个文件或多个文件。你还可以将其他工具的输出通过管道传输给`grep`，这样你只会看到你想看的信息。而且，`grep`支持正则表达式，这让你即使只有一个大概的搜索方向，也能进行搜索。
- en: '`grep` isn’t hard, but is does require a bit of practice. If you’re ready,
    let’s get started.'
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: '`grep`并不难，但确实需要一些练习。如果你准备好了，我们就开始吧。'
- en: Basic Searches with grep
  id: totrans-343
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用grep进行基本搜索
- en: I’ve already shown you some examples of using `grep` in *Chapter 7, Text Stream
    Filters Part 2* and *Chapter 8, Basic Shell Script Construction*, but that’s okay.
    I’d still like to start with the basics and provide an explanation of how to use
    it. I’ll begin the demos with some text files that you’ve already created.
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 我已经在*第7章，文本流过滤器 第二部分*和*第8章，基本Shell脚本构建*中给你展示了一些使用`grep`的例子，但没关系。我仍然想从基础开始，并提供如何使用它的解释。我将从你已经创建的文本文件开始演示。
- en: 'The most basic way to use grep is to search for a text string within a single
    file, like so:'
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`grep`最基本的方式是搜索一个文件中的文本字符串，如下所示：
- en: '[PRE95]'
  id: totrans-346
  prefs: []
  type: TYPE_PRE
  zh: '[PRE95]'
- en: Here, I listed the text string that I want to find, and then listed the name
    of the file that contains the text string. I surrounded the search term with a
    pair of single quotes, but I didn’t need to in this case. I only need the quotes
    if the search term contains characters that the shell will interpret incorrectly.
    (I most always use the single quotes, due to force-of-habit.)
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我列出了要查找的文本字符串，然后列出了包含该文本字符串的文件名。我用一对单引号将搜索词包围起来，但在这种情况下其实不需要这样做。只有当搜索词包含shell会错误解释的字符时，我才需要加引号。（我通常总是使用单引号，这也是一种习惯。）
- en: 'By default, `grep` is case-sensitive. Use the `-i` switch to make it case-insensitive,
    like this:'
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，`grep`是区分大小写的。使用`-i`开关可以使搜索不区分大小写，如下所示：
- en: '[PRE96]'
  id: totrans-349
  prefs: []
  type: TYPE_PRE
  zh: '[PRE96]'
- en: 'If you need to see which lines of the file contain the search term, use the
    `-n` switch, like this:'
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你需要查看文件中哪些行包含搜索词，可以使用`-n`开关，如下所示：
- en: '[PRE97]'
  id: totrans-351
  prefs: []
  type: TYPE_PRE
  zh: '[PRE97]'
- en: 'You can use a wild-card to search through multiple files at once, like this:'
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用通配符一次搜索多个文件，如下所示：
- en: '[PRE98]'
  id: totrans-353
  prefs: []
  type: TYPE_PRE
  zh: '[PRE98]'
- en: Note how the filenames are now included in the output.
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，现在文件名已经包含在输出中了。
- en: 'The `-v` switch means inverse. Use it to show all lines that *don’t* have the
    specified search term, like this:'
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: '`-v`开关表示反向。使用它可以显示所有*不*包含指定搜索词的行，如下所示：'
- en: '[PRE99]'
  id: totrans-356
  prefs: []
  type: TYPE_PRE
  zh: '[PRE99]'
- en: 'The `-c` switch shows a count of how many times a search pattern is in a file,
    but it doesn’t show the lines where the search pattern was found. It looks like
    this:'
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: '`-c`开关显示搜索模式在文件中出现的次数，但不会显示包含搜索模式的行。它看起来是这样的：'
- en: '[PRE100]'
  id: totrans-358
  prefs: []
  type: TYPE_PRE
  zh: '[PRE100]'
- en: In these examples, I’ve been showing you how to combine the `grep` option switches
    with just a single `-`. Of course, you can just use one option at a time, if that
    fits your needs.
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 在这些例子中，我展示了如何将`grep`选项开关与单个`-`结合使用。当然，如果你需要的话，你也可以一次只使用一个选项。
- en: Okay, so these were fairly simple examples, and you’re saying, “Hey, when do
    we get to the good stuff?” Well, hang on, it’s coming.
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，这些例子相对简单，你可能会说：“嘿，那什么时候才是重点？”别着急，重点快来了。
- en: More Advanced Searches with grep
  id: totrans-361
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 更高级的grep搜索
- en: Here are a few more cool grep optons.
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一些更酷的grep选项。
- en: 'Example 1: Searching for Whole Words'
  id: totrans-363
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 示例1：搜索完整单词
- en: 'By default, `grep` doesn’t search for whole words. So, if you search for the
    text string *and*, it will display lines that contain the words *land*, *hand*,
    *sand*, along with the word *and*. Let’s look at that by searching through our
    public-domain e-book for the text string *noun*. (It’s a very long output, so
    I’ll only show part of it.) I’ll make it a case-sensitive search, like this:'
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，`grep`不会搜索完整单词。因此，如果你搜索文本字符串*and*，它会显示包含*land*、*hand*、*sand*和*and*的行。我们通过在公共领域电子书中搜索文本字符串*noun*来看看这个效果。（输出很长，所以我只展示一部分。）我会让它变成区分大小写的搜索，如下所示：
- en: '[PRE101]'
  id: totrans-365
  prefs: []
  type: TYPE_PRE
  zh: '[PRE101]'
- en: 'This search returned not only lines that contain the word *noun*, but also
    lines that contain *nouns*, *pronouns*, *Pronouns*, and *Pronoun*. One line has
    the word *pronouncing*. If you want to search for the word *noun*, and only the
    word *noun*, then you’ll have to add the `-w` switch, like this:'
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: 这个搜索不仅返回了包含单词*noun*的行，还返回了包含*nouns*、*pronouns*、*Pronouns*和*Pronoun*的行。还有一行包含了*pronouncing*这个词。如果你只想搜索单词*noun*，且仅仅是*noun*，那么你需要添加`-w`开关，如下所示：
- en: '[PRE102]'
  id: totrans-367
  prefs: []
  type: TYPE_PRE
  zh: '[PRE102]'
- en: You’ve narrowed the search considerably. (You’ll still see some *Pronouns* in
    here, but only because they were on the same line as a *noun*.)
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: 你已经大大缩小了搜索范围。（你仍然会在其中看到一些*代词*，但只是因为它们和*名词*在同一行上。）
- en: 'Example 2: Making Searches Case-Insensitive'
  id: totrans-369
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例2：进行不区分大小写的搜索
- en: 'Now, add the `-i` switch to make the search case-insensitive, like so:'
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，添加`-i`选项来使搜索不区分大小写，像这样：
- en: '[PRE103]'
  id: totrans-371
  prefs: []
  type: TYPE_PRE
  zh: '[PRE103]'
- en: 'Add the `^` metacharacter to the left of the search pattern, and `grep` will
    only display the lines where the search pattern appears at the beginning, like
    this:'
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: 在搜索模式的左侧添加`^`元字符，`grep`将只显示那些模式出现在行首的行，像这样：
- en: '[PRE104]'
  id: totrans-373
  prefs: []
  type: TYPE_PRE
  zh: '[PRE104]'
- en: 'Just for curiosity, count how many times the whole word *noun* shows up in
    this document by using the `-c` switch, like so:'
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: 仅仅出于好奇，使用`-c`选项来计算一下整个单词*名词*在文档中出现了多少次，像这样：
- en: '[PRE105]'
  id: totrans-375
  prefs: []
  type: TYPE_PRE
  zh: '[PRE105]'
- en: 'Now, will it make a difference if I omit the -i switch to make this case-sensitive?
    Let’s see:'
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，如果我省略`-i`选项来使搜索区分大小写，会有什么不同吗？让我们看看：
- en: '[PRE106]'
  id: totrans-377
  prefs: []
  type: TYPE_PRE
  zh: '[PRE106]'
- en: So, we have a total of 33 case-insensitive *noun* strings, and 29 that are case-sensitive.
    This tells me that there are four *noun* strings with at least one upper-case
    letter.
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，我们总共有33个不区分大小写的*名词*字符串，以及29个区分大小写的。这告诉我，至少有四个*名词*字符串包含至少一个大写字母。
- en: 'Example 3: Dealing with Carriage Returns'
  id: totrans-379
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例3：处理回车符
- en: Here’s a realistic scenario that you just might encounter at some point in your
    Linux career. It’s one that could cause you a good bit of consternation until
    you finally figure it out.
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个你可能在Linux工作中遇到的实际场景。直到你最终弄明白它，这个问题可能会让你有点烦恼。
- en: 'You’ve just seen how to perform a case-insensitive search for every occurrence
    of the word *noun* at the start of a line. You found one *NOUN* on a line by itself.
    It would make sense then that you would also find that line by performing a case-insensitive
    search for *noun* at the end of lines. So now, give it a try:'
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: 你刚刚学会了如何执行不区分大小写的搜索，以查找每一行开头的*名词*。你发现了一个单独的*NOUN*。那么，按照这个逻辑，你也应该能够通过执行不区分大小写的搜索，查找到行尾的*名词*。所以，现在，试试看：
- en: '[PRE107]'
  id: totrans-382
  prefs: []
  type: TYPE_PRE
  zh: '[PRE107]'
- en: Wait a minute. Why didn’t it find anything? We know that there’s one to be found.
    Well, here’s a clue.
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: 等一下，为什么没有找到任何结果呢？我们知道应该能找到一个。这里有个线索。
- en: A few chapters back, I told you that I downloaded this file from the Project
    Gutenberg web site. So, there’s a good possibility that the file was created with
    either a DOS or Windows text editor.
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: 几章前，我告诉过你我从Project Gutenberg网站下载了这个文件。所以，文件很可能是用DOS或Windows文本编辑器创建的。
- en: That’s significant because DOS and Windows text editors place a carriage return
    character at the end of each line in text files, where Unix and Linux text editors
    just use newline characters. If `grep` sees a newline character during a search,
    it will just ignore it. However, it won’t ignore a carriage return. Now, let’s
    test our theory. I’ll start by showing you how to use another Regular Expressions
    metacharacter.
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: 这很重要，因为DOS和Windows文本编辑器会在文本文件的每一行末尾插入回车符，而Unix和Linux文本编辑器则只使用换行符。如果`grep`在搜索过程中遇到换行符，它会忽略它。然而，它不会忽略回车符。现在，让我们来验证一下我们的理论。我将从向你展示如何使用另一个正则表达式元字符开始。
- en: 'If you place a dot in a search pattern, it means that you’ll accept the presence
    of any single character in that position, as long as the rest of the pattern can
    make a proper match. So, place a dot at the end of your search pattern. Then,
    pipe the output into the `od -c` command, like this:'
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在搜索模式中放置一个点号，这意味着你会接受该位置存在任何单个字符，只要其余模式能够匹配正确。所以，将一个点号放在你的搜索模式的末尾。然后，将输出通过`od
    -c`命令传递，像这样：
- en: '[PRE108]'
  id: totrans-387
  prefs: []
  type: TYPE_PRE
  zh: '[PRE108]'
- en: 'Yeah, there’s the problem. The `\r` is the carriage return control character.
    Not to worry, though. Just use `tr` with the `-d` option to get rid of those pesky
    rascals. Save the converted output to a new file, like this:'
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: 是的，问题来了。`\r`是回车控制字符。不过不用担心，只需使用`tr`命令加上`-d`选项来去掉那些讨厌的家伙。然后将转换后的输出保存到一个新文件中，像这样：
- en: '[PRE109]'
  id: totrans-389
  prefs: []
  type: TYPE_PRE
  zh: '[PRE109]'
- en: 'Verify that the carriage returns are gone and that the `grep` search now works
    correctly, by performing the searches without the dot in the pattern. It should
    look like this:'
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: 验证回车符已经消失，并且`grep`搜索现在可以正确工作，方法是进行不带点号的模式搜索。它应该像这样：
- en: '[PRE110]'
  id: totrans-391
  prefs: []
  type: TYPE_PRE
  zh: '[PRE110]'
- en: Now when you feed the search output through `od`, you’ll see that the carriage
    return character is gone. Then, when you try the original search, you get just
    what you’re supposed to get.
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，当你将搜索输出通过`od`命令处理时，你会发现回车符已经消失了。然后，当你尝试原始搜索时，你会得到你应该得到的结果。
- en: 'But, you’re not done yet. What if there’s a *noun* at the end of a line that’s
    also the end of a sentence? Then, the *noun* would be followed by a period, and
    the search as you’ve just performed it wouldn’t pick it up. Let’s go back a few
    steps, and perform the search with our dot metacharacter again, like so:'
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: 不过，你还没完成。如果行尾的 *noun* 恰好是一个句子的结尾呢？那么，*noun* 后面会跟着一个句号，而你刚才执行的搜索是无法捕捉到这一点的。让我们回到前面几步，再次使用点号元字符进行搜索，像这样：
- en: '[PRE111]'
  id: totrans-394
  prefs: []
  type: TYPE_PRE
  zh: '[PRE111]'
- en: 'Now that the carriage return character is gone, this search now finds *noun.*
    and *nouns.* But, you don’t want to find *nouns*. You only want to find the singular
    *noun*. I’ll show you how by introducing another metacharacter, like this:'
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: 现在换行符已经去掉，这个搜索现在能找到 *noun.* 和 *nouns.*，但是，你不想找到 *nouns*。你只想找到单数形式的 *noun*。我会通过引入另一个元字符来告诉你怎么做，像这样：
- en: '[PRE112]'
  id: totrans-396
  prefs: []
  type: TYPE_PRE
  zh: '[PRE112]'
- en: By placing a backslash in front of the dot, you’ve turned the dot metacharacter
    into a common period. The `\?` tells `grep` to try to find a match for the character
    that precedes it, but that it’s okay if it doesn’t find a match. So here, you’re
    telling `grep` to perform a case-insensitive search for the whole word *noun*
    at the ends of lines, with or without the period. (Are you beginning to see how
    much fun that Regular Expressions can be?)
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
  zh: 通过在点号前放置反斜杠，你将点号元字符变成了一个普通的句点。` \? ` 告诉 `grep` 尝试找到前面字符的匹配，但如果找不到也没关系。所以，在这里，你告诉
    `grep` 执行一个不区分大小写的搜索，查找行尾的整个单词 *noun*，无论是否有句号。（你开始明白正则表达式有多有趣了吗？）
- en: Okay, you’ve seen some cool stuff, but you’re still not done. So, let’s move
    on.
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
  zh: 好了，你已经看过一些酷东西了，但还没完成。接下来，让我们继续。
- en: Even More Advanced Searches with grep
  id: totrans-399
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 grep 进行更高级的搜索
- en: You can combine `grep` with other utilities for even more advanced searches.
    Here’s how.
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以将 `grep` 与其他工具结合，进行更高级的搜索。下面是如何操作的。
- en: 'Example 1: Auditing Source Code Files'
  id: totrans-401
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 示例 1：审计源代码文件
- en: 'To demo this, use either your Fedora Server or your Debian virtual machine,
    so that you can install a package that you might not want to install on your Linux
    workstation, if that’s what you’re using. On Fedora Server, install the `cairo-devel`
    package, like this:'
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
  zh: 要演示这个，使用你的 Fedora 服务器或 Debian 虚拟机，这样你就可以安装一个你可能不想在 Linux 工作站上安装的包，如果你正在使用的是工作站的话。在
    Fedora 服务器上，安装 `cairo-devel` 包，像这样：
- en: '[PRE113]'
  id: totrans-403
  prefs: []
  type: TYPE_PRE
  zh: '[PRE113]'
- en: 'If you’d rather use the Debian virtual machine, install the `libghc-cairo-dev`
    package, like this:'
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你更倾向于使用 Debian 虚拟机，请安装 `libghc-cairo-dev` 包，像这样：
- en: '[PRE114]'
  id: totrans-405
  prefs: []
  type: TYPE_PRE
  zh: '[PRE114]'
- en: 'Next, look through the source code files in the `/usr/include/cairo/` directory,
    looking for lines that have the string `#include`, like this:'
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，查看 `/usr/include/cairo/` 目录中的源代码文件，查找包含字符串 `#include` 的行，像这样：
- en: '[PRE115]'
  id: totrans-407
  prefs: []
  type: TYPE_PRE
  zh: '[PRE115]'
- en: If you don’t want to show the filenames where the text strings are found, use
    the `-h` switch. Then feed the lines through `sort`, which in turn will feed the
    lines through `uniq`. That way, you’ll end up with sorted output, and all duplicate
    lines will be eliminated.
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你不想显示文本字符串所在的文件名，可以使用 `-h` 开关。然后将这些行通过 `sort` 排序，再通过 `uniq` 进行去重。这样，你就会得到排序后的输出，并且所有重复的行都会被删除。
- en: Also, by using the `-c` switch with `uniq`, we’ll find out how many times each
    particular line was duplicated.
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
  zh: 同时，通过在 `uniq` 命令中使用 `-c` 开关，我们将得知每一行被重复了多少次。
- en: 'Example 2: Searching for Social Security Numbers'
  id: totrans-410
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 示例 2：搜索社会保障号码
- en: 'Here’s a more complex example of how to use a regular expression for your search.
    First, create the `ssn.txt` file with a list of names, birth dates, and US Social
    Security numbers, like this:'
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个使用正则表达式进行搜索的更复杂示例。首先，创建一个 `ssn.txt` 文件，列出姓名、出生日期和美国社会保障号码，像这样：
- en: '[PRE116]'
  id: totrans-412
  prefs: []
  type: TYPE_PRE
  zh: '[PRE116]'
- en: Note that these are all fictitious, so we’re not violating anyone’s privacy
    here. Also, I have no idea why I chose German foods for the surnames. Perhaps
    I was hungry?
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，这些都是虚构的，因此我们没有侵犯任何人的隐私。此外，我也不知道为什么我选择了德国食物作为姓氏，也许是因为我饿了？
- en: 'Then, construct a `grep` command that will only show lines that contain Social
    Security numbers, like this:'
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，构建一个 `grep` 命令，只显示包含社会保障号码的行，像这样：
- en: '[PRE117]'
  id: totrans-415
  prefs: []
  type: TYPE_PRE
  zh: '[PRE117]'
- en: Here, each instance of `[0-9]` means that you’re searching for any digit. The
    numbers that are surrounded by the backslashes and curly braces mean that you
    want to find a certain number of consecutive digits. So, the `[0-9]\{3\}` construct
    means that you’re hunting for three consecutive digits. There are three of those
    groupings in this regular expression, all separated by a hyphen.
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，每个`[0-9]`表示你正在搜索任何数字。被反斜杠和大括号包围的数字表示你要找到特定数量的连续数字。所以，`[0-9]\{3\}`结构表示你要寻找三个连续的数字。在这个正则表达式中，包含了三个这样的分组，每个分组之间用连字符分隔。
- en: 'Example 3: Using the ^ Metacharacter'
  id: totrans-417
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 示例 3：使用 ^ 元字符
- en: 'Here’s one more example before we move on to the next topic. This is an example
    of how the `^` metacharacter can have two different meanings, depending on its
    placement in the regular expression. See how that works in the following `grep`
    command:'
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们继续讨论下一个话题之前，再来看一个例子。这是一个关于`^`元字符的例子，取决于它在正则表达式中的位置，它可以有两种不同的含义。请看下面的`grep`命令，了解它是如何工作的：
- en: '[PRE118]'
  id: totrans-419
  prefs: []
  type: TYPE_PRE
  zh: '[PRE118]'
- en: In this command, the `'^[^a-zA-Z]'` regular expression means to look for all
    lines that do *not* begin with a letter. That’s because outside of the square
    bracket, the `^` means to only look for a match at the beginning of a line. Inside
    the square brackets, in front of the designated search term, it means to display
    everything that *doesn’t* match that term.
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个命令中，`'^[^a-zA-Z]'`正则表达式表示查找所有**不**以字母开头的行。这是因为在方括号外，`^`表示只在行首查找匹配。在方括号内，它则表示显示所有**不**匹配该词项的内容。
- en: 'Of course, you’ll also see a lot of consecutive blank lines, since blank lines
    don’t start with a letter. If you don’t need to see all of those blank lines,
    just feed the grep output into `uniq`, like this:'
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，你还会看到很多连续的空行，因为空行不以字母开头。如果你不想看到这些空行，可以将`grep`的输出传递给`uniq`，像这样：
- en: '[PRE119]'
  id: totrans-422
  prefs: []
  type: TYPE_PRE
  zh: '[PRE119]'
- en: Be sure to scroll through the output of both of these two commands, and note
    the difference.
  id: totrans-423
  prefs: []
  type: TYPE_NORMAL
  zh: 一定要滚动查看这两个命令的输出，并注意它们之间的差异。
- en: All right, let’s move on to see if we can extend things a bit.
  id: totrans-424
  prefs: []
  type: TYPE_NORMAL
  zh: 好了，我们继续看接下来能否进一步扩展。
- en: Using Extended Regular Expressions with grep
  id: totrans-425
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在`grep`中使用扩展正则表达式
- en: 'As you saw on the regular expressions metacharacter charts a few pages back
    in the *Understanding Regular Expressions* section, there are two forms of command
    syntax for `grep`. What I’ve shown you so far is the *basic* syntax. The other
    form is the *extended* syntax. Here are two differences between the two:'
  id: totrans-426
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你在几页前的*理解正则表达式*部分中看到的正则表达式元字符图表，`grep`有两种命令语法。我到目前为止展示的就是*基本*语法。另一种是*扩展*语法。以下是它们之间的两个区别：
- en: Basic syntax requires the use of a backslash in front of certain metacharacters,
    but extended syntax doesn’t.
  id: totrans-427
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基本语法要求在某些元字符前使用反斜杠，而扩展语法则不需要。
- en: Extended syntax requires that you either use `egrep` instead of `grep`, or `grep`
    with the `-E` option switch. (Be aware that although `egrep` still works for now,
    it’s considered as obsolete and might cease to work in the future. So, you should
    always use `grep -E`, instead.)
  id: totrans-428
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 扩展语法要求你使用`egrep`代替`grep`，或者使用带有`-E`选项开关的`grep`。（需要注意的是，虽然`egrep`目前仍然有效，但它已被视为过时，并可能在未来停止工作。所以，你应该始终使用`grep
    -E`。）
- en: Okay, here are some examples.
  id: totrans-429
  prefs: []
  type: TYPE_NORMAL
  zh: 好了，这里有一些例子。
- en: 'Example 1: Basic Search with Extended Syntax'
  id: totrans-430
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 示例 1：使用扩展语法进行基本搜索
- en: 'Let’s take another look at a previous example. Here’s the command with normal,
    basic syntax:'
  id: totrans-431
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们再看一个之前的例子。这里是使用普通基本语法的命令：
- en: '[PRE120]'
  id: totrans-432
  prefs: []
  type: TYPE_PRE
  zh: '[PRE120]'
- en: 'Here’s the exact same command with extended syntax:'
  id: totrans-433
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是使用扩展语法的完全相同命令：
- en: '[PRE121]'
  id: totrans-434
  prefs: []
  type: TYPE_PRE
  zh: '[PRE121]'
- en: Okay, it’s not a big deal here, because using the extended syntax only eliminated
    one backslash that I had to type. But, if you have a `grep` command that requires
    you to escape lots of characters with basic syntax, the extended syntax could
    considerably cut down on the typing.
  id: totrans-435
  prefs: []
  type: TYPE_NORMAL
  zh: 好吧，这里没什么大问题，因为使用扩展语法只消除了一个需要输入的反斜杠。但是，如果你的`grep`命令需要使用基本语法来转义很多字符，那么扩展语法可以大大减少输入量。
- en: 'Example 2: Searching for Consecutive Duplicate Words'
  id: totrans-436
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 示例 2：搜索连续的重复单词
- en: 'The next example is just a bit more complex. You’re looking through the `/etc/services`
    file for all lines that contain consecutive duplicate words, like so:'
  id: totrans-437
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个例子稍微复杂一些。你正在查看`/etc/services`文件，寻找所有包含连续重复单词的行，像这样：
- en: '[PRE122]'
  id: totrans-438
  prefs: []
  type: TYPE_PRE
  zh: '[PRE122]'
- en: 'Here’s the breakdown:'
  id: totrans-439
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是具体的解析：
- en: The `\<. . .\>` construct represents a word boundary. The pattern that’s inside
    this construct will match a single word, and only a single word.
  id: totrans-440
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`\<. . .\>`构造表示一个单词边界。这个构造内的模式将仅匹配一个单一的单词。'
- en: The `[a-z]` means that we’re looking for a single alphabetic character. Of course,
    you see nothing but lower-case letters here, which would normally mean that this
    would only match lower-case letters. But, the `i` in the `grep -Ei` command makes
    this case-insensitive.
  id: totrans-441
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`[a-z]`表示我们在寻找一个单一的字母字符。当然，你看到的全是小写字母，这通常意味着它只会匹配小写字母。但是，`grep -Ei`命令中的`i`使得这次搜索不区分大小写。'
- en: The `+` at the end of `[a-z]` is called a **repeat character**. This means that
    we want to match one or more of whatever character or set of characters precedes
    it. In this case, we want to match a pattern that contains only the set of characters
    that’s between the two square brackets.
  id: totrans-442
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`[a-z]`末尾的`+`称为**重复字符**。这意味着我们希望匹配一个或多个在它前面出现的字符或字符集。在这个例子中，我们希望匹配只包含两个方括号之间字符集的模式。'
- en: Placing the `[a-z]+` within a pair of parentheses indicates that we want to
    evaluate this part of the regular expression before we evaluate the second part.
  id: totrans-443
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将`[a-z]+`放在一对括号中表示我们希望在评估第二部分之前先评估这一部分的正则表达式。
- en: Finally, the `+\1` in the second part of the regular expression means that we
    want to find an additional second match to the pattern that’s described in the
    first part. In other words, we want to find all lines in the `/etc/services` file
    that contain two consecutive identical words.
  id: totrans-444
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后，正则表达式第二部分中的`+\1`表示我们希望找到与第一部分描述的模式的第二次匹配。换句话说，我们要查找`/etc/services`文件中包含两个连续相同单词的所有行。
- en: 'Now, make the search case-sensitive by leaving out the `-i` option, like so:'
  id: totrans-445
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，通过省略`-i`选项，使搜索区分大小写，像这样：
- en: '[PRE123]'
  id: totrans-446
  prefs: []
  type: TYPE_PRE
  zh: '[PRE123]'
- en: 'Example 3: Searching for Words that Begin with a Certain Letter'
  id: totrans-447
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 示例 3：搜索以特定字母开头的单词
- en: 'Next, look through the `/etc/` directory for all files and directories with
    names that begin with either a *p* or a *q*, like this:'
  id: totrans-448
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，浏览`/etc/`目录，查找所有名称以* p *或* q *开头的文件和目录，像这样：
- en: '[PRE124]'
  id: totrans-449
  prefs: []
  type: TYPE_PRE
  zh: '[PRE124]'
- en: 'Try that again, except this time look for files and directories that have *p*
    or *q* as the first letter, and that also have *p* as the second letter, like
    so:'
  id: totrans-450
  prefs: []
  type: TYPE_NORMAL
  zh: 再试一次，不过这次查找文件和目录，要求它们的第一个字母是*p*或*q*，而且第二个字母也是*p*，像这样：
- en: '[PRE125]'
  id: totrans-451
  prefs: []
  type: TYPE_PRE
  zh: '[PRE125]'
- en: 'Now, list all files and directories in the `/etc/` directory with names that
    begin with *se* and have the optional third letter of *r*, like this:'
  id: totrans-452
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，列出`/etc/`目录中所有名称以*se*开头并且可选的第三个字母为*r*的文件和目录，像这样：
- en: '[PRE126]'
  id: totrans-453
  prefs: []
  type: TYPE_PRE
  zh: '[PRE126]'
- en: Try this again, but this time *require* that the file and directory names have
    *r* as the third letter. (I’m not going to show you how this time, but I will
    give you a hint. Just look at the previous example.)
  id: totrans-454
  prefs: []
  type: TYPE_NORMAL
  zh: 再试一次，但这次*要求*文件和目录名称的第三个字母是*r*。（我这次不会告诉你如何做，但我会给你个提示。只需要看看之前的例子。）
- en: 'In this next example, I’m going to show you a bit of shorthand. List all files
    and directories in the `/etc/` directory that use non-alphanumeric characters
    in their names, like this:'
  id: totrans-455
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一个示例中，我将向你展示一些简写。列出`/etc/`目录中所有名称中包含非字母数字字符的文件和目录，像这样：
- en: '[PRE127]'
  id: totrans-456
  prefs: []
  type: TYPE_PRE
  zh: '[PRE127]'
- en: You see the file and directory names that contain characters such as dots, underscores,
    and hyphens. Any file or directory name that doesn’t have any of these non-alphanumeric
    characters won’t show up. The `\W` in this example is just shorthand for `[^_[:alnum:]]`.
    The `^` indicates an inversion, which causes `grep` to search for the non-alphanumeric
    characters.
  id: totrans-457
  prefs: []
  type: TYPE_NORMAL
  zh: 你会看到包含点、下划线和连字符等字符的文件和目录名称。任何没有这些非字母数字字符的文件或目录名称将不会显示。这个示例中的`\W`只是`[^_[:alnum:]]`的简写。`^`表示取反，这会导致`grep`搜索非字母数字字符。
- en: Using a lower-case *w* (`\w`) would replace `[_[:alnum:]]`, which would cause
    `grep` to search for all alpha-numeric characters.
  id: totrans-458
  prefs: []
  type: TYPE_NORMAL
  zh: 使用小写的*w*（`\w`）将替代`[_[:alnum:]]`，这会导致`grep`搜索所有字母数字字符。
- en: 'Example 4: Searching for Words with Digits'
  id: totrans-459
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 示例 4：搜索包含数字的单词
- en: 'Next, search through `/etc/` for all files and directories with a numeric digit
    in their names, like this:'
  id: totrans-460
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，搜索`/etc/`中的所有文件和目录，查找名称中包含数字的文件，像这样：
- en: '[PRE128]'
  id: totrans-461
  prefs: []
  type: TYPE_PRE
  zh: '[PRE128]'
- en: 'For the final example, use the alternator operator to create an either/or type
    of regular expression, like so:'
  id: totrans-462
  prefs: []
  type: TYPE_NORMAL
  zh: 在最后一个示例中，使用替代符号运算符来创建一种“或者/或”的正则表达式，像这样：
- en: '[PRE129]'
  id: totrans-463
  prefs: []
  type: TYPE_PRE
  zh: '[PRE129]'
- en: The `|` in the `(cron|yum)` construct acts as an `or` operator, which allows
    `grep` to search for directories and filenames that contain either *cron* or *yum*.
    (By the way, if you’re doing this on a Debian machine instead of a Fedora machine,
    just replace *yum* with *apt*.)
  id: totrans-464
  prefs: []
  type: TYPE_NORMAL
  zh: 在`(cron|yum)`结构中的`|`符号充当了`或`运算符，这使得`grep`可以搜索包含*cron*或*yum*的目录和文件名。（顺便说一下，如果你在Debian机器上而不是Fedora机器上进行此操作，只需将*yum*替换为*apt*。）
- en: That’s it for extended `grep`. Let’s turn our attention to fixed-strings.
  id: totrans-465
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是扩展`grep`的全部内容。让我们将注意力转向固定字符串。
- en: Using Fixed-strings Regular Expressions with grep
  id: totrans-466
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用固定字符串正则表达式与grep
- en: 'Either `fgrep` or `grep -F` will interpret any patterns you feed it as literal
    expressions. So, if you follow either `grep -F` or `fgrep` with a regular expression,
    you’ll actually be searching for that regular expression, instead of the parsed
    pattern. For example, let’s copy the `ssn.txt` file that we used earlier to `ssn_2.txt`,
    and add a line. The new file will look like this:'
  id: totrans-467
  prefs: []
  type: TYPE_NORMAL
  zh: 无论是`fgrep`还是`grep -F`，它们都会将你输入的任何模式解释为字面量表达式。因此，如果你在`grep -F`或`fgrep`后面跟上正则表达式，你实际上是在搜索该正则表达式，而不是解析后的模式。例如，让我们将之前使用的`ssn.txt`文件复制到`ssn_2.txt`，并添加一行。新文件将如下所示：
- en: '[PRE130]'
  id: totrans-468
  prefs: []
  type: TYPE_PRE
  zh: '[PRE130]'
- en: 'This new last line is the regular expression that you’ll use to search through
    the file. Using `grep` with no options, as you saw before, will yield a list of
    lines that contain Social Security numbers, as you see here:'
  id: totrans-469
  prefs: []
  type: TYPE_NORMAL
  zh: 这新增加的最后一行是你用来搜索文件的正则表达式。使用不带选项的`grep`，正如你之前看到的，将返回包含社会保障号的行列表，如下所示：
- en: '[PRE131]'
  id: totrans-470
  prefs: []
  type: TYPE_PRE
  zh: '[PRE131]'
- en: 'But, look what happens if you use either `fgrep` or `grep` `-F`:'
  id: totrans-471
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，看看如果你使用`fgrep`或`grep -F`会发生什么：
- en: '[PRE132]'
  id: totrans-472
  prefs: []
  type: TYPE_PRE
  zh: '[PRE132]'
- en: With either `fgrep` or `grep -F`, the regular expression is interpreted as just
    another text string.
  id: totrans-473
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`fgrep`或`grep -F`时，正则表达式被解释为仅仅是另一个文本字符串。
- en: As is the case with `egrep`, `fgrep` is considered as obsolete and might cease
    to work in the somewhat near future. So, your best bet is to get used to using
    `grep -E` and `grep -F`, instead of `egrep` and `fgrep`. (The main reason I mention
    them at all is because you might find other tutorials that mention them.)
  id: totrans-474
  prefs: []
  type: TYPE_NORMAL
  zh: 和`egrep`一样，`fgrep`被认为是过时的，并且可能会在不久的将来停止工作。因此，你最好的选择是开始习惯使用`grep -E`和`grep -F`，而不是`egrep`和`fgrep`。（我提到它们的主要原因是，你可能会在其他教程中看到它们。）
- en: Now that you’ve seen some regular expressions in use, let’s look at how to simplify
    the process of creating them.
  id: totrans-475
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经看过一些正则表达式的使用，接下来让我们看看如何简化创建它们的过程。
- en: Using RegEx Helper Programs
  id: totrans-476
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用正则表达式助手程序
- en: Okay, now that you’ve seen so many examples, you can now create regular expressions
    to do whatever you need to be done.
  id: totrans-477
  prefs: []
  type: TYPE_NORMAL
  zh: 好了，现在你已经看到了这么多示例，你现在可以创建正则表达式来完成任何你需要做的事情。
- en: What?! *No*, you say?
  id: totrans-478
  prefs: []
  type: TYPE_NORMAL
  zh: 什么？！*不行*，你说？
- en: Don’t feel bad. I’ve told you already that Regular Expressions is quite complex,
    and is something about which entire books have been written. That’s where a helper
    program can come in handy. Let’s look at some examples.
  id: totrans-479
  prefs: []
  type: TYPE_NORMAL
  zh: 别难过。我已经告诉过你，正则表达式是相当复杂的，并且它是许多书籍的主题。正是在这种情况下，助手程序就派上了用场。让我们看看一些示例。
- en: RegexBuddy and RegexMagic
  id: totrans-480
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: RegexBuddy 和 RegexMagic
- en: RegexBuddy and RegexMagic are a pair of helper programs that are published by
    the *Just Great Software* company. The difference between them is that RegexBuddy
    is mainly a point-and-click interface for building your own regular expressions.
    There is a library of pre-built regular expressions that you can use, but to build
    anything else you’ll still need to know something about the Regular Expressions
    language.
  id: totrans-481
  prefs: []
  type: TYPE_NORMAL
  zh: RegexBuddy 和 RegexMagic 是由*Just Great Software*公司发布的一对助手程序。它们之间的区别在于，RegexBuddy主要是一个用于构建正则表达式的点击式界面。它有一个预构建的正则表达式库，你可以使用它，但要构建其他任何东西，你仍然需要了解一些正则表达式语言。
- en: RegexMagic is great for Regular Expressions beginners, because all you need
    to do is to enter some sample text and mark the areas that you want to convert
    to a regular expression. RegexMagic then generates the regular expression for
    you.
  id: totrans-482
  prefs: []
  type: TYPE_NORMAL
  zh: RegexMagic 对于正则表达式初学者来说非常棒，因为你只需输入一些示例文本并标记出你想要转换为正则表达式的区域。然后，RegexMagic 会为你生成正则表达式。
- en: There are really only two slight drawbacks to RegexBuddy and RegexMagic. First,
    they’re both closed-source, commercial programs, so you’ll need to pay for them.
    But, the price is quite reasonable, at only US $39.95 each. (You can get a discount
    if you buy them both in a bundle.)
  id: totrans-483
  prefs: []
  type: TYPE_NORMAL
  zh: RegexBuddy 和 RegexMagic 真的只有两个小缺点。首先，它们都是闭源的商业程序，所以你需要为它们付费。但是，价格相当合理，每个仅需 39.95
    美元。（如果你将它们一起购买，还可以享受折扣。）
- en: The second slight drawback is that they’re only written for the Windows operating
    system. However, you’ll be glad to know that they both run fine under WINE on
    Linux machines. (In fact, I have them both installed here on this Fedora workstation.)
    The RegexBuddy and RegexMagic websites even give you directions on how to install
    these programs under WINE.
  id: totrans-484
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个小缺点是它们仅为 Windows 操作系统编写。然而，你会很高兴地知道，它们都能在 Linux 机器上通过 WINE 良好运行。（事实上，我已经在这台
    Fedora 工作站上安装了这两个工具。）RegexBuddy 和 RegexMagic 的网站甚至提供了如何在 WINE 下安装这些程序的指南。
- en: WINE is a recursive acronym that stands for *WINE is Not an Emulator*. It’s
    a translation layer that converts Windows executable code to Linux executable
    code, and is included in the repositories for pretty much every Linux distro.
  id: totrans-485
  prefs: []
  type: TYPE_NORMAL
  zh: WINE 是一个递归缩写，代表 *WINE is Not an Emulator*（WINE 不是一个模拟器）。它是一个翻译层，将 Windows 可执行代码转换为
    Linux 可执行代码，并且几乎所有的 Linux 发行版都包含了这个工具。
- en: Also, please know that I have no financial arrangements with the folk at Just
    Great Software, so I don’t receive any compensation for telling you about their
    products.
  id: totrans-486
  prefs: []
  type: TYPE_NORMAL
  zh: 另外，请知道我与 Just Great Software 的员工没有任何财务安排，因此我提到他们的产品并不会得到任何报酬。
- en: 'To check out these cool products, just visit their websites. You can find RegexBuddy
    here: [https://www.regexbuddy.com/index.html](https://www.regexbuddy.com/index.html)'
  id: totrans-487
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看这些很酷的产品，只需访问它们的网站。你可以在这里找到 RegexBuddy：[https://www.regexbuddy.com/index.html](https://www.regexbuddy.com/index.html)
- en: 'And, you can find RegexMagic here: [https://www.regexmagic.com/](https://www.regexmagic.com/)'
  id: totrans-488
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在这里找到 RegexMagic：[https://www.regexmagic.com/](https://www.regexmagic.com/)
- en: Now, let’s check out a free tool.
  id: totrans-489
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们来看看一个免费的工具。
- en: Regex101
  id: totrans-490
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Regex101
- en: If you prefer to use a free-of-charge tool, you might want to check out Regex101\.
    It’s web-based, so there’s nothing to download or to install. It doesn’t have
    the bells and whistles that RegexBuddy and RegexMagic have, but there’s enough
    there to get you started. Signing in to an account is optional, but there are
    benefits to doing so. Note that you won’t be creating an account, but will instead
    be signing in via either your Google or Github account.
  id: totrans-491
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你更倾向于使用免费的工具，可以查看 Regex101。它是基于网页的，因此无需下载或安装。虽然它没有 RegexBuddy 和 RegexMagic
    那些丰富的功能，但足够让你开始使用。登录账号是可选的，但登录后会有一些好处。请注意，你不会创建一个新账号，而是通过你的 Google 或 Github 账号进行登录。
- en: 'You can check out Regex101 here: [https://regex101.com/](https://regex101.com/)'
  id: totrans-492
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在这里查看 Regex101：[https://regex101.com/](https://regex101.com/)
- en: I think that we’ve covered enough theory. Let’s move on to the real world.
  id: totrans-493
  prefs: []
  type: TYPE_NORMAL
  zh: 我想我们已经覆盖了足够的理论。接下来，让我们进入实际应用。
- en: Looking at Some Real-World Examples
  id: totrans-494
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 查看一些实际的例子
- en: I have some cool case studies on how to use `sed`, `grep`, and regular expressions
    in real life. So, read on and enjoy!
  id: totrans-495
  prefs: []
  type: TYPE_NORMAL
  zh: 我有一些关于如何在实际生活中使用 `sed`、`grep` 和正则表达式的有趣案例研究。继续阅读并享受吧！
- en: Modifying Multiple Files at Once
  id: totrans-496
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 一次修改多个文件
- en: If you have more than one file that you need to modify in the same manner, you
    can have `sed` do them all in one command, just by using a `*` wildcard in the
    filename. Quite a few years ago I assisted a website maintainer in migrating a
    set of PHP-based websites from a CentOS 5 server to a CentOS 6 server. To make
    the sites work with the newer PHP version, she needed to add a line of new code
    to each `.php` file. That could have been a bit problematic, because she had about
    2,000 files to modify, which is more than you’d want to edit manually. I suggested
    that she use `sed` to modify all files at once, and she knew immediately what
    I was talking about. (I jogged her memory by making the suggestion.)
  id: totrans-497
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你有多个文件需要以相同方式修改，可以通过使用文件名中的 `*` 通配符，让 `sed` 在一个命令中处理所有文件。几年前，我帮助一个网站维护者将一组基于
    PHP 的网站从 CentOS 5 服务器迁移到 CentOS 6 服务器。为了使网站能够兼容更新版的 PHP，她需要在每个 `.php` 文件中添加一行新代码。这可能会有些麻烦，因为她需要修改大约
    2,000 个文件，这比你手动编辑的数量要多。我建议她使用 `sed` 一次性修改所有文件，她立刻明白我在说什么。（我通过这个建议唤起了她的记忆。）
- en: Searching Through Apache Webserver Logs for Cross-site Scripting Attacks
  id: totrans-498
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 通过 Apache Webserver 日志搜索跨站脚本攻击
- en: About 15 years ago, a security worker buddy of mine called me with an urgent
    plea for help. His boss at the credit union where he worked had handed him a USB
    memory stick with four Gigabyes--Yes, four *Gigabytes*!--worth of compressed Apache
    access logs, and told him to look through them for signs of **cross-site scripting
    attacks**. What’s a poor security admin to do in a case like this?
  id: totrans-499
  prefs: []
  type: TYPE_NORMAL
  zh: 大约15年前，我的一位安全工作者朋友给我打电话，急切地求助。他在信用合作社工作的老板交给他一个USB存储设备，里面存储着四个GB——没错，就是四个*GB*——的压缩Apache访问日志，并要求他查看其中是否有**跨站脚本攻击**的迹象。像我这样一位可怜的安全管理员，在这种情况下该怎么办呢？
- en: Cross-site scripting, often abbreviated as **XSS**, is used by malicious hackers
    to steal information or to manipulate websites. I know that this name is confusing,
    and that it doesn’t give you an accurate picture of what XSS attacks really do.
    It would be more accurate to call this type of attack a **Javascript injection
    attack**, because that’s how it really works.
  id: totrans-500
  prefs: []
  type: TYPE_NORMAL
  zh: 跨站脚本攻击，通常简称为**XSS**，是恶意黑客用来窃取信息或操控网站的一种手段。我知道这个名字可能让人感到困惑，它并没有准确地描述XSS攻击的真实作用。更准确的说法应该是将这种攻击称为**Javascript注入攻击**，因为这才是它真正的工作方式。
- en: 'When an attacker finds a website that’s vulnerable to this type of attack,
    he or she can use an attack tool, such as ones that are part of Kali Linux, to
    perform his or her dirty deeds. Or at least, that’s how it is nowadays. When my
    buddy called me up 15 years ago, it was still possible to perform an XSS attack
    with a simple web browser. All an attacker had to do was to append some special
    Javascript code to the end of a website’s URL, like this:'
  id: totrans-501
  prefs: []
  type: TYPE_NORMAL
  zh: 当攻击者发现一个易受此类攻击的网站时，他或她可以使用攻击工具，如Kali Linux中的一些工具，来执行攻击。或者至少，现在是这样。15年前我朋友打电话给我时，仍然可以通过简单的网页浏览器执行XSS攻击。攻击者只需要将一些特殊的Javascript代码附加到网站URL的末尾，如下所示：
- en: '[PRE133]'
  id: totrans-502
  prefs: []
  type: TYPE_PRE
  zh: '[PRE133]'
- en: It’s no longer possible to perform an XSS attack with a web browser, because
    modern versions of all web browsers now sanitize their input. So now, the Javascript
    in the URL no longer has any effect.
  id: totrans-503
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，已经不可能通过网页浏览器执行XSS攻击了，因为现代版本的所有网页浏览器现在都会对输入进行过滤。所以，现在URL中的Javascript代码已经没有任何效果了。
- en: But, I digress.
  id: totrans-504
  prefs: []
  type: TYPE_NORMAL
  zh: 但，我偏题了。
- en: 'After my buddy called me, I set up a machine with an Apache webserver, and
    then performed some XSS attacks against it from another machine. I discovered
    that log file entries that were the result of an XSS attack had a `%` pattern
    in the `GET` portion, like this:'
  id: totrans-505
  prefs: []
  type: TYPE_NORMAL
  zh: 在我朋友打电话给我之后，我搭建了一台装有Apache Web服务器的机器，然后从另一台机器对其执行了几次XSS攻击。我发现，作为XSS攻击结果的日志文件条目，在`GET`部分会有一个`%`模式，像这样：
- en: '[PRE134]'
  id: totrans-506
  prefs: []
  type: TYPE_PRE
  zh: '[PRE134]'
- en: The `GET /%27%27` part is what tells us that this is from an XSS attack. No
    log file entries that were the result of normal website access had this pattern.
  id: totrans-507
  prefs: []
  type: TYPE_NORMAL
  zh: '`GET /%27%27` 这一部分告诉我们这是来自XSS攻击的痕迹。没有任何由正常网站访问生成的日志条目会包含这种模式。'
- en: 'There were also a couple of other variations on this pattern, and the first
    thing I had to do was to create the regular expressions that I needed to match
    all of them. The regular expressions that I created were `GET /%`, `GET /.%`,
    and `GET /.=%`. (The dot is a wildcard, which tells the script to search for any
    character in that position.) Next, I created the script, using the `find` utility
    to find and read all of the Apache log files. Here’s the script that I created:'
  id: totrans-508
  prefs: []
  type: TYPE_NORMAL
  zh: 这个模式还有一些变体，我首先需要做的是创建正则表达式来匹配所有这些变体。我创建的正则表达式有`GET /%`、`GET /.%`和`GET /.=%`。（点号是一个通配符，表示脚本在该位置查找任意字符。）接下来，我创建了脚本，使用`find`工具来查找并读取所有的Apache日志文件。这里是我创建的脚本：
- en: '[PRE135]'
  id: totrans-509
  prefs: []
  type: TYPE_PRE
  zh: '[PRE135]'
- en: 'The first thing you see is that I’m using positional parameter `$1` to designate
    the mount point of the USB memory stick, and positional parameter `$2` to designate
    the filename of the report file. The `if..then` construct is a safety feature
    that prevents the user from overwriting an existing file. The command to invoke
    the script would have looked something like this:'
  id: totrans-510
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，你会看到我使用了位置参数`$1`来指定USB存储设备的挂载点，使用位置参数`$2`来指定报告文件的文件名。`if..then`结构是一个安全特性，用来防止用户覆盖已有文件。调用脚本的命令大概长这样：
- en: '[PRE136]'
  id: totrans-511
  prefs: []
  type: TYPE_PRE
  zh: '[PRE136]'
- en: Linux system log files are normally always compressed with `gzip`, and the filenames
    will end with a `.gz`. So, I had `find` search for all `.gz` files on the memory
    stick, read them with `zcat`, and pipe the output into `grep`. Finally, I had
    the report automatically open in `less`.
  id: totrans-512
  prefs: []
  type: TYPE_NORMAL
  zh: Linux系统的日志文件通常都会被`gzip`压缩，文件名会以`.gz`结尾。因此，我让`find`命令搜索USB存储设备中的所有`.gz`文件，使用`zcat`读取它们，然后将输出传递给`grep`。最后，我让报告自动在`less`中打开。
- en: Fortunately, my buddy was able to verify that this script actually does work.
    The previous autumn, the credit union had hired a penetration testing outfit to
    test security, with XSS attacks being part of the test. The script found all instances
    of the pen tester’s attack, so everyone was happy.
  id: totrans-513
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，我的朋友能够验证这个脚本确实有效。前一个秋天，信用合作社雇佣了一家渗透测试公司进行安全测试，其中XSS攻击是测试的一部分。脚本找到了所有渗透测试人员的攻击实例，大家都很高兴。
- en: Automating Third-party Repository Installations
  id: totrans-514
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 自动化第三方仓库安装
- en: The next real-world script that I’ll show you is, sadly, one that you won’t
    be able to run. That’s because I created it sometime in either 2010 or 2011, when
    I was creating training documentation and plug-ins for the Nagios monitoring system.
    My client and I were doing everything with CentOS 5 and CentOS 6 at the time,
    which are now both obsolete.
  id: totrans-515
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来我要给你展示的另一个真实脚本，很遗憾，你将无法运行。那是因为我是在2010年或2011年创建的，当时我正在为Nagios监控系统编写培训文档和插件。我和客户当时都在使用CentOS
    5和CentOS 6，这两个版本现在都已经过时了。
- en: This scenario is part of a larger scenario that involved automatically downloading
    and compiling Nagios Core source code on a CentOS server. One of the prerequisites
    was to install the RPMForge and EPEL third-party software repositories. At that
    time, installing a third-party repository on CentOS also required you to configure
    the priorities of each of the repositories, in order to prevent having one repository
    overwrite packages that had been installed from another repository. Since my client
    and I were constantly having to perform new Nagios installations, I wrote a script
    to help automate the process. The script is too large to reproduce here, so I’ll
    invite you to download the `add-repos.sh` script from Github. However, I will
    reproduce a few snippets here to explain things.
  id: totrans-516
  prefs: []
  type: TYPE_NORMAL
  zh: 这个场景是一个更大场景的一部分，涉及在CentOS服务器上自动下载并编译Nagios Core源代码。一个前提是安装RPMForge和EPEL第三方软件仓库。那时，在CentOS上安装第三方仓库还需要配置每个仓库的优先级，以防止一个仓库的包覆盖另一个仓库安装的包。由于我和客户经常需要进行新的Nagios安装，我写了一个脚本来帮助自动化这个过程。这个脚本太大，无法在这里重现，所以我邀请你从Github下载`add-repos.sh`脚本。然而，我会在这里展示一些片段来解释一下。
- en: 'At the top of the script, you see this `if..then..else` construct:'
  id: totrans-517
  prefs: []
  type: TYPE_NORMAL
  zh: 在脚本的顶部，你会看到这个`if..then..else`结构：
- en: '[PRE137]'
  id: totrans-518
  prefs: []
  type: TYPE_PRE
  zh: '[PRE137]'
- en: At that time, the computer industry was still transitioning from 32-bit to 64-bit
    CPUs. So, the maintainer of the now defunct RPMForge repository offered separate
    installation packages for each. (I wanted to completely make the break to 64-bit,
    but my client insisted on still supporting 32-bit.) This construct automatically
    detects which flavor of CentOS is installed, and then downloads and installs the
    appropriate RPMForge package.
  id: totrans-519
  prefs: []
  type: TYPE_NORMAL
  zh: 那时，计算机行业还在从32位转向64位CPU。所以，已经废弃的RPMForge仓库的维护者为每种架构提供了单独的安装包。（我想完全切换到64位，但我的客户坚持仍然支持32位。）这个结构会自动检测安装了哪种版本的CentOS，然后下载并安装适当的RPMForge包。
- en: 'Next is the line that installs the packages for the EPEL repository and for
    setting the repository priorities. It looks like this:'
  id: totrans-520
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来是安装EPEL仓库包和设置仓库优先级的那一行。它看起来是这样的：
- en: '[PRE138]'
  id: totrans-521
  prefs: []
  type: TYPE_PRE
  zh: '[PRE138]'
- en: 'The final step is to use `sed` to automatically set the priorities for each
    section of the various repository configuration files. Here’s a snippet from one
    of those files:'
  id: totrans-522
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一步是使用`sed`自动设置每个不同仓库配置文件中各部分的优先级。下面是其中一个文件的片段：
- en: '[PRE139]'
  id: totrans-523
  prefs: []
  type: TYPE_PRE
  zh: '[PRE139]'
- en: Other sections of the file were named `[updates]`, `[extras]`, `[centosplus]`,
    and `[contrib]`. (To see the whole file, download the `CentOS-Base.repo` file
    from GitHub.) The other configuration files were also divided into sections with
    different names. The goal was to use `sed` to automatically append a `priority=`
    line just under the `[section_name]` line of every section of every file.
  id: totrans-524
  prefs: []
  type: TYPE_NORMAL
  zh: 文件的其他部分分别命名为`[updates]`、`[extras]`、`[centosplus]`和`[contrib]`。（要查看整个文件，请从GitHub下载`CentOS-Base.repo`文件。）其他配置文件也分为不同名称的部分。目标是使用`sed`自动将`priority=`这一行附加到每个文件中每个部分的`[section_name]`行下方。
- en: 'Here’s what those `sed` scripts look like:'
  id: totrans-525
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是这些`sed`脚本的样子：
- en: '[PRE140]'
  id: totrans-526
  prefs: []
  type: TYPE_PRE
  zh: '[PRE140]'
- en: 'You see that each `sed` script appends the proper priorities settings to their
    proper places. The result would have looked something like this:'
  id: totrans-527
  prefs: []
  type: TYPE_NORMAL
  zh: 你会看到每个`sed`脚本都将适当的优先级设置添加到它们应放置的位置。结果看起来大致是这样的：
- en: '[PRE141]'
  id: totrans-528
  prefs: []
  type: TYPE_PRE
  zh: '[PRE141]'
- en: And now, let’s look at one final real-life scenario.
  id: totrans-529
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看最后一个真实场景。
- en: Filling Empty Fields in a .csv File
  id: totrans-530
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在.csv文件中填充空字段
- en: 'If you ever have to work with columnar data, you might find yourself having
    to work with **Comma Separated Value** (`.csv`) files. As the name suggests, these
    are files with rows of data, with the same number of fields in each row. The fields
    are all separated by commas, like so:'
  id: totrans-531
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你曾经需要处理列数据，你可能会遇到必须使用 **逗号分隔值** (`.csv`) 文件的情况。顾名思义，这些文件包含多行数据，每行都有相同数量的字段。字段之间都由逗号分隔，如下所示：
- en: '[PRE142]'
  id: totrans-532
  prefs: []
  type: TYPE_PRE
  zh: '[PRE142]'
- en: 'The beauty of `.csv` files is that you can use a normal plain-text editor to
    create them. Then, you can open them up in any spreadsheet program, like this:'
  id: totrans-533
  prefs: []
  type: TYPE_NORMAL
  zh: '`.csv` 文件的美妙之处在于，你可以使用普通的纯文本编辑器来创建它们。然后，你可以在任何电子表格程序中打开它们，就像这样：'
- en: '![B21693_9_2](img/B21693_09_02.png)'
  id: totrans-534
  prefs: []
  type: TYPE_IMG
  zh: '![B21693_9_2](img/B21693_09_02.png)'
- en: 'Figure 9.2: Opening a .csv file as a spreadsheet'
  id: totrans-535
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.2：将 .csv 文件作为电子表格打开
- en: 'At times, you might encounter a `.csv` file that contains empty fields, like
    this one:'
  id: totrans-536
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，你可能会遇到包含空字段的 `.csv` 文件，如下所示：
- en: '[PRE143]'
  id: totrans-537
  prefs: []
  type: TYPE_PRE
  zh: '[PRE143]'
- en: 'You see that the commas are there, but there are no values in the fields between
    them. Opening this file in a spreadsheet program would look like this:'
  id: totrans-538
  prefs: []
  type: TYPE_NORMAL
  zh: 你会看到逗号存在，但字段之间没有值。在电子表格程序中打开该文件时，应该是这样的：
- en: '![B21693_9_3](img/B21693_09_03.png)'
  id: totrans-539
  prefs: []
  type: TYPE_IMG
  zh: '![B21693_9_3](img/B21693_09_03.png)'
- en: 'Figure 9.3: Opening a .csv file with empty fields'
  id: totrans-540
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.3：打开一个包含空字段的 .csv 文件
- en: Okay, that doesn’t look like a complete disaster, but you want something that
    looks better. So, you need to find an easy way to place values in all of the empty
    fields. You might want to insert some value as just a placeholder, or you might
    want to insert some text that explains why the fields are empty. Either way, `sed`
    makes that easy.
  id: totrans-541
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，看起来不像完全的灾难，但你可能想要一些看起来更好的东西。因此，你需要找到一种简单的方法，在所有空字段中填充值。你可能想要插入一些占位符值，或者你可能想要插入一些解释字段为何为空的文本。无论哪种方式，`sed`
    都能轻松完成这项工作。
- en: 'But, I have to confess that someone else has already created a solution for
    this, and I can’t really improve upon it. So, rather than try to explain the solution
    myself, I’ll invite you to visit the author’s original article that contains the
    solution, which is here: [https://linuxconfig.org/how-to-fill-all-empty-valued-cells-within-a-csv-file-with-sed-and-bash-shell](https://linuxconfig.org/how-to-fill-all-empty-valued-cells-within-a-csv-file-with-sed-and-bash-shell)'
  id: totrans-542
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，我得坦白说，别人已经为这个问题创建了解决方案，我真的无法在此基础上做出改进。所以，与其自己解释解决方案，不如邀请你访问作者的原始文章，里面包含了解决方案，链接如下：[https://linuxconfig.org/how-to-fill-all-empty-valued-cells-within-a-csv-file-with-sed-and-bash-shell](https://linuxconfig.org/how-to-fill-all-empty-valued-cells-within-a-csv-file-with-sed-and-bash-shell)
- en: Okay, that covers it for this chapter. Let’s wrap this baby up and move on.
  id: totrans-543
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，本章的内容就到这里了。让我们结束这部分，继续前进。
- en: Summary
  id: totrans-544
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: As always, we’ve covered lots of ground in this chapter. I first gave you a
    basic explanation of Regular Expressions, regular expressions, `sed`, and `grep`.
    Then, I showed you how to use regular expressions with both `sed` and `grep`.
    I also showed you some cool tools that can help simplify the process of creating
    regular expressions. Finally, I showed you some real-live scenarios in which I
    actually used these concepts for my own scripts.
  id: totrans-545
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们通常做的那样，在本章中我们覆盖了很多内容。我首先向你解释了正则表达式、正则表达式的基本概念、`sed` 和 `grep`。接着，我展示了如何将正则表达式与
    `sed` 和 `grep` 配合使用。我还展示了一些很棒的工具，这些工具可以帮助简化正则表达式的创建过程。最后，我展示了一些实际场景，在这些场景中，我在自己的脚本中使用了这些概念。
- en: The next chapter will be about functions. I’ll see you there.
  id: totrans-546
  prefs: []
  type: TYPE_NORMAL
  zh: 下一章将讲解函数。我们在那里见。
- en: Questions
  id: totrans-547
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: Which of the following is the preferred method for using grep with extended
    syntax?
  id: totrans-548
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下哪一项是使用扩展语法的 `grep` 的首选方法？
- en: '`Egrep`'
  id: totrans-549
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`Egrep`'
- en: '`egrep`'
  id: totrans-550
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`egrep`'
- en: '`grep -e`'
  id: totrans-551
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`grep -e`'
- en: '`grep -E`'
  id: totrans-552
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`grep -E`'
- en: Which of the following are the two general types of characters that are used
    in regular expressions? (Choose two.)
  id: totrans-553
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下哪两种字符是正则表达式中使用的两种通用字符？（选择两个。）
- en: digits
  id: totrans-554
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: digits
- en: alphabetic
  id: totrans-555
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 字母
- en: literals
  id: totrans-556
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 字面量
- en: numbers
  id: totrans-557
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 数字
- en: metacharacters
  id: totrans-558
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 元字符
- en: When creating a regular expression, which of the following would you use as
    an `or` operator?
  id: totrans-559
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在创建正则表达式时，以下哪一项你会用作 `or` 运算符？
- en: '`or`'
  id: totrans-560
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`or`'
- en: '`-o`'
  id: totrans-561
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`-o`'
- en: '`-or`'
  id: totrans-562
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`-or`'
- en: '`|`'
  id: totrans-563
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`|`'
- en: '`?`'
  id: totrans-564
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`?`'
- en: What are the three types of metacharaters in Regular Expressions? (Choose three.)
  id: totrans-565
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 正则表达式中有哪三种元字符？（选择三个。）
- en: Literals
  id: totrans-566
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 字面量
- en: Positional anchors
  id: totrans-567
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 位置锚点
- en: Numbers
  id: totrans-568
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 数字
- en: Character sets
  id: totrans-569
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 字符集
- en: Modifiers
  id: totrans-570
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 修饰符
- en: Which option switch would you use with sed to save changes to the source file?
  id: totrans-571
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你会使用 `sed` 的哪个选项开关来保存更改到源文件中？
- en: '`-o`'
  id: totrans-572
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`-o`'
- en: '`-i`'
  id: totrans-573
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`-i`'
- en: '`-s`'
  id: totrans-574
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`-s`'
- en: '`-n`'
  id: totrans-575
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`-n`'
- en: Further Reading
  id: totrans-576
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: 'Regex Tutorial—How to write regular expressions?: [https://www.geeksforgeeks.org/write-regular-expressions/](https://www.geeksforgeeks.org/write-regular-expressions/)'
  id: totrans-577
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 正则表达式教程——如何编写正则表达式：[https://www.geeksforgeeks.org/write-regular-expressions/](https://www.geeksforgeeks.org/write-regular-expressions/)
- en: 'Regular Expressions.info: [https://www.regular-expressions.info/](https://www.regular-expressions.info/)'
  id: totrans-578
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 正则表达式信息：[https://www.regular-expressions.info/](https://www.regular-expressions.info/)
- en: 'Learn Regex: A Beginner’s Guide: [https://www.sitepoint.com/learn-regex/](https://www.sitepoint.com/learn-regex/)'
  id: totrans-579
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 学习正则表达式：初学者指南：[https://www.sitepoint.com/learn-regex/](https://www.sitepoint.com/learn-regex/)
- en: 'A Practical Guide to Regular Expressions: [https://www.freecodecamp.org/news/practical-regex-guide-with-real-life-examples/](https://www.freecodecamp.org/news/practical-regex-guide-with-real-life-examples/)'
  id: totrans-580
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 正则表达式实用指南：[https://www.freecodecamp.org/news/practical-regex-guide-with-real-life-examples/](https://www.freecodecamp.org/news/practical-regex-guide-with-real-life-examples/)
- en: 'Regex Cheat Sheet and Quick Reference: [https://quickref.me/regex.html](https://quickref.me/regex.html)'
  id: totrans-581
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 正则表达式备忘单和快速参考：[https://quickref.me/regex.html](https://quickref.me/regex.html)
- en: 'How to Use the sed Command on Linux: [https://www.howtogeek.com/666395/how-to-use-the-sed-command-on-linux/](https://www.howtogeek.com/666395/how-to-use-the-sed-command-on-linux/)'
  id: totrans-582
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何在Linux上使用sed命令：[https://www.howtogeek.com/666395/how-to-use-the-sed-command-on-linux/](https://www.howtogeek.com/666395/how-to-use-the-sed-command-on-linux/)
- en: 'How to Use sed to Find and Replace String in Files: [https://linuxize.com/post/how-to-use-sed-to-find-and-replace-string-in-files/](https://linuxize.com/post/how-to-use-sed-to-find-and-replace-string-in-files/)'
  id: totrans-583
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何使用sed查找并替换文件中的字符串：[https://linuxize.com/post/how-to-use-sed-to-find-and-replace-string-in-files/](https://linuxize.com/post/how-to-use-sed-to-find-and-replace-string-in-files/)
- en: 'How to Use the grep Command on Linux: [https://www.howtogeek.com/496056/how-to-use-the-grep-command-on-linux/](https://www.howtogeek.com/496056/how-to-use-the-grep-command-on-linux/)'
  id: totrans-584
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何在Linux上使用grep命令：[https://www.howtogeek.com/496056/how-to-use-the-grep-command-on-linux/](https://www.howtogeek.com/496056/how-to-use-the-grep-command-on-linux/)
- en: 'How to use the Linux grep command: [https://opensource.com/article/21/3/grep-cheat-sheet](https://opensource.com/article/21/3/grep-cheat-sheet)'
  id: totrans-585
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何使用Linux grep命令：[https://opensource.com/article/21/3/grep-cheat-sheet](https://opensource.com/article/21/3/grep-cheat-sheet)
- en: Answers
  id: totrans-586
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 答案
- en: d
  id: totrans-587
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: d
- en: c and e
  id: totrans-588
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: c 和 e
- en: d
  id: totrans-589
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: d
- en: b, d, and e
  id: totrans-590
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: b, d 和 e
- en: b
  id: totrans-591
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: b
- en: Join our community on Discord!
  id: totrans-592
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 加入我们的Discord社区！
- en: Read this book alongside other users, Linux experts, and the author himself.
  id: totrans-593
  prefs: []
  type: TYPE_NORMAL
  zh: 和其他用户、Linux专家以及作者本人一起阅读本书。
- en: Ask questions, provide solutions to other readers, chat with the author via
    Ask Me Anything sessions, and much more. Scan the QR code or visit the link to
    join the community.
  id: totrans-594
  prefs: []
  type: TYPE_NORMAL
  zh: 提问、为其他读者提供解决方案、通过“问我任何问题”环节与作者交流，等等。扫描二维码或访问链接加入社区。
- en: '[https://packt.link/SecNet](https://packt.link/SecNet)'
  id: totrans-595
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://packt.link/SecNet](https://packt.link/SecNet)'
- en: '![](img/QR_Code10596186092701843.png)'
  id: totrans-596
  prefs: []
  type: TYPE_IMG
  zh: '![](img/QR_Code10596186092701843.png)'
- en: Leave a Review!
  id: totrans-597
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 留下评论！
- en: Thank you for purchasing this book from Packt Publishing—we hope you enjoy it!
    Your feedback is invaluable and helps us improve and grow. Once you've completed
    reading it, please take a moment to leave an Amazon review; it will only take
    a minute, but it makes a big difference for readers like you.
  id: totrans-598
  prefs: []
  type: TYPE_NORMAL
  zh: 感谢您从Packt Publishing购买本书——我们希望您喜欢它！您的反馈非常宝贵，帮助我们改进和成长。阅读完本书后，请花几分钟时间在Amazon上留下评论；这只需要一分钟，但对像您这样的读者来说，它能带来巨大的影响。
- en: Scan the QR code below to receive a free ebook of your choice.
  id: totrans-599
  prefs: []
  type: TYPE_NORMAL
  zh: 扫描下方二维码，领取您选择的免费电子书。
- en: '[https://packt.link/NzOWQ](https://packt.link/NzOWQ)'
  id: totrans-600
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://packt.link/NzOWQ](https://packt.link/NzOWQ)'
- en: '![](img/review.png)'
  id: totrans-601
  prefs: []
  type: TYPE_IMG
  zh: '![](img/review.png)'
