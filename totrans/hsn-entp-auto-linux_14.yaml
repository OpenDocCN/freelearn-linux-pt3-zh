- en: Database Management
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: No application stack is complete without data, and this is commonly stored in
    a database. There is a myriad of databases to choose from when your platform is
    Linux, and the whole topic of database management and administration often warrants
    entire books by itself—in fact, normally one book per database technology. In
    spite of the vastness of this topic, a little knowledge of Ansible can assist
    greatly when it comes to database administration.
  prefs: []
  type: TYPE_NORMAL
- en: Indeed, whether you are installing a new database server, or performing maintenance
    or administration tasks on an existing one, our original principles discussed
    in [Chapter 1](c7596fb8-4971-44d7-943a-7660c5eecb17.xhtml), *Building a Standard
    Operating Environment on Linux* still apply. Indeed, why would you go to all the
    trouble of standardizing your Linux environment and ensuring all changes are automated,
    only to insist on manual management of the database tier? This could easily result
    in a lack of standardization, auditability, and even traceability (for example,
    who made which changes, and when?). Ansible can perform database operations and
    configuration via modules. It is perhaps not a replacement for some of the more
    advanced database management tools available on the market, but if these can be
    driven through the command line, it can execute these on your behalf, as well
    as taking care of many tasks itself. Ultimately, you want all changes to be documented
    (or self-documented) and auditable, and Ansible (combined with Ansible Tower,
    or AWX) can help you achieve this. This chapter explores methods that will help
    you with this.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following topics will be covered in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Installing databases with Ansible
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Importing and exporting data
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Performing routine maintenance
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This chapter includes examples, based on the following technologies:'
  prefs: []
  type: TYPE_NORMAL
- en: Ubuntu Server 18.04 LTS
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: CentOS 7.6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Ansible 2.8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'To run through these examples, you will need access to two servers or virtual
    machines running one each of the operating systems just listed, and also, Ansible.
    Note that the examples given in this chapter may be destructive in nature (for
    example, they add and remove databases and tables, and change database configuration)
    and, if run as is, are only intended to be run in an isolated test environment.
    Once you are satisfied that you have a safe environment in which to operate, let''s
    get started on looking at the installation of new software packages with Ansible.
    All example code discussed in this chapter is available from GitHub, at the following
    URL: [https://github.com/PacktPublishing/Hands-On-Enterprise-Automation-on-Linux/tree/master/chapter11](https://github.com/PacktPublishing/Hands-On-Enterprise-Automation-on-Linux/tree/master/chapter11).'
  prefs: []
  type: TYPE_NORMAL
- en: Installing databases with Ansible
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In [Chapter 7](200bea26-7066-4feb-a571-481a5f047ae4.xhtml), *Configuration Management
    with Ansible*, we explored a few examples of package installation and used MariaDB
    server in some of our examples. Of course, MariaDB is only one of a myriad of
    databases available on Linux, and there are too many to cover in detail here.
    Nonetheless, Ansible can help you install just about any database server on Linux,
    and in this chapter, we will proceed through a series of examples that will provide
    you with the tools and techniques to install your own database server, no matter
    what it is.
  prefs: []
  type: TYPE_NORMAL
- en: Let's get started in the next section, by building on our example of installing
    MariaDB.
  prefs: []
  type: TYPE_NORMAL
- en: Installing MariaDB server with Ansible
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Although earlier in the book, we installed the native `mariadb-server` package
    that ships with CentOS 7, most enterprises that need a MariaDB server would choose
    to standardize on a specific release directly from MariaDB. This is often more
    up to date than the version shipped with a given Linux release, and hence provides
    newer features and, sometimes, performance improvements. In addition, standardizing
    on a release directly from MariaDB ensures consistency of your platform, a principle
    we have kept to throughout this book.
  prefs: []
  type: TYPE_NORMAL
- en: Let's take a simple example—suppose you are running your infrastructure on **Red
    Hat Enterprise** **Linux** (**RHEL**) 7\. This ships with MariaDB version 5.5.64\.
    Now, suppose you want to standardize your infrastructure on the newly released
    RHEL 8—if you are relying on the packages supplied by Red Hat, this suddenly moves
    you to version 10.3.11 of MariaDB, meaning not only an upgrade to your Linux infrastructure
    but also to your databases, too.
  prefs: []
  type: TYPE_NORMAL
- en: Instead, it would be better to standardize upfront on a release directly from
    MariaDB itself. At the time of writing, the latest stable release of MariaDB is
    10.4—but let us suppose that you have standardized on the 10.3 release, as it
    is known, and tested successfully in your environment.
  prefs: []
  type: TYPE_NORMAL
- en: The installation process is quite straightforward and is well documented on
    the MariaDB website—see [https://mariadb.com/kb/en/library/yum/](https://mariadb.com/kb/en/library/yum/)
    for CentOS- and Red Hat-specific examples. However, this details the manual installation
    process, and we wish to automate this with Ansible. Let's now build this into
    a real, working Ansible example.
  prefs: []
  type: TYPE_NORMAL
- en: In this example, we will follow the instructions from MariaDB, which includes
    downloading the packages from their repository. Although for simplicity we will
    follow this example through, you could mirror the MariaDB package repositories
    into Pulp or Katello, as detailed in [Chapter 8](56007c92-a39b-4e56-9b01-a137eab2369d.xhtml),
    *Enterprise Repository Management* *with Pulp* and [Chapter 9](f5ffd33a-aabf-419c-95b2-c5a308f24b2f.xhtml),
    *Patching with Katello*.
  prefs: []
  type: TYPE_NORMAL
- en: First of all, we can see from the installation documentation that we need to
    create a `.repo` file, to tell `yum` where to download the packages from. We can
    use a template to provide this, such that the MariaDB version can be defined by
    a variable and thus changed in the future when migration to version 10.4 (or indeed,
    any other future version) is deemed necessary.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Thus, our template file, defined in `roles/installmariadb/templates/mariadb.repo.j2`,
    would look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Once we have created this, we should also create a default for this variable,
    to prevent any issues or errors if it is not specified when the role is run—this
    will be defined in `roles/installmariadb/defaults/main.yml`. Ordinarily, this
    variable would be provided in the inventory file for a given server or group of
    servers, or by one of the many other supported methods in Ansible, but the `defaults`
    file provides a catch-all, in case it gets overlooked. Run the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'With this defined, we can now begin to build up the tasks in our role in `roles/installmariadb/tasks/main.yml`,
    as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: This will ensure that the correct repository file is written to the server,
    and if it is ever incorrectly modified, restored to its original, desired state.
  prefs: []
  type: TYPE_NORMAL
- en: On CentOS or RHEL, you could also use the `yum_repository` Ansible module to
    perform this task—however, this has the disadvantage of being unable to modify
    an existing repository definition, and so, in a scenario where we might wish to
    change the repository version in future, we are better off using a template.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we should clean out the `yum` cache—this is especially important when
    upgrading MariaDB to a new version, as package names will be the same, and cached
    information could cause issues with the installation. At present, cleaning the
    `yum` cache is achieved using the `shell` module, to run the `yum clean all` command.
    However, as this is a shell command, it will always run, and this could be considered
    inefficient—especially as this command being run would result in any future package
    operations needing to update the yum cache again, even if we didn't modify the
    MariaDB repository definition. Thus, we want to run it only when the `template`
    module task results in a changed state.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'To do this, we must first add this line to our `template` task, to store the
    results of the task:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, when we define our shell command, we can tell Ansible to only run it if
    the `template` task resulted in a `changed` state, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'With our cache appropriately cleared out, we can then install the required
    MariaDB packages—the list used in the task shown in the following code block is
    taken from the MariaDB documentation referenced earlier in this section, but you
    should tailor it to your exact requirements:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'The use of `state: latest` ensures that we always install the latest packages
    from the repository file created by our `template` task. Thus, this role can be
    used equally for initial installation and upgrade to the latest version. However,
    if you do not want this behavior, change this statement to `state: present`—this
    simply ensures that the packages listed are installed on our target host. If they
    are, it does not update them to the latest version—it simply returns an `ok` status
    and proceeds to the next task, even if updates are available.'
  prefs: []
  type: TYPE_NORMAL
- en: 'With the packages installed, we must ensure that the server service is then
    started at boot time. We would probably also want to start it now so that we can
    perform any initial configuration work on it. Thus, we will add a final task to
    our `installmariadb` role that looks like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Also, we know that CentOS 7 has a firewall enabled by default—as such, we must
    change the firewall rules to ensure that our newly installed MariaDB server can
    be accessed. The task to perform this would look something like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s now run this role and see it in action—the output should look something
    like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/7a175122-a7c8-46f2-918f-9c66561bb41e.png)'
  prefs: []
  type: TYPE_IMG
- en: The output has been truncated to conserve space, but clearly shows the installation
    in progress. Note that the warning can safely be ignored—the Ansible engine has
    detected our `yum clean all` command and is helpfully advising us to use the `yum`
    module—however, the `yum` module in this instance does not provide the function
    we need, and hence, we used the `shell` module instead.
  prefs: []
  type: TYPE_NORMAL
- en: 'With the database installed and running, we have the following three high-level
    tasks to perform next:'
  prefs: []
  type: TYPE_NORMAL
- en: Update the MariaDB configuration.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Secure the MariaDB installation.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Load initial data (or schemas) into the database.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Of these tasks, we explored, in detail, methods to use the Ansible `template`
    module effectively to manage the MariaDB configuration in [Chapter 7](200bea26-7066-4feb-a571-481a5f047ae4.xhtml),
    *Configuration Management with Ansible* (see the *Making scalable dynamic configuration
    changes* section*)*. As such, we will not go into detail on this here—however,
    check the configuration file structure for your chosen version of MariaDB, as
    it might differ from that shown in the aforementioned chapter.
  prefs: []
  type: TYPE_NORMAL
- en: If you have installed MariaDB RPMs on a platform such as CentOS, you can find
    out where the configuration files live, by running the command `rpm -qc MariaDB-server`
    in a root shell.
  prefs: []
  type: TYPE_NORMAL
- en: Thus, assuming that you have the installation and configuration of the database
    server in hand, let us proceed to secure it. This, at a bare minimum, will entail
    changing the `root` password, though good practice states that you should also
    remove remote root access, the `test` database, and the anonymous user accounts
    that come with a default MariaDB installation.
  prefs: []
  type: TYPE_NORMAL
- en: MariaDB comes with a command-line utility called `mysql_secure_installation`,
    to perform exactly these tasks—however, it is an interactive tool and does not
    lend itself to automation with Ansible. Luckily, Ansible provides modules for
    interacting with the database that can assist us in performing exactly these tasks.
  prefs: []
  type: TYPE_NORMAL
- en: 'To separate out these tasks from the installation, we''ll create a new role
    called `securemariadb`. Before we can define the tasks, we must define a variable
    to contain the root password for the MariaDB installation. Note that normally,
    you would provide this in a more secure manner—perhaps through an Ansible Vault
    file, or using some of the advanced features in AWX or Ansible Tower. For simplicity,
    in this example, we will define a variables file in the role (in `roles/securemariadb/vars/main.yml`),
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Now, let's build up the tasks for the role. Ansible includes a few native modules
    for use in database management, and we can make use of these here, to make the
    required changes to our MariaDB database.
  prefs: []
  type: TYPE_NORMAL
- en: Note, however, that some modules have certain Python requirements, and in the
    case of our example system—MariaDB on CentOS 7—we must install the `MySQL-python`
    package.
  prefs: []
  type: TYPE_NORMAL
- en: 'Knowing this, the first step in building up our role is to install the prerequisite
    Python package, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Our most immediate task, once this is installed, is to set the password on
    the local root account, and prevent anyone from logging in without authentication.
    Run the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'So far, this is a textbook example of how to use the `mysql_user` module—however,
    there is a twist in our usage from here. The preceding example takes advantage
    of the fact that no root password is set—it is implicitly manipulating the database
    as `root`, by virtue of the fact that we will put `become: yes` in our `site.yml`
    file, and thus, the playbook will be run as `root`. At the time that this task
    is run, the root user has no password, and so, the above task will run satisfactorily.'
  prefs: []
  type: TYPE_NORMAL
- en: The answer to this is to add the `login_user` and `login_password` parameters
    to the module for all future tasks, to ensure that we have authenticated successfully
    with the database to perform the required tasks.
  prefs: []
  type: TYPE_NORMAL
- en: 'This role will only run successfully once as it is written—on the second run,
    a password will be set for the root MariaDB user, and the preceding task will
    fail. However, if we specify a `login_password` for the above task, and the password
    is blank (as in the initial run), the task will also fail. There are a number
    of ways around this, such as setting the old password in another variable or,
    indeed, committing to only running this role once. You could also specify `ignore_errors:
    yes` under this task so that, if the root password is already set, we simply carry
    on to the next tasks, which should run successfully.'
  prefs: []
  type: TYPE_NORMAL
- en: 'With this condition understood, we now add another task to the role, to remove
    the remote root accounts, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Again, this code is quite self-explanatory—however, note here too that running
    this task a second time will also yield an error, this time because on the second
    run, these privileges will not exist because we deleted them on the first run.
    Thus, this is almost certainly a role to run once only—or where careful consideration
    must be applied to the code and the error handling logic.
  prefs: []
  type: TYPE_NORMAL
- en: 'We now add a task to delete the anonymous user accounts, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'You will see the use of a `loop` here—this is used to remove both the local
    and remote privileges within a single task. Finally, we remove the `test` database,
    which is redundant in most enterprise scenarios, by running the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'With the role fully complete, we can run it in the usual manner, and secure
    our newly installed database. The output should look something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/37b03b62-9e01-42aa-8a91-e69708f34d9b.png)'
  prefs: []
  type: TYPE_IMG
- en: 'With these two roles and some input from [Chapter 7](200bea26-7066-4feb-a571-481a5f047ae4.xhtml),
    *Configuration Management with Ansible*, we have successfully installed, configured,
    and secured a MariaDB database on CentOS. This is, obviously, a very specific
    example—however, if you were to perform this on Ubuntu, the process would be very
    similar. The differences would be the following:'
  prefs: []
  type: TYPE_NORMAL
- en: The `apt` module would be used in place of the `yum` module in all tasks.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Package names would have to be changed for Ubuntu.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Defining the repository source would be performed under `/etc/apt` rather than
    `/etc/yum.repos.d`, with the file format adjusted accordingly.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Configuration paths may be different for MariaDB on Ubuntu.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Ubuntu normally uses `ufw` instead of `firewalld`—by default, you might find
    that `ufw` is disabled, so, this step could be skipped.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: With these changes taken into account, the preceding process can be very quickly
    adapted for Ubuntu (or, indeed, any other platform, provided the appropriate changes
    are made). Once the packages are installed and configured, as the modules such
    as `mysql_user` and `mysql_db` are cross-platform, they will work equally well
    on all supported platforms.
  prefs: []
  type: TYPE_NORMAL
- en: So far in this book, we have focused very heavily on MariaDB—this is not because
    of any inherent bias toward this database, nor indeed should it be inferred as
    any recommendation. It has simply been chosen as a relevant example and built
    upon throughout the text. Before we proceed to look at the process of loading
    data or schemes into a newly installed database, we will take a brief look in
    the next section at how to apply the processes we have learned so far to another
    popular Linux database—PostgreSQL.
  prefs: []
  type: TYPE_NORMAL
- en: Installing PostgreSQL Server with Ansible
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we will demonstrate how the principles and high-level processes
    we have looked at so far for MariaDB on CentOS can be applied to another platform.
    Taking a high-level view, these processes can be applied to almost any database
    and Linux platform, with the proper attention to detail. Here, we will install
    PostgreSQL Server onto Ubuntu Server, and then secure it by setting the root password—essentially,
    analogous to the process we have performed in the preceding section.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let us get started by creating a role called `installpostgres`. In this role
    we will again define a template for the package downloads from the official PostgreSQL
    sources, this time—of course—tailoring it to the fact that we''re using Ubuntu
    Server, and not CentOS. The following code shows the template file—note that this
    is specific for Ubuntu Server 18.04 LTS—codename `bionic`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'As before, once our package sources are defined, we can proceed to create the
    tasks that will install the database. In the case of Ubuntu, we must add the package-signing
    key manually to the `apt` keyring, in addition to copying the preceding template
    into place. Thus, our tasks within the role begin, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: We could also use `apt_repository` here, but, for consistency with the previous
    MariaDB example, we are using template. Both will achieve the same end result.
  prefs: []
  type: TYPE_NORMAL
- en: 'When the `template` package is in place, we must then add the package-signing
    key to `apt`''s keyring, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'The `postgresql-11` and other supporting packages are then installed (as per
    the documentation at [https://www.postgresql.org/download/linux/ubuntu/](https://www.postgresql.org/download/linux/ubuntu/)),
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'As our default Ubuntu Server install is not running a firewall, the final task
    in this playbook is to start the service, and ensure it starts at boot time, as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Running this should yield output similar to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/e64ead5b-ee7d-4244-bd88-e1c56ff1eb4e.png)'
  prefs: []
  type: TYPE_IMG
- en: By default, *out-of-the-box* installation of PostgreSQL is much more secure
    than MariaDB. Without additional configuration, no remote logins are allowed at
    all, and although no password is set for the superuser account, it can only be
    accessed on the local machine from the `postgres` user account. Similarly, there
    is no test database to drop.
  prefs: []
  type: TYPE_NORMAL
- en: Thus, although the high-level process is the same, you must be aware of the
    nuances of both the database server you are using and the underlying operating
    system.
  prefs: []
  type: TYPE_NORMAL
- en: By way of example and to complete this section, let's create a database called
    `production`, and an associated user called `produser` who will be given access
    to it. Although technically, this overlaps with the next section on loading initial
    data, it is provided here to be analogous to the preceding section on MariaDB,
    and to demonstrate how to use the native Ansible modules for PostgreSQL.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s create a role called `setuppostgres`, and start by defining a task to
    install the Ubuntu package necessary to support the Ansible PostgreSQL modules,
    as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'After this, we add a task to create the database (this is a very simple example—you
    will want to tailor it to your exact requirements), as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Notice how we leverage the local `postgres` account on the target machine for
    database superuser access with the `become_user` statement. Next, we''ll add the
    user, and give them privileges on this database, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: As usual, you would not just specify the password in plaintext like this—this
    has been done here for simplicity. As usual, substitute appropriate data for variables,
    and if those variables are sensitive, either encrypt them at rest using Ansible
    Vault or prompt the user for them when the playbook is run.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, to get PostgreSQL to listen for remote connections for this user, we need
    to perform two more actions. We need to add a line to `pg_hba.conf`, to tell PostgreSQL
    to allow the user we just created to access this database from the appropriate
    network—the following example is shown, but be sure to tailor it to your network
    and requirements:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'We must also change the `listen_addresses` parameter in the `postgresql.conf`
    file, which defaults to local connections only. The exact location of this file
    will vary depending on your operating system and version of PostgreSQL—the following
    example shown is suitable for our install of PostgreSQL 11 on Ubuntu Server 18.04:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Observant readers will have noticed the use of handlers here too—the `postgresql`
    service must be restarted to pick up any changes to this file. However, this should
    only be performed when the file is changed, and hence we make use of handlers.
    Our `handlers/main.yml` file will look like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'With our playbook assembled, we can now run it, and the output should look
    something like the following screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/420b017b-3c12-4abc-a370-621bf44f930e.png)'
  prefs: []
  type: TYPE_IMG
- en: Although this example is not strictly the same as the replication of the `mysql_secure_installation`
    tool in the previous section, it does show how to use native Ansible modules to
    configure and secure a PostgreSQL database and shows how Ansible can powerfully
    assist you in setting up and securing new database servers. These principles can
    be applied to just about any database server that is compatible with Linux, though
    the modules available for each database will vary. A full list of modules can
    be found here: [https://docs.ansible.com/ansible/latest/modules/list_of_database_modules.html](https://docs.ansible.com/ansible/latest/modules/list_of_database_modules.html)
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have looked at the process of installing a database server, in the
    next section, we will build on our installation work, to load initial data and
    schemas.
  prefs: []
  type: TYPE_NORMAL
- en: Importing and exporting data
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: No database is complete simply by installing the software and configuring it—often,
    there is a very important intermediate stage, which involves loading an initial
    dataset. This might be a backup from a previous database, a sanitized dataset
    for testing purposes, or, simply, a schema into which application data can be
    loaded.
  prefs: []
  type: TYPE_NORMAL
- en: Although Ansible has modules for a limited set of database functions, the functionality
    here is not as complete as that for other automation tasks. The most complete
    support offered for a database by Ansible is for PostgreSQL—with lesser support
    for some other databases. Through some clever use of the `shell` module, any manual
    task that you can perform on the command line can be replicated into an Ansible
    task. It is up to you to apply logic to the tasks to handle errors or conditions
    where, for example, a database already exists, and we shall see an example of
    this in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we will look at how you could use Ansible to automate the
    task of loading a sample database into a MariaDB database.
  prefs: []
  type: TYPE_NORMAL
- en: Automating MariaDB data loading with Ansible
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: MariaDB is a good choice for this chapter because it offers a middle-of-the-road
    view when it comes to database management with Ansible. There is some native module
    support in Ansible, but this is not complete for all tasks you might want to execute.
    As a result, we will develop the following example, which automates the loading
    of a sample set of data, using just the `shell` Ansible modules. We will then
    develop this to show how it would be completed with the `mysql_db` module, to
    provide you with a direct comparison between the two automation techniques.
  prefs: []
  type: TYPE_NORMAL
- en: Note that the following examples performed using the `shell` module could be
    adapted for almost any database you can manage from the command line, and so it
    is hoped these will provide you with a valuable reference for automating your
    database management tasks.
  prefs: []
  type: TYPE_NORMAL
- en: 'In terms of example databases, we will work with the publicly available **Employees**
    sample database, as this is available to everyone reading this book. You can,
    of course, choose your own set of data to work with—however, it is, as ever, hoped
    that this following practical example will teach you the skills you need to load
    data into your newly installed database with Ansible:'
  prefs: []
  type: TYPE_NORMAL
- en: 'To start with, let''s create a role called `loadmariadb`. Into the `roles`
    directory structure, create a directory called `files/`, and clone the `employees`
    sample database. This is publicly available on GitHub, and, at the time of writing,
    could be cloned using the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'From here, we create a `tasks/` directory within the role and write the code
    for our role tasks themselves. To start with, we need to copy the database files
    across to our database server, by running the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Once the data files are copied to the server, it is simply a matter of loading
    them into the database. However, as there is no module for this task, we must
    revert to a shell command to handle this, as shown in the following code block:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'The role tasks are simplicity themselves—however, before we can run the playbook,
    we need to set the `mariadb_root_password` variable, ideally in a vault, but for
    simplicity in this book, we will put it in a plaintext `vars` file in the role.
    The file `vars/main.yml` should look like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: As you will have spotted, this playbook assumes that you already installed and
    configured MariaDB in a previous role—the password used in the preceding code
    block is that set in the previous section when we installed MariaDB and secured
    it using Ansible.
  prefs: []
  type: TYPE_NORMAL
- en: 'Running the playbook should yield results like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/fa4e8d55-7e63-498e-8520-4962c88370d4.png)'
  prefs: []
  type: TYPE_IMG
- en: Here, we have not only loaded a sample schema, but also sample data, into our
    database. In your enterprise, you could choose to perform either of these tasks
    in isolation, as required.
  prefs: []
  type: TYPE_NORMAL
- en: You will probably have spotted that this playbook is extremely dangerous. As
    we discussed previously, the issue with using the `shell` module in Ansible playbooks
    is that the results of the task will vary as the shell command is always run,
    whether it needs running or not. Thus, if you ran this playbook against a server
    with an existing database called `employees`, it would overwrite all the data
    in it with the sample data! Contrast this with the `copy` module, which only copies
    the files if they do not already exist on the receiving end.
  prefs: []
  type: TYPE_NORMAL
- en: Given the lack of native database modules at the time of writing, we need to
    devise a more intelligent way of running this command. Here, we can make use of
    some of the clever error handling built into Ansible.
  prefs: []
  type: TYPE_NORMAL
- en: The `shell` module assumes that the command it is running has run successfully
    if it returns exit code zero. This results in the task returning the `changed`
    status we saw in this playbook run. However, if the exit code is not zero, the
    `shell` module will instead return a status of `failed`.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can take advantage of this knowledge, and couple it with a useful MariaDB
    command that will return a zero exit code if the database we query exists, and
    non-zero if it doesn''t. See the following screenshot for an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/185c8355-44d3-4a26-b99e-7ad5cbea9fa4.png)'
  prefs: []
  type: TYPE_IMG
- en: We can make use of this command by running it before our task that loads the
    data. We can ignore any errors from the command, and instead register them in
    a variable. We use this to conditionally run the data load, loading it only if
    an error occurred (this is the instance where the database does not exist, and
    so it is safe to load the data).
  prefs: []
  type: TYPE_NORMAL
- en: 'The copy task remains the same, but the tail end of the tasks now looks like
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: Now, we will only load the data if the database doesn't exist. This code has
    been kept simple for the sake of providing an example, and it is left to you to
    enhance it—for example, by putting the filenames and database name into a variable
    so that the role becomes reusable in a variety of circumstances (which, after
    all, is one of the goals of writing a role).
  prefs: []
  type: TYPE_NORMAL
- en: 'If we now run this code, we can see that it operates as desired—on the first
    run, the data is loaded, as the following screenshot shows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/d14854d0-0c2d-4035-8843-ddaa7a583c0d.png)'
  prefs: []
  type: TYPE_IMG
- en: 'However, on the second run, it is not—the following screenshot shows the playbook
    being run a second time, and the data load task being skipped because the database
    exists:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/1063129d-0ed5-4518-8e18-e6dc0dcc2404.png)'
  prefs: []
  type: TYPE_IMG
- en: Although these examples are specific to MariaDB, the high-level process performed
    here should work with just about any database. The key element is to use the `shell`
    module to load the data and/or schema but to do so in a way that reduces the right
    of a valid database getting overwritten, in the event that the playbook gets run
    twice. You should extend this logic to any other task you perform—your ultimate
    goal should be that if your playbook is run unintentionally, then no damage is
    done to the existing database.
  prefs: []
  type: TYPE_NORMAL
- en: 'Having completed this example, it is worth noting that Ansible does provide
    a module called `mysql_db`, which can natively handle tasks such as dumping and
    importing database data. Let''s now develop an example that makes use of the native
    `mysql_db` module:'
  prefs: []
  type: TYPE_NORMAL
- en: 'If we were to develop a role to perform exactly the same task as shown previously,
    but using this native module, we would first of all check to see if the database
    exists as before, registering the result to a variable, like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'We then create a `block` in our tasks file, as there is no point running any
    of the tasks after this step if the database exists. The `block` uses the `when`
    clause we used before, to determine whether the tasks inside it should run or
    not, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'Inside the `block`, we copy over all the SQL files to import just as we did
    before, like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, an important difference emerges between using the `shell` module, and `mysql_db`.
    When using the `shell` module, we used the `chdir` argument to change the working
    directory to `/tmp`, which is where all our SQL files were copied to. The `mysql_db`
    module has no `chdir` (or equivalent) argument, and so will fail when it comes
    to try to load the `*.dump` files that are sourced via `employees.sql`. To work
    around this, we use the Ansible `replace` module, to add the full path to these
    files into the appropriate lines in `employees.sql`, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we use the `mysql_db` module to load in the data (this is analogous
    to the shell command we performed in our earlier example), as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'When we run this code, it achieves the same end result as our previous role
    that used the `shell` module, as the following screenshot shows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/335f97a1-02fb-4eb6-8e5f-a0fffd5f6e80.png)'
  prefs: []
  type: TYPE_IMG
- en: 'This process works equally well for backing up databases, too. If you were
    to use the `shell` module, you could use the `mysqldump` command to back up a
    database, and then copy the backed-up data to your Ansible host (or indeed, another)
    for archiving. A simple piece of example code to achieve this might be constructed
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 'As we want the backup filename to be dynamic and include useful information
    such as the current date and hostname on which the backup is being performed,
    we use the `set_fact` module, along with some internal Ansible variables, to define
    a filename for the backup data, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'We then use the `shell` module to run `mysqldump`, with the appropriate parameters
    for creating a backup—going into depth on these is beyond the scope of this book,
    but the following example creates a backup of all databases on your server, without
    locking the tables during the backup:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'The `fetch` module is then used to retrieve the data for archiving—fetch works
    just like the `copy` module that we used earlier in this section, except that
    it copies data in the reverse direction (that is, from the inventory host to the
    Ansible server). Run the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'Running this in the usual manner results in a complete backup of the database,
    with the resulting file being copied to our Ansible server, as the following screenshot
    shows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/58a09392-6801-45a7-bfa7-dc4e2ea207e9.png)'
  prefs: []
  type: TYPE_IMG
- en: 'This example could also be achieved using the `mysql_db` module, just as we
    did before—the `set_fact` and `fetch` tasks remain exactly the same, while the
    `shell` task is replaced with the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: Thus, Ansible can assist you both with loading data into your databases and
    backing it up. As we have discussed previously, it is generally better to use
    the native Ansible modules (such as `mysql_db`) where they are available, but,
    provided you apply the correct logic to it, the `shell` module can assist you,
    if native modules don't exist or provide the functionality you need.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have considered the process of creating databases and loading data
    into them, we will proceed in the next section to demonstrate how to build on
    this work, to perform routine database maintenance with Ansible.
  prefs: []
  type: TYPE_NORMAL
- en: Performing routine maintenance
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Loading schemas and/or data is not the only task you would perform with Ansible
    on a database. Sometimes, manual intervention is required in a database. For example,
    PostgreSQL requires VACUUM operations from time to time, to free up unused space
    in the database. MariaDB has a maintenance tool called `mysqlcheck` that can be
    used to verify the integrity of tables and perform optimization. Each platform
    will have its own specific tools for maintenance operations, and it is up to you
    to establish the best practices for database maintenance on your chosen platform.
    Furthermore, sometimes it is necessary to make simple changes to a database. For
    example, it might be necessary to delete (or update) a row from a table, to clear
    an error situation that has occurred in an application.
  prefs: []
  type: TYPE_NORMAL
- en: Of course, all these activities could be performed manually—however, this (as
    always) brings about the risk of losing track of what happened, who ran a task,
    and how they ran it (for example, which options were provided). If we move this
    example into the world of Ansible and AWX, suddenly we have a complete audit trail
    of activities, and we know exactly what was run and how it was run. Furthermore,
    if special options are required for a task, these will be stored within the playbooks,
    and thus the *self-documentation* that Ansible provides is available here too.
  prefs: []
  type: TYPE_NORMAL
- en: As our examples thus far have been very MariaDB-centric, let's take a look at
    how you might run a full vacuum on a table in PostgreSQL, with Ansible.
  prefs: []
  type: TYPE_NORMAL
- en: Routine maintenance on PostgreSQL with Ansible
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'PostgreSQL is something of a special case on Ansible, as it has more native
    modules to support database activities than most other databases. Let''s consider
    an example case: performing a vacuum on the `sales.creditcard` table in the publicly
    available AdventureWorks sample database (available here: [https://github.com/lorint/AdventureWorks-for-Postgres](https://github.com/lorint/AdventureWorks-for-Postgres)).'
  prefs: []
  type: TYPE_NORMAL
- en: Vacuuming is a PostgreSQL-specific maintenance process and one that you might
    want to consider running on a regular basis, especially if your tables have a
    lot of deletes or modifications. Although a full discussion of this is beyond
    the scope of this book, it is important to consider that tables that are subject
    to these activities can become bloated in size and queries can become slow over
    time, and vacuuming is a way to release unused space and speed up queries again.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, to perform a vacuum on this table by hand, you would log in to the `psql`
    client utility with appropriate credentials, and then run the following commands
    to connect to the database and perform the task:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: In a real enterprise, this would be a task that encompasses many more tables,
    and even databases, but here, we will once again keep the example simple, to demonstrate
    the principles involved. Scaling this up is then left as a task for you to perform.
    Let's automate this, first of all using the `shell` module in Ansible. This is
    a useful example, as this technique will work with most major databases—simply,
    you must establish the command needed for your particular maintenance operation,
    and then run it.
  prefs: []
  type: TYPE_NORMAL
- en: 'A simple role to perform this task would look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'Note—as before—very simple use of the `shell` module with the appropriate command,
    except that, this time, we are using the `become_user` parameter to switch to
    the `postgres` user account, which has superuser rights on the database on the
    host to which we connect. Let''s see what happens when we run this, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/afb8f821-4b31-4674-a91d-3f3a6e1f90f5.png)'
  prefs: []
  type: TYPE_IMG
- en: Naturally, this could be scaled to just about any other database—for example,
    you could use the `mysql` client tool on a MariaDB database, or even run the `mysqlcheck`
    tool, as discussed earlier. The limit really is on what you can script for the
    `shell` module to run, and because Ansible runs the command over SSH on the database
    server itself, you don't need to worry about opening up your database for access
    across the network—it can remain tightly locked down.
  prefs: []
  type: TYPE_NORMAL
- en: In addition to using the `shell` module, Ansible offers us the option to actually
    run queries directly from a module called `postgresql_query`. This is unique,
    though such support could be added for any other database if someone was willing
    to write the module and submit it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Unfortunately for Ansible versions prior to 2.9, it was not possible to extend
    our VACUUM example to this as the `postgresql_query` module runs transactions
    inside a block, and it is not possible to run a VACUUM inside a transaction block.
    If you are running version 2.9 or later, you can now run a VACUUM using example
    code, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: By way of another simple example, we could also use the `postgresql_query` module
    to directly manipulate the database.
  prefs: []
  type: TYPE_NORMAL
- en: 'Suppose that a bug in the application using this database has occurred, and
    an operator must manually insert a credit card number into the database. The SQL
    code to perform this might look something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'We could achieve the same end result in Ansible, using a role that looks like
    the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: Naturally, you would use variables for the data values, and sensitive data like
    this should always be stored in a vault (or, perhaps, entered by hand when the
    role is run).
  prefs: []
  type: TYPE_NORMAL
- en: AWX has a feature called **Surveys**, which presents the user with a series
    of predefined questions to answer before a playbook is run. The answers to these
    questions are stored in Ansible variables— thus, a role such as the preceding
    one could be parameterized, and run from AWX with all the values entered into
    a Survey, negating the need for a vault and concerns over sensitive customer data
    being stored in Ansible.
  prefs: []
  type: TYPE_NORMAL
- en: 'As you can see here, when we run this role, we actually get a changed status
    when the `INSERT` operation is successful—very useful for monitoring such tasks
    and ensuring they have run as desired. The following screenshot shows this role
    being run, and the `changed` status, denoting the successful insertion of data
    into the `sales.creditcard` table:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/118c4804-76c5-4289-be64-5047e307d3a0.png)'
  prefs: []
  type: TYPE_IMG
- en: The world really is your oyster when it comes to database management with Ansible,
    and, regardless of the task required, it is desirable that all database tasks
    be handled in a standardized, repeatable, and auditable manner, just like the
    rest of your Enterprise Linux estate. It is hoped that this chapter has gone some
    way in showing you how to achieve this.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Databases are a core part of the application stack in most enterprises, and
    there is a multitude of databases available on the Linux platform. Although many
    databases have their own management tools, Ansible is well suited to assist with
    a wide array of database management tasks, from the installation of database services
    and loading of initial data or schemas (or even restoring from backups) to handling
    day-to-day maintenance tasks. Combining Ansible's error handling and secure automation,
    there is virtually no limit to the types of database management tasks you can
    perform with Ansible.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, you learned how to use Ansible to install database servers
    in a consistent and repeatable manner. You then learned how to import initial
    data and schemas, and how to extend this to automate backup tasks. Finally, you
    gained hands-on knowledge of some routine database maintenance tasks with Ansible.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will look at how Ansible can assist with the task of
    routine maintenance on your Linux servers.
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Why is it prudent to install and manage your database platform with Ansible?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What are the best practices for database configuration file management with
    Ansible?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How can Ansible help you keep your database secure on the network?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: When would you use the `shell` module instead of a native database module in
    Ansible?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Why would you want to perform routine maintenance with Ansible?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How would you perform a PostgreSQL database backup with Ansible?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Which module would you use to manipulate the users on a MariaDB database?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How is PostgreSQL support unique in Ansible at the present time?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For an in-depth understanding of Ansible, please refer to *Mastering Ansible,
    Third Edition—James Freeman* and *Jesse Keating* ([https://www.packtpub.com/gb/virtualization-and-cloud/mastering-ansible-third-edition](https://www.packtpub.com/gb/virtualization-and-cloud/mastering-ansible-third-edition)).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To learn more about the specifics relating to PostgreSQL database management,
    readers may refer to *Learning PostgreSQL 11, Third Edition—Andrey Volkov, Salahadin
    Juba* ([https://www.packtpub.com/gb/big-data-and-business-intelligence/learning-postgresql-11-third-edition](https://www.packtpub.com/gb/big-data-and-business-intelligence/learning-postgresql-11-third-edition)).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Similarly, to learn more about MariaDB database management, readers can refer
    to *MariaDB Essentials—Federico Razzoli, Emilien Kenler* ([https://www.packtpub.com/gb/application-development/mariadb-essentials](https://www.packtpub.com/gb/application-development/mariadb-essentials)).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For a full list of available Ansible modules, readers should refer to [https://docs.ansible.com/ansible/latest/modules/list_of_database_modules.html.](https://docs.ansible.com/ansible/latest/modules/list_of_database_modules.html)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
