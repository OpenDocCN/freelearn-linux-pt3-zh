- en: '4'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Configuring and Building the Kernel
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The kernel is the third element of embedded Linux. It is the component that
    is responsible for managing resources and interfacing with hardware. As such,
    it affects almost every aspect of your final software build. Each finished kernel
    is usually configured for some specific hardware. However, device trees enable
    us to employ a generic kernel and tailor it for our custom hardware using the
    contents of the DTB, as we saw in [*Chapter 3*](Chapter_03.xhtml#_idTextAnchor061).
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will look at how to get a kernel for a board and how to
    configure and compile it. We will look again at Bootstrap, this time, focusing
    on the part the kernel plays. We will also look at device drivers and how they
    pick up information from the device tree.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: What does the kernel do?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Choosing a kernel
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Configuring the kernel
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Compiling with `Kbuild`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Building and booting the kernel
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Observing the kernel boot process
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Porting Linux to a new board
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To follow along with the examples, make sure you have the following:'
  prefs: []
  type: TYPE_NORMAL
- en: An Ubuntu 24.04 or later LTS-based host system
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A Bootlin `aarch64` toolchain from [*Chapter 2*](Chapter_01.xhtml#_idTextAnchor028)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A microSD card reader and card
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A microSD card with U-Boot installed from [*Chapter 3*](Chapter_03.xhtml#_idTextAnchor061)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A USB to TTL serial cable with 3.3V logic level
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Raspberry Pi 4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The BeaglePlay
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A 5V USB-C power supply capable of delivering 3A
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The code used in this chapter can be found in the chapter folder in this book’s
    GitHub repository: [https://github.com/PacktPublishing/Mastering-Embedded-Linux-Development/tree/main/Chapter04](https://github.com/PacktPublishing/Mastering-Embedded-Linux-Development/tree/main/Chapter04).'
  prefs: []
  type: TYPE_NORMAL
- en: What does the kernel do?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Linux began in 1991 when Linus Torvalds started writing an operating system
    for Intel 386- and 486-based personal computers. He was inspired by the MINIX
    operating system written by Andrew S. Tanenbaum four years earlier. Linux differed
    in many ways from MINIX; the main differences being that it was a 32-bit virtual
    memory kernel, and the code was open source, later released under the GPL v2 license.
    He announced it on 25th August 1991 on the `comp.os.minix` newsgroup in a famous
    post that began with:'
  prefs: []
  type: TYPE_NORMAL
- en: Hello everybody out there using minix—I’m doing a (free) operating system (just
    a hobby, won’t be big and professional like GNU) for 386(486) AT clones. This
    has been brewing since April, and is starting to get ready. I’d like any feedback
    on things people like/dislike in minix, as my OS resembles it somewhat (same physical
    layout of the filesystem (due to practical reasons) among other things).
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: To be strictly accurate, Linus did not write an operating system. He wrote a
    kernel, which is only one component of an operating system. To create a complete
    operating system with user space commands and a shell command interpreter, he
    used components from the GNU project, especially the toolchain, the C library,
    and basic command-line tools. That distinction remains today and gives Linux a
    lot of flexibility in the way it is used.
  prefs: []
  type: TYPE_NORMAL
- en: '**Berkeley Software Distribution** (**BSD**) predates Linux by many years.
    BSD began as a research project at the University of California, Berkeley’s renowned
    Computer Systems Research Group sometime in the late 1970s. Originally known as
    Berkeley Unix, BSD was based on the original Unix source code developed at Bell
    Labs. Now a defunct operating system, BSD lives on in the form of its open source
    descendants including FreeBSD, OpenBSD, and NetBSD. Most notably, the Darwin open
    source operating system used in Apple’s macOS and iOS is a derivative of BSD.'
  prefs: []
  type: TYPE_NORMAL
- en: The Linux kernel can be combined with a GNU user space to create a full Linux
    distribution that runs on desktops and servers, which is sometimes called GNU/Linux.
    It can be combined with an Android user space to create the well-known mobile
    operating system, or it can be combined with a small BusyBox-based user space
    to create a compact embedded system.
  prefs: []
  type: TYPE_NORMAL
- en: Contrast this with the BSD operating systems (FreeBSD, OpenBSD, and NetBSD)
    in which the kernel, toolchain, and user space are combined into a single code
    base. By removing the toolchain, you can deploy slimmer runtime images without
    a compiler or header files. By decoupling user space from the kernel, you gain
    options in terms of init systems (`runit` vs `systemd`), C libraries (`musl` vs
    `glibc`) and package formats (`.apk` vs `.deb`).
  prefs: []
  type: TYPE_NORMAL
- en: 'The kernel has three main jobs – to manage resources, to interface with hardware,
    and to provide an API that offers a useful level of abstraction to user space
    programs, as summarized in the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.1 − User space, kernel space, and hardware](img/B18466_04_01.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.1 − User space, kernel space, and hardware
  prefs: []
  type: TYPE_NORMAL
- en: Applications running in **user space** run at a low CPU privilege level. They
    can do very little other than make library calls. The primary interface between
    user space and **kernel space** is the **C library,** which translates user-level
    functions, such as those defined by POSIX, into kernel system calls. The system
    call interface uses an architecture-specific method, such as a trap or a software
    interrupt, to switch the CPU from low-privilege user mode to high-privilege kernel
    mode. A CPU running in kernel mode has access to all memory addresses and CPU
    registers.
  prefs: []
  type: TYPE_NORMAL
- en: The system call handler dispatches the call to the appropriate kernel subsystem.
    Memory allocation calls go to the memory manager, filesystem calls to the filesystem
    code, and so on. Some of those calls require input from the underlying hardware
    and will be passed down to a device driver. In some cases, the hardware itself
    invokes a kernel function by raising an interrupt.
  prefs: []
  type: TYPE_NORMAL
- en: '**IMPORTANT NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: 'The diagram in *Figure 4.1* shows that there is a second entry point into kernel
    code: hardware interrupts. Interrupts can only be handled in a device driver,
    never by a user space application.'
  prefs: []
  type: TYPE_NORMAL
- en: In other words, all the useful things that your application does are done through
    the kernel. The kernel is therefore one of the most important elements in the
    system. So, it is important to understand how to choose one.
  prefs: []
  type: TYPE_NORMAL
- en: Choosing a kernel
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The next step is to choose the kernel for your project. It is important to balance
    your desire to always use the latest version of software against the need for
    vendor-specific additions and an interest in the long-term support of the code
    base.
  prefs: []
  type: TYPE_NORMAL
- en: Kernel development cycle
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Linux is developed at a fast pace with a new version being released every 8
    to 12 weeks. The way that the version numbers are constructed has changed over
    the years. Before July 2011, there was a three-number version scheme with version
    numbers that looked like 2.6.39\. The middle number indicated whether it was a
    developer or stable release. Odd numbers (2.1.x, 2.3.x, 2.5.x) were for developers.
    Even numbers were for end users.
  prefs: []
  type: TYPE_NORMAL
- en: From version 2.6 onward, the idea of a long-lived development branch (the odd
    numbers) was dropped, as it slowed down the rate at which new features were made
    available to the users. The change in numbering from 2.6.39 to 3.0 in July 2011
    was purely because Linus felt that the numbers were becoming too large.
  prefs: []
  type: TYPE_NORMAL
- en: 'There was no huge leap in the features or architecture of Linux between those
    two versions. He also took the opportunity to drop the middle number. Since then,
    Linus has bumped the major version three more times: next in April 2015 (3 to
    4), again in March 2019 (4 to 5), and most recently, in October 2022 (5 to 6).
    Each time, he did this purely for neatness, not because of any large architectural
    shift.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Linus manages the development kernel tree. You can follow him by cloning the
    Git tree like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: This will check the source out into a subdirectory named `linux`. You can keep
    up to date by running the command `git pull` in that directory from time to time.
  prefs: []
  type: TYPE_NORMAL
- en: A full cycle of kernel development begins with a merge window of two weeks during
    which Linus will accept patches for new features. At the end of the merge window,
    a stabilization phase begins. Once the merge window closes, Linus will produce
    weekly release candidates with version numbers ending in `-rc1`, `-rc2`, and so
    on, usually up to `-rc7` or `-rc8`. During this time, people test the candidates
    and submit bug reports and fixes. When all significant bugs have been fixed, the
    kernel is released.
  prefs: []
  type: TYPE_NORMAL
- en: The code incorporated during the merge window needs to be fairly mature already.
    Usually, it is pulled from the repositories of the many subsystems and architecture
    maintainers of the kernel. By keeping to a short development cycle, features can
    be merged when they are ready. If a feature is deemed not sufficiently stable
    or well developed by the kernel maintainers, it can simply be delayed until the
    next release.
  prefs: []
  type: TYPE_NORMAL
- en: Keeping track of what has changed from release to release is not easy. You can
    read the commit log in Linus’ Git repository but, with so many entries, it is
    not easy to get an overview. Thankfully, there is the Linux **Kernel Newbies**
    website ([https://kernelnewbies.org](https://kernelnewbies.org)) where you can
    find a succinct overview of each version at [https://kernelnewbies.org/LinuxVersions](https://kernelnewbies.org/LinuxVersions).
  prefs: []
  type: TYPE_NORMAL
- en: Stable and long-term support releases
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The rapid rate of change of Linux is a good thing in that it brings new features
    into the mainline code base, but it does not fit very well with the longer life
    cycle of embedded projects. Kernel developers address this in two ways: stable
    releases and long-term releases. After the release of a mainline kernel (maintained
    by Linus Torvalds), it is moved to the **stable** tree (maintained by Greg Kroah-Hartman).
    Bug fixes are applied to the stable kernel while the mainline kernel begins the
    next development cycle.'
  prefs: []
  type: TYPE_NORMAL
- en: Point releases of the stable kernel are marked by a third number (3.18.1, 3.18.2,
    and so on). Before version 3, there were four release numbers (2.6.29.1, 2.6.39.2,
    and so on).
  prefs: []
  type: TYPE_NORMAL
- en: 'You can get the stable tree by using the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'You can use `git` `checkout` to get a particular version like 6.6.46:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: The stable kernel is usually updated only until the next mainline release (8
    to 12 weeks later) so you will see that there are just one or sometimes two stable
    kernels at [https://www.kernel.org/](https://www.kernel.org/). To cater to those
    users who would like updates for longer, some kernels are labeled **long-term**
    and maintained for two or more years. Long-term kernels come with the assurance
    that any bugs will be found and fixed. There is at least one long-term kernel
    release each year.
  prefs: []
  type: TYPE_NORMAL
- en: 'Looking at [https://www.kernel.org/](https://www.kernel.org/) in August of
    2024, there are a total of six long-term kernels: 6.6, 6.1, 5.15, 5.10, 5.4, and
    4.19\. The oldest has been maintained for nearly six years and is at version 4.19.319\.
    If you are building a product that you will have to maintain for this length of
    time, then the latest long-term kernel might well be a good choice.'
  prefs: []
  type: TYPE_NORMAL
- en: Vendor support
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In an ideal world, you would be able to download a kernel from [https://www.kernel.org/](https://www.kernel.org/)
    and configure it for any device that claims to support Linux. However, that is
    not always possible. In fact, mainline Linux has solid support for only a small
    subset of the many devices that can run Linux. You may find support for your board
    or SoC from independent open source projects like Linaro ([https://www.linaro.org/](https://www.linaro.org/))
    or The Yocto Project ([https://www.yoctoproject.org/](https://www.yoctoproject.org/)).
    There are some companies that offer paid third-party support for embedded Linux.
    But in many cases, you will be obliged to look to the vendor of your SoC or board
    for a working kernel.
  prefs: []
  type: TYPE_NORMAL
- en: As we know, some vendors are better at supporting Linux than others. My advice
    at this point is to choose vendors who give good support or, even better, who
    take the trouble to get their kernel changes into the mainline. Search the Linux
    kernel mailing list or commit history for recent activity around a candidate SoC
    or board. When upstream changes are absent from the mainline kernel, the verdict
    as to whether a vendor offers good support is largely based on word of mouth.
    Some vendors are notorious for releasing only one kernel code drop before redirecting
    all their energies toward their newer SoCs.
  prefs: []
  type: TYPE_NORMAL
- en: Licensing
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The Linux source code is licensed under GPL v2\. That means you must make the
    source code of your kernel available in one of the ways specified in the license.
  prefs: []
  type: TYPE_NORMAL
- en: The actual text of the license for the kernel is in the file `COPYING`. It begins
    with an addendum written by Linus that states that code calling the kernel from
    user space via the system call interface is not considered a derivative work of
    the kernel and so is not covered by the license. Hence, there is no problem with
    proprietary applications running on top of Linux.
  prefs: []
  type: TYPE_NORMAL
- en: 'However, there is one area of Linux licensing that causes endless confusion
    and debate: kernel modules. A **kernel module** is simply a piece of code that
    is dynamically linked with the kernel at runtime thereby extending the functionality
    of the kernel. The **General Public License** (**GPL**) makes no distinction between
    static and dynamic linking, so it would appear that the source for kernel modules
    is covered by the GPL. In the early days of Linux, there were debates about exceptions
    to this rule, for example, in connection with the **Andrew File System** (**AFS**).
    This code predates Linux and, therefore (it was argued), is not a derivative work
    so the license does not apply.'
  prefs: []
  type: TYPE_NORMAL
- en: Similar discussions took place over the years with respect to other pieces of
    code with the result that it is now accepted practice that the GPL does not necessarily
    apply to kernel modules. This is codified by the kernel `MODULE_LICENSE` macro,
    which may take the value `Proprietary` to indicate that it is not released under
    the GPL. If you plan to use the same arguments yourself, you may want to read
    through an oft-quoted email thread titled *Linux GPL and binary module exception
    clause?*, which is archived at [https://yarchive.net/comp/linux/gpl_modules.html](https://yarchive.net/comp/linux/gpl_modules.html).
  prefs: []
  type: TYPE_NORMAL
- en: The GPL should be considered a good thing because it guarantees that when we
    are working on embedded projects, we can always get the source code for the kernel.
    Without it, embedded Linux would be much harder to use and more fragmented.
  prefs: []
  type: TYPE_NORMAL
- en: Best practices
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: That said, to choose a kernel, you need to weigh the benefits of using the latest
    version against the need for vendor-specific enhancements and driver stability.
    Also, the rapid Linux development cycle allows features to be integrated quickly,
    with stable and long-term support releases available for extended maintenance.
    The long-term kernels, which receive updates for over two years, are ideal for
    long-term projects. Vendor support is also crucial, so make sure to choose vendors
    who actively support Linux and contribute to the mainline kernel. Lastly, licensing
    under GPL v2 ensures access to the kernel source code, which makes it easier to
    use and maintain for embedded projects.
  prefs: []
  type: TYPE_NORMAL
- en: Configuring the kernel
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Having decided which kernel to base your image on, the next step is configuring
    the kernel.
  prefs: []
  type: TYPE_NORMAL
- en: Getting the source
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: All three of the targets used in this book (Raspberry Pi 4, BeaglePlay, and
    QEMU) are well supported by the mainline kernel. Therefore, it makes sense to
    use the latest long-term kernel available from [https://www.kernel.org/](https://www.kernel.org/),
    which, at the time of writing, was 6.6.46\. When you come to do this for yourself,
    you should check to see if there is a later version of the 6.6 kernel and use
    that instead since it will have fixes for bugs found after 6.6.46 was released.
  prefs: []
  type: TYPE_NORMAL
- en: '**IMPORTANT NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: If there is a later long-term release, you may want to consider using that one.
    However, be aware that there may have been changes that mean that the following
    sequence of commands does not work exactly as given.
  prefs: []
  type: TYPE_NORMAL
- en: 'To fetch and extract a release tarball of the 6.6.46 Linux kernel, use the
    following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: To fetch a later version, replace `6.6.46` after `linux-` with the desired long-term
    release.
  prefs: []
  type: TYPE_NORMAL
- en: 'There is a lot of code here. There are over 81,000 files in the 6.6 kernel
    containing C source code, header files, and assembly code amounting to a total
    of over 24 million lines of code as measured by the SLOCCount utility. Nevertheless,
    it is worth knowing the basic layout of the code and approximately where to look
    for a particular component. The main directories of interest are:'
  prefs: []
  type: TYPE_NORMAL
- en: '`arch`: Contains architecture-specific files. There is one subdirectory per
    architecture.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Documentation`: Contains kernel documentation. Always look here first if you
    want to find more information about an aspect of Linux.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`drivers`: Contains device drivers, thousands of them. There is a subdirectory
    for each type of driver.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`fs`: Contains filesystem code.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`include`: Contains kernel header files including those required when building
    the toolchain.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`init`: Contains the kernel start-up code.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`kernel`: Contains core functions including scheduling, locking, timers, power
    management, and debug/trace code.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`mm`: Contains memory management.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`net`: Contains network protocols.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`scripts`: Contains many useful scripts including the device tree compiler,
    which I described in [*Chapter 3*](Chapter_03.xhtml#_idTextAnchor061).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`tools`: Contains many useful tools including the Linux performance counters
    tool (`perf`), which I will describe in [*Chapter 20*](Chapter_16.xhtml#_idTextAnchor538).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Over time, you will become familiar with this structure and realize that if
    you are looking for the serial port code of a particular SoC, you will find it
    in `drivers/tty/serial` and not in `arch/$ARCH/mach-foo` because it is a device
    driver and not something CPU architecture-specific.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding kernel configuration– Kconfig
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: One of the strengths of Linux is the degree to which you can configure the kernel
    to suit different jobs, from a small, dedicated device such as a smart thermostat
    to a complex mobile handset. In current versions, there are many thousands of
    configuration options. Getting the configuration right is a task in itself, but
    before we get into that, I want to show you how it works so that you can better
    understand what is going on.
  prefs: []
  type: TYPE_NORMAL
- en: The configuration mechanism is called `Kconfig`, and the build system that it
    integrates with is called `Kbuild`. Both are documented in `Documentation/kbuild`.
    `Kconfig`/`Kbuild` is used in a number of other projects besides the kernel including
    Crosstool-NG, U-Boot, Barebox, and BusyBox.
  prefs: []
  type: TYPE_NORMAL
- en: The configuration options are declared in a hierarchy of files named `Kconfig`
    using a syntax described in `Documentation/kbuild/kconfig-language.rst`.
  prefs: []
  type: TYPE_NORMAL
- en: 'In Linux, the top-level `Kconfig` looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'And the first line of `arch/Kconfig` is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: That line includes the architecture-dependent configuration file, which sources
    other `Kconfig` files depending on which options are enabled.
  prefs: []
  type: TYPE_NORMAL
- en: 'Having the architecture play such a prominent role has three implications:'
  prefs: []
  type: TYPE_NORMAL
- en: First, you must specify an architecture when configuring Linux by setting `ARCH=<architecture>`;
    otherwise, it will default to the local machine architecture.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Second, the value you set for `ARCH` usually determines the value of `SRCARCH`
    so you rarely need to set `SRCARCH` explicitly.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Third, the layout of the top-level menu is different for each architecture.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The value you put into `ARCH` is one of the subdirectories you find in the directory
    `arch` with the oddity that `ARCH=i386` and `ARCH=x86_64` both source `arch/x86/Kconfig`.
  prefs: []
  type: TYPE_NORMAL
- en: The `Kconfig` files consist largely of menus delineated by the `menu` and `endmenu`
    keywords. Menu items are marked by the keyword `config`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is an example taken from `drivers/char/Kconfig`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'The parameter following `config` names a variable, which, in this case, is
    `DEVMEM`. Since this option is a `bool` (Boolean), it can only have two values:
    if it is enabled, it is assigned `y`, and if it is not enabled, the variable is
    not defined at all. The name of the menu item that is displayed on the screen
    is the string following the `bool` keyword.'
  prefs: []
  type: TYPE_NORMAL
- en: This configuration item, along with all the others, is stored in a file named
    `.config`.
  prefs: []
  type: TYPE_NORMAL
- en: '**TIP**'
  prefs: []
  type: TYPE_NORMAL
- en: The leading dot (`.`) in `.config` means that it is a hidden file that will
    not be shown by the `ls` command unless you type `ls -a` to show all files.
  prefs: []
  type: TYPE_NORMAL
- en: 'The line corresponding to this configuration item reads:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'There are several other data types in addition to `bool`. Here is the complete
    list:'
  prefs: []
  type: TYPE_NORMAL
- en: '`bool`: Either `y` or not defined.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`tristate`: Used where a feature can be built as a kernel module or built into
    the main kernel image. The values are `m` for a module, `y` to be built in, and
    not defined if the feature is not enabled.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`int`: An integer value using decimal notation.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`hex`: An unsigned integer value using hexadecimal notation.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`string`: A string value.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'There may be dependencies between items expressed by the `depends on` construct,
    as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: If `CONFIG_MTD` has not been enabled elsewhere, this menu option is not shown
    and so cannot be selected.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are also reverse dependencies. The `select` keyword enables other options
    if this one is enabled. The `Kconfig` file in `arch/$ARCH` has numerous `select`
    statements that enable features specific to the architecture, as seen here for
    Arm:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: By selecting `ARCH_CLOCKSOURCE_DATA` and `ARCH_HAS_DEVMEM_IS_ALLOWED`, we are
    assigning a value of `y` to these variables so that these features are built statically
    into the kernel.
  prefs: []
  type: TYPE_NORMAL
- en: There are several configuration utilities that can read the `Kconfig` files
    and produce a `.config` file. Some of them display the menus on the screen and
    allow you to make choices interactively. `menuconfig` is probably the one most
    people are familiar with but there are also `xconfig` and `gconfig`.
  prefs: []
  type: TYPE_NORMAL
- en: 'To use `menuconfig`, you first need to have `ncurses`, `flex`, and `bison`
    installed. The following command installs all these prerequisites on Ubuntu:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'You launch `menuconfig` via the `make` command, remembering that, in the case
    of the kernel, you need to supply an architecture, as illustrated here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Make sure that your `PATH` variable points to the 64-bit toolchain you downloaded
    back in [*Chapter 2*](Chapter_01.xhtml#_idTextAnchor028).
  prefs: []
  type: TYPE_NORMAL
- en: 'Here you can see `menuconfig` with the `DEVMEM` config option highlighted previously:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.2 − Selecting DEVMEM](img/B18466_04_02.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.2 − Selecting DEVMEM
  prefs: []
  type: TYPE_NORMAL
- en: The star (`*`) to the left of an item means that the driver has been selected
    to be built statically into the kernel. If it is an `M`, then it has been selected
    to be built as a kernel module for insertion into the kernel at runtime.
  prefs: []
  type: TYPE_NORMAL
- en: '**TIP**'
  prefs: []
  type: TYPE_NORMAL
- en: You often see instructions like enable `CONFIG_BLK_DEV_INITRD` but, with so
    many menus to browse through, it can take a while to find the place where that
    configuration is set. All configuration editors have a search function. You can
    access it in `menuconfig` by pressing the forward slash key */*. In `xconfig`,
    it is in the **Edit** menu but make sure you leave off the `CONFIG_` part of the
    configuration item you are searching for.
  prefs: []
  type: TYPE_NORMAL
- en: With so many things to configure, it is unreasonable to start with a clean sheet
    each time you want to build a kernel, so there are a set of known working configuration
    files in `arch/$ARCH/configs`, each containing suitable configuration values for
    a single SoC or a group of SoCs.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can select one with the `make <configuration file name>` command. For example,
    to configure Linux to run on a wide range of 64-bit Arm SoCs, you would type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: This is a generic kernel that runs on various boards. For a more specialized
    application, like when using a vendor-supplied kernel, the default configuration
    file is part of the board support package. You will need to find out which one
    to use before you can build the kernel.
  prefs: []
  type: TYPE_NORMAL
- en: There is another useful configuration target named `oldconfig`. You use it when
    moving a configuration to a new kernel version. This target takes an existing
    `.config` file and prompts you with questions about new configuration options.
    Copy `.config` from the old kernel to the new source directory and run the `make
    ARCH=arm64 oldconfig` command to bring it up to date.
  prefs: []
  type: TYPE_NORMAL
- en: The `oldconfig` target can also be used to validate a `.config` file that you
    have edited manually (ignoring the text *Automatically generated file; DO NOT
    EDIT* that occurs at the top).
  prefs: []
  type: TYPE_NORMAL
- en: If you do make changes to the configuration, then the modified `.config` file
    becomes part of your board support package and needs to be placed under source
    code control.
  prefs: []
  type: TYPE_NORMAL
- en: When you start the kernel build, a header file named `include/generated/autoconf.h`
    is generated. This header file contains a `#define` for each configuration value
    so that it can be included in the kernel source.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have settled on a kernel and learned how to configure it, we will
    identify it.
  prefs: []
  type: TYPE_NORMAL
- en: Using LOCALVERSION to identify your kernel
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'You can discover the kernel version and release that you have built using the
    `make kernelversion` and `make kernelrelease` targets:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: This is reported at runtime through the `uname` command and is also used in
    naming the directory where kernel modules are stored.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you change the configuration from the default, it is advisable to append
    your version information, which you can configure by setting `CONFIG_LOCALVERSION`
    using `menuconfig`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'For example, if I wanted to mark the kernel I am building with the identifier
    `meld` and version `1.0`, then I would define the local version in `menuconfig`
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.3 – Appending to kernel release version](img/B18466_04_03.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.3 – Appending to kernel release version
  prefs: []
  type: TYPE_NORMAL
- en: Exit out of `menuconfig` and choose **Yes** when asked to save your new configuration.
  prefs: []
  type: TYPE_NORMAL
- en: 'Run `make prepare` to refresh the `Makefile` with the new `kernelrelease` version:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Running `make kernelversion` produces the same output as before, but if I run
    `make kernelrelease` now, I see:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: That was a pleasant detour into kernel versioning, but now let’s get back to
    the business of configuring our kernel for compilation.
  prefs: []
  type: TYPE_NORMAL
- en: When to use kernel modules
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: I have mentioned kernel modules several times already. Desktop Linux distributions
    use them extensively so that the correct device and kernel functions can be loaded
    at runtime depending on the hardware detected and features required. Without them,
    every single driver and feature would have to be statically linked into the kernel,
    making it infeasibly large.
  prefs: []
  type: TYPE_NORMAL
- en: On the other hand, with embedded devices, the hardware and kernel configuration
    is usually known at the time the kernel is built; therefore, modules are not so
    useful. In fact, they cause a problem because they create a version dependency
    between the kernel and the root filesystem, which can cause boot failures if one
    is updated but not the other. Consequently, it is quite common for embedded kernels
    to be built without any modules at all.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are a few cases where kernel modules are a good idea in embedded systems:'
  prefs: []
  type: TYPE_NORMAL
- en: When you have proprietary modules, for the licensing reasons given in the preceding
    section.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To reduce boot time by deferring the loading of non-essential drivers.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When there are several drivers to potentially load and it would take up too
    much memory to compile them statically. For example, you have a USB interface
    that supports a range of devices. This is essentially the same argument used in
    desktop distributions.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Next, let’s learn how to compile a kernel image with or without kernel modules
    using `Kbuild`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Compiling with Kbuild
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The kernel build system (`Kbuild`) is a set of `make` scripts that take the
    configuration information from the `.config` file, work out the dependencies,
    and compile everything necessary to produce a kernel image. This kernel image
    contains all the statically linked components, an optional device tree binary,
    and any kernel modules. The dependencies are expressed within Makefiles inside
    each directory with buildable components. For instance, the following two lines
    are taken from `drivers/char/Makefile`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: The `obj-y` rule unconditionally compiles a file to produce the target, so `mem.c`
    and `random.c` are always part of the kernel. In the second line, `ttyprintk.c`
    is dependent on a configuration parameter. If `CONFIG_TTY_PRINTK` is `y`, then
    it is compiled as a built-in. If it is `m`, then it is built as a module. If the
    parameter is undefined, then it is not compiled at all.
  prefs: []
  type: TYPE_NORMAL
- en: For most targets, just typing `make` (with the appropriate `ARCH` and `CROSS_COMPILE`)
    will do the job, but it is instructive to take it one step at a time. See the
    last section of [*Chapter 2*](Chapter_01.xhtml#_idTextAnchor028) for the meaning
    of the `CROSS_COMPILE` `make` variable.
  prefs: []
  type: TYPE_NORMAL
- en: Finding out which kernel target to build
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To build a kernel image, you need to know what your bootloader expects. This
    is a rough guide:'
  prefs: []
  type: TYPE_NORMAL
- en: '**U-Boot**: Can load a compressed `Image.gz` file for 64-bit Arm. Can also
    load a self-extracting `zImage` file for 32-bit Arm using the `bootz` command.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**x86 targets**: Require a `bzImage` file.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Most other bootloaders**: Require a `zImage` file.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Here is an example of building an `Image.gz` file for 64-bit Arm:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Make sure that your `PATH` variable points to the 64-bit toolchain you downloaded
    back in [*Chapter 2*](Chapter_01.xhtml#_idTextAnchor028).
  prefs: []
  type: TYPE_NORMAL
- en: '**IMPORTANT NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: 'The first time you run `make` on the kernel source tree, you may be prompted
    to include or omit various features, options, and plugins. Most of these features
    and options offer increased security so there is no harm in adding them. There
    is one notable exception. When prompted for GCC plugins, make sure to enter `n`
    for no as shown:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Otherwise, the build will fail because `make` cannot find `g++`.
  prefs: []
  type: TYPE_NORMAL
- en: Remember to replace `<n>` after `make -j` with the number of CPU cores available
    on your host machine to speed up your build.
  prefs: []
  type: TYPE_NORMAL
- en: '**TIP**'
  prefs: []
  type: TYPE_NORMAL
- en: The `-j<n>` option tells `make` how many jobs to run in parallel, which reduces
    the time it takes to build. `make -j4` runs four jobs. A rough guide is to run
    as many jobs as you have CPU cores.
  prefs: []
  type: TYPE_NORMAL
- en: The AArch64 kernel does not currently provide a decompressor and, therefore,
    requires decompression (`gzip`, etc.) to be performed by the bootloader if a compressed
    `Image` target (e.g., `Image.gz`) is used.
  prefs: []
  type: TYPE_NORMAL
- en: Regardless of which kernel image format we target, the same two build artifacts
    (`vmlinux` and `System.map`) are first created before the bootable image is generated.
  prefs: []
  type: TYPE_NORMAL
- en: Build artifacts
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A kernel build generates two files in the top-level directory: `vmlinux` and
    `System.map`. The first, `vmlinux`, is the kernel as an ELF binary. If you have
    compiled your kernel with debug enabled (`CONFIG_DEBUG_INFO=y`), it will contain
    debug symbols that can be used with debuggers like `kgdb`. You can also use other
    ELF binary tools, such as `size` to measure the length of each segment (`text`,
    `data`, and `bss`) that comprises the `vmlinux` executable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: A program like the kernel is divided into segments in memory. The `text` segment
    contains executable instructions (code). The `data` segment contains initialized
    global and static variables. The `bss` segment contains uninitialized global and
    static variables. The `dec` and `hex` values are the total file size in decimal
    and hexadecimal, respectively.
  prefs: []
  type: TYPE_NORMAL
- en: '`System.map` contains the symbol table in human-readable form.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Most bootloaders cannot handle ELF code directly. There is a further stage
    of processing that takes `vmlinux` and places binaries that are suitable for the
    various bootloaders in `arch/$ARCH/boot`:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Image`: `vmlinux` converted to raw binary format.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`zImage`: For the PowerPC architecture, this is just a compressed version of
    `Image`, implying that the bootloader must do the decompression. For all other
    architectures, the compressed `Image` is piggybacked onto a stub of code that
    decompresses and relocates it.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`uImage`: `zImage` plus a 64-byte U-Boot header.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'While the build is running, you will see a summary of the commands being executed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'When the kernel build fails, it is sometimes useful to see the actual commands
    being executed. To do that, add `V=1` to the command line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: In this section, we learned how `Kbuild` takes a precompiled `vmlinux` ELF binary
    and converts it into a bootable kernel image. Next, we will look at how we can
    compile device trees.
  prefs: []
  type: TYPE_NORMAL
- en: Compiling device trees
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: The compiled `.dtb` files are generated in the `../build_arm64` output directory.
  prefs: []
  type: TYPE_NORMAL
- en: Compiling modules
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'If you have configured some features to be built as modules, then you can build
    them separately using the `modules` target:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: Replace `<n>` after `make -j` with the number of CPU cores available on your
    host machine to speed up your build.
  prefs: []
  type: TYPE_NORMAL
- en: The compiled modules have a `.ko` suffix and are generated in the same directory
    as the source code, meaning that they are scattered all around the kernel source
    tree. Finding them is a little tricky, but you can use the `modules_install` target
    to install them in the right place.
  prefs: []
  type: TYPE_NORMAL
- en: 'The default location is `/lib/modules` in your development system, which is
    almost certainly not what you want. To install them into the staging area of your
    root filesystem, provide the path using `INSTALL_MOD_PATH`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: Kernel modules are put into the directory `/lib/modules/<kernel version>` relative
    to the root of the filesystem.
  prefs: []
  type: TYPE_NORMAL
- en: Cleaning kernel sources
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'There are three make targets for cleaning the kernel source tree:'
  prefs: []
  type: TYPE_NORMAL
- en: '**clean**: Removes object files and most intermediates.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**mrproper**: Removes all intermediate files including the `.config` file.
    Use this target to return the source tree to the state it was in immediately after
    cloning or extracting the source code. Mr. Proper is a cleaning product common
    in some parts of the world. The purpose of `make mrproper` is to give the kernel
    sources a really good scrub.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**distclean**: This is the same as `mrproper` but also deletes editor backup
    files, patch files, and other artifacts of software development.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Building and booting the kernel
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Building and booting Linux is highly device-dependent. In this section, I will
    show you how it works for the Raspberry Pi 4, BeaglePlay, and QEMU. For other
    target boards, you must consult the information from the vendor or from the community
    project if there is one.
  prefs: []
  type: TYPE_NORMAL
- en: Building a kernel for the Raspberry Pi 4
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Even though there is support for the Raspberry Pi 4 in the mainline kernel,
    I prefer to use the Raspberry Pi Foundation’s fork of Linux ([https://github.com/raspberrypi/linux](https://github.com/raspberrypi/linux))
    for stability. 6.6 was the latest long-term kernel supported by that fork in August
    2024, so that is the version we shall build.
  prefs: []
  type: TYPE_NORMAL
- en: Since the Raspberry Pi 4 has a 64-bit quad-core Arm Cortex-A72 CPU, we will
    use the Bootlin toolchain from [*Chapter 2*](Chapter_01.xhtml#_idTextAnchor028)*,*
    to cross-compile a 64-bit kernel for it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Install a package we need to build the kernel:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that you have the requisite toolchain and packages installed, clone the
    `6.6.y` branch of the kernel repo one-level deep to a directory named `linux-rpi`
    and export some prebuilt binaries to a `boot` subdirectory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: The `--depth=n` argument instructs Git to fetch only the last `n` commits when
    cloning.
  prefs: []
  type: TYPE_NORMAL
- en: 'Navigate to the newly cloned `linux-rpi` directory and build the kernel:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: Replace `<n>` after `make -j` with the number of CPU cores available on your
    host machine to speed up your build.
  prefs: []
  type: TYPE_NORMAL
- en: 'When the build finishes, copy the kernel image, device tree blobs, and boot
    parameters to the boot subdirectory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding commands are all found in the script `MELD/Chapter04/build-linux-rpi4.sh`.
    Note that the kernel command line written to `cmdline.txt` must be all on one
    line. Let’s break these steps down into stages:'
  prefs: []
  type: TYPE_NORMAL
- en: Clone the `rpi-6.6.y` branch of the Raspberry Pi Foundation’s kernel fork into
    a `linux-rpi` directory.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Clone the `1.20240529` tag of the Raspberry Pi Foundation’s firmware rep into
    a `firmware-rpi` directory.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Move the `boot` subdirectory from the Raspberry Pi Foundation’s `firmware` repo
    to a `boot` directory.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Delete the existing kernel image[s], device tree blobs, and device tree overlays
    from the `boot` directory.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: From the `linux-rpi` directory, build the 64-bit kernel, modules, and device
    tree for the Raspberry Pi 4.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Copy the newly-built kernel image, device tree blobs, and device tree overlays
    from ./build_rpi/`arch/arm64/boot` to the `boot` directory.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Write `config.txt` and `cmdline.txt` files out to the `boot` directory for the
    Raspberry Pi 4’s bootloader to read and pass to the kernel.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Let’s look at the settings in `config.txt`. The `enable_uart=1` line enables
    the serial console during boot, which is disabled by default. The `arm_64bit=1`
    line instructs the Raspberry Pi 4’s bootloader to start the CPU in 64-bit mode
    and load the kernel image from a file named `kernel8.img`.
  prefs: []
  type: TYPE_NORMAL
- en: Now, let’s look at `cmdline.txt`. The `console=serial0,115200` and `console=tty1`
    kernel command-line parameters instruct the kernel to output log messages to the
    serial console as our kernel boots.
  prefs: []
  type: TYPE_NORMAL
- en: Booting the Raspberry Pi 4
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Raspberry Pi devices use a proprietary bootloader provided by Broadcom instead
    of U-Boot. Unlike previous Raspberry Pi models, the Raspberry Pi 4’s bootloader
    resides on an onboard SPI EEPROM rather than on a microSD card. We still need
    to put the kernel image and device tree blobs for the Raspberry Pi 4 on a microSD
    to boot our 64-bit kernel.
  prefs: []
  type: TYPE_NORMAL
- en: Before proceeding, you need a microSD card with a FAT32 `boot` partition large
    enough to hold the necessary kernel build artifacts. The `boot` partition needs
    to be the first partition on the microSD card. A partition size of 1 GB is sufficient.
  prefs: []
  type: TYPE_NORMAL
- en: For guidance on connecting a USB-to-TTL serial cable to the Raspberry Pi 4,
    see [https://learn.adafruit.com/adafruits-raspberry-pi-lesson-5-using-a-console-cable/connect-the-lead](https://learn.adafruit.com/adafruits-raspberry-pi-lesson-5-using-a-console-cable/connect-the-lead).
  prefs: []
  type: TYPE_NORMAL
- en: 'To prepare a microSD card with your newly built kernel image and boot it on
    your Raspberry Pi 4:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, navigate one level above the `boot` directory:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Next, insert the microSD card into your card reader and copy the entire contents
    of the `boot` directory to the `boot` partition.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Unmount the card and insert it into the Raspberry Pi 4.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Connect your USB-to-TTL serial cable to the GND, TXD, and RXD pins on the 40-pin
    GPIO header.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Start a terminal emulator like `gtkterm`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Lastly, power on the Raspberry Pi 4.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'You should see the following output on the serial console:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: The sequence will end in a kernel panic because the kernel cannot locate a root
    filesystem on the microSD card. I’ll explain what a kernel panic is later in this
    chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Building a kernel for the BeaglePlay
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Here is the sequence of commands to build a kernel, modules, and device tree
    for the BeaglePlay:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, add the 64-bit Arm toolchain to your `PATH` if you haven’t already:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, navigate back to the mainline Linux source tree:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Set the `ARCH` and `CROSS_COMPILE` environment variables for 64-bit Arm:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Run `make defconfig` to configure a kernel suitable for most 64-bit Arm SoCs:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Run `make menuconfig` to continue configuring the kernel:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Drill down into the **General architecture-dependent options** submenu.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Deselect **GCC plugins** if it is set.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Back out of the **General architecture-dependent options** submenu.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Drill down into the **Platform selection** submenu.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Deselect support for all SoCs except for **Texas Instruments Inc. K3 multicore
    SoC architecture**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Back out of the **Platform selection** submenu.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Drill down into the **Device drivers** | **Graphics support** submenu
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Deselect **Direct Rendering Manager**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Back out of the **Graphics support** and **Device drivers** submenus.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Exit out of `menuconfig` and choose **Yes** when asked to save your new configuration.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Lastly, build a kernel, modules, and device tree for the BeaglePlay:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Replace `<n>` after `make -j` with the number of CPU cores available on your
    host machine to speed up your build.
  prefs: []
  type: TYPE_NORMAL
- en: Booting the BeaglePlay
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Before proceeding, you need a microSD card with U-Boot installed, as described
    in the section titled *Installing U-Boot* from [*Chapter 3*](Chapter_03.xhtml#_idTextAnchor061):'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, navigate one level above the `build_beagleplay` directory:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Next, insert the microSD card into your card reader and copy the `build_beagleplay/arch/arm64/boot/Image.gz`
    and `build_beagleplay/arch/arm64/boot/dts/ti/k3-am625-beagleplay.dtb` files to
    the FAT32 `boot` partition.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Unmount the card and insert it into the BeaglePlay.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Start a terminal emulator like `gtkterm` and be prepared to press the spacebar
    as soon as you see the U-Boot messages appear.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Power on the BeaglePlay while holding down the USR button and press the spacebar.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Lastly, enter the following commands at the U-Boot prompt:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'You should see the following output on the serial console:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: Note that we set the kernel command line to `console=ttyS2`. That tells Linux
    which UART device to use for console output. Without this, we would not see any
    messages after `Starting the kernel...` and so would be unable to tell if it was
    working or not. The sequence ends in a kernel panic, just as it did for the Raspberry
    Pi 4.
  prefs: []
  type: TYPE_NORMAL
- en: Building a kernel for QEMU
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Here is the sequence of commands to build Linux for the `virt` generic virtual
    platform emulated by QEMU:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, add the 64-bit Arm toolchain to your `PATH` if you haven’t already:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, navigate back to the mainline Linux source tree:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Set the `ARCH` and `CROSS_COMPILE` environment variables for 64-bit Arm:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Run `make defconfig` to configure a kernel suitable for most 64-bit Arm SoCs:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Run `make menuconfig` to continue configuring the kernel:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Drill down into the **Platform selection** submenu.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Deselect support for all SoCs except for **ARMv8 software model (Versatile Express)**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Back out of the **Platform selection** submenu.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select **ACPI (Advanced Configuration and Power Interface) Support**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Exit out of `menuconfig` and choose **Yes** when asked to save your new configuration.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Lastly, build a kernel, modules, and device tree for QEMU:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Replace `<n>` after `make -j` with the number of CPU cores available on your
    host machine to speed up your build.
  prefs: []
  type: TYPE_NORMAL
- en: Booting QEMU
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Assuming that you have already installed `qemu-system-aarch64`, you can launch
    QEMU from the mainline kernel source tree as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: As with the Raspberry Pi 4 and BeaglePlay, this will end with a kernel panic
    and the system will halt. To exit from QEMU, type *Ctrl + A* and then *x* (two
    separate keystrokes).
  prefs: []
  type: TYPE_NORMAL
- en: Observing the kernel boot process
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: At this point, you should have the kernel image files and the device tree blobs
    for the Raspberry Pi 4, BeaglePlay, and QEMU. Let’s start by looking at a kernel
    panic.
  prefs: []
  type: TYPE_NORMAL
- en: Kernel panic
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'While things started off well on QEMU, they ended badly:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: This is a good example of a kernel panic. A panic occurs when the kernel encounters
    an unrecoverable error. By default, it will print out a message to the console
    and then halt. You can set the panic command-line parameter to allow a few seconds
    before reboots following a panic. In this case, the unrecoverable error is no
    root filesystem, illustrating that a kernel is useless without a user space to
    control it. You can supply a user space by providing a root filesystem, either
    as a RAM disk or on a mountable mass storage device. We will talk about how to
    create a root filesystem in the next chapter, but first, I want to describe the
    sequence of events that leads up to panic.
  prefs: []
  type: TYPE_NORMAL
- en: Early user space
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To transition from kernel initialization to user space, the kernel has to mount
    a root filesystem and execute a program in that root filesystem. This can be achieved
    via a RAM disk or by mounting a real filesystem on a block device. The code for
    all of this is in `init/main.c` starting with the function `rest_init()`, which
    creates the first thread with PID 1 and runs the code in `kernel_init()`. If there
    is a RAM disk, it will try to execute the program `/init`, which will take on
    the task of setting up the user space.
  prefs: []
  type: TYPE_NORMAL
- en: 'If the kernel fails to find and run `/init`, it tries to mount a filesystem
    by calling the function `prepare_namespace()` in `init/do_mounts.c`. This requires
    a `root=` command line to give the name of the block device to use for mounting
    usually in the form:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'Or for SD cards and eMMC:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: For example, for the first partition on an SD card, that would be `root=/dev/mmcblk0p1`.
    If the mount succeeds, it will try to execute `/sbin/init`, followed by `/etc/init`,
    `/bin/init`, and then `/bin/sh`, stopping at the first one that works. The program
    can be overridden on the command line. For a RAM disk, use `rdinit=`. For a filesystem,
    use `init=`.
  prefs: []
  type: TYPE_NORMAL
- en: Kernel messages
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Kernel developers are fond of printing out useful information through the liberal
    use of `printk()` and similar functions. The messages are categorized according
    to importance, with `0` being the highest:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Level** | **Value** | **Meaning** |'
  prefs: []
  type: TYPE_TB
- en: '| `KERN_EMERG` | `0` | The system is unusable |'
  prefs: []
  type: TYPE_TB
- en: '| `KERN_ALERT` | `1` | Action must be taken immediately |'
  prefs: []
  type: TYPE_TB
- en: '| `KERN_CRIT` | `2` | Critical conditions |'
  prefs: []
  type: TYPE_TB
- en: '| `KERN_ERR` | `3` | Error conditions |'
  prefs: []
  type: TYPE_TB
- en: '| `KERN_WARNING` | `4` | Warning conditions |'
  prefs: []
  type: TYPE_TB
- en: '| `KERN_NOTICE` | `5` | Normal but significant conditions |'
  prefs: []
  type: TYPE_TB
- en: '| `KERN_INFO` | `6` | Informational |'
  prefs: []
  type: TYPE_TB
- en: '| `KERN_DEBUG` | `7` | Debug-level messages |'
  prefs: []
  type: TYPE_TB
- en: Table 4.1 – List of kernel messages
  prefs: []
  type: TYPE_NORMAL
- en: They are first written to a buffer named `__log_buf`, the size of which is two
    to the power of `CONFIG_LOG_BUF_SHIFT`. For example, if `CONFIG_LOG_BUF_SHIFT`
    is `16`, then `__log_buf` is 64 KB. You can dump the entire buffer using the command
    `dmesg`.
  prefs: []
  type: TYPE_NORMAL
- en: If the level of a message is less than the console log level, it is displayed
    on the console as well as placed in `__log_buf`. The default console log level
    is `7`. This means that messages of level `6` and lower are displayed while filtering
    out `KERN_DEBUG`, which is level `7`.
  prefs: []
  type: TYPE_NORMAL
- en: You can change the console log level in several ways, including by using the
    kernel parameter `loglevel=<level>` or the command `dmesg -n <level>`.
  prefs: []
  type: TYPE_NORMAL
- en: Kernel command line
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The kernel command line is a string that is passed to the kernel by the bootloader
    via the `bootargs` variable in the case of U-Boot. It can also be defined in the
    device tree or set as part of the kernel configuration in `CONFIG_CMDLINE`.
  prefs: []
  type: TYPE_NORMAL
- en: 'We have seen some examples of the kernel command line already but there are
    many more. There is a complete list in `Documentation/admin-guide/kernel-parameters.txt`.
    Here is a smaller list of the most useful ones:'
  prefs: []
  type: TYPE_NORMAL
- en: '`debug`: Sets the console log level to the highest level (`8`) to ensure that
    you see all the kernel messages on the console.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`init=`: The `init` program to run from a mounted root filesystem. Defaults
    to `/sbin/init`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`lpj=`: Sets `loops_per_jiffy` to a given constant. There is a description
    of the significance of this in the paragraph following this list.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`panic=`: Behavior when the kernel panics. If it is greater than zero, it gives
    the number of seconds before rebooting; if it is zero, it waits forever (default);
    or if it is less than zero, it reboots without any delay.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`quiet`: Sets the console log level to silent, suppressing all but emergency
    messages. Since most devices have a serial console, it takes time to output all
    those strings. Consequently, reducing the number of messages using this option
    reduces boot time.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`rdinit=`: The init program to run from a RAM disk. Defaults to `/init`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ro`: Mounts the root device as read-only. Has no effect on a RAM disk, which
    is always read/write.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`root=`: Device to mount the root filesystem.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`rootdelay=`: Number of seconds to wait before trying to mount the root device.
    Defaults to zero. Useful if the device takes time to probe the hardware. Also
    see `rootwait`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`rootfstype=`: Filesystem type for the root device. In many cases, it is auto-detected
    during mount, although it is required for jffs2 filesystems.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`rootwait`: Waits indefinitely for the root device to be detected, usually
    necessary with MMC devices.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`rw`: Mounts the root device as read-write (default).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The `lpj` parameter is often mentioned in connection with reducing the kernel
    boot time. During initialization, the kernel loops for approximately 250 ms to
    calibrate a delay loop. The value is stored in the variable `loops_per_jiffy`
    and reported like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: If the kernel always runs on the same hardware, it will always calculate the
    same value. You can shave 250 ms off the boot time by adding `lpj=4980736` to
    the command line.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we will learn how to port Linux to a new board based on
    the BeaglePlay, our hypothetical Nova board.
  prefs: []
  type: TYPE_NORMAL
- en: Porting Linux to a new board
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Porting Linux to a new board can be easy or difficult, depending on how similar
    your board is to an existing development board. In [*Chapter 3*](Chapter_03.xhtml#_idTextAnchor061)*,*
    we ported U-Boot to a new board named Nova based on the BeaglePlay. Very few changes
    need to be made to the kernel code, so it is very easy. If you are porting to
    completely new and innovative hardware, then there will be more to do. I am only
    going to consider the simple case. We will delve deeper into the topic of additional
    hardware peripherals throughout [*Chapter 12*](#_idTextAnchor126).
  prefs: []
  type: TYPE_NORMAL
- en: The organization of architecture-specific code in `arch/$ARCH` differs from
    one system to another. The x86 architecture is fairly clean because most hardware
    details are detected at runtime. The PowerPC architecture organizes SoC- and board-specific
    files into subdirectories under `platforms`. The 32-bit Arm architecture, on the
    other hand, is quite messy because there is a lot of variability between the many
    Arm-based SoCs. Platform-dependent code is put in directories named `mach-*`,
    approximately one per SoC. There are other directories named `plat-*`, which contain
    code common to several versions of an SoC.
  prefs: []
  type: TYPE_NORMAL
- en: In the following sections, I am going to explain how to create a device tree
    for a new 64-bit Arm board.
  prefs: []
  type: TYPE_NORMAL
- en: A new device tree
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The first thing to do is create a device tree for the board and modify it to
    describe the additional or changed hardware of the Nova board. In this simple
    case, we just copy `k3-am625-beagleplay`.`dts` to `nova.dts` and change the model
    name to Nova, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: Complete all the steps from *Building a kernel for the BeaglePlay*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following dependency to `linux-stable/arch/arm64/boot/dts/ti/Makefile`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: This entry ensures that the device tree for Nova is compiled whenever an AM62x
    target is selected.
  prefs: []
  type: TYPE_NORMAL
- en: 'Build the Nova device tree binary like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'We can see the effect of using the Nova device tree by booting the BeaglePlay.
    Follow the same procedure as in *Booting the BeaglePlay*. Insert the same microSD
    card into your card reader and copy the `build_beagleplay/arch/arm64/boot/dts/ti/nova.dtb`
    file to the FAT32 `boot` partition. Use the same `Image.gz` file as before but
    load `nova.dtb` in place of `k3-am625-beagleplay`.`dtb`. The following output
    is the point at which the machine model is printed out:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: Now that we have a device tree specifically for the Nova board, we could modify
    it to describe the hardware differences between Nova and BeaglePlay. There are
    quite likely to be changes to the kernel configuration as well. In that case,
    you would create a custom configuration file based on a copy of `arch/arm64/configs/defconfig`.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: What makes Linux so powerful is the ability to configure the kernel however
    we need to. The definitive place to get the kernel source code is [https://www.kernel.org/](https://www.kernel.org/),
    but you will probably need to get the source for a particular SoC or board from
    the vendor of that device or a third party that supports that device. The customization
    of the kernel for a particular target may consist of changes to the core kernel
    code, additional drivers for devices that are not in mainline Linux, a default
    kernel configuration file, and a device tree source file.
  prefs: []
  type: TYPE_NORMAL
- en: Normally, you start with the default configuration for your target board and
    then tweak it by running one of the configuration tools such as `menuconfig`.
    One of the things you should consider at this point is whether the kernel features
    and drivers should be disabled, compiled as modules, or built-in. Kernel modules
    are usually no great advantage for embedded systems where the feature set and
    hardware are usually well defined. However, modules offer a way to import proprietary
    code into the kernel and reduce boot times by loading non-essential drivers after
    booting. Disabling unused kernel features and drivers altogether reduces compile
    times as well as boot times.
  prefs: []
  type: TYPE_NORMAL
- en: Building the kernel produces a compressed kernel image file named `zImage`,
    `Image.gz`, or `bzImage`, depending on the bootloader you will be using and the
    target architecture. A kernel build will also generate any kernel modules (`.ko`
    files) that you have configured and device tree binaries (`.dtb` files) if your
    target requires them.
  prefs: []
  type: TYPE_NORMAL
- en: Porting Linux to a new target board can be quite simple or very difficult, depending
    on how different the hardware is from that in the mainline or vendor-supplied
    kernel. If your hardware is based on a well-known reference design, then it may
    be just a question of making changes to the device tree or the platform data.
    You may well need to add device drivers, which we’ll discuss in [*Chapter 11*](Chapter_11.xhtml#_idTextAnchor373).
    However, if the hardware is radically different from a reference design, you may
    need additional core support, which is outside the scope of this book.
  prefs: []
  type: TYPE_NORMAL
- en: The kernel is the core of a Linux-based system but it cannot work by itself.
    It requires a root filesystem that contains the user space components. The root
    filesystem can be a RAM disk or a filesystem accessed via a block device, which
    will be the subject of the next chapter. As we have seen, booting a kernel without
    a root filesystem results in kernel panic.
  prefs: []
  type: TYPE_NORMAL
- en: Further study
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '*So You Want to Build an Embedded Linux System?* by Jay Carlson – [https://jaycarlson.net/embedded-linux/](https://jaycarlson.net/embedded-linux/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Embedded Linux training* – [https://bootlin.com/training/embedded-linux/](https://bootlin.com/training/embedded-linux/%0D%0A)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Linux Weekly News* – [https://lwn.net/](https://lwn.net/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Raspberry Pi Forums* – [https://forums.raspberrypi.com/](https://forums.raspberrypi.com/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Linux Kernel Development, Third Edition*, by Robert Love'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
