<html><head></head><body>
<div id="sbo-rt-content"><div class="Basic-Text-Frame" id="_idContainer151">
<h1 class="chapterNumber">13</h1>
<h1 class="chapterTitle" id="_idParaDest-178">Managing Databases</h1>
<p class="normal">The Linux platform has long been a very popular choice for hosting databases. Given the fact that databases power a large majority of popular websites across the internet nowadays, this is a very important role for servers to fill. Ubuntu Server is also a very popular choice for this purpose, as its stability is a major benefit to the hosting community. This time around, we’ll take a look at MariaDB, a popular fork of MySQL. The goal won’t be to provide a full walkthrough of MySQL’s syntax (as that would be a full book in and of itself), but we’ll focus on setting up and maintaining database servers utilizing MariaDB, and we’ll even go over how to set up a primary/secondary relationship between them. If you already have a firm understanding of how to architect databases, you’ll still benefit from this chapter as we’ll be discussing Ubuntu’s implementation of MariaDB in particular, which has its configuration organized a bit differently than in other platforms.</p>
<p class="normal">As we work through setting up our very own MariaDB server, we will cover the following topics:</p>
<ul>
<li class="bulletList">Preparations for setting up a database server</li>
<li class="bulletList">Installing MariaDB</li>
<li class="bulletList">Understanding the MariaDB configuration files</li>
<li class="bulletList">Managing MariaDB databases</li>
<li class="bulletList">Setting up a secondary database server</li>
</ul>
<p class="normal">As with setting up any server for a particular purpose, we should first think about the goal and plan accordingly. So in the next section, we’ll talk about some of the higher-level details to consider while preparing a database server.</p>
<h1 class="heading-1" id="_idParaDest-179">Preparations for setting up a database server</h1>
<p class="normal">Before we get<a id="_idIndexMarker705"/> started with setting up our database server, there are a few odds and ends to get out of the way. As we go through this chapter, we’ll set up a basic database server using MariaDB. I’m sure more than a few of my readers are familiar with MySQL. MySQL is a tried and true solution that is still in use in many data centers today, and that will probably continue to be the case for the foreseeable future. There’s a good chance that a popular website or two that you regularly visit utilizes it on the backend. So, you may be wondering then, why not go over that instead of MariaDB?</p>
<p class="normal">There are two reasons why this book will focus on MariaDB. First, the majority of the Linux community is migrating over to it (more on that later), and it’s also a drop-in replacement for MySQL. This means that any databases or scripts you’ve already written for MySQL will most likely work just fine with MariaDB, barring some edge cases. In reverse, the commands you practice with MariaDB should also function as you would expect on a MySQL server. This is great, considering that many MySQL installations are still in use in many data centers, and you’ll be able to support those too. For the most part, there are very few reasons to stick with MySQL when your existing infrastructure can be ported over to MariaDB, and that’s the direction the Linux community is headed toward anyway.</p>
<p class="normal">Why the change? A while back, various distributions of Linux started switching to MariaDB from MySQL. Red Hat is one such example; it switched to MariaDB back in version 7 of Red Hat Enterprise Linux. Other distributions, such as Arch Linux and Fedora, went down the same route. This was partly due to a lack of trust in Oracle, the company that now owns MySQL. When Oracle became the owner of MySQL, there were some serious questions raised in the open source community regarding the future of MySQL as well as its licensing. I’m not going to get into any speculation about Oracle, the future of MySQL, or any politics regarding its future since it’s not relevant to this book (and I’m not a fan of corporate drama). The fact, though, is that many distributions are moving toward MariaDB, and that seems to be the future. It’s a great technology, and I definitely recommend it over MySQL for several reasons that are unrelated to current controversies.</p>
<p class="normal">MariaDB is more than just a fork of MySQL. On its own, it’s a very competent database server. The fact that your existing MySQL implementations should be compatible with it eases adoption. But more than that, MariaDB makes some very worthwhile changes and improvements to MySQL that will only benefit you.</p>
<p class="normal">Everything you love about MySQL can be found in MariaDB, plus some cutting-edge features that are exclusive to it. But even better is the fact that MariaDB features additional clustering options that are leaps and bounds better and more efficient than plain old MySQL.</p>
<p class="normal">So, hopefully I’ve sold you on the value of MariaDB. Ultimately, whether or not you actually use it will depend on the needs of your organization. I’ve seen some organizations opt to stick with MySQL, if only for the sole reason that it’s what they know. I can understand that if a solution has proven itself in your data center, there’s really no reason to change if your database stack is working perfectly fine the way it is. To that end, while I’ll be going over utilizing MariaDB, it’s possible that the examples may work for MySQL as well. If in doubt, MariaDB is recommended for the examples in this chapter.</p>
<p class="normal">With regard to your server, a good implementation plan is key (as always). I won’t spend too much time on this aspect, since by now I know you’ve probably been through a paragraph or two in this book where I’ve mentioned the importance of redundancy (and I’m sure I’ll mention redundancy again a few more times before the last page). At this point, you’re probably just setting up a lab environment or test server on which to practice these concepts before using your newfound skills in production. But when you do eventually roll out a database server into production, it’s crucial to plan for long-term stability. Database servers <a id="_idIndexMarker706"/>should be regularly backed up, redundant (there I go again), and regularly patched. Later on in this chapter, I’ll walk you through setting up a secondary database server, which will take care of the redundancy part. </p>
<p class="normal">However, that’s not enough on its own, as regular backups are important. There are many utilities that allow you to do this, such as <code class="inlineCode">mysqldump</code>, and you can also take snapshots of your virtual machine (assuming you’re not using a physical server). Both solutions are valid, depending on your environment. As someone who has lost an entire workday attempting to resurrect a fallen database server for a client (of which they had no backups or redundancy), my goal is simply to spare you that headache.</p>
<p class="normal">As far as how many resources a database server needs, that solely depends on your environment. MariaDB itself does not take up a huge amount of resources, but as with MySQL, your usage is dependent on your workload. Either you’ll have a few dozen clients connecting, or a few thousand, or more. But one recommendation I’ll definitely make is to <a id="_idIndexMarker707"/>use <strong class="keyWord">Logical Volume Manager</strong> (<strong class="keyWord">LVM</strong>) for the partition that houses your database files. This will certainly spare you grief in the long run. As we’ve discussed in <em class="chapterRef">Chapter 9</em>, <em class="italic">Managing Storage Volumes</em>, LVM makes it very simple to expand a filesystem, especially on a virtual machine.</p>
<p class="normal">If your database server is on a virtual machine, you can add a disk to the volume group and expand it if your database partition starts to get full, and your customers will never notice there was ever about to be a problem. Without LVM, you’ll need to shut down the server, add a new volume, <code class="inlineCode">rsync</code> your database server files over to the new location, and then bring up the server. Depending on the size of your database, this situation can span hours. Do yourself a favor, use LVM.</p>
<p class="normal">With that out of the way, we can begin setting up MariaDB. For learning and testing purposes, you can<a id="_idIndexMarker708"/> use pretty much any server you’d like: physical, virtual, or <a id="_idIndexMarker709"/>a <strong class="keyWord">Virtual Private Server</strong> (<strong class="keyWord">VPS</strong>). Once you’re ready, let’s move on and we’ll get started!</p>
<h1 class="heading-1" id="_idParaDest-180">Installing MariaDB</h1>
<p class="normal">Now we’ve come to<a id="_idIndexMarker710"/> the fun part, installing MariaDB. To get the ball rolling, we’ll install the <code class="inlineCode">mariadb-server</code> package:</p>
<pre class="programlisting con"><code class="hljs-con">sudo apt install mariadb-server 
</code></pre>
<p class="normal">If your organization prefers to stick with MySQL, the package to install is <code class="inlineCode">mysql-server</code> instead:</p>
<pre class="programlisting con"><code class="hljs-con">sudo apt install mysql-server 
</code></pre>
<p class="normal">Although it might be tempting to try out both MySQL and MariaDB to compare and contrast their differences, I don’t recommend switching from MariaDB to MySQL (or vice versa) on the same server. I’ve seen some very strange configuration issues occur on servers that had one installed and then were switched to the other (even after wiping the configuration). For the most part, it’s best to pick one solution per server and stick with it. As a general rule, MySQL should be used if you have legacy databases to support. For brand-new installations, go with MariaDB.</p>
<p class="normal">After you install the <code class="inlineCode">mariadb-server</code> package, check to make sure the service started and is enabled. By default, it should already be running:</p>
<pre class="programlisting con"><code class="hljs-con">systemctl status mariadb
</code></pre>
<p class="normal">Next, we’ll want to add some security to our MariaDB installation (even though we’re using MariaDB, the name of the following command hasn’t been updated and still includes <code class="inlineCode">mysql</code> in the name):</p>
<pre class="programlisting con"><code class="hljs-con">sudo mysql_secure_installation 
</code></pre>
<p class="normal">At this point, we haven’t set a <code class="inlineCode">root</code> password yet, so go ahead and just press <em class="keystroke">Enter</em> when the script asks for it. This script will ask you additional questions. You will be asked if you’d like to <a id="_idIndexMarker711"/>switch to <strong class="keyWord">unix_socket authentication</strong>. The default answer for this question is yes, but I recommend answering no to this question. This will ensure password authentication is used, which is going to be better for compatibility. There is a security benefit by switching to <code class="inlineCode">unix_socket authentication</code>, but for our purposes password authentication will suffice. If you decide to dive into the subject of database management, switching to <code class="inlineCode">unix_socket authentication</code> might be better in the future. </p>
<p class="normal">Continuing, the <code class="inlineCode">mysql_secure_installation</code> script will ask you if you want to set a <code class="inlineCode">root</code> password. The <code class="inlineCode">root</code> user for MariaDB is not the same as the <code class="inlineCode">root</code> user on your system, and you definitely should create a password for it. So when this comes up, press <em class="keystroke">y</em> to tell it you want to create a <code class="inlineCode">root</code> password, then enter that password twice.</p>
<p class="normal">After setting the <code class="inlineCode">root</code> password, the script will ask you whether you’d like to remove anonymous users, and<a id="_idIndexMarker712"/> also disallow remote access to the database server. You should answer yes to both. The latter is especially important, as there’s almost never a situation in which allowing public access to MySQL/MariaDB is a good idea. Even if you’re hosting a website for external users, those users only need access to the website, not the database server. The website itself will interface with the database locally as needed; an external connection wouldn’t be necessary. (If you have a standalone database server that’s not publicly accessible to the internet, then you will want to answer yes here – just make sure that the database server can’t be reached publicly). Continuing for the most part, just answer <code class="inlineCode">yes</code> to everything the script asks you (unless you have a good reason not to).</p>
<p class="normal">The entire process after executing <code class="inlineCode">mysql_secure_installation</code> looks like the following, and I’ve included the responses I recommend for each (“y” for yes, “n” for no):</p>
<pre class="programlisting con"><code class="hljs-con">Enter current password for root (enter for none): 
Switch to unix_socket authentication [Y/n] n
Set root password? [Y/n] y
Remove anonymous users? [Y/n] y
Disallow root login remotely? [Y/n] y
Remove test database and access to it? [Y/n] y
Reload privilege tables now? [Y/n] y
</code></pre>
<p class="normal">At this point, we officially have a fully functional database server. The previous command allowed us to apply some basic security, and our database server is now available to us. To connect to it and manage it, we’ll use the <code class="inlineCode">mariadb</code> command to access the MariaDB shell, where we’ll enter commands to manage our database(s). There are actually two methods to connect to this shell. The first method is by simply using the <code class="inlineCode">mariadb</code> command with <code class="inlineCode">sudo</code>:</p>
<pre class="programlisting con"><code class="hljs-con">sudo mariadb 
</code></pre>
<p class="normal">This particular command works because if you use the <code class="inlineCode">mariadb</code> command as <code class="inlineCode">root</code> (we used <code class="inlineCode">sudo</code> in this example) the password is bypassed. In fact, we didn’t even enter the username either; <code class="inlineCode">root</code> is assumed if you are attempting to access MariaDB with <code class="inlineCode">sudo</code>. This is by far the simplest way to connect. However, some of you may be accustomed to a different method of authentication if you’ve used other Linux distributions: entering the username and password. In that case, the command will look like this (it won’t work by default though):</p>
<pre class="programlisting con"><code class="hljs-con">mariadb -u root -p
</code></pre>
<p class="normal">When that command works correctly, it will ask you for your <code class="inlineCode">root</code> password and then let you into the shell.</p>
<p class="normal">It’s recommended to <a id="_idIndexMarker713"/>create a different user in order to manage your MariaDB installation, as logging in as <code class="inlineCode">root</code> is not recommended in most cases. We’ll be creating additional users later on in this chapter, but for now, the <code class="inlineCode">root</code> account is the only one we have available. It’s common practice to use the root account to do the initial setup, and then create a different user for administrative purposes going forward. However, the <code class="inlineCode">root</code> account is still often used for server maintenance, so use your best judgment.</p>
<p class="normal">So, now that we have access to the MariaDB shell, what can we do with it? The commands we’ll execute on this shell allow us to do things such as create and delete databases and users, add tables, and so on. The <code class="inlineCode">mariadb</code> command comes from the <code class="inlineCode">mariadb-client-10.6</code> package, which was installed as a dependency when we installed <code class="inlineCode">mariadb-server</code>. Entering the <code class="inlineCode">mariadb</code> command by itself with no options connects us to the database server on our local machine. This utility also lets us connect to external database servers to manage them remotely, which we’ll discuss later.</p>
<p class="normal">The MariaDB shell prompt will look like this:</p>
<pre class="programlisting con"><code class="hljs-con">MariaDB [(none)]&gt; 
</code></pre>
<p class="normal">We’ll get into MariaDB commands and user management later. For now, you can exit the shell. To exit, you can type <code class="inlineCode">exit</code> and press <em class="keystroke">Enter</em> or press <em class="keystroke">Ctrl</em> + <em class="keystroke">d</em> on your keyboard.</p>
<p class="normal">Now, our MariaDB server is ready to go. While you can now move on to the next section, you might want to consider setting up another MariaDB server by following these steps on another<a id="_idIndexMarker714"/> machine. If you have room for another virtual machine, it might be a good idea for you to get this out of the way now, since we’ll be setting up a secondary database server later.</p>
<h1 class="heading-1" id="_idParaDest-181">Understanding the MariaDB configuration files</h1>
<p class="normal">Now that we have<a id="_idIndexMarker715"/> MariaDB installed, let’s take a quick look at how its configuration is stored. While we won’t be changing much of the configuration in this chapter (aside from adding parameters related to setting up a secondary database instance), it’s a good idea to know where to find the configuration, since you’ll likely be asked by a developer to tune the database configuration at some point in your career. This may involve changing the storage engine, buffer sizes, or countless other settings. A full walkthrough on performance tuning is outside the scope of this book, but it will be helpful to know how the settings for MariaDB are read, since Ubuntu’s implementation is fairly unique.</p>
<p class="normal">The configuration files for MariaDB are stored in the <code class="inlineCode">/etc/mysql</code> directory. In that directory, you’ll see the following files by default:</p>
<pre class="programlisting code"><code class="hljs-code">debian.cnf 
debian-start 
mariadb.cnf 
my.cnf 
my.cnf.fallback 
</code></pre>
<p class="normal">You’ll also see the following directories:</p>
<pre class="programlisting code"><code class="hljs-code">conf.d 
mariadb.conf.d 
</code></pre>
<p class="normal">The configuration file that MariaDB reads on startup is the <code class="inlineCode">/etc/mysql/mariadb.cnf</code> file. This is where you’ll begin perusing when you want to configure the daemon, but we’ll get to that soon. The <code class="inlineCode">/etc/mysql/debian-start</code> file is actually a script that sets default values for MariaDB when it starts, such as setting some environment variables. It also defines a task that is executed if the <code class="inlineCode">mariadb</code> process dies or exits, and allows it to check for crashed tables.</p>
<p class="normal">The <code class="inlineCode">debian-start</code> script also loads the <code class="inlineCode">/etc/mysql/debian.cnf</code> file, which sets some client settings for the <code class="inlineCode">mariadb</code> daemon. Here’s a list of values from that file:</p>
<pre class="programlisting code"><code class="hljs-code">[client] 
host     = localhost 
user     = root 
[mysql_upgrade] 
host     = localhost 
user     = root 
</code></pre>
<p class="normal">The defaults for these values are fine and there’s rarely a reason to change them. Essentially, the file sets the default user, host, and socket location. If you’ve used MySQL before on other platforms, you may have seen many of those settings in the <code class="inlineCode">/etc/my.cnf</code> file, which is typically the standard file for the <code class="inlineCode">mariadb</code> daemon. With MariaDB on Ubuntu Server, you can see that the default layout of the files was changed considerably.</p>
<p class="normal">The <code class="inlineCode">/etc/mysql/mariadb.cnf</code> file sets the global defaults for MariaDB. However, in Ubuntu’s implementation, this default file just includes configuration files from the <code class="inlineCode">/etc/mysql/conf.d</code> and <code class="inlineCode">/etc/mysql/mariadb.conf.d</code> directories. Within those directories, there are additional<a id="_idIndexMarker716"/> files ending with the <code class="inlineCode">.cnf</code> extension. Many of these files contain default configuration values that would normally be found in a single file, but Ubuntu’s implementation modularizes these settings into separate files instead. For our purposes in this book, we’ll be editing the <code class="inlineCode">/etc/mysql/conf.d/mysql.cnf</code> file when it is time to set up a relationship between primary and secondary servers.</p>
<p class="normal">The other configuration files aren’t relevant for the content of this book, and their current values are more than sufficient for what we need. When it comes to performance tuning, you may consider creating a new configuration file ending with the <code class="inlineCode">.cnf</code> extension, with specific tuning values as provided by the documentation of a software package you want to run that interfaces with a database, or requirements given to you by a developer.</p>
<p class="normal">For additional information on how these configuration files are read, you can refer to the <code class="inlineCode">/etc/mysql/mariadb.cnf</code> file, which includes some helpful content at the top of the file that details the order in which these configuration files are read, as well as their purpose. Here’s an excerpt of these comments from that file:</p>
<pre class="programlisting code"><code class="hljs-code"># The MariaDB/MySQL tools read configuration files in the following order: 
# 1. "/etc/mysql/mariadb.cnf" (this file) to set global defaults, 
# 2. "/etc/mysql/conf.d/*.cnf" to set global options. 
# 3. "/etc/mysql/mariadb.conf.d/*.cnf" to set MariaDB-only options. 
# 4. "~/.my.cnf" to set user-specific options. 
</code></pre>
<p class="normal">As we can see, when MariaDB starts up, it first reads the <code class="inlineCode">/etc/mysql/mariadb.cnf</code> file, followed <code class="inlineCode">by .cnf</code> files stored within the <code class="inlineCode">/etc/mysql/conf.d</code> directory, then the <code class="inlineCode">.cnf</code> files stored within the <code class="inlineCode">/etc/mysql/mariadb.conf.d</code> directory, followed by any user-specific settings stored within a <code class="inlineCode">.my.cnf</code> file that may be present in the user’s <code class="inlineCode">home</code> directory.</p>
<p class="normal">With Ubuntu’s implementation, when the <code class="inlineCode">/etc/mysql/mariadb.cnf</code> file is read during startup, the process will immediately scan the contents of <code class="inlineCode">/etc/mysql/conf.d</code> and <code class="inlineCode">/etc/mysql/mariadb.conf.d</code>, because the <code class="inlineCode">/etc/mysql/mariadb.cnf</code> file contains the following lines:</p>
<pre class="programlisting code"><code class="hljs-code">!includedir /etc/mysql/conf.d/ 
!includedir /etc/mysql/mariadb.conf.d/ 
</code></pre>
<p class="normal">As you can see, the <a id="_idIndexMarker717"/>order that the configuration files are checked is set to the <code class="inlineCode">mariadb.cnf</code> file first, followed by the <code class="inlineCode">/etc/mysql/conf.d</code> and <code class="inlineCode">/etc/mysql/mariadb.conf.d</code> directories.</p>
<p class="normal">This may be a bit confusing at first, because the default configuration for MariaDB in Ubuntu Server essentially consists of files that redirect to other files. But the main takeaway is that any configuration changes you make that are not exclusive to MariaDB (basically, configuration that’s compatible with MySQL itself) should be placed in a configuration file that ends with the <code class="inlineCode">.cnf</code> extension, and then stored in the <code class="inlineCode">/etc/mysql/conf.d</code> directory.</p>
<p class="normal">If the configuration you’re wanting to add is for a feature exclusive to MariaDB (but not compatible with MySQL itself), the configuration file should be placed in the <code class="inlineCode">/etc/mysql/mariadb.conf.d</code> directory instead. For our purposes, we’ll be editing the <code class="inlineCode">/etc/mysql/conf.d/mysql.cnf</code> file when it comes time to set up our primary/secondary replication, since the method we’ll be using is not specific to MariaDB.</p>
<p class="normal">In this section, we discussed MariaDB configuration and how it differs from its implementation in other platforms. The way the configuration files are presented is not the only difference in<a id="_idIndexMarker718"/> Ubuntu’s implementation of MariaDB; there are other differences as well. In the next section, we’ll take a look at a few additional ways in which Ubuntu’s implementation differs from implementations in other distributions of Linux.</p>
<h1 class="heading-1" id="_idParaDest-182">Managing MariaDB databases</h1>
<p class="normal">Now that our <a id="_idIndexMarker719"/>MariaDB server is up and running, we can finally look into managing it. In this section, I’ll demonstrate how to connect to a database server using the <code class="inlineCode">mariadb</code> command, which will allow us to create databases, remove (drop) them, and also manage users and permissions.</p>
<p class="normal">To begin, we’ll need to create an administrative user for MariaDB. The <code class="inlineCode">root</code> account already exists as the default administrative user, but it’s not a good idea to allow others to use that account. Instead, it makes more sense to create an administrative account separate from <code class="inlineCode">root</code> for managing our databases. Therefore, we’ll begin our discussion on managing databases with user management. The users we’ll manage within MariaDB are specific to MariaDB; these are separate from the user accounts on the actual system.</p>
<p class="normal">To manage and interact with databases, we’ll need to enter the MariaDB shell, and the same goes for when it comes to creating database users. Right now, since we only have the <code class="inlineCode">root</code> account, we’ll need to access the current MariaDB implementation as <code class="inlineCode">root</code> in order to set up our administrative user. If you’ve set up standard authentication, as we discussed earlier in this chapter, you can access the prompt using the standard means:</p>
<pre class="programlisting con"><code class="hljs-con">mariadb -u root -p
</code></pre>
<p class="normal">Or, more simply:</p>
<pre class="programlisting con"><code class="hljs-con">sudo mariadb
</code></pre>
<p class="normal">Once inside the MariaDB shell, your prompt will change to the following:</p>
<pre class="programlisting con"><code class="hljs-con">MariaDB [(none)]&gt; 
</code></pre>
<p class="normal">Now, we can create our new administrative user. I’ll call mine <code class="inlineCode">admin</code> in my examples, but you can use whatever name you’d like. In a company I used to work for, we used the username <code class="inlineCode">velociraptor</code> as our administrative user on our servers, since nothing is more powerful than a velociraptor (and they can open doors). Feel free to use a clever name, but just make sure you remember it. Using a non-standard username has the added benefit of security by obscurity; the name wouldn’t be what an intruder would expect.</p>
<p class="normal">Here’s the command to create a new user in MariaDB (replace the username and password in the command with your desired credentials):</p>
<pre class="programlisting con"><code class="hljs-con">CREATE USER 'admin'@'localhost' IDENTIFIED BY 'password';
FLUSH PRIVILEGES;
</code></pre>
<p class="normal">When it comes to MySQL syntax, the commands are not case sensitive (though the data parameters are), but it’s common to capitalize instructions to separate them from data. During the remainder of this chapter, we’ll be executing some commands within the Linux shell, and others within the MariaDB shell. I’ll let you know which shell each command needs to be executed in as we come to them, but if you are confused, just keep in mind that MariaDB commands are the only ones that are capitalized.</p>
<p class="normal">With the preceding commands, we’re creating the <code class="inlineCode">admin</code> user and restricting it to <code class="inlineCode">localhost</code>. This is important because we don’t want to open up the <code class="inlineCode">admin</code> account to the world. We’re also flushing privileges, which causes MariaDB to reload its privileges information. The <code class="inlineCode">FLUSH PRIVILEGES</code> command should be run every time you add a user or modify<a id="_idIndexMarker720"/> permissions. I may not always mention the need to run this command, so you might want to make a mental note of it and make it a habit now.</p>
<p class="normal">As I mentioned, the previous command created the <code class="inlineCode">admin</code> user but is only allowing it to connect from <code class="inlineCode">localhost</code>. This means that an administrator would first need to log in to the server itself before they would be able to log in to MariaDB with the <code class="inlineCode">admin</code> account. As an example of the same command (but allowing remote login from any other location), the following command is a variation that will do just that:</p>
<pre class="programlisting con"><code class="hljs-con">CREATE USER 'admin'@'%' IDENTIFIED BY 'password'; 
</code></pre>
<p class="normal">Can you see the percent symbol (<code class="inlineCode">%</code>) in place of <code class="inlineCode">localhost</code>? That basically means <em class="italic">everywhere</em>, which indicates we’re creating a user that can be logged into from any source (even external nodes). However, by restricting our user to <code class="inlineCode">localhost</code> with the first command, we’re making our server just a bit more secure. You can also restrict access to particular networks, which is desired if you really do need to allow a database administrator access to the server remotely:</p>
<pre class="programlisting con"><code class="hljs-con">CREATE USER 'admin'@'192.168.1.%' IDENTIFIED BY 'password'; 
</code></pre>
<p class="normal">That’s a little better, but not as secure as limiting login to <code class="inlineCode">localhost</code>. As you can see, the <code class="inlineCode">%</code> character is basically a wildcard, so you can restrict access to needing to be from a specific IP or even a particular subnet.</p>
<p class="normal">So far, all we did is create a new user; we have yet to give this user any permissions. We can create a set of permissions (also <a id="_idIndexMarker721"/>known as <strong class="keyWord">grants</strong>) with the <code class="inlineCode">GRANT</code> command. First, let’s give our admin user full access to the database server when called from <code class="inlineCode">localhost</code>:</p>
<pre class="programlisting con"><code class="hljs-con">GRANT ALL PRIVILEGES ON *.* TO 'admin'@'localhost'; 
FLUSH PRIVILEGES; 
</code></pre>
<p class="normal">Now, we have an administrative user we can use to manage our server’s databases. We can use this account for managing our server instead of the <code class="inlineCode">root</code> account. Any logged-on Linux user will be able to access the database server and manage it, provided they know the password. To access the MariaDB shell as the <code class="inlineCode">admin</code> user that we created, the following command will do the trick:</p>
<pre class="programlisting con"><code class="hljs-con">mariadb -u admin -p 
</code></pre>
<p class="normal">After entering the <a id="_idIndexMarker722"/>password, you’ll be logged into MariaDB as <code class="inlineCode">admin</code>.</p>
<p class="normal">In addition, you can actually provide the password to the <code class="inlineCode">mariadb</code> command without needing to be prompted for it:</p>
<pre class="programlisting con"><code class="hljs-con">mariadb -u admin -p&lt;password&gt; 
</code></pre>
<p class="normal">Notice that there is no space in between the <code class="inlineCode">-p</code> option and the actual password (though it’s common to put a space between the <code class="inlineCode">-u</code> option and the username). As useful as it is to provide the username and password in one shot, I don’t recommend that you ever use that method. This is because any Linux command you type is saved in the history, so anyone can view your command history and they’ll see the password in plain text. I only mention it here because I find that many administrators do this, even though they shouldn’t. At least now you’re aware of this method and why it’s wrong.</p>
<p class="normal">The <code class="inlineCode">admin</code> account we created is only intended for system administrators who need to manage databases on the server. The password for this account should not be given to anyone other than staff employees or administrators that absolutely need it. Additional users can be added to the MariaDB server, each with differing levels of access. Keep in mind that our <code class="inlineCode">admin</code> account can manage databases but not users. This is important, as you probably shouldn’t allow anyone other than server administrators to create users. You’ll still need to log in as <code class="inlineCode">root</code> to manage user permissions.</p>
<p class="normal">It may also be useful to create a read-only user for MariaDB for employees who need to be able to read data but not make changes. Back in the MariaDB shell (as <code class="inlineCode">root</code>), we can issue the following command to effectively create a read-only user:</p>
<pre class="programlisting con"><code class="hljs-con">GRANT SELECT ON *.* TO 'readonlyuser'@'localhost' IDENTIFIED BY 'password'; 
</code></pre>
<p class="normal">With this command (and flushing privileges afterward), we’ve done two things. First, we’ve created a new user and also set up grants for that user with a single command. Second, we’ve created a read-only user that can view databases but not manage them (we’ve restricted the<a id="_idIndexMarker723"/> permissions to <code class="inlineCode">SELECT</code>). This is more secure. In practice, it’s better to restrict a read-only user to a specific database. This is typical in a development environment, where you’ll have an application that connects to a database over a network and needs to read information from it. We’ll go over this scenario soon.</p>
<p class="normal">Next, let’s create a database. At the MariaDB prompt, execute:</p>
<pre class="programlisting con"><code class="hljs-con">CREATE DATABASE mysampledb; 
</code></pre>
<p class="normal">That was easy. We should now have a database on our server named <code class="inlineCode">mysampledb</code>. To list all databases on our server (and confirm our database was created properly), we can execute the following command:</p>
<pre class="programlisting con"><code class="hljs-con">SHOW DATABASES;
</code></pre>
<p class="normal">This will produce an output like the following:</p>
<figure class="mediaobject"><img alt="" height="352" src="../Images/B18425_13_01.png" width="881"/></figure>
<p class="packt_figref">Figure 13.1: Listing MariaDB databases</p>
<p class="normal">The output will show some system databases that were created for us, but our new database should be listed among them. We can also list users just as easily:</p>
<pre class="programlisting con"><code class="hljs-con">SELECT HOST, USER, PASSWORD FROM mysql.user; 
</code></pre>
<p class="normal">Entering this <a id="_idIndexMarker724"/>command will result in something similar to the following output:</p>
<figure class="mediaobject"><img alt="Text  Description automatically generated" height="325" src="../Images/B18425_13_02.png" width="875"/></figure>
<p class="packt_figref">Figure 13.2: Listing MariaDB users</p>
<p class="normal">In a typical scenario, when installing an application that needs its own database, we’ll create the database and then a user for that database. We’ll normally want to give that user permission to only<a id="_idIndexMarker725"/> that database, with only as much permission as required to allow it to function properly. We’ve already created the <code class="inlineCode">mysampledb</code> database, so if we want to create a user with read-only access to it, we can do so with the following command:</p>
<pre class="programlisting con"><code class="hljs-con">GRANT SELECT ON mysampledb.* TO 'appuser'@'localhost' IDENTIFIED BY 'password'; 
</code></pre>
<p class="normal">With one command, we’re not only creating the user <code class="inlineCode">appuser</code>, but we’re also setting a password for it, in addition to allowing it to have <code class="inlineCode">SELECT</code> permissions on the <code class="inlineCode">mysampledb</code> database. This is equivalent to read-only access. If our user needed full access, we could use the following instead:</p>
<pre class="programlisting con"><code class="hljs-con">GRANT ALL ON mysampledb.* TO 'appuser'@'localhost' IDENTIFIED BY 'password'; 
</code></pre>
<p class="normal">To double-check that we’ve executed the command correctly, we can use this command to show the grants for a particular user:</p>
<pre class="programlisting con"><code class="hljs-con">SHOW GRANTS FOR 'appuser'@'localhost';
</code></pre>
<p class="normal">Now, our <code class="inlineCode">appuser</code> has full access but only to the <code class="inlineCode">mysampledb</code> database. Of course, we should only provide full access to the database if absolutely necessary. We can also provide additional permissions, such as <code class="inlineCode">DELETE</code> (whether or not the user has permission to delete rows from database tables), <code class="inlineCode">CREATE</code> (which controls whether the user can add rows to the database), <code class="inlineCode">INSERT</code> (controls whether or not the user can add new rows to a table), <code class="inlineCode">SELECT</code> (allows the user to read information from the database), <code class="inlineCode">DROP</code> (allows the user to fully remove a database), and <code class="inlineCode">ALL</code> (which gives the user everything). There are other permissions we can grant or deny; check the MariaDB documentation for more details. The types of permissions you’ll need to grant to a user to satisfy the application you’re installing will depend on the documentation for that software. Always refer to the installation instructions for the application you’re attempting to install to determine which permissions are required for it to run.</p>
<p class="normal">If you’d like to remove user access, you can use the following command to do so (substituting <code class="inlineCode">myuser</code> with the user account you wish to remove):</p>
<pre class="programlisting con"><code class="hljs-con">DROP USER 'myuser'@'localhost'
</code></pre>
<p class="normal">Now, let’s go back to<a id="_idIndexMarker726"/> databases. Now that we’ve created the <code class="inlineCode">mysampledb</code> database, what can we do with it? We’ll add tables and rows, of course! A database is useless without actual data, so we can work through some examples of adding data to our database to see how this works. First, log in to the MariaDB shell as a user with full privileges to the <code class="inlineCode">mysampledb</code> database. Now, we can have some fun and modify the contents. Here are some examples you can follow:</p>
<pre class="programlisting con"><code class="hljs-con">USE mysampledb;
</code></pre>
<p class="normal">The <code class="inlineCode">USE</code> command allows us to select a database we want to work with. The MariaDB prompt will change from <code class="inlineCode">MariaDB [(none)]&gt;</code> to <code class="inlineCode">MariaDB [mysampledb]&gt;</code>. This is very useful, as the MariaDB prompt changes to indicate which database we are currently working with. We basically just told <code class="inlineCode">MariaDB</code> that for all of the commands we’re about to execute, we would like them to be issued against the <code class="inlineCode">mysampledb</code> database.</p>
<p class="normal">Now, we can <code class="inlineCode">CREATE</code> a table in our database. It doesn’t matter what you call yours, since we’re just practicing. I’ll call mine <code class="inlineCode">Employees</code>:</p>
<pre class="programlisting con"><code class="hljs-con">CREATE TABLE Employees (Name char(15), Age int(3), Occupation char(15));
</code></pre>
<p class="normal">We can verify this command by showing the columns in the database, to ensure it shows what we expect:</p>
<pre class="programlisting con"><code class="hljs-con">SHOW COLUMNS IN Employees;
</code></pre>
<p class="normal">With this command, we’ve created a table named <code class="inlineCode">Employees</code> that has three columns (<code class="inlineCode">Name</code>, <code class="inlineCode">Age</code>, and <code class="inlineCode">Occupation</code>). To add new data to this table, we can use the following <code class="inlineCode">INSERT</code> command:</p>
<pre class="programlisting con"><code class="hljs-con">INSERT INTO Employees VALUES ('Joe Smith', '26', 'Ninja');
</code></pre>
<p class="normal">The example <code class="inlineCode">INSERT</code> command adds a new employee to our <code class="inlineCode">Employees</code> table. When we use <code class="inlineCode">INSERT</code>, we insert all the data for each of the columns. Here, we have an employee named <code class="inlineCode">Joe</code>, who is <code class="inlineCode">26</code> years old and whose occupation is a <code class="inlineCode">Ninja</code>. Feel free to add additional employees; all you would need to do is formulate additional <code class="inlineCode">INSERT</code> statements and provide data for each of the three fields. When you’re done, you can use the following command to <a id="_idIndexMarker727"/>show all of the data in this table:</p>
<pre class="programlisting con"><code class="hljs-con">SELECT * FROM Employees;
</code></pre>
<figure class="mediaobject"><img alt="" height="264" src="../Images/B18425_13_03.png" width="626"/></figure>
<p class="packt_figref">Figure 13.3: Listing database rows from a table</p>
<p class="normal">To remove an entry, the following command will do what we need:</p>
<pre class="programlisting con"><code class="hljs-con">DELETE FROM Employees WHERE Name = 'Joe Smith'; 
</code></pre>
<p class="normal">Basically, we’re using the <code class="inlineCode">DELETE FROM</code> command, giving the name of the table we wish to delete from (<code class="inlineCode">Employees</code>, in this case), and then using <code class="inlineCode">WHERE</code> to provide some search criteria for narrowing down our command.</p>
<p class="normal">The <code class="inlineCode">DROP</code> command allows us to delete tables or entire databases, and it should be used with care. I don’t actually recommend you delete the database we just created, since we’ll use it for additional examples. But if you really wanted to drop the <code class="inlineCode">Employees</code> table, you could use:</p>
<pre class="programlisting con"><code class="hljs-con">DROP TABLE Employees; 
</code></pre>
<p class="normal">Or use this to drop the entire database:</p>
<pre class="programlisting con"><code class="hljs-con">DROP DATABASE mysampledb; 
</code></pre>
<p class="normal">There is, of course, much more to MariaDB and its MySQL syntax than the samples I have provided, but this should be enough to get you through the examples in this book. As much as I would love to give you a full walkthrough of the MySQL syntax, it would easily push this chapter beyond a reasonable number of pages. If you’d like to push your skills beyond the samples of this chapter, there are great books available that are dedicated to the subject.</p>
<p class="normal">Before I close this section though, I think it will be worthwhile for you to see how to back up and restore your databases. To do this, we have the <code class="inlineCode">mysqldump</code> command at our disposal. Its syntax is very simple, as you’ll see.</p>
<p class="normal">First, exit the <a id="_idIndexMarker728"/>MariaDB shell and return to your standard Linux shell. Since we’ve already created an <code class="inlineCode">admin</code> user earlier in the chapter, we’ll use that user for the purposes of our backup:</p>
<pre class="programlisting con"><code class="hljs-con">mysqldump -u admin -p --databases mysampledb &gt; mysampledb.sql
</code></pre>
<p class="normal">With this example, we’re using <code class="inlineCode">mysqldump</code> to create a copy of the <code class="inlineCode">mysampledb</code> database and storing it in a file named <code class="inlineCode">mysampledb.sql</code>. Since MariaDB requires us to log in, we authenticate to MariaDB using the <code class="inlineCode">-u</code> option with the username <code class="inlineCode">admin</code> and the <code class="inlineCode">-p</code> option, which will prompt us for a password. The <code class="inlineCode">--databases</code> option is necessary because, by default, <code class="inlineCode">mysqldump</code> does not include the <code class="inlineCode">database create</code> statement . However, the <code class="inlineCode">--databases</code> option forces this, which just makes it easier for you to restore. Assuming that we were able to authenticate properly, the contents of the <code class="inlineCode">mysampledb</code> database will be dumped into the <code class="inlineCode">mysampledb.sql</code> file. This export should happen very quickly, since this database probably only contains a single table and a few rows. Larger production databases can take hours to dump.</p>
<p class="normal">Restoring a backup is fairly simple. We can utilize the <code class="inlineCode">mariadb</code> command with the backup file used as a source of input:</p>
<pre class="programlisting con"><code class="hljs-con">sudo mariadb -u admin -p &lt; mysampledb.sql 
</code></pre>
<p class="normal">So, there you<a id="_idIndexMarker729"/> have it. The <code class="inlineCode">mysqldump</code> command is definitely very handy in backing up databases. In the next section, we’ll work through setting up a secondary database server.</p>
<h1 class="heading-1" id="_idParaDest-183">Setting up a secondary database server</h1>
<p class="normal">Redundancy is an<a id="_idIndexMarker730"/> amazing thing. If a primary server fails for some reason, you can keep your applications running by having a secondary database server available in case the original meets its demise. Of course, you can always create regular backups of your database servers and restore if necessary, but it’s very hard to keep up with databases that are always changing, so backups have a tendency to become stale quite fast. A secondary database server enables you to have a copy that is always up to date. This doesn’t mean that you no longer need backups, but it does give you another option for recovery when faced with a problem.</p>
<p class="normal">The industry is moving away from terms like “Master” and “Slave” to describe a primary and secondary server. In this chapter and moving forward, we will use the terms “Primary” and “Secondary” to describe the relationship of one main database server that replicates to another. Therefore, the verbiage around our actions will use “primary” and “secondary,” even though the verbiage inside Ubuntu 22.04 still uses the old terminology. Just keep in mind that the naming will likely switch to a new naming scheme in the future.</p>
<p class="normal">At this point, we have one database server already. To set up a secondary database instance, all you really need in order to begin the process is to set up another physical server or virtual machine and install the <code class="inlineCode">mariadb-server</code> package as we did earlier. If you’ve already set up two database servers as recommended earlier in the chapter, you’re ready to begin. If not, feel free to spin up another virtual machine and follow the process from the <em class="italic">Installing MariaDB</em> section, which covered the initial setup of MariaDB. Go ahead and set up another server if you haven’t already done so. Of your two servers, one should be designated as the primary and the other as the secondary, so make a note of the IP addresses for each.</p>
<p class="normal">To begin, we’ll first start working on the primary. We’ll need to edit the <code class="inlineCode">/etc/mysql/conf.d/mysql.cnf</code> file on the server you wish to be the primary. Currently, the file contains just the following line:</p>
<pre class="programlisting code"><code class="hljs-code">[mysql] 
</code></pre>
<p class="normal">Right underneath that, add a blank line and then the following code:</p>
<pre class="programlisting code"><code class="hljs-code">[mysqld] 
log-bin 
binlog-do-db=mysampledb 
server-id=1 
</code></pre>
<p class="normal">With this configuration, we’re first enabling binary logging, which is required for a primary/secondary server to function properly. Binary logs contain records of all database changes, which enables a secondary database instance to reproduce changes made to the primary server. These binary logs record changes made to a database, which will then be transferred to a secondary server.</p>
<p class="normal">Another configuration file that we’ll need to edit is <code class="inlineCode">/etc/mysql/mariadb.conf.d/50-server.cnf</code>. In this file, we have the following line:</p>
<pre class="programlisting code"><code class="hljs-code">bind-address = 127.0.0.1 
</code></pre>
<p class="normal">With this default setting, the <code class="inlineCode">mysql</code> daemon is only listening for connections on <code class="inlineCode">localhost</code> (<code class="inlineCode">127.0.0.1</code>), which is a problem since we’ll need to connect to it from another machine (the secondary <a id="_idIndexMarker731"/>server). Change this line to the following:</p>
<pre class="programlisting code"><code class="hljs-code">bind-address = 0.0.0.0 
</code></pre>
<p class="normal">Next, we’ll need to access the MariaDB shell on the primary server and execute the following commands:</p>
<pre class="programlisting con"><code class="hljs-con">GRANT REPLICATION SLAVE ON *.* to 'replicate'@'192.168.1.204' identified by 'password'; 
</code></pre>
<p class="normal">Here, we’re creating a replication user named <code class="inlineCode">replicate</code> and allowing it to connect to our primary server from the IP address <code class="inlineCode">192.168.1.204</code>. Be sure to change that IP to match the IP of your secondary server, but you can also use a hostname identifier such as <code class="inlineCode">%.mydomain</code> if you have a domain configured, which is equivalent to allowing any hostname that ends with <code class="inlineCode">.mydomain</code>. Also, we’re setting the password for this user to <code class="inlineCode">password</code>, so feel free to customize that as well to fit your password requirements (be sure to make a note of the password).</p>
<p class="normal">We should now restart the <code class="inlineCode">mariadb</code> daemon so that the changes we’ve made to the <code class="inlineCode">mysql.cnf</code> file take effect:</p>
<pre class="programlisting con"><code class="hljs-con">sudo systemctl restart mariadb 
</code></pre>
<p class="normal">Next, we’ll set up the secondary server. But before we do that, there’s a consideration to make now that will possibly make the process easier on us. In a production environment, it’s very possible that data is still being written to the primary server. The process of setting up a secondary server is much easier if we don’t have to worry about the primary database changing while we set up the secondary. The following command, when executed within the MariaDB shell, will lock the database and prevent additional changes:</p>
<pre class="programlisting con"><code class="hljs-con">FLUSH TABLES WITH READ LOCK;
</code></pre>
<p class="normal">If you’re absolutely sure that no data is going to be written to the primary server, you can disregard that step.</p>
<p class="normal">Next, we should utilize <code class="inlineCode">mysqldump</code> to make sure that both the primary and the secondary servers contain the same data before we start synchronizing them. The process is smoother if we begin with them already synchronized, rather than trying to mirror the databases later. Using <code class="inlineCode">mysqldump</code> as we did in the previous section, create a dump of the primary server’s database<a id="_idIndexMarker732"/> and then import that dump into the secondary. The easiest way to transfer the dump file is to use <code class="inlineCode">rsync</code> or <code class="inlineCode">scp</code>. Then, on the secondary instance, use <code class="inlineCode">mariadb</code> to import the file.</p>
<p class="normal">The command to back up the database on the primary server becomes the following:</p>
<pre class="programlisting con"><code class="hljs-con">mysqldump -u admin -p --databases mysampledb &gt; mysampledb.sql 
</code></pre>
<p class="normal">After transferring the <code class="inlineCode">mysampledb.sql</code> file to the secondary server, you can import the backup into the secondary server:</p>
<pre class="programlisting con"><code class="hljs-con">mariadb -u root -p &lt; mysampledb.sql 
</code></pre>
<p class="normal">Also on the secondary server, we’ll need to edit <code class="inlineCode">/etc/mysql/conf.d/mysql.cnf</code> and then place the following code at the end (make sure to add a blank line after <code class="inlineCode">[mysql]</code>:</p>
<pre class="programlisting con"><code class="hljs-con">[mysqld] 
server-id=2 
</code></pre>
<p class="normal">Although it’s outside the scope of this book, you can set up more than just one secondary database server. If you do, each will need a unique <code class="inlineCode">server-id</code>.</p>
<p class="normal">Make sure you restart the <code class="inlineCode">mariadb</code> unit on the secondary server before continuing:</p>
<pre class="programlisting con"><code class="hljs-con">sudo systemctl restart mariadb 
</code></pre>
<p class="normal">From the <code class="inlineCode">root</code> MariaDB shell on your secondary server, enter the following command. Change the IP address in the command accordingly:</p>
<pre class="programlisting con"><code class="hljs-con">CHANGE MASTER TO MASTER_HOST="192.168.1.184", MASTER_USER='replicate', MASTER_PASSWORD='password'; 
</code></pre>
<p class="normal">Now that we’re finished configuring the synchronization, we can unlock the primary server’s tables. On the primary server, execute the following command within the MariaDB shell:</p>
<pre class="programlisting con"><code class="hljs-con">UNLOCK TABLES; 
</code></pre>
<p class="normal">Now, we can check <a id="_idIndexMarker733"/>the status of the secondary server to see whether or not it is running.</p>
<p class="normal">Within the secondary server’s MariaDB shell, execute the following command:</p>
<pre class="programlisting con"><code class="hljs-con">SHOW SLAVE STATUS \G; 
</code></pre>
<p class="normal">Here, we’re adding <code class="inlineCode">\G</code>, which changes the output to be displayed vertically instead of horizontally.</p>
<p class="normal">Assuming all went well, we should see the following line in the output:</p>
<pre class="programlisting con"><code class="hljs-con">Slave_IO_State: Waiting for master to send event 
</code></pre>
<p class="normal">If the secondary server isn’t running (<code class="inlineCode">Slave_IO_State</code> is blank), execute the following command:</p>
<pre class="programlisting con"><code class="hljs-con">START SLAVE; 
</code></pre>
<p class="normal">Next, check the status of the secondary server process again to verify:</p>
<pre class="programlisting con"><code class="hljs-con">SHOW SLAVE STATUS \G;
</code></pre>
<p class="normal">From this point forward, any data you add to your database on the primary server should be replicated to the secondary. To test, add a new record to the <code class="inlineCode">Employees</code> table on the <code class="inlineCode">mysampledb</code> database on the primary server:</p>
<pre class="programlisting con"><code class="hljs-con">USE mysampledb; 
INSERT INTO Employees VALUES ('Optimus Prime', '100', 'Transformer'); 
</code></pre>
<p class="normal">On the secondary server, check the same database and table for the new value to appear. It may take a second or two:</p>
<pre class="programlisting con"><code class="hljs-con">USE mysampledb; 
SELECT * FROM Employees; 
</code></pre>
<p class="normal">If you see any errors in the <code class="inlineCode">Slave_IO_State</code> line when you run <code class="inlineCode">SHOW SLAVE STATUS \G</code>, or your databases aren’t synchronizing properly, here are a few things you can try. First, make sure that the primary database server is listening for connections on <code class="inlineCode">0.0.0.0</code> port <code class="inlineCode">3306</code>. </p>
<p class="normal">To test this, run this variation of the <code class="inlineCode">ss</code> command to see which port the <code class="inlineCode">mariadb</code> process is listening on (it’s listed as <code class="inlineCode">mysqld</code>):</p>
<pre class="programlisting con"><code class="hljs-con">ss -tulpn | grep mysqld 
</code></pre>
<p class="normal">The output should be<a id="_idIndexMarker734"/> similar to the following:</p>
<pre class="programlisting con"><code class="hljs-con">tcp   LISTEN 0      80                               0.0.0.0:3306       0.0.0.0:*            users:(("mysqld",pid=9768,fd=23)) 
</code></pre>
<p class="normal">If you see that the service is listening on <code class="inlineCode">127.0.0.1:3306</code> instead, that means it’s only accepting connections from localhost. Earlier in this section, I mentioned changing the <code class="inlineCode">bind</code> address in the <code class="inlineCode">/etc/mysql/mariadb.conf.d/50-server.cnf</code> file. Make sure you’ve already done that and restart <code class="inlineCode">mariadb</code>. During my tests, I’ve actually had one situation where the <code class="inlineCode">mariadb</code> service became locked after I made this change, and attempting to restart the process did nothing (I ended up having to reboot the entire server, which is not typically something you’d have to do). Once the server came back up, it was listening for connections from the network.</p>
<p class="normal">If you receive errors on the secondary server when you run <code class="inlineCode">SHOW SLAVE STATUS \G</code>, with regards to authentication, make sure you’ve run <code class="inlineCode">FLUSH PRIVILEGES</code> on the primary server. Even if you have, run it again to be sure. Also, double-check that you’re synchronizing with the correct username, IP address, and password. For your convenience, here’s the command we ran on the primary server to grant replication permissions:</p>
<pre class="programlisting con"><code class="hljs-con">GRANT REPLICATION SLAVE ON *.* to 'replicate'@'192.168.1.204' identified by 'password'; 
FLUSH PRIVILEGES 
</code></pre>
<p class="normal">Here’s the command that we ran on the secondary server:</p>
<pre class="programlisting con"><code class="hljs-con">CHANGE MASTER TO MASTER_HOST="192.168.1.184", MASTER_USER='replicate', MASTER_PASSWORD='password'; 
</code></pre>
<p class="normal">Finally, make sure that your primary database and the secondary database both contain the same databases and tables. The primary server won’t be able to update a database on the secondary server if it doesn’t exist there. Flip back to my example usage on <code class="inlineCode">mysqldump</code> if you need a refresher. You should only need to use <code class="inlineCode">mysqldump</code> and import the database onto the secondary server once, since after you get the replication going, any changes made to the database on the primary server should follow over to the secondary. If you have any difficulties with the <code class="inlineCode">mysqldump</code> command, you can manually create <code class="inlineCode">mysampledb</code> and the <code class="inlineCode">Employees</code> table on the secondary server, which is really all it needs for synchronization to start.</p>
<p class="normal">Synchronization should then begin within a minute, but you can execute <code class="inlineCode">STOP SLAVE</code>, followed by <code class="inlineCode">START SLAVE</code>, on the secondary server to force it to try to synchronize again without waiting.</p>
<p class="normal">And that should be all there is to it. At this point, you should have fully functional primary and secondary database servers at your disposal. To get additional practice, try adding additional<a id="_idIndexMarker735"/> databases, tables, and users, and insert new rows into your databases. </p>
<p class="normal">It’s worth mentioning that the users we’ve created here will not be synced to the secondary server, so you can use the commands we used earlier in this chapter to create users on the secondary server if you wish for them to be present there.</p>
<h1 class="heading-1" id="_idParaDest-184">Summary</h1>
<p class="normal">Depending on your skill set, you’re either an administrator who is learning about SQL databases for the first time, or you’re a seasoned veteran who is curious about how to implement a database server with Ubuntu Server. In this chapter, we dove into Ubuntu’s implementation of this technology and worked through setting up our own database server. We also worked through some examples of the MariaDB syntax, such as creating databases, as well as setting up users and their grants. We also worked through setting up primary and secondary servers for replication.</p>
<p class="normal">Database administration is a vast topic, and we’ve only scratched the surface here. Being able to manage MySQL and MariaDB databases is a very sought-after skill for sure. If you haven’t worked with these databases before, this chapter will serve as a good foundation for you to start your research.</p>
<p class="normal">In the next chapter, we’ll use our database server to act as a foundation for Nextcloud, which we will set up as part of our look into setting up a web server. When you’ve finished practicing these database concepts, head on over to <em class="chapterRef">Chapter 14</em>, <em class="italic">Serving Web Content</em>, where we’ll journey into the world of web hosting.</p>
<h1 class="heading-1" id="_idParaDest-185">Further reading</h1>
<ul>
<li class="bulletList">Configuring MariaDB with Option Files: <a href="https://mariadb.com/kb/en/configuring-mariadb-with-option-files/"><span class="url">https://mariadb.com/kb/en/configuring-mariadb-with-option-files/</span></a></li>
</ul>
<h1 class="heading-1">Join our community on Discord</h1>
<p class="normal">Join our community’s Discord space for discussions with the author and other readers: </p>
<p class="normal"><a href="https://packt.link/LWaZ0"><span class="url">https://packt.link/LWaZ0</span></a></p>
<p class="normal"><img alt="" height="177" src="../Images/QR_Code50046724-1955875156.png" width="177"/></p>
</div>
</div></body></html>