- en: '9'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Keeping the Data Safe – Securing a System
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: No one wants to be the headline news story, especially when their data is stolen.
    One of the best ways to help protect your data is to secure the operating system
    and its services. Securing is often compared to an onion, as there are multiple
    layers that are difficult to peel open, each providing some defense against bad
    actors. When bad actors attack your data, it’s not always to steal it; it’s often
    to change it as well. To make matters worse, when you move to the cloud, you will
    have to protect not only against internal threats, such as rogue contractors or
    employees, and external threats, such as hackers attacking the systems, but you
    also have to protect your data against your cloud provider as well. In security,
    you never know who is the bad actor!
  prefs: []
  type: TYPE_NORMAL
- en: It is not just protecting your systems against bad actors; many industries also
    require a strong security stance. This is common with healthcare, which often
    requires security controls for compliance with the **Health Insurance Portability
    and Accountability Act** (**HIPAA**). Businesses that process credit cards must
    meet the **Payment Card Industry Data Security Standard** (**PCI-DSS**) principles,
    and many governmental organizations must implement security standards to be compliant
    with the **Federal Risk and Authorization Management Program** (**FedRAMP**) for
    their cloud workloads.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: Security teams have their own language! The term “bad actors” refers to hackers
    — the folks trying to modify or steal the data. They do this by attacking the
    systems against attack surfaces, basic system components, and services that are
    reachable by the bad guys.
  prefs: []
  type: TYPE_NORMAL
- en: When you secure systems, you must cover more than just one attack surface. These
    attack surfaces can be data at rest, data in motion, services such as HTTP, or
    even the Linux kernel. You also need to use tools that can help identify how the
    system is configured to best protect the data. In this chapter, the goal is to
    give you several recipes to help you identify risks and protect your data.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will cover the following main recipes in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Signing Git commits with GPG
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Encrypting all web traffic
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Encrypting all data at rest
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Validating adherence to a compliance policy
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Port protection and restricting network access
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Keeping SELinux active
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For this recipe, you will need an Oracle Linux 8 system. As with most of these
    recipes, a VM on your desktop using a desktop virtualization product such as Oracle
    VirtualBox is recommended. A small VM with 2 cores, 2 GB RAM, and a few free gigabytes
    of disk space is fine. Ideally, before you start, you should update your system
    to the latest packages available. This only takes a few minutes and can save you
    a ton of time when troubleshooting issues caused by a bug.
  prefs: []
  type: TYPE_NORMAL
- en: Many of the recipes in this book have their related configuration files available
    in GitHub at [https://github.com/PacktPublishing/Oracle-Linux-Cookbook](https://github.com/PacktPublishing/Oracle-Linux-Cookbook).
  prefs: []
  type: TYPE_NORMAL
- en: Signing Git commits with GPG
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This recipe will show you how to digitally sign Git commits and RPM packages
    using a **GNU Privacy Guard** (**GPG**) keypair. A GPG keypair consists of two
    parts: the public key and the private key.'
  prefs: []
  type: TYPE_NORMAL
- en: This is done by creating a GPG keypair and using it to sign Git commits and
    RPM packages.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In order to work with GPG and Git, you first need to install a few packages.
    Normally GPG is installed by default when the package `gnupg2` is installed.
  prefs: []
  type: TYPE_NORMAL
- en: Git should be installed using `dnf install` `git -y`.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The first step is to create a GPG key if you do not already have one. This key
    will be used to sign both your Git commits and RPM packages. To work with the
    GPG key, you can use the `gpg` or `gpg2` commands; both are the same thing, as
    `gpg` links to `gpg2`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The GPG key is created via the command line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'The command will ask for some information, mainly your real name and email
    address. After you enter the information and continue, it will ask you to set
    a passphrase to use the key. Do not forget the passphrase! If you do, the key
    will become unusable and you will lose all data encrypted with the key. You can
    choose not to use a passphrase, but if you do this, you will be asked to verify
    this several times. The output of the key creation should be similar to the following
    screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.1 – GPG keys created](img/B18349_09_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.1 – GPG keys created
  prefs: []
  type: TYPE_NORMAL
- en: Optionally, you can use the `--full-generate-key` option, which can be used
    to create keys stored on hardware devices, among other uses.
  prefs: []
  type: TYPE_NORMAL
- en: Once the key is created, it is put in your keyring, the `pubring.kbx` file in
    the `.gnupg` directory in your home directory. To see all the keys in the file,
    run the `gpg2 --list-keys --``keyid-format=long` command.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `gpg --list-secret-keys` command is used to list the secret keys (i.e.,
    private keys) stored in your GPG keyring. Running the command will show output
    similar to the following figure for GPG keys:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.2 – GPG keys](img/B18349_09_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.2 – GPG keys
  prefs: []
  type: TYPE_NORMAL
- en: 'The output gives several columns of information for each key:'
  prefs: []
  type: TYPE_NORMAL
- en: '`sec`: This column indicates that the key is a secret key.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`rsa2048/4096/...`: This column shows the algorithm and key length used by
    the key. For example, `rsa2048` indicates that the key uses the RSA algorithm
    with a key length of 2,048 bits. If the long format is used, this will also contain
    the key fingerprint after the key length.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`[creation date]`: This column shows the date on which the key was created.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`[expiration date]`: If the key has an expiration date set, it will be shown
    in this column. If not, this column will be empty.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`[uid]`: This column shows the user ID associated with the key. This is usually
    the name and email address of the key’s owner.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`[ssb]`: This column indicates that the key has a corresponding subkey (i.e.,
    a separate key used for encryption, signing, or authentication).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`[expires]`: If the subkey has an expiration date set, it will be shown in
    this column. If not, this column will be empty.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The key fingerprint is a shortened digital representation of the key. It allows
    other people to validate that your public key was sent with no tampering. The
    long key ID format for the GPG command is a 16-character hexadecimal string that
    uniquely identifies a public or private key in GPG. It is often used to refer
    to a specific key when working with GPG.
  prefs: []
  type: TYPE_NORMAL
- en: The long key ID is derived from the full 40-character fingerprint of the key.
    The fingerprint is a cryptographic hash of the key’s public key material, and
    it is used to verify the authenticity of the key. The long key ID is the last
    16 characters of the fingerprint.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that you have a key, we need to import it into Git. In the following example,
    we will use the key `E921BF9E922221B6`. To import the key, we will use the following
    command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we can set Git to sign all commits by default using the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Git can sign both commits and tags using the GPG key. Be careful with Git though,
    as it isn’t consistent. `git tag` uses `-s` to sign tags, but `git commit` uses
    `-s` to add the `-S` actually signs the commit using GPG.
  prefs: []
  type: TYPE_NORMAL
- en: 'To set up a new tag, we will use the Git tag `-s $TAG -``m $TAG_DESCRIPTION`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: You can also set `tag.gpgsign` either globally or per-repo to ensure all tags
    are automatically signed.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we can show the tag with `git` `show v1.0`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'After this, when we check code using Git, add a `-S` option to the command
    to automatically sign the commit with the tag:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: This is not needed if `commit.gpgsign=true` is set either globally or in the
    active Git repo.
  prefs: []
  type: TYPE_NORMAL
- en: Encrypting all web traffic
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'It’s important to encrypt the communication to and from your web servers. Even
    a simple blog or company website with no login has several advantages of being
    encrypted:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Maintaining user trust**: Encrypting your web pages with HTTPS helps establish
    trust between your website and your users. When a user sees the padlock icon in
    their web browser indicating that the connection is secure, they can be more confident
    that their data is being transmitted securely. Browsers will show sites that are
    not encrypted. Chrome and Edge browsers will show text as *not secure* next to
    the URL or as Mozilla’s red slashed padlock.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**SEO benefits**: Google has stated that HTTPS is a ranking factor in their
    search algorithm. This means that websites that use HTTPS may rank higher in search
    results than those that do not.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Browser warnings**: Modern web browsers such as Chrome and Firefox now display
    warning messages when a user visits a non-HTTPS website that collects sensitive
    information. This can discourage users from using your website and negatively
    impact your business.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Compliance**: If your website is subject to certain regulations or standards,
    such as PCI DSS or HIPAA, encrypting your web pages with HTTPS may be required
    to comply with those regulations.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: While SSL is a term that is commonly used, modern systems actually use **Transport
    Layer Security** (**TLS**) as the encryption technology. SSL, being an older technology,
    has some security flaws, which is why TLS was developed as an upgraded version
    of SSL. TLS addresses the existing vulnerabilities of SSL, making it a much safer
    option.
  prefs: []
  type: TYPE_NORMAL
- en: Overall, encrypting web pages with HTTPS is important for protecting sensitive
    data, maintaining user trust, and complying with regulations and standards. It
    is also becoming increasingly important for SEO and avoiding browser warnings
    that may negatively impact your website’s reputation. It’s also easy to do and
    free with services such as Let’s Encrypt ([https://letsencrypt.org/](https://letsencrypt.org/))
    and ZeroSSL ([https://zerossl.com/](https://zerossl.com/)).
  prefs: []
  type: TYPE_NORMAL
- en: Both Let’s Encrypt and ZeroSSL provide free security certificates, including
    SSL/TLS certificates, that are used to encrypt HTTP traffic. SSL/TLS certificates
    are used to encrypt web traffic, allowing for encrypted communication between
    web servers and web browsers. Let’s Encrypt was created to make it easier for
    website owners to obtain SSL/TLS certificates and enable HTTPS on their websites.
    Prior to Let’s Encrypt, obtaining SSL/TLS certificates was often a complicated
    and expensive process involving manual verification and payment to certificate
    authorities. Let’s Encrypt streamlines this process by automating the verification
    process and providing certificates for free.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s Encrypt certificates are trusted by all major web browsers and operating
    systems. They are issued for a period of 90 days and can be renewed automatically
    using an automated client software. Let’s Encrypt also provides an **Automated
    Certificate Management Environment** (**ACME**) protocol that allows web servers
    to automate the process of obtaining, renewing, and revoking certificates.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For this example, you will need a web server running Oracle Linux. The server
    needs to be accessible over the internet so that the Let’s Encrypt system can
    verify the URL. In this example, I will be using a VM on Oracle Cloud, using their
    free tier of service. This VM is running on an Arm-based CPU with 2 cores and
    12 GB RAM. Both ports `80` and `443` are opened up to this server. This process
    works the same regardless of processor type or cloud. The system is running Oracle
    Linux 8 with the latest patches.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To do this, we need to do a few things:'
  prefs: []
  type: TYPE_NORMAL
- en: Install Apache with `mod_ssl` and all its requirements.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Get `acme.sh` from Git.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a cert using the webroot mode. Webroot mode requires that the site is
    accessible from the internet on both ports `80` and `443`. While it is easy to
    implement, there is another verification method using DNS. For more information
    about different challenge types, refer to [https://letsencrypt.org/docs/challenge-types/](https://letsencrypt.org/docs/challenge-types/).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Conduct testing.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Installing Apache with mod_ssl and all its requirements
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'So let’s get started as the root user. First, we need to add some packages:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`httpd` – Apache web server'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`mod_ssl` – enables SSL on Apache'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'You can do this with the following command:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: firewall-cmd --zone=public --permanent --add-service=http
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: firewall-cmd --zone=public --permanent --add-service=https
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'ssltest.talesfromthedatacenter.com. This way, we can later add the SSL certs
    just for this virtual server. As the root, let’s make a directory for the files
    and chown them to the apache user:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: <VirtualHost *:80>
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '# Put this in /etc/httpd/conf.d/ssltest.conf'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Alias /.well-known/acme-challenge/ /var/www/ssltest/.well-known/acme-challenge/
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: <Directory "/var/www/ssltest/.well-known/acme-challenge/">
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Options None
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: AllowOverride None
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: ForceType text/plain
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: RedirectMatch 404 "^(?!/\.well-known/acme-challenge/[\w-]{43}$)"
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: </Directory>
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: RewriteEngine On
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: RewriteCond %{REQUEST_URI} !^/.well-known/acme-challenge [NC]
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: RewriteCond %{HTTPS} off
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: RewriteRule (.*) https://%{HTTP_HOST}%{REQUEST_URI} [R=301,L]
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: </VirtualHost>
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: After you save the file, run an `apachctl configtest`. It is good practice to
    always run this test when you modify the config files.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '80. You should see the default Apache page. Notice, the Not secure flag in
    the upper-left corner! The site is *not* using SSL:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '![Figure 9.3 – Apache test page with no SSL](img/B18349_09_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.3 – Apache test page with no SSL
  prefs: []
  type: TYPE_NORMAL
- en: Getting acme.sh from Git
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Now, we need to grab the `acme.sh` script from Git:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we need to install Git with the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: mkdir acme
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, we can clone from the official Git site ([https://github.com/acmesh-official/acme.sh](https://github.com/acmesh-official/acme.sh))
    with the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: And then run the installer, updating your direcotry and email address as needed.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Creating a cert using the webroot mode
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Next, let’s register for an account, passing an email address as the variable:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, we can run the script, passing the URL and the `apache` home directory
    for the site:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The following figure shows the command running with the new certificate being
    installed by the script.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 9.4 – Certificate to be installed](img/B18349_09_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.4 – Certificate to be installed
  prefs: []
  type: TYPE_NORMAL
- en: The script will restart Apache.
  prefs: []
  type: TYPE_NORMAL
- en: Testing
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'You can now go to the site with an HTTPS. You will see a padlock in the left
    side of the address bar. The site is now secure. This is seen in the following
    figure:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 9.5 – SSL keys installed](img/B18349_09_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.5 – SSL keys installed
  prefs: []
  type: TYPE_NORMAL
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The way this works is the `acme.sh` script generates a temporary key file and
    places it in the `.well-know/acme-challenge` directory. The system then queries
    from the internet to the server to get the file. If it can get to the file, the
    test passes and new keys are issued. It is important to monitor this, as third-party
    security software or SELinux can impact your ability to get to the temporary key
    file.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that the certificate is set up, there is one task left to do to make this
    a refresh. You can easily have the system check daily for a new certificate by
    adding in the following cron job. As a note, you will need to adjust the location
    of the script based on where you installed it. In this case, it was installed
    in `/home/acme/.acme.sh`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: When using keys that automatically update, it is highly recommended to monitor
    your sites consistently for SSL errors. Ideally, you are checking for SSL errors
    once an hour just in case things break. Look in the web server’s SSL logs and
    also run a check with a tool such as wget or curl to verify that the site is running.
    Both wget and curl will fail with an error if the SSL key is invalid.
  prefs: []
  type: TYPE_NORMAL
- en: Encrypting all data at rest
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Encrypting your data in motion is great, but you also need to encrypt the data
    at rest. This is especially important in the cloud, where you are sharing storage
    with many other users. While your cloud provider may offer automatic encryption,
    it is important to remember that if they can decrypt the data automatically, they
    also have access to the keys. To truly protect your data, you need to encrypt
    the data with keys that your cloud does not have access to. This can be done easily
    with **Linux Unified Key Setup** (**LUKS**). Large organizations will also want
    to use **Clevis**, which enables the automatic decryption of data from keys managed
    by a Tang server. The Tang server is used to store and manage the encryption keys.
    In the cloud, this allows you to manage your boot encryption without the cloud
    provider having access to your keys. This process is called **Network Bound Disk**
    **Encryption** (**NBDE**).
  prefs: []
  type: TYPE_NORMAL
- en: NBDE is a security feature used in Oracle Linux that provides disk encryption
    keys during the boot process. NBDE is an extension of regular disk encryption
    and uses a network server to store and provide the encryption keys rather than
    the local machine. Combined with NUKS, this allows both a local key (that requires
    a manual passphrase to use) and an automatic key from the Tang server to decrypt
    the boot drive. This gives you the simplicity of a secure automated boot, but
    in an emergency, you can still boot without the Tang server.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Unlike other recipes, this one will need a minimum of two VMs: one to act as
    the Tang server and the other to act as a client. Both systems should be updated
    to the latest software.'
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this recipe, we will do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a server named `tang`:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Install and configure a Tang server
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Build another server named `clevis`:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Install and configure Clevis
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Configure LUKS to work with Clevis to encrypt a data volume
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Configuring a Tang server
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The Tang server is used by Oracle Linux to provide encryption keys during the
    boot process. Here’s a basic overview of how it operates:'
  prefs: []
  type: TYPE_NORMAL
- en: During the boot process, the remote system contacts the Tang server and requests
    an encryption key
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Tang server generates a random encryption key and sends it back to the remote
    system
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The remote system uses the encryption key to unlock its encrypted drive, allowing
    it to boot
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Tang server discards the encryption key so it cannot be used again
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: One of the key benefits of using a Tang server is that it can provide encryption
    keys to remote systems even if the main encryption key is compromised. This can
    improve the security of the system by limiting the amount of damage that can be
    done if the main encryption key is compromised.
  prefs: []
  type: TYPE_NORMAL
- en: To install the Tang server as the root, we will simply install the software
    with `dnf`, open up the firewall ports, and set the server to run. This is all
    done as the root user.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Installing via `dnf` is easy; just run the following command:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: firewall-cmd --zone=trusted --add-source=192.168.56.0/24
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: firewall-cmd --zone=trusted --add-service=http
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: firewall-cmd --runtime-to-permanent
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Configure the service to start upon booting and also start now with the following
    command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'You can verify that the service is running with the following command:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[root@tang ~]# tang-show-keys'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: RxdbjAY7_N19UEYBO6XIUVosv0s
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[root@tang ~]#'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Next, let’s set up the client system with LUKS to encrypt the data drive.
  prefs: []
  type: TYPE_NORMAL
- en: Setting up LUKS
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'First, install the required packages with the following `dnf` command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[root@clevis ~]# lsblk'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: NAME           MAJ:MIN RM  SIZE RO TYPE MOUNTPOINT
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: sda              8:0    0  100G  0 disk
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: ├─sda1           8:1    0    1G  0 part /boot
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: └─sda2           8:2    0 72.9G  0 part
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: ├─ol-root    252:0    0   50G  0 lvm  /
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: ├─ol-swap    252:1    0  7.9G  0 lvm  [SWAP]
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: ├─ol-var     252:2    0    5G  0 lvm  /var
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: ├─ol-home    252:3    0    5G  0 lvm  /home
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: └─ol-var_log 252:4    0    5G  0 lvm  /var/log
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: sdb              8:16   0   20G  0 disk
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '/dev/sdb with the following command:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '**WARNING: Doing this will delete ALL DATA on the device**, including any partitions:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '![Figure 9.6 – Encrypting the drive](img/B18349_09_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.6 – Encrypting the drive
  prefs: []
  type: TYPE_NORMAL
- en: When running the command, you will also be prompted for a passphrase. **DO NOT
    LOSE THIS** or you will be unable to decrypt the drive manually.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, let’s manually unlock the drive using the previously saved passphrase
    with the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[root@clevis ~]# ls /dev/mapper/datadisk1'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '/dev/mapper/datadisk1 like any normal disk. In the example, let’s create a
    xfs filesystem on /dev/mapper/datadisk1:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'blkid command. The UUID will be used to identify the disk to decrypt it later:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: echo "UUID=58c9f051-f243-4c42-af4f-62d2e3e3b90f /data xfs defaults 0 0" | sudo
    tee -a /etc/fstab
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE31]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE32]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now we can mount the disk with the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, we need to bind a Tang key to the device using Clevis with the following
    command. We will pass the device and Tang server information via the following
    command line. You will need to use the existing LUKS password to add the keys
    to Tang:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '![Figure 9.7 – LUKS with the second slot used](img/B18349_09_07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.7 – LUKS with the second slot used
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we need to configure the disk to decrypt the drive on boot. We first
    need to pull the new UUID of the encrypted drive:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, let’s enable the Clevis service:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: /etc/fstab file for the filesystem, changing the default to _netdev. This will
    allow the device to mount after the other non-encrypted filesystems.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The `/etc/fstab` should look similar to the following screenshot, with the
    UUID of the encrypted drive mounting as a `_netdev`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 9.8 – fstab](img/B18349_09_08.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.8 – fstab
  prefs: []
  type: TYPE_NORMAL
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Clevis and Tang are both software tools that are used to unlock and decrypt
    disks automatically during the boot process of a Linux system.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is a brief overview of how they work:'
  prefs: []
  type: TYPE_NORMAL
- en: During the boot process, the system prompts the user for a passphrase to unlock
    and decrypt the disk.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: With Clevis and Tang, this prompt is replaced with an automated process that
    unlocks and decrypts the disk using a network-based key server.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Clevis and Tang work together to create a *binding* between the encrypted disk
    and the key server. This binding is based on a *policy* that specifies the conditions
    under which the disk can be unlocked.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: When the system boots up, it contacts the key server and requests the decryption
    key for the encrypted disk. The key server checks the policy to determine whether
    the conditions for unlocking the disk have been met.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If the policy conditions are met, the key server sends the decryption key to
    the system, which then uses it to unlock and decrypt the disk.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If the policy conditions are not met, the key server denies the request for
    the decryption key, and the disk remains locked.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: There’s more…
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Optionally, you can also modify the system to allow an admin to manually enter
    the initial password when the system boots. To do this, install `clevis-dracut`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, rebuild the boot files:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'When the system boots, you will have the opportunity to enter the passphrase
    manually:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.9 – Manual passphrase entry](img/B18349_09_09.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.9 – Manual passphrase entry
  prefs: []
  type: TYPE_NORMAL
- en: Now you have an encrypted filesystem with an automatic way to decrypt it, as
    well as a manual method for use in emergencies.
  prefs: []
  type: TYPE_NORMAL
- en: Validating adherence to a compliance policy
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Securing systems is much more than encrypting data at rest or in motion. Many
    configuration files should be checked, along with other common security settings.
    This can be done automatically using **Security Content Automation Protocol**
    (**SCAP**) files. SCAP is a standardized framework that is used to automate the
    process of maintaining the security of computer systems. It is a suite of specifications
    that provide a standardized approach to security automation, enabling organizations
    to implement consistent and repeatable security practices across their IT infrastructure.
  prefs: []
  type: TYPE_NORMAL
- en: SCAP defines a common language for communicating security-related information,
    which allows security tools and products from different vendors to work together
    seamlessly. It includes a set of standards and guidelines for creating and sharing
    security content, such as vulnerability data, security checklists, and configuration
    baselines. Some of the key components of SCAP include the **Common Vulnerabilities
    and Exposures** (**CVE**) database, which is used to identify and track known
    security vulnerabilities, and the **Common Configuration Enumeration** (**CCE**)
    database, which provides a standardized method for identifying configuration settings
    that are relevant to security.
  prefs: []
  type: TYPE_NORMAL
- en: The easiest way to do this is to use a tool called OpenSCAP, which comes with
    Oracle Linux.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As with the other test, we will need an Oracle Linux system to play with. Nothing
    else is required other than the ability for the system to access a `dnf` repository
    to install additional packages.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The first step is to install OpenSCAP, usually by installing the entire suite
    of tools:'
  prefs: []
  type: TYPE_NORMAL
- en: '`scap-workbench`: A GUI'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`openscap-scanner`: Scans systems'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`openscap`: The OpenSCAP core'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`openscap-utils`: Several command-line tools for scanning systems and containers'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`scap-security-guide`: Commonly used SCAP files'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'This is done via `dnf` with the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'Once OpenSCAP is installed, you have two ways to run the tool: via a GUI or
    by using the command line. To start the GUI, run `scap-workbench`. This launches
    an easy-to-use GUI that will let you run scans.'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: If you install `scap-workbench` and X11 is not installed, `dnf` will install
    it. If you are not using X11 on your servers, consider installing the `scap-workbench`
    on a WSL Oracle Linux system or a system with X11\. You can also install SCAP
    Workbench on a Windows desktop. Downloads for Windows can be found on the Open
    SCAP website, [https://www.open-scap.org/](https://www.open-scap.org/).
  prefs: []
  type: TYPE_NORMAL
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: While many users run the GUI, you can also use a command line.
  prefs: []
  type: TYPE_NORMAL
- en: 'When the GUI Launches, you need to pick the type of systems you wish to scan.
    Here, OL8 is being used:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.10 – Workbench launch](img/B18349_09_10.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.10 – Workbench launch
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, select the profile you wish to use for the scan. The profile is the standard
    that you are comparing to. You must pick one of the profiles to continue:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.11 – SCAP profiles](img/B18349_09_11.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.11 – SCAP profiles
  prefs: []
  type: TYPE_NORMAL
- en: 'The families of profiles included are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**ANSSI-BP**: ANSSI-BP is a set of security recommendations developed by the
    **French National Agency for the Security of Information Systems** (**ANSSI**)
    to provide guidance on securing information systems. The ANSSI-BP recommendations
    cover a wide range of topics, including network security, secure software development,
    access control, cryptography, incident response, and security monitoring.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**CJIS**: The **Criminal Justice Information Services** (**CJIS**) are a division
    of the **Federal Bureau of Investigation** (**FBI**) in the United States. The
    CJIS division is responsible for providing law enforcement agencies with access
    to criminal justice information systems, which includes databases of criminal
    records, fingerprints, and other related information. The CJIS division was established
    in 1992 and provides services to more than 18,000 law enforcement agencies across
    the United States. Its mission is to provide accurate and timely information to
    law enforcement officials to help them solve and prevent crimes, while also ensuring
    the privacy and security of the information.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**NIST-800**: NIST-800 refers to a series of guidelines and standards for information
    security developed by the **National Institute of Standards and Technology** (**NIST**)
    in the United States. The NIST-800 series includes a set of publications that
    provide guidance on various aspects of information security, such as risk management,
    security controls, and incident response. The NIST-800 series is widely used by
    government agencies, private sector organizations, and other entities to improve
    the security of their information systems. The publications in the series are
    regularly updated to reflect changes in the threat landscape and advancements
    in security technology.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**ACSC**: The **Australian Cyber Security Centre** (**ACSC**) is a government
    agency that is responsible for enhancing the cyber security capabilities and resilience
    of the Australian government, businesses, and the community. The ACSC was established
    in 2014 and is a part of the **Australian Signals** **Directorate** (**ASD**).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**HIPAA**: The **Health Insurance Portability and Accountability Act** (**HIPAA**)
    is a federal law in the United States that protects healthcare information. This
    law establishes standards for protecting the privacy and security of individuals’
    health-related information. HIPAA includes specific requirements for securing
    **electronic protected health information** (**ePHI**), which is health information
    that is stored or transmitted electronically.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**PCS-DSS**: The **Payment Card Industry Data Security Standard** **(PCI-DSS)**
    is a set of security standards established by major credit card companies that
    ensure that organizations that have access to credit card details protect the
    confidentiality and integrity of cardholder data. PCI-DSS is designed to reduce
    the risk of data breaches and credit card fraud.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**STIG**: **STIG** stands for **Security Technical Implementation Guide**,
    which is a set of guidelines developed by the **Defense Information Systems Agency**
    (**DISA**) in the United States for securing information systems and software
    used by the **Department of Defense** (**DoD**). STIG provides detailed information
    on how to configure and maintain various technologies to meet DoD security requirements
    and ensure that systems are hardened against cyberattacks.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When picking a standard, you can use the default generic standards (such as
    the *Standard System Security Profile for Oracle Linux 8* found at [https://static.open-scap.org/ssg-guides/ssg-ol8-guide-standard.html](https://static.open-scap.org/ssg-guides/ssg-ol8-guide-standard.html))
    or a standard that aligns with the workload. For example, for healthcare, HIPAA
    is likely the appropriate standard. If you are in the US Federal Government ecosystem,
    the STIG standard is widely used even outside of the DoD. Once you pick the standard,
    you have several additional options, as seen in the following screenshot. You
    can pick a local or remote machine, as well as a remediation role. The remediation
    role allows the system to automatically resolve issues if possible, but any admin
    should be careful using this. This is because many of the standards can break
    system functionality. Always be careful when automatically remediating issues,
    especially with the more stringent standards, such as STIG and CJIS.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.12 – Scan settings](img/B18349_09_12.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.12 – Scan settings
  prefs: []
  type: TYPE_NORMAL
- en: Once you have made your choices, select **Scan**.
  prefs: []
  type: TYPE_NORMAL
- en: 'Depending on the standard used, the scan can run in as fast as a few seconds
    or take over 20 minutes. When the scan is complete, you can use the GUI to review
    the results:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.13 – Scan results](img/B18349_09_13.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.13 – Scan results
  prefs: []
  type: TYPE_NORMAL
- en: 'Not all fixes involve changing a simple setting. Some may require additional
    filesystems or kernel settings. To see the details of a finding, simply expand
    the results as seen in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.14 – Result details](img/B18349_09_14.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.14 – Result details
  prefs: []
  type: TYPE_NORMAL
- en: 'At the bottom of the summary, you have several options:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.15 – Report options](img/B18349_09_15.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.15 – Report options
  prefs: []
  type: TYPE_NORMAL
- en: 'These options are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Save Results**: Saves the results as a HTML file, an **Asset Reporting File**
    (**ARF**) file, or an **Extensible Configuration Checklist Description Format**
    (**XCDDF**) file'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Generate remediation role**: Generates a script in bash, Ansible, or Puppet
    format to automate the remediation of the server'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Show Report**: Opens up the HTML-formatted report in a browser'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Port protection and restricting network access
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Oracle Linux has a firewall built into the distribution. This firewall is called
    **firewalld**, short for **firewall daemon**. firewalld is a dynamic firewall
    management tool used on Linux systems that provides a simple and consistent way
    to manage firewall rules across different distributions. It is designed to allow
    administrators to manage firewall rules in a flexible and efficient way.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'As with the other test, we will need an Oracle Linux system to play with. Nothing
    else is required. The system is enabled by default on most installations. To check
    the status of the daemon, you can use the `systemctl` command as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'The output is displayed in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.16 – firewalld status](img/B18349_09_16.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.16 – firewalld status
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'You can see the current configuration using the `firewall-cmd` with the `--``list-all`
    option:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'This will show the following information:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.17 – firewall-cmd --list-all](img/B18349_09_17.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.17 – firewall-cmd --list-all
  prefs: []
  type: TYPE_NORMAL
- en: 'The output of the preceding command displays a comprehensive summary of the
    active firewall rules and configurations managed by firewalld on a Linux system.
    The output is organized into several sections:'
  prefs: []
  type: TYPE_NORMAL
- en: '`public` (active): This line displays the name of the active firewall zone,
    which in this example is the public zone. When `Target:default` is present, this
    indicates that this is the default zone and that it is currently active.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`interfaces: enp0s3 enp0s8`: This line shows the network interface(s) that
    is assigned to the active firewall zone. In this example, both the `enp0s3` and
    `enp0s8` interfaces are assigned to the public zone.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`sources`: This line displays the IP addresses or network ranges that are allowed
    to access the firewall zone. If no sources are defined, this line will be blank.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`services: cockpit dhcpv6-client ssh`: This line lists the services that are
    allowed to access the firewall zone. In this example, incoming traffic for the
    cockpit, `dhcpv6-client`, and `ssh` services are allowed.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ports`: This line shows the TCP and UDP ports that are allowed to access the
    firewall zone. If no ports are defined, this line will be blank.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`protocols`: This line shows protocols, such as TCP/UDP/ICMP, that are managed
    at a protocol level.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`forward`: This shows whether zone forwarding is enabled.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`masquerade: no`: This line indicates whether masquerading is enabled or disabled
    for the firewall zone. Masquerading allows packets from one network to appear
    as if they are coming from another network.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`forward-ports`: This line shows any forwarded ports that are defined for the
    firewall zone. Forwarded ports allow incoming traffic on a specific port to be
    redirected to a different port or IP address.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`source-ports`: This line shows any source ports that are defined for the firewall
    zone. Source ports allow incoming traffic from a specific port to be redirected
    to a different port or IP address.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`icmp-blocks`: This line displays any **Internet Control Message Protocol**
    (**ICMP**) packets that are blocked by the firewall. ICMP packets are used for
    network diagnostics and troubleshooting.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`rich rules`: This line shows any rich rules that are defined for the firewall
    zone. Rich rules allow more complex rules to be defined using a syntax that is
    similar to the `iptables` syntax.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Adding new rules is easy to do. A rule can be added using the service name
    (found in the `/etc/services` file) or the port number. The most common task is
    to add a common user service, such as `http` or `mysql`. This is done by adding
    the `--add-service` option to the command. When the service is added, the configuration
    will not survive a reboot unless the `--permanent` option is added. Some common
    examples are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'Optionally, you can specify the protocol and port to allow the service. The
    following are examples of adding TCP or UDP ports:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'You can also remove a port or service by using the `--remove-port` or `--``remove-service`
    options:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'When you are done making changes, you will need to reload the firewall rules.
    This is done with the `--``reload` option:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: firewalld is based on the netfilter framework, which is a set of hooks that
    allows network packets to be filtered by the kernel. This framework is used to
    implement the iptables firewall on many Linux systems. firewalld provides a higher-level
    abstraction of the netfilter framework, allowing administrators to define rules
    in terms of services, ports, and protocols rather than directly manipulating iptables
    rules. One of the key advantages of firewalld is its ability to define firewall
    rules that match on multiple attributes. For example, administrators can define
    a rule that matches on both the source and destination IP address, as well as
    the protocol and port number. This allows more granular control over network traffic
    and makes it easier to define complex firewall policies.
  prefs: []
  type: TYPE_NORMAL
- en: firewalld also allows administrators to define firewall rules in terms of network
    zones. A zone is a set of network interfaces that are assigned a specific level
    of trust. For example, an administrator might define a public zone for network
    interfaces that are exposed to the internet and a trusted zone for network interfaces
    that are only accessible from trusted internal networks. Each zone can have its
    own set of firewall rules, allowing administrators to apply different policies
    to different network interfaces.
  prefs: []
  type: TYPE_NORMAL
- en: Keeping SELinux active
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**SELinux**, or **Security-Enhanced Linux**, is a security module that provides
    **mandatory access control** (**MAC**) policies in the Linux kernel. It is needed
    because it offers a higher level of security for Linux systems by enforcing strict
    rules on what processes and users can do on the system. By default, Linux uses
    **discretionary access control** (**DAC**), which means that any user or process
    can access any file or resource, as long as they have the appropriate permissions.
    This can lead to security vulnerabilities, as any compromised process or user
    can potentially access and modify sensitive data or system files.'
  prefs: []
  type: TYPE_NORMAL
- en: SELinux adds an extra layer of security by enforcing mandatory access control
    policies that restrict access to files and resources based on the security context
    of the process or user. This means that even if a process or user has the appropriate
    permissions, they will only be able to access resources that are explicitly allowed
    by the SELinux policy.
  prefs: []
  type: TYPE_NORMAL
- en: This recipe will cover how to create a custom SELinux policy instead of disabling
    it and how to allow services to do things such as bind to low ports (<`1024`).
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'As with the other test, we will need an Oracle Linux system to play with. Nothing
    else is required. The system is enabled by default on most installations. To see
    the status of SELinux, you can use the command `getenforce`. The command will
    return the current active state. There are three states:'
  prefs: []
  type: TYPE_NORMAL
- en: '`enforcing` – SELinux is active and blocking activity that is not allowed'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`permissive` – SELinux is enabled, but will not block any activity'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`disabled` – SELinux is disabled'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Addition commands are available if you install the `setools` using `dnf`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'You can also use the command `sestatus` to get more information about SELinux:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: You can also use the SELinux type to manage resources. SELinux types are labels
    used to classify various resources in a Linux system, such as processes, files,
    directories, and network ports. SELinux types are an important part of SELinux
    security policies, as they determine which processes and users can access specific
    resources on the system.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are several types of SELinux types, including the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '**User types**: User types are used to define the security context of a user.
    They are also used to confine the actions of a user to a specific set of resources
    on the system.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Role types**: Role types are used to define the security context of a role.
    They are also used to confine the actions of a user to a specific set of resources
    on the system.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Domain types**: Domain types are used to define the security context of a
    process. Each process on the system is assigned a unique domain type, which determines
    which resources the process can access.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Type enforcement types**: Type enforcement types are used to define the security
    context of a file or directory and confine the actions of a process to a specific
    set of resources on the system.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Network port type**s: Network port types are used to define the security
    context of a network port. Network port types are used to restrict network access
    to specific ports or services on the system.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In addition to these types, there are also several special types used by SELinux,
    such as the `unconfined_t` type, which is used for processes that are not confined
    by SELinux, and the `system_u` and `root_t` types, which are used for system resources
    and processes.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The state of SELinux can be changed on the fly using the command `setenforce`
    with the parameters `1` or `0`. Using `1` puts SELinux into `enforcing` mode,
    while `0` puts it into `permissive` mode.
  prefs: []
  type: TYPE_NORMAL
- en: Additionally, you can edit the configuration file, `/etc/selinux/config`, and
    set the field SELinux to any one of the three states. This is also the only way
    to disable SELinux.
  prefs: []
  type: TYPE_NORMAL
- en: While disabling SELinux is tempting for many admins, it can easily be updated
    to allow the required behavior.
  prefs: []
  type: TYPE_NORMAL
- en: SELinux also logs to the `/var/log/audit/audit.log` file by default.
  prefs: []
  type: TYPE_NORMAL
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: SELinux has several layers of security managing files, ports, and kernel modules.
    They are all managed by the `semanage` command.
  prefs: []
  type: TYPE_NORMAL
- en: semanage
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '`semanage` is a command-line tool used that''s to manage SELinux policies in
    Linux systems. It is used to create, modify, or delete SELinux policies, as well
    as manage file contexts and network ports. Here are some common uses of the `semanage`
    command:'
  prefs: []
  type: TYPE_NORMAL
- en: '`semanage` can be used to create, modify, or delete policy modules. For example,
    you can create a new policy module with the following command:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`semanage` can be used to manage file contexts, including adding or modifying
    contexts for specific files or directories. For example, you can add a new file
    context with the following command:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`semanage` can be used to manage network ports and services, including adding
    or modifying port types and policies. For example, you can define a new port type
    with the following command:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`setsebool`: SELinux has Boolean variables that can be either enabled or disabled
    to control specific security policies. To change the value of these variables,
    you can use the `setsebool` command to enable or disable certain SELinux policies.
    A useful example is when you set `httpd_can_network_connect` to true for a web
    server:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: getsebool httpd_can_network_connect
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: httpd_can_network_connect --> off
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: SELinux fixfiles
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'SELinux `fixfiles` is a command-line tool that''s used to restore the SELinux
    file contexts of files and directories. SELinux uses file contexts to determine
    which processes and users can access specific files or directories on the system.
    When file contexts are changed or corrupted, it can cause issues with system functionality
    or security. The `fixfiles` command is used to restore the SELinux file contexts
    to their default values. This can be useful when you encounter issues with file
    access or SELinux-related errors. Here are some common ways to use the `fixfiles`
    command:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Restore default file contexts for a directory**: To restore the default file
    contexts for a specific directory, you can use the following command:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This will recursively restore the default file contexts for all files and directories
    within the specified directory.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**Restore default file contexts for the entire system**: To restore the default
    file contexts for the entire system, run the following command:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This will restore the default file contexts for all files and directories on
    the system. Note that this can take some time to complete and may cause temporary
    disruptions to system functionality.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**Verify file contexts**: You can use the following command to verify the file
    contexts for a specific file or directory:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: 'If SELinux was disabled for any amount of time, these contexts would not have
    been set while it was not running. There is a shortcut to get SELinux to re-label
    the entire filesystem hierarchy: `#` `touch /.autorelabel`'
  prefs: []
  type: TYPE_NORMAL
- en: Now reboot the machine. As SELinux starts, it will set all file and security
    contexts to the default for each type and location.
  prefs: []
  type: TYPE_NORMAL
- en: SELinux users
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: SELinux users are labels used to classify different types of users in a Linux
    system. SELinux users are an important part of SELinux security policies, as they
    are used to confine the actions of a user to a specific set of resources on the
    system.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are several types of SELinux users:'
  prefs: []
  type: TYPE_NORMAL
- en: '**System users**: System users are users that are defined by the system and
    are used to run system services or daemons. These users are typically assigned
    a unique SELinux user label, which is used to confine the actions of the user
    to a specific set of resources on the system.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Login users**: Login users are users that are defined by the system and are
    used to log into the system. These users are typically assigned a unique SELinux
    user label, which is used to confine the actions of the user to a specific set
    of resources on the system.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Staff users**: Staff users are users that are defined by the system and are
    used by staff members to perform their work. These users are typically assigned
    a unique SELinux user label, which is used to confine the actions of the user
    to a specific set of resources on the system.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**User-defined users**: User-defined users are users that are defined by the
    system administrator. These users are typically assigned a unique SELinux user
    label, which is used to confine the actions of the user to a specific set of resources
    on the system.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Here are some of the commonly used SELinux user commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '`semanage user`: This command is used to manage SELinux users and their properties.
    For example, to create a new SELinux user, you can use the command `semanage user
    -a -R "s0-s0:c0.c1023" -r s0 -L s0:c0.c1023 -P user -``n username`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`semanage login`: This command is used to manage SELinux login mappings, which
    map system users to SELinux users. For example, to create a new login mapping,
    you can use the command `semanage login -a -s user_u -r` `s0 username`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`semanage staff`: This command is used to manage SELinux staff mappings, which
    map staff users to SELinux users. For example, to create a new staff mapping,
    you can use the command `semanage staff -a -s user_u -r` `s0 username`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`semanage sudo`: This command is used to manage SELinux sudo mappings, which
    map sudoers to SELinux users. For example, to create a new sudo mapping, you can
    use the command `semanage sudo -a -r s0 -R "s0-s0:c0.c1023" -L s0:c0.c1023 -``U
    username`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`semanage port`: This command is used to manage SELinux port mappings, which
    map ports to SELinux types. For example, to create a new port mapping, you can
    use the command `semanage port -a -t http_port_t -p` `tcp 80`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
