- en: '7'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Oracle Linux 8 – Patching Doesn’t Have to Mean Rebooting
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: I’ve rebooted when patching for my entire life, why change now?
  prefs: []
  type: TYPE_NORMAL
- en: Since Linux was released back in 1991, when the kernel was patched, you had
    to reboot the system. At the time, even the IBM mainframes that dominated corporate
    IT needed to be rebooted when patched, so it was considered normal for all other
    systems to be rebooted when patched. This process appeared to work fine for almost
    the next 20 years, but the seeds of change were planted in 2005 when a **Massachusetts
    Institute of Technology** (**MIT**) student came up with a simple question. *What
    if you could patch without rebooting the system?* His team came up with an answer
    in 2009 when Ksplice was released, enabling the ability to patch a Linux kernel
    while the system was running.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will cover why you should start using Ksplice and how it
    is used to improve the security of your system.
  prefs: []
  type: TYPE_NORMAL
- en: 'This chapter contains the following recipes:'
  prefs: []
  type: TYPE_NORMAL
- en: Setting up Ksplice with internet access
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using Ksplice with no internet access
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Installing and enabling Known Exploit Detection
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Setting up Ksplice with internet access
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Before we get into the recipe, let’s understand what’s all the fuss around Ksplice.
  prefs: []
  type: TYPE_NORMAL
- en: What’s all the fuss about Ksplice?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The first question is, *Why is this important to IT, and more importantly, to
    defending the applications running on the servers?* Before we get to that, you
    first need to understand the process that hackers use to compromise systems.
  prefs: []
  type: TYPE_NORMAL
- en: 'The basic process includes three main stages: reconnaissance, gaining access,
    and then maintaining access. Once a system is compromised, the process is repeated
    on other systems on the network:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.1 – Security life cycle](img/B18349_07_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7.1 – Security life cycle
  prefs: []
  type: TYPE_NORMAL
- en: 'In the first phase, **reconnaissance**, hackers use a variety of methods to
    scan the system for vulnerabilities. Often, this attacking phase against servers
    starts after hackers have gained access to a low-level support account that has
    access to the server. Once there, it is a trivial task to look at the kernel version
    and identify what vulnerabilities the kernel is susceptible to. Oracle offers
    a free site ([https://ksplice.oracle.com/inspector](https://ksplice.oracle.com/inspector))
    that lets you easily check the vulnerabilities of the kernel. The results of such
    a check are shown in *Figure 7**.2*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.2 – Ksplice Inspector](img/B18349_07_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7.2 – Ksplice Inspector
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: The MITRE Corporation is a non-profit company funded by the US federal government
    that researches ways to improve safety across multiple industries, including aviation,
    healthcare, homeland security, defense, and cybersecurity. The **Common Vulnerabilities
    and Exposures** (**CVE**) program was launched in 1999 and quickly became the
    go-to location to track cybersecurity vulnerabilities. More information about
    the CVE program can be found at [https://cve.org](https://cve.org).
  prefs: []
  type: TYPE_NORMAL
- en: Not only will the system identify the CVE that the kernel is susceptible to
    but it also links to the MITRE site with the CVE details. In the example report,
    you can see the kernel is susceptible to several CVEs, including a few that would
    allow the attacker to gain root access. Surprisingly, unlike other similar technologies,
    Ksplice also helps defend against this phase with its ability to detect attacks
    against the running kernel, seeking to gain privileged escalation using the **Known
    Exploit Detection** technology. This effectively turns every system using Ksplice
    into a free intrusion detection system for the kernel.
  prefs: []
  type: TYPE_NORMAL
- en: In the next phase, gaining access, the hacker exploits the vulnerability, gaining
    access to the data. This is often done weeks after the initial discovery phase.
    Hackers take their time; they do this to run under the radar, and they know that
    most environments are only patched on a quarterly basis at best. Additionally,
    many attacks come from inside the organization, from people who have limited access
    to systems as part of their normal role. Ksplice disrupts this pattern, enabling
    the system admin to easily patch daily, closing the window of opportunity for
    the hacker.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the last phase, the hackers work to maintain access, often using the same
    vulnerability to continually mine the system for data. Ksplice allows this to
    also be shut down, as it closes the vulnerability not only for exploits post-patch
    but also shuts down the exploit for the attack while in progress. This is an important
    feature of Ksplice: the ability to patch the kernel and close the exploit while
    the exploit is being used. This shuts down the exploit mid-flight, significantly
    enhancing the system’s security.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, about that patching effort – once a quarter at best? Kernel patches are
    released almost daily, yet systems can remain unpatched for almost a quarter of
    the year or more. This gives attackers a huge window of opportunity to compromise
    your systems. Not only is scheduling the patch a challenge for most mission-critical
    systems but the patch process itself is very time- and labor-intensive. Let’s
    look at why this is the case. As seen in the following diagram, there are many
    steps required to patch a server:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.3 – Legacy patch process](img/B18349_07_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7.3 – Legacy patch process
  prefs: []
  type: TYPE_NORMAL
- en: 'The following list provides a short description of each of these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Block users from accessing the application**: Disable load balancers or disable
    user logins to the application so users do not accidentally corrupt data.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Shut down the application**: Shut down the databases, application servers,
    schedulers, load balancers, and so on. This is to prepare for the operating system
    reboot.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Sanity reboot the servers**: Perform a reboot of the servers, with no other
    changes made. This is to verify that the servers can perform a clean reboot. Often
    in this step, a snapshot is made of the app servers.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Restart the application**: Start the application back up to verify that it
    is working. This is to verify the sanity reboot.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Test post sanity reboot**: Often, some changes get made to the application
    and/or its infrastructure that can cause issues with the application. This step
    verifies that there is a good system before the patches are applied.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Shut down the application**: Shut everything down again to prepare for the
    patching.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Patch the servers**: Apply the operating system patches.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Reboot post patch**: Reboot so the patches take effect.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Restart the application**: Restart the application again.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Test the application**: Test the application, and verify all is good.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Let users back in**: Allow users back into the application.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: Not every organization follows the full path process, skipping steps to save
    some time. While this can save some time in the short term, all it takes is one
    bad patch cycle where changes were made to the application and/or its infrastructure
    between patch cycles to make for a very bad, long night, or worse, long days.
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, properly patching takes a lot of time, and the more complex
    the application, the more people and time are required for each patch cycle. Most
    of this time and effort is caused due to the reboots required.
  prefs: []
  type: TYPE_NORMAL
- en: When you avoid the reboot, the patch process is significantly simplified; as
    shown in the following diagram, there are only two steps!
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.4 – Ksplice patching process](img/B18349_07_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7.4 – Ksplice patching process
  prefs: []
  type: TYPE_NORMAL
- en: 'The following list provides a short description of these two steps:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Ksplice the servers**: Apply the kernel and user space patches with ksplice.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Testing**: Test the application'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By using Ksplice, your team can save a ton of time, reduce late nights, and
    improve security. Best of all, it’s easy to set up and use!
  prefs: []
  type: TYPE_NORMAL
- en: Discovering Ksplice
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Ksplice is easy to configure. There are a few concepts and points you need
    to understand before Ksplicing your servers:'
  prefs: []
  type: TYPE_NORMAL
- en: If your servers are running on **Oracle Cloud Infrastructure** (**OCI**), using
    Oracle’s default platform images, all the Ksplice preparation work and access
    to the Ksplice repo is already performed to support online Ksplice usage. Systems
    will also need a route (usually done with a NAT gateway) to the Ksplice endpoint.
    This is automatically set up when using the **Virtual Cloud Network** (**VCN**)
    wizard.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If you are using Autonomous Linux on OCI, your systems are already being Kspliced
    automatically.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'There are two Ksplice clients: the legacy Uptrack client and the Enhanced client.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You do not need internet access to use Ksplice; you can use specially built
    Ksplice `.rpm` files using the offline mode. This will require that you mirror
    the ULN Ksplice repos on a local YUM server. This was covered in [*Chapter 5*](B18349_05.xhtml#_idTextAnchor135).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Both the Enhanced client and the Uptrack client allow you to Ksplice the kernel,
    but the Enhanced client also offers the ability to Ksplice user space libraries,
    KVM hypervisors, and Arm-based systems and offers Known Exploit Detection on x86_64
    platforms. Most new users should use the Enhanced client.
  prefs: []
  type: TYPE_NORMAL
- en: The older Uptrack client does not offer the advantages the Enhanced client offers,
    but it does support the ability to patch some non-Oracle Linux systems.
  prefs: []
  type: TYPE_NORMAL
- en: 'Ksplice offers two different modes: the online mode and the offline mode. The
    online mode requires that each system registers to the Oracle ULN but offers a
    Ksplice web interface, the Ksplice Uptrack API, for advanced automation and the
    ability to patch a Xen hypervisor. However, since this requires every system to
    not only register with ULN but also for internet access, many system administrators
    use the offline mode.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The offline mode allows the system to use Ksplice without internet access.
    This is most often used by Enterprise and Government environments where all servers
    do not have internet access. In these use cases, the most common method is to
    set up a ULN mirror, giving that system access to the internet, and the local
    Oracle Linux servers will pull from that mirror to use Ksplice:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.5 – Ksplice offline mode using RPMs](img/B18349_07_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7.5 – Ksplice offline mode using RPMs
  prefs: []
  type: TYPE_NORMAL
- en: 'With the offline mode, only the local ULN mirror needs to be able to access
    the Oracle ULN, via the HTTPS protocol. This can be done via a basic firewall
    rule or a more advanced proxy server. Once the ULN mirror is registered and synced
    from the ULN, the servers behind the firewall can pull their RPMs via HTTP/HTTPS
    from the ULN mirror. There are a couple of advantages to the offline mode: less
    bandwidth is used for the internet and not every client needs to be registered.
    Of course, having no API, there are some limitations with more advanced automation.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Regardless of what mode is used, the clients must have access to a few specific
    Ksplice channels. The following table describes the channels that are available
    for Ksplice in Oracle Linux:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Channel Name** | **Enhanced** **Client** | **Channel Label** | **Description**
    |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| Ksplice for Oracle Linux 7 (x86_64) | Optional | `ol7_x86_64_ksplice` | Ksplice
    RPMs for Oracle Linux 7 on x86_64 systems |'
  prefs: []
  type: TYPE_TB
- en: '| Ksplice for Oracle Linux 7 (aarch64) | Optional | `ol7_aarch64_ksplice` |
    Ksplice RPMs for Oracle Linux 7 on aarch64 systems |'
  prefs: []
  type: TYPE_TB
- en: '| Ksplice for Oracle Linux 8 (x86_64) | Optional | `ol8_x86_64_ksplice` | Ksplice
    RPMs for Oracle Linux 8 on x86_64 systems |'
  prefs: []
  type: TYPE_TB
- en: '| Ksplice for Oracle Linux 8 (aarch64) | Optional | `ol8_aarch64_ksplice` |
    Ksplice RPMs for Linux 8 on aarch64 systems |'
  prefs: []
  type: TYPE_TB
- en: '| Ksplice-aware user space packages for Oracle Linux 7 (x86_64) | Required
    | `ol7_x86_64_userspace_ksplice` | Latest RPMs for Ksplice-aware user space packages
    for Oracle Linux 7 (x86_64) |'
  prefs: []
  type: TYPE_TB
- en: '| Ksplice-aware user space packages for Oracle Linux 7 (aarch64) | Required
    | `ol7_aarch64_userspace_ksplice` | Latest RPMs for Ksplice-aware user space packages
    for Oracle Linux 7 (aarch64) |'
  prefs: []
  type: TYPE_TB
- en: '| Ksplice-aware user space packages for Oracle Linux 8 (x86_64) | Required
    | `ol8_x86_64_userspace_ksplice` | Latest RPMs for Ksplice-aware user space packages
    for Oracle Linux 8 (x86_64) |'
  prefs: []
  type: TYPE_TB
- en: '| Ksplice-aware user space packages for Oracle Linux 8 (aarch64) | Optional
    | `ol8_aarch64_userspace_ksplice` | Latest RPMs for Ksplice-aware user space packages
    for Oracle Linux 8 (aarch64) |'
  prefs: []
  type: TYPE_TB
- en: Table 7.1 – Ksplice channels
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: If `prelink` is installed, revert the pre-linked binaries to their original
    state (`prelink -au`) and then uninstall `prelink` (`dnf remove prelink -y`).
    While not often used, `prelink` is not compatible with Ksplice.
  prefs: []
  type: TYPE_NORMAL
- en: Now that you have an understanding of why you need to use Ksplice and the basics
    of how it works, let’s get to the recipe.
  prefs: []
  type: TYPE_NORMAL
- en: The easiest way to use Ksplice is to allow each system to access the Oracle
    Ksplice service directly. This is called online mode. This can be done via an
    internet proxy, direct access, or by running the systems in OCI.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To do this, you will need a test system, running Oracle Linux 8, with access
    to the internet.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'When using Ksplice, make sure you match each system for both the operating
    system version, and the user-space libraries. Do not use an Oracle Linux 9 repo
    for an Oracle Linux 8 system. An example of what a system should look like can
    be seen in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.6 – Required channels](img/B18349_07_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7.6 – Required channels
  prefs: []
  type: TYPE_NORMAL
- en: 'If you are using an internet proxy server, you will need to export some environmental
    variables to set the proxy servers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Set `proxy_server_URL` to the proxy server, and `http_port` to the port the
    proxy server uses.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, Ksplice will be installed using `dnf`. Both the `ksplice` and `uptrack`
    packages are needed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: When the installation is complete, please verify that your system is seen in
    the ULN and that an access key has been populated in `/etc/uptrack/uptrack.conf`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The access key should be in the `[Auth]` section and should look similar to
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Once done, perform a normal `dnf update` and then reboot the system. This `dnf
    update` is required so the Ksplice-aware user space libraries are loaded; it is
    only required the first time Ksplice is used.
  prefs: []
  type: TYPE_NORMAL
- en: Once the server is rebooted, Ksplice can now be used to patch user space libraries
    and the kernel.
  prefs: []
  type: TYPE_NORMAL
- en: 'To see what updates are available for the kernel, you can run the Ksplice `kernel
    upgrade` command, passing `-n` for no action:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'The output from this command is seen in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.7 – Ksplice available upgrades](img/B18349_07_07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7.7 – Ksplice available upgrades
  prefs: []
  type: TYPE_NORMAL
- en: 'In this system, only one update is available, patching `CVE-2021-4034`. To
    splice the system, run the same command, replacing `-n` with `-y` to say yes to
    applying the kernel path:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.8 – Ksplice updating the kernel](img/B18349_07_08.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7.8 – Ksplice updating the kernel
  prefs: []
  type: TYPE_NORMAL
- en: From here, you can see that the CVE patch has now taken place without a reboot!
  prefs: []
  type: TYPE_NORMAL
- en: The kernel that has been patched is referred to as the effective kernel. When
    you use the `ksplice kernel uname -r` command in Ksplice, it displays the effective
    kernel version, which indicates the current security status of the kernel based
    on the applied patches. This version typically varies from the initially booted
    kernel version and is meant to reflect the present condition of the kernel regarding
    any potential security threats or major issues.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can now validate what your effective kernel is by using the following Ksplice
    command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Note that the version of the running kernel and the installed kernel will not
    match! This is because when Ksplice splices the kernel, it splices the RAM of
    the running kernel with the new code. This patches the kernel (and selected user
    space libraries) but has the effect of `uname` no longer matching the effective
    kernel:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.9 – Ksplice uname](img/B18349_07_09.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7.9 – Ksplice uname
  prefs: []
  type: TYPE_NORMAL
- en: Here, the installed kernel is `5.4.17-2136.302.7.2.1.el8uek.aarch64`, but the
    effective kernel that has been Kspliced is a newer kernel at version `5.4.17-2136.306.1.3.el8uek`.
    This is normal behavior with Ksplice.
  prefs: []
  type: TYPE_NORMAL
- en: 'User space libraries can be patched in the same way, replacing the kernel with
    the user. As a note, if the Ksplice user space libraries are *not* installed,
    the first time the command is run, you will be prompted to upgrade the user libraries
    to a Ksplice-compatible version:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.10 – Installing Ksplice user libraries for the first time](img/B18349_07_10.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7.10 – Installing Ksplice user libraries for the first time
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: 'You can also check user space available packages to Ksplice with the `ksplice
    user show --available` command but if you did not install the Ksplice-aware packages,
    you will get this error:'
  prefs: []
  type: TYPE_NORMAL
- en: '`No active user-space` `Ksplice targets`'
  prefs: []
  type: TYPE_NORMAL
- en: '`Have you installed Ksplice-aware libraries` `and rebooted?`'
  prefs: []
  type: TYPE_NORMAL
- en: 'You can also check what user space targets are currently running and can be
    patched. This is done with the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'The sample output is shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.11 – Ksplice targets](img/B18349_07_11.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7.11 – Ksplice targets
  prefs: []
  type: TYPE_NORMAL
- en: 'The Ksplice command can also be used to roll back a splice. By using the `ksplice
    kernel show` command, you can see all the splices currently installed:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.12 – Installed kernel patches](img/B18349_07_12.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7.12 – Installed kernel patches
  prefs: []
  type: TYPE_NORMAL
- en: Each Ksplice patch has a unique **Ksplice identifier** (**KID**). The KID is
    also unique to the specific kernel build and patch, so when comparing KIDs across
    different kernels, be careful. If using automation to leverage the KID, make sure
    that you limit the automation to systems with the same kernel build and architecture.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is the first column in the list of installed patches. If you need to uninstall
    a specific patch, it is possible. In this example, KID `qd1g4vxd` (CVE-2021-4149:
    denial-of-service in the BTRFS filesystem) will be uninstalled using the Ksplice
    `undo` command, passing the specific KID. You can also pass `-v` for verbose.
    Once uninstalled, check the list of installed KIDs to verify the removal of the
    single KID:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.13 – Ksplice undo](img/B18349_07_13.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7.13 – Ksplice undo
  prefs: []
  type: TYPE_NORMAL
- en: 'Optionally, all installed KIDs can be removed from a running system by using
    the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'This will remove all the KIDs from the running kernel in memory:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.14 – Ksplice remove](img/B18349_07_14.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7.14 – Ksplice remove
  prefs: []
  type: TYPE_NORMAL
- en: Ksplice also allows for automatic updates. They can be enabled or disabled by
    simply touching a file, or removing a file. If the `/etc/uptrack/disable` file
    exists, Ksplice will not automatically update the system when you reboot. If the
    file is not there, then Ksplice will check on reboot for any new KIDs and apply
    them. You can also modify this behavior by updating the `uptrack.conf` file. This
    is covered later in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When you are using Ksplice with internet access, the Ksplice client connects
    to the Oracle ULN Ksplice system, and downloads and applies the required splices.
  prefs: []
  type: TYPE_NORMAL
- en: Using Ksplice with no internet access
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Not all systems have internet access. That is fine, as it’s possible to use
    Ksplice against a local patch repository.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To do this, you will need a test system running Oracle Linux 8, with access
    to a local YUM repository on the network.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To install the client, make sure that your server is using an RPM repo that
    is mirrored locally. To install Ksplice, you must decide on either the online
    or offline client. As a reminder, the online client requires that the system be
    registered with ULN, and the offline client will use a local RPM repository.
  prefs: []
  type: TYPE_NORMAL
- en: 'To install the online client, run the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'To install the offline client, run the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'The output from this command is shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.15 – Offline Ksplice installation](img/B18349_07_15.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7.15 – Offline Ksplice installation
  prefs: []
  type: TYPE_NORMAL
- en: Once Ksplice is installed, you can now splice the server.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: Since the Uptrack client has no advantages over the new client with Oracle Linux
    8 (or Oracle Linux 7 for that matter), we will focus on the Enhanced client. If
    you are using an older operating system, you may need to use the older Uptrack
    client.
  prefs: []
  type: TYPE_NORMAL
- en: 'Ksplice with the offline method is really easy; simply use `dnf` to patch the
    system:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: This will patch in both the normal way and then with Ksplice for the kernel
    and user libraries. If you want to disable this behavior, you can set `skip_apply_after_pkg_install`
    to `true` in `/``etc/uptrack/uptrack.conf`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Before you patch, make sure you have added a Ksplice entry in `/etc/yum.repos.d`.
    A sample Ksplice entry may look like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Ksplice is a tool that allows Linux systems to stay current with security fixes
    and vital updates without requiring system reboots. This is especially beneficial
    for servers and settings that need to stay up and running with little downtime.
    It’s worth noting that while Ksplice can handle many patches, some changes may
    be too intricate to apply in a live environment and will require a traditional
    reboot-based update.
  prefs: []
  type: TYPE_NORMAL
- en: Installing and enabling Known Exploit Detection
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One of the most critical things to do to secure your system (and, more importantly,
    the data in the system) is to implement the ability to detect when the bad guys
    are trying to break in. Ksplice has a unique feature called **Known Exploit Detection**
    (**KED**) that will report on known attacks against the kernel. Normally, only
    exploits that allow the hacker to access additional privileges are instrumented
    for KED and, for these to trigger, the kernel should already have been spliced
    for the vulnerability.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To do this, you will need a test system running Oracle Linux 8, with Ksplice
    set up.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This is done via tripwire code, which is triggered when specific events are
    detected. Normally, only events that enable the attacker to gain privileged access
    are monitored. This package is available on both x86 and ARM systems.
  prefs: []
  type: TYPE_NORMAL
- en: 'To enable this, the pack must first be installed by using the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Regardless of whether the installation is on an ARM or x64 server, the installation
    is almost identical, with the major differences being more about the software
    already installed on each system. This brings a point to mind: regardless of whether
    ARM or x64, the admin tasks are the same.'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: When KED is installed, `postfix` is also installed to enable sending emails
    as part of the notification system.
  prefs: []
  type: TYPE_NORMAL
- en: 'The output from installing this on an ARM-based system is shown in the following
    screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.16 – KED installation on ARM](img/B18349_07_16.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7.16 – KED installation on ARM
  prefs: []
  type: TYPE_NORMAL
- en: 'The output from installing this on an x86_64-based system is shown in the following
    screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.17 – KED installation on x64](img/B18349_07_17.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7.17 – KED installation on x64
  prefs: []
  type: TYPE_NORMAL
- en: 'Once KED is installed, the feature needs to be enabled. This is done by adding
    the following lines to `/``etc/uptrack/uptrack.conf`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, you will need to Ksplice the kernel to enable the feature in the running
    kernel:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'The output for this is shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.18 – Enabling KED in a running kernel](img/B18349_07_18.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7.18 – Enabling KED in a running kernel
  prefs: []
  type: TYPE_NORMAL
- en: As a note, if no Ksplice patches are available, you will get a notification
    that the kernel is up to date, as shown in the preceding screenshot. But if the
    system requires patches, Ksplice will patch the kernel at this time while enabling
    KED.
  prefs: []
  type: TYPE_NORMAL
- en: 'To verify that KED is enabled, `cat /proc/sys/kernel/known_exploit_detection`
    and look for an output of `1`. If the file is missing or there is a zero there,
    KED is not enabled so won’t be monitoring your system:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.19 – Checking whether KED is enabled](img/B18349_07_19.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7.19 – Checking whether KED is enabled
  prefs: []
  type: TYPE_NORMAL
- en: 'Notifications from KED are controlled from the `/etc/log-known-exploit.conf`
    configuration file. A sample configuration file is shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.20 – KED notifications configuration](img/B18349_07_20.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7.20 – KED notifications configuration
  prefs: []
  type: TYPE_NORMAL
- en: 'In the config file, you can control the following actions:'
  prefs: []
  type: TYPE_NORMAL
- en: '`[syslog]`: Most admins log events to syslog for capture and analysis using
    log analytics tools such as OCI Log Analytics or Splunk. The `enabled: 0` setting
    will disable logging to syslog.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`[email]`: This section allows you to enable emails to be sent when a tripwire
    is triggered. Add email addresses for recipients as needed. This will also require
    that the system can send emails, either through a cloud service such as the OCI
    Email Delivery Service or your own **Simple Mail Transport Protocol** (**SMTP**)
    relay.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`[actions]`: You can specifically disable notifications for a specific CVE.
    This is helpful if you have an accidental false positive on a system. To disable
    a CVE, add a line with the CVE and `ignore`. The `default:` parameter sets the
    default behavior for all CVE.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: If you enable email notification, make sure your email subsystem is configured
    before enabling emails from KED.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can also test the system with the `log-known-exploit` command. This will
    log a test message in the kernel:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'The test event will look like the following in `/var/log/messages`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: In the log, you will see the time, the CVE that was triggered, and also the
    **Process ID** (**PID**) and **User ID** (**UID**) of the process and user that
    triggered the event.
  prefs: []
  type: TYPE_NORMAL
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Ksplice installs a piece of tripwire code in the kernel for specific exploits,
    detecting when something tries to exploit the exploit. These triggers then kick
    off the notification subsystem, letting you know when an attack happens.
  prefs: []
  type: TYPE_NORMAL
