- en: '13'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Secure Remote Access with SSH
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The **Secure Shell Protocol** (**SSH**) is a Swiss Army knife – a do-everything
    tool – for creating secure connections and tunneling data through them. During
    your career, you’ll use SSH for a bit of everything:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
- en: Securely logging in to a remote system
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Cloning your private Git repository
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Transferring files from your laptop to a server, or between servers
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Mapping a web service behind a VPN to a local port on your laptop so that someone
    on your home network can use it
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Various other tasks that involve tunneling traffic or sending files through
    multiple network connections
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In this chapter, we’ll give you everything you need to be comfortable with the
    basics. You’ll learn how public key cryptography works, which is essential to
    being able to reason about these kinds of tools and their usage. You’ll create
    SSH keys and use them to log in to a remote server. To cement the basics, we’ve
    even created a small project for you, where you’ll set up key-based logins for
    a remote host that you work with often.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
- en: For those times when you inevitably have issues when using SSH, we’ve collected
    some of the most common SSH errors we see in the wild. You’ll learn what the most
    common error messages indicate, and how to use SSH’s built-in “debug” option to
    troubleshoot your way out of them.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we’ll cover the following topics:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
- en: A primer in public key cryptography
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Message encryption
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Message signing
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: SSH keys
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Converting SSH2 keys to the OpenSSH format
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: File transfer
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: SSH tunneling
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The configuration file
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let’s jump right in with the very basics of what you need to understand about
    public key cryptography so that the rest of this chapter doesn’t just sound like
    obscure black magic to you.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
- en: Public key cryptography primer
  id: totrans-20
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Depending on what path your career has taken, you may have already come across
    the topic of public key cryptography. While cryptography is its own field, and
    this is not a book about cryptography, it *is* important to have an understanding
    of the basics. Thankfully, the core concepts are very simple and will get you
    far. We’ll make this section as short as possible, and then dive right into the
    commands you need to configure and use secure access with SSH.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
- en: Public key cryptography is a system that uses two separate keys, called the
    public key and the private key. Together, these make up what is called a key pair.
    As the names imply, the public key is a key that can be shared with everyone,
    while the private key is supposed to remain private at all costs.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
- en: Message encryption
  id: totrans-23
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Once you’ve created a key pair, any message that has been encrypted using that
    key pair’s public key can be decrypted with the corresponding private key.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
- en: Imagine a person named Alice, who wants to send Bob an encrypted message. To
    do this, Alice downloads Bob’s public key and uses it to encrypt the message.
    Alice then sends the encrypted message to Bob. As he owns the matching private
    key, Bob will be able to decrypt and read the message. Even if someone else sees
    the encrypted message, they won’t be able to decrypt and read it because only
    Bob has the private key.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
- en: For this reason, it is important to *never* share your private key with a third
    party. Doing so would be a breach of security.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
- en: Message signing
  id: totrans-27
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'There is another way to use these two keys: they can be used to sign a message.
    “Signing” a message is a way to cryptographically prove that a message was really
    written by the person owning the key. This makes use of the fact that while a
    message encrypted with the public key can be decrypted with the private key, the
    reverse is also true – a message *encrypted* with the private key can be *decrypted*
    using the public key.'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
- en: When Alice wants to sign a message, the private key can be used to encrypt the
    message (or a cryptographically secure hash of the message). Everyone who possesses
    Alice’s public key can use it to decrypt the message and, if it works, knows that
    it must have been encrypted with Alice’s private key.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
- en: Both mechanisms, encryption and signing, are often used together. Additionally,
    signatures themselves are frequently used to ensure security (by verifying authorship)
    when you’re downloading software, for example, through package managers or app
    stores.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
- en: It’s worth noting that these core public-key encryption and signing mechanisms
    are used for everything from encrypting emails to securing HTTPS web traffic to
    thousands of other things in the modern world. In other words, Alice and Bob don’t
    have to be people; they can be computers, services, and so on.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
- en: Now that you’ve seen the basic cryptographic building blocks that SSH takes
    advantage of to secure your remote access, you’re ready to make practical use
    of all of this fancy technology!
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
- en: SSH keys
  id: totrans-33
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'One of the first things you are likely to do when it comes to SSH is create
    your very own key pair. This will allow you to authenticate to an SSH server.
    A classic command for creating a key pair is this:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: This will create an `ed25519` (a modern elliptic curve cryptography algorithm)
    key pair using `John Doe <john.doe@example.org>` as a comment. Comments are like
    the comments you know from programming languages, in that they can be any string
    of text and won’t interfere with anything on a functional level. In the case of
    SSH, this comment will be appended to your public key, making it easier to distinguish
    keys when they are uploaded to a server, for example, in an `authorized_keys`
    file. Later in this chapter, we’ll dive deeper into the `authorized_keys` files
    and how to use them to set up seamless, secure access to remote servers.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
- en: After you run this command, OpenSSH will ask you a few questions about where
    to store the key files it creates and what password you’d like to use to encrypt
    the private key. Since this will be the key used to access remote systems, make
    sure to set a strong password.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 运行此命令后，OpenSSH 会询问你一些关于存储它创建的密钥文件位置以及你希望用于加密私钥的密码的问题。由于这将是用来访问远程系统的密钥，确保设置一个强密码。
- en: '**Note**'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: By default, keys will be placed in your `~/.ssh` directory.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，密钥将被放置在你的 `~/.ssh` 目录中。
- en: 'Now that you’ve created a key pair, it’s time to reiterate the most important
    practical point: never, ever share the private key. Doing so would allow a third
    party to impersonate you. No service should ever ask you to share your private
    key. The public key, which is supposed to be shared and is safe to make public,
    will contain a `.pub` suffix, so you can tell the difference.'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经创建了密钥对，是时候重申最重要的实用点：永远不要共享私钥。这样做会让第三方冒充你。没有任何服务应该要求你共享私钥。公共密钥应该是共享的，并且可以公开的，它会带有
    `.pub` 后缀，这样你就能区分它。
- en: 'Thankfully, the contents of these files look very different, so if you ever
    get confused, you can peek at them to see which is which:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，这些文件的内容看起来非常不同，因此如果你感到困惑，可以查看它们来判断哪一个是哪个：
- en: The public key is in the format of `<algorithm> <key> <comment>`.
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 公钥的格式是 `<algorithm> <key> <comment>`。
- en: The private key starts with a line like `-----BEGIN OPENSSH PRIVATE KEY-----`,
    followed by the key and a similar ending line.
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 私钥以类似 `-----BEGIN OPENSSH PRIVATE KEY-----` 的行开始，接着是密钥和类似的结束行。
- en: Be careful never to overwrite these key files, and ensure that you have stored
    both of them in a secure backup. Again, your password manager is a good choice
    for this. Many password managers even have a specific option to store private
    key files or generic text.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 小心不要覆盖这些密钥文件，并确保你将它们都存储在一个安全的备份中。同样，密码管理器是一个不错的选择。许多密码管理器甚至有专门选项来存储私钥文件或通用文本。
- en: Exceptions to these rules
  id: totrans-45
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 这些规则的例外
- en: For personal use – on your laptop, for example – you’ll always want to encrypt
    your private key (by specifying a password during key creation), and then never
    share it, as mentioned before.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 对于个人使用——例如在你的笔记本电脑上——你总是希望加密你的私钥（在创建密钥时指定一个密码），然后像之前提到的那样永远不要共享它。
- en: However, there are some situations where it’s okay to break these rules – specifically
    when setting up keys for automated systems to use. If you want your build server
    to authenticate to GitHub before checking out your code base, you’d likely use
    a key pair whose private key is *not* encrypted (unless you want to have to manually
    type in that password every time your build service runs).
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在某些情况下，打破这些规则是可以接受的——特别是在为自动化系统设置密钥时。如果你希望构建服务器在检出代码库之前通过 GitHub 进行身份验证，你可能会使用一个私钥未加密的密钥对（除非你希望在每次构建服务运行时手动输入密码）。
- en: Machine-to-machine authentication and encryption are great reasons to use cryptographic
    key pairs. Just be sure to always make dedicated, single-purpose key pairs for
    jobs like these, and do not reuse or share those key pairs across machines or
    services.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 机器与机器之间的身份验证和加密是使用加密密钥对的一个重要原因。只要确保总是为这些任务创建专用的、单一用途的密钥对，并且不要在不同的机器或服务之间重复使用或共享这些密钥对。
- en: Logging in and authenticating
  id: totrans-49
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 登录和身份验证
- en: 'Logging in to a remote system using SSH-based authentication looks similar
    to this:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 使用基于 SSH 的身份验证登录远程系统的过程类似于这样：
- en: '[PRE1]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '`user` is the username that you want to log in as, and `example.org` is a stand-in
    for any remote system you’d like to connect to. This is often just an IP address,
    as opposed to a fully qualified domain name.'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: '`user` 是你希望登录的用户名，`example.org` 是你想连接的任何远程系统的代号。它通常是一个 IP 地址，而不是一个完全限定的域名。'
- en: 'If you’re logging in with an SSH key, or you need to specify a specific key
    (identity, or `-i)`, it’ll look like this:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你正在使用 SSH 密钥登录，或者需要指定特定的密钥（身份，或 `-i`），它看起来像这样：
- en: '[PRE2]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: When accessing an SSH server that you have never connected to before, you will
    be presented with the fingerprint of the remote server. This allows you to make
    sure that the server you are talking to is indeed the one you intend to connect
    to and that no man-in-the-middle attack is taking place. You should make sure
    this is correct.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 当你访问一个从未连接过的 SSH 服务器时，你将看到远程服务器的指纹。这使你能够确保你连接的服务器确实是你想连接的服务器，并且没有发生中间人攻击。你应该确保这个指纹是正确的。
- en: Once you type `yes` and mark that fingerprint as trusted, it will be saved to
    a file. Should it ever change – for example, if someone sets up a malicious server
    at the same IP address that your trusted server was using before – you will be
    notified by your SSH client, and authentication will not be possible.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦您输入`yes`并将该指纹标记为受信任，它将被保存到一个文件中。如果它发生了变化——例如，如果有人在相同IP地址上设置了一个恶意服务器，您的SSH客户端将通知您，并且身份验证将不可能成功。
- en: After you mark the server as trusted, your local client and the server will
    negotiate which form of authentication to use. OpenSSH offers a wide variety of
    options, with the two most common ones involving a password or a key pair. Depending
    on which is chosen, OpenSSH will ask you to enter the password (or the password
    to decrypt your private key). Once the authentication step succeeds, you will
    be logged in.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 在您将服务器标记为受信任后，您的本地客户端和服务器将协商使用哪种身份验证方式。OpenSSH提供了多种选项，其中最常见的两种涉及密码或密钥对。根据选择的选项，OpenSSH将要求您输入密码（或用于解密私钥的密码）。一旦身份验证步骤成功，您将登录。
- en: 'Practical project: Set up a key-based login to a remote server'
  id: totrans-58
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实际项目：设置基于密钥的登录到远程服务器
- en: Presuming you have access to a long-running Linux server that you want to allow
    key-based login on, follow these steps.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 假设您有权限访问长时间运行的Linux服务器，并希望允许基于密钥的登录，请按照以下步骤操作。
- en: 'Step 1: Open your terminal on the SSH client (not the server)'
  id: totrans-60
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 'Step 1: 在SSH客户端（而非服务器）上打开您的终端'
- en: You’ll be using your local command-line environment for the rest of these steps.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 您将在接下来的步骤中使用本地命令行环境。
- en: 'Step 2: Generate the key pair'
  id: totrans-62
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 'Step 2: 生成密钥对'
- en: If you’ve already set up a key pair because you were following along earlier
    in this chapter, good for you! You can skip this step.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您已经设置了密钥对，因为您之前在本章中跟随了这些步骤，那么太棒了！您可以跳过此步骤。
- en: 'If you don’t yet have an SSH key pair, create one by typing the following command
    and hitting *Enter*:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您还没有SSH密钥对，请输入以下命令并按*Enter*键创建一个：
- en: '[PRE3]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: As mentioned before, we strongly recommend adding a passphrase for extra security.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 正如之前提到的，我们强烈建议添加一个密码短语以增强安全性。
- en: 'Step 3: Copy the public key to your server'
  id: totrans-67
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 'Step 3: 将公钥复制到您的服务器'
- en: After generating the keys, you’ll need to place the public key on your server.
    The public key usually has the extension `.pub` and by default will be located
    in your `~/.ssh` directory.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 生成密钥后，您需要将公钥放置在您的服务器上。公钥通常具有扩展名`.pub`，默认情况下将位于您的`~/.ssh`目录中。
- en: 'You can manually copy it to the remote user’s `authorized_keys` file (a file
    that contains all authorized public keys for that user, one key per line), or
    you can condense all of those actions into a single command using the `ssh-copy-id`
    program:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以将其手动复制到远程用户的`authorized_keys`文件中（该文件包含该用户的所有授权公钥，每行一个密钥），或者您可以使用`ssh-copy-id`程序将所有这些操作压缩为单个命令：
- en: '[PRE4]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Replace `username` with your user on the remote server and `remote_server_address`
    with the server’s IP address or domain name.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 将`username`替换为远程服务器上的用户，将`remote_server_address`替换为服务器的IP地址或域名。
- en: This command will ask for your user password on the remote server. After entering
    it, the public key will be appended to the `~/.ssh/authorized_keys` file of the
    remote user’s home directory. This allows you to log in and execute commands on
    the remote machine without being prompted for a password.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 此命令将要求您在远程服务器上输入用户密码。输入后，公钥将追加到远程用户主目录下的`~/.ssh/authorized_keys`文件中。这允许您登录并在远程机器上执行命令，而无需提示输入密码。
- en: 'Step 4: Test it out!'
  id: totrans-73
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 'Step 4: 测试一下吧！'
- en: 'Now try logging in to the server:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 现在尝试登录服务器：
- en: '[PRE5]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: If everything worked, you should be logged in without being asked for a password
    (unless you set up a passphrase for your SSH key). Instead of using a small password
    string that might be guessed by an attacker, you’re now using a *much* more secure
    cryptographic key to authenticate yourself.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一切顺利，您应该能够登录而无需输入密码（除非您为SSH密钥设置了一个密码短语）。现在，您将使用一个*更*安全的加密密钥来进行身份验证，而不是使用可能被攻击者猜到的小密码字符串。
- en: Welcome to the wonderful world of secure, password-free SSH access!
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 欢迎来到安全且无密码的SSH访问的美好世界！
- en: Converting SSH2 keys to the OpenSSH format
  id: totrans-78
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将SSH2密钥转换为OpenSSH格式
- en: When not using a Unix-based operating system, you’ll often come across the SSH2
    public key format. PuTTY is probably the most famous software using this format
    and many people using Windows use it to connect via SSH. To connect to an **SSH
    File Transfer Protocol** (**SFTP**) server, Git repository, or other system that
    uses the OpenSSH key format, you need to convert an SSH2 public key into the OpenSSH
    format. Here is how to convert it.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
- en: What we are trying to achieve
  id: totrans-80
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We start with an SSH2-formatted public key that looks like this:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The goal is to convert it to an OpenSSH public key like the following:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: How to convert the SSH2-formatted key to OpenSSH
  id: totrans-85
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `ssh-keygen` command, which we used to create a new key, can also convert
    it with this very simple command:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The command above will take the key from the file `ssh2.pub` and write it to
    `openssh.pub`.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
- en: 'If you just want to look at the OpenSSH key material or have it ready for copying
    and pasting, then you don’t have to worry about piping stdout into a file (the
    same command as above, without the last part):'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: This will simply display the public key in the OpenSSH format.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
- en: 'A more practical example of this might be converting and appending a coworker’s
    key to a server’s `authorized_keys` file. This can be achieved using the following
    command:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: After this, a coworker using the relevant private key will be able to log in
    to the system as the user who runs this command.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
- en: 'The other direction: Converting SSH2 keys to the OpenSSH format'
  id: totrans-95
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The opposite – converting OpenSSH to SSH2 keys – is also possible. Simply use
    the `-e` (for export) flag, instead of `-i` (for import):'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: SSH-agent
  id: totrans-98
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When you’re frequently logging in to servers using SSH keys, it can be annoying
    to have to retype your private key password over and over, every time you connect
    (or reconnect) to a host. SSH-Agent allows you to store an identity (private key)
    for a local session – in other words, it lets you decrypt your private key once,
    and then keep it in memory until you log out or start a new shell session. This
    means that you add an identity (key pair) once, and get to use it over and over
    again without re-decrypting your private key.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
- en: '**Note**'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
- en: The SSH Agent doesn’t always run in your local shell session – various IDEs,
    window managers, desktop managers, and password managers can also run an agent
    for you. You’ll know this is the case when you only have to enter the password
    for an identity once.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
- en: 'To add a key to the agent, just use the `ssh-add` command – the argument is
    the path to your private key for that identity:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'We recommend that you make it a habit to use the `–t` option, which adds a
    time limit to how long your keys are kept decrypted in memory. The following command
    is the same as the one above, except it sets a time limit of 30 seconds, after
    which the agent will delete the keys from memory:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'To show which keys have been added to the agent, use the following command:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'To remove all identities from the SSH agent, use `-D`:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '**Note**'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
- en: If you’ve added more than three identities to the agent, you may still have
    to specify `-i $YOUR_IDENTITY` when logging in via SSH. This is because most servers
    are configured to reject logins after three incorrect attempts, and SSH will try
    each of the keys stored in the agent, one by one, when logging in. If the first
    key doesn’t work, it’ll try the second one, and so on. If the server aborts the
    login attempt after three tries, you’ll never get to the fourth key in your agent.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
- en: 'You can enable agent forwarding when using SSH to log in to remote machines
    with `-A`; however, you should do so sparingly and carefully, for reasons we’ll
    explain:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: After logging in to `remotehost` with this command, SSH will forward your keys
    to that host so you can use them to jump to additional hosts from there. The reason
    we recommend doing this sparingly is that it allows a compromised host to see
    your private keys, which we’ve hopefully taught you should always stay private,
    preferably on your machine or, during your wildest moments, in your password manager.
    In other words, if `remotehost` has been hacked, then your SSH keys are now compromised.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
- en: 'One final note about security: some Linux desktop environments like GNOME/MATE
    will keep your SSH key in memory indefinitely when you use and decrypt it once.
    This happens by default and is a security risk you should be aware of.'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
- en: Common SSH errors and the -v (verbose) argument
  id: totrans-116
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `-v` flag in the SSH command enables verbose mode, which prints out a detailed,
    step-by-step log of the connection process. This feature is particularly useful
    for diagnosing common issues such as authentication failures, connection timeouts,
    and key mismatches. Use it like this:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: You’ll receive step-by-step information about each stage of the SSH handshake
    and connection, making it easier to identify and resolve any issues that may arise.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are some of the frequent errors that you might encounter, which verbose
    output can help you diagnose:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
- en: '**Permission Denied (public key/password)**: This indicates that the server
    rejected your login attempt. The verbose log will show you which keys were tried,
    helping you to pinpoint whether the correct key was used or even offered. This
    is an *incredibly* common issue when you have more than three key pairs stored
    on the client, and the server only allows three tries.'
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Connection Timed Out**: If the connection is taking too long, you might have
    a network issue or an incorrect IP address or port. The `-v` flag will show where
    the process gets stuck, helping you understand whether the client even reached
    the server.'
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Connection Refused**: This usually means that SSH isn’t running (or reachable)
    on the target port on the server. The verbose output will clearly indicate that
    the connection attempt was rejected, helping you focus on firewall rules or SSH
    server settings.'
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Host Key Verification Failed**: The server’s key doesn’t match the one saved
    in your system’s `known_hosts` file. The `–v` flag will show the mismatched keys,
    at which point you can focus on figuring out **why** (for example, is there a
    new server at this IP address or hostname?).'
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Could not resolve hostname**: Often related to DNS or network issues.'
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**No Route to Host**: This suggests network issues, maybe involving firewalls
    or incorrect routing.'
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Too Many Authentication Failures**: The maximum number of authentication
    attempts has been reached. The verbose mode will show all the methods tried, which
    may include unwanted or unexpected key offers.'
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Key Load Errors**: These usually indicate a problem with the format or permissions
    of your SSH key. The `-v` flag will identify which key the SSH client is trying
    to load, allowing you to check for formatting or permission issues.'
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using the `–v` flag will help you understand what exactly is going wrong and
    how you might be able to fix it. At the very least, it will help you start looking
    in the right direction.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
- en: File transfer
  id: totrans-130
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the sections below we will explore the `sftp` and `scp` commands for file
    transfer. Going through a few examples using these commands will help you understand
    how you can handle files in most situations. That said, we will also cover file
    transfer without SFTP or SCP, in case they are disabled on the server.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
- en: SFTP
  id: totrans-132
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: While OpenSSH is frequently used as a way to log in to remote systems, it also
    allows for file transfer independently of a login session. This is usually accomplished
    via the SFTP subsystem. Though SFTP resembles **File Transfer Protocol** (**FTP**),
    it is actually a completely custom protocol. Like FTP, SFTP allows authenticated
    users to transfer files to and from remote servers. Unlike FTP, which is insecure,
    SFTP’s authentication and file transfers are secure and fully encrypted.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
- en: There are many FTP clients that also support SFTP. One famous example is Filezilla,
    which has an excellent graphical user interface. However, since this is a book
    about the Linux command line, we will give you a basic overview of how to use
    SFTP on the command line.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
- en: 'Authentication is nearly identical to `ssh`:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'After this, you’ll be presented with an FTP-style interface. It accepts simpler/modified
    versions of some shell commands that we have already gone over in previous chapters,
    and also introduces some new ones. Here are the most common commands:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
- en: '`help`: lists all commands and gives a short summary'
  id: totrans-138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ls`: lists the contents of a remote directory'
  id: totrans-139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`lls`: lists the contents of a local directory'
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`cd`: changes the remote directory'
  id: totrans-141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`lcd`: changes the local directory'
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`pwd`: displays the remote directory you are in'
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`lpwd`: displays the local directory you are in'
  id: totrans-144
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`get`: downloads a file from the remote server'
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`put`: uploads a file to the remote server'
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`chmod`: changes the permissions of a remote file or directory'
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`chown`: changes the owner of a remote file or directory'
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`quit`, `exit`, `bye`: exits SFTP (*CTRL*+*D* also works)'
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`quit`，`exit`，`bye`：退出 SFTP（*CTRL*+*D* 也有效）'
- en: SCP
  id: totrans-150
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: SCP
- en: The `scp` command is often a more practical way to upload and download files
    and directories than `sftp`. While it was historically independent of SFTP, today
    it uses the SFTP subsystem. It is meant to work as a replacement for the `cp`
    command, except that it allows copying to and from remote servers.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: '`scp` 命令通常比 `sftp` 更实用，用于上传和下载文件和目录。虽然历史上它独立于 SFTP，但今天它使用了 SFTP 子系统。它作为 `cp`
    命令的替代品，除了它可以实现从远程服务器上传和下载。'
- en: 'Commands are in the following format:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 命令格式如下：
- en: '[PRE19]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: '`$SOURCE`, `$DESTINATION`, or both can be remote systems; `scp` uses the SSH
    `user@example.org` syntax that you’ve already seen.'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: '`$SOURCE`，`$DESTINATION`，或者两者都可以是远程系统；`scp` 使用你已经看到的 SSH `user@example.org`
    语法。'
- en: 'Here is what it looks like in practice:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是实际操作的样子：
- en: '[PRE20]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'This will do the following:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 这将执行以下操作：
- en: Connect to `example.org`.
  id: totrans-158
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 连接到 `example.org`。
- en: Authenticate as `user` (prompting you for a password unless you’re using SSH
    keys and the SSH agent).
  id: totrans-159
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 作为 `user` 进行身份验证（如果你没有使用 SSH 密钥和 SSH 代理，它会提示你输入密码）。
- en: Copy the file to the local path `/home/user/my_local_file`.
  id: totrans-160
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将文件复制到本地路径 `/home/user/my_local_file`。
- en: As you can see, the argument order is the same as for the Linux `cp` (copy)
    command.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，参数的顺序与 Linux 的 `cp`（复制）命令相同。
- en: 'Reversing the source and destination arguments – uploading a file, instead
    of downloading it – looks like you might expect:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 反转源和目标参数——上传文件，而不是下载文件——看起来应该是你预期的样子：
- en: '[PRE21]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Just like with `cp`, you can specify relative paths. The following command
    will copy the remote file to the current (local) directory:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 就像使用 `cp` 一样，你可以指定相对路径。以下命令会将远程文件复制到当前（本地）目录：
- en: '[PRE22]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'As with the `cp` command, it is also possible to recursively copy an entire
    directory using the `-r` (recurse, also `-R` on some systems) flag:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 与 `cp` 命令一样，也可以使用 `-r`（递归，某些系统上是 `-R`）标志递归地复制整个目录：
- en: '[PRE23]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Clever examples
  id: totrans-168
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 巧妙的示例
- en: 'As with all commands and tools, `ssh` and `scp` can also be used in scripts;
    for example, you can use ssh to quickly back up a database:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 与所有命令和工具一样，`ssh` 和 `scp` 也可以在脚本中使用；例如，你可以使用 ssh 快速备份数据库：
- en: '[PRE24]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: If you use clever shell hacks like this in a script, take care to alert on errors;
    otherwise, the process might just silently remain stuck when it runs into an issue.
    For development situations, this kind of command can really come in handy.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在脚本中使用类似的巧妙 shell 技巧，请注意在出现错误时进行提示；否则，程序可能在遇到问题时默默卡住。对于开发环境来说，这种命令确实非常实用。
- en: Without SFTP or SCP
  id: totrans-172
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 如果没有 SFTP 或 SCP
- en: In some rare situations, you’ll find that SFTP has been disabled on a server
    and you can only log in to an interactive shell. You still want to transfer a
    file to the remote system, and while it might be possible to just open a file
    in an editor, this isn’t always possible (for example, with whole directories
    or binary files). Here are a few tricks that you can use to still achieve your
    goal (they all make use of the Unix pipe in combination with an SSH session).
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 在一些罕见的情况下，你可能会发现 SFTP 在服务器上被禁用，且只能登录到交互式 shell。你仍然希望将文件传输到远程系统，尽管可能可以在编辑器中打开文件，但并不总是可行（例如，整个目录或二进制文件）。下面是一些你可以用来实现目标的技巧（它们都利用了
    Unix 管道与 SSH 会话的结合）。
- en: 'The simplest case is downloading a file from a remote server:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 最简单的情况是从远程服务器下载文件：
- en: '[PRE25]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'This command will do the following:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 此命令将执行以下操作：
- en: Log in to the server.
  id: totrans-177
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 登录到服务器。
- en: Run the command `cat /path/to/file` on the remote server, which will result
    in the contents of that file being streamed to `stdout`.
  id: totrans-178
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在远程服务器上运行命令 `cat /path/to/file`，这将导致该文件的内容被流式传输到 `stdout`。
- en: '`stdout` can then be locally piped into a file of our choice.'
  id: totrans-179
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`stdout` 可以被本地重定向到我们选择的文件中。'
- en: Like most well-behaved Unix software, errors and other possibly interfering
    output will be sent to `STDERR`, so you do not have to fear that a password prompt
    will get in the way and corrupt the file content being piped across your SSH tunnel,
    as an example.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 像大多数行为规范的 Unix 软件一样，错误信息和其他可能干扰的输出会发送到 `STDERR`，所以你无需担心密码提示会阻碍文件内容的传输并破坏通过 SSH
    隧道传输的文件内容。
- en: Directory upload and .tar.gz compression
  id: totrans-181
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 目录上传和 .tar.gz 压缩
- en: Let’s do something different and upload a whole directory. Since this is potentially
    quite a lot of data, we will also compress it with the `tar` program. `tar` is
    a command that turns multiple files and/or directories into a single file (an
    “archive”).
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
- en: 'It’s common to add a compression step after archiving – you’ve probably seen
    files with the `tar.gz` or `tar.bz2` endings, for example. This means that the
    files have first been archived into a single file with `tar`, and then compressed
    using `gzip` or `bzip2`:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Here, we first archive `/home/user/directory` with `tar`, turning the result
    into a stream of bytes.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
- en: The `-` is the target file. In the case that you want to store it immediately
    instead of streaming it to another program, this would be something like `/home/user/directory.tar.gz`.
    As is customary with many Unix commands, a dash symbolizes that this should instead
    be written to stdout.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
- en: This resulting stream will then be piped into the `ssh` process, which uses
    it as input (`stdin`) for a `tar` command on the remote system, which decompresses
    and unarchives that stream, writing the resulting directory to `/home/user/directory_to_upload`.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
- en: Tunnels
  id: totrans-188
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'SSH tunnelling is used to transport data over an SSH connection. In the following
    sections, we will look at two methods of tunnelling: local forwarding and proxying.'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
- en: Local forwarding
  id: totrans-190
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: SSH can create secure, encrypted tunnels to remote systems. This functionality
    is similar to what a VPN provides and can allow you to access services reachable
    from the remote system.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
- en: That’s powerful functionality, and with SSH, it’s actually simple to achieve.
    All you have to do is specify an additional argument, `-L`, with the destination
    and the local port to bind it to when establishing an SSH session.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
- en: 'Imagine a remote system running an HTTP server on port `8080`. You want to
    access it on your laptop, on port `3000`. Here is how to accomplish that with
    a simple command:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: You can now open a browser and visit `http://localhost:3000/` to access the
    web server as if you were opening that browser on the remote system and visiting
    `http://localhost:8080`.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
- en: Proxying
  id: totrans-196
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The same would be true if you wanted to access a server that you don’t have
    access to, but the remote server does. Imagine `app.example.org` is where your
    web application runs. This web application connects to a database server like
    PostgreSQL at `db.example.org`, which is only accessible from the `www.example.org`
    internal network. Like most production databases, it’s guarded by a firewall that
    prevents direct connections from outside.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
- en: 'From a network perspective, it looks like this:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
- en: '`(localhost) ——-> (app.example.org) ——-> (db.example.org)`'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
- en: 'You might want to use your local `psql` Postgres client to connect to that
    database. What you’d do is create a tunnel like this:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: This will open a new SSH session to `app.example.org`, reach out to the DB server
    from there, and map `db.example.org:5432` to `localhost:5000`.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
- en: Now, running `psql --port=5000 --host=localhost dbname` on your laptop will
    connect you to the Postgres database at `db.example.org:5432`, by bouncing through
    `app.example.org` to get access.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
- en: The configuration file
  id: totrans-204
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'It is possible to specify host configuration in `.ssh/config`. This can be
    helpful in various situations, as it allows you to specify:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
- en: Custom (friendly) names for hosts
  id: totrans-206
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The default user to use
  id: totrans-207
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The port
  id: totrans-208
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Tunnels to open before connecting
  id: totrans-209
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Identity files (keys)
  id: totrans-210
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Among many other things.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
- en: '**Note**'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
- en: If a server you connect to has a permanent IP address, it can make sense to
    specify it in your SSH config file to avoid relying on DNS or CDNs during a disaster
    recovery situation.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
- en: 'SSH configuration files aren’t particularly complicated, so we’ll show you
    an example here that uses many of the available features:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Conclusion
  id: totrans-216
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'OpenSSH is a very versatile tool, and we hope that the introduction you received
    in this chapter has motivated you to experiment and learn more. Just think of
    everything we’ve covered:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
- en: You’ve learned the basics of how public key cryptography works, which is essential
    to being able to reason about these kinds of tools and their usage. You saw how
    to create SSH keys and use them for remote shell sessions.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
- en: Hopefully, you got some practical experience, too, by following along and setting
    up key-based logins for a remote host that you work with often. If that remote
    host happens to be on **Amazon Web Services** (**AWS**) or another platform that
    uses `.pem` keys, you learned how to convert between key formats (that trick alone
    is sure to impress your coworkers).
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
- en: Even if you didn’t run into them yourself, we exposed you to some of the most
    common SSH errors we see people get stuck on in the wild, and how to track them
    down with the `–v` option.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
- en: 'We even covered SSH usage beyond remote interactive shell sessions – file transfers,
    tunneling network traffic, and setting up custom configurations for different
    servers. Surprisingly, there’s even more that OpenSSH can do:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
- en: Encrypt and sign files with `ssh-keygen`
  id: totrans-222
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Add two-factor authentication via FIDO/U2F, storing your key on an external
    device
  id: totrans-223
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Force certain commands to be run after login, which both limits the attack vector
    and allows SSH to be an interface to a service
  id: totrans-224
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The OpenSSH project provides excellent documentation on its manual pages and
    on its website. If you have a problem that requires secure connections between
    machines and you want technology that is battle-tested and proven, OpenSSH is
    worth checking out. Now go forth and encrypt!
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
- en: Learn more on Discord
  id: totrans-226
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To join the Discord community for this book – where you can share feedback,
    ask questions to the author, and learn about new releases – follow the QR code
    below:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
- en: '[https://packt.link/SecNet](https://packt.link/SecNet)'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/QR_Code1768422420210094187.png)'
  id: totrans-229
  prefs: []
  type: TYPE_IMG
