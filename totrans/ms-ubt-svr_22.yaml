- en: '22'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '22'
- en: Troubleshooting Ubuntu Servers
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 故障排查Ubuntu服务器
- en: So far, we’ve covered many topics surrounding Ubuntu Server and worked on some
    really fun projects. We’ve set up web servers, built automation, and even created
    infrastructure in the cloud. As the applications and services you’ve implemented
    age, your organization may depend on them more and more. But what happens if something
    your organization relies on suddenly becomes unavailable? What do you do when
    things don’t quite go according to plan?
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经涵盖了很多关于Ubuntu服务器的话题，并且做了一些非常有趣的项目。我们已经搭建了Web服务器，构建了自动化流程，甚至在云端创建了基础设施。随着你所实现的应用程序和服务逐渐老化，你的组织可能会越来越依赖它们。但是，如果你所在的组织依赖的某个服务突然不可用时会发生什么呢？当事情没有按计划进行时，你该怎么办？
- en: While it’s impossible for us to account for every possible problem that may
    come up, there are some common places to look for clues when you run into a problem.
    In this chapter, we’ll take a look at some common starting points and techniques
    that you can utilize when it comes to troubleshooting issues with your servers.
    Building solid troubleshooting skills is an important focus, and with the concepts
    explored here, you’ll be well on your way.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管我们无法考虑到每一个可能出现的问题，但在遇到问题时，有一些常见的地方可以寻找线索。在本章中，我们将探讨一些常见的起始点和技术，帮助你在排查服务器问题时提供帮助。建立扎实的故障排除技能是一个重要的目标，通过本章探讨的概念，你将能够顺利掌握这一技能。
- en: 'In this chapter, we will cover:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖：
- en: Evaluating the scope
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 评估范围
- en: Conducting a root cause analysis
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 进行根本原因分析
- en: Viewing system logs
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 查看系统日志
- en: Tracing network issues
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 跟踪网络问题
- en: Troubleshooting resource issues
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 排查资源问题
- en: Diagnosing defective RAM
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 诊断故障的RAM
- en: The first step with regards to troubleshooting is to analyze the problem and
    determine how critical a problem it may be. In the next section, we’ll explore
    how to do just that.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 故障排查的第一步是分析问题，并确定问题的严重性。在接下来的部分，我们将探讨如何进行这一步。
- en: Evaluating the scope
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 评估范围
- en: When a problem occurs within your servers or network, your systems will exhibit
    one or more symptoms. Perhaps an application is much slower than normal, maybe
    users are unable to access the network, or a server suffers from total failure.
    There are many problems that can come up at any time, and it can be challenging
    to keep up.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 当服务器或网络出现问题时，你的系统会表现出一个或多个症状。也许某个应用程序比正常情况下慢得多，也许用户无法访问网络，或者某台服务器完全故障。任何时候都可能出现各种问题，跟上排查进度可能是一个挑战。
- en: Once you’ve identified the symptoms of the problem, the next goal is to identify
    the overall scope. Essentially, this means determining (as best you can) where
    the problem is most likely to reside, and how many systems and services are affected.
    Sometimes the root cause is obvious. For example, if none of your computers are
    receiving an IP address from your DHCP server, then you’ll know straight away
    to start investigating the logs on that particular server concerning its ability
    (or inability) to do the job designated for it. In other cases, the cause may
    not be so obvious. Perhaps you have an application that exhibits problems every
    now and then but isn’t something you can reliably reproduce. In that case, it
    may take some digging before you know just how large the scope of the problem
    might be. Sometimes, the culprit is the last thing you expect.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你识别出问题的症状，接下来的目标是确定问题的整体范围。本质上，这意味着尽可能确定问题最可能出在哪个地方，以及有多少个系统和服务受到了影响。有时候，根本原因很明显。例如，如果你的计算机没有从DHCP服务器获取IP地址，你会立刻知道要开始检查该服务器的日志，查看它是否有能力（或无法）执行指定的任务。在其他情况下，原因可能并不那么明显。也许你有一个偶尔出现问题的应用程序，但它并不是你能够可靠复现的。在这种情况下，可能需要进行一些深入挖掘，才能了解问题的范围有多大。有时，罪魁祸首可能是你最不期待的那个。
- en: Each component on your network works together with other components, or at least
    that’s how it should be. A network of Linux servers, just as with any other network,
    is a collection of services (daemons) that complement and often depend upon one
    another. For example, DHCP assigns IP addresses to all of your hosts, but it also
    assigns their default DNS servers as well. If your DNS server has encountered
    an issue, then your DHCP server would essentially be assigning a non-working DNS
    server to your clients. Identifying the problem space means that after you identify
    the symptoms, you’ll also work toward reaching an understanding of how each component
    within your network contributes to (or is affected by) the problem.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 网络上的每个组件都会与其他组件协同工作，或者至少应该是这样。一个Linux服务器网络，就像任何其他网络一样，是一个由服务（守护进程）组成的集合，这些服务互相补充，并且通常相互依赖。例如，DHCP为所有主机分配IP地址，但它也会分配默认的DNS服务器。如果你的DNS服务器出现问题，那么DHCP服务器本质上会为客户端分配一个无法工作的DNS服务器。识别问题空间意味着，在你识别出症状后，还需要努力理解网络中每个组件如何对问题产生影响或如何受问题影响。
- en: With regards to the scope, we identify how far the problem reaches, as well
    as how many users or systems are affected by the issue. Perhaps just one user
    is affected, or an entire subnet. This will help you determine the priority of
    the issue and decide whether this is something essential that you need to fix
    now, or something that can wait until later. Often, prioritizing is half the battle;
    sometimes a user will even be under the impression that their issues are more
    important than others. Use your best judgment.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 关于范围，我们需要确定问题的影响范围，以及有多少用户或系统受到了影响。可能只是一个用户受到影响，或者是整个子网。这将帮助你确定问题的优先级，并决定是否需要立即解决，还是可以等到稍后再处理。通常，优先级排序是解决问题的一半；有时候，用户甚至会认为他们的问题比其他人的更重要。请凭借你的最佳判断来处理。
- en: 'When identifying the scope, you’ll want to answer the following questions as
    best as you can:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 在识别问题范围时，你需要尽可能回答以下问题：
- en: What are the symptoms of the issue?
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这个问题的症状是什么？
- en: When did this problem first occur?
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这个问题是什么时候首次发生的？
- en: Were there any changes made within the network around that time?
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 网络中是否在那个时候做过任何更改？
- en: Has this problem happened before? If so, what was done to fix it last time?
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这个问题之前发生过吗？如果有，上次是如何解决的？
- en: Which servers or nodes are impacted by this issue?
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 哪些服务器或节点受到了这个问题的影响？
- en: How many users are impacted?
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有多少用户受到影响？
- en: If the problem is limited to a single machine, then a few really good places
    to start poking around is to check who is logged in to the server and which commands
    have recently been entered. Quite often, I’ve found the culprit just by checking
    the Bash history for logged-on users (or users that have recently logged in).
    With each user account, there should be a .bash_history file in their home directory.
    Within this file is a list of commands that were recently entered. Check this
    file and see if anyone modified anything recently. I can’t tell you how many times
    this alone has led directly to the answer. And what’s even better, sometimes the
    Bash history leads to the solution. If a problem has occurred before and someone
    has already fixed it at some point in the past, chances are their efforts were
    recorded in the Bash history, so you can see what the previous person did to solve
    the problem just by looking at it.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 如果问题仅限于一台机器，那么一些很好的排查起点是检查谁登录了服务器，以及最近输入了哪些命令。我经常通过检查登录用户（或最近登录的用户）的Bash历史记录来找到罪魁祸首。每个用户帐户的主目录中应该都有一个.bash_history文件。这个文件包含了最近输入的命令。检查这个文件，看看是否有人最近修改了什么。我数不清有多少次仅凭这一点就直接找到了答案。更妙的是，有时候Bash历史记录直接指向了解决方案。如果之前发生过类似的问题并且有人已经修复过，往往他们的努力已经记录在Bash历史记录中，你可以通过查看它，知道之前的人是如何解决问题的。
- en: To view the Bash history, you can either view the contents of the .bash_history
    file in a user’s home directory, or you can simply execute the history command
    as that user.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看Bash历史记录，你可以查看用户主目录中的.bash_history文件内容，或者直接以该用户身份执行history命令。
- en: Additionally, if you check who is currently logged into the server, you may
    be able to pinpoint if someone is working on an issue already, or perhaps something
    they’re doing caused the issue in the first place. If you enter the `w` command,
    you can see who is logged in to the server currently. In addition, you’ll also
    see the IP address of the user that’s logged in when you run this command. Therefore,
    if you don’t know who corresponds to a user account listed when you run the `w`
    command, you can check the IP address in your DHCP server to find out who the
    IP address belongs to, so you can ask that person directly. In a perfect world,
    other administrators will send out a departmental email when they work on something
    to make sure everyone is aware. Unfortunately, many don’t do this. By checking
    the logged-in users as well as their Bash history, you’re well on your way to
    determining where the problem originated.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，如果你检查当前登录到服务器的用户，可能能够确定是否有人已经在处理某个问题，或者也许他们所做的事情导致了问题的发生。如果你输入`w`命令，你可以看到谁目前登录到服务器。此外，当你运行此命令时，还会看到登录用户的IP地址。因此，如果你不清楚`w`命令列出的用户账户对应谁，你可以在你的DHCP服务器中检查IP地址，找出这个IP地址属于谁，然后直接询问那个人。在理想的世界中，其他管理员在处理某些问题时会发一封部门邮件，确保大家都知情。不幸的是，很多人并没有这样做。通过检查已登录的用户以及他们的Bash历史记录，你已经走在了确定问题源头的道路上。
- en: After identifying the problem space and the scope, you can begin narrowing down
    the issue to help find a cause. Sometimes, the culprit will be obvious. If a website
    stopped working and you noticed that the Apache configuration on your web server
    was changed recently, you can attack the problem by investigating the change and
    who made it.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 在识别问题范围和范围后，你可以开始缩小问题范围，帮助找到原因。有时，罪魁祸首会显而易见。如果一个网站停止工作，而你注意到最近你的Web服务器上的Apache配置发生了变化，那么你可以通过调查更改和谁做了这些更改来攻克这个问题。
- en: If the problem is a network issue, such as users not being able to visit websites,
    the potential problem space is much larger. Your internet gateway may be malfunctioning,
    your DNS or DHCP server may be down, your internet provider could be having issues,
    or perhaps your accounting department simply forgot to pay the internet bill.
    As long as you are able to determine a potential list of targets to focus your
    troubleshooting on, you’re well on your way to finding the issue. As we go through
    this chapter, I’ll talk about some common issues that can come up and how to deal
    with them.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 如果问题是网络问题，例如用户无法访问网站，潜在的问题范围要大得多。你的互联网网关可能出现故障，DNS或DHCP服务器可能宕机，你的互联网服务提供商可能出现问题，或者也许你的财务部门只是忘了支付互联网账单。只要你能够确定一个潜在的目标列表来集中进行故障排除，你就离找到问题不远了。在本章中，我会谈到一些常见的问题以及如何处理这些问题。
- en: Understanding the scope of the problem helps us understand just how severe it
    may be and the number of systems and users impacted, and sometimes, investigating
    the scope can lead you to the root cause of the problem. If you don’t already
    know the underlying cause, you can conduct a root cause analysis to attempt to
    find the source of the problem. That’s what we’ll explore next.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 了解问题的范围帮助我们理解问题的严重程度以及受影响的系统和用户数量，有时，调查范围本身可能会引导你找到问题的根本原因。如果你还不知道潜在的原因，可以进行根本原因分析，尝试找出问题的源头。这就是我们接下来要探讨的内容。
- en: Conducting a root cause analysis
  id: totrans-30
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进行根本原因分析
- en: Once you resolve a problem on your server or network, you’ll immediately revel
    in the awesomeness of your troubleshooting skills. It’s a wonderful feeling to
    have fixed an issue, becoming the hero within your technology department. But
    you’re not done yet. The next step is looking toward preventing this problem from
    happening again. It’s important to look at how the problem started as well as
    steps you can take in order to help stop the problem from occurring again. This
    is known as a **root cause analysis**. A root cause analysis may be a report you
    file with your manager or within your knowledge-base system, or it could just
    be a memo you document for yourself. Either way, it’s an important learning opportunity.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你解决了服务器或网络上的问题，你会立即为自己解决问题的能力感到骄傲。解决了一个问题后，成为技术部门的英雄是一种非常棒的感觉。但你还没有完成。下一步是考虑如何防止这个问题再次发生。查看问题是如何开始的，并采取一些步骤以帮助防止问题再次发生，这一点非常重要。这就是所谓的**根本原因分析**。根本原因分析可能是你向经理提交的报告，或是你在知识库系统中记录的内容，也可能只是你自己记录的备忘录。无论哪种方式，它都是一次重要的学习机会。
- en: A good root cause analysis has several sides to the equation. First, it will
    demonstrate the events that led to the problem occurring in the first place. Then,
    it will contain a list of steps that you’ve completed to correct the problem.
    If the problem is something that could potentially recur, you would want to include
    information about how to prevent it from happening again in the future.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 一个好的根本原因分析有多个方面。首先，它会展示导致问题发生的事件。然后，它会列出你为解决问题所采取的步骤。如果问题可能会再次发生，你应该包括如何防止未来再次发生类似问题的信息。
- en: The problem with a root cause analysis is that it’s rare that you can be 100
    percent accurate. Sometimes, the root cause may be obvious. For example, suppose
    a user named `Bob` deleted an entire directory that contained files important
    to your company. If you log into the server and check the logs, you can see that
    `Bob` not only logged into the server near the time of the incident, but his Bash
    history literally shows him running the `rm -rf /work/important-files` command.
    At this point, the case is closed. You figured out how the problem happened and
    who did it, and you can restore the files from your most recent backup. But a
    root cause is usually not that cut and dry.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 根本原因分析的问题在于，很少能做到百分之百准确。有时候，根本原因可能是显而易见的。例如，假设有个叫做`Bob`的用户删除了一个包含公司重要文件的整个目录。如果你登录到服务器并查看日志，你会看到`Bob`不仅在事件发生时登录了服务器，而且他的
    Bash 历史记录显示他运行了`rm -rf /work/important-files`命令。此时，案件就解决了。你已经弄清楚了问题发生的原因和责任人，并且可以从最近的备份中恢复文件。但根本原因通常不像这样简单明了。
- en: One example I’ve personally encountered was a pair of **Virtual Machine** (**VM**)
    servers that were “fencing.” At a company I once worked for, our Citrix-based
    VM servers (which were part of a cluster) both went down at the same time, taking
    every Linux VM down with them. When I attached a monitor to them, I could see
    them both rebooting over and over. After I got the servers to settle down, I started
    to investigate deeper. I read in the documentation for Citrix XenServer that you
    should never install a cluster of anything less than three machines because it
    can create a situation exactly like the one I experienced. We only had two servers
    in that cluster, so I concluded that the servers were set up improperly and the
    company would need a third server if they wanted to cluster them.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 我亲身遇到过的一个例子是，一对**虚拟机**（**VM**）服务器发生了“围栏”问题。我曾在一家公司工作时，我们基于 Citrix 的虚拟机服务器（它们是一个集群的一部分）同时宕机，导致每个
    Linux 虚拟机也随之宕机。当我给它们接上显示器时，看到它们不停地重启。等到服务器稳定下来后，我开始深入调查。我在 Citrix XenServer 的文档中读到，集群的机器数量不能少于三台，因为这会导致像我所经历的那种情况。我们这个集群只有两台服务器，所以我得出结论，服务器的配置不当，如果公司想要建立集群，就需要一台第三台服务器。
- en: The problem though is that this root cause analysis wasn’t 100 percent perfect.
    Were the servers having issues because they needed a third server? The documentation
    did mention that three servers were a minimum, but there’s no way to know for
    sure that was the reason the problem started. However, not only was I not watching
    the servers when it happened, but I also wasn’t the individual who set them up;
    that person had already left the company. There was no way I could reach an absolute
    conclusion, but my root cause analysis was sound in the sense that it was the
    most likely explanation (that we weren’t using best practices). Someone could
    counter my root cause analysis with “but the servers were running fine that way
    for several years.” True, but nothing is absolute when dealing with technology.
    Sometimes, you never really know. The only thing you can do is make sure everything
    is set up properly according to the guidelines set forth by the manufacturer.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 问题在于，这个根本原因分析并不是百分之百完美的。服务器出现问题是因为需要第三台服务器吗？文档确实提到过三台服务器是最低配置，但无法确定这就是问题发生的真正原因。然而，不仅在问题发生时我没有监控服务器，而且我也不是设置服务器的那个人；那个人已经离开公司。虽然无法得出绝对结论，但我的根本原因分析是合理的，因为这是最有可能的解释（即我们没有遵循最佳实践）。有人可能会反驳我的根本原因分析，称“但是这些服务器运行了好几年也没问题。”这倒是真的，但在处理技术问题时，没有什么是绝对的。有时候，你根本无法确知。唯一能做的就是确保一切按照厂商设定的指南正确配置。
- en: A good root cause analysis is as sound in logic as it can be, though not necessarily
    bulletproof. Correlating system events to symptoms is often a good first step
    but is not necessarily perfect. After investigating the symptoms, solving the
    issue, and documenting what you’ve done to rectify it, sometimes the root cause
    analysis writes itself. Other times, you’ll need to read the documentation and
    ensure that the configuration of the server or daemon that failed was implemented
    along with best practices. In a worst-case scenario, you won’t really know how
    the problem happened or how to prevent it, but it should still be documented in
    case other details come to light later. And without documentation, you’ll never
    gain anything from the situation.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 一个好的根本原因分析在逻辑上应尽可能严密，尽管不一定是万无一失的。将系统事件与症状关联起来通常是一个很好的第一步，但并不一定是完美的。在调查症状、解决问题并记录你所做的修复工作之后，有时根本原因分析会自动显现。其他时候，你需要查看文档，确保出现故障的服务器或守护进程的配置已按照最佳实践进行实施。在最坏的情况下，你可能无法确切知道问题是如何发生的，也不清楚如何防止它发生，但仍然应该进行文档记录，以便日后发现其他细节。没有文档记录，你永远无法从这个情况中获得任何经验。
- en: 'A root cause analysis should include details such as the following:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 根本原因分析应包括以下细节：
- en: A description of the issue
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 问题的描述
- en: Which application or piece of hardware encountered a fault
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 哪个应用程序或硬件出现了故障
- en: The date and time the issue was first noticed
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 问题首次出现的日期和时间
- en: What you found while investigating the issue
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你在调查问题时发现的内容
- en: What you’ve done to resolve the issue
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你为解决问题所采取的措施
- en: What events, configurations, or faults caused the issue to happen
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 导致问题发生的事件、配置或故障
- en: A root cause analysis should be used as a learning experience. Depending on
    what the issue was, it may serve as an example of what not to do, or what to do
    better. In the case of my VM server fiasco, the moral of the story was to follow
    best practices from Citrix and use three servers for the cluster instead of two.
    Other times, the end result may be another technician not following proper directives
    or making a mistake, which is unfortunate. In the future, if the issue were to
    happen again, you’ll be able to look back and remember exactly what happened last
    time and what you did to fix it. This is valuable, if only because we’re all human
    and prone to forgetting important details after a time. In an organization, a
    root cause analysis is valuable to show stakeholders that you’re able to not only
    address a problem but are reasonably able to prevent it from happening again.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 根本原因分析应该作为一次学习经验。根据问题的性质，它可能作为不应做的事情或需要改进的做法的范例。以我的虚拟机服务器故障为例，故事的教训是遵循Citrix的最佳实践，使用三台服务器而非两台来搭建集群。其他时候，最终结果可能是另一个技术员没有遵循正确的指示或犯了错误，这很不幸。如果将来问题再次发生，你将能够回顾并记得上次发生了什么，以及你做了什么来解决问题。这非常有价值，因为我们都是人，时间一长容易忘记重要的细节。在一个组织中，根本原因分析对于向利益相关者展示你不仅能解决问题，还能合理防止问题再次发生，非常重要。
- en: Often, log files are a great place to find clues, as quite a bit of information
    surrounding system and application events are stored there. In the next section,
    we’ll explore log files in more detail.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 日志文件通常是寻找线索的好地方，因为系统和应用程序事件的相关信息通常会存储在其中。在下一节中，我们将更详细地探讨日志文件。
- en: Viewing system logs
  id: totrans-46
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 查看系统日志
- en: If you’re having trouble finding the root cause, or you just want more information
    regarding a problem that occurred, consider looking through log files. Linux has
    great logging capabilities, and many of the applications you may be running are
    writing log files as events happen. If there’s an issue, you may be able to find
    information about it within an application’s logs.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在寻找根本原因时遇到困难，或者你只是想获取更多有关发生问题的信息，可以考虑查看日志文件。Linux有强大的日志记录功能，许多你可能正在运行的应用程序会在事件发生时写入日志文件。如果出现问题，你可能会在应用程序的日志中找到相关信息。
- en: There are two primary methods of viewing logs. Historically, for most of Ubuntu’s
    life, you could simply inspect the log files that are stored within the `/var/log`
    directory. The files contained within that directory are standard files and directories,
    so you can use commands you’ve used in the past to view the contents of text files
    to view the contents of the log files within the `/var/log` directory as well.
    This method of viewing log files is slowly being aged out; however, the majority
    of applications still store their log files within that directory, even today.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 查看日志有两种主要方法。从历史上看，在大部分Ubuntu使用期间，你只需检查存储在`/var/log`目录中的日志文件即可。该目录中的文件是标准文件和目录，因此你可以使用以往查看文本文件内容的命令来查看`/var/log`目录中的日志文件内容。这种查看日志文件的方法正在逐步被淘汰；然而，大多数应用程序今天仍然将它们的日志文件存储在该目录中。
- en: 'The newer method of viewing logging information for an application is to use
    the `journalctl` command. This command is part of `systemd`, and it’s dedicated
    to the purpose of viewing logs. To use the `journalctl` command to check the status
    of a running service, you provide it the `-u` option, along with the name of a
    service you’d like to check:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 查看应用程序日志的较新方法是使用`journalctl`命令。此命令是`systemd`的一部分，专门用于查看日志。要使用`journalctl`命令检查正在运行的服务的状态，你需要提供`-u`选项，以及你想检查的服务名称：
- en: '[PRE0]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'With that example, we’re attempting to view logging information for the `ssh`
    service:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这个例子，我们尝试查看`ssh`服务的日志信息：
- en: '![](img/B18425_22_01.png)'
  id: totrans-52
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B18425_22_01.png)'
- en: 'Figure 22.1: Viewing logging information via the `journalctl` command'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 图 22.1：通过`journalctl`命令查看日志信息
- en: The `-u` option is required and tells the `journalctl` command that you’d like
    to check on a service. So in the previous example, we provided `ssh` as an argument
    for what we wanted to find logging information on. The name of the unit (or service)
    will be the same as it is when you’re starting, stopping, or restarting a service
    with the `systemctl` command. I recommend making the `journalctl` command your
    first consideration when checking logging information on a Linux system.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: '`-u`选项是必需的，它告诉`journalctl`命令你想要检查某个服务。因此，在之前的示例中，我们提供了`ssh`作为我们想要查找日志信息的服务名称。服务的单元（或服务）名称与使用`systemctl`命令启动、停止或重启服务时的名称相同。我建议在检查Linux系统的日志信息时，首先考虑使用`journalctl`命令。'
- en: If you also add the `-f` option in addition to the `-u` option, the output will
    continue to scroll as new information is added to the logs for the particular
    service you’re checking. This is very useful if you want to follow along with
    what’s going on with a service as new events occur.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在`-u`选项之外再加上`-f`选项，输出将会继续滚动，随着你检查的特定服务的新日志信息被添加到日志中。如果你想跟踪服务发生的新事件，这非常有用。
- en: However, not all services log information via `journalctl`, so understanding
    the legacy approach to viewing log files is also important. Inside the `/var/log`
    directory, you’ll see a handful of logs you can view, which differs from server
    to server depending on which applications are installed. In quite a few cases,
    an installed application will create its own log file somewhere within `/var/log`,
    either in a log file or a log file within a subdirectory of `/var/log`. For example,
    once you install Apache, it will create log files in the `/var/log/apache2` directory,
    and looking through those logs may give you a hint as to what may be going on
    if the problem is related to your web server. These are known as **Application
    Logs**, which are basically log files created by an application and not the distribution.
    There are also **System Logs**, which are the log files created by the distribution
    and allow you to view system events.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，并不是所有服务都通过`journalctl`记录日志，因此了解查看日志文件的传统方法也很重要。在`/var/log`目录中，你会看到一些日志文件，可以查看这些文件，不同服务器之间会有所不同，具体取决于安装了哪些应用程序。在很多情况下，已安装的应用程序会在`/var/log`中的某个位置创建自己的日志文件，可能是在日志文件中，或者是在`/var/log`的子目录下的日志文件。例如，一旦你安装了Apache，它会在`/var/log/apache2`目录中创建日志文件，查看这些日志可能会给你一些线索，帮助你了解问题是否与web服务器有关。这些被称为**应用程序日志**，即由应用程序而非发行版创建的日志文件。还有**系统日志**，它们是由发行版创建的日志文件，用于查看系统事件。
- en: 'Viewing a log file stored within the `/var/log` directory can be done in several
    ways. One way is to use the `cat` command along with the path and filename of
    a log file. For example, the Apache access log can be viewed with the following
    command:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 查看存储在`/var/log`目录中的日志文件可以通过几种方法完成。一个方法是使用`cat`命令，并指定日志文件的路径和文件名。例如，可以使用以下命令查看Apache的访问日志：
- en: '[PRE1]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Some log files are restricted and need `root` privileges in order to access
    them. If you get a permission denied error when attempting to view a log, use
    `sudo` in front of any of the commands in this section to view the file.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 一些日志文件是受限的，需要`root`权限才能访问。如果在尝试查看日志时遇到权限拒绝错误，可以在本节中的任何命令前加上`sudo`来查看该文件。
- en: One problem with the `cat` command is that it will print out the entire file,
    no matter how big it is. It will scroll by your terminal and if the file is large,
    you won’t be able to see all of it. In addition, if your server is already taxed
    when it comes to performance, using `cat` can actually tie up the server for a
    bit in a case where the log file is massive. This will cause you to lose control
    of your shell until the file stops printing. You can press *Ctrl + c* to stop
    printing the log file, but the server may end up being too busy to respond to
    *Ctrl + c* and show the entire file anyway.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: '`cat`命令的一个问题是它会打印出整个文件，无论文件有多大。它会在你的终端上滚动，如果文件很大，你将无法看到完整内容。此外，如果你的服务器在性能上已经有些吃力，使用`cat`实际上可能会暂时占用服务器，尤其是在日志文件非常大的情况下。这会导致你失去对shell的控制，直到文件打印停止。你可以按*Ctrl
    + c*来停止打印日志文件，但服务器可能忙得无法响应*Ctrl + c*，并且无论如何都会显示整个文件。'
- en: 'Another method is to use the `tail` command. By default, the `tail` command
    shows you the last ten lines of a file:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种方法是使用`tail`命令。默认情况下，`tail`命令显示文件的最后十行：
- en: '[PRE2]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'If you wish to see more than the last ten lines, you can use the `-n` option
    to specify a different amount. To view the last `100` lines, we would use the
    following:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你希望查看超过最后十行的内容，可以使用`-n`选项来指定不同的行数。要查看最后`100`行，可以使用以下命令：
- en: '[PRE3]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Perhaps one of the most useful features of the `tail` command is the `-f` option,
    which allows you to follow a log file. Basically, this means that as entries are
    written to the log file, it will scroll by in front of you. It’s close to watching
    the log file in real time:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 也许`tail`命令最有用的特性之一就是`-f`选项，它允许你跟踪日志文件。基本上，这意味着当日志文件有新的条目被写入时，它会在你面前滚动，就像实时查看日志文件一样。
- en: '[PRE4]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Once you start using the `follow` option, you’ll wonder how you ever lived without
    it. If you’re having a specific problem that you are able to reproduce, you can
    watch the log file for that application and see the log entries as they appear
    while you’re reproducing the issue. In the case of a DHCP server not providing
    IP addresses to clients, you can view the output of the `/var/log/syslog` file
    (the `isc-dhcp-server` daemon doesn’t have its own log file), and you can see
    any errors that come up as your clients try to re-establish their DHCP lease,
    allowing you to see the problem as it is happening.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦开始使用`follow`选项，你会想知道自己以前是怎么没有它的。如果你正遇到一个能重现的问题，你可以观察该应用程序的日志文件，并看到日志条目随着问题的重现而出现。以DHCP服务器未能向客户端提供IP地址为例，你可以查看`/var/log/syslog`文件的输出（`isc-dhcp-server`守护进程没有自己的日志文件），并看到当客户端尝试重新获取DHCP租约时出现的任何错误，从而让你看到问题的发生过程。
- en: 'Another useful command for viewing logs is `less`. The `less` command allows
    you to scroll through a log file with the page up and page down keys on your keyboard,
    which makes it more useful for viewing log files than the `cat` command. You can
    press *q* to exit the file:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个有用的查看日志的命令是`less`。`less`命令允许你通过键盘上的Page Up和Page Down键滚动查看日志文件，这使得它比`cat`命令在查看日志文件时更加实用。你可以按*q*退出文件：
- en: '[PRE5]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: So now that you know a few ways in which you can view these files, which files
    should you inspect? Unfortunately, there’s no one rule, as each application handles
    its logging differently. Some daemons have their own log file stored somewhere
    in `/var/log`.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经了解了一些查看这些文件的方法，那么应该检查哪些文件呢？不幸的是，并没有统一的规则，因为每个应用程序的日志处理方式不同。一些守护进程有自己的日志文件，存储在`/var/log`目录下。
- en: 'Therefore, a good place to check is in that directory, to see if there is a
    log file with the name of the daemon. Some daemons don’t even have their own log
    file and will use `/var/log/syslog` instead. You may try viewing the contents
    of the file while using `grep` to find messages related to the daemon you’re troubleshooting.
    In regard to the `isc-dhcp-server` daemon, the following would narrow down the
    `syslog` to messages from that specific daemon:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，一个好的检查位置是该目录，查看是否有一个以守护进程名称命名的日志文件。有些守护进程甚至没有自己的日志文件，而是使用`/var/log/syslog`。你可以尝试在查看文件内容时使用`grep`来查找与你正在排查的守护进程相关的消息。关于`isc-dhcp-server`守护进程，以下命令将会把`syslog`缩小到来自该特定守护进程的消息：
- en: '[PRE6]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: While troubleshooting security issues, the log file you’ll definitely want to
    look at is the **Authorization Log**, located at `/var/log/auth.log`. You’ll need
    to use the `root` account or `sudo` to view this file. The authorization log includes
    information regarding authentication attempts to the server, including logins
    from the server itself, as well as logins over OpenSSH. This is useful for several
    reasons, among them the fact that if something really bad happens on your server,
    you can find out who logged in to the server around that time. In addition, if
    you or one of your users is having trouble accessing the server via OpenSSH, you
    may want to look at the authorization log for clues, as additional information
    for OpenSSH failures will be logged there. Often, the `ssh` command may complain
    about permissions of key files not being correct, which would give you an answer
    as to why public key authentication stopped working, as OpenSSH expects specific
    permissions for its files. For example, the private key file (typically `/home/<user>/.ssh/id_rsa`)
    should not be readable or writable by anyone other than its owning user. You’d
    see errors within `/var/log/auth.log` mentioning such a thing if that were the
    case.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 在排查安全问题时，你肯定会想查看的日志文件是**授权日志**，该日志位于`/var/log/auth.log`。你需要使用`root`账户或`sudo`来查看该文件。授权日志包含有关对服务器进行身份验证尝试的信息，包括来自服务器本身的登录以及通过OpenSSH的登录。这样做有几个原因，其中之一是如果服务器上发生了严重问题，你可以查看在那个时间点谁登录了服务器。此外，如果你或你的某个用户在通过OpenSSH访问服务器时遇到问题，你可能需要查看授权日志来寻找线索，因为OpenSSH失败的更多信息会被记录在其中。通常，`ssh`命令可能会抱怨密钥文件的权限不正确，这会给出公钥认证无法正常工作的问题答案，因为OpenSSH对其文件有特定的权限要求。例如，私钥文件（通常是`/home/<user>/.ssh/id_rsa`）不应该被除了其拥有者外的任何人读取或写入。如果是这种情况，你会在`/var/log/auth.log`中看到类似的错误信息。
- en: Another use case for checking `/var/log/auth.log` is for security, as a high
    number of login attempts may indicate an intrusion attempt. (Hopefully, you have
    Fail2ban installed, which we went over in the last chapter.) An unusually high
    number of failed password attempts may indicate someone trying to log in to the
    server by brute force. That would definitely be a cause for concern, and you’d
    want to block their IP address immediately.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 检查`/var/log/auth.log`的另一个使用场景是安全性，因为大量的登录尝试可能表明有入侵企图。（希望你已经安装了Fail2ban，我们在上一章讨论过。）异常高的密码尝试失败次数可能意味着有人正在尝试通过暴力破解登录服务器。这肯定是一个需要关注的警告，你应该立即封锁他们的IP地址。
- en: The **System Log**, located in `/var/log/syslog`, contains logging information
    for quite a few different things. It’s essentially the Swiss Army knife of Ubuntu’s
    logs. If a daemon doesn’t have its own log file, chances are its logs are being
    written to this file. In addition, information regarding cron jobs will be written
    here, which makes it a candidate to check when a cron job isn’t being executed
    properly. The `dhclient` daemon, which is responsible for grabbing an IP address
    from a DHCP server, is also important.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: '**系统日志**，位于`/var/log/syslog`，包含了许多不同内容的日志信息。它本质上是Ubuntu日志的瑞士军刀。如果某个守护进程没有自己的日志文件，很可能它的日志会被写入此文件。此外，关于cron作业的信息也会写入此处，因此当cron作业未能正确执行时，这里是一个可以检查的地方。负责从DHCP服务器获取IP地址的`dhclient`守护进程同样非常重要。'
- en: You’ll be able to see from `dhclient` events within the system log when an IP
    address is renewed, and you can also see messages relating to failures if it’s
    not able to obtain an IP address. Also, the `systemd init` daemon itself logs
    here, which allows you to see messages related to server startup as well as applications
    it’s trying to run.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 你将能够从`dhclient`事件中看到系统日志中的IP地址更新情况，也可以看到无法获取IP地址时的失败消息。此外，`systemd init`守护进程本身也会在这里记录日志，这使得你可以看到与服务器启动以及它尝试运行的应用程序相关的消息。
- en: Another useful log is the `/var/log/dpkg.log` file, which records log entries
    relating to installing and upgrading packages. If a server starts misbehaving
    after you roll out updates across your network, you can view this log to see which
    packages were recently updated. This log will not only give you a list of updated
    or installed packages, but also a timestamp from when the installation occurred.
    If a user installed an unauthorized application, you can correlate this log to
    the authentication log to determine who logged in around that time, and then you
    can check that user’s Bash history to confirm.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个有用的日志文件是`/var/log/dpkg.log`，它记录了与安装和升级软件包相关的日志条目。如果服务器在你通过网络推送更新后开始出现问题，你可以查看这个日志，查看最近更新了哪些软件包。这个日志不仅会提供已更新或安装的软件包列表，还会提供安装发生时的时间戳。如果某个用户安装了未经授权的应用程序，你可以将该日志与认证日志进行关联，确定当时谁登录了系统，然后查看该用户的Bash历史记录以确认。
- en: 'Often, log files will get rotated after some time by a utility known as `logrotate`.
    Inside the `/var/log` directory, you’ll see several log files with a `.gz` extension,
    which means that the original log file was compressed and renamed, and a new log
    file was created in its place. For example, you’ll see the `syslog` file for the
    system log in the `/var/log` directory, but you’ll also see files named with a
    number and a `.gz` extension as well, such as `syslog.2.gz`. These are compressed
    logs. Normally, you’d view these logs by uncompressing them and then opening them
    via any of the methods mentioned in this section. An easier way to do so is with
    the `zcat` command, which allows you to view compressed files immediately:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 日志文件通常会在一段时间后通过名为`logrotate`的工具进行轮转。在`/var/log`目录中，你会看到一些带有`.gz`扩展名的日志文件，这意味着原始的日志文件已经被压缩并重命名，并且一个新的日志文件已经在原位置创建。例如，你会在`/var/log`目录中看到系统日志的`syslog`文件，但你也会看到一些带有数字和`.gz`扩展名的文件，如`syslog.2.gz`。这些是压缩后的日志文件。通常，你需要先解压它们，然后通过本节中提到的任意方法查看这些日志。更简单的方法是使用`zcat`命令，它允许你立即查看压缩文件：
- en: '[PRE7]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: There’s also `zless`, which serves a similar purpose as the `less` command.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 还有`zless`，它的作用与`less`命令类似。
- en: Another useful command for checking logging information is `dmesg`. Unlike other
    log files, `dmesg` is literally its own command, and you can execute it from anywhere
    in the filesystem. The `dmesg` command allows you to view log entries from the
    Linux kernel’s ring buffer, which can be very useful when troubleshooting hardware
    issues (such as seeing which disks were recognized by the kernel). When troubleshooting
    hardware, the system log is also helpful, but using the `dmesg` command may be
    a good place to check as well.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个有用的查看日志信息的命令是`dmesg`。与其他日志文件不同，`dmesg`本身就是一个命令，你可以从文件系统中的任何位置执行它。`dmesg`命令允许你查看来自Linux内核环形缓冲区的日志条目，这在排查硬件问题时非常有用（例如查看哪些硬盘被内核识别）。在排查硬件问题时，系统日志也很有帮助，但使用`dmesg`命令可能是一个好的检查起点。
- en: As I mentioned earlier, on an Ubuntu system, there are two types of log files,
    system logs and application logs. System logs, such as `auth.log` and `dpkg.log`,
    detail important system events and aren’t specific to any one particular application.
    Application logs become installed when you install their parent packages, such
    as Apache or MariaDB. Application logs create log entries into their own log file.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，在Ubuntu系统上，有两种类型的日志文件，系统日志和应用程序日志。系统日志，如`auth.log`和`dpkg.log`，记录了重要的系统事件，并且不特定于某个应用程序。应用程序日志在安装其父软件包时一起安装，例如Apache或MariaDB。应用程序日志会将日志条目写入其自己的日志文件。
- en: Some daemons you install will not create their own application log, such as
    `isc-dhcp-server`. Since there’s no general rule when it comes to which applications
    log is where, the first step in finding a log file is to see if the application
    you want log entries from creates its own log file. If not, it’s likely using
    a system log.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 一些你安装的守护进程不会创建自己的应用程序日志，例如`isc-dhcp-server`。由于没有统一的规则规定应用程序日志存放位置，因此查找日志文件的第一步是查看你想查看日志条目的应用程序是否创建了自己的日志文件。如果没有，可能是使用了系统日志。
- en: When faced with a problem, it’s important to practice viewing log files at the
    same time as you try and reproduce the problem. Using `follow` mode with `tail`
    (`tail -f`) works very well for this, as you can watch the log file generate new
    entries as you try and reproduce the issue. This technique works very well in
    almost any situation where you’re dealing with a misbehaving daemon. This technique
    can also help narrow down hardware issues. For example, I once dealt with an Ubuntu
    system where when I plugged in a flash drive, nothing happened. When I followed
    the log as I inserted and removed the flash drive, I saw the system log update
    and recognize each insertion and removal. So clearly, the Linux kernel itself
    saw the hardware and was prepared to use it. This helped me narrow down the problem
    to being that the desktop environment I was using wasn’t updating to show the
    inserted flash drive, but my hardware and USB ports were operating perfectly fine.
    With one command, I was able to determine that the issue was a software problem
    and not related to hardware.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 在面对一个问题时，同时查看日志文件并尝试重现问题非常重要。使用`follow`模式与`tail`命令（`tail -f`）对于此目的非常有效，因为你可以在尝试重现问题时，观察日志文件生成新的条目。这种技术在几乎任何你处理不正常运行的守护进程时都能很好地发挥作用。这个技术也能帮助你缩小硬件问题的范围。例如，我曾处理过一个Ubuntu系统，当我插入闪存驱动器时，什么也没发生。当我在插拔闪存驱动器时查看日志时，我看到系统日志更新并识别了每一次插入和移除。因此，很明显，Linux内核本身识别到了硬件并准备使用它。这帮助我将问题缩小到桌面环境未能更新以显示插入的闪存驱动器，而我的硬件和USB端口完全正常。通过一个命令，我能够确定问题是软件问题，而不是硬件相关的问题。
- en: As you can see, Ubuntu contains very helpful log files that will aid you in
    troubleshooting your servers. Often, when you’re faced with a problem, viewing
    relevant log entries and then conducting a Google search regarding them will result
    in a useful answer, or at least bring you to a bug report to let you know the
    problem isn’t just limited to you or your configuration.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，Ubuntu包含了非常有用的日志文件，这些文件能帮助你排查服务器问题。通常，当你遇到问题时，查看相关的日志条目，然后进行Google搜索，往往会得到有用的答案，或者至少会找到一个bug报告，告诉你这个问题不仅限于你或你的配置。
- en: Hopefully, your search results will lead you right to the answer, or at least
    to a workaround. From there, you can continue to work through the problem until
    it is solved.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 希望你的搜索结果能直接带你找到答案，或者至少找到一个解决方法。然后，你可以继续处理问题，直到它被解决。
- en: What about network issues? Tracking down the root cause of an issue on the network
    can be especially challenging, but it’s not as difficult as it may seem. In the
    next section, we’ll take a look at a few ways you can trace network issues.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，网络问题呢？追踪网络问题的根本原因可能特别具有挑战性，但实际上并不像看起来那么难。在接下来的部分，我们将介绍几种追踪网络问题的方法。
- en: Tracing network issues
  id: totrans-88
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 追踪网络问题
- en: It’s amazing how important TCP/IP networking is to the world today. Of all the
    protocols in use in modern computing, it’s by far the most widespread. But it’s
    also one of the most annoying situations to figure out when it’s not working well.
    Thankfully, Ubuntu features really handy utilities you can use in order to pinpoint
    what’s going on.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 今天，TCP/IP网络对于世界的重要性真是令人惊讶。在现代计算中使用的所有协议中，它无疑是最为广泛的。但当它无法正常工作时，它也是最令人头疼的情况之一。幸运的是，Ubuntu提供了非常实用的工具，帮助你找出问题所在。
- en: First, let’s look at connectivity. After all, if you can’t connect to a network,
    your server is essentially useless. In most cases, Ubuntu recognizes just about
    all network cards without fail, and it will automatically connect your server
    or workstation to your network if it is within reach of a DHCP server.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们看看连接性。毕竟，如果你无法连接到网络，你的服务器基本上就没用了。在大多数情况下，Ubuntu几乎能够无误地识别所有网络卡，并且如果它能够连接到一个DHCP服务器，它会自动将你的服务器或工作站连接到网络。
- en: While troubleshooting, get the obvious stuff out of the way first. The following
    may seem like a no-brainer, but you’d be surprised how often one can miss something
    obvious. I’m going to assume you’ve already checked to make sure network cables
    are plugged in tight on both ends. Another aspect regarding cabling is that sometimes
    network cables themselves develop faults and need to be replaced. You should be
    able to use a cable tester and get a clean signal through the cable.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 在排查问题时，先处理显而易见的东西。以下内容看起来可能是显而易见的，但你会惊讶地发现有多少人会忽略这些显而易见的事情。我假设你已经检查过网络电缆是否在两端插好。关于电缆的另一个方面是，有时候网络电缆本身会出现故障，需要更换。你应该可以使用电缆测试仪来检查电缆是否能传递干净的信号。
- en: 'Routing issues can sometimes be tricky to troubleshoot, but by testing each
    destination point one by one, you can generally see where the problem lies. Typical
    symptoms of a routing issue may include being unable to access a device within
    another subnet, or perhaps not being able to get out to the internet, despite
    being able to reach internal devices. To investigate a potential routing issue,
    first, check your routing table. You can do so with the `ip route` command. This
    command will print your current routing table information:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 路由问题有时可能很难排查，但通过逐个测试每个目的地点，你通常能找到问题所在。路由问题的典型症状可能包括无法访问另一个子网内的设备，或者尽管能够访问内部设备，却无法访问互联网。要调查潜在的路由问题，首先检查你的路由表。你可以使用`ip
    route`命令来查看，运行此命令将打印出当前的路由表信息：
- en: '![](img/B18425_22_02.png)'
  id: totrans-93
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B18425_22_02.png)'
- en: 'Figure 22.2: Viewing the routing table on an Ubuntu server'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 图 22.2：在Ubuntu服务器上查看路由表
- en: In this example, you can see that the default gateway for all traffic is `10.10.10.1`.
    This is the first entry on the table, which tells us that all traffic to the destination
    `0.0.0.0` (which is everything) leaves via `10.10.10.1`. As long as ICMP traffic
    isn’t disabled, you should be able to ping this default gateway, and you should
    be able to ping other nodes within your subnet as well.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，你可以看到所有流量的默认网关是`10.10.10.1`。这是表格中的第一项，告诉我们所有到达目标`0.0.0.0`（即所有流量）的数据都通过`10.10.10.1`发送。只要ICMP流量没有被禁用，你应该能够ping通这个默认网关，并且应该能够ping通子网内的其他节点。
- en: To start troubleshooting a routing issue, you would use the information shown
    after printing your routing table to conduct several ping tests. First, try to
    ping your default gateway. If you cannot, then you’ve found the issue. If you
    can, try running the `traceroute` command.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 要开始排查路由问题，首先使用打印出的路由表中的信息进行几个ping测试。首先，尝试ping你的默认网关。如果无法ping通，那么问题就在这里。如果可以ping通，接下来尝试运行`traceroute`命令。
- en: This command isn’t available by default, but all you’ll have to do is install
    the `traceroute` package, so hopefully, you have it installed on the server. If
    you do, you can run `traceroute` against a host, such as an external URL, to find
    out where the connection drops. The `traceroute` command should show every hop
    between you and your target. Each “hop” is basically another default gateway.
    You traverse through one gateway after another until you ultimately reach your
    destination. With the `traceroute` command, you can see where the chain stops.
    In all likelihood, you’ll find that perhaps the problem isn’t even on your network,
    but perhaps your internet service provider is where the connection drops.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 这个命令默认并不可用，但你只需要安装`traceroute`包，所以下希望你已经在服务器上安装了它。如果已安装，你可以对主机运行`traceroute`，比如外部URL，来查找连接中断的位置。`traceroute`命令应该显示你与目标之间的每一个跳跃点。每个“跳跃”基本上是一个默认网关。你会依次穿过每个网关，直到最终到达目标。使用`traceroute`命令，你可以看到链条中断的地方。很可能，你会发现问题可能并不出现在你的网络上，而是出现在你的互联网服务提供商那一端。
- en: DNS issues don’t happen very often, but by using a few tricks, you should be
    able to resolve them. Symptoms of DNS failures will usually result in a host being
    unable to access internal or external resources by name.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: DNS问题并不常见，但通过一些技巧，你应该能够解决它们。DNS故障的症状通常表现为主机无法通过名称访问内部或外部资源。
- en: Knowing whether the problem is with internal or external hosts (or both) should
    help you determine whether it’s your DNS server that’s the problem, or perhaps
    the DNS server at your ISP.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 确定问题出在内部主机还是外部主机（或者两者都有）应该有助于你判断问题是不是出在DNS服务器，或者可能是你的互联网服务提供商的DNS服务器。
- en: 'The first step in pinpointing the source of DNS woes is to ping a known IP
    address on your network, preferably the default gateway. If you can ping it, but
    you can’t ping the gateway by name, then you probably have a DNS issue. You can
    confirm a potential DNS issue by using the `nslookup` command against the domain,
    such as this:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 定位 DNS 问题源的第一步是 ping 网络中的已知 IP 地址，最好是默认网关。如果你能 ping 通它，但无法通过名称 ping 通网关，那么你可能遇到了
    DNS 问题。你可以通过使用 `nslookup` 命令对域名进行查询来确认潜在的 DNS 问题，例如：
- en: '[PRE8]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: In addition, make sure you try and ping external resources as well, such as
    a website. This will help you narrow down the scope of the issue.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，请确保尝试 ping 外部资源，例如网站。这将帮助你缩小问题的范围。
- en: 'You will also want to know which DNS server your host is sending queries to.
    In the past, finding out which DNS server was assigned to your host was as simple
    as inspecting the contents of `/etc/resolv.conf`. However, nowadays, this file
    will often refer to a local resolver instead and won’t reveal the actual server
    requests are being sent to. To find out the real DNS server that’s assigned to
    your host, the following command will do the trick:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 你还需要了解你的主机正在向哪个 DNS 服务器发送查询请求。过去，查找分配给主机的 DNS 服务器就像查看 `/etc/resolv.conf` 文件内容一样简单。然而，现在这个文件通常会指向本地解析器，而不会显示实际的服务器请求目标。要找出分配给主机的真实
    DNS 服务器，可以使用以下命令：
- en: '[PRE9]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Are they what you expect? If not, you can temporarily fix this problem by removing
    the incorrect name server entries from this file and replacing them with the correct
    IP addresses. The reason I suggest this as a temporary fix and not a permanent
    one is because the next thing you’ll need to do is investigate how the invalid
    IP addresses got there in the first place. Normally, these are assigned by your
    DHCP server. As long as your DHCP server is sending out the appropriate name server
    list, you shouldn’t run into this problem. If you’re using a static IP address,
    then perhaps there’s an error in your Netplan config file.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 它们是你预期的 DNS 服务器吗？如果不是，你可以通过临时删除该文件中的错误名称服务器条目，并将其替换为正确的 IP 地址来解决这个问题。我建议将其作为临时解决方案而非永久解决方案的原因是，接下来你需要调查无效的
    IP 地址是如何出现在此文件中的。通常，这些地址是由你的 DHCP 服务器分配的。只要你的 DHCP 服务器发送适当的名称服务器列表，你就不应该遇到这个问题。如果你使用的是静态
    IP 地址，那么可能是你的 Netplan 配置文件中存在错误。
- en: A useful method of pinpointing DNS issues in regard to being unable to resolve
    external sites is to temporarily switch your DNS provider on your local machine.
    Normally, your machine is going to use your external DNS provider, such as the
    one that comes from your ISP. Your external DNS server is something we went through
    setting up in *Chapter 11*, *Setting Up Network Services*, specifically the forwarders
    section of the configuration for the `bind9` daemon. The forwarders used by the
    `bind9` daemon are where it sends traffic if it isn’t able to resolve your request
    based on its internal list of hosts.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 在无法解析外部网站时，定位 DNS 问题的一个有用方法是暂时切换本地计算机的 DNS 提供商。通常，你的计算机会使用外部 DNS 提供商，例如来自 ISP
    的 DNS。你设置外部 DNS 服务器的过程是我们在*第 11 章*，*设置网络服务*中提到的，具体来说是 `bind9` 守护进程配置中的转发器部分。`bind9`
    守护进程使用的转发器是它无法基于内部主机列表解析请求时发送流量的地方。
- en: You could consider bypassing this by changing your local workstation’s DNS name
    servers to Google’s, which are `8.8.8.8` and `8.8.4.4`. If you’re able to reach
    the external resource after switching your name servers, you can be reasonably
    confident that your forwarders are the culprit.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过将本地工作站的 DNS 名称服务器更改为 Google 的 `8.8.8.8` 和 `8.8.4.4` 来绕过此问题。如果在更改名称服务器后能够访问外部资源，那么你可以合理地认为是转发器导致了问题。
- en: I’ve actually seen situations in which a website has changed its IP address
    but the ISP’s DNS servers didn’t get updated quickly enough, causing some clients
    to be unable to reach a site they need to perform their job. Switching everyone
    to alternate name servers (by adjusting the `forwarders` option, as we did in
    *Chapter 11*, *Setting Up Network Services*) was the easiest way they could work
    around the issue.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 我实际上曾经遇到过这样一种情况：一个网站更改了其 IP 地址，但 ISP 的 DNS 服务器未能及时更新，导致一些客户无法访问他们工作所需的网站。将所有人切换到备用名称服务器（通过调整我们在*第
    11 章*，*设置网络服务*中提到的 `forwarders` 选项）是他们解决此问题的最简单方法。
- en: 'Some additional tools to consider while checking your server’s ability to resolve
    DNS entries are `dig` and `nslookup`. You should be able to use both commands
    to test your server’s DNS settings. Both commands are used with a hostname or
    domain name as an option. The `dig` command will present you with information
    regarding the address (`A`) record of the DNS zone file responsible for the IP
    address or domain. The `host` command should return the IP address of the host
    you’re trying to reach. Here’s some example output:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 在检查服务器解析 DNS 记录的能力时，一些额外的工具需要考虑，例如`dig`和`nslookup`。你应该能够使用这两个命令来测试服务器的 DNS 设置。两个命令都可以使用主机名或域名作为选项。`dig`命令将向你展示有关
    DNS 区域文件中负责 IP 地址或域名的地址（`A`）记录的信息。`host`命令应返回你尝试连接的主机的 IP 地址。以下是一些示例输出：
- en: '![](img/B18425_22_03.png)'
  id: totrans-110
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B18425_22_03.png)'
- en: 'Figure 22.3: Output of the dig and host commands'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 图 22.3：`dig` 和 `host` 命令的输出
- en: Hardware support is also critical when it comes to networking. If the Linux
    kernel doesn’t support your network hardware, then you’ll likely run into a situation
    where the distribution doesn’t recognize or do anything when you insert a network
    cable, or in the case of wireless networking, doesn’t show any nearby networks
    despite there being one or more. Unlike the Windows platform, hardware support
    is generally baked right into the kernel when it comes to Linux. While there are
    exceptions to this, the Linux kernel shipped with a distribution typically supports
    hardware the same age as itself or older.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 硬件支持在网络中也至关重要。如果 Linux 内核不支持你的网络硬件，你很可能会遇到这种情况：当你插入网络电缆时，发行版无法识别或没有任何反应，或者在无线网络的情况下，尽管有一个或多个网络，但却看不到任何附近的网络。与
    Windows 平台不同，Linux 在硬件支持方面通常是集成在内核中的。虽然也有例外，但发行版随附的 Linux 内核通常支持与其自身同龄或更早的硬件。
- en: In the case of Ubuntu 22.04 LTS (which was released in April 2022), it’s able
    to support hardware released as of the beginning of 2022 and older. Future releases
    of Ubuntu Server will publish hardware enablement updates, which will allow Ubuntu
    Server 22.04 to support newer hardware and chip sets once they come out. Typically,
    Ubuntu will release several point releases during the life of a supported distribution,
    such as 22.04.1, 22.04.2, and so on. As long as you’re using the latest one, you’ll
    have access to the latest hardware support that Ubuntu has made available at the
    time.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Ubuntu 22.04 LTS（该版本于2022年4月发布）的情况下，它能够支持截至2022年初发布的硬件和更早的硬件。未来的 Ubuntu Server
    版本将发布硬件支持更新，这将使 Ubuntu Server 22.04 能够支持新发布的硬件和芯片组。通常，Ubuntu 会在支持的发行版生命周期内发布几个版本更新，例如
    22.04.1、22.04.2 等等。只要你使用的是最新版本，你就能获得 Ubuntu 在当时提供的最新硬件支持。
- en: 'In other cases, hardware support may depend on external kernel modules. In
    the case of a missing hardware driver, the first thing you should try when faced
    with network hardware that’s not recognized is to look up the hardware using a
    search engine. Typically the search term `<hardware name> Ubuntu` will do the
    trick. But what do you search for? To find out the hardware string for your network
    device, try the `lspci` command:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 在其他情况下，硬件支持可能依赖于外部内核模块。如果缺少硬件驱动程序，当你遇到无法识别的网络硬件时，应该首先尝试使用搜索引擎查找该硬件。通常，搜索词 `<硬件名称>
    Ubuntu` 就能解决问题。但你该搜索什么呢？要查找你的网络设备的硬件字符串，可以尝试使用 `lspci` 命令：
- en: '[PRE10]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'The `lspci` command lists hardware connected to your server’s PCI bus. Here,
    we’re using the command with a case insensitive `grep` search for the word `net`:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: '`lspci` 命令列出了连接到服务器 PCI 总线的硬件。这里，我们使用该命令并结合不区分大小写的 `grep` 搜索 `net` 这个词：'
- en: '[PRE11]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'This should return a list of networking components available on your server.
    On my machine, for example, I get the following output:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 这将返回服务器上可用的网络组件列表。例如，在我的机器上，我得到以下输出：
- en: '[PRE12]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: As you can see, I have a wired and wireless network card on this machine. If
    one of them wasn’t working, I could search online for information by searching
    for the hardware string and the keyword `Ubuntu`, which should give me results
    pertaining to my exact hardware. If a package is required to be installed, the
    search results will likely give me some clues as to what package I need to install.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，我的机器上有一块有线和无线网卡。如果其中一个无法工作，我可以通过在线搜索硬件字符串和关键字 `Ubuntu` 来查找信息，这应该会给我关于我硬件的相关结果。如果需要安装某个软件包，搜索结果通常会给我一些关于需要安装哪个软件包的线索。
- en: Without having network access though, the worst-case scenario is that I may
    have to download the package from another computer and transfer it to the server
    via a flash drive. That’s certainly not a fun thing to need to do, but it does
    work if the latest Ubuntu installation media doesn’t yet offer full support for
    your hardware.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果没有网络访问，最坏的情况是我可能需要从另一台计算机下载软件包，并通过闪存驱动器将其传输到服务器。这肯定不是一件有趣的事情，但如果最新的 Ubuntu
    安装媒体尚未完全支持你的硬件，这种方法是有效的。
- en: Another potential problem point is DHCP. When it works well, DHCP is a wonderfully
    magical thing. When it stops working, it can be frustrating. But generally, DHCP
    issues often end up being a lack of available IP addresses, the DHCP daemon (`isc-dhcp-server`)
    not running, an invalid configuration, or hosts that have clocks that are out
    of sync (all servers should have the `ntp` package installed).
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个潜在的问题点是 DHCP。当它运行正常时，DHCP 是一项神奇的技术。当它停止工作时，则可能令人沮丧。但一般来说，DHCP 问题往往是由于可用的
    IP 地址不足、DHCP 守护进程（`isc-dhcp-server`）未运行、配置无效或主机的时钟不同步（所有服务器应该安装 `ntp` 包）。
- en: If you have a server that is unable to obtain an IP address via DHCP and your
    network utilizes a Linux-based DHCP server, check the system log (`/var/log/syslog`)
    for events related to `dhcpd`. Unfortunately, there’s no command you can run that
    I’ve ever been able to find that will print how many IP address leases your DHCP
    server has remaining, but if you run out, chances are you’ll see log entries related
    to an exhausted pool in the system log. In addition, the system log will also
    show you attempts from your nodes to obtain an IP address as they attempt to do
    so. Feel free to use `tail -f` against the system log to watch for any events
    related to DHCP leases.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你的服务器无法通过 DHCP 获取 IP 地址，并且你的网络使用的是基于 Linux 的 DHCP 服务器，请检查系统日志（`/var/log/syslog`）中与
    `dhcpd` 相关的事件。不幸的是，我从未找到过可以直接显示 DHCP 服务器剩余 IP 地址租约数的命令，但如果你用完了租约，系统日志中很可能会看到与池耗尽相关的日志条目。此外，系统日志还会显示你的节点尝试获取
    IP 地址时的尝试记录。你可以使用 `tail -f` 命令实时监控系统日志，以观察与 DHCP 租约相关的任何事件。
- en: In some cases, a lack of DHCP leases being available can come down to having
    a very generous lease time enabled. Some administrators will give their clients
    up to a week for the lease time, which is generally unnecessary. A lease time
    of one day is fine for most networks, but ultimately, the lease time you decide
    on is up to you. In *Chapter 11*, *Setting Up Network Services*, we looked at
    configuring our DHCP server, so feel free to refer to that chapter if you need
    a refresher on how to configure the `isc-dhcp-server` daemon.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些情况下，DHCP 租约不可用的问题可能是由于启用了非常长的租约时间。一些管理员会给客户端设置最长一周的租约时间，而这通常是不必要的。对于大多数网络来说，一天的租约时间就足够了，但最终，租约时间的决定权在于你自己。在*第11章*，*设置网络服务*中，我们已经讨论了如何配置
    DHCP 服务器，因此如果你需要回顾如何配置 `isc-dhcp-server` 守护进程，可以参考那一章。
- en: Although it’s probably not the first thing you’ll think of while facing DHCP
    issues, hosts having out-of-sync clocks can actually contribute to the problem.
    DHCP requests are `timestamped` on both the client and the server, so if the clock
    is off by a large degree on one, the timestamps will be off as well, causing the
    DHCP server to become confused. Surprisingly, I’ve seen this come up fairly often.
    I recommend standardizing NTP across your network as early on as you can. DHCP
    isn’t the only service that suffers when clocks are out of sync; file synchronization
    utilities also require accurate time. If you ensure NTP is installed on all of
    your clients and it’s up to date and working, you should be in good shape. Using
    configuration management utilities such as Ansible to ensure NTP is not only configured
    but is running properly on all the machines in your network will only benefit
    you.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管在面对 DHCP 问题时，这可能不是你首先想到的原因，但主机时钟不同步实际上可能会加剧问题。DHCP 请求在客户端和服务器上都会被 `时间戳`，因此，如果其中一方的时钟误差较大，时间戳也会出错，从而导致
    DHCP 服务器混淆。令人惊讶的是，我曾经遇到过这种情况相当频繁。我建议尽早在你的网络中标准化 NTP 配置。时钟不同步不仅会影响 DHCP 服务，文件同步工具也需要准确的时间。如果你确保所有客户端都安装了
    NTP，并且它是最新且正常运行的，你应该能确保一切顺利。使用配置管理工具（例如 Ansible）确保 NTP 不仅配置正确，还在网络中所有机器上正常运行，将对你大有裨益。
- en: Of course, there are many things that can go wrong when it comes to networking,
    but the information here should cover the majority of issues. In summary, troubleshooting
    network issues generally revolves around ping tests. Trying to ping your default
    gateway, tracing failed endpoints with `traceroute`, and troubleshooting DNS and
    DHCP will take care of a majority of issues. Then again, faulty hardware such
    as failed network cards and bad cabling will no doubt present themselves as well.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，网络方面可能出现许多问题，但这里的信息应该涵盖大多数问题。总的来说，排查网络问题通常围绕着 ping 测试展开。尝试 ping 默认网关、使用`traceroute`跟踪失败的端点，以及排查
    DNS 和 DHCP 问题，可以解决大多数问题。当然，硬件故障，如网卡损坏或电缆问题，也会显现出来。
- en: Our servers utilize storage, CPU, memory, and other resources to provide us
    with value and serve our clients. In the next section, we’ll take a closer look
    at how to check those resources.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的服务器利用存储、CPU、内存以及其他资源为我们提供价值并服务于我们的客户。在接下来的章节中，我们将详细介绍如何检查这些资源。
- en: Troubleshooting resource issues
  id: totrans-128
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 排查资源问题
- en: I don’t know about others, but it seems that a majority of my time troubleshooting
    servers is usually spent pinpointing resource issues. By resources, I’m referring
    to CPU, memory, disk, input/output, and so on. Generally, issues come down to
    a user storing too many large files, a process going haywire that consumes a large
    amount of CPU, or a server running out of memory. In this section, we’ll go through
    some of the common things you’re likely to run into while administering Ubuntu
    servers.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 我不知道其他人怎么样，但似乎我大多数排查服务器问题的时间通常都花在定位资源问题上。这里所说的资源指的是 CPU、内存、磁盘、输入/输出等。一般来说，问题通常出在用户存储了过多的大文件，某个进程异常消耗大量
    CPU，或者服务器内存不足。在本节中，我们将讨论一些你在管理 Ubuntu 服务器时可能会遇到的常见问题。
- en: 'First, let’s revisit topics related to storage. In *Chapter 9*, *Managing Storage
    Volumes*, we went over concepts related to this already, and many of those concepts
    also apply to troubleshooting as well. Therefore, I won’t spend too much time
    on those concepts here, but it’s worth a refresher in regard to troubleshooting
    storage issues. First, whenever you have users that are complaining about being
    unable to write new files to the server, the following two commands are the first
    you should run. You are probably already well aware of these, but they’re worth
    repeating:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们回顾一下与存储相关的话题。在*第9章* *管理存储卷*中，我们已经讨论过一些相关的概念，很多这些概念也适用于故障排除。因此，我不会在这里花太多时间讲解这些概念，但在排查存储问题时，复习这些内容是很有必要的。首先，每当用户抱怨无法在服务器上写入新文件时，以下两个命令是你应该首先运行的。你可能已经非常熟悉这些命令了，但它们值得重复：
- en: '[PRE13]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The first `df` command variation gives you information regarding how much space
    is used on a drive, in a human-readable format (the `-h` option), which will print
    the information in terms of megabytes and gigabytes.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个 `df` 命令的变体会以人类可读的格式（`-h` 选项）提供关于驱动器空间使用情况的信息，这些信息会以兆字节和吉字节为单位打印出来。
- en: The `-i` option in the second command gives you information regarding in-use
    and available inodes. The reason you should also run this is that on a Linux system,
    it can report storage as full even if there’s plenty of free space. But if there
    are no remaining inodes, it’s the same as being full, but the first command wouldn’t
    show the usage as 100 percent when no inodes are free. Usually, the number of
    inodes a storage medium has available is extremely generous, and the limit is
    hard to hit. However, if a service is creating new log files over and over every
    second, or a mail daemon grows out of control and generates a huge backlog of
    undelivered mail, you’d be surprised how quickly inodes can empty out.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个命令中的`-i`选项会提供关于正在使用和可用 inode 的信息。你需要运行此命令的原因是，在 Linux 系统中，如果没有剩余的 inode，系统会报告存储已满，即使仍然有大量的可用空间。通常，存储介质可用的
    inode 数量是非常充裕的，限制也很难达到。然而，如果一个服务不断地创建新的日志文件，或者邮件守护进程失控并生成大量未发送的邮件，你会惊讶于 inode
    会这么快耗尽。
- en: 'Of course, once you figure out that you have an issue with full storage, the
    next logical question becomes, what is eating up all my free space? The `df` commands
    will give you a list of storage volumes and their sizes, which will tell you at
    least which disk or partition to focus your attention on. My favorite command
    for pinpointing storage hogs, as I mentioned in *Chapter 9*, *Managing Storage
    Volumes*, is the `ncdu` command. While not installed by default, `ncdu` is a wonderful
    utility for checking to see where your storage is being consumed the most. If
    run by itself, `ncdu` will scan your server’s entire filesystem. Instead, I recommend
    running it with the `-x` option, which will limit it to a specific folder as a
    starting point. For example, if the `/home` partition is full on your server,
    you might want to run the following to find out which directory is using the most
    space:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，一旦你发现存储已满，接下来的逻辑问题是，是什么占用了我所有的空闲空间？`df` 命令会列出存储卷及其大小，至少会告诉你哪个磁盘或分区需要关注。正如我在*第9章*《管理存储卷》中提到的，我最喜欢用的定位存储占用的命令是
    `ncdu` 命令。虽然默认没有安装，`ncdu` 是一个非常棒的工具，可以检查存储的主要占用位置。如果单独运行，`ncdu` 会扫描服务器的整个文件系统。相反，我建议加上
    `-x` 选项，这样它只会限制扫描特定文件夹。例如，如果服务器的 `/home` 分区已满，你可能希望运行以下命令来查找哪个目录占用了最多的空间：
- en: '[PRE14]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The `-x` option will cause `ncdu` to not cross filesystems. This means if you
    have another disk mounted within the folder you’re scanning, it won’t touch it.
    With `-x`, `ncdu` is only concerned with the target you give it.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: '`-x` 选项会导致 `ncdu` 不跨越文件系统。这意味着如果你在扫描的文件夹内挂载了另一个磁盘，它将不会触及这个磁盘。使用 `-x` 选项时，`ncdu`
    只关注你指定的目标。'
- en: 'If you aren’t able to utilize `ncdu`, there’s also the `du` command, which
    takes some extra work. The `du -h` command, for example, will give you the current
    usage of your current working directory, with human-readable numbers. It doesn’t
    traverse directory trees by default like `ncdu` does, so you’d need to run it
    on each subdirectory until you manually find the directory that’s holding the
    most files. A very useful variation of the `du` command, nicknamed `ducks`, is
    the following. It will show you the top 15 largest directories in your current
    working directory:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你无法使用 `ncdu`，也可以使用 `du` 命令，不过需要更多的操作。例如，`du -h` 命令会显示当前工作目录的使用情况，且以人类可读的数字呈现。它默认不会像
    `ncdu` 那样遍历目录树，因此你需要在每个子目录上运行它，直到手动找到占用最多文件的目录。`du` 命令的一个非常有用的变种，昵称为 `ducks`，如下所示。它将显示当前工作目录中最大的前15个目录：
- en: '[PRE15]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Another issue with storage volumes that can arise is to do with filesystem
    integrity. Most of the time, these issues only seem to come up when there’s an
    issue with power, such as a server powering off unexpectedly. Depending on the
    server and the formatting you’ve used when setting up your storage volumes (and
    several other factors), power issues are handled differently from one installation
    to another. In most cases, a filesystem check (`fsck`) will happen automatically
    during the next boot. If it doesn’t, and you’re having odd issues with storage
    that can’t be explained, a manual filesystem check is recommended. Scheduling
    a filesystem check is actually very easy:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个可能出现的存储卷问题是与文件系统完整性相关。大多数时候，这些问题似乎只有在出现电力问题时才会出现，比如服务器意外断电。根据服务器和在设置存储卷时所使用的格式（以及其他几个因素），电力问题的处理方式因安装而异。在大多数情况下，文件系统检查（`fsck`）会在下次启动时自动发生。如果没有发生，并且你遇到了一些无法解释的存储问题，建议手动进行文件系统检查。安排文件系统检查其实非常简单：
- en: '[PRE16]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The previous command will create an empty file, `forcefsck`, at the root of
    the filesystem. When the server reboots and it sees this file, it will trigger
    a filesystem check on that volume and then remove the file.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 上面的命令会在文件系统的根目录创建一个空文件 `forcefsck`。当服务器重启并看到这个文件时，它会触发对该存储卷的文件系统检查，然后删除该文件。
- en: 'If you’d like to check a filesystem other than the root volume, you can create
    the `forcefsck` file elsewhere. For example, if your server has a separate `/home`
    partition, you could create the file there instead to check that volume:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想检查根存储卷以外的文件系统，可以在其他地方创建 `forcefsck` 文件。例如，如果你的服务器有一个单独的 `/home` 分区，你可以在该位置创建文件来检查该存储卷：
- en: '[PRE17]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: The filesystem check will usually complete fairly quickly unless there’s an
    issue it needs to fix. Depending on the nature of the problem, the issue could
    be repaired quickly, or perhaps it will take a while. I’ve seen some really bad
    integrity issues that have taken over four hours to fix, but I’ve seen others
    fixed in a matter of seconds. Sometimes it will finish so quickly that it will
    scroll by so fast during boot that you may miss seeing it. In case of a large
    volume, you may want to schedule the `fsck` check to happen after-hours in case
    the scan takes a long time.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 文件系统检查通常会相对较快地完成，除非有需要修复的问题。根据问题的性质，可能会快速修复，或者可能需要较长时间。我见过一些非常严重的完整性问题，修复需要超过四个小时，但我也见过其他问题只需几秒钟就能修复。有时它会非常快速地完成，在启动过程中会快速滚动，以至于你可能会错过看到它的机会。在大容量的情况下，你可能希望安排`fsck`检查在非工作时间进行，以防扫描时间较长。
- en: 'With regards to issues with memory, the `free -m` command will give you an
    overview of how much memory and swap are available on your server. It won’t tell
    you what exactly is using up all your memory, but you’ll use it to see if you’re
    in jeopardy of running out. The **free** column from the output of the `free`
    command will show you how much memory is remaining, and allow you to make a decision
    on when to take action:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 关于内存问题，`free -m`命令将为你提供服务器上可用内存和交换空间的概述。它不会告诉你究竟是什么正在使用你的所有内存，但你可以用它来查看是否面临内存耗尽的危险。`free`命令的输出中的**free**列将显示剩余多少内存，并允许你决定何时采取行动：
- en: '![](img/B18425_22_04.png)'
  id: totrans-146
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B18425_22_04.png)'
- en: 'Figure 22.4: Checking the available memory on an Ubuntu server'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 图 22.4：检查 Ubuntu 服务器上可用内存
- en: In *Chapter 8*, *Monitoring System Resources*, we took a look at the `htop`
    command, which helps us answer the question of “what” is using up our resources.
    Using `htop` (once installed), you can sort the list of processes by CPU or memory
    usage by pressing *F6* and then selecting a new sort field, such as `PERCENT_CPU`
    or `PERCENT_MEM`. This will give you an idea of what is consuming resources on
    your server, allowing you to make a decision on what to do about it. The action
    you take will differ from one process to another, and your solution may range
    from adding more memory to the server to tuning the application to have a lower
    memory ceiling. But what do you do when the results from `htop` don’t correlate
    to the usage you’re seeing? For example, what if your load average is high, but
    no process seems to be consuming a large portion of CPU?
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 在*第 8 章*中，*监控系统资源*，我们介绍了`htop`命令，它帮助我们回答“什么”正在使用我们的资源的问题。安装了`htop`后，你可以通过按下*F6*然后选择一个新的排序字段（如`PERCENT_CPU`或`PERCENT_MEM`）来按CPU或内存使用率对进程列表进行排序。这将让你了解到服务器上哪些内容正在消耗资源，从而让你可以做出相应的决策。你的解决方案可能因进程而异，从增加服务器内存到调整应用程序以降低内存使用上限都有可能。但当`htop`的结果与你观察到的使用情况不符时，你该怎么办呢？例如，如果你的负载平均值很高，但没有进程似乎占用大量CPU？
- en: 'One command I haven’t discussed so far in this book is `iotop`. While not installed
    by default, the `iotop` utility is definitely a must-have, so I recommend you
    install the `iotop` package. The `iotop` utility itself needs to be run as `root`
    or with `sudo`:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书中，我还没有讨论过的一个命令是`iotop`。虽然不是默认安装的，但`iotop`实用程序绝对是必备的，因此我建议你安装`iotop`包。`iotop`本身需要以`root`或使用`sudo`来运行：
- en: '[PRE18]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: The `iotop` command will allow you to see how much data is being written to
    or read from your disks. **Input/Output** (**IO**) definitely contributes to a
    system’s load, and not all resource monitoring utilities will show this usage.
    If you see a high load average but nothing in your resource monitor shows anything
    to account for it, check the IO.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: '`iotop`命令将允许你查看数据写入或从磁盘读取的量。**输入/输出**（**IO**）绝对会对系统的负载产生影响，而并非所有的资源监控工具都会显示这种使用情况。如果你看到负载平均值很高，但资源监视器中没有任何内容可以解释这一使用情况，请检查IO。'
- en: 'The `iotop` utility is a great way to do that as if data is bottle-necked while
    being written to disk, which can account for a serious overhead in IO that will
    slow other processes down. If nothing else, it will give you an idea of which
    process is misbehaving, in case you need to kill it:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: '`iotop`实用程序是一个很好的方式，因为如果数据在写入磁盘时受到限制，这可能会导致IO中的严重开销，从而减慢其他进程的速度。即使没有其他影响，它也能让你知道哪个进程在出现问题，以便你需要终止它：'
- en: '![](img/B18425_22_05.png)'
  id: totrans-153
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B18425_22_05.png)'
- en: 'Figure 22.5: The iotop utility running on an Ubuntu server'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 图 22.5：在 Ubuntu 服务器上运行的 iotop 实用程序
- en: The `iotop` window will refresh on its own, sorting processes by the column
    that is highlighted. To change the highlight, you’ll only need to press the *left*
    and *right* arrows on your keyboard. You can sort processes by columns such as
    `IO`, `SWAPIN`, `DISK WRITE`, `DISK READ`, and others. When you’re finished with
    the application, press *q* to quit.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: '`iotop`窗口会自动刷新，根据高亮的列排序进程。要改变高亮列，你只需要按键盘上的*左箭头*和*右箭头*。你可以按照`IO`、`SWAPIN`、`DISK
    WRITE`、`DISK READ`等列来排序进程。完成后，按*q*退出应用程序。'
- en: The utilities we looked at in this section are very useful when identifying
    issues with bottle-necked resources. What you do to correct the situation after
    you find the culprit will depend on the daemon. Perhaps there’s an invalid configuration,
    or the daemon has encountered a fault and needs to be restarted. Often, checking
    the logs may lead you to an answer as to why a daemon misbehaves. In the case
    of full storage, almost nothing beats `ncdu`, which will almost always lead you
    directly to the problem. Tools such as `htop` and `iotop` allow you to view additional
    information regarding resource usage as well, and `htop` even allows you to kill
    a misbehaving process right from within the application, by pressing *F9*.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 本节中介绍的工具在识别瓶颈资源问题时非常有用。在发现问题根源后，你的解决方法将取决于守护进程。可能是配置无效，或者守护进程遇到故障需要重新启动。通常，查看日志可能会帮助你找到守护进程出现问题的原因。在存储空间满了的情况下，几乎没有什么工具能比得上`ncdu`，它几乎总能直接指向问题所在。像`htop`和`iotop`这样的工具也能让你查看关于资源使用的更多信息，而`htop`甚至允许你直接在应用程序内按*F9*键杀死一个表现不正常的进程。
- en: What do you do when system memory (RAM) becomes physically defective? It happens
    more often than you’d think. In the next section, we’ll look at a way we can test
    our RAM to see if it’s defective or not.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 当系统内存（RAM）发生物理故障时，你该怎么办？这种情况比你想象的要更常见。在接下来的章节中，我们将探讨一种方法，来测试我们的RAM是否存在故障。
- en: Diagnosing defective RAM
  id: totrans-158
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 诊断有缺陷的RAM
- en: All server and computing components can and will fail eventually, but there
    are a few pieces of hardware that seem to fail more often than others. Fans, power
    supplies, and hard disks definitely make the list of common things administrators
    will end up replacing, but defective memory is also a situation I’m sure you’ll
    run into eventually.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 所有的服务器和计算组件最终都会出现故障，但有一些硬件似乎比其他组件更容易出现问题。风扇、电源和硬盘绝对是管理员更换的常见设备，但有缺陷的内存也是一个我相信你最终会遇到的情况。
- en: Although memory sticks becoming defective is something that could happen, I
    made it the last section in this chapter because unfortunately, I can’t give you
    a definitive list of symptoms to look out for that indicate that memory is the
    source of an issue. RAM issues are very mysterious in nature, and each time I’ve
    run into one, I’ve always stumbled across memory being bad only after troubleshooting
    everything else. It’s for this reason that nowadays I’ll often test the memory
    on a server or workstation first since it’s very easy to do. Even if memory has
    nothing to do with an issue, it’s worth checking anyway since it could become
    a problem later.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管内存条发生故障是有可能的，但我把它放在本章的最后一节，因为不幸的是，我无法给出一份明确的症状清单，帮助你判断内存是否是问题的根源。RAM问题本质上是非常神秘的，每次我遇到这类问题时，总是通过排除其他所有可能的原因后，才最终发现是内存坏了。正因如此，现在我通常会先测试服务器或工作站的内存，因为这非常简单。即使内存问题与某个问题无关，检查它也是值得的，因为它可能以后会成为问题。
- en: 'Most distributions of Linux (Ubuntu included) feature **Memtest86+** right
    on the installation media. Whether you create a bootable CD or flash drive, there’s
    a memory test option available from the Ubuntu Server media. When you first boot
    from the Ubuntu Server media, you’ll see an icon toward the bottom indicating
    that you can press a key to bring up a menu (if you don’t press a key, the installer
    will automatically start). Next, you’ll be asked to choose your language, and
    then you’ll be shown an installation menu. Among the choices there will be a **Test
    memory** option:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数Linux发行版（包括Ubuntu）在安装介质中都带有**Memtest86+**。无论你是创建可启动的CD还是闪存驱动器，都可以从Ubuntu
    Server的安装介质中选择内存测试选项。当你首次从Ubuntu Server介质启动时，你会看到一个位于屏幕底部的图标，表示你可以按一个键来显示菜单（如果不按键，安装程序会自动启动）。接下来，你需要选择语言，然后会显示安装菜单。在菜单中会有一个**测试内存**的选项：
- en: '![](img/B18425_22_06.png)'
  id: totrans-162
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B18425_22_06.png)'
- en: 'Figure 22.6: The main menu of the Ubuntu installer, showing a Test memory option'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 图22.6：Ubuntu安装程序的主菜单，显示了一个“测试内存”选项
- en: Other editions of Ubuntu, such as the Ubuntu desktop distribution or any of
    its derivatives, also feature an option to test memory. Even if you don’t have
    installation media handy for the server edition, you can use whichever version
    you have.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 其他版本的 Ubuntu，如 Ubuntu 桌面版或其任何衍生版，也提供了测试内存的选项。即使你没有服务器版的安装介质，你也可以使用你手头上的任何版本。
- en: When you choose the **Test memory** option from your installation media, the
    **Memtest86+** program will immediately get to work and start testing your memory
    (press *Esc* to exit the test). The test may take a long time, depending on how
    much memory your workstation or server has installed. It can take minutes or even
    hours to complete. Generally speaking, when your machine has defective RAM, you’ll
    see a bunch of errors show up relatively quickly, usually within the first 5-10
    minutes.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 当你从安装介质中选择**测试内存**选项时，**Memtest86+**程序会立即开始工作并测试你的内存（按*Esc*键退出测试）。根据你的工作站或服务器安装的内存量，测试可能需要很长时间，可能需要几分钟甚至几个小时才能完成。一般来说，当你的机器存在有缺陷的
    RAM 时，你会在相对较短的时间内看到一堆错误，通常是在前 5-10 分钟内。
- en: If you don’t see errors within 15 minutes, you’re most likely in good shape.
    In my experience, every time I’ve run into defective memory, I’ve seen errors
    in 15 minutes or less (usually within 5). Theoretically, though, you could very
    well have a small issue with your memory modules that may not show up until after
    15 minutes, so you should let the test finish if you can spare the time for it.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在 15 分钟内没有出现错误，通常说明你的系统状态良好。根据我的经验，每次遇到有缺陷的内存时，我都会在 15 分钟内或更短时间内看到错误（通常是在
    5 分钟内）。不过，从理论上讲，你的内存模块可能存在一个小问题，这个问题可能在 15 分钟之后才会出现，所以如果你有时间，最好让测试完成。
- en: The main question becomes when to run **Memtest86+** on a machine. In my experience,
    symptoms of bad memory are almost never the same from one machine to another.
    Usually, you’ll run into a situation where a server doesn’t boot properly, applications
    close unexpectedly, applications don’t start at all, or perhaps an application
    is behaving irregularly. In my view, testing memory should be done whenever you
    experience a problem that doesn’t necessarily seem straightforward. In addition,
    you may want to consider testing the memory on your server before you roll it
    out into production. That way, you can ensure that it starts out as free of hardware
    issues as possible. If you install new memory modules, make sure to test the RAM
    right away.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 主要的问题是：什么时候在机器上运行**Memtest86+**。根据我的经验，内存有问题的症状在不同机器上几乎从来都不相同。通常，你会遇到服务器无法正常启动、应用程序意外关闭、应用程序根本无法启动，或者某个应用程序行为不正常的情况。在我看来，当你遇到一个问题，看起来不那么直接明了时，应该进行内存测试。此外，你可能还想在将服务器投入生产之前，先测试一下内存。这样，你可以确保它在开始时尽可能不含硬件问题。如果你安装了新的内存模块，请务必立即测试
    RAM。
- en: If the test does report errors, you’ll next want to find out which memory module
    is faulty. This can be difficult, as some servers can have more than a dozen memory
    modules installed. To narrow it down, you’d want to test each memory module independently
    if you can, until you find out which one is defective. You should also continue
    to test the other modules, even after you discover the culprit. The reason for
    this is that having multiple memory modules going bad isn’t outside the realm
    of possibility, considering whatever situation led to the first module becoming
    defective may have affected others.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 如果测试报告了错误，接下来你需要找出哪个内存模块有问题。这可能会比较困难，因为一些服务器可能安装了十几个内存模块。为了缩小范围，如果可能的话，你应该独立测试每个内存模块，直到找出哪个模块是有缺陷的。即使你找到了有问题的模块，也应该继续测试其他模块。原因是，多个内存模块同时出现问题并非不可能，因为导致第一个模块出现故障的情况可能也影响了其他模块。
- en: Another tip I’d like to pass along regarding memory is that when you do discover
    a bad stick of memory, it’s best to erase the hard disk and start over if you
    can. I understand that this isn’t always feasible, and you could have many hours
    logged into setting up a server. Some servers can take weeks to rebuild, depending
    on their workload. But at least keep in mind that any data that passes through
    defective RAM can become corrupted.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 另外，我想给你提供一个关于内存的建议：当你发现某个内存条有问题时，如果可以的话，最好清空硬盘并重新开始。我理解这并非总是可行的，而且你可能已经花了很多时间来设置服务器。有些服务器可能需要几周才能重建，具体取决于它们的工作负载。但至少要记住，任何经过有缺陷的
    RAM 的数据都有可能变得损坏。
- en: This means that data at rest (data stored on your hard disk) may be corrupt
    if it was sitting in a defective area of RAM before it was written to disk. When
    a server or workstation encounters defective RAM, you really can’t trust it anymore.
    I’ll leave the decision on how to handle this situation up to you (hopefully you’ll
    never encounter it at all), but just keep this in mind as you plan your course
    of action. Personally, I don’t trust an installation of any operating system after
    its hardware has encountered such issues.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着，如果数据在写入磁盘之前曾存放在有缺陷的 RAM 区域，那么静态数据（存储在硬盘上的数据）可能会损坏。当服务器或工作站遇到有缺陷的 RAM 时，你就不能再信任它了。我将如何处理这种情况留给你决定（希望你永远不会遇到这种问题），但在你计划行动方案时，记住这一点。就个人而言，我在硬件出现此类问题后不再信任任何操作系统的安装。
- en: 'I also recommend that you check the capacitors on your server’s motherboard
    whenever you’re having odd issues. Although this isn’t necessarily related to
    memory, I mention it here because the symptoms are basically the same as bad memory
    when you have bad capacitors. I’m not asking you to get a voltage meter or do
    any kind of electrician work, but sometimes it may make sense to open the case
    of your server, shine a flashlight on the capacitors, and see if any of them appear
    to be leaking fluid or expanding. The reason I bring this up is that I’ve personally
    spent hours troubleshooting a machine (more than once) where I would test the
    memory and hard disk and look through system logs, without finding any obvious
    causes, only to later look at the hardware and discover that capacitors on the
    motherboard were leaking. It would have saved me a lot of time if I had simply
    looked at the capacitors. And that’s really all you have to do: just take a quick
    glance around the motherboard and look for anything that doesn’t seem right.'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 我还建议你在遇到奇怪问题时检查服务器主板上的电容器。虽然这与内存问题不一定相关，但我在此提到它是因为当电容器损坏时，症状与内存故障基本相同。我不是让你去买一个电压表或做任何电工工作，但有时候，打开服务器机箱，拿手电筒照一下电容器，看是否有任何电容器泄漏液体或膨胀，确实是有意义的。我之所以提这个，是因为我曾经花了几个小时排查一台机器（不止一次），测试内存、硬盘并查看系统日志，却没有发现明显的原因，后来再检查硬件时才发现主板上的电容器在泄漏。如果我早早检查电容器，可能会省去不少时间。这其实就是你需要做的：快速扫一眼主板，看看有没有什么不对劲的地方。
- en: Summary
  id: totrans-172
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: While Ubuntu is generally a very stable and secure platform, it’s important
    to be prepared for problems occurring and to know how to deal with them. In this
    chapter, we discussed common troubleshooting we can perform when our servers stop
    behaving themselves. We started off by evaluating the scope, which gives us an
    understanding of how many users or servers are affected by the issue. Then, we
    looked into Ubuntu’s log files, which are a treasure trove of information that
    we can use to pinpoint issues and narrow down the problem. We also covered several
    networking issues that can come up, such as issues with DHCP, DNS, and routing.
    We certainly can’t predict problems before they occur, nor can we be prepared
    in advance for every type of problem that can possibly happen. However, applying
    sound logic and common sense to problems will go a long way in helping us figure
    out the root cause.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然 Ubuntu 通常是一个非常稳定和安全的平台，但了解如何应对可能出现的问题并做好准备是很重要的。在本章中，我们讨论了当服务器无法正常运行时，可以进行的常见故障排除。我们首先评估了问题的范围，这有助于我们了解有多少用户或服务器受到了影响。然后，我们查看了
    Ubuntu 的日志文件，这些日志文件包含了大量信息，帮助我们定位问题并缩小问题范围。我们还讨论了几种可能出现的网络问题，例如 DHCP、DNS 和路由问题。我们当然无法在问题发生之前预测它们，也无法提前为每一种可能发生的问题做好准备。然而，将合理的逻辑和常识应用于问题处理中，将大大帮助我们找出根本原因。
- en: In the next chapter, we will take a look at preventing disasters in the first
    place and recovering from them if they happen anyway. See you there!
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将讨论如何防止灾难的发生，并在灾难发生时如何进行恢复。我们下章见！
- en: Further reading
  id: totrans-175
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: 'Reporting Bugs in Ubuntu Server: [https://learnlinux.link/report-bugs](https://learnlinux.link/report-bugs)'
  id: totrans-176
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 Ubuntu 服务器中报告错误：[https://learnlinux.link/report-bugs](https://learnlinux.link/report-bugs)
- en: Join our community on Discord
  id: totrans-177
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 加入我们在 Discord 上的社区
- en: 'Join our community’s Discord space for discussions with the author and other
    readers:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 加入我们社区的 Discord 讨论区，与作者及其他读者交流：
- en: '[https://packt.link/LWaZ0](https://packt.link/LWaZ0)'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://packt.link/LWaZ0](https://packt.link/LWaZ0)'
- en: '![](img/QR_Code50046724-1955875156.png)'
  id: totrans-180
  prefs: []
  type: TYPE_IMG
  zh: '![](img/QR_Code50046724-1955875156.png)'
