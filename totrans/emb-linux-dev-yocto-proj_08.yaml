- en: '8'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Diving into BitBake Metadata
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: At this point in this book, we know how to generate images and packages and
    how to use package feeds – basically, everything we must know for the simple usage
    of Poky. Hereafter, we will learn how to control the behavior of Poky to accomplish
    our goals and achieve maximum benefit from the Yocto Project as a whole.
  prefs: []
  type: TYPE_NORMAL
- en: This chapter will help enhance our understanding of the BitBake metadata syntax.
    We will learn to use the BitBake operators to alter the content of variables,
    variable expansions, and so on. These are the key concepts we can use to make
    our recipes and the customization that we will learn about in the following chapters.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding BitBake’s metadata
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The amount of metadata used by BitBake is enormous. Therefore, to get the maximum
    benefit from Poky, we must master it. As we learned in [*Chapter 4*](B19361_04.xhtml#_idTextAnchor071),
    *Meeting the BitBake Tool*, metadata covers three major areas:'
  prefs: []
  type: TYPE_NORMAL
- en: '`.conf` files): The configuration files define the global content that configures
    how the classes and recipes will work.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`.bbclass` files): Classes can be inherited for easier maintenance and to promote
    code reuse and avoid code duplication.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`.bb` or `.bbappend` files): The recipes describe the tasks to be run and provide
    the required information to allow BitBake to generate the required task chain.
    They are the most commonly used metadata, as they define the variables and tasks
    for the recipes. The most common types of recipes generate packages and images.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The classes and recipes use a mix of Python and Shell Script code, which is
    parsed by BitBake, generating a massive number of tasks and local states that
    must still be executed after being parsed.
  prefs: []
  type: TYPE_NORMAL
- en: We will also learn about the operators and essential concepts we need to build
    our recipes.
  prefs: []
  type: TYPE_NORMAL
- en: Working with metadata
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The syntax used by BitBake metadata can be misleading and sometimes hard to
    trace. However, we can check the value of each variable in BitBake-generated,
    pre-processed recipe data by using the `bitbake` option (`-e` or `--environment`),
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.1 – How to display the BitBake environment](img/Figure_8.01_B19361.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8.1 – How to display the BitBake environment
  prefs: []
  type: TYPE_NORMAL
- en: To understand how BitBake works, please refer to *BitBake User Manual* ([https://docs.yoctoproject.org/bitbake/2.0](https://docs.yoctoproject.org/bitbake/2.0)).
    The following sections will show most of the syntax commonly used in recipes.
  prefs: []
  type: TYPE_NORMAL
- en: The basic variable assignment
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The assignment of a variable can be done as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.2 – An example of a variable assignment](img/Figure_8.02_B19361.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8.2 – An example of a variable assignment
  prefs: []
  type: TYPE_NORMAL
- en: In the preceding example, the value of the `FOO` variable is assigned to `bar`.
    Variable assignment is core to the BitBake metadata syntax, as most examples use
    variables.
  prefs: []
  type: TYPE_NORMAL
- en: The variable expansion
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'BitBake supports variable referencing. The syntax closely resembles Shell Script,
    such as the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.3 – An example of variable expansion](img/Figure_8.03_B19361.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8.3 – An example of variable expansion
  prefs: []
  type: TYPE_NORMAL
- en: 'The preceding example results in `A` containing `aValue` and `B` containing
    `before-aValue-after`. An important thing to bear in mind is that the variable
    only expands when it is used, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.4 – The variables are only expanded when used](img/Figure_8.04_B19361.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8.4 – The variables are only expanded when used
  prefs: []
  type: TYPE_NORMAL
- en: '*Figure 8**.4* illustrates the *lazy evaluation* used by BitBake evaluation.
    The `B` variable value is `before-${A}-after` until a task requires the variable
    value. The `A` variable has been assigned to `aNewValue` in line 3; consequently,
    `B` evaluates `before-aNewValue-after`.'
  prefs: []
  type: TYPE_NORMAL
- en: Assigning a value if the variable is unassigned, using ?=
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'When there is a need to assign a variable only if the variable is still unassigned,
    the `?=` operator can be used. The following code shows its use:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.5 – An example of value](img/Figure_8.05_B19361.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8.5 – An example of value
  prefs: []
  type: TYPE_NORMAL
- en: 'The same behavior happens if there are multiple `?=` assignments to a single
    variable. The first use of the `?=` operator is responsible for assigning the
    variable. Let’s look at the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.6 – An example of a second assignment being ignored](img/Figure_8.06_B19361.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8.6 – An example of a second assignment being ignored
  prefs: []
  type: TYPE_NORMAL
- en: The `A` variable has been assigned to `value` on line 1, before the assignment
    of `ignoredAsAlreadyAssigned` on line 2, which is ignored.
  prefs: []
  type: TYPE_NORMAL
- en: 'We need to consider that the `=` operator is stronger than the `?=` operator,
    as it assigns the value independently of the previous variable state, as shown
    here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.7 – An example showing that the ?= operator is weaker than the =
    operator](img/Figure_8.07_B19361.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8.7 – An example showing that the ?= operator is weaker than the = operator
  prefs: []
  type: TYPE_NORMAL
- en: Hence, the `A` variable is assigned as `changeValue`.
  prefs: []
  type: TYPE_NORMAL
- en: Assigning a default value using ??=
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Using the `??=` operator is intended to provide a default value for a variable
    and is a weaker version of the `?=` operator.
  prefs: []
  type: TYPE_NORMAL
- en: 'Check out the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.8 – An example of how default values are assigned](img/Figure_8.08_B19361.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8.8 – An example of how default values are assigned
  prefs: []
  type: TYPE_NORMAL
- en: In line 1, the `A` default value is assigned to `firstValue`, and then in line
    2, the `A` default value is changed to `secondValue`. As no other assignment is
    made to the `A` variable, the final value is `secondValue`.
  prefs: []
  type: TYPE_NORMAL
- en: '`?=` is an assignment operator, as seen before, and takes precedence over the
    `??=` operator, as can be seen in the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.9 – An example of the ??= operator being weaker than the ?= operator](img/Figure_8.09_B19361.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8.9 – An example of the ??= operator being weaker than the ?= operator
  prefs: []
  type: TYPE_NORMAL
- en: The final value of `A` variable is `thirdValue`, as no assignment has been made
    until line 3.
  prefs: []
  type: TYPE_NORMAL
- en: The immediate variable expansion
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `:=` operator is used when there is a need to force the immediate expansion
    of a variable. It results in the variable’s contents being expanded immediately
    rather than when the variable is used, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.10 – An example of immediate variable expansion](img/Figure_8.10_B19361.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8.10 – An example of immediate variable expansion
  prefs: []
  type: TYPE_NORMAL
- en: The value for `B` is assigned immediately, in line 2, and expands to `aValue-after`.
    However, the value for `C` is only assigned when used and then set to `newValue`,
    as `A` value has been set in line 3.
  prefs: []
  type: TYPE_NORMAL
- en: The list appending and prepending
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `+=` operator, known as *list appending*, adds a new value after the original
    one, separated with a space, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.11 – An example of list appending](img/Figure_8.11_B19361.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8.11 – An example of list appending
  prefs: []
  type: TYPE_NORMAL
- en: In this example, the final value for `A` is `originalValue appendedValue`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `=+` operator, known as *list prepending*, adds a new value before the
    original one, separated with a space, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.12 – An example of list prepending](img/Figure_8.12_B19361.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8.12 – An example of list prepending
  prefs: []
  type: TYPE_NORMAL
- en: In this example, the final value for `A` is `prependedValue originalValue`.
  prefs: []
  type: TYPE_NORMAL
- en: The string appending and prepending
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `.=` operator, known as *string appending*, adds a new value after the
    original one, with no extra space, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.13 – An example of string appending](img/Figure_8.13_B19361.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8.13 – An example of string appending
  prefs: []
  type: TYPE_NORMAL
- en: In this example, the final value for `A` is `originalValueAppendedValue`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `=.` operator, known as *string prepending*, adds the new value before
    the original one with no extra space, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.14 – An example of string prepending](img/Figure_8.14_B19361.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8.14 – An example of string prepending
  prefs: []
  type: TYPE_NORMAL
- en: In this example, the final value for `A` is `prependedValueOriginalValue`.
  prefs: []
  type: TYPE_NORMAL
- en: The :append and :prepend operators
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `:append` operator adds a new value after the original with no extra space,
    as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.15 – An example of how to use the :append operator](img/Figure_8.15_B19361.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8.15 – An example of how to use the :append operator
  prefs: []
  type: TYPE_NORMAL
- en: In this example, the final value for `A` is `originalValueAppendedValue`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `:prepend` operator adds the new value before the original with no extra
    space, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.16 – An example of how to use the :prepend operator](img/Figure_8.16_B19361.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8.16 – An example of how to use the :prepend operator
  prefs: []
  type: TYPE_NORMAL
- en: In this example, the final value for `A` is `prependedValueOriginalValue`.
  prefs: []
  type: TYPE_NORMAL
- en: 'You may have noticed that the `:append` and `:prepend` operators resemble the
    string appending (`.=`) and prepending (`=.`) operators. Still, there is a subtle
    difference between how the `:append` and `:prepend` operators and the string appending
    and string prepending operators are parsed, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: "![Figure 8.17 – An example of the difference between \uFEFF:append and the\
    \ .= operator](img/Figure_8.17_B19361.jpg)"
  prefs: []
  type: TYPE_IMG
- en: Figure 8.17 – An example of the difference between :append and the .= operator
  prefs: []
  type: TYPE_NORMAL
- en: Using the `:append` operator queues the operation for execution, which happens
    after the *line 2* assignment, resulting in `A` becoming `valueAppendedValue`.
    The `.=` operator is immediate, so the assignment of *line 4* replaces the value
    set on *line 3*, resulting in `B` becoming `value`.
  prefs: []
  type: TYPE_NORMAL
- en: The list item removal
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `:remove` operator drops a list item from the original content. For example,
    see the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.18 – An example of how to use the :remove operator](img/Figure_8.18_B19361.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8.18 – An example of how to use the :remove operator
  prefs: []
  type: TYPE_NORMAL
- en: In this example, `A` is now `value1 value3`. The `:remove` operator considers
    the variable value as a list of strings separated by spaces so that the operator
    can remove one or more items from the list. Note that every appending and prepending
    operation has already finished when `:remove` is executed.
  prefs: []
  type: TYPE_NORMAL
- en: Conditional metadata sets
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: BitBake provides a very easy-to-use way to write conditional metadata through
    a mechanism called **overrides**.
  prefs: []
  type: TYPE_NORMAL
- en: The `OVERRIDES` variable contains values separated by colons (`:`) and evaluated
    from left to right. Each value is an item that we want to have conditional metadata.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s consider the next example:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.19 – An example of the OVERRIDES variable](img/Figure_8.19_B19361.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8.19 – An example of the OVERRIDES variable
  prefs: []
  type: TYPE_NORMAL
- en: 'The `linux` override is less specific than `arm` and `mymachine`. The following
    example shows how we can use `OVERRIDES` to set the `A` variable conditionally:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.20 – An example of using OVERRIDES conditional setting](img/Figure_8.20_B19361.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8.20 – An example of using OVERRIDES conditional setting
  prefs: []
  type: TYPE_NORMAL
- en: In this example, `A` will be `linuxSpecificValue`, due to the condition of `linux`
    being in `OVERRIDES`.
  prefs: []
  type: TYPE_NORMAL
- en: Conditional appending
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'BitBake also supports appending and prepending variables, based on whether
    something is in `OVERRIDES`, as shown in the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.21 – An example of using OVERRIDES conditional appending](img/Figure_8.21_B19361.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8.21 – An example of using OVERRIDES conditional appending
  prefs: []
  type: TYPE_NORMAL
- en: In the preceding example, `A` is set to `value armValue`.
  prefs: []
  type: TYPE_NORMAL
- en: File inclusion
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: BitBake provides two directives for file inclusion – `include` and `require`.
  prefs: []
  type: TYPE_NORMAL
- en: With the `include` keyword, BitBake attempts to insert the file at the keyword
    location, so it is optional. Let’s suppose the path specified on the `include`
    line is relative; then, BitBake locates the first instance it can find within
    `BBPATH`. By contrast, the `require` keyword raises `ParseError` if the required
    file cannot be found.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs: []
  type: TYPE_NORMAL
- en: The convention generally adopted in the Yocto Project is to use a `.inc` file
    to share the common code between two or more recipe files.
  prefs: []
  type: TYPE_NORMAL
- en: Python variable expansion
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'BitBake makes it easy to use Python code in variable expansion with the following
    syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.22 – An example of Python expansion syntax](img/Figure_8.22_B19361.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8.22 – An example of Python expansion syntax
  prefs: []
  type: TYPE_NORMAL
- en: 'This gives enormous flexibility to a user. We can see a Python function call
    in the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.23 – An example of a Python command to print the current date](img/Figure_8.23_B19361.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8.23 – An example of a Python command to print the current date
  prefs: []
  type: TYPE_NORMAL
- en: This results in the `A` variable containing today’s date.
  prefs: []
  type: TYPE_NORMAL
- en: Defining executable metadata
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Metadata recipes (`.bb`) and class files (`.bbclass`) can use Shell Script
    code, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.24 – An example of a task definition](img/Figure_8.24_B19361.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8.24 – An example of a task definition
  prefs: []
  type: TYPE_NORMAL
- en: The task definition is identical to setting a variable, except that this variable
    happens to be an executable Shell Script code. When writing the task code, we
    should not use Bash or Zsh-specific features, as the tasks can only rely on POSIX-compatible
    features. When in doubt, an excellent way to test whether your code is safe is
    to use the Dash shell to try it out.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another way to inject code is by using Python code, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.25 – An example of a Python task definition](img/Figure_8.25_B19361.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8.25 – An example of a Python task definition
  prefs: []
  type: TYPE_NORMAL
- en: The task definition is similar, but it flags the task as Python so that BitBake
    knows how to run it accordingly.
  prefs: []
  type: TYPE_NORMAL
- en: Defining Python functions in a global namespace
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'When we need to generate a value for a variable or some other use, this can
    be quickly done in recipes (`.bb`) and classes (`.bbclass`) using code similar
    to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.26 – A code example to handle variable values in Python code](img/Figure_8.26_B19361.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8.26 – A code example to handle variable values in Python code
  prefs: []
  type: TYPE_NORMAL
- en: Usually, we need to access the BitBake datastore when writing a Python function.
    Therefore, a convention among all metadata is the use of an argument called `d`
    to point to BitBake’s datastore. It is usually in the last parameter of the function.
  prefs: []
  type: TYPE_NORMAL
- en: In *Figure 8**.26*, we ask the datastore for the value of the `SOMECONDITION`
    variable in line 2 and return a value depending on it.
  prefs: []
  type: TYPE_NORMAL
- en: The example results in the value for the `DEPENDS` variable containing `dependencyWithConditon`.
  prefs: []
  type: TYPE_NORMAL
- en: The inheritance system
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `inherit` directive specifies which classes of functionality our recipe
    (`.bb`) offers a rudimentary inheritance mechanism, such as object-oriented programming
    languages. For example, we can abstract the tasks involved in using the Autoconf
    and Automake building tools and put them into the class for our recipes to reuse.
    A given `.bbclass` is located by searching for `classes/filename.bbclass` in `BBPATH`.
    So, in a recipe that uses Autoconf or Automake, we can use the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.27 – An example of how to inherit a class](img/Figure_8.27_B19361.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8.27 – An example of how to inherit a class
  prefs: []
  type: TYPE_NORMAL
- en: Line 1 from *Figure 8**.27* instructs BitBake to use `inherit autotools.bbclass`,
    providing the default tasks that work fine for most Autoconf- or Automake-based
    projects.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we learned in detail about the BitBake metadata syntax, its
    operators to manipulate variable contents, and variable expansions, including
    some usage examples.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will learn how to use Poky to create external compilation
    tools and produce a `root` filesystem suitable for target development.
  prefs: []
  type: TYPE_NORMAL
