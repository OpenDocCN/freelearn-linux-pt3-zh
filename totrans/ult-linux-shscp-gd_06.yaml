- en: '6'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Text-Stream Filters – Part 1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This is the first of two chapters in which I introduce the concept of text-stream
    filters. We’ll look at what they are and how to use them from the command-line.
    In the following chapters, I’ll present some examples of how these filter utilities
    can be used in shell scripts.
  prefs: []
  type: TYPE_NORMAL
- en: There are two reasons why you should learn about these various utilities. First,
    they’re very helpful if you need to create shell scripts that can automate the
    creation of different types of documents, such as reports. The second reason is
    that they are covered on certain Linux certification exams, such as the CompTIA
    Linux+/Linux Professional Institute exams.
  prefs: []
  type: TYPE_NORMAL
- en: 'Topics in this chapter include:'
  prefs: []
  type: TYPE_NORMAL
- en: Introduction to text-stream filters
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using `cat`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using `tac`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using `cut`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using `paste`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using `join`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using `sort`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Okay, let’s get cracking, shall we?
  prefs: []
  type: TYPE_NORMAL
- en: Technical Requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Use any of your Linux virtual machines for this chapter, because these filter
    utilities work the same on all of them. Or, if you just happen to be running either
    Linux or macOS on your host machine, feel free to use it instead of a virtual
    machine. There’s no hands-on lab, so feel free to try out all the commands on
    your own machine as you go through the chapter.
  prefs: []
  type: TYPE_NORMAL
- en: You’ll be working with a lot of text files in both this chapter and the next
    one. For your convenience, I’ve placed the files in the GitHub repository. If
    you’re using Linux, the best way to retrieve them is to install `git` on your
    system with your distro’s normal package manager.
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, use the following command to download the files:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Then, `cd` into the `The-Ultimate-Linux-Shell-Scripting-Guide` directory that
    the `git` command created, where you’ll find subdirectories for the various chapters.
  prefs: []
  type: TYPE_NORMAL
- en: If you’re on a Mac, you’ll need to open the App Store and install the `Xcode`
    package in order to use `git`. Then, use the command that I’ve just shown you
    to download the files.
  prefs: []
  type: TYPE_NORMAL
- en: I’ve also included a few examples of how some of these utilities work on FreeBSD
    and OpenIndiana. You can create a FreeBSD and an OpenIndiana virtual machine if
    you like, but it’s not strictly necessary just yet.
  prefs: []
  type: TYPE_NORMAL
- en: Introduction to Text-Stream Filters
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As either a Linux systems administrator or an office worker who uses Linux on
    the desktop, you’ll probably have a certain number of text files that you need
    to work with. You may even get tasked with extracting data from these files and
    presenting the data effectively.
  prefs: []
  type: TYPE_NORMAL
- en: Or, you might need to extract data from utilities that show the status of your
    Linux system or from within scripts that automatically scrape the web for some
    specific information. The **text-stream filter utilities** that I present in this
    topic can help make these jobs easier. Once you learn them, you may even find
    that you can extract and display data with them more quickly than you could with
    text editors or word processors.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B21693_06_01.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6.1: The basic concept of text-stream filters'
  prefs: []
  type: TYPE_NORMAL
- en: With only one exception, you won’t use these utilities to modify the original
    text file. You’ll use them either to view the selected data on-screen, pipe the
    selected data to another utility, or use a redirector to create or append the
    selected data to another text file.
  prefs: []
  type: TYPE_NORMAL
- en: Using cat
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `cat` utility has nothing to do with our feline friends. It’s used to either
    view, create, or join multiple text files together. (In fact, the term `cat` is
    short for *catenate*, which is a fancy way of saying “to join two things together,
    end-to-end”.)
  prefs: []
  type: TYPE_NORMAL
- en: I said in the introduction that Mac users can perform the demos in this chapter
    on their Macs. Now though, I have to add a bit of a caveat. That’s because there
    are at least three versions of `cat`, which all have different sets of option
    switches. I’ll point out the differences as we go along.
  prefs: []
  type: TYPE_NORMAL
- en: Sometimes, you’ll need to write scripts that are portable across various different
    operating systems. So, it’s important that you know about these little idiosyncrasies.
  prefs: []
  type: TYPE_NORMAL
- en: 'By default, `stdin` for cat is the keyboard, and `stdout` is the computer screen.
    If you just type `cat` at the command prompt, you’ll be able to type in text and
    make it echo back to you as soon as you hit *Enter*. It will keep doing this until
    you press *Ctrl-d* to end it. Here’s what it looks like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'I haven’t hit *Enter* yet. Watch what happens when I do:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'This is the only line I want to enter, so I’ll exit out of `cat` with *Ctrl-d*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Of course, this by itself isn’t terribly useful. But, you can use `cat` with
    the `stdout` redirector to create simple text files. When you’re through typing
    the message, hit *Enter* once more to get to a blank line, and then press *Ctrl-d*
    to exit. It should look something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Once you’ve created your file you can use `cat` to display it. It’s not like
    the `less` utility though, because `cat` simply dumps everything in the file onto
    the display screen without pagination. You don’t need to use a `stdin` redirector
    with `cat`, because `cat` is designed to use arguments instead of `stdin` redirectors.
    Anyway, here’s what this looks like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, use `cat` to create a second file, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Here’s where the catenate part comes in. Invoke `cat` again, but use the names
    of both of your new files as arguments, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: '![](img/B21693_06_02.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6.2: Directing the contents of two files into a third file.'
  prefs: []
  type: TYPE_NORMAL
- en: This time, you’ll see both of your files displayed as if they were one single
    file.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, add a `stdout` redirector to create a new file by combining the first
    two, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'It’s important to understand that you need to create a third text file when
    you do this. That’s because if you were to redirect the output of the two original
    files into either one of the two original files, you would completely obliterate
    the contents of that destination file. The only thing you’d have left would be
    the contents of the second file. In fact, let me show you:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: As you see, the text that was in the original `newtext.txt` file no longer exists.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are several display options that you can use with `cat`. To see how to
    use them, create another text file. This time, add some tabs and a whole bunch
    of empty lines. It will look something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: At the beginning of the `of the options will work` line I inserted a few blank
    spaces. I began all of the other lines by hitting the *Tab* key once.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s say that we don’t need so many consecutive blank lines. That’s no problem.
    I’ll just use the `-s` option to squeeze them out, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: It looks better, doesn’t it?
  prefs: []
  type: TYPE_NORMAL
- en: 'On Linux, FreeBSD, and macOS, you can see where all of the tabs are by using
    the `-t` option, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: You see that all of the tabs now show up as `^I` characters.
  prefs: []
  type: TYPE_NORMAL
- en: 'On OpenIndiana you’ll need to combine the `-t` and the `-v` options to see
    the tab characters, because using the `-t` option alone won’t show you anything.
    Here’s how it looks on OpenIndiana:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'If you want to see where the end of each line is, use the `-e` option, like
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'On OpenIndiana you’ll need to combine the `-e` and the `-v` options, because
    using the `-e` option alone won’t show you anything. Here’s how it looks on OpenIndiana:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: As you see, the end of each line is marked by a `$`.
  prefs: []
  type: TYPE_NORMAL
- en: 'On Linux only, you can see both where the tabs are and where the end of each
    line is by using the `-A` option, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Note that the `-A` option only works on the Linux version of `cat`. It does
    not work on OpenIndiana, FreeBSD, or macOS.
  prefs: []
  type: TYPE_NORMAL
- en: Also, note that if script portability is a concern, you can use `cat -tv` as
    well as `cat -ev` on Linux machines, even though the `-v` option isn’t necessary
    on Linux.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `-b` option will number all non-blank lines for you, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Or, use the `-n` option to have all lines numbered, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: That’s it for `cat`, so let’s look at `tac`.
  prefs: []
  type: TYPE_NORMAL
- en: Using tac
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`tac`--`cat` spelled backwards--displays one or more files at a time in reverse
    order. To see how it works, we’ll first create two text files that will look like
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Let’s use `cat` to view both of the files at once:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'You can use `tac` to view one file in reverse order:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Or, view two or more files in reverse order:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Note that the contents of the first file is displayed first, followed by the
    contents of the second file.
  prefs: []
  type: TYPE_NORMAL
- en: 'And, of course, you can use the `stdout` redirector to create a new text file,
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: You would think that `tac` would use the same options as `cat`, but it doesn’t.
    None of the options for `cat` can be used for `tac`.
  prefs: []
  type: TYPE_NORMAL
- en: That’s it for `tac`. Next up is `cut`.
  prefs: []
  type: TYPE_NORMAL
- en: Using cut
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As its name implies, this handy utility is used to cut and display selected
    information from a text file. Think of it as something that will take a vertical
    slice of a text file and send it to the output of your choice. There are two ways
    to specify where you want to begin and end the slice. You can specify it either
    by specifying the starting and ending characters, or by specifying the fields.
  prefs: []
  type: TYPE_NORMAL
- en: To specify your slice by fields, you’ll need to use both the `-d` and `-f` switches.
    The `-d` switch will specify the delimiter, the character that separates the fields.
    That’s so that `cut` will know where each field begins and ends. The `-f` switch
    will specify which fields you want to look at. In this diagram, you see that I
    used `cut` to extract the user name and real name--fields `1` and `5`--from the
    `/etc/passwd` file.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B21693_06_03.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6.3: Using cut to view fields 1 and 5 of the passwd file'
  prefs: []
  type: TYPE_NORMAL
- en: Since the fields in this file are separated by colons, I used `-d:` for the
    delimiter switch.
  prefs: []
  type: TYPE_NORMAL
- en: The other method for specifying the slice is the character method. With this
    method, you select the beginning and the ending characters of the lines of text
    that you want to display. In the next diagram, you see that I’ve saved a listing
    of files in my current directory to `filelist.txt`.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B21693_06_04.png)Figure 6.4: Using cut to view the first 20 characters'
  prefs: []
  type: TYPE_NORMAL
- en: 'I’ve decided that I only want to look at the first 20 characters of the lines
    of text in this file, so I used the `-c` switch appended with the appropriate
    character numbers. (Note that you can type the command as either `cut -c1-20 filelist.txt`
    or as `cut -c 1-20 filelist.txt`. The blank space between the `-c` and the first
    number is optional.) To further illustrate how this works, let me show you what
    the output of cutting an actual multi-line file looks like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: You see that `cut` operates on every line in the file. Also, you see that the
    entire first line prints out because it consists of fewer than 20 characters.
    (The same thing happens when you use the field method.)
  prefs: []
  type: TYPE_NORMAL
- en: 'Of course, with both of the above examples, you have the option of using a
    `stdout` redirector to save the extracted information to a text file. For example,
    you could do something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'As with most of the text-stream filter utilities, you can either pipe the output
    from `cut` into another utility, or pipe another utility’s output into `cut`.
    In the previous example, I really didn’t need to save the `ls -l` output to a
    text file. I could have just piped the `ls -l` output into `cut`, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Add on a `stdout` redirector, and you can also save this to a text file, like
    so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: That’s it for `cut`. Now, let’s do some pasting.
  prefs: []
  type: TYPE_NORMAL
- en: Using paste
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Instead of joining two or more files together end-to-end as `cat` does, `paste`
    joins them together side-by-side. This is handy when you have two or more files
    of columnar data, and you want to look at all of the data in one display. Go ahead
    and create the two text files that you see in the following diagram Then try out
    the `paste` command that you see in the diagram.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B21693_06_05.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6.5: Pasting two files together with paste'
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two options that you can use with `paste`. The serial option, set
    with the `-s` switch, allows you to view the columns of data horizontally. Pasting
    the `myfile_1.txt` and `myfile_2.txt` with the `-s` option looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'The delimiter option, set by the `-d` switch, allows you to change how the
    columns are separated. If you leave out the `-d` switch, the columns of the pasted
    display will be separated by tabs, as you see in the preceding examples. To replace
    the tabs with something else, just place the desired replacement after the `-d`
    switch. Here, I’m using a set of double-quotes with a space in between to replace
    each tab with a normal space:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, here’s a really cool trick that you can use to impress your friends. First,
    create four new text files as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, put them all together with paste. This time, place the `+`, `-`, and `=`
    signs between the quotes after the `-d`, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: As you see, the three arithmetic operators got placed in the appropriate places.
    (Oh, and in case you’re wondering, uno, dos, tres, and cuatro are Spanish for
    1, 2, 3, and 4.)
  prefs: []
  type: TYPE_NORMAL
- en: This really is more than just a crazy party trick. I’ll show you a practical
    use for this in *Chapter 11, Performing Mathematical Operations*.
  prefs: []
  type: TYPE_NORMAL
- en: Okay, now that we’ve pasted some files together, let’s join some together.
  prefs: []
  type: TYPE_NORMAL
- en: Using join
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Here’s another handy utility you can use to combine two text files. (Unlike
    the other utilities we’ve looked at, you can use `join` for two text files, but
    no more than two.) To see how it works, take a look at the following diagram with
    its text files about famous Hollywood actors from a by-gone era. Then, go ahead
    and create the files, with tabs between the two columns of each file. Then, run
    the command that’s shown in the diagram.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B21693_06_06.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6.6: Joining two files together with join'
  prefs: []
  type: TYPE_NORMAL
- en: As you see, the `join` utility replaces the tabs that were between the columns
    with blank spaces.
  prefs: []
  type: TYPE_NORMAL
- en: Note that in each of the two input files, the first field is the same. (In this
    case, it’s the last name of each actor.) In the output, the first field--which
    we’ll call the **key field**--is only listed once. The information for each actor’s
    last name--the key field--is obtained from both of the two input files.
  prefs: []
  type: TYPE_NORMAL
- en: The thing to remember here is that you have to have one field that is identical
    in both input files. It doesn’t have to be the first field, as we’ll illustrate
    in the next example.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can use the `-j` switch to use another field, if you so desire. You can
    see this with the following two lists of numbers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let’s join them:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: Here, the second field is identical in each input file, so I used the `-j 2`
    option to designate that field as the key field.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can pipe the output of `join` into other utilities for customized output.
    If you want to number the lines of the output, pipe it into `cat` with the `-n`
    option, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'It’s rather common these days for people to create spreadsheet files in **Comma
    Separated Values** (**csv**) format, rather than in a spreadsheet program’s native
    format. The advantages of this are that the files can be created in any plain-text
    editor, and that the files can be read by any spreadsheet program. You can make
    `join` work with these files by using the `-t` switch to specify that the fields
    are separated by commas instead of by tabs. To see how that works, copy the `actorfile_1.txt`
    and `actorfile_2.txt` files to corresponding `.csv` files, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, edit the two `.csv` files to replace the tabs with commas. The first
    file will look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'The second file will look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, watch what happens when I try to use `join` in the normal way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'It doesn’t work, because `join` thinks that there’s only one field in each
    file. To make it work, I’ll need to use the `-t` switch to specify the comma as
    my field separator, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: Cool, that looks much better. And of course, you can always redirect the output
    into a third `.csv` file that you can import into any spreadsheet program.
  prefs: []
  type: TYPE_NORMAL
- en: There are still more possibilities for how you can use `join`, which you can
    see in the `join` man page. Combine the power of `join` with the power of the
    next utility that we’re about to cover, and you’ll have the makings of an easy-to-use
    utility for creating simple databases.
  prefs: []
  type: TYPE_NORMAL
- en: Using sort
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This is a versatile utility that you can use by itself, or in conjunction with
    other utilities. You can use it to sort either one file, or multiple files together.
  prefs: []
  type: TYPE_NORMAL
- en: There are lots of options for different purposes. You can choose how to format
    your output, how you want the data sorted, and what fields you want to use for
    the sort. You can even perform sorts on two or more fields at once, with the primary
    sort on one field and secondary sorts on others.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are a lot of ways that you can use `sort`. As I’ve said before, the only
    limitation is your own imagination. To start, look at the following diagram. Create
    the text file on your own machine and then run the commands that you see:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B21693_06_07.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6.7: Sorting the actorfile_1.txt file'
  prefs: []
  type: TYPE_NORMAL
- en: What you see in the above diagram is the simplest of sorts. By default, sorts
    are case-sensitive and are performed on each entire line of the input file.
  prefs: []
  type: TYPE_NORMAL
- en: In the next example, I’ll show you two options at once. The first is the `-k`
    option, which allows you to sort the input file on a particular field. The second
    is the `-o` option, which allows you to save the output to a text file. Of course,
    you can still do that with a redirector. But, unlike the redirector, the `-o`
    option allows you to save the sorted output back to the original input file without
    wiping out its contents.
  prefs: []
  type: TYPE_NORMAL
- en: 'Before I show you that, I’m going to copy the `actorfile_1.txt` file over to
    the `actorfile_5.txt` file, so that I can use the `actorfile_1.txt` file again
    later:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let’s see how this works:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: As you see, the original input file is now sorted according to the actors’ first
    names.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s say that you need a list of actresses to go along with your list of actors,
    and that the list looks something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'Sort the `actorfile_1.txt` file and the `actorfile_6.txt` file together, like
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'After you view the results on screen, save the results to a new file, like
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: You can also pipe this through the `tee` utility, so that you can see the output
    on screen and save it to a file at the same time.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'There are a few other options that could help you out in special situations.
    To demonstrate, create the file `fruit.txt`, which will look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'You see that there are some duplicate entries. Let’s see what a normal sort
    would look like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'Since you only need one entry for each fruit, use the `-u` option to get rid
    of duplicate entries, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'That looks somewhat better. But, do you really need to have the fruit names
    repeated in both upper-case and lower-case? If not, then add the `-f` switch to
    make `sort` look at all letters as if they were uppercase, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: Some older Linux books may tell you that text files with a mixture of upper-case
    and lower-case letters in the sorted fields won’t sort properly unless you use
    the `-f` switch.
  prefs: []
  type: TYPE_NORMAL
- en: For example, the name “MacLeod” would have come before the name “Mack” because
    the upper-case L would have been placed before the lower-case k. The `-f` switch
    would have forced `sort` to place the list items in proper alphabetical order,
    regardless of case. However, with the newer Linux distros, this is no longer a
    problem. The `-f` switch still has its uses, as you see in the above example.
    But, this problem that those other Linux books tell you about no longer exists.
  prefs: []
  type: TYPE_NORMAL
- en: For our next demonstration, create a file with a list of numbers.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'Here’s what you’ll get when you try to sort the list:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'That’s probably not what you want. To make it sort in proper numerical order,
    use the `-n` switch, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'Add the `-r` switch to sort the file in reverse order:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'This time, just for fun, create a text file with some decimals and negative
    numbers, as well as some positive numbers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let’s see how this sorts out without any option switches:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'As before, add the `-n` switch to sort the list in proper numerical order:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'For our next example, let’s create a file list of used automobiles. We’ll list
    the make, model, year, mileage (in thousands), and the selling price. (If you’re
    not here with me in the United States, just pretend that the miles are really
    kilometers.) Here’s what the list looks like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'We’ll first do a normal sort, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: By default, a sort operation will start with the first column of a file, and
    go through each entire row until it runs out of non-unique entries. Here, we see
    that everything sorts properly until it gets to the year column. (We’ll fix that
    in a moment.)
  prefs: []
  type: TYPE_NORMAL
- en: Whenever there is more than one car of a certain make, the sort will continue
    to the model column. When there is more than one of a given model, the sort will
    continue on to the year column. The mileage column is considered in the sort as
    well, even though it may not look like it in this example. That’s because of the
    problem with numerical sorting that I showed you a couple of pages ago.
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to sort numbers in numerical order instead of machine-sort order,
    you have to use the `-n` switch. We can do that by using the `-k` switch to specify
    the individual columns that we want to sort, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: The `-k1,3` option means to sort on fields one through three. (In other words,
    sort on the make, model, and year fields.) The `-k4n` option means to also sort
    on the fourth (the mileage) field in numerical order.
  prefs: []
  type: TYPE_NORMAL
- en: Note that you can specify sort options for individual fields. Also note that
    the price column will never be considered in this sort, since no line entries
    are completely identical up through the mileage column.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, let’s sort our autos list first by both manufacturer and then by price.
    For this, you would have to sort on fields one and five. Since we already know
    that we need the `-n` switch for column five to sort properly, we’ll go ahead
    and add it in, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: Whenever you specify two or more `-k` switches, `sort` will perform its operation
    in more than one pass. For the first pass, it will sort on the field specified
    with the first `-k` switch. Sorts on the remaining specified fields will be performed
    in subsequent passes.
  prefs: []
  type: TYPE_NORMAL
- en: Here, we see that `sort` ignored the second `-k` switch. That’s because the
    first `-k` switch didn’t specify an end point for its sort. So, `sort` evaluated
    each entire line on the first pass, and decided that a second pass wasn’t needed.
  prefs: []
  type: TYPE_NORMAL
- en: Now, let’s specify an endpoint for the first `-k` switch to see if that makes
    a difference.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: The `-k1,1` option means that we want the first pass to sort on the first—and
    only the first—field of our file. By adding that end point, our sort works as
    we want it to.
  prefs: []
  type: TYPE_NORMAL
- en: You don’t have to start with the first field for your sorts. For this next example,
    we’ll sort first by field three (year), and then by field one (make).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: Again, you can see what happens when you don’t specify an end point for your
    first sort field. So, let’s try this again.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: Okay, so it still didn’t work. Everything is still sorted correctly by year,
    but not by make. We’re not the ones to give up here, so let’s try it one more
    time.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: Note how in four out of the five fields, the text strings are of different lengths.
    Theoretically, the extra blank spaces in the lines with shorter text strings should
    have adversely affected all of the sort operations that we’ve performed. For some
    reason, however, only this last sort operation was affected. By adding the `-b`
    switch, we’re telling `sort` to ignore the extra blank spaces.
  prefs: []
  type: TYPE_NORMAL
- en: Okay, maybe you don’t have a collection of antique automobiles. But, you might
    have lists of other items that you’ll need to sort in various ways. Keep in mind
    that you can use the techniques that I’ve presented here for any type of list
    that you might have.
  prefs: []
  type: TYPE_NORMAL
- en: 'All right, that’s enough for the vintage automobiles. Let’s now look at sorting
    lists of months. First, let’s create the list, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, use the `-M` switch to sort the list by month:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: As you see, the `-M` switch isn’t case-sensitive.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, use the techniques you’ve learned in the previous examples to sort first
    by year, and then by month, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: 'And finally, as promised, I’ll now show you how to use `join` and `sort` together
    to somewhat emulate a simple relational database program. Let’s first take a peek
    at the input files, which are the same ones that we used before. First, we have
    `actorfile_1.txt`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: 'The second input file is `actorfile_2.txt`, which looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: Now, we’ll join them together and feed the results through `sort`. (Again, note
    how `join` turns the tabs in the input into normal spaces.)
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: 'Okay, this doesn’t look so great, because `join` doesn’t maintain proper column
    alignment. Let’s fix that by piping the output into the `column -t` command, like
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: We can use the techniques we’ve already learned to sort by category, and then
    by last name.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: As you see, there’s a lot to this topic, but don’t let that discourage you.
    With a little practice, you’ll be sorting with the pros.
  prefs: []
  type: TYPE_NORMAL
- en: Okay, that just about wraps things up for this chapter. Let’s summarize and
    move on.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As a Linux systems administrator, a developer, or even an office clerk who uses
    Linux, you might need to extract and format data from either text files or the
    output of system commands. In this chapter you learned about various text-stream
    filters and how they can be useful for helping you do this. There are plenty more
    filters left to cover, which we’ll do in the next chapter. I’ll see you there.
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Which of the following utilities would you use to join two or more files together
    side-by-side?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`join`'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '`cat`'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '`tac`'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '`paste`'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Which two of the following utilities can you use together to create simple databases?
    (Choose two.)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`paste`'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '`sort`'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '`join`'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '`cat`'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Which of the following commands would properly save the output of the cat operation?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`cat file1.txt file2.txt > file1.txt`'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '`cat file1.txt file2.txt > file2.txt`'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '`cat file1.txt file2.txt > file3.txt`'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: You want `sort` to sort on Field 1, and only Field 1, of your file. What would
    your command look like?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`sort -F1 myfile.txt`'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '`sort -F1,1 myfile.txt`'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '`sort -k1 myfile.txt`'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '`sort -k1,1 myfile.txt`'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Which of the following option switches would you use with cat to eliminate duplicate
    blank lines?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`-d`'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '`-s`'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '`-o`'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '`-u`'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Further Reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Linux Professional Institute Exam 101 Objectives: [https://www.lpi.org/our-certifications/exam-101-objectives](https://www.lpi.org/our-certifications/exam-101-objectives)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'How to Use the join Command on Linux: [https://www.howtogeek.com/542677/how-to-use-the-join-command-on-linux/](https://www.howtogeek.com/542677/how-to-use-the-join-command-on-linux/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'sort Command Examples: [https://linuxhandbook.com/sort-command/](https://linuxhandbook.com/sort-command/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Answers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: d
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: b and c
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: c
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: d
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: b
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Join our community on Discord!
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Read this book alongside other users, Linux experts, and the author himself.
  prefs: []
  type: TYPE_NORMAL
- en: Ask questions, provide solutions to other readers, chat with the author via
    Ask Me Anything sessions, and much more. Scan the QR code or visit the link to
    join the community.
  prefs: []
  type: TYPE_NORMAL
- en: '[https://packt.link/SecNet](https://packt.link/SecNet)'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/QR_Code10596186092701843.png)'
  prefs: []
  type: TYPE_IMG
