<html><head></head><body>
		<div id="_idContainer253">
			<h1 id="_idParaDest-262" class="chapter-number"><a id="_idTextAnchor267"/>13</h1>
			<h1 id="_idParaDest-263"><a id="_idTextAnchor268"/>Working with PowerShell 7 and Windows</h1>
			<p>Welcome to the final section of the book, where over the next four chapters we’ll look at using PowerShell 7 in different environments. In this chapter, we’ll be looking at the peculiarities of Windows-based systems, and the various workarounds that exist to allow us to use PowerShell 7 effectively. We’ll also look at when we absolutely need to use native Windows PowerShell instead. It’s important to remember that PowerShell 7 is an open source product and is subject to fast-paced change. The examples in this and subsequent chapters are true at the time of writing, but may not be true at the time of reading. Also; there are bugs. The PowerShell GitHub pages are a powerful source of information regarding recent changes, and also things that don’t work the way they <span class="No-Break">should: </span><a href="https://github.com/PowerShell/PowerShell"><span class="No-Break">https://github.com/PowerShell/PowerShell</span></a><span class="No-Break">.</span></p>
			<p>As we covered in <a href="B17600_01.xhtml#_idTextAnchor013"><span class="No-Break"><em class="italic">Chapter 1</em></span></a>, <em class="italic">Introduction to PowerShell 7 – What It Is and How to Get It</em>, PowerShell 7.2 and later are built on the .NET 6 platform, the latest version of .NET Core. However, Windows PowerShell and many Windows applications are built using the .NET 4.5 framework, which is not open source, and contains much proprietary code. This has led to some incompatibilities, where things that work in Windows PowerShell won’t work in PowerShell 7. We’ll be covering them in this chapter, and then look at how we can use the <strong class="bold">Common Information Model</strong> (<strong class="bold">CIM</strong>) and <strong class="bold">Windows Management Instrumentation (WMI) </strong>to work with our <span class="No-Break">Windows machines.</span></p>
			<p>The main topics we will cover in this chapter are <span class="No-Break">the following:</span></p>
			<ul>
				<li>Understanding PowerShell 7 and <span class="No-Break">Windows PowerShell</span></li>
				<li><span class="No-Break">Exploring compatibility</span></li>
				<li>What doesn’t work with <span class="No-Break">PowerShell 7</span></li>
				<li>Managing machines with CIM <span class="No-Break">and WMI</span></li>
			</ul>
			<h1 id="_idParaDest-264"><a id="_idTextAnchor269"/>Understanding PowerShell 7 and Windows PowerShell</h1>
			<p>The key to understanding<a id="_idIndexMarker910"/> how we can use PowerShell 7 on Windows is to understand<a id="_idIndexMarker911"/> that PowerShell 7 is built on a fundamentally different platform; PowerShell 7 is built on an open source, stripped-down version of .NET, whereas Windows PowerShell is built on the full proprietary .NET Framework. This means that Windows PowerShell has a greater degree of native compatibility with the Windows operating system and many of the applications that run on it and can make use of elements of .NET Framework<a id="_idIndexMarker912"/> that are not accessible to PowerShell 7. Microsoft uses the terminology <strong class="bold">Desktop edition</strong> for PowerShell running on .NET Framework, and <strong class="bold">Core edition</strong> for PowerShell running on open<a id="_idIndexMarker913"/> <span class="No-Break">source .NET.</span></p>
			<p>In <a href="B17600_11.xhtml#_idTextAnchor218"><span class="No-Break"><em class="italic">Chapter 11</em></span></a>, <em class="italic">Creating Our First Module</em>, we learned that most PowerShell functionality comes<a id="_idIndexMarker914"/> from using extensible libraries called modules, and looked at how modules are put together. To run a command in a module, PowerShell must first load that module. Microsoft has done a pretty good job of rewriting the core PowerShell modules and the more heavily used ones, such as the Active Directory module, but not all modules are compatible with PowerShell 7; sometimes the authors haven’t got around to it yet, but sometimes the incompatibility is because key functionality in the module relies on features of .NET Framework that just aren’t in the open source .NET Core. If we attempt to load these incompatible modules, they will generally either cause an error or just not work. In the next section, we’ll see how we can get around this. Sometimes, however, we will find that things just don’t work, and we need to use Windows PowerShell. We’ll examine some of those cases in the third section of <span class="No-Break">this chapter.</span></p>
			<h1 id="_idParaDest-265"><a id="_idTextAnchor270"/>Exploring compatibility</h1>
			<p>It’s all very well saying that some modules<a id="_idIndexMarker915"/> aren’t compatible with PowerShell 7, but how do we know which ones are OK to use, and what happens when they aren’t? The good news is that most of this process is automated and transparent to the casual user; we need to know about it however so we can understand why bad things happen sometimes. To understand compatibility, we’ll need to remember what we learned about modules and module manifests from <a href="B17600_11.xhtml#_idTextAnchor218"><span class="No-Break"><em class="italic">Chapter 11</em></span></a>, <em class="italic">Creating Our First Module</em>, and the section on PowerShell remoting that we did in the last chapter, <a href="B17600_12.xhtml#_idTextAnchor236"><span class="No-Break"><em class="italic">Chapter 12</em></span></a>, <span class="No-Break"><em class="italic">Securing PowerShell</em></span><span class="No-Break">.</span></p>
			<h2 id="_idParaDest-266"><a id="_idTextAnchor271"/>Which modules are compatible with PowerShell 7?</h2>
			<p>Let’s have a look at some modules<a id="_idIndexMarker916"/> to see how we can tell whether they are compatible with PowerShell 7. Run this cmdlet in <span class="No-Break">Windows PowerShell:</span></p>
			<pre class="console">
Get-Module | Format-Table -Auto -Wrap Name, CompatiblePSEditions, Version</pre>			<p>We should see something like the <span class="No-Break">following output:</span></p>
			<div>
				<div id="_idContainer237" class="IMG---Figure">
					<img src="image/B17600_13_001.jpg" alt="Figure 13.1 – Uncovering compatible editions"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 13.1 – Uncovering compatible editions</p>
			<p>We can see that we have seven modules loaded. Four of them have compatibility information; <strong class="source-inline">Microsoft.PowerShell.Management</strong> says it is compatible with Desktop and Core editions. <strong class="source-inline">Microsoft.Powershell.Utility</strong>, <strong class="source-inline">Microsoft.PowerShell.Security</strong>, and <strong class="source-inline">Microsoft.WSMan.Management</strong> are only compatible with the Desktop edition. We could have run the command in PowerShell 7, but of course then it would generally only show modules that were compatible with the <span class="No-Break">Core edition.</span></p>
			<p>Three of the modules have no compatibility information available; this may mean that they were written before PowerShell Core was released, and are therefore only compatible with the Desktop edition, or it may be that they are the wrong type of module to have compatibility information. Recall that there are four types of modules; script modules, manifest modules, binary modules, and dynamic modules. Manifest modules contain a manifest file with a <strong class="source-inline">.Psd1</strong> extension. We can check what the type of the module is by running <strong class="source-inline">Get-Module &lt;modulename&gt;</strong>, <span class="No-Break">like so:</span></p>
			<div>
				<div id="_idContainer238" class="IMG---Figure">
					<img src="image/B17600_13_002.jpg" alt="Figure 13.2 – Checking the module type"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 13.2 – Checking the module type</p>
			<p>In this case, we can see that <strong class="source-inline">PSReadline</strong> is a script<a id="_idIndexMarker917"/> module, and so doesn’t have an associated manifest file that could contain <span class="No-Break">compatibility information.</span></p>
			<p>So, what can we do when we need some functionality, but the module isn’t listed as compatible with PowerShell 7? We have <span class="No-Break">three</span><span class="No-Break"><a id="_idIndexMarker918"/></span><span class="No-Break"> choices:</span></p>
			<ul>
				<li>Find a <span class="No-Break">compatible version</span></li>
				<li>Load <span class="No-Break">it anyway</span></li>
				<li>Use <span class="No-Break">Compatibility mode</span></li>
			</ul>
			<p>Let’s take a look at <span class="No-Break">these methods.</span></p>
			<h3>Finding a compatible version</h3>
			<p>The <strong class="source-inline">Microsoft.PowerShell.Utility</strong> module shown<a id="_idIndexMarker919"/> previously in <span class="No-Break"><em class="italic">Figure 13</em></span><em class="italic">.1</em> is really useful; for a start, it provides<a id="_idIndexMarker920"/> the <strong class="source-inline">ConvertTo-*</strong> cmdlets. We know that these work in PowerShell 7, because we’ve been using them throughout the book. Look at the <span class="No-Break">following figure:</span></p>
			<div>
				<div id="_idContainer239" class="IMG---Figure">
					<img src="image/B17600_13_003.jpg" alt="Figure 13.3 – Microsoft.PowerShell.Utility in PowerShell 7"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 13.3 – Microsoft.PowerShell.Utility in PowerShell 7</p>
			<p>As we can see, the <strong class="source-inline">Microsoft.PowerShell.Utility</strong> module is loaded in our PowerShell 7 session. How is that? Check the version numbers shown in the different screenshots. PowerShell 7 loads <strong class="source-inline">Microsoft.PowerShell.Utility 7.0.0.0</strong>, whereas Windows PowerShell loads <strong class="source-inline">Microsoft.PowerShell.Utility 3.1.0.0</strong>. Different versions of core PowerShell modules have been supplied with PowerShell 7, and are installed in <strong class="source-inline">C:\program files\powershell\7\Modules</strong>. Some third-party modules will have specific versions that are compatible with PowerShell 7, even if the one we currently have is not, and it’s worth checking on the repository if this is the case. For instance, in the PowerShell gallery, we can include the search term <strong class="source-inline">Tags:"core"</strong> to find modules that are compatible with PowerShell 7, <span class="No-Break">like this:</span></p>
			<div>
				<div id="_idContainer240" class="IMG---Figure">
					<img src="image/B17600_13_004.jpg" alt="Figure 13.4 – Searching the PowerShell gallery for a module that is compatible"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 13.4 – Searching the PowerShell gallery for a module that is compatible</p>
			<p>As you can see, I’ve included two search<a id="_idIndexMarker921"/> terms; the first is the string <strong class="source-inline">databases</strong> and the second is <strong class="source-inline">Tags:"core"</strong>. This has found me a module for manipulating databases<a id="_idIndexMarker922"/> that will run on PowerShell 7. Let’s see what we can do if there is no <span class="No-Break">compatible version.</span></p>
			<h3>Loading it anyway</h3>
			<p>If we don’t find a version of the module<a id="_idIndexMarker923"/> compatible with PowerShell 7, we can attempt to load it anyway. This might work, although quite often the module will load but then not work as expected when we come to use it. I include this method as a last resort and a sort of warning; there are articles on the internet that recommend doing this. Personally, <span class="No-Break">I wouldn’t.</span></p>
			<p>That said, how do you load a module that doesn’t have a compatible version? We can use the <strong class="source-inline">-SkipEditionCheck</strong> parameter of <strong class="source-inline">Import-Module</strong> <span class="No-Break">like this:</span></p>
			<div>
				<div id="_idContainer241" class="IMG---Figure">
					<img src="image/B17600_13_005.jpg" alt="Figure 13.5 – Forcing a module to load"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 13.5 – Forcing a module to load</p>
			<p>In this example, I’ve used the <strong class="source-inline">-SkipEditionCheck</strong> parameter to try to force PowerShell 7 to load the <strong class="source-inline">RemoteDesktop</strong> module in a PowerShell 7 session with admin privileges. As we can see, this hasn’t worked very well. The problem is that with some modules<a id="_idIndexMarker924"/> it does work, while with others it doesn’t, but it doesn’t produce an error like <strong class="source-inline">RemoteDesktop</strong> does. So, what is the right way to do this? We use <span class="No-Break">Compatibility mode.</span></p>
			<h3>Using Compatibility mode</h3>
			<p>Using Compatibility mode<a id="_idIndexMarker925"/> in recent versions<a id="_idIndexMarker926"/> of PowerShell 7 is easy. Just import the module you want to load, <span class="No-Break">like this:</span></p>
			<pre class="console">
Import-Module RemoteDesktop</pre>			<p>As we can see in the following figure, something <span class="No-Break">magical happens:</span></p>
			<div>
				<div id="_idContainer242" class="IMG---Figure">
					<img src="image/B17600_13_006.jpg" alt="Figure 13.6 – Using Compatibility mode"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 13.6 – Using Compatibility mode</p>
			<p>In the first command, all I’ve done is use <strong class="source-inline">Import-Module</strong> with no parameters. PowerShell checks for a compatible module, and when it doesn’t find one it creates a remote session to run Windows PowerShell in the background. The module is loaded into this remote session, which is running on the local machine. It warns us that this is what it has done. In the second command, I check what remote sessions are running, and we can see that there is a session called <strong class="source-inline">WinPSCompatSession</strong> created. We saw remote sessions in <a href="B17600_12.xhtml#_idTextAnchor236"><span class="No-Break"><em class="italic">Chapter 12</em></span></a>, <em class="italic">Securing PowerShell</em>. In that chapter, though, we explicitly created the sessions. The <strong class="source-inline">WinPSCompatSession</strong> is an example of <span class="No-Break">implicit remoting.</span></p>
			<p>There are two important<a id="_idIndexMarker927"/> things to remember about Compatibility<a id="_idIndexMarker928"/> mode. The first important thing is that <strong class="source-inline">WinPSCompatSession</strong> is running Windows PowerShell, not PowerShell 7. Look <span class="No-Break">at this:</span></p>
			<div>
				<div id="_idContainer243" class="IMG---Figure">
					<img src="image/B17600_13_007.jpg" alt="Figure 13.7 – Demonstrating the PowerShell version running in WinPSCompatSession"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 13.7 – Demonstrating the PowerShell version running in WinPSCompatSession</p>
			<p>In the first command, I’m putting <strong class="source-inline">WinPSCompatSession</strong> into a variable called <strong class="source-inline">$session</strong> so I can easily use it. On the second line, I pass the <strong class="source-inline">$session</strong> variable to <strong class="source-inline">Invoke-Command</strong> and call the <strong class="source-inline">PSVersion</strong> property of the <strong class="source-inline">$PSVersionTable</strong> automatic variable from within that session. We can see from the result that the session is running PowerShell version 5.1 – Windows PowerShell. In the third command, I get the same information for the local terminal session, where I’m running <span class="No-Break">PowerShell 7.3.8.</span></p>
			<p>The second important thing<a id="_idIndexMarker929"/> is that this is a remote<a id="_idIndexMarker930"/> session, and therefore behaves differently to directly running commands. The most important difference is that the output has been deserialized, which we can see in the warning in <span class="No-Break"><em class="italic">Figure 13</em></span><em class="italic">.6</em>. Recall that the output of a command is a PowerShell object. To pass a PowerShell object from a remote computer to the local computer, the object is converted to CliXML (the specialized form of XML that PowerShell uses to serialize objects) on the remote end of the session, and then converted back to a PowerShell object at the local end. This has implications for what we can do with the object, as it now has different methods and properties. Let’s see what this <span class="No-Break">looks like:</span></p>
			<div>
				<div id="_idContainer244" class="IMG---Figure">
					<img src="image/B17600_13_008.jpg" alt="Figure 13.8 – Deserialized objects"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 13.8 – Deserialized objects</p>
			<p>In the top pane I am using Windows PowerShell to run the <strong class="source-inline">Get-WmiObject win32_bios | gm</strong> command to get the <strong class="source-inline">TypeName</strong> and members of the object that the <strong class="source-inline">Get-WmiObject</strong> command generates: <strong class="source-inline">System.Management.ManagementObject</strong>. Note it has no methods, and <strong class="source-inline">PSComputerName</strong> is an <strong class="source-inline">AliasProperty</strong>, so if we call <strong class="source-inline">PSComputerName</strong>, we actually get the value of the <span class="No-Break"><strong class="source-inline">__SERVER</strong></span><span class="No-Break"> property.</span></p>
			<p>In the lower pane, I am using PowerShell 7 to run <strong class="source-inline">Get-WmiObject</strong> inside the <strong class="source-inline">WinPSCompatSession</strong> session using <strong class="source-inline">Invoke-Command</strong>, and then getting the members of the returned object. As we can see, this is now a <strong class="source-inline">Deserialized.System.Management.ManagementObject</strong>, and the methods and properties are subtly changed. For example, <strong class="source-inline">PSComputerName</strong> is now a <strong class="source-inline">NoteProperty</strong> that contains a <span class="No-Break">string: </span><span class="No-Break"><strong class="source-inline">PSComputerName=localhost</strong></span><span class="No-Break">.</span></p>
			<p>Now, this is fairly easy to remember when we are explicitly using <strong class="source-inline">Invoke-Command</strong>. We know that what we get back is running in a remote session and will be a deserialized object. However, because this can happen transparently in the background, it is easy to accidentally load a module in Compatibility mode, and then be surprised that the objects we are working with aren’t behaving quite the way we expect them to. Some administrators like to prevent implicit imports in PowerShell compatibility by editing the <strong class="source-inline">powershell.config.json</strong> file to include the <span class="No-Break">JSON line:</span></p>
			<pre class="source-code">
"DisableImplicitWinCompat" : "true"</pre>			<p>This doesn’t disable Compatibility mode<a id="_idIndexMarker931"/> altogether, however, it just makes<a id="_idIndexMarker932"/> us more mindful of when we are using it. We can still explicitly use Compatibility mode by adding the <strong class="source-inline">-UseWindowsPowerShell</strong> parameter of the <strong class="source-inline">Import-Module</strong> cmdlet, <span class="No-Break">like this:</span></p>
			<div>
				<div id="_idContainer245" class="IMG---Figure">
					<img src="image/B17600_13_009.jpg" alt="Figure 13.9 – Explicitly using PowerShell Compatibility"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 13.9 – Explicitly using PowerShell Compatibility</p>
			<p>In the command on the first line, I import the <strong class="source-inline">ScheduledTasks</strong> module as normal, with no parameters. In the second line, I test for the presence of the compatibility session – as we can see, no remote session has been opened. In the third line, I remove the module, and in the fourth line I reload it, this time adding the <strong class="source-inline">-UseWindowsPowershell</strong> parameter. In the fifth line, I again test for the compatibility session, and there <span class="No-Break">it is.</span></p>
			<p>We can also prevent specific modules from loading in Compatibility mode altogether by editing the deny list in the <span class="No-Break"><strong class="source-inline">powershell.config.json</strong></span><span class="No-Break"> file:</span></p>
			<pre class="source-code">
"WindowsPowerShellCompatibilityModuleDenyList":  [
   "PSScheduledJob","BestPractices","UpdateServices"
]</pre>			<p>If we try and load a module on that list, then we will see an error similar to <span class="No-Break">the following:</span></p>
			<div>
				<div id="_idContainer246" class="IMG---Figure">
					<img src="image/B17600_13_010.jpg" alt="Figure 13.10 – No, you can’t load the PSScheduledJob module"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 13.10 – No, you can’t load the PSScheduledJob module</p>
			<p>It’s important to understand the limitations<a id="_idIndexMarker933"/> of Compatibility mode. There are four <span class="No-Break">main ones:</span></p>
			<ul>
				<li>It only works on local computers – you can’t call Compatibility mode while already in a remote session on <span class="No-Break">another machine</span></li>
				<li>It requires Windows PowerShell 5.1 to be installed on the local machine – older machines might still have only Windows PowerShell 3.0 or <span class="No-Break">4.0 installed</span></li>
				<li>It returns deserialized objects based on values – not live objects that can <span class="No-Break">be manipulated</span></li>
				<li>There can be only one compatibility session running on a machine at any one time, so all modules that use Compatibility will share <span class="No-Break">a runspace</span></li>
			</ul>
			<p>It’s also important to remember<a id="_idIndexMarker934"/> that this area of PowerShell 7 is one that lots of people are actively working on, and each new version of PowerShell is better than the last, and each new version of Windows is more compatible with PowerShell 7. Lots of the instructions and tutorials on the internet date very quickly, and so will <span class="No-Break">this chapter.</span></p>
			<h1 id="_idParaDest-267"><a id="_idTextAnchor272"/>What doesn’t work with PowerShell 7</h1>
			<p>However, there are some things<a id="_idIndexMarker935"/> on Windows that just don’t work with PowerShell 7 and aren’t likely to either. In this section we’ll cover a few of them, which will set us up nicely for the final section of the chapter, <em class="italic">Managing machines with CIM </em><span class="No-Break"><em class="italic">and WMI</em></span><span class="No-Break">.</span></p>
			<p>The <strong class="source-inline">-ComputerName</strong> parameter had been ported from Windows PowerShell to PowerShell 7; unfortunately, some of the protocols and models that this parameter uses in Windows are not compatible with PowerShell 7, and so the parameter didn’t work. In the most recent releases of PowerShell 7, such as 7.3, the parameter has finally been removed from the non-working cmdlets. For people moving from Windows PowerShell to PowerShell 7, however, it can still cause confusion. The workaround is to use <span class="No-Break"><strong class="source-inline">Invoke-Command</strong></span><span class="No-Break"> instead.</span></p>
			<p>Some important administration modules like <strong class="source-inline">UpdateServices</strong> for managing <strong class="bold">Windows Server Update Services</strong> (<strong class="bold">WSUS</strong>) won’t work in Compatibility mode as they rely on manipulating<a id="_idIndexMarker936"/> the objects that are returned through their methods, which don’t survive the <span class="No-Break">deserialization process.</span></p>
			<p><strong class="bold">Windows Management Instrumentation</strong> (<strong class="bold">WMI</strong>) commands aren’t included in PowerShell 7, as Microsoft<a id="_idIndexMarker937"/> has been trying to deprecate them since PowerShell 3.0, preferring people to use the more lightweight CIM commands. They remain popular, however, and many people still use WMI over CIM. We’ll be discussing these CIM commands and how to use them in the next section, as it is an <span class="No-Break">important topic.</span></p>
			<h1 id="_idParaDest-268"><a id="_idTextAnchor273"/>Managing machines with CIM and WMI</h1>
			<p>CIM and WMI are related technologies for managing local and remote machines. In this section, we will look at the basics of each and discuss their similarities <span class="No-Break">and differences.</span></p>
			<h2 id="_idParaDest-269"><a id="_idTextAnchor274"/>Introduction to CIM and WMI</h2>
			<p>CIM and WMI are based on the <strong class="bold">Web-Based Enterprise Management</strong> (<strong class="bold">WBEM</strong>) standard introduced by the <strong class="bold">Distributed Management Task Force</strong> (<strong class="bold">DMTF</strong>) in 1996. WMI is Microsoft’s implementation<a id="_idIndexMarker938"/> of a set <a id="_idIndexMarker939"/>of tools based on WBEM, released in 1998, and CIM<a id="_idIndexMarker940"/> is an open standard from the DMTF that defines how the entities in an environment are represented and related. It was released in 1999. In a Windows environment, CIM uses elements<a id="_idIndexMarker941"/> of WMI but uses a different set of protocols<a id="_idIndexMarker942"/> to access them; WMI uses the <strong class="bold">Distributed Common Object Model</strong> (<strong class="bold">DCOM</strong>) protocol, which is proprietary, and CIM uses the <strong class="bold">Web Services for Management</strong> (<strong class="bold">WS-MAN</strong>) protocol over HTTP, which<a id="_idIndexMarker943"/> we saw in <a href="B17600_12.xhtml#_idTextAnchor236"><span class="No-Break"><em class="italic">Chapter 12</em></span></a>, <span class="No-Break"><em class="italic">Securing PowerShell</em></span><span class="No-Break">.</span></p>
			<p>Both technologies link to a common repository – the WMI repository, which we’ll look at shortly. This repository holds information about the type of objects we might want to manage, such as printers, clients, network adapters, and so on, and instances of <span class="No-Break">those objects.</span></p>
			<p>The PowerShell CIM commands<a id="_idIndexMarker944"/> allow us to connect to local and remote machines via WS-MAN to the <strong class="bold">Windows Remote Management</strong> (<strong class="bold">WinRM</strong>) endpoint that we use for remote sessions. We can do this either as an ad hoc connection or via a CIM session, similar <span class="No-Break">to remoting.</span></p>
			<p>WMI only supports ad hoc connections over DCOM. This means WinRM doesn’t need to be enabled on the <span class="No-Break">remote machine.</span></p>
			<h3>Why CIM is better than WMI</h3>
			<p>CIM is slightly newer, but crucially<a id="_idIndexMarker945"/> uses an open connection<a id="_idIndexMarker946"/> protocol – WS-MAN. This requires a pair of static network ports<a id="_idIndexMarker947"/> to be available on machines and any devices in the network. DCOM uses the <strong class="bold">Remote Procedure Call</strong> (<strong class="bold">RPC</strong>) protocol, which relies heavily on ephemeral TCP/IP ports; it’s much easier to run WS-MAN over a network than it is to run DCOM because of this difference. There are lots of other reasons why WS-MAN is better than DCOM, but the biggest stumbling block in my experience is DCOM’s requirement for <span class="No-Break">ephemeral ports.</span></p>
			<p>Microsoft has been trying since PowerShell 3.0 in 2012 to deprecate the WMI cmdlets and persuade people to use the CIM cmdlets instead, as CIM uses a lighter protocol with less of a network footprint; RPC has many disadvantages, and I’ve spent a good chunk of my career identifying and fixing problems that have resulted from RPC. However, plenty of people still use the WMI cmdlets, and there are lots of popular scripts available on the internet that <span class="No-Break">use them.</span></p>
			<p>The WMI cmdlets<a id="_idIndexMarker948"/> are not available within PowerShell 7, but we will see many workarounds<a id="_idIndexMarker949"/> on the internet involving <strong class="source-inline">Invoke-Command</strong> that enable us to use them via <span class="No-Break">Compatibility mode.</span></p>
			<h3>Commands that use CIM and WMI</h3>
			<p>The WMI repository is huge<a id="_idIndexMarker950"/> and confusing, as we shall <a id="_idIndexMarker951"/>see. Therefore, it’s better, where possible, to use a dedicated cmdlet rather than a CIM or WMI cmdlet. What does that look like? For instance, we might use <strong class="source-inline">Get-CimInstance Win32_Printer</strong> to query the printers on a machine, but it’s quicker and more intuitive to use the <strong class="source-inline">Get-Printer</strong> cmdlet, demonstrated <span class="No-Break">as follows:</span></p>
			<div>
				<div id="_idContainer247" class="IMG---Figure">
					<img src="image/B17600_13_011.jpg" alt="Figure 13.11 – Looking for printers"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 13.11 – Looking for printers</p>
			<p>Both commands are looking for the HP printer on my local machine. They both use CIM to query the WMI repository. Arguably, the second command is easier to run and remember, and is generally faster too. <strong class="source-inline">Get-Printer</strong> supports the <strong class="source-inline">-ComputerName</strong> parameter for remote machines and even supports using CIM sessions. Before digging around for hours to work out how to do something using a CIM cmdlet, check there isn’t already a handy pre-written cmdlet that does what we want. Of course, <strong class="source-inline">Get-Printer</strong> is a Windows PowerShell cmdlet, and therefore we need to be running on a Windows client and <span class="No-Break">use Compatibility.</span></p>
			<h3>Repository</h3>
			<p>The WMI repository<a id="_idIndexMarker952"/> is a hierarchical database – a tree <a id="_idIndexMarker953"/>structure. At the top level are namespaces – essentially containers. Namespaces contain classes. A class represents a type of object, such as a printer, and contains instances of that type of object. Each instance of a class has the same set of properties and methods as other instances of a class – although they may not all be populated or enabled. There is a class called <strong class="source-inline">__NAMESPACE</strong>, with two underscores (<strong class="source-inline">_</strong>), that contains namespaces, so a namespace may contain other namespaces <span class="No-Break">as well.</span></p>
			<p>The root namespace is called, unimaginatively, <strong class="source-inline">root</strong>. We can see the contents of this with the <span class="No-Break">following command:</span></p>
			<pre class="console">
Get-CimClass -Namespace 'Root' | Select-Object -First 10</pre>			<p>And we can see the instances of the <strong class="source-inline">__NAMESPACE</strong> class with <span class="No-Break">the following:</span></p>
			<pre class="console">
Get-CimInstance -Namespace 'Root' -ClassName __NAMESPACE</pre>			<p>The contents of the namespaces and classes may vary on each machine, as hardware and software will create their own namespaces and classes when installed. The important namespace for most people though is <strong class="source-inline">root/CIMV2</strong>, shown in the <span class="No-Break">following figure.</span></p>
			<div>
				<div id="_idContainer248" class="IMG---Figure">
					<img src="image/B17600_13_012.jpg" alt="Figure 13.12 – Finding the CIMV2 namespace"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 13.12 – Finding the CIMV2 namespace</p>
			<p>In the first command, I’m listing<a id="_idIndexMarker954"/> out the first 10 returned classes<a id="_idIndexMarker955"/> in the <strong class="source-inline">root</strong> namespace. There are 75 classes in the root namespace on my client so I’m only listing the first 10 – this number will likely differ on yours. In the second command, I’m listing the instances of the <strong class="source-inline">__NAMESPACE</strong> class on my machine – again, there is quite a large number, and yours may be different. The <strong class="source-inline">CIMV2</strong> namespace <span class="No-Break">is highlighted.</span></p>
			<p>The <strong class="source-inline">CIMV2</strong> namespace contains the Microsoft Windows classes. We can use <strong class="source-inline">Get-CimClass</strong> to list them out, but there are over 1,200 classes in this namespace on my machine; most of them called either <strong class="source-inline">MSFT_*</strong> or <strong class="source-inline">Win32_*</strong>. With so many classes, we can see that finding things in the repository can be a challenge. Microsoft has done a reasonable job of documenting the contents of the <strong class="source-inline">root/CIMV2</strong> namespace online, but the contents of other namespaces are typically not well documented, and finding out what things do and how to use them can be a bit of <span class="No-Break">an exercise.</span></p>
			<p>In <span class="No-Break"><em class="italic">Figure 13</em></span><em class="italic">.11</em>, we used the <strong class="source-inline">Get-CimInstance Win32_Printer</strong> command, without specifying a namespace – this is because PowerShell has the <strong class="source-inline">CIMV2</strong> namespace set as the default, so that we don’t have to add<a id="_idIndexMarker956"/> the <strong class="source-inline">-Namespace 'root/CIMV2'</strong> parameter to <span class="No-Break">every</span><span class="No-Break"><a id="_idIndexMarker957"/></span><span class="No-Break"> command.</span></p>
			<h2 id="_idParaDest-270"><a id="_idTextAnchor275"/>Querying data</h2>
			<p>We use CIM and WMI for two<a id="_idIndexMarker958"/> main tasks – finding out information and changing things, frequently on large numbers of machines at once. Let’s start by looking at how we can find things out. We’ve already seen two CIM cmdlets that we can use; <strong class="source-inline">Get-CimClass</strong> <span class="No-Break">and </span><span class="No-Break"><strong class="source-inline">Get-CimInstance</strong></span><span class="No-Break">.</span></p>
			<h3>Get-CimClass</h3>
			<p>This cmdlet gets a list of the CIM<a id="_idIndexMarker959"/> classes in a specified namespace, or in the default namespace if no namespace is given. There are a few parameters for <span class="No-Break">this cmdlet:</span></p>
			<ul>
				<li><strong class="source-inline">-ClassName</strong>: This allows us to either specify a class, or provide a partial class name when we’re looking for a specific class; e.g., <strong class="source-inline">Get-CimClass -ClassName *disk*</strong> will get all the classes in <strong class="source-inline">CIMV2</strong> with the word <strong class="source-inline">disk</strong> in <span class="No-Break">the name.</span></li>
				<li><strong class="source-inline">-Namespace</strong>: This allows us to specify a namespace other <span class="No-Break">than </span><span class="No-Break"><strong class="source-inline">root/CIMV2</strong></span><span class="No-Break">.</span></li>
				<li><strong class="source-inline">-ComputerName</strong>: This parameter allows us to specify a machine other than the local machine. We can use an FQDN, a NetBIOS name, or an <span class="No-Break">IP address.</span></li>
				<li><strong class="source-inline">-MethodName</strong>: This parameter allows us to search for classes that have a particular method. For example, <strong class="source-inline">Get-CimClass -MethodName 'term*'</strong> will return the <strong class="source-inline">Win32_Process</strong> class, which has a <strong class="source-inline">Terminate</strong> method. No prizes for guessing what that <span class="No-Break">method does.</span></li>
				<li><strong class="source-inline">-PropertyName</strong>: Similar to the <strong class="source-inline">-MethodName</strong> parameter, this allows us to search for classes with a <span class="No-Break">particular property.</span></li>
				<li><strong class="source-inline">-QualifierName</strong>: Qualifiers are like tags that are applied to classes. There is no standard list (a bit like tags), but they can sometimes be quite useful. For instance, we can use <strong class="source-inline">Get-CimClass -QualifierName 'deprecated'</strong> to retrieve a list of classes that are being phased out, and probably shouldn’t be used in <span class="No-Break">a script.</span></li>
				<li><strong class="source-inline">-Amended</strong>: This parameter gets amended information – usually information that changes depending on the locale of the machine. Localizable information is often presented numerically and requires a lookup to be translated into the local language – this parameter will <span class="No-Break">do that.</span></li>
				<li><strong class="source-inline">-OperationTimeoutSec</strong>: If we are running the command against a remote computer, it’s possible that the machine is unresponsive or not even switched on. This allows us to specify a timeout other than the default network timeout set for the local machine, which is by default 3 minutes. If we were querying 1,000 machines, and 10% of them are switched off or not connected to the network, this allows us to complete the command in less than <span class="No-Break">5 hours.</span></li>
				<li><strong class="source-inline">-CimSession</strong>: This allows us to run<a id="_idIndexMarker960"/> the command in a pre-existing CIM session. More on CIM <span class="No-Break">sessions shortly.</span></li>
			</ul>
			<p>Let’s take a look at <span class="No-Break"><strong class="source-inline">Get-CimInstance</strong></span><span class="No-Break"> next.</span></p>
			<h3>Get-CimInstance</h3>
			<p>This cmdlet gets the instances<a id="_idIndexMarker961"/> of a given CIM class – again, the default namespace is root/CIMV2. It has many of the same parameters as <strong class="source-inline">Get-CimClass</strong>, with a few differences. Let’s take <span class="No-Break">a look:</span></p>
			<ul>
				<li><strong class="source-inline">-CimSession</strong>: Same as <span class="No-Break">for </span><span class="No-Break"><strong class="source-inline">Get-CimClass</strong></span><span class="No-Break">.</span></li>
				<li><strong class="source-inline">-ClassName</strong>: Same as <span class="No-Break">for </span><span class="No-Break"><strong class="source-inline">Get-CimClass</strong></span><span class="No-Break">.</span></li>
				<li><strong class="source-inline">-ComputerName</strong>: Same as <span class="No-Break">for </span><span class="No-Break"><strong class="source-inline">Get-CimClass</strong></span><span class="No-Break">.</span></li>
				<li><strong class="source-inline">-Filter</strong>: Allows us to specify a filter string to only get certain instances. For instance, <strong class="source-inline">Get-CimInstance -Classname Win32_Printer -Filter "Name like 'HP%'"</strong> will find<a id="_idIndexMarker962"/> the HP printer<a id="_idIndexMarker963"/> on my machine. Note that we must use <strong class="bold">Windows Query Language</strong> (<strong class="bold">WQL</strong>) or <strong class="bold">Cassandra Query </strong><span class="No-Break"><strong class="bold">Language</strong></span><span class="No-Break"> (</span><span class="No-Break"><strong class="bold">CQL</strong></span><span class="No-Break">).</span></li>
				<li><strong class="source-inline">-KeyOnly</strong>: Returns only the key properties of an instance, rather than all <span class="No-Break">the properties.</span></li>
				<li><strong class="source-inline">-Namespace</strong>: Same as <span class="No-Break">for </span><span class="No-Break"><strong class="source-inline">Get-CimClass</strong></span><span class="No-Break">.</span></li>
				<li>-<strong class="source-inline">OperationTimeoutSec</strong>: Same as <span class="No-Break">for </span><span class="No-Break"><strong class="source-inline">Get-CimClass</strong></span><span class="No-Break">.</span></li>
				<li><strong class="source-inline">-Property</strong>: Unlike <strong class="source-inline">Get-CimClass</strong>, this doesn’t search for instances with a given property; remember, all instances of a class have the same properties and methods. Notice it is <strong class="source-inline">-Property</strong>, not <strong class="source-inline">-PropertyName</strong>. We can use this parameter to retrieve a list of specified properties, rather than all the properties of <span class="No-Break">an instance.</span></li>
				<li><strong class="source-inline">-Query</strong>: Allows us to specify a query string written in WQL or CQL. For example, <strong class="source-inline">Get-CimInstance -Query "SELECT * from Win32_Printer WHERE name LIKE 'HP%'"</strong> will find my HP <span class="No-Break">printer, again.</span></li>
				<li><strong class="source-inline">-QueryDialect</strong>: Specifies the dialect the query is written in. The default is WQL, so we would generally only use this parameter if we were supplying a query written <span class="No-Break">in CQL.</span></li>
				<li><strong class="source-inline">-Shallow</strong>: By default, <strong class="source-inline">Get-CimInstance</strong> returns all instances of a class, and instances of any child classes. This parameter prevents any results from child classes <span class="No-Break">being returned.</span></li>
			</ul>
			<p>We can see that both these cmdlets<a id="_idIndexMarker964"/> have a <strong class="source-inline">-ComputerName</strong> parameter for working with remote machines. Each time we use this parameter, we create and then remove an ad hoc CIM session. If we have a bunch of commands to run against a remote machine then we can create a persistent CIM session in the same way as we can create a persistent PowerShell remoting session. Let’s see how we can <span class="No-Break">do this.</span></p>
			<h3>CIM sessions</h3>
			<p>There are four cmdlets<a id="_idIndexMarker965"/> for manipulating CIM sessions – <strong class="source-inline">New-CimSession</strong>, <strong class="source-inline">Get-CimSession</strong>, <strong class="source-inline">Remove-CimSession</strong>, and <strong class="source-inline">New-CimSessionOption</strong>. They behave in a very similar way to the PowerShell remoting cmdlets, and <strong class="source-inline">Get-CimSession</strong> and <strong class="source-inline">Remove-CimSession</strong> do exactly what you would expect. Note that CIM sessions work best in an Active Directory domain environment that uses Kerberos, which is the default authentication scheme. If this isn’t available, then the remote machines will need to be added to the TrustedHosts exception list in WinRM. Let’s take a quick look at how <span class="No-Break"><strong class="source-inline">New-CimSession</strong></span><span class="No-Break"> works.</span></p>
			<p>The cmdlet<a id="_idIndexMarker966"/> has the <span class="No-Break">following parameters:</span></p>
			<ul>
				<li><strong class="source-inline">-Authentication</strong>: Which authentication scheme we want to use. This will depend on the environment we are working in. Kerberos is the best option for a <span class="No-Break">domain environment.</span></li>
				<li><strong class="source-inline">-CertificateThumbprint</strong>: If we are working in a certificate-based authentication scheme, then we will need to provide the details of <span class="No-Break">our certificate.</span></li>
				<li><strong class="source-inline">-ComputerName</strong>: The name of the remote computer we want to work on. If not given, then a CIM session to the local machine over DCOM is created. WSMan is used for <span class="No-Break">remote computers.</span></li>
				<li><strong class="source-inline">-Credential</strong>: Again, depending on the authentication scheme we are working with, we might need to give a <span class="No-Break">credential object.</span></li>
				<li><strong class="source-inline">-Name</strong>: We can assign a friendly name to the session to make it easier to <span class="No-Break">work with.</span></li>
				<li><strong class="source-inline">-OperationTimeoutSec</strong>: This is the same as <span class="No-Break">for </span><span class="No-Break"><strong class="source-inline">Get-CimClass</strong></span><span class="No-Break">.</span></li>
				<li><strong class="source-inline">-Port</strong>: We can specify a particular TCP port if our network is restricted, but this <span class="No-Break">isn’t recommended.</span></li>
				<li><strong class="source-inline">-SessionOption</strong>: This allows us to set advanced options for the session by creating a <strong class="source-inline">SessionOption</strong> object <span class="No-Break">with </span><span class="No-Break"><strong class="source-inline">New-CimSessionOption</strong></span><span class="No-Break">.</span></li>
				<li><strong class="source-inline">-SkipTestConnection</strong>: This stops the cmdlet testing the session connectivity before <span class="No-Break">creating it.</span></li>
			</ul>
			<p>There are a number of advanced options covering the use of proxy servers and controlling how we work with different authentication schemes. These can all be set with the <strong class="source-inline">New-CimSessionOption</strong> cmdlet, but we’re not going to go into <span class="No-Break">them here.</span></p>
			<p>Let’s see how this all works<a id="_idIndexMarker967"/> in the <span class="No-Break">following figure:</span></p>
			<div>
				<div id="_idContainer249" class="IMG---Figure">
					<img src="image/B17600_13_013.jpg" alt="Figure 13.13 – Working with CIM sessions"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 13.13 – Working with CIM sessions</p>
			<p>In the first command, I create a new CIM session on the local machine and give it a friendly name, <strong class="source-inline">localsession</strong>. In the second command, I get the details of my session using the friendly name; notice this is using WSMan, not DCOM, even though it’s the local machine. That’s because I specified the local machine with the <strong class="source-inline">-ComputerName</strong> parameter, so the cmdlet automatically uses a WSMan session. Neat, huh? In the final command, I remove <span class="No-Break">the session.</span></p>
			<p>So, that’s the cmdlets<a id="_idIndexMarker968"/> we can use to get information about classes and instances. In the next section, we’ll look at how we can manipulate the properties of instances and use <span class="No-Break">their methods.</span></p>
			<h2 id="_idParaDest-271"><a id="_idTextAnchor276"/>Making changes</h2>
			<p>We can use the CIM cmdlets to manipulate the objects in the WMI repository as well; we can change their properties (sometimes) or use their methods. Let’s start with <span class="No-Break">changing properties.</span></p>
			<h3>Changing properties</h3>
			<p>Let's run<a id="_idIndexMarker969"/> the <span class="No-Break">following</span><span class="No-Break"><a id="_idIndexMarker970"/></span><span class="No-Break"> command:</span></p>
			<pre class="console">
Get-CimInstance Win32_Printer | Where-Object {$_.Name -like 'HP*'} | gm</pre>			<p>Then we will see all the methods and properties of an HP printer installed on our local client. If we don’t have an HP printer installed, then we’ll get an error, but we can change the search string to match the sort of printer we might have; for instance <strong class="source-inline">'can*'</strong> will find Canon printers. Note that the properties are followed by a string that looks like <strong class="source-inline">{get;set;}</strong>. If it only reads <strong class="source-inline">{get;}</strong> then it is not writable. Let’s see how changing a writable <span class="No-Break">property looks:</span></p>
			<div>
				<div id="_idContainer250" class="IMG---Figure">
					<img src="image/B17600_13_014.jpg" alt="Figure 13.14 – Changing the properties with Set-CimInstance"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 13.14 – Changing the properties with Set-CimInstance</p>
			<p>In the first command, I’m creating a variable called <strong class="source-inline">$printer</strong> and putting my HP printer in it. In the second command, I’m calling the variable, just to check the right thing is in there. <span class="No-Break">It is.</span></p>
			<p>In the third command, I’m checking the current value of the <strong class="source-inline">Comment</strong> property of the <strong class="source-inline">$printer</strong> variable – we can see it’s empty. In the fourth command, I’m changing the property of the variable to <strong class="source-inline">I </strong><span class="No-Break"><strong class="source-inline">Love PowerShell</strong></span><span class="No-Break">.</span></p>
			<p>The fifth command is the important bit – I’m taking the contents of the variable, and now I’m writing them back to the instance in the WMI repository with the <strong class="source-inline">Set-CimInstance</strong> cmdlet. The variable contains a WMI object so I’m using the <strong class="source-inline">-InputObject</strong> parameter of the cmdlet. Has it worked? Let’s take <span class="No-Break">a look.</span></p>
			<div>
				<div id="_idContainer251" class="IMG---Figure">
					<img src="image/B17600_13_015.jpg" alt="Figure 13.15 – My printer has an opinion"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 13.15 – My printer has an opinion</p>
			<p>Of course it worked. Phew. If we look at the list of properties<a id="_idIndexMarker971"/> on a printer object, we can see that the majority<a id="_idIndexMarker972"/> of them are not writable. For instance, there is a <strong class="source-inline">Default</strong> property, but it’s not writable, and we can’t set it with <strong class="source-inline">Set-CimInstance</strong>. In the next section, we’ll look at a cmdlet that could do <span class="No-Break">it, </span><span class="No-Break"><strong class="source-inline">Invoke-CimMethod</strong></span><span class="No-Break">.</span></p>
			<h3>Discovering methods</h3>
			<p>We know that objects <a id="_idIndexMarker973"/>have properties<a id="_idIndexMarker974"/> and methods, and that includes the objects in the WMI repository. We’ve looked at the properties, seen how to get them, and how to set them. Now we’re going to look at the methods those objects may have. Here, we’re going to see just why working with the WMI repository is sometimes such <span class="No-Break">a pain.</span></p>
			<p>Our first problem is knowing the name of the class we want, and we saw how to do that in the preceding section on querying data. Once we know the name of the class, we need to understand what methods are available. The <strong class="source-inline">Get-CimClass</strong> cmdlet doesn’t discover all the methods by default, unlike the <strong class="source-inline">Get-WmiObject</strong> cmdlet, so we have to use something like the <span class="No-Break">following command:</span></p>
			<pre class="console">
Get-CimClass -Class Win32_Printer | Select-Object -ExpandProperty CimClassMethods</pre>			<p>This will expose the full set of methods. Once we’ve got our method, of course, we need to know how to use it. Because WMI isn’t part of PowerShell, the PowerShell documentation won’t help us. Most<a id="_idIndexMarker975"/> of the time, we can find out what we need to know from the Microsoft <span class="No-Break">website, here:</span></p>
			<p><a href="https://learn.microsoft.com/en-us/windows/win32/cimwin32prov/cimwin32-wmi-providers"><span class="No-Break">https://learn.microsoft.com/en-us/windows/win32/cimwin32prov/cimwin32-wmi-providers</span></a></p>
			<p>However, it takes a bit of searching, and quite often the examples are given in Visual Basic, not PowerShell. Let’s see how we might <span class="No-Break">do it.</span></p>
			<p>In the next section, we’re going<a id="_idIndexMarker976"/> to see how to start and stop a process, so let’s use the <strong class="source-inline">Win32_Process</strong> <span class="No-Break">documentation, here:</span></p>
			<p><a href="https://learn.microsoft.com/en-us/windows/win32/cimwin32prov/win32-process"><span class="No-Break">https://learn.microsoft.com/en-us/windows/win32/cimwin32prov/win32-process</span></a></p>
			<p>We can see if we scroll down<a id="_idIndexMarker977"/> that there is a <em class="italic">Methods</em> section. The most likely method<a id="_idIndexMarker978"/> there is <strong class="source-inline">Create</strong>. If we click on the link, we can see that the <strong class="source-inline">Create</strong> method has a <strong class="source-inline">CommandLine</strong> parameter. Let’s see how that <span class="No-Break">might work.</span></p>
			<h3>Invoking methods</h3>
			<p>Now we have our method, and a likely parameter<a id="_idIndexMarker979"/> for that method, let’s give<a id="_idIndexMarker980"/> it a try. First of all, we’ll need our <strong class="source-inline">Invoke-CimMethod</strong> cmdlet. This cmdlet has the following parameters, many of which work in ways we should now be <span class="No-Break">familiar with:</span></p>
			<ul>
				<li><strong class="source-inline">-ClassName</strong>: Same as <span class="No-Break">for </span><span class="No-Break"><strong class="source-inline">Get-CimClass</strong></span><span class="No-Break">.</span></li>
				<li><strong class="source-inline">-CimClass</strong>: We can use this parameter to specify a WMI class instead of the <strong class="source-inline">-ClassName</strong> parameter. We need to pass it a WMI class object, however, via a variable, instead of <span class="No-Break">a string.</span></li>
				<li><strong class="source-inline">-CimSession</strong>: Same as <span class="No-Break">for </span><span class="No-Break"><strong class="source-inline">Get-CimClass</strong></span><span class="No-Break">.</span></li>
				<li><strong class="source-inline">-Namespace</strong>: Same as <span class="No-Break">for </span><span class="No-Break"><strong class="source-inline">Get-CimClass</strong></span><span class="No-Break">.</span></li>
				<li><strong class="source-inline">-ComputerName</strong>: Same as <span class="No-Break">for </span><span class="No-Break"><strong class="source-inline">Get-CimClass</strong></span><span class="No-Break">.</span></li>
				<li><strong class="source-inline">-MethodName</strong>: This is a mandatory parameter that accepts a string; the name of <span class="No-Break">the method.</span></li>
				<li><strong class="source-inline">-Arguments</strong>: Here, we specify the parameters we are passing to the method, as an <strong class="source-inline">iDictionary</strong> hash table, like this: <strong class="source-inline">-Arguments @{ ParameterName = '</strong><span class="No-Break"><strong class="source-inline">value'}</strong></span><span class="No-Break">.</span></li>
				<li><strong class="source-inline">-OperationTimeoutSeconds</strong>: Same as <span class="No-Break">for </span><span class="No-Break"><strong class="source-inline">Get-CimClass</strong></span><span class="No-Break">.</span></li>
				<li><strong class="source-inline">-Query</strong> and <strong class="source-inline">-QueryDialect</strong>: Same as <span class="No-Break">for </span><span class="No-Break"><strong class="source-inline">Get-CimInstance</strong></span><span class="No-Break">.</span></li>
			</ul>
			<p>Let’s start the Notepad<a id="_idIndexMarker981"/> program; we may want to close<a id="_idIndexMarker982"/> any running instances of Notepad, especially if we’re working on Windows 11. First, we’ll use the <strong class="source-inline">Invoke-CimMethod</strong> cmdlet. We’ll need the class name, <strong class="source-inline">Win32_Process</strong>, the method name, <strong class="source-inline">Create()</strong>, and the argument. We’ll use <strong class="source-inline">CommandLine = 'notepad.exe'</strong>, as <strong class="source-inline">notepad.exe</strong> is in the <strong class="source-inline">PATH</strong> environmental variable, so shouldn’t need <span class="No-Break">a location:</span></p>
			<pre class="console">
Invoke-CimMethod -ClassName Win32_Process -MethodName Create -Arguments @{CommandLine = 'notepad.exe'}'}</pre>			<p>And it looks <span class="No-Break">like this:</span></p>
			<div>
				<div id="_idContainer252" class="IMG---Figure">
					<img src="image/B17600_13_016.jpg" alt="Figure 13.16 – Invoking a method"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 13.16 – Invoking a method</p>
			<p>We can see the return value (<strong class="source-inline">0</strong>) indicates success, and we get the <strong class="source-inline">ProcessId</strong> of the new Notepad process we’ve created. Note that this command may create the process in the background; we don’t see the Notepad window suddenly appear, but we’ll see it on <span class="No-Break">the taskbar.</span></p>
			<p class="callout-heading">Activities</p>
			<ol>
				<li class="callout" value="1">How could we close the <strong class="source-inline">notepad.exe</strong> process we just started <span class="No-Break">with PowerShell?</span></li>
				<li class="callout">How can we set a printer as the default with PowerShell? Hint: we can’t use the Windows PowerShell <span class="No-Break"><strong class="source-inline">Set-Printer</strong></span><span class="No-Break"> cmdlet.</span></li>
			</ol>
			<p>That’s all we’re going to cover<a id="_idIndexMarker983"/> here. Just remember that properties and methods<a id="_idIndexMarker984"/> are not well documented, and that quite often there will be a PowerShell cmdlet specifically written for our purpose, either as part of PowerShell 7 or Windows PowerShell. Let’s summarize <span class="No-Break">this chapter.</span></p>
			<h1 id="_idParaDest-272"><a id="_idTextAnchor277"/>Summary</h1>
			<p>We started the final section of the book in this chapter on using PowerShell in different environments. We’ve started with the Windows environment, arguably the environment in which PowerShell is most effective. However, we saw there are some important differences between PowerShell 7 and <span class="No-Break">Windows PowerShell.</span></p>
			<p>We saw that PowerShell 7 can’t necessarily use modules written for Windows PowerShell, and we looked at three ways of coping with that; finding an equivalent module for PowerShell 7, loading the module anyway, or using <span class="No-Break">Compatibility mode.</span></p>
			<p>While most of the time Compatibility mode is used transparently, we looked at how it works, and some cases where we might want to limit how it is used. However, it is incredibly useful, and we saw that it is getting better all <span class="No-Break">the time.</span></p>
			<p>We moved on to look at some stuff that just doesn’t work with PowerShell 7, and why. Generally, this is related to older modules that are no longer worth rewriting to be compatible with <span class="No-Break">PowerShell 7.</span></p>
			<p>We then looked at one of the most useful ways to use PowerShell 7 on a Windows machine: using CIM to manipulate the WMI repository. We took some time to understand the WMI repository, then moved on to how we can get the properties of objects there to understand the environment on both our local machine and <span class="No-Break">remote machines.</span></p>
			<p>The final section looked at how to manipulate the properties of objects in the WMI repository, and then looked at how we can call the methods on those objects to affect the wider <span class="No-Break">computing environment.</span></p>
			<p>That’s it for this chapter. In the next chapter, we’re going to look at how we can use PowerShell 7 on Linux and <span class="No-Break">macOS machines.</span></p>
			<h1 id="_idParaDest-273"><a id="_idTextAnchor278"/>Exercises</h1>
			<ol>
				<li>What type of modules have <span class="No-Break">compatibility information?</span></li>
				<li>Why might a module have no <span class="No-Break">compatibility information?</span></li>
				<li>We’ve run <strong class="source-inline">Get-PSSession</strong>, and we can see that there is a remote session called <strong class="source-inline">WinPSCompatSession</strong> running on the localhost machine. What version of PowerShell is <span class="No-Break">it running?</span></li>
				<li>What sort of objects do we get back from commands run in <span class="No-Break">the </span><span class="No-Break"><strong class="source-inline">WinPSCompatSession</strong></span><span class="No-Break">?</span></li>
				<li>Our local admin has disabled implicit Windows compatibility on our machine. How can we still import modules in <span class="No-Break">Compatibility mode?</span></li>
				<li>What CIM class contains instances <span class="No-Break">of namespaces?</span></li>
				<li>What is the purpose of the <strong class="source-inline">-OperationTimeoutSecs</strong> parameter on the <span class="No-Break"><strong class="source-inline">Get-CimInstance</strong></span><span class="No-Break"> cmdlet?</span></li>
				<li>What cmdlet would we use to change the properties of a <span class="No-Break">WMI object?</span></li>
				<li>How do we pass method parameters to <strong class="source-inline">Invoke-CimMethod</strong> and what format do they need to <span class="No-Break">be in?</span></li>
			</ol>
			<h1 id="_idParaDest-274"><a id="_idTextAnchor279"/>Further reading</h1>
			<ul>
				<li><em class="italic">.</em><span class="No-Break"><em class="italic">NET Framework</em></span><span class="No-Break">:</span><p class="list-inset"><a href="https://en.wikipedia.org/wiki/.NET_Framework"><span class="No-Break">https://en.wikipedia.org/wiki/.NET_Framework</span></a></p></li>
				<li><span class="No-Break"><em class="italic">Module compatibility</em></span><span class="No-Break">:</span><p class="list-inset"><a href="https://learn.microsoft.com/en-us/powershell/gallery/concepts/module-psedition-support"><span class="No-Break">https://learn.microsoft.com/en-us/powershell/gallery/concepts/module-psedition-support</span></a></p></li>
				<li><span class="No-Break"><em class="italic">PowerShell editions</em></span><span class="No-Break">:</span><p class="list-inset"><a href="https://learn.microsoft.com/en-us/powershell/module/microsoft.powershell.core/about/about_powershell_editions"><span class="No-Break">https://learn.microsoft.com/en-us/powershell/module/microsoft.powershell.core/about/about_powershell_editions</span></a></p></li>
				<li><em class="italic">Differences in </em><span class="No-Break"><em class="italic">PowerShell 7</em></span><span class="No-Break">:</span><p class="list-inset"><a href="https://learn.microsoft.com/en-us/powershell/scripting/whats-new/differences-from-windows-powershell"><span class="No-Break">https://learn.microsoft.com/en-us/powershell/scripting/whats-new/differences-from-windows-powershell</span></a></p></li>
				<li><em class="italic">Web-Based </em><span class="No-Break"><em class="italic">Enterprise Management</em></span><span class="No-Break">:</span><p class="list-inset"><a href="https://en.wikipedia.org/wiki/Web-Based_Enterprise_Management"><span class="No-Break">https://en.wikipedia.org/wiki/Web-Based_Enterprise_Management</span></a></p></li>
				<li><em class="italic">Common </em><span class="No-Break"><em class="italic">Information Model</em></span><span class="No-Break">:</span><p class="list-inset"><a href="https://en.wikipedia.org/wiki/Common_Information_Model_(computing)"><span class="No-Break">https://en.wikipedia.org/wiki/Common_Information_Model_(computing)</span></a></p></li>
				<li><span class="No-Break"><em class="italic">WSMan</em></span><span class="No-Break">:</span><p class="list-inset"><a href="https://en.wikipedia.org/wiki/WS-Management"><span class="No-Break">https://en.wikipedia.org/wiki/WS-Management</span></a></p></li>
				<li><em class="italic">Windows </em><span class="No-Break"><em class="italic">Management Instrumentation</em></span><span class="No-Break">:</span><p class="list-inset"><a href="https://en.wikipedia.org/wiki/Windows_Management_Instrumentation"><span class="No-Break">https://en.wikipedia.org/wiki/Windows_Management_Instrumentation</span></a></p></li>
				<li><em class="italic">Distributed Component </em><span class="No-Break"><em class="italic">Object Model</em></span><span class="No-Break">:</span><p class="list-inset"><a href="https://en.wikipedia.org/wiki/Distributed_Component_Object_Model"><span class="No-Break">https://en.wikipedia.org/wiki/Distributed_Component_Object_Model</span></a></p></li>
				<li><em class="italic">Migrating from Windows PowerShell 5.1 to </em><span class="No-Break"><em class="italic">PowerShell 7.x</em></span><span class="No-Break">:</span><p class="list-inset"><a href="https://learn.microsoft.com/en-us/powershell/scripting/whats-new/migrating-from-windows-powershell-51-to-powershell-7"><span class="No-Break">https://learn.microsoft.com/en-us/powershell/scripting/whats-new/migrating-from-windows-powershell-51-to-powershell-7</span></a></p></li>
				<li><em class="italic">About Windows </em><span class="No-Break"><em class="italic">PowerShell Compatibility</em></span><span class="No-Break">:</span><p class="list-inset"><a href="https://learn.microsoft.com/en-us/powershell/module/microsoft.powershell.core/about/about_windows_powershell_compatibility"><span class="No-Break">https://learn.microsoft.com/en-us/powershell/module/microsoft.powershell.core/about/about_windows_powershell_compatibility</span></a></p></li>
				<li><em class="italic">PowerShell 7 </em><span class="No-Break"><em class="italic">module compatibility</em></span><span class="No-Break">:</span><p class="list-inset"><a href="https://learn.microsoft.com/en-us/powershell/scripting/whats-new/module-compatibility"><span class="No-Break">https://learn.microsoft.com/en-us/powershell/scripting/whats-new/module-compatibility</span></a></p></li>
				<li><em class="italic">Modules with compatible </em><span class="No-Break"><em class="italic">PowerShell editions</em></span><span class="No-Break">:</span><p class="list-inset"><a href="https://learn.microsoft.com/en-us/powershell/gallery/concepts/module-psedition-support"><span class="No-Break">https://learn.microsoft.com/en-us/powershell/gallery/concepts/module-psedition-support</span></a></p></li>
				<li><em class="italic">About </em><span class="No-Break"><em class="italic">PowerShell editions</em></span><span class="No-Break">:</span><p class="list-inset"><a href="https://learn.microsoft.com/en-us/powershell/module/microsoft.powershell.core/about/about_powershell_editions"><span class="No-Break">https://learn.microsoft.com/en-us/powershell/module/microsoft.powershell.core/about/about_powershell_editions</span></a></p></li>
				<li><span class="No-Break"><em class="italic">Implicit remoting</em></span><span class="No-Break">:</span><p class="list-inset"><a href="https://devblogs.microsoft.com/scripting/remoting-the-implicit-way/"><span class="No-Break">https://devblogs.microsoft.com/scripting/remoting-the-implicit-way/</span></a></p></li>
				<li><em class="italic">Getting WMI objects </em><span class="No-Break"><em class="italic">with Get-CimInstance</em></span><span class="No-Break">:</span><p class="list-inset"><a href="https://learn.microsoft.com/en-us/powershell/scripting/samples/getting-wmi-objects--get-ciminstance-?view=powershell-7.4"><span class="No-Break">https://learn.microsoft.com/en-us/powershell/scripting/samples/getting-wmi-objects--get-ciminstance-?view=powershell-7.4</span></a></p></li>
				<li><em class="italic">Using PowerShell CIM cmdlets to explore </em><span class="No-Break"><em class="italic">WMI classes</em></span><span class="No-Break">:</span><p class="list-inset"><a href="https://devblogs.microsoft.com/scripting/using-powershell-cim-cmdlets-to-explore-wmi-classes/"><span class="No-Break">https://devblogs.microsoft.com/scripting/using-powershell-cim-cmdlets-to-explore-wmi-classes/</span></a></p></li>
			</ul>
		</div>
	</body></html>