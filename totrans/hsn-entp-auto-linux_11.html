<html><head></head><body>
        <section>

                            <header>
                    <h1 class="header-title">Enterprise Repository Management with Pulp</h1>
                </header>
            
            <article>
                
<p>So far in this book, we have covered several tasks related to the build and configuration of Linux servers for deployment in an Enterprise environment. While much of the work we have completed scales well to cover most scenarios, it must be noted that so far we have only installed packages from one of two sources—either the upstream public package repositories corresponding to each Linux distribution we are using or, in the case of our PXE booting chapter, from an ISO image we downloaded. </p>
<p>Needless to say, this presents several challenges, especially when it comes to creating repeatable, manageable builds of Linux. We will explore these in greater depth in the section titled <em>Installing Pulp for patch management</em>, but suffice to say, using the publicly available repositories means that two builds being performed on two different weekdays could be different! The ISO installation method presents the other end of the spectrum and always produces consistent builds regardless of when they are performed, but in this case, no security (or other) updates are received! What is required is a compromise between these two extremes, and thankfully, one exists in the form of a software package called <strong>Pulp</strong>. </p>
<p>We shall explore Pulp in this chapter, specifically covering the following:</p>
<ul>
<li>Installing Pulp for patch management</li>
<li>Building repositories in Pulp</li>
<li>Patching processes with Pulp</li>
</ul>
<p class="mce-root"/>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Technical requirements</h1>
                </header>
            
            <article>
                
<p>This chapter includes examples based on the following technologies:</p>
<ul>
<li>Ubuntu Server 18.04 LTS</li>
<li>CentOS 7.6</li>
<li>Ansible 2.8</li>
</ul>
<p>To run through these examples, you will need access to two servers or virtual machines running one of each of the operating systems listed previously and Ansible. Note that the examples provided in this chapter may be destructive in nature and if run as-is are only intended to be run in an isolated test environment.</p>
<p><span>All example code discussed in this chapter is available on GitHub at the following URL:</span> <a href="https://github.com/PacktPublishing/Hands-On-Enterprise-Automation-on-Linux/tree/master/chapter08"><span>https://github.com/PacktPublishing/Hands-On-Enterprise-Automation-on-Linux/tree/master/chapter08</span></a>.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Installing Pulp for patch management</h1>
                </header>
            
            <article>
                
<p>Before we delve into the practical aspects of installing Pulp, let's take a more in-depth look at why you would use it. Throughout this book, we have advocated building a Linux environment that is standardized and features high degrees of repeatability, audibility, and predictability. These are important not just as a foundation for automation, but also serves as good practice in the enterprise. </p>
<p>Let's assume that you build a server and deploy a new service to it with Ansible, as we have set out earlier in this book. So far, so good—the Ansible playbooks provide documentation on the build standard and ensure the build can be accurately repeated at a later date. There is a catch, however. Let's say that, a few months later, you return to create another server—perhaps to scale an application or for a <strong>Disaster Recovery</strong> (<strong>DR</strong>) scenario. Depending on the source for your packages, one of two things will happen:</p>
<ul>
<li>If you install from the public internet-facing repositories, both builds will have the latest versions of all the packages that were installed on the date they were built. This difference may be significant, and if time has been put into testing and qualifying software on a given build of Linux, you may not be able to guarantee this with different package versions. Sure, everything is up to date, and you will have all of the latest security patches and bug fixes, but every time you perform this build on a different day, you are prone to getting different package versions. This causes problems with repeatability, especially when ensuring that code that has been tested in one environment works in another.</li>
<li>At the other end of the scale is the ISO build repositories that we used in <span><a href="0c3b40ef-5f31-4fd1-b05f-d549444db163.xhtml" target="_blank">Chapter 6</a></span><span>,</span> <em>Custom Builds with PXE Booting</em>. These never change (unless someone downloads a newer ISO and extracts it over the old one), and so while it produces builds that are of a completely known quantity (and hence support our repeatability goal), they never receive any security updates. This in itself may be a problem.</li>
</ul>
<p>The compromise is, of course, to find a middle ground between these two extremes. What if it were possible to create our own repositories of packages that were a snapshot of a given point in time of a public repository? Hence, they remain static when we need them to (thus ensuring consistent builds), and yet can be updated on demand if an important security fix comes out. The Pulp project comes to our rescue here and is capable of doing exactly these things. It is also a component in some of the more complex infrastructure management solutions such as Katello, as we shall see in the next chapter. </p>
<p>However, for installations where a <strong>Graphical User Interface</strong> (<strong>GUI</strong>) is not a requirement, Pulp meets our needs perfectly. Let's take a look at how we might install it.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Installing Pulp</h1>
                </header>
            
            <article>
                
<p>As we discussed in <a href="c7596fb8-4971-44d7-943a-7660c5eecb17.xhtml" target="_blank">Chapter 1</a>, <em>Building a Standard Operating Environment on Linux</em>, in this book, there will be times when even though you may have built a standardized operating environment around a given Linux distribution such as Ubuntu Server, you have to create an exception. Pulp is such a case, for although it can manage both <kbd>.rpm</kbd> and <kbd>.deb</kbd> packages (hence handling repository requirements for a wide variety of Linux distributions), it is only packaged for (and therefore is easiest to install) on CentOS, Fedora, and RHEL-based operating systems. You can still manage your Ubuntu Server estate with Pulp—you just need to install it on CentOS (or your preferred Red Hat variant). </p>
<div class="packt_infobox">There are several facets to the Pulp installation. For example, Pulp relies on a MongoDB installation, which may be external if desired. Similarly, it also relies on a message bus, and it is possible to use either RabbitMQ or Qpid as preferred. Most organizations will have their own standards for these things, and so it is left as an exercise to you to define the architecture best suited to your enterprise. In this chapter, we will perform a very simple installation of Pulp on a single server to demonstrate the steps involved. </div>
<p>Given the relative complexity of installing Pulp, it is recommended that you create an Ansible Playbook for your Pulp installation. However, in this chapter, we will complete the installation manually to demonstrate the work involved—there is no one-size-fits-all Pulp installation:</p>
<ol>
<li>Before we can begin the installation, we must build a virtual (or physical) server to host our Pulp repositories. For our example, we will base this on CentOS 7.6, which is the latest supported version for Pulp at the time of writing. Also, note the following filesystem requirements:
<ul>
<li><kbd>/var/lib/mongodb</kbd><span>: W</span>e will build our example Pulp server with MongoDB on the same host. The MongoDB database can grow to over 10 GB in size, and it is recommended to mount this path on a dedicated LVM backed filesystem so that it can be easily grown if required, and so that if it ever does fill up, it doesn't halt the rest of the system.</li>
<li><kbd>/var/lib/pulp</kbd><span>: T</span>his directory is where the Pulp repositories are housed, and again it should be on a dedicated LVM backed filesystem. The size will be determined by the repositories you wish to create—for example, if you want to mirror a 20 GB upstream repository, then<span> </span><kbd>/var/lib/pulp</kbd><span> </span>needs to be a minimum of 20 GB in size. This filesystem also must be XFS-based—if created on <kbd>ext4</kbd>, you run the risk of running out of inodes.</li>
</ul>
</li>
<li>Once these requirements are met, we must install the EPEL repository as the Pulp install will draw packages from here:</li>
</ol>
<pre style="padding-left: 60px"><strong>$ sudo yum install epel-release</strong></pre>
<ol start="3">
<li>We then need to install the Pulp repository file:</li>
</ol>
<pre style="padding-left: 60px"><strong>$ sudo wget -O /etc/yum.repos.d/rhel-pulp.repo https://repos.fedorapeople.org/repos/pulp/pulp/rhel-pulp.repo</strong></pre>
<ol start="4">
<li>Next, we set up the MongoDB server—this must be completed before we proceed with the Pulp installation. It is expected that most enterprises will have some internal standards for the database servers that they will follow—here, we will suffice with a default installation with SSL encryption:</li>
</ol>
<pre style="padding-left: 60px"><strong>$ sudo yum install mongodb-server</strong></pre>
<ol start="5">
<li>Again, it is fair to say that most enterprises will have their own certificate authority, be it internal or otherwise. For our example server, we will generate a simple self-signed certificate with the following command:</li>
</ol>
<pre style="padding-left: 60px"><strong>$ sudo openssl req -x509 -nodes -newkey rsa:4096 -keyout /etc/ssl/mongodb-cert.key -out /etc/ssl/mongodb-cert.crt -days 3650 -subj "/C=GB/CN=pulp.example.com"</strong></pre>
<ol start="6">
<li>We then need to concatenate the private key and certificate into one file for MongoDB to pick up:</li>
</ol>
<pre style="padding-left: 60px"><strong>$ sudo cat /etc/ssl/mongodb-cert.key /etc/ssl/mongodb-cert.crt | sudo tee /etc/ssl/mongodb.pem &gt; /dev/null</strong></pre>
<ol start="7">
<li>With this complete, we must reconfigure MongoDB to pick up the newly created certificate file and enable SSL. Edit the <kbd>/etc/mongod.conf</kbd><span> </span>file and configure the following parameters (any other parameters in the file can be left at their defaults):</li>
</ol>
<pre style="padding-left: 60px"># Use ssl on configured ports<br/>sslOnNormalPorts = true<br/><br/># PEM file for ssl<br/>sslPEMKeyFile = /etc/ssl/mongodb.pem</pre>
<ol start="8">
<li>At this stage, we can now enable the MongoDB service to start on boot and start it:</li>
</ol>
<pre style="padding-left: 60px"><strong>$ sudo systemctl enable mongod.service</strong><br/><strong>$ sudo systemctl restart mongod.service</strong></pre>
<ol start="9">
<li>With our Mongo database server running, we now need to install the message bus. Again, most enterprises will have corporate standards for this and it is recommended to adhere to these where they are defined. The following example is the minimum required set of steps for a functional demo—it should not be considered fully secured, but it is functional for the sake of testing and evaluating pulp. Here, we simply install the required packages and then enable and start the services:</li>
</ol>
<pre style="padding-left: 60px"><strong>$ sudo yum install qpid-cpp-server qpid-cpp-server-linearstore</strong><br/><strong>$ sudo systemctl enable qpidd.service</strong><br/><strong>$ sudo systemctl start qpidd.service</strong></pre>
<ol start="10">
<li>With our underlying infrastructure completed, we can now install Pulp itself. The initial steps are to install the base packages:</li>
</ol>
<pre style="padding-left: 60px"><strong>$ sudo yum install pulp-server python-gofer-qpid python2-qpid qpid-tools</strong></pre>
<p style="padding-left: 60px">Pulp uses a plugin-based architecture to host the various repositories it is capable of serving. At the time of writing, Pulp is capable of hosting the following:</p>
<ul>
<li style="list-style-type: none">
<ul>
<li>RPM-based repositories (for example, CentOS, RHEL, and Fedora)</li>
<li>DEB-based repositories (for example, Debian and Ubuntu)</li>
<li>Python modules (for example, for mirroring PyPI content)</li>
<li>Puppet manifests</li>
<li>Docker images</li>
<li>OSTree content</li>
</ul>
</li>
</ul>
<p style="padding-left: 60px">Unfortunately, this chapter does not allow us space to go into all of these modules in detail—however, it is safe to say that, at a high-level, Pulp operates in the same manner across all these different technologies. Whether working with Python modules, Docker images, or RPM packages, you can create a central repository that is stable and can be version controlled to ensure an up-to-date environment can be maintained without losing control of what that environment contains. </p>
<p style="padding-left: 60px">As our use case is Pulp for serving out Linux packages, we will install the RPM- and DEB-based plugins:</p>
<pre style="padding-left: 60px"><strong>$ sudo yum install pulp-deb-plugins pulp-rpm-plugins</strong></pre>
<ol start="11">
<li>With Pulp installed, we must configure the core services. This is performed by editing<span> </span><kbd>/etc/pulp/server.conf</kbd><span>—</span>most of the default settings are fine for a simple demo such as ours—however, as we enabled SSL support on our MongoDB backend, we must tell the Pulp server we have done this and disable SSL verification as we are using self-signed certificates. The<span> </span><kbd>[database]</kbd><span> </span>section of the aforementioned file should look like this:</li>
</ol>
<pre style="padding-left: 60px">[database]<br/>ssl: true<br/>verify_ssl: false</pre>
<p style="padding-left: 60px">If you examine this file, you will see there is a great deal of configuration that can be carried out, all of which is well documented with comments. Specifically, you can customize the following sections:</p>
<ul>
<li style="list-style-type: none">
<ul>
<li><kbd>[email]</kbd><span>:</span> This is off by default but if you want your Pulp server to send email reports, you would configure this here.</li>
<li><span><kbd>[database]</kbd>: We have simply turned on SSL support in this section, but if the database was on an external server or required more advanced parameters, these would be specified here.</span></li>
<li><span><kbd>[messaging]</kbd>: For communication between different Pulp components, the default Qpid message broker requires no further configuration here, but if you are using RabbitMQ and/or have turned on authentication/SSL support, then that will need to be configured here.</span></li>
<li><span><kbd>[tasks]</kbd>: Pulp can have separate message brokers for inter-component communication and its asynchronous tasks, and the broker for the latter can be configured here. As we are using the same Qpid instance for both functions, nothing further is required for this example.</span></li>
<li><span><kbd>[server]</kbd>: This is used to configure the server's default credentials, hostname, and such.</span></li>
</ul>
</li>
</ul>
<ol start="12">
<li>Once the Pulp server is configured, we must generate the RSA key pair and CA certificate for Pulp using the following two commands:</li>
</ol>
<pre style="padding-left: 60px"><strong>$ sudo pulp-gen-key-pair</strong><br/><strong>$ sudo pulp-gen-ca-certificate</strong></pre>
<ol start="13">
<li>Pulp uses Apache to serve its HTTP(S) content, and so we must configure this. First of all, we initialize the backend database by running the following command (note it is run as the<span> </span><kbd>apache</kbd><span> </span>user):</li>
</ol>
<pre style="padding-left: 60px"><strong>$ sudo -u apache pulp-manage-db</strong></pre>
<ol start="14">
<li>If you are intending to use SSL transport with Apache, be sure to configure it to your enterprise requirements. CentOS installs a self-signed certificate for Apache SSL by default, but you may want to replace this with a certificate signed by your Enterprise CA. Also, be sure to disable the insecure SSL protocols—as a minimum, it is recommended to place the following two settings into<span> </span><kbd>/etc/httpd/conf.d/ssl.conf</kbd>:</li>
</ol>
<pre style="padding-left: 60px">SSLProtocol all -SSLv2 -SSLv3<br/><br/>SSLCipherSuite HIGH:3DES:!aNULL:!MD5:!SEED:!IDEA</pre>
<p style="padding-left: 60px">This, of course, is only a guide, and most enterprises will have their own security standards that should be adhered to here.</p>
<div class="packt_tip">As new vulnerabilities are discovered, these requirements may change. The preceding configuration is believed to be good practice at the time of writing, but could change at any time without notice. It is up to you to check any and all security-related settings for your environment.</div>
<ol start="15">
<li>With Apache configured, set it to start on boot and start it up:</li>
</ol>
<pre style="padding-left: 60px"><strong>$ sudo systemctl enable httpd.service</strong><br/><strong>$ sudo systemctl start httpd.service</strong></pre>
<ol start="16">
<li>Pulp has several other backend services that are required for it to be operational. Each of these can be configured and tuned as required, but again, for the sake of our example server, it is sufficient to enable and start each in turn:</li>
</ol>
<pre style="padding-left: 60px"><strong>$ sudo systemctl enable pulp_workers.service</strong><br/><strong>$ sudo systemctl start pulp_workers.service</strong><br/><br/><strong>$ sudo systemctl enable pulp_celerybeat.service</strong><br/><strong>$ sudo systemctl start pulp_celerybeat.service</strong><br/><br/><strong>$ sudo systemctl enable pulp_resource_manager.service</strong><br/><strong>$ sudo systemctl start pulp_resource_manager.service</strong></pre>
<ol start="17">
<li>Our final task is to install the administrative components of Pulp so that we can manage our server:</li>
</ol>
<pre style="padding-left: 60px"><strong>$ sudo yum install pulp-admin-client pulp-rpm-admin-extensions pulp-deb-admin-extensions</strong></pre>
<p class="mce-root"/>
<p class="mce-root"/>
<ol start="18">
<li>There is one final task to complete for our server. Pulp is designed to be administered remotely, and as such, it communicates over SSL to ensure the security of all transactions. Although we have created an <em>all-in-one</em> host and throughout this chapter will perform the server admin from the same host, we need to tell the Pulp admin client that we are using self-signed certificates—otherwise, SSL validation will fail. To do this, edit <kbd>/etc/pulp/admin/admin.conf</kbd>, and in the<span> </span><kbd>[server]</kbd><span> </span>section, define the following parameter:</li>
</ol>
<pre style="padding-left: 60px">verify_ssl: False</pre>
<ol start="19">
<li>Finally, we can test that our Pulp server is operational by logging in to it. Although Pulp supports multiple user accounts, and even integration with LDAP backends, a simple installation such as ours comes with one administrator account, where the username and password are both<span> </span><kbd>admin</kbd>.</li>
</ol>
<p style="padding-left: 60px">If all goes well, you should see output similar to the following and be able to query to server status (note that the output has been truncated to save space):</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/666b7da6-ad6b-40e4-933e-4021fe49b930.png"/></p>
<p>Now that we have a fully operational Pulp server, we shall demonstrate the process of creating repositories for managed stable updates and system builds using our newly built Pulp system.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Building repositories in Pulp</h1>
                </header>
            
            <article>
                
<p>Although in this chapter we will only be using a subset of the features available in Pulp, it is intended that a viable workflow is demonstrated here that showcases why you might choose Pulp to manage Enterprise repositories, rather than rolling your own solution (for example, copying packages off an ISO as we did in <a href="0c3b40ef-5f31-4fd1-b05f-d549444db163.xhtml" target="_blank">Chapter 6</a>, <em>Custom Builds with PXE Booting</em>). </p>
<p>The process for handling RPM-based package repositories and DEB-based ones is broadly similar.</p>
<p>Let's start by exploring how to create and manage RPM-based repositories.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Building RPM-based repositories in Pulp</h1>
                </header>
            
            <article>
                
<p>Although installing Pulp is quite a complex process, once it is installed, the process of managing repositories is incredibly straightforward. However, it does require a little knowledge of the repository structure for your chosen Linux distribution. Let's continue with the CentOS 7 build that we have been using as an example throughout this book. </p>
<p>The core CentOS 7 repositories are split into two—first of all, there is the<span> OS</span><span> </span>repository; this contains all of the files for the latest point release of CentOS 7—which, at the time of writing, is 7.6. This was last updated in November 2018 and will remain static until CentOS 7.7 is released. The updates for this release are then contained in a separate repository, and so to build a fully functional mirror for CentOS 7 in our Pulp server, we need to mirror both of these paths.</p>
<p>Let's start by creating a mirror of the base operating system:</p>
<ol>
<li><span>The first step is to log into the</span><span> </span><kbd>pulp-admin</kbd><span> </span><span>client, as we demonstrated at the end of the previous section. Then, from there, we run the following command to create a new repository:</span></li>
</ol>
<pre style="padding-left: 60px"><strong>$ pulp-admin rpm repo create --repo-id='centos76-os' --relative-url='centos76-os' --feed=http://mirror.centos.org/centos/7/os/x86_64/</strong></pre>
<p style="padding-left: 60px">Let's break that command down:</p>
<ul>
<li style="list-style-type: none">
<ul>
<li><kbd>rpm repo create</kbd>: This set of keywords tells the Pulp server to create a new RPM-based repository definition. Note that nothing is synchronized or published at this stage—this is simply creating metadata for a new repository.</li>
<li><kbd>--repo-id='centos76-os'</kbd>: This tells Pulp that the ID of our new repository is<span> </span><kbd>centos76-os</kbd><span>—</span>this is like a unique key and should be used to differentiate your new repository from others.</li>
<li><kbd>--relative-url='centos76-os'</kbd>: This instructs Pulp where to publish the repository—RPM-based repositories are published at<span> </span><kbd>http(s)://pulp-server-address/pulp/repos/&lt;relative-url&gt;</kbd>.</li>
<li><kbd>--feed=http://mirror.centos.org/centos/7/os/x86_64/</kbd><span>:   </span>This is the upstream location from which RPM-based content will be synchronized.</li>
</ul>
</li>
</ul>
<ol start="2">
<li>With our repository definition created, the next step is to synchronize the packages from the upstream server. This is as simple as running this command:</li>
</ol>
<pre style="padding-left: 60px"><strong>$ pulp-admin rpm repo sync run --repo-id='centos76-os'</strong></pre>
<ol start="3">
<li>This kicks off an asynchronous command that runs in the background on the server—you can check the status at any time using this command:</li>
</ol>
<pre style="padding-left: 60px"><strong>$ pulp-admin rpm repo sync status --repo-id='centos76-os'</strong></pre>
<ol start="4">
<li>Finally, once the synchronization is completed, the repository must be published—this effectively makes the synchronized content available over the Apache web server installed as part of the Pulp installation earlier:</li>
</ol>
<pre style="padding-left: 60px"><strong>$ pulp-admin rpm repo publish run --repo-id='centos76-os'</strong></pre>
<p>Now, with this completed, you have an internal snapshot of the upstream CentOS 7.6 OS repository defined by the<span> </span><kbd>--feed</kbd><span> </span>parameter, which will remain constant on our Pulp server even when CentOS 7.7 is released.</p>
<p>Now, of course, we also need updates to ensure we get the latest security patches, bug fixes, and so on. The frequency of updates of your repositories will depend upon your patching cycle, internal security policies, and so on. Hence, we will define a second repository to house the update packages.</p>
<p>We will issue an almost identical set of commands to the preceding ones to create the updates repository, only this time there are two key differences:</p>
<ul>
<li>We are using the<span> </span><kbd>/updates/</kbd><span> </span>path for the feed rather than<span> </span><kbd>/os/</kbd>.</li>
<li>We have put a date stamp into <kbd>repo-id</kbd><span> </span>and<span> </span><kbd>relative-url</kbd><span>—</span>you could, of course, adopt your own versioning scheme here—however, as this repository will be a snapshot of all CentOS 7 updates to August 7, 2019, using the date of the snapshot as an identifier is one sensible approach:</li>
</ul>
<pre style="padding-left: 60px"><strong>$ pulp-admin rpm repo create --repo-id='centos7-07aug19' --relative-url='centos7-07aug19' --feed=http://mirror.centos.org/centos/7/updates/x86_64/</strong><br/><strong>$ pulp-admin rpm repo sync run --repo-id='centos7-07aug19'</strong><br/><strong>$ pulp-admin rpm repo publish run --repo-id centos7-07aug19</strong></pre>
<p>With this run, we can then use the <kbd>pulp-admin</kbd> client to inspect the repositories and inspect the disk usage. At present, we can see that the Pulp filesystem has 33 GB used, though not all of this is for CentOS as there are other repositories on this test system. This level of usage will become important in a minute.</p>
<p>In an enterprise environment, a good practice would be to build or update a set of test CentOS 7 systems to this August 7 snapshot and perform the requisite testing on them to ensure confidence in the build. This is especially important in physical systems where kernel changes could cause issues. Once confidence has been established in this build, it becomes the baseline for all CentOS 7 systems. The great thing about this for an enterprise scenario is that all systems (provided they use the Pulp repository) will have the same versions of all packages. This, combined with good automation practices, as we have discussed throughout this book so far, brings almost Docker-like stability and platform confidence to a Linux environment.</p>
<p class="mce-root"/>
<p>Building on this scenario, suppose that overnight a critical security patch is released for CentOS 7. As important it is to apply this patch in a timely manner, it also is important to perform testing on it to ensure it doesn't break any existing services. As a result, we do not wish to update our<span> </span><kbd>centos7-07aug19</kbd><span> </span>repository mirror, as this is a known stable snapshot (in other words, we have tested it and are happy with it—it is stable within our enterprise environment).</p>
<p>If we were just using the upstream internet-facing repositories, then we would have no control over this and our CentOS 7 servers would blindly pick up the patch the next time an update was run. Equally, if we were manually building repository mirrors using a tool such as<span> </span><kbd>reposync</kbd>, we would have one of two choices. First, we could update our existing mirror, which would cost us little disk space, but would bring the same problems as using the upstream repositories (that is, all servers pick up the new patch as soon as an update is run). Alternatively, we could create a second snapshot for testing purposes. I estimated that mirroring the CentOS 7 updates on the Pulp server required approximately 16 GB of disk space and so creating a second snapshot would require around 32 GB of disk space. As time goes on, more snapshots would require more and more disk space, which is incredibly inefficient.</p>
<p>This is where Pulp really shines—not only can it create and manage RPM-based repositories in an efficient manner, but it also knows not to download packages that it already has on a sync operation and not to duplicate packages on a publish—hence, it is very efficient in terms of both bandwidth and disk usage. Due to this, we can issue the following command set to create a new snapshot of the CentOS 7 updates on August<span> </span><span>8</span><span>:</span></p>
<pre><strong>$ pulp-admin rpm repo create --repo-id='centos7-08aug19' --relative-url='centos7-08aug19' --feed=http://mirror.centos.org/centos/7/updates/x86_64/</strong><br/><strong>$ pulp-admin rpm repo sync run --repo-id='centos7-08aug19'</strong><br/><strong>$ pulp-admin rpm repo publish run --repo-id centos7-08aug19</strong></pre>
<p>You will recognize the similarity with the commands we ran earlier in this section to create the August 7, 2019 snapshot—they are, in fact, identical except for the new repository ID (<kbd>--repo-id</kbd>) and URL (<kbd>--relative-url</kbd>), which carry the new date in to differentiate it from our earlier one. This process will run as before, as shown in the following screenshot—it appears that all packages are downloaded and at this stage, there is little clue as to what goes on behind the scenes:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/35ae2ab6-0b63-4f93-a0a2-8dc28039fd0c.png" style="width:42.33em;height:21.58em;"/></p>
<p>However, let's now examine the disk usage:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/133bb03b-d5a6-47e3-a3ce-e277eb7f3a58.png" style="width:31.75em;height:3.58em;"/></p>
<p>Here, we can see that the disk usage has been rounded up to 34 GB—we would likely find the usage considerably less if we used a more fine-grained measure. In this way, Pulp allows us to create snapshots almost as we require them, without consuming vast amounts of disk space, while retaining older ones for stability purposes until new ones are proved, at which point redundant snapshots can be deleted.</p>
<p>It is worth saying in this regard that deleting a repository from Pulp does not necessarily free up disk space. The reason for this is that the package de-duplication at the backend must be careful not to delete any packages that are still required. In our example, more than 99% of the packages from our August <span>7</span><span> </span><span>snapshot are also in the </span><span>August </span><span>8</span><span> </span><span>one, and so it is important that if we delete either of these, that the other remains intact.</span></p>
<p>In Pulp, this process is called orphan recovery, and it is the very process of finding packages that no longer belong to any repository (presumably because the repository was deleted) and tidying them up.</p>
<p>Completing our current example, suppose that we tested our August <span>8</span><span> </span><span>snapshot and the updated packages in it caused problems in testing. From this, we have determined that this snapshot is not suitable for production and that we will delete it, pending creation of a new snapshot when a fix becomes available:</span></p>
<ol>
<li>First of all, we must delete the repository itself:</li>
</ol>
<pre style="padding-left: 60px"><strong>$ pulp-admin rpm repo delete --repo-id='centos7-08aug19'</strong></pre>
<p style="padding-left: 60px">This removes the repository definition and the published URL on the Apache server so that it can no longer be used.</p>
<ol start="2">
<li>To clean up any orphan packages, we can then issue the following command:</li>
</ol>
<pre style="padding-left: 60px"><strong>$ pulp-admin orphan remove --all</strong></pre>
<p style="padding-left: 60px">This command is a general cleanup that removes all orphans from across the entire Pulp server and is a good general maintenance step. However, the command can receive more fine-grained control to remove only a specific type of orphan (for example, you could clean out all orphan RPMs, but not DEB packages):</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/024a3646-89cc-40da-b766-091b2db4e84e.png" style="width:40.08em;height:22.92em;"/></p>
<ol start="3">
<li>Once this step is completed, we will see that our additional disk space used by the new snapshot has been recovered:</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img src="assets/32b4b4fd-9aa2-4f55-b0f1-d270f76b8f3e.png" style="width:43.50em;height:5.00em;"/></p>
<p>In this section, so far we have stepped through all the Pulp commands and activities manually—this has been done to provide you with a good understanding of the steps required in setting up Pulp and the accompanying repositories. In regular services, best practice would dictate that these steps ar<span>e performed with Ansible—however, there are no native Ansi</span><span>ble modules to cover all of the tasks we have performed in this chapter.</span></p>
<p>For example, the<span> </span><kbd>pulp_repo</kbd><span> </span>module (introduced to Ansible in version 2.3) is capable of creating and deleting repositories, as we have done so far in this chapter with<span> </span><kbd>pulp-admin rpm repo create</kbd>. However, it cannot perform orphan clean-up, and so this command would need to be issued using the<span> </span><kbd>shell</kbd><span> </span>or <kbd>command</kbd><span> </span>Ansible modules. Full automation with Ansible is left as an exercise for you.</p>
<p>Once our repos are set up, the final step is to put them into use on our Enterprise Linux servers, and we will cover this in the next section of this chapter.</p>
<p>First, though, we will look at some of the nuances of managing DEB packages in Pulp in contrast to RPM-based management.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Building DEB-based repositories in Pulp</h1>
                </header>
            
            <article>
                
<p>Although there are some subtle differences in the command-line structure between the RPM repository plugin for Pulp and the DEB one, the overall process is the same. As before, some prior knowledge is also required of the repository structure to create an effective mirror. In this book, we have worked with Ubuntu Server 18.04 LTS as an example, and the default repository set that is configured on this is as follows:</p>
<ul>
<li><kbd>bionic</kbd><span>:</span> This is the baseline repository for the release of Ubuntu Server 18.04 (codename Bionic Beaver), and as with the<span> </span>OS<span> </span>repository for CentOS 7, does not change following the release of the operating system</li>
<li><kbd>bionic-security</kbd><span>: </span>These are security-specific updates for the bionic operating system built post-release</li>
<li><kbd>bionic-updates</kbd><span>:</span> These are non-security updates for the bionic operating system release</li>
</ul>
<p>There are other repositories too, such as<span> </span><kbd>backports</kbd>, and in addition to the<span> </span><kbd>main</kbd><span> </span>component (which we will concern ourselves with here), there is a wide array of packages available in the<span> </span><kbd>restricted</kbd>,<span> </span><kbd>universe</kbd><span>, </span>and<span> </span><kbd>multiverse</kbd> c<span>omponents. </span>Going into greater detail about the Ubuntu repository structure is beyond the scope of this book, but suffice to say there is a wide array of documentation available on this subject. The following link is a good place to start reading about the different Ubuntu repositories you may wish to mirror: <a href="https://wiki.ubuntu.com/SecurityTeam/FAQ#Repositories_and_Updates">https://wiki.ubuntu.com/SecurityTeam/FAQ#Repositories_and_Updates</a>.</p>
<p>For now, let's suppose we are updating a minimal build of Ubuntu Server 18.04 LTS. For this, we are only interested in packages in the<span> </span><kbd>main</kbd><span> </span>component, but we do need a snapshot of all the security fixes and updates at a given point in time, just like one we had for our CentOS 7 build:</p>
<ol>
<li>First of all, having ensured we are logged in to the<span> </span><kbd>pulp-admin</kbd><span> </span>client as before, we will create a repository in Pulp for the<span> </span><kbd>main</kbd><span> </span>component and the operating system release packages:</li>
</ol>
<pre style="padding-left: 60px"><strong>$ pulp-admin deb repo create --repo-id='bionic-amd64-08aug19' --relative-url='bionic-amd64-08aug19' --feed='http://de.archive.ubuntu.com/ubuntu' --releases=bionic --components=main --architectures='amd64' --serve-http=true</strong></pre>
<p style="padding-left: 60px">As you can see, the preceding command is very similar to our RPM repository creation command. We specify <kbd>repo-id</kbd><span> </span>and<span> </span><kbd>relative-url</kbd><span> </span>in the same manner as before and specify an upstream<span> </span><kbd>feed</kbd><span> </span>URL. This time, though, we are specifying the Ubuntu<span> </span><kbd>releases</kbd>,<span> </span><kbd>components</kbd>,<span> </span>and<span> </span><kbd>architectures</kbd><span> </span>as command-line options whereas, in our CentOS 7 example, these were implicit in the URL we mirrored. In addition to these DEB-specific configuration parameters, we are now also specifying the<span> </span><kbd>--serve-http</kbd><span> </span>option. By default, Pulp serves all repository content over HTTPS only. However, owing to some limitations around package signing for DEB packages in Pulp, which will be discussed later in this chapter, we must enable the serving of repository content over plain HTTP.</p>
<div class="packt_tip">Note that, as the plural naming of the<span> </span><kbd>--releases</kbd><span> </span>option implies, more than one release may be specified here. Although this works at repository creation time, the sync process is, at the time of writing, broken, and so one separate Pulp repository must be created for each Ubuntu release we wish to mirror. This is expected to be fixed at a future date.</div>
<p style="padding-left: 60px">Having done this, we will create two more repositories for the<span> </span><kbd>security</kbd><span> </span>and<span> </span><kbd>updates</kbd><span> </span>repositories:</p>
<pre style="padding-left: 60px"><strong>$ pulp-admin deb repo create --repo-id='bionic-security-amd64-08aug19' --relative-url='bionic-security-amd64-08aug19' --feed='http://de.archive.ubuntu.com/ubuntu' --releases=bionic-security --components=main --architectures='amd64' --serve-http=true</strong><br/><br/><strong>$ pulp-admin deb repo create --repo-id='bionic-updates-amd64-08aug19' --relative-url='bionic-updates-amd64-08aug19' --feed='http://de.archive.ubuntu.com/ubuntu' --releases=bionic-updates --components=main --architectures='amd64' --serve-http=true</strong></pre>
<ol start="2">
<li>With our repository creation completed, we can run our sync processes, just like we did previously:</li>
</ol>
<pre style="padding-left: 60px"><strong>$ pulp-admin deb repo sync run --repo-id='bionic-amd64-08aug19'</strong><br/><br/><strong>$ pulp-admin deb repo sync run --repo-id='bionic-security-amd64-08aug19'</strong><br/><br/><strong>$ pulp-admin deb repo sync run --repo-id='bionic-updates-amd64-08aug19'</strong></pre>
<ol start="3">
<li>Finally, we publish the repositories:</li>
</ol>
<pre style="padding-left: 60px"><strong>$ pulp-admin deb repo publish run --repo-id='bionic-amd64-08aug19'</strong><br/><br/><strong>$ pulp-admin deb repo publish run --repo-id='bionic-security-amd64-08aug19'</strong><br/><br/><strong>$ pulp-admin deb repo publish run --repo-id='bionic-updates-amd64-08aug19'</strong></pre>
<p>It is worth noting that Ubuntu repositories tend to be much larger than their CentOS counterparts, especially the<span> </span><kbd>updates</kbd><span> </span>and<span> </span><kbd>security</kbd><span> </span>ones. During the sync process, the packages are downloaded into<span> </span><kbd>/var/cache/pulp</kbd><span> </span>temporarily before they are archived into the<span> </span><kbd>/var/lib/pulp</kbd><span> </span>directory. If<span> </span><kbd>/var/cache/pulp</kbd><span> </span>is on your root filesystem, there is a significant danger of your root filesystem filling up, and as such, it may be best to create a new volume for this purpose and mount at<span> </span><kbd>/var/cache/pulp</kbd><span> </span>to prevent a disk full situation from stopping your Pulp server.</p>
<p>The DEB plugin for Pulp features the same package deduplication as its RPM counterpart and publishes packages over HTTPS (and optionally HTTP) in the same manner. With a few changes to the syntax of the commands, we can effectively create snapshots of upstream Linux repositories for most of the major distributions that are found in enterprise environments.</p>
<p>As a result of completing this section, you have learned how to create your own repository mirrors for both RPM- and DEB-based content in Pulp, which may be treated as stable and unchanging and hence provide an excellent basis for patch management in an enterprise.</p>
<p>In the next section of this chapter, we will look at how to deploy these repositories to two different types of Linux server.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Patching processes with Pulp</h1>
                </header>
            
            <article>
                
<p>It is worth mentioning at the outset of this section that Pulp supports two main methods for the distribution of packages from the repositories created within it. The first is a kind of push-based distribution that uses something called the <strong>Pulp Consumer</strong>.</p>
<p>We will not be exploring this in this chapter for the following reasons:</p>
<ul>
<li>The Pulp Consumer only works with RPM-based repositories and distributions, and at the time of writing, there is no equivalent client available for Ubuntu or Debian. This means that our processes cannot be uniform across the enterprise, which, in an ideal world, they would be.</li>
<li>Using the Pulp Consumer means we would have two overlapping means of automation. Distributing packages to nodes using the consumer is a task that can be performed with Ansible, and if we use Ansible for this task, then we have an approach that is common across all of our platforms. This supports the principles of automation in an enterprise context that we established earlier in this book around lowering barriers to entry, ease of use, and so on.</li>
</ul>
<p>As such, we will build out separate Ansible-based examples for managing repositories and updates using the repositories we created in the previous section, entitled <em>Building repositories in Pulp</em>. These can be managed along with all the other Ansible playbooks and can be run through a platform such as AWX to ensure a single pane of glass is used wherever possible for all tasks.</p>
<p>Let's get started by looking at how to patch RPM-based systems using a combination of Ansible and Pulp.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">RPM-based patching with Pulp</h1>
                </header>
            
            <article>
                
<p>In the previous section of this chapter, we created two repositories for our CentOS 7 build—one for the operating system release and another to contain the updates.</p>
<p>The process of updating a CentOS 7 build from these repositories is, at a high level, done as follows:</p>
<ol>
<li>Move aside any existing repository definitions in<span> </span><kbd>/etc/yum.repos.d</kbd><span> </span>to ensure we only load repositories from the Pulp server.</li>
<li>Deploy the appropriate configuration using Ansible.</li>
<li>Employ Ansible to pull the updates (or any required packages) from the Pulp server using the new configuration.</li>
</ol>
<p>Before we proceed with creating the appropriate playbooks, let's take a look at what the repository definition file would look like on our CentOS 7 machine if we created it by hand. Ideally, we want it to look something like this:</p>
<pre>[centos-os]<br/>name=CentOS-os<br/>baseurl=https://pulp.example.com/pulp/repos/centos76-os<br/>gpgcheck=1<br/>gpgkey=file:///etc/pki/rpm-gpg/RPM-GPG-KEY-CentOS-7<br/>sslverify=0<br/><br/>[centos-updates]<br/>name=CentOS-updates<br/>baseurl=https://pulp.example.com/pulp/repos/centos7-07aug19<br/>gpgcheck=1<br/>gpgkey=file:///etc/pki/rpm-gpg/RPM-GPG-KEY-CentOS-7<br/>sslverify=0</pre>
<p>There's nothing particularly unique about this configuration—we are using the <kbd>relative-url</kbd><span> </span>we created earlier with our repository using<span> </span><kbd>pulp-admin</kbd>. We are using GPG checking of package integrity, along with the CentOS 7 RPM GPG key, which we know will already be installed on our CentOS 7 machine. The only tweak we've had to make to this otherwise standard configuration is to turn off SSL verification since our demo Pulp server features a self-signed certificate. Of course, if we are using an enterprise certificate authority and the CA certificates are installed on each machine, then this problem goes away.</p>
<p>Given the power of Ansible, we can be a bit clever about how we do this. There's no point creating and deploying static configuration files when we know that, at some point, we're going to update the repository—meaning, at the very least, that <kbd>baseurl</kbd><span> </span>might change.</p>
<p class="mce-root"/>
<p class="mce-root"/>
<p>Let's start off by creating a role called<span> </span><kbd>pulpconfig</kbd><span> </span>to deploy the correct configuration<span>—</span><kbd>tasks/main.yml</kbd><span> </span>should look like this:</p>
<pre>---<br/>- name: Create a directory to back up any existing REPO configuration<br/>  file:<br/>    path: /etc/yum.repos.d/originalconfig<br/>    state: directory<br/><br/>- name: Move aside any existing REPO configuration<br/>  shell: mv /etc/yum.repos.d/*.repo /etc/yum.repos.d/originalconfig<br/><br/>- name: Copy across and populate Pulp templated config<br/>  template:<br/>    src: templates/centos-pulp.repo.j2<br/>    dest: /etc/yum.repos.d/centos-pulp.repo<br/>    owner: root<br/>    group: wheel<br/><br/>- name: Clean out yum database<br/>  shell: "yum clean all"</pre>
<p>The accompanying<span> </span><kbd>templates/centos-pulp.repo.j2</kbd><span> template </span>should look like this:</p>
<pre>[centos-os]<br/>name=CentOS-os<br/>baseurl=https://pulp.example.com/pulp/repos/{{ centos_os_relurl }}<br/>gpgcheck=1<br/>gpgkey=file:///etc/pki/rpm-gpg/RPM-GPG-KEY-CentOS-7<br/>sslverify=0<br/><br/>[centos-updates]<br/>name=CentOS-updates<br/>baseurl=https://pulp.example.com/pulp/repos/{{ centos_updates_relurl }}<br/>gpgcheck=1<br/>gpgkey=file:///etc/pki/rpm-gpg/RPM-GPG-KEY-CentOS-7<br/>sslverify=0</pre>
<p>Notice the variable substitutions at the end of each of the<span> </span><kbd>baseurl</kbd><span> </span>lines—these allow us to keep the same template (which should be common for most purposes) but change the repository URL over time to adapt to updates.</p>
<p>Next, we will define a second role specifically for updating the kernel—this will be very simple for our example and <kbd>tasks/main.yml</kbd><span> </span>will contain the following:</p>
<pre>---<br/>- name: Update the kernel<br/>  yum:<br/>    name: kernel<br/>    state: latest</pre>
<p>Finally, we will define <kbd>site.yml</kbd><span> </span>at the top level of the playbook structure to pull all of this together. We could, as we discussed previously, define the variables for the relative URLs in a whole host of places, but for the sake of this example, we will put them in the<span> </span><kbd>site.yml</kbd><span> </span>playbook itself:</p>
<pre>---<br/>- name: Install Pulp repos and update kernel<br/>  hosts: all<br/>  become: yes<br/>  vars:<br/>    centos_os_relurl: "centos76-os"<br/>    centos_updates_relurl: "centos7-07aug19"<br/><br/>  roles:<br/>    - pulpconfig<br/>    - updatekernel</pre>
<p>Now, if we run this in the usual manner, we will see output similar to the following:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/3ca9b23c-7687-4ddf-b54d-6a6039dab28f.png" style="width:32.42em;height:28.08em;"/></p>
<p>So far, so good—the <kbd>changed</kbd> statuses from the preceding play tell us that the new configuration was applied successfully.</p>
<div class="packt_tip">Those with a keen eye will have observed the warning on the <kbd>Clean out yum database</kbd> tasks—Ansible detects when a raw shell command is being used that has overlapping functionality with a module and recommends that you use the module instead for reasons of repeatability and idempotency, as we discussed earlier. However, as we want to ensure all traces of any earlier <kbd>yum</kbd> databases are removed (which can present problems), I have adopted a <em>brute force</em> method here to clean up the old databases.</div>
<p>Now, as I'm sure you will have spotted, the great thing about this approach is that if, say, we want to test our<span> </span><kbd>08aug19</kbd><span> </span>repository snapshot that we created in the previous section, all we have to do is modify the<span> </span><kbd>vars:</kbd><span> </span>block of<span> </span><kbd>site.yml</kbd><span> </span>so that it looks like this:</p>
<pre>  vars:<br/>    centos_os_relurl: "centos76-os"<br/>    centos_updates_relurl: "centos7-08aug19"</pre>
<p>Hence, we can reuse the same playbook, roles, and templates in a variety of scenarios simply by changing one or two variable values. In an environment such as AWX, these variables could even be overridden using the GUI, making the whole process even easier.</p>
<p>In this way, combining Ansible with Pulp lends itself to a really stable enterprise framework for managing and distributing (and even testing) updates. However, before we look at this process on Ubuntu, a word on rollbacks. In the previous section, we hypothesized an example where our<span> </span><kbd>08aug19</kbd><span> </span>snapshot failed testing and so had to be deleted. As far as CentOS 7 servers are concerned, rollbacks are not as straightforward as simply installing the earlier repository definitions and performing an update since the update will detect newer packages that have been installed and take no action. </p>
<p>The Pulp repository does, of course, provide a stable base to roll back to—however, rollbacks are generally quite a manual process as you must identify the transaction ID in the <kbd>yum</kbd> database that you want to roll back to and validate the actions to be performed and then roll back to it. This, of course, can be automated, provided you have a reliable way of retrieving the transaction ID.</p>
<p>The following screenshot shows a simple example of identifying the transaction ID for the kernel update we just automated and establishing the details of the change that was performed:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/23b9467c-1cc1-453c-9f97-a11cf42a8071.png"/></p>
<p>Then, we can (if we so choose) roll back the transaction using the command shown in the following screenshot:</p>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="CDPAlignCenter CDPAlign"><img src="assets/b2a07d83-c7b1-4c53-a864-4f904ba65b1e.png" style="width:52.75em;height:48.33em;"/></p>
<p>Using this simple process and the playbooks offered here as a guide, it should be possible to establish a solid, stable, automated update platform for any RPM-based Linux distribution.</p>
<p>In the next section, we will look at the method we can use to perform the same set of tasks, except for DEB-based systems such as Ubuntu.</p>
<p class="mce-root"/>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">DEB-based patching with Pulp</h1>
                </header>
            
            <article>
                
<p>At a high level, the process of managing updates on Ubuntu from our Pulp server is exactly the same as it is for managing the RPM based updates for CentOS (save for the fact that we have no option regarding the use of the Pulp Consumer and must use Ansible for the update process).</p>
<p>There are, however, a couple of limitations when it comes to the use of Pulp with Ubuntu's APT repository system:</p>
<ul>
<li>At the time of writing, there is an issue whereby the Pulp sync process does not mirror the signing keys from the upstream Ubuntu repository. This means that even though the upstream repository features <kbd>Release.gpg</kbd>, it is not mirrored on the Pulp server. Hopefully, in the future, this will be fixed, but in this chapter, we will work around this by adding implicit trust to the packages.</li>
<li>HTTPS support on Ubuntu is configured not to accept updates from unverifiable (that is, self-signed) certificates by default. Although we can turn off SSL verification as we did on CentOS, Ubuntu's APT package manager then goes in search of an<span> </span><kbd>InRelease</kbd><span> </span>file (which should have the aforementioned GPG key embedded). As we discussed in the previous point, the Pulp DEB plugin does not support the signing of mirrored repositories, and so right now, the only workaround for this is to use unencrypted HTTP traffic. Hopefully, in a future release, these two issues will be fixed—however, at the time of writing, there appears to be no documented fix or workaround for them.</li>
</ul>
<p>With these two limitations understood, we can define our APT sources file for the repository set we created earlier. Following on from the examples in the previous section, our<span> </span><kbd>/etc/apt/sources.list</kbd><span> </span>file could look like this:</p>
<pre>deb [trusted=yes] http://pulp.example.com/pulp/deb/bionic-amd64-08aug19 bionic main<br/>deb [trusted=yes] http://pulp.example.com/pulp/deb/bionic-security-amd64-08aug19 bionic-security main<br/>deb [trusted=yes] http://pulp.example.com/pulp/deb/bionic-updates-amd64-08aug19 bionic-updates main</pre>
<p class="mce-root"/>
<p>The<span> </span><kbd>[trusted=yes]</kbd><span> </span>string tells the APT package manager to ignore the lack of package signing. The file structure itself is incredibly simple, and so just as with our CentOS example, we can create a template file so that the relative URL can be populated using a variable:</p>
<ol>
<li>First, we'll create a role called<span> </span><kbd>pulpconfig</kbd> and create the following<span> </span><kbd>templates/sources.list.j2</kbd> template:</li>
</ol>
<pre style="padding-left: 60px">deb [trusted=yes] http://pulp.example.com/pulp/deb/{{ ubuntu_os_relurl }} bionic main<br/>deb [trusted=yes] http://pulp.example.com/pulp/deb/{{ ubuntu_security_relurl }} bionic-security main<br/>deb [trusted=yes] http://pulp.example.com/pulp/deb/{{ ubuntu_updates_relurl }} bionic-updates main</pre>
<ol start="2">
<li>Then, we will create some tasks with the role to install this template and move aside any old configuration for APT:</li>
</ol>
<pre style="padding-left: 60px">---<br/>- name: Create a directory to back up any existing REPO configuration<br/>  file:<br/>    path: /etc/apt/originalconfig<br/>    state: directory<br/><br/>- name: Move existing config into backup directory<br/>  shell: mv /etc/apt/sources.list /etc/apt/originalconfig<br/><br/>- name: Copy across and populate Pulp templated config<br/>  template:<br/>    src: templates/sources.list.j2<br/>    dest: /etc/apt/sources.list<br/>    owner: root<br/>    group: root<br/><br/>- name: Clean out dpkg database<br/>  shell: "apt-get clean"</pre>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mceNonEditable"/>
<p class="mceNonEditable"/>
<ol start="3">
<li>Finally, we will define a role to update the kernel, but this time using APT:</li>
</ol>
<pre style="padding-left: 60px">---<br/>- name: Update the kernel<br/>  apt:<br/>    name: linux-generic<br/>    state: latest</pre>
<p class="mce-root"/>
<ol start="4">
<li>Our<span> </span><kbd>site.yml</kbd><span> playbook </span>for Ubuntu systems now looks like this—save for the variable differences, it is almost identical to the CentOS 7 one, once again highlighting the value in using Ansible as an automation platform:</li>
</ol>
<pre style="padding-left: 60px">---<br/>- name: Install Pulp repos and update kernel<br/>  hosts: all<br/>  become: yes<br/>  vars:<br/>    ubuntu_os_relurl: "bionic-amd64-08aug19"<br/>    ubuntu_security_relurl: "bionic-security-amd64-08aug19"<br/>    ubuntu_updates_relurl: "bionic-updates-amd64-08aug19"<br/><br/>  roles:<br/>    - pulpconfig<br/>    - updatekernel</pre>
<ol start="5">
<li>Now, after putting this all together and running it, we should see output similar to what can be seen in the following screenshot:</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img src="assets/866e4066-b61c-493e-a2ad-59507ea55947.png" style="width:50.17em;height:44.08em;"/></p>
<p>Putting aside the security limitations present in the current Pulp Debian support, this provides a neat space-efficient solution for managing Ubuntu updates across an enterprise infrastructure in a manner that is repeatable and lends itself well to automation. As with our earlier CentOS-based example, it would be very easy to test packages from a new snapshot by simply changing the variable definitions passed to our roles.</p>
<p>As with CentOS, should a new package set not be suitable for production use, Ansible makes it easy to restore the previous repository configuration. However, rolling back packages on Ubuntu (and other Debian-based distributions) is a much more manual process than we saw in the previous section. Fortunately, there is a great deal of history regarding package transactions kept in<span> </span><kbd>/var/log/dpkg.log</kbd><span> </span>and<span> </span><kbd>/var/log/apt/history.log*</kbd><span>, </span>which can be used to determine which packages were installed and/or upgraded and when. The<span> </span><kbd>apt-get</kbd><span> </span>command can then be used to install a specific version of a package using the <kbd>apt-get install &lt;packagename&gt;=&lt;version&gt;</kbd> syntax. There are many elegant scripted solutions to this problem on the internet, and so it is left as an exercise for you to determine the one best suited to your needs and environment.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Summary</h1>
                </header>
            
            <article>
                
<p>Managing package repositories in an enterprise setting can present numerous challenges, especially when it comes to efficient storage, conservation of internet bandwidth, and ensuring build consistency. Fortunately, the Pulp software package provides an elegant solution to these challenges for most of the common Linux distributions and lends itself well to effective management in the enterprise.</p>
<p>In this chapter, you learned how to install Pulp to begin patching an Enterprise Linux environment. You then learned how to build repositories in Pulp for both RPM-based and DEB-based Linux distributions through hands-on examples, before gaining practical knowledge of deploying the appropriate Pulp configuration and updating packages using Ansible.</p>
<p>In the next chapter, we will explore how the Katello software tools complement Pulp in enterprise environment management.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Questions</h1>
                </header>
            
            <article>
                
<ol>
<li>Why would you want to create a repository with Pulp rather than just a simple mirror of files that you could download manually?</li>
<li>What are the issues around building and testing Linux patch repositories in an enterprise environment?</li>
<li>What components does Pulp need to run?</li>
<li>Specify the filesystem requirements for successfully installing Pulp.</li>
<li>How would you patch an RPM-based system from a Pulp repository you created previously?</li>
<li>Why would you use Ansible to deploy patches from a Pulp repository rather than the Pulp Consumer?</li>
<li>Does the removal of a Pulp repository free up disk space? If not, how is this performed?</li>
</ol>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Further reading</h1>
                </header>
            
            <article>
                
<ul>
<li>For more in-depth details on the Pulp project and how to make use of this tool, please refer to the official documentation (<a href="https://pulpproject.org/">https://pulpproject.org/</a>).</li>
</ul>


            </article>

            
        </section>
    </body></html>