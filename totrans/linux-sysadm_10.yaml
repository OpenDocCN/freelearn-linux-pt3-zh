- en: '10'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Storage Management
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: It feels like there’s never going to be enough space on our servers for everything
    that needs to be stored there. Despite the fact that the storage capacity of hard
    disks continues to increase and high-capacity disks are now more affordable than
    ever, our servers quickly fill up any available space. Our best efforts as server
    administrators have always been to order machines with as much storage as possible,
    but the reality is that even the most well-planned enterprises eventually run
    out of space. Additional storage space will certainly need to be added at some
    point in the course of administering your servers. Storage management, however,
    entails more than simply replacing full disks with empty ones. **Logical Volume
    Manager** (**LVM**) and other similar technologies can greatly simplify your work
    if you start using them as soon as possible, thus it’s crucial to plan ahead.
  prefs: []
  type: TYPE_NORMAL
- en: 'The concepts discussed in this chapter, including LVM itself, will allow you
    greater freedom in the management of servers. I will also explain some other ideas
    that will prove useful when you work with volumes and storage on your server.
    In particular, the following topics will be covered:'
  prefs: []
  type: TYPE_NORMAL
- en: Creating new volumes in a filesystem
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to format and partition storage devices
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to mount and unmount volumes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Learning how to use a `/``etc/fstab` file
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Working with **Logical Volume** **Manager** (**LVM**)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding additional storage volumes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Additional server storage space will likely be required at some time. The capacity
    of a server can be expanded by installing more hard drives, either on a standalone
    machine or by using cloud computing. Whatever its name may be, we’ll need to find
    out how to format and mount the device before we can use the additional space.
  prefs: []
  type: TYPE_NORMAL
- en: 'Using LVM (which we will cover later in this chapter), we can easily add space
    to an existing volume without restarting the server. However, there is an overarching
    procedure that must be followed when introducing a new device. The following are
    a few things to consider while upgrading your system’s storage capacity:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Can you tell me how much space you’ll need?** If there is enough free space
    in your hypervisor’s storage pool, you can create a virtual disk of any size you
    like.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`/``dev/sdb1`, `/dev/sdb2`).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**What format do you want for your device?** At present, ext4 is the most widely
    used filesystem. However, there are additional choices you might make for various
    tasks (such as XFS). Use ext4 if you’re unsure, but research the alternatives
    to see if any better suit your needs. ZFS is an additional possibility; however,
    it is more recent than many of the other filesystems out there. You may know this
    already, but new Linux users may be confused by the fact that the term *filesystem*
    has many meanings, depending on the situation. When discussing the file and directory
    structure of a normal Linux system, we Linux administrators will most often use
    the term *filesystem*. On the other hand, the phrase can also refer to the format
    of a disk that is compatible with the distribution (for example, the ext4 filesystem).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Where do you want it mounted?** Since the new disk must be reachable by the
    system and possibly users, you must mount (attach) it to a directory on your filesystem
    from which users or applications can access it. In this chapter, we also cover
    LVM, and in most cases, you’ll want to add it to an existing storage group. The
    new volume can be used with any directory you like, but I’ll go over some typical
    ones in the *Formatting and partitioning storage devices* section. In the *Mounting
    and unmounting volumes* section, we will discuss the mounting and unmounting processes
    in detail.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let’s think about the responses to the first two queries. To determine how much
    more room you should implement, you should analyze your program’s or company’s
    requirements. When it comes to actual disks, your options are limited to which
    disk to buy. With virtual drives, you can be more thrifty by adding a smaller
    disk to serve your needs (you can always add more later). The primary advantage
    of using LVM with virtual drives is the ability to increase a filesystem without
    restarting the server. If you have a 50 GB volume and want to make it larger,
    you can create two more 10 GB virtual disks and enlarge it that way.
  prefs: []
  type: TYPE_NORMAL
- en: 'While LVM is not limited to virtual servers, it can be used on physical servers
    as well; however, doing so would likely necessitate a reboot due to the need to
    open the casing and physically attach a hard drive. The ability to add or remove
    physical hard disks from some servers is called `fdisk -l` into a terminal. We
    can find out what our new disk is called by using the `fdisk` command, which is
    more commonly used to create and erase partitions. If you run the `fdisk -l` command
    as `root` or with `sudo`, you’ll get the following details:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: '![Figure 10.1 – Listing all disks](img/B18575_10_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10.1 – Listing all disks
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have learned how to list all the disks, we will next learn how to
    format and partition storage devices.
  prefs: []
  type: TYPE_NORMAL
- en: Formatting and partitioning storage devices
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A disk must be formatted before it can be used. Finding the device’s given
    name is necessary to format the right disk. If you read the last section, you
    know that drives in Linux distributions follow a predetermined naming convention.
    Consequently, you should be familiar with the new disk’s device name. You can
    view information about the storage devices connected to your server using the
    `sudo fdisk -l` command, as previously mentioned:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: '![Figure 10.2 – Listing all disks](img/B18575_10_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10.2 – Listing all disks
  prefs: []
  type: TYPE_NORMAL
- en: The `/dev/sdb` device is new to my server, as I just installed it (see *Figure
    10**.2*). I’m using it for the exercises in this chapter. Currently, it is not
    partitioned. At this point, it’s quite clear that the storage device referenced
    by `/dev/sdb` in the previous example is brand new. To avoid losing data, we must
    be careful never to format or repartition the wrong device. Since there are no
    partitions on `/dev/sdb` (as this volume wasn’t there before I added it), it’s
    evident that this is the disk we should work with. One or more partitions can
    be made on it at this point, bringing us one step closer to actually using it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Using the `fdisk` command with `sudo` and the device’s name as an option, we
    can partition the drive. The following is the command I would use to access disk
    `/dev/sdb`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: You’ll see that I didn’t specify a partition number because `fdisk` deals with
    the disk directly (and we also have yet to create any partitions). In this section,
    I will assume that you have access to a drive that hasn’t been partitioned yet
    or is completely erasable. Upon successful execution, `fdisk` will display an
    introductory message and prompt.
  prefs: []
  type: TYPE_NORMAL
- en: 'To see a list of available commands, use the `m` key on your keyboard, as shown
    in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.3 – Help menu for fdisk](img/B18575_10_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10.3 – Help menu for fdisk
  prefs: []
  type: TYPE_NORMAL
- en: 'Here, I will demonstrate the sequence of steps necessary to create a new disk.
    Understand that `fdisk` can do serious damage to your system. Using `fdisk` on
    the wrong drive can cause permanent data loss. It’s normal for administrators
    to internalize the use of tools such as`fdisk` to the point where it’s second
    nature; however, before executing any such instructions, double-check that you’re
    indeed accessing the correct disk. There are two types of partition tables – the
    `fdisk`. There are restrictions to think about when using MBR partition tables.
    To begin with, there is a limit of four primary partitions in MBR. It also restricts
    your disk use to about 2 TB. As long as your disk is under 2 TB in size, you should
    be fine, but disks greater than 2 TB are becoming increasingly prevalent. However,
    GPT doesn’t limit partition sizes, so if you have a disk that’s many TB in size,
    the choice between MBR and GPT is already made for you. In addition, `fdisk` with
    a GPT partition table allows you to construct up to 128 primary partitions. The
    following command gives options on what to do with the specific HDD, `/dev/sdb`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.4 – Creating a new partition](img/B18575_10_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10.4 – Creating a new partition
  prefs: []
  type: TYPE_NORMAL
- en: 'I used GPT, so I had to enter `g`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.5 – Creating a new GPT partition table](img/B18575_10_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10.5 – Creating a new GPT partition table
  prefs: []
  type: TYPE_NORMAL
- en: Don’t forget to enter `w` to save changes.
  prefs: []
  type: TYPE_NORMAL
- en: If you made any mistakes, you can run `fdisk` again. After entering the `fdisk`
    prompt again, you can construct a new GPT layout by hitting `g`, or a new MBR
    layout by typing `o` if you made a mistake or simply wish to start over. Partitioning
    your drive is a two-step process, so you’ll need to repeat the previous stages.
    You can try this out for yourself a few times until you get the hang of it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, using `fdisk -l /dev/sdb`, we can see there is a new partition, `/dev/sdb2`,
    as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.6 – Listing the partitions for /dev/sdb HDD](img/B18575_10_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10.6 – Listing the partitions for /dev/sdb HDD
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have learned how to create a new partition, we will see how to format
    it.
  prefs: []
  type: TYPE_NORMAL
- en: Formatting a newly created partition
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Your new partition can be formatted once you’ve finished designing the disk’s
    partition arrangement and are satisfied with it. The results of `sudo fdisk -l`
    will be different now that I have partitioned the new drive.
  prefs: []
  type: TYPE_NORMAL
- en: 'A new partition, `/dev/sdb2`, has been created and is reflected in the output.
    We can proceed with the formatting at this time. The `mkfs` command is used to
    create the filesystem. In order to execute this operation, you must use the correct
    syntax, which consists of entering `mkfs`, followed by a period (`.`), and then
    the name of the filesystem you wish to create. Using this code as an example,
    we can format `/dev/sdb2` as `ext4` by running the `sudo mkfs.ext4 /``dev/sdb2`
    command:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.7 – Formatting a partition](img/B18575_10_07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10.7 – Formatting a partition
  prefs: []
  type: TYPE_NORMAL
- en: It is important to remember to format the partition; otherwise, it won’t be
    usable.
  prefs: []
  type: TYPE_NORMAL
- en: Mounting and unmounting volumes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The next step after adding and formatting a new storage volume on your server
    is mounting the device. The `mount` command accomplishes this task. With this
    command, you can link a removable drive (or a network share) to a directory on
    the server’s hard drive. Mounting requires a clean directory. In order to mount
    a device, you must specify a directory to mount it to by using the `mount` command,
    which we will practice with an example shortly. Mounting additional storage is
    as simple as issuing the `mount` command and selecting a location that isn’t currently
    mounted or full of data. `mount` is a command that normally requires root privileges
    to execute. However, in most cases, only the root should mount volumes (although
    there is a workaround that involves allowing regular users to mount volumes; we
    won’t discuss that right now). Since you need a directory in which to mount these
    volumes, I’ll show you how to make one called `/usbpartition` using the following
    command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'With the preceding command, I mount the `/dev/sdb2` device to the `/usbpartition`
    directory as an example. Obviously, you’ll need to change the `/dev/sdb2` and
    `/usbpartition` references to reflect your own device and directory choices. A
    mount normally requires the `-t` option to specify the device type, but `fdisk
    -l` can be used as a handy reminder if you’ve forgotten what devices are installed
    on your server. The `mount` command that I should have used with the `-t` option,
    given that my disk is ext4-formatted, is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'To check whether this has been mounted properly, use this command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'If you’re done working with a volume, you can unmount it with the `umount`
    command (the *n* in *unmount* is left out on purpose):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: It is possible to remove a storage device from your filesystem using the `umount`
    command, which also requires you to be logged in as root or with `sudo`. The volume
    must be turned off for this command to take effect. A device or resource busy
    error message may appear if this is the case. After unmounting, you can verify
    that the filesystem is no longer mounted by running `df -h` and noting that it
    does not return any results. When devices are manually mounted, they will unmount
    when the server reboots. I will show you how to update the `/etc/fstab` file so
    that the mount is available at server startup in the following section.
  prefs: []
  type: TYPE_NORMAL
- en: Updating the /etc/fstab file
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: An essential Linux system file is the `/etc/fstab` file. You can manually mount
    additional volumes at boot time by editing this file. However, this file’s primary
    function is to mount your primary filesystem, thus any mistakes you make while
    modifying it will prevent your server from starting up (at all). Take extreme
    caution.
  prefs: []
  type: TYPE_NORMAL
- en: The location of the root filesystem is determined by reading the `/etc/fstab`
    file, which is read during system boot. This file is also used to determine the
    swap partition’s location, and it is mounted at boot time. Each mount point in
    this file will be read and mounted sequentially by your system. This file can
    be used to automatically mount almost any type of storage device. You can even
    install Windows server network shares. In other words, it has no morals and won’t
    pass judgment (unless you make a typo).
  prefs: []
  type: TYPE_NORMAL
- en: 'This is what an `/etc/fstab` file looks like:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.8 – A sample of an /etc/fstab file](img/B18575_10_08.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10.8 – A sample of an /etc/fstab file
  prefs: []
  type: TYPE_NORMAL
- en: It is important to be careful when editing this file, as incorrect settings
    can cause the system to fail to boot or cause data loss. It is recommended to
    make a backup of the file before making any changes.
  prefs: []
  type: TYPE_NORMAL
- en: Editing /etc/fstab file
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As we mentioned earlier, any device mounted manually won’t be mounted automatically
    on reboot.
  prefs: []
  type: TYPE_NORMAL
- en: In order to do it automatically, the device has to be added to the `/``etc/fstab`
    file.
  prefs: []
  type: TYPE_NORMAL
- en: 'I added an entry in `/etc/fstab` to mount `/dev/sdb2` automatically in `/usbpartition/`
    on boot, as shown in the last line of the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.9 – A sample of the /etc/fstab file](img/B18575_10_09.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10.9 – A sample of the /etc/fstab file
  prefs: []
  type: TYPE_NORMAL
- en: On my machine, both the fifth and sixth columns read `0`, indicating a successful
    dump and a passing grade. Nearly invariably set to `0`, the dump partition can
    be checked by a backup program to see whether the filesystem needs to be backed
    up (`0` for no, and `1` for yes). Since almost nothing uses this anymore, you
    can usually just leave it at `0`. Filesystems will be checked in the order specified
    in the pass field. In the event of a system crash or as part of a routine maintenance
    procedure, the `fsck` utility checks drives for filesystem problems. Values can
    be either a `0` or a `1`. When set to `0`, `fsck` will never run to check on the
    partition. If this value is `1`, the partition is examined before anything else.
  prefs: []
  type: TYPE_NORMAL
- en: By default, only the root user can modify the `/etc/fstab` file, so it’s important
    to be careful when editing it. Incorrectly modifying this file can cause serious
    problems with the system’s boot process and data integrity.
  prefs: []
  type: TYPE_NORMAL
- en: Utilizing LVM
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Your organization’s requirements will evolve over time. As server administrators,
    we constantly strive to set up resources with future expansion in mind. Unfortunately,
    budgets and policy shifts frequently get in the way. You’ll find that LVM is invaluable
    in the long run. Linux’s superiority in scalability and cloud deployments is due
    in large part to technologies such as LVM. By using LVM, you can expand or contract
    your filesystems without having to restart the server. Consider the following
    scenario. Say you have a mission-critical app operating on a virtualized production
    server. It’s possible that when you initially set up the server, you allocated
    300 GB of space for the application’s data directory, thinking it would never
    grow to fill that much space. The expansion of your company has not only increased
    your space requirements but also created a crisis. So, tell me, what do you do?
    If the server was initially configured to use LVM, then adding a new storage volume,
    including it in the LVM pool, and expanding the partition would not require a
    reboot. However, without LVM, you’d have to schedule downtime for your server
    while you added more storage the old-fashioned way, which could take hours. Even
    if your server isn’t virtual, you can still profit from expanding your filesystem
    online by installing more hard drives and leaving them on standby without using
    them. In addition, you can add more volumes without having to shut down the server
    if your server supports hot-plugging. Because of this, I can’t stress enough how
    important it is to use LVM whenever possible on storage volumes in virtual servers.
    Again, LVM is essential to set up storage volumes on a virtual server. If you
    don’t, you’ll have to spend your weekends laboring to add disks, since you will
    have ran out of space during the week.
  prefs: []
  type: TYPE_NORMAL
- en: Getting started with LVM
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Linux’s server installer allows you to select LVM as a volume manager for a
    fresh server setup. However, LVM should be utilized extensively for storage volumes,
    especially those that will house user and application data. If you want the root
    filesystem on your Ubuntu server to take advantage of LVM’s functionality, LVM
    is a good option. We’ll need to have a firm grasp on volume groups, physical volumes,
    and logical volumes before we can begin using LVM. The logical and physical volumes
    you intend to use with an LVM solution are organized into volume groups. In a
    nutshell, a volume group is the umbrella term for your whole LVM infrastructure.
    You can think of it as a container that can hold disks. A `vg-accounting` volume
    group is an illustration of this type of group. The accounting department would
    use this volume group to store their records. It will include both the actual
    disk space and the virtual disk space that these users will access. It’s worth
    noting that you’re not restricted to a single volume group but can instead create
    multiple, each with its own set of disks and volumes. A physical volume is a disk,
    either real or virtual, that belongs to a volume group. A `vg-accounting` volume
    group might theoretically have three 500 GB hard drives, each of which would be
    treated as a physical volume. Keep in mind that, although these disks are virtual,
    in the context of LVM they are still referred to as physical volumes. A physical
    volume is a storage device that belongs to a volume group. Finally, the concept
    of logical volumes is comparable to that of partitions. In contrast to traditional
    partitions, logical volumes can span over numerous physical drives. A logical
    volume, for instance, may be set up with three 500 GB disks, giving you access
    to a total of 1,500 GB. When it’s mounted, it acts like a single partition on
    a regular hard drive, allowing users to save and access files with the same ease
    as they would with any other disk. When the space on the volume runs out, you
    can expand it by adding a new disk and then expanding the partition. Although
    it may actually be comprised of several hard drives, to your users it will appear
    as a single, unified space. Physical volumes can be subdivided in any way that
    makes sense to you. Users will interact with logical volumes, which are created
    from the underlying physical volumes.
  prefs: []
  type: TYPE_NORMAL
- en: 'Installing LVM on a server that isn’t already utilizing it requires having
    at least one unused volume and the necessary packages, either of which may or
    may not already be present on the server. The following commands will tell you
    whether the necessary `lvm2` package is present on your server:'
  prefs: []
  type: TYPE_NORMAL
- en: 'For Debian, use this command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'For Redhat, use this command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'The next step is to count all of the disks in our possession. Many times now,
    we have used the `fdisk -l` command to display a list of these drives. As an example,
    I have `/dev/sdc` on my server now. Disk names will vary by hardware or virtualization
    platform, so you’ll need to tweak the following commands to work with your setup.
    First, we must prepare each disk for usage with LVM by creating a physical volume.
    It is important to remember that setting up LVM does not include formatting a
    storage device or using `fdisk` to configure it. In this case, formatting occurs
    later. To begin setting up our drives for usage with LVM, we will use the `pvcreate`
    command. As a result, we must execute the `pvcreate` command on each of the drives
    we intend to employ. To set up LVM with my USB disks, I will execute the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'If you want to check that everything is set up properly, you can see a list
    of your server’s physical volumes by running the `pvdisplay` command as root or
    using `sudo`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.10 – The pvdisplay command output](img/B18575_10_10.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10.10 – The pvdisplay command output
  prefs: []
  type: TYPE_NORMAL
- en: 'Only one volume could be displayed on this page, so only that one is shown
    in the screenshot. If you scroll up, more output from the `pvdisplay` command
    will be displayed. We have access to a number of physical volumes, but none of
    them have been placed in a volume group. Actually, we haven’t done something as
    simple as making a volume group yet. Using the `vgcreate` command, we can create
    a volume group, give it a name, and add our first disk to it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'At this point, I creating a volume group called `vg-packt` and allocate one
    of the created physical volumes (`/dev/sdc`) to it. With the `sudo vgdisplay`
    command, we can see the volume group’s configuration, including the number of
    disks it uses (which should be 1 at this point):'
  prefs: []
  type: TYPE_NORMAL
- en: 'Right now, all that has to be done is for us to make a logical volume and format
    it. The disk space we allocate to our volume group may be used in its entirety,
    or in part. Here’s the command I’ll use to partition the newly added virtual disk
    within the volume group into a 5 GB logical volume:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Although the command looks difficult, it is actually quite simple. For clarity,
    I use the `-n` option to give my logical volume the name `packtvol1` in this example.
    I use the `-L` option followed by `5g` to specify that I only want to allocate
    5 GB of space. The volume group that this logical volume will be part of is listed
    as the final item. To view details about this volume, use the `sudo` `lvdisplay`
    command:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.11 – The lvdisplay command output](img/B18575_10_11.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10.11 – The lvdisplay command output
  prefs: []
  type: TYPE_NORMAL
- en: At this point, we have everything we need to set up LVM. Like with non-LVM disks,
    we must format a volume before using it.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a format for logical disks
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The next step is to utilize the correct format for our logical volume. However,
    for the formatting process to go smoothly, we must always know the device’s name.
    Since LVM exists, this is a breeze. You can see this in the output (it’s the third
    line down in *Figure 10**.11*, under `lvdisplay` command provided. Let’s use the
    `ext4` filesystem to set up the drive:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, this storage device can be used like any other hard drive. Mine will
    be mounted at `/mnt/lvm/packtvol1`, but you can use whatever you like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'We can run `df -h` to verify that the volume is mounted and displays the right
    size. The single disk in our current LVM arrangement makes this useless. The 5
    GB I’ve allotted probably won’t last very long, but we have some unused space
    that we can put to good use:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'The following `lvextend` command allows me to expand my logical volume to fill
    the remaining space on the physical disk:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: '![Figure 10.12 – The lvextend command](img/B18575_10_12.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10.12 – The lvextend command
  prefs: []
  type: TYPE_NORMAL
- en: To be more specific, the preceding `+100%FREE` option specifies that we wish
    to allocate the full remaining space to the logical volume. In my case, this is
    only 2.5 GB, as I used a USB stick for demo purposes.
  prefs: []
  type: TYPE_NORMAL
- en: 'All of the space on the physical drive I designated for my logical volume is
    being used up. However, tread carefully, because if I had more than one physical
    volume allocated, the command would have taken up all of that space as well, making
    the logical volume the size of all the space on all the disks. Even if you don’t
    want to do this all the time, it’s fine by me because I just have one physical
    volume. Feel free to use the `df -h` tool once again to verify your available
    storage space:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Unfortunately, the additional volume space we’ve added isn’t reflected. `df`
    still returns the old volume size in its output. The reason for this is that we
    did not resize the `ext4` filesystem that is located on this logical disk, despite
    the fact that we have a larger logical volume and it has all the space given to
    it. The `resize2fs` command is what we’ll utilize to do this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: '![Figure 10.13 – The resize2fs command](img/B18575_10_13.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10.13 – The resize2fs command
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, using the `df -h` command again, we can see we have all the space allocated:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: In this section, we’ve learned how to use logical volumes and how to extend
    a filesystem.
  prefs: []
  type: TYPE_NORMAL
- en: Deleting volumes with LVM
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Last but not least, you probably want to know what happens when you delete
    a logical volume or volume group. The `lvremove` and `vgremove` commands are used
    for this reason. Destructive as they may be, these commands can be very helpful
    if you ever need to get rid of a logical volume or volume group. The following
    syntax will get rid of any logical volumes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Giving the `lvremove` command the name of the volume group you want to remove
    the logical volume from, followed by a forward slash, is all that’s required.
    To remove the entire volume group, the following command should do the trick:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Even though you probably won’t be removing logical volumes very often, there
    are commands available to help you do so if you ever find yourself in need of
    decommissioning an LVM component. Hopefully, you can see why LVM is so great now.
  prefs: []
  type: TYPE_NORMAL
- en: The `pvremove` command in Linux is used to remove a **physical volume** (**PV**)
    from the LVM. Before using this command, make sure that the PV you want to remove
    is not part of any volume group and does not contain any active logical volumes.
    Otherwise, data loss may occur.
  prefs: []
  type: TYPE_NORMAL
- en: This technology gives you unprecedented control over the data stored on your
    server. Linux’s versatility in the cloud is due in part to LVM’s adaptability.
    If you’re not familiar with LVM, these ideas may seem foreign at first. However,
    with virtualization, experimenting with LVM is straightforward. Until you feel
    comfortable making, editing, and erasing volume groups and logical volumes, I
    advise you to put in some practice time. Concepts that aren’t immediately evident
    will become so with repeated exposure.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Maintaining a smooth operation requires careful storage management, as a full
    filesystem will cause your server to cease. Fortunately, Linux servers come with
    a plethora of storage management capabilities, some of which are the envy of competing
    systems. It would not be possible to perform our jobs as Linux server administrators
    without innovations such as LVM. In this chapter, we dove into these resources
    and learned some storage management tricks. We went through a wide range of topics,
    including how to create and manage partitions, mount and unmount volumes, work
    with the `fstab` file, use LVM, and check disk use.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will discuss logging configuration and remote logging.
  prefs: []
  type: TYPE_NORMAL
- en: 'Part 3: Linux as a Part of a Larger System'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: All modern IT infrastructures consist of multiple machines with different roles,
    so all systems administrators need to know how to make their Linux-based systems
    work together. In this part of the book, you will learn how to collect log messages
    from all these systems on a central server, simplify user account and permission
    management by using centralized authentication mechanisms, create robust services
    with automatic failover and load balancing, and manage multiple systems at once
    with automation tools. You will also learn how to keep your systems secure.
  prefs: []
  type: TYPE_NORMAL
- en: 'This part has the following chapters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[*Chapter 11*](B18575_11.xhtml#_idTextAnchor189), *Logging Configuration and
    Remote Logging*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[*Chapter 12*](B18575_12.xhtml#_idTextAnchor201), *Centralized Authentication*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[*Chapter 13*](B18575_13.xhtml#_idTextAnchor216), *High Availability*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[*Chapter 14*](B18575_14.xhtml#_idTextAnchor235), *Automation with Chef*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[*Chapter 15*](B18575_15.xhtml#_idTextAnchor267), *Security Guidelines and
    Best Practices*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
