<html><head></head><body>
<div id="_idContainer035">
<h1 class="chapter-number" id="_idParaDest-52"><a id="_idTextAnchor053"/><span class="koboSpan" id="kobo.1.1">3</span></h1>
<h1 id="_idParaDest-53"><a id="_idTextAnchor054"/><span class="koboSpan" id="kobo.2.1">Exploring the Actual Filesystems Under the VFS</span></h1>
<p class="author-quote"><span class="koboSpan" id="kobo.3.1">“Not all roots are buried down in the ground, some are at the top of a tree.” </span><span class="koboSpan" id="kobo.3.2">— Jinvirle</span></p>
<p><span class="koboSpan" id="kobo.4.1">The kernel’s I/O stack can be broken down into three major sections: the </span><strong class="bold"><span class="koboSpan" id="kobo.5.1">virtual filesystem</span></strong><span class="koboSpan" id="kobo.6.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.7.1">VFS</span></strong><span class="koboSpan" id="kobo.8.1">), the </span><strong class="bold"><span class="koboSpan" id="kobo.9.1">block layer</span></strong><span class="koboSpan" id="kobo.10.1">, and the </span><strong class="bold"><span class="koboSpan" id="kobo.11.1">physical layer</span></strong><span class="koboSpan" id="kobo.12.1">. </span><span class="koboSpan" id="kobo.12.2">The different flavors of filesystems supported by Linux can be thought of as the tail end of the VFS layer. </span><span class="koboSpan" id="kobo.12.3">The first two chapters gave us a decent understanding of the role of VFS, the major structures used by VFS, and how it aids the end user processes to interact with the different filesystems through a common file model. </span><span class="koboSpan" id="kobo.12.4">This means that we’ll now be able to use the word </span><em class="italic"><span class="koboSpan" id="kobo.13.1">filesystem</span></em><span class="koboSpan" id="kobo.14.1"> in its commonly accepted </span><span class="No-Break"><span class="koboSpan" id="kobo.15.1">context. </span><span class="koboSpan" id="kobo.15.2">Finally.</span></span></p>
<p><span class="koboSpan" id="kobo.16.1">In </span><a href="B19430_02.xhtml#_idTextAnchor028"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.17.1">Chapter 2</span></em></span></a><span class="koboSpan" id="kobo.18.1">, we defined and explained some important data structures used by the VFS to define a generic framework for different filesystems. </span><span class="koboSpan" id="kobo.18.2">In order for a particular filesystem to be supported by the kernel, it should operate within the boundaries defined in this framework. </span><span class="koboSpan" id="kobo.18.3">But it is not mandatory that all the methods defined by the VFS are used by a filesystem. </span><span class="koboSpan" id="kobo.18.4">The filesystems should stick to the structures defined in the VFS and build upon them to ensure commonality between them, but as each filesystem follows a different approach for organizing data, there might be a ton of methods and fields in these structures that are not applicable to a particular filesystem. </span><span class="koboSpan" id="kobo.18.5">In such cases, filesystems define the relevant fields as per their design and leave out the </span><span class="No-Break"><span class="koboSpan" id="kobo.19.1">non-essential information.</span></span></p>
<p><span class="koboSpan" id="kobo.20.1">As we’ve seen, the VFS is sandwiched between user-space programs and </span><em class="italic"><span class="koboSpan" id="kobo.21.1">actual</span></em><span class="koboSpan" id="kobo.22.1"> filesystems and implements a common file model so that applications can use uniform access methods to perform their operations, regardless of the underlying filesystem in use. </span><span class="koboSpan" id="kobo.22.2">We’re now going to shift our focus to one particular side of this </span><em class="italic"><span class="koboSpan" id="kobo.23.1">sandwich</span></em><span class="koboSpan" id="kobo.24.1">, which is the filesystems that contain </span><span class="No-Break"><span class="koboSpan" id="kobo.25.1">user data.</span></span></p>
<p><span class="koboSpan" id="kobo.26.1">This chapter will introduce you to some of the more common and popular filesystems used in Linux. </span><span class="koboSpan" id="kobo.26.2">We’ll cover the working of the extended filesystem in great detail as it is most commonly used. </span><span class="koboSpan" id="kobo.26.3">We’ll also shed some light on </span><strong class="bold"><span class="koboSpan" id="kobo.27.1">network filesystems</span></strong><span class="koboSpan" id="kobo.28.1">, and cover a few important concepts related to filesystems such as journaling, filesystems in user-space, and </span><strong class="bold"><span class="koboSpan" id="kobo.29.1">copy-on-write</span></strong><span class="koboSpan" id="kobo.30.1"> (</span><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.31.1">CoW</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.32.1">) mechanisms.</span></span></p>
<p><span class="koboSpan" id="kobo.33.1">We’re going to cover the following </span><span class="No-Break"><span class="koboSpan" id="kobo.34.1">main topics:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.35.1">The concept </span><span class="No-Break"><span class="koboSpan" id="kobo.36.1">of journaling</span></span></li>
<li><span class="No-Break"><span class="koboSpan" id="kobo.37.1">CoW mechanisms</span></span></li>
<li><span class="koboSpan" id="kobo.38.1">The </span><a id="_idTextAnchor055"/><span class="koboSpan" id="kobo.39.1">extended </span><span class="No-Break"><span class="koboSpan" id="kobo.40.1">filesystem family</span></span></li>
<li><span class="No-Break"><span class="koboSpan" id="kobo.41.1">Network filesystems</span></span></li>
<li><span class="koboSpan" id="kobo.42.1">Filesystems in </span><span class="No-Break"><span class="koboSpan" id="kobo.43.1">user space</span></span></li>
</ul>
<h1 id="_idParaDest-54"><a id="_idTextAnchor056"/><span class="koboSpan" id="kobo.44.1">Technical requirements</span></h1>
<p><span class="koboSpan" id="kobo.45.1">This chapter focuses entirely on filesystems and associated concepts. </span><span class="koboSpan" id="kobo.45.2">If you have experience with storage administration tasks in Linux but haven’t delved into the inner workings of filesystems, this chapter will serve as a valuable exercise. </span><span class="koboSpan" id="kobo.45.3">Having prior knowledge of filesystem concepts will enhance your understanding of the content covered in </span><span class="No-Break"><span class="koboSpan" id="kobo.46.1">this chapter.</span></span></p>
<p><span class="koboSpan" id="kobo.47.1">The commands and examples presented in this chapter are distribution-agnostic and can be run on any Linux operating system, such as Debian, Ubuntu, Red Hat, Fedora, and so on. </span><span class="koboSpan" id="kobo.47.2">There are a few references to the kernel source code. </span><span class="koboSpan" id="kobo.47.3">If you want to download the kernel source, you can download it from </span><a href="https://www.kernel.org"><span class="koboSpan" id="kobo.48.1">https://www.kernel.org</span></a><span class="koboSpan" id="kobo.49.1">. </span><span class="koboSpan" id="kobo.49.2">The code segments referred to in this book are from </span><span class="No-Break"><span class="koboSpan" id="kobo.50.1">kernel </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.51.1">5.19.9</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.52.1">.</span></span></p>
<h1 id="_idParaDest-55"><a id="_idTextAnchor057"/><span class="koboSpan" id="kobo.53.1">The Linux filesystem gallery</span></h1>
<p><span class="koboSpan" id="kobo.54.1">As said earlier, one of the major benefits of using Linux is the wide range of supported filesystems. </span><span class="koboSpan" id="kobo.54.2">The kernel contains out-of-the-box support for some of these, such as XFS, Btrfs, and extended filesystem versions 2, 3, and 4. </span><span class="koboSpan" id="kobo.54.3">These are considered </span><strong class="bold"><span class="koboSpan" id="kobo.55.1">native filesystems</span></strong><span class="koboSpan" id="kobo.56.1"> as they were designed keeping in mind the Linux principles and philosophies. </span><span class="koboSpan" id="kobo.56.2">On the other side of the aisle are filesystems such as NTFS and FAT. </span><span class="koboSpan" id="kobo.56.3">These can be considered </span><strong class="bold"><span class="koboSpan" id="kobo.57.1">non-native filesystems</span></strong><span class="koboSpan" id="kobo.58.1">. </span><span class="koboSpan" id="kobo.58.2">This is because, although the Linux kernel is capable of understanding these filesystems, supporting them usually requires additional configuration as they do not fall in line with the conventions adopted by native filesystems. </span><span class="koboSpan" id="kobo.58.3">We’re going to keep our focus on the native filesystems and explain the key concepts associated </span><span class="No-Break"><span class="koboSpan" id="kobo.59.1">with them.</span></span></p>
<p><span class="koboSpan" id="kobo.60.1">Although each filesystem claims to be better, faster, and more reliable and secure than all others, it is important to note that no filesystem can be the best fit for all kinds of applications. </span><span class="koboSpan" id="kobo.60.2">Every filesystem comes with its strengths and limitations. </span><span class="koboSpan" id="kobo.60.3">From a functional standpoint, filesystems can be classified </span><span class="No-Break"><span class="koboSpan" id="kobo.61.1">as follows:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer025">
<span class="koboSpan" id="kobo.62.1"><img alt="Figure 3.1 – Linux filesystem gallery" src="image/B19430_03_01.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.63.1">Figure 3.1 – Linux filesystem gallery</span></p>
<p><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.64.1">Figure 3</span></em></span><em class="italic"><span class="koboSpan" id="kobo.65.1">.1</span></em><span class="koboSpan" id="kobo.66.1"> gives a glimpse of some of the supported filesystems and their respective categories. </span><span class="koboSpan" id="kobo.66.2">Given the plethora of filesystems supported by Linux, covering all of them will make us run out of space (filesystem pun!). </span><span class="koboSpan" id="kobo.66.3">Although the implementation details vary, filesystems usually make use of some common techniques for their internal operations. </span><span class="koboSpan" id="kobo.66.4">Some core concepts, such as journaling, are more common among filesystems. </span><span class="koboSpan" id="kobo.66.5">Similarly, some filesystems make use of the popular CoW technique, due to which they do not </span><span class="No-Break"><span class="koboSpan" id="kobo.67.1">need journaling.</span></span></p>
<p><span class="koboSpan" id="kobo.68.1">Let’s explain the concept of journaling </span><span class="No-Break"><span class="koboSpan" id="kobo.69.1">in filesystems.</span></span></p>
<h1 id="_idParaDest-56"><a id="_idTextAnchor058"/><span class="koboSpan" id="kobo.70.1">The diary of a filesystem – the concept of journaling</span></h1>
<p><span class="koboSpan" id="kobo.71.1">A filesystem uses complex structures to organize data on the physical disk. </span><span class="koboSpan" id="kobo.71.2">In the case of a system crash or abrupt failure, a filesystem is unable to finish off its operations in a graceful manner, which can corrupt its organizational structures. </span><span class="koboSpan" id="kobo.71.3">When the system is powered up the next time, the user will need to run a consistency or integrity check of some sort against the filesystem to detect and repair those </span><span class="No-Break"><span class="koboSpan" id="kobo.72.1">damaged structures.</span></span></p>
<p><span class="koboSpan" id="kobo.73.1">When explaining VFS data structures in </span><a href="B19430_02.xhtml#_idTextAnchor028"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.74.1">Chapter 2</span></em></span></a><span class="koboSpan" id="kobo.75.1">, we discussed that one of the fundamental principles followed in Linux is the separation of metadata from actual data. </span><span class="koboSpan" id="kobo.75.2">The metadata of a file is defined in an independent structure, called an </span><strong class="bold"><span class="koboSpan" id="kobo.76.1">inode</span></strong><span class="koboSpan" id="kobo.77.1">. </span><span class="koboSpan" id="kobo.77.2">We also saw how a directory is treated as a special file and it contains the mapping of filenames to their inode numbers. </span><span class="koboSpan" id="kobo.77.3">Keeping this in mind, let’s say we’re creating a simple file to add some text to it. </span><span class="koboSpan" id="kobo.77.4">To go through with this, the kernel will need to perform the </span><span class="No-Break"><span class="koboSpan" id="kobo.78.1">following operations:</span></span></p>
<ol>
<li><span class="koboSpan" id="kobo.79.1">Create and initialize a new inode for the file to be created. </span><span class="koboSpan" id="kobo.79.2">An inode should be unique within </span><span class="No-Break"><span class="koboSpan" id="kobo.80.1">a filesystem.</span></span></li>
<li><span class="koboSpan" id="kobo.81.1">Update the timestamps for the directory in which the file is </span><span class="No-Break"><span class="koboSpan" id="kobo.82.1">being created.</span></span></li>
<li><span class="koboSpan" id="kobo.83.1">Update the inode for the directory. </span><span class="koboSpan" id="kobo.83.2">This is required so that the filenames-to-inode mapping </span><span class="No-Break"><span class="koboSpan" id="kobo.84.1">is updated.</span></span></li>
</ol>
<p><span class="koboSpan" id="kobo.85.1">Even for an operation as simple as text file creation, the kernel needs to perform several I/O operations to update multiple structures. </span><span class="koboSpan" id="kobo.85.2">Let’s say that while performing one of these operations, there is a hardware or power failure due to which the system shuts down abruptly. </span><span class="koboSpan" id="kobo.85.3">All the operations required for creating a new file will not have completed successfully, which will render the filesystem structurally incomplete. </span><span class="koboSpan" id="kobo.85.4">If an inode for the file was initialized and not linked to the directory containing the file, the inode will be considered </span><em class="italic"><span class="koboSpan" id="kobo.86.1">orphaned</span></em><span class="koboSpan" id="kobo.87.1">. </span><span class="koboSpan" id="kobo.87.2">Once the system is back online, a consistency check will be run on the filesystem, which will remove any such inodes that are not linked to any directory. </span><span class="koboSpan" id="kobo.87.3">After a crash, the filesystem itself might remain intact, but individual files could be impacted. </span><span class="koboSpan" id="kobo.87.4">In a worst-case scenario, the filesystem itself can also become </span><span class="No-Break"><span class="koboSpan" id="kobo.88.1">permanently damaged.</span></span></p>
<p><span class="koboSpan" id="kobo.89.1">To improve filesystem reliability in case of outages and system crashes, the feature of journaling was introduced in filesystems. </span><span class="koboSpan" id="kobo.89.2">The first filesystem to support this feature was IBM’s </span><strong class="bold"><span class="koboSpan" id="kobo.90.1">JFS</span></strong><span class="koboSpan" id="kobo.91.1">, also known as </span><strong class="bold"><span class="koboSpan" id="kobo.92.1">Journaled Filesystem</span></strong><span class="koboSpan" id="kobo.93.1">. </span><span class="koboSpan" id="kobo.93.2">Over the last few years, journaling has become an essential ingredient in the design </span><span class="No-Break"><span class="koboSpan" id="kobo.94.1">of filesystems.</span></span></p>
<p><span class="koboSpan" id="kobo.95.1">The concept of filesystem journaling finds its roots in the design of database systems. </span><span class="koboSpan" id="kobo.95.2">In most databases, journaling guarantees data consistency and integrity in case a transaction fails due to external events, such as hardware failures. </span><span class="koboSpan" id="kobo.95.3">A database journal will keep track of uncommitted changes by recording such operations in a journal. </span><span class="koboSpan" id="kobo.95.4">When the system comes back online, the database will perform a recovery using the journal. </span><span class="koboSpan" id="kobo.95.5">Journaling in filesystems follows the </span><span class="No-Break"><span class="koboSpan" id="kobo.96.1">same route.</span></span></p>
<p><span class="koboSpan" id="kobo.97.1">Any changes that need to be performed on the filesystem are first written sequentially to a journal. </span><span class="koboSpan" id="kobo.97.2">These changes or modifications are referred to as transactions. </span><span class="koboSpan" id="kobo.97.3">Once a transaction has been written to a journal, it is then written to the appropriate location on the disk. </span><span class="koboSpan" id="kobo.97.4">In the case of a system crash, the filesystem replays the journal to see whether any transaction is incomplete. </span><span class="koboSpan" id="kobo.97.5">When the transaction has been written to its on-disk location, it is then removed from </span><span class="No-Break"><span class="koboSpan" id="kobo.98.1">the journal.</span></span></p>
<p><span class="koboSpan" id="kobo.99.1">Depending on the journaling approach, either metadata or actual data (or both) is first written to the journal. </span><span class="koboSpan" id="kobo.99.2">Once data has been written to the filesystem, the transaction is removed from </span><span class="No-Break"><span class="koboSpan" id="kobo.100.1">the journal:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer026">
<span class="koboSpan" id="kobo.101.1"><img alt="Figure 3.2 – Journaling in filesystems" src="image/B19430_03_02.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.102.1">Figure 3.2 – Journaling in filesystems</span></p>
<p><span class="koboSpan" id="kobo.103.1">It’s important to note that, by default, the filesystem journal is also stored on the same filesystem, albeit in a segregated section. </span><span class="koboSpan" id="kobo.103.2">Some filesystems also allow storing the journal on a separate disk. </span><span class="koboSpan" id="kobo.103.3">The size of the journal is typically just a </span><span class="No-Break"><span class="koboSpan" id="kobo.104.1">few megabytes.</span></span></p>
<h2 id="_idParaDest-57"><a id="_idTextAnchor059"/><span class="koboSpan" id="kobo.105.1">The burning question – doesn’t journaling adversely affect performance?</span></h2>
<p><span class="koboSpan" id="kobo.106.1">The entire point of journaling is to make the filesystem more reliable and preserve its structures in case of system crashes and hardware failures. </span><span class="koboSpan" id="kobo.106.2">With a journaling filesystem, data is first written to a journal and then to its specified disk location. </span><span class="koboSpan" id="kobo.106.3">It’s not difficult to see that we’re adding an extra hop to reach our destination as we’ll need to write the same data twice. </span><span class="koboSpan" id="kobo.106.4">Surely this is going to backfire and undermine the </span><span class="No-Break"><span class="koboSpan" id="kobo.107.1">filesystem performance?</span></span></p>
<p><span class="koboSpan" id="kobo.108.1">It’s one of those questions whose answer seems obvious but it isn’t. </span><span class="koboSpan" id="kobo.108.2">The filesystem performance doesn’t necessarily deteriorate when using journaling. </span><span class="koboSpan" id="kobo.108.3">In fact, in most cases, it’s the exact opposite. </span><span class="koboSpan" id="kobo.108.4">There could be workloads where the difference in both cases is negligible, but in most scenarios, especially in metadata-intensive workloads, filesystem journaling actually boosts performance. </span><span class="koboSpan" id="kobo.108.5">The degree to which the performance is enhanced </span><span class="No-Break"><span class="koboSpan" id="kobo.109.1">can vary.</span></span></p>
<p><span class="koboSpan" id="kobo.110.1">Consider a filesystem without journaling. </span><span class="koboSpan" id="kobo.110.2">Every time a file is modified, the natural course of action is to perform the relevant modifications on the disk. </span><span class="koboSpan" id="kobo.110.3">For metadata-intensive operations, this could negatively impact performance. </span><span class="koboSpan" id="kobo.110.4">For instance, modifications in file contents also require that the corresponding timestamps of the file are also updated. </span><span class="koboSpan" id="kobo.110.5">This means that every time a file is processed and modified, the filesystem has to go and update not only the actual file data but also the metadata. </span><span class="koboSpan" id="kobo.110.6">When journaling is enabled, </span><strong class="bold"><span class="koboSpan" id="kobo.111.1">fewer seeks</span></strong><span class="koboSpan" id="kobo.112.1"> to the physical disk are required as data is written to disk only when a transaction has been committed to the journal or when the journal fills up. </span><span class="koboSpan" id="kobo.112.2">Another benefit is the use of sequential writes in a journal. </span><span class="koboSpan" id="kobo.112.3">When using a journal, random write operations are converted into </span><span class="No-Break"><span class="koboSpan" id="kobo.113.1">sequential writes.</span></span></p>
<p><span class="koboSpan" id="kobo.114.1">In most cases, performance improvement occurs as a result of the cancellation of metadata operations. </span><span class="koboSpan" id="kobo.114.2">When metadata updates are required in a swift manner, such as recursively performing operations on a directory and its contents, the use of journaling can improve performance by reducing frequent trips to disks and performing multiple updates in an </span><span class="No-Break"><span class="koboSpan" id="kobo.115.1">atomic operation.</span></span></p>
<p><span class="koboSpan" id="kobo.116.1">Of course, how a filesystem implements journaling also plays a major role in this. </span><span class="koboSpan" id="kobo.116.2">Filesystems offer different approaches when it comes to journaling. </span><span class="koboSpan" id="kobo.116.3">For instance, some filesystems only journal the metadata of a file, while others write both metadata and actual data in a journal. </span><span class="koboSpan" id="kobo.116.4">Some filesystems also offer flexibility in their approach and allow end users to decide the </span><span class="No-Break"><span class="koboSpan" id="kobo.117.1">journaling mode.</span></span></p>
<p><span class="koboSpan" id="kobo.118.1">To summarize, journaling is an important constituent of modern filesystems as it makes sure that the filesystem remains structurally sound, even in the case of a </span><span class="No-Break"><span class="koboSpan" id="kobo.119.1">system crash.</span></span></p>
<h1 id="_idParaDest-58"><a id="_idTextAnchor060"/><span class="koboSpan" id="kobo.120.1">The curious case of CoW filesystems</span></h1>
<p><strong class="bold"><span class="koboSpan" id="kobo.121.1">CoW</span></strong><span class="koboSpan" id="kobo.122.1"> is a resource management mechanism that is used in the Linux kernel. </span><span class="koboSpan" id="kobo.122.2">This concept is most commonly associated with the </span><strong class="source-inline"><span class="koboSpan" id="kobo.123.1">fork ()</span></strong><span class="koboSpan" id="kobo.124.1"> system call. </span><span class="koboSpan" id="kobo.124.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.125.1">fork ()</span></strong><span class="koboSpan" id="kobo.126.1"> system call creates a new process by duplicating the calling process. </span><span class="koboSpan" id="kobo.126.2">When a new process is created using a </span><strong class="source-inline"><span class="koboSpan" id="kobo.127.1">fork ()</span></strong><span class="koboSpan" id="kobo.128.1"> system call, memory pages are shared between the parent and child processes. </span><span class="koboSpan" id="kobo.128.2">As long as the pages are being shared, they cannot be modified. </span><span class="koboSpan" id="kobo.128.3">When either the parent or child process attempts to modify a page, the kernel duplicates the page and marks </span><span class="No-Break"><span class="koboSpan" id="kobo.129.1">it writable.</span></span></p>
<p><span class="koboSpan" id="kobo.130.1">Most filesystems in Linux that have existed for a long time use a very conventional approach when it comes to the core design principles. </span><span class="koboSpan" id="kobo.130.2">Over the past several years, two major changes in the extended filesystem have been the use of journaling and extents. </span><span class="koboSpan" id="kobo.130.3">Although efforts have been made to scale the filesystems for modern use, some major areas such as error detection, snapshots, and deduplication have been left out. </span><span class="koboSpan" id="kobo.130.4">These features are the need of today’s enterprise </span><span class="No-Break"><span class="koboSpan" id="kobo.131.1">storage environments.</span></span></p>
<p><span class="koboSpan" id="kobo.132.1">Filesystems that use the CoW approach for writing data differ from other filesystems in a notable way. </span><span class="koboSpan" id="kobo.132.2">When overwriting data on an Ext4 or XFS filesystem, the new data is written on top of the existing data. </span><span class="koboSpan" id="kobo.132.3">This means that the original data will be destroyed. </span><span class="koboSpan" id="kobo.132.4">Filesystems that use the CoW approach copy the old data to some other location on disk. </span><span class="koboSpan" id="kobo.132.5">The new incoming data is written to this new location. </span><span class="koboSpan" id="kobo.132.6">Hence, the phrase </span><em class="italic"><span class="koboSpan" id="kobo.133.1">Copy on Write</span></em><span class="koboSpan" id="kobo.134.1">. </span><span class="koboSpan" id="kobo.134.2">As the old data or its snapshot is still there, the space utilization on the filesystem will be a lot more than the user would expect to see. </span><span class="koboSpan" id="kobo.134.3">This is often confusing to newer users and it might take some time to get used to this. </span><span class="koboSpan" id="kobo.134.4">Some Linux folks have a rather funny take on this: </span><em class="italic"><span class="koboSpan" id="kobo.135.1">CoWs ate my data</span></em><span class="koboSpan" id="kobo.136.1">. </span><span class="koboSpan" id="kobo.136.2">As shown in </span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.137.1">Figure 3</span></em></span><em class="italic"><span class="koboSpan" id="kobo.138.1">.3</span></em><span class="koboSpan" id="kobo.139.1">, filesystems using the CoW approach write incoming data to a </span><span class="No-Break"><span class="koboSpan" id="kobo.140.1">new block:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer027">
<span class="koboSpan" id="kobo.141.1"><img alt="Figure 3.3 – The CoW approach in filesystems" src="image/B19430_03_03.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.142.1">Figure 3.3 – The CoW approach in filesystems</span></p>
<p><span class="koboSpan" id="kobo.143.1">As an analogy, we can loosely relate this to the concept of time travel in movies. </span><span class="koboSpan" id="kobo.143.2">When someone travels back in time and makes changes to the past, a parallel timeline is created. </span><span class="koboSpan" id="kobo.143.3">This creates a separate copy of the timeline that diverges from the original. </span><span class="koboSpan" id="kobo.143.4">CoW filesystems operate similarly. </span><span class="koboSpan" id="kobo.143.5">When a modification is requested on a file, instead of directly modifying the original data, a separate copy of the data is created. </span><span class="koboSpan" id="kobo.143.6">The original data remains intact while the modified version is </span><span class="No-Break"><span class="koboSpan" id="kobo.144.1">stored separately.</span></span></p>
<p><span class="koboSpan" id="kobo.145.1">Since the original data is preserved in the process, this opens up some interesting avenues. </span><span class="koboSpan" id="kobo.145.2">Because of this approach, filesystem recovery in the case of a system crash is simplified. </span><span class="koboSpan" id="kobo.145.3">The previous state of data is saved on an alternate location on disk. </span><span class="koboSpan" id="kobo.145.4">Hence, if there's an outage, the filesystem can easily revert to its former state. </span><span class="koboSpan" id="kobo.145.5">This makes the need for maintaining any journal obsolete. </span><span class="koboSpan" id="kobo.145.6">This also allows for the implementation of snapshots at the </span><a id="_idIndexMarker146"/><span class="koboSpan" id="kobo.146.1">filesystem level. </span><span class="koboSpan" id="kobo.146.2">Only modified data blocks are copied to a new location. </span><span class="koboSpan" id="kobo.146.3">When a filesystem needs to be restored using a particular snapshot, the data can be </span><span class="No-Break"><span class="koboSpan" id="kobo.147.1">easily reconstructed.</span></span></p>
<p><em class="italic"><span class="koboSpan" id="kobo.148.1">Table 3.1</span></em><span class="koboSpan" id="kobo.149.1"> highlights some major differences between journaling and CoW-based filesystems. </span><span class="koboSpan" id="kobo.149.2">Please note that the implementation and availability of some of these features may vary depending on the type </span><span class="No-Break"><span class="koboSpan" id="kobo.150.1">of filesystem:</span></span></p>
<table class="No-Table-Style _idGenTablePara-1" id="table001-3">
<colgroup>
<col/>
<col/>
<col/>
</colgroup>
<tbody>
<tr class="No-Table-Style">
<td class="No-Table-Style"/>
<td class="No-Table-Style">
<p><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.151.1">Journaling</span></strong></span></p>
</td>
<td class="No-Table-Style">
<p><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.152.1">Copy-on-Write</span></strong></span></p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.153.1">Write handling</span></strong></span></p>
</td>
<td class="No-Table-Style">
<p><span class="koboSpan" id="kobo.154.1">Changes are recorded in a journal before applying them to the </span><span class="No-Break"><span class="koboSpan" id="kobo.155.1">actual filesystem</span></span></p>
</td>
<td class="No-Table-Style">
<p><span class="koboSpan" id="kobo.156.1">A separate copy of data is created to </span><span class="No-Break"><span class="koboSpan" id="kobo.157.1">make modifications</span></span></p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.158.1">Original data</span></strong></span></p>
</td>
<td class="No-Table-Style">
<p><span class="koboSpan" id="kobo.159.1">Original data </span><span class="No-Break"><span class="koboSpan" id="kobo.160.1">gets overwritten</span></span></p>
</td>
<td class="No-Table-Style">
<p><span class="koboSpan" id="kobo.161.1">Original data </span><span class="No-Break"><span class="koboSpan" id="kobo.162.1">remains intact</span></span></p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.163.1">Data consistency</span></strong></span></p>
</td>
<td class="No-Table-Style">
<p><span class="koboSpan" id="kobo.164.1">Ensures consistency by recording metadata changes and replaying them </span><span class="No-Break"><span class="koboSpan" id="kobo.165.1">if needed</span></span></p>
</td>
<td class="No-Table-Style">
<p><span class="koboSpan" id="kobo.166.1">Ensures consistency by never modifying the </span><span class="No-Break"><span class="koboSpan" id="kobo.167.1">original data</span></span></p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.168.1">Performance</span></strong></span></p>
</td>
<td class="No-Table-Style">
<p><span class="koboSpan" id="kobo.169.1">Minimal overhead depending on the type of </span><span class="No-Break"><span class="koboSpan" id="kobo.170.1">journaling mode</span></span></p>
</td>
<td class="No-Table-Style">
<p><span class="koboSpan" id="kobo.171.1">Some performance gains because of </span><span class="No-Break"><span class="koboSpan" id="kobo.172.1">faster writes</span></span></p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.173.1">Space utilization</span></strong></span></p>
</td>
<td class="No-Table-Style">
<p><span class="koboSpan" id="kobo.174.1">Journal size is typically in MB, so no additional space </span><span class="No-Break"><span class="koboSpan" id="kobo.175.1">is required</span></span></p>
</td>
<td class="No-Table-Style">
<p><span class="koboSpan" id="kobo.176.1">More space is required due to separate copies </span><span class="No-Break"><span class="koboSpan" id="kobo.177.1">of data</span></span></p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.178.1">Recovery times</span></strong></span></p>
</td>
<td class="No-Table-Style">
<p><span class="koboSpan" id="kobo.179.1">Fast recovery times as the journal can be </span><span class="No-Break"><span class="koboSpan" id="kobo.180.1">replayed instantly</span></span></p>
</td>
<td class="No-Table-Style">
<p><span class="koboSpan" id="kobo.181.1">Slower recovery times as data needs to be reconstructed using </span><span class="No-Break"><span class="koboSpan" id="kobo.182.1">recent copies</span></span></p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.183.1">Features</span></strong></span></p>
</td>
<td class="No-Table-Style">
<p><span class="koboSpan" id="kobo.184.1">No built-in support for features such as compression </span><span class="No-Break"><span class="koboSpan" id="kobo.185.1">or deduplication</span></span></p>
</td>
<td class="No-Table-Style">
<p><span class="koboSpan" id="kobo.186.1">Built-in support for compression </span><span class="No-Break"><span class="koboSpan" id="kobo.187.1">and deduplication</span></span></p>
</td>
</tr>
</tbody>
</table>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.188.1">Table 3.1 – Differences between CoW and journaling filesystems</span></p>
<p><span class="koboSpan" id="kobo.189.1">Filesystems that use the CoW-based approach for organizing data include </span><strong class="bold"><span class="koboSpan" id="kobo.190.1">Zettabyte Filesystem</span></strong><span class="koboSpan" id="kobo.191.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.192.1">ZFS</span></strong><span class="koboSpan" id="kobo.193.1">), </span><strong class="bold"><span class="koboSpan" id="kobo.194.1">B-Tree Filesystem</span></strong><span class="koboSpan" id="kobo.195.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.196.1">Btrfs</span></strong><span class="koboSpan" id="kobo.197.1">), and Bcachefs. </span><span class="koboSpan" id="kobo.197.2">ZFS was initially used on Solaris and quickly gained popularity because of its powerful features. </span><span class="koboSpan" id="kobo.197.3">Although not included in the kernel because of licensing issues, it has been ported to Linux through the </span><em class="italic"><span class="koboSpan" id="kobo.198.1">ZFS on Linux</span></em><span class="koboSpan" id="kobo.199.1"> project. </span><span class="koboSpan" id="kobo.199.2">The Bcachefs filesystem was developed from the kernel’s block cache code and is quickly gaining popularity. </span><span class="koboSpan" id="kobo.199.3">It might become a part of future kernel releases. </span><span class="koboSpan" id="kobo.199.4">Btrfs, also fondly known as ButterFS, is directly inspired by ZFS. </span><span class="koboSpan" id="kobo.199.5">Unfortunately, because of a few bugs in early releases, its adoption slowed down in the Linux community. </span><span class="koboSpan" id="kobo.199.6">Nevertheless, it has been under active development and has been a part of the Linux kernel for over </span><span class="No-Break"><span class="koboSpan" id="kobo.200.1">a decade.</span></span></p>
<p><span class="koboSpan" id="kobo.201.1">Despite a few issues, Btrfs is the most advanced filesystem present in the kernel because of its rich feature set. </span><span class="koboSpan" id="kobo.201.2">As mentioned previously, Btrfs draws a lot of inspiration from ZFS and tries to offer almost identical features. </span><span class="koboSpan" id="kobo.201.3">Like ZFS, Btrfs is not just a simple disk filesystem, it also offers the functionality of a logical volume manager and software,</span><strong class="bold"><span class="koboSpan" id="kobo.202.1"> Redundant Array of Independent Disks</span></strong><span class="koboSpan" id="kobo.203.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.204.1">RAID</span></strong><span class="koboSpan" id="kobo.205.1">). </span><span class="koboSpan" id="kobo.205.2">Some of its features include snapshots, checksums, encryption, deduplication, and compression, which are usually not available in regular block filesystems. </span><span class="koboSpan" id="kobo.205.3">All these characteristics greatly simplify </span><span class="No-Break"><span class="koboSpan" id="kobo.206.1">storage management.</span></span></p>
<p><span class="koboSpan" id="kobo.207.1">To summarize, the CoW approach of filesystems such as Btrfs and ZFS ensures that existing data is never overwritten. </span><span class="koboSpan" id="kobo.207.2">Hence, even in the case of a sudden system crash, existing data will not be in an </span><span class="No-Break"><span class="koboSpan" id="kobo.208.1">inconsistent state.</span></span></p>
<h1 id="_idParaDest-59"><a id="_idTextAnchor061"/><span class="koboSpan" id="kobo.209.1">Extended filesystem</span></h1>
<p><span class="koboSpan" id="kobo.210.1">The </span><strong class="bold"><span class="koboSpan" id="kobo.211.1">extended filesystem</span></strong><span class="koboSpan" id="kobo.212.1">, shortened as </span><strong class="bold"><span class="koboSpan" id="kobo.213.1">Ext</span></strong><span class="koboSpan" id="kobo.214.1">, has been a trusted aide of the Linux kernel since its inception and is almost as old as the Linux kernel itself. </span><span class="koboSpan" id="kobo.214.2">It was first introduced in the kernel 0.96c. </span><span class="koboSpan" id="kobo.214.3">Over the years, the extended filesystem has gone through some major changes that have resulted in multiple versions of the filesystem. </span><span class="koboSpan" id="kobo.214.4">These versions are briefly explained </span><span class="No-Break"><span class="koboSpan" id="kobo.215.1">as follows:</span></span></p>
<ul>
<li><strong class="bold"><span class="koboSpan" id="kobo.216.1">The First Extended Filesystem</span></strong><span class="koboSpan" id="kobo.217.1">: The first filesystem to run Linux was Minix and it supported a maximum filesystem size of 64 MB. </span><span class="koboSpan" id="kobo.217.2">The extended filesystem was designed to overcome the shortcomings in Minix and was generally considered an extension of the Minix filesystem. </span><span class="koboSpan" id="kobo.217.3">The extended filesystem supported a maximum filesystem size of 2 GB. </span><span class="koboSpan" id="kobo.217.4">It was also the first filesystem to make use of the VFS. </span><span class="koboSpan" id="kobo.217.5">The first Ext filesystem only allowed one timestamp per file, as compared to the three timestamps </span><span class="No-Break"><span class="koboSpan" id="kobo.218.1">used today.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.219.1">The Second Extended Filesystem</span></strong><span class="koboSpan" id="kobo.220.1">: Almost a year after the release of the first extended filesystem, its second version, Ext2, was released. </span><span class="koboSpan" id="kobo.220.2">The Ext2 filesystem addressed the limitations of its predecessor, such as partition sizes, fragmentation, filename lengths, timestamps, and maximum file size. </span><span class="koboSpan" id="kobo.220.3">It also introduced several new features including the concept of filesystem blocks. </span><span class="koboSpan" id="kobo.220.4">The design of Ext2 was inspired by BSD’s Berkeley Fast File System. </span><span class="koboSpan" id="kobo.220.5">The Ext2 filesystem supported much larger filesystem sizes, up to a </span><span class="No-Break"><span class="koboSpan" id="kobo.221.1">few terabytes.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.222.1">The Third Extended Filesystem</span></strong><span class="koboSpan" id="kobo.223.1">: The Ext2 filesystem was widely adopted but fragmentation and filesystem corruption in the case of a crash remained big concerns. </span><span class="koboSpan" id="kobo.223.2">The third extended filesystem, Ext3, was designed keeping this in mind. </span><span class="koboSpan" id="kobo.223.3">The most important feature introduced in this release was </span><strong class="bold"><span class="koboSpan" id="kobo.224.1">journaling</span></strong><span class="koboSpan" id="kobo.225.1">. </span><span class="koboSpan" id="kobo.225.2">Through journaling, the Ext3 filesystem kept track of uncommitted changes. </span><span class="koboSpan" id="kobo.225.3">This reduced the risk of data loss if the system crashed because of a hardware or </span><span class="No-Break"><span class="koboSpan" id="kobo.226.1">power failure.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.227.1">The Fourth Extended Filesystem</span></strong><span class="koboSpan" id="kobo.228.1">: Ext4 is currently the latest version of the extended filesystem family. </span><span class="koboSpan" id="kobo.228.2">The Ext4 filesystem offers several improvements over Ext2 and Ext3 in terms of performance, fragmentation, and scalability, while also keeping backward compatibility with Ext2 and Ext3. </span><span class="koboSpan" id="kobo.228.3">When it comes to Linux distributions, Ext4 is probably the most frequently </span><span class="No-Break"><span class="koboSpan" id="kobo.229.1">deployed filesystem.</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.230.1">We’re going to mainly focus on the design and structure of the most recent version of the extended </span><span class="No-Break"><span class="koboSpan" id="kobo.231.1">filesystem, Ext4.</span></span></p>
<h2 id="_idParaDest-60"><a id="_idTextAnchor062"/><span class="koboSpan" id="kobo.232.1">Blocks – the lingua franca of filesystems</span></h2>
<p><span class="koboSpan" id="kobo.233.1">At the lowest level, a hard drive is addressed in units of sectors. </span><span class="koboSpan" id="kobo.233.2">Sectors are the physical property of a disk drive and are normally 512 bytes in size. </span><span class="koboSpan" id="kobo.233.3">Although, these days, it’s not uncommon to see drives using a sector size of 4 KB. </span><span class="koboSpan" id="kobo.233.4">The sector size is something that we cannot tinker with as it is decided by the drive manufacturer. </span><span class="koboSpan" id="kobo.233.5">As a sector is the smallest addressable unit on the drive, any operation performed on the physical drive is always going to be larger than or equal to the </span><span class="No-Break"><span class="koboSpan" id="kobo.234.1">sector size.</span></span></p>
<p><span class="koboSpan" id="kobo.235.1">A filesystem is created on top of the physical drive and does not address the drive in terms of sectors. </span><span class="koboSpan" id="kobo.235.2">All filesystems (and the extended filesystem family is no exception to this) address a physical drive in terms of blocks. </span><span class="koboSpan" id="kobo.235.3">A block is a group of physical sectors and is the fundamental unit of a filesystem. </span><span class="koboSpan" id="kobo.235.4">An Ext4 filesystem performs all operations in terms of blocks. </span><span class="koboSpan" id="kobo.235.5">On x86 systems, the filesystem block size is set to 4 KB by default. </span><span class="koboSpan" id="kobo.235.6">Although it can be set to a lower or higher value, the block size should always satisfy the following </span><span class="No-Break"><span class="koboSpan" id="kobo.236.1">two constraints:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.237.1">The block size should always be a power-of-two multiple of the disk </span><span class="No-Break"><span class="koboSpan" id="kobo.238.1">sector size</span></span></li>
<li><span class="koboSpan" id="kobo.239.1">The block size should always be less than or equal to the memory </span><span class="No-Break"><span class="koboSpan" id="kobo.240.1">page size</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.241.1">The maximum filesystem block size is the page size of the architecture. </span><span class="koboSpan" id="kobo.241.2">On most x86-based systems, the default page size of the kernel is 4 KB. </span><span class="koboSpan" id="kobo.241.3">So, the filesystem block size cannot exceed 4 KB. </span><span class="koboSpan" id="kobo.241.4">The page size of the VFS cache also amounts to 4 KB. </span><span class="koboSpan" id="kobo.241.5">The restriction of the block size to be less than or equal to the kernel’s page size is not limited to the extended filesystem only. </span><span class="koboSpan" id="kobo.241.6">The page size is defined during kernel compilation and is 4 KB for x86_64 systems. </span><span class="koboSpan" id="kobo.241.7">As shown ahead, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.242.1">mkfs</span></strong><span class="koboSpan" id="kobo.243.1"> program for Ext4 will throw a warning if a block size greater than the page size is specified. </span><span class="koboSpan" id="kobo.243.2">Even if a filesystem is created with a block size greater than the page size, it cannot </span><span class="No-Break"><span class="koboSpan" id="kobo.244.1">be mounted:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.245.1">
[root@linuxbox ~]# getconf PAGE_SIZE
4096
[root@linuxbox ~]# mkfs.ext4 /dev/sdb -b 8192
Warning: blocksize 8192 not usable on most systems.
</span><span class="koboSpan" id="kobo.245.2">mke2fs 1.44.6 (5-Mar-2019)
mkfs.ext4: 8192-byte blocks too big for system (max 4096)
Proceed anyway? </span><span class="koboSpan" id="kobo.245.3">(y,N) y
Warning: 8192-byte blocks too big for system (max 4096), forced to continue
[....]
[root@linuxbox ~]# mount /dev/sdb /mnt
mount: /mnt: wrong fs type, bad option, bad superblock on /dev/sdb, missing codepage or helper program, or other error.
</span><span class="koboSpan" id="kobo.245.4">[root@linuxbox ~]#
[root@linuxbox ~]# dmesg |grep bad
[ 5436.033828] EXT4-fs (sdb): bad block size 8192
[ 5512.534352] EXT4-fs (sdb): bad block size 8192
[root@linuxbox ~]#</span></pre>
<p><span class="koboSpan" id="kobo.246.1">Once a filesystem has been created, the block size cannot be changed. </span><span class="koboSpan" id="kobo.246.2">The Ext4 filesystem divides the available storage into logical blocks of 4 KB by default. </span><span class="koboSpan" id="kobo.246.3">The selection of block size has a significant impact on the space efficiency and performance of the filesystem. </span><span class="koboSpan" id="kobo.246.4">The block size dictates the minimum on-disk size of a file, even if its actual size is less than the block size. </span><span class="koboSpan" id="kobo.246.5">Let’s say that our filesystem uses a block size of 4 KB and we save a simple text file of 10 bytes on it. </span><span class="koboSpan" id="kobo.246.6">This 10-byte file, when stored on the physical disk, will use 4 KB of space. </span><span class="koboSpan" id="kobo.246.7">A block can only hold a single file. </span><span class="koboSpan" id="kobo.246.8">This means that for a 10-byte file, the remaining space in a block (4 KB – 10 bytes) is wasted. </span><span class="koboSpan" id="kobo.246.9">As shown next, a simple text file containing the </span><strong class="source-inline"><span class="koboSpan" id="kobo.247.1">"hello"</span></strong><span class="koboSpan" id="kobo.248.1"> string will occupy a full </span><span class="No-Break"><span class="koboSpan" id="kobo.249.1">filesystem block:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.250.1">
robocop@linuxbox:~$ echo "hello" &gt; file.txt
robocop@linuxbox:~$ stat file.txt
  File: file.txt
  Size: 6               Blocks: 8          IO Block: 4096   regular file
Device: 803h/2051d      Inode: 2622288     Links: 1
Access: (0664/-rw-rw-r--)  Uid: ( 1000/   robocop)   Gid: ( 1000/   robocop)
Access: 2022-11-10 12:55:55.406596713 +0500
Modify: 2022-11-10 13:01:12.962761327 +0500
Change: 2022-11-10 13:01:12.962761327 +0500
 Birth: -
robocop@linuxbox:~$</span></pre>
<p><span class="koboSpan" id="kobo.251.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.252.1">stat</span></strong><span class="koboSpan" id="kobo.253.1"> command gives us a block count of </span><strong class="source-inline"><span class="koboSpan" id="kobo.254.1">8</span></strong><span class="koboSpan" id="kobo.255.1">, which is a bit misleading, as it is actually the sector count. </span><span class="koboSpan" id="kobo.255.2">This is because the </span><strong class="source-inline"><span class="koboSpan" id="kobo.256.1">stat</span></strong><span class="koboSpan" id="kobo.257.1"> system call assumes that 512 bytes of disk space are allocated per block. </span><span class="koboSpan" id="kobo.257.2">The block count here indicates that </span><strong class="source-inline"><span class="koboSpan" id="kobo.258.1">4096</span></strong><span class="koboSpan" id="kobo.259.1"> bytes (8 x 512) are physically allocated on the disk. </span><span class="koboSpan" id="kobo.259.2">The file size is </span><strong class="source-inline"><span class="koboSpan" id="kobo.260.1">6</span></strong><span class="koboSpan" id="kobo.261.1"> bytes only, but it occupies one full block on the disk. </span><span class="koboSpan" id="kobo.261.2">As shown next, when we add another line of text in the file, the file size increases from </span><strong class="source-inline"><span class="koboSpan" id="kobo.262.1">6</span></strong><span class="koboSpan" id="kobo.263.1"> to </span><strong class="source-inline"><span class="koboSpan" id="kobo.264.1">19</span></strong><span class="koboSpan" id="kobo.265.1"> bytes, but the numbers of used sectors and blocks remain </span><span class="No-Break"><span class="koboSpan" id="kobo.266.1">the same:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.267.1">
robocop@linuxbox:~$ echo "another line" &gt;&gt; file.txt
robocop@linuxbox:~$ stat file.txt
  File: file.txt
  Size: 19              Blocks: 8          IO Block: 4096   regular file
Device: 803h/2051d      Inode: 2622288     Links: 1
Access: (0664/-rw-rw-r--)  Uid: ( 1000/   robocop)   Gid: ( 1000/   robocop)
Access: 2022-11-10 12:55:55.406596713 +0500
Modify: 2022-11-10 13:01:59.772249416 +0500
Change: 2022-11-10 13:01:59.772249416 +0500
 Birth: -
robocop@linuxbox:~$</span></pre>
<h2 id="_idParaDest-61"><a id="_idTextAnchor063"/><span class="koboSpan" id="kobo.268.1">Is there a more efficient approach to organizing data?</span></h2>
<p><span class="koboSpan" id="kobo.269.1">Given that a small text file occupies a full block, it’s not difficult to see the impact of filesystem block size. </span><span class="koboSpan" id="kobo.269.2">Having a lot of small files on a filesystem of a large block size can result in a waste of disk space, and a filesystem can quickly run out of blocks. </span><span class="koboSpan" id="kobo.269.3">Let’s see a visual representation for a </span><span class="No-Break"><span class="koboSpan" id="kobo.270.1">clearer understanding.</span></span></p>
<p><span class="koboSpan" id="kobo.271.1">Let’s say we have four files of varied sizes </span><span class="No-Break"><span class="koboSpan" id="kobo.272.1">as follows:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.273.1">File A -&gt; </span><span class="No-Break"><span class="koboSpan" id="kobo.274.1">5 KB</span></span></li>
<li><span class="koboSpan" id="kobo.275.1">File B -&gt; </span><span class="No-Break"><span class="koboSpan" id="kobo.276.1">1 KB</span></span></li>
<li><span class="koboSpan" id="kobo.277.1">File C -&gt; </span><span class="No-Break"><span class="koboSpan" id="kobo.278.1">7 KB</span></span></li>
<li><span class="koboSpan" id="kobo.279.1">File D -&gt; </span><span class="No-Break"><span class="koboSpan" id="kobo.280.1">2 KB</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.281.1">Going with the approach of allocating a whole block (4 KB) to a single file, the files will be stored on disk </span><span class="No-Break"><span class="koboSpan" id="kobo.282.1">as follows:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer028">
<span class="koboSpan" id="kobo.283.1"><img alt="Figure 3.4 – Even the smallest of files occupy a full block" src="image/B19430_03_04.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.284.1">Figure 3.4 – Even the smallest of files occupy a full block</span></p>
<p><span class="koboSpan" id="kobo.285.1">As is apparent from </span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.286.1">Figure 3</span></em></span><em class="italic"><span class="koboSpan" id="kobo.287.1">.4</span></em><span class="koboSpan" id="kobo.288.1">, we’re wasting 3 KB of space in blocks 2 and 3, and 1 KB and 2 KB in blocks 5 and 6, respectively. </span><span class="koboSpan" id="kobo.288.2">It’s pretty clear that too many small files spoil </span><span class="No-Break"><span class="koboSpan" id="kobo.289.1">the blocks!</span></span></p>
<p><span class="koboSpan" id="kobo.290.1">Let’s try an alternative approach and try to store the files in a more condensed format to avoid </span><span class="No-Break"><span class="koboSpan" id="kobo.291.1">wasting space:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer029">
<span class="koboSpan" id="kobo.292.1"><img alt="Figure 3.5 – An alternate method for storing files" src="image/B19430_03_05.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.293.1">Figure 3.5 – An alternate method for storing files</span></p>
<p><span class="koboSpan" id="kobo.294.1">It’s not difficult to see that the second approach is more compact and efficient. </span><span class="koboSpan" id="kobo.294.2">We’re now able to store the same four files in only four blocks as compared to the six in the first approach. </span><span class="koboSpan" id="kobo.294.3">We are even able to save 1 KB of filesystem space. </span><span class="koboSpan" id="kobo.294.4">Apparently, allocating a whole filesystem block for a single file seems like an inefficient method for managing space, but in reality, that is a </span><span class="No-Break"><span class="koboSpan" id="kobo.295.1">necessary evil.</span></span></p>
<p><span class="koboSpan" id="kobo.296.1">On the first look, the second approach seems far better, but do you see the design flaw? </span><span class="koboSpan" id="kobo.296.2">A filesystem following this approach would have major pitfalls. </span><span class="koboSpan" id="kobo.296.3">If filesystems were designed to accommodate multiple files in a single block, they would need to devise a mechanism that would keep track of individual file boundaries within a single block. </span><span class="koboSpan" id="kobo.296.4">This would increase the design complexity by a fair margin. </span><span class="koboSpan" id="kobo.296.5">Additionally, this would lead to massive fragmentation, which would degrade the filesystem performance. </span><span class="koboSpan" id="kobo.296.6">If the size of a file increases, the incoming data would have to be adjusted in a separate block. </span><span class="koboSpan" id="kobo.296.7">Files would be stored in random blocks and there would be no sequential access. </span><span class="koboSpan" id="kobo.296.8">All of this would result in poor filesystem performance and neutralize any advantage gained from this condensed approach. </span><span class="koboSpan" id="kobo.296.9">Therefore, every file occupies a full block, even if its size is less than the filesystem </span><span class="No-Break"><span class="koboSpan" id="kobo.297.1">block size.</span></span></p>
<h2 id="_idParaDest-62"><a id="_idTextAnchor064"/><span class="koboSpan" id="kobo.298.1">The structural layout of an Ext4 filesystem</span></h2>
<p><span class="koboSpan" id="kobo.299.1">The individual blocks in Ext4 are arranged into another unit called block groups. </span><span class="koboSpan" id="kobo.299.2">A </span><strong class="bold"><span class="koboSpan" id="kobo.300.1">block group</span></strong><span class="koboSpan" id="kobo.301.1"> is a collection of contiguous blocks. </span><span class="koboSpan" id="kobo.301.2">When it comes to the organization of the block group, there are two cases. </span><span class="koboSpan" id="kobo.301.3">For the first block group, the first 1,024 bytes are not used. </span><span class="koboSpan" id="kobo.301.4">These are reserved for the installation of boot sectors. </span><span class="koboSpan" id="kobo.301.5">For the first block group, the layout is </span><span class="No-Break"><span class="koboSpan" id="kobo.302.1">as follows:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer030">
<span class="koboSpan" id="kobo.303.1"><img alt="Figure 3.6 – Layout for block group 0" src="image/B19430_03_06.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.304.1">Figure 3.6 – Layout for block group 0</span></p>
<p><span class="koboSpan" id="kobo.305.1">If the filesystem is created with a block size of 1 KB, the superblock will be kept in the next block. </span><span class="koboSpan" id="kobo.305.2">For all other block groups, the layout becomes </span><span class="No-Break"><span class="koboSpan" id="kobo.306.1">the following:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer031">
<span class="koboSpan" id="kobo.307.1"><img alt="Figure 3.7 – Layout for block group 1 and onward" src="image/B19430_03_07.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.308.1">Figure 3.7 – Layout for block group 1 and onward</span></p>
<p><span class="koboSpan" id="kobo.309.1">Let’s discuss the constituents of an Ext4 </span><span class="No-Break"><span class="koboSpan" id="kobo.310.1">block group.</span></span></p>
<h3><span class="koboSpan" id="kobo.311.1">Superblock</span></h3>
<p><span class="koboSpan" id="kobo.312.1">As explained in </span><a href="B19430_02.xhtml#_idTextAnchor028"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.313.1">Chapter 2</span></em></span></a><span class="koboSpan" id="kobo.314.1">, the </span><strong class="bold"><span class="koboSpan" id="kobo.315.1">superblock</span></strong><span class="koboSpan" id="kobo.316.1"> is one of the major data structures in VFS. </span><span class="koboSpan" id="kobo.316.2">It is mandatory for a filesystem to implement a superblock structure that contains the metadata of a filesystem. </span><span class="koboSpan" id="kobo.316.3">The Ext4 superblock is defined in </span><strong class="source-inline"><span class="koboSpan" id="kobo.317.1">fs/ext4/ext4.h</span></strong><span class="koboSpan" id="kobo.318.1"> and, as shown next, it contains dozens of fields defining the different attributes of </span><span class="No-Break"><span class="koboSpan" id="kobo.319.1">the filesystem:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.320.1">
struct ext4_super_block {
  __le32  s_inodes_count;         /* Inodes count */
        __le32  s_blocks_count_lo;      /* Blocks count */
        __le32  s_r_blocks_count_lo;    /* Reserved blocks count */
        __le32  s_free_blocks_count_lo; /* Free blocks count */
    __le32  s_free_inodes_count;    /* Free inodes count */
        __le32  s_first_data_block;     /* First Data Block */
        __le32  s_log_block_size;       /* Block size */
        __le32  s_log_cluster_size;     /* Allocation cluster size */
/*20*/  __le32  s_blocks_per_group;     /* # Blocks per group */
        __le32  s_clusters_per_group;   /* # Clusters per group */
        __le32  s_inodes_per_group;     /* # Inodes per group */
        __le32  s_mtime;                /* Mount time */
/*30*/  __le32  s_wtime;                /* Write time */
        __le16  s_mnt_count;            /* Mount count */
[……]</span></pre>
<p><span class="koboSpan" id="kobo.321.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.322.1">__le32</span></strong><span class="koboSpan" id="kobo.323.1"> data types indicate that the representation is in little-endian order. </span><span class="koboSpan" id="kobo.323.2">As evident from its definition in the kernel source, the Ext4 superblock defines a number of properties to characterize the filesystem. </span><span class="koboSpan" id="kobo.323.3">This contains information such as the total number of blocks and block groups in the filesystem, the total number of used and unused blocks, the block size, the total number of used and unused inodes, the filesystem state, and a lot more. </span><span class="koboSpan" id="kobo.323.4">The information contained in a superblock is of utmost importance as it is the first thing that is read when mounting a filesystem. </span><span class="koboSpan" id="kobo.323.5">Given its critical nature, multiple copies of the superblock are kept at </span><span class="No-Break"><span class="koboSpan" id="kobo.324.1">different locations.</span></span></p>
<p><span class="koboSpan" id="kobo.325.1">Most fields in the superblock definition are easily understood. </span><span class="koboSpan" id="kobo.325.2">Some interesting fields are </span><span class="No-Break"><span class="koboSpan" id="kobo.326.1">explained here:</span></span></p>
<ul>
<li><strong class="bold"><span class="koboSpan" id="kobo.327.1">Block size calculation</span></strong><span class="koboSpan" id="kobo.328.1">: The block size of the Ext4 filesystem is computed using this 32-bit value. </span><span class="koboSpan" id="kobo.328.2">The block size is calculated </span><span class="No-Break"><span class="koboSpan" id="kobo.329.1">as follows:</span></span></li>
</ul>
<p><em class="italic"><span class="koboSpan" id="kobo.330.1">Ext4 block size = 2 ^ (10 + </span></em><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.331.1">s_log_block_size)</span></em></span></p>
<p><span class="koboSpan" id="kobo.332.1">The minimum block size of an Ext4 filesystem can be 1 KB when </span><strong class="source-inline"><span class="koboSpan" id="kobo.333.1">s_log_block_size</span></strong><span class="koboSpan" id="kobo.334.1"> is zero. </span><span class="koboSpan" id="kobo.334.2">The Ext4 filesystem supports a maximum block size of </span><span class="No-Break"><span class="koboSpan" id="kobo.335.1">64 KB.</span></span></p>
<ul>
<li><strong class="bold"><span class="koboSpan" id="kobo.336.1">Block clusters</span></strong><span class="koboSpan" id="kobo.337.1">: Even though the capacity of disk drives has grown exponentially in the last few years, the Ext4 filesystem works with block sizes of a few kilobytes. </span><span class="koboSpan" id="kobo.337.2">The bigger the drive, the larger the number of blocks and their overhead. </span><span class="koboSpan" id="kobo.337.3">As a workaround, the Ext4 developers added the functionality of block clusters in Ext4. </span><span class="koboSpan" id="kobo.337.4">Instead of allocating single 4 KB blocks, a filesystem can allocate blocks in larger groups using the concept of block groups. </span><span class="koboSpan" id="kobo.337.5">The Ext4 filesystem maintains the mapping between these larger blocks and 4 KB blocks. </span><span class="koboSpan" id="kobo.337.6">This feature is known as </span><strong class="bold"><span class="koboSpan" id="kobo.338.1">bigalloc</span></strong><span class="koboSpan" id="kobo.339.1">. </span><span class="koboSpan" id="kobo.339.2">The block cluster size can be specified at filesystem creation time and is stored </span><span class="No-Break"><span class="koboSpan" id="kobo.340.1">in </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.341.1">s_log_cluster_size</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.342.1">.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.343.1">Filesystem state and checks</span></strong><span class="koboSpan" id="kobo.344.1">: The filesystem consistency check can be triggered in three cases. </span><span class="koboSpan" id="kobo.344.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.345.1">s_mnt_count</span></strong><span class="koboSpan" id="kobo.346.1"> field indicates the number of times the filesystem has been mounted since the last consistency check was run. </span><span class="koboSpan" id="kobo.346.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.347.1">s_max_mnt_count</span></strong><span class="koboSpan" id="kobo.348.1"> field imposes a hard limit on the number of mounts, beyond which a consistency check is mandatory. </span><span class="koboSpan" id="kobo.348.2">The filesystem state is saved in </span><strong class="source-inline"><span class="koboSpan" id="kobo.349.1">s_state</span></strong><span class="koboSpan" id="kobo.350.1">. </span><span class="koboSpan" id="kobo.350.2">It can be one of </span><span class="No-Break"><span class="koboSpan" id="kobo.351.1">the following:</span></span><ul><li><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.352.1">cleanly unmounted</span></strong></span></li><li><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.353.1">errors detected</span></strong></span></li><li><strong class="source-inline"><span class="koboSpan" id="kobo.354.1">orphans </span></strong><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.355.1">being recovered</span></strong></span></li></ul></li>
</ul>
<p><span class="koboSpan" id="kobo.356.1">If the filesystem state in </span><strong class="source-inline"><span class="koboSpan" id="kobo.357.1">s_state</span></strong><span class="koboSpan" id="kobo.358.1"> is not clean, the check is enforced automatically. </span><span class="koboSpan" id="kobo.358.2">The date of the last consistency check is saved in </span><strong class="source-inline"><span class="koboSpan" id="kobo.359.1">s_lastcheck</span></strong><span class="koboSpan" id="kobo.360.1">. </span><span class="koboSpan" id="kobo.360.2">If the time specified in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.361.1">s_checkinterval</span></strong><span class="koboSpan" id="kobo.362.1"> field has passed since the last check, the consistency check is enforced on </span><span class="No-Break"><span class="koboSpan" id="kobo.363.1">the filesystem.</span></span></p>
<ul>
<li><strong class="bold"><span class="koboSpan" id="kobo.364.1">Magic signatures</span></strong><span class="koboSpan" id="kobo.365.1">: Different filesystems use the concept of a magic number that appears at a certain offset. </span><span class="koboSpan" id="kobo.365.2">Different tools use this number as a way of identifying a particular filesystem type. </span><span class="koboSpan" id="kobo.365.3">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.366.1">s_magic</span></strong><span class="koboSpan" id="kobo.367.1"> field in the superblock contains this magic number. </span><span class="koboSpan" id="kobo.367.2">For Ext4, its value is </span><strong class="source-inline"><span class="koboSpan" id="kobo.368.1">0xEF53</span></strong><span class="koboSpan" id="kobo.369.1">. </span><span class="koboSpan" id="kobo.369.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.370.1">s_rev_level</span></strong><span class="koboSpan" id="kobo.371.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.372.1">s_minor_rev_level</span></strong><span class="koboSpan" id="kobo.373.1"> fields are used to differentiate between </span><span class="No-Break"><span class="koboSpan" id="kobo.374.1">filesystem versions.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.375.1">Block reservation</span></strong><span class="koboSpan" id="kobo.376.1">: These are the default user and group IDs for reserved blocks. </span><span class="koboSpan" id="kobo.376.2">These default to a value of </span><strong class="source-inline"><span class="koboSpan" id="kobo.377.1">0</span></strong><span class="koboSpan" id="kobo.378.1"> (root user). </span><span class="koboSpan" id="kobo.378.2">An Ext4 filesystem reserves 5% of filesystem blocks for the super or root user. </span><span class="koboSpan" id="kobo.378.3">This is done so that the root user processes continue to run, even if the non-root processes cannot write to </span><span class="No-Break"><span class="koboSpan" id="kobo.379.1">the filesystem.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.380.1">First inode number</span></strong><span class="koboSpan" id="kobo.381.1">: This is the first inode number that can be used for regular files and directories. </span><span class="koboSpan" id="kobo.381.2">This value is usually </span><strong class="source-inline"><span class="koboSpan" id="kobo.382.1">11</span></strong><span class="koboSpan" id="kobo.383.1">, which belongs to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.384.1">lost+found</span></strong><span class="koboSpan" id="kobo.385.1"> directory on an </span><span class="No-Break"><span class="koboSpan" id="kobo.386.1">Ext4 filesystem.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.387.1">Filesystem UUID</span></strong><span class="koboSpan" id="kobo.388.1">: This is a 128-bit value that is used as a unique volume identifier for an Ext4 filesystem. </span><span class="koboSpan" id="kobo.388.2">On systems where drives are added and removed often, the device names (such as </span><strong class="source-inline"><span class="koboSpan" id="kobo.389.1">sda</span></strong><span class="koboSpan" id="kobo.390.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.391.1">sdb</span></strong><span class="koboSpan" id="kobo.392.1">) can often change, resulting in confusion and incorrect mount points. </span><span class="koboSpan" id="kobo.392.2">The UUID is a unique identifier for a filesystem and can be used in </span><strong class="source-inline"><span class="koboSpan" id="kobo.393.1">/etc/fstab</span></strong><span class="koboSpan" id="kobo.394.1"> to </span><span class="No-Break"><span class="koboSpan" id="kobo.395.1">mount filesystems.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.396.1">Compatible features</span></strong><span class="koboSpan" id="kobo.397.1">: Both these values are 32-bit. </span><span class="koboSpan" id="kobo.397.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.398.1">s_feature_compat</span></strong><span class="koboSpan" id="kobo.399.1"> field contains a 32-bit bitmask of compatible features. </span><span class="koboSpan" id="kobo.399.2">The filesystem is free to support the features defined in this field. </span><span class="koboSpan" id="kobo.399.3">On the other hand, if any feature defined in </span><strong class="source-inline"><span class="koboSpan" id="kobo.400.1">s_feature_incompat</span></strong><span class="koboSpan" id="kobo.401.1"> is not understood by the kernel, the filesystem mount operation will </span><span class="No-Break"><span class="koboSpan" id="kobo.402.1">not succeed.</span></span></li>
</ul>
<h3><span class="koboSpan" id="kobo.403.1">Data block and inode bitmaps</span></h3>
<p><span class="koboSpan" id="kobo.404.1">The Ext4 filesystem uses a negligible amount of space to organize some internal structures. </span><span class="koboSpan" id="kobo.404.2">Most of the space in a filesystem is used for storing user data. </span><span class="koboSpan" id="kobo.404.3">The Ext4 filesystem stores user data in data blocks. </span><span class="koboSpan" id="kobo.404.4">As we learned in </span><a href="B19430_02.xhtml#_idTextAnchor028"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.405.1">Chapter 2</span></em></span></a><span class="koboSpan" id="kobo.406.1">, the metadata of each file is stored in a separate structure, called an inode. </span><span class="koboSpan" id="kobo.406.2">The inodes are also stored on disk, albeit in a reserved space. </span><span class="koboSpan" id="kobo.406.3">Inodes are unique in a filesystem. </span><span class="koboSpan" id="kobo.406.4">Every filesystem uses a technique to keep track of allocated and available inodes. </span><span class="koboSpan" id="kobo.406.5">Similarly, there has to be a method through which the number of allocated and free blocks can </span><span class="No-Break"><span class="koboSpan" id="kobo.407.1">be tracked.</span></span></p>
<p><span class="koboSpan" id="kobo.408.1">Ext4 uses a bitmap as an allocation structure. </span><span class="koboSpan" id="kobo.408.2">A bitmap is a sequence of bits. </span><span class="koboSpan" id="kobo.408.3">Separate bitmaps are used to track the number of inodes and data blocks. </span><span class="koboSpan" id="kobo.408.4">The data block bitmap tracks the usage of data blocks within the block group. </span><span class="koboSpan" id="kobo.408.5">Similarly, the inode bitmap keeps track of entries in the inode table. </span><span class="koboSpan" id="kobo.408.6">A bit value of </span><strong class="source-inline"><span class="koboSpan" id="kobo.409.1">0</span></strong><span class="koboSpan" id="kobo.410.1"> indicates that the block or inode is available for use. </span><span class="koboSpan" id="kobo.410.2">A value of </span><strong class="source-inline"><span class="koboSpan" id="kobo.411.1">1</span></strong><span class="koboSpan" id="kobo.412.1"> indicates that the block or inode </span><span class="No-Break"><span class="koboSpan" id="kobo.413.1">is occupied.</span></span></p>
<p><span class="koboSpan" id="kobo.414.1">The bitmaps for both the inode and data block are of one block each. </span><span class="koboSpan" id="kobo.414.2">As a byte is composed of 8 bits, that means, for the default block size of 4 KB, the block bitmap can represent a maximum of 8 x 4 KB = 32,768 blocks per group. </span><span class="koboSpan" id="kobo.414.3">This can be verified in the output of </span><strong class="source-inline"><span class="koboSpan" id="kobo.415.1">mkfs</span></strong><span class="koboSpan" id="kobo.416.1"> or through the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.417.1">tune2fs</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.418.1"> program.</span></span></p>
<h3><span class="koboSpan" id="kobo.419.1">Inode tables</span></h3>
<p><span class="koboSpan" id="kobo.420.1">In addition to inode bitmaps, a block group also contains an inode table. </span><span class="koboSpan" id="kobo.420.2">The inode table spans a series of consecutive blocks. </span><span class="koboSpan" id="kobo.420.3">The definition of an Ext4 inode is present in the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.421.1">fs/ext4/ext4.h</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.422.1"> file:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.423.1">
struct ext4_inode {
        __le16  i_mode;         /* File mode */
        __le16  i_uid;          /* Low 16 bits of Owner Uid */
        __le32  i_size_lo;      /* Size in bytes */
        __le32  i_atime;        /* Access time */
        __le32  i_ctime;        /* Inode Change time */
        __le32  i_mtime;        /* Modification time */
        __le32  i_dtime;        /* Deletion Time */
        __le16  i_gid;          /* Low 16 bits of Group Id */
        __le16  i_links_count;  /* Links count */
        __le32  i_blocks_lo;    /* Blocks count */
        __le32  i_flags;        /* File flags */
[…………..]</span></pre>
<p><span class="koboSpan" id="kobo.424.1">The Ext4 inode has a size of 256 bytes. </span><span class="koboSpan" id="kobo.424.2">Some fields of particular interest are </span><span class="No-Break"><span class="koboSpan" id="kobo.425.1">as follows:</span></span></p>
<ul>
<li><strong class="bold"><span class="koboSpan" id="kobo.426.1">Ownership</span></strong><span class="koboSpan" id="kobo.427.1">: The </span><strong class="source-inline"><span class="koboSpan" id="kobo.428.1">i_uid</span></strong><span class="koboSpan" id="kobo.429.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.430.1">i_gid</span></strong><span class="koboSpan" id="kobo.431.1"> fields serve as the user and </span><span class="No-Break"><span class="koboSpan" id="kobo.432.1">group identifiers.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.433.1">Timestamps</span></strong><span class="koboSpan" id="kobo.434.1">: The timestamps for a particular file are saved in </span><strong class="source-inline"><span class="koboSpan" id="kobo.435.1">i_atime</span></strong><span class="koboSpan" id="kobo.436.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.437.1">i_ctime</span></strong><span class="koboSpan" id="kobo.438.1">, and </span><strong class="source-inline"><span class="koboSpan" id="kobo.439.1">i_mtime</span></strong><span class="koboSpan" id="kobo.440.1">. </span><span class="koboSpan" id="kobo.440.2">These describe the last access time, inode change time, and data modification time, respectively. </span><span class="koboSpan" id="kobo.440.3">The file deletion time is saved in </span><strong class="source-inline"><span class="koboSpan" id="kobo.441.1">i_dtime</span></strong><span class="koboSpan" id="kobo.442.1">. </span><span class="koboSpan" id="kobo.442.2">These 4 fields are 32-bit signed integers that represent the elapsed seconds since the Unix epoch time, January 1, 1970, 00:00:00 UTC. </span><span class="koboSpan" id="kobo.442.3">For calculating time with subsecond accuracy, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.443.1">i_atime_extra</span></strong><span class="koboSpan" id="kobo.444.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.445.1">i_mtime_extra</span></strong><span class="koboSpan" id="kobo.446.1">, and </span><strong class="source-inline"><span class="koboSpan" id="kobo.447.1">i_ctime_extra</span></strong><span class="koboSpan" id="kobo.448.1"> fields </span><span class="No-Break"><span class="koboSpan" id="kobo.449.1">are used.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.450.1">Hard links</span></strong><span class="koboSpan" id="kobo.451.1">: In contrast to a soft link, a hard link points to a file by its inode number. </span><span class="koboSpan" id="kobo.451.2">The hard link count of a file is defined in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.452.1">i_links_count</span></strong><span class="koboSpan" id="kobo.453.1"> field. </span><span class="koboSpan" id="kobo.453.2">This is a 16-bit value, which means that Ext4 allows for a maximum of 65K hard links for </span><span class="No-Break"><span class="koboSpan" id="kobo.454.1">a file.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.455.1">Data block pointers</span></strong><span class="koboSpan" id="kobo.456.1">: In addition to some generic metadata, an inode also holds information about the on-disk locations of data blocks. </span><span class="koboSpan" id="kobo.456.2">This information is kept in </span><strong class="source-inline"><span class="koboSpan" id="kobo.457.1">i_block</span></strong><span class="koboSpan" id="kobo.458.1">, which is an array of length </span><strong class="source-inline"><span class="koboSpan" id="kobo.459.1">EXT4_N_BLOCKS</span></strong><span class="koboSpan" id="kobo.460.1">. </span><span class="koboSpan" id="kobo.460.2">The value of </span><strong class="source-inline"><span class="koboSpan" id="kobo.461.1">EXT4_N_BLOCKS</span></strong><span class="koboSpan" id="kobo.462.1"> is </span><strong class="source-inline"><span class="koboSpan" id="kobo.463.1">15</span></strong><span class="koboSpan" id="kobo.464.1">. </span><span class="koboSpan" id="kobo.464.2">As discussed in </span><a href="B19430_02.xhtml#_idTextAnchor028"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.465.1">Chapter 2</span></em></span></a><span class="koboSpan" id="kobo.466.1">, an inode structure uses pointers for block addressing. </span><span class="koboSpan" id="kobo.466.2">First, 12 pointers point directly to block addresses and are called </span><strong class="bold"><span class="koboSpan" id="kobo.467.1">direct pointers</span></strong><span class="koboSpan" id="kobo.468.1">. </span><span class="koboSpan" id="kobo.468.2">The next three pointers are indirect pointers. </span><span class="koboSpan" id="kobo.468.3">An </span><strong class="bold"><span class="koboSpan" id="kobo.469.1">indirect pointer</span></strong><span class="koboSpan" id="kobo.470.1"> points to a block of pointers. </span><span class="koboSpan" id="kobo.470.2">The 13th, 14th, and 15th pointers provide single-, double-, and </span><span class="No-Break"><span class="koboSpan" id="kobo.471.1">triple-level indirection.</span></span></li>
</ul>
<h3><span class="koboSpan" id="kobo.472.1">Group descriptors</span></h3>
<p><span class="koboSpan" id="kobo.473.1">Group descriptors are stored just after the superblock in the filesystem layout. </span><span class="koboSpan" id="kobo.473.2">Every block group has a group descriptor associated with it, so there are as many group descriptors as the number of block groups. </span><span class="koboSpan" id="kobo.473.3">It’s important to understand that the block group descriptors describe the contents of each block group in the filesystem. </span><span class="koboSpan" id="kobo.473.4">This means they include information about the local, as well as all the other block groups in the filesystem. </span><span class="koboSpan" id="kobo.473.5">The group descriptor structure is defined </span><span class="No-Break"><span class="koboSpan" id="kobo.474.1">in </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.475.1">fs/ext4/ext4.h</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.476.1">:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.477.1">
struct ext4_group_desc
{
        __le32  bg_block_bitmap_lo;     /* Blocks bitmap block */
        __le32  bg_inode_bitmap_lo;     /* Inodes bitmap block */
        __le32  bg_inode_table_lo;      /* Inodes table block */
        __le16  bg_free_blocks_count_lo;/* Free blocks count */
        __le16  bg_free_inodes_count_lo;/* Free inodes count */
        __le16  bg_used_dirs_count_lo;  /* Directories count */
        __le16  bg_flags;               /* EXT4_BG_flags (INODE_UNINIT, etc) */
[…………]</span></pre>
<p><span class="koboSpan" id="kobo.478.1">Some important fields are </span><span class="No-Break"><span class="koboSpan" id="kobo.479.1">described further:</span></span></p>
<ul>
<li><strong class="bold"><span class="koboSpan" id="kobo.480.1">Bitmap location</span></strong><span class="koboSpan" id="kobo.481.1">: The group descriptors contain information about the on-disk locations of block bitmaps, inode bitmaps, and the inode table. </span><span class="koboSpan" id="kobo.481.2">This information is stored in the following fields in the form of the least and most significant bits. </span><span class="koboSpan" id="kobo.481.3">The least significant bits are stored in </span><strong class="source-inline"><span class="koboSpan" id="kobo.482.1">bg_block_bitmap_lo</span></strong><span class="koboSpan" id="kobo.483.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.484.1">bg_inode_bitmap_lo</span></strong><span class="koboSpan" id="kobo.485.1">, and </span><strong class="source-inline"><span class="koboSpan" id="kobo.486.1">bg_inode_table_lo</span></strong><span class="koboSpan" id="kobo.487.1">, whereas the most significant bits are stored in </span><strong class="source-inline"><span class="koboSpan" id="kobo.488.1">bg_block_bitmap_hi</span></strong><span class="koboSpan" id="kobo.489.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.490.1">bg_inode_bitmap_hi</span></strong><span class="koboSpan" id="kobo.491.1">, </span><span class="No-Break"><span class="koboSpan" id="kobo.492.1">and </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.493.1">bg_inode_table_hi</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.494.1">.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.495.1">Block and inode usage</span></strong><span class="koboSpan" id="kobo.496.1">: The group descriptors also contain information about the number of free blocks, inodes, and directories. </span><span class="koboSpan" id="kobo.496.2">This is also stored in the form of the least and most significant bits. </span><span class="koboSpan" id="kobo.496.3">The fields used to store this information are </span><strong class="source-inline"><span class="koboSpan" id="kobo.497.1">bg_free_blocks_count_lo</span></strong><span class="koboSpan" id="kobo.498.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.499.1">bg_free_blocks_count_hi</span></strong><span class="koboSpan" id="kobo.500.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.501.1">bg_free_inodes_count_lo</span></strong><span class="koboSpan" id="kobo.502.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.503.1">bg_free_inodes_count_hi</span></strong><span class="koboSpan" id="kobo.504.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.505.1">bg_used_dirs_count_lo</span></strong><span class="koboSpan" id="kobo.506.1">, </span><span class="No-Break"><span class="koboSpan" id="kobo.507.1">and </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.508.1">bg_used_dirs_count_hi</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.509.1">.</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.510.1">As each block group descriptor includes information about both local and non-local block groups, it contains a descriptor for each block group in the filesystem. </span><span class="koboSpan" id="kobo.510.2">Because of this, the following information can be determined from any single </span><span class="No-Break"><span class="koboSpan" id="kobo.511.1">block group:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.512.1">The number of free blocks </span><span class="No-Break"><span class="koboSpan" id="kobo.513.1">and inodes</span></span></li>
<li><span class="koboSpan" id="kobo.514.1">The location of the inode table in </span><span class="No-Break"><span class="koboSpan" id="kobo.515.1">the filesystem</span></span></li>
<li><span class="koboSpan" id="kobo.516.1">The location of block and </span><span class="No-Break"><span class="koboSpan" id="kobo.517.1">inode bitmaps</span></span></li>
</ul>
<h3><span class="koboSpan" id="kobo.518.1">Reserved GDT blocks</span></h3>
<p><span class="koboSpan" id="kobo.519.1">One of the most useful features of an Ext4 filesystem is its on-the-fly expansion. </span><span class="koboSpan" id="kobo.519.2">The size of an Ext4 filesystem can be increased on the fly without any disruption. </span><span class="koboSpan" id="kobo.519.3">The reserved </span><strong class="bold"><span class="koboSpan" id="kobo.520.1">group descriptor table</span></strong><span class="koboSpan" id="kobo.521.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.522.1">GDT</span></strong><span class="koboSpan" id="kobo.523.1">) blocks are put aside at the time of filesystem creation. </span><span class="koboSpan" id="kobo.523.2">This is done to aid in the process of filesystem expansion. </span><span class="koboSpan" id="kobo.523.3">Increasing the size of the filesystem involves the addition of physical disk space and the creation of filesystem blocks in the newly added disk space. </span><span class="koboSpan" id="kobo.523.4">This also means that to accommodate the newly added space, more block groups and group descriptors will be required. </span><span class="koboSpan" id="kobo.523.5">These reserved GDT blocks are used when an Ext4 filesystem is to </span><span class="No-Break"><span class="koboSpan" id="kobo.524.1">be extended.</span></span></p>
<h3><span class="koboSpan" id="kobo.525.1">Journaling modes</span></h3>
<p><span class="koboSpan" id="kobo.526.1">Like most filesystems, Ext4 also implements the concept of journaling to prevent data corruption and inconsistencies in the case of a system crash. </span><span class="koboSpan" id="kobo.526.2">The default journal size is typically just a few megabytes. </span><span class="koboSpan" id="kobo.526.3">The journaling in Ext4 uses the generic journaling layer in the kernel, known as the </span><strong class="bold"><span class="koboSpan" id="kobo.527.1">journaling block device</span></strong><span class="koboSpan" id="kobo.528.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.529.1">JBD</span></strong><span class="koboSpan" id="kobo.530.1"> or </span><strong class="bold"><span class="koboSpan" id="kobo.531.1">JBD2</span></strong><span class="koboSpan" id="kobo.532.1">). </span><span class="koboSpan" id="kobo.532.2">If you’ve ever checked the top I/O consuming processes on a busy Linux system, you might have seen the </span><strong class="source-inline"><span class="koboSpan" id="kobo.533.1">jbd2</span></strong><span class="koboSpan" id="kobo.534.1"> process in that list. </span><span class="koboSpan" id="kobo.534.2">This is the kernel thread responsible for updating the </span><span class="No-Break"><span class="koboSpan" id="kobo.535.1">Ext4 journal.</span></span></p>
<p><span class="koboSpan" id="kobo.536.1">Ext4 offers a great deal of flexibility when it comes to journaling. </span><span class="koboSpan" id="kobo.536.2">The Ext4 filesystem supports three journaling modes. </span><span class="koboSpan" id="kobo.536.3">Depending upon the requirements, the journaling mode can be changed if required. </span><span class="koboSpan" id="kobo.536.4">By default, journaling is enabled at the time of filesystem creation. </span><span class="koboSpan" id="kobo.536.5">If desired, it can be disabled later. </span><span class="koboSpan" id="kobo.536.6">The different journaling modes are </span><span class="No-Break"><span class="koboSpan" id="kobo.537.1">explained here:</span></span></p>
<ul>
<li><strong class="bold"><span class="koboSpan" id="kobo.538.1">Ordered</span></strong><span class="koboSpan" id="kobo.539.1">: In ordered mode, only metadata is journaled. </span><span class="koboSpan" id="kobo.539.2">The actual data is directly written to disk. </span><span class="koboSpan" id="kobo.539.3">The order of the operations is strictly followed. </span><span class="koboSpan" id="kobo.539.4">First, the metadata is written to the journal; second, the actual data is written to disk; and last, the metadata is written to disk. </span><span class="koboSpan" id="kobo.539.5">If there is a crash, filesystem structures are preserved. </span><span class="koboSpan" id="kobo.539.6">However, the data being written at the time of the crash may </span><span class="No-Break"><span class="koboSpan" id="kobo.540.1">be lost.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.541.1">Writeback</span></strong><span class="koboSpan" id="kobo.542.1">: The writeback mode also only journals metadata. </span><span class="koboSpan" id="kobo.542.2">The difference is that actual data and metadata can be written in any order. </span><span class="koboSpan" id="kobo.542.3">This is a slightly more risky approach than ordered mode but offers much </span><span class="No-Break"><span class="koboSpan" id="kobo.543.1">better performance.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.544.1">Journal</span></strong><span class="koboSpan" id="kobo.545.1">: In journal mode, both data and metadata are written to the journal first, before being committed to the disk. </span><span class="koboSpan" id="kobo.545.2">This offers the highest level of security and consistency but can adversely affect performance, as all write operations have to be </span><span class="No-Break"><span class="koboSpan" id="kobo.546.1">performed twice.</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.547.1">The default journaling mode is </span><em class="italic"><span class="koboSpan" id="kobo.548.1">ordered</span></em><span class="koboSpan" id="kobo.549.1">. </span><span class="koboSpan" id="kobo.549.2">If you want to change the journal mode, you’ll need to unmount the filesystem and add the desired mode in the corresponding </span><strong class="source-inline"><span class="koboSpan" id="kobo.550.1">fstab</span></strong><span class="koboSpan" id="kobo.551.1"> entry. </span><span class="koboSpan" id="kobo.551.2">For instance, to change the journaling mode to </span><em class="italic"><span class="koboSpan" id="kobo.552.1">writeback</span></em><span class="koboSpan" id="kobo.553.1">, add </span><strong class="source-inline"><span class="koboSpan" id="kobo.554.1">data=writeback</span></strong><span class="koboSpan" id="kobo.555.1"> against the relevant filesystem entry in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.556.1">/etc/fstab</span></strong><span class="koboSpan" id="kobo.557.1"> file. </span><span class="koboSpan" id="kobo.557.2">Once done, you can verify the journaling mode </span><span class="No-Break"><span class="koboSpan" id="kobo.558.1">as follows:</span></span></p>
<pre class="source-code">
<strong class="bold"><span class="koboSpan" id="kobo.559.1">[root@linuxbox ~]# mount |grep sdc</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.560.1">/dev/sdc on /mnt type ext4 (rw,relatime,data=writeback)</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.561.1">[root@linuxbox ~]#</span></strong></pre>
<p><span class="koboSpan" id="kobo.562.1">You can also display information about the filesystem journal using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.563.1">logdump</span></strong><span class="koboSpan" id="kobo.564.1"> command from </span><strong class="source-inline"><span class="koboSpan" id="kobo.565.1">debugfs</span></strong><span class="koboSpan" id="kobo.566.1">. </span><span class="koboSpan" id="kobo.566.2">For instance, you can check the journal for the </span><strong class="source-inline"><span class="koboSpan" id="kobo.567.1">sdc</span></strong><span class="koboSpan" id="kobo.568.1"> device </span><span class="No-Break"><span class="koboSpan" id="kobo.569.1">as follows:</span></span></p>
<pre class="source-code">
<strong class="bold"><span class="koboSpan" id="kobo.570.1">[root@linuxbox ~]#  debugfs -R 'logdump -S' /dev/sdc</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.571.1">debugfs 1.44.6 (5-Mar-2019)</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.572.1">Journal features:         journal_64bit journal_checksum_v3</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.573.1">Journal size:             32M</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.574.1">Journal length:           8192</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.575.1">Journal sequence:         0x00000005</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.576.1">Journal start:            1</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.577.1">Journal checksum type:    crc32c</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.578.1">Journal checksum:         0xb78622f2</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.579.1">Journal starts at block 1, transaction 5</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.580.1">Found expected sequence 5, type 1 (descriptor block) at block 1</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.581.1">Found expected sequence 5, type 2 (commit block) at block 13</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.582.1">Found expected sequence 6, type 1 (descriptor block) at block 14</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.583.1">[…............]</span></strong></pre>
<h3><span class="koboSpan" id="kobo.584.1">Filesystem extents</span></h3>
<p><span class="koboSpan" id="kobo.585.1">We’ve covered the use of indirect pointers to address large files. </span><span class="koboSpan" id="kobo.585.2">Through the use of indirect pointers, an inode can keep track of data blocks that contain the file contents. </span><span class="koboSpan" id="kobo.585.3">For large files, this approach becomes a bit inefficient. </span><span class="koboSpan" id="kobo.585.4">The higher the number of blocks occupied by a file, the higher the number of pointers required to keep track of each block. </span><span class="koboSpan" id="kobo.585.5">This creates a complex mapping scheme and increases the metadata usage per file. </span><span class="koboSpan" id="kobo.585.6">As a result, some operations on large files are performed </span><span class="No-Break"><span class="koboSpan" id="kobo.586.1">rather slowly.</span></span></p>
<p><span class="koboSpan" id="kobo.587.1">Ext4 makes use of extents to address this problem and reduce the metadata required to keep track of data blocks. </span><span class="koboSpan" id="kobo.587.2">An </span><strong class="bold"><span class="koboSpan" id="kobo.588.1">extent</span></strong><span class="koboSpan" id="kobo.589.1"> is a pointer plus a length of blocks – basically, a bunch of contiguous physical blocks. </span><span class="koboSpan" id="kobo.589.2">When using extents, we only need to know the address of the first and last block of this contiguous range. </span><span class="koboSpan" id="kobo.589.3">For instance, let’s say that we’re using an extent size of 4 MB. </span><span class="koboSpan" id="kobo.589.4">To store a 100 MB file, we can allocate 25 contiguous blocks. </span><span class="koboSpan" id="kobo.589.5">Since the blocks are contiguous, we only need to remember the address of the first and last blocks. </span><span class="koboSpan" id="kobo.589.6">Assuming a block size of 4 KB, while using pointers, we would need to create an indirect mapping of 25,600 blocks to store a 100 </span><span class="No-Break"><span class="koboSpan" id="kobo.590.1">MB file.</span></span></p>
<h3><span class="koboSpan" id="kobo.591.1">Block allocation policies</span></h3>
<p><span class="koboSpan" id="kobo.592.1">When it comes to filesystem performance, fragmentation is a silent killer. </span><span class="koboSpan" id="kobo.592.2">The Ext4 filesystem uses several techniques to improve the overall performance and reduce fragmentation. </span><span class="koboSpan" id="kobo.592.3">The block allocation policies in Ext4 ensure that related information exists within the same filesystem </span><span class="No-Break"><span class="koboSpan" id="kobo.593.1">block group.</span></span></p>
<p><span class="koboSpan" id="kobo.594.1">When a new file is to be created and saved, the filesystem will need to initialize an inode for that file. </span><span class="koboSpan" id="kobo.594.2">Ext4 will then select an appropriate block group for that file. </span><span class="koboSpan" id="kobo.594.3">The design of Ext4 makes sure that maximum effort is made to do </span><span class="No-Break"><span class="koboSpan" id="kobo.595.1">the following:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.596.1">Allocate the inode in the block group that contains the parent directory of </span><span class="No-Break"><span class="koboSpan" id="kobo.597.1">the file</span></span></li>
<li><span class="koboSpan" id="kobo.598.1">Allocate a file to the block group that contains the </span><span class="No-Break"><span class="koboSpan" id="kobo.599.1">file’s inode</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.600.1">Once a file has been saved on disk, after some time, the user wants to add new data to the file. </span><span class="koboSpan" id="kobo.600.2">Ext4 will start a search for free blocks, from the block that was most recently allocated to </span><span class="No-Break"><span class="koboSpan" id="kobo.601.1">the file.</span></span></p>
<p><span class="koboSpan" id="kobo.602.1">When writing data to an Ext3 filesystem, the block allocator only allocated a single 4 KB block at a time. </span><span class="koboSpan" id="kobo.602.2">Assuming a block size of 4KB, for a single 100 MB file, the block allocator would need to be called 25,600 times. </span><span class="koboSpan" id="kobo.602.3">Similarly, when a file is extended and new blocks are allocated from the block group, they can be in random order. </span><span class="koboSpan" id="kobo.602.4">This random allocation can result in excessive disk seeking. </span><span class="koboSpan" id="kobo.602.5">This approach does not scale well and causes fragmentation and performance issues. </span><span class="koboSpan" id="kobo.602.6">The Ext4 filesystem offers a significant improvement on this through the use of a multi-block allocator. </span><span class="koboSpan" id="kobo.602.7">When a new file is created, the multi-block allocator in Ext4 allocates multiple blocks in a single call. </span><span class="koboSpan" id="kobo.602.8">This reduces the overhead and increases performance. </span><span class="koboSpan" id="kobo.602.9">If the file uses those blocks, the data is written in a single multi-block extent. </span><span class="koboSpan" id="kobo.602.10">If the file does not use the extra allocated blocks, they </span><span class="No-Break"><span class="koboSpan" id="kobo.603.1">are freed.</span></span></p>
<p><span class="koboSpan" id="kobo.604.1">The Ext4 filesystem uses delayed allocation and does not allocate the blocks immediately upon a write operation. </span><span class="koboSpan" id="kobo.604.2">This is done because the kernel makes heavy use of the page cache. </span><span class="koboSpan" id="kobo.604.3">All operations are first performed in the kernel’s page cache and then flushed to disk after some time. </span><span class="koboSpan" id="kobo.604.4">Using delayed allocation, the blocks are only allocated when data is actually being written to disk. </span><span class="koboSpan" id="kobo.604.5">This is extremely useful as the filesystem can then allocate contiguous extents for saving </span><span class="No-Break"><span class="koboSpan" id="kobo.605.1">the file.</span></span></p>
<p><span class="koboSpan" id="kobo.606.1">Ext4 tries to keep the data blocks of a file in the same block group as its inode. </span><span class="koboSpan" id="kobo.606.2">Similarly, all inodes in a directory are placed in the same block group as </span><span class="No-Break"><span class="koboSpan" id="kobo.607.1">the directory.</span></span></p>
<h3><span class="koboSpan" id="kobo.608.1">Examining the result of an mkfs operation</span></h3>
<p><span class="koboSpan" id="kobo.609.1">Let’s summarize our discussion about Ext4 and see what happens when we create an Ext4 filesystem using </span><strong class="source-inline"><span class="koboSpan" id="kobo.610.1">mkfs</span></strong><span class="koboSpan" id="kobo.611.1">. </span><span class="koboSpan" id="kobo.611.2">The following command was run on a disk of only </span><span class="No-Break"><span class="koboSpan" id="kobo.612.1">1 GB:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.613.1">
[root@linuxbox ~]# mkfs.ext4 -v /dev/sdb
mke2fs 1.44.6 (5-Mar-2019)
fs_types for mke2fs.conf resolution: 'ext4'
Discarding device blocks: done
Filesystem label=
OS type: Linux
Block size=4096 (log=2)
Fragment size=4096 (log=2)
Stride=0 blocks, Stripe width=0 blocks
65536 inodes, 262144 blocks
13107 blocks (5.00%) reserved for the super user
First data block=0
Maximum filesystem blocks=268435456
8 block groups
32768 blocks per group, 32768 fragments per group
8192 inodes per group
Filesystem UUID: ebcfa024-f87b-4c52-b3e1-25f1d4d31fec
Superblock backups stored on blocks:
        32768, 98304, 163840, 229376
Allocating group tables: done
Writing inode tables: done
Creating journal (8192 blocks): done
Writing superblocks and filesystem accounting information: done</span></pre>
<p><span class="koboSpan" id="kobo.614.1">Let’s examine </span><span class="No-Break"><span class="koboSpan" id="kobo.615.1">the output.</span></span></p>
<p><span class="koboSpan" id="kobo.616.1">As the man page of </span><strong class="source-inline"><span class="koboSpan" id="kobo.617.1">mkfs.ext4</span></strong><span class="koboSpan" id="kobo.618.1"> will tell you, the discarding device blocks feature is especially useful for solid-state drives. </span><span class="koboSpan" id="kobo.618.2">By default, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.619.1">mkfs</span></strong><span class="koboSpan" id="kobo.620.1"> command will issue a </span><strong class="source-inline"><span class="koboSpan" id="kobo.621.1">TRIM</span></strong><span class="koboSpan" id="kobo.622.1"> command to inform the underlying drive to erase </span><span class="No-Break"><span class="koboSpan" id="kobo.623.1">unused blocks.</span></span></p>
<p><span class="koboSpan" id="kobo.624.1">The filesystem consists of 262,144 blocks of 4 KB each. </span><span class="koboSpan" id="kobo.624.2">The total number of inodes in the filesystem is 65,536. </span><span class="koboSpan" id="kobo.624.3">The UUID can be used in </span><strong class="source-inline"><span class="koboSpan" id="kobo.625.1">fstab</span></strong><span class="koboSpan" id="kobo.626.1"> to mount </span><span class="No-Break"><span class="koboSpan" id="kobo.627.1">the filesystem.</span></span></p>
<p><span class="koboSpan" id="kobo.628.1">The stride and stripe widths are used when the underlying storage is a </span><span class="No-Break"><span class="koboSpan" id="kobo.629.1">RAID volume.</span></span></p>
<p><span class="koboSpan" id="kobo.630.1">An Ext4 filesystem will by default reserve 5% space for </span><span class="No-Break"><span class="koboSpan" id="kobo.631.1">the superuser.</span></span></p>
<p><span class="koboSpan" id="kobo.632.1">We see that the filesystem has divided the 262,144 blocks into 8 block groups. </span><span class="koboSpan" id="kobo.632.2">There are a total of 32,768 blocks per group. </span><span class="koboSpan" id="kobo.632.3">Each block has 8,192 inodes. </span><span class="koboSpan" id="kobo.632.4">This is in line with the total number of inodes mentioned earlier – that is, 8 x 8,192 = </span><span class="No-Break"><span class="koboSpan" id="kobo.633.1">65,536.</span></span></p>
<p><span class="koboSpan" id="kobo.634.1">The copies of the superblock structure are stored on multiple blocks. </span><span class="koboSpan" id="kobo.634.2">The filesystem will always be mounted using the primary superblock. </span><span class="koboSpan" id="kobo.634.3">But if the primary superblock gets corrupted for some reason, the filesystem can be mounted using the backups saved on different block locations. </span><span class="koboSpan" id="kobo.634.4">The filesystem journal occupies 8,192 blocks, which gives us a journal size of 8,192 x 4 KB = </span><span class="No-Break"><span class="koboSpan" id="kobo.635.1">32 MB.</span></span></p>
<p><span class="koboSpan" id="kobo.636.1">The extended filesystem is one of the oldest Linux-specific software projects. </span><span class="koboSpan" id="kobo.636.2">Over the years, it has gone through several enhancements in terms of reliability, scalability, and performance. </span><span class="koboSpan" id="kobo.636.3">Most of the concepts associated with Ext4, such as journaling, the use of extents, and delayed allocation, also apply to XFS, although XFS uses different techniques to implement these features. </span><span class="koboSpan" id="kobo.636.4">Like all block-based filesystems, Ext4 divides the available disk space into fixed-size blocks. </span><span class="koboSpan" id="kobo.636.5">Being a native filesystem, it makes extensive use of the structures defined in VFS and implements them as per its own design. </span><span class="koboSpan" id="kobo.636.6">Because of its proven track record of stability, it is the most used filesystem across </span><span class="No-Break"><span class="koboSpan" id="kobo.637.1">Linux distributions.</span></span></p>
<h1 id="_idParaDest-63"><a id="_idTextAnchor065"/><span class="koboSpan" id="kobo.638.1">Network filesystem</span></h1>
<p><span class="koboSpan" id="kobo.639.1">The evolution of computer networks and network protocols made remote file sharing possible. </span><span class="koboSpan" id="kobo.639.2">This gave rise to the concept of distributed computing and client-server architectures, which can be referred to as distributed filesystems. </span><span class="koboSpan" id="kobo.639.3">The idea was to store data on a central location on one or more servers. </span><span class="koboSpan" id="kobo.639.4">There are multiple clients that request access to this data through different programs and protocols. </span><span class="koboSpan" id="kobo.639.5">This includes protocols such as </span><strong class="bold"><span class="koboSpan" id="kobo.640.1">File Transfer Protocol</span></strong><span class="koboSpan" id="kobo.641.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.642.1">FTP</span></strong><span class="koboSpan" id="kobo.643.1">) and </span><strong class="bold"><span class="koboSpan" id="kobo.644.1">Secure File Transfer Protocol</span></strong><span class="koboSpan" id="kobo.645.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.646.1">SFTP</span></strong><span class="koboSpan" id="kobo.647.1">). </span><span class="koboSpan" id="kobo.647.2">The use of these programs makes it possible to transfer data between </span><span class="No-Break"><span class="koboSpan" id="kobo.648.1">two machines.</span></span></p>
<p><span class="koboSpan" id="kobo.649.1">As compared to any traditional filesystem, a filesystem that uses the distributed approach will require some additional elements for its functioning. </span><span class="koboSpan" id="kobo.649.2">We’ve seen that processes make use of the generic system call layer to issue read or write requests. </span><span class="koboSpan" id="kobo.649.3">In the case of conventional filesystems, both the process (which issues the request) and the storage (which serves that request) are part of the same system. </span><span class="koboSpan" id="kobo.649.4">In distributed systems, there can be a dedicated client-side application that is used for accessing the filesystem. </span><span class="koboSpan" id="kobo.649.5">In response to a generic system call such as </span><strong class="source-inline"><span class="koboSpan" id="kobo.650.1">read ()</span></strong><span class="koboSpan" id="kobo.651.1">, the client side will send a message to the server requesting read access to a </span><span class="No-Break"><span class="koboSpan" id="kobo.652.1">particular resource.</span></span></p>
<p><span class="koboSpan" id="kobo.653.1">One of the oldest </span><a id="_idTextAnchor066"/><span class="koboSpan" id="kobo.654.1">filesystems to follow this approach is the </span><strong class="bold"><span class="koboSpan" id="kobo.655.1">Network Filesystem</span></strong><span class="koboSpan" id="kobo.656.1">, shortened as </span><strong class="bold"><span class="koboSpan" id="kobo.657.1">NFS</span></strong><span class="koboSpan" id="kobo.658.1">. </span><span class="koboSpan" id="kobo.658.2">The NFS protocol was created by Sun Microsystems in 1984. </span><span class="koboSpan" id="kobo.658.3">NFS is a distributed filesystem, which allows accessing files stored in a remote location. </span><span class="koboSpan" id="kobo.658.4">NFS version 4 is the most recent version of the protocol. </span><span class="koboSpan" id="kobo.658.5">Since the communication between the client and server is over a network, any request by the clients will traverse all the layers in the </span><strong class="bold"><span class="koboSpan" id="kobo.659.1">Open Systems Interconnection</span></strong><span class="koboSpan" id="kobo.660.1"> (</span><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.661.1">OSI</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.662.1">) model.</span></span></p>
<h2 id="_idParaDest-64"><a id="_idTextAnchor067"/><span class="koboSpan" id="kobo.663.1">NFS architecture</span></h2>
<p><span class="koboSpan" id="kobo.664.1">From an architecture standpoint, NFS has three </span><span class="No-Break"><span class="koboSpan" id="kobo.665.1">major components:</span></span></p>
<ul>
<li><strong class="bold"><span class="koboSpan" id="kobo.666.1">Remote Procedure Calls</span></strong><span class="koboSpan" id="kobo.667.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.668.1">RPCs</span></strong><span class="koboSpan" id="kobo.669.1">): To allow processes to send and receive messages to and from each other, the kernel offers different </span><strong class="bold"><span class="koboSpan" id="kobo.670.1">inter-process communication</span></strong><span class="koboSpan" id="kobo.671.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.672.1">IPC</span></strong><span class="koboSpan" id="kobo.673.1">) mechanisms. </span><span class="koboSpan" id="kobo.673.2">The NFS uses RPCs as a method of communication between an NFS client and server. </span><span class="koboSpan" id="kobo.673.3">RPC is an extension of the IPC mechanism. </span><span class="koboSpan" id="kobo.673.4">As the name suggests, in RPC, the procedure called by the client doesn’t need to be in the same address space as the client. </span><span class="koboSpan" id="kobo.673.5">It can be in a remote address space. </span><span class="koboSpan" id="kobo.673.6">The RPC service is implemented at the </span><span class="No-Break"><span class="koboSpan" id="kobo.674.1">session layer.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.675.1">External Data Representation</span></strong><span class="koboSpan" id="kobo.676.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.677.1">XDR</span></strong><span class="koboSpan" id="kobo.678.1">): NFS uses XDR as the standard for encoding binary data at the presentation layer of the OSI model. </span><span class="koboSpan" id="kobo.678.2">The use of XDR ensures that all stakeholders use the same language when communicating. </span><span class="koboSpan" id="kobo.678.3">The use of a standardized method for transferring data is necessary as data representation may differ between the two systems. </span><span class="koboSpan" id="kobo.678.4">For instance, it is possible that the NFS participants may be architecturally different and have different endian-ness. </span><span class="koboSpan" id="kobo.678.5">For instance, if data is being transmitted from a system using big-endian architecture to a system using little-endian architecture, the bytes will be received in the reverse order. </span><span class="koboSpan" id="kobo.678.6">XDR uses a canonical method of data representation. </span><span class="koboSpan" id="kobo.678.7">When an NFS client needs to write data on an NFS server, it will convert the local representation of relevant data into its equivalent XDR encoding. </span><span class="koboSpan" id="kobo.678.8">Similarly, when this XDR-encoded data is received by the server, it will decode and convert it back into its </span><span class="No-Break"><span class="koboSpan" id="kobo.679.1">local representation.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.680.1">NFS procedures</span></strong><span class="koboSpan" id="kobo.681.1">: All the NFS operations function at the application layer of the OSI model. </span><span class="koboSpan" id="kobo.681.2">The procedures defined at this layer specify the different tasks that can be performed on files residing on the NFS server. </span><span class="koboSpan" id="kobo.681.3">These procedures include file operations, directory operations, and </span><span class="No-Break"><span class="koboSpan" id="kobo.682.1">filesystem operations.</span></span></li>
</ul>
<p><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.683.1">Figure 3</span></em></span><em class="italic"><span class="koboSpan" id="kobo.684.1">.8</span></em><span class="koboSpan" id="kobo.685.1"> depicts the route taken by an I/O request when </span><span class="No-Break"><span class="koboSpan" id="kobo.686.1">using NFS:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer032">
<span class="koboSpan" id="kobo.687.1"><img alt="Figure 3.8 – Flow of an I/O request in NFS" src="image/B19430_03_08.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.688.1">Figure 3.8 – Flow of an I/O request in NFS</span></p>
<p><span class="koboSpan" id="kobo.689.1">In version 2, NFS used UDP as the underlying transport protocol and as a result, NFS v2 and v3 were stateless. </span><span class="koboSpan" id="kobo.689.2">An advantage of this approach was the slightly better performance because of the lower overhead when using UDP. </span><span class="koboSpan" id="kobo.689.3">Since version 4, the default protocol has been changed to TCP. </span><span class="koboSpan" id="kobo.689.4">Mounting NFS shares using TCP is a more reliable option. </span><span class="koboSpan" id="kobo.689.5">NFS version 4 is stateful, which means that both the NFS client and server maintain information about open files and file locks. </span><span class="koboSpan" id="kobo.689.6">In the case of a server crash, both the client and server side work to recover the state prior to the failure. </span><span class="koboSpan" id="kobo.689.7">NFS version 4 also introduced the </span><strong class="bold"><span class="koboSpan" id="kobo.690.1">compound</span></strong><span class="koboSpan" id="kobo.691.1"> request format. </span><span class="koboSpan" id="kobo.691.2">By using the compound request format, the NFS client can combine several operations into a single request. </span><span class="koboSpan" id="kobo.691.3">The compound procedure acts as a wrapper to coalesce one or more operations into a single </span><span class="No-Break"><span class="koboSpan" id="kobo.692.1">RPC request.</span></span></p>
<p><span class="koboSpan" id="kobo.693.1">Like any regular filesystem, the NFS also needs to be mounted to establish a logical connection between the client and server. </span><span class="koboSpan" id="kobo.693.2">This mount operation is a bit different from a local filesystem. </span><span class="koboSpan" id="kobo.693.3">While mounting an NFS filesystem, we do not need to create a filesystem since the filesystem already exists on the remote side. </span><span class="koboSpan" id="kobo.693.4">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.694.1">mount</span></strong><span class="koboSpan" id="kobo.695.1"> command will include the name of the remote directory to be mounted. </span><span class="koboSpan" id="kobo.695.2">In NFS terms, this is called an </span><strong class="bold"><span class="koboSpan" id="kobo.696.1">export</span></strong><span class="koboSpan" id="kobo.697.1">. </span><span class="koboSpan" id="kobo.697.2">The NFS server keeps a list of filesystems that can be exported and a list of hosts that are allowed to access </span><span class="No-Break"><span class="koboSpan" id="kobo.698.1">these exports.</span></span></p>
<p><span class="koboSpan" id="kobo.699.1">The NFS server uses a special structure to uniquely identify a file. </span><span class="koboSpan" id="kobo.699.2">This structure is known as a </span><strong class="bold"><span class="koboSpan" id="kobo.700.1">file handle</span></strong><span class="koboSpan" id="kobo.701.1">. </span><span class="koboSpan" id="kobo.701.2">This handle makes use of an inode number, a filesystem identifier, and a generation number. </span><span class="koboSpan" id="kobo.701.3">The generation number plays a critical role in this identification process. </span><span class="koboSpan" id="kobo.701.4">Let’s say that file A had an inode number of 100 and was deleted by the user. </span><span class="koboSpan" id="kobo.701.5">A new file, say B, was created and was assigned the recently freed inode number, 100. </span><span class="koboSpan" id="kobo.701.6">When trying to access a file using its file handle, this can cause confusion, as now, file B uses the inode number that was previously assigned to file A. </span><span class="koboSpan" id="kobo.701.7">Because of this, the file handle structure also uses a generation number. </span><span class="koboSpan" id="kobo.701.8">This generation number is incremented every time an inode is reused by </span><span class="No-Break"><span class="koboSpan" id="kobo.702.1">the server.</span></span></p>
<h2 id="_idParaDest-65"><a id="_idTextAnchor068"/><span class="koboSpan" id="kobo.703.1">Comparing NFS with regular block filesystems</span></h2>
<p><span class="koboSpan" id="kobo.704.1">Network filesystems are also referred to as </span><em class="italic"><span class="koboSpan" id="kobo.705.1">file-level storage</span></em><span class="koboSpan" id="kobo.706.1">. </span><span class="koboSpan" id="kobo.706.2">As such, I/O operations performed on an NFS are called file-level I/O operations. </span><span class="koboSpan" id="kobo.706.3">Unlike block filesystems, file-level I/O doesn’t specify the block address of a file when requesting an operation. </span><span class="koboSpan" id="kobo.706.4">Keeping track of the exact location of the file on the disk is the job of the NFS server. </span><span class="koboSpan" id="kobo.706.5">Upon receiving the request from the NFS client, the NFS server will convert it into a block-level request and perform the requested operation. </span><span class="koboSpan" id="kobo.706.6">This does introduce additional overhead and is one of the major reasons that the performance of an NFS pales in comparison to a regular block filesystem. </span><span class="koboSpan" id="kobo.706.7">In the case of block filesystems and storage, applications have the freedom to decide how filesystem blocks will be accessed or modified. </span><span class="koboSpan" id="kobo.706.8">For NFS, the management of filesystem structures is entirely the responsibility of the </span><span class="No-Break"><span class="koboSpan" id="kobo.707.1">NFS server.</span></span></p>
<p><span class="koboSpan" id="kobo.708.1">We can see the differences between an NFS and a </span><span class="No-Break"><span class="koboSpan" id="kobo.709.1">block filesystem:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer033">
<span class="koboSpan" id="kobo.710.1"><img alt="Figure 3.9 – NFS versus block filesystem" src="image/B19430_03_09.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.711.1">Figure 3.9 – NFS versus block filesystem</span></p>
<p><span class="koboSpan" id="kobo.712.1">To sum up, NFS is one of the most popular protocols for remote file sharing. </span><span class="koboSpan" id="kobo.712.2">It is distributive in nature and follows a client-server architecture. </span><span class="koboSpan" id="kobo.712.3">The request from an NFS client ends up on the NFS server after traversing the entire network stack. </span><span class="koboSpan" id="kobo.712.4">To standardize data representation between the client and server, NFS uses XDR for data encoding at the presentation layer of the OSI model. </span><span class="koboSpan" id="kobo.712.5">Although it lags in performance when compared to regular block storage, it is still used in most enterprise infrastructures, mainly for backups </span><span class="No-Break"><span class="koboSpan" id="kobo.713.1">and archiving.</span></span></p>
<h1 id="_idParaDest-66"><a id="_idTextAnchor069"/><span class="koboSpan" id="kobo.714.1">FUSE – a unique method for creating filesystems</span></h1>
<p><span class="koboSpan" id="kobo.715.1">We’ve talked about how the kernel divides the system into two portions: user space and kernel space. </span><span class="koboSpan" id="kobo.715.2">All the privileged system resources reside in kernel space. </span><span class="koboSpan" id="kobo.715.3">The kernel code, including that of filesystems, also exists in kernel space in a separate area of memory. </span><span class="koboSpan" id="kobo.715.4">It is not possible for normal user-space application programs to access it. </span><span class="koboSpan" id="kobo.715.5">The distinction between user space and kernel space programs restricts any regular process from modifying the </span><span class="No-Break"><span class="koboSpan" id="kobo.716.1">kernel code.</span></span></p>
<p><span class="koboSpan" id="kobo.717.1">Although this approach is essential to the kernel’s design, it does create a few problems in the development process. </span><span class="koboSpan" id="kobo.717.2">Consider the example of any filesystem. </span><span class="koboSpan" id="kobo.717.3">As all the filesystem code exists in the kernel space, in the case of a bug in the filesystem code, it is extremely difficult to perform any troubleshooting or debugging because of this segregation. </span><span class="koboSpan" id="kobo.717.4">Any operations on the filesystem also need to be performed by the </span><span class="No-Break"><span class="koboSpan" id="kobo.718.1">root user.</span></span></p>
<p><span class="koboSpan" id="kobo.719.1">The </span><strong class="bold"><span class="koboSpan" id="kobo.720.1">filesystem in user space</span></strong><span class="koboSpan" id="kobo.721.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.722.1">FUSE</span></strong><span class="koboSpan" id="kobo.723.1">) framework was designed to address some of these limitations. </span><span class="koboSpan" id="kobo.723.2">Through the use of the FUSE interface, filesystems can be created without tinkering with the kernel code. </span><span class="koboSpan" id="kobo.723.3">As such, the code for such filesystems only exists in user space. </span><span class="koboSpan" id="kobo.723.4">Both the actual data and metadata on the filesystem are managed by user-space processes. </span><span class="koboSpan" id="kobo.723.5">This is extremely flexible as it allows non-privileged users to mount the filesystem. </span><span class="koboSpan" id="kobo.723.6">It’s important to note that FUSE-based filesystems can be stackable, meaning that they can be deployed on top of existing filesystems such as Ext4 and XFS. </span><span class="koboSpan" id="kobo.723.7">One of the most widely used FUSE-based solutions that makes use of this approach is </span><strong class="bold"><span class="koboSpan" id="kobo.724.1">GlusterFS</span></strong><span class="koboSpan" id="kobo.725.1">. </span><span class="koboSpan" id="kobo.725.2">GlusterFS operates as a user-space filesystem and can be stacked on top of any existing block-based filesystem such as Ext4 </span><span class="No-Break"><span class="koboSpan" id="kobo.726.1">or XFS.</span></span></p>
<p><span class="koboSpan" id="kobo.727.1">The functionality provided by FUSE is achieved using a kernel module (</span><strong class="source-inline"><span class="koboSpan" id="kobo.728.1">fuse.ko</span></strong><span class="koboSpan" id="kobo.729.1">) and a user-space daemon using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.730.1">libfuse</span></strong><span class="koboSpan" id="kobo.731.1"> library. </span><span class="koboSpan" id="kobo.731.2">The FUSE kernel module is responsible for registering the filesystem with VFS. </span><span class="koboSpan" id="kobo.731.3">The interaction between the user-space daemon and the kernel is achieved using a character device, </span><strong class="source-inline"><span class="koboSpan" id="kobo.732.1">/dev/fuse</span></strong><span class="koboSpan" id="kobo.733.1">. </span><span class="koboSpan" id="kobo.733.2">This device plays the role of a bridge between the user-space daemon and the kernel module. </span><span class="koboSpan" id="kobo.733.3">The user-space daemon will read from and write requests to </span><span class="No-Break"><span class="koboSpan" id="kobo.734.1">this device:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer034">
<span class="koboSpan" id="kobo.735.1"><img alt="Figure 3.10 – The FUSE approach" src="image/B19430_03_10.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.736.1">Figure 3.10 – The FUSE approach</span></p>
<p><span class="koboSpan" id="kobo.737.1">When a process in user space performs any operation on a FUSE filesystem, the relevant system call is sent to the VFS layer. </span><span class="koboSpan" id="kobo.737.2">Upon checking that this corresponds to a FUSE-based filesystem, VFS will forward this request to the FUSE kernel module. </span><span class="koboSpan" id="kobo.737.3">The FUSE driver will </span><a id="_idIndexMarker147"/><span class="koboSpan" id="kobo.738.1">create a request structure and put it in the FUSE queue in </span><strong class="source-inline"><span class="koboSpan" id="kobo.739.1">/dev/fuse</span></strong><span class="koboSpan" id="kobo.740.1">. </span><span class="koboSpan" id="kobo.740.2">The communication between the kernel module and </span><strong class="source-inline"><span class="koboSpan" id="kobo.741.1">libfuse</span></strong><span class="koboSpan" id="kobo.742.1"> library is achieved using a special file descriptor. </span><span class="koboSpan" id="kobo.742.2">The user-space daemon will open the </span><strong class="source-inline"><span class="koboSpan" id="kobo.743.1">/dev/fuse</span></strong><span class="koboSpan" id="kobo.744.1"> device to process the result. </span><span class="koboSpan" id="kobo.744.2">If the FUSE filesystem is stacked on top of an existing filesystem, then the request will again be routed to the kernel space so that it can be passed to the </span><span class="No-Break"><span class="koboSpan" id="kobo.745.1">filesystem underneath.</span></span></p>
<p><span class="koboSpan" id="kobo.746.1">FUSE filesystems are not as robust as traditional filesystems but they offer a great deal of flexibility. </span><span class="koboSpan" id="kobo.746.2">They are easy to deploy and can be mounted by non-privileged users. </span><span class="koboSpan" id="kobo.746.3">Since the filesystem code is in user space, it is easier to troubleshoot and make changes. </span><span class="koboSpan" id="kobo.746.4">Even in the case of a bug in the code, the functionality of the kernel will not </span><span class="No-Break"><span class="koboSpan" id="kobo.747.1">be impacted.</span></span></p>
<h1 id="_idParaDest-67"><a id="_idTextAnchor070"/><span class="koboSpan" id="kobo.748.1">Summary</span></h1>
<p><span class="koboSpan" id="kobo.749.1">Having covered the workings of VFS in the first two chapters, this chapter gave you an introduction to common filesystems and their concepts. </span><span class="koboSpan" id="kobo.749.2">The Linux kernel is capable of supporting around 50 filesystems and covering each one of them is an impossible task. </span><span class="koboSpan" id="kobo.749.3">We maintained our focus on the native filesystems in Linux, as the kernel is capable of supporting them out of the box. </span><span class="koboSpan" id="kobo.749.4">We explained some features that are common among a group of filesystems, such as journaling, CoW mechanisms, and FUSE. </span><span class="koboSpan" id="kobo.749.5">The major focus of this chapter was the working and internal design of the extended filesystem. </span><span class="koboSpan" id="kobo.749.6">The extended filesystem has been around since kernel version 0.96 and is the most widely deployed filesystem on computing platforms. </span><span class="koboSpan" id="kobo.749.7">We also shed some light on the architecture of network filesystems and explained the differences between file and block storage. </span><span class="koboSpan" id="kobo.749.8">At the end, we discussed FUSE, which offers an interface for user space programs to export a filesystem to the </span><span class="No-Break"><span class="koboSpan" id="kobo.750.1">Linux kernel.</span></span></p>
<p><span class="koboSpan" id="kobo.751.1">With this chapter, we’ve now completed our exploration of VFS and filesystem layers in the kernel. </span><span class="koboSpan" id="kobo.751.2">This brings the curtains down on </span><em class="italic"><span class="koboSpan" id="kobo.752.1">Part 1</span></em><span class="koboSpan" id="kobo.753.1"> of this book. </span><span class="koboSpan" id="kobo.753.2">I would like to think that this has been a good learning journey so far and I hope that it stays that way. </span><span class="koboSpan" id="kobo.753.3">The second part of this book, starting from </span><a href="B19430_04.xhtml#_idTextAnchor072"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.754.1">Chapter 4</span></em></span></a><span class="koboSpan" id="kobo.755.1">, will focus on the block layer in the kernel, which provides an upstream interface to </span><span class="No-Break"><span class="koboSpan" id="kobo.756.1">the filesystems.</span></span></p>
</div>


<div class="Content" id="_idContainer036">
<h1 id="_idParaDest-68"><a id="_idTextAnchor071"/><span class="koboSpan" id="kobo.1.1">Part 2: Navigating Through the Block Layer</span></h1>
<p><span class="koboSpan" id="kobo.2.1">This part introduces the role of the block layer in the Linux kernel. </span><span class="koboSpan" id="kobo.2.2">The block layer is a key part of the kernel’s storage stack because the interfaces implemented in the block layer are used by the user space applications to access the available storage devices. </span><span class="koboSpan" id="kobo.2.3">This part will explain the block layer and its major components, such as the device mapper framework, block devices, block layer data structures, the multi-queue framework, and the different </span><span class="No-Break"><span class="koboSpan" id="kobo.3.1">I/O schedulers.</span></span></p>
<p><span class="koboSpan" id="kobo.4.1">This part contains the </span><span class="No-Break"><span class="koboSpan" id="kobo.5.1">following chapters:</span></span></p>
<ul>
<li><a href="B19430_04.xhtml#_idTextAnchor072"><em class="italic"><span class="koboSpan" id="kobo.6.1">Chapter 4</span></em></a><span class="koboSpan" id="kobo.7.1">, </span><em class="italic"><span class="koboSpan" id="kobo.8.1">Understanding the Block Layer, Block Devices, and Data Structures</span></em></li>
<li><a href="B19430_05.xhtml#_idTextAnchor090"><em class="italic"><span class="koboSpan" id="kobo.9.1">Chapter 5</span></em></a><span class="koboSpan" id="kobo.10.1">, </span><em class="italic"><span class="koboSpan" id="kobo.11.1">Understanding the Block Layer, Multi-Queue, and Device Mapper</span></em></li>
<li><a href="B19430_06.xhtml#_idTextAnchor101"><em class="italic"><span class="koboSpan" id="kobo.12.1">Chapter 6</span></em></a><span class="koboSpan" id="kobo.13.1">, </span><em class="italic"><span class="koboSpan" id="kobo.14.1">Understanding I/O Handling and Scheduling in the Block Layer</span></em></li>
</ul>
</div>
<div>
<div class="Basic-Graphics-Frame" id="_idContainer037">
</div>
</div>
<div>
<div id="_idContainer038">
</div>
</div>
</body></html>