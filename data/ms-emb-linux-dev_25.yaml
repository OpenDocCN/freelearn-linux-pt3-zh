- en: '20'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '20'
- en: Profiling and Tracing
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 性能分析与追踪
- en: Interactive debugging using a source-level debugger, as described in the previous
    chapter, can give you an insight into the way a program works, but it constrains
    your view to a small body of code. In this chapter, we will look at the larger
    picture to see whether the system is performing as intended.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 使用源代码级调试器进行交互式调试，如上一章所述，可以帮助你深入了解程序的工作原理，但它将你的视野限制在一小部分代码上。在本章中，我们将从更宏观的角度来看，是否系统按预期执行。
- en: Programmers and system designers are notoriously bad at guessing where bottlenecks
    are. So, if your system has performance issues, it is wise to start by looking
    at the full system and then work down, using more sophisticated tools as you go.
    In this chapter, I’ll begin with the well-known `top` command as a means of getting
    an overview. Often, the problem can be localized to a single program, which you
    can analyze using the Linux profiler, `perf`. If the problem is not so localized
    and you want to get a broader picture, `perf` can do that as well. To diagnose
    problems associated with the kernel, I will describe some trace tools—Ftrace,
    LTTng, and eBPF—as a means of gathering detailed information.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 程序员和系统设计师通常不擅长猜测瓶颈在哪里。因此，如果你的系统存在性能问题，明智的做法是从整体系统开始分析，然后逐步深入，随着进展使用更复杂的工具。本章中，我将从广为人知的
    `top` 命令开始，作为了解概况的手段。通常，问题可能局限于某个程序，你可以使用 Linux 性能分析工具 `perf` 进行分析。如果问题没有那么局限，并且你想获得更广泛的视角，`perf`
    也能做到。为了诊断与内核相关的问题，我将介绍一些追踪工具——Ftrace、LTTng 和 eBPF——作为获取详细信息的手段。
- en: I will also cover Valgrind, which, because of its sandboxed execution environment,
    can monitor a program and report on code as it runs. I will complete the chapter
    with a description of a simple trace tool, `strace`, which reveals the execution
    of a program by tracing the system calls it makes.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 我还将介绍 Valgrind，它因其沙盒执行环境，可以监控程序并报告程序运行时的代码。我将通过描述一个简单的追踪工具`strace`来完成本章，它通过追踪程序发出的系统调用，揭示程序的执行过程。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将讨论以下主题：
- en: Observer effect
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 观察者效应
- en: Beginning to profile
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 开始进行性能分析
- en: Profiling with `top`
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `top` 进行性能分析
- en: Profiling with GDB
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 GDB 进行性能分析
- en: Introducing `perf`
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 介绍 `perf`
- en: Tracing events
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 追踪事件
- en: Introducing Ftrace
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 介绍 Ftrace
- en: Using LTTng
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 LTTng
- en: Using eBPF
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 eBPF
- en: Using Valgrind
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Valgrind
- en: Using `strace`
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `strace`
- en: Technical requirements
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'To follow along with the examples, make sure you have the following:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 要跟随示例进行操作，请确保你拥有以下内容：
- en: An Ubuntu 24.04 or later LTS host system with at least 90 GB of free disk space
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一台运行 Ubuntu 24.04 或更高版本 LTS 的主机系统，至少有 90 GB 的空闲磁盘空间
- en: Buildroot 2024.02.6 LTS release
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Buildroot 2024.02.6 LTS 版本
- en: A microSD card reader and card
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个 microSD 卡读卡器和卡
- en: balenaEtcher for Linux
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 适用于 Linux 的 balenaEtcher
- en: An Ethernet cable and router with an available port for network connectivity
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一根以太网线和一个可用端口的路由器，用于网络连接
- en: Raspberry Pi 4
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Raspberry Pi 4
- en: A 5 V USB-C power supply capable of delivering 3 A
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一台能够提供 3A 电流的 5V USB-C 电源
- en: You should have already installed the 2024.02.6 LTS release of Buildroot in
    [*Chapter 6*](Chapter_04.xhtml#_idTextAnchor110). If you have not, then refer
    to the *System requirements* section of *The Buildroot user manual* ([https://buildroot.org/downloads/manual/manual.html](https://buildroot.org/downloads/manual/manual.html))
    before installing Buildroot on your Linux host according to the instructions from
    [*Chapter 6*](Chapter_04.xhtml#_idTextAnchor110).
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该已经在 [*第6章*](Chapter_04.xhtml#_idTextAnchor110) 中安装了 Buildroot 2024.02.6 LTS
    版本。如果没有，请参考 *Buildroot 用户手册* 中的 *系统要求* 部分 ([https://buildroot.org/downloads/manual/manual.html](https://buildroot.org/downloads/manual/manual.html))，然后按照
    [*第6章*](Chapter_04.xhtml#_idTextAnchor110) 中的说明在你的 Linux 主机上安装 Buildroot。
- en: 'The code used in this chapter can be found in the chapter folder in this book’s
    GitHub repository: [https://github.com/PacktPublishing/Mastering-Embedded-Linux-Development/tree/main/Chapter20/buildroot](https://github.com/PacktPublishing/Mastering-Embedded-Linux-Development/tree/main/Chapter20/buildroot).'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中使用的代码可以在本书 GitHub 仓库中的章节文件夹中找到：[https://github.com/PacktPublishing/Mastering-Embedded-Linux-Development/tree/main/Chapter20/buildroot](https://github.com/PacktPublishing/Mastering-Embedded-Linux-Development/tree/main/Chapter20/buildroot)。
- en: Observer effect
  id: totrans-28
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 观察者效应
- en: 'Before diving into the tools, let’s talk about what the tools will show you.
    As is the case in many fields, measuring a certain property affects the observation
    itself. Measuring the electric current in a power supply line requires measuring
    the voltage drop over a small resistor. However, the resistor itself affects the
    current. The same is true for profiling: every system observation has a cost in
    CPU cycles, and that resource is no longer spent on the application. Measurement
    tools also mess up caching behavior, eat memory space, and write to disk, which
    all make it worse. There is no measurement without overhead.'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 在深入了解工具之前，先让我们谈谈这些工具会向你展示什么。就像许多领域一样，测量某个特性会影响到观察本身。测量电源线中的电流需要测量小电阻上的电压降。然而，电阻本身会影响电流。分析也是如此：每一次系统观察都会消耗CPU周期，这些资源就不再用在应用程序上。测量工具还会干扰缓存行为，占用内存空间，写入磁盘，这一切都会使情况变得更糟。没有开销就没有测量。
- en: I’ve often heard engineers say that the results of a profiling job were totally
    misleading. That is usually because they were performing the measurements on something
    not approaching a real situation. Always try to measure on the target, running
    release builds of the software, with a valid dataset preferably obtained from
    the field, using as few extra services as possible.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 我经常听到工程师说，他们做的分析工作完全误导。这通常是因为他们在某些非真实的情况下进行测量。始终尽量在目标系统上进行测量，运行发布版本的软件，并使用有效的数据集，最好是从实际环境中获得，尽量减少额外的服务。
- en: A release build usually implies building fully optimized binaries without debug
    symbols. These production requirements severely limit the functionality of most
    profiling tools.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 发布构建通常意味着构建完全优化过的二进制文件，而没有调试符号。这些生产要求会严重限制大多数分析工具的功能。
- en: Once our system is up and running, we will hit a problem right away. While it
    is important to observe the system in its natural state, the tools often need
    additional information to make sense of the events.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们的系统启动并运行起来，我们会立刻遇到一个问题。虽然观察系统的自然状态很重要，但工具往往需要额外的信息才能理解事件。
- en: Some tools require special kernel options. For the tools we are examining in
    this chapter, this applies to `perf`, Ftrace, LTTng, and eBPF. Therefore, you
    will probably have to build and deploy a new kernel for these tests.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 一些工具需要特殊的内核选项。对于我们在本章中讨论的工具，这适用于`perf`、Ftrace、LTTng和eBPF。因此，你可能需要为这些测试构建并部署一个新的内核。
- en: 'Debug symbols are very helpful in translating raw program addresses into function
    names and line numbers in source code. Deploying executables with debug symbols
    does not change the execution of the code, but it does require that you have copies
    of the binaries, and a kernel compiled with debug information, at least for the
    components you want to profile. Some tools work best if you have these installed
    on the target system: `perf`, for example. The techniques are the same as for
    general debugging, as I discussed in [*Chapter 19*](Chapter_19.xhtml#_idTextAnchor611).'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 调试符号在将原始程序地址转换为函数名和源代码行号时非常有用。部署带有调试符号的可执行文件不会改变代码的执行，但确实要求你拥有二进制文件副本，并且至少对你想要分析的组件，内核需要带有调试信息。一些工具在目标系统上安装这些内容会更有效，比如`perf`。这些技巧与一般调试相同，正如我在[*第19章*](Chapter_19.xhtml#_idTextAnchor611)中讨论的那样。
- en: If you want a tool to generate call graphs, you may have to compile with stack
    frames enabled. If you want the tool to attribute addresses with line numbers
    in source code accurately, you may need to compile with lower levels of optimization.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你希望工具生成调用图，你可能需要编译时启用堆栈帧。如果你希望工具能准确地将地址与源代码中的行号匹配，你可能需要使用较低级别的优化进行编译。
- en: Finally, some tools require instrumentation to be inserted into the program
    to capture samples, so you will have to recompile those components. This applies
    to Ftrace and LTTng for the kernel.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，一些工具需要将仪器插入程序中以捕获样本，因此你需要重新编译这些组件。这适用于内核的Ftrace和LTTng。
- en: Be aware that the more you change the system you are observing, the harder it
    is to relate the measurements you make to the production system.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，你改变被观察系统的程度越大，你所做的测量与生产系统之间的关系就越难以建立。
- en: '**TIP**'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: '**提示**'
- en: It is best to adopt a wait-and-see approach, making changes only when the need
    is clear, and being mindful that each time you do so, you will change what you
    are measuring.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 最好采取等待观察的方法，只有在需要时才进行更改，并时刻注意，每次更改时，你都会改变你正在测量的内容。
- en: Because the results of profiling can be so ambiguous, start with simple, easy-to-use
    tools that are readily available before reaching for more complex and invasive
    instruments.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 由于分析结果可能非常模糊，建议在使用更复杂和入侵性较强的工具之前，先从一些简单、易用且 readily available 的工具入手。
- en: Beginning to profile
  id: totrans-41
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 开始分析
- en: When looking at the entire system, a good place to start is with a simple tool
    such as `top`, which gives you an overview very quickly. It shows you how much
    memory is being used, which processes are eating CPU cycles, and how this is spread
    across different cores and times.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 在查看整个系统时，一个好的起点是使用像`top`这样简单的工具，它能快速提供概览。它显示了正在使用的内存量、哪些进程消耗了CPU周期，以及这些消耗如何分布在不同的核心和时间上。
- en: If `top` shows that a single application is using up all the CPU cycles in user
    space, then you can profile that application using `perf`.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`top`显示单个应用程序占用了所有的用户空间CPU周期，那么你可以使用`perf`对该应用程序进行分析。
- en: If two or more processes have a high CPU usage, there is probably something
    that is coupling them together, perhaps data communication. If a lot of cycles
    are spent on system calls or handling interrupts, then there may be an issue with
    the kernel configuration or with a device driver. In either case, you need to
    start by taking a profile of the whole system, again using `perf`.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 如果两个或更多进程的CPU使用率很高，可能是它们之间有某种关联，可能是数据通信。如果大量时间花费在系统调用或处理中断上，那么可能是内核配置或设备驱动程序出现问题。在任何情况下，你需要首先使用`perf`对整个系统进行分析。
- en: If you want to find out more about the kernel and the sequencing of events there,
    use Ftrace, LTTng, or eBPF.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想了解更多关于内核和事件顺序的内容，可以使用Ftrace、LTTng或eBPF。
- en: There could be other problems that `top` will not help you with. If you have
    multi-threaded code and there are problems with lockups, or if you have random
    data corruption, then `pidstat` (part of `sysstat`) or Valgrind plus the Helgrind
    plugin might be helpful. Memory leaks also fit into this category; I covered memory-related
    diagnosis in [*Chapter 18*](Chapter_18.xhtml#_idTextAnchor581).
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 可能会有其他`top`无法帮助你发现的问题。如果你有多线程代码，并且遇到锁死问题，或者数据出现随机性损坏，那么`pidstat`（`sysstat`的一部分）或Valgrind加上Helgrind插件可能会有所帮助。内存泄漏也属于这一类别；我在[*第18章*](Chapter_18.xhtml#_idTextAnchor581)中介绍了与内存相关的诊断。
- en: Before we get into these more advanced profiling tools, let’s start with the
    most rudimentary one that is found on most systems, including those in production.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 在深入探讨这些更高级的分析工具之前，我们先从大多数系统中都能找到的最基本的工具开始，包括生产环境中的系统。
- en: Profiling with top
  id: totrans-48
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用top进行分析
- en: The **top** program is a simple tool that doesn’t require any special kernel
    options or symbol tables. There is a basic version in BusyBox and a more functional
    version in the `procps` package, which is available in The Yocto Project and Buildroot.
    You may also want to consider using `htop`, which has functionally similar to
    `top` but a much nicer user interface.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: '**top**程序是一个简单的工具，不需要任何特殊的内核选项或符号表。BusyBox中有一个基本版本，而`procps`包中有一个功能更全的版本，后者在Yocto项目和Buildroot中都可以找到。你可能还想考虑使用`htop`，它与`top`功能相似，但界面更加友好。'
- en: 'To begin with, focus on the summary line of `top`, which is the second line
    if you are using BusyBox and the third line if you are using `top` from `procps`.
    Here is an example, using BusyBox’s `top`:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，关注`top`的概要行，如果你使用的是BusyBox，则它是第二行；如果你使用的是`procps`中的`top`，则是第三行。下面是一个例子，使用BusyBox的`top`：
- en: '[PRE0]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The summary line shows the percentage of time spent running in various states,
    as shown in this table:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 概要行显示了在不同状态下运行的时间百分比，如下表所示：
- en: '| **procps** | **BusyBox** | **Description** |'
  id: totrans-53
  prefs: []
  type: TYPE_TB
  zh: '| **procps** | **BusyBox** | **描述** |'
- en: '| `us` | `usr` | User-space programs with a default nice value |'
  id: totrans-54
  prefs: []
  type: TYPE_TB
  zh: '| `us` | `usr` | 默认优先级值的用户空间程序 |'
- en: '| `sy` | `sys` | Kernel code |'
  id: totrans-55
  prefs: []
  type: TYPE_TB
  zh: '| `sy` | `sys` | 内核代码 |'
- en: '| `ni` | `nic` | User-space programs with a non-default nice value |'
  id: totrans-56
  prefs: []
  type: TYPE_TB
  zh: '| `ni` | `nic` | 优先级非默认值的用户空间程序 |'
- en: '| `id` | `idle` | Idle |'
  id: totrans-57
  prefs: []
  type: TYPE_TB
  zh: '| `id` | `idle` | 空闲 |'
- en: '| `wa` | `io` | I/O wait |'
  id: totrans-58
  prefs: []
  type: TYPE_TB
  zh: '| `wa` | `io` | I/O等待 |'
- en: '| `hi` | `irq` | Hardware interrupts |'
  id: totrans-59
  prefs: []
  type: TYPE_TB
  zh: '| `hi` | `irq` | 硬件中断 |'
- en: '| `si` | `sirq` | Software interrupts |'
  id: totrans-60
  prefs: []
  type: TYPE_TB
  zh: '| `si` | `sirq` | 软件中断 |'
- en: '| `st` | `-` | Steal time: only relevant in virtual environments |'
  id: totrans-61
  prefs: []
  type: TYPE_TB
  zh: '| `st` | `-` | Steal时间：仅在虚拟环境中相关 |'
- en: Table 20.1 – procps top vs. BusyBox top
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 表20.1 – procps top与BusyBox top的对比
- en: 'In the preceding example, almost all of the time (58%) is spent in user mode,
    with a small amount (4%) in system mode, so this is a system that is CPU-bound
    in user space. The first line after the summary shows that just one application
    is responsible: `ffmpeg`. Any efforts toward reducing CPU usage should be directed
    there.'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例中，几乎所有时间（58%）都花费在用户模式下，系统模式下的时间较少（4%），所以这是一个在用户空间中受 CPU 限制的系统。总结后的第一行显示，只有一个应用程序负责：`ffmpeg`。任何减少
    CPU 使用的努力都应集中在这里。
- en: 'Here is another example:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 这是另一个示例：
- en: '[PRE1]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: This system is spending almost all of the time in kernel space (99% `sys`),
    as a result of `cat` reading from `/dev/urandom`. In this artificial case, profiling
    `cat` by itself would not help, but profiling the kernel functions that `cat`
    calls might.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 这个系统几乎将所有时间都花费在内核空间（99% `sys`），这是由于 `cat` 从 `/dev/urandom` 读取数据所导致。在这个人工案例中，仅仅对
    `cat` 进行分析并不会帮助，但分析 `cat` 调用的内核函数可能会有所帮助。
- en: The default view of `top` shows only processes, so the CPU usage is the total
    of all the threads in the process. Press *H* to see information for each thread.
    Likewise, it aggregates the time across all CPUs. If you are using the `procps`
    version of `top`, you can see a summary per CPU by pressing the *1* key.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: '`top`的默认视图只显示进程，因此 CPU 使用率是进程中所有线程的总和。按 *H* 键可以查看每个线程的详细信息。同样，它会汇总所有 CPU 的时间。如果你使用的是
    `procps` 版本的 `top`，可以按 *1* 键查看每个 CPU 的摘要信息。'
- en: Once we have singled out the problem process using `top`, we can attach GDB
    to it.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦通过 `top` 确定了问题进程，我们就可以将 GDB 附加到它上面。
- en: Profiling with GDB
  id: totrans-69
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 GDB 进行分析
- en: You can profile an application just by using **GDB** to stop it at arbitrary
    intervals to see what it is doing. This is the **poor man’s profiler**. It is
    easy to set up and is one way of gathering profile data.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以仅通过使用**GDB**在任意间隔停止应用程序，查看它的状态。这就是**穷人分析器**。它易于设置，是收集分析数据的一种方式。
- en: 'The procedure is simple:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 过程很简单：
- en: Attach to the process using `gdbserver` (for a remote debug) or GDB (for a native
    debug). The process stops.
  id: totrans-72
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `gdbserver`（用于远程调试）或 GDB（用于本地调试）附加到进程。进程会停止。
- en: Observe the function it stopped in. You can use the `backtrace` GDB command
    to see the call stack.
  id: totrans-73
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 查看程序停止时所在的函数。你可以使用 `backtrace` GDB 命令查看调用栈。
- en: Type `continue` so that the program resumes.
  id: totrans-74
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 输入 `continue`，让程序继续执行。
- en: After a while, press *Ctrl + C* to stop it again, and go back to *step 2*.
  id: totrans-75
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一段时间后，按 *Ctrl + C* 停止程序，然后返回到 *步骤 2*。
- en: If you repeat *steps 2* to *4* several times, you will quickly get an idea of
    whether it is looping or making progress, and if you repeat them often enough,
    you will get an idea of where the hotspots in the code are.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你重复执行*步骤 2* 到 *4* 多次，你很快就能了解程序是否在循环或进展，如果你足够频繁地重复这些步骤，你就能了解代码中的热点所在。
- en: There is a whole web page dedicated to this idea at [https://poormansprofiler.org/](https://poormansprofiler.org/),
    together with scripts that make it a little easier. I have used this technique
    many times over the years with various operating systems and debuggers.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 有一个完整的网页专门讲解这个方法，地址是[https://poormansprofiler.org/](https://poormansprofiler.org/)，并且提供了一些脚本，让这个过程变得更简单。多年来，我在各种操作系统和调试器中多次使用过这个技巧。
- en: This is an example of **statistical profiling**, in which you sample the program
    state at intervals. After a number of samples, you begin to learn the statistical
    likelihood of the functions being executed. It is surprising how few you really
    need. Other statistical profilers are `perf record`, OProfile, and `gprof`.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 这是**统计分析**的一个示例，其中你在一定间隔内对程序状态进行采样。经过一段时间的采样后，你可以开始了解函数执行的统计概率。令人惊讶的是，实际上你所需要的样本数非常少。其他统计分析工具包括
    `perf record`、OProfile 和 `gprof`。
- en: Sampling using a debugger is intrusive because the program is stopped for a
    significant period while you collect the sample. Other tools can sample with less
    overhead. One such tool is `perf`.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 使用调试器进行采样具有侵入性，因为程序在采样期间会停止很长时间。其他工具可以以更低的开销进行采样。一个这样的工具是 `perf`。
- en: Introducing perf
  id: totrans-80
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 引入 perf
- en: '**perf** is an abbreviation of the Linux **performance event counter subsystem**,
    `perf_events`, and also the name of the command-line tool for interacting with
    `perf_events`. Both have been part of the kernel since Linux 2.6.31\. There is
    plenty of useful information in the Linux source tree in `tools/perf/Documentation`
    as well as at [https://perfwiki.github.io](https://perfwiki.github.io).'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: '**perf** 是 Linux **性能事件计数子系统** `perf_events` 的缩写，也是与 `perf_events` 交互的命令行工具的名称。自
    Linux 2.6.31 以来，它们已成为内核的一部分。在 Linux 源代码树中的 `tools/perf/Documentation` 以及 [https://perfwiki.github.io](https://perfwiki.github.io)
    上有大量有用的信息。'
- en: The initial impetus for developing `perf` was to provide a unified way to access
    the registers of the **performance measurement unit** (**PMU**), which is part
    of most modern processor cores. Once the API was defined and integrated into Linux,
    it became logical to extend it to cover other types of performance counters.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 开发 `perf` 的初衷是提供一种统一的方式来访问 **性能测量单元** (**PMU**) 的寄存器，PMU 是大多数现代处理器核心的一部分。一旦
    API 被定义并集成到 Linux 中，扩展它以涵盖其他类型的性能计数器便变得合乎逻辑。
- en: At its heart, `perf` is a collection of event counters with rules about when
    they actively collect data. By setting the rules, you can capture data from the
    whole system, just the kernel, or just one process and its children, and do it
    across all CPUs or just one CPU. It is very flexible. With this one tool, you
    can start by looking at the whole system, then zero in on a device driver that
    seems to be causing problems, an application that is running slowly, or a library
    function that seems to be taking longer to execute than you thought.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 从本质上讲，`perf` 是一个事件计数器集合，具有关于何时主动收集数据的规则。通过设置规则，您可以从整个系统、仅内核、仅一个进程及其子进程中捕获数据，并且可以跨所有
    CPU 或仅一个 CPU 进行操作。它非常灵活。使用这个工具，您可以从查看整个系统开始，然后集中关注可能导致问题的设备驱动程序、运行缓慢的应用程序，或执行时间似乎比预期更长的库函数。
- en: The code for the `perf` command-line tool is part of the kernel, in the `tools/perf`
    directory. The tool and the kernel subsystem are developed hand in hand, meaning
    that they must be from the same version of the kernel. `perf` can do a lot. In
    this chapter, I will examine it only as a profiler. For a description of its other
    capabilities, read the `perf` man pages and refer to the documentation mentioned
    at the start of this section.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: '`perf` 命令行工具的代码是内核的一部分，位于 `tools/perf` 目录下。该工具和内核子系统是同步开发的，这意味着它们必须来自同一个版本的内核。`perf`
    功能强大。在本章中，我将仅作为分析器来探讨它。关于其其他功能的描述，请阅读 `perf` 手册并参考本节开头提到的文档。'
- en: In addition to debug symbols, there are two configuration options we need to
    set to fully enable `perf` in the kernel.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 除了调试符号之外，我们还需要设置两个配置选项，以完全启用内核中的 `perf`。
- en: Configuring the kernel for perf
  id: totrans-86
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 为 perf 配置内核
- en: You need a kernel that is configured for `perf_events`, and you need the `perf`
    command cross-compiled to run on the target. The relevant kernel configuration
    is `CONFIG_PERF_EVENTS`, present in the **General setup** | **Kernel Performance
    Events and Counters** menu.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 您需要一个已配置 `perf_events` 的内核，并且需要将 `perf` 命令交叉编译，以便在目标上运行。相关的内核配置是 `CONFIG_PERF_EVENTS`，位于
    **General setup** | **Kernel Performance Events and Counters** 菜单中。
- en: If you want to profile using tracepoints—more on this subject later—also enable
    the options described in the section about Ftrace. While you are there, it is
    worthwhile enabling `CONFIG_DEBUG_INFO` as well.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您希望使用 tracepoints 进行分析——稍后会详细讲解——还需要启用有关 Ftrace 部分中描述的选项。同时，在这里启用 `CONFIG_DEBUG_INFO`
    也是值得的。
- en: The `perf` command has many dependencies, which makes cross-compiling it quite
    messy. However, both The Yocto Project and Buildroot have target packages for
    it.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: '`perf` 命令有许多依赖项，这使得交叉编译变得相当复杂。然而，Yocto 项目和 Buildroot 都有针对它的目标包。'
- en: You will also need debug symbols on the target for the binaries that you are
    interested in profiling; otherwise, `perf` will not be able to resolve addresses
    to meaningful symbols. Ideally, you want debug symbols for the whole system, including
    the kernel. For the latter, remember that the debug symbols for the kernel are
    in the `vmlinux` file.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 您还需要为您感兴趣的二进制文件启用目标的调试符号；否则，`perf` 将无法解析地址到有意义的符号。理想情况下，您希望为整个系统（包括内核）启用调试符号。对于后者，请记住，内核的调试符号位于
    `vmlinux` 文件中。
- en: Building perf with The Yocto Project
  id: totrans-91
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 Yocto 项目构建 perf
- en: If you are using the standard `linux-yocto` kernel, `perf_events` is enabled
    already, so there is nothing more to do.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您使用的是标准的 `linux-yocto` 内核，`perf_events` 已经启用，因此无需进行更多操作。
- en: 'To build the `perf` tool, you can add it explicitly to the target image dependencies,
    or you can add the `tools-profile` feature. You also want debug symbols on the
    target image as well as the kernel `vmlinux` image. In total, this is what you
    will need in `conf/local.conf`:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 要构建 `perf` 工具，您可以将其显式添加到目标镜像的依赖项中，或者您可以添加 `tools-profile` 特性。您还需要在目标镜像以及内核 `vmlinux`
    镜像中启用调试符号。总的来说，您在 `conf/local.conf` 中需要配置以下内容：
- en: '[PRE2]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Adding `perf` to a Buildroot image is more involved for several reasons.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 将 `perf` 添加到 Buildroot 镜像中涉及多个步骤。
- en: Building perf with Buildroot
  id: totrans-96
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 Buildroot 构建 perf
- en: Many Buildroot kernel configurations do not include `perf_events`, so you should
    begin by checking that your kernel includes the options mentioned in the preceding
    section.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 许多Buildroot内核配置不包括`perf_events`，因此你应该首先检查内核是否包括前面章节提到的选项。
- en: 'To cross-compile `perf`, run the Buildroot `menuconfig` and select the following:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 要交叉编译`perf`，运行Buildroot的`menuconfig`并选择以下选项：
- en: '`BR2_PACKAGE_LINUX_TOOLS_PERF` in **Kernel** | **Linux Kernel Tools** | **perf**'
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在**内核** | **Linux内核工具** | **perf**中选择`BR2_PACKAGE_LINUX_TOOLS_PERF`
- en: '`BR2_PACKAGE_LINUX_TOOLS_PERF_TUI` in **Kernel** | **Linux Kernel Tools** |
    **perf** | **Enable perf TUI**'
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在**内核** | **Linux内核工具** | **perf**中选择`BR2_PACKAGE_LINUX_TOOLS_PERF_TUI` | **启用perf
    TUI**
- en: 'To build binaries with debug information and install them onto the target without
    stripping, enable the first and disable the second of these two options:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 要构建带有调试信息的二进制文件并将它们安装到目标上而不剥离，启用这两个选项中的第一个并禁用第二个：
- en: '`BR2_ENABLE_DEBUG` in **Build options** | **Build packages with debugging symbols**'
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在**构建选项**中选择`BR2_ENABLE_DEBUG` | **构建带调试符号的包**
- en: '`BR2_STRIP_strip` in **Build options** | **Strip target binaries**'
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在**构建选项**中选择`BR2_STRIP_strip` | **剥离目标二进制文件**
- en: 'To copy the unstripped `vmlinux` file to the target image, select the following:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 要将未剥离的`vmlinux`文件复制到目标映像中，选择以下选项：
- en: '`BR2_LINUX_KERNEL_VMLINUX` in **Kernel** | **Kernel binary format** | **vmlinux**'
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在**内核** | **内核二进制格式** | **vmlinux**中选择`BR2_LINUX_KERNEL_VMLINUX`
- en: '`BR2_LINUX_KERNEL_INSTALL_TARGET` in **Kernel** | **Install kernel image to
    /boot in target**'
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在**内核** | **将内核映像安装到目标的/boot目录**中选择`BR2_LINUX_KERNEL_INSTALL_TARGET`
- en: 'To increase the size of the root filesystem to accommodate the unstripped binaries
    and the `vmlinux` file:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 为了增加根文件系统的大小以适应未剥离的二进制文件和`vmlinux`文件：
- en: Select **Filesystem images** | **ext2/3/4 root filesystem** | **Exact size**
    and enter `960M` in the text field.
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 选择**文件系统映像** | **ext2/3/4根文件系统** | **精确大小**，然后在文本框中输入`960M`。
- en: Then run `make clean` followed by `make`.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 然后运行`make clean`，接着运行`make`。
- en: Once you have built everything, you will have to copy `vmlinux` to the target
    image manually.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你完成了所有构建，你将需要手动将`vmlinux`复制到目标映像中。
- en: Profiling with perf
  id: totrans-111
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用perf进行性能分析
- en: You can use `perf` to sample the state of a program using one of the event counters
    and accumulate samples over a period of time to create a profile. This is another
    example of statistical profiling. The default event counter is called `cycles`,
    which is a generic hardware counter that is mapped to a PMU register representing
    a count of cycles at the core clock frequency.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用`perf`通过事件计数器采样程序状态，并在一段时间内累积样本来创建性能分析报告。这是另一种统计性能分析的方法。默认事件计数器叫做`cycles`，它是一个通用硬件计数器，映射到一个PMU寄存器，表示在核心时钟频率下的周期计数。
- en: 'Creating a profile using `perf` is a two-stage process: the `perf record` command
    captures samples and writes them to a file named `perf.data`, then `perf report`
    analyzes the results. Both commands are run on the target. The samples being collected
    are filtered for the process and any of its children. Here is an example of profiling
    a shell script that searches for the `linux` string:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`perf`创建分析报告是一个两阶段的过程：`perf record`命令捕获样本并将其写入名为`perf.data`的文件，然后`perf report`命令分析结果。两个命令都在目标上运行。收集的样本会过滤出特定进程及其所有子进程的相关数据。以下是对一个查找`linux`字符串的shell脚本进行分析的示例：
- en: '[PRE3]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Now you can display the results from `perf.data` using the `perf report` command.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你可以使用`perf report`命令显示`perf.data`中的结果。
- en: 'There are three user interfaces to choose from:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 有三种用户界面可供选择：
- en: '`--stdio`: This is a pure-text interface with no user interaction. You will
    have to launch `perf report` and `annotate` for each view of the trace.'
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`--stdio`：这是一个纯文本界面，没有用户交互。你需要分别启动`perf report`和`annotate`来查看每个跟踪视图。'
- en: '`--tui`: This is a simple text-based menu interface with traversal between
    screens.'
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`--tui`：这是一个基于文本的简单菜单界面，可以在屏幕之间进行导航。'
- en: '`--gtk`: This is a graphical interface that otherwise acts in the same way
    as `--tui`.'
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`--gtk`：这是一个图形界面，功能与`--tui`相同。'
- en: 'The default is TUI, as shown in this example:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下是TUI，如本示例所示：
- en: '![Figure 20.1 – perf report TUI](img/B18466_20_1.png)'
  id: totrans-121
  prefs: []
  type: TYPE_IMG
  zh: '![图 20.1 – perf报告TUI](img/B18466_20_1.png)'
- en: Figure 20.1 – perf report TUI
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 图 20.1 – perf报告TUI
- en: '`perf` is able to record the kernel functions executed on behalf of the processes
    because it collects samples in kernel space.'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: '`perf`能够记录由进程执行的内核函数，因为它在内核空间收集样本。'
- en: The list is ordered with the most active functions first. In this example, all
    but one are captured while `grep` is running. Some are in a library, `libc-2.20`,
    some are in a program, `busybox.nosuid`, and some are in the kernel. We have symbol
    names for program and library functions because all the binaries have been installed
    on the target with debug information, and kernel symbols are being read from `/boot/vmlinux`.
    If you have `vmlinux` in a different location, add `-k <path>` to the `perf report`
    command. Rather than storing samples in `perf.data`, you can save them to a different
    file using `perf record -o <file name>` and analyze them using `perf report` `-i
    <file name>`.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 列表按照最活跃的函数排在前面。在这个例子中，除了一个，所有函数都是在运行 `grep` 时捕获的。有些在库中，`libc-2.20`，有些在程序中，`busybox.nosuid`，还有些在内核中。我们能够获取程序和库函数的符号名，因为所有的二进制文件都已经安装在目标机器上并包含了调试信息，而内核符号是从
    `/boot/vmlinux` 中读取的。如果你的 `vmlinux` 存放在其他位置，记得在 `perf report` 命令中加上 `-k <path>`
    参数。你也可以通过使用 `perf record -o <文件名>` 将样本保存到不同的文件中，然后用 `perf report -i <文件名>` 进行分析，而不是将样本存储在
    `perf.data` 中。
- en: By default, `perf record` samples at a frequency of 1,000 Hz using the `cycles`
    counter.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，`perf record` 使用 `cycles` 计数器以 1,000 Hz 的频率进行采样。
- en: '**TIP**'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: '**提示**'
- en: A sampling frequency of 1,000 Hz may be higher than you really need and may
    be the cause of the observer effect. Try lower rates; 100 Hz is enough for most
    cases. You can set the sample frequency using the `-F` option.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 1,000 Hz 的采样频率可能比你实际需要的更高，也可能是观测者效应的原因。尝试较低的采样率；100 Hz 足以应对大多数情况。你可以使用 `-F`
    选项来设置采样频率。
- en: This is still not really making life easy; the functions at the top of the list
    are mostly low-level memory operations, and you can be fairly sure that they have
    already been optimized. Fortunately, `perf record` also gives us the ability to
    crawl up the call stack and see where these functions are being invoked.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 这仍然没有真正简化工作；列表顶部的函数大多是低级别的内存操作，且你可以相当肯定这些函数已经被优化过了。幸运的是，`perf record` 还为我们提供了向上爬取调用堆栈并查看这些函数被调用位置的能力。
- en: Call graphs
  id: totrans-129
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 调用图
- en: It would be nice to step back and see the surrounding context of these costly
    functions. You can do that by passing the `-g` option to `perf record` to capture
    the backtrace from each sample.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 如果能够回溯并查看这些高开销函数的周围上下文，那就更好了。你可以通过向 `perf record` 传递 `-g` 选项来捕获每个样本的回溯信息。
- en: 'Now, `perf report` shows a plus sign (`+`) where the function is part of a
    call chain. You can expand the trace to see the functions lower down in the chain:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，`perf report` 显示一个加号（`+`）表示该函数是调用链的一部分。你可以展开追踪，查看链条中更低位置的函数：
- en: '![Figure 20.2 – perf report (call graphs)](img/B18466_20_2.png)'
  id: totrans-132
  prefs: []
  type: TYPE_IMG
  zh: '![图 20.2 – perf report（调用图）](img/B18466_20_2.png)'
- en: Figure 20.2 – perf report (call graphs)
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 图 20.2 – perf report（调用图）
- en: '**IMPORTANT NOTE**'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: '**重要提示**'
- en: Generating call graphs relies on the ability to extract call frames from the
    stack, just like backtraces in GDB. The debug information needed to unwind stacks
    is encoded in the executables. Call graphs cannot be produced for some combinations
    of architecture and toolchains because the binaries lack the necessary debug information.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 生成调用图依赖于从堆栈中提取调用帧的能力，就像GDB中的回溯信息一样。解开堆栈所需的调试信息被编码在可执行文件中。对于某些架构和工具链的组合，由于二进制文件缺乏必要的调试信息，因此无法生成调用图。
- en: Backtraces are nice, but where is the assembler, or better yet, the source code,
    for these functions?
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 回溯信息很有用，但这些函数的汇编代码在哪里，或者更好的是，源代码在哪里？
- en: perf annotate
  id: totrans-137
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: perf annotate
- en: Now that you know which functions to look at, it would be nice to step inside
    and see the code and to have hit counts for each instruction. That is what `perf
    annotate` does, by calling down to a copy of `objdump` installed on the target.
    You just need to use `perf annotate` in place of `perf report`.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经知道了要查看哪些函数，接下来可以深入查看代码，并获得每个指令的命中次数。这就是 `perf annotate` 的作用，它通过调用目标机器上的
    `objdump` 副本来实现。你只需将 `perf annotate` 替换为 `perf report` 即可。
- en: '`perf annotate` requires symbol tables for the executables and `vmlinux`. Here
    is an example of an annotated function:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: '`perf annotate` 需要可执行文件和 `vmlinux` 的符号表。以下是一个注释过的函数示例：'
- en: '![Figure 20.3 – perf annotate (assembler)](img/B18466_20_3.png)'
  id: totrans-140
  prefs: []
  type: TYPE_IMG
  zh: '![图 20.3 – perf annotate（汇编代码）](img/B18466_20_3.png)'
- en: Figure 20.3 – perf annotate (assembler)
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 图 20.3 – perf annotate（汇编代码）
- en: 'If you want to see the source code interleaved with the assembler, you can
    copy the relevant source files to the target device. If you are using The Yocto
    Project and build with the `src-pkgs` extra image feature or have installed the
    individual `<package>-src` packages, then the source will have been installed
    for you in `/usr/src/debug`. Otherwise, you can examine the debug information
    to see the location of the source code:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想看到与汇编代码交织在一起的源代码，可以将相关源文件复制到目标设备。如果你使用的是 The Yocto Project 并且通过 `src-pkgs`
    附加镜像特性构建，或者已经安装了单独的 `<package>-src` 包，那么源代码将已经安装在 `/usr/src/debug` 中。否则，你可以查看调试信息，查找源代码的位置：
- en: '[PRE4]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The path on the target should be *exactly the same* as the path you can see
    in `DW_AT_comp_dir`.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 目标路径必须与 `DW_AT_comp_dir` 中看到的路径*完全相同*。
- en: 'Here is an example of annotation with the source and assembler code:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是源代码与汇编代码的注释示例：
- en: '![Figure 20.4 – perf annotate (source code)](img/B18466_20_4.png)'
  id: totrans-146
  prefs: []
  type: TYPE_IMG
  zh: '![图 20.4 – perf annotate（源代码）](img/B18466_20_4.png)'
- en: Figure 20.4 – perf annotate (source code)
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 图 20.4 – perf annotate（源代码）
- en: 'Now we can see the corresponding C source code above `cmp r0` and below the
    `str r3, [fp, #-40]` instruction.'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: '现在我们可以看到 `cmp r0` 上方和 `str r3, [fp, #-40]` 指令下方的相应 C 源代码。'
- en: This concludes our coverage of `perf`. While there are other statistical sampling
    profilers that predate `perf`, like OProfile and `gprof`, these tools have fallen
    out of favor in recent years, so I chose to omit them. Next, we will look at event
    tracers.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是我们对`perf`的介绍。虽然在`perf`之前还有其他统计采样分析器，比如 OProfile 和 `gprof`，但这些工具近年来已经不再被广泛使用，因此我选择将它们省略。接下来，我们将讨论事件跟踪工具。
- en: Tracing events
  id: totrans-150
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 跟踪事件
- en: 'The tools we have seen so far all use statistical sampling. You often want
    to know more about the ordering of events so that you can see them and relate
    them to each other. Function tracing involves instrumenting the code with tracepoints
    that capture information about the event, and may include some or all of the following:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止我们看到的所有工具都使用统计采样。你通常希望了解更多关于事件顺序的信息，以便你能查看它们并将它们相互关联。函数跟踪涉及通过在代码中加入跟踪点来捕捉事件信息，可能包括以下一些或全部内容：
- en: A timestamp
  id: totrans-152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 时间戳
- en: Context, such as the current PID
  id: totrans-153
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 上下文信息，例如当前的PID
- en: Function parameters and return values
  id: totrans-154
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 函数参数和返回值
- en: A call stack
  id: totrans-155
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 调用栈
- en: It is more intrusive than statistical profiling and it can generate a large
    amount of data. The latter problem can be mitigated by applying filters when the
    sample is captured and, later on, when viewing the trace.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 它比统计分析更具侵入性，并且可能会生成大量数据。后者的问题可以通过在采样时应用过滤器以及稍后查看跟踪时应用过滤器来减轻。
- en: 'I will cover three trace tools here: the kernel function tracers Ftrace, LTTng,
    and eBPF.'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 我将在这里介绍三种跟踪工具：内核函数跟踪器 Ftrace、LTTng 和 eBPF。
- en: Introducing Ftrace
  id: totrans-158
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 引入 Ftrace
- en: The kernel function tracer **Ftrace** evolved from work done by Steven Rostedt
    and many others as they were tracking down the causes of high scheduling latency
    in real-time applications. Ftrace appeared in Linux 2.6.27 and has been actively
    developed since then. There are a number of documents describing kernel tracing
    in the kernel source in `Documentation/trace`.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 内核函数跟踪器 **Ftrace** 起源于 Steven Rostedt 等人为了追踪实时应用中高调度延迟的原因而开展的工作。Ftrace 出现在 Linux
    2.6.27 中，并且自那时以来一直在积极开发。内核源代码中的 `Documentation/trace` 目录包含了许多关于内核跟踪的文档。
- en: Ftrace consists of a number of tracers that can log various types of activity
    in the kernel. Here, I am going to talk about the `function` and `function_graph`
    tracers and the event tracepoints. In [*Chapter 21*](Chapter_19.xhtml#_idTextAnchor654),
    I will revisit Ftrace when I talk about real-time latencies.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: Ftrace由多个跟踪器组成，可以记录内核中的各种活动。在这里，我将讨论 `function` 和 `function_graph` 跟踪器以及事件跟踪点。在[*第21章*](Chapter_19.xhtml#_idTextAnchor654)中，我将再次提到
    Ftrace，并讨论实时延迟。
- en: The `function` tracer instruments each kernel function so that calls can be
    recorded and timestamped. It compiles the kernel with the `-pg` switch to inject
    the instrumentation. The `function_graph` tracer goes further and records both
    the entry and exit of functions so that it can create a call graph. The event
    tracepoints feature records parameters associated with the call.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: '`function` 跟踪器为每个内核函数添加了跟踪点，以便记录和时间戳化调用。它通过 `-pg` 选项编译内核，以注入这些跟踪代码。`function_graph`
    跟踪器更进一步，记录了函数的入口和出口，从而生成调用图。事件跟踪点功能记录与调用相关的参数。'
- en: 'Ftrace has a very embedded-friendly user interface that is entirely implemented
    through virtual files in the `debugfs` filesystem, meaning that you do not have
    to install any tools on the target to make it work. Nevertheless, there are other
    user interfaces if you prefer: `trace-cmd` is a command-line tool that records
    and views traces and is available in Buildroot (`BR2_PACKAGE_TRACE_CMD`) and The
    Yocto Project (`trace-cmd`). There is a graphical trace viewer named **KernelShark**
    that is available as a package for The Yocto Project.'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: Ftrace 具有非常适合嵌入式的用户界面，完全通过 `debugfs` 文件系统中的虚拟文件实现，这意味着你不必在目标上安装任何工具即可使其工作。不过，如果你愿意，也有其他用户界面可供选择：`trace-cmd`
    是一个命令行工具，用于记录和查看跟踪，且可以在 Buildroot (`BR2_PACKAGE_TRACE_CMD`) 和 The Yocto Project
    (`trace-cmd`) 中使用。还有一个图形化的跟踪查看器 **KernelShark**，它作为 The Yocto Project 的一个软件包提供。
- en: Like `perf`, enabling Ftrace requires setting certain kernel configuration options.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 像 `perf` 一样，启用 Ftrace 需要设置一些内核配置选项。
- en: Preparing to use Ftrace
  id: totrans-164
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备使用 Ftrace
- en: 'Ftrace and its various options are configured in the kernel configuration menu.
    You will need the following at a minimum:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: Ftrace 及其各种选项在内核配置菜单中进行配置。至少需要以下选项：
- en: '`CONFIG_FUNCTION_TRACER` from the **Kernel hacking** | **Tracers** | **Kernel
    Function Tracer** menu.'
  id: totrans-166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Kernel hacking** | **Tracers** | **Kernel Function Tracer** 菜单中的 `CONFIG_FUNCTION_TRACER`'
- en: 'You would be well advised to turn on these options as well:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 强烈建议你开启这些选项：
- en: '`CONFIG_FUNCTION_GRAPH_TRACER` in the **Kernel hacking** | **Tracers** | **Kernel
    Function Tracer** | **Kernel Function Graph Tracer** menu'
  id: totrans-168
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Kernel hacking** | **Tracers** | **Kernel Function Tracer** | **Kernel Function
    Graph Tracer** 菜单中的 `CONFIG_FUNCTION_GRAPH_TRACER`'
- en: '`CONFIG_DYNAMIC_FTRACE` in the **Kernel hacking** | **Tracers** | **Kernel
    Function Tracer** | **Enable/disable function tracing dynamically** menu'
  id: totrans-169
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Kernel hacking** | **Tracers** | **Kernel Function Tracer** | **Enable/disable
    function tracing dynamically** 菜单中的 `CONFIG_DYNAMIC_FTRACE`'
- en: '`CONFIG_FUNCTION_PROFILER` in the **Kernel hacking** | **Tracers** | **Kernel
    Function Tracer** | **Kernel function profiler** menu'
  id: totrans-170
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Kernel hacking** | **Tracers** | **Kernel Function Tracer** | **Kernel function
    profiler** 菜单中的 `CONFIG_FUNCTION_PROFILER`'
- en: Since the whole thing is hosted in the kernel, there is no user-space configuration
    to be done.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 由于整个过程在内核中执行，因此无需进行用户空间的配置。
- en: Using Ftrace
  id: totrans-172
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 Ftrace
- en: 'Before you can use Ftrace, you have to mount the `debugfs` filesystem, which
    goes in the `/sys/kernel/debug` directory:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 在你使用 Ftrace 之前，你必须挂载 `debugfs` 文件系统，它位于 `/sys/kernel/debug` 目录下：
- en: '[PRE5]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: All the controls for Ftrace are in the `/sys/kernel/debug/tracing` directory;
    there is even a mini `HOWTO` in the `README` file there.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 所有 Ftrace 控制项都在 `/sys/kernel/debug/tracing` 目录下；这里甚至有一个迷你版的 `HOWTO` 文件在 `README`
    中。
- en: 'This is the list of tracers available in the kernel:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 这是内核中可用的跟踪器列表：
- en: '[PRE6]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The active tracer is shown by `current_tracer`. Initially, it will be the null
    tracer, `nop`.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 当前使用的跟踪器由 `current_tracer` 显示。最初，它将是空跟踪器 `nop`。
- en: 'To capture a trace, select the tracer by writing the name of one of the `available_tracers`
    to `current_tracer`. Then, enable tracing for a short while:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 要捕获跟踪，请通过将 `available_tracers` 中某个跟踪器的名称写入 `current_tracer` 来选择跟踪器。然后，启用短时间的跟踪：
- en: '[PRE7]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'In that one second, the trace buffer will have been filled with the details
    of every function called by the kernel. The format of the trace buffer is plain
    text, as described in `Documentation/trace/ftrace.txt`. You can read the trace
    buffer from the `trace` file:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一秒钟内，跟踪缓冲区将被填充上内核调用的每个函数的详细信息。跟踪缓冲区的格式是纯文本，如 `Documentation/trace/ftrace.txt`
    中所描述。你可以通过 `trace` 文件读取跟踪缓冲区：
- en: '[PRE8]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: You can capture a large number of data points in just one second—in this case,
    over 40,000.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在仅仅一秒钟内捕获大量数据点——在此情况下，超过 40,000 个。
- en: 'As with profilers, it is difficult to make sense of a flat function list like
    this. If you select the `function_graph` tracer, Ftrace captures call graphs like
    this:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 和分析器一样，像这样的平面函数列表很难理解。如果你选择 `function_graph` 跟踪器，Ftrace 会捕获如下的调用图：
- en: '[PRE9]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Now you can see the nesting of the function calls, delimited by braces, `{`
    and `}`. At the terminating brace, there is a measurement of the time taken in
    the function, annotated with a plus sign (`+`) if it takes more than 10 µs and
    an exclamation mark (`!`) if it takes more than 100 µs.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你可以看到函数调用的嵌套，使用大括号 `{` 和 `}` 分隔。在终止的大括号处，会显示该函数的执行时间，如果超过 10 微秒，会有一个加号（`+`）标注；如果超过
    100 微秒，会有一个感叹号（`!`）标注。
- en: You are often only interested in the kernel activity caused by a single process
    or thread, in which case you can restrict the trace to one thread by writing the
    thread ID to `set_ftrace_pid`.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 你通常只对由单个进程或线程引起的内核活动感兴趣，这时你可以通过将线程 ID 写入`set_ftrace_pid`来将追踪限制为一个线程。
- en: Dynamic Ftrace and trace filters
  id: totrans-188
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 动态 Ftrace 和 trace 过滤器
- en: Enabling `CONFIG_DYNAMIC_FTRACE` allows Ftrace to modify the function trace
    sites at runtime, which has a couple of benefits. Firstly, it triggers additional
    build-time processing of the trace function probes, which allows the Ftrace subsystem
    to locate them at boot time and overwrite them with `nop` instructions, thus reducing
    the overhead of the function trace code to almost nothing. You can then enable
    Ftrace in production or near-production kernels with no impact on performance.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 启用`CONFIG_DYNAMIC_FTRACE`允许 Ftrace 在运行时修改函数追踪位置，这有几个好处。首先，它触发了额外的构建时处理追踪函数探针，这使得
    Ftrace 子系统能够在启动时定位它们并用`nop`指令覆盖，从而将函数追踪代码的开销减少到几乎为零。你可以在生产环境或接近生产环境的内核中启用 Ftrace，而不会影响性能。
- en: 'The second advantage is that you can selectively enable function trace sites
    rather than tracing everything. The list of functions is put into `available_filter_functions`.
    You can selectively enable function traces as needed by copying the name from
    `available_filter_functions` to `set_ftrace_filter.` To stop tracing that function,
    write its name to `set_ftrace_notrace`. You can also use wildcards and append
    names to the list. For example, suppose you are interested in `tcp` handling:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个好处是你可以选择性地启用函数追踪位置，而不是追踪所有内容。函数的列表被放入`available_filter_functions`中。你可以通过将名称从`available_filter_functions`复制到`set_ftrace_filter`来按需启用函数追踪。要停止追踪该函数，向`set_ftrace_notrace`写入其名称。你还可以使用通配符并将名称追加到列表中。例如，假设你对`tcp`处理感兴趣：
- en: '[PRE10]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Run some tests and then look at `trace`:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 运行一些测试，然后查看`trace`：
- en: '[PRE11]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The `set_ftrace_filter` function can also contain commands to start and stop
    tracing when certain functions are executed. There isn’t space to go into these
    details here, but if you want to find out more, read the *Filter commands* section
    in `Documentation/trace/ftrace.txt`.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: '`set_ftrace_filter`函数还可以包含命令，用于在某些函数执行时启动和停止追踪。这里没有足够的空间详细说明这些内容，但如果你想了解更多，阅读`Documentation/trace/ftrace.txt`中的*Filter
    commands*部分。'
- en: Trace events
  id: totrans-195
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Trace 事件
- en: The `function` and `function_graph` tracers only record the time at which the
    function was executed. The trace events feature also records parameters associated
    with the call, making the trace more readable and informative. For example, instead
    of just recording that the `kmalloc` function has been called, a trace event will
    record the number of bytes requested and the returned pointer. Trace events are
    used in `perf` and LTTng as well as Ftrace, but the development of the trace events
    subsystem was prompted by the LTTng project.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: '`function`和`function_graph`追踪器只记录函数执行的时间。Trace 事件特性还记录与调用相关的参数，使追踪更加可读和具有信息性。例如，追踪事件不仅记录`kmalloc`函数已被调用，还会记录请求的字节数和返回的指针。Trace
    事件在`perf`、LTTng以及 Ftrace 中都被使用，但开发 trace 事件子系统的推动力来自于 LTTng 项目。'
- en: 'It takes effort from kernel developers to create trace events. They are defined
    in the source code using the `TRACE_EVENT` macro; there are over a thousand of
    them now. You can see the list of events available at runtime in `/sys/kernel/debug/tracing/available_events`.
    They are named <`subsystem>:<function>` (e.g., `kmem:kmalloc`). Each event is
    also represented by a subdirectory in `tracing/events/<subsystem>/<function>`:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: '创建 trace 事件需要内核开发人员的努力。它们在源代码中使用`TRACE_EVENT`宏进行定义，现在有超过一千个。你可以在运行时查看`/sys/kernel/debug/tracing/available_events`中可用事件的列表。它们的命名格式为<`subsystem`:
    `function`>（例如，`kmem:kmalloc`）。每个事件还通过`tracing/events/<subsystem>/<function>`中的子目录进行表示：'
- en: '[PRE12]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'The files are:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 这些文件是：
- en: '`enable`: You write a `1` to this file to enable the event.'
  id: totrans-200
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`enable`：你可以向此文件写入`1`来启用事件。'
- en: '`filter`: This is an expression that must evaluate to `true` for the event
    to be traced.'
  id: totrans-201
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`filter`：这是一个表达式，事件必须评估为`true`才能被追踪。'
- en: '`format`: This is the format of the event and parameters.'
  id: totrans-202
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`format`：这是事件及其参数的格式。'
- en: '`id`: This is a numeric identifier.'
  id: totrans-203
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`id`：这是一个数字标识符。'
- en: '`trigger`: This is a command that is executed when the event occurs using the
    syntax defined in the *Filter commands* section of `Documentation/trace/ftrace.txt`.'
  id: totrans-204
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`trigger`：这是一个命令，当事件发生时会执行，语法定义在`Documentation/trace/ftrace.txt`的*Filter commands*部分。'
- en: 'I will show you a simple example involving `kmalloc` and `kfree`. Event tracing
    does not depend on the function tracers, so begin by selecting the `nop` tracer:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 我将展示一个涉及`kmalloc`和`kfree`的简单示例。事件跟踪不依赖于函数跟踪器，因此可以从选择`nop`跟踪器开始：
- en: '[PRE13]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Next, select the events to trace by enabling each one individually:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，通过单独启用每个事件来选择要跟踪的事件：
- en: '[PRE14]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'You can also write the event names to `set_event`, as shown here:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以将事件名称写入`set_event`，如下所示：
- en: '[PRE15]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Now, when you read the trace, you can see the functions and their parameters:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，当你阅读跟踪时，你可以看到函数及其参数：
- en: '[PRE16]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Exactly the same trace events are visible in `perf` as tracepoint events.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 在`perf`中可见的跟踪事件与tracepoint事件完全相同。
- en: Since there is no bloated user-space component to build, Ftrace is well suited
    for deploying to most embedded targets. Next, we will look at another popular
    event tracer whose origins predate those of Ftrace.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 由于没有臃肿的用户空间组件需要构建，Ftrace非常适合部署到大多数嵌入式目标设备上。接下来，我们将看一下另一种流行的事件跟踪器，它的起源早于Ftrace。
- en: Using LTTng
  id: totrans-215
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用LTTng
- en: The **Linux Trace Toolkit** (**LTT**) project was started by Karim Yaghmour
    as a means of tracing kernel activity and was one of the first trace tools generally
    available for the Linux kernel. Later, Mathieu Desnoyers took up the idea and
    re-implemented it as a next-generation trace tool, **LTTng**. It was then expanded
    to cover user-space traces as well as the kernel. The project website is at [https://lttng.org/](https://lttng.org/)
    and contains a comprehensive user manual.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: '**Linux Trace Toolkit**（**LTT**）项目由Karim Yaghmour发起，目的是跟踪内核活动，并且是最早为Linux内核提供的跟踪工具之一。后来，Mathieu
    Desnoyers接手了这个想法，并将其重新实现为下一代跟踪工具，**LTTng**。之后，项目扩展到了包括用户空间的跟踪。项目官网在[https://lttng.org/](https://lttng.org/)，并包含了一本全面的用户手册。'
- en: 'LTTng consists of three components:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: LTTng由三个组件组成：
- en: A core session manager
  id: totrans-218
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个核心会话管理器
- en: A kernel tracer implemented as a group of kernel modules
  id: totrans-219
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个作为一组内核模块实现的内核跟踪器
- en: A user-space tracer implemented as a library
  id: totrans-220
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个作为库实现的用户空间跟踪器
- en: In addition to those, you will need a trace viewer such as **Babeltrace** ([https://babeltrace.org/](https://babeltrace.org/))
    or the **Eclipse Trace Compass** plugin to display and filter the raw trace data
    on the host or target.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 除了这些，你还需要一个跟踪查看器，比如**Babeltrace**（[https://babeltrace.org/](https://babeltrace.org/)）或**Eclipse
    Trace Compass**插件，用于在主机或目标设备上显示和过滤原始跟踪数据。
- en: LTTng requires a kernel configured with `CONFIG_TRACEPOINTS`, which is enabled
    when you select **Kernel hacking** | **Tracers** | **Kernel Function Tracer**.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: LTTng需要一个配置了`CONFIG_TRACEPOINTS`的内核，当你选择**Kernel hacking** | **Tracers** | **Kernel
    Function Tracer**时，会启用该选项。
- en: The description that follows refers to LTTng version 2.13\. Other versions may
    be different.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 以下描述指的是LTTng版本2.13。其他版本可能会有所不同。
- en: LTTng and The Yocto Project
  id: totrans-224
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: LTTng和Yocto项目
- en: 'You need to add these packages to the target dependencies in `conf/local.conf`:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 你需要将这些包添加到`conf/local.conf`中的目标依赖项：
- en: '[PRE17]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: If you want to run Babeltrace on the target, also append the `babeltrace2` package.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想在目标设备上运行Babeltrace，也需要添加`babeltrace2`包。
- en: LTTng and Buildroot
  id: totrans-228
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: LTTng和Buildroot
- en: 'You need to enable the following:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 你需要启用以下选项：
- en: '`BR2_PACKAGE_LTTNG_MODULES` in the **Target packages** | **Debugging, profiling
    and benchmark** | **lttng-modules** menu'
  id: totrans-230
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Target packages** | **Debugging, profiling and benchmark** | **lttng-modules**菜单中的`BR2_PACKAGE_LTTNG_MODULES`'
- en: '`BR2_PACKAGE_LTTNG_TOOLS` in the **Target packages** | **Debugging, profiling
    and benchmark** | **lttng-tools** menu'
  id: totrans-231
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Target packages** | **Debugging, profiling and benchmark** | **lttng-tools**菜单中的`BR2_PACKAGE_LTTNG_TOOLS`'
- en: 'For user-space trace tracing, enable these:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 对于用户空间的跟踪，请启用以下选项：
- en: '`BR2_PACKAGE_UTIL_LINUX_UUIDD` in the **Target packages** | **System tools**
    | **util-linux** | **uuidd** menu'
  id: totrans-233
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Target packages** | **System tools** | **util-linux** | **uuidd**菜单中的`BR2_PACKAGE_UTIL_LINUX_UUIDD`'
- en: '`BR2_PACKAGE_LTTNG_LIBUST` in the **Target packages** | **Libraries** | **Other**
    | **lttng-libust** menu'
  id: totrans-234
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Target packages** | **Libraries** | **Other** | **lttng-libust**菜单中的`BR2_PACKAGE_LTTNG_LIBUST`'
- en: '`BR2_PACKAGE_HOST_BABELTRACE2` in the **Host utilities** | **host babeltrace2**
    menu'
  id: totrans-235
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Host utilities** | **host babeltrace2** 菜单中的`BR2_PACKAGE_HOST_BABELTRACE2`'
- en: There is a package called `babletrace2` for the target. Buildroot installs `babeltrace2`
    for the host in `output/host/usr/bin/babeltrace2`.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 目标设备上有一个名为`babletrace2`的包。Buildroot在`output/host/usr/bin/babeltrace2`中为主机安装了`babeltrace2`。
- en: Using LTTng for kernel tracing
  id: totrans-237
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用LTTng进行内核跟踪
- en: LTTng can use the set of Ftrace events described previously as potential tracepoints.
    Initially, they are disabled.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: LTTng可以使用前面描述的Ftrace事件集作为潜在的跟踪点。最初，它们是禁用的。
- en: 'The control interface for LTTng is the `lttng` command. You can list the kernel
    probes using the following:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: LTTng的控制接口是`lttng`命令。您可以使用以下命令列出内核探针：
- en: '[PRE18]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Traces are captured in the context of a session, which, in this example, is
    called `test`:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 跟踪是在会话上下文中捕获的，例如，在这个示例中称为`test`：
- en: '[PRE19]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Now enable a few events in the current session. You can enable all kernel tracepoints
    using the `--all` option, but remember the warning about generating too much trace
    data. Let’s start with a couple of scheduler-related trace events:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 现在在当前会话中启用几个事件。您可以使用`--all`选项启用所有内核跟踪点，但请记住有关生成过多跟踪数据的警告。让我们从几个与调度器相关的跟踪事件开始：
- en: '[PRE20]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Check that everything is set up:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 检查所有设置是否已完成：
- en: '[PRE21]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Now start tracing:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 现在开始跟踪：
- en: '[PRE22]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Run the test load, and then stop tracing:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 运行测试负载，然后停止跟踪：
- en: '[PRE23]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Traces for the session are written to the session directory, `lttng-traces/<session>/kernel`.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 会话的跟踪结果将写入会话目录，`lttng-traces/<session>/kernel`。
- en: 'Use the Babeltrace viewer to dump the raw trace data in text format. In this
    case, I ran it on the host computer:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Babeltrace查看器以文本格式转储原始跟踪数据。在本例中，我在主机上运行了它：
- en: '[PRE24]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: The output is too verbose to fit on this page, so I will leave it as an exercise
    for you to capture and display a trace in this way. The text output from Babeltrace
    has the advantage that it is easy to search for strings using `grep` and similar
    commands.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 输出内容过于冗长，无法完全显示在本页上，所以我会留给您的练习是以这种方式捕获和显示跟踪。使用Babeltrace的文本输出的优点是可以使用`grep`和类似命令轻松搜索字符串。
- en: 'A good choice for a graphical trace viewer is the **Trace Compass** plugin
    for Eclipse, which is now part of the Eclipse IDE for the C/C++ developer bundle.
    Importing the trace data into Eclipse is characteristically fiddly. Follow these
    steps:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 图形跟踪查看器的一个不错选择是Eclipse的**Trace Compass**插件，它现在是Eclipse IDE的一部分，适用于C/C++开发者包。将跟踪数据导入Eclipse通常有些复杂。请按照以下步骤操作：
- en: Open the **Tracing** perspective.
  id: totrans-256
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开**跟踪**视图。
- en: Create a new project by selecting **File** | **New** | **Tracing project**.
  id: totrans-257
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过选择**文件** | **新建** | **跟踪项目**来创建新项目。
- en: Enter a project name and click on **Finish**.
  id: totrans-258
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 输入项目名称，然后单击**完成**。
- en: Right-click on the **New Project** option in the **Project Explorer** menu and
    select **Import**.
  id: totrans-259
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**项目资源管理器**菜单中右键单击**新建项目**选项，然后选择**导入**。
- en: Expand **Tracing**, and then select **Trace Import**.
  id: totrans-260
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 展开**跟踪**，然后选择**跟踪导入**。
- en: Browse to the directory containing the traces (e.g., `test-20150824-140942`),
    tick the box to indicate which subdirectories you want (might be **kernel**),
    and click on **Finish**.
  id: totrans-261
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 浏览到包含跟踪的目录（例如，`test-20150824-140942`），选中要包括的子目录（可能是**kernel**），然后单击**完成**。
- en: Expand the project, expand **Traces[1]**, and then double-click on **kernel**.
  id: totrans-262
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 展开项目，展开**跟踪[1]**，然后双击**kernel**。
- en: Now, let’s switch gears away from LTTng and jump headfirst into the latest and
    greatest event tracer for Linux.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们远离LTTng，直接跳入最新和最伟大的Linux事件跟踪器。
- en: Using eBPF
  id: totrans-264
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用eBPF
- en: '**Berkeley Packet Filter** (**BPF**) is a technology that was first introduced
    in 1992 to capture, filter, and analyze network traffic. In 2013, Alexi Starovoitov
    undertook a rewrite of BPF with help from Daniel Borkmann. Their work, then known
    as **eBPF** (**extended BPF**), was merged into the kernel in 2014, where it has
    been available since Linux 3.15\. eBPF provides a sandboxed execution environment
    for running programs inside the Linux kernel. eBPF programs are written in C and
    are **just-in-time** (**JIT**) compiled to native code. Before that happens, the
    intermediate eBPF bytecode must first pass through a series of safety checks so
    that a program cannot crash the kernel.'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: '**伯克利数据包过滤器**（**BPF**）是一项技术，最早于1992年引入，用于捕获、过滤和分析网络流量。2013年，Alexi Starovoitov在Daniel
    Borkmann的帮助下重写了BPF。他们的工作，后来称为**扩展BPF**（**eBPF**），在2014年合并到内核中，自Linux 3.15版本以来一直可用。eBPF为在Linux内核内运行程序提供了一个沙盒执行环境。eBPF程序用C语言编写，并且**即时编译**（**JIT**）成本地代码。在这之前，eBPF中间字节码必须通过一系列安全检查，以防止程序崩溃内核。'
- en: Despite its networking origins, eBPF is now a general-purpose virtual machine
    running inside the Linux kernel. By making it easy to run small programs on specific
    kernel and application events, eBPF has quickly emerged as the most powerful tracer
    for Linux. Like what cgroups did for containerized deployments, eBPF has the potential
    to revolutionize observability by enabling users to fully instrument production
    systems. Netflix and Facebook make extensive use of eBPF across their microservices
    and cloud infrastructure for performance analysis and thwarting **distributed
    denial-of-service** (**DDoS**) attacks.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管 eBPF 起源于网络，但现在已经成为一个在 Linux 内核中运行的通用虚拟机。通过使得在特定内核和应用程序事件上运行小程序变得简单，eBPF 已迅速成为
    Linux 最强大的跟踪工具。就像 cgroups 对容器化部署的影响一样，eBPF 有潜力通过使用户能够全面监控生产系统，彻底革新可观察性。Netflix
    和 Facebook 在其微服务和云基础设施中广泛使用 eBPF 进行性能分析，并防止 **分布式拒绝服务**（**DDoS**）攻击。
- en: 'The tooling around eBPF is evolving, with **BPF Compiler Collection** (**BCC**)
    and **bpftrace** establishing themselves as the two most prominent frontends.
    Brendan Gregg was deeply involved in both projects and has written about eBPF
    extensively in his book *BPF Performance Tools: Linux System and Application Observability*.
    With so many possibilities covering such a vast scope, new technology such as
    eBPF can seem overwhelming. But much like cgroups, we don’t need to understand
    how eBPF works to start making use of it. BCC comes with several ready-made tools
    and examples that we can simply run from the command line.'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: eBPF 周围的工具正在不断发展，**BPF 编译器集合**（**BCC**）和 **bpftrace** 已经成为两个最突出的前端工具。Brendan
    Gregg 深度参与了这两个项目，并在他的书籍《*BPF 性能工具：Linux 系统和应用程序可观察性*》中广泛撰写了有关 eBPF 的内容。由于 eBPF
    涉及的范围如此广泛，许多可能性可能让人感觉不知所措。但和 cgroups 一样，我们并不需要理解 eBPF 的具体工作原理，就能开始利用它。BCC 提供了多个现成的工具和示例，我们可以直接从命令行运行。
- en: Configuring the kernel for eBPF
  id: totrans-268
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 为 eBPF 配置内核
- en: A package named **ply** ([https://github.com/iovisor/ply](https://github.com/iovisor/ply))
    was merged into Buildroot on January 23, 2021, for inclusion in the 2021.02 LTS
    release of Buildroot. **ply** is a lightweight, dynamic tracer for Linux that
    leverages eBPF so that probes can be attached to arbitrary points in the kernel.
    Unlike `bpftrace`, which depends on BCC, `ply` does not rely on LLVM and has no
    required external dependencies aside from `libc`. This makes it much easier to
    port to embedded CPU architectures such as `arm` and `powerpc`.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 一个名为 **ply** 的软件包（[https://github.com/iovisor/ply](https://github.com/iovisor/ply)）于
    2021 年 1 月 23 日合并到 Buildroot 中，并将在 Buildroot 2021.02 LTS 版本中包含。**ply** 是一个轻量级的动态跟踪器，利用
    eBPF 使得探针可以附加到内核中的任意位置。与依赖 BCC 的 `bpftrace` 不同，`ply` 不依赖 LLVM，并且除了 `libc` 之外没有其他外部依赖。这使得它更容易移植到嵌入式
    CPU 架构，如 `arm` 和 `powerpc`。
- en: 'Let’s begin by configuring an eBPF-enabled kernel for Raspberry Pi 4:'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从为 Raspberry Pi 4 配置启用 eBPF 的内核开始：
- en: '[PRE25]'
  id: totrans-271
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'The `make linux-configure` command will download and build some host tools
    before fetching, extracting, and configuring the kernel source code. The `raspberrypi4_64_defconfig`
    from the 2024.02.6 LTS release of Buildroot points to a custom 6.1 kernel source
    tarball from the Raspberry Pi Foundation’s GitHub fork. Inspect the contents of
    your `raspberrypi4_64_defconfig` to verify what version of the kernel you are
    on. Once `make linux-configure` has configured the kernel, we can reconfigure
    it for eBPF:'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: '`make linux-configure` 命令将在获取、解压并配置内核源代码之前，下载并构建一些主机工具。来自 Buildroot 2024.02.6
    LTS 版本的 `raspberrypi4_64_defconfig` 指向了 Raspberry Pi 基金会 GitHub 分支中的自定义 6.1 内核源代码
    tarball。检查你的 `raspberrypi4_64_defconfig` 内容，以验证你使用的内核版本。一旦 `make linux-configure`
    配置了内核，我们可以重新配置它以支持 eBPF：'
- en: '[PRE26]'
  id: totrans-273
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: To search for a specific kernel configuration option from the interactive menu,
    hit */* and enter a search string. The search should return a numbered list of
    matches. Entering a given number takes you directly to that configuration option.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 要从交互式菜单中搜索特定的内核配置选项，请按 */* 并输入搜索字符串。搜索结果应返回一个匹配项的编号列表。输入某个编号即可直接跳转到该配置选项。
- en: 'At a minimum, we need to select the following to enable kernel support for
    eBPF:'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 至少需要选择以下选项，以启用内核对 eBPF 的支持：
- en: '[PRE27]'
  id: totrans-276
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'The following are intended for BCC but there is no harm in adding them:'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 以下项是为 BCC 设计的，但添加它们不会有害：
- en: '[PRE28]'
  id: totrans-278
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Add these so that users can compile and attach eBPF programs to `kprobe`, `uprobe`,
    and `tracepoint` events:'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 添加这些选项，以便用户能够编译并附加 eBPF 程序到 `kprobe`、`uprobe` 和 `tracepoint` 事件：
- en: '[PRE29]'
  id: totrans-280
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'These need to be selected for `ply` to work:'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 为了让 `ply` 正常工作，需要选择以下项：
- en: '[PRE30]'
  id: totrans-282
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Make sure to save your changes when exiting `make` `linux-menuconfig` so that
    they get applied to `output/build/linux-custom/.config` before building your eBPF-enabled
    kernel.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 在退出`make` `linux-menuconfig`时确保保存你的更改，以便它们能被应用到`output/build/linux-custom/.config`中，然后再构建你的eBPF启用内核。
- en: Building ply with Buildroot
  id: totrans-284
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用Buildroot构建ply
- en: 'Let’s build `ply` and install the tool along with some example scripts. The
    `ply` scripts are bundled together inside an `ebpf` package under the `MELD/Chapter20/`
    directory for easy installation. To copy them over to your 2024.02.06 LTS installation
    of Buildroot:'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们构建`ply`并安装该工具及一些示例脚本。`ply`脚本被打包在`MELD/Chapter20/`目录下的`ebpf`包中，便于安装。要将它们复制到你的2024.02.06
    LTS版Buildroot中：
- en: '[PRE31]'
  id: totrans-286
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Now build the `ply` image for Raspberry Pi 4:'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 现在构建适用于Raspberry Pi 4的`ply`镜像：
- en: '[PRE32]'
  id: totrans-288
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: If your version of Buildroot is 2024.02.06 LTS and you copied the `buildroot`
    overlay from `MELD/Chapter20` correctly, then the `ply` image should build successfully.
    The kernel built for this image is already configured for eBPF so there is no
    need to perform the previous `linux-menuconfig` steps. The `ply` image also automounts
    `debugfs` at `/sys/kernel/debug` so `ply` is ready to run on boot up.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你的Buildroot版本是2024.02.06 LTS，并且你正确地从`MELD/Chapter20`复制了`buildroot`叠加文件，那么`ply`镜像应该能够成功构建。为该镜像构建的内核已为eBPF配置，因此不需要执行之前的`linux-menuconfig`步骤。`ply`镜像还会在`/sys/kernel/debug`自动挂载`debugfs`，因此`ply`在启动时已经准备好运行。
- en: Insert the finished microSD into your Raspberry Pi 4, plug it into your local
    network with an Ethernet cable, and power the device up. Use `arp-scan` to locate
    your Raspberry Pi 4’s IP address and SSH into it as `root` with the password you
    set in the previous section. I used `temppwd` for the `root` password in the `configs/rpi4_64_ply_defconfig`
    that I included with my `MELD/Chapter20/buildroot` overlay. Now, we are ready
    to gain some firsthand experience in experimenting with eBPF.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 将已完成的microSD卡插入到你的Raspberry Pi 4中，使用以太网电缆将其连接到本地网络，并启动设备。使用`arp-scan`定位你的Raspberry
    Pi 4的IP地址，并使用你在上一节中设置的密码通过SSH以`root`身份登录。我在`configs/rpi4_64_ply_defconfig`中设置的`root`密码是`temppwd`，它包含在我提供的`MELD/Chapter20/buildroot`叠加文件中。现在，我们准备好亲身体验eBPF的实验了。
- en: Using ply
  id: totrans-291
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用ply
- en: 'Doing almost anything with eBPF, including running the `ply` tool and examples,
    requires `root` privileges, which is why we enabled `root` login via SSH. Another
    prerequisite is mounting `debugfs`. If there is no `debugfs` entry in your `/etc/fstab`,
    then mount `debugfs` from the command line:'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 使用eBPF几乎做任何事情，包括运行`ply`工具和示例，都需要`root`权限，这就是我们通过SSH启用了`root`登录的原因。另一个前提是挂载`debugfs`。如果你的`/etc/fstab`中没有`debugfs`条目，则需要从命令行挂载`debugfs`：
- en: '[PRE33]'
  id: totrans-293
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Let’s start by counting `syscalls` system-wide by function:'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从按功能统计系统范围内的`syscalls`开始：
- en: '[PRE34]'
  id: totrans-295
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Notice that the `ply` session terminates, and the trace results are displayed
    when the user enters *Ctrl + C*. You may need to enter *Ctrl + C* repeatedly until
    the `ply` session finally terminates.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，`ply`会话会在用户按下*Ctrl + C*时终止，并显示追踪结果。你可能需要重复按*Ctrl + C*，直到`ply`会话最终终止。
- en: 'The directory where the `ply` scripts are located is not in the `PATH` environment
    variable, so navigate there for easier execution:'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: '`ply`脚本所在的目录不在`PATH`环境变量中，因此请导航到该目录以便更轻松地执行：'
- en: '[PRE35]'
  id: totrans-298
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Let’s start with a system-wide script that displays read sizes as a histogram:'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从一个系统范围的脚本开始，该脚本显示读取大小的直方图：
- en: '[PRE36]'
  id: totrans-300
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'The `tcp-send-recv.ply` script counts TCP I/O by executable and direction:'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: '`tcp-send-recv.ply`脚本按可执行文件和方向统计TCP I/O：'
- en: '[PRE37]'
  id: totrans-302
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: In this instance, I am tracing all calls to `tcp_sendmsg` and `tcp_recvmsg`
    while I run a Redis client/server latency test. I performed the test from an SSH
    terminal so there is TCP I/O reported for `dropbear` as well. The number of samples
    displayed increased from `0` to `1033` over the course of the latency test, which
    explains the `1048` sends made by `dropbear`.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我在运行Redis客户端/服务器延迟测试时，追踪所有对`tcp_sendmsg`和`tcp_recvmsg`的调用。我是在SSH终端中进行测试的，所以也会报告`dropbear`的TCP
    I/O。显示的样本数从`0`增加到`1033`，这解释了`dropbear`发送的`1048`次。
- en: 'The `heap-allocs.ply` script displays heap allocation counts. I ran an LRU
    cache simulation of 100,000 keys on Redis:'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: '`heap-allocs.ply`脚本显示堆分配次数。我在Redis上进行了100,000个键的LRU缓存仿真：'
- en: '[PRE38]'
  id: totrans-305
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Notice that an instance of `redis-cli` with PID `215` performed `1027` heap
    allocations. This concludes our coverage of Linux event tracing tools: Ftrace,
    LTTng, and eBPF. All of them require at least some kernel configuration to work.
    Valgrind offers more profiling tools that operate entirely from the comfort of
    user space.'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，`PID` 为 `215` 的 `redis-cli` 实例进行了 `1027` 次堆内存分配。至此，我们已经介绍了 Linux 事件追踪工具：Ftrace、LTTng
    和 eBPF。它们都至少需要一些内核配置才能工作。而 Valgrind 提供了更多的分析工具，完全在用户空间中运行，使用起来更为便捷。
- en: Using Valgrind
  id: totrans-307
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Valgrind
- en: I introduced **Valgrind** in [*Chapter 18*](Chapter_18.xhtml#_idTextAnchor581)
    as a tool for identifying memory problems using the `memcheck` tool. Valgrind
    has other useful tools for application profiling. The two I am going to look at
    here are Callgrind and Helgrind. Since Valgrind works by running the code in a
    sandbox, it can check the code as it runs and report certain behaviors, which
    native tracers and profilers cannot do.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 我在 [*第18章*](Chapter_18.xhtml#_idTextAnchor581) 中介绍了 **Valgrind**，作为使用 `memcheck`
    工具识别内存问题的工具。Valgrind 还有其他用于应用程序分析的有用工具。我在这里要讨论的两个工具是 Callgrind 和 Helgrind。由于 Valgrind
    通过在沙箱中运行代码的方式工作，它可以在代码执行时检查代码并报告某些行为，而本地的追踪器和分析器无法做到这一点。
- en: Callgrind
  id: totrans-309
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Callgrind
- en: '**Callgrind** is a call graph-generating profiler that also collects information
    about processor cache hit rate and branch prediction. Callgrind is only useful
    if your bottleneck is CPU-bound. It’s not useful if heavy I/O or multiple processes
    are involved.'
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: '**Callgrind** 是一个生成调用图的分析器，它还收集有关处理器缓存命中率和分支预测的信息。如果你的瓶颈在于 CPU，Callgrind 会非常有用。如果涉及到重度
    I/O 或多个进程，Callgrind 就不太适用了。'
- en: Valgrind does not require kernel configuration, but it does need debug symbols.
    It is available as a target package in both The Yocto Project and Buildroot (`BR2_PACKAGE_VALGRIND`).
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: Valgrind 不需要内核配置，但需要调试符号。它在 The Yocto Project 和 Buildroot 中作为一个目标包提供（`BR2_PACKAGE_VALGRIND`）。
- en: 'You run Callgrind in Valgrind on the target like so:'
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在目标系统上通过 Valgrind 运行 Callgrind，命令如下：
- en: '[PRE39]'
  id: totrans-313
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: This produces a file called `callgrind.out.<PID>`, which you can copy to the
    host and analyze with `callgrind_annotate`.
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 这将生成一个名为 `callgrind.out.<PID>` 的文件，你可以将其复制到主机上，并使用 `callgrind_annotate` 进行分析。
- en: The default is to capture data for all the threads together in a single file.
    If you add the `--separate-threads=yes` option when capturing, there will be profiles
    for each of the threads in files named `callgrind.out.<PID>-<thread id>`.
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，它会将所有线程的数据捕获到一个单独的文件中。如果你在捕获时添加 `--separate-threads=yes` 选项，则每个线程都会有各自的分析文件，文件名为
    `callgrind.out.<PID>-<thread id>`。
- en: Callgrind can simulate the processor L1/L2 cache and report on cache misses.
    Capture the trace with the `--simulate-cache=yes` option. L2 misses are much more
    expensive than L1 misses, so pay attention to code with high `D2mr` or `D2mw`
    counts.
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: Callgrind 可以模拟处理器的 L1/L2 缓存，并报告缓存未命中的情况。使用 `--simulate-cache=yes` 选项来捕获跟踪数据。L2
    缓存未命中的代价要高于 L1，因此要特别注意具有高 `D2mr` 或 `D2mw` 计数的代码。
- en: The raw output from Callgrind can be overwhelming and difficult to untangle.
    A visualizer such as **KCachegrind** ([https://kcachegrind.github.io/html/Home.html](https://kcachegrind.github.io/html/Home.html))
    can help you navigate the mountains of data Callgrind collects.
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: Callgrind 的原始输出可能会非常复杂且难以整理。像 **KCachegrind** 这样的可视化工具（[https://kcachegrind.github.io/html/Home.html](https://kcachegrind.github.io/html/Home.html)）可以帮助你浏览
    Callgrind 收集的大量数据。
- en: Helgrind
  id: totrans-318
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Helgrind
- en: '**Helgrind** is a thread-error detector for detecting synchronization errors
    in C, C++, and Fortran programs that include POSIX threads.'
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: '**Helgrind** 是一个线程错误检测工具，用于检测 C、C++ 和 Fortran 程序中包含 POSIX 线程的同步错误。'
- en: Helgrind can detect three classes of errors. Firstly, it can detect the incorrect
    use of the API. Some examples are unlocking a mutex that is already unlocked,
    unlocking a mutex that was locked by a different thread, or not checking the return
    value of certain `pthread` functions. Secondly, it monitors the order in which
    threads acquire locks to detect cycles that may result in deadlocks (also known
    as the deadly embrace). Finally, it detects data races, which can happen when
    two threads access a shared memory location without using suitable locks or other
    synchronization to ensure single-threaded access.
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: Helgrind 可以检测三类错误。首先，它可以检测 API 使用不当的情况。例如，解锁已经解锁的互斥锁、解锁由不同线程锁定的互斥锁，或者没有检查某些
    `pthread` 函数的返回值。其次，它监控线程获取锁的顺序，以检测可能导致死锁（也称为致命拥抱）的循环。最后，它检测数据竞争，当两个线程在没有使用适当的锁或其他同步机制来确保单线程访问时，访问共享内存位置，就会发生数据竞争。
- en: 'Using Helgrind is simple; you just need this command:'
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 Helgrind 很简单；你只需要以下命令：
- en: '[PRE40]'
  id: totrans-322
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: It prints problems and potential problems as it finds them. You can direct these
    messages to a file by adding `--log-file=<filename>`.
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 它在找到问题和潜在问题时会打印出来。你可以通过添加`--log-file=<文件名>`将这些信息导入到文件中。
- en: Callgrind and Helgrind rely on Valgrind’s virtualization for their profiling
    and deadlock detection. This heavyweight approach slows down the execution of
    your programs, increasing the likelihood of the observer effect.
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: Callgrind和Helgrind依赖于Valgrind的虚拟化技术来进行性能分析和死锁检测。这种重量级的方法会减慢程序的执行速度，增加观察者效应的可能性。
- en: Sometimes the bugs in our programs are so reproducible and easy to isolate that
    a simpler, less invasive tool is enough to quickly debug them. That tool more
    often than not is `strace`.
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，我们程序中的bug是如此容易重现且容易隔离，以至于只需要一个简单、低侵入性的工具，就能快速调试它们。这种工具往往就是`strace`。
- en: Using strace
  id: totrans-326
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用strace
- en: 'I started the chapter with a simple and ubiquitous tool, `top`, and I will
    finish with another: **strace**. It is a very simple tracer that captures system
    calls made by a program and, optionally, its children. You can use it to do the
    following:'
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 我以一个简单且普遍使用的工具`top`开始本章，我将以另一个工具结束：**strace**。它是一个非常简单的跟踪器，捕捉程序及其子进程的系统调用。你可以用它来做以下事情：
- en: Learn which system calls a program makes.
  id: totrans-328
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 学习一个程序所执行的系统调用。
- en: Find those system calls that fail, together with the error code. I find this
    useful if a program fails to start but doesn’t print an error message or if the
    message is too general.
  id: totrans-329
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 查找那些失败的系统调用及其错误代码。如果程序启动失败，但没有打印错误信息，或者错误信息过于笼统，我发现这个功能非常有用。
- en: Find which files a program opens.
  id: totrans-330
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 查找一个程序打开了哪些文件。
- en: Find out which `syscalls` a running program is making, for example, to see whether
    it is stuck in a loop.
  id: totrans-331
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 查明一个正在运行的程序正在执行哪些`syscalls`，例如，看看它是否卡在某个循环中。
- en: There are many more examples online. Just search for `strace` tips and tricks.
    Everybody has a favorite `strace` story, for example, [https://alexbilson.dev/plants/technology/debug-a-program-with-strace/](https://alexbilson.dev/plants/technology/debug-a-program-with-strace/).
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 网上有很多更多的示例。只需搜索`strace`的技巧和窍门。每个人都有一个自己喜欢的`strace`故事，例如，[https://alexbilson.dev/plants/technology/debug-a-program-with-strace/](https://alexbilson.dev/plants/technology/debug-a-program-with-strace/)。
- en: '`strace` uses the `ptrace(2)` function to hook calls as they are made from
    user space to the kernel. If you want to know more about how `ptrace` works, the
    manual page is detailed and surprisingly readable.'
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: '`strace`使用`ptrace(2)`函数来挂钩从用户空间到内核的调用。如果你想了解更多关于`ptrace`是如何工作的，手册页非常详细且出乎意料的易懂。'
- en: 'The simplest way to get a trace is to run the command as a parameter to `strace`
    (the listing has been edited for clarity):'
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 获取trace的最简单方法是将命令作为参数传递给`strace`（为了清晰，列表已编辑）：
- en: '[PRE41]'
  id: totrans-335
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: Most of the trace shows how the runtime environment is created. In particular,
    you can see how the library loader hunts for `libc.so.6`, eventually finding it
    in `/lib`. Finally, it gets to running the `main()` function of the program, which
    prints its message and exits.
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数的trace展示了运行时环境是如何创建的。特别是，你可以看到库加载器是如何寻找`libc.so.6`的，最终在`/lib`中找到它。最后，它开始运行程序的`main()`函数，打印出消息并退出。
- en: If you want `strace` to follow any child processes or threads created by the
    original process, add the `-f` option.
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你希望`strace`跟踪原始进程创建的任何子进程或线程，可以添加`-f`选项。
- en: '**TIP**'
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: '**提示**'
- en: If you are using `strace` to trace a program that creates threads, you almost
    certainly want to use the `-f` option. Better still, use `-ff` and -`o <file name>`
    so that the output for each child process or thread is written to a separate file
    named `<filename>.<PID | TID>`.
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你使用`strace`跟踪创建线程的程序，几乎可以肯定你会想使用`-f`选项。更好的是，使用`-ff`和`-o <文件名>`，这样每个子进程或线程的输出将被写入一个单独的文件，文件名为`<filename>.<PID
    | TID>`。
- en: 'A common use of `strace` is to discover which files a program tries to open
    at startup. You can restrict the system calls that are traced through the `-e`
    option, and you can write the trace to a file instead of `stdout` using the `-o`
    option:'
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: '`strace`的一个常见用途是发现程序在启动时尝试打开的文件。你可以通过`-e`选项限制跟踪的系统调用，并且可以使用`-o`选项将跟踪结果写入文件，而不是`stdout`：'
- en: '[PRE42]'
  id: totrans-341
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: This shows the libraries and configuration files `ssh` opens when it is setting
    up a connection.
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 这展示了`ssh`在建立连接时打开的库文件和配置文件。
- en: 'You can even use `strace` as a basic profile tool. If you use the `-c` option,
    it accumulates the time spent in system calls and prints out a summary like this:'
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 你甚至可以将`strace`作为一个基本的性能分析工具。如果你使用`-c`选项，它会累计系统调用所花费的时间，并打印出如下总结：
- en: '[PRE43]'
  id: totrans-344
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: '`strace` is extremely versatile. We have only scratched the surface of what
    the tool can do.'
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: '`strace` 极其多功能。我们只是略微触及了该工具的表面。'
- en: I recommend downloading *Spying on your programs with strace*, a free zine by
    Julia Evans available at [https://wizardzines.com/zines/strace/](https://wizardzines.com/zines/strace/).
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 我推荐下载 *使用 strace 监视你的程序*，这是 Julia Evans 编写的免费杂志，网址是 [https://wizardzines.com/zines/strace/](https://wizardzines.com/zines/strace/)。
- en: Summary
  id: totrans-347
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: Nobody can complain that Linux lacks options for profiling and tracing. This
    chapter has given you an overview of some of the most common ones.
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 没有人会抱怨 Linux 在分析和跟踪方面缺乏选项。本章为您概述了一些最常见的工具。
- en: When faced with a system that is not performing as well as you would like, start
    with `top` and try to identify the problem. If it proves to be a single application,
    then you can use `perf record`/`report` to profile it. Bear in mind that you will
    have to configure the kernel to enable `perf` and you will need debug symbols
    for both the binaries and kernel. If the problem is not so well localized, use
    `perf` or `ply` to get a system-wide view.
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 当遇到一个系统性能不如预期时，从 `top` 开始并尝试识别问题。如果问题出在某个特定的应用程序，那么你可以使用 `perf record`/`report`
    对其进行分析。请记住，你需要配置内核以启用 `perf`，并且需要调试符号来支持二进制文件和内核。如果问题并不容易定位，可以使用 `perf` 或 `ply`
    来获取系统范围的视图。
- en: Ftrace comes into its own when you have specific questions about the behavior
    of the kernel. The `function` and `function_graph` tracers provide a detailed
    view of the relationship and sequence of function calls. The event tracers allow
    you to extract more information about functions, including the parameters and
    return values.
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 当你对内核的行为有具体问题时，Ftrace 显得尤为重要。`function` 和 `function_graph` 追踪器提供了函数调用关系和顺序的详细视图。事件追踪器则允许你提取更多关于函数的信息，包括参数和返回值。
- en: LTTng performs a similar role, making use of the event trace mechanism, and
    adds high-speed ring buffers to extract large quantities of data from the kernel.
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: LTTng 执行类似的功能，利用事件追踪机制，并增加高速环形缓冲区，以便从内核提取大量数据。
- en: Valgrind has the advantage of running code in a sandbox and can report on errors
    that are hard to track down in other ways. Using Callgrind, it can generate call
    graphs and report on processor cache usage, and with Helgrind, it can report on
    thread-related problems.
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: Valgrind 具有在沙箱中运行代码的优势，并且能够报告其他方式难以追踪的错误。使用 Callgrind 时，它可以生成调用图并报告处理器缓存的使用情况，而使用
    Helgrind 时，则能报告与线程相关的问题。
- en: Finally, don’t forget `strace`. It is a good standby for finding out which system
    calls a program is making, from tracking file open calls to finding file pathnames
    and checking for system wake-ups and incoming signals.
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，不要忘记`strace`。它是一个很好的备用工具，可以帮助你查明程序正在执行哪些系统调用，从跟踪文件打开调用到查找文件路径名，甚至检查系统唤醒和接收信号。
- en: All the while, be aware of, and try to avoid, the observer effect by making
    sure that your measurements are valid for a production system. In the next chapter,
    we will delve into the latency tracers that help us quantify the real-time performance
    of a target system.
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 在此期间，务必注意并尽量避免观察者效应，确保你的测量结果适用于生产系统。在下一章中，我们将深入探讨有助于量化目标系统实时性能的延迟追踪器。
- en: Further study
  id: totrans-355
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步学习
- en: '*Profiling and tracing with perf,* by Julia Evans'
  id: totrans-356
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*使用 perf 进行分析和追踪*，由 Julia Evans 编写'
- en: '*Systems Performance: Enterprise and the Cloud, Second Edition*, by Brendan
    Gregg'
  id: totrans-357
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*系统性能：企业与云计算，第2版*，由 Brendan Gregg 编写'
- en: '*BPF Performance Tools: Linux System and Application Observability*, by Brendan
    Gregg'
  id: totrans-358
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*BPF 性能工具：Linux 系统与应用程序可观察性*，由 Brendan Gregg 编写'
- en: '*ply: lightweight eBPF tracing*, by Frank Vasquez: [https://www.youtube.com/watch?v=GuEEJlU9Mr8](https://www.youtube.com/watch?v=GuEEJlU9Mr8)'
  id: totrans-359
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*ply：轻量级 eBPF 追踪*，由 Frank Vasquez 编写：[https://www.youtube.com/watch?v=GuEEJlU9Mr8](https://www.youtube.com/watch?v=GuEEJlU9Mr8)'
- en: '*Spying on your programs with strace,* by Julia Evans'
  id: totrans-360
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*使用 strace 监视你的程序*，由 Julia Evans 编写'
