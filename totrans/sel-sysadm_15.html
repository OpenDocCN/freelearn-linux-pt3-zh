<html><head></head><body><div id="sbo-rt-content" class="calibre1"><div id="_idContainer033" class="calibre2">
			<h1 id="_idParaDest-308" class="calibre5"><em class="italic"><a id="_idTextAnchor312" class="pcalibre calibre6 pcalibre1"/>Chapter 12</em>: Tuning SELinux Policies</h1>
			<p class="calibre3">Until now, we have been working with an existing SELinux policy by tuning our system to deal with the proper SELinux contexts and assigning the right labels to files, directories, and even network ports. We've learned that the behavior that SELinux enforces is defined within the policies. To fine-tune the policy enforcement rules, we have already briefly covered SELinux booleans.</p>
			<p class="calibre3">It's time we look into SELinux booleans in more detail, learning how to look up the impact booleans have. Within this chapter, we then consider SELinux policy modules themselves and what options administrators have when dealing with these modules. Finally, we will look at how to update or even replace existing policies.</p>
			<p class="calibre3">In this chapter, we're going to cover the following main topics:</p>
			<ul class="calibre8">
				<li class="calibre9">Working with SELinux booleans</li>
				<li class="calibre9">Handling policy modules</li>
				<li class="calibre9">Replacing and updating existing policies</li>
			</ul>
			<h1 id="_idParaDest-309" class="calibre5"><a id="_idTextAnchor313" class="pcalibre calibre6 pcalibre1"/>Technical requirements</h1>
			<p class="calibre3">Check out the following video to see the Code in Action: <a href="https://bit.ly/2T7MkVK" class="pcalibre calibre6 pcalibre1">https://bit.ly/2T7MkVK</a></p>
			<h1 id="_idParaDest-310" class="calibre5"><a id="_idTextAnchor314" class="pcalibre calibre6 pcalibre1"/>Working with SELinux booleans</h1>
			<p class="calibre3">One of the methods of manipulating<a id="_idIndexMarker812" class="pcalibre calibre6 pcalibre1"/> SELinux policies is by toggling SELinux booleans. Ever since <a href="B16276_02_Final_VK.xhtml#_idTextAnchor045" class="pcalibre calibre6 pcalibre1"><em class="italic">Chapter 2</em></a>, <em class="italic">Understanding SELinux Decisions and Logging</em>, where we used the <strong class="source-inline">secure_mode_policyload</strong> boolean, these tunable settings have been popping up over the course of this book. With their simple ON/OFF state, they enable or disable parts of the SELinux policy. Policy developers and administrators use SELinux booleans to toggle parts of the policy that not all deployments always need to be active, but some still do.</p>
			<p class="calibre3">These booleans are added to the policy based on feedback from, and with the help of, the community at large. By <a id="_idIndexMarker813" class="pcalibre calibre6 pcalibre1"/>establishing which policy rules are necessary against those that are optional, SELinux developers can provide an SELinux policy that works for a majority of systems, even when the uses of these systems differ.</p>
			<h2 id="_idParaDest-311" class="calibre10"><a id="_idTextAnchor315" class="pcalibre calibre6 pcalibre1"/>Listing SELinux booleans</h2>
			<p class="calibre3">An overview of SELinux booleans <a id="_idIndexMarker814" class="pcalibre calibre6 pcalibre1"/>can be obtained by using the <strong class="source-inline">semanage</strong> command with the <strong class="source-inline">boolean</strong> option. On a regular system, we can easily find over a hundred SELinux booleans, so it is necessary to filter them out for the description of the boolean we need:</p>
			<p class="source-code"># semanage boolean -l | grep policyload</p>
			<p class="source-code">secure_mode_policyload	(off, off)</p>
			<p class="source-code">  Boolean to determine whether the system permits loading</p>
			<p class="source-code">  policy, setting enforcing mode, and changing boolean values.</p>
			<p class="source-code">  Set this to true and you have to reboot to set it back.</p>
			<p class="calibre3">The output not only gives us a brief description of the boolean, but also the current value (actually, it gives us the current value and then the value pending a policy change, but this will almost always be the same).</p>
			<p class="calibre3">Another method for getting the current value of a boolean is through the <strong class="source-inline">getsebool</strong> command, as follows:</p>
			<p class="source-code"># getsebool secure_mode_policyload</p>
			<p class="source-code">secure_mode_policyload --&gt; off</p>
			<p class="calibre3">If the name of the boolean is not exactly known, we can ask for an overview of all booleans (and their values) and filter for the one we need:</p>
			<p class="source-code"># getsebool -a | grep policy</p>
			<p class="source-code">secure_mode_policyload --&gt; off</p>
			<p class="calibre3">Another utility that can be used to view SELinux boolean descriptions is the <strong class="source-inline">sepolicy booleans</strong> command:</p>
			<p class="source-code"># sepolicy booleans -b secure_mode_policyload</p>
			<p class="source-code">secure_mode_policyload=_("Boolean to ...")</p>
			<p class="calibre3">However, this command does not show the current value of the boolean.</p>
			<p class="calibre3">Finally, booleans are also represented through the <strong class="source-inline">/sys/fs/selinux</strong> filesystem:</p>
			<p class="source-code"># cat /sys/fs/selinux/booleans/secure_mode_policyload</p>
			<p class="source-code">0 0</p>
			<p class="calibre3">Here, booleans can be<a id="_idIndexMarker815" class="pcalibre calibre6 pcalibre1"/> read as if they were regular files, and they return two values:</p>
			<ul class="calibre8">
				<li class="calibre9">The first value is the current state of the boolean, where <strong class="source-inline">0</strong> means OFF and <strong class="source-inline">1</strong> means ON.</li>
				<li class="calibre9">The second value is the pending state of the boolean. </li>
			</ul>
			<p class="calibre3">A pending state allows administrators to change multiple boolean values simultaneously, but only when manipulating booleans through the <strong class="source-inline">/sys/fs/selinux</strong> filesystem, as we will see next.</p>
			<h2 id="_idParaDest-312" class="calibre10"><a id="_idTextAnchor316" class="pcalibre calibre6 pcalibre1"/>Changing boolean values</h2>
			<p class="calibre3">We can change the value of a boolean <a id="_idIndexMarker816" class="pcalibre calibre6 pcalibre1"/>using the <strong class="source-inline">setsebool</strong> command. For instance, to toggle the <strong class="source-inline">httpd_can_sendmail</strong> SELinux boolean, we can use the following command:</p>
			<p class="source-code"># setsebool httpd_can_sendmail on</p>
			<p class="calibre3">Some Linux distributions might also have the <strong class="source-inline">togglesebool</strong> command available. This command will flip the value of the boolean, so ON becomes OFF, and OFF becomes ON:</p>
			<p class="source-code"># togglesebool httpd_can_sendmail</p>
			<p class="calibre3">SELinux booleans have a default state defined by the policy administrator (and thus the default SELinux policy active on the system). Changing the value using <strong class="source-inline">setsebool</strong> updates the current active access controls, but this does not persist across reboots (if we toggle the boolean, then after rebooting, the old value will be used again).</p>
			<p class="calibre3">In order to keep the changes permanently, add the <strong class="source-inline">-P</strong> option to the <strong class="source-inline">setsebool</strong> command as follows:</p>
			<p class="source-code"># setsebool -P httpd_can_sendmail off</p>
			<p class="calibre3">In the background, the updated SELinux boolean value is included in the policy store. Then, the current policy file is rebuilt and loaded. As a result, the policy file (called <strong class="source-inline">policy.##</strong> with <strong class="source-inline">##</strong> representing an integer value) residing in <strong class="source-inline">/etc/selinux/targeted/policy</strong> will be regenerated. This regeneration takes time, which is why switching a boolean value persistently (using <strong class="source-inline">-P</strong>) takes more time to complete than when we change a value without persisting it (using <strong class="source-inline">setsebool</strong> without <strong class="source-inline">-P</strong> or <strong class="source-inline">togglesebool</strong>) to the policy store.</p>
			<p class="calibre3">Another way to change and persist<a id="_idIndexMarker817" class="pcalibre calibre6 pcalibre1"/> the boolean settings is to use the <strong class="source-inline">semanage boolean</strong> command as follows:</p>
			<p class="source-code"># semanage boolean -m --on httpd_can_sendmail</p>
			<p class="calibre3">In this case, we modify (<strong class="source-inline">-m</strong>) the boolean value and set it to ON (<strong class="source-inline">--on</strong>).</p>
			<p class="calibre3">Booleans can also be changed through their <strong class="source-inline">/sys/fs/selinux/booleans</strong> representation. When this happens, the boolean value is not immediately activated – the change of the value is pending. This allows administrators to modify multiple booleans through <strong class="source-inline">/sys/fs/selinux/booleans</strong> first:</p>
			<p class="source-code"># echo 0 &gt; /sys/fs/selinux/booleans/httpd_can_sendmail</p>
			<p class="source-code"># getsebool httpd_can_sendmail</p>
			<p class="source-code">httpd_can_sendmail --&gt; on pending: off</p>
			<p class="calibre3">To commit the changes, write the<a id="_idIndexMarker818" class="pcalibre calibre6 pcalibre1"/> value <strong class="source-inline">1</strong> into <strong class="source-inline">/sys/fs/selinux/commit_pending_bools</strong>:</p>
			<p class="source-code"># echo 1 &gt; /sys/fs/selinux/commit_pending_bools</p>
			<p class="calibre3">As long as you modify booleans through the <strong class="source-inline">semanage</strong> or <strong class="source-inline">setsebool</strong> commands though, the changes will immediately be committed. Only operations through the <strong class="source-inline">/sys/fs/selinux</strong> structure allow pending boolean changes.</p>
			<h2 id="_idParaDest-313" class="calibre10"><a id="_idTextAnchor317" class="pcalibre calibre6 pcalibre1"/>Inspecting the impact of a boolean</h2>
			<p class="calibre3">To discover which <a id="_idIndexMarker819" class="pcalibre calibre6 pcalibre1"/>policy rules a boolean manipulates, the description usually suffices. Sometimes though, we might want to know which SELinux rules change when we alter a boolean value. With the <strong class="source-inline">sesearch</strong> application, we can query the SELinux policy, displaying the rules affected by a given boolean. To show this information in detail, we use the <strong class="source-inline">-b</strong> option (for the boolean) and <strong class="source-inline">-A</strong> option (to show all <strong class="source-inline">allow</strong> rules):</p>
			<p class="source-code"># sesearch -b httpd_can_sendmail -A</p>
			<p class="source-code">allow httpd_suexec_t bin_t:dir { getattr open search }; [ httpd_can_sendmail ]:True</p>
			<p class="source-code">...</p>
			<p class="source-code">allow system_mail_t httpd_t:process sigchld; [ httpd_can_sendmail ]:True</p>
			<p class="calibre3">When we query the SELinux policy directly, conditional rules can be shown as part of the output:</p>
			<p class="source-code"># sesearch -s system_mail_t -t httpd_t -A</p>
			<p class="source-code">allow domain domain:key { link search };</p>
			<p class="source-code">allow system_mail_t httpd_t:fd use; [ httpd_can_sendmail ]:True</p>
			<p class="source-code">...</p>
			<p class="calibre3">When <strong class="source-inline">allow</strong> rules are suffixed with <a id="_idIndexMarker820" class="pcalibre calibre6 pcalibre1"/>an SELinux boolean between square brackets followed by <strong class="source-inline">:True</strong>, then these rules are only applied if the boolean is active. If the boolean is followed by <strong class="source-inline">:False</strong>, then the rule is applied if the boolean is not active.</p>
			<p class="calibre3">Not all situations can be perfectly defined by policy writers though. Sometimes we will need to create our own SELinux policy modules and load those. Let's see how we can handle SELinux policy modules specifically.</p>
			<h1 id="_idParaDest-314" class="calibre5"><a id="_idTextAnchor318" class="pcalibre calibre6 pcalibre1"/>Handling policy modules</h1>
			<p class="calibre3">When the system loads the <a id="_idIndexMarker821" class="pcalibre calibre6 pcalibre1"/>SELinux policy in memory, it uses the <strong class="source-inline">policy.##</strong> file, with <strong class="source-inline">##</strong> representing the policy version, as explained at the end of <a href="B16276_01_Final_VK.xhtml#_idTextAnchor018" class="pcalibre calibre6 pcalibre1"><em class="italic">Chapter 1</em></a>, <em class="italic">Fundamental SELinux Concepts</em>. This file, which resides in <strong class="source-inline">/etc/selinux/targeted/policy</strong>, is generated every time the policy is modified. This can be when booleans are changed (and persisted), or when SELinux policy modules are added or removed.</p>
			<h2 id="_idParaDest-315" class="calibre10"><a id="_idTextAnchor319" class="pcalibre calibre6 pcalibre1"/>Listing policy modules</h2>
			<p class="calibre3">SELinux policy modules are sets of <a id="_idIndexMarker822" class="pcalibre calibre6 pcalibre1"/>SELinux rules that can be loaded and unloaded. These modules, with <strong class="source-inline">.pp</strong> or <strong class="source-inline">.cil</strong> suffixes, can be loaded and unloaded as needed by the administrator. Once loaded, the policy module is made part of the SELinux policy store, and will be loaded even after a system reboot. Unlike SELinux boolean changes, SELinux policy module loads are always persisted.</p>
			<p class="calibre3">To list the currently loaded SELinux policy modules, we recommend using the <strong class="source-inline">semodule</strong> command. By default, <strong class="source-inline">semodule</strong> will show all loaded SELinux policy modules without any details:</p>
			<p class="source-code"># semodule -l</p>
			<p class="source-code">abrt</p>
			<p class="source-code">accountsd</p>
			<p class="source-code">...</p>
			<p class="source-code">zosremote</p>
			<p class="calibre3">SELinux policy modules can,<a id="_idIndexMarker823" class="pcalibre calibre6 pcalibre1"/> however, be loaded at a specified priority. This allows administrators to load a policy that overrules an already loaded policy: SELinux policy <a id="_idIndexMarker824" class="pcalibre calibre6 pcalibre1"/>modules with a higher <strong class="bold">policy module priority</strong> take precedence over similarly named SELinux policy modules with lower priorities. To see the current priorities, use the <strong class="source-inline">--list-modules=full</strong> argument:</p>
			<p class="source-code"># semodule --list-modules=full</p>
			<p class="source-code">100 abrt       pp</p>
			<p class="source-code">100 accountsd  pp</p>
			<p class="source-code">...</p>
			<p class="source-code">400 test       cil</p>
			<p class="source-code">...</p>
			<p class="source-code">100 zosremote  pp</p>
			<p class="calibre3">Alongside the priority, the listing also <a id="_idIndexMarker825" class="pcalibre calibre6 pcalibre1"/>shows whether the policy module is based upon the binary module format (<strong class="source-inline">pp</strong>) or the more modern <strong class="bold">Common Intermediate Language</strong> (<strong class="bold">CIL</strong>) format (<strong class="source-inline">cil</strong>).</p>
			<p class="calibre3">The SELinux utilities will copy the active policy modules into a policy-specific location. This allows administrators to list the currently active modules through regular filesystem queries as well:</p>
			<p class="source-code"># ls /var/lib/selinux/targeted/active/modules/*</p>
			<p class="source-code">/var/lib/selinux/targeted/active/modules/100:</p>
			<p class="source-code">abrt</p>
			<p class="source-code">accountsd</p>
			<p class="source-code">...</p>
			<p class="source-code">/var/lib/selinux/targeted/active/modules/400:</p>
			<p class="source-code">test</p>
			<p class="calibre3">The use of the filesystem location for querying active policies is, however, not recommended, as we<a id="_idIndexMarker826" class="pcalibre calibre6 pcalibre1"/> have no guarantee that the loaded policies match the filesystem: non-SELinux utilities can add or remove files from these locations without adjusting the SELinux policy state.</p>
			<h2 id="_idParaDest-316" class="calibre10"><a id="_idTextAnchor320" class="pcalibre calibre6 pcalibre1"/>Loading and removing policy modules</h2>
			<p class="calibre3">In the <em class="italic">Replacing and updating existing policies</em> section, we will learn how to generate new policy<a id="_idIndexMarker827" class="pcalibre calibre6 pcalibre1"/> modules. Once created, they need to be loaded and/or<a id="_idIndexMarker828" class="pcalibre calibre6 pcalibre1"/> removed. We load policy modules with <strong class="source-inline">semodule</strong> as well, regardless of the policy format (<strong class="source-inline">.pp</strong> or <strong class="source-inline">.cil</strong>):</p>
			<p class="source-code"># semodule -i screen.pp</p>
			<p class="calibre3">By default, SELinux policy modules are loaded at the <strong class="source-inline">400</strong> priority when invoked by the administrator, whereas SELinux policy modules loaded as part of the default system policy will be loaded at the <strong class="source-inline">100</strong> priority. When loading policies, the priority can be adjusted using the <strong class="source-inline">-X</strong> option. For instance, to load the <strong class="source-inline">test.cil</strong> policy with a priority of <strong class="source-inline">500</strong> we use the <strong class="source-inline">-X</strong> option as follows:</p>
			<p class="source-code"># semodule -X 500 -i test.cil</p>
			<p class="source-code">libsemanage.semanage_direct_install_info: Overriding test module at lower priority 400 with module at priority 500.</p>
			<p class="calibre3">To remove a policy module with <strong class="source-inline">semodule</strong>, use the <strong class="source-inline">--remove</strong> or <strong class="source-inline">-r</strong> option. In this case, we are not referring to an SELinux policy module <em class="italic">file</em>, but to the <em class="italic">name</em> of the module itself as displayed by <strong class="source-inline">semodule</strong>. Hence, we do not need to pass on a suffix:</p>
			<p class="source-code"># semodule -r test</p>
			<p class="calibre3">To remove an SELinux policy module from a specified priority, use the <strong class="source-inline">-X</strong> option:</p>
			<p class="source-code"># semodule -X 500 -r test</p>
			<p class="source-code">libsemanage.semanage_direct_remove_key: test module at priority 400 is now active.</p>
			<p class="calibre3">The order of the arguments is important: the <strong class="source-inline">-X</strong> option will set the priority for the actions that follow it, not those that precede it. If it is not set, then a priority value of <strong class="source-inline">400</strong> will be used.</p>
			<p class="calibre3">Finally, it is possible to keep an SELinux policy module but disable it. This keeps the module in the policy store, but disables all the SELinux policy rules inside of it. We use the <strong class="source-inline">--disable</strong> (or <strong class="source-inline">-d</strong>) option to accomplish this:</p>
			<p class="source-code"># semodule -d screen</p>
			<p class="calibre3">To re-enable the policy, use the <strong class="source-inline">--enable</strong> (or <strong class="source-inline">-e</strong>) option:</p>
			<p class="source-code"># semodule -e screen</p>
			<p class="calibre3">The disabled and enabled states of SELinux policy modules persist through reboots as well. Furthermore, if you are disabling an SELinux module, all instances of that module (including lower priority ones) will be disabled.</p>
			<p class="calibre3">Disabling policies is <a id="_idIndexMarker829" class="pcalibre calibre6 pcalibre1"/>strongly recommended when the policy module is part of the distribution's SELinux policy, as the modules themselves are not always available on<a id="_idIndexMarker830" class="pcalibre calibre6 pcalibre1"/> the system and might require a reinstallation of the policy package just to get it back.</p>
			<p class="calibre3">With loading and unloading policies explained, let's see how we can generate updates on the current SELinux policy.</p>
			<h1 id="_idParaDest-317" class="calibre5"><a id="_idTextAnchor321" class="pcalibre calibre6 pcalibre1"/>Replacing and updating existing policies</h1>
			<p class="calibre3">When we replace or<a id="_idIndexMarker831" class="pcalibre calibre6 pcalibre1"/> update existing policies, we need to load them using the <strong class="source-inline">semodule</strong> commands, as shown<a id="_idIndexMarker832" class="pcalibre calibre6 pcalibre1"/> in the <em class="italic">Handling policy modules</em> section. But how do we create or update the policies, exactly? Let's consider a few use cases where SELinux policy adjustments are triggered.</p>
			<h2 id="_idParaDest-318" class="calibre10"><a id="_idTextAnchor322" class="pcalibre calibre6 pcalibre1"/>Creating policies using audit2allow</h2>
			<p class="calibre3">When SELinux prevents <a id="_idIndexMarker833" class="pcalibre calibre6 pcalibre1"/>certain actions, we know it will log the <a id="_idIndexMarker834" class="pcalibre calibre6 pcalibre1"/>appropriate denial (assuming no <strong class="source-inline">dontaudit</strong> statements are defined) in the audit logs. This denial can be used as the source to generate a custom SELinux policy that allows the activity.</p>
			<p class="calibre3">Consider the following denial, which occurred when a confined user called <strong class="source-inline">su</strong> to switch to the root user:</p>
			<p class="source-code">type=AVC msg=audit(...): avc: denied { write } for pid=58002 comm="su" name="btmp" dev="vda1" ino=4213650 scontext=staff_u:staff_r:staff_t:s0 tcontext=system_u:object_r:faillog_t:s0 tclass=file permissive=0</p>
			<p class="calibre3">If we are certain that these operations need to be granted, then we can use the <strong class="source-inline">audit2allow</strong> command to generate a policy module for us that allows these activities. The <strong class="bold">audit2allow</strong> application transforms<a id="_idIndexMarker835" class="pcalibre calibre6 pcalibre1"/> a denial (or set of denials) into SELinux <strong class="source-inline">allow</strong> rules. These<a id="_idIndexMarker836" class="pcalibre calibre6 pcalibre1"/> rules can then be saved in a file, ready to be <a id="_idIndexMarker837" class="pcalibre calibre6 pcalibre1"/>built into an SELinux policy module, which can then be loaded.</p>
			<p class="calibre3">To generate SELinux policy <strong class="source-inline">allow</strong> rules, pipe the denials through the <strong class="source-inline">audit2allow</strong> application:</p>
			<p class="source-code"># grep btmp /var/log/audit/audit.log | audit2allow</p>
			<p class="source-code">#============ staff_t ============</p>
			<p class="source-code">allow staff_t faillog_t:file write;</p>
			<p class="calibre3">Based on the denials, <strong class="source-inline">audit2allow</strong> prepared an <strong class="source-inline">allow</strong> rule. We can also ask <strong class="source-inline">audit2allow</strong> to immediately create an SELinux policy module:</p>
			<p class="source-code"># grep btmp /var/log/audit/audit.log | audit2allow -M localpolicy</p>
			<p class="source-code">************ IMPORTANT ************</p>
			<p class="source-code">To make this policy package active, execute:</p>
			<p class="source-code">semodule -i localpolicy.pp</p>
			<p class="calibre3">A file called <strong class="source-inline">localpolicy.pp</strong> will be available in the current directory, which we can load using the <strong class="source-inline">semodule</strong> command. The source file will also be present, named <strong class="source-inline">localpolicy.te</strong>.</p>
			<p class="calibre3">If the denials that occurred are considered cosmetic in nature (meaning that the system functions as expected and the denials should not cause any updates on the policy), you can use <strong class="source-inline">audit2allow</strong> to generate <strong class="source-inline">dontaudit</strong> rules rather than <strong class="source-inline">allow</strong> rules. In that case, the denials will no longer be visible in the audit logs, while still preventing the actions from taking place:</p>
			<p class="source-code"># grep btmp /var/log/audit/audit.log | audit2allow -D -M localpolicy</p>
			<p class="calibre3">It is likely, after including the necessary rules, that the action will result in more denials that were not previously triggered. As long as the previous AVC denials are still available in the audit logs, it is sufficient to regenerate the policy and continue. After all, <strong class="source-inline">audit2allow</strong> will consider all AVC denials that it encountered, regardless of the current SELinux policy state.</p>
			<p class="calibre3">Another popular<a id="_idIndexMarker838" class="pcalibre calibre6 pcalibre1"/> approach is to put the system (or the application domain) in permissive mode to generate and fill up the audit logs with all the AVC denials related to the action. Although this generates more AVC denials to work with, it could also result in wrong decisions by the <strong class="source-inline">audit2allow</strong> command. Hence, always <a id="_idIndexMarker839" class="pcalibre calibre6 pcalibre1"/>verify the denials before generating new policy constructs, and review the generated policy to make sure that it will enforce the right set of access controls and not grant more privileges than needed.</p>
			<p class="calibre3">When the previous AVC denials are no longer available inside the audit log, a new policy module will need to be generated, as otherwise the previously fixed accesses will be denied again: the newly generated policy will no longer contain the <strong class="source-inline">allow</strong> rules from before, and when we load the new policy, the old policy is no longer active.</p>
			<h2 id="_idParaDest-319" class="calibre10"><a id="_idTextAnchor323" class="pcalibre calibre6 pcalibre1"/>Using sensible module names</h2>
			<p class="calibre3">In the previous section, we<a id="_idIndexMarker840" class="pcalibre calibre6 pcalibre1"/> used the <strong class="source-inline">audit2allow</strong> command to generate a policy module named <strong class="source-inline">localpolicy</strong>. However, this name does not reveal what the purpose of the module is.</p>
			<p class="calibre3">Once we create a (binary) policy (such as the <strong class="source-inline">localpolicy.pp</strong> file) and load it, it is not always clear to the administrators and users at first glance what this module is meant to accomplish. Although it is possible to unpack the <strong class="source-inline">.pp</strong> file (using <strong class="source-inline">semodule_unpackage</strong>) and then disassemble the resulting <strong class="source-inline">.mod</strong> file into a <strong class="source-inline">.te</strong> file, it requires software not available on most distributions (the <strong class="source-inline">dismod</strong> application, for instance, part of the <strong class="source-inline">checkpolicy</strong> software, is often not included). Considering that we just want to get insights into the rules that are part of a module, this is a very elaborate and time-intensive approach.</p>
			<p class="calibre3">The content of a module can also be somewhat deduced from its CIL code. For instance, an active <strong class="source-inline">screen</strong> module will have its code available at <strong class="source-inline">/var/lib/selinux/targeted/active/modules/100/screen</strong>, in a file called <strong class="source-inline">cil</strong>. On some distributions, this file will be a compressed file, so you might need to unzip it before viewing:</p>
			<p class="source-code"># file screen/cil</p>
			<p class="source-code">cil: bzip2 compressed data, block size = 500k</p>
			<p class="source-code"># bzcat screen/cil</p>
			<p class="source-code">(typealias secadm_screen_home_t</p>
			<p class="source-code">...</p>
			<p class="calibre3">Still, having to dive into the rules to know what <strong class="source-inline">localpolicy</strong> is about is not only very cumbersome, but also requires sufficient privileges to be able to read these files.</p>
			<p class="calibre3">Instead, it is a best practice to name the generated modules for their intended purposes. An SELinux policy that fixes a few AVC denials that come up when <strong class="source-inline">su</strong> executes from within the <strong class="source-inline">staff_t</strong> domain would be best named <strong class="source-inline">custom_staff_su_faillog</strong>, for instance.</p>
			<p class="calibre3">It is also recommended to<a id="_idIndexMarker841" class="pcalibre calibre6 pcalibre1"/> prefix (or suffix) the custom policies, so they can be more easily found:</p>
			<p class="source-code"># semodule -l | grep ^custom_</p>
			<p class="source-code">custom_staff_su_faillog</p>
			<p class="calibre3">This identifies that the policy module has been added by the administrator (or organization) and is not sourced from the default Linux distribution's policy.</p>
			<h2 id="_idParaDest-320" class="calibre10"><a id="_idTextAnchor324" class="pcalibre calibre6 pcalibre1"/>Generating reference policy style modules with audit2allow</h2>
			<p class="calibre3">The reference policy project<a id="_idIndexMarker842" class="pcalibre calibre6 pcalibre1"/> provides distributions and<a id="_idIndexMarker843" class="pcalibre calibre6 pcalibre1"/> policy writers with a set of functions that simplify the development of SELinux policies. As an example, let's see<a id="_idIndexMarker844" class="pcalibre calibre6 pcalibre1"/> what the reference policy functions (called <strong class="bold">macros</strong>) can do with the <strong class="source-inline">su</strong> situation:</p>
			<p class="source-code"># grep btmp /var/log/audit/audit.log | audit2allow -R</p>
			<p class="source-code">require {</p>
			<p class="source-code">  type staff_t;</p>
			<p class="source-code">}</p>
			<p class="source-code">#============ staff_t ============</p>
			<p class="source-code">auth_rw_faillog(staff_t)</p>
			<p class="calibre3">The rule in the example is <strong class="source-inline">auth_rw_faillog(staff_t)</strong>. This is a reference policy macro that explains an SELinux rule (or set of rules) in a more human-readable way. In this case, it allows the <strong class="source-inline">staff_t</strong> domain to read/write on <strong class="source-inline">faillog_t</strong> labeled resources. The <strong class="source-inline">faillog_t</strong> type is part of the system authentication SELinux policy (as suggested by the <strong class="source-inline">auth_</strong> prefix, which identifies the source SELinux policy module).</p>
			<p class="callout-heading">Important note</p>
			<p class="callout">As <strong class="source-inline">audit2allow -R</strong> uses an automated approach for finding potential functions, we need to review the results carefully. Sometimes it selects a method that creates far more privileges for a domain than needed.</p>
			<p class="calibre3">All major <a id="_idIndexMarker845" class="pcalibre calibre6 pcalibre1"/>distributions base their SELinux policies upon the macros and content provided by the reference policy. The list of methods we can call while building SELinux policies is available on the local<a id="_idIndexMarker846" class="pcalibre calibre6 pcalibre1"/> filesystem, at <strong class="source-inline">/usr/share/doc/selinux-policy/html</strong>.</p>
			<p class="calibre3">These named methods bundle a set of rules related to the functionality that SELinux policy administrators want to enable. For instance, the <strong class="source-inline">storage_read_tape()</strong> method allows us to enhance an SELinux policy, providing a given domain with read access to tape storage devices.</p>
			<h2 id="_idParaDest-321" class="calibre10"><a id="_idTextAnchor325" class="pcalibre calibre6 pcalibre1"/>Building reference policy - style modules</h2>
			<p class="calibre3">If we generate an SELinux <a id="_idIndexMarker847" class="pcalibre calibre6 pcalibre1"/>policy using reference policy macros but do not have access to the binary policy module anymore, then we need to build the policy before loading it. CIL-based policies can be loaded directly, which is why this book uses CIL as much as possible. However, given the wide use of the reference policy, knowing how to build these modules is important as well.</p>
			<p class="calibre3">Suppose that the <em class="italic">reference policy</em>-based SELinux policy code resides in a file called <strong class="source-inline">custom_staff_su_faillog.te</strong>, then we can build it into a <strong class="source-inline">.pp</strong> file as follows:</p>
			<p class="source-code"># make -f /usr/share/selinux/devel/Makefile custom_staff_su_faillog.pp</p>
			<p class="source-code">Compiling targeted custom_staff_su_faillog.pp policy package</p>
			<p class="source-code">rm tmp/custom_staff_su_faillog.mod tmp/custom_staff_su_faillog.mod.fc</p>
			<p class="calibre3">Once built, we can load it using <strong class="source-inline">semodule</strong>. Every time we change the policy code (in the <strong class="source-inline">.te</strong> file) or other policy information (such as file context definitions in the <strong class="source-inline">.fc</strong> file), we need to rebuild the <strong class="source-inline">.pp</strong> file before <a id="_idIndexMarker848" class="pcalibre calibre6 pcalibre1"/>we can load it.</p>
			<h2 id="_idParaDest-322" class="calibre10"><a id="_idTextAnchor326" class="pcalibre calibre6 pcalibre1"/>Building legacy-style modules</h2>
			<p class="calibre3">If we ask <strong class="source-inline">audit2allow</strong> to generate the <a id="_idIndexMarker849" class="pcalibre calibre6 pcalibre1"/>policy rules without using reference policy style macros (which we call a <em class="italic">legacy-style</em> SELinux policy), then building the <strong class="source-inline">.pp</strong> file from it requires a different approach.</p>
			<p class="calibre3">Suppose we have the <strong class="source-inline">.te</strong> file as generated by <strong class="source-inline">audit2allow -M</strong>, but not the <strong class="source-inline">.pp</strong> file, then we can generate it as follows:</p>
			<ol class="calibre18">
				<li class="calibre9">First, create the <strong class="source-inline">.mod</strong> file using <strong class="source-inline">checkmodule</strong>:<p class="source-code"><strong class="bold"># checkmodule -M -m -o custom_nonrefpol.mod \</strong></p><p class="source-code"><strong class="bold">  custom_nonrefpol.te</strong></p></li>
				<li class="calibre9">Next, generate the <strong class="source-inline">.pp</strong> file using <strong class="source-inline">semodule_package</strong>:<p class="source-code"><strong class="bold"># semodule_package -o custom_nonrefpol.pp \</strong></p><p class="source-code"><strong class="bold">  -m custom_nonrefpol.mod</strong></p><p class="calibre3">If an <strong class="source-inline">.fc</strong> file (which contains file context definitions) is present, use the <strong class="source-inline">-f</strong> option:</p><p class="source-code"><strong class="bold"># semodule_package -o custom_nonrefpol.pp \</strong></p><p class="source-code"><strong class="bold">  -m custom_nonrefpol.mod -f custom_nonrefpol.fc</strong></p></li>
			</ol>
			<p class="calibre3">The <strong class="source-inline">audit2allow</strong> command will automatically execute these commands, so this is only needed if the <strong class="source-inline">.pp</strong> file is no longer present, or when these more legacy-style SELinux policies are shared with you and you need to build and load them manually.</p>
			<h2 id="_idParaDest-323" class="calibre10"><a id="_idTextAnchor327" class="pcalibre calibre6 pcalibre1"/>Replacing the default distribution policy</h2>
			<p class="calibre3">When adding custom<a id="_idIndexMarker850" class="pcalibre calibre6 pcalibre1"/> SELinux policies, all that users can do is to add more <strong class="source-inline">allow</strong> rules. SELinux does not have a deny rule that can be used to remove currently allowed access rules from the active policy.</p>
			<p class="calibre3">If the current policy is too permissive for the administrator's liking, then the administrator will need to update the policy rather than just enhance it. That implies that the administrator has access to the current SELinux policy rules in use.</p>
			<p class="calibre3">To replace an active SELinux policy, most Linux distributions allow you to get the source code of the policy. For instance, for RPM-based Linux distributions, the source RPM of the SELinux policy package can be downloaded and unpacked to gain access to the policy as follows:</p>
			<ol class="calibre18">
				<li value="1" class="calibre9">First, find out what the current version of the SELinux policy is:<p class="source-code"><strong class="bold">$ rpm -qi selinux-policy</strong></p><p class="source-code"><strong class="bold">Name		: selinux-policy</strong></p><p class="source-code"><strong class="bold">Version	: 3.14.3</strong></p><p class="source-code"><strong class="bold">...</strong></p><p class="source-code"><strong class="bold">Source RPM	: selinux-policy-3.14.3-20.el8.src.rpm</strong></p><p class="source-code"><strong class="bold">...</strong></p></li>
				<li class="calibre9">Next, try to obtain the source RPM shown in the output. Source RPMs can also be downloaded from third-party repositories. If the package is difficult to find, you can try to find it through <a href="https://rpmfind.net" class="pcalibre calibre6 pcalibre1">https://rpmfind.net</a>.</li>
				<li class="calibre9">Next, use the <strong class="source-inline">rpmbuild</strong> utility to extract the source RPM:<p class="source-code"><strong class="bold">$ rpmbuild --rebuild --nobuild \</strong></p><p class="source-code"><strong class="bold">  selinux-policy-3.14.3-20.el8.src.rpm</strong></p><p class="calibre3">This will unpack the source RPM in the <strong class="source-inline">~/rpmbuild</strong> directory.</p></li>
				<li class="calibre9">When finished, the SELinux policy source code can be found inside <strong class="source-inline">~/rpmbuild/SOURCES</strong> and is probably named <strong class="source-inline">selinux-policy-9c02e99.tar.gz</strong> or similar, which you can extract further:<p class="source-code"><strong class="bold">$ tar xvf selinux-policy-9c92e99.tar.gz</strong></p><p class="source-code"><strong class="bold">$ tar xvf selinux-policy-contrib-c8ebb9f.tar.gz</strong></p><p class="calibre3">The SELinux policy can then be found in the created subdirectories. For instance, the <strong class="source-inline">screen.te</strong> file can be found in the <strong class="source-inline">./selinux-policy-contrib-c8ebb*/policy/modules/contrib</strong> subdirectory.</p></li>
			</ol>
			<p class="calibre3">The policy files can now be safely copied over, manipulated at will, and built to replace the existing policy. If we load the updated SELinux policy module with the same (or higher) priority as the already loaded policy, it will take precedence in the policy.</p>
			<p class="calibre3">Most distributions will <a id="_idIndexMarker851" class="pcalibre calibre6 pcalibre1"/>also have their active SELinux policy available through an online source-controlled repository. For instance, the current SELinux policy for <a id="_idIndexMarker852" class="pcalibre calibre6 pcalibre1"/>CentOS is available at <a href="https://github.com/fedora-selinux/selinux-policy" class="pcalibre calibre6 pcalibre1">https://github.com/fedora-selinux/selinux-policy</a>.</p>
			<h1 id="_idParaDest-324" class="calibre5"><a id="_idTextAnchor328" class="pcalibre calibre6 pcalibre1"/>Summary</h1>
			<p class="calibre3">The SELinux policy can be adjusted by administrators, either through SELinux booleans as provided by the SELinux policy itself, or by loading new SELinux policy modules. These modules can be generated automatically, or built manually by the policy developers.</p>
			<p class="calibre3">In this chapter, we've learned how to use SELinux booleans and how to query the active policy for the effects that the booleans will have on the system. We then learned how to use <strong class="source-inline">semodule</strong> to load and unload policies, or enable/disable modules on the system. We ended the chapter with information on how to generate and replace policies.</p>
			<p class="calibre3">In the next chapter, we will extend our query of the SELinux policy beyond just booleans, and learn how to analyze policy behavior in detail using specialized tools.</p>
			<h1 id="_idParaDest-325" class="calibre5"><a id="_idTextAnchor329" class="pcalibre calibre6 pcalibre1"/>Questions</h1>
			<ol class="calibre18">
				<li value="1" class="calibre9">How can we mark a boolean change as pending but not commit it yet?</li>
				<li class="calibre9">Which command can be used to query the impact of a boolean?</li>
				<li class="calibre9">Why can SELinux policy modules be loaded with different priorities?</li>
				<li class="calibre9">How can denials be transformed into new SELinux policy modules?</li>
			</ol>
		</div>
	</div></body></html>