- en: '16'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Working with PowerShell and .NET
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Here we are then, the last chapter. We’re going to look at the product that
    PowerShell 7 is built on, .NET, and how we can use it to expand the range of things
    we can do in PowerShell. Note that this chapter can’t be anything more than a
    whistlestop tour; .NET is a huge subject, and there are many, many more books
    written for it than there are for PowerShell. PowerShell is just one application
    written on .NET, and it only touches a subset of the things that we can do with
    .NET. That being said, let’s have a look at how it works and some of the exciting
    things we can use it for.
  prefs: []
  type: TYPE_NORMAL
- en: 'The main topics we will cover in this chapter are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Exploring .NET
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The components of .NET
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Working with .NET in PowerShell
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using .NET
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Exploring .NET
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**.NET** (**dot-net**) is a software framework. It’s free and open source and
    can be used to write web applications, command-line applications, and applications
    that run in a **Graphical User Interface** (**GUI**). It is based on the proprietary
    coded .NET Framework, which is the software framework that the Windows operating
    system uses. It can be used with a range of programming languages, including C#,
    F#, and Visual Basic .NET. Let’s unpack all that, shall we?'
  prefs: []
  type: TYPE_NORMAL
- en: Software frameworks explained
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A software framework is a tool for constructing applications. Some frameworks
    are written for specific purposes and specific languages; AngularJS is a framework
    for developing the frontends of web applications in JavaScript. PhaserJS is a
    game development framework, again for JavaScript. While frameworks contain many
    libraries, they differ from libraries in that libraries provide tools for our
    code that we can use in any way we like; with a framework, we need to work within
    the structure. The basics of an application are provided; we need to provide the
    specifics.
  prefs: []
  type: TYPE_NORMAL
- en: .NET implements a **Common Language Infrastructure** (**CLI**) that allows different
    high-level languages (such as C#) to be used on multiple operating system platforms,
    without needing to be rewritten for each architecture; this is how PowerShell
    7 can work on Intel and ARM processors. By installing the correct version of .NET,
    our PowerShell code can then run anywhere.
  prefs: []
  type: TYPE_NORMAL
- en: A .NET component called **CoreFX** houses the .NET libraries of classes, interfaces,
    and value types in a **Framework Class Library**. .NET provides more than just
    libraries, though. .NET applications run in a virtual machine called **CoreCLR**,
    in the same way that Java applications run inside the Java Virtual Machine.
  prefs: []
  type: TYPE_NORMAL
- en: Common language infrastructure
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The CLI is an open technical standard developed by Microsoft and is largely
    only found in variations of .NET, although there is an open development platform
    called **Mono** that uses it as well. The CLI specifies five things:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Common Type System (CTS)** – the set of types that can be accessed by programming
    languages using the framework.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Metadata**, which is used to describe the program structure.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Common Language Specification (CLS)** – rules for using the framework.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Virtual Execution System (VES)** – this loads and executes applications.
    It uses metadata to run code generated in compliant languages at runtime, compiling
    them into a platform-agnostic **Common Intermediate Language** (**CIL**), which
    is then compiled to a platform-specific machine language in real time. In .NET,
    the VES is implemented in the CoreCLR component.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Standard libraries**, which provide common functions, such as accessing networks
    and files.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let’s look at the CoreCLR component.
  prefs: []
  type: TYPE_NORMAL
- en: Common language runtime – CoreCLR
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: CoreCLR provides a common language runtime, which is a layer that sits between
    the application and the operating system. It is similar in principle to the PowerShell
    program; .NET applications need .NET to be running on the machine to interpret
    the application code as machine code. This means PowerShell needs .NET to be running,
    as PowerShell is a .NET application.
  prefs: []
  type: TYPE_NORMAL
- en: However, CoreCLR doesn’t just provide a runtime. It also includes additional
    services such as memory management (allocating portions of virtual memory to applications),
    garbage collection (recovering unused memory that is no longer needed), and thread
    management. This means that when we use .NET to write applications, we don’t need
    to worry about memory leaks or memory addressing errors, as all that is handled
    for us by CoreCLR.
  prefs: []
  type: TYPE_NORMAL
- en: Happily, we don’t need to know much about how CoreCLR works to use .NET with
    PowerShell. Most of what we are interested in is held in the libraries – CoreFX.
  prefs: []
  type: TYPE_NORMAL
- en: Framework Class Library – CoreFX
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'CoreFX contains the class libraries that .NET uses, which include types, functions,
    and classes. All the PowerShell data types, for instance, are a subset of the
    available .NET types. We’ve seen this already; in [*Chapter 4*](B17600_04.xhtml#_idTextAnchor071),
    *PowerShell Variables and Data Structures*, we saw that changing the contents
    of a PowerShell array was resource-intensive because each time we change an array,
    we create a new one and delete the old one. We saw that one of the solutions to
    this was to use a .NET type that is not available natively inside PowerShell,
    `ArrayList`, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: We use the `[System.Collections.ArrayList]` full .NET type to set the array
    as `ArrayList`. Sometimes, working with .NET really is that easy.
  prefs: []
  type: TYPE_NORMAL
- en: .NET history
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: .NET Framework was first released in 2002 and was intended to create Windows
    applications. It introduced the Microsoft concept of **managed code**, code that
    would only interact with the CLI. Managed code could be more tightly controlled,
    both in terms of resource use and security, and it was also less prone to causing
    system crashes – the dreaded Blue Screen of Death – because it only touched the
    CLR, not the underlying operating system. In time, many of Microsoft’s most popular
    applications, such as Microsoft Exchange Server, were written in managed code
    and required .NET Framework to run. .NET Framework will only run on Windows and
    contains many Windows-specific features.
  prefs: []
  type: TYPE_NORMAL
- en: In 2014, Microsoft released .NET Core, an open source, cross-platform implementation
    of the CLI. This shared many features of .NET Framework but not all of them, and
    similarly, it contained many features that were not implemented in .NET Framework,
    notably the ability to run on different operating systems. In 2022, Microsoft
    released a new version of .NET Core, simply called .NET 5; the intention was that
    .NET would eventually overtake .NET Framework. As happened with PowerShell and
    Windows PowerShell, in practice, both versions now exist side by side. The latest
    release of .NET Framework, at the time of writing, is version 4.8.1 in August
    2022, whereas .NET is released annually, around November; the latest version is
    .NET 8.0, released in November 2023.
  prefs: []
  type: TYPE_NORMAL
- en: So, what can we use .NET for? Let’s take a look.
  prefs: []
  type: TYPE_NORMAL
- en: The uses of .NET
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: .NET Framework was developed to create Windows applications – while we can use
    it for command-line programs, it includes the **Windows Presentation Foundation**
    (**WPF**) framework, ASP.NET (for internet applications), and Windows Forms for
    graphical applications.
  prefs: []
  type: TYPE_NORMAL
- en: The current iteration of .NET includes libraries for cloud-native applications
    and serverless functions on Azure, cross-platform desktop applications and games,
    mobile apps using .NET **Multi Application User Interface** (**MAUI**), machine
    learning applications with ML.NET, and Internet of Things applications with .NET
    IoT.
  prefs: []
  type: TYPE_NORMAL
- en: The most mature libraries, however, are for Windows, and they include libraries
    for Windows Desktop apps with WPF, Windows Forms, and the **Universal Windows
    Platform** (**UWP**) and Windows services libraries that allow us to run applications
    as services.
  prefs: []
  type: TYPE_NORMAL
- en: It would be easy to write a whole series of books on .NET, and many people have.
    However, we are mostly interested in how we can use .NET with PowerShell. We are
    going to focus on the .NET libraries and how we can access their contents from
    PowerShell, accessing in turn the APIs we wish to work with. Let’s start by looking
    at the structure of the .NET libraries.
  prefs: []
  type: TYPE_NORMAL
- en: The components of .NET
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Before we can start using the .NET libraries, we need to understand how they
    are structured. **Members** (properties, methods, etc.) are contained inside **types**,
    which in turn are contained in **namespaces**. This is **logical type containment**.
    There is also **physical type containment**. These logical structures are physically
    held in **assemblies**. We’ve already seen many of these components in PowerShell.
    Let’s start with assemblies.
  prefs: []
  type: TYPE_NORMAL
- en: Assemblies
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Assemblies are collections of types and the resources needed to support them.
    They can be either **static**, loaded from a file, or **dynamic**, existing solely
    in memory. PowerShell will load a number of default assemblies at startup, and
    then, as we import modules, that list will expand. We can see the list of assemblies
    we have loaded with the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'That will output a table like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 16.1 – Enumerating assemblies](img/B17600_16_1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 16.1 – Enumerating assemblies
  prefs: []
  type: TYPE_NORMAL
- en: We can see the version and the location of the files that these static assemblies
    are stored in. There is another column, `GAC`, which refers to the `False`. We
    can use assemblies that are usually stored in the GAC by installing them with
    NuGet, the .NET package manager; we just can’t access them from the GAC. We can
    also see that the assemblies are `.dll` files, which we talked about when discussing
    binary modules in [*Chapter 11*](B17600_11.xhtml#_idTextAnchor218), *Creating
    Our First Module*, and we also saw that binary modules are a type of .NET assembly.
    We can think of loading .NET assemblies as similar to loading binary modules.
    PowerShell loads a set of default assemblies when it starts, and these assemblies
    define the types that are available to us. To access other types, we need to load
    further assemblies.
  prefs: []
  type: TYPE_NORMAL
- en: Types
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We first encountered types in [*Chapter 4*](B17600_04.xhtml#_idTextAnchor071),
    *PowerShell Variables and Data Structures*. The PowerShell types are a subset
    of the types found in .NET. We used a .NET type earlier in the chapter when we
    created an `ArrayList` object. Types are enclosed in square brackets.
  prefs: []
  type: TYPE_NORMAL
- en: Type versus class
  prefs: []
  type: TYPE_NORMAL
- en: In type theory, a type is an abstract concept, whereas a class is a set of instructions
    to create an object of a given type. An object is of a certain type – for example,
    a string or an imaginary bike. A class is an implementation of the type. An object
    is an instance of the class. For instance, we could have multiple different classes
    of an imaginary bike that would all be of type `Imaginary.Bike`, but they could
    all have different features – for example, ape hanger handlebars or drop handlebars.
    We could then create many instances of each class (i.e., objects) – in this case,
    imaginary bikes.
  prefs: []
  type: TYPE_NORMAL
- en: In practice, classes are user-defined in PowerShell, whereas types are provided
    by .NET – except, of course, where that isn’t true.
  prefs: []
  type: TYPE_NORMAL
- en: Enumerations
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'An enumeration is a list of constant values. While we haven’t discussed them
    before, we have certainly used them. In [*Chapter 10*](B17600_10.xhtml#_idTextAnchor201),
    *Error Handling – Oh No! It’s Gone Wrong!*, we saw the `$ErrorActionPreference`
    automatic variable and how, by changing the value of the variable, we could control
    how PowerShell handles errors temporarily. We can check the type of the `$ErrorActionPreference`
    variable by calling the variable `GetType()` method, and we can see that it is
    a `System.Enum` type in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 16.2 – How can I set thee? Let me count the ways](img/B17600_16_2.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 16.2 – How can I set thee? Let me count the ways
  prefs: []
  type: TYPE_NORMAL
- en: We can list out the list of possible values with the `GetEnumValues()` method,
    and we can see the familiar list of possible values. `$ErrorActionPreference`
    can only have those values, and we can’t change them.
  prefs: []
  type: TYPE_NORMAL
- en: Classes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A class is a logical definition of an object that defines the properties and
    methods of the object – a recipe. It is an implementation of a type. Back in [*Chapter
    4*](B17600_04.xhtml#_idTextAnchor071), *PowerShell Variables and Data Structures*,
    we created three objects of type `Imaginary.Bike`, by creating the objects and
    their properties and labeling them as `Imaginary.Bike`. We could also have defined
    a class of objects called `Imaginary.Bike` with the same properties and methods,
    using a **constructor** to create actual instances of the class. We use classes
    when we want to be able to create objects easily and repeatably.
  prefs: []
  type: TYPE_NORMAL
- en: Namespaces
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Namespaces are analogous to folders in a filesystem; we saw namespaces used
    in this context in [*Chapter 13*](B17600_13.xhtml#_idTextAnchor267), *Working
    With PowerShell 7 and Windows*, when we discussed CIM classes. Most PowerShell
    types and functions are found in the `System.Management.Automation` namespace.
    When we interact with the filesystem, we use the `System.IO` namespace. We don’t
    need to write `System` when we refer to a namespace in PowerShell, as the `System`
    namespace is automatically searched; `Management.Automation` is functionally the
    same as `System.Management.Automation`. Unfortunately, we need to specify the
    namespace of any type that isn’t immediately in the `System` namespace, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 16.3 – Accessing namespaces](img/B17600_16_3.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 16.3 – Accessing namespaces
  prefs: []
  type: TYPE_NORMAL
- en: The `Path` type defines the file path of an object and is in the `System.IO`
    namespace. If we try to reference it without specifying the namespace in line
    1, we get an error. In line 2, we specify the full namespace, but in line 3, we
    can see that we don’t need to specify the `System` portion of the namespace, as
    it is implied.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can also use the `using` keyword to load the namespace, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'After running this, we can call the `Path` type without specifying the namespace,
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 16.4 – The using keyword in action](img/B17600_16_4.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 16.4 – The using keyword in action
  prefs: []
  type: TYPE_NORMAL
- en: We saw the `using` keyword in [*Chapter 11*](B17600_11.xhtml#_idTextAnchor218),
    *Creating Our First Module*, where we learned it was the recommended way of loading
    modules inside a script. As we can see, we can also use it to load namespaces
    and assemblies. Unfortunately, in the console, only the most recent `using` statement
    is applied, so if we access another namespace with it in the current session,
    we will lose access to the `System.IO` namespace. Scripts allow multiple `using`
    statements, written at the start of the script; they can only be preceded by comments.
    We can load multiple namespaces in the console by using semicolons (`;`) to separate
    the `using` statements.
  prefs: []
  type: TYPE_NORMAL
- en: Members
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Types and classes have members; throughout the book, we have used the `Get-Member`
    command to examine the properties and methods available on objects, and we’ve
    seen that objects are instances of a specific type. .NET types have a member we
    have not seen before, the constructor. Constructors provide ways of instantiating
    objects of the given class and take the same name as the class. They don’t appear
    when we run `Get-Member` against the class and can’t be directly called. Constructors
    may have parameters that we can use to populate the data members of the new object,
    or they may not; the object is created with a set of null value properties. Constructors
    may have overloads, where different sets of arguments can be passed when constructing
    the object. Most .NET classes have an automatic constructor called `new()`, which
    is a static method added by PowerShell.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s look at an example. The `[string]` type is immutable; when we change
    a string, we destroy the old string and create a new one. If we need the string
    to change frequently, this can cause a performance problem, much the same as the
    issue we have seen with arrays. There is a class in .NET that defines mutable
    strings that get around this problem; it’s called the `StringBuilder` class, and
    objects of this class are of type `System.Text.Stringbuilder`. If we create a
    new `StringBuilder` object with the default automatic constructor, we get an object
    with three properties, `Capacity`, `MaxCapacity`, and `Length`, in characters.
    If we call the `new()` method without the brackets, then we can see a list of
    the possible overloads:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 16.5 – The overloads of the StringBuilder class](img/B17600_16_5.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 16.5 – The overloads of the StringBuilder class
  prefs: []
  type: TYPE_NORMAL
- en: 'As we can see, we can pass different combinations of arguments to the `new()`
    method to construct `StringBuilder` objects with different properties. Let’s try
    it. Type the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Now, if we call `$string1` and `$string2`, we can see that `$string1` is empty
    and has a capacity of 32\. `$string2` has a length of 2 and a capacity of 16\.
    That’s because we called the overload `new(int capacity)` for `$string1` and the
    overload `new(string value)` for `$string2`.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can use the `ToString()` method to see the contents, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: '`$string1` is empty, and `$string2` contains the `''32''` string. If we use
    the `GetType()` method, we can see that both are `StringBuilder` objects. If we
    pipe them to the `Get-Member` cmdlet, we can also see that the `new()` method
    isn’t listed because it’s a constructor.'
  prefs: []
  type: TYPE_NORMAL
- en: Versioning
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: An assembly is a `.dll` file that contains metadata called the assembly manifest,
    which lists the contents of the file, as well as the name and the version of the
    file. The concept of strong names was introduced in .NET; a strong name consists
    of the name of the module, the version, and also a cryptographic hash that validates
    the file author. When .NET programs are linked to a strong named assembly, then
    the name, version, and hash of the file must match the linked strong name. If
    we simply replace the `.dll` file with a later version, then the program will
    fail to load it. This leads to different versions of `.dll` that have the same
    version number to prevent introducing breaking changes. Great.
  prefs: []
  type: TYPE_NORMAL
- en: There are many other components, but these are the things we most need to be
    aware of when working with .NET and PowerShell. Let’s look now at how PowerShell
    makes use of .NET.
  prefs: []
  type: TYPE_NORMAL
- en: Working with .NET in PowerShell
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we are going to look at some of the details of how PowerShell
    accesses .NET libraries. We’ll look at the default assemblies, how PowerShell
    finds types, and another way of creating objects.
  prefs: []
  type: TYPE_NORMAL
- en: Why bother?
  prefs: []
  type: TYPE_NORMAL
- en: PowerShell and C# are part of the .NET family and thus work well together, as
    they are based on the same .NET foundation. They share many features, such as
    classes and libraries. We can call C# inside PowerShell by using `Add-Type`, allowing
    us to compile and run the C# code when we run the PowerShell script. This lets
    us take advantage of the simplicity and ease of PowerShell, but we have C# available
    whenever we need it, without having to write an entire program.
  prefs: []
  type: TYPE_NORMAL
- en: PowerShell assemblies
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We saw at the start of the chapter that we could list the loaded assemblies
    with the statement:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: '`AppDomain` is a class that encapsulates and isolates the execution environment;
    it’s a bit like `PSSession` but even more secure; each instance of `PSSession`
    shares a set of assemblies, whereas each instance of `AppDomain` loads its own
    assemblies. `CurrentDomain` gets the current execution environment. The double
    colon (`::`) represents the C# namespace alias operator; we need to use it to
    access a member of an aliased namespace, and it goes between two identifiers.
    Let’s run the statement again, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we can see a list of the strong names of the assemblies we’ve loaded:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 16.6 – Default assemblies and their strong names](img/B17600_16_6.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 16.6 – Default assemblies and their strong names
  prefs: []
  type: TYPE_NORMAL
- en: Note that each strong name contains a short name, a version, a culture identifier,
    and the cryptographic key that identifies the author.
  prefs: []
  type: TYPE_NORMAL
- en: Dynamic assembly loading
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Automatic loading works for compiled programs such as `pwsh.exe`, but it relies
    on the required assembly list in the executable. We can add required assemblies
    to a module manifest as well, in the `RequiredAssemblies` element. If we need
    to load non-default assemblies when writing scripts, we can use the preceding
    `using` keyword, the `Add-Type` cmdlet, or even the `Import-Module` cmdlet if
    the assembly is in a `.``dll` file.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `Add-Type` cmdlet has five parameter sets; three of them are for defining
    new types, but we can also use it to import assemblies from a named path, or to
    just import the types we need from the assembly, such as the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: This will add the assemblies required to call simple Windows GUI elements from
    within PowerShell.
  prefs: []
  type: TYPE_NORMAL
- en: Once we’ve imported (or created) our new type, we can create instances of types
    with the `New-Object` cmdlet.
  prefs: []
  type: TYPE_NORMAL
- en: Creating instances of types
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `New-Object` cmdlet creates an instance of a type. Either the type must
    exist inside the PowerShell default assemblies, or we must import it first with
    `Add-Type`. `New-Object` is easy to use. All we need to provide is `TypeName`
    and a list of arguments that matches one of the available overloads. For instance,
    one of the overloads on the `StringBuilder` type allows a string to define the
    value of the new object, and an integer to define the initial capacity. Note that
    it takes a string value, (`System.Text.String.Builder`), not a namespace and namespace
    alias qualifier (`[System.Text.StringBuilder]::`), so we can do this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'That will create a variable called `$loveit` that contains the `"i love PowerShell"`
    string and has an initial capacity of 128 characters:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 16.7 – Loving it](img/B17600_16_7.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 16.7 – Loving it
  prefs: []
  type: TYPE_NORMAL
- en: We can see in the preceding screenshot that the initial capacity is 128, whereas
    we would expect it to be 17, the length of the string, if we had just passed a
    string value. Note that we have to understand the required arguments for the overload
    we wish to use as a constructor – in this instance, `"i love powershell"` and
    `128`. For instance, if we supply two strings, we will get an error.
  prefs: []
  type: TYPE_NORMAL
- en: An alternative is to use the `-Property` parameter, which accepts a hashtable
    of property names and the required values. We’ll see how to use that in the next
    section, but note that if you misspell a property, PowerShell will simply add
    the misspelled property to the object, rather than tell you that you have it wrong.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s try a couple of examples to get a feel for how we can use .NET with PowerShell.
  prefs: []
  type: TYPE_NORMAL
- en: Using .NET
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We’ll try two examples in this section – an alternative way of getting an action
    to fire, such as a script, and how we can call Windows GUI elements from PowerShell.
  prefs: []
  type: TYPE_NORMAL
- en: An alternative to the Task Scheduler
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this example, we’re going to create a timer object and then use the `Register-Event`
    cmdlet to fire an action at regular intervals.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, let’s make a timer:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we need to register the event and define an action:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let’s start the timer going with the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we should see the `hello` string appear on the screen, every five seconds,
    until we type the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'This is how it looks on my machine:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 16.8 – hello](img/B17600_16_8.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 16.8 – hello
  prefs: []
  type: TYPE_NORMAL
- en: We can see the command firing every time the timer reaches 5,000 milliseconds.
    Cool, eh?
  prefs: []
  type: TYPE_NORMAL
- en: Let’s try creating a GUI message box.
  prefs: []
  type: TYPE_NORMAL
- en: Creating GUI objects
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'This example will create a pop-up message box in Windows with a pair of yes/no
    buttons. The value of the pressed button is recorded in the PowerShell session:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'We could use this in conjunction with the preceding timer object to display
    a message box, allowing people to cancel a long-running script. This is how it
    looks on my machine:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 16.9 – Of course you do](img/B17600_16_9.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 16.9 – Of course you do
  prefs: []
  type: TYPE_NORMAL
- en: Note that the default answer is **Yes**. We could also use the response to set
    parameters, add an event, or trigger a conditional statement.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s summarize what we’ve seen in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We started out by understanding what .NET is – a software framework. We learned
    that it is based on the Common Language Infrastructure and is similar to .NET
    Framework in Windows, but it is not the same. We saw that it includes its own
    runtime, CoreCLR, and a set of libraries, CoreFX. We learned about the relationship
    between .NET and .NET Framework and how they co-exist. We saw that .NET can be
    used for many things, including machine learning and Internet of Things applications,
    but is mostly used for Azure and Windows.
  prefs: []
  type: TYPE_NORMAL
- en: We went through the components of .NET, and we understood how they are related
    to each other and are represented in PowerShell. We saw the constructor member,
    a special type of method for instantiating objects, and understood why versioning
    is frequently confusing.
  prefs: []
  type: TYPE_NORMAL
- en: We then looked at the specifics of how we access .NET libraries from PowerShell,
    learned about dynamic loading, and then saw how to use the `New-Object` cmdlet
    to create instances of classes.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we worked through two examples of things we can do using .NET – creating
    an event timer and a Windows message box.
  prefs: []
  type: TYPE_NORMAL
- en: What’s next? Well, it depends. If you want to learn more about PowerShell, then
    there are great books such as *Mastering PowerShell Scripting* by Chris Dent from
    Packt, or the absolute bible, *Windows PowerShell in Action* by Bruce Payette
    et al. Whichever you choose, what you need to do is practice, practice, practice.
    The best way to become confident with a language, any language, is to use it.
    If you are interested in .NET, then PowerShell is a good start, but sooner or
    later, you will want to use a compiled language with it, such as C#. While it’s
    technically possible to write a machine learning application in PowerShell, I
    think it would be a lot easier to do it with C#.
  prefs: []
  type: TYPE_NORMAL
- en: That’s it. That’s the end of the book. Thank you for sticking with it alongside
    me; I hope you enjoyed reading it as much as I enjoyed writing it. I can assure
    you I have learned a lot in the process, and hopefully, so have you. I hope you’ve
    enjoyed my company as much as I’ve enjoyed yours.
  prefs: []
  type: TYPE_NORMAL
- en: Exercises
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: How do you create a new instance of a .NET class in PowerShell?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What command in PowerShell is used to add a .NET assembly to the session?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How do you call a static method of a .NET class in PowerShell?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In PowerShell, how can you access a static property of a .NET class?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How can you invoke a .NET constructor with parameters in PowerShell?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is the PowerShell cmdlet to load a .NET assembly from a file?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How can you determine the .NET type of an object in PowerShell?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In PowerShell, how do you list all the methods of a .NET object?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is the syntax to invoke an instance method of a .NET object in PowerShell?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How do you access an instance property of a .NET object in PowerShell?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'What is .NET?: [https://dotnet.microsoft.com/en-us/learn/dotnet/what-is-dotnet](https://dotnet.microsoft.com/en-us/learn/dotnet/what-is-dotnet)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The Microsoft .NET documentation: [https://learn.microsoft.com/en-us/dotnet/core/introduction](https://learn.microsoft.com/en-us/dotnet/core/introduction)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The original .NET documentation; surprisingly useful: [https://learn.microsoft.com/en-us/previous-versions/tn-archive/bb496996(v=technet.10)](https://learn.microsoft.com/en-us/previous-versions/tn-archive/bb496996(v=technet.10))'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The `System.Management.Automation` namespace: [https://learn.microsoft.com/en-gb/dotnet/api/system.management.automation](https://learn.microsoft.com/en-gb/dotnet/api/system.management.automation)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Classes: [https://learn.microsoft.com/en-us/powershell/module/microsoft.powershell.core/about/about_classes](https://learn.microsoft.com/en-us/powershell/module/microsoft.powershell.core/about/about_classes)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Constructors: [https://learn.microsoft.com/en-us/powershell/module/microsoft.powershell.core/about/about_classes_constructors](https://learn.microsoft.com/en-us/powershell/module/microsoft.powershell.core/about/about_classes_constructors)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The `StringBuilder` class: [https://learn.microsoft.com/en-gb/dotnet/api/system.text.stringbuilder](https://learn.microsoft.com/en-gb/dotnet/api/system.text.stringbuilder)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Add-Type`: [https://learn.microsoft.com/en-us/powershell/module/microsoft.powershell.utility/add-type](https://learn.microsoft.com/en-us/powershell/module/microsoft.powershell.utility/add-type)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`New-Object`: [https://learn.microsoft.com/en-us/powershell/module/microsoft.powershell.utility/new-object](https://learn.microsoft.com/en-us/powershell/module/microsoft.powershell.utility/new-object)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The `Timer` class: [https://learn.microsoft.com/en-us/dotnet/api/system.timers.timer](https://learn.microsoft.com/en-us/dotnet/api/system.timers.timer)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Register-ObjectEvent`: [https://learn.microsoft.com/en-us/powershell/module/microsoft.powershell.utility/register-objectevent](https://learn.microsoft.com/en-us/powershell/module/microsoft.powershell.utility/register-objectevent)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'PowerShell Eventing: [https://devblogs.microsoft.com/powershell/powershell-eventing-quickstart/](https://devblogs.microsoft.com/powershell/powershell-eventing-quickstart/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Learn C#: [https://dotnet.microsoft.com/en-us/learn/csharp](https://dotnet.microsoft.com/en-us/learn/csharp)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Answers to Activities and Exercises
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '[Chapter 1](B17600_01.xhtml#_idTextAnchor013)'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Activities
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'You can use `ADD_FILE_CONTEXT_MENU_RUNPOWERSHELL`, like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '![Figure A.1 – Some PowerShell processes](img/B17600_Assessments_001.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure A.1 – Some PowerShell processes
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s get rid of `4052`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure A.2 – Fewer PowerShell processes](img/B17600_Assessments_002.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure A.2 – Fewer PowerShell processes
  prefs: []
  type: TYPE_NORMAL
- en: Exercises
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Input `Get-Random`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Input `Get-Random -Minimum 1 -``Maximum 11`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Input `Get-ChildItem -``Path <folderpath>`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Input `Get-ChildItem -Path <``folderpath> -Recurse`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Input `New-Item -Path <folder path> -Name <item` `name> -ItemType`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Directory.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Input `Get-Uptime`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Input `Out-File`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Store a username and password for use later in the shell or in a script.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: This cmdlet converts the output of a previous cmdlet or pipeline to HTML, which
    can then be displayed in a web browser. Note that you might need to save it as
    a file using `out-file` as well, or it will just display the HTML code in the
    shell.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[Chapter 2](B17600_02.xhtml#_idTextAnchor034)'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Activities
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`New` creates a new object. For instance, `New-Item C:\foo\bar.tx``t` will
    create an empty text file called `bar.txt` in the `C:\foo` directory. Add will
    add things to the existing object, so `Add-Content C:\foo\bar.txt "PowerShell
    rocks my world``"`will add that string to the previously empty text file.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Just specify the `-InputObject` parameter like this: `Get-Random -``InputObject
    20`.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Use the `-Prefix` parameter. This is particularly useful when using remote sessions.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Exercises
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`Get-Content` is correct. This is a bit of a trick question, as the *Approved
    Verbs for PowerShell Commands* web page says that `Get` should be reserved for
    getting information *about* an object, not its contents. Nonetheless, `Get-Content`
    is right, as we are getting the contents of a file and reserving it for future
    use *as an object*, as opposed to reading data from a remote resource such as
    a web page. `Read-Host` is an example of a cmdlet that reads things—in this case,
    information from the shell.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You should see the words `alive alive` printed on the screen. This is because
    `oh` is an alias for `Out-Host`, which takes an object—in this case, the string
    `alive alive`—and prints it to the default host, usually the screen.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`Get-ChildItem` has two parameter sets. The parameter that determines which
    set you use is `-LiteralPath`.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`*.exe` is being passed to the `-filter` parameter. If you look at the help
    file, you can see that `-filter` is a positional parameter with a position of
    1, so the second value without a specified parameter will be understood as a filter
    argument.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: No. the `-Filter` parameter only takes a single argument. If you want this cmdlet
    to run, then `Get-ChildItem c:\foo\* -include *.exe, *.txt` will work.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`Find-module *aws*` will find lots of official modules for working with AWS,
    provided by Amazon.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: At the time of writing, there aren’t any on the PowerShell Gallery, but there
    are some on GitHub. I’m not sure how official they are, though. Be wary.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Holding the *Ctrl* key and scrolling the mouse wheel is the easiest temporary
    way of doing it. *Ctrl* and *+* (plus) or *Ctrl* and *-* (minus) will also do
    it. To change it permanently, open **Settings**, click on the profile you wish
    to change, and go into the **Appearance** subsection.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[Chapter 3](B17600_03.xhtml#_idTextAnchor049)'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Activities
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We can combine `-first`, `-last`, and `-skip` to do this, like so:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '![Figure A.3 – Output when we use first, last, and skip](img/B17600_Assessments_003.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure A.3 – Output when we use first, last, and skip
  prefs: []
  type: TYPE_NORMAL
- en: This is because `-contains` doesn’t support wildcards. The value must match
    exactly, except that it is not case sensitive.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`Get-Command -ParameterName filter` will do this for us. If you run it, you
    will see that there are lots of them. Most of them make use of the same `filter`
    block syntax we’ve been looking at in this chapter.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Exercises
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`Get-Command` will let us find the `Get-Date` cmdlet. Next, we need to use
    `Get-Member` to see the properties of the object that `Get-Date` produces. Finally,
    we need to use `Select-Object` to just show the `DayOfWeek` property – **Day**
    returns the day of the month.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`path` isn’t a property that is displayed when we run `Get-Process`, so we
    will need to use `Get-Member` to find it.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Get-Process | select-object name, cpu, path | sort-object** **path -descending**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Simple.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`Where-Object` needs to come early. Remember, *filter left*.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'It’s best to make use of the filtering properties of a cmdlet rather than passing
    everything through the pipeline to `Where-Object`, so the following code is the
    most efficient way:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: ForEach-Object interactively.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`Get-Content` is the cmdlet you need, and we’ll be covering this in [*Chapter
    6*](B17600_06.xhtml#_idTextAnchor117), *PowerShell and Files – Reading, Writing,
    and Manipulating Data*. You will remember from the work we have done earlier in
    this chapter that the `-Name` parameter for `Get-Process` doesn’t accept objects
    `ByValue`, only `ByProcessName`, so we can’t use `Get-Content` to grab the list
    of names. Instead, we must use parentheses and feed them directly to the `-``Name`
    parameter.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'It won’t run like that; although the `-computername` parameter accepts a `system.string`
    object, it does so `ByPropertyName`, not `ByValue`. The correct way to run this
    is as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[Chapter 4](B17600_04.xhtml#_idTextAnchor071)'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Activities
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: It’s all about memory. As we mentioned, the stack has limited space, and value-type
    objects are held in the stack. Therefore, it makes sense to conserve memory as
    much as possible while being transparent to the human writing the code. `[Int64]`
    type objects take up twice as much space on the stack as `[Int32]` type objects.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`MyString` has been told to take the contents of `MyVariable`, the integer
    `42`, and treat it as a string. We can subsequently put an integer in `MyString`,
    because we didn’t constrain it in any way when we created it.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Doing it the other way around, with `[string]$MyOtherString`, constrains `MyOtherString`
    to only be able to contain strings.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Exercises
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There’s a space in there – spaces aren’t allowed. If we really must use a space
    in the variable name, then we must enclose it in curly braces – `{My Variable}`,
    which is arguably more work than using a variable name that doesn’t include a
    space.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`System.Management.Automation.PSVariable`, `PSVariable`, or even `Variable`.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Use the preference variable `$ErrorView`. By default, it is set to `ConciseView`,
    a shorter, reader-friendly message containing just the error. This was introduced
    in PowerShell 7.0 and replaced a slightly more oblique format. This old format
    can still be seen by setting `$ErrorView` to `NormalView`. Interestingly, the
    PowerShell documentation lists `$ErrorView` as both a preference and an automatic
    variable – I suspect this is wrong; I think it’s a preference variable.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`$Null` will do this. `$Null` is different from 0 and is still a value; it’s
    just an empty value.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'We can use the `CompareTo()` method. This will give us three possible outputs:
    `0` if the integers are the same, `-1` if the first integer is smaller than the
    second, or `1` if it is larger. Try the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This sort of thing will come in handy in the next chapter, [*Chapter 5*](B17600_05.xhtml#_idTextAnchor096),
    *PowerShell Control Flow – Conditionals and Loops*, where we will be looking at
    conditional statements.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: It’s a `System.Array` object or array.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`MyString.ToCharArray()` will output each `char` as an element of an array
    on a separate line.PowerShell Variables and Data Structures 34'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Because we are only using single quote marks, the output will be `My Name is
    $MyName`. If we want the variable to be expanded, we must use double quotes.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'This is the `TypeName` of an ordered hashtable, and we can create it using
    the `[ordered]` accelerator. Remember, this goes on the right-hand side of the
    statement, not the left, like so:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[Chapter 5](B17600_05.xhtml#_idTextAnchor096)'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Activities
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Because the switch is `7 { Write-Output 'contains 7' }`, which is looking for
    an integer. The line it is searching is a string, and so contains no integers.
    If we replaced the `7` in the `switch` statement with `'*7'`, making it a string,
    then it would work.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: It’s because we’re executing the increment statement before we write the output.
    Switching the two statements around would demonstrate that the scriptblock doesn’t
    execute when the condition isn’t met.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Exercises
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: None. The statement only produces output if `$x` is larger than 4\. There is
    no `else` statement here to produce alternative output. This is a true conditional
    statement, rather than a conditional that provides alternate flows.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`$x = 4 ; IF ($x -gt 4) {Write-Host ''$x is larger than 4''}Else {Write-Host
    ''$x is not larger` `than 4''}`'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`$x = 4 ; IF ($x -gt 4) {Write-Host ''$x is larger than 4''}elseif ($x -lt
    4) {Write-Host ''$x is smaller than 4''} Else {Write-Host ''$x` `is 4''}`'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`$x = 4 ; ($x -gt 4) ? (Write-Host ''$x is larger than 4'') : (Write-Host ''$x
    is not larger` `than 4'')`'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Because `foreach` is after a pipe character, there is only a single statement
    here, and `foreach` is interpreted as an alias of `ForEach-Object`, so the syntax
    is wrong. We can make it right by replacing the pipe character with a semicolon.
    This separates it into two statements, and `foreach` is correctly interpreted:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`number = 0 ; Do {$number ++ ; Write-Host "Number is $number"} While (!($number
    -eq 5))` will work. We’ll see that construction using the `not` operator alias
    (`!`) to reverse a statement quite often.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 't’s missing the iterator. This will work: `for ($i = 0 ; $i -lt 5 ; $i ++)
    {``Write-Host $i}.`'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`switch` statements. Using them outside loops and `switch` statements can lead
    to unpredictable outcomes.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'There are a few ways to do this; any that work are right, but my solution involves
    substituting a `for` loop instead of the existing `while` loop to implement the
    counter. I’ve also added an extra `elseif` statement to handle a winning condition,
    like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure A.4 – Guess limited Brucie](img/B17600_Assessments_004.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure A.4 – Guess limited Brucie
  prefs: []
  type: TYPE_NORMAL
- en: There are lots of ways of writing this on the internet – I’ve chosen this way
    just to use concepts that we’ve covered in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: '[Chapter 6](B17600_06.xhtml#_idTextAnchor117)'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Activity
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'This is just one way of doing it. If you got something different that worked,
    well done. That’s the right way – one of them, anyway. According to *Exercises
    in Programming Style*, there are at least 41 others:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Here it is running:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure A.5 – The ten most frequent words in an English translation of The
    Trial](img/B17600_Assessments_005.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure A.5 – The ten most frequent words in an English translation of The Trial
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s step through it quickly:'
  prefs: []
  type: TYPE_NORMAL
- en: Lines 1 and 2 bring our two files into PowerShell using `Get-Content`, in `Raw`
    format as single strings.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Line 3 adds some extra delimiters and removes empty strings. I don’t expect
    you to know about the string split options, so I gave you this in the hint.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Line 5 creates an empty array list to hold interesting words; if we used a PowerShell
    array, this would be painfully slow.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Line 7 starts a `Foreach` loop to step through each word in `$TrialWords`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Line 8 creates a variable and casts each word to lowercase into it each time
    the loop repeats.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Line 9 starts an `if` statement matching the condition “`$Lword` is not in `$StopWords`.”
    Note we are using the `-Contains` method, which matches substrings in a single
    string, so it is searching the `$StopWords` string for substrings that match `$LWord`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Line 10 adds `$Word` to the `$Words` array list if the condition is true.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Line 13 groups and sorts the words in `$Words`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Line 14 returns the 10 most frequent words, in descending order.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Exercises
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Get-Childitem -Path C:\Temp -File | Format-Wide -****Column 3**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Get-Process | Format-Wide -column 5 | Where-Object id -****gt 100**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'It will produce no output. Remember, **Format Right**. The correct code should
    be as follows:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '**“I love PowerShell” | Out-File -****Path Q3.txt**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**“Sooo much” | Out-File -Path** **Q3.txt -Append**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Get-ChildItem | Export-Csv -Path items.csv -****Delimiter “;”**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**(****Get-ChildItem Function:).count**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Get-Content Q3.txt -Delimiter “ “** Or **(Get-Content** **Q3.txt).Split(“
    “)**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`PSCustomObjects`.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Import-Clixml: Element ‘Objs’ with namespace name ‘http:// schemas.microsoft.com/powershell/2004/04’
    was** **not found.**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The XML file we are trying to import wasn’t formatted correctly for the cmdlet
    or it isn’t a PowerShell object.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[Chapter 7](B17600_07.xhtml#_idTextAnchor140)'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Activity
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Here is my solution:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure A.6 – One solution](img/B17600_Assessments_006.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure A.6 – One solution
  prefs: []
  type: TYPE_NORMAL
- en: 'Line 2 grabs the data in JSON format from the API and puts it in a variable.
    If we look at the `$astronauts` variable, we can see it has two key-value pairs,
    `message` and `people`. `people` contains an array of JSON objects, which themselves
    have two key-value pairs; `name` and `craft`. We can see this in the following
    figure:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure A.7 – Getting the JSON data](img/B17600_Assessments_007.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure A.7 – Getting the JSON data
  prefs: []
  type: TYPE_NORMAL
- en: So, we know the data we need are in the `$astronauts.people.name` key-value
    pair. All we need to do now is display it in a pleasing manner. We covered how
    to use `ConvertTo-Html` in [*Chapter 6*](B17600_06.xhtml#_idTextAnchor117), *PowerShell
    and Files – Reading, Writing, and Manipulating Data*, and this is the way I’ve
    chosen.
  prefs: []
  type: TYPE_NORMAL
- en: 'On line 5, we set up a `$params` hashtable so we can splat all the parameters
    we need. I’ve chosen to include a CSS stylesheet that displays a lovely image,
    but that’s not necessary. This is my CSS:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Finally, the magic happens on line 12\. We feed the values we are interested
    in into `ConvertTo- Html` via the pipeline and then use `Out-File` to write the
    HTML to a file. We can then open this file in the browser of our choosing.
  prefs: []
  type: TYPE_NORMAL
- en: Hopefully, this has shown you how easy it is to obtain, manipulate, and display
    data using an API.
  prefs: []
  type: TYPE_NORMAL
- en: Exercises
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Invoke-WebRequest -Uri ‘https://httpbin.org/delete’ -****Method Delete**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We use the `-SessionVariable` parameter in the first request (usually a login
    request) to supply a string, and then, in subsequent requests, we supply the session
    variable as a variable using the `-``WebSession` parameter.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We can use the `-SkipCertificateCheck` parameter, but we should only do this
    if we’re really sure that the site is valid and not malicious.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The mistake we made is in encoding the token before supplying it via the header.
    Encode the token to supply it as a parameter and keep it in plain text for headers.
    This means that supplying it as a parameter is slightly more secure, but not all
    services will accept it that way.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: WebSocket APIs are usually stateful. This means information about the requestor
    is persisted through multiple requests; this makes it more complicated to use,
    as we need to persist session information, and susceptible to network conditions.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'There are lots of ways to do this, but the most straightforward is probably
    this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We can either pass it a long string describing the custom schema using the `-Schema`
    parameter, or we can pass it a file location using `-SchemaFile`. You’re right!
    This isn’t in the chapter. You hopefully read the help file to get the answer.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[Chapter 8](B17600_08.xhtml#_idTextAnchor162)'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Activities
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The easy way to do this is to create an `$Output` variable in the `Param()`
    block, and pass that as a parameter to the `Out-File` cmdlet in the script, like
    this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The trouble with that is if we want to change the filename, we need to type
    both the filename and the path each time. It’s likely that we will want to change
    the filename far more often than we want to change the path. Let’s separate out
    the path and the filename like this:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure A.8 – Separating the filename and file path](img/B17600_Assessments_008.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure A.8 – Separating the filename and file path
  prefs: []
  type: TYPE_NORMAL
- en: Now, we can just pass a different filename when we want to, and a different
    path if we want to, without having to type out the whole thing each time.
  prefs: []
  type: TYPE_NORMAL
- en: 'From the help file of a cmdlet that has a parameter that takes multiple strings,
    we can see that the attribute contains an empty pair of square brackets, like
    this: `[string[]]`. That part is easy enough. We also need to process each element
    of the array that is then passed to the `-City` parameter. To do that, we’ll need
    a `foreach` loop as well, wrapped around the working part of the script.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Finally, we’ll need some way of sending each city’s data to a separate output
    file. I’ve chosen to do that by passing the `$item` variable from the `foreach`
    loop. Here’s my solution. Yours may look different, but if it works, that’s great.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure A.9 – Processing multiple cities](img/B17600_Assessments_009.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure A.9 – Processing multiple cities
  prefs: []
  type: TYPE_NORMAL
- en: In line `3`, I’ve added the `[string[]]` attribute to the `-City` parameter
    to allow it to take multiple strings.
  prefs: []
  type: TYPE_NORMAL
- en: I’ve opened a `foreach` loop on line `9` and closed it on line `22`. The lines
    in between will now be repeated for each `$item` in the array of strings held
    in the `$City` parameter. I’ve also indented the lines in between to make it easier
    to read.
  prefs: []
  type: TYPE_NORMAL
- en: I’ve changed line `17` so that it uses the `$item` variable (the current city)
    rather than the array in `$City` because that would cause an error – the API only
    accepts a single string at a time.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, I’ve changed line `11` so that it sends each output to a file that
    includes the name of the city.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s my example. Yours may differ but, hopefully, you’ve included warnings
    about needing the API key in advance:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Exercises
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This might be because of a few settings, but let’s imagine it is the simplest;
    the execution policy is correct for you, but not for them. This implies that the
    `CurrentUser` policy is restricting them.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Using the following should do it if the script was written on the local machine,
    or if we have signed it with a code-signing certificate on another machine:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The `-Maximum` parameter. I’m not aware of any *Dungeons and Dragons* dice that
    start at a number other than 1 (except for the d100, but we’ll come to that in
    a question shortly).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Well, there are a few ways we could do it, but hopefully, you’ve come up with
    something like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: You don’t need to have the `CmdletBinding()` attribute in there, but I always
    put it in.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'It should be an integer, and we’d specify it with the `[``int]` attribute:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'So, if we read the link, we can see that we can assign the `ValidateSet` attribute
    to a parameter and pass it an array of legal values, which looks like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'To do this, we’re going to need a loop and to specify the number of times we
    run the loop with a parameter, then add the output of each loop to a running total.
    It might look like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'This is because there is no default value assigned for `$Dice`. We could assign
    it a default, but it might be better to make it a mandatory parameter by adding
    `[Parameter(Mandatory)]` like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We could make both parameters mandatory and include a `HelpMessage` attribute
    that explains what to put for each parameter.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: So, the first thing to do is to add the value of `100` to the `ValidateSet`
    attribute of the `$``sides` parameter.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Once that’s done, we need to treat the value of `100` differently, so we can’t
    just add it to the loop. I’ve used an `if` and an `else` statement. Here’s my
    resulting script:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure A.10 – My level 15 paladin will crush your chaotic evil cleric](img/B17600_Assessments_010.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure A.10 – My level 15 paladin will crush your chaotic evil cleric
  prefs: []
  type: TYPE_NORMAL
- en: Remember, there are lots of ways to do this; if your code is completely different
    to mine but it works, that’s fine.
  prefs: []
  type: TYPE_NORMAL
- en: '[Chapter 9](B17600_09.xhtml#_idTextAnchor184)'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Activities
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Nothing, because our parameter is not written to accept pipeline input. As
    we discovered in [*Chapter 8*](B17600_08.xhtml#_idTextAnchor162), *Writing Our
    First Script – Turning Simple Cmdlets into Reusable Code*, to allow a parameter
    to accept pipeline input, we must add a parameter argument, like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure A.11 –  Accepting values from the pipeline](img/B17600_Assessments_011.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure A.11 – Accepting values from the pipeline
  prefs: []
  type: TYPE_NORMAL
- en: On line `9`, we’ve added a `ValueFromPipeline` argument to the parameter, which
    allows it to accept values from the pipeline. We’ve also enclosed the function
    in a `process` block, opening on line `12` and closing on line `20`; if we don’t
    have a `process` block, then the function will only act on the last value in the
    pipeline.
  prefs: []
  type: TYPE_NORMAL
- en: Because `Get-Random` only accepts one positional parameter, `-Maximum`. If we
    run it as previously, then the maximum will be set as `15`, and the cmdlet has
    no idea what to do with the `20` value. Similarly, `Get-Fifteen20 15 -maximum
    20` won’t work because the `-Maximum` parameter is already filled by the named
    value, `20`, so it doesn’t know what to do with the `15` value. `Get-Fifteen20
    -minimum 15 20` will work, however.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'There are lots of ways to do this, as always. My method is as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: I’ve created a function called `Remove-Log` that I can call in my script. I’ve
    created a variable called `$limit` that gets a date seven days less than when
    it is run. I then get all the items in the `C:\temp` directory that start with
    the string `MyLogFile`, using a wildcard. I’ve then filtered the list using `Where-Object`
    to select only the files older than my `$limit` date. Finally, I’ve piped that
    to `Remove-Item` with the `-Force` parameter to suppress any confirmations.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Exercises
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Avoid Hasty Abstractions – it’s a software engineering principle that encourages
    us to only create an abstraction, such as a function, when we know we will need
    it and we know exactly what we need it to do.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Because dot sourcing causes whatever it is calling to be run in the local, or
    parent, scope rather than the appropriate child scope.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Because just calling the variable will produce the code in the scriptblock;
    it won’t run it. We need to use the `invoke()` method, the call operator, or the
    `Invoke-Command` cmdlet. What we shouldn’t do is dot source it without careful
    consideration.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The `ValidatePattern` validation attribute should do it, but we’d need to use
    a regular expression. Ugh! Hopefully, you looked this up in the help file mentioned
    in the *Further* *reading* section.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Because filters expect pipeline input, and we haven’t supplied any. However,
    `365 | get-square` would work.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We’re preventing the `$number` variable from being accessed from another scope.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A function is named, whereas a scriptblock is anonymous.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We’re trying to feed a value through the pipeline, but there’s no parameter
    that accepts pipeline input. We need to either make it an advanced function and
    create a parameter that accepts pipeline input, or we need to use `$Args`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'We will write the function as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We can use it like this:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure A.12 – Getting a root the easy way](img/B17600_Assessments_012.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure A.12 – Getting a root the easy way
  prefs: []
  type: TYPE_NORMAL
- en: '[Chapter 10](B17600_10.xhtml#_idTextAnchor201)'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Activities
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `-ErrorAction` parameter will override the `$ErrorActionPreference` variable,
    and the `nosuchfile` string will cause a terminating error. Because it’s a terminating
    error, the cmdlet will not process `bar.txt`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Because if there is an error, then the error object is put into the pipeline,
    replacing the string that caused the error.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Exercises
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Terminating errors stop the script altogether. Non-terminating errors may stop
    the script from doing the current step, but PowerShell will move the script on
    to the next step.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Either with the `Get-Error` cmdlet, which displays the most recent error object,
    or with the `$Error` variable. This has an array of all the error objects created
    during a session up to a default maximum of 256.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The `-ErrorActionPreference` variable allows us to set the default error action
    preference for all cmdlets and scripts running in a specific PowerShell session.
    It determines whether errors should be displayed, ignored, or handled in a specific
    way.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The `Write-Error` cmdlet allows us to manually generate and display custom non-terminating
    error messages within a script. It is useful when we want to explicitly signal
    an error condition to the user or the calling code.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: To generate a terminating error that can be handled by a `try`/`catch` statement
    pair.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: By either using the `-Debug` parameter with a cmdlet or advanced script or by
    setting the `$DebugPreference` variable to `Continue`; the default is `SilentlyContinue`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: By using the `Write-Debug` cmdlet in the script. Debug messages are for people
    who write code; error messages are for people who use code. As such, a debug message
    should include detailed information about what is going on in the script at that
    point, possibly including variable values and step counts.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A breakpoint is a marker set in the script to pause its execution at a specific
    line or condition. It allows us to inspect the state of the script and variables
    at that point. A break point in tennis is quite different.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: It executes the current line of a script and moves on to the next line but treats
    whole functions as a single line. So, if the next line of code is a function,
    or we are currently in a function, then the whole function call will complete,
    rather than moving on to the next line in the function.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[Chapter 11](B17600_11.xhtml#_idTextAnchor218)'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Activity
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Try running `Remove-Module` to get rid of the module we’ve just installed, and
    then running `Get-Square`. What happens? Why does this happen?
  prefs: []
  type: TYPE_NORMAL
- en: 'The `Get-Square` cmdlet is still available. This is because we saved the module
    in the module path correctly; this means that PowerShell will autoload the module
    when we call a function in the module. We can see it working in the following
    screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure A.13 – Autoloading with PowerShell](img/B17600_Assessments_013.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure A.13 – Autoloading with PowerShell
  prefs: []
  type: TYPE_NORMAL
- en: In the first line, I list the loaded modules. Then, I run `Get-Square 7`, which
    autoloads `MyFirstModule`. After that, I confirm that’s what happened by running
    `Get-Module` again. We can see that `Remove-Module` removes the `Get-Square` cmdlet
    by running it with the `-Verbose` switch in the last line.
  prefs: []
  type: TYPE_NORMAL
- en: Exercises
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Get-Module**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: It imports a module into the global scope. Note that when we import a module
    from the command prompt, it is already imported into the global scope – we use
    this when we’re importing a module from inside another module; a nested module.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We need to give the full path to the module in the `-Name` parameter of `Import-Module`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Either use the `-NoClobber` parameter if they are not functions we want to use
    or use the `-Prefix` parameter if they are.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Either with the `Export-ModuleMembers` cmdlet in the module file or with a module
    manifest.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: It provides a link to the online documentation for the module, allowing the
    help to be updated.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the context of a module, it might be either formatting information for function
    or cmdlet output, or it might be custom type information.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We’ll get cmdlets; a `.dll` extension signifies a binary module, so the commands
    inside it will be of the `Cmdlet` type. Script modules contain commands of the
    `Function` type.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Because they are slow. The CDXML gets parsed to a PowerShell script, which then
    has to be interpreted.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[Chapter 12](B17600_12.xhtml#_idTextAnchor236)'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Exercises
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`New-PSSession` creates a persistent session, but an ad hoc session can be
    created with `Enter- PSSession`.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: By using SSH.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The `AllSigned` execution policy only allows scripts signed by a trusted publisher
    to run.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The `-ExecutionPolicy Bypass` switch is used to temporarily bypass an execution
    policy when running a script.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: PowerShell AMSI.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The constrained language mode is used to restrict access to dangerous cmdlets
    and scripting features in PowerShell.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: By using JEA.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Script block logging records the content of script blocks executed in PowerShell,
    providing visibility into potentially malicious actions. It records the contents
    in the `PowerShellCore` operational event log in Windows and in the systemd log
    in Linux.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A secure string is a PowerShell object of type `System.Security.SecureString`,
    and an encrypted string is a string object that has been encrypted with a key
    so that it cannot be read in a file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[Chapter 13](B17600_13.xhtml#_idTextAnchor267)'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Activities
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We could write a fairly complicated cmdlet with `Invoke-CimMethod`, but that
    isn’t the best way to do it. Instead, we should use the cmdlet specifically written
    for this purpose, `Stop- Process`, with the `ProcessId` of the `notepad` process:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '![Figure A.14 – Setting a default printer with CIM commands](img/B17600_Assessments_014.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure A.14 – Setting a default printer with CIM commands
  prefs: []
  type: TYPE_NORMAL
- en: In the first command, I put the printer object into a variable, then I used
    that variable as the input object for `Invoke-CimMethod` and invoked the `SetDefaultPrinter`
    method. The return value of `0` indicates success.
  prefs: []
  type: TYPE_NORMAL
- en: 'Note that the `SetDefaultPrinter` method doesn’t appear on the `$printer` variable.
    Unfortunately, we need to read the documentation to discover this method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://learn.microsoft.com/en-us/windows/win32/cimwin32prov/win32-printer-methods](https://learn.microsoft.com/en-us/windows/win32/cimwin32prov/win32-printer-methods)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://learn.microsoft.com/en-us/windows/win32/cimwin32prov/setdefaultprinter-method-in-class-win32-printer](https://learn.microsoft.com/en-us/windows/win32/cimwin32prov/setdefaultprinter-method-in-class-win32-printer)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Exercises
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Manifest modules.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: It may have been written before PowerShell Core was released, the author may
    not have included compatibility information in the manifest, or it may not be
    a manifest module.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Windows PowerShell 5.1.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Deserialized ones.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Use the `-``UseWindowsPowershell` parameter.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`__NAMESPACE`'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: It allows us to specify a different timeout when querying remote machines, as
    the default is 3 minutes per machine.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Possibly we could use `Set-CimInstance`, but because many properties are not
    writable, we more likely will use `Invoke-CimMethod`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We pass them as an i`Dictionary` hash table to the `-``Arguments` parameter.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[Chapter 14](B17600_14.xhtml#_idTextAnchor280)'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Activity
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Because PowerShell is very forgiving about file path separators, the only bit
    of code that needs to be different depending on the platform is how we get the
    name of the machine. Everything else is straightforward. Here’s my solution; yours
    could be very different and still achieve the task:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'Because we need to use different ways to get the machine name, those two lines
    are within `if` statements. Everything else works the same on Linux and Windows,
    so it’s very straightforward. This is how it looks running on my CentOS box:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure A.15 – Running a cross-platform script on CentOS](img/B17600_Assessments_015.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure A.15 – Running a cross-platform script on CentOS
  prefs: []
  type: TYPE_NORMAL
- en: As we can see, it works just fine. The script would be better for some error
    checking; for instance, what if both automatic variables are `false`?
  prefs: []
  type: TYPE_NORMAL
- en: Exercises
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The internet. As with most Linux distributions, Kali Linux is not supported
    by Microsoft.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Trick question. We are actually calling the `ls` Bash command on Linux. When
    we type it on Windows, we are calling `Get-ChildItem` via the `ls` alias.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Either `\` or `/`. It doesn’t matter, thankfully. This means it’s a lot easier
    to write cross-platform scripts.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: By calling the `$IsMacOS` variable. If it returns `true`, then we are running
    on macOS.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: By starting PowerShell with the `sudo pwsh` command. There is no way to elevate
    privilege during a PowerShell session.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`New-PSSession` with the `-``HostName` parameter.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`New-PSSession` and the `-``KeyFilePath` parameter.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: It’s a file transfer program that is included in the PowerShell 7 packages.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Ed25519 is a recent, more secure encryption algorithm for digital signatures
    based on public/private keys.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[Chapter 15](B17600_15.xhtml#_idTextAnchor302)'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Answers
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Because the Zero and Pico use an ARMv6 chip architecture, which isn’t compatible
    with .NET since it requires ARMv7 or ARMv8.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Either `C:\Users\<username>\.sshconfig` or `C:\ProgramData\ssh\ssh_config`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Test-NetConnection**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**ssh <username>@<hostname>**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**sudo** **bash ./install.sh**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Because it’s a pain typing `~/powershell/pwsh`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**sudo ln -s ~/****powershell/pwsh /usr/bin/pwsh**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Use the `-Raw` switch parameter with the `Get-GpioPin` cmdlet.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Debian Linux, similar to Ubuntu.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[Chapter 16](B17600_16.xhtml#_idTextAnchor320)'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Exercises
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**$object = New-Object -****TypeName Namespace.ClassName**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Add-Type -****AssemblyName “AssemblyName”**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**[****Namespace.ClassName]::MethodName()**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**[****Namespace.ClassName]::PropertyName**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**$object = New-Object -TypeName Namespace.ClassName -ArgumentList (arg1,**
    **arg2, ...)**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Add-Type -****Path “Path\To\Assembly.dll”**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Using $object.GetType()**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**$object | Get-Member -****MemberType Method**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**$****object.MethodName()**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**$****object.PropertyName**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
