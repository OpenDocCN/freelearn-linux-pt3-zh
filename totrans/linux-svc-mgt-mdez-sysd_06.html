<html><head></head><body>
		<div id="_idContainer018">
			<h1 id="_idParaDest-63"><em class="italic"><a id="_idTextAnchor063"/>Chapter 5</em>: Creating and Editing Services</h1>
			<p>We've just seen what <strong class="source-inline">systemd</strong> services are and how to control them. Sometimes though, you might need to either alter the behavior of a service or create a completely new one. In this chapter, we'll look at the proper way to edit services. Then, we'll look at how to create a new one. The specific topics of this chapter are as follows:</p>
			<ul>
				<li>Editing an existing service</li>
				<li>Creating a new service</li>
				<li>Changing the default systemd editor</li>
				<li>Creating a new container service with podman</li>
			</ul>
			<p>So, if you're ready, let's jump in.</p>
			<h1 id="_idParaDest-64"><a id="_idTextAnchor064"/>Technical requirements</h1>
			<p>As before, I'll be using an Alma Linux 8 virtual machine and an Ubuntu Server 20.04 virtual machine. To perform the Secure Shell exercise, you'll need to go into the VirtualBox network settings for both virtual machines and choose <strong class="bold">Bridged Adapter </strong>from the <strong class="bold">Attached to</strong> drop-down list. Then, expand the <strong class="bold">Advanced</strong> menu and choose <strong class="bold">Allow All</strong> from the <strong class="bold">Promiscuous Mode</strong> drop-down list. When you boot up the virtual machine, obtain its IP address by opening a terminal and typing <strong class="source-inline">ip a</strong>. That way, you'll be able to remotely log into your virtual machines from the command line of your host machine.</p>
			<p>Check out the following link to see the Code in Action video: <a href="https://bit.ly/3xP0yOH">https://bit.ly/3xP0yOH</a></p>
			<h1 id="_idParaDest-65"><a id="_idTextAnchor065"/>Editing an existing service</h1>
			<p>We've seen that the unit files<a id="_idIndexMarker098"/> for our services live in the <strong class="source-inline">/lib/systemd/system/</strong> directory, so your first instinct might be to go there and edit files in your favorite text editor. You don't want to do that though, even though it would work. If you were to do a system update, it might overwrite the files that you edited, and you'd lose your changes.</p>
			<p>The proper way to do this is to create edited versions of your service files in the <strong class="source-inline">/etc/systemd/system/</strong> directory. You can do<a id="_idIndexMarker099"/> that with your favorite text editor, the same as you would with any other configuration file. Indeed, that's the way that you <em class="italic">used to</em> have to do it. When Red Hat released RHEL 7.2, they added an <strong class="source-inline">edit</strong> function to the <strong class="source-inline">systemctl</strong> command, which makes life much easier. (Of course, that <strong class="source-inline">edit</strong> function is now available on all Linux distros that run <strong class="source-inline">systemd</strong>.)</p>
			<p class="callout-heading">Note</p>
			<p class="callout">It has been brought to my attention that some people prefer to add their own custom unit files<a id="_idIndexMarker100"/> to the <strong class="source-inline">/lib/systemd/system/</strong> directory so that they'll be alongside the unit files that get installed by the operating system. If you're one of those people, please understand that this is <em class="italic">not</em> good practice. By doing this, you risk getting your custom unit files either deleted or overwritten when you do a system update. Also, keeping your custom unit files in the <strong class="source-inline">/etc/systemd/system/</strong> directory will make it much easier for you to keep track of which unit files you've added, and which ones were installed by the operating system.</p>
			<p>Now, you might be wondering how you can know what changes you can make to a service file. The most simplistic answer is to read the man pages for the various unit types and look at all the parameters and options that you can add, delete, or modify. If you're like me though, you'll start reading these man pages and soon find that they're the perfect cure for insomnia. Don't get me wrong, the man pages are definitely useful. But if you want to really learn how to make services sing and dance the way you want them to, the most painless way to do it is to look at the service files that are already on your system and see how they're set up. Then, look at the parameters that are listed in those files, and look them up in the appropriate man pages to see what they're doing for you. As we go through this chapter, I'll give you plenty of examples of what I'm talking about.</p>
			<p>When you use the <strong class="source-inline">systemctl edit</strong> function, you can either partially edit the file or edit the entire file. By default, you'll do a partial edit. Let's begin with the simplest example I can think of.</p>
			<h2 id="_idParaDest-66"><a id="_idTextAnchor066"/>Creating a partial edit to the [Install] section</h2>
			<p>Let's fire up the Ubuntu server<a id="_idIndexMarker101"/> virtual machine and add an <strong class="source-inline">Alias=</strong> line to the <strong class="source-inline">apache2.service</strong> file. Start by doing this:</p>
			<p class="source-code">sudo systemctl edit apache2</p>
			<p>What you'll get looks something like this:</p>
			<div>
				<div id="_idContainer014" class="IMG---Figure">
					<img src="image/Figure_5.1_B17491.jpg" alt=""/>
				</div>
			</div>
			<p class="figure-caption">Figure 5<a id="_idTextAnchor067"/>.1 â€“ The systemd service editor on Ubuntu</p>
			<p>Yeah, that doesn't look like much, does it? It's just an empty file opened in the nano text editor. Don't worry, though. All we're going to do here is to add one parameter, and we don't need to see the whole service file to do that. Since we're working with Ubuntu, the name of the Apache service is <strong class="source-inline">apache2</strong>. Let's say that you've just come over from the Red Hat world, and you're used to always using <strong class="source-inline">httpd</strong> as the Apache service name. Consequently, you get frustrated when you always instinctively type the wrong service name on the Ubuntu machine. It's kind of like if you've been used to driving with a standard transmission all your life, and then you start stomping around for a clutch when you get into a car with an automatic transmission. (Well, that's what I do, anyway.) We can easily fix that, but let's first look at an example that we already have.</p>
			<p>In another window, look at the <strong class="source-inline">[Install]</strong> section<a id="_idIndexMarker102"/> of the <strong class="source-inline">ssh.service</strong> file on the Ubuntu machine, as shown here: </p>
			<p class="source-code">. . .</p>
			<p class="source-code">. . .</p>
			<p class="source-code">[Install]</p>
			<p class="source-code">WantedBy=multi-user.target</p>
			<p class="source-code">Alias=sshd.service</p>
			<p>That <strong class="source-inline">Alias=</strong> line at the end is our example. Now, over in the nano window, type this:</p>
			<p class="source-code">[Install]</p>
			<p class="source-code">Alias=httpd.service</p>
			<p>Save the file and exit the editor by doing a <em class="italic">Ctrl</em> + <em class="italic">X</em> sequence. When it asks if you want to save the modified buffer, hit the <em class="italic">y</em> key. Then, just hit the <em class="italic">Enter</em> key to accept the default filename. Next, look inside the <strong class="source-inline">/etc/systemd/system/</strong> directory. You'll see that we've just created a new <strong class="source-inline">apache2.service.d</strong> directory:</p>
			<p class="source-code">donnie@ubuntu20-04:/etc/systemd/system$ ls -l</p>
			<p class="source-code">total 104</p>
			<p class="source-code">drwxr-xr-x 2 root root 4096 AprÂ Â 5 16:55 apache2.service.d</p>
			<p class="source-code">. . .</p>
			<p class="source-code">. . .</p>
			<p>Inside that directory, you'll see the following <strong class="source-inline">override.conf</strong> file:</p>
			<p class="source-code">donnie@ubuntu20-04:/etc/systemd/system/apache2.service.d$ ls -l</p>
			<p class="source-code">total 4</p>
			<p class="source-code">-rw-r--r-- 1 root root 30 AprÂ Â 5 16:55 override.conf</p>
			<p class="source-code">donnie@ubuntu20-04:/etc/systemd/system/apache2.service.d$</p>
			<p>This file contains the parameter that we've just added, which looks like this:</p>
			<p class="source-code">[Install]</p>
			<p class="source-code">Alias=httpd.service</p>
			<p>That's it â€“ the entire file. When<a id="_idIndexMarker103"/> we start Apache, this parameter will get added to what's already in the original service file. The beauty of this is that if the original service file were to get replaced by a system update, you'd get the changes that were made by the update, and you'd still have this modification.</p>
			<p>But, before you can use this modification, you'll need to load it into the system. Do that by doing:</p>
			<p class="source-code">donnie@ubuntu20-04:~$ sudo systemctl daemon-reload</p>
			<p class="source-code">[sudo] password for donnie: </p>
			<p class="source-code">donnie@ubuntu20-04:~$</p>
			<p>Any time you modify or add a service file, you'll need to do a <strong class="source-inline">daemon-reload</strong>. When you add an <strong class="source-inline">Alias=</strong>, you'll also need to create a symbolic link for it in the <strong class="source-inline">/etc/systemd/system/</strong> directory. You can create it manually with an <strong class="source-inline">ln -s</strong> command, but you don't have to. When you add an <strong class="source-inline">Alias=</strong> line to the <strong class="source-inline">[Install]</strong> section of a service file, the link will get created automatically when you enable the service. On the Ubuntu machine, the Apache service is already enabled and running, so we'll just disable it and enable it again. (Note that there's no need to stop the service.) So, let's first disable Apache, like this:</p>
			<p class="source-code">donnie@ubuntu20-04:/etc/systemd/system$ sudo systemctl disable apache2</p>
			<p class="source-code">Synchronizing state of apache2.service with SysV service script with /lib/systemd/systemd-sysv-install.</p>
			<p class="source-code">Executing: /lib/systemd/systemd-sysv-install disable apache2</p>
			<p class="source-code">Removed /etc/systemd/system/multi-user.target.wants/apache2.service.</p>
			<p class="source-code">donnie@ubuntu20-04:/etc/systemd/system$</p>
			<p>Now, we'll enable it again, like this:</p>
			<p class="source-code">donnie@ubuntu20-04:/etc/systemd/system$ sudo systemctl enable apache2</p>
			<p class="source-code">Synchronizing state of apache2.service with SysV service script with /lib/systemd/systemd-sysv-install.</p>
			<p class="source-code">Executing: /lib/systemd/systemd-sysv-install enable apache2</p>
			<p class="source-code">Created symlink /etc/systemd/system/httpd.service â†’ /lib/systemd/system/apache2.service.</p>
			<p class="source-code">Created symlink /etc/systemd/system/multi-user.target.wants/apache2.service â†’ /lib/systemd/system/apache2.service.</p>
			<p class="source-code">donnie@ubuntu20-04:/etc/systemd/system$</p>
			<p>You can see in the output<a id="_idIndexMarker104"/> that the <strong class="source-inline">enable</strong> command reads in the <strong class="source-inline">Alias=</strong> line that we inserted into the <strong class="source-inline">[Install]</strong> section, and creates an <strong class="source-inline">httpd.service</strong> link that points back to the original <strong class="source-inline">apache2.service</strong> file. We can verify that with this <strong class="source-inline">ls -l</strong> command as follows:</p>
			<p class="source-code">donnie@ubuntu20-04:/etc/systemd/system$ ls -l httpd.service </p>
			<p class="source-code">lrwxrwxrwx 1 root root 35 AprÂ Â 5 17:39 httpd.service -&gt; /lib/systemd/system/apache2.service</p>
			<p class="source-code">donnie@ubuntu20-04:/etc/systemd/system$</p>
			<p>Now comes the moment of truth. Can we now control Apache on our Ubuntu machine by invoking the <strong class="source-inline">httpd</strong> service name? Let's see:</p>
			<p class="source-code">donnie@ubuntu20-04:~$ systemctl status httpd</p>
			<p class="source-code">â€¢ apache2.service - The Apache HTTP Server</p>
			<p class="source-code">Â Â Â Â Â Loaded: loaded (/lib/systemd/system/apache2.service; enabled; vendor preset: enabled)</p>
			<p class="source-code">Â Â Â Â Drop-In: /etc/systemd/system/apache2.service.d</p>
			<p class="source-code">Â Â Â Â Â Â Â Â Â Â Â Â Â â””â”€override.conf</p>
			<p class="source-code">Â Â Â Â Â Active: active (running) since Mon 2021-04-05 17:19:08 UTC; 34min ago</p>
			<p class="source-code">. . .</p>
			<p class="source-code">. . .</p>
			<p>Oh, yeah. It works<a id="_idIndexMarker105"/> like a champ. (Don't you just love it when a plan comes together?) To see the service file along with your new edit, use <strong class="source-inline">systemctl cat</strong>, like this:</p>
			<p class="source-code">donnie@ubuntu20-04:~$ systemctl cat apache2</p>
			<p class="source-code"># /lib/systemd/system/apache2.service</p>
			<p class="source-code">[Unit]</p>
			<p class="source-code">Description=The Apache HTTP Server</p>
			<p class="source-code">. . .</p>
			<p class="source-code">. . .</p>
			<p class="source-code">[Install]</p>
			<p class="source-code">WantedBy=multi-user.target</p>
			<p class="source-code"># /etc/systemd/system/apache2.service.d/override.conf</p>
			<p class="source-code">[Install]</p>
			<p class="source-code">Alias=httpd.service</p>
			<p class="source-code">donnie@ubuntu20-04:~$</p>
			<p>The top part of the output shows the original service file, and the bottom part shows the <strong class="source-inline">override.conf</strong> file that you created.</p>
			<p>Of course, you can also go the opposite way with this. If you're used to doing things the Ubuntu way and suddenly find yourself administering Apache on a RHEL-type machine, you can add an <strong class="source-inline">Alias=apache2.service</strong> line to the <strong class="source-inline">httpd.service</strong> file, and then disable and re-enable Apache in order to create the link. The only difference in the procedure is that on the Ubuntu machine, <strong class="source-inline">systemctl edit</strong> invokes the nano text editor, and on RHEL-type machines, it might invoke the vi text editor. (The RHEL-type distros just recently switched from vi to nano as the default systemd editor.)</p>
			<p class="callout-heading">Pro tip</p>
			<p class="callout">Remember that whatever changes you make to the <strong class="source-inline">[Install]</strong> section of a service file affects what happens whenever you enable or disable that service.</p>
			<p>Okay, now that we've added<a id="_idIndexMarker106"/> a cool option to the <strong class="source-inline">[Install]</strong> section, let's add a few to the <strong class="source-inline">[Service]</strong> section.</p>
			<h2 id="_idParaDest-67"><a id="_idTextAnchor068"/>Creating a partial edit to the [Service] section</h2>
			<p>Let's continue on with our Ubuntu Server virtual machine, and just add to what we've already done. This time, we'll add a few options to the <strong class="source-inline">[Service]</strong> section<a id="_idIndexMarker107"/> that will beef up security a bit. Before we do that though, let's see how secure Apache really is. We'll do that with the <strong class="source-inline">systemd-analyze</strong> utility.</p>
			<p>On the <strong class="source-inline">systemd-analyze</strong> man page, you'll see that there are quite a few uses for this utility. For now, we'll just cover the <strong class="source-inline">security</strong> option. Let's start by checking the overall security profile for the services on our Ubuntu VM by doing:</p>
			<p class="source-code">donnie@ubuntu20-04:~$ systemd-analyze security</p>
			<p class="source-code">UNITÂ Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â EXPOSURE PREDICATE HAPPY</p>
			<p class="source-code">accounts-daemon.serviceÂ Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â 9.6 UNSAFEÂ Â ğŸ˜¨Â Â Â Â </p>
			<p class="source-code">apache2.serviceÂ Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â 9.2 UNSAFEÂ Â ğŸ˜¨Â Â Â Â </p>
			<p class="source-code">apport.serviceÂ Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â 9.6 UNSAFEÂ Â ğŸ˜¨Â Â Â Â </p>
			<p class="source-code">. . .</p>
			<p class="source-code">. . .Â Â Â Â Â Â ğŸ™‚Â Â Â Â </p>
			<p class="source-code">systemd-udevd.serviceÂ Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â 8.4 EXPOSED ğŸ™Â Â Â Â </p>
			<p class="source-code">thermald.serviceÂ Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â 9.6 UNSAFEÂ Â ğŸ˜¨Â Â Â Â </p>
			<p class="source-code">unattended-upgrades.serviceÂ Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â 9.6 UNSAFEÂ Â ğŸ˜¨Â Â Â Â </p>
			<p class="source-code">user@1000.serviceÂ Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â 9.4 UNSAFEÂ Â ğŸ˜¨Â Â Â Â </p>
			<p class="source-code">uuidd.serviceÂ Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â 4.5 OKÂ Â Â Â Â Â ğŸ™‚Â Â Â Â </p>
			<p class="source-code">vgauth.serviceÂ Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â 9.5 UNSAFEÂ Â ğŸ˜¨Â Â Â Â </p>
			<p class="source-code">donnie@ubuntu20-04:~$</p>
			<p>This command checks<a id="_idIndexMarker108"/> the security and sandboxing settings for each service and assigns an <strong class="source-inline">EXPOSURE</strong> score to each. The higher the score, the less safe the service is. So, this is like the game of golf, where you want to get the lowest score possible. The <strong class="source-inline">HAPPY</strong> column is supposed to show little face emoticons with varying degrees of happy or sad expressions, but the faces don't show when pasted into this book. That's okay though, because you can see them for yourself on your virtual machine.</p>
			<p>Now, before you get too excited about seeing that a service is marked as <strong class="source-inline">UNSAFE</strong>, as we see here for the Apache service, you need to understand that this only examines the security settings in the service files. It doesn't account for any security settings that might be in the service's own configuration files, security options that are encoded<a id="_idIndexMarker109"/> into the service executable file, or any <strong class="bold">Mandatory Access Control</strong> (<strong class="bold">MAC</strong>) options that might be in effect. Still, though, this is a useful tool for suggesting ways to enhance your security settings.</p>
			<p>Next, let's look at some suggestions for the Apache service:</p>
			<p class="source-code">donnie@ubuntu20-04:~$ systemd-analyze security apache2</p>
			<p class="source-code">Â Â NAMEÂ Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â DESCRIPTIONÂ Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â EXPOSURE</p>
			<p class="source-code">âœ— PrivateNetwork=Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Service has access to the host's networkÂ Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â 0.5</p>
			<p class="source-code">âœ— User=/DynamicUser=Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Service runs as root userÂ Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â 0.4</p>
			<p class="source-code">âœ— CapabilityBoundingSet=~CAP_SET(UID|GID|PCAP)Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Service may change UID/GID identities/capabilitiesÂ Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â 0.3</p>
			<p class="source-code">âœ— CapabilityBoundingSet=~CAP_SYS_ADMINÂ Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Service has administrator privilegesÂ Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â 0.3</p>
			<p class="source-code">âœ— CapabilityBoundingSet=~CAP_SYS_PTRACEÂ Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Service has ptrace() debugging abilitiesÂ Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â 0.3</p>
			<p class="source-code">. . .</p>
			<p class="source-code">. . .</p>
			<p>There's too much output<a id="_idIndexMarker110"/> to show here in its entirety, but that's okay. Let's scroll down a bit and show some settings that are a bit more relevant to what we want to do:</p>
			<p class="source-code">. . .</p>
			<p class="source-code">. . .</p>
			<p class="source-code">âœ“ PrivateMounts=Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Service cannot install system mountsÂ Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â </p>
			<p class="source-code">âœ“ PrivateTmp=Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Service has no access to other software's temporary filesÂ Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â </p>
			<p class="source-code">âœ— PrivateUsers=Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Service has access to other usersÂ Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â 0.2</p>
			<p class="source-code">âœ— ProtectClock=Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Service may write to the hardware clock or system clockÂ Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â 0.2</p>
			<p class="source-code">âœ— ProtectControlGroups=Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Service may modify the control group file systemÂ Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â 0.2</p>
			<p class="source-code">âœ— ProtectHome=Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Service has full access to home directoriesÂ Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â 0.2</p>
			<p class="source-code">. . .</p>
			<p class="source-code">. . .</p>
			<p class="source-code">âœ— ProtectSystem=Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Service has full access to the OS file hierarchyÂ Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â 0.2</p>
			<p class="source-code">. . .</p>
			<p class="source-code">. . .</p>
			<p>When you see an <strong class="source-inline">X</strong> in front<a id="_idIndexMarker111"/> of an entry, it means that an unsafe setting is in effect. Having a checkmark in front of an entry means that that parameter is configured with a safe setting. But, if you go in all willy-nilly and change the unsafe settings to safe ones, you'll break the service so that it will no longer run. Some of these supposedly unsafe settings are necessary for the service to do its job. Take the <strong class="source-inline">User=/DynamicUser=</strong> setting, for example. We see here that not having that parameter allows the Apache service to run with root privileges. Is that bad? Not really, because the Apache service needs root privileges to do certain things that it has to do. If you set this option to a non-root user, Apache will fail to start. And besides, the Apache developers have already accounted for this. They set it up so that only the first Apache process runs with root privileges, and all other Apache processesâ€”the ones to which web browsers connectâ€”run without root privileges. We've already seen that on a RHEL-type distro, such as Alma Linux, the Apache processes run under the <strong class="source-inline">apache</strong> user account. On Ubuntu, we see here that they run under the <strong class="source-inline">www-data</strong> account:</p>
			<p class="source-code">donnie@ubuntu20-04:/etc/apache2$ ps aux | grep apache</p>
			<p class="source-code">rootÂ Â Â Â Â Â Â Â 2290Â Â 0.0Â Â 0.2Â Â Â 6520Â Â 4480 ?Â Â Â Â Â Â Â Â SsÂ Â Â 18:40Â Â Â 0:00 /usr/sbin/apache2 -k start</p>
			<p class="source-code">www-dataÂ Â Â Â 2291Â Â 0.0Â Â 0.2 752656Â Â 4344 ?Â Â Â Â Â Â Â Â SlÂ Â Â 18:40Â Â Â 0:00 /usr/sbin/apache2 -k start</p>
			<p class="source-code">www-dataÂ Â Â Â 2292Â Â 0.0Â Â 0.2 752656Â Â 4344 ?Â Â Â Â Â Â Â Â SlÂ Â Â 18:40Â Â Â 0:00 /usr/sbin/apache2 -k start</p>
			<p class="source-code">donnieÂ Â Â Â Â Â 2554Â Â 0.0Â Â 0.0Â Â Â 6432Â Â Â 724 pts/0Â Â Â Â S+Â Â Â 19:55Â Â Â 0:00 grep --color=auto apache</p>
			<p class="source-code">donnie@ubuntu20-04:/etc/apache2$</p>
			<p>This non-root user<a id="_idIndexMarker112"/> is defined in the Apache configuration files. Let's see if our good friend <strong class="source-inline">grep</strong> can help us find where this is set:</p>
			<p class="source-code">donnie@ubuntu20-04:/etc/apache2$ grep -r 'USER' *</p>
			<p class="source-code">apache2.conf:User ${APACHE_RUN_USER}</p>
			<p class="source-code">envvars:export APACHE_RUN_USER=www-data</p>
			<p class="source-code">donnie@ubuntu20-04:/etc/apache2$</p>
			<p>So, on the Ubuntu machine, the non-root <strong class="source-inline">www-data</strong> user is defined in the <strong class="source-inline">/etc/apache2/envvars</strong> file and invoked in the <strong class="source-inline">/etc/apache2/apache2.conf</strong> file. (I'll leave it to you to find where this is set on the Alma Linux machine.) Anyway, that's enough about the settings that we can't change. Let's look at some settings that we <em class="italic">can</em> change.</p>
			<p class="callout-heading">Tip:</p>
			<p class="callout">On RHEL-type machines, everything I'm about to show you is already covered by SELinux. But, you can still use these settings if you want double protection. Ubuntu and SUSE use AppArmor instead of SELinux. Unfortunately, AppArmor<a id="_idIndexMarker113"/> provides almost no protection at all for Apache unless you jump through the hoops of creating your own custom AppArmor profile. Setting up this protection in <strong class="source-inline">systemd</strong> is much easier.</p>
			<p>Let's first look at protecting users' home directories. We'll once again use the <strong class="source-inline">sudo systemctl edit apache2</strong> command, which will open the <strong class="source-inline">override.conf</strong> file that we created previously. The <strong class="source-inline">[Install]</strong> section will still be there, so we'll just add a <strong class="source-inline">[Service]</strong> section, as follows:</p>
			<p class="source-code">[Service]</p>
			<p class="source-code">ProtectHome=yes</p>
			<p class="source-code">ProtectSystem=strict</p>
			<p class="source-code">[Install]</p>
			<p class="source-code">Alias=httpd.service</p>
			<p>By default, the Apache service<a id="_idIndexMarker114"/> can read from or write to any place in the filesystem. The <strong class="source-inline">ProtectHome=yes</strong> setting prevents Apache from accessing the <strong class="source-inline">/root/</strong>, <strong class="source-inline">/home/</strong>, and the <strong class="source-inline">/run/user/</strong> directories, even if they're set up with world-readable permissions. We can also set this to <strong class="source-inline">read-only</strong> if users want to serve web content out of their own home directories while preventing Apache from writing to them.</p>
			<p>The <strong class="source-inline">ProtectSystem=strict</strong> setting causes Apache to have read-only access to the entire filesystem, except for the <strong class="source-inline">/dev/</strong>, <strong class="source-inline">/proc/</strong>, and <strong class="source-inline">/sys/</strong> directories. Let's save the file and restart Apache to see what we've got:</p>
			<p class="source-code">donnie@ubuntu20-04:~$ sudo systemctl daemon-reload</p>
			<p class="source-code">donnie@ubuntu20-04:~$ sudo systemctl restart apache2</p>
			<p class="source-code">Job for apache2.service failed because the control process exited with error code.</p>
			<p class="source-code">See "systemctl status apache2.service" and "journalctl -xe" for details.</p>
			<p class="source-code">donnie@ubuntu20-04:~$</p>
			<p>Oh, dear. This isn't good. Let's look at the status to see what the problem could be:</p>
			<p class="source-code">donnie@ubuntu20-04:~$ sudo systemctl status apache2</p>
			<p class="source-code">. . .</p>
			<p class="source-code">. . .</p>
			<p class="source-code">Apr 10 21:52:20 ubuntu20-04 apachectl[3848]: (30)Read-only file system: AH00091: apache2: could not open error log file /var/log/apache2/error.log.</p>
			<p class="source-code">Apr 10 21:52:20 ubuntu20-04 apachectl[3848]: AH00015: Unable to open logs</p>
			<p class="source-code">Apr 10 21:52:20 ubuntu20-04 apachectl[3836]: Action 'start' failed.</p>
			<p class="source-code">Apr 10 21:52:20 ubuntu20-04 apachectl[3836]: The Apache error log may have more information.</p>
			<p class="source-code">. . .</p>
			<p class="source-code">. . .</p>
			<p class="source-code">donnie@ubuntu20-04:~$</p>
			<p>So, Apache<a id="_idIndexMarker115"/> wants to write to its log file in the <strong class="source-inline">/var/log/apache2/</strong> directory, but it can't. Let's change the <strong class="source-inline">ProtectSystem</strong> setting to see if that helps:</p>
			<p class="source-code">[Service]</p>
			<p class="source-code">ProtectHome=yes</p>
			<p class="source-code">ProtectSystem=fullÂ Â </p>
			<p class="source-code">[Install]</p>
			<p class="source-code">Alias=httpd.service</p>
			<p>Setting <strong class="source-inline">ProtectSystem=</strong> to <strong class="source-inline">full</strong> causes Apache to have read-only access to the <strong class="source-inline">/boot/</strong>, <strong class="source-inline">/usr/</strong>, and <strong class="source-inline">/etc/</strong> directories. Apache normally doesn't need to write to any of those directories, so it should now work. Let's try it and see:</p>
			<p class="source-code">donnie@ubuntu20-04:~$ sudo systemctl daemon-reload</p>
			<p class="source-code">donnie@ubuntu20-04:~$ sudo systemctl restart apache2</p>
			<p class="source-code">donnie@ubuntu20-04:~$</p>
			<p>There are no error messages, so that's good. Let's check the status:</p>
			<p class="source-code">donnie@ubuntu20-04:~$ sudo systemctl status apache2</p>
			<p class="source-code">â— apache2.service - The Apache HTTP Server</p>
			<p class="source-code">Â Â Â Â Â Loaded: loaded (/lib/systemd/system/apache2.service; enabled; vendor preset: enabled)</p>
			<p class="source-code">Â Â Â Â Drop-In: /etc/systemd/system/apache2.service.d</p>
			<p class="source-code">Â Â Â Â Â Â Â Â Â Â Â Â Â â””â”€override.conf</p>
			<p class="source-code">Â Â Â Â Â Active: active (running) since Sat 2021-04-10 21:58:22 UTC; 4s ago</p>
			<p class="source-code">. . .</p>
			<p class="source-code">. . .</p>
			<p>Yeah, that's good. So, yee-haw! We're golden, baby! But seriously, look in the <strong class="source-inline">systemd.exec</strong> man page, and you'll see a lot more security<a id="_idIndexMarker116"/> settings that you could possibly use. </p>
			<p class="callout-heading">Note</p>
			<p class="callout">You can see here that I inadvertently used <strong class="source-inline">sudo</strong> to just look at a service status. Using <strong class="source-inline">sudo</strong> with <strong class="source-inline">systemctl</strong> is a force of habit with me, but fortunately, it doesn't hurt anything if I use it when it's not needed.</p>
			<p>Just for fun, let's add in a few more security options, and then check the security status again. This time, we'll make our <strong class="source-inline">[Service]</strong> section look like this:</p>
			<p class="source-code">[Service]</p>
			<p class="source-code">ProtectHome=yes</p>
			<p class="source-code">ProtectSystem=full</p>
			<p class="source-code">PrivateDevices=yes</p>
			<p class="source-code">ProtectKernelTunables=yes</p>
			<p class="source-code">ProtectKernelModules=yes</p>
			<p class="source-code">ProtectControlGroups=yes</p>
			<p class="source-code">SystemCallFilter=@system-service</p>
			<p class="source-code">SystemCallErrorNumber=EPERM</p>
			<p class="source-code">NoNewPrivileges=yes</p>
			<p>I'll leave it to you to read about these new parameters in the <strong class="source-inline">systemd.exec</strong> man page. </p>
			<p>Once you've finished the edit, restart Apache to ensure that it will start properly. Then, run <strong class="source-inline">systemd-analyze security apache2.service</strong> again. You should see that the overall security score looks somewhat better than it did before.</p>
			<p>There are a lot more security-related parameters<a id="_idIndexMarker117"/> that you can set in your service files. Remember though, that most services require that some settings be left in an <strong class="source-inline">UNSAFE</strong> mode for them to function correctly. Your best bet is to play around with these settings for various services on a virtual machine. That way, you can get a good idea of which settings work for the various services. And for goodness' sake, thoroughly test any service modifications you want to make before you put them into production.</p>
			<p>Next, let's look at doing full edits for the Secure Shell service.</p>
			<h2 id="_idParaDest-68"><a id="_idTextAnchor069"/>Creating a full edit</h2>
			<p>Doing partial edits<a id="_idIndexMarker118"/> works great when all you want to do is add a parameter that isn't already in the service file. But, it doesn't work if you need to delete a parameter, change the value of a parameter, or add a parameter that conflicts with some other existing parameter. To do any of these things, you'll need to do a full edit. The other reason for doing full edits is just that you might want to have the full file in front of you so that you can see what you're really doing. To do a full edit of the <strong class="source-inline">ssh.service</strong> file, for example, just use the <strong class="source-inline">--full</strong> option, like this:</p>
			<p class="source-code">donnie@ubuntu20-04:~$ sudo systemctl edit --full ssh.service</p>
			<p>This time, you'll see the entire <strong class="source-inline">ssh.service</strong> file, as shown here:</p>
			<div>
				<div id="_idContainer015" class="IMG---Figure">
					<img src="image/Figure_5.2_B17491.jpg" alt=""/>
				</div>
			</div>
			<p class="figure-caption">Figure 5.2 â€“ Editing a service file with the --full option</p>
			<p>For our demo<a id="_idIndexMarker119"/> this time, let's set up access control for our Secure Shell service.</p>
			<p class="callout-heading">Pro tip</p>
			<p class="callout">If you've been on the Linux scene for a while, you might be familiar with the concept of <strong class="source-inline">tcpwrappers</strong>. It's a strange name, but the concept is simple. You would just configure the IP addresses that you'd want to allow to access a particular network service in the <strong class="source-inline">/etc/hosts.allow</strong> file, and then deny all other IP addresses in the <strong class="source-inline">/etc/hosts.deny</strong> file. This still works for Ubuntu, but the Red Hat folk have removed <strong class="source-inline">tcpwrappers</strong> from RHEL 8. So, if you want to configure access control on any RHEL 8-type distro, such as the Alma Linux 8 that we're using, you'll need to do it by configuring the service files. On Ubuntu, you can use either method.</p>
			<p>So, let's say that you want<a id="_idIndexMarker120"/> to allow SSH logins to your server from only one particular desktop machine. To do that, we'll use the <strong class="source-inline">IPAddressAllow=</strong> and the <strong class="source-inline">IPAddressDeny=</strong> parameters in the <strong class="source-inline">[Service]</strong> section of the <strong class="source-inline">ssh.service</strong> file. (Of course, that would be the <strong class="source-inline">sshd.service</strong> file if you want to try this on the Alma Linux machine.) Open the file for editing as I've just shown you and add two lines to the end of the <strong class="source-inline">[Service]</strong> section, using the IP address of your own host machine in the <strong class="source-inline">IPAddressAllow=</strong> line. The lines should look something like this:</p>
			<p class="source-code">IPAddressAllow=192.168.0.222</p>
			<p class="source-code">IPAddressDeny=any</p>
			<p>The whole file should now look something like this:</p>
			<div>
				<div id="_idContainer016" class="IMG---Figure">
					<img src="image/Figure_5.3_B17491.jpg" alt=""/>
				</div>
			</div>
			<p class="figure-caption">Figure 5.3 â€“ The ssh.service file after editing</p>
			<p>If you just insert the <strong class="source-inline">IPAddressAllow=</strong> line and don't insert the <strong class="source-inline">IPAddressDeny=</strong> line, you'll find that nothing gets blocked. So, any time you want to set up an access whitelist, you'll need to use both of these lines together.</p>
			<p>Save the file<a id="_idIndexMarker121"/> and do <strong class="source-inline">sudo systemctl daemon-reload</strong>. Then, restart or reload the Secure Shell service. Assuming that you used the correct IP address for your host machine, you should be able to log in via SSH. To really test this feature out, edit the file again, and use an incorrect IP address for your host. This time, you should be blocked from doing an SSH login. Note though, that you won't have to do another <strong class="source-inline">daemon-reload</strong> command. This new setting will take effect immediately upon saving the file. So, if you're doing this remotely, you will get locked out if you've entered an incorrect IP address for your host. In real life, you'd have to fix it by entering the server room and configuring things correctly from the server's local terminal.</p>
			<p>When you do a full edit, a complete new modified copy of the original service file will get saved in the <strong class="source-inline">/etc/systemd/system/</strong> directory, as we can see here:</p>
			<p class="source-code">donnie@ubuntu20-04:~$ cd /etc/systemd/system/</p>
			<p class="source-code">donnie@ubuntu20-04:/etc/systemd/system$ ls -l ssh.service </p>
			<p class="source-code">-rw-r--r-- 1 root root 586 Apr 11 20:07 ssh.service</p>
			<p class="source-code">donnie@ubuntu20-04:/etc/systemd/system$</p>
			<p>As long as this file exists, it will always override the original file in the <strong class="source-inline">/lib/systemd/system/</strong> directory.</p>
			<p>Next, let's look at creating a brand new service.</p>
			<h1 id="_idParaDest-69"><a id="_idTextAnchor070"/>Creating a new service</h1>
			<p>To create a brand new service<a id="_idIndexMarker122"/> from scratch, use the <strong class="source-inline">--force</strong> and <strong class="source-inline">--full</strong> options together, like this:</p>
			<p class="source-code">donnie@ubuntu20-04:~$ sudo systemctl edit --force --full timestamp.service</p>
			<p>This will create a new service file in the <strong class="source-inline">/etc/systemd/system/</strong> directory, just as we saw previously. </p>
			<p>For this demo, we'll create a service that will<a id="_idIndexMarker123"/> place a periodic timestamp into our system log file. Our <strong class="source-inline">timestamp.service</strong> file will look like this:</p>
			<p class="source-code">[Unit]</p>
			<p class="source-code">Description=Service Creation Demo</p>
			<p class="source-code">Wants=network.target</p>
			<p class="source-code">After=syslog.target network-online.target</p>
			<p class="source-code">[Service]</p>
			<p class="source-code">ExecStart=/usr/local/bin/timestamp.sh</p>
			<p class="source-code">Restart=on-failure</p>
			<p class="source-code">RestartSec=20</p>
			<p class="source-code">KillMode=process</p>
			<p class="source-code">[Install]</p>
			<p class="source-code">WantedBy=multi-user.target</p>
			<p>Here, we see the <strong class="source-inline">RestartSec=</strong> parameter, which we haven't seen before. This works with the <strong class="source-inline">Restart=</strong> line and just says to wait for the designated number of seconds before restarting a crashed service. Here, we're saying to wait for 20 seconds. We don't see a <strong class="source-inline">Type=</strong> line here, because we don't need it. Without this line, <strong class="source-inline">systemd</strong> will just go with the default of <strong class="source-inline">Type=simple</strong>, which is what we want. (I'll leave it to you to read about the <strong class="source-inline">simple</strong> <strong class="source-inline">Type</strong> in the <strong class="source-inline">systemd.service</strong> man page.)</p>
			<p>Next, we'll create the <strong class="source-inline">timestamp.sh</strong> script, which will place a timestamp into the system log file every 60 seconds. Let's make it look like this:</p>
			<p class="source-code">#!/bin/bash</p>
			<p class="source-code">echo "Starting the timestamp service" | systemd-cat -p info</p>
			<p class="source-code">while :</p>
			<p class="source-code">do</p>
			<p class="source-code">Â Â Â Â Â Â Â Â echo "timestamp.service: The current time is $(date '+%m-%d-%Y %H:%M:%S')" | systemd-cat -p info</p>
			<p class="source-code">Â Â Â Â Â Â Â Â sleep 60</p>
			<p class="source-code">done</p>
			<p>As you can see, it's just a simple <strong class="source-inline">while</strong> loop that pipes the current time into the <strong class="source-inline">systemd-cat</strong> utility every 60 seconds. In turn, <strong class="source-inline">systemd-cat</strong> sends the <strong class="source-inline">timestamp</strong> message<a id="_idIndexMarker124"/> to the system log file. The <strong class="source-inline">-p info</strong> option marks the message with an <strong class="source-inline">info</strong> level priority. </p>
			<p>Next, make the script file executable, and copy it to the <strong class="source-inline">/usr/local/bin/</strong> directory. Then, start the service:</p>
			<p class="source-code">donnie@ubuntu20-04:~$ chmod u+x timestamp.sh </p>
			<p class="source-code">donnie@ubuntu20-04:~$ sudo cp timestamp.sh /usr/local/bin</p>
			<p class="source-code">donnie@ubuntu20-04:~$ sudo systemctl start timestamp</p>
			<p class="source-code">donnie@ubuntu20-04:~$</p>
			<p>You can enable the service if you really want to, but for now, we don't need to.</p>
			<p>The status should look like this:</p>
			<p class="source-code">donnie@ubuntu20-04:~$ systemctl status timestamp</p>
			<p class="source-code">â— timestamp.service - Service Creation Demo</p>
			<p class="source-code">Â Â Â Â Â Loaded: loaded (/etc/systemd/system/timestamp.service; disabled; vendor preset: enabled)</p>
			<p class="source-code">Â Â Â Â Â Active: active (running) since Sun 2021-04-11 21:57:26 UTC; 13min ago</p>
			<p class="source-code">Â Â Â Main PID: 14293 (timestamp.sh)</p>
			<p class="source-code">Â Â Â Â Â Â Tasks: 2 (limit: 2281)</p>
			<p class="source-code">Â Â Â Â Â Memory: 820.0K</p>
			<p class="source-code">Â Â Â Â Â CGroup: /system.slice/timestamp.service</p>
			<p class="source-code">Â Â Â Â Â Â Â Â Â Â Â Â Â â”œâ”€14293 /bin/bash /usr/local/bin/timestamp.sh</p>
			<p class="source-code">Â Â Â Â Â Â Â Â Â Â Â Â Â â””â”€14411 sleep 60</p>
			<p class="source-code">Apr 11 22:00:26 ubuntu20-04 cat[14335]: timestamp.service: The current time is 04-11-2021 22:00:26</p>
			<p class="source-code">. . .</p>
			<p class="source-code">. . .</p>
			<p>To see the timestamps in the log file, do:</p>
			<p><strong class="source-inline">donnie@ubuntu20-04:~$ journalctl -xe</strong></p>
			<p>Or, you can see them getting<a id="_idIndexMarker125"/> added in real time by doing <strong class="source-inline">sudo tail -f /var/log/syslog</strong> on the Ubuntu machine, or <strong class="source-inline">sudo tail -f /var/log/messages</strong> on the Alma machine. When you've seen enough, just do <em class="italic">Ctrl</em> + <em class="italic">C</em> to quit.</p>
			<h1 id="_idParaDest-70"><a id="_idTextAnchor071"/>Changing the default systemd editor</h1>
			<p>So far, I've been showing you how to do all of this in the nano text editor, which is the default <strong class="source-inline">systemd</strong> editor<a id="_idIndexMarker126"/> for most modern Linux distros. But, what if you don't like nano, and would prefer to use something else? Let's say that Vim is your favorite text editor, and you want to use it instead of nano.</p>
			<p>One way to use an alternate text editor is to specify the alternate editor each time you run a <strong class="source-inline">systemctl edit</strong> command, like this:</p>
			<p class="source-code">[donnie@localhost ~]$ sudo EDITOR=vim systemctl edit --full sshd</p>
			<p class="source-code">[donnie@localhost ~]$</p>
			<p>That works, but doing it every time you want to run a <strong class="source-inline">systemctl edit</strong> command could get a bit tiresome. Fortunately, changing the default editor is easy, once you know how to do it.</p>
			<p>First, edit the <strong class="source-inline">.bashrc</strong> file that's in your own home directory. At the very bottom of the file, add this line:</p>
			<p class="source-code">export SYSTEMD_EDITOR=vim</p>
			<p>After saving<a id="_idIndexMarker127"/> the file, reload the new configuration:</p>
			<p class="source-code">[donnie@localhost ~]$ source .bashrc</p>
			<p class="source-code">[donnie@localhost ~]$</p>
			<p>Next, open the <strong class="source-inline">sudoers</strong> file:</p>
			<p class="source-code">[donnie@localhost ~]$ sudo visudo</p>
			<p>Scroll down to where you see the <strong class="source-inline">Defaults</strong> lines, and then add this line:</p>
			<p class="source-code">DefaultsÂ Â Â env_keep += "SYSTEMD_EDITOR"</p>
			<p>Save the file, and try running a <strong class="source-inline">systemctl edit</strong> command. You should now see vim instead of nano.</p>
			<p>We've seen some cool stuff, but we're just getting started. For the ultimate in cool, let's look at using <strong class="source-inline">podman</strong> to automatically create container service files for us.</p>
			<h1 id="_idParaDest-71"><a id="_idTextAnchor072"/>Creating a new container service with podman</h1>
			<p>Containers<a id="_idIndexMarker128"/> have been around for a long time, but they<a id="_idIndexMarker129"/> never became all that popular until Docker arrived on the scene with its new container management system. The original Docker system is cool, all right. But, it has some shortcomings, especially with security. For that reason, the good folk at Red Hat developed their own Docker replacement, which they call <strong class="source-inline">podman</strong>. <strong class="source-inline">podman</strong> comes with greatly enhanced security, and with cool features that aren't in Docker. The only problem is that <strong class="source-inline">podman</strong> is still only available on RHEL-type and Fedora distros, and everyone else still uses Docker. So, we'll perform these demos on the Alma Linux machine.</p>
			<p>To install <strong class="source-inline">podman</strong> on your Alma machine, do:</p>
			<p class="source-code">[donnie@localhost ~]$ sudo dnf install podman-docker</p>
			<p>This will install the <strong class="source-inline">podman</strong> package along with a shell script that invokes <strong class="source-inline">podman</strong> whenever you accidentally type <strong class="source-inline">docker</strong>. (Actually, that might not be by accident. You might have shell scripts that invoke <strong class="source-inline">docker</strong> commands, and installing the <strong class="source-inline">podman-docker</strong> package will prevent you from having to modify them to use <strong class="source-inline">podman</strong> commands.) To avoid confusion, I'll just be showing you <strong class="source-inline">podman</strong> commands in this demo.</p>
			<p>The <strong class="source-inline">podman</strong> utility normally<a id="_idIndexMarker130"/> doesn't need root privileges, which<a id="_idIndexMarker131"/> is one of its advantages over Docker. But, in order to make this work, we'll need to create our Docker container under the root user account. We can do that either by going to the root user shell and doing everything there or by staying in the normal user shell and prefacing the <strong class="source-inline">podman</strong> commands with <strong class="source-inline">sudo</strong>. Since I normally like to avoid going to the root shell unless I absolutely have to, we'll do this with sudo.</p>
			<p>Let's create a <strong class="source-inline">wordpress</strong> container, like this:</p>
			<p class="source-code">[donnie@localhost ~]$ sudo podman run -d -p 8080:80 --name wordpress wordpress</p>
			<p>WordPress is a free open source blogging platform. Here, we're running a <strong class="source-inline">wordpress</strong> container in <strong class="source-inline">detached</strong>, or <strong class="source-inline">background</strong>, mode with the <strong class="source-inline">-d</strong> switch. Instead of exposing the default port <strong class="source-inline">80</strong> to the network, we're exposing port <strong class="source-inline">8080</strong>. (Note that if this fails to start, you might already have something listening on port <strong class="source-inline">8080</strong>. If that's the case, try again with another port.) The <strong class="source-inline">--name</strong> switch sets the container name that we'll soon be using in the command to create the service file.</p>
			<p>We'll verify that it's running with <strong class="source-inline">sudo podman ps</strong>:</p>
			<p class="source-code">[donnie@localhost ~]$ sudo podman ps</p>
			<p class="source-code">CONTAINER IDÂ Â IMAGEÂ Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â COMMANDÂ Â Â Â Â Â Â Â Â Â Â Â Â Â Â CREATEDÂ Â Â Â Â Â Â Â STATUSÂ Â Â Â Â Â Â Â Â Â Â Â PORTSÂ Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â NAMES</p>
			<p class="source-code">cc06c35f21ceÂ Â docker.io/library/wordpress:latestÂ Â apache2-foregroun...Â Â 2 minutes agoÂ Â Up 2 minutes agoÂ Â 0.0.0.0:8080-&gt;80/tcpÂ Â wordpress</p>
			<p class="source-code">[donnie@localhost ~]$</p>
			<p>You can also try to access WordPress from your host machine's web browser, but you'll first need to open port <strong class="source-inline">8080/tcp</strong> on the Alma machine's firewall, like this:</p>
			<p class="source-code">[donnie@localhost ~]$ sudo firewall-cmd --permanent --add-port=8080/tcp</p>
			<p class="source-code">success</p>
			<p class="source-code">[donnie@localhost ~]$ sudo firewall-cmd --reload</p>
			<p class="source-code">success</p>
			<p class="source-code">[donnie@localhost ~]$</p>
			<p>Then, go to the web browser<a id="_idIndexMarker132"/> of your host machine<a id="_idIndexMarker133"/> and navigate to port <strong class="source-inline">8080</strong> of the IP address of your Alma machine. The URL should look something like this:</p>
			<p><a href="http://192.168.0.9:8080/">http://192.168.0.9:8080/</a></p>
			<p>This should pull up the opening WordPress screen, which will lead you through the setup process. </p>
			<p>Okay, that's great, except that when you reboot the machine, the container won't start back up automatically. To fix that, we'll use the <strong class="source-inline">sudo podman generate systemd</strong> command to create the service file, as follows:</p>
			<p class="source-code">[donnie@localhost ~]$ sudo podman generate systemd wordpress | sudo tee /etc/systemd/system/wordpress-container.service</p>
			<p>Note that using <strong class="source-inline">sudo</strong> to do a normal redirection with the <strong class="source-inline">&gt;</strong> symbol doesn't work well in the <strong class="source-inline">/etc/</strong> directory, but piping the output into the <strong class="source-inline">tee</strong> utility does. As you'll see, the <strong class="source-inline">tee</strong> utility sends output to both the screen and to a specified file.</p>
			<p>Doing <strong class="source-inline">systemctl cat wordpress-container</strong> will show you the generated service file:</p>
			<div>
				<div id="_idContainer017" class="IMG---Figure">
					<img src="image/Figure_5.4_B17491.jpg" alt=""/>
				</div>
			</div>
			<p class="figure-caption">Figure 5.4 â€“ The podman-generated service file</p>
			<p>Now, if that isn't slick, I don't know what is. Let's enable the service<a id="_idIndexMarker134"/> and reboot, just to see<a id="_idIndexMarker135"/> what happens:</p>
			<p class="source-code">[donnie@localhost ~]$ sudo systemctl daemon-reload</p>
			<p class="source-code">[donnie@localhost ~]$ sudo systemctl enable wordpress-container</p>
			<p class="source-code">Created symlink /etc/systemd/system/multi-user.target.wants/wordpress-container.service â†’ /etc/systemd/system/wordpress-container.service.</p>
			<p class="source-code">Created symlink /etc/systemd/system/default.target.wants/wordpress-container.service â†’ /etc/systemd/system/wordpress-container.service.</p>
			<p class="source-code">[donnie@localhost ~]$ sudo shutdown -r now</p>
			<p>When the reboot is complete, a <strong class="source-inline">sudo podman ps</strong> command should show you that the container is running:</p>
			<p class="source-code">[donnie@localhost ~]$ sudo podman ps</p>
			<p class="source-code">[sudo] password for donnie: </p>
			<p class="source-code">CONTAINER IDÂ Â IMAGEÂ Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â COMMANDÂ Â Â Â Â Â Â Â Â Â Â Â Â Â Â CREATEDÂ Â Â Â Â Â Â Â Â STATUSÂ Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â PORTS Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â NAMES</p>
			<p class="source-code">cc06c35f21ceÂ Â docker.io/library/wordpress:latestÂ Â apache2-foregroun...Â Â 12 minutes agoÂ Â Up About a minute agoÂ Â 0.0.0.0:8080-&gt;80/tcpÂ Â wordpress</p>
			<p class="source-code">[donnie@localhost ~]$</p>
			<p>(You'll need to use <strong class="source-inline">sudo</strong> here only because the container is running under the root user's account.)</p>
			<p>And of course, <strong class="source-inline">systemctl status</strong> should also show you that it's running:</p>
			<p class="source-code">[donnie@localhost ~]$ systemctl status wordpress-container</p>
			<p class="source-code">â— wordpress-container.service - Podman container-cc06c35f21cedd4d2384cf2c048f013748e84cabdc594b110a8c8529173f4c81.service</p>
			<p class="source-code">Â Â Â Loaded: loaded (/etc/systemd/system/wordpress-container.service; enabled; vendor preset: disabled)</p>
			<p class="source-code">Â Â Â Active: active (running) since Wed 2021-04-14 15:27:37 EDT; 2min 38s ago</p>
			<p class="source-code">. . .</p>
			<p class="source-code">. . .</p>
			<p>Okay, that's all good. But, what if you need to create<a id="_idIndexMarker136"/> a container service that you want<a id="_idIndexMarker137"/> to run from your own user account without root privileges? Well, we've got you covered there, too. Just create the service file in your own home directory, and run it from there.</p>
			<p>We'll start as we did before, except with a different container name and from our normal user shell, like so:</p>
			<p class="source-code">[donnie@localhost ~]$ podman run -d -p 9080:80 --name wordpress-noroot wordpress</p>
			<p>We're using a different network port this time, so that it won't conflict with what we've already done. For now, let's stop the container:</p>
			<p class="source-code">[donnie@localhost ~]$ podman container stop wordpress-noroot</p>
			<p class="source-code">a6e2117dd4d5148d01a55d64ad8753c03436bfd9a573435e95d927f74 dc48f9e</p>
			<p class="source-code">[donnie@localhost ~]$</p>
			<p>We'll next create a subdirectory within the user's own normal home directory:</p>
			<p class="source-code">[donnie@localhost ~]$ mkdir -p .config/systemd/user/</p>
			<p class="source-code">[donnie@localhost ~]$</p>
			<p>We'll generate the service file, the same as we did before:</p>
			<p class="source-code">[donnie@localhost ~]$ podman generate systemd wordpress-noroot &gt; .config/systemd/user/wordpress-noroot.service</p>
			<p class="source-code">[donnie@localhost ~]$</p>
			<p>I forgot to point out before<a id="_idIndexMarker138"/> that there's a slight difference<a id="_idIndexMarker139"/> in the <strong class="source-inline">[Install]</strong> section of these generated service files. Instead of seeing only one target listed, you'll see two, as shown here:</p>
			<p class="source-code">. . .</p>
			<p class="source-code">. . .</p>
			<p class="source-code">[Install]</p>
			<p class="source-code">WantedBy=multi-user.target default.target</p>
			<p><strong class="source-inline">Default.target</strong> is needed whenever you want to run a service from your own user account. From here on out, the management commands are mostly the same, except that you won't need <strong class="source-inline">sudo</strong> and you'll need to use the <strong class="source-inline">--user</strong> option to tell <strong class="source-inline">systemd</strong> that the service unit file is in your own home directory. Let's load the new service file, and check the status:</p>
			<p class="source-code">[donnie@localhost ~]$ systemctl --user daemon-reload</p>
			<p class="source-code">[donnie@localhost ~]$ systemctl --user status wordpress-noroot</p>
			<p class="source-code">â— wordpress-noroot.service - Podman container-a6e2117dd4d5148d01a55d64ad8753c03436bfd9a573435e95d927f74dc48f9e.service</p>
			<p class="source-code">Â Â Â Loaded: loaded (/home/donnie/.config/systemd/user/wordpress-noroot.service; disabled; vendor preset: enabled)</p>
			<p class="source-code">Â Â Â Active: inactive (dead)</p>
			<p class="source-code">. . .</p>
			<p class="source-code">. . .</p>
			<p>Let's enable it and start it, and check the status again:</p>
			<p class="source-code">[donnie@localhost ~]$ systemctl --user enable --now wordpress-noroot</p>
			<p class="source-code">Created symlink /home/donnie/.config/systemd/user/multi-user.target.wants/wordpress-noroot.service â†’ /home/donnie/.config/systemd/user/wordpress-noroot.service.</p>
			<p class="source-code">Created symlink /home/donnie/.config/systemd/user/default.target.wants/wordpress-noroot.service â†’ /home/donnie/.config/systemd/user/wordpress-noroot.service.</p>
			<p class="source-code">[donnie@localhost ~]$ systemctl --user status wordpress-noroot</p>
			<p class="source-code">â— wordpress-noroot.service - Podman container-a6e2117dd4d5148d01a55d64ad8753c03436bfd9a573435e95d927f74dc48f9e.service</p>
			<p class="source-code">Â Â Â Loaded: loaded (/home/donnie/.config/systemd/user/wordpress-noroot.service; enabled; vendor preset: enabled)</p>
			<p class="source-code">Â Â Â Active: active (running) since Wed 2021-04-14 15:44:26 EDT; 12s ago</p>
			<p class="source-code">. . .</p>
			<p class="source-code">. . .</p>
			<p>If you have root privileges, you can<a id="_idIndexMarker140"/> open port <strong class="source-inline">9080/tcp</strong> on the<a id="_idIndexMarker141"/> firewall and access WordPress from an external machine, just as we did before.</p>
			<p>As things stand now, our rootless WordPress service won't automatically start when you boot the machine. But, it will start when you log into the machine and will stop when you log out. Fix that by doing the following for your own user account:</p>
			<p class="source-code">[donnie@localhost ~]$ loginctl enable-linger donnie</p>
			<p class="source-code">[donnie@localhost ~]$</p>
			<p>Now, the container service will remain running when I log out and will automatically start when I reboot the machine.</p>
			<h1 id="_idParaDest-72"><a id="_idTextAnchor073"/>Summary</h1>
			<p>In this chapter, we looked at how to edit and create service unit files. Along the way, we looked at various parameters that we can set, including several security-related ones. We also saw the importance of testing any changes that we make to the service files before putting them into production. And of course, there's that one thing that I keep pointing out, about the importance of knowing how to use the <strong class="source-inline">systemd</strong> man pages.</p>
			<p>In the next chapter, we'll look at <strong class="source-inline">systemd</strong> targets. I'll see you there.</p>
			<h1 id="_idParaDest-73"><a id="_idTextAnchor074"/>Questions</h1>
			<ol>
				<li value="1">How would you do a partial edit of the <strong class="source-inline">ssh.service</strong> file?<p>a) <strong class="source-inline">sudo systemctl edit --partial ssh.service</strong></p><p>b) <strong class="source-inline">sudo systemctl edit ssh.service</strong></p><p>c) <strong class="source-inline">sudo systemedit ssh.service</strong></p><p>d) <strong class="source-inline">sudo systemedit --partial ssh.service</strong></p></li>
				<li>How would you create a brand-new service?<p>a) <strong class="source-inline">sudo systemctl edit --new newservice.service</strong></p><p>b) <strong class="source-inline">sudo systemctl edit --full newservice.service</strong></p><p>c) <strong class="source-inline">sudo systemctl edit --full --force newservice.service</strong></p><p>d) <strong class="source-inline">sudo systemctl edit newservice.service</strong></p></li>
				<li>How would you create an access whitelist for a service?<p>a) Just insert an <strong class="source-inline">IPAddressAllow=</strong> directive into the <strong class="source-inline">[Service]</strong> section.</p><p>b) Insert both an <strong class="source-inline">IPAddressAllow=</strong> directive and an <strong class="source-inline">IPAddressDeny=</strong> directive in the <strong class="source-inline">[Service]</strong> section.</p><p>c) Just insert an <strong class="source-inline">IPAddressAllow=</strong> directive into the <strong class="source-inline">[Unit]</strong> section.</p><p>d) Insert both an <strong class="source-inline">IPAddressAllow=</strong> directive and an <strong class="source-inline">IPAddressDeny=</strong> directive in the <strong class="source-inline">[Unit]</strong> section.</p></li>
			</ol>
			<h1 id="_idParaDest-74"><a id="_idTextAnchor075"/>Answers</h1>
			<p>b</p>
			<p>c</p>
			<p>b</p>
			<h1 id="_idParaDest-75"><a id="_idTextAnchor076"/>Further reading</h1>
			<ul>
				<li>How to create <strong class="source-inline">systemd</strong> service files: <a href="https://linuxconfig.org/how-to-create-systemd-service-unit-in-linux">https://linuxconfig.org/how-to-create-systemd-service-unit-in-linux</a></li>
				<li>Securing and sandboxing applications and services: <a href="https://www.redhat.com/sysadmin/mastering-systemd">https://www.redhat.com/sysadmin/mastering-systemd</a></li>
				<li>Managing containers in <strong class="source-inline">podman</strong> with <strong class="source-inline">systemd</strong> unit files: <a href="https://youtu.be/AGkM2jGT61Y">https://youtu.be/AGkM2jGT61Y</a></li>
			</ul>
		</div>
	</body></html>