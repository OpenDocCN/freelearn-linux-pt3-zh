["```\n$ArrayList = [System.Collections.ArrayList]@()\n1..10000 | ForEach-Object { $Null = $ArrayList.Add($_) }\n```", "```\n[System.AppDomain]::CurrentDomain.GetAssemblies()\n```", "```\nusing namespace System.IO\n```", "```\n$string1 = ([System.Text.StringBuilder]::new(32))\n$string2 = ([System.Text.StringBuilder]::new('32'))\n```", "```\n$string1.tostring()\n$string2.tostring()\n```", "```\n[System.AppDomain]::CurrentDomain.GetAssemblies()\n```", "```\n[System.AppDomain]::CurrentDomain.GetAssemblies() | select FullName\n```", "```\nAdd-Type -AssemblyName PresentationCore,PresentationFramework\n```", "```\n$loveit = (New-Object -TypeName System.Text.StringBuilder -ArgumentList \"i love powershell\", 128)\n```", "```\n$timer = (New-Object -TypeName System.Timers.Timer -Property @{\nAutoReset = $true\nInterval = 5000\nEnabled = $true\n}\n)\n```", "```\nRegister-ObjectEvent -InputObject $timer -EventName Elapsed -SourceIdentifier Test -Action {Write-Host \"hello\"}\n```", "```\n$timer.start()\n```", "```\n$timer.stop()\n```", "```\nAdd-Type -AssemblyName PresentationCore,PresentationFramework\n$Button = [System.Windows.MessageBoxButton]::YesNo\n$Title = \"PowerShell for Everyone\"\n$Body = \"Do you love PowerShell?\"\n$Icon = [System.Windows.MessageBoxImage]::Warning\n[System.Windows.MessageBox]::Show($Body,$Title,$Button,$Icon)\n```", "```\n    kill(). Charming, right? CloseMainWindow() might work for a graphical process, and Close() will ask politely, but kill() should do it. Note that sometimes it won’t, for instance, if the process you are trying to kill is running with higher privileges than the account you are running PowerShell with.You can use it like this. Here’s my list of `pwsh` processes:\n    ```", "```\n    -skip parameter will skip from the start, unless it is combined with -last. However, it is not positional, so if we specify both the -first and -last parameters, -skip will always skip from the start of the array; it doesn’t matter where we put it in the cmdlet:\n    ```", "```\n    ForEach-Object here, like this:\n\n    ```", "```\n\n    ```", "```\n    shutdown command and can’t work against remote machines. Hopefully, you followed the instructions not to try it, as it will ignore the bobscomputer string and shut down your local machine if you don’t include the -WhatIf parameter.\n    ```", "```\n    $x = 42\n    $y = 23\n    $y.CompareTo($x)\n    ```", "```\n    $OrderedHash = [ordered]@{a=10;b=20;c=30}\n    ```", "```\n    $processes = Get-process ; foreach ($process in $processes) {$process.name}\n    ```", "```\n$TheTrial = Get-Content -Path .\\thetrial.txt -Raw\n$StopWords = Get-Content -Path .\\stopwords.txt -Raw\n$TrialWords = $TheTrial.Split(\" \", \"`t\", \"`n\", \",\",\"`\"\",\".\", [System. StringSplitOptions]::RemoveEmptyEntries)\n$Words = [System.Collections.ArrayList]@()\nForeach ($Word in $TrialWords) {\n$LWord = $Word.ToLower()\nif (!($StopWords.Contains($LWord))) {\n$Words.Add($Word)\n}\n}\n$Grouped = ($Words | Group-Object | Sort-Object Count)\n$Grouped[-1 .. -10]\n```", "```\n    Get-Process | Where-Object id -gt 100 | Format-Wide -column 5\n    ```", "```\nTable {\ncolor: white;\ntext-align: left;\nbackground-color: black;\n}\nBody {\nbackground-image: url(\"iss.jpg\");\nbackground-size: cover;\nbackground-repeat: no-repeat;\nbackground-color: black;\nfont-family: 'Trebuchet MS';\ncolor: yellow;\n}\n```", "```\n    (Invoke-RestMethod 'http://universities. hipolabs.com/search?country=United+kingdom').name | Where-Object {$_ -like '*x*'} | Measure | select -Property 'count'.I get `8`, but this is subject to change.\n    ```", "```\n    [CmdletBinding()]\n    Param(\n    $City = \"London\",\n    $Output = \"c:\\temp\\poshbook\\ch8\\WeatherData.html\"\n    )\n    $headers = @{\"key\" = \"<Key>\"}\n    $uri = \"https://api.weatherapi.com/v1/current.json?q=$($City)&aqi=no\"\n    $response = Invoke-RestMethod -Uri $uri -Method GET -Headers $headers\n    $response | Convertto-Html | Out-File $Output\n    ```", "```\n    <#\n    .SYNOPSIS\n    Gathers weather data for a number of cities and stores the API output.\n    .DESCRIPTION\n    This cmdlet will gather the current weather data from a number of cities from\n    the API endpoint at https://api.weatherapi.com and outputs the responses to a\n    set of named HTML files stored in the specified directory.\n    The -City parameter takes an array of strings, either explicitly or via the\n    pipeline (ByValue).\n    The -OutputFile parameter takes a single string specifying the filename and\n    suffix. This filename will be prefixed by the string provided in the -City\n    parameter, eg. London_WeatherData.html\n    The -OutptPath parameter specifies a location for the output file.\n    The -Key parameter specifies a txt file that contains the key from\n    weatherapi.com\n    .NOTES\n    This script requires a personal API key from https://weatherapi. com\n    The output path will need to exist before running the script\n    .LINK\n    No link, sorry.\n    .EXAMPLE\n    .\\weatherdata.ps1 -City london,paris\n    This will generate two html files; one for London and one for Paris\n    #>\n    ```", "```\n    Unrestricted.\n    ```", "```\n    [CmdletBinding()]\n    param(\n    $Sides = 20\n    )\n    get-random -minimum 1 -Maximum $Sides\n    ```", "```\n    [int]$Sides = 20\n    ```", "```\n    [CmdletBinding()]\n    param(\n    [ValidateSet(4,6,8,10,12,20)]\n    [int]$Sides = 20\n    )\n    get-random -minimum 1 -Maximum $Sides\n    ```", "```\n    [CmdletBinding()]\n    param(\n    [ValidateSet(4,6,8,10,12,20)]\n    [int]$Sides = 20,\n    [int]$Dice\n    )\n    $total = 0\n    while ($Dice -gt 0) {\n    $result = (Get-Random -Minimum 1 -Maximum $Sides)\n    $Dice -= 1\n    $total += $result\n    write-output \"die says $result\"\n    }\n    Write-Output \"The total is $total\"\n    ```", "```\n    param(\n    [ValidateSet(4,6,8,10,12,20)]\n    [int]$Sides = 20,\n    [Parameter(Mandatory)]\n    [int]$Dice\n    )\n    ```", "```\n    function Remove-Log {\n    $limit = (Get-Date).AddDays(-7)\n    Get-ChildItem -Path \"C:\\temp\" -Include \"MyLogFile*\" -Recurse -Force |\n    Where-Object {$_.CreationTime -lt $limit} |\n    Remove-Item -Force\n    }\n    ```", "```\n    Function get-root($a) {\n    <what goes here?>\n    }\n    [math]::Sqrt($a)\n    ```", "```\n    Invoke-CimMethod like this:\n    ```", "```\nif ($IsWindows) {\n$computername = $env:COMPUTERNAME\n}\nelseif ($IsLinux) {\n$computername = (hostname)\n}\nGet-Process |\nSort-Object -Property CPU -Descending |\nSelect-Object -First 5 |\nOut-File \"$($computername)_processes.txt\"\n```"]