<html><head></head><body>
		<div id="_idContainer268">
			<h1 id="_idParaDest-275" class="chapter-number"><a id="_idTextAnchor280"/>14</h1>
			<h1 id="_idParaDest-276"><a id="_idTextAnchor281"/>PowerShell 7 for Linux and macOS</h1>
			<p>It is commonly said that Linux is the most popular operating system for servers, and while this is true, it doesn’t acknowledge that there are nearly as many types of Linux as there are actual servers. Whereas Windows and macOS are closely engineered and maintained by companies that are concerned that everybody should be running homogenous, secure, and often forcibly updated code, the Linux world is far more unrestricted, with a multiplicity of free, open source, and often barely maintained variations that seem to hang around on servers for years or sometimes decades. In this chapter, we’re going to look at how we can use PowerShell on some of the more common varieties of Linux; in our case, Ubuntu and CentOS, a free <a id="_idIndexMarker985"/>version of <strong class="bold">Red Hat Enterprise </strong><span class="No-Break"><strong class="bold">Linux</strong></span><span class="No-Break"> (</span><span class="No-Break"><strong class="bold">RHEL</strong></span><span class="No-Break">).</span></p>
			<p>We’re going to start by looking at how we can get access to a Linux machine to practice on; without that, this chapter would be pretty boring. Once we’ve got a machine, we will look at three different ways of installing PowerShell, using package managers and <span class="No-Break">direct download.</span></p>
			<p>After that, we’ll install VS Code and see how to set it up on CentOS 7 before going on to look at some of the main differences we will see running PowerShell on Linux rather <span class="No-Break">than Windows.</span></p>
			<p>We will look at one of the most common ways of using PowerShell on Linux: remote sessions over<a id="_idIndexMarker986"/> the <strong class="bold">Secure Shell</strong> (<strong class="bold">SSH</strong>) protocol. This is important and is easily the most common way I see people logging in to <span class="No-Break">Linux machines.</span></p>
			<p>Finally, we’ll take a quick look at how easy it is to install PowerShell and VS Code on macOS using the free open source package <span class="No-Break">manager, Homebrew.</span></p>
			<p>The main topics we will cover in this chapter are <span class="No-Break">the following:</span></p>
			<ul>
				<li>Installing <span class="No-Break">PowerShell 7</span></li>
				<li>Installing <span class="No-Break">VS Code</span></li>
				<li>Running PowerShell <span class="No-Break">on Linux</span></li>
				<li>Remoting <span class="No-Break">with OpenSSH</span></li>
				<li>PowerShell <span class="No-Break">for macOS</span></li>
			</ul>
			<h1 id="_idParaDest-277"><a id="_idTextAnchor282"/>Technical requirements</h1>
			<p>Unless we already have a client running some form of Linux, we’ll need a Linux device to work on. There’s a really easy way to get one and a slightly harder way to get one. I’ve done both on my machine to get the screenshots for this chapter, providing a Ubuntu server (with no graphical interface) and a CentOS <span class="No-Break">desktop client.</span></p>
			<p>The Ubuntu server is very easy <span class="No-Break">to install:</span></p>
			<ol>
				<li>Go to <strong class="bold">Control Panel</strong> | <strong class="bold">Programs and Features</strong> | <strong class="bold">Turn Windows features on and off</strong> and <a id="_idIndexMarker987"/>make sure the checkbox for <strong class="bold">Windows Subsystem for Linux</strong> is checked, <span class="No-Break">like this:</span></li>
			</ol>
			<div>
				<div id="_idContainer254" class="IMG---Figure">
					<img src="image/B17600_14_1.jpg" alt="Figure 14.1 – Enabling Windows Subsystem for Linux"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 14.1 – Enabling Windows Subsystem for Linux</p>
			<p class="list-inset"><strong class="bold">Windows Subsystem for Linux</strong> is displayed inside the <span class="No-Break">red box.</span></p>
			<ol>
				<li value="2">Once <strong class="bold">Windows Subsystem for Linux</strong> (<strong class="bold">WSL</strong>) is enabled, reboot, go to the Microsoft <a id="_idIndexMarker988"/>Store (<a href="https://apps.microsoft.com">https://apps.microsoft.com</a>), and select a Linux application. I’m using the latest version of Ubuntu – <span class="No-Break">22.04:</span></li>
			</ol>
			<div>
				<div id="_idContainer255" class="IMG---Figure">
					<img src="image/B17600_14_2.jpg" alt="Figure 14.2 – An Ubuntu app on the Microsoft Store"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 14.2 – An Ubuntu app on the Microsoft Store</p>
			<p class="list-inset">All I’ve done here is <a id="_idIndexMarker989"/>search for Ubuntu in the search box and select the most <span class="No-Break">recent app.</span></p>
			<ol>
				<li value="3">Click on <strong class="bold">Install</strong>, and a Microsoft Store window will open; click on <strong class="bold">Get</strong>, and once the app is downloaded, the button will change <span class="No-Break">to </span><span class="No-Break"><strong class="bold">Open</strong></span><span class="No-Break">:</span></li>
			</ol>
			<div>
				<div id="_idContainer256" class="IMG---Figure">
					<img src="image/B17600_14_3.jpg" alt="Figure 14.3 – The Microsoft Store app"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 14.3 – The Microsoft Store app</p>
			<ol>
				<li value="4">Click <strong class="bold">Open</strong>, and a terminal<a id="_idIndexMarker990"/> window will open, with a message saying <strong class="source-inline">Installing, this may take a few minutes...</strong>. After a few minutes, we’ll be asked to create a username and then input a password twice, and that’s it. We now have a Ubuntu server running inside WSL <span class="No-Break">on Windows:</span></li>
			</ol>
			<div>
				<div id="_idContainer257" class="IMG---Figure">
					<img src="image/B17600_14_4.jpg" alt="Figure 14.4 – Ubuntu on WSL"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 14.4 – Ubuntu on WSL</p>
			<p class="list-inset">In the first line, I’ve<a id="_idIndexMarker991"/> created a new username, <strong class="source-inline">nickp</strong> (imaginative), and in the second and third, I’ve input the new password. Ubuntu hides the password when you type, but unlike Windows, it doesn’t do it by displaying dots or asterisks. It just <span class="No-Break">displays... nothing.</span></p>
			<p>And that’s it – our Ubuntu environment is ready to have <span class="No-Break">PowerShell installed.</span></p>
			<p class="callout-heading">Note</p>
			<p class="callout">These instructions are for Windows 10 Pro build 19045. Different platforms such as Windows 11 or Windows Server may have different instructions for installing WSL. Also, this is WSL. There is another version called WSL2 for later <span class="No-Break">operating systems.</span></p>
			<p>I’ve also installed CentOS into Oracle VirtualBox; it would work just as well from the Microsoft Store, but I want a separate machine with a GUI we can use for <span class="No-Break">this chapter.</span></p>
			<p>Instructions for installing VirtualBox are <span class="No-Break">available here:</span></p>
			<p><a href="https://www.virtualbox.org/manual/UserManual.html#installation"><span class="No-Break">https://www.virtualbox.org/manual/UserManual.html#installation</span></a></p>
			<p>It’s <span class="No-Break">pretty straightforward.</span></p>
			<p>Once VirtualBox is installed, we’ll need to download a CentOS image <span class="No-Break">from here:</span></p>
			<p><a href="http://isoredirect.centos.org/centos/7/isos"><span class="No-Break">http://isoredirect.centos.org/centos/7/isos</span></a></p>
			<p>And we need to create a VM to install it on. There are good instructions for that <span class="No-Break">here: </span><a href="https://www.linuxfordevices.com/tutorials/centos/centos-on-virtualbox"><span class="No-Break">https://www.linuxfordevices.com/tutorials/centos/centos-on-virtualbox</span></a><span class="No-Break">.</span></p>
			<p>I’ve installed CentOS 7 with a GNOME desktop GUI so that we can have a look at how to install PowerShell on older operating systems; I find that a lot of the Linux systems I work with are getting on a bit. I’m still using Ubuntu 12.04 in some places. Precise Pangolin was a great name for an operating system, but really, we should all be on Jammy Jellyfish – at least for the sake <span class="No-Break">of security.</span></p>
			<p>Finally, to follow the section on macOS, we’ll need a Mac of some description. I’m an absolute cheapskate, so I’ve borrowed a MacBook from my friend Paul that’s running OS 13, Ventura, which is pretty recent. <span class="No-Break">Thanks, Paul.</span></p>
			<p>Now we’ve covered the sort of environment we’ll need and how to install it, let’s look at <span class="No-Break">installing PowerShell.</span></p>
			<h1 id="_idParaDest-278"><a id="_idTextAnchor283"/>Installing PowerShell 7</h1>
			<p>Somewha<a id="_idIndexMarker992"/>t perversely, I find that installing PowerShell on Linux is probably easier than installing it on Windows, despite PowerShell being developed for Windows. Microsoft publishes good scripts that we can use for the supported versions of Linux; note, though, that there are very few supported flavors: RHEL, Ubuntu, Alpine, <span class="No-Break">and Debian.</span></p>
			<p>This doesn’t mean we can’t install PowerShell on other versions, only that Microsoft doesn’t provide any support for us. Microsoft only supports specific recent versions as well. Because of the rate at which both operating systems change, it’s worth making sure that our versions of PowerShell and Linux are on the supportability matrix; otherwise, we may get unexpected results, as we will see when we look at installing <span class="No-Break">on CentOS.</span></p>
			<p>Let’s start with Ubuntu, which I’ve got running in WSL on my Windows <span class="No-Break">10 client.</span></p>
			<h2 id="_idParaDest-279"><a id="_idTextAnchor284"/>Installing PowerShell on Ubuntu 22.04</h2>
			<p>In this section, we <a id="_idIndexMarker993"/>are going to install PowerShell 7.4 on<a id="_idIndexMarker994"/> Ubuntu 22.04. Ubuntu is running inside WSL on my Windows 10 client, but it will work just as well on a VM or a physical machine. There are detailed alternative instructions <span class="No-Break">here: </span><a href="https://learn.microsoft.com/en-us/powershell/scripting/install/install-ubuntu"><span class="No-Break">https://learn.microsoft.com/en-us/powershell/scripting/install/install-ubuntu</span></a><span class="No-Break">.</span></p>
			<p>Let’s have a go. We’re going to run the commands <span class="No-Break">shown next:</span></p>
			<ol>
				<li>In the first line, we are updating the local packages with the latest versions from the default repositories. This is good practice before installing any software on Linux. We use the <strong class="source-inline">sudo</strong> command to tell Linux that we want to use administrator privileges, or root privileges, to run the command. Obviously, to do that, we need to actually have those privileges, and we will be asked to input our account password to confirm that before we can run <span class="No-Break">the command:</span><pre class="source-code">
<strong class="bold">sudo apt-get update</strong></pre></li>				<li>In the second line, we’re installing some <span class="No-Break">prerequisite packages:</span><pre class="source-code">
<strong class="bold">sudo apt-get install -y wget apt-transport-https software-properties-common</strong></pre></li>				<li>In the third line, we are grabbing the exact version of the operating system and then using that in the <span class="No-Break">fourth line:</span><pre class="source-code">
<strong class="bold">source /etc/os-release</strong></pre></li>				<li>We use <strong class="source-inline">wget</strong> to download the correct repository package for our operating system. This is the Linux package repository for Microsoft products, abbreviated <strong class="bold">PMC</strong> (short <a id="_idIndexMarker995"/><span class="No-Break">for </span><span class="No-Break"><strong class="bold">packages.microsoft.com</strong></span><span class="No-Break">):</span><pre class="source-code">
<strong class="bold">wget -q https://packages.microsoft.com/config/ubuntu/$VERSION_ID/packages-microsoft-prod.deb</strong></pre></li>				<li>In the fifth line, we’re registering PMC with <strong class="source-inline">dpkg</strong>, the Ubuntu package <span class="No-Break">management system:</span><pre class="source-code">
<strong class="bold">sudo dpkg -i packages-microsoft-prod.deb</strong></pre></li>				<li>In the sixth line, we’re deleting the key file <span class="No-Break">for security:</span><pre class="source-code">
<strong class="bold">rm packages-microsoft-prod.deb</strong></pre></li>				<li>In the seventh line, we’re running <strong class="source-inline">sudo apt-get update</strong> again to make sure we’ve got the latest list of packages for the <span class="No-Break">new repository:</span><pre class="source-code">
<strong class="bold">sudo apt-get update</strong></pre></li>				<li>Finally, in the eighth line, we’re <span class="No-Break">installing PowerShell:</span><pre class="source-code">
<strong class="bold">sudo apt-get install -y powershell</strong></pre></li>			</ol>
			<p>Linux is quite chatty, and we’ll see 60 or 70 lines of output as we type the preceding commands, but the process is very straightforward and <span class="No-Break">works well.</span></p>
			<p>To start PowerShell, we <a id="_idIndexMarker996"/>simply type <strong class="source-inline">pwsh</strong>, and we <a id="_idIndexMarker997"/>will be taken to a PowerShell prompt, as in the <span class="No-Break">following screenshot:</span></p>
			<div>
				<div id="_idContainer258" class="IMG---Figure">
					<img src="image/B17600_14_5.jpg" alt="Figure 14.5 – Starting PowerShell on Ubuntu"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 14.5 – Starting PowerShell on Ubuntu</p>
			<p>In the preceding screenshot, I started PowerShell with <strong class="source-inline">pwsh</strong>. Once PowerShell started, I called the <strong class="source-inline">$PSVersionTable</strong> automatic variable to get some information about the environment, including the version of PowerShell, the edition, and which operating system is running. I closed PowerShell by typing <strong class="source-inline">exit</strong>. If I’d wanted to keep PowerShell running in the background, I could have typed <strong class="source-inline">bash</strong> and gone to a Bash prompt instead. As we can see, we get the same color coding on Linux that we see on Windows, which helps to keep the experience consistent <span class="No-Break">across platforms.</span></p>
			<p>It’s good to know that tab completion works in Linux as well. One of the things that trips me up most often with Linux is capitalization; PowerShell on Windows has made me lazy. Therefore, being able to use tabs to complete paths is really useful. Note that PowerShell itself is not<a id="_idIndexMarker998"/> case-sensitive on Linux; <strong class="source-inline">get-process</strong> works<a id="_idIndexMarker999"/> just as well <span class="No-Break">as </span><span class="No-Break"><strong class="source-inline">Get-Process</strong></span><span class="No-Break">.</span></p>
			<p>Let’s look now at installing PowerShell <span class="No-Break">on CentOS.</span></p>
			<h2 id="_idParaDest-280"><a id="_idTextAnchor285"/>Installing PowerShell on CentOS 8 and 9</h2>
			<p>Installing the <a id="_idIndexMarker1000"/>latest version of PowerShell on<a id="_idIndexMarker1001"/> recent <a id="_idIndexMarker1002"/>versions of CentOS, CentOS 8, or CentOS 9 (and also RHEL and Fedora) is very similar to installing it on Ubuntu, but using the <strong class="source-inline">yum</strong> package manager for RHEL 8 or the <strong class="source-inline">dnf</strong> package manager for RHEL 9; if anything, it’s even easier. Do note, however, that Microsoft only officially supports PowerShell on RHEL, not on CentOS or Fedora. We’re going to run the commands <span class="No-Break">shown next:</span></p>
			<ol>
				<li>In the first line, we’re using the <strong class="source-inline">curl</strong> application rather than <strong class="source-inline">wget</strong> to <span class="No-Break">fetch PCM:</span><pre class="source-code">
<strong class="bold">curl -ssl -O https://packages.microsoft.com/config/rhel/8/packages-microsoft-prod.rpm</strong></pre></li>				<li>In the second line, we’re registering the repository with <strong class="source-inline">rpm</strong>, the <span class="No-Break">package manager:</span><pre class="source-code">
<strong class="bold">sudo rpm -i packages-microsoft-prod.rpm</strong></pre></li>				<li>In the third line, we’re removing the key <span class="No-Break">files, again:</span><pre class="source-code">
<strong class="bold">rm packages-microsoft-prod.rpm</strong></pre></li>				<li>In the fourth line, we’re updating the package lists now we’ve registered the <span class="No-Break">new repository:</span><pre class="source-code">
<strong class="bold">sudo dnf update</strong></pre></li>				<li>In the final line, we are installing PowerShell. The <strong class="source-inline">-y</strong> switch at the end specifies that we are answering <strong class="source-inline">yes</strong> to all questions. We can start PowerShell using <strong class="source-inline">pwsh</strong>, again, just like <span class="No-Break">on Ubuntu:</span><pre class="source-code">
<strong class="bold">sudo dnf install powershell </strong><strong class="bold">-</strong><strong class="bold">y</strong></pre></li>			</ol>
			<p class="callout-heading">Troubleshooting tip</p>
			<p class="callout">If this doesn’t work, there’s a pretty good chance that it’s the proxy settings. There are at least three different places in CentOS where we might find the proxy settings. For <strong class="source-inline">yum</strong>, it’s <strong class="source-inline">/etc/yum.conf</strong>. For <strong class="source-inline">dnf</strong>, it’s <strong class="source-inline">/etc/dnf/dnf.conf</strong>. </p>
			<p>What happens if we want to use PowerShell on an older version, though? We must install a specific older version <span class="No-Break">of PowerShell.</span></p>
			<p>For RHEL 7 (and, therefore, CentOS 7), the last definitely good version of PowerShell was 7.2. Early releases of 7.3 work, but later releases don’t, as they rely on Linux libraries that aren’t compatible with CentOS 7. What we see if we try to install a recent version of <a id="_idIndexMarker1003"/>PowerShell <a id="_idIndexMarker1004"/>are<a id="_idIndexMarker1005"/> error messages such <span class="No-Break">as this:</span></p>
			<pre class="console">
GLIBCXX_3.4.21 not found (required by pwsh)</pre>			<p>The answer here is to install PowerShell 7.2. Let’s see how we <span class="No-Break">do that.</span></p>
			<h2 id="_idParaDest-281"><a id="_idTextAnchor286"/>Installing PowerShell on CentOS 7</h2>
			<p>Installing by <a id="_idIndexMarker1006"/>direct download is really easy on CentOS; it’s <span class="No-Break">one line:</span></p>
			<pre class="console">
sudo yum install https://github.com/PowerShell/PowerShell/releases/download/v7.2.17/powershell-7.2.17-1.rh.x86_64.rpm</pre>			<p>All we’re doing here is using <strong class="source-inline">yum</strong>, the package manager on CentOS 7, to fetch and install a package from a URL. The trick here is knowing the URL of the package you need to download, though. All the packages are maintained on GitHub by Microsoft, <span class="No-Break">here: </span><a href="https://github.com/PowerShell/PowerShell/releases/"><span class="No-Break">https://github.com/PowerShell/PowerShell/releases/</span></a><span class="No-Break">.</span></p>
			<p>To download a release, click on the link in the name of the package (in our case, <strong class="bold">v7.2.17 Release of PowerShell</strong>) and scroll down to the <strong class="bold">Assets</strong> section on the next page. Click on the package we need, <strong class="source-inline">powershell-7.2.17-1.rh.x86_64.rpm</strong>, and copy the <span class="No-Break">hyperlink: </span><a href="https://github.com/PowerShell/PowerShell/releases/download/v7.2.17/powershell-7.2.17-1.rh.x86_64.rpm"><span class="No-Break">https://github.com/PowerShell/PowerShell/releases/download/v7.2.17/powershell-7.2.17-1.rh.x86_64.rpm</span></a><span class="No-Break">.</span></p>
			<p>Once we have that, we pass it to <strong class="source-inline">sudo yum install</strong>, <span class="No-Break">like this:</span></p>
			<div>
				<div id="_idContainer259" class="IMG---Figure">
					<img src="image/B17600_14_6.jpg" alt="Figure 14.6 – Installing PowerShell on CentOS 7 using a direct download"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 14.6 – Installing PowerShell on CentOS 7 using a direct download</p>
			<p>In the first line, I’ve <a id="_idIndexMarker1007"/>run the direct download command, as<a id="_idIndexMarker1008"/> shown previously. The rest of the screen<a id="_idIndexMarker1009"/> output is chat from the operating system, telling us what it is doing. There are quite a few more lines of this before we finally get to run PowerShell. It’s a very easy way to install PowerShell; the downside is that we don’t register the <span class="No-Break">Microsoft repository.</span></p>
			<p>That is pretty much all we’re going to cover on installing PowerShell on Linux; we’ve covered representatives of the two main families of Linux, Ubuntu and CentOS, and we’ve looked at how we can install different versions of PowerShell. Let’s look now at how we can install VS Code on <a id="_idIndexMarker1010"/>Linux. We’ll be using my CentOS system because that has <span class="No-Break">a GUI.</span></p>
			<h1 id="_idParaDest-282"><a id="_idTextAnchor287"/>Installing VS Code</h1>
			<p>Installing VS Code on<a id="_idIndexMarker1011"/> Linux is straightforward. On recent Ubuntu machines, we can use <strong class="source-inline">snapd</strong>, a package management system for Ubuntu, <span class="No-Break">like this:</span></p>
			<pre class="console">
sudo snap install --classic code</pre>			<p>And that’s it. On RHEL and CentOS machines, we may need to enable <strong class="source-inline">snapd</strong> first, before we can use it to <span class="No-Break">install code.</span></p>
			<p>We’re going to run the commands <span class="No-Break">shown next:</span></p>
			<ol>
				<li>In the first line, we are installing the <span class="No-Break"><strong class="source-inline">snapd</strong></span><span class="No-Break"> package:</span><pre class="source-code">
<strong class="bold">sudo yum install snapd</strong></pre><p class="list-inset"><em class="italic">Note</em>: For CentOS 7, we will also need to run the <span class="No-Break">following command:</span></p><pre class="source-code"><strong class="bold">sudo yum install epel-release</strong></pre></li>				<li>In the second line, we’re enabling the network socket that <span class="No-Break"><strong class="source-inline">snap</strong></span><span class="No-Break"> uses:</span><pre class="source-code">
<strong class="bold">sudo systemctl enable --now snapd.socket</strong></pre></li>				<li>In the third line, we’re creating a symbolic link that maps <strong class="source-inline">/snap</strong> <span class="No-Break">to </span><span class="No-Break"><strong class="source-inline">/var/lib/snapd/snap</strong></span><span class="No-Break">:</span><pre class="source-code">
<strong class="bold">sudo ln -s /var/lib/snapd/snap /snap</strong></pre></li>				<li>Finally, we need to log out and log back in, or reboot the machine, to make sure that everything <span class="No-Break">is updated.</span></li>
			</ol>
			<p>We’re now ready to use <strong class="source-inline">snap</strong> to install VS Code, as before. The big advantage of using <strong class="source-inline">snap</strong> is that it will keep VS Code updated in <span class="No-Break">the background.</span></p>
			<p>We can also install VS Code manually if we don’t have access to <strong class="source-inline">snap</strong>. We can do it like this on <span class="No-Break">CentOS 7:</span></p>
			<pre class="console">
sudo rpm --import  https://packages.microsoft.com/keys/microsoft.asc</pre>			<p>This will register the Microsoft GPG encryption keys with <strong class="source-inline">rpm</strong>, the CentOS 7 package manager. Next, type <span class="No-Break">the following:</span></p>
			<pre class="console">
sudo nano /etc/yum.repos.d/vscode.repo</pre>			<p>This will create an empty text file called <strong class="source-inline">vscode.repo</strong>. We need to add some lines to this file and save it, so <span class="No-Break">type this:</span></p>
			<pre class="source-code">
[code]
name=Visual Studio Code
baseurl=https://packages.microsoft.com/yumrepos/vscode
enabled=1
gpgcheck=1
gpgkey=https://packages.microsoft.com/keys/microsoft.asc</pre>			<p>Press <em class="italic">Ctrl</em> and <em class="italic">X</em> to exit, and <a id="_idIndexMarker1012"/>answer <strong class="source-inline">y</strong> when prompted to save <span class="No-Break">the file.</span></p>
			<p>The <strong class="source-inline">vscode.repo</strong> file should look <span class="No-Break">like this:</span></p>
			<div>
				<div id="_idContainer260" class="IMG---Figure">
					<img src="image/B17600_14_7.jpg" alt="Figure 14.7 – The vscode.repo file in nano"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 14.7 – The vscode.repo file in nano</p>
			<p>When we create the file, it is empty, and we must type in the code and then save <span class="No-Break">and exit.</span></p>
			<p>Finally, to install VS Code, type <span class="No-Break">the following:</span></p>
			<pre class="console">
sudo yum install code</pre>			<p>That’s it. We can start VS Code by typing <strong class="source-inline">code</strong> at the terminal prompt. VS Code works exactly the same way<a id="_idIndexMarker1013"/> in Linux as it does in Windows. Refer to the <em class="italic">Configuring VS Code for PowerShell</em> section of <a href="B17600_05.xhtml#_idTextAnchor096"><span class="No-Break"><em class="italic">Chapter 5</em></span></a>, <em class="italic">PowerShell Control Flow – Conditionals </em><span class="No-Break"><em class="italic">and Loops</em></span><span class="No-Break">.</span></p>
			<p>Now we’ve got everything installed, let’s look at how we can use PowerShell <span class="No-Break">on Linux.</span></p>
			<h1 id="_idParaDest-283"><a id="_idTextAnchor288"/>Running PowerShell on Linux</h1>
			<p>Mostly, PowerShell <a id="_idIndexMarker1014"/>works exactly the same on Linux as it does<a id="_idIndexMarker1015"/> on Windows, but obviously, there are some differences between the two underlying operating systems that we need to be aware of and subsequently understand how PowerShell <span class="No-Break">handles them.</span></p>
			<p>Case sensitivity is the obvious one; while <strong class="source-inline">get-content</strong> works as well as <strong class="source-inline">Get-Content</strong> on Linux, <strong class="source-inline">get-content ./myfile.txt</strong> doesn’t work if the file is called <strong class="source-inline">MyFile.txt</strong>; see the <span class="No-Break">following screenshot:</span></p>
			<div>
				<div id="_idContainer261" class="IMG---Figure">
					<img src="image/B17600_14_8.jpg" alt="Figure 14.8 – The importance of capitalization"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 14.8 – The importance of capitalization</p>
			<p>As you can see, if the capitalization of the path or filename is incorrect, then PowerShell can’t find the file. The best way I have found to compensate for this is to use tab completion as much as possible, as tab completion ignores capitalization, so typing <strong class="source-inline">myfi</strong> and pressing <em class="italic">Tab</em> will find a file <span class="No-Break">called </span><span class="No-Break"><strong class="source-inline">MyFile.txt</strong></span><span class="No-Break">.</span></p>
			<p>The filesystems are different, also. Linux doesn’t use letters to distinguish drives and uses forward slashes (<strong class="source-inline">/</strong>) instead of backslashes (<strong class="source-inline">\</strong>). PowerShell recognizes both as a file path separator, so there is no functional difference between <strong class="source-inline">Get-Content ./MyFile.txt</strong> and <span class="No-Break"><strong class="source-inline">Get-Content .\MyFile.txt</strong></span><span class="No-Break">:</span></p>
			<div>
				<div id="_idContainer262" class="IMG---Figure">
					<img src="image/B17600_14_9.jpg" alt="Figure 14.9 – Versatile path separators"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 14.9 – Versatile path separators</p>
			<p>As you can see, we get <a id="_idIndexMarker1016"/>the <a id="_idIndexMarker1017"/>contents of the file whichever file path separator we choose. This makes writing cross-platform <span class="No-Break">scripts easier.</span></p>
			<p>I have made my views on aliases known already, and it appears my furious letter writing has paid off, because PowerShell 7 on Linux no longer includes common aliases such as <strong class="source-inline">ls</strong>, although they persist when running PowerShell 7 on Windows. Instead, PowerShell now calls the Bash command, <span class="No-Break">like this:</span></p>
			<div>
				<div id="_idContainer263" class="IMG---Figure">
					<img src="image/B17600_14_10.jpg" alt="Figure 14.10 – Fewer aliases in PowerShell 7 on Linux"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 14.10 – Fewer aliases in PowerShell 7 on Linux</p>
			<p>We can see the difference between running <strong class="source-inline">ls</strong> in Bash and PowerShell in the preceding screenshot. The output is the same, but we don’t get the color coding we get when running in Bash. By contrast, we get a completely different type of output when we run <strong class="source-inline">Get-ChildItem</strong>. Compare this to the behavior on Windows, where <strong class="source-inline">ls</strong> is an alias for <strong class="source-inline">Get-ChildItem</strong>. Other Linux commands that are no longer aliased include <strong class="source-inline">cp</strong>, <strong class="source-inline">mv</strong>, <strong class="source-inline">rm</strong>, <strong class="source-inline">cat</strong>, <strong class="source-inline">man</strong>, <strong class="source-inline">mount</strong>, <span class="No-Break">and </span><span class="No-Break"><strong class="source-inline">ps</strong></span><span class="No-Break">.</span></p>
			<p>Running as an administrator is different on Linux, as well. People familiar with Linux will be used to running commands with the <strong class="source-inline">sudo</strong> prefix to run the command as root. This won’t work in PowerShell. Instead, we must start PowerShell with <strong class="source-inline">sudo</strong>, <span class="No-Break">like this:</span></p>
			<pre class="console">
sudo pwsh</pre>			<p>This will give us a new PowerShell session running with <span class="No-Break">root privileges.</span></p>
			<p>Given that one of the big attractions of running PowerShell on Linux (and macOS, and ARM) is that we can start to write cross-platform scripts, how do we know which platform our<a id="_idIndexMarker1018"/> script is<a id="_idIndexMarker1019"/> running on? Easy – we test the automatic variables. There are three automatic variables called <strong class="source-inline">$IsWindows</strong>, <strong class="source-inline">$IsLinux</strong>, and <strong class="source-inline">$IsMacOS</strong>, which return either <strong class="source-inline">true</strong> or <strong class="source-inline">false</strong>, depending on the operating system. We can use these variables to write <strong class="source-inline">if</strong> statements in our scripts that alter behavior depending on <span class="No-Break">the environment.</span></p>
			<p class="callout-heading">Activity – Writing a cross-platform script</p>
			<p class="callout">Given what we’ve<a id="_idIndexMarker1020"/> learned previously, write a cross-platform script that will run on both Windows and Linux and return five running processes with the highest current CPU usage. Output the processes in descending order to a text file with a name that includes the name of the computer it was <span class="No-Break">run on.</span></p>
			<p class="callout">We can get the name <a id="_idIndexMarker1021"/>of the computer in Windows with <strong class="source-inline">$env:computername</strong>, and in Linux by <span class="No-Break">typing </span><span class="No-Break"><strong class="source-inline">hostname</strong></span><span class="No-Break">.</span></p>
			<p>Of course, much of the time, we won’t actually be running commands and scripts directly on a Linux machine; most of the time, we will want to remote into it. In the next section, we’ll look at<a id="_idIndexMarker1022"/> the<a id="_idIndexMarker1023"/> recommended way of remoting into <span class="No-Break">Linux machines.</span></p>
			<h1 id="_idParaDest-284"><a id="_idTextAnchor289"/>Remoting with OpenSSH</h1>
			<p>We saw in <a href="B17600_12.xhtml#_idTextAnchor236"><span class="No-Break"><em class="italic">Chapter 12</em></span></a>, <em class="italic">Securing PowerShell</em>, that remoting was a powerful way to establish a<a id="_idIndexMarker1024"/> connection with a machine and take control. When we looked at remoting in that chapter, we explored remoting over the <strong class="bold">Windows Remote Management</strong> (<strong class="bold">WinRM</strong>) protocol on <a id="_idIndexMarker1025"/>other Windows machines. We mentioned that we could also use SSH to establish remote sessions. Linux does not support the WinRM protocol, so we must use SSH to remotely <span class="No-Break">administer it.</span></p>
			<p>OpenSSH is an open source SSH toolset that is almost ubiquitous on Linux and other Unix machines. Since 2018, it has been available for Windows and makes managing heterogeneous environments much easier. It can be a bit tricky to set up, but once it is working, it makes remoting very easy. Let’s take <span class="No-Break">a look.</span></p>
			<h2 id="_idParaDest-285"><a id="_idTextAnchor290"/>Checking that PowerShell has OpenSSH support</h2>
			<p>The first thing to <a id="_idIndexMarker1026"/>check is that our version of<a id="_idIndexMarker1027"/> PowerShell 7 has got OpenSSH support; if we’ve downloaded and installed it from GitHub, then we should be OK, but first, let’s check using the <span class="No-Break">following command:</span></p>
			<pre class="console">
(Get-Command New-PSSession).ParameterSets.Name</pre>			<p>If we see parameter sets called <strong class="source-inline">SSHHost</strong> and <strong class="source-inline">SSHHostHashParam</strong>, then we are good to go. If not, then we should download a recent version of PowerShell 7 <span class="No-Break">from GitHub.</span></p>
			<h2 id="_idParaDest-286"><a id="_idTextAnchor291"/>Installing OpenSSH on Windows</h2>
			<p>We only need to<a id="_idIndexMarker1028"/> install OpenSSH on Windows if we are going to <a id="_idIndexMarker1029"/>want to remote into that Windows machine. If we’re going to remote from it to other machines, then we can skip installing it; PowerShell already has a working SSH client that will allow us to connect to Linux machines using <span class="No-Break">PowerShell remoting.</span></p>
			<p>If we decide we want to install an OpenSSH server, then we first need to check if we are running on a viable version of Windows and that we have the correct rights. Start an elevated administrator PowerShell session, and type <span class="No-Break">the following:</span></p>
			<pre class="console">
(New-Object Security.Principal.WindowsPrincipal([Security.Principal.WindowsIdentity]::GetCurrent())).IsInRole([Security.Principal.WindowsBuiltInRole]::Administrator)
Winver.exe</pre>			<p>This is what I get on <span class="No-Break">my machine:</span></p>
			<div>
				<div id="_idContainer264" class="IMG---Figure">
					<img src="image/B17600_14_11.jpg" alt="Figure 14.11 – Checking OpenSSH prerequisites on Windows"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 14.11 – Checking OpenSSH prerequisites on Windows</p>
			<p>As we can see, my rights test returns <strong class="source-inline">True</strong>, so I do have the correct rights, and when I run <strong class="source-inline">winver.exe</strong>, the pop-up window shows I am running Windows 10 22H2, more recent than the minimum version of Windows 10 1809. We’re ready to install. In the elevated prompt we’ve just used, type <span class="No-Break">the following:</span></p>
			<pre class="console">
Get-WindowsCapability -Online | Where-Object {$_.Name -like 'OpenSSH*'} | Add-WindowsCapability -Online</pre>			<p>This will install OpenSSH. We also need to start the <strong class="source-inline">sshd</strong> service and set it to automatically <span class="No-Break">start up:</span></p>
			<pre class="console">
Start-Service sshd
Set-Service sshd -StartupType Automatic</pre>			<p>Finally, we need to configure <strong class="source-inline">sshd</strong> to allow PowerShell to use it. Open <strong class="source-inline">notepad.exe</strong> as an administrator (right-click and choose <strong class="bold">Run as Administrator</strong>), and then open the <strong class="source-inline">C:\ProgramData\ssh\sshd_config</strong> file, add the following lines above the last entry in the file, and save <span class="No-Break">the file:</span></p>
			<pre class="source-code">
PasswordAuthentication yes
PubkeyAuthentication yes
Subsystem powershell c:/progra~1/powershell/7/pwsh.exe -sshs -nologo</pre>			<p>The <strong class="source-inline">-</strong><strong class="source-inline">nologo</strong> parameter isn’t needed if we’re using PowerShell 7.4 or later. Be careful not to save the<a id="_idIndexMarker1030"/> file <a id="_idIndexMarker1031"/><span class="No-Break">as </span><span class="No-Break"><strong class="source-inline">sshd_config.txt</strong></span><span class="No-Break">.</span></p>
			<p class="callout-heading">Warning!</p>
			<p class="callout">Wait! What’s that <strong class="source-inline">c:/progra~1/powershell/7/pwsh.exe</strong> path all about? Working with non-Microsoft open source software on Windows can be frustrating at times. OpenSSH is an example. It doesn’t understand paths with a space in them, even if the path is enclosed in single or double quotes, and so we have to use something called 8.3 format, which is the short filename format that we used to use with older Microsoft <span class="No-Break">operating systems.</span></p>
			<p class="callout">Unfortunately, it’s even more complicated. Some releases of OpenSSH don’t like that format either; when we add the PowerShell subsystem into the <strong class="source-inline">sshd_config</strong> file, the <strong class="source-inline">sshd</strong> service refuses to start. The answer here is to side-load another copy of PowerShell into a directory with no spaces and no names longer than eight characters. To get mine to work, I downloaded the PowerShell 7.4 ZIP file from the PowerShell GitHub pages, unblocked it by right-clicking on the downloaded file, selecting <strong class="bold">Properties</strong>, and checking the <strong class="bold">Unblock</strong> checkbox, and then extracted the contents to a suitable directory; in my case, I used <strong class="source-inline">c:\scratch\pwsh</strong>. I then added this line <span class="No-Break">to </span><span class="No-Break"><strong class="source-inline">sshd_config</strong></span><span class="No-Break">:</span></p>
			<p class="callout"><strong class="source-inline">Subsystem powershell </strong><span class="No-Break"><strong class="source-inline">c:/scratch/pwsh/pwsh.exe -sshs</strong></span></p>
			<p class="callout">And now, the <strong class="source-inline">sshd</strong> service will <span class="No-Break">start normally.</span></p>
			<p>Finally, restart the service with the <span class="No-Break">following command:</span></p>
			<pre class="console">
Restart-Service sshd</pre>			<p>And that’s it. Our Windows <a id="_idIndexMarker1032"/>machine is ready to receive <a id="_idIndexMarker1033"/>PowerShell remoting <span class="No-Break">over OpenSSH.</span></p>
			<h2 id="_idParaDest-287"><a id="_idTextAnchor292"/>Installing OpenSSH on Linux</h2>
			<p>Now, we have to <a id="_idIndexMarker1034"/>configure OpenSSH on Linux. We’re going to <a id="_idIndexMarker1035"/>use my CentOS 7 machine, which already has OpenSSH installed, but if we wanted to install it on an Ubuntu machine, we’d need to install it first with the <span class="No-Break">following command:</span></p>
			<pre class="console">
sudo apt install openssh-client
sudo apt install openssh-server</pre>			<p>Once OpenSSH is installed, we need to edit the <strong class="source-inline">sshd_config</strong> file at <strong class="source-inline">/etc/ssh</strong>. To do this, we need to start our text editor <span class="No-Break">with </span><span class="No-Break"><strong class="source-inline">sudo</strong></span><span class="No-Break">:</span></p>
			<pre class="console">
sudo nano /etc/ssh/sshd_config</pre>			<p>We need to add the <span class="No-Break">following lines:</span></p>
			<pre class="source-code">
PasswordAuthentication yes
PubkeyAuthentication yes
Subsystem powershell /usr/bin/pwsh -sshs -nologo</pre>			<p>Then, we save the file. Next, we need to restart the <span class="No-Break"><strong class="source-inline">sshd</strong></span><span class="No-Break"> service:</span></p>
			<pre class="console">
sudo systemctl restart sshd</pre>			<p>And then, we set it to <span class="No-Break">start automatically:</span></p>
			<pre class="console">
sudo systemctl enable sshd</pre>			<p>And that’s us set up for remoting. Note that the final command may throw an error if it is <span class="No-Break">already enabled.</span></p>
			<h2 id="_idParaDest-288"><a id="_idTextAnchor293"/>Running remote sessions</h2>
			<p>Using remote <a id="_idIndexMarker1036"/>sessions over SSH is just as easy as using them over WinRM, which we saw in <a href="B17600_12.xhtml#_idTextAnchor236"><span class="No-Break"><em class="italic">Chapter 12</em></span></a>, <em class="italic">Securing PowerShell</em>. We start out by creating a <span class="No-Break">session object:</span></p>
			<pre class="console">
$session = New-PSSession -HostName &lt;name of remote computer&gt; -UserName &lt;username&gt;</pre>			<p>Notice that we’re using the <strong class="source-inline">-HostName</strong> parameter, not the <strong class="source-inline">-ComputerName</strong> parameter. This tells PowerShell to create an SSH session, not a WinRM one. We’ll be asked to input the user’s password, and then the session object is created. We can then use the variable containing the session object to start a <span class="No-Break">remote session:</span></p>
			<pre class="console">
Enter-PSSession -Session $session</pre>			<p>We’ll see the prompt change to reflect the machine that we are remoting into, and we are straight into a PowerShell session on that machine. To leave the session, we can just type <strong class="source-inline">exit</strong> and return to the local machine. This is how it looks <span class="No-Break">in practice:</span></p>
			<div>
				<div id="_idContainer265" class="IMG---Figure">
					<img src="image/B17600_14_12.jpg" alt="Figure 14.12 – SSH remoting into a Linux server"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 14.12 – SSH remoting into a Linux server</p>
			<p>The numbering in the preceding screenshot is explained <span class="No-Break">as follows:</span></p>
			<ol>
				<li>In <em class="italic">line 1</em>, I’m creating a new session object and storing it in a variable. I’m passing the IP address of the remote machine because I haven’t set up name resolution. I’m also passing the username of a user on the remote machine who has the right to <span class="No-Break">log in.</span></li>
				<li>In <em class="italic">line 2</em>, I am asked for the remote user’s password; once it is provided, the session object <span class="No-Break">is created.</span></li>
				<li>In <em class="italic">line 3</em>, I’m calling the <strong class="source-inline">$session</strong> variable, and the properties of the new session <span class="No-Break">are displayed.</span></li>
				<li>In <em class="italic">line 4</em>, I’m passing the <strong class="source-inline">$session</strong> variable to <strong class="source-inline">Enter-PSSession</strong>, and I’m entering a <span class="No-Break">remote session.</span></li>
				<li>In <em class="italic">line 5</em>, we can see that the prompt has changed to <strong class="source-inline">[nick@192.168.56.101]: PS /home/nick&gt;</strong>, which tells us I’m in a PowerShell session on the machine at <strong class="source-inline">192.168.56.101</strong> and I’m logged in as <strong class="source-inline">nick</strong>. The working directory is <strong class="source-inline">/home/nick</strong>. I’m running the <strong class="source-inline">Get-Process</strong> PowerShell cmdlet, looking for processes containing the <strong class="source-inline">shell</strong> string, and I get two <strong class="source-inline">gnome</strong> processes returned. This is definitely Linux – my CentOS 7 GUI box, to be precise. If we run it on Ubuntu, we may not see any processes at all if there is no <span class="No-Break">GUI installed.</span></li>
				<li>In <em class="italic">line 6</em>, I run the <strong class="source-inline">hostname</strong> Bash command, and the name of the remote system is <span class="No-Break">returned: </span><span class="No-Break"><strong class="source-inline">localhost.localdomain</strong></span><span class="No-Break">.</span></li>
				<li>In <em class="italic">line 7</em>, just so there is no doubt, we can see that the value of the <strong class="source-inline">$IsLinux</strong> automatic variable <span class="No-Break">is </span><span class="No-Break"><strong class="source-inline">True</strong></span><span class="No-Break">.</span></li>
				<li>Finally, on <em class="italic">line 8</em>, I type <strong class="source-inline">exit</strong> and am returned to my local PowerShell session running <span class="No-Break">on Windows.</span></li>
			</ol>
			<p>The trouble is, I’ve used <a id="_idIndexMarker1037"/>a username and password combination here, and many Linux machines will be set up to use key-based authentication. Let’s take a look at how we can set <span class="No-Break">that up.</span></p>
			<h2 id="_idParaDest-289"><a id="_idTextAnchor294"/>Authentication</h2>
			<p>Key-based authentication is<a id="_idIndexMarker1038"/> a more secure way of using SSH for PowerShell remoting. It also makes it easier to automate scripts, as once it is set up, no one needs to manually enter a password. Let’s look at how we can get <span class="No-Break">it working.</span></p>
			<p>PowerShell 7 includes a utility called <strong class="source-inline">Ssh-keygen</strong> that we can use to create a public/private key pair that we can use to authenticate ourselves to the remote machine. We can use it <span class="No-Break">like this:</span></p>
			<pre class="console">
Ssh-keygen -t Ed25519</pre>			<p>We’re asking PowerShell to generate a key pair using the Ed21559 algorithm, which is quite modern. Older systems may require that we use the RSA algorithm instead. We will be asked for a path to save the files to; it’s best to accept the default one by just pressing <em class="italic">Enter</em>. We will also be asked to enter a passphrase; again, this is optional, and we can just press <em class="italic">Enter</em> twice to save the files with <span class="No-Break">no passphrase.</span></p>
			<p>Now, we can save the public key onto the Linux machine in the <strong class="source-inline">.ssh</strong> directory of the user we want to log in with. PowerShell has another utility called <strong class="source-inline">scp</strong> that we can use to copy the file across (note that we might need to create a .<strong class="source-inline">ssh</strong> <span class="No-Break">directory first):</span></p>
			<pre class="console">
scp c:\Users\&lt;username&gt;\.ssh\id_ed25519.pub &lt;user&gt;@&lt;remote_host&gt;:~/.ssh/authorized_keys</pre>			<p>I’m using <strong class="source-inline">scp</strong> with two<a id="_idIndexMarker1039"/> parameters here – the first is the path to the file we’ve created, and the second is the path we want it copied to. We’ll be asked to provide the password for the remote user again, but that’s the last time we’ll need to do that. Now, when we log in as that user, we will pass a hash of our private key on the local machine that pairs with the hash of the public key on the remote machine, and we will be recognized as the remote user. This is how it looks on <span class="No-Break">my machine:</span></p>
			<div>
				<div id="_idContainer266" class="IMG---Figure">
					<img src="image/B17600_14_13.jpg" alt="Figure 14.13 – Setting up key-based authentication"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 14.13 – Setting up key-based authentication</p>
			<p>In the preceding<a id="_idIndexMarker1040"/> screenshot, I’ve run the commands needed to set up <span class="No-Break">key-based authentication:</span></p>
			<ol>
				<li>In <em class="italic">line 1</em>, I am running <strong class="source-inline">Ssh-keygen</strong> to create my <span class="No-Break">key pair.</span></li>
				<li>In <em class="italic">line 2</em>, I’m accepting the default path by <span class="No-Break">pressing </span><span class="No-Break"><em class="italic">Enter</em></span><span class="No-Break">.</span></li>
				<li>In <em class="italic">line 3</em>, I’m setting a blank passphrase by pressing <span class="No-Break"><em class="italic">Enter</em></span><span class="No-Break"> twice.</span></li>
				<li>In <em class="italic">line 4</em>, I’m using <strong class="source-inline">scp</strong> to copy the public key across to the user <strong class="source-inline">.ssh</strong> directory on the <span class="No-Break">remote machine.</span></li>
				<li>In <em class="italic">line 5</em>, I’m providing the password – hopefully for the last <span class="No-Break">time ever.</span></li>
				<li>In <em class="italic">line 6</em>, I am storing a new session object in a variable called <strong class="source-inline">$sessionSSH</strong>. Notice that I am not providing a password, but I am providing the path to the private key in the <strong class="source-inline">-</strong><span class="No-Break"><strong class="source-inline">KeyFilePath</strong></span><span class="No-Break"> parameter.</span></li>
				<li>In <em class="italic">line 7</em>, I’m calling the variable to check <span class="No-Break">the properties.</span></li>
				<li>In <em class="italic">line 8</em>, I am entering the session using the <strong class="source-inline">$</strong><span class="No-Break"><strong class="source-inline">sessionSSH</strong></span><span class="No-Break"> variable.</span></li>
				<li>In the final line, we can see that the prompt has changed to reflect that I am working in a <span class="No-Break">remote session.</span></li>
			</ol>
			<p>There’s an awful lot<a id="_idIndexMarker1041"/> more to using SSH, but that is enough to get us started. Let’s move on to the final section of this chapter: <em class="italic">PowerShell </em><span class="No-Break"><em class="italic">for macOS</em></span><span class="No-Break">.</span></p>
			<h1 id="_idParaDest-290"><a id="_idTextAnchor295"/>PowerShell for macOS</h1>
			<p>macOS is very<a id="_idIndexMarker1042"/> similar to Linux; both operating systems are based on elements <a id="_idIndexMarker1043"/>of Unix, and many Linux programs can run on macOS without modifying the source code. The differences we will focus on here are how we install PowerShell and VS Code. I’ve used a friend’s MacBook, which is running Ventura (macOS 13). If anything, installing on macOS is even easier than installing <span class="No-Break">on Linux.</span></p>
			<h2 id="_idParaDest-291"><a id="_idTextAnchor296"/>Installing Homebrew on macOS</h2>
			<p>Homebrew is<a id="_idIndexMarker1044"/> a free open source package manager that<a id="_idIndexMarker1045"/> works on Linux and macOS, but mostly we see it on macOS. It’s very easy to install and use, and it’s what we’re going to use to install PowerShell and VS Code on macOS. It’s a one-line installation. Open the terminal and type <span class="No-Break">the following:</span></p>
			<pre class="console">
/bin/bash -c "$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh)"</pre>			<p>We’re passing a <strong class="source-inline">curl</strong> command to the <strong class="source-inline">bash</strong> shell here to download and run a Bash script from a URL. We’ll probably be asked to provide our password. macOS is just as chatty as Linux, but after a few minutes, we should see a message saying <strong class="source-inline">Installation successful!</strong>. Now, we’re ready to <span class="No-Break">install PowerShell.</span></p>
			<h2 id="_idParaDest-292"><a id="_idTextAnchor297"/>Installing PowerShell on macOS</h2>
			<p>Once we’ve got<a id="_idIndexMarker1046"/> Homebrew installed, everything else is easy. To<a id="_idIndexMarker1047"/> install PowerShell, we type <span class="No-Break">the following:</span></p>
			<pre class="console">
brew install powershell/tap/powershell</pre>			<p>And that’s it. We can start PowerShell by typing <strong class="source-inline">pwsh</strong> in the terminal. This is how it looks on <span class="No-Break">Paul’s machine:</span></p>
			<div>
				<div id="_idContainer267" class="IMG---Figure">
					<img src="image/B17600_14_14.jpg" alt="Figure 14.14 – Installing PowerShell on macOS"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 14.14 – Installing PowerShell on macOS</p>
			<p>In <em class="italic">line 1</em>, I’m installing PowerShell using Homebrew. In <em class="italic">line 2</em>, I’m starting PowerShell with <strong class="source-inline">pwsh</strong>, and in <em class="italic">line 3</em>, I’m calling <strong class="source-inline">$PSVersionTable</strong> to check what <span class="No-Break">we’ve got.</span></p>
			<p>We’ll need to keep PowerShell updated. We can do that with these <span class="No-Break">two lines:</span></p>
			<pre class="console">
brew update
brew upgrade powershell</pre>			<p>The first line updates the Homebrew database, and the second upgrades PowerShell based on the most <span class="No-Break">recent information.</span></p>
			<p>Finally, to uninstall PowerShell, we can just type <span class="No-Break">the following:</span></p>
			<pre class="console">
brew uninstall --cask powershell</pre>			<p>However, I’ve no idea <a id="_idIndexMarker1048"/>why we would want to do that. Let’s look at <a id="_idIndexMarker1049"/>installing VS <span class="No-Break">Code next.</span></p>
			<h2 id="_idParaDest-293"><a id="_idTextAnchor298"/>Installing VS Code on macOS</h2>
			<p>We can use <a id="_idIndexMarker1050"/>Homebrew to download and install VS Code using the<a id="_idIndexMarker1051"/> following command, which updates the latest files <span class="No-Break">for Homebrew:</span></p>
			<pre class="console">
brew update</pre>			<p>This installs the <strong class="source-inline">cask</strong> repository if it’s not <span class="No-Break">already present:</span></p>
			<pre class="console">
brew tap caskroom/cask</pre>			<p>This searches for VS Code in <span class="No-Break">the repository:</span></p>
			<pre class="console">
brew cask search visual-studio-code</pre>			<p>And this line <span class="No-Break">installs it:</span></p>
			<pre class="console">
brew cask install visual-studio-code</pre>			<p>We can use the launcher application to start VS Code, or we can add it to the <strong class="source-inline">PATH</strong> variable with this <span class="No-Break"><strong class="source-inline">cat</strong></span><span class="No-Break"> command:</span></p>
			<pre class="console">
cat &lt;&lt; EOF &gt;&gt; ~/.bash_profile
# Add Visual Studio Code (code)
export PATH="\$PATH:/Applications/Visual Studio Code.app/Contents/Resources/app/bin"
EOF</pre>			<p>We can also install it by downloading it directly from <a href="https://code.visualstudio.com/">https://code.visualstudio.com/</a> and double-clicking the <span class="No-Break">downloaded file.</span></p>
			<p>We can uninstall VS Code by running <span class="No-Break">the following:</span></p>
			<pre class="console">
brew cask uninstall visual-studio-code</pre>			<p>But I bet we won’t <span class="No-Break">want to.</span></p>
			<p>That’s it for this chapter. Let’s review what <span class="No-Break">we’ve learned.</span></p>
			<h1 id="_idParaDest-294"><a id="_idTextAnchor299"/>Summary</h1>
			<p>In this chapter, we saw that there is no standard way to install PowerShell and VS Code. We saw how to use package managers to install PowerShell 7 on Ubuntu and RHEL, and then used the direct download method to install on an older version of Linux: <span class="No-Break">CentOS 7.</span></p>
			<p>After that, we looked at how we can install VS Code on Linux, with a practical example on CentOS <span class="No-Break">7, again.</span></p>
			<p>We looked at a number of ways PowerShell on Linux differs from running PowerShell on Windows, including the filesystem, capitalization, and the use <span class="No-Break">of aliases.</span></p>
			<p>We spent some time on an important topic: how we can remote into Linux machines using SSH. The use of Linux as a desktop is rare, and the majority of work carried out on Linux machines is over remote sessions on SSH, whether that is with PowerShell or directly into a <span class="No-Break">Bash terminal.</span></p>
			<p>Finally, we had a quick tour of ways of installing PowerShell and VS Code on macOS. We saw that it was very easy to both install and uninstall these applications using the free open source package <span class="No-Break">manager, Homebrew.</span></p>
			<p>In the next chapter, we’re going to look at running PowerShell on a different processor, ARM, and the associated operating <span class="No-Break">system, Raspbian.</span></p>
			<h1 id="_idParaDest-295"><a id="_idTextAnchor300"/>Exercises</h1>
			<ol>
				<li>Where would we go to get support installing PowerShell on <span class="No-Break">Kali Linux?</span></li>
				<li>Which command are we calling when we type <strong class="source-inline">ls</strong> into a PowerShell session <span class="No-Break">on Linux?</span></li>
				<li>Which file path separator does PowerShell use <span class="No-Break">on Linux?</span></li>
				<li>How could we easily tell if we were working on a <span class="No-Break">macOS machine?</span></li>
				<li>How would we run a PowerShell script with root privileges <span class="No-Break">in Linux?</span></li>
				<li>Which cmdlet and parameter would we use to create a new remote session to a <span class="No-Break">Linux machine?</span></li>
				<li>Which cmdlet and parameter would we use to avoid having to send a password across <span class="No-Break">the network?</span></li>
				<li>What does <span class="No-Break"><strong class="source-inline">scp</strong></span><span class="No-Break"> do?</span></li>
				<li>What <span class="No-Break">is Ed25519?</span></li>
			</ol>
			<h1 id="_idParaDest-296"><a id="_idTextAnchor301"/>Further reading</h1>
			<ul>
				<li><em class="italic">Install PowerShell </em><span class="No-Break"><em class="italic">on Linux</em></span><span class="No-Break">:</span><p class="list-inset"><a href="https://learn.microsoft.com/en-us/powershell/scripting/install/installing-powershell-on-linux"><span class="No-Break">https://learn.microsoft.com/en-us/powershell/scripting/install/installing-powershell-on-linux</span></a></p></li>
				<li><em class="italic">Installing PowerShell </em><span class="No-Break"><em class="italic">on Ubuntu</em></span><span class="No-Break">:</span><p class="list-inset"><a href="https://learn.microsoft.com/en-us/powershell/scripting/install/install-ubuntu"><span class="No-Break">https://learn.microsoft.com/en-us/powershell/scripting/install/install-ubuntu</span></a></p></li>
				<li><em class="italic">Installing PowerShell on Red Hat Enterprise </em><span class="No-Break"><em class="italic">Linux (RHEL)</em></span><span class="No-Break">:</span><p class="list-inset"><a href="https://learn.microsoft.com/en-us/powershell/scripting/install/install-rhel"><span class="No-Break">https://learn.microsoft.com/en-us/powershell/scripting/install/install-rhel</span></a></p></li>
				<li><em class="italic">Installing PowerShell </em><span class="No-Break"><em class="italic">on macOS</em></span><span class="No-Break">:</span><p class="list-inset"><a href="https://learn.microsoft.com/en-us/powershell/scripting/install/installing-powershell-on-macos"><span class="No-Break">https://learn.microsoft.com/en-us/powershell/scripting/install/installing-powershell-on-macos</span></a></p></li>
				<li><em class="italic">Running Visual Studio Code </em><span class="No-Break"><em class="italic">on macOS</em></span><span class="No-Break">:</span><p class="list-inset"><a href="https://code.visualstudio.com/docs/setup/mac"><span class="No-Break">https://code.visualstudio.com/docs/setup/mac</span></a></p></li>
				<li><em class="italic">PowerShell remoting </em><span class="No-Break"><em class="italic">over SSH</em></span><span class="No-Break">:</span><p class="list-inset"><a href="https://learn.microsoft.com/en-us/powershell/scripting/learn/remoting/ssh-remoting-in-powershell"><span class="No-Break">https://learn.microsoft.com/en-us/powershell/scripting/learn/remoting/ssh-remoting-in-powershell</span></a></p></li>
				<li><em class="italic">Get started with OpenSSH </em><span class="No-Break"><em class="italic">for Windows</em></span><span class="No-Break">:</span><p class="list-inset"><a href="https://learn.microsoft.com/en-us/windows-server/administration/openssh/openssh_install_firstuse?tabs=gui"><span class="No-Break">https://learn.microsoft.com/en-us/windows-server/administration/openssh/openssh_install_firstuse?tabs=gui</span></a></p></li>
				<li><em class="italic">OpenSSH Server configuration for Windows Server </em><span class="No-Break"><em class="italic">and Windows</em></span><span class="No-Break">:</span><p class="list-inset"><a href="https://learn.microsoft.com/en-us/windows-server/administration/openssh/openssh_server_configuration"><span class="No-Break">https://learn.microsoft.com/en-us/windows-server/administration/openssh/openssh_server_configuration</span></a></p></li>
			</ul>
		</div>
	</body></html>