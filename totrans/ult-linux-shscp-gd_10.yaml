- en: '10'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '10'
- en: Understanding Functions
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解函数
- en: Functions are an important component of pretty much every modern programming
    language. They’re simply blocks of code that each perform one specific task. The
    cool thing about them is that they allow programmers to reuse code. That is, one
    block of code can be called either from within a program in various places, or
    it can be called by various different programs from function libraries. In this
    chapter, I’ll show you the basics about using functions in shell scripts.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 函数是几乎所有现代编程语言中的重要组成部分。它们只是执行特定任务的代码块。它们的酷点在于，允许程序员重用代码。也就是说，一个代码块可以在程序的不同地方被调用，或者可以被不同的程序从函数库中调用。在本章中，我将向你展示如何在
    shell 脚本中使用函数的基础知识。
- en: 'Topics in this chapter include:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章内容包括：
- en: Introduction to functions
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 函数简介
- en: Defining a function
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 定义函数
- en: Using functions in shell scripts
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 shell 脚本中使用函数
- en: Creating function libraries
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建函数库
- en: Looking at some real-world examples
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 查看一些现实世界的例子
- en: If you’re ready, let’s get started.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你准备好了，我们就开始吧。
- en: Technical Requirements
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: Use any of your Linux virtual machines or your Linux host machine.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 使用任何你的 Linux 虚拟机或你的 Linux 主机。
- en: 'Also, as always, you can grab the scripts and text files from Github, like
    so:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，和往常一样，你可以从 Github 上抓取脚本和文本文件，像这样：
- en: '[PRE0]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Introduction to Functions
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 函数简介
- en: As I’ve mentioned above, a function is a block of programming code that performs
    a specific task. What makes functions so cool is that they really cut down on
    the amount of code that you have to type. Instead of having to type in the same
    code every time you want to perform a task, you can just call the function, instead.
    This cuts down on the size of your scripts, and makes typing the script much less
    prone to error.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我上面提到的，函数是执行特定任务的编程代码块。函数之所以这么酷，是因为它们大大减少了你需要输入的代码量。你不必每次执行一个任务时都输入相同的代码，而是可以直接调用函数。这减少了脚本的大小，也使得输入脚本时更不容易出错。
- en: Also, after a function has been called the first time, it resides in system
    memory, which can enhance the performance of your scripts.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，在函数第一次被调用之后，它会驻留在系统内存中，这可以提高脚本的性能。
- en: You can create functions that accept parameters from the main program, that
    return values to the main program, or that might do some stand-alone task that
    doesn’t involve either passing parameters or passing values. Learning to create
    functions is easy, because for the most part you’re just using the same coding
    techniques that I’ve already shown you. I mean, yeah, there are some new things
    that you’ll have to learn, but there’s really nothing hard about any of it.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以创建接受主程序传递参数的函数，返回值给主程序的函数，或者执行一些独立任务的函数，这些任务既不涉及传递参数也不涉及返回值。学习创建函数很简单，因为大多数时候你只需使用我已经向你展示过的相同编码技巧。我的意思是，是的，你会需要学习一些新东西，但实际上没有什么难度。
- en: 'If you’re running Linux on your workstation, you’re already using a lot of
    functions without realizing it. To see the functions that your system is running,
    just run a `declare -F` command, like so:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在工作站上运行 Linux，你已经在不自觉中使用了很多功能。要查看系统正在运行的功能，只需运行一个 `declare -F` 命令，像这样：
- en: '[PRE1]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: These functions are loaded into system memory by the shell every time you log
    into your computer, and are used by the various utilities that make up the `bash`
    ecosystem.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 这些功能每次你登录到计算机时都会由 shell 加载到系统内存中，并被构成 `bash` 生态系统的各种实用工具使用。
- en: 'Running `declare` with a lower case `-f` also shows you the code for each function.
    You can also list the name of a function to only see the code for it, like this:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 运行 `declare` 命令并加上小写 `-f` 参数，还可以显示每个函数的代码。你也可以仅列出函数的名称，来只查看该函数的代码，像这样：
- en: '[PRE2]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'To see where these functions are defined, you’ll need to enter debugger mode
    and then use a `declare -F` command, like this:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看这些函数是在哪里定义的，你需要进入调试模式，然后使用 `declare -F` 命令，像这样：
- en: '[PRE3]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: So, you see that this function is defined on line number 1069 of the `bash_completion`
    function library file that’s in the `/usr/share/bash-completion/` directory. Go
    ahead and peek into that file, and you’ll see that many functions are defined
    in it. When you’re through with debugger mode, just type `exit`.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，你会看到这个函数是在 `/usr/share/bash-completion/` 目录下的 `bash_completion` 函数库文件的第 1069
    行定义的。去看一下那个文件，你会看到它里面定义了很多函数。当你完成调试模式后，只需输入 `exit`。
- en: 'You can also obtain information about a function with the `type` command, like
    so:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以使用 `type` 命令获取关于函数的信息，像这样：
- en: '[PRE4]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Now that you know what functions are, let’s see if we can define some.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你知道了什么是函数，接下来我们来看看如何定义一些函数。
- en: Defining a Function
  id: totrans-29
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 定义一个函数
- en: 'You can define a function in the following places:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在以下地方定义一个函数：
- en: On the command-line
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在命令行中
- en: In a shell script
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在一个 shell 脚本中
- en: In a function library
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在一个函数库中
- en: In a shell configuration file
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在一个 shell 配置文件中
- en: 'Defining a function from the command-line can be useful if you need to do any
    quick testing or experimentation with new code. Here’s what it looks like:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 从命令行定义函数很有用，特别是当你需要快速测试或尝试新代码时。下面是它的样子：
- en: '[PRE5]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The name of this function is `howdy`, and the `()` tells the shell that this
    is a function. The code for the function is within the pair of curly braces. The
    function consists of two `echo` commands, which are separated by a semi-colon.
    Note that you need to place another semi-colon at the end of the final command.
    You also need to have one blank space between the first curly brace and the first
    command, and the final semi-colon and the closing curly brace.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数的名字是`howdy`，`()`告诉 shell 这是一个函数。函数的代码包含在一对大括号内。这个函数由两个`echo`命令组成，它们通过分号隔开。请注意，你需要在最后一个命令的末尾放置一个分号。你还需要确保在第一个大括号和第一个命令之间有一个空格，以及在最后一个分号和闭合的大括号之间有一个空格。
- en: 'Some tutorials that you’ll find might tell you that you can begin the function
    with the keyword `function`, as you see here:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 一些教程可能会告诉你，可以使用`function`关键字开始函数，像你在这里看到的那样：
- en: '[PRE6]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: But, creating functions without the `function` keyword works well, so there’s
    no real reason to use it.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 不过，创建没有`function`关键字的函数也可以正常工作，所以实际上没有必要使用它。
- en: Be aware that using the `function` keyword is a really bad idea, because it’s
    not portable. I mean, it works on `bash`, `zsh`, and `ash`, but it doesn’t work
    on `ksh`, `dash`, or Bourne Shell. Even where you can use the `function` keyword,
    it serves no real purpose. So, your best bet is to just never use it.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，使用`function`关键字是一个非常糟糕的主意，因为它不具备可移植性。我的意思是，它在`bash`、`zsh`和`ash`中有效，但在`ksh`、`dash`或
    Bourne Shell 中不起作用。即使可以使用`function`关键字，它也没有实际用途。因此，你最好的做法是永远不要使用它。
- en: Any functions that you define on the command line will be ephemeral and will
    disappear as soon as you close the terminal. So, you’ll want to commit them to
    a file to make them permanent. Also, any functions that you define on the command-line
    will not be visible in a `bash --debug` session, because they don’t get exported
    to a child shell.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 你在命令行中定义的任何函数都是临时的，一旦关闭终端就会消失。所以你需要将它们保存到文件中，使其持久化。而且，你在命令行中定义的任何函数在`bash --debug`会话中是不可见的，因为它们没有被导出到子
    shell。
- en: There’s no difference in how you would create a function in shell scripts, function
    library files, and shell configuration files. But, there a couple of different
    methods for how you structure your functions.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 在 shell 脚本、函数库文件和 shell 配置文件中创建函数的方式没有区别。但是，你在结构化函数时有几种不同的方法。
- en: The first method is to place the entire function on a single line, with or without
    the preceding `function` keyword. This would look exactly as it would if you were
    to create a function on the command-line. Since you’ve already seen that, I’ll
    say no more about it.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个方法是将整个函数放在一行中，可以选择是否使用前面的`function`关键字。这和你在命令行中创建函数的方式完全一样。既然你已经见过这个方法了，我就不再多说了。
- en: 'The other method is to structure your functions in a multi-line format, as
    you would do in other programming languages such as C or Java. This is really
    your best bet, because it makes your code much more readable and less prone to
    error. A quick way to see how that looks is to view the single-line `howdy` function
    that I just created on the command-line with `declare -f`, like so:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种方法是将函数结构化为多行格式，就像在其他编程语言（如 C 或 Java）中一样。这实际上是最好的选择，因为它使代码更加易读，减少了出错的可能性。一个快速的方法是通过`declare
    -f`查看我刚才在命令行上创建的单行`howdy`函数，像这样：
- en: '[PRE7]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'The `declare -f` command automatically converts the function that I entered
    on the command-line into multi-line format. If I wanted to, I could just copy
    and paste this into a shell script file. In fact, I think I will copy it into
    a new `howdy_func.sh` script. Here’s what it will look like:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: '`declare -f`命令会自动将我在命令行中输入的函数转换为多行格式。如果我愿意，我可以将它复制粘贴到 shell 脚本文件中。事实上，我决定将它复制到一个新的`howdy_func.sh`脚本中。它将是这样的：'
- en: '[PRE8]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: As before, the preceding `function` keyword is optional. I’ve chosen to omit
    it, since it serves no function and isn’t compatible with some non-`bash` shells.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，前面的`function`关键字是可选的。我选择省略它，因为它没有实际作用，而且不兼容某些非`bash` shell。
- en: 'Okay, this all looks good, but watch what happens when I run the script:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，这一切看起来都不错，但当我运行脚本时看看会发生什么：
- en: '[PRE9]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Nothing happens, which isn’t good. I’ll show you why in the next section.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 什么都没有发生，这可不好。我会在下一部分展示为什么。
- en: Using Functions in Shell Scripts
  id: totrans-53
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在 shell 脚本中使用函数
- en: You’ll be amazed at how functions can make your shell scripts so much more *functional*.
    (Yeah, I know. That really was a bad pun.) Read on to see how to make that happen.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 你会惊讶于函数如何让你的 shell 脚本变得更加*有功能*。（是的，我知道，那个真的是个糟糕的双关笑话。）继续阅读，看看如何实现这一点。
- en: Creating and Calling Functions
  id: totrans-55
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建并调用函数
- en: 'When you place a function inside a shell script, the function code won’t get
    executed until you call the function. Let’s modify the `howdy_func.sh` script
    to make that happen, like this:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 当你将一个函数放入一个 shell 脚本中时，函数代码不会被执行，直到你调用该函数。让我们修改一下`howdy_func.sh`脚本来实现这一点，像这样：
- en: '[PRE10]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'You see that all I had to do was to place the name of the function outside
    of the function code block. Also, note that the function definition must come
    before the function call. Otherwise, the shell will never be able to find the
    function. Anyway, when I run the script now, it works fine:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 你看到我所做的只是将函数名称放在函数代码块之外。另外，请注意，函数定义必须出现在函数调用之前。否则，shell 将无法找到该函数。无论如何，当我现在运行脚本时，它可以正常工作：
- en: '[PRE11]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'I should also point out that the first curly brace can be on a line by itself
    as you see above, or it can be on the same line as the function name, like this:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 我还应该指出，第一个大括号可以像上面那样单独放在一行，也可以与函数名称放在同一行，像这样：
- en: '[PRE12]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: I personally prefer this way for a simple reason. It’s just that my preferred
    text editor is `vim`, and placing the first curly brace on the same line as the
    function name causes `vim` to activate its automatic indenting feature.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 我个人更喜欢这种方式，有一个简单的理由。就是我偏爱的文本编辑器是`vim`，并且将第一个大括号放在与函数名称同一行会导致`vim`激活其自动缩进功能。
- en: 'The ability to reuse code is one of the coolest features about functions. Instead
    of having to type the same code in every place where you need to perform a certain
    task, just type it once and call it from wherever you need to. Let’s make another
    slight modification to the `howdy_func.sh` script, like so:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 重用代码的能力是函数最酷的功能之一。你不必在每个需要执行某项任务的地方都输入相同的代码，只需输入一次，然后在需要的地方调用它。让我们对`howdy_func.sh`脚本再做一点修改，像这样：
- en: '[PRE13]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Here’s what running the modified script looks like:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 运行修改过的脚本时是这样的：
- en: '[PRE14]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: So, I called the function twice, and it got executed twice. How cool is that?
    But, it gets even better.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，我调用了这个函数两次，它执行了两次。多酷啊？不过，它还会变得更好。
- en: Passing Positional Parameters to Functions
  id: totrans-68
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将位置参数传递给函数
- en: 'You can also pass positional parameters into a function, the same as you can
    pass them into a shell script. To do that, call the function with a value that
    you want to pass as a positional parameter, as you see here in this `greet_func.sh`
    script:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以像将位置参数传递给 shell 脚本一样，将位置参数传递给函数。为此，像你在这个`greet_func.sh`脚本中看到的那样调用函数并传递你希望作为位置参数的值：
- en: '[PRE15]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'You see the `$1` positional parameter in the function. When I call the function,
    I’m passing the value `Donnie` into the function. Here’s what happens when I run
    the script:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 你看到函数中的`$1`位置参数。当我调用该函数时，我传递了`Donnie`这个值给函数。下面是我运行脚本时发生的情况：
- en: '[PRE16]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'You can also pass the positional parameter into the script as you normally
    would, and then pass it into the function, as you see here:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以像平常一样将位置参数传递给脚本，然后将它传递给函数，像你在这里看到的那样：
- en: '[PRE17]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Here’s what happens when I run this script:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我运行这个脚本时发生的情况：
- en: '[PRE18]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'That’s good, but it only works with one parameter. Any additional names that
    you pass in as parameters won’t show up in the output. You can fix that by defining
    additional parameters, like this:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 这很好，但它只适用于一个参数。你传入的任何额外参数都不会出现在输出中。你可以通过定义更多的参数来解决这个问题，像这样：
- en: '[PRE19]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'And, that’s fine if you know that you’ll always want to pass in a specified
    number of parameters. If you don’t want to limit yourself like this, use the `$@`
    as the positional parameter. That way, you can pass in however many parameters
    you want each time that you run the script. Here’s what it looks like:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你知道总是想要传递指定数量的参数，这样也可以。如果你不想限制自己，可以使用`$@`作为位置参数。这样，每次运行脚本时都可以传递任意数量的参数。看起来是这样的：
- en: '[PRE20]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Let’s see what it looks like when I pass in four names:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看当我输入四个名称时会发生什么情况：
- en: '[PRE21]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'That looks good. But, I can still fancy it up a bit, like this:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 看起来不错。但我还可以稍微修饰一下，就像这样：
- en: '[PRE22]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Pretty slick, eh? What’s even more slick is having a function pass values back
    to the main program.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 相当灵巧，是吧？更加灵巧的是，让函数将值传递回主程序。
- en: Passing Values from a Function
  id: totrans-86
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 从函数传递值
- en: Okay, here’s where I need to pause for a moment and clarify something for the
    veterans of other programming languages. Unlike what you may be used to with other
    languages, a shell scripting function cannot *directly* return a value to its
    caller, which is normally the main body of the program.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，这里我需要稍作停顿，并澄清一些其他编程语言的老手可能会遇到的事情。与其他语言不同，Shell脚本函数不能*直接*将值返回给它的调用者，通常是程序的主体部分。
- en: Okay, there is a `return` command that you can use in a function, but it’s not
    the same as the `return` command in other languages. In shell scripts, the only
    thing that you can pass with `return` is just the exit status of a command.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，在函数中有一个`return`命令，但它与其他语言中的`return`命令不同。在Shell脚本中，你可以通过`return`仅传递命令的退出状态。
- en: You can create a function that will return a value, but you have to do it with
    either a **global variable** or a combination of a **local variable** and command
    substitution. Another difference is that in other languages, variables are local
    by default, and you have to specify which variables are to be global. In shell
    scripting, it’s just the opposite. Shell scripting variables are global by default,
    and you have to specify which variables are to be local.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以创建一个返回值的函数，但你必须使用全局变量或局部变量和命令替换的组合来实现。另一个区别是，在其他语言中，变量默认是局部的，你必须指定哪些变量是全局的。在Shell脚本中，情况正好相反。Shell脚本变量默认是全局的，你必须指定哪些变量是局部的。
- en: Now, for those of you who aren’t veterans of other programming languages, allow
    me to explain the difference between local and global variables.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，对于那些不是其他编程语言老手的人，请允许我解释一下局部和全局变量之间的区别。
- en: 'A global variable can be accessed from anywhere in a script, even if you defined
    it within a function. For example, look at the `valuepass` function in this `value1.sh`
    script:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 全局变量可以从脚本的任何地方访问，即使你在函数内定义它。例如，看看这个`value1.sh`脚本中的`valuepass`函数：
- en: '[PRE23]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Here’s what happens when I run the script:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 看看我运行脚本时会发生什么：
- en: '[PRE24]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: In this script, you see that the function does nothing except to define the
    global `textstring` variable and set its value. The value of `textstring` is available
    outside of the function, which means that after calling the function, I can then
    echo back the value of `textstring`.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个脚本中，你可以看到函数除了定义全局变量`textstring`并设置其值外什么也没做。`textstring`的值在函数外部是可用的，这意味着调用函数后，我可以回显`textstring`的值。
- en: 'Now, let’s define `textstring` as a local variable in the `value2.sh` script,
    like so:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们像这样在`value2.sh`脚本中将`textstring`定义为局部变量：
- en: '[PRE25]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Watch what happens when I run the script this time:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 看看这次我运行脚本时会发生什么：
- en: '[PRE26]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: There’s no output this time, because the local variable isn’t accessible outside
    of the function. Or, more accurately, the local variable isn’t *directly* accessible
    outside of the function. There are ways to make the function pass the value of
    a local variable to an external caller, which I’ll show you in just a few moments.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 这次没有输出，因为局部变量在函数外部是不可访问的。或者更准确地说，局部变量在函数外部是*直接*不可访问的。有方法可以使函数将局部变量的值传递给外部调用者，我马上就会给你展示。
- en: First though, I want answer a question that I know you’re anxious to ask. That
    is, if we can use a global variable to pass a value outside of a function, why
    do we need local variables? Well, it’s just that if you use nothing but global
    variables in your functions, you could turn your script into a debugging nightmare.
    That’s because if you accidentally create a variable outside of the function with
    the same name as a global variable that’s inside of the function, you would overwrite
    the value of the variable from within the function.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 不过首先，我想回答一个你一定很想问的问题。也就是说，如果我们可以使用全局变量将值传递到函数外部，那为什么还需要本地变量呢？其实，如果你在函数中只使用全局变量，你可能会把脚本弄成一个调试噩梦。因为如果你不小心在函数外创建了一个与函数内全局变量同名的变量，你就会覆盖函数内部变量的值。
- en: 'By using only local variables inside of functions, you avoid that problem.
    If you have an external variable that has the same name as a local variable that’s
    in a function, the external variable won’t overwrite the internal variable’s value.
    To demo this, let’s create the `value3.sh` script, like so:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 通过在函数内部仅使用本地变量，你可以避免这个问题。如果你有一个与函数内的本地变量同名的外部变量，外部变量不会覆盖本地变量的值。为了演示这个，我们来创建一个
    `value3.sh` 脚本，像这样：
- en: '[PRE27]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'You see that I’ve set the `textstring` variable in the function back to a global
    variable, and I’ve defined the variable again outside of the function. Here’s
    what happens when I run the script now:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 你会看到，我在函数内将 `textstring` 变量重新设置为全局变量，并且在函数外再次定义了这个变量。现在，当我运行脚本时，会发生以下情况：
- en: '[PRE28]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: The second `echo $textstring` command used the new value of `textstring`, which
    overwrote the previous value. That’s fine if that’s what you want to happen, but
    it usually isn’t what you want to happen.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个 `echo $textstring` 命令使用了 `textstring` 的新值，覆盖了之前的值。如果这是你希望发生的情况，那是没问题的，但通常这并不是你想要的结果。
- en: 'One way to have a function pass a value with a local variable is to call the
    function from within a command substitution construct. To demo that, create the
    `value4.sh` script, like so:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 让一个函数通过本地变量传递值的一种方法是通过命令替换结构来调用该函数。为了演示这一点，创建一个 `value4.sh` 脚本，像这样：
- en: '[PRE29]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: You see here that I’ve created the external `result` variable, and assigned
    to it the value that was obtained by the `$(valuepass)` command substitution.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 你会看到，我创建了外部的 `result` 变量，并将通过 `$(valuepass)` 命令替换获得的值赋给了它。
- en: 'Another method for obtaining a value from a function is to use a **result variable**.
    This involves passing the *name* of a variable into the function when you call
    it, and then assigning a value to that variable inside the function. Let’s look
    at the `value5.sh` script to see how that works:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 获取函数值的另一种方法是使用 **结果变量**。这涉及到在调用函数时将一个 *变量名* 传递到函数中，然后在函数内部给该变量赋值。让我们看一下 `value5.sh`
    脚本，看看它是如何工作的：
- en: '[PRE30]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: The `valuepass result` command calls the function and passes the name of the
    `result` variable into the function, via the `$1` positional parameter. Understand
    though, that `result` still doesn’t have an assigned value, so the only thing
    that you’re passing into the function is just the name of the variable, and nothing
    else.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: '`valuepass result` 命令调用函数，并通过 `$1` 位置参数将 `result` 变量的名称传递给函数。不过需要理解的是，`result`
    仍然没有被赋值，所以你传递给函数的只是变量的名称，而没有传递其他任何东西。'
- en: Up to this point, you’ve only seen positional parameters used to pass values
    into the script when you invoke the script. Here, you seen how positional parameters
    can also be used to pass values from the main body of a script into a function.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，你只看到过位置参数用于在调用脚本时传递值。这里，你看到了位置参数也可以用于将值从脚本的主体传递到函数中。
- en: Inside the function, this variable name is represented by the `$1` positional
    parameter. This variable name is assigned as the value of the local `__internalvar`
    variable. The next line assigns `Shell scripting is cool!` as the value of the
    local `myresult` variable. In the final line, the `eval` command sets the value
    of `$myresult` as the value of the `$__internalvar` variable.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 在函数内部，这个变量名由 `$1` 位置参数表示。这个变量名被赋值给本地变量 `__internalvar`。下一行将 `Shell scripting
    is cool!` 赋值给本地变量 `myresult`。在最后一行，`eval` 命令将 `$myresult` 的值设置为 `$__internalvar`
    变量的值。
- en: Remember that the value of the `__internalvar` variable is `result`, which is
    the name of the variable that we passed into the function. Also, be aware that
    this is now a global variable, because I didn’t specify the `local` keyword here.
    This means that its value can be passed back to the main body of the script.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，`__internalvar`变量的值是`result`，这是我们传入函数的变量名。同时，请注意，由于这里没有指定`local`关键字，这个变量现在是全局变量。这意味着它的值可以返回到脚本的主体部分。
- en: So now, `$__internalvar` is really the `result` variable with `Shell scripting
    is cool!` as its assigned value.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 所以现在，`$__internalvar`实际上就是`result`变量，且它的值是`Shell scripting is cool!`。
- en: Understand though, that you don’t want the variable name that you pass into
    a function to be the same as the name of the local variable that’s inside the
    function. Otherwise, the `eval` command won’t be able to properly set the value
    of the variable. That’s why I prefaced the name of the local variable with a pair
    of underscores, so that I can be sure to prevent having a variable with the same
    name outside of the function. (Of course, only one underscore would have sufficed,
    but the accepted convention is to use two underscores.)
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 不过要理解的是，你传入函数的变量名不能与函数内部的局部变量名相同。否则，`eval`命令将无法正确设置变量的值。这就是为什么我在局部变量名前加了两个下划线，以确保避免在函数外部有相同名称的变量。（当然，单个下划线也能达到目的，但约定俗成的做法是使用两个下划线。）
- en: Next, let’s create some libraries.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们来创建一些库。
- en: Creating Function Libraries
  id: totrans-119
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建函数库
- en: For a convenient way to make your functions reusable, just place them into a
    function library. Then, from within your scripts, call the desired libraries with
    either a `source` command or a dot command. If you’re the only one who will ever
    use the libraries, you can place them in your own home directory.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 为了方便地使函数可重用，只需将它们放入函数库中。然后，在你的脚本中，使用`source`命令或点命令调用所需的库。如果只有你一个人会使用这些库，可以将它们放在你的主目录中。
- en: If you want to make them available for everyone, you can place them in a central
    location, such as in the `/usr/local/lib/` directory.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你希望所有人都能使用它们，可以将它们放在一个中心位置，比如`/usr/local/lib/`目录下。
- en: 'For a simple demonstration, I’ve created the `donnie_library` file in the `/usr/local/lib/`
    directory with two simple functions. It looks like this:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 为了简单演示，我在`/usr/local/lib/`目录中创建了`donnie_library`文件，里面包含了两个简单的函数。它看起来是这样的：
- en: '[PRE31]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: (I live in the state of Georgia, which explains the second function.)
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: （我住在乔治亚州，这也解释了第二个函数的存在。）
- en: There’s no need to set the executable permission on this file, because it only
    contains code that will be called in by an executable script.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 这个文件不需要设置可执行权限，因为它只包含将在可执行脚本中被调用的代码。
- en: 'Next, I created the `library_demo1.sh` script, which looks like this:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我创建了`library_demo1.sh`脚本，它看起来是这样的：
- en: '[PRE32]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'You see that I used the `source` command to reference the `donnie_library`
    file. I then called the `howdy_world` function as I would normally do. Running
    the script looks like this:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 你看到我使用`source`命令引用了`donnie_library`文件。然后，我像通常那样调用了`howdy_world`函数。运行脚本看起来是这样的：
- en: '[PRE33]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'I also created the `library_demo2.sh` file, which looks like this:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 我还创建了`library_demo2.sh`文件，它看起来是这样的：
- en: '[PRE34]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: This time I replaced the `source` command with a dot, to show you that they
    both do the exact same thing.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 这次我用点命令替换了`source`命令，向你展示它们实际上执行的是相同的操作。
- en: Be aware that using the `source` keyword works on `ash`, `ksh`, `zsh`, and `bash`,
    but it doesn’t work on certain other shells, such as `dash` or Bourne. If you
    need your scripts to run on as many shells as possible, you’ll need to use the
    dot, and avoid using `source`.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，使用`source`关键字适用于`ash`、`ksh`、`zsh`和`bash`，但在某些其他shell（如`dash`或Bourne）上不起作用。如果你希望脚本能够在尽可能多的shell上运行，你需要使用点命令（dot），而避免使用`source`。
- en: 'I then called the second function in the library file. Running this script
    looks like this:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我在库文件中调用了第二个函数。运行这个脚本看起来是这样的：
- en: '[PRE35]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'For something a bit more practical, let’s add a network checking function,
    using a `case..esac` construct. Unfortunately, the `donnie_library` file is now
    too large to show you here in the book, but you can download it from the Github
    repository. Still though, I do want to point out one thing about this `case..esac`
    construct, which you see here:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 为了做一个稍微更实用的例子，我们加入一个网络检查函数，使用`case..esac`结构。不幸的是，`donnie_library`文件现在太大，无法在书中展示，但你可以从Github仓库下载它。不过，我还是想指出关于这个`case..esac`结构的一点：
- en: '[PRE36]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Note how for the first condition I used a `"")` construct. The pair of double-quotes,
    with no blank space between them, means that no value has been passed in for the
    positional parameter. This also means that `google.com` will be used as the default
    site name.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，在第一个条件中，我使用了`"")`构造。成对的双引号，中间没有空格，意味着位置参数没有传入任何值。这也意味着`google.com`会作为默认的网站名称。
- en: 'Now, the `library_demo3.sh` script that uses this new function looks like this:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，使用这个新函数的`library_demo3.sh`脚本如下所示：
- en: '[PRE37]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Running the script without supplying an argument looks like this:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 如果没有提供参数，运行脚本的结果是这样的：
- en: '[PRE38]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Here’s how it looks when I supply a valid site name as the argument:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 这是当我提供有效网站名称作为参数时的结果：
- en: '[PRE39]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'And finally, here’s what I get when I supply an invalid site name:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，这是当我提供一个无效的网站名称时得到的结果：
- en: '[PRE40]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: I know, it’s a crying shame that there’s no website that’s named after me. (I
    might have to correct that problem some day.)
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 我知道，真可惜没有一个网站是以我命名的。（也许某天我得解决这个问题。）
- en: And, guess what? That’s really all I have to say about function libraries. Let’s
    move on to the real world.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 你猜怎么着？这就是我对函数库要说的全部内容。接下来让我们进入现实世界。
- en: Looking at Some Real-World Examples
  id: totrans-149
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 看一些真实世界的例子
- en: Here are a few cool examples of functions in action. Enjoy!
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有几个函数实际应用的酷例子，快来看看吧！
- en: Checking Network Connectivity
  id: totrans-151
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 检查网络连接
- en: This function is essentially the same as the one that I’ve just shown you in
    the previous section. The only real difference is that I’m using an `if..then`
    construct instead of the `case..esac` construct.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数本质上与我在前面一节中展示的函数相同。唯一的真正不同之处在于，我使用了`if..then`结构，而不是`case..esac`结构。
- en: 'Also, I placed this function into the actual executable script. But, you can
    easily move it into a library file if you desire. (I can’t show you the entire
    script here due to book formatting constraints, but you can download it from the
    Github repository. It’s the `network_func.sh` file.) Anyway, here’s the important
    part that I really want you to see:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我将这个函数放入了实际可执行的脚本中。不过，如果你愿意，也可以轻松将它移到库文件中。（由于书籍排版的限制，我不能在这里展示完整脚本，但你可以从 Github
    仓库下载。它是`network_func.sh`文件。）总之，下面是我真正希望你看到的重点部分：
- en: '[PRE41]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'You see that after I defined the `network()` function, I called it three different
    times. I first called it without a positional parameter, so that it would ping
    `google.com`. I then called it with another real website and then with a fake
    website as the positional parameter. Here’s what I get when I run this new script:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 你看，在我定义了`network()`函数之后，我调用了它三次。我第一次调用时没有传入位置参数，这样它就会 ping `google.com`。接着我又分别用另一个真实网站和一个假的网站作为位置参数调用了它。下面是我运行这个新脚本时得到的结果：
- en: '[PRE42]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'That part works. Let’s now look in the system log file to see if the `logger`
    utility that’s in the function actually made the appropriate log entries:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 那部分没问题。现在让我们查看系统日志文件，看看函数中的`logger`工具是否正确记录了日志条目：
- en: '[PRE43]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: Yeah, that part works too. So once again, we have achieved coolness. (Of course,
    you can also modify the script so that you can supply your own positional parameter
    as an argument. I’ll leave it to you to do that.)
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 是的，那部分也正常工作。所以再次证明，我们已经实现了酷炫功能。（当然，你也可以修改脚本，使你能够将自己的位置参数作为参数传入。我就不再赘述这部分内容了。）
- en: Be aware that I tested this script on a Fedora machine, which still uses the
    old-style `rsyslog` log files. If you try this on Debian, you’ll need to install
    `rsyslog` yourself. By default, Debian 12 now only uses the `journald` logging
    system, and doesn’t come with `rsyslog` installed.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我是在一台 Fedora 机器上测试这个脚本的，它仍然使用旧版的`rsyslog`日志文件。如果你在 Debian 上尝试此操作，你需要自己安装`rsyslog`。默认情况下，Debian
    12现在只使用`journald`日志系统，并且没有安装`rsyslog`。
- en: Next, is a little something that I whipped up for myself.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，这是我为自己编写的一些小东西。
- en: Using the CoinGecko API
  id: totrans-162
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用CoinGecko API
- en: CoinGecko is a cool website where you can go to check on the prices and statistics
    of pretty much every cryptocurrency there is. It’s fairly quick to use if you
    just need to check on one coin, but it can be fairly time-consuming if you need
    to check on multiple coins.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: CoinGecko是一个很酷的网站，你可以在这里查看几乎所有加密货币的价格和统计信息。如果你只需要查看一个币种，它使用起来相当快速，但如果你需要查看多个币种，就可能会比较耗时。
- en: You can create a custom portfolio of coins, which is useful if you always want
    to see the same list of coins. But, it’s not so useful if you always want to check
    on different lists of coins. So, you might like to streamline the process a bit.
    For that, you can create a shell script that uses the CoinGecko **Application
    Programming Interface** (**API**).
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以创建一个自定义的硬币投资组合，这在你总是希望看到相同的硬币列表时很有用。但如果你总是想查看不同的硬币列表，这样做就不太有用了。所以，你可能想简化这个过程。为此，你可以创建一个使用
    CoinGecko **应用程序编程接口**（**API**）的 shell 脚本。
- en: To take full advantage of all of the CoinGecko API features, you’ll need to
    become a paying customer, which is rather expensive. Fortunately, you don’t need
    to do that for this demo. Instead, you’ll just use CoinGecko’s public API key,
    which is free-of-charge. To demo this, let’s do a hands-on lab.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 要充分利用 CoinGecko API 的所有功能，你需要成为付费客户，这个费用相当高。幸运的是，做这个演示时你不需要这样做。你只需使用 CoinGecko
    的公共 API 密钥，它是免费的。为了演示这一点，我们来做一个动手实验。
- en: Hands-on Lab – Creating the coingecko.sh Script
  id: totrans-166
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 动手实验 – 创建 coingecko.sh 脚本
- en: 'To begin, take a look at CoinGecko’s documentation page (https://www.coingecko.com/api/documentation),
    and follow these steps as mentioned below:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，查看 CoinGecko 的文档页面（https://www.coingecko.com/api/documentation），并按照以下步骤进行操作：
- en: Scroll down the page, and you’ll see a list of the various functions that you
    can perform with the public API. You can use the forms in the drop-down lists
    to create the code that you’ll copy into a shell script. I’ve already created
    the `coingecko.sh` shell script that performs three of those functions, which
    you can download from the Github repository. Before you use it though, you’ll
    need to ensure that the `curl` and `jq` packages are installed on your system.
    Anyway, here’s how the script works.
  id: totrans-168
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 向下滚动页面，你会看到可以使用公共 API 执行的各种功能列表。你可以使用下拉列表中的表单创建你将复制到 shell 脚本中的代码。我已经创建了`coingecko.sh`脚本，它执行其中三个功能，你可以从
    Github 仓库下载。在使用之前，你需要确保你的系统上已安装`curl`和`jq`软件包。无论如何，下面是脚本的工作方式。
- en: At the top of the `gecko_api` function, I defined the `coin` and `currency`
    variables as positional parameters `$1` and `$2`. The `if [ -z $coin ]; then`
    line checks to see if the value of `coin` is zero length. If it is, it means that
    I haven’t entered any arguments when I invoked the script. So, it will then echo
    a series of statements about how to invoke the script.
  id: totrans-169
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`gecko_api`函数的顶部，我将`coin`和`currency`变量定义为位置参数`$1`和`$2`。`if [ -z $coin ]; then`这一行检查`coin`的值是否为零长度。如果是，说明在调用脚本时我没有输入任何参数。因此，脚本会显示一系列关于如何调用脚本的说明。
- en: 'Next, you see this `elif` stanza:'
  id: totrans-170
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，你会看到这个`elif`结构：
- en: '[PRE44]'
  id: totrans-171
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE44]'
- en: I copied this `curl` command from the CoinGecko documentation page, and pasted
    it into the script.
  id: totrans-172
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我从 CoinGecko 的文档页面复制了这个`curl`命令，并将其粘贴到脚本中。
- en: Then, I piped the output into the `jq` utility to convert the normal **json**
    output to **pretty json** format.
  id: totrans-173
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我将输出管道传递给`jq`工具，将普通的**json**输出转换为**美化后的 json**格式。
- en: I then piped that output into `tee` in order to both view the output on screen
    and save it to a text file. Invoking the script with the `list` argument will
    download the entire list of coins that are supported by the API. The `elif` construct
    in the next stanza is the same as this `elif` construct, except that it will show
    a list of *versus currencies* that you can use for pricing the coins.
  id: totrans-174
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我将输出管道传递给`tee`命令，以便在屏幕上查看输出并将其保存到文本文件中。使用`list`参数调用脚本将下载 API 支持的所有硬币列表。下一行的`elif`结构与这个`elif`结构相同，只是它将显示可以用于定价硬币的*对比货币*列表。
- en: The `else` construct in the final stanza of the function requires you to enter
    both a coin and a versus currency as arguments. The original code from the documentation
    page contained the actual names of the coin and versus currency that I entered
    into the form on the documentation page. I changed them to the `$coin` and `$currency`
    variables, respectively. I then had to change the pair of single quotes that surround
    the URL with a pair of double quotes, so that the `$` in the variable names would
    be interpreted correctly.
  id: totrans-175
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 函数最后一行的`else`结构要求你输入一个硬币和一个对比货币作为参数。文档页面上的原始代码包含了我在文档页面表单中输入的硬币和对比货币的实际名称。我将它们分别更改为`$coin`和`$currency`变量。接着，我需要将围绕
    URL 的一对单引号改为一对双引号，以便变量名中的`$`能够正确解析。
- en: 'Let’s say that you want to check the price of Bitcoin in US dollars. First,
    open the `coinlist.txt` file that you created when you ran the `./coingecko list`
    command. Search for Bitcoin, and you’ll find a stanza that looks like this:'
  id: totrans-176
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 假设你想查看比特币的美元价格。首先，打开你在运行`./coingecko list`命令时创建的`coinlist.txt`文件。搜索比特币，你会找到一段类似于这样的内容：
- en: '[PRE45]'
  id: totrans-177
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Next, open the `currency_list.txt` that you created when you ran the `./coingecko
    currencies` command. Scroll down until you find the versus currency that you want
    to use to price your particular coin or coins. Now, to view the price of your
    coin(s) in your desired currency, enter the `"id:"` value for the coin from the
    `coinlist.txt` file as the first argument, and the desired versus currency as
    the second argument, like this:'
  id: totrans-178
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，打开你在运行`./coingecko currencies`命令时创建的`currency_list.txt`文件。向下滚动，直到找到你想用来为特定币种定价的基准货币。现在，要查看你想要的币种在所选货币中的价格，输入
    `coinlist.txt` 文件中该币种的 `"id:"` 值作为第一个参数，并将期望的基准货币作为第二个参数，像这样：
- en: '[PRE46]'
  id: totrans-179
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE46]'
- en: So, it looks like the current price of Bitcoin is $34664 US.
  id: totrans-180
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 所以，看起来当前比特币的价格是 $34664 美元。
- en: 'You can view multiple coins at a time by entering a comma-separated list, like
    this:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过输入用逗号分隔的列表一次查看多个币种，像这样：
- en: '[PRE47]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'If you’re a trader, you might want to check the price of an altcoin in terms
    of some other versus currency, such as Bitcoin satoshis. Here, I’m checking the
    Bitcoin satoshi price of Dero:'
  id: totrans-183
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果你是一个交易者，你可能想要查看某个山寨币相对于其他货币的价格，比如比特币的 satoshi。这里，我正在查看 Dero 的比特币 satoshi 价格：
- en: '[PRE48]'
  id: totrans-184
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE48]'
- en: So, the current satoshi price of Dero is 8544.47 sats. (Of course, these prices
    will be different by the time you look at them.)
  id: totrans-185
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 所以，Dero 的当前 satoshi 价格是 8544.47 sats。（当然，当你查看时，这些价格会有所不同。）
- en: 'The top three lines of the output are from the curl command that the script
    used to download information about the coins. For some strange reason, bash considers
    this curl message as an error message, even though it really isn’t. But, that’s
    actually good, because you can prevent having to see this message by using a stderr
    redirector at the end of your command, like this:'
  id: totrans-186
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 输出的前三行是脚本用来下载有关币种信息的 curl 命令。由于某种奇怪的原因，bash 把这个 curl 消息当做错误消息，尽管它实际上并不是错误消息。不过，这其实是好事，因为你可以通过在命令末尾使用标准错误重定向器来避免看到这个消息，就像这样：
- en: '[PRE49]'
  id: totrans-187
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Oh, I almost forgot about the most important part of the script, which is the
    command that calls the function:'
  id: totrans-188
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 哦，我差点忘了脚本中最重要的部分，那就是调用函数的命令：
- en: '[PRE50]'
  id: totrans-189
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE50]'
- en: It asks for two positional parameters, but will work just fine if you just enter
    either `list` or `currencies` as a single argument.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 它要求输入两个位置参数，但如果你只输入 `list` 或 `currencies` 作为单个参数，它也能正常工作。
- en: 'Okay, this is good. But, what if you have a very long list of coins that you
    want to track, and you don’t want to type that whole long list in every time that
    invoke this script? Well, that’s easy. I’ll just create the mycoins.sh script,
    which will call the coingecko.sh script. Here’s how it looks:'
  id: totrans-191
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 好的，这很好。但如果你有一个非常长的币种列表，并且每次调用这个脚本时都不想输入这么长的列表怎么办？这个很简单。我将创建一个 mycoins.sh 脚本，它将调用
    coingecko.sh 脚本。它的样子如下：
- en: '[PRE51]'
  id: totrans-192
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE51]'
- en: Of course, you can edit this script to add your own list of favorite coins.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，你可以编辑这个脚本，加入你自己喜欢的币种列表。
- en: For a variation on this theme, download the `coingecko-case.sh` script, too.
    It’s the same script, but I built it with a `case..esac` construct instead of
    an `if..then` contruct.
  id: totrans-194
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 作为此主题的变体，也可以下载 `coingecko-case.sh` 脚本。它与之前的脚本相同，但我使用了 `case..esac` 结构，而不是 `if..then`
    结构。
- en: That’s about it for functions, at least for now. But, don’t be too surprised
    if you see more throughout the rest of this book.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是关于函数的内容，至少目前是这样。不过，如果你在本书的其余部分看到更多内容，也不要太惊讶。
- en: Now, let’s wrap up and move on.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们总结一下并继续前进。
- en: Summary
  id: totrans-197
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: Functions are an important part of most every modern programming language. In
    this chapter I’ve shown you how to construct them, how to call them, and how to
    create function libraries that you can either use for yourself or share with other
    users.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 函数是几乎所有现代编程语言中的重要组成部分。在本章中，我向你展示了如何构建函数、如何调用函数，以及如何创建函数库，你可以为自己使用或与其他用户共享。
- en: In the next chapter, I’ll show you how to perform mathematical operations with
    shell scripts. I’ll see you there.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章，我将向你展示如何使用 shell 脚本执行数学运算。到时见。
- en: Questions
  id: totrans-200
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: Which two of the following methods would you use to create a function? (Choose
    two.)
  id: totrans-201
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下哪两种方法可以用来创建函数？（选择两项。）
- en: '`function function_name()`'
  id: totrans-202
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`function function_name()`'
- en: '`function_name()`'
  id: totrans-203
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`function_name()`'
- en: '`declare -f function_name`'
  id: totrans-204
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`declare -f function_name`'
- en: '`declare -F function_name`'
  id: totrans-205
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`declare -F function_name`'
- en: You want to create a function that will pass the value of a variable back to
    the main program. Which of the following should you use to do that?
  id: totrans-206
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你想创建一个函数，将变量的值返回给主程序。以下哪项应当使用来实现这一功能？
- en: A global variable
  id: totrans-207
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一个全局变量
- en: A local variable
  id: totrans-208
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一个局部变量
- en: A `return` statement
  id: totrans-209
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一个 `return` 语句
- en: A continue statement
  id: totrans-210
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一个 continue 语句
- en: You want to create a function that any user can use in his or her own scripts.
    What is the best way to do that?
  id: totrans-211
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你想创建一个任何用户都可以在他或她的脚本中使用的函数。最好的方法是什么？
- en: Create a function library file in a central location, and make it executable.
  id: totrans-212
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在一个中心位置创建一个函数库文件，并使其可执行。
- en: Add the new functions to the `/etc/bashrc` file.
  id: totrans-213
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将新函数添加到 `/etc/bashrc` 文件中。
- en: Create a function library file in a central location, but don’t make it executable.
  id: totrans-214
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在一个中心位置创建一个函数库文件，但不要使其可执行。
- en: D. Create a function library file in your own home directory.
  id: totrans-215
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: D. 在你自己的主目录中创建一个函数库文件。
- en: Which two of the following commands would you use to reference a function library
    in your shell scripts? (Choose two.)
  id: totrans-216
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下面哪两个命令可以用来在你的 shell 脚本中引用一个函数库？（选择两个）
- en: '`load`'
  id: totrans-217
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`load`'
- en: '`reference`'
  id: totrans-218
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`reference`'
- en: '`source`'
  id: totrans-219
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`source`'
- en: '`.`'
  id: totrans-220
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`.`'
- en: You want to see the list of functions that are loaded into memory, along with
    their associated source code. Which command would you use?
  id: totrans-221
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你想查看加载到内存中的函数列表，以及它们的源代码。你应该使用哪个命令？
- en: '`declare -f`'
  id: totrans-222
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`declare -f`'
- en: '`declare -F`'
  id: totrans-223
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`declare -F`'
- en: '`debugger -f`'
  id: totrans-224
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`debugger -f`'
- en: '`debugger -F`'
  id: totrans-225
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`debugger -F`'
- en: Further Reading
  id: totrans-226
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: 'Bash Functions: https://linuxize.com/post/bash-functions/'
  id: totrans-227
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'Bash 函数: [https://linuxize.com/post/bash-functions/](https://linuxize.com/post/bash-functions/)'
- en: 'Returning Values from Bash Functions: https://www.linuxjournal.com/content/return-values-bash-functions'
  id: totrans-228
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '从 Bash 函数返回值: [https://www.linuxjournal.com/content/return-values-bash-functions](https://www.linuxjournal.com/content/return-values-bash-functions)'
- en: 'Bash Function & How to Use It {Variables, Arguments, Return}: https://phoenixnap.com/kb/bash-function'
  id: totrans-229
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'Bash 函数及其使用方法 {变量、参数、返回值}: [https://phoenixnap.com/kb/bash-function](https://phoenixnap.com/kb/bash-function)'
- en: 'Writing shell scripts-Lesson 15: Errors and Signals and Traps: http://linuxcommand.org/lc3_wss0150.php'
  id: totrans-230
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '编写 shell 脚本 - 第15课：错误、信号和陷阱: [http://linuxcommand.org/lc3_wss0150.php](http://linuxcommand.org/lc3_wss0150.php)'
- en: (Note that the author of this tutorial uses all upper-case letters for the names
    of scripting variables, which is something that I don’t advocate. Other than that,
    it’s a good tutorial.)
  id: totrans-231
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: （请注意，本教程的作者使用全大写字母来表示脚本变量名称，我个人不推荐这样做。除此之外，这是一个很好的教程。）
- en: 'Advance Bash Script Guide: https://tldp.org/LDP/abs/html/abs-guide.html#FUNCTIONS'
  id: totrans-232
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'Bash 脚本高级指南: [https://tldp.org/LDP/abs/html/abs-guide.html#FUNCTIONS](https://tldp.org/LDP/abs/html/abs-guide.html#FUNCTIONS)'
- en: Answers
  id: totrans-233
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 答案
- en: a and b
  id: totrans-234
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: a 和 b
- en: b
  id: totrans-235
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: b
- en: c
  id: totrans-236
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: c
- en: c and d
  id: totrans-237
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: c 和 d
- en: a
  id: totrans-238
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: a
- en: Join our community on Discord!
  id: totrans-239
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 加入我们的 Discord 社区！
- en: Read this book alongside other users, Linux experts, and the author himself.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 与其他用户、Linux 专家和作者本人一起阅读这本书。
- en: Ask questions, provide solutions to other readers, chat with the author via
    Ask Me Anything sessions, and much more. Scan the QR code or visit the link to
    join the community.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 提问、为其他读者提供解决方案、通过 "问我任何问题"（Ask Me Anything）环节与作者聊天，等等。扫描二维码或访问链接加入社区。
- en: https://packt.link/SecNet
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://packt.link/SecNet](https://packt.link/SecNet)'
- en: '![](img/QR_Code10596186092701843.png)'
  id: totrans-243
  prefs: []
  type: TYPE_IMG
  zh: '![](img/QR_Code10596186092701843.png)'
