- en: '15'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '15'
- en: Automating Server Configuration with Ansible
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Ansible 自动化服务器配置
- en: Nowadays, it’s not uncommon to have hundreds of servers that make up your organization’s
    infrastructure. As our user base grows, we’re able to scale our environment to
    meet the demands of our customers. As we scale our resources and add additional
    servers, the amount of time we spend configuring them and setting them up increases
    considerably. The time spent setting up new servers can be a major burden—especially
    if we need to create hundreds of servers within a small window of time. As workload
    demands increase, we need to have a solution in place to manage our infrastructure
    and quickly deploy new resources with as small a workload as possible. In this
    chapter, we explore the concept of configuration management along with automated
    deployments. This sure sounds complicated, but it’s not—you’ll be surprised how
    easy it is to automate your configuration.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 如今，拥有成百上千台服务器组成组织基础设施并不罕见。随着用户基数的增加，我们能够扩展环境以满足客户需求。当我们扩展资源并增加额外服务器时，配置和设置这些服务器所花费的时间会显著增加。设置新服务器所花费的时间可能成为一项重大负担——特别是当我们需要在短时间内创建数百台服务器时。随着工作负载的增加，我们需要有一个解决方案来管理我们的基础设施，并尽可能以最小的工作量快速部署新资源。在本章中，我们将探讨配置管理的概念以及自动化部署。听起来很复杂，但其实并不难——你会惊讶于自动化配置有多么简单。
- en: 'In this chapter, we will cover:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将覆盖以下内容：
- en: Understanding the need for configuration management
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解配置管理的需求
- en: Why Ansible?
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为什么选择 Ansible？
- en: Creating a Git repository
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建 Git 仓库
- en: Getting started with Ansible
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 开始使用 Ansible
- en: Making your servers do your bidding
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 让你的服务器按照你的指令行事
- en: Putting it all together – automating web server deployment
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将一切整合在一起——自动化部署 Web 服务器
- en: Using Ansible’s pull method
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Ansible 的拉取方式
- en: In the introduction, I’ve already given you some examples of why you might want
    to consider building automation into your workflow and implement an effective
    solution in your environment. In the next section, we’ll explore the need for
    automation in more detail before we actually get started.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在介绍中，我已经给出了你可能希望将自动化集成到工作流中的一些示例，并在你的环境中实现有效的解决方案。在接下来的部分，我们将更详细地探讨自动化的需求，然后再开始实际操作。
- en: Understanding the need for configuration management
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解配置管理的需求
- en: When I first started working in the IT industry, it was a much different landscape
    than it is today. Servers were all physical, and any time you needed a new server,
    you literally needed to call a vendor and order one.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 当我刚开始从事 IT 行业时，那个时候的环境和今天有很大的不同。服务器都是物理服务器，每当你需要一台新服务器时，你需要打电话给供应商并订购一台。
- en: You waited for a week or two for the server to be built and sent to you. When
    it arrived, you installed it in a rack, set up an operating system, and then installed
    whatever applications you needed. You then tested the server for a while to make
    sure the combination of software, hardware, and drivers was stable and reliable.
    After some time, you’d deploy the new server into production.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能等待了一到两周才等到服务器搭建并发货给你。收到服务器后，你把它安装到机架上，设置操作系统，然后安装所需的应用程序。你会测试这台服务器一段时间，确保软件、硬件和驱动程序的组合是稳定可靠的。过了一段时间，你就可以将新服务器投入生产使用。
- en: Nowadays, it’s still the case that system administrators often need to purchase
    and install hardware, much like the process I mentioned in the previous paragraph.
    However, with virtual machines and containers, the physical hardware we install
    is commonly just a catalyst to host virtual resources. In the past, we had one
    physical server for each use case, which meant we needed to have very large server
    rooms. But in modern times, you may have a server with dozens of cores that are
    capable of running hundreds of virtual machines. But the problem of configuration
    remains—the process of setting up an operating system and applications is a very
    time-consuming endeavor.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 如今，系统管理员仍然经常需要购买和安装硬件，就像我在前面提到的那样。然而，随着虚拟机和容器的出现，我们安装的物理硬件通常只是托管虚拟资源的催化剂。过去，我们为每个用例配备一台物理服务器，这意味着我们需要非常大的服务器机房。但在现代，你可能有一台具有数十个核心的服务器，能够运行成百上千个虚拟机。但配置问题依然存在——设置操作系统和应用程序的过程是一个非常耗时的工作。
- en: As the landscape changed, the need for automation increased. Servers needed
    to be deployed quickly and efficiently. With the large number of servers in a
    typical data center, it became less and less practical to connect to each of them
    and configure them one by one every time a change was necessary. For example,
    when a security vulnerability hit the news, the typical administrator would need
    to manually install a patch on every server. This could take days or even weeks.
    That’s not very efficient.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 随着技术环境的变化，对自动化的需求增加。服务器需要快速高效地部署。在典型数据中心中，由于服务器数量庞大，每次需要变更时，逐一连接每台服务器并进行配置变得越来越不现实。例如，当安全漏洞成为新闻时，通常的管理员需要手动在每台服务器上安装补丁。这可能需要几天甚至几周的时间。这显然效率低下。
- en: To better deal with this issue, the concept of configuration management has
    become very popular. With configuration management, an administrator can write
    some sort of code (such as a script) and then use a utility to execute it across
    every server. Configuration management is also known as **Infrastructure as Code**
    (**IaC**) and basically lets the administrator define a set of guidelines for
    servers of various types and have them automatically be provisioned to meet those
    requirements. This automation saves a ton of work.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更好地应对这一问题，配置管理的概念变得非常流行。通过配置管理，管理员可以编写某种代码（例如脚本），然后使用工具在每台服务器上执行它。配置管理也被称为**基础设施即代码**（**IaC**），基本上让管理员为各种类型的服务器定义一组指南，并自动配置服务器以满足这些要求。这种自动化节省了大量的工作。
- en: Configuration management also comes into play while provisioning a new server.
    Imagine defining some rules for a specific type of server, and having it come
    to life meeting those exact specifications. The applications you want it to have
    are installed during the provisioning process, configuration files are copied
    over, users are created, and firewall rules are put in place, all automatically
    as defined in your specification. Put even more simply, imagine setting up something
    like a web server with just a single command. No need to install Apache or do
    any of that manual work. You simply request a server, and the configuration management
    solution you have in place will take care of the rest.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 配置管理在配置新服务器时也发挥作用。假设为特定类型的服务器定义一些规则，并使其按照这些规则生效。在配置过程中，您希望它安装的应用程序会被自动安装，配置文件被复制，用户被创建，防火墙规则被设置，所有这些都按照您的规范自动完成。更简单地说，假设您只需要通过一个命令就能设置一个类似于
    Web 服务器的环境。无需安装 Apache 或做任何手动工作。您只需要请求一个服务器，您所设置的配置管理解决方案将会处理其余的工作。
- en: IaC, which is basically a fancy term for configuration management, is essentially
    just the automated running of scripts on your servers. In this book, we’ve looked
    at automation already. In *Chapter 6*, *Boosting Your Command-line Efficiency*,
    we wrote a simple script that we could use to back up a server. That same mentality
    can be used for provisioning servers as well, by simply having a server run a
    script when it comes online. For existing servers, you can make a change once
    and apply that change to every server you manage, or even just a subset.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: '**IaC**，基本上是配置管理的一个花哨术语，本质上就是在服务器上自动运行脚本。在本书中，我们已经介绍过自动化。在*第6章*，*提升命令行效率*中，我们编写了一个简单的脚本，可以用来备份服务器。同样的思路也可以用于服务器的配置，只需在服务器上线时让其运行一个脚本。对于现有的服务器，您可以只修改一次并将该变更应用到您管理的每台服务器，甚至是某些子集。'
- en: This is where configuration management utilities, such as Chef, Puppet, and
    others, come into play. Each of these solutions features a specific type of scripting
    language that is designed from the ground up to facilitate the provisioning of
    resources. With such utilities, there is typically some sort of program (or locally
    installed agent) that interprets the instructions from a central server and runs
    them on its clients. Each solution is relatively smart; it will determine what
    needs to be done and perform the steps.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 配置管理工具，如 Chef、Puppet 等，在这里发挥作用。这些解决方案中的每一个都具有一种特定类型的脚本语言，旨在从零开始简化资源的配置过程。使用这些工具时，通常会有某种程序（或本地安装的代理）来解释来自中央服务器的指令，并在其客户端上执行这些指令。每个解决方案都相对智能，它将确定需要完成的任务并执行相关步骤。
- en: If a requirement is met, the instruction is skipped. If a required resource
    is not present, it will be configured appropriately. One such configuration management
    solution is Ansible, which we will use in this chapter.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 如果满足某个要求，指令会被跳过。如果缺少必要的资源，它将被适当配置。一个这样的配置管理解决方案是Ansible，我们将在本章中使用它。
- en: Why Ansible?
  id: totrans-22
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为什么选择Ansible？
- en: In this chapter, I will show you how to set up Ansible, and then we will use
    it to automate some configuration tasks. By the end of this chapter, you’ll understand
    the basic concepts you can use to start the process of automating deployments
    in your organization. You may be wondering, then, why Ansible and not one of the
    other solutions, such as Chef or Puppet?
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我将向你展示如何设置Ansible，接着我们将使用它来自动化一些配置任务。到本章结束时，你将理解一些基本概念，可以开始在你的组织中自动化部署过程。你可能会问，为什么是Ansible，而不是其他解决方案，比如Chef或Puppet？
- en: Some configuration management solutions are relatively heavy from a resource
    perspective. With other solutions, you’ll generally have a central server, which
    will run a master program. This program will periodically *check in* with each
    server under its control by communicating with the agent installed on each server.
    Then, the agent will receive instructions from the central server and carry them
    out.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 一些配置管理解决方案在资源角度上比较沉重。对于其他解决方案，你通常会有一个中央服务器，它将运行一个主程序。这个程序会定期与每个受控服务器通过与安装在每台服务器上的代理进行通信，*检查*它们的状态。然后，代理将从中央服务器接收指令并执行。
- en: This means that you’ll need to maintain a server with modest CPU and RAM requirements,
    and the agent on the client side of the communication will also spend valuable
    CPU in order to carry out the instructions. This resource utilization can be very
    heavy on both the primary and client servers.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着你需要维持一台具有适度CPU和内存要求的服务器，并且通信过程中的客户端代理也需要消耗宝贵的CPU来执行指令。这种资源利用可能会对主服务器和客户端服务器造成很大负担。
- en: Ansible is very different than the other solutions in that there is no agent
    at all. There is typically a server, but it’s not required to run any resource-intensive
    software. The entire configuration process happens via SSH, so you can even carry
    out the instructions from your workstation if you want to skip having to maintain
    a central server. Typically, the administrator will create a user account on each
    server, and then the central Ansible server (or workstation) will execute commands
    over SSH to update the configuration on each machine. Since there is no agent
    installed on each server, the process takes a lot less CPU. Of course, the instructions
    that Ansible gives your servers will definitely result in CPU usage, but certainly
    a lot less than the other solutions.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: Ansible与其他解决方案的最大不同在于，它根本不需要代理。通常会有一个服务器，但它不需要运行任何资源密集型的软件。整个配置过程通过SSH完成，因此如果你不想维护一个中央服务器，你甚至可以从你的工作站执行指令。通常，管理员会在每台服务器上创建一个用户帐户，然后中央Ansible服务器（或工作站）将通过SSH执行命令来更新每台机器的配置。由于每台服务器上都没有安装代理，整个过程的CPU消耗要少得多。当然，Ansible给服务器下达的指令肯定会导致CPU使用，但肯定比其他解决方案要少得多。
- en: Ansible is typically set up by creating an **inventory file**, which contains
    a list of resources (servers) (in the form of hostnames or IP addresses that Ansible
    will be instructed to connect to and configure). If you want to add a new server,
    you simply make sure that a specific user account exists on that server, then
    you add it to the inventory list. If you want to remove it, you delete the line
    in the inventory file corresponding to that server. It’s very easy.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: Ansible通常通过创建一个**清单文件**来设置，这个文件包含了一份资源（服务器）列表（形式为主机名或IP地址，Ansible将被指示连接并配置）。如果你想添加一台新服务器，只需要确保该服务器上存在一个特定的用户帐户，然后将它添加到清单中。如果你想移除它，只需要删除清单文件中与该服务器对应的行。非常简单。
- en: However, something that’s magical about Ansible is that you don’t even have
    to run a central server at all if you don’t want to. You can store your Ansible
    configuration in a Git repository, and have each server download code from the
    repository and run it locally. This means that if you do have a dynamic environment
    where servers come and go all the time (which is very common in cloud deployments),
    you don’t have to worry about maintaining an inventory file. Just instruct each
    server to download the code and provision themselves. This is known as the **pull
    method** of Ansible, which I will also show you.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，Ansible 的一个神奇之处在于，你完全不必运行中央服务器，如果你不想的话。你可以将 Ansible 配置存储在 Git 仓库中，然后让每台服务器从仓库中下载代码并在本地运行。这意味着，如果你有一个动态环境，服务器时常增减（这在云部署中非常常见），你不必担心维护一个清单文件。只需要指示每台服务器下载代码并自行配置。这就是
    Ansible 的**pull 方法**，我将在后面展示给你。
- en: While solutions such as Chef and Puppet have their merits and are definitely
    fun to use, I think you’ll find that Ansible scales better and gives you far more
    control over how these hosts are configured. While it’s up to you to figure out
    exactly how you want to implement Ansible, the creative freedom it gives you is
    second to none. I’ve been using Ansible for quite a while now, and I’m still finding
    new ways to use it. It’s a technology that will grow with you.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然 Chef 和 Puppet 等解决方案各有优点，且使用起来确实很有趣，但我相信你会发现，Ansible 在扩展性方面更优秀，且能让你对这些主机的配置拥有更多的控制权。虽然如何实施
    Ansible 完全取决于你，但它给予你的创作自由无与伦比。我已经使用 Ansible 一段时间了，仍在不断发现新的使用方式。这是一项能与您共同成长的技术。
- en: Creating a Git repository
  id: totrans-30
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建 Git 仓库
- en: For the examples in this chapter, it’s recommended that you create a Git repository
    to store your Ansible code. This isn’t required, as you can find other ways of
    hosting your code, but it’s highly recommended. This is especially true when we
    get to the pull method of Ansible at the end of this chapter. In this section,
    I’ll walk you through creating a repository. If you already know how to use GitHub,
    you can skip this section.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中的示例，建议你创建一个 Git 仓库来存储你的 Ansible 代码。这不是强制性的，因为你可以通过其他方式托管代码，但强烈推荐这么做。尤其是在本章末尾讲解
    Ansible 的 pull 方法时，创建 Git 仓库显得尤为重要。如果你已经知道如何使用 GitHub，可以跳过这一部分。
- en: While a full walkthrough of Git is beyond the scope of this book, the basics
    are more than enough for following along here. When it comes to Git, you can simply
    install the `git` package on a server to have it host your code, but GitHub is
    probably the easiest way to get started. An added bonus is that GitHub is home
    to a lot of great projects you can benefit from, and browsing the code of these
    projects is a great way to become more accustomed to syntax rules with different
    scripting and programming languages. For our purposes, we’re going to use GitHub
    as a central place to store our Ansible code.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然本书无法对 Git 进行全面讲解，但基本概念足以帮助你跟上本书的内容。对于 Git，你可以简单地在服务器上安装`git`软件包来托管你的代码，但 GitHub
    可能是最简单的入门方式。额外的好处是，GitHub 上有许多优秀的项目，你可以从中受益，浏览这些项目的代码是熟悉不同脚本语言和编程语言语法规则的好方法。对于我们的目的，我们将使用
    GitHub 作为存储 Ansible 代码的中央位置。
- en: It probably goes without saying, but GitHub is a public resource. Any code you
    upload to the service will be available for all to see by default. Therefore,
    be mindful of the information you commit to your repository. Make sure you don’t
    include any personally identifiable information, passwords, blueprints, API keys,
    or anything else you don’t want the public to know about you or your organization.
    You can create a private repository to hide confidential information, but it’s
    still safer to not upload protected information at all (whether the repository
    is private or not).
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 这可能是显而易见的，但 GitHub 是一个公开资源。你上传到服务的任何代码默认都可以供所有人查看。因此，提交到仓库时需要注意你包含的信息。确保不包含任何个人身份信息、密码、蓝图、API
    密钥或任何你不希望公众知道的关于你或你组织的信息。你可以创建一个私有仓库来隐藏机密信息，但即便如此，最好不要上传受保护的信息（无论仓库是否为私有）。
- en: 'To get started, create an account at [https://www.github.com](https://www.github.com)
    if you don’t already have one. This is a free process. Make sure you create a
    reasonably secure password here. After you have created an account, click on **New
    repository**, and then give it a name (simply calling it `ansible` is fine):'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 要开始，请在 [https://www.github.com](https://www.github.com) 创建一个帐户（如果尚未拥有）。这是一个免费的过程。确保在这里创建一个相对安全的密码。创建完帐户后，单击
    **新建仓库**，然后给它命名（简单地称为 `ansible` 即可）：
- en: '![](img/B18425_15_01.png)'
  id: totrans-35
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B18425_15_01.png)'
- en: 'Figure 15.1: Creating an Ansible repository on GitHub'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 图 15.1：在 GitHub 上创建一个 Ansible 仓库
- en: In the example screenshot, I created a repository that is **Public**, which
    means exactly that—anyone will be able to view the code. You can create **Private**
    repositories as well, if you prefer. Since we’re not going to include confidential
    information in the repository during the examples in this book, we don’t need
    to worry about that right now.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 在示例截图中，我创建了一个 **公共** 仓库，这意味着任何人都可以查看代码。如果你喜欢，也可以创建 **私有** 仓库。由于在本书的示例中不会包含仓库中的机密信息，因此我们现在不需要担心这个问题。
- en: 'Once the repository is created using **Create repository**, we’ll need to download
    it locally. For that, we’ll need to install the `git` package:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 创建仓库后，我们需要下载它到本地，使用 **创建仓库**。为此，我们需要安装 `git` 软件包：
- en: '[PRE0]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Next, we should set up our local Git client so that we can fill out our name
    and email address, otherwise Git will most likely complain. To do this, we can
    issue the following commands, substituting the content in the quotes with your
    information:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们应该设置本地的 Git 客户端，以便我们可以填写我们的姓名和电子邮件地址，否则 Git 很可能会抱怨。为此，我们可以使用以下命令，并将引号中的内容替换为你的信息：
- en: '[PRE1]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'To download our repository, the following will do the trick (ignore the warning
    about the repository being empty if you see such a message):'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 要下载我们的仓库，以下操作将奏效（如果看到关于仓库为空的警告，请忽略）：
- en: '[PRE2]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Now you have the Git repository downloaded locally. Right now, the repository
    doesn’t include anything useful. To create a file within the repository, you simply
    change your working directory to be inside the repository folder that was downloaded
    when you cloned it, and create whatever files you want inside. By default, Git
    doesn’t care about any files you create inside the repository until you add them.
    For example, we can create a test file and commit it to the repository with the
    following commands:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经将 Git 仓库下载到本地。目前，该仓库不包含任何有用的内容。要在仓库中创建文件，只需将工作目录更改为克隆时下载的仓库文件夹内部，并在其中创建任何你想要的文件。默认情况下，Git
    不会关心你在仓库内创建的任何文件，直到你添加它们。例如，我们可以使用以下命令创建一个测试文件并提交到仓库：
- en: '[PRE3]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'With these commands, we used `echo` to create a test file with some text in
    it. Then, we used the `git add` command to tell Git that we want the file to be
    a part of our repository. Finally, we finalized our changes by using `git commit`,
    along with the `-m` flag and a message about the commit. At this point, the changes
    only exist locally. To push our changes back to GitHub, we use the following command
    from inside the repository directory:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这些命令，我们使用 `echo` 创建了一个包含一些文本的测试文件。然后，我们使用 `git add` 命令告诉 Git 我们希望这个文件成为仓库的一部分。最后，我们通过
    `git commit` 完成了我们的更改，同时使用了 `-m` 标志并附上了关于提交的消息。此时，这些更改仅存在于本地。要将更改推送回 GitHub，我们从仓库目录内部使用以下命令：
- en: '[PRE4]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: By following the on-screen prompts (GitHub username and password), our changes
    will be placed inside our actual repository.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 通过按照屏幕提示（GitHub 用户名和密码），我们的更改将被放置在我们的实际仓库内部。
- en: So, how does this help us when it comes to configuration management? Typically,
    the code that administrators use to provision servers will be placed inside a
    repository for safekeeping. If the local copy of the code is lost, it can simply
    be cloned again from the repository. GitHub is a safe place to put our code, since
    we can be reasonably sure that our code won’t disappear as the service is very
    stable (you still may want to create a local backup to be safe). Whether you’re
    using Ansible, Chef, Puppet, or another utility, it’s common practice to keep
    the code in a Git repository. With regard to Ansible, this will directly impact
    us in the last section of this chapter since we’ll be using the `ansible-pull`
    command, which expects a repository URL.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，这如何帮助我们进行配置管理呢？通常，管理员用于配置服务器的代码会保存在一个仓库中以确保安全。如果本地的代码丢失了，只需从仓库中重新克隆即可。GitHub
    是我们存放代码的安全地方，因为我们可以合理地确信，代码不会丢失，因为该服务非常稳定（不过你仍然可能希望创建一个本地备份以确保安全）。无论你是使用 Ansible、Chef、Puppet
    还是其他工具，将代码保存在 Git 仓库中都是常见做法。就 Ansible 而言，这将直接影响本章最后一节，因为我们将使用 `ansible-pull` 命令，它需要一个仓库
    URL。
- en: 'In practice, when we create Ansible playbooks, you should commit those changes
    back to the repository. I won’t specifically call on you to do that, so go ahead
    and keep that in mind as we go. When you create a new playbook, add it to the
    repository, then commit it. If you make changes to existing files, commit those
    changes. Be sure to use the `git push` command to push your changes back to the
    repository. For example, if you created a file inside the repository named `myplaybook.yml`,
    you would execute commands such as these:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 在实践中，当我们创建 Ansible 剧本时，应该将这些更改提交回仓库。我不会特别要求你这么做，但请在接下来的操作中牢记这一点。当你创建一个新的剧本时，将其添加到仓库中，然后提交。如果你对现有文件进行了更改，记得提交这些更改。确保使用
    `git push` 命令将更改推送回仓库。例如，如果你在仓库中创建了一个名为 `myplaybook.yml` 的文件，你将执行类似以下的命令：
- en: '[PRE5]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Go ahead and practice this a bit before you move on. Even if you don’t use Ansible
    in production, understanding the basics of Git is invaluable, as you’ll almost
    definitely need it at some point in your career.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 在继续之前，不妨先练习一下。即使你在生产环境中不使用 Ansible，了解 Git 的基础知识也非常宝贵，因为你几乎肯定会在未来的某个时刻需要它。
- en: Getting started with Ansible
  id: totrans-53
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 开始使用 Ansible
- en: The first thing to know about Ansible is that it changes constantly. New versions
    with exciting features are released regularly, and it shows no sign of slowing
    down whatsoever. There is a lot of excitement around this technology, so it’s
    regularly improving.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 了解 Ansible 的第一件事是它在不断变化。新版本带有令人兴奋的功能，定期发布，而且完全没有放缓的迹象。这个技术引起了很多的关注，因此它也在不断改进。
- en: The reason I’m bringing this up is that although the examples in this book have
    been written for (and tested on) Ubuntu 22.04, new versions of Ansible are released
    regularly outside of Ubuntu’s repositories, and not only include new features
    but syntax changes as well. For our needs in this book, the version of Ansible
    included in the repositories should be more than fine. However, if you were to
    look at examples of Ansible playbooks online, they might be written for a newer
    version (or even an older version). If for any reason you have an issue with a
    particular example written for Ansible, a good first step in terms of troubleshooting
    is to compare the version of Ansible the tutorial was written for against the
    version installed. When it comes to Ubuntu 22.04, the version of Ansible that’s
    made available is 2.10.x. You can install a newer version of Ansible from the
    official website, but for the purposes of this book, we’ll use the version that’s
    in the default repositories.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 我之所以提到这一点，是因为尽管本书中的示例是在 Ubuntu 22.04 上编写并测试的，但 Ansible 的新版本会定期发布，且这些版本不仅包含新功能，还包括语法更改。对于本书的需求，仓库中提供的
    Ansible 版本应该完全足够。然而，如果你查看网上的 Ansible 剧本示例，它们可能是为较新版本（甚至较旧版本）编写的。如果你遇到针对特定示例的 Ansible
    问题，排查的一个好方法是对比教程所用的 Ansible 版本与已安装的版本。对于 Ubuntu 22.04，提供的 Ansible 版本是 2.10.x。你可以从官方网站安装更高版本的
    Ansible，但为了本书的目的，我们将使用默认仓库中的版本。
- en: 'Go ahead and install `ansible` via `apt`:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 继续通过 `apt` 安装 `ansible`：
- en: '[PRE6]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Now you should have the `ansible-playbook` command available, which is the main
    binary that we’ll be using as we explore Ansible. There are other commands that
    Ansible provides us, but we’re not concerned with them.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你应该已经能够使用`ansible-playbook`命令了，这是我们在探索Ansible时将使用的主要命令。Ansible还提供了其他一些命令，但我们不关心它们。
- en: In order to follow along with the remainder of this chapter, it’s recommended
    that you have at least two servers to work with; the more the better. If you have
    a **Virtual Machine** (**VM**) solution such as VirtualBox available, simply create
    additional VMs. To save time, consider cloning an existing VM a few times (just
    make sure you don’t overload your computer/server by over-allocating resources).
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 为了能够跟上本章的其余内容，建议你至少有两台服务器来操作；更多的服务器会更好。如果你有像VirtualBox这样的**虚拟机**(**VM**)解决方案，只需创建更多的虚拟机。为了节省时间，可以考虑克隆现有虚拟机几次（只是确保不要通过过度分配资源来超载你的计算机/服务器）。
- en: 'The most common workflow of Ansible works something like this: you have a main
    server or workstation, on which Ansible is installed. While you don’t need an
    agent on the clients, they will, however, need OpenSSH installed and configured
    as that’s how Ansible communicates. To make things easy, it’s recommended to have
    a dedicated Ansible user on each machine, and the Ansible user on the server should
    be able to connect to each machine without a password. It doesn’t matter what
    you call the Ansible user; you can simply use `ansible` or something clever. We
    covered how to create SSH keys in *Chapter 10*, *Connecting to Networks*, so refer
    to that if you need a reminder. Creating users was covered in *Chapter 2*, *Managing
    Users and Permissions*. In a nutshell, here are the things you should work on
    in order to set up your environment for Ansible:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: Ansible最常见的工作流大致是这样的：你有一台安装了Ansible的主服务器或工作站。虽然客户端不需要安装代理，但它们需要安装并配置OpenSSH，因为Ansible通过SSH进行通信。为了简化操作，建议每台机器上都有一个专门的Ansible用户，并且服务器上的Ansible用户应能无密码连接到每台机器。你可以随便为Ansible用户起个名字；你可以使用`ansible`，也可以起个更有创意的名字。我们在*第10章*，*连接到网络*中介绍了如何创建SSH密钥，如果需要回顾，可以参考该章节。创建用户的内容在*第2章*，*管理用户和权限*中有所讲解。总之，以下是你为了设置Ansible环境需要做的几件事：
- en: Install Ansible on a central server or workstation
  id: totrans-61
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在中央服务器或工作站上安装Ansible
- en: Create a user for Ansible on each machine you want to manage configuration on
  id: totrans-62
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在每台你想管理配置的机器上创建一个Ansible用户
- en: Create the same user on your central server or your local machine
  id: totrans-63
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在中央服务器或本地机器上创建相同的用户
- en: Set up the Ansible user on the server so that it can connect to clients via
    SSH without a password
  id: totrans-64
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在服务器上设置Ansible用户，以便它能够通过SSH连接到客户端且无需密码。
- en: Configure `sudo` on the client machines so that the Ansible user can execute
    commands with `sudo` with no password
  id: totrans-65
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 配置客户端机器上的`sudo`，使得Ansible用户可以在没有密码的情况下执行`sudo`命令
- en: 'In previous chapters, we covered how to create users and SSH keys, but we have
    yet to cover the last point. Assuming you named your Ansible user `ansible`, create
    the following file:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 在之前的章节中，我们讲解了如何创建用户和SSH密钥，但还没有讲解最后一点。假设你将Ansible用户命名为`ansible`，创建以下文件：
- en: '[PRE7]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Inside that file, place the following text:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 在该文件中，放入以下内容：
- en: '[PRE8]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Next, we need to ensure that the file is owned by `root`:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要确保该文件的所有者是`root`：
- en: '[PRE9]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Finally, we need to adjust the permissions of the file:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们需要调整文件的权限：
- en: '[PRE10]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Go ahead and test this out. On the server, switch to the `ansible` user:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 现在可以开始测试了。在服务器上切换到`ansible`用户：
- en: '[PRE11]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Then, to test this out, use SSH to execute a command on a remote machine:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，测试一下，通过SSH在远程机器上执行一个命令：
- en: '[PRE12]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: How does this work? You may or may not know this, but if you use SSH to execute
    just one command, you don’t necessarily need to set up a persistent connection.
    In this example, we first switch to the `ansible` user. Then, we connect to `192.168.1.123`
    (or whatever the IP address of the client is) and tell it to execute `sudo ls
    /etc`. Executing an `ls` command with `sudo` may seem like a silly thing to do,
    but it’s great—it allows you to test whether or not `sudo` works without doing
    anything potentially dangerous. Listing the contents of a directory is about as
    innocent as you can get.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 这是如何工作的呢？你可能知道也可能不知道，如果你使用SSH执行单个命令，其实不一定需要建立一个持久连接。在这个例子中，我们首先切换到`ansible`用户。然后，我们连接到`192.168.1.123`（或者客户端的IP地址），并告诉它执行`sudo
    ls /etc`。用`sudo`执行`ls`命令可能看起来像个傻事，但这非常有用——它让你可以测试`sudo`是否能正常工作，而不会做出任何潜在危险的操作。列出目录的内容是最无害的操作之一。
- en: It may seem like an awful lot of steps in order to get configuration management
    working. But make sure you think with a system administrator’s mindset—these setup
    tips can be automated. In my case, I have a Bash script that I run on each of
    my servers that sets up the required user, keys, and `sudo` access specifically
    for Ansible. Anytime I want to add a new server to Ansible, I simply run that
    script on the machine just once, and from that point forward Ansible will take
    care of the rest.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: '这看起来可能像是一个繁琐的过程，但请确保你从系统管理员的角度思考——这些设置步骤是可以自动化的。以我为例，我有一个 Bash 脚本，会在每台服务器上运行，设置所需的用户、密钥和专门用于
    Ansible 的 `sudo` 权限。每当我想将新服务器添加到 Ansible 时，只需要在该机器上运行一次脚本，从此以后，Ansible 将自动处理剩余部分。  '
- en: What should have happened is that the command should have executed and printed
    the contents of `/etc` without prompting you for a password. If this doesn’t work,
    make sure you have completed each of the recommended steps. You should have an
    `ansible` user on each machine, and that user should have access to `sudo` without
    a password since we created a file for that user in `/etc/sudoers.d`. If the SSH
    portion fails, check the log file at `/var/log/auth.log` for clues, as that is
    where related errors will be saved. Once you have met these requirements, we can
    get automating with Ansible!
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: '正常情况下，命令应该执行并打印 `/etc` 目录的内容，而不会提示你输入密码。如果这不起作用，请确保你已经完成了所有推荐的步骤。每台机器上应该有一个
    `ansible` 用户，该用户应具备无需密码的 `sudo` 权限，因为我们已经在 `/etc/sudoers.d` 中为该用户创建了一个文件。如果 SSH
    部分失败，请检查 `/var/log/auth.log` 日志文件，里面会保存相关错误的线索。一旦你满足了这些要求，就可以开始使用 Ansible 自动化了！  '
- en: Making your servers do your bidding
  id: totrans-81
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '让你的服务器按照你的意愿工作  '
- en: As server administrators, we’re control freaks. There are few things more exciting
    than executing a command and having every single server obey it and carry it out.
    Now that we have Ansible set up, that’s exactly what we’re going to do. I’m assuming
    by now you have some machines you want to configure, and they’re all set up to
    communicate via SSH with your central server. Also, as I mentioned before, I highly
    recommend you utilize something like Git to store your configuration files, but
    that’s not required for this section.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: '作为服务器管理员，我们都是控制狂。没有什么比执行一个命令，看到每一台服务器都服从并执行它更让人兴奋了。既然我们已经设置好 Ansible，接下来正是要做这件事。我假设你现在已经有了一些要配置的机器，它们都已经配置好通过
    SSH 与中央服务器进行通信。另外，正如我之前提到的，我强烈推荐你使用类似 Git 的工具来存储你的配置文件，但这部分并不是本节的必要内容。  '
- en: Setting up an inventory file and configuring Ansible settings
  id: totrans-83
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 设置清单文件并配置 Ansible 设置
- en: First, we’ll need an inventory file, which is a special text file Ansible expects
    to find that tells it where to find servers to connect to. In previous versions,
    the process of installing the `ansible` package would provide you with some default
    configuration, located in `/etc/ansible`. In Ubuntu 22.04, at least with the version
    of Ansible that’s offered in the default repositories, this is no longer the case.
    For our purposes, that’s fine, though – we were going to create an empty configuration
    anyway.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: '首先，我们需要一个清单文件，这是一种特殊的文本文件，Ansible 需要从中读取信息以确定连接到哪些服务器。在以前的版本中，安装 `ansible`
    包的过程中会为你提供一些默认的配置，位于 `/etc/ansible` 目录下。但在 Ubuntu 22.04 中，至少对于默认仓库中提供的 Ansible
    版本，情况发生了变化。对于我们的目的来说，这没关系——反正我们是要创建一个空的配置文件。  '
- en: 'First, let’s create the directory that we’ll be using for the configuration
    on our “controller” server (the one we’ll be using to control, or “configure,”
    other nodes):'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: '首先，让我们创建一个目录，在“控制器”服务器上用于配置管理（即我们用来控制或“配置”其他节点的服务器）：  '
- en: '[PRE13]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'After that, we can create an empty inventory file:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: '之后，我们可以创建一个空的清单文件：  '
- en: '[PRE14]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: There’s actually a way to avoid needing to create an inventory file, which we’ll
    get into later in this chapter.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: '事实上，有一种方法可以避免创建清单文件，稍后我们将在本章中讨论这一点。  '
- en: 'We should also make sure that only the Ansible user account can read it. Execute
    the following command to change ownership (replace `ansible` with whatever user
    account you chose as your Ansible account if you’re using something different):'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: '我们还应该确保只有 Ansible 用户帐户可以读取该文件。执行以下命令以更改文件的所有权（如果你使用的是不同的用户帐户，请将 `ansible` 替换为你选择的帐户名）：  '
- en: '[PRE15]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Next, modify the permissions such that only the owner can view or change the
    file:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: '接下来，修改文件的权限，使得只有所有者可以查看或更改该文件：  '
- en: '[PRE16]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Next, let’s edit the `/etc/ansible/hosts` file and populate it. If you did
    end up having a default `hosts` file created for you when you installed Ansible,
    you can simply empty the file since we’ll be creating our own anyway. What we’ll
    do with this file is populate it with the IP addresses of the servers we wish
    to manage. Feel free to make a backup of the original host file, if it already
    exists. For right now, we’re only including the IP addresses of the nodes we want
    to control with Ansible, so the file will end up looking similar to the following:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们编辑`/etc/ansible/hosts`文件并填充它。如果在安装Ansible时确实为你创建了默认的`hosts`文件，你可以简单地清空该文件，因为我们无论如何都会创建自己的文件。我们将在这个文件中填入我们希望管理的服务器的IP地址。如果原始的主机文件已经存在，欢迎你先备份它。现在，我们只包括了我们希望用Ansible控制的节点的IP地址，因此该文件最终会看起来像下面这样：
- en: '[PRE17]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'That’s it; it’s simply just a list of IP addresses. I bet you were expecting
    some long configuration with all kinds of syntax requirements? Sorry to disappoint.
    All you need to do is copy a list of IP addresses of the servers you want to manage
    into this file. If you have DNS names set up for the machines you want to configure,
    you can use them instead:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 就是这样；它只是一个简单的IP地址列表。我敢打赌你原本以为会有一些包含各种语法要求的长配置吧？抱歉让你失望了。你需要做的就是将你想要管理的服务器的IP地址列表复制到这个文件中。如果你已经为你想配置的机器设置了DNS名称，你也可以使用它们：
- en: '[PRE18]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Since Ansible understands IP addresses as well as DNS names, we can use either
    or a combination of both in order to set up our inventory file. We can also split
    up our hosts within the inventory file between different roles, but that is outside
    the scope of this book. I do recommend learning about roles in Ansible if you
    wish to take your knowledge further (see the *Relevant videos* section for more
    information).
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 由于Ansible既能理解IP地址，也能理解DNS名称，我们可以使用其中任意一种，或两者结合起来设置我们的库存文件。我们还可以在库存文件中将主机按不同角色进行划分，但这超出了本书的范围。如果你希望进一步深入了解Ansible的知识，我推荐学习关于Ansible角色的内容（有关更多信息，请参见*相关视频*部分）。
- en: 'If you decide not to store your inventory file at `/etc/ansible/hosts`, you
    must tell Ansible where to find it. There is another important file to Ansible,
    and that is its configuration file, located at `/etc/ansible/ansible.cfg`. Inside
    this file, we can fine-tune Ansible to get the best performance possible. While
    we won’t go over this file in detail, just know that you can seriously increase
    the performance of Ansible by fine-tuning its settings, and Ansible will read
    settings from its configuration file every time it runs. In our case, if we wish
    to store our inventory file somewhere other than `/etc/ansible/hosts`, we will
    need to add the following two lines to this file (most likely, you’ll need to
    create this file since it probably doesn’t already exist at this point):'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你决定不将库存文件存储在`/etc/ansible/hosts`，你必须告诉Ansible它的存放位置。Ansible还有另一个重要的文件，那就是它的配置文件，位于`/etc/ansible/ansible.cfg`。在这个文件中，我们可以微调Ansible，以便获得最佳性能。虽然我们不会详细讨论这个文件，但要知道，通过微调配置设置，你可以显著提高Ansible的性能，并且Ansible每次运行时都会读取配置文件中的设置。在我们的案例中，如果我们希望将库存文件存储在`/etc/ansible/hosts`以外的地方，我们需要在这个文件中添加以下两行（很可能，你需要创建这个文件，因为此时它可能还不存在）：
- en: '[PRE19]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: With the first setting, we’re basically telling Ansible where to find its inventory
    file. There are many more configuration items we can place in the `ansible.cfg`
    file to configure it further, but that’s all we need to configure right now. With
    the second line, we’re setting a default user to use for Ansible playbooks, which
    must exist on any servers you wish to manage with it.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一个设置中，我们基本上是在告诉Ansible去哪里找到它的库存文件。我们还可以在`ansible.cfg`文件中添加更多的配置项来进一步配置它，但目前这些就是我们需要配置的内容。在第二行中，我们设置了一个默认用户，用于Ansible的剧本，这个用户必须在你希望使用Ansible管理的任何服务器上存在。
- en: Similar to the inventory file, Ansible also checks the local directory for a
    file named `ansible.cfg` to fetch its configuration, so you could actually include
    the configuration file in the Git repository as well, and then execute Ansible
    commands from within the repository directory. This works because Ansible will
    check for the existence of a configuration file in your current working directory,
    and use it if it’s found there. You may want to be careful about including your
    configuration file in your Git directory, though. While it’s not as private as
    the inventory file, it can potentially contain privileged information. Therefore,
    you may want to keep the file at `/etc/ansible/ansible.cfg` and manage it outside
    of the Git repository if you include anything private in the file (for example,
    encryption keys).
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 与库存文件类似，Ansible 还会检查本地目录中是否存在一个名为 `ansible.cfg` 的文件来获取其配置，因此你也可以将配置文件包含在 Git
    仓库中，然后从仓库目录内执行 Ansible 命令。这是可行的，因为 Ansible 会检查当前工作目录中是否存在配置文件，并在找到该文件时使用它。不过，你可能需要小心将配置文件包含在
    Git 仓库中。虽然它不像库存文件那样私密，但它可能包含敏感信息。因此，如果文件中包含了任何私密信息（例如加密密钥），你可能需要将文件保存在 `/etc/ansible/ansible.cfg`
    目录，并在 Git 仓库之外管理。
- en: 'Now we can test out whether or not Ansible is working at this point. Thankfully,
    this is also easy. Just simply execute the following command:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以测试一下 Ansible 是否已经正常工作。幸运的是，这也很简单。只需要执行以下命令：
- en: '[PRE20]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'The results should look similar to this:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 结果应该类似于以下内容：
- en: '![](img/B18425_15_02.png)'
  id: totrans-106
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B18425_15_02.png)'
- en: 'Figure 15.2: Testing Ansible'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 图 15.2：测试 Ansible
- en: Depending on how many servers you have set up, you should see that output one
    or more times. You may think that all that command has done is a simple ping test,
    but `ping` means something different to Ansible than usual. It’s actually attempting
    to make a connection to the server, to test its availability. If it fails, double-check
    that the hosts are available over SSH. Success here simply means that Ansible
    is able to communicate with your hosts via SSH. Now that the communication exists,
    we can build some actual configuration.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 根据你设置的服务器数量，你应该会看到输出出现一次或多次。你可能认为这个命令只做了一个简单的 ping 测试，但在 Ansible 中，`ping` 的含义与通常不同。它实际上是在尝试与服务器建立连接，以测试其可用性。如果失败了，双重检查一下主机是否可以通过
    SSH 访问。这里的成功意味着 Ansible 能够通过 SSH 与主机通信。既然通信已经建立，我们就可以开始构建一些实际的配置了。
- en: Configuring client servers
  id: totrans-109
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 配置客户端服务器
- en: Ansible uses something called a **playbook** in order to store configuration.
    A playbook is essentially a file in the YAML format with instructions that Ansible
    understands, that are interpreted as a set of tasks run against hosts A full guide
    on YAML isn’t something we’ll be covering here – you don’t have to master this
    format or even fully understand it to use it with Ansible. That will automatically
    come in time. The takeaway here is that YAML is simply the format that Ansible
    uses, and it’s a file format that’s not specific to Ansible itself. A playbook
    is basically just a collection of instructions written in YAML format, and each
    individual instruction is known as a play.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: Ansible 使用一种叫做 **playbook** 的工具来存储配置。Playbook 本质上是一个 YAML 格式的文件，包含 Ansible 可以理解的指令，这些指令会被解释为一组针对主机执行的任务。关于
    YAML 的完整指南我们在这里不会深入讨论——你不需要精通这个格式，甚至不需要完全理解它就可以在 Ansible 中使用。随着使用的深入，这些内容会自然掌握。这里需要注意的是，YAML
    仅仅是 Ansible 使用的格式，它并非 Ansible 特有的文件格式。Playbook 基本上就是一系列以 YAML 格式书写的指令集合，每个单独的指令称为一个
    play。
- en: You can think of this with the analogy of a sport, like football. Although I
    don’t know the first thing about football, I do know that football coaches have
    playbooks containing things that they want their players to do, and each action
    by a player is a play. It’s the same concept here.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以用一种类似于体育运动的比喻来理解这一点，比如足球。虽然我对足球一无所知，但我知道足球教练有一本包含他们希望球员执行的动作的战术手册，每个球员的动作就是一场比赛。这里的概念也是一样的。
- en: 'Let’s write our first playbook. Create a file called `packages.yml` in your
    local Ansible directory. You can fill it with this content (make sure you include
    the hyphens):'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们编写第一个剧本。在你的本地 Ansible 目录中创建一个名为 `packages.yml` 的文件。你可以将以下内容填入文件中（确保包含短横线）：
- en: '[PRE21]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'We can run this playbook with the following command:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用以下命令运行这个剧本：
- en: '[PRE22]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'This will produce an output that looks something like the following:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 这将产生类似于以下内容的输出：
- en: '![](img/B18425_15_03.png)'
  id: totrans-117
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B18425_15_03.png)'
- en: 'Figure 15.3: Ansible in action'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 图 15.3：Ansible 运行示例
- en: Just like that, all of the hosts in your inventory file will have the `htop`
    package installed. It really doesn’t matter which package you install, so long
    as it exists in the repositories; I just used `htop` as a simple example. But
    once you run it, you should see an overview of what was changed. Ansible will
    tell you how many items your hosts updated, how many tasks have failed, and how
    many targets weren’t reachable at the time the playbook was run.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 就这样，库存文件中的所有主机都会安装`htop`包。你安装哪个包其实并不重要，只要它在软件库中存在；我只是用`htop`作为一个简单的示例。但一旦你运行它，你应该能看到所做更改的概览。Ansible会告诉你有多少项更新，多少任务失败，多少目标在运行剧本时无法访问。
- en: Let’s take a closer look at what the instructions in this sample playbook do.
    The hyphens at the beginning are part of the YAML format, so we really don’t need
    to get into that. Spacing is very important with the YAML format, as you need
    to be consistent throughout.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们仔细看看这个示例剧本中的指令做了什么。开头的短横线是YAML格式的一部分，所以我们其实不需要深入讨论。空格在YAML格式中非常重要，因为你需要保持一致。
- en: 'In my examples, I am inserting two spaces underneath each heading. A heading
    starts with a hyphen:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 在我的示例中，我在每个标题下面插入了两个空格。标题以短横线开始：
- en: '[PRE23]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Here, we declare which hosts we want to have the commands apply to. I added
    `all` here, which basically runs the configuration against every host in the inventory
    file. With advanced usage, you can actually create `roles` in Ansible and divide
    your hosts between them, such as a web server, database server, and so on. Then,
    you can apply configuration only to hosts inside a particular role. We’re not
    going to get into that in this chapter, but just know that it is possible.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们声明希望将命令应用于哪些主机。我在这里添加了`all`，这基本上是对库存文件中的每一台主机运行配置。在高级用法中，你实际上可以在Ansible中创建`roles`（角色），并将主机分配到不同的角色中，例如Web服务器、数据库服务器等等。然后，你可以只将配置应用于特定角色内的主机。我们在本章不打算深入讨论这个内容，但只需知道这是可行的。
- en: 'The next line is `become`:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 下一行是`become`：
- en: '[PRE24]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'This line is basically Ansible’s term for describing `sudo`. We’re telling
    Ansible to use `sudo` to execute the commands, since installing packages requires
    `root` privileges. The next part of the playbook is as follows:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 这一行基本上是Ansible用来描述`sudo`的术语。我们告诉Ansible使用`sudo`来执行命令，因为安装包需要`root`权限。接下来的剧本部分如下：
- en: '[PRE25]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'This line starts the next section, which is where we place our individual tasks.
    Next, we name our new task (Ansible refers to a “task” as a “play”):'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 这一行开始了下一部分，那里是我们放置各个任务的地方。接下来，我们为我们的新任务命名（Ansible称任务为“play”）：
- en: '[PRE26]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'With `name`, we give the play a name. This isn’t required but you should always
    include it. The importance of this is that whatever we type here is what is going
    to show up in the logs if we enable logging, and will also print to the terminal
    as the play runs. We should be descriptive here, as it will certainly help if
    a play fails and we need to locate it in a log file that has hundreds of lines.
    Next, we utilize the `apt` module and tell it to install a package, `htop` in
    this case:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`name`，我们为该剧本指定一个名称。这不是必需的，但你应该始终包含它。这样做的重要性在于，无论我们在这里输入什么，如果启用了日志记录，它都会出现在日志中，并且会在剧本运行时打印到终端。我们在这里应该写得具有描述性，因为这对于剧本执行失败时，我们需要在成百上千行的日志文件中找到它时，肯定会有所帮助。接下来，我们使用`apt`模块并告诉它安装一个包，这里以`htop`为例：
- en: '[PRE27]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: We use the `ansible.builtin.apt` module simply because Ubuntu uses the `apt`
    command to manage packages, but modules exist for all of the popular Linux distributions.
    Ansible’s support of package managers among various distributions is actually
    fairly extensive. All of the major distributions, such as Red Hat, Fedora, openSUSE,
    Arch Linux, and Debian, are supported (and those are just the ones I’ve used in
    my lab off the top of my head). If you want to execute a play against a server
    that’s running a distribution other than Ubuntu, simply adjust `ansible.builtin.apt`
    to something else, such as `ansible.builtin.dnf`.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用`ansible.builtin.apt`模块仅仅是因为Ubuntu使用`apt`命令来管理包，但也有针对所有流行Linux发行版的模块。Ansible对各个发行版的包管理器的支持实际上非常广泛。所有主要的发行版，如Red
    Hat、Fedora、openSUSE、Arch Linux和Debian，都得到支持（而这些只是我在实验室中使用过的发行版）。如果你想对运行非Ubuntu发行版的服务器执行剧本，只需将`ansible.builtin.apt`调整为其他命令，如`ansible.builtin.dnf`。
- en: Since Ansible allows you to use additional resources from Galaxy, a site that’s
    specific to Ansible that gives you access to additional capabilities, we use `ansible.builtin.apt`
    instead of simply `apt` in order to clarify that we’re using a built-in module,
    not something we’re using from an external resource.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 Ansible 允许你使用来自 Galaxy 的额外资源，Galaxy 是一个专门为 Ansible 提供额外功能的站点，因此我们使用 `ansible.builtin.apt`
    而不仅仅是 `apt`，以明确表示我们使用的是内建模块，而不是来自外部资源的模块。
- en: This new naming scheme is new since the previous edition of this book was published.
    The older versions of the playbooks should still work just fine, but since the
    naming scheme has changed since then, we’ll use the new naming style going forward.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 这个新的命名方案自从本书上一版发布以来才出现。旧版本的 playbooks 应该依然可以正常工作，但由于命名方案自那时起发生了变化，我们将使用新的命名风格继续。
- en: 'You can, of course, add additional packages by simply adding more plays to
    the existing playbook:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，你可以通过简单地在现有 playbook 中添加更多的 play 来增加额外的软件包：
- en: '[PRE28]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'However, that’s not an extremely efficient method. I’ll show you how we can
    combine multiple similar plays in one play. Sure, you don’t have to, but I think
    you’ll agree that this method looks cleaner:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这并不是一个非常高效的方法。我将展示如何将多个相似的 play 合并到一个 play 中。当然，你不必这样做，但我相信你会同意，这种方法看起来更简洁：
- en: '[PRE29]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: With the new format, we include just one play to install multiple packages.
    This is similar to the concept of a *for loop* if you have programming knowledge.
    For every package we list, it will run the `ansible.builtin.apt` module against
    it. If we want to add additional packages, we just add a new one to the list.
    Simple.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 使用新格式时，我们只包含一个 play 来安装多个软件包。如果你有编程经验，这就像是 *for 循环* 的概念。对于我们列出的每个软件包，它都会执行 `ansible.builtin.apt`
    模块。如果我们想添加额外的软件包，只需要在列表中添加新的软件包。非常简单。
- en: 'We can also copy files to our hosts. Consider the following example playbook,
    which I will call `copy_files.yml`:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以将文件复制到我们的主机上。考虑下面这个示例 playbook，我将它命名为 `copy_files.yml`：
- en: '[PRE30]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Then, you can run this playbook with the following command:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，你可以通过以下命令运行这个 playbook：
- en: '[PRE31]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Inside the same directory, create a file called `motd` and place any text in
    it. It doesn’t really matter what you type into the file, but this file in particular
    acts as a message that is printed any time a user logs into a server. When you
    run the playbook, it will copy that file over to the server at the destination
    you configured. Since we created a message of the day (`motd`), we should see
    the new message the next time we log in to the server.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 在相同目录下，创建一个名为 `motd` 的文件，并将任意文本放入其中。你输入到文件中的内容并不重要，但这个文件特别用作每次用户登录服务器时打印的消息。当你运行
    playbook 时，它会将这个文件复制到你配置的服务器目标位置。由于我们创建了一个今天消息（`motd`），所以下次登录服务器时，我们应该看到新消息。
- en: By now, you’re probably seeing just how useful Ansible can be. Sure, we only
    installed a few packages and copied one file. We could’ve performed those tasks
    easily ourselves without Ansible, but this is only a start. Ansible lets you automate
    everything, and we have to start somewhere. You can tell it to not only install
    packages and copy files, but you can also use it to start services, apply configuration
    file templates, and much more—it will surprise you. In fact, you can go as far
    as to automate the setup of a web server, a user’s workstation... you name it!
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 到现在为止，你可能已经意识到 Ansible 是多么有用。没错，我们只是安装了几个软件包并复制了一个文件。我们本来可以轻松地自己完成这些任务，而不需要
    Ansible，但这仅仅是个开始。Ansible 让你能够自动化一切，我们必须从某个地方开始。你不仅可以让它安装软件包和复制文件，还可以用它启动服务、应用配置文件模板，等等——它会让你惊讶。事实上，你可以用它自动化设置一个
    Web 服务器，一个用户的工作站……随你选择！
- en: Putting it all together – automating web server deployment
  id: totrans-146
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 把它们整合在一起——自动化 Web 服务器部署
- en: 'Speaking of automating the setup of a web server, why don’t we go ahead and
    do exactly that? It’ll be another simple example, but it will serve you well if
    we demonstrate more of what Ansible can do. We will set up a playbook to perform
    the following tasks:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 说到自动化设置 Web 服务器，为什么不直接做这个呢？这将是另一个简单的例子，但如果我们展示 Ansible 的更多功能，它将对你非常有帮助。我们将设置一个
    playbook 来执行以下任务：
- en: Install Apache
  id: totrans-148
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 安装 Apache
- en: Start the `apache2` service
  id: totrans-149
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 启动 `apache2` 服务
- en: Copy an HTML file for the new site
  id: totrans-150
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为新站点复制一个 HTML 文件
- en: 'First, let’s set up the playbook to simply install Apache. I called mine `apache.yml`,
    but the name is arbitrary:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们设置一个 playbook 来简单地安装 Apache。我把它命名为 `apache.yml`，但这个名字是随意的：
- en: '[PRE32]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'No surprises here; we’ve already installed a package at this point. Let’s add
    an additional instruction to start the `apache2` service:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 没有什么惊讶的；我们此时已经安装了一个软件包。接下来，让我们添加一个指令来启动 `apache2` 服务：
- en: '[PRE33]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: So far, the syntax should be self-explanatory. Ansible has a `service` module,
    which can be used to start a service on a host. In this case, we start the `apache2`
    service (the service would’ve already been started when `apache2` was installed,
    but at least this way we can make sure it’s started). You do have to know the
    service name ahead of time, but you don’t have to pay attention to what utility
    needs to be used in the background to start the service. Ansible already knows
    how to start services on all the popular distributions and takes care of the specifics
    for you in the background.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，语法应该是自解释的。Ansible 有一个 `service` 模块，可以用来启动主机上的服务。在这个例子中，我们启动 `apache2`
    服务（虽然在 `apache2` 安装时服务已经自动启动，但这样做至少可以确保它已经启动）。你确实需要提前知道服务的名称，但你无需关注需要在后台使用哪个工具来启动服务。Ansible
    已经知道如何在所有流行的发行版上启动服务，并为你处理后台的具体操作。
- en: 'Having a play that starts `apache2` may seem a bit redundant since most packages
    you install on an Ubuntu server will automatically start the associated service
    as soon as it’s installed (and `apache2` is no exception). But when we write automation
    code, it’s important to be clear and explicit about what the desired end result
    is supposed to be. Even though `apache2` will automatically start once Ansible
    installs the package, we’re adding a `service` play to clarify the fact that it
    needs to be running, so anyone looking at it will know what’s expected. Also,
    we can make sure `apache2` is `enabled` by adding one more line to that section
    of the code (note the bold line):'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 启动 `apache2` 的剧本可能显得有些多余，因为在 Ubuntu 服务器上安装的大多数软件包都会在安装完成后自动启动相关服务（`apache2`
    也不例外）。但是在编写自动化代码时，清晰和明确地表达所期望的最终结果是非常重要的。尽管 `apache2` 在 Ansible 安装完包后会自动启动，但我们还是添加了一个
    `service` 剧本，以明确它需要处于运行状态，这样任何查看它的人都会知道期望的结果是什么。此外，我们可以通过在代码的这一部分再加一行来确保 `apache2`
    被设置为 `enabled`（注意那一行加粗的部分）：
- en: '[PRE34]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: I’ll leave it up to you whether or not to include that extra line, but the takeaway
    is to be as clear and direct as you can when writing automation, so there’s no
    confusion about what the end result is supposed to be.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 我会留给你决定是否包含那一行额外的内容，但关键是当编写自动化脚本时，要尽可能清晰和直接，以避免对最终结果产生任何混淆。
- en: 'Well, that was easy. Let’s create a simple web page for Apache to serve for
    us. It doesn’t need to be fancy, we just want to see that it works. Create the
    following content inside a file named `index.xhtml` in the same working directory
    as the other Ansible files:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，这很简单。让我们为 Apache 创建一个简单的网页，让它为我们提供服务。网页不需要太花哨，我们只是想看到它是否能正常工作。在与其他 Ansible
    文件相同的工作目录中，创建一个名为 `index.xhtml` 的文件，并在其中写入以下内容：
- en: '[PRE35]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'As you can see, that HTML file is fairly lame, but it will work just fine for
    what we need. Next, let’s add another instruction to our Apache playbook:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，这个 HTML 文件相当简单，但对于我们的需求来说，它完全足够了。接下来，让我们在 Apache 的剧本中添加另一条指令：
- en: '[PRE36]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: With the `copy` module, we can copy a file from our local Ansible directory
    to the server. All we need to do is provide it with a source (`src`) and destination
    (`dest`).
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `copy` 模块，我们可以将文件从本地 Ansible 目录复制到服务器。我们只需要提供源文件路径（`src`）和目标路径（`dest`）。
- en: 'Let’s go ahead and run the new playbook:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们继续执行新的剧本：
- en: '[PRE37]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'This will produce an output like the following:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 这将产生如下所示的输出：
- en: '![](img/B18425_15_04.png)'
  id: totrans-167
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B18425_15_04.png)'
- en: 'Figure 15.4: Installing Apache and copying a default site file with Ansible'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 图 15.4：使用 Ansible 安装 Apache 并复制默认站点文件
- en: 'Within a few minutes, you should have at least one web server configured by
    Ansible. In a real production environment, you would’ve only run this on servers
    within a specific role, but roles are beyond the scope of this chapter. But from
    the simple playbook we created, you should be able to see the power of this amazing
    piece of software:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 几分钟内，你应该已经至少配置了一个由 Ansible 管理的 web 服务器。在真实的生产环境中，你只会在特定角色的服务器上运行这些指令，但角色超出了本章的讨论范围。从我们创建的简单剧本中，你应该能够看到这款强大软件的威力：
- en: '![](img/B18425_15_05.png)'
  id: totrans-170
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B18425_15_05.png)'
- en: 'Figure 15.5: An example of a web page provisioned by Ansible'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 图 15.5：Ansible 提供的网页示例
- en: At this point in our exploration into configuration management with Ansible,
    we’ve installed packages, started services, and copied files. Admittedly, this
    isn’t much, but it’s really all you need in order to practice the basics. The
    documentation for Ansible includes guides on how to do all sorts of things, and
    you’ll be able to utilize the various modules it provides to perform many different
    tasks.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们对 Ansible 配置管理的探索过程中，我们已经安装了软件包、启动了服务并复制了文件。诚然，这些操作不算多，但它们正是你练习基础操作所需的。Ansible
    的文档包含了如何做各种操作的指南，你将能够利用它提供的各种模块来执行不同的任务。
- en: To explore Ansible further, I recommend that you think about things you do on
    a regular basis that you would benefit from automating. Things like installing
    security updates, creating user accounts, setting passwords, and enabling services
    to automatically start at boot time are tasks that are easy to get started with.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更深入地探索 Ansible，我建议你考虑一下那些你日常做的、可以从自动化中获益的事情。像安装安全更新、创建用户账户、设置密码和启用服务自动启动等任务，都是很适合开始使用的自动化操作。
- en: In addition, you may want to consider adding a simple **cron job** to run under
    your `ansible` user, to run the playbook every hour or so. We covered cron jobs
    in *Chapter 7*, *Controlling and Managing Processes*. Adding a cron job shouldn’t
    add any overhead from a resource perspective, since Ansible won’t actually be
    doing much unless you add a new command. In more advanced usage, you’ll want to
    have Ansible check out code from a repository and then apply the configuration
    if it has changed. This way, all you have to do is commit to a Git repository
    and all of your servers will download the configuration and run it at the next
    scheduled time. One of the things I love most about Ansible is that it’s easy
    to get started, but you’ll continue to find new ways to use it and benefit from
    it.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，你可能还想考虑为 `ansible` 用户添加一个简单的 **cron 作业**，每小时左右运行一次 playbook。我们在*第七章*《控制和管理进程》中介绍了
    cron 作业。添加 cron 作业不会带来额外的资源开销，因为 Ansible 实际上不会做太多工作，除非你添加了新的命令。在更高级的使用中，你可能希望让
    Ansible 从代码库中检出代码，并在配置发生变化时应用配置。这样，你只需要将更改提交到 Git 仓库，所有服务器将在下一次计划时间下载并运行该配置。我最喜欢
    Ansible 的一点是，它很容易上手，但你会不断发现新的使用方式并从中受益。
- en: Using Ansible’s pull method
  id: totrans-175
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Ansible 的拉取方法
- en: The way we set up our Ansible configuration in the previous section works very
    well if we have a list of specific servers that we want it to manage. To add a
    new server, we create the user account and set up the SSH configuration on the
    new host, and then add it to the inventory file. If we decommission that server,
    we simply remove it from the inventory file. This works well in a static environment,
    where servers you deploy typically stay around for a while. In a dynamic environment,
    though, this may not work as well.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一节中我们设置的 Ansible 配置方法，如果我们有一系列特定的服务器需要管理，效果非常好。要添加新服务器，我们只需要在新主机上创建用户账户并配置
    SSH，然后将其添加到清单文件中。如果我们要停用那台服务器，只需要将其从清单文件中删除。这种方法在静态环境下非常有效，静态环境中部署的服务器通常会保持一段时间。然而，在动态环境中，这种方法可能效果不佳。
- en: Dynamic environments are very typical in the cloud. With cloud computing, you
    typically have one or more virtual servers that provide a service to your company
    or users. These servers may come and go at any time. With dynamic environments,
    servers will come online as needed to handle load and will also get decommissioned
    automatically as load decreases. Therefore, you never really know when a server
    is going to come online, and having to manually provision a server in such an
    environment is inefficient.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 动态环境在云计算中非常典型。在云计算中，通常会有一个或多个虚拟服务器为你的公司或用户提供服务。这些服务器可能随时上线或下线。在动态环境中，服务器会根据需要上线以处理负载，并且随着负载的减少，服务器也会自动下线。因此，你永远不知道服务器何时上线，而在这种环境下手动配置服务器是低效的。
- en: For this reason, Ansible’s inventory file may not be a good fit for dynamic
    infrastructure. There certainly are ways to make Ansible’s inventory work in such
    an environment, as you can actually replace the inventory file with an executable
    script that can make API calls and customize itself for your infrastructure if
    you so desire. However, that’s out of the scope of this book, and there’s an easier
    method anyway.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，Ansible 的清单文件可能不适合动态基础设施。虽然确实有方法可以让 Ansible 的清单在这种环境中工作，实际上你可以用一个可执行脚本替换清单文件，这个脚本可以进行
    API 调用并根据需要自定义你的基础设施。但是，这超出了本书的范围，而且还有一种更简单的方法。
- en: As we’ve seen, Ansible uses an inventory file and connects to every server listed
    in that file. However, Ansible also features a **pull mode**, where instead of
    having a central server that connects to other machines, each server in pull mode
    will actually run Ansible against itself. In my opinion, this is a great way to
    use Ansible and it doesn’t seem to get the attention it deserves. First, I’ll
    explain the theory of how it works, and then we can work through an actual example.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，Ansible 使用清单文件并连接到文件中列出的每一台服务器。然而，Ansible 也有 **拉取模式**，在这种模式下，除了有一个中央服务器连接到其他机器，每台处于拉取模式的服务器实际上会运行
    Ansible 来操作它自身。依我看，这是使用 Ansible 的一种很棒的方式，但它似乎没有得到应有的关注。首先，我将解释它的工作原理，然后我们可以通过一个实际的例子来学习。
- en: With pull mode, you’ll want to have your Ansible playbooks inside a Git repository.
    This repository must be accessible from the servers you will manage. For example,
    if you store the Git repository on GitHub, you’ll want to make sure the servers
    can access GitHub externally. If you host your own Git server internally, you’ll
    want to make sure your servers are able to access it through your firewall or
    any security rules you may have in place.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 使用拉取模式时，你需要将 Ansible playbooks 存放在一个 Git 仓库中。这个仓库必须能够从你将管理的服务器访问。例如，如果你将 Git
    仓库存放在 GitHub 上，你需要确保服务器能够从外部访问 GitHub。如果你在内部托管自己的 Git 服务器，你需要确保服务器能够通过防火墙或你可能设置的任何安全规则访问它。
- en: 'Pull mode is used with the `ansible-pull` command, which comes bundled with
    Ansible. The syntax looks like the following:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 拉取模式是通过 `ansible-pull` 命令实现的，该命令与 Ansible 一起捆绑。语法如下所示：
- en: '[PRE38]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Of course, you’d replace the URL with the actual HTTP or HTTPS URL to your Git
    repository. However, that’s basically it. The `ansible-pull` command simply expects
    the `-U` option (short for URL) along with the URL to a Git repository.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，你需要将网址替换为你实际的 Git 仓库的 HTTP 或 HTTPS 地址。基本上就是这样。`ansible-pull` 命令仅需要 `-U` 选项（即
    URL 的简写）以及指向 Git 仓库的 URL。
- en: 'In order for this to work, you’ll need a playbook inside the repository with
    a special name, `local.yml`. If you don’t declare a specific playbook with Ansible,
    it will expect to find a playbook with that name inside the root of the repository.
    If you choose to use a name for the main playbook that’s something other than
    `local.yml`, you’ll need to specify it:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使这个方法生效，你需要在仓库中有一个特殊命名的 playbook，`local.yml`。如果你没有在 Ansible 中声明特定的 playbook，它将期望在仓库的根目录中找到一个名为
    `local.yml` 的 playbook。如果你选择为主 playbook 使用一个不同于 `local.yml` 的名字，那么你需要指定它：
- en: '[PRE39]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: In this example, the `ansible-pull` command will cache the Git repository located
    at the specified URL locally, and run the playbook `myplaybook.yml` that you would
    have inside the repository. One thing you may find is that Ansible might complain
    about not finding an inventory file, even though that’s the entire point of the
    `ansible-pull` command. You can ignore this error. This will likely be fixed in
    Ansible at some point in the future, but as of the time of this writing, it will
    print a warning if it doesn’t detect an inventory file.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，`ansible-pull` 命令会将位于指定 URL 的 Git 仓库缓存到本地，并运行仓库中的 `myplaybook.yml` 这个
    playbook。你可能会发现 Ansible 会抱怨找不到清单文件，尽管这正是 `ansible-pull` 命令的整个目的。你可以忽略这个错误。这个问题可能会在未来的某个版本中得到修复，但截至本文写作时，如果它没有检测到清单文件，会打印一个警告。
- en: 'With the theory out of the way, let’s work through an actual example. If you’ve
    been following along so far, we created a playbook in the previous section that
    automates the deployment of a hypothetical web server. We can reuse that code.
    However, it’s best practice to have a file with the name `local.yml`, so you can
    simply rename the `apache.yml` playbook we created earlier to `local.yml`. There’s
    one small change we need to make to the file, which I’ve highlighted here:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 理论部分讲解完毕后，让我们通过一个实际的例子来操作。如果你到目前为止都在跟着学习，我们在上一节中创建了一个自动化部署假设性 Web 服务器的 playbook。我们可以重用那段代码。不过，最佳实践是将文件命名为`local.yml`，因此你可以简单地将我们之前创建的`apache.yml`
    playbook 重命名为`local.yml`。我们需要对文件做一个小修改，我在这里已将其标出：
- en: '[PRE40]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Since we’re executing the playbook locally (without SSH) we changed the `hosts`:
    line to point to `localhost`, to instruct Ansible that we want to execute the
    commands locally rather than remotely. Now, we can push this playbook to our Git
    repository and execute it directly from the repository URL.'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们是在本地执行 playbook（没有 SSH），我们将 `hosts:` 行修改为指向 `localhost`，以告知 Ansible 我们希望在本地执行命令，而不是远程执行。现在，我们可以将这个
    playbook 推送到我们的 Git 仓库，并直接从仓库 URL 执行它。
- en: 'Pay careful attention to the `hosts:` line of any playbook you intend to run.
    If you are using the pull method, this line will need to be changed from `hosts:
    all` to `hosts: localhost`, the reason being, we are executing the playbooks directly
    on localhost, rather than from a remote SSH connection. If you don’t make this
    change, you’ll see an error similar to the following:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: '在执行任何 playbook 时，请仔细注意 `hosts:` 行。如果你使用的是 pull 方法，这一行需要从 `hosts: all` 改为 `hosts:
    localhost`，原因是我们是直接在本地主机上执行 playbook，而不是通过远程 SSH 连接来执行。如果你没有做这个修改，你会看到类似下面的错误：'
- en: '[PRE41]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Before you run the playbook, you’ll want to first switch to your Ansible user,
    since the playbook will need to be run as a user with `sudo` privileges since
    it will execute system-level commands:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 在运行 playbook 之前，你需要先切换到你的 Ansible 用户，因为该 playbook 需要以具有 `sudo` 权限的用户身份运行，因为它将执行系统级命令：
- en: '[PRE42]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Then, execute the playbook:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，执行 playbook：
- en: '[PRE43]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'If we kept the name as `apache.yml`, we would just specify that:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们保持文件名为 `apache.yml`，我们只需要指定该文件名即可：
- en: '[PRE44]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: Keep in mind that since `ansible-pull` executes playbooks directly on localhost,
    the playbook must be executed by a user that has access to `sudo`. If `sudo` is
    not configured to run as that user without a password, the playbook will fail
    as it’s not interactive (it won’t ask for the password). You can also use `sudo`
    in front of the `ansible-pull` command and provide the password before it runs,
    but that won’t work if you set it up to run automatically via cron.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，由于`ansible-pull`直接在本地主机上执行 playbook，因此该 playbook 必须由具有`sudo`权限的用户来执行。如果`sudo`没有配置为允许该用户无需密码运行，playbook
    执行时将会失败，因为它不是交互式的（它不会询问密码）。你也可以在`ansible-pull`命令前加上`sudo`并在执行前输入密码，但如果你设置为通过 cron
    自动运行的话，这种方式就行不通了。
- en: If all goes according to plan, the playbook repository should be cached to the
    server, and the instructions carried out. If there is an error, Ansible is fairly
    good about presenting logical error messages. As long as the user has permission
    to execute privileged commands on the server, the required files are present in
    the repository, and the server has access to download the repository (a firewall
    isn’t blocking it), then the playbook will run properly.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一切按计划进行，playbook 仓库应该已经缓存到服务器，并且指令会被执行。如果出现错误，Ansible 会相当善于提供逻辑性错误信息。只要用户有权限在服务器上执行特权命令，仓库中包含所需的文件，并且服务器能够访问并下载仓库（没有防火墙阻止），那么
    playbook 就会正确运行。
- en: When it comes to implementing the pull method in production across various server
    types, there are several ways we can go about this. One way is to have a separate
    playbook per server type. For example, perhaps you’d have an Apache playbook,
    as well as playbooks specific to database servers, file servers, user workstations,
    and so on. Then, depending on the type of server you’re deploying, you’d specify
    the appropriate playbook when you called the `ansible-pull` command. If you’re
    using a service such as cloud computing, you can actually provide a script for
    each server to execute upon creation. You can then instruct the service to automatically
    run the `ansible-pull` command any time a new server is created. In AWS, for example,
    you can use a feature known as user data to place a script for a server to execute
    when it’s launched for the first time. This saves you from having to provision
    anything manually. For this to work, you would first include a command for the
    server to install Ansible itself, and then the next command would be the `ansible-pull`
    command along with the URL to the repository. Just those two lines would completely
    automate the installation of Ansible and the application of your playbook. Try
    to think of the possibilities ahead of time so you can understand the many ways
    that automation can benefit you.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 在生产环境中实施拉取方法时，针对不同类型的服务器有几种方法可以实现。一种方法是为每种服务器类型单独创建一个playbook。例如，你可能会有一个Apache的playbook，以及专门用于数据库服务器、文件服务器、用户工作站等的playbook。然后，根据你部署的服务器类型，在调用`ansible-pull`命令时指定相应的playbook。如果你使用的是像云计算这样的服务，你实际上可以为每个服务器提供一个创建时要执行的脚本。你可以指示服务在每次创建新服务器时自动运行`ansible-pull`命令。例如，在AWS中，你可以使用一种叫做用户数据的功能，在服务器第一次启动时执行一个脚本。这可以避免你手动配置任何内容。为了使其工作，你需要首先包含一个命令来安装Ansible本身，接着第二个命令是`ansible-pull`命令，并附上仓库的URL。这仅仅是两行代码，就可以完全自动化Ansible的安装和playbook的应用。提前考虑这些可能性，帮助你理解自动化如何为你带来诸多好处。
- en: While provisioning new servers properly and efficiently is very important, so
    too is maintaining your existing servers. When you need to install a new package
    or apply a security update, the last thing you want to do is connect to all of
    your servers manually and update them one by one. The `ansible-pull` command allows
    simple management as well; you just simply run the command again. Every time you
    run `ansible-pull`, it will download the latest version of the code within your
    repository and run it. If there are any changes, they will be applied, while things
    that have already been applied will be skipped. For example, if you include a
    play to install the `apache2` package, Ansible won’t reinstall the package if
    you run the playbook a second time; it will skip that play since that requirement
    has already been met.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然正确有效地配置新服务器非常重要，但维护现有服务器同样重要。当你需要安装新软件包或应用安全更新时，最后你想做的事就是手动连接到每一台服务器，逐个更新它们。`ansible-pull`命令也能简化管理；你只需再次运行命令。每次运行`ansible-pull`时，它会下载仓库中的最新代码并运行。如果有任何更改，它们会被应用，已经应用的部分则会被跳过。例如，如果你在playbook中包含了安装`apache2`包的任务，Ansible在第二次运行playbook时不会重新安装这个包，因为该需求已经满足，它会跳过这一任务。
- en: One trick worth knowing with `ansible-pull` is the `-o` option. This option
    will ensure that the playbook inside the repository is only run if there have
    been any actual changes to the repository. If you haven’t committed any changes
    to the repository, it will skip the entire thing. This is very useful if you set
    up the `ansible-pull` command syntax to be run periodically via cron, for example,
    every hour.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: '`ansible-pull`的一个值得了解的技巧是`-o`选项。这个选项会确保只有在仓库中有实际更改时，仓库内的playbook才会被运行。如果你没有提交任何更改，Ansible将跳过整个过程。如果你将`ansible-pull`命令设置为定期通过cron运行，比如每小时运行一次，这个功能非常有用。'
- en: If you don’t include the `-o` option, Ansible will run the entire playbook every
    hour. This will consume valuable CPU resources for no good reason at all. With
    the `-o` option, Ansible will only use as much CPU as required for simply checking
    the repository for changes. The playbook will only be run if you actually commit
    changes to the repository.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你没有包含`-o`选项，Ansible将每小时运行整个playbook。这将无端消耗宝贵的CPU资源。使用`-o`选项时，Ansible将仅使用必要的CPU资源来检查仓库是否有更改。仅当你实际提交了更改到仓库时，playbook才会被运行。
- en: The introduction to Ansible within this chapter has been very basic, as we’ve
    only used the very core of the required components. By looking deeper into Ansible,
    you’ll find more advanced techniques, and some more clever ways to implement it.
    Examples include automating firewall rules, security patches, and user passwords,
    as well as having Ansible send you an email any time a server is successfully
    provisioned (or even when that fails). Basically, just about anything you can
    do manually, you can automate with Ansible. In the future, I recommend looking
    at server administration with an automation mindset. As I’ve mentioned several
    times before, if you will need to perform a task more than once, automate it.
    Ansible is one of the best ways of automating server administration.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 本章节中对Ansible的介绍非常基础，我们仅使用了所需组件的核心部分。通过深入研究Ansible，您将发现更高级的技术，以及一些更聪明的实施方式。例如自动化防火墙规则、安全补丁和用户密码，还可以让Ansible在成功配置服务器时发送电子邮件（甚至在失败时也可以）。基本上，您可以手动执行的任何任务，都可以用Ansible自动化。在未来，我建议以自动化的思维方式进行服务器管理。正如我之前多次提到的，如果您需要重复执行某项任务，就自动化它。Ansible是自动化服务器管理的最佳途径之一。
- en: Summary
  id: totrans-205
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we took a look at configuration management using Ansible. Ansible
    is an exciting technology that is exploding in popularity. It gives you the full
    power of configuration management utilities such as Chef or Puppet, without all
    the resource overhead. It allows you to automate just about everything. During
    our exploration, we walked through installing packages, copying files, and starting
    services. Near the end of the chapter, we worked through an example of using Ansible
    to provision a simple web server, and we even explored the pull method, which
    is very useful in dynamic environments. These concepts form the basis of knowledge
    that can be expanded to automate more complex rollouts.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们介绍了使用Ansible进行配置管理的内容。Ansible是一项越来越受欢迎的令人兴奋的技术。它为您提供了像Chef或Puppet等配置管理工具的全部功能，但没有所有的资源开销。它允许您几乎自动化所有事务。在我们的探索过程中，我们介绍了安装软件包、复制文件和启动服务的过程。在章节的末尾附近，我们通过一个示例介绍了如何使用Ansible来配置一个简单的Web服务器，甚至探讨了在动态环境中非常有用的拉取方法。这些概念构成了可以扩展到自动化更复杂部署的知识基础。
- en: 'The next chapter will be fun: we’ll set up our very own virtualization server
    with KVM. This is one of my favorite topics, and I’m sure you’ll enjoy it too.
    See you there!'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 下一章会很有趣：我们将使用KVM搭建我们自己的虚拟化服务器。这是我最喜欢的话题之一，我相信你也会喜欢。到时见！
- en: Relevant videos
  id: totrans-208
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 相关视频
- en: 'Git Essentials (LearnLinuxTV): [https://linux.video/git-essentials](https://linux.video/git-essentials)'
  id: totrans-209
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'Git Essentials (LearnLinuxTV): [https://linux.video/git-essentials](https://linux.video/git-essentials)'
- en: 'Getting Started with Ansible (LearnLinuxTV): [https://linux.video/learn-ansible](https://linux.video/learn-ansible)'
  id: totrans-210
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '使用Ansible入门 (LearnLinuxTV): [https://linux.video/learn-ansible](https://linux.video/learn-ansible)'
- en: 'Ansible workstation/laptop configuration (LearnLinuxTV): [https://linux.video/ansible-workstation](https://linux.video/ansible-workstation)'
  id: totrans-211
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '使用Ansible配置工作站/笔记本电脑 (LearnLinuxTV): [https://linux.video/ansible-workstation](https://linux.video/ansible-workstation)'
- en: 'Ansible Vault (LearnLinuxTV): [https://linux.video/ansible-vault](https://linux.video/ansible-vault)'
  id: totrans-212
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'Ansible Vault (LearnLinuxTV): [https://linux.video/ansible-vault](https://linux.video/ansible-vault)'
- en: 'Ansible Pull (LearnLinuxTV): [https://linux.video/ansible-pull](https://linux.video/ansible-pull)'
  id: totrans-213
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'Ansible Pull (LearnLinuxTV): [https://linux.video/ansible-pull](https://linux.video/ansible-pull)'
- en: Further reading
  id: totrans-214
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: 'Ansible documentation: [https://learnlinux.link/ansible-docs](https://learnlinux.link/ansible-docs)'
  id: totrans-215
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'Ansible文档: [https://learnlinux.link/ansible-docs](https://learnlinux.link/ansible-docs)'
- en: 'Ansible Roles documentation: [https://learnlinux.link/reuse-roles](https://learnlinux.link/reuse-roles)'
  id: totrans-216
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'Ansible角色文档: [https://learnlinux.link/reuse-roles](https://learnlinux.link/reuse-roles)'
- en: 'Ansible config file documentation article: [https://learnlinux.link/a-config](https://learnlinux.link/a-config)'
  id: totrans-217
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'Ansible配置文件文档文章: [https://learnlinux.link/a-config](https://learnlinux.link/a-config)'
- en: '`ansible-pull` documentation: [https://learnlinux.link/a-pull](https://learnlinux.link/a-pull)'
  id: totrans-218
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ansible-pull`文档: [https://learnlinux.link/a-pull](https://learnlinux.link/a-pull)'
- en: 'How to manage your workstation configuration with Ansible: [https://learnlinux.link/a-ws](https://learnlinux.link/a-ws)'
  id: totrans-219
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '如何使用Ansible管理您的工作站配置: [https://learnlinux.link/a-ws](https://learnlinux.link/a-ws)'
- en: 'Git basics: [https://learnlinux.link/git-book](https://learnlinux.link/git-book)'
  id: totrans-220
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'Git基础: [https://learnlinux.link/git-book](https://learnlinux.link/git-book)'
- en: 'Setting up Git (GitHub): [https://learnlinux.link/setup-git](https://learnlinux.link/setup-git)'
  id: totrans-221
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '设置Git (GitHub): [https://learnlinux.link/setup-git](https://learnlinux.link/setup-git)'
- en: Join our community on Discord
  id: totrans-222
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 加入我们社区的Discord
- en: 'Join our community’s Discord space for discussions with the author and other
    readers:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 加入我们社区的Discord空间，与作者和其他读者进行讨论：
- en: '[https://packt.link/LWaZ0](https://packt.link/LWaZ0)'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://packt.link/LWaZ0](https://packt.link/LWaZ0)'
- en: '![](img/QR_Code50046724-1955875156.png)'
  id: totrans-225
  prefs: []
  type: TYPE_IMG
  zh: '![](img/QR_Code50046724-1955875156.png)'
