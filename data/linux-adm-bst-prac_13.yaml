- en: '*Chapter 10*: User and Access Management Strategies'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第10章*：用户与访问管理策略'
- en: In the **Linux** world it is all too easy to forget that we still have users,
    and they still need all of the oversight, security, and management that we would
    expect in the **Windows** or **macOS** worlds. Users are typically an afterthought
    on Linux-based operating systems as systems are often seen as just black box server
    workloads or bizarre appliances to which end users do not apply. This is not true,
    of course. Users matter on any Linux system just as they do on anything else.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在**Linux**世界中，我们很容易忘记我们依然有用户，而这些用户仍然需要我们在**Windows**或**macOS**世界中期望的所有监督、安全和管理。在基于Linux的操作系统中，用户通常是被忽视的，因为这些系统常常被视为黑盒服务器工作负载或奇怪的设备，最终用户不需要关心。这当然并不正确。用户在任何Linux系统中都很重要，就像在其他任何系统中一样。
- en: In this chapter, we are going to talk about user and user access management
    for both servers and for end user devices. We are going to look at approaches
    common in the Windows world, and approaches commonly known in the UNIX world,
    and we are going to talk about some alternative approaches that are starting to
    emerge in the industry.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将讨论服务器和最终用户设备的用户及用户访问管理。我们将研究在Windows世界中常见的方法，以及在UNIX世界中常见的方法，并且我们还会谈到一些在行业中开始出现的替代方法。
- en: We will also look at remote access for Linux – that is, supporting or working
    from our systems remotely. Of course, all of this will be done in the context
    of security, as user management is fundamentally a security topic.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将讨论Linux的远程访问——即支持或从我们的系统进行远程工作。当然，所有这一切都将在安全的背景下进行，因为用户管理本质上是一个安全话题。
- en: 'In this chapter, we are going to learn about the following:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将学习以下内容：
- en: Local and remote users
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 本地用户与远程用户
- en: User management mechanisms
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用户管理机制
- en: Remote access approaches
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 远程访问方法
- en: SSH, key management and jump boxes
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: SSH、密钥管理和跳转服务器
- en: Alternative remote access approaches
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 替代的远程访问方法
- en: Terminal servers and VDI
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 终端服务器和虚拟桌面基础架构（VDI）
- en: Local and remote users
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 本地用户与远程用户
- en: At the highest level, there are two basic ways to think of user accounts on
    any system. The first is local accounts that exist on the local system where they
    are being used. The second is user accounts stored remotely on some sort of server
    that the local system references over the network. Of course, there are hybrid
    methods that combine these techniques in various ways as well.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 从最高层次来看，任何系统上的用户账户有两种基本的思考方式。第一种是本地账户，存在于本地系统上并被使用。第二种是用户账户，存储在某种远程服务器上，本地系统通过网络进行引用。当然，也有将这些技术以各种方式结合的混合方法。
- en: We should start by talking about the obvious benefits to both approaches. With
    locally managed user accounts we have lightning-fast access to our account information
    and no dependence on the network. This provides obvious performance advantages,
    better security, and protection against services failing elsewhere impacting our
    local systems. Local users are robust and simple, fast and easy. Until the 1990s
    it was rare to even consider the possibility of anything else.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 我们应该首先谈论这两种方法的明显好处。对于本地管理的用户账户，我们可以迅速访问账户信息，并且不依赖于网络。这带来了明显的性能优势、更好的安全性，并且防止了其他服务的故障影响到我们的本地系统。本地用户是稳健且简单的，快速且易用。直到1990年代，甚至很少有人考虑其他可能性。
- en: '*Remotely managed users* make up the overwhelming majority of cases today because
    this model allows for a *single source of truth* for users between different organizations,
    and in some cases, even inter-organizationally! This has many benefits, such as
    allowing users to make a single, complicated password that they actually have
    some chance of remembering and being able to use it in many places, change it
    once to change it everywhere, and making it simple for the support team (which
    might mean us as the system administrators) to reset, lock, or disable accounts.'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: '*远程管理的用户*今天占据了绝大多数的情况，因为这种模式使得不同组织之间的用户可以有一个*单一的真理来源*，有时候甚至可以跨组织使用！这有许多好处，比如允许用户创建一个复杂的密码，他们有可能记住并在多个地方使用，修改一次密码就能在所有地方生效，同时也使得支持团队（这可能是我们这些系统管理员）可以轻松重置、锁定或禁用账户。'
- en: It has become common to assume that only remote user accounts are plausible
    in modern businesses, but local accounts remain fully functional and viable, and
    are a good choice for a great number of organizations of any size. Do not simply
    assume that because of your size or modernity that one style or the other is appropriate
    for your use case. Of course, nearly all existing organizations are heavily invested
    in whatever architecture that they are going to use and changing is a very large
    undertaking. It is rare that we get the joy of implementing something like user
    management on any scale in a green field scenario, but it does happen from time
    to time.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在现代企业中，假设只有远程用户账户是可行的已经成为常见做法，但本地账户依然完全可用且可行，对于各种规模的组织来说，仍然是一个不错的选择。不要仅仅因为你的规模或现代化程度而认为某种方式适合你的使用场景。当然，几乎所有现有组织都已经在他们将要使用的架构上进行了大量投资，改变架构是一个非常庞大的工作。我们很少能有机会在一片空白的环境中实施类似用户管理的项目，但偶尔也会遇到这种情况。
- en: Local user management requires less network bandwidth, but that is essentially
    never a concern today. Far more important are the issues around security and availability.
    Most networks are extremely fast today and user management uses few resources;
    this has led to vendors providing user management as a service allowing centralized
    user accounts to be provided via hosted vendors over the Internet. If the Internet
    can adequately provide bandwidth for these services, LAN-based versions should
    have no issue at all.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 本地用户管理需要的网络带宽更少，但今天这基本上已经不是一个问题。更为重要的是安全性和可用性问题。如今，大多数网络非常快，用户管理所需的资源也很少；这导致供应商将用户管理提供为一种服务，通过托管服务商通过互联网提供集中式用户账户。如果互联网能够为这些服务提供足够的带宽，那么基于局域网的版本应该也不会有问题。
- en: Security becomes a problem because having a single account that is available
    in many locations means that there is a single account to attack aggressively
    and, if compromised, will essentially provide unlimited access to all places where
    that account is used. If we have local user accounts and reuse the same password
    over and over again this mimics this problem so in many cases this becomes a moot
    point unless we have a scenario where our users are truly using different credentials
    in different locations. For traditional end users, this is not very likely to
    be the case. For system administrators this might be relatively easy to do. High
    security users with training and an understanding of the importance of their credentials
    may easily take advantage of the flexibility of local accounts. You have to know
    your users and their willingness to participate in order to really evaluate the
    security posture potential in this case.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 安全性成为问题的原因是，多个地方共享同一个账户意味着有一个账户会成为攻击的目标，而如果这个账户被攻破，实际上将无限制地访问所有使用该账户的地方。如果我们使用本地用户账户，并且在不同地方重复使用相同的密码，那么这就模拟了这个问题，因此在很多情况下，除非我们遇到一种情况，用户在不同位置使用不同的凭证，否则这个问题并不成立。对于传统的终端用户来说，这种情况不太可能发生。对于系统管理员来说，这可能相对容易做到。经过培训并理解凭证重要性的高安全性用户，可能很容易利用本地账户的灵活性。你必须了解你的用户及其参与意愿，才能真正评估这种情况中的安全潜力。
- en: The bigger issue surrounding security is the specific mechanism that supports
    the remote accounts, which can be attacked separately from the accounts supported
    by it. Whatever mechanism you chose, there must be communications over the network
    in order for the accounts to be able to centralize. In almost all cases, there
    is also some form of local fallback – such as a credential cache – that can be
    attacked, so having accounts exist remotely almost never eliminates the need to
    also have them locally as well as some mechanism. If such a mechanism is lacking,
    then there are readily available methods to disrupt logins by attacking network
    access.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 围绕安全性的更大问题是支持远程账户的具体机制，它们可以单独受到攻击，而与其支持的账户是分开的。无论你选择哪种机制，都必须通过网络进行通信，以便这些账户能够集中化。在几乎所有情况下，还会有某种形式的本地回退机制——例如凭证缓存——它也可能成为攻击的目标，因此远程存在的账户几乎从未能完全消除本地账户及某种机制的需求。如果缺乏这样的机制，那么就有现成的方法可以通过攻击网络访问来中断登录。
- en: Remote user management benefits from having a central store that can receive
    more focused security attention and that can be kept far more easily from being
    physically exposed to attackers. End points typically have, at most, a small number
    of cached user accounts or emergency access accounts on them and not the entire
    user list minimizing the risks of a stolen laptop or compromised desktop from
    impacting beyond the built-in list of accounts cached on the device.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 远程用户管理的优势在于拥有一个中央存储库，这个存储库可以接收更专注的安全关注，并且能够更轻松地防止物理暴露给攻击者。终端设备通常最多只会缓存少数的用户账户或紧急访问账户，而不是整个用户列表，从而减少了盗窃笔记本电脑或桌面被攻击时，影响超出设备上缓存的账户列表的风险。
- en: Neither method constitutes anything close to a best practice. Both are completely
    viable and should be evaluated both at an organizational, as well as a workload,
    level. It is not uncommon for businesses to elect to use different methods for
    different purposes. There is generally no need to institute a single mechanism
    as most organizations are large enough to have varying needs and to justify implementing
    more than one mechanism inside of the organization. Often this hybrid approach
    works best as centralized accounts tend towards being most beneficial for most
    end users and local accounts tend towards being best for IT and other technical
    departments.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 这两种方法都不能算作最佳实践。两者都是完全可行的，并且应当在组织层面以及工作负载层面进行评估。企业选择使用不同的方法来满足不同需求并不罕见。通常没有必要实行单一机制，因为大多数组织足够庞大，拥有多样化的需求，且可以合理地在组织内部实施多个机制。通常，这种混合方式效果最佳，因为集中账户对于大多数终端用户最有利，而本地账户则更适合
    IT 和其他技术部门。
- en: With that foundation under our belts, we are prepared to talk about the mechanisms
    that can manage these users, wherever we choose to implement them.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们掌握了这些基础知识后，我们准备好讨论可以管理这些用户的机制，无论我们选择在哪里实现它们。
- en: User management mechanisms
  id: totrans-22
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 用户管理机制
- en: In the real world there are many user management mechanism implementations to
    consider. Some are native to UNIX or Linux, some are common in the Windows world,
    some are novel, and some are universal and agnostic.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 在现实世界中，有许多用户管理机制的实现方式需要考虑。有些是 UNIX 或 Linux 原生的，有些在 Windows 世界中常见，有些是新兴的，还有些则是通用且中立的。
- en: It should go without saying that our first stop on any journey of investigating
    user management mechanisms is the Linux user system itself. Simple and universal,
    every Linux system of note ships with it. Of course, it can be replaced, but in
    practice it never is. This system carries the huge advantages of being always
    built in, very fast and secure, and well known by every UNIX admin anywhere. There
    is almost nothing to go wrong, nothing complex anywhere in the system. A few archaic
    components might linger on having been left over from the olden days that might
    be a little confusing if one finds it necessary to do manual configurations, but
    today almost no one manipulates these systems by hand anyway (although it is always
    good to know how to do so just in case.) Local users are always very easily automated
    by custom script, stock tools, or things like state machines.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 需要说明的是，任何探讨用户管理机制的旅程，首先要研究的就是 Linux 用户系统本身。简单而通用，每个值得一提的 Linux 系统都会自带此系统。当然，这个系统是可以被替代的，但实际上它几乎从未被替换。这个系统有着巨大的优势：它始终内置、速度非常快、安全性高，且为每个
    UNIX 管理员所熟知。系统中几乎没有出错的地方，也没有复杂的设计。虽然有一些过时的组件可能会因为早期的遗留而存在，如果有必要进行手动配置，可能会让人感到有些困惑，但如今几乎没有人手动操作这些系统（尽管了解如何手动操作总是有备无患）。本地用户通常可以通过自定义脚本、现有工具或状态机等方式非常轻松地自动化。
- en: Using automation to turn local uses into remote users
  id: totrans-25
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用自动化将本地用户转化为远程用户
- en: Here is one of those cases where we end up being unable to define the difference
    between a local user and a remote user. One important approach to local user management
    is to have a master user list stored elsewhere. This list might be a simple text
    file that we run a script against, or more likely a configuration file in a state
    management system used as part of an Infrastructure as Code implementation.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 这正是我们无法区分本地用户和远程用户之间差异的一个典型案例。对本地用户管理的一种重要方法是将主用户列表存储在其他地方。这个列表可能是一个简单的文本文件，我们对其运行脚本，或者更可能是一个配置文件，在基础设施即代码的实现中作为状态管理系统的一部分。
- en: In this example our central management system can be used to push out user accounts,
    permissions, and details from the central configuration system onto each host
    in our network. The system might put all users on all machines, or just the users
    assigned to those machines. These kinds of decisions are all completely subject
    to your discretion during implementation.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们的中央管理系统可以用于将用户账户、权限和细节从中央配置系统推送到我们网络中的每台主机上。系统可能会将所有用户推送到所有机器上，或者只将分配给这些机器的用户推送上去。这些决策在实施过程中完全由你来决定。
- en: In this example, yes, we still use the local user mechanism on each computer
    and there is no need to reach out over the network in order to log in at any given
    time, however the accounts are still centrally controlled in a way that almost
    completely mimics a system like Active Directory. We can centrally enforce password
    rules, we can centrally create or revoke accounts, we can centrally control onto
    which machines logins can and cannot happen, and so forth. We essentially have
    a central user system, not a local one.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，是的，我们仍然在每台计算机上使用本地用户机制，并且在任何给定时刻都不需要通过网络进行登录，然而账户仍然是以一种几乎完全模仿像Active
    Directory这样的系统的方式进行中央控制的。我们可以集中执行密码规则，可以集中创建或撤销账户，可以集中控制哪些机器可以或不可以登录，等等。我们本质上有一个中央用户系统，而不是本地系统。
- en: The key difference is that with a true central user directory such as Active
    Directory, user activity is directed to the central system and only optionally
    will hit a local cache when the system is offline or in some degraded state. When
    possible, network activity occurs to support the login process. With a mechanism
    such as the one we are describing, all logins happen purely using local – that
    is to say, *non-networked* – resources, and the central system is only used to
    update the local login list and details. A carefully worded semantic difference
    between local accounts and locally cached accounts to be sure, but the behaviors
    of the two truly are different. It is a very interesting thought experiment, though.
    It is assumed that locally maintained accounts will have to hold all users on
    each device, but in practice there are many ways to limit this to just a few and
    sometimes even just one user, while it is assumed that none or just a few users
    will be cached onto a local device from a remote user management system but in
    some cases the entire user list might be cached there. The difference here is
    how the user list is created locally and knowing how that mechanism works in your
    case combined with knowing how the system is used will tell you the exposure of
    both approaches for you.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 关键的区别在于，像Active Directory这样的真正中央用户目录中，用户活动会被导向中央系统，只有在系统离线或处于某种降级状态时，才会可选地触发本地缓存。当可能时，网络活动会支持登录过程。我们所描述的机制中，所有的登录都是通过本地资源进行的——也就是说，*非网络化*的资源，而中央系统仅用于更新本地登录列表和细节。虽然“本地账户”和“本地缓存账户”之间存在精确的语义差异，但这两者的行为确实是不同的。这是一个非常有趣的思维实验。假设本地维护的账户必须在每台设备上包含所有用户，但实际上有许多方法可以将其限制为仅几个用户，甚至有时仅一个用户，同时假设没有用户或只有少数用户会从远程用户管理系统缓存到本地设备，但在某些情况下，整个用户列表可能会被缓存到本地。这里的区别在于用户列表是如何本地创建的，了解这种机制在你案例中的工作原理，再加上了解系统的使用方式，就能告诉你两种方法对你的暴露程度。
- en: However, automation of this nature provides a pretty significant opportunity
    to rethink our assumptions around local user limitations. In this kind of situation,
    we might be able to recreate many or all of the desired features that are generally
    assumed to be provided exclusively by heavier and more fragile remote user systems
    using only local users. In a modern environment with applications that typically
    do not authenticate to an extension of the operating system authentication system
    this can potentially work beautifully, especially on a Linux-based operating system
    where such integrations are not common. If your network architecture is one that
    uses shared authentication methods, like those provided by Active Directory, to
    allow access network resources then this methodology will fall short of the smooth,
    integrated experience that one traditionally has with those models. Network resource
    design models that rely on those shared authentication processes are starting
    to lose their ground as the dominant approach today as the user experience landscape
    starts to change in the wake of greater work from home, user mobility, and security
    concerns.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这种自动化本质上提供了一个相当重要的机会，让我们重新思考关于本地用户限制的假设。在这种情况下，我们或许能够仅通过本地用户重新创建许多或所有通常被认为仅由更重、更脆弱的远程用户系统提供的期望功能。在现代环境中，应用程序通常不会对操作系统认证系统的扩展进行身份验证，这种方法可能会非常奏效，尤其是在基于
    Linux 的操作系统上，在这种系统上，这种集成并不常见。如果你的网络架构采用共享认证方法，例如通过 Active Directory 提供的方式来允许访问网络资源，那么这种方法将无法提供与这些模型通常所具有的平滑、集成体验。依赖这些共享认证过程的网络资源设计模型在如今的主流方法中正逐渐失去其地位，因为随着居家办公的增加、用户的流动性增强以及安全问题的关注，用户体验的格局开始发生变化。
- en: Moving past local users for which there is effectively only the default mechanism
    we start to see a variety of legacy and more modern user management options, and
    more will certainly be coming in the future as this space heats up as new demands
    on infrastructure are shifting user management priorities for many businesses.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 在超越本地用户之后，实际上只有默认机制可用时，我们开始看到各种遗留的和更现代的用户管理选项，随着这一领域的升温，未来肯定会有更多选项出现，因为新的基础设施需求正在推动许多企业对用户管理优先级的转变。
- en: Traditionally in the UNIX landscape, which of course includes Linux, the standard
    user centralization service was the **Network Information Service** originally
    called YellowPages and eventually just known as **NIS**. NIS was introduced by
    **SUN Microsystems** in 1985 and it quickly caught on across the UNIX world and
    changed how people thought about users across systems. NIS was the vanguard of
    the movement that drove IT development in the 1990s as directory services became
    the hot strategic technology of the age. NIS may have not been the absolute first
    directory service (although maybe it was), but it was certainly the first to see
    widespread use or to fundamentally shift the industry's paradigm of user management.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 在 UNIX 环境中，当然包括 Linux，传统的用户集中管理服务是**网络信息服务**，最初称为 YellowPages，后来简化为**NIS**。NIS
    由**SUN Microsystems**于1985年推出，并迅速在 UNIX 世界中普及，改变了人们对跨系统用户的思考方式。NIS 是推动1990年代 IT
    发展运动的先锋，当时目录服务成为那个时代的热门战略技术。NIS 可能不是第一个目录服务（尽管也许是），但它无疑是第一个广泛应用并且从根本上改变了行业的用户管理范式的服务。
- en: NIS was extremely basic, but flexible and easy to manage, and lacked almost
    all security as it would be needed today - all things that made it effective in
    its time. NIS became all but universally available on all UNIX systems including
    commercial offerings like Solaris and AIX as well as on open source offerings
    like BSD and Linux-based operating systems. Learning NIS meant you could work
    across operating system divides easily and NIS provided interoperability between
    disparate UNIX flavors as well.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: NIS 非常基础，但灵活且易于管理，几乎没有现代所需的所有安全性——这些特性在当时使其非常有效。NIS 几乎在所有 UNIX 系统上都普遍可用，包括 Solaris
    和 AIX 等商业产品，以及 BSD 和基于 Linux 的开源操作系统。学习 NIS 意味着你可以轻松跨操作系统进行工作，NIS 还提供了不同 UNIX
    版本之间的互操作性。
- en: Given the immense age of NIS and the lack of security and scalability it might
    seem as though NIS would have faded into the past leaving us with nothing but
    stories for old timers to bring out over the campfire, but this is not the case.
    NIS remains in use today, especially in well entrenched, larger firms where NIS
    implementations might easily stretch back to the 1990s when it was the key technology
    still. New deployments might have all but disappeared over a decade ago, but old
    ones linger on. In fact, at the time of writing, every major Linux-based operating
    system still includes packages and support for NIS both to allow the system to
    act as a NIS client as well as creating new NIS servers! It has been proposed
    that RHEL will drop NIS in the next few years, but at this point it is still a
    proposal and still some ways off in the future. NIS has created quite the legacy
    for itself.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑到NIS的巨大历史以及它在安全性和可扩展性方面的不足，似乎NIS早已过时，成为人们围坐篝火旁给老一辈讲述的故事，但事实并非如此。NIS至今仍在使用，尤其是在一些历史悠久的大型企业中，NIS的实现可能早在1990年代就已开始使用，那时它仍是关键技术。新的部署可能早在十多年前几乎就消失了，但旧的实现仍然存在。事实上，在撰写本文时，每个主要的基于Linux的操作系统仍然包括NIS的包和支持，既可以使系统作为NIS客户端使用，也可以创建新的NIS服务器！有人提出RHEL将在未来几年弃用NIS，但目前这仍然只是一个提议，离实际发生还有一段时间。NIS为自己创造了相当深远的影响。
- en: NIS lacked so much, especially in the areas of security and scalability, that
    its designers attempted to replace it after just seven years introducing NIS+
    in 1992 (I told you that the 1990s were big on directory services.) NIS+ was not
    a direct upgrade for NIS, however, and proved to be hard to manage and was not
    a smooth upgrade process from NIS. NIS+ never gained strong enough traction to
    make it a major player and NIS actually managed to outlive it in real world utilization
    and in software support. SUN, who made both NIS and NIS+, announced that NIS+
    was to be discontinued in 2002 and while it was still officially supported for
    several more years it was waning. NIS+ advanced the art of centralized user management,
    to be sure, but it never itself became a key technology. Its heyday was in the
    mid-1990s, but as so many technologies were being fielded during that era it was
    lost in a sea of competition from every angle - including from new players like
    Novell and Microsoft.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: NIS存在许多不足，特别是在安全性和可扩展性方面，以至于它的设计者在仅仅七年后就尝试用1992年推出的NIS+来替代它（我告诉过你，1990年代是目录服务的黄金时代）。然而，NIS+并不是NIS的直接升级，并且管理起来非常困难，从NIS到NIS+的升级过程也并不顺利。NIS+从未获得足够强大的支持，未能成为主流技术，实际上NIS在现实世界的使用和软件支持方面超越了NIS+。制造NIS和NIS+的SUN公司宣布NIS+将在2002年停止使用，虽然它在几年后仍然得到官方支持，但已经逐渐衰退。毫无疑问，NIS+推动了集中式用户管理技术的发展，但它本身从未成为关键技术。它的黄金时代是在1990年代中期，但由于当时涌现了大量的技术，NIS+在来自各方的竞争中逐渐被遗忘——包括来自Novell和Microsoft等新兴厂商的竞争。
- en: To avoid going into a history of the convoluted, and mostly forgotten, world
    of directory services in the 1980s and 1990s, we need only focus on one dominant
    technology that was introduced in 1993 and that is LDAP (the Lightweight Directory
    Access Protocol.) LDAP was a game changer in many ways. For one, it was vendor
    neutral allowing any system to implement it freely. Second it had many advanced
    database, protocol, and security features that allowed it to be used flexibly
    and security while allowing it to scale. Other technologies existed, but by 1997
    when LDAPv3 was released, no other directory service was still making headlines.
    LDAP was seen as the clear winner and future of the LAN-based directory market.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 为了避免深入讨论1980年代和1990年代那些复杂且大多被遗忘的目录服务历史，我们只需关注1993年推出的一项主导技术——LDAP（轻量级目录访问协议）。LDAP在许多方面改变了游戏规则。首先，它是厂商中立的，允许任何系统自由实现。其次，它具备许多先进的数据库、协议和安全特性，既能够灵活使用，又能保证安全，同时具备良好的可扩展性。虽然当时也存在其他技术，但到了1997年LDAPv3发布时，其他目录服务几乎不再成为新闻头条。LDAP被视为局域网目录市场的明确胜者和未来。
- en: LDAP began to replace NIS and NIS+ in the UNIX world, including on Linux-based
    operating systems, during the 1990s although the available implementations were
    complex and not well known yet. LDAP really lept forward when, in 2000, Microsoft
    announced that they were replacing their traditional Security Account Manager
    or SAM system (this is the one famous for having Primary and Backup Domain Controllers
    knows as PDCs and BDCs) with an LDAP implementation called Active Directory. Active
    Directory proved to be such a well-made and easy to manage LDAP implementation
    that it completely dominated the market and itself overshadowed LDAP to the point
    that few people are even aware that Active Directory is in essence just one of
    many LDAP implementations available on the market.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: LDAP在1990年代开始取代UNIX世界中的NIS和NIS+，包括在基于Linux的操作系统中，尽管当时可用的实现复杂且尚未广为人知。LDAP真正取得突破是在2000年，Microsoft宣布他们将用名为Active
    Directory的LDAP实现来取代传统的安全账户管理器（SAM）系统（该系统以有主备域控制器（PDC和BDC）而闻名）。Active Directory被证明是一个制作精良且易于管理的LDAP实现，它完全主导了市场，并且超越了LDAP，甚至到了今天，很少有人意识到Active
    Directory本质上只是市场上众多LDAP实现之一。
- en: Linux-based operating systems can use nearly any LDAP server as a directory
    service source, or even Active Directory itself, which is an LDAP server but additionally
    has advanced requirements like Kerberos, in addition to the LDAP portion of the
    system, that given it expanded functionality and security over vanilla LDAP. Since
    the late 1990s, LDAP (in one form or another) has been the general standard for
    Linux systems that need to authenticate to a LAN-based directory service. Today,
    multiple LDAP server implementations are available that can run on Linux. There
    is even a SAM and Active Directory implementation for Linux to act as a server!
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 基于Linux的操作系统几乎可以使用任何LDAP服务器作为目录服务源，甚至可以使用Active Directory本身，后者是一个LDAP服务器，但除了LDAP系统部分外，还有像Kerberos这样的高级要求，赋予了它比普通LDAP更强的功能和安全性。自1990年代末以来，LDAP（以某种形式）一直是Linux系统需要认证到基于局域网的目录服务时的通用标准。今天，有多种LDAP服务器实现可以在Linux上运行。甚至还有用于Linux的SAM和Active
    Directory实现，可以作为服务器运行！
- en: If using a local directory server is the chosen approach, then some implementation
    of LDAP is almost certainly going to be the only reasonable choice for a Linux-based
    operating system today. If the intent is to integrate with other systems, such
    as Windows or macOS, then an Active Directory flavor of LDAP with its additional
    *special sauce* is almost certainly the necessary option - either the version
    directly from Microsoft or the open-source Samba implementation available to run
    from almost any Linux. If implementing for an all UNIX set of devices then one
    of the more traditional LDAP server products is more likely to be appropriate
    such as OpenLDAP or 389 Directory Server.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 如果选择使用本地目录服务器作为方法，那么在基于Linux的操作系统中，几乎可以肯定实现LDAP的方式是唯一合理的选择。如果目的是与其他系统（如Windows或macOS）进行集成，那么带有额外*特殊功能*的Active
    Directory版本的LDAP几乎可以肯定是必需的选项——无论是直接来自Microsoft的版本，还是可以在几乎任何Linux上运行的开源Samba实现。如果是为了实现全UNIX设备的集成，那么更传统的LDAP服务器产品更可能是合适的选择，例如OpenLDAP或389目录服务器。
- en: LDAP is generally not considered to be viable for exposure to public networks
    (like the Internet) and is generally thought of as being LAN-centric, meaning
    that it relies at least partially on the network firewall to provide a safe operating
    space in which it can do its job. Exposing LDAP (even assuming SSL/TLS support
    via the upgrades LDAPS protocol) carries a bit of risk. A few companies still
    do this, and it can work, but it requires a lot of planning and an understanding
    as to the scope of exposure. Many companies accidentally expose LDAP components
    through a third-party proxy creating an exposure unintentionally (and highlighting
    the risks of the walled garden theory of LAN-centric security approaches.)
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 一般认为LDAP不适合暴露给公共网络（如互联网），通常被认为是局域网中心化的，这意味着它至少部分依赖于网络防火墙来提供一个安全的操作空间，以便它能够执行其工作。暴露LDAP（即使假设通过升级版LDAPS协议支持SSL/TLS）也有一定的风险。一些公司仍然这样做，虽然它可以工作，但需要大量的规划和对暴露范围的理解。许多公司通过第三方代理不小心暴露了LDAP组件，导致了无意的暴露（也突显了局域网中心化安全方法的围墙花园理论的风险）。
- en: The famous RDP exposure risk
  id: totrans-41
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 著名的RDP暴露风险
- en: In Linux or UNIX circles, the RDP exposure risk example is not as widely known
    as in the Windows world, where remote access to systems by way of the Microsoft
    **Remote Desktop Protocol** (**RDP**) is a very common thing. However, the concept
    and problems often associated with RDP, such as vulnerability to brute force attacks
    and high visibility to potential attackers, are not actually related to Windows
    but to architectural design.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 在Linux或UNIX圈子里，RDP暴露风险的例子并不像在Windows世界中那样广为人知，因为通过微软的**远程桌面协议**（**RDP**）远程访问系统是非常常见的。然而，RDP通常相关的概念和问题，如容易受到暴力破解攻击和对潜在攻击者的高可见性，实际上与Windows本身无关，而是与架构设计有关。
- en: The issue is that exposing RDP on a publicly accessible IP address is considered
    to be very high risk. Yet the security on the RDP protocol is similar to that
    on SSH which is generally considered to be safe to exposure (within reason.) Why
    would two protocols of similar use and security result in two such wildly different
    security postures?
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 问题在于，将RDP暴露在一个公开可访问的IP地址上被认为是非常高风险的。然而，RDP协议的安全性与SSH相似，SSH通常被认为是可以公开暴露的（在合理范围内）。为什么这两种用途和安全性相似的协议会导致两种如此不同的安全态势？
- en: The secret lies either with the convention in the Windows world to use Active
    Directory (an LDAP implementation) ubiquitously or in the fact that Microsoft's
    standard multi-user RDP environment, **RDS** (for **Remote Desktop Services**),
    requires Active Directory. Active Directory essentially becomes a foregone conclusion
    when RDP is mentioned, but when using SSH it is assumed that Active Directory
    or some form of LDAP will not be used (at least as the external authentication
    method.)
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 秘密在于，Windows世界中的一个惯例是普遍使用Active Directory（一个LDAP实现），或者是微软标准的多用户RDP环境**RDS**（**远程桌面服务**）要求Active
    Directory。提到RDP时，Active Directory几乎成为了一个不言而喻的结论，但使用SSH时，通常假设不会使用Active Directory或某种形式的LDAP（至少不是作为外部认证方法）。
- en: Why does the underlying security method make a different when Active Directory
    and LDAP are highly secure on their own, and RDP is a very secure protocol? The
    answer is in that RDP forcibly exposes access to Active Directory in a manner
    very different to how it would be used on an internal LAN.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么底层的安全方法会产生不同的效果，而Active Directory和LDAP本身都是高度安全的，RDP也是一个非常安全的协议？答案在于，RDP以一种与其在内部局域网中的使用方式截然不同的方式强制暴露了对Active
    Directory的访问。
- en: On the LAN we basically have an automatic whitelist that consists of the devices
    on our LAN. In many environments this will be additionally limited by VLANs that
    keep unnecessary devices (phones, IoT, and others) away from our end user devices.
    In larger environments network access controls may further limit potential exposure
    leaving us with a very protected environment in which our Active Directory can
    operate. Further, Active Directory itself generally protects itself by limiting
    attempts to log in to any given account locking the account for some period of
    time before it allows further attempts. Attacking Active Directory remotely on
    a LAN is generally quite difficult to do effectively.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 在局域网内，我们基本上有一个自动白名单，它包含了我们局域网中的设备。在许多环境中，这个白名单会被VLAN进一步限制，将不必要的设备（手机、物联网设备等）隔离在终端用户设备之外。在更大的环境中，网络访问控制可能进一步限制潜在的暴露，从而为我们的Active
    Directory提供一个非常安全的环境。此外，Active Directory本身通常通过限制对任何给定账户的登录尝试来保护自己，在允许进一步尝试之前，会将账户锁定一段时间。远程攻击局域网中的Active
    Directory通常是相当困难的。
- en: When we add RDP and open it to the Internet at large, all of these controls
    drop away, completely. Of course, there are ways to limit this through IP whitelisting,
    VPN encapsulation, or other technique, but a stock deployment is going to expose
    our system broadly (if it does not do so, the purpose of exposing it is generally
    lost.) What is often missed is that the *lock after some number of failed attempts*
    mechanism that is so critical to securing Active Directory frequently offers a
    means of enacting denial-of-service (DoS) attacks on our users (that is, making
    it easy for an external user to block our users from logging in). In order to
    mitigate this attack risk, we have to disable this mechanism for RDP, in turn
    allowing essentially unlimited attacks on our accounts from the public space!
    Neither option is truly viable, and therefore, RDP becomes highly risky when used
    in a conventional way, even though both RDP and Active Directory are quite secure
    in their own right.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们将RDP开放到互联网时，所有这些控制都会完全消失。当然，可以通过IP白名单、VPN封装或其他技术来限制这一点，但标准部署将会大范围地暴露我们的系统（如果没有这样做，暴露它的目的通常就会丧失）。通常被忽视的是，*在一定数量的失败尝试后锁定*机制，这对于确保Active
    Directory的安全至关重要，但它也为对我们的用户发动拒绝服务（DoS）攻击提供了手段（也就是说，外部用户可以轻易地阻止我们的用户登录）。为了减轻这种攻击风险，我们必须禁用RDP的此机制，从而允许来自公共空间的无限攻击！两种选择都不完全可行，因此，尽管RDP和Active
    Directory在各自的领域内都相当安全，但在传统方式下使用RDP仍然具有很高的风险。
- en: SSH and other mechanisms are most often used decoupled from central user account
    systems such as LDAP and Active Directory, allowing them to maintain a completely
    separate security mechanism and posture when compared to other user authentication
    methods. RDP can be used this way too, of course, but it is often assumed to have
    the functionality of central user account access because of Active Directory,
    making it difficult to treat it like a decoupled service because many in our organization
    many expect that because it is RDP that they will have immediate integration with
    Active Directory.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: SSH和其他机制通常与中央用户账户系统（如LDAP和Active Directory）解耦使用，使它们能够保持一个完全独立的安全机制和姿态，相较于其他用户认证方法。RDP当然也可以这样使用，但由于Active
    Directory的存在，通常假设它具有中央用户账户访问功能，这使得将其视为解耦服务变得困难，因为我们组织中的许多人会期望它与Active Directory有即时的集成。
- en: Today we are living in the post-LAN and generally post-LDAP world. Even LDAP's
    single biggest proponent, Microsoft, has moved away from it when possible and
    is investing probably more than any other company in LDAP alternatives, primarily,
    their own Azure AD service which, confusingly, keeps Active Directory in its name
    even though it is a completely unrelated mechanism to Active Directory (but can
    be tied to it to extend it.)
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 今天，我们生活在一个后LAN和通常是后LDAP的世界里。即使是LDAP的最大支持者微软，也在尽可能避免使用它，并且可能比其他任何公司都在投资LDAP替代方案，主要是他们自己的Azure
    AD服务，这个服务令人困惑地保留了“Active Directory”这个名字，尽管它与Active Directory完全不相关（但可以与之连接以扩展它）。
- en: The biggest changes to industry accepted authentication systems is that most
    systems are hosted products rather than software that businesses are expected
    to deploy and maintain on their own; and most modern systems are Internet based
    allowing users to be located almost anywhere and, as long as they have an Internet
    connection, be able to connect to the authentication mechanisms.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 对行业公认的认证系统的最大变化是，大多数系统是托管产品，而不是企业需要自行部署和维护的软件；而且大多数现代系统都是基于互联网的，允许用户几乎位于任何地方，只要他们有互联网连接，就能连接到认证机制。
- en: These new mechanisms are coming in a continuously increasing variety of flavors
    from many different vendors and types of vendors. In the completely non-server,
    desktop only world of Chromebooks, Google themselves have an exclusive authentication
    mechanism and represents a very significant portion of the Linux-based end-user
    market today.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 这些新的机制来自许多不同的供应商和供应商类型，以不断增加的多样化形式出现。在完全不涉及服务器、仅限桌面的Chromebook世界中，Google自身拥有一个独特的认证机制，并且今天代表了基于Linux的最终用户市场的一个非常重要的部分。
- en: Are operating system logins relevant in the modern world?
  id: totrans-52
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 操作系统登录在现代世界中还有意义吗？
- en: This being a book on Linux administration, we are understandably talking about
    users at the level of the operating system, and we have to (as is best practice)
    question whether such a concept even matters today (or historically, for that
    matter) or if logging into operating systems may soon be a thing of the past entirely.
    Honestly, it is not an easy question to answer. The knee-jerk reaction is to jump
    to the conclusion that operating system users are incredibly relevant and underpin
    all security. But are they really?
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 作为一本关于Linux管理的书，我们无可避免地要讨论操作系统级别的用户管理，并且我们必须（按照最佳实践）质疑这个概念今天是否仍然重要（或从历史角度来看是否重要），或者登录操作系统是否很快就会成为过去式。说实话，这个问题并不容易回答。直觉的反应是得出结论，操作系统用户是极其相关的，并且是所有安全的基础。但它们真的是吗？
- en: 'To start, I am going to lead with saying that: Yes, generally operating system
    logins and user management is still important today and always has been.'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我想先说：是的，通常来说，操作系统的登录和用户管理今天仍然很重要，而且一直以来都是如此。
- en: How we think of user logins has changed immensely, though. The user landscape
    today is very different from what it was just one to two decades ago. Let's start
    with a little history.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，我们对用户登录的思考方式发生了巨大的变化。今天的用户环境与一到两十年前大不相同。让我们从一点历史开始。
- en: During the pre-1990 era, the *archaic* computing world, very few systems used
    user identification mechanisms, at least at the operating system level. Systems
    that did, like UNIX and VMS, were special cases, big enterprise systems that were
    considered advanced and impressive. What most users would interact with, even
    using systems like Mac, Amiga, or MS-DOS, were single user, non-authenticated
    systems. As late as 2001, Microsoft's Windows **Millenium Edition** (**ME**) was
    released without true multi-user support (as it was still just a graphical shell
    layered on MS-DOS). In general, the idea that operating systems needed to manage
    multiple users was a foreign one.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 在1990年之前的时代，即*古老的*计算机世界，极少有系统使用用户身份验证机制，至少在操作系统级别没有。像UNIX和VMS这样的系统是特殊案例，是被视为先进和令人印象深刻的大型企业系统。大多数用户接触到的，甚至是使用像Mac、Amiga或MS-DOS这样的系统，都是单用户、没有身份验证的系统。直到2001年，微软的Windows
    **Millenium Edition**（**ME**）发布时仍不支持真正的多用户（因为它仍然只是MS-DOS上的图形化外壳）。总的来说，操作系统需要管理多个用户的想法曾是一个陌生的概念。
- en: In the 1990s, the shift to user security and access control as networking became
    generally accessible, the Internet began to come to fruition, and users needed
    more advanced functionality was significant. If anything, the 1990s were marked
    by being the era of user management (which we mentioned earlier.) Rather suddenly
    everyone was concerned with how we would handle many users sharing the same devices
    and how we would make the user experience portable across multiple devices. System
    administration was essentially flipped on its ear.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 在1990年代，随着网络的普及、互联网逐渐成熟，用户对更高级功能的需求显著增加，用户安全性和访问控制的转变非常重要。如果说1990年代有什么特征的话，那就是用户管理的时代（我们之前提到过）。突然间，每个人都开始关心如何处理多个用户共享同一设备，如何在多个设备之间使用户体验变得可移植。系统管理几乎被完全颠覆。
- en: By the 2000s, the operating system level user experience expectations were well
    entrenched and user management moved from competitive advantage to commodity functionality.
    The last remaining operating systems of any note that did not support native multi-user
    functionality faded away and even casual end user products intended for entertainment
    user started to encourage user management and security.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 到了2000年代，操作系统级别的用户体验期望已经深深扎根，用户管理从竞争优势转变为商品化功能。最后那些没有支持原生多用户功能的操作系统逐渐消失，即便是面向娱乐用户的普通终端产品也开始鼓励用户管理和安全性。
- en: When smart phones first entered the market, they were a throwback to the user-less
    systems of the 1980s. The holder of the device was assumed to be its universal
    and unnamed singular user. Even cell phones have moved to at least being a user
    and security centered device, even if they still focus on a single user, they
    do so with access controls and user identity in mind.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 当智能手机首次进入市场时，它们是对1980年代无用户系统的回顾。设备的持有者被假定为其普遍且未命名的唯一用户。即使是手机也已经至少转变为一个以用户和安全为中心的设备，即使它们仍然聚焦于单个用户，但也会考虑访问控制和用户身份。
- en: On the server side, user management has certainly lost its luster over the past
    decades. At its peak in the 1990s, Linux and its UNIX cousin systems were all
    the rage for direct end user logins and user management on the server was a significant
    portion of a system administrators' day. That trend fell away, and the idea that
    end users would need accounts or logins to a server at the operating system level
    now feels outdated, at best. Exceptions will always apply, but they are few and
    far between and becoming increasingly rare.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 在服务器端，用户管理在过去几十年里确实失去了光彩。在1990年代的巅峰时期，Linux及其UNIX亲戚系统曾风靡一时，直接的终端用户登录和服务器上的用户管理占据了系统管理员大部分的工作时间。这个趋势逐渐消退，如今，终端用户需要在操作系统级别上访问服务器的账户或登录的想法，最多也只是显得过时。例外情况总是存在，但它们少之又少，并且越来越罕见。
- en: Even at its peak, the necessity that all administrators log in with individual
    user accounts was never universally accepted. It may never have been exactly normal
    for all administrators to share single accounts, but it was never exactly rare,
    either. Shared root (the default administration user account) account access has
    always been a common practice that few want to admit to having witnessed and exists
    commonly in Linux, Windows, and likely all other environments. The practice was
    (and surely still is) so widespread that techniques and tools for managing user
    access to the single user account through external mechanisms are even somewhat
    popular (such as logging into a third-party control console that grants access
    to root accounts on multiple servers as needed!)
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 即便在其巅峰时期，所有管理员必须使用单独的用户账户登录这一必要性也从未得到普遍接受。或许所有管理员共享单一账户从未真正成为常态，但也从未真正罕见过。共享root账户（默认的管理员用户账户）访问一直是一个普遍的做法，尽管很少有人愿意承认自己见过，它在Linux、Windows，甚至可能在所有其他环境中都很常见。这种做法（并且肯定仍然存在）如此广泛，以至于通过外部机制管理用户访问单一账户的技术和工具甚至有点流行（比如登录到一个第三方控制台，按需访问多个服务器上的root账户！）
- en: As we are a book on best practices, I am going to take moment to point out that
    in our role as system administrators it is absolutely a best practice to maintain
    user identity and access control on our servers and that shared accounts are really
    never a good idea even when they are well managed and secured. The necessary effort
    to maintain more secure and auditable systems is simply not that great that we
    should be working to avoid it. That said, shared account access is not necessarily
    as risk as it sounds as there remain the potential for audit controls and access
    controls even when doing so and while I truly doubt that there is ever an actual
    justifiable use case for doing so, it is certainly possible to make shared access
    *secure enough* to function effectively.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们这本书是关于最佳实践的，我想花一点时间指出，作为系统管理员，维护用户身份和访问控制在我们的服务器上绝对是最佳实践，而且共享账户即使管理得当并且安全，通常也不是一个好主意。为了维持更安全和可审计的系统所需的努力并不大，我们完全没有理由去避免它。尽管如此，共享账户的访问并不一定像听起来那么危险，因为即使在这种情况下，仍然存在审计控制和访问控制的潜力，而虽然我真的怀疑是否存在实际正当的使用案例来支持这么做，但确实可以让共享访问变得*足够安全*，以便有效运作。
- en: More importantly, for servers (and the administrative functions of end user
    workstations as well) modern design techniques using state machines, infrastructure
    as code, application encapsulation such as application containers, **MDM** (**mobile
    device management**) and even **RMM** (**remote monitoring and management**) tools
    may entirely eliminate the need for logins at all making the entire discussion
    of user management moot. If we never log in, if we never create a user, we need
    not consider the possibility of user account access security, whether that's remote
    or even local.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 更重要的是，对于服务器（以及终端用户工作站的管理功能），现代设计技术如状态机、基础设施即代码、应用封装（如应用容器）、**MDM**（**移动设备管理**）甚至**RMM**（**远程监控和管理**）工具，可能完全消除了登录的需求，从而使整个用户管理讨论变得不再重要。如果我们从不登录，如果我们从不创建用户，那么我们就不需要考虑用户账户访问安全的问题，无论是远程的还是本地的。
- en: So, it is worth considering that from a server perspective, the need for users
    may have been nothing more than a passing fad or fallback crutch for shops that
    are not able to maintain the most modern of techniques. These are administrative
    users, of course, but that has long been the only users expected to exist on a
    server at all.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，值得考虑的是，从服务器的角度来看，用户的需求可能不过是一个过时的时尚，或是那些无法保持最新技术的商店所依赖的备用支撑。这些当然是管理用户，但这长期以来一直是服务器上唯一预期存在的用户。
- en: On end user devices, the concepts of users have begun to change dramatically
    as well, but for entirely different reasons. Traditionally work on end user devices
    was focused on locally installed applications that themselves have no user controls
    and simply run under the security controls of the environment provided by the
    operating system. This could be any kind of application from word process, image
    editor, or video game. The environment was primarily defined by the accessible
    local storage locations. For many users, especially home users, this has almost
    entirely changed.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 在终端用户设备上，用户的概念也开始发生剧烈变化，但原因完全不同。传统上，终端用户设备上的工作主要集中在本地安装的应用程序上，这些应用程序本身没有用户控制，而只是运行在操作系统提供的安全控制环境下。这可以是任何类型的应用程序，从文字处理、图像编辑到视频游戏。这个环境主要由可访问的本地存储位置来定义。对许多用户，尤其是家庭用户而言，这几乎已经完全改变。
- en: Today most applications are web applications, applications that run in the browser
    rather than being installed at all. Users might log into the application, but
    this is almost always separate from any operating system login. Even locally installed
    applications are starting to connect over the Internet to authenticate to a service
    increasingly.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 如今，大多数应用程序是Web应用程序，即在浏览器中运行而不是完全安装的应用程序。用户可能会登录到应用程序，但这几乎总是与任何操作系统登录分开。即使是本地安装的应用程序，也开始通过互联网连接进行身份验证，越来越多地依赖于服务。
- en: As this shift occurs, the concept of the operating system user being the primary
    component used to define the context of security access is fading rapidly, and
    the idea that users need to exist at the application level instead has already
    become the norm. As this happens, we have to start to consider the functionality
    of the operating system user accounts not to be a granular access control mechanism
    or the end all of user management but rather little more than a security step
    to attempt to guarantee a safe, protected environment from which we can launch
    our web or networked application and sign in at the application layer where our
    users and access controls are far more relevant. Moving user access controls to
    the application layer is critical as this is where the data intelligence resides,
    and control can be made at a granular level rather than granting access at the
    level of the entire application.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 随着这一变化的发生，操作系统用户作为定义安全访问上下文的主要组成部分的概念正在迅速消退，用户需要在应用程序级别存在的想法已经成为常态。随着这一过程的推进，我们必须开始考虑操作系统用户账户的功能不再是精细的访问控制机制或用户管理的终极方式，而只是为了尝试确保一个安全、受保护的环境，从中我们可以启动我们的Web或网络应用程序，并在应用程序层面进行登录，在那里用户和访问控制才是更加相关的。将用户访问控制转移到应用程序层面至关重要，因为数据智能就存在于此，在这一层面可以进行更细粒度的控制，而不是在整个应用程序层面授予访问权限。
- en: As the operating system starts to lose its traditional role in user management,
    the benefits of strong user management and control systems begin to erode. It
    is far more than just the shift of user access control up the stack from operating
    systems to applications as the industry and software matures that is causing this.
    Other factors are at play. It used to be that computers were expected to user
    printers heavily, something that has broadly stopped being true. Printers are
    now an afterthought, if they even exist, rather than being a primary functionality
    of computers. Likewise, modern applications do not use operating system managed
    storage in the same ways and the need to strictly administer local storage and
    mapping remote storage resources has fallen away.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 随着操作系统在用户管理中的传统角色逐渐消失，强大的用户管理和控制系统的优势也开始削弱。这不仅仅是因为行业和软件成熟导致了用户访问控制从操作系统上移到应用程序中的变化。还有其他因素在起作用。曾几何时，计算机被期望大量使用打印机，但这种情况已经不再普遍。打印机现在只是一个事后考虑的设备，如果它们存在的话，而不再是计算机的主要功能。同样，现代应用程序也不像过去那样使用操作系统管理的存储，严格管理本地存储和映射远程存储资源的需求已经减少。
- en: Even just ten years ago user management systems, Active Directory as a prime
    example, were used first and foremost to coordinate printing and mapped drive
    resources for end users. Today, between application modernization and workforce
    mobility and computing ubiquity, both of these things have become legacy functions.
    A laptop user working from home might have absolutely zero need for either mapped
    drives or printers, and in order to allow mobile users to function in this way,
    in-office workers have had to adapt to this as well. The trend in access control
    mechanisms is moving away from the traditional uses of operating-system-level
    users.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 即使是在十年前，用户管理系统，比如Active Directory，首先用于协调打印和映射驱动器资源给终端用户。今天，随着应用现代化、工作力量的流动性和计算的普及，这些功能已经成为遗留功能。在家工作的笔记本用户可能完全不需要映射驱动器或打印机，而为了让移动用户能够以这种方式工作，办公室内的工作人员也不得不做出相应的适应。访问控制机制的趋势正在远离传统的操作系统级用户使用方式。
- en: In summary, users still matter, but they do not maintain the relevance that
    they had in the past and the future looks like one where that value will continue
    to diminish.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 总结来说，用户仍然很重要，但他们的相关性已经不像过去那样强烈，未来看起来是一个用户价值将继续减弱的趋势。
- en: Knowing what remote access methods are going to be most appropriate for you
    requires more than just an understanding of how these systems work and how their
    implementations play into your environment is just the first piece of the puzzle
    in determining what mechanism should be chosen for your organization. Learning
    what products are currently on the market, their current features, limitations,
    pricing, and other business factors are necessary. User management is rapidly
    becoming a market where it is more about knowing the current offerings available
    and much less of something that we will implement ourselves.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 知道哪些远程访问方法最适合你，需要的不仅仅是理解这些系统是如何工作的，了解它们的实现如何适应你的环境只是确定应该为你的组织选择哪种机制的第一步。了解市场上目前有哪些产品，它们的当前功能、局限性、定价和其他商业因素都是必要的。用户管理迅速发展成为一个市场，在这个市场中，我们更多的是需要了解现有的产品供应，而不再是自己来实施。
- en: In the next section, we are going to move past authenticating our users and
    now dig into how we can provide these users with remote access to the systems
    that they need.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的章节中，我们将超越用户身份验证，深入探讨如何为这些用户提供远程访问他们所需系统的方式。
- en: Remote access approaches
  id: totrans-73
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 远程访问方法
- en: Assuming we are not using a *access-less* approach built off of state machine
    technology, we have a few different paths that we can popularly use to gain access
    to our Linux systems. In most cases with Linux based operating systems we are
    going to be discussing how system administrators, like you and me, are able to
    log in and use the operating system interactively, but any typical method that
    we are going to use to do this is going to be an option for end users as well.
    The needs of end users is generally very different from that of system administrators,
    but the tools that we can use are going to generally overlap.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们没有采用基于状态机技术的*无访问*方法，我们有几种常见的途径可以用来访问我们的Linux系统。在大多数基于Linux的操作系统中，我们将讨论系统管理员，像你我一样，如何能够登录并交互使用操作系统，但我们所使用的任何典型方法，最终也将成为终端用户的选择。终端用户的需求通常与系统管理员的需求截然不同，但我们能使用的工具通常会有所重叠。
- en: For us, in the system administration role, access is most often defined by needing
    to be very quick to set up, quite temporary in its use, with the focus critically
    being on ensuring that the system is highly accessible and command line driven.
    For end users, we will expect the opposite. Administrators often have to log into
    many different operating systems, maybe one after another, maybe many all at the
    same time. A lengthy process to access them could significantly hinder our ability
    to be useful.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们这些系统管理员来说，访问通常需要非常快速地设置，使用时也非常临时，重点是确保系统具有高度的可访问性并以命令行驱动。对于终端用户，我们则会期待相反的需求。管理员通常需要登录到多个不同的操作系统，可能是一个接一个地登录，也可能是同时登录多个系统。访问过程过长可能会显著妨碍我们发挥作用。
- en: Traditionally end users will log into only a single system and remain attached
    to it for the duration of their work period, typically a workday or something
    similar. Taking more time to log in that one time, but having a more robust end
    user experience, is their priority. Because the needs are so different, remote
    access techniques may be separate. There is little need to feel compelled to merge
    them.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 传统上，终端用户通常只会登录到单一系统，并在整个工作期间（通常是一个工作日或类似时间段）保持连接。虽然他们可能需要花更多时间进行一次登录，但优先考虑的是提供更稳定的终端用户体验。由于需求差异，远程访问技术可能是分开的，实际上没有必要强求将它们合并。
- en: There are two main types of remote access. One is direct, meaning that we expose
    ports and have some protocol with as SSH, RDP, or RFB (VNC) that allows us to
    connect from some software client to our systems. This is the best-known type
    of technology and is the most straightforward to manage. It requires nothing complex
    and is well understood. In this approach we have a traditional service on the
    virtual machine in question (or potentially on the hypervisor, but the result
    is roughly the same) and an external client *reaches in* to access the system.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 远程访问有两种主要类型。一种是直接连接，即我们暴露端口并使用像SSH、RDP或RFB（VNC）这样的协议，通过软件客户端连接到我们的系统。这是最为人熟知的技术类型，也是最直接的管理方式。它不需要复杂的配置，且易于理解。在这种方法中，我们在目标虚拟机上（或者可能是在虚拟化管理程序上，但结果大致相同）运行传统服务，外部客户端*访问*该系统。
- en: The other access methodology is indirect access where an access server is used
    to manage access for both the operating system to be access and for the client
    attempting to access it. This method requires a server that is hosted publicly
    (often provided as a service but can be self-hosted as well) and both the end
    points connect to it as clients so that nothing except for the access server need
    to be exposed outwardly.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种访问方法是间接访问，其中使用访问服务器来管理操作系统和客户端的访问。该方法需要一个公开托管的服务器（通常是以服务形式提供，但也可以自托管），终端用户和客户端都作为客户端连接到它，从而确保只有访问服务器需要对外暴露。
- en: Advantages of both solution types are pretty clear. Direct connections are simpler
    and have less to go wrong. Indirect connections require more infrastructure but
    reduce potential points of exposure, consolidate connections, and hide the presence
    of the networks making it harder to discover and attack a network based on its
    remote access publications.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 两种解决方案的优点非常明确。直接连接较为简单，出错的可能性较低。间接连接则需要更多的基础设施，但能减少潜在的暴露点，整合连接，并隐藏网络的存在，使得基于远程访问发布的网络更难被发现和攻击。
- en: For many reasons, there is a trend towards direct connection technologies, such
    as RDP and RFB (VNC), for regular end users and indirect connection technologies,
    such as MeshCentral, ConnectWise, and LogMeIn, for system administrators. For
    end users, the direct connection technologies tend to provide the most robust
    experience to replicate the feeling of working directly on the hardware as if
    it was sitting in front of you. For system administrators, the increased security
    and consolidation of access to systems potentially across many different physical
    locations is highly beneficial.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 出于多种原因，普通终端用户倾向于使用直接连接技术，如RDP和RFB（VNC），而系统管理员则倾向于使用间接连接技术，如MeshCentral、ConnectWise和LogMeIn。对于终端用户而言，直接连接技术通常能提供最稳定的体验，仿佛他们直接操作硬件，就像它就在面前一样。对于系统管理员而言，增强的安全性和对跨多个物理位置系统的访问整合是非常有益的。
- en: Notice, however, in all cases we keep saying *tends*. There are no hard and
    fast rules here, only strong tendencies. Because we are dealing with Linux, we
    have other considerations, however. For example, RDP tends to be less easy to
    manage than on Windows, while indirect access methods might be easier but not
    as well understood. Also, our user base may have different inherent expectations
    – for example, where Windows users might expect Windows-native tooling, Linux-based
    operating system users might be more open to less familiar access options.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，需要注意的是，我们在所有情况下都在说*趋向*。这里没有硬性规则，只有强烈的趋势。然而，由于我们正在处理Linux，我们还需要考虑其他因素。例如，RDP在Linux上的管理通常比在Windows上更为复杂，而间接访问方法可能更容易实施，但理解程度较低。此外，我们的用户群体可能有不同的固有期望——例如，Windows用户可能期望使用Windows原生工具，而基于Linux的操作系统用户可能对不太熟悉的访问选项持更加开放的态度。
- en: Like so many things in IT, understanding base level technologies is only the
    first step. In our next section we will discuss ways that we can make SSH, a direct
    connection technology, more flexible and robust and in some ways of looking at
    it we will be mimicking an indirect connection using direct ones. The differences
    between them are not so large.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 和许多 IT 领域的事情一样，理解基础技术只是第一步。在接下来的部分中，我们将讨论如何使 SSH（一种直接连接技术）变得更加灵活和强大，并从某些角度来看，我们将通过直接连接模拟间接连接。它们之间的差异并不大。
- en: Even a rule of thumb is difficult in this situation and likely much discussion
    of remote access will depend upon many factors such as how that access will be
    used, will the infrastructure be shared with end users, what security needs may
    exist, do other access considerations exist such as VPNs, and is there value to
    creating a unified connection process that is shared with other technologies or
    platforms?
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 即便是经验法则在这种情况下也很难适用，远程访问的讨论通常会依赖于许多因素，例如如何使用这种访问，这些基础设施是否会与最终用户共享，可能存在的安全需求，是否还有其他访问方式如
    VPN，是否有价值创建一个与其他技术或平台共享的统一连接过程？
- en: And then we have to consider the possibility of having multiple access methods.
    It is not uncommon to use more than one to ensure availability even when one has
    failed. One may be the convenient, yet fragile, access method while the backup
    is heavily secured and cumbersome to use but serves as a critical backup should
    all else fail.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们还需要考虑使用多种访问方式的可能性。为了确保即使一种方法失败，仍然能保持可用，使用不止一种方法是很常见的。某一种可能是方便但脆弱的访问方式，而备份方法则可能是高度安全、操作繁琐，但作为关键备份，能在其他方式都失败时派上用场。
- en: How do I approach remote access
  id: totrans-85
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 我如何处理远程访问
- en: In a topic so devoid of strong guidance, I feel taking a moment to present my
    own typical access choices is valuable. I do this not to suggest that my approach
    is ideal, but to give some insight into a real-world decision-making process.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 在这样一个缺乏明确指导的主题下，我觉得花时间分享我自己常用的访问选择是有价值的。我这么做并不是要建议我的方法是理想的，而是希望为大家提供一些现实世界决策过程的洞察。
- en: Most of the time when deploying Linux servers where I am overseeing their system
    administration and we need to have remote access to a running system instead of
    being managed completely by way of state machines or infrastructure as code, we
    opt for a two-prong approach with one direct and one indirect access method.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 在我负责管理 Linux 服务器的系统行政工作时，我们通常需要远程访问正在运行的系统，而不是完全依赖于状态机或基础设施即代码的方式，通常会选择一种双重方法，一个是直接访问，另一个是间接访问。
- en: For indirect access we use MeshCentral which, itself, is open-source software
    and runs on a Linux based operating system that we host ourselves. This allows
    us extensive flexibility and cost savings compared to most solutions and because
    we are able to run it on the same operating system that we deploy internally and
    for customers we are able to leverage processes, tools, and skills that we are
    already using other places in order to maximize our efficiency. With MeshCentral,
    as with many indirect remote access solutions, we have remote terminal access,
    remote graphical desktop access if a GUI is installed on the server, and many
    tools for monitoring, file moving, and remote command execution.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 对于间接访问，我们使用 MeshCentral，它本身是开源软件，运行在我们自己托管的 Linux 操作系统上。这使我们在与大多数解决方案相比，具有广泛的灵活性和成本节省，并且因为我们能够在与内部和客户部署相同的操作系统上运行它，我们能够利用其他地方已在使用的流程、工具和技能，从而最大化效率。像许多间接远程访问解决方案一样，使用
    MeshCentral，我们可以进行远程终端访问、如果服务器上安装了 GUI，还可以进行远程图形桌面访问，并且有许多工具用于监控、文件传输和远程命令执行。
- en: With this indirect access the system administrators have nearly instant access
    to all of the servers that we maintain, across highly disparate technology stacks
    and physical locations. Some servers are isolated on LANs without any port forwarding
    available, some have public IPs, some have graphical desktops, most are command
    line only. No matter what they location, use case, or disposition MeshCentral
    gives us access to do what is needed to manage the systems.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这种间接访问，系统管理员几乎可以立即访问我们所维护的所有服务器，跨越高度不同的技术栈和物理位置。一些服务器被隔离在局域网内，无法进行端口转发，一些有公共
    IP，一些有图形桌面，大多数只有命令行接口。不管它们的地点、使用场景或配置如何，MeshCentral 都能为我们提供所需的访问权限，帮助我们管理系统。
- en: For situations mostly involving emergency access we also maintain direct SSH
    access to nearly all systems. This is important as the ability to reconfigure,
    patch, or restart a system where indirect access methods have failed is often
    critical. This access would almost always be limited to access only from a local
    LAN on which the workload directly sits and potentially even limited further within
    that network scope making SSH only available from select workstations or another
    server designated for the purpose of highly secure remote access. In some cases,
    the SSH service may not even be kept running by default and only turned on by
    way of a state machine setting being changed; or it may be changed manually via
    a form of out of band management. `SSH` may also be useful for some forms of automation.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 对于主要涉及紧急访问的情况，我们还保持对几乎所有系统的直接 SSH 访问。这一点非常重要，因为当间接访问方式失败时，重新配置、打补丁或重启系统的能力通常至关重要。这种访问几乎总是会限制为仅从直接托管工作负载的本地
    LAN 上进行访问，甚至可能在该网络范围内进一步限制，使得 SSH 只能从某些特定工作站或其他指定为高度安全远程访问用途的服务器访问。在某些情况下，SSH
    服务可能甚至默认不会运行，只有通过更改状态机设置或通过某种带外管理方式手动开启；或者它也可能通过某种自动化方式启用。`SSH` 对某些自动化任务也可能非常有用。
- en: Having two very different forms of access, with deep security controls in place,
    provides the right balance of accessibility, protection, and security for us.
    You have to be aware that each additional method of access means another avenue
    of attack by malicious actors, as well, so layering on access methods that are
    not necessary is generally not a good option. You want to ensure reliable access
    without putting systems at risk.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 拥有两种截然不同的访问方式，并且配备深度安全控制，为我们提供了访问性、保护性和安全性的最佳平衡。你必须意识到，每增加一种访问方式，意味着恶意攻击者的攻击途径也会增多，因此增加不必要的访问方式通常不是一个好选择。你需要确保可靠的访问同时又不危及系统安全。
- en: Something often overlooked in these types of discussions is that there are some
    direct remote access tools that work in ways we often do not anticipate such as
    web based direct access tools. These tools would include such products as **Cockpit**
    or **WebMin** which provide a web-based interface to our systems. These tools
    may give access to configure our systems via a web interface and may even allow
    for interactive console access through the web interface allowing us to publish
    and secure remote access in an entirely different way.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 在这类讨论中常常被忽视的一点是，有些直接远程访问工具的工作方式往往是我们没有预料到的，比如基于网页的直接访问工具。这些工具包括 **Cockpit**
    或 **WebMin** 等产品，它们为我们的系统提供基于网页的界面。这些工具可能允许通过网页界面配置系统，甚至可能允许通过网页界面进行交互式控制台访问，从而使我们能够以完全不同的方式发布和确保远程访问。
- en: In the Linux world, by far the most common and assumed method of accessing a
    computer across the room or on the other side of the world is the ubiquitous SSH
    protocol. Next, we will look at ways to make SSH even more powerful than it is
    out of the box.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Linux 世界里，跨越房间或跨越全球访问计算机最常见且假定的方法就是广泛使用的 SSH 协议。接下来，我们将探讨一些方法，让 SSH 比原生更强大。
- en: SSH, key management, and jump boxes
  id: totrans-94
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: SSH、密钥管理和跳板机
- en: Using SSH for remote management of Linux based operating systems is so ubiquitous
    that it deserves special consideration. SSH on its own is efficient and very secure,
    but it is well known and generally exposes such extreme functionality in our systems
    that it is often the target a focused attacks. We cannot be complacent in the
    use of SSH, especially if exposed to the Internet, as the risks are simply too
    high.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 SSH 进行 Linux 操作系统的远程管理是如此普遍，以至于它值得特别关注。单独使用 SSH 是高效且非常安全的，但它是一个广为人知的工具，通常会暴露出如此强大的功能，因此常常成为有针对性的攻击目标。我们在使用
    SSH 时不能掉以轻心，尤其是当它暴露在互联网上时，风险实在是太高了。
- en: When using SSH we have almost a laundry list of ways that it can be secured.
    We will touch on several of these and how they work together to make SSH extremely
    difficult to compromise. SSH on Linux is provided via OpenSSH which is mature
    and battle tested and receives more scrutiny than almost any software package
    made. SSH starts as an already very harded package from most perspectives.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 SSH 时，我们几乎有一长串的方式可以保障其安全。我们将探讨其中几种方式，以及它们如何协同工作，使得 SSH 极其难以被攻破。在 Linux 上，SSH
    通过 OpenSSH 提供，它是一个成熟且经过实战检验的工具，接受的审查比几乎所有软件包都要严格。大多数角度来看，SSH 从一开始就是一个非常坚固的软件包。
- en: Our first tool for securing SSH is to consider completely removing password-based
    access to it in favor of using keys. Keys are fast and efficient allowing admins
    to access servers faster and more securely than with passwords. Keys also support
    passphrases which act as a form of two factor authentication. If this makes sense
    for your organization based on the security needs, then this requires someone
    to know an encrypted password and possess the private key simultaneous to attempt
    to breach a system through this channel. Keys have been around for remote access
    authentication for a very long time but have not enjoyed the popularity that they
    should. Too many companies take a *set up keys for yourself if you feel like it*
    approach, allowing far too many administrators to just not bother to take advantages
    of the efficiency and security that they offer.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 我们确保 SSH 安全的第一个工具是完全取消基于密码的访问，而改为使用密钥。密钥快速高效，允许管理员比使用密码更快速、更安全地访问服务器。密钥还支持密码短语，作为一种两步验证的形式。如果根据安全需求，这对于你的组织是可行的，那么这就要求某人同时知道加密密码并拥有私钥，才能尝试通过这一通道攻击系统。密钥在远程访问认证中已经使用了很长时间，但它们并没有得到应有的普及。许多公司采取了*如果你愿意，可以为自己设置密钥*的做法，导致太多管理员根本不愿意利用密钥所提供的效率和安全性。
- en: Our second tool is account lockouts from failed attempts. The standard tool
    for this on Linux based operating systems is called Fail2Ban. Fail2Ban takes SSH
    and other services that have standard login modules, and works with them to detect
    suspected malicious attempts against our systems and automates our local (meaning
    the firewall on our Linux based operating system itself) firewall to halt traffic
    from the offending IP address(es) for some predetermined period of time, typically
    three to fifteen minutes. This approach is our most effective tool against brute
    force attacks.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的第二个工具是来自失败尝试的帐户锁定。基于 Linux 的操作系统中用于此的标准工具是 Fail2Ban。Fail2Ban 处理 SSH 和其他具有标准登录模块的服务，与它们一起检测针对我们系统的可疑恶意尝试，并自动化我们本地的（即
    Linux 基础操作系统上的防火墙）防火墙，阻止来自受影响 IP 地址的流量一段预定时间，通常是三到十五分钟。这种方法是我们对抗暴力破解攻击最有效的工具。
- en: Do you still need both a network edge firewall and an operating system firewall?
  id: totrans-99
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 你是否仍然需要同时拥有网络边缘防火墙和操作系统防火墙？
- en: You might be shocked at just how often this question has come up over the years.
    What makes it such a surprising question is the context that it is always asked
    in.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会对这个问题出现的频率感到震惊。让这个问题如此令人惊讶的是它总是出现在什么样的背景下。
- en: First, some tech. In the real world, for many practical reasons, all routers
    are also firewalls. So functioning without a hardware firewall on the network
    edge is effectively impossible. In some cases, such as when installing VPS or
    cloud, we might be defaulted to a completely wide open firewall, but the firewall
    is at least still there. We have to start from an assumption that all operating
    system instances will always effectively be located behind a network firewall
    and that that firewall may be highly ineffective.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，了解一些技术。在现实世界中，出于多种实际原因，所有路由器实际上也是防火墙。所以，没有硬件防火墙的网络边缘环境几乎是不可能的。在某些情况下，例如安装
    VPS 或云服务时，我们可能默认一个完全开放的防火墙，但至少防火墙还是存在的。我们必须从一个假设出发，即所有操作系统实例通常都位于网络防火墙之后，而这个防火墙可能非常无效。
- en: Second, some history. Operating system firewalls were extremely rare due to
    their performance impacts until the late 1990s. They were also not very important
    as the degree to which computers were networked was much lower until that era.
    Operating system firewalls were introduced even though network firewalls were
    already a universal assumption because they add granularity and automation such
    as we can get with Fail2Ban, and because they protect individual machines from
    attacks that have either breached the network firewall or, far more likely, originate
    from inside of the LAN.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 其次，稍微了解一下历史。由于性能影响，操作系统防火墙在1990年代末期之前极为罕见。它们也不太重要，因为在那之前，计算机网络化的程度远远较低。即使网络防火墙已经是普遍的假设，操作系统防火墙还是被引入了，因为它们能提供更细粒度和自动化的功能，例如我们在
    Fail2Ban 中所得到的功能，而且它们保护的是已经突破网络防火墙或更可能的是来自局域网内部的攻击。
- en: Given the context, tech limitations, and history it seems ridiculous that someone
    would ever assume that both firewalls are not needed. If we had the ability to
    skip the network firewall, theoretically, we could do so, but there is no purpose
    to skipping the security at this layer; and while we can choose to not use the
    firewall in the operating system, this creates risks that has no other mitigation
    method. The operating system firewall is unique in its ability to defend against
    both local and remote threats, whereas the network firewall can protect against
    remote only. While nothing is going to be good as having both, it is the operating
    system firewall that we care about the most from a security perspective. Primarily
    we care about the network firewall only to lower the workload on the operating
    system firewall.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑到背景、技术限制和历史，认为两个防火墙不需要的想法显得荒谬。如果我们有能力绕过网络防火墙，理论上是可以做到的，但在这一层跳过安全性是没有意义的；虽然我们可以选择不使用操作系统防火墙，但这样会带来无法通过其他方法缓解的风险。操作系统防火墙在抵御本地和远程威胁方面具有独特的能力，而网络防火墙只能防御远程威胁。虽然没有什么比同时拥有两个防火墙更好的，但从安全角度来看，我们最关心的是操作系统防火墙。我们主要关心网络防火墙的原因是为了减轻操作系统防火墙的负担。
- en: Importantly, basic firewall functionality today does not require any measurable
    system overhead. This was the downside to using them (around a quarter of a century
    ago.) Today there is no effective caveats to the use of firewalls.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是，今天的基本防火墙功能并不会产生任何可测量的系统开销。这曾是使用防火墙的缺点（大约二十五年前）。如今，使用防火墙没有有效的限制条件。
- en: 'Best practice here is extremely clear and quite important: both the network
    firewall and the operating system firewall are absolutely needed. There is no
    situation where one of these firewalls should be removed or disabled.'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 最佳实践非常明确且极其重要：网络防火墙和操作系统防火墙是绝对需要的。没有任何情况是可以移除或禁用其中一个防火墙的。
- en: Often operating system firewalls are disabled because system administrators
    do not want to be bothered to have to know their networking needs or to secure
    their workloads properly. This is never a valid excuse. We all feel lazy at times,
    and we would all like to avoid having to maintain yet another point of support
    on our systems, but this is fundamental security and being able to properly support
    a system in production would require that we have all of the knowledge necessary
    to enable and configure the firewall regardless. Any perceived value to disabling
    a firewall (outside of troubleshooting, of course) should be seen as a huge warning
    sign that something is wrong that we need to address.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 操作系统防火墙常常被禁用，因为系统管理员不愿意花时间了解网络需求或正确地保护工作负载。这从来不是一个有效的借口。我们都曾感到懒惰，也都希望避免在系统中维护另一个支持点，但这涉及到基础的安全性，能够正确地支持生产环境中的系统就要求我们具备启用并配置防火墙所需的所有知识。任何认为禁用防火墙有价值的情况（当然不包括故障排除）都应该被视为一个巨大的警告信号，提示我们需要解决某些问题。
- en: Our third tool to secure `SSH`, after key-based authentication and account lockouts,
    is network limits, generally in the form of limiting the IP addresses from which
    requests to connect to SSH can originate. This can come in multiple forms. Often,
    we would do this with the firewall on the Linux system itself, but it could also
    be provided by the hardware firewall on the network edge or by a network firewall
    from a cloud provider and so forth.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `SSH` 的安全性方面，继基于密钥的认证和账户锁定后，我们的第三种工具是网络限制，通常以限制连接到 SSH 的请求来源 IP 地址的形式存在。这可以通过多种方式实现。通常，我们会在
    Linux 系统上的防火墙上实现这一点，但它也可以由网络边缘的硬件防火墙或云服务提供商的网络防火墙等提供。
- en: IP limits are often best set by whitelisting, when possible. Whitelisting allows
    us to restrict SSH traffic to just a single IP or small group of IP addresses
    that we believe to be known and safe such as from administrators' homes, a trusted
    data center, or the office IP address. This dramatically reduces the attack surface
    of our systems and makes them difficult to detect in the first place.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: IP 限制通常最好通过白名单来设置，尽可能的话。白名单允许我们将 SSH 流量限制到一个单一的 IP 或一小组我们认为是已知且安全的 IP 地址，例如管理员的家庭、信任的数据中心或办公室的
    IP 地址。这大大减少了我们系统的攻击面，使它们在第一时间难以被发现。
- en: For some, though, whitelisting is not possible or, at least, not plausible.
    In those cases, blacklisting of IP ranges that are certainly not going to need
    access will still increase security. In this case, for system administration,
    the use of national IP ranges to block traffic from certain countries and regions
    can be practical. I never recommend this practice for customer facing systems
    where you might accidentally block a customer or business partner without realizing
    it and risk backlash (remember, to someone trying to use a service from a blacklisted
    location does not see it as blocked, but as the service having failed and being
    offline), but for system administration access where the locations of your administrators
    should be roughly known and alternative back channels for communications should
    always exist and where security is far more critical it can make a lot of sense.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，对于某些人来说，白名单可能不可行，或者至少不太现实。在这种情况下，黑名单可以用来屏蔽那些肯定不需要访问的IP范围，依然能提高安全性。在这种情况下，系统管理员可以使用国家IP范围来阻止来自某些国家和地区的流量，这种做法是可行的。我从不推荐在面向客户的系统中使用这种做法，因为你可能会无意中阻止客户或商业伙伴，从而招致反弹（记住，对于试图从黑名单所在地点使用服务的人来说，他们并不会认为自己被阻止，而是认为服务失败了或离线了），但对于系统管理访问来说，管理员的位置应该大致已知，并且应始终有备选的沟通渠道，安全性更为关键，这种做法是非常有意义的。
- en: Fourth, the use of `sudo` to require an additional verification before executing
    escalated privilege commands is very useful. With `sudo` we can layer on more
    protection over what we already can have with keys or better, keys with passphrases.
    If we log in using a user account that possesses `sudo` permissions to the root
    superuser account, then we have already demonstrated one or two factors of authentication
    just to become a standard user. To use `sudo` we optionally require another, separate,
    password for that user to gain privilege escalation. That is a lot of potential
    protection. `Sudo` also helps us avoid dangerous errors that can happen, mostly
    from typos, when running as the root user directly. `Sudo` is more likely to protect
    us from ourselves than it is from external actors. It's a very useful tool.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 第四，使用`sudo`要求在执行提升权限的命令之前进行额外验证是非常有用的。通过`sudo`，我们可以在已有的密钥或更好的密钥加密码的基础上增加更多的保护。如果我们使用拥有`sudo`权限的用户账户登录root超级用户账户，那么我们在成为普通用户之前已经证明了一个或两个认证因素。使用`sudo`时，我们可以选择要求该用户输入另一个独立的密码，以便获得提升权限的权限。这提供了很多潜在的保护。`Sudo`还帮助我们避免了直接以root用户身份运行时可能发生的危险错误，通常是由于打字错误。`Sudo`更可能保护我们免于自身的错误，而不是来自外部的攻击。它是一个非常有用的工具。
- en: Fifth, thanks to the power of `sudo` mentioned above, we can disable root user
    logins over `SSH` completely keeping the most well-known, and by far the riskiest
    account, out of the risk equation completely. There is no need to the root user
    to be directly exposed when we have `sudo` mechanisms to protect it and to log
    when it is accessed already.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 第五，由于上面提到的`sudo`的强大功能，我们可以完全禁用通过`SSH`登录的root用户，将最著名、也是目前风险最大账户完全排除在风险之外。当我们拥有`sudo`机制来保护root用户，并且在其被访问时进行日志记录时，就没有必要将root用户暴露在外了。
- en: Does changing the default port of SSH work?
  id: totrans-112
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 更改SSH默认端口有效吗？
- en: You will find many people and articles that tell you that you should always
    change the default port of SSH, or any access protocol, to make it harder for
    attackers to detect. This will then be pointed out as being a form of security
    through obscurity which, is generally believed, to mean no security at all.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 你会发现许多人和文章告诉你应该始终更改SSH的默认端口，或任何访问协议的默认端口，以便使攻击者更难发现。这种做法通常被认为是一种“安全性通过模糊化”手段，但这种方式一般被认为根本没有安全性。
- en: In reality, both positions are a bit overstated. Changing the default port will
    truly do nothing for actual security as any real attack of any complexity or effort
    will find a non-standard port in a matter of seconds and likely the attacker will
    never even become aware that you attempted to thwart the attack by changing the
    address. Much like if you were to move the door to your house to somewhere along
    the side of the house, most thieves breaking in would not even take note of the
    fact that the door was in an odd location. The door is still the door and completely
    obvious.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 但实际上，这两种做法都有些被夸大。更改默认端口对于实际安全并没有什么作用，因为任何具有一定复杂性或力度的真实攻击都可以在几秒钟内发现一个非标准端口，而攻击者甚至可能不会意识到你试图通过更改地址来阻止攻击。就像你把家门移到房子的侧面，大多数闯入的小偷甚至不会注意到门的位置变得奇怪。门还是那扇门，非常明显。
- en: Thinking of using non-standard ports as a security measure is incorrect. At
    best it nominally improved the security posture, at worst it may advertise that
    you have attempted security through obscurity and may make a good target for a
    more focused attack. Where non-standard ports benefit us potentially is by reducing
    the amount of traffic that hits our ports making it easier to store and filter
    logs.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 认为使用非标准端口作为安全措施是错误的。充其量，它在名义上改善了安全姿态，最糟糕的情况可能是暗示你通过混淆来进行安全防护，并可能成为更有针对性攻击的良好目标。非标准端口潜在的好处在于减少了击中我们端口的流量量，使得存储和过滤日志变得更容易。
- en: Reducing log clutter can aid security, of course, simply by making a worrisome
    attack easier to spot or faster to diagnose, and reducing storage needs is always
    a nice benefit. So changing SSH ports may be beneficial, but the benefit should
    be kept in context.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，通过减少日志混乱可以增强安全性，因为这样可以更快地发现或诊断令人担忧的攻击，并且减少存储需求总是一个不错的好处。因此，更改 SSH 端口可能是有益的，但应保持在适当的背景下考虑其益处。
- en: Beyond all of these best practice security methods for SSH there are many other
    standard hardening options that can be used, but I would argue that outside of
    these that we would struggle to define any more as best practices as opposed to
    highly recommended or well worth considering. With a little accommodation, SSH
    can be ridiculously secure for almost any organizational need.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 除了 SSH 的所有这些最佳实践安全方法外，还有许多其他标准的加固选项可以使用，但我认为，除了这些，我们很难再定义更多作为最佳实践而不是强烈推荐或值得考虑的选项。稍作调整，SSH
    对几乎任何组织需求都可以极其安全。
- en: To take security in SSH to another level you can also, and quite easily, apply
    one-time passwords for multi-factor authentication through tools like Google Authenticator.
    Many third-party security enhancements exist and SSH can effectively be as secure
    as you want it to be.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 要提升 SSH 安全性的另一种方法是通过工具如 Google Authenticator 应用一次性密码进行多因素身份验证，这非常简单。还存在许多第三方安全增强措施，SSH
    可以像你想要的那样安全。
- en: SSH key management
  id: totrans-119
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: SSH 密钥管理
- en: It is generally assumed that if we are going to use SSH then we are going to
    use keys to secure the access to it. As mentioned before, they are fast and highly
    secure. There is little reason not to use them. It is not as simple as *just using
    them*, however. When we choose to use keys we then have to determine how we will
    manage those keys. How that is going to make sense will depend primarily on the
    size of our organization or, at least, on the size of our systems administration
    team and how many systems will be being accessed using said keys.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 一般认为，如果我们要使用 SSH，则需要使用密钥来保护对其的访问。如前所述，它们快速且非常安全。没有理由不使用它们。然而，并不仅仅是*简单地使用*它们。当我们选择使用密钥时，我们必须确定如何管理这些密钥。这如何才会有意义主要取决于我们组织的规模，或者至少取决于我们的系统管理团队的规模，以及使用这些密钥访问的系统数量。
- en: At its simplest SSH key management can be left up to the individual to manage
    on their own. If users have access to log in to an operating system already, then
    they are free to create and manage their own keys. For smaller organizations or
    those working with just a few system administrators this might make sense.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 在其最简单的形式下，SSH 密钥管理可以由个人自行管理。如果用户已经可以登录操作系统，则可以自由创建和管理自己的密钥。对于较小的组织或仅与少数系统管理员合作的情况，这可能是有意义的。
- en: With SSH keys, of course, management includes two components, the public keys
    and the private keys. Typically users will manage their own private keys, keeping
    them safe, and public keys can be managed in nearly any fashion.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 SSH 密钥时，管理涵盖了两个组成部分，即公钥和私钥。通常用户会管理自己的私钥，确保安全，而公钥可以采用几乎任何方式管理。
- en: In a smaller organization looking to improve the management of keys with little
    other infrastructure, it can be as easy as storing the public keys for users (which
    includes system administrators) on a wiki or other simple documentation system
    where they can be easily obtained as needed. This one step alone can make a big
    difference in making keys very easy to use.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 对于希望改进密钥管理而基础设施较少的小型组织，最简单的方法可以是将用户（包括系统管理员）的公钥存储在维基或其他简单文档系统中，以便根据需要轻松获取。单单这一步就能极大地简化密钥的使用。
- en: Keys can also be stored on the filesystem of something like a management server
    or workstation and pushed out through simple automation like a script that runs
    over SSH remotely and copies keys into place. Scripts could also pull public keys
    from a web page, a file share, or use something like GIT or Subversion to grab
    keys from a repository. Keys are simply text files and so managing them is flexible.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 密钥也可以存储在类似管理服务器或工作站的文件系统中，并通过简单的自动化推送出去，比如通过SSH远程执行的脚本，将密钥复制到指定位置。脚本也可以从网页、文件共享中提取公钥，或者使用像GIT或Subversion这样的工具从仓库中获取密钥。密钥本质上是文本文件，因此管理它们非常灵活。
- en: In a more advanced setting, state machines and infrastructure as code approaches
    can be used to automate key deployments through the same tooling as other automations.
    Keys can be just another set of files and do not need to be treated specially
    in any way. DevOps processes like state machines and infrastructure as code are
    great mechanisms to make SSH key management vastly simplified
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 在更高级的设置中，可以使用状态机和基础设施即代码的方法，通过与其他自动化工具相同的工具来自动化密钥部署。密钥可以仅仅作为一组文件处理，并不需要特别对待。像状态机和基础设施即代码这样的DevOps流程是简化SSH密钥管理的极好机制。
- en: All of that, however, is really barely worth considering. Once you are working
    at any scale with keys and are at a point where key management is going to become
    something on your system administration radar, then it is probably time to look
    at a **public key infrastructure** (**PKI**) system to manage certificates instead
    of keys. SSH uses TLS, the same mechanism as HTTPS and countless other secure
    protocols, and as such it can use the same PKI system that websites use.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，所有这些实际上几乎不值得考虑。一旦你在任何规模上使用密钥，并且你的系统管理中出现了密钥管理的问题，那么可能是时候考虑使用**公钥基础设施**（**PKI**）系统来管理证书，而不是密钥了。SSH使用TLS，这是与HTTPS以及无数其他安全协议相同的机制，因此它可以使用与网站相同的PKI系统。
- en: Of course, in almost all cases using a publicly hosted PKI certificate system
    is going to be problematic for what are almost always private and internal hosts
    in our Linux infrastructure. So, we would be required to run our own certificate
    authority, known as a CA, but this is a standard practice, has extremely low cost
    and overhead, and while the skills to do so are not broadly available they are
    easily acquired. Using SSH certificates *instead* of SSH keys (instead is in quotes
    here because certificates contain keys, the keys always remain under the hood)
    gives us a mechanism to rapidly scale SSH key security for many administrators,
    potentially many end users.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，在几乎所有情况下，使用公共托管的PKI证书系统对于我们Linux基础设施中的几乎所有私有和内部主机来说都会是一个问题。因此，我们需要运行自己的证书授权机构，称为CA，但这是一个标准的做法，成本和开销极低，虽然这种技能并不广泛存在，但它是可以轻松掌握的。使用SSH证书*而不是*SSH密钥（这里的“而不是”是因为证书包含了密钥，密钥始终隐藏在背后）为我们提供了一个机制，能够快速扩展许多管理员和可能的许多最终用户的SSH密钥安全性。
- en: I would not go so far as to call running your own certificate authority and
    building a PKI infrastructure is a best practice, it is a good rule of thumb for
    organizations with more than just a few users connecting to more than a few boxes
    over SSH. The network effect of many users to many different operating system
    instances can mean an explosion in SSH keys that could remain unmanaged if we
    do not take action. Ten administrators, twenty developers, ten testers, and one
    hundred virtual machines alone could create a need to monitor four thousand SSH
    key combinations!
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 我不会过于夸张地说运行自己的证书授权机构并建立PKI基础设施是最佳实践，但对于那些不仅仅是几个用户连接到几个SSH主机的组织来说，这是一条不错的经验法则。许多用户连接到不同操作系统实例的网络效应，可能导致SSH密钥数量激增，如果不采取措施，可能会无人管理。例如，十个管理员、二十个开发人员、十个测试人员和一百个虚拟机，光是这些就可能需要监控四千个SSH密钥组合！
- en: With essentially all operating system supporting SSH today the benefits of a
    robust SSH security strategy are even larger. The easier SSH is to use securely,
    the more likely it is to be used over alternative technologies.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 随着几乎所有操作系统今天都支持SSH，强大的SSH安全策略的好处更加显著。SSH越容易安全地使用，就越有可能被采用，取代其他技术。
- en: Jump boxes
  id: totrans-130
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 跳板机
- en: Jump boxes are an important security and management tool that can simplify many
    aspects of system administration. As a concept they are very common, but as a
    term often even seasoned system administrators may not be familiar. A jump box
    is a system that is accessed remotely by system administrators (or regular users,
    but it is typically only used for technical support staff due to the cumbersome
    nature of the design) from which access is then granted on to the systems that
    will be managed.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 跳跃盒子是一个重要的安全和管理工具，可以简化系统管理的许多方面。作为一个概念，它们非常常见，但作为一个术语，即使是经验丰富的系统管理员也可能不熟悉。跳跃盒子是一个系统，系统管理员（或普通用户，但通常只供技术支持人员使用，因为其设计较为繁琐）通过远程访问该系统，并授予访问权限到要管理的其他系统。
- en: It is called a jump box because you log into it before *jumping* to another
    system. It is a jumping off point for your tasks. It is common for jump boxes
    to be used for more than just access, but also as a central repository for tools,
    a temporary storage location, or a common location from which to run automation
    scripts.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 它被称为跳跃盒子，因为你在*跳跃*到另一个系统之前，首先登录到它。它是你任务的起点。跳跃盒子不仅用于访问，还常常作为工具的中央存储库、临时存储位置，或者运行自动化脚本的公共位置。
- en: Jump boxes are often used to provide a central point of direct access to systems
    to get something akin to a hybrid between the features generally associated with
    indirect remote access technologies and traditional direct access. Technically
    a jump box is just a two stage direct access system, but one that can be highly
    useful and avoids the need to use a network router like a VPN or complex proxies
    to accomplish a consolidation of access.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 跳跃盒子通常用于提供一个中央访问点，以便直接访问系统，获取类似于间接远程访问技术和传统直接访问之间的混合特性。从技术上讲，跳跃盒子只是一个两阶段的直接访问系统，但它非常有用，可以避免使用像VPN或复杂代理这样的网络路由器来实现访问整合。
- en: Through access consolidation we can more practically secure our first line of
    access. It is common for jump boxes to receive the most complex IP filtering,
    strict Fail2Ban rules, detailed logging, two factor authentication, rapid patching,
    and so on to tightly secure the most vulnerable point of ingress. In this fashion,
    system administrators might start their day by logging into their jump box and
    then quickly and easily attach to the systems that they administer from that point.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 通过访问整合，我们可以更实际地保护我们的第一道访问防线。跳跃盒子通常会收到最复杂的IP过滤、严格的Fail2Ban规则、详细的日志记录、双因素认证、快速修补等，以紧密保护最脆弱的进入点。以这种方式，系统管理员可能会通过登录到他们的跳跃盒子开始一天的工作，然后快速轻松地从该点连接到他们管理的系统。
- en: Because of their design, it is often easy for jump boxes to exist inside of
    the LAN, be hosted in colocation, or even be cloud hosted. They can be put wherever
    is practical and given access to resources anywhere. They can be hardened, monitored,
    and then connected through direct access protocols or even a VPN or multiple VPNs
    to systems and sites as needed.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 由于其设计，跳跃盒子通常容易存在于局域网内，托管在共置数据中心，甚至可以是云托管的。它们可以被放置在任何实际需要的地方，并可以在任何地方访问资源。它们可以被加固、监控，并通过直接访问协议，甚至VPN或多个VPN连接到系统和网站，根据需要进行访问。
- en: Because a jump box is a single system it is easy to have the systems that we
    manage allow connections from its single IP address to allow good security even
    while using direct access technologies.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 由于跳跃盒子是一个单一系统，因此管理的系统可以允许从它的单一IP地址连接，即使使用直接访问技术时也能保持良好的安全性。
- en: Jump boxes for Linux based operating systems are typically used for SSH and
    so may be built as a lean server. A GUI-less Linux jump box can run on one of
    the smallest of virtual machines, these use almost no resources making them very
    easy to deploy wherever needed with little cost.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 基于Linux的操作系统的跳跃盒子通常用于SSH，因此它们可能被构建为精简的服务器。没有图形界面的Linux跳跃盒子可以运行在最小的虚拟机上，这些虚拟机几乎不占用任何资源，使得它们非常容易在需要的地方部署且成本低廉。
- en: Jump boxes are also built to handle other protocols, often X or RDP, for example.
    This is uncommon for Linux system administration as rarely is a GUI anything but
    an encumbrance for us and when using a jump box the resource needs and complexity
    of providing a central GUI source will often make us reconsider providing a GUI
    as well.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 跳跃盒子还可以处理其他协议，通常是X或RDP协议。例如，这在Linux系统管理中并不常见，因为图形界面通常对我们来说只是负担，而当使用跳跃盒子时，提供中央图形界面源的资源需求和复杂性通常会让我们重新考虑是否提供图形界面。
- en: Jump boxes are not a best practice, but they are a common security and management
    tool and can be very helpful where direct access is needed to make it faster,
    easier, and more secure than it would likely be otherwise.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 跳板机不是最佳实践，但它是一个常见的安全和管理工具，在需要直接访问以加快、简化和提高安全性时非常有用。
- en: Alternative remote access approaches
  id: totrans-140
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 替代性远程访问方法
- en: Traditional remote access, at least as we tend to think of it, is all designed
    around the needs of end users needing to use remote sessions as a replacement
    for their local desktop. As system administrators, it is great for us to be able
    to use those tools when they make sense for us, and it is necessary that we understand
    those tools because they are generally components that fall to us to administer,
    but for our own usage they may not be the most practical.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 至少从我们通常的理解来看，传统远程访问完全是围绕终端用户的需求设计的，用户需要通过远程会话来替代他们的本地桌面。作为系统管理员，能够在合适的场景下使用这些工具对我们来说是非常有帮助的，并且我们必须理解这些工具，因为它们通常是由我们来管理的组成部分，但就我们自身使用而言，这些工具可能不是最实用的。
- en: Of course, we can include most indirect remote access technologies under the
    heading of alternative remote access approaches, but they are basically just traditional
    access that has been tweaked to be more practical for our use cases. As administrators
    we want to reduce our logins or interactive sessions with remote machines in the
    hopes of removing that access completely, at least in an ideal world.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，我们可以将大多数间接远程访问技术归类为替代性远程访问方法，但它们本质上只是经过调整的传统访问方式，以使其更适合我们的使用场景。作为管理员，我们希望减少与远程机器的登录或交互式会话，期望最终完全消除这种访问，至少在理想状态下是这样。
- en: To this end, we have other methodologies today for running commands on our servers.
    There are not going to replace our existing methods in all cases, but they may
    be a steppingstone technology to help us move from where we are to where we want
    to be in the future.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 为此，我们今天有了其他方法来在我们的服务器上运行命令。这些方法并不会在所有情况下取代我们现有的方式，但它们可能是帮助我们从当前状态向未来目标过渡的一项过渡性技术。
- en: What makes most of our system access methods *traditional* is really that they
    involve complete interactivity. That means that whether we are using RDP or Splashtop
    or an SSH session, we assume that we are establishing a full connection to the
    system to be managed, complete with user-level environmental settings, and working
    in a manner where we have continuous input and output from the system. This is
    so much assumed that many applications or tools actually assume that this method
    is used and may require session environmental variables that are not logical or
    appropriate.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 使我们大多数系统访问方法看起来*传统*的原因，实际上是它们涉及完全的交互性。这意味着无论我们使用 RDP、Splashtop 还是 SSH 会话，我们都假设正在与需要管理的系统建立完全连接，包括用户级别的环境设置，并在一个持续的输入和输出过程中进行工作。这种假设已经深入人心，许多应用程序或工具实际上也假设使用这种方法，可能需要一些不合逻辑或不合适的会话环境变量。
- en: Short of remove access altogether as we discussed earlier when talking about
    infrastructure as code, our interim access step is remote command execution or
    using non-interactive commands. This works effective just as our other access
    methods do, but without the ability to become interactive. Remote command execution
    lets us move from manual tasks to automation more easily and is great for auditing,
    security, and scalability.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 除非像我们之前讨论的那样完全移除访问——即通过基础设施即代码的方式——否则我们的过渡性访问步骤是远程命令执行或使用非交互式命令。这与我们其他访问方法一样有效，但没有交互能力。远程命令执行使我们能更轻松地从手动任务过渡到自动化，并且非常适用于审计、安全性和可扩展性。
- en: At its simplest, remote command execution can be handled through SSH using the
    same infrastructure that we would have for interactive sessions. SSH is designed
    to handle either method with aplomb and since it does so transparently it can
    be an easy tool for moving slowly from one method to the other. The methods can
    be mixed on a situational basis, or one administrator could use one method and
    a second could use the other.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 从最简单的角度看，远程命令执行可以通过 SSH 处理，使用与交互式会话相同的基础设施。SSH 设计得能够优雅地处理这两种方法，并且由于它是透明地执行的，它可以是从一种方法平稳过渡到另一种方法的便捷工具。这些方法可以根据情况混合使用，或者一位管理员使用一种方法，另一位使用另一种方法。
- en: With remote command execution we get the benefit that all commands are executed,
    and therefore can be recorded, on the originating system. Perfect for the use
    of something like a jump box or management server that could log all actions performed.
    Interactive sessions, however, even those initiated from a jump box, will log
    all of the important session information on the final operating system and the
    jump box will only know that a remote session was started - visibility into exactly
    what commands were run there and what their responses were will be lost to the
    central logging platform.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 使用远程命令执行，我们可以获得所有命令都在源系统上执行的好处，因此可以被记录。非常适合像跳板机或管理服务器这样的工具，可以记录所有执行的操作。然而，交互式会话，即使是从跳板机启动的，也会将所有重要的会话信息记录到最终的操作系统中，跳板机只会知道远程会话已启动——对于到底执行了哪些命令及其响应的详细信息，将会丧失在中央日志平台的可见性。
- en: In many ways, remote command execution is a system administrator's analogue
    to functional programming in the software development world. Interactive sessions
    are more akin to procedural programming, where actions are seen as a sequence
    of events. Remote command execution is the use of singular remote functions to
    perform a task. A difficult analogy to apply if you are not familiar with these
    programming paradigms, but for those that have used them I think the example is
    valuable.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 在许多方面，远程命令执行是系统管理员在软件开发世界中的函数式编程类比。交互式会话更像是过程式编程，其中动作被视为一系列事件。远程命令执行则是使用单一远程函数来执行任务。如果你不熟悉这些编程范式，这个类比可能难以应用，但对于那些使用过这些范式的人来说，我认为这个例子是有价值的。
- en: SSH may be ideal for sneaking in a casual introduction of remote command execution
    and is essentially always available for system administrators to use. Even in
    highly strict, structured, and formal process driven environments it would be
    highly unlikely for a policy decree to not allow administrators to use this approach
    whenever and wherever they want, assuming traditionally interactive SSH sessions
    are allowed.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: SSH 可能是悄然引入远程命令执行的理想方式，并且本质上始终可供系统管理员使用。即使在高度严格、结构化和正式的流程驱动环境中，政策法令通常也不太可能不允许管理员在允许传统交互式
    SSH 会话的情况下，随时随地使用这种方法。
- en: 'Other tools, and with increasing popularity, also allow remote command execution
    today. This has become a standard option in most indirect remote access tools
    from large, commercial software as a service products to small open source products
    for self-hosting: almost always remote command execution is included in some fashion
    today. In some cases with extended features such as the ability to run the same
    command or set of commands against a set or list of systems simultaneously.'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 其他工具，尤其是越来越流行的工具，今天也允许远程命令执行。这已成为大多数间接远程访问工具的标准选项，从大型商业软件服务产品到小型开源自托管产品几乎总是包含某种形式的远程命令执行。在某些情况下，还具备扩展功能，如能够同时对一组或列表中的多个系统运行相同的命令或命令集。
- en: RMM tools are often building in remote command execution systems in the same
    way. This is far easier than creating custom interactive session mechanisms and
    can be touted as a more advanced option, while being much simpler to implement.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 远程管理工具（RMM）通常以相同方式构建远程命令执行系统。这比创建自定义交互式会话机制要容易得多，并且可以被吹捧为更先进的选项，同时实现起来也更简单。
- en: The most interesting place to find remote command execution, in my opinion,
    is in state machine systems. Just as SSH can be viewed as having remote command
    execution as a an optional strategy, to move away from interactive sessions and
    ease into something a bit less familiar, state machines can and do implement remote
    command execution as a way to maintain one foot in a more traditional operational
    mode to allow system administrators a fallback method for when state definitions
    are too difficult or time consuming to implement.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 在我看来，最有趣的远程命令执行应用场景是状态机系统。正如 SSH 可以被视为具有远程命令执行作为可选策略，远离交互式会话，逐步过渡到一种稍微不那么熟悉的方式，状态机也可以并且确实将远程命令执行作为一种方式，保持在更传统的操作模式中，为系统管理员提供在状态定义过于复杂或耗时时的备用方法。
- en: Remote command execution from a state machine is also a method for testing state
    machine access or capabilities while developing state files. State is maintained,
    one way or another, by running commands on the system being managed. In some cases,
    commands are run by an agent at arm's length and while remote commands are executed,
    the exact commands are not sent by the state management central system. In other
    systems commands may be sent directly as typed on the management system and the
    state machine is just an execution assistant.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 从状态机进行远程命令执行也是一种测试状态机访问或功能的方法，尤其是在开发状态文件时。状态是通过在被管理的系统上运行命令来维持的，不管是哪种方式。在某些情况下，命令是通过一个远程代理来执行的，而远程命令虽然被执行，但具体的命令并不是由状态管理中心系统发送的。在其他系统中，命令可能直接按照管理系统上输入的内容发送，状态机只是作为执行助手。
- en: Remote access, as simple as it might seem at first, is not a one size fits all
    solution and we do not have to use only a single solution even inside of a single
    organization. Consider thinking outside of the box and trying new or different
    approaches to make your workflows more secure, stable, and efficient.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 远程访问，尽管一开始看起来很简单，并不是“一刀切”的解决方案，我们甚至可以在同一个组织内使用不同的解决方案。考虑跳出固有思维，尝试新的或不同的方法来提升工作流程的安全性、稳定性和效率。
- en: 'Now that we are prepared to system administrator access and security across
    a broad variety of approaches, we should talk a little about technologies more
    applicable to end user access to systems: terminal servers and virtual desktop
    infrastructure.'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经准备好从各种方法中获取系统管理员访问和安全性的概念，我们应该讨论一些更适用于终端用户访问系统的技术：终端服务器和虚拟桌面基础设施。
- en: Terminal servers and virtual desktop infrastructure (VDI)
  id: totrans-156
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 终端服务器和虚拟桌面基础设施（VDI）
- en: Unlike the Windows world, remote GUI access in the world of Linux based operating
    systems is relatively rare. This is just not part of the Linux wheelhouse in a
    self-fulfilling situation where customers do not demand it, so vendors do not
    specialize around it, leaving customers feeling that little is available for it
    and the cycle continues. But that is not to say that both terminal services and
    **VDI** (which stands for **Virtual Desktop Infrastructure** but is more meaningful
    and known simply by its acronym) options cannot or do not exist for Linux based
    systems, they most certainly do.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 与Windows世界不同，在基于Linux的操作系统中，远程GUI访问相对较少。这只是因为Linux并不将此视为其核心功能，在这种自我实现的情况下，客户没有需求，所以供应商也没有在此方面做专门化，导致客户觉得这方面的可用性很低，从而形成了一个循环。然而，这并不是说终端服务和**VDI**（即**虚拟桌面基础设施**，但它通常更为人熟知并直接以缩写形式使用）选项在Linux系统中不存在，它们当然存在。
- en: Understanding terminal services and VDI conceptually
  id: totrans-158
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 概念上理解终端服务和VDI
- en: It is not uncommon for terminal servers and VDI architectures to become intertwined,
    this mostly has happened because of marketing departments trying to sell VDI where
    it does not apply and because overlapping technologies are often used. That VDI
    was presented as the hot, new technology as if it had not always existed added
    to this confusion. And Microsoft, the leader in this space, renaming their core
    product from **Terminal Server** to **Remote Desktop Server** (**RDS**) did not
    help any either. This led to the problem that many Windows administrators, let
    alone users, routinely confused RDP, the Remote Desktop Protocol, with RDS, Microsoft's
    terminal server product. One is a communications protocol used by and implemented
    by many different products; the other is a specific product, as well as licensing
    vehicle, that you have to purchase from Microsoft that may or may not utilize
    RDP.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 终端服务器和VDI架构交织在一起并不罕见，这主要是由于市场营销部门试图在不适用的场景中推销VDI，并且因为常常使用重叠的技术。VDI被作为一种新的热门技术来推广，好像它并非一直存在一样，这也加剧了混淆。而作为该领域领导者的微软，将其核心产品从**终端服务器**重命名为**远程桌面服务器**（**RDS**），也没有起到任何帮助。这导致了一个问题，即许多Windows管理员，更不用说用户，常常将RDP（远程桌面协议）与RDS（微软的终端服务器产品）混淆。一个是由多种不同产品实现并使用的通信协议；另一个是一个具体的产品和许可工具，必须从微软购买，可能会使用RDP，也可能不会。
- en: So we have to start by defining these technologies. Both involve accessing a
    computer remotely. Both can and do use the same potential set of protocols to
    make this magic happen. Both serve the same basic purpose but implement it in
    two different ways.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 所以我们必须从定义这些技术开始。两者都涉及远程访问计算机。两者都可以使用相同的一套潜在协议来实现这一“魔法”。两者的基本目的是相同的，但实现方式有所不同。
- en: 'A terminal server has always meant a *single server* (meaning: a *single operating
    system instance*) that can be accessed simultaneously by multiple remote users.
    In the earliest days, this was accomplished by using serial connections to dumb
    terminals to display text *remotely*. Later came technologies such as telnet and
    RSH and eventually SSH as we use today. All of these technologies advanced the
    state of security and accessibility, but fundamentally remote access remained
    a familiar command line activity resembling the original serial-based physical
    terminals. Decades ago, the remote use of graphical desktop environments became
    the norm for end users, and new protocols such as RDP, RFB, X, and NX became popular,
    but nothing really changed fundamentally. Many users would connect to a single
    operating system instance, and they would share its resources. There was only
    one operating system to patch, and everyone shared the same kernel and applications.
    A terminal server uses a *many-to-one* architecture.'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 终端服务器一直意味着一个*单一服务器*（即：一个*单一操作系统实例*），可以被多个远程用户同时访问。在最初的时代，这通过使用串行连接到哑终端来远程显示文本来实现。后来出现了诸如telnet、RSH，最终是今天我们使用的SSH等技术。这些技术推进了安全性和可访问性的状态，但从根本上讲，远程访问仍然是一个类似于原始串行物理终端的命令行活动。几十年前，图形桌面环境的远程使用成为终端用户的常态，新的协议如RDP、RFB、X和NX变得流行，但本质上没有什么根本变化。许多用户仍然连接到一个单一的操作系统实例，并共享其资源。只有一个操作系统需要修补，所有人共享相同的内核和应用程序。终端服务器采用的是*多对一*架构。
- en: VDI, which stands for virtual desktop infrastructure, refers to an alternative
    approach where users remotely access dedicated operating system instances that
    exist only for them, and which are virtualized. With VDI, each user's operating
    system instance could be completely different with different patch levels or even
    different operating systems entirely. One user might be on **Windows 11**, another
    on Windows XP, and another on Ubuntu. VDI means a *one-to-one* architecture.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: VDI（虚拟桌面基础设施）是一种替代方法，用户可以远程访问仅为他们存在的虚拟化操作系统实例。在VDI中，每个用户的操作系统实例可以完全不同，具有不同的补丁级别，甚至可能是完全不同的操作系统。一个用户可能使用**Windows
    11**，另一个用户使用Windows XP，另一个用户使用Ubuntu。VDI意味着*一对一*架构。
- en: For the most part, the concepts of and differences between these two approaches
    are created almost entirely out of the need to manage limitations created by Microsoft
    software licensing. In the Linux world, the difference between a terminal server
    or a VDI deployment is purely a matter of how any given system is used *in-the-moment*
    at the time that they are being accessed. Every Linux device is inherently multi-user
    already. Linux lacks the *one user at a time* framework that has always been a
    part of the Windows ecosystem. These concepts are often lost or confusing in a
    non-Windows context. For Linux administrators, any VDI system is just many terminal
    servers that tend to be lightly used. In the Windows world, licensing dictates
    every aspect of this equation in very complex ways.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 在大多数情况下，这两种方法之间的概念和区别几乎完全是出于管理微软软件许可限制的需要。在Linux世界中，终端服务器或VDI部署之间的区别纯粹是根据系统在访问时如何使用*即时*决定的。每个Linux设备本身已经是多用户的。Linux缺乏Windows生态系统中始终存在的*一次只有一个用户*的框架。这些概念在非Windows环境中往往会被忽视或造成混淆。对于Linux管理员来说，任何VDI系统其实就是多个轻度使用的终端服务器。在Windows世界中，许可规则以非常复杂的方式支配了这个方程式的各个方面。
- en: In the Windows world, an end user workstation license as available for Windows
    7, 10, or 11 is always a single user license, no exceptions. Remote access is
    always allowed, but only for the singular user never for alternative or additional
    users. One user sitting at the console or that user remote, but never more than
    one at a time. Even Windows Server licenses only allow for one user at a time
    (with one additional license purely for the purposes of systems administration
    purposes) unless RDS licensing is purchased for additional users. RDS is only
    available as an add-on license to Windows Server. Because of these licensing rules,
    the ideas of what is a server and what is an end user workstation in the Windows
    world is exceptionally clear and obvious.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 在Windows世界中，Windows 7、10或11的最终用户工作站许可证总是单用户许可证，没有例外。远程访问总是允许的，但只允许单一用户使用，绝不允许替代或附加用户。一个用户坐在控制台前，或者该用户远程访问，但一次只能有一个用户使用。即使是Windows
    Server许可证也只允许一个用户同时使用（另有一个额外许可证仅供系统管理用途），除非购买了RDS许可证以支持额外用户。RDS只能作为附加许可证用于Windows
    Server。由于这些许可证规则，Windows世界中什么是服务器，什么是最终用户工作站，界限非常明确且显而易见。
- en: With Linux, of course, there is no such licensing limitations. Any workstation
    can do the job of a server, any server can be used as a desktop or for multiple
    users. Any machine can be used in any way, at any time, flexibly. Terms like terminal
    servers and VDI refer only to how we intend to use a system or how it is being
    used at any given moment, but to most non-Linux administrators it is a locked-in,
    set in stone, expensive, licensing-driven design and decision process and so we
    have to be adaptable to understanding how these terms and concepts play into the
    consciousness of those outside of our free and flexible universe.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，在Linux中并不存在这样的许可证限制。任何工作站都可以作为服务器使用，任何服务器都可以作为桌面或供多个用户使用。任何机器都可以灵活地在任何时间以任何方式使用。诸如终端服务器和VDI之类的术语仅指我们打算如何使用系统或系统在任何特定时刻的使用方式，但对于大多数非Linux管理员来说，它是一个固定、石沉大海、昂贵的、以许可证为驱动的设计和决策过程，因此我们必须能够理解这些术语和概念如何影响那些处于我们自由灵活的环境之外的人们的认知。
- en: Of course, there is an obvious, third option that has no name. Terminal services
    does not consider if a system is physical (that is to say, installed directly
    on bare metal hardware) or virtualized, in both cases it is a terminal server,
    and the virtualization is irrelevant. With VDI, virtualization is part of the
    name, so we only consider it to be VDI when it is also virtualized for no obvious
    reason. If we do the same logical architecture as VDI but do so on bare metal
    operating system installs, then the architecture has no name, at least no well-known
    name. One to one remote access without virtualization is actually the most common,
    base approach to remote access, so much so that most people do not even think
    about it as an architecture. It requires essentially no planning or coordination
    and is often used for a variety of purposes. This unnamed design is common for
    any operating system Linux, Windows, macOS, or otherwise.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，还有一个显而易见的第三种选择，它没有名称。终端服务并不考虑系统是物理的（也就是说，直接安装在裸机硬件上）还是虚拟化的，在这两种情况下它都是一个终端服务器，虚拟化是无关紧要的。对于VDI，虚拟化是名称的一部分，因此我们只有在系统没有明显理由进行虚拟化时，才会将其视为VDI。如果我们在裸机操作系统安装上做与VDI相同的逻辑架构，那么这个架构没有名称，至少没有一个广为人知的名称。没有虚拟化的一对一远程访问实际上是最常见的远程访问基础方式，甚至以至于大多数人都不会将其视为一种架构。它基本上不需要规划或协调，通常用于各种目的。这个没有名称的设计在任何操作系统中都很常见，无论是Linux、Windows、macOS还是其他。
- en: 'Linux based operating systems will support any remote access architecture that
    we desire and will even support protocols typically associated with other operating
    systems: namely RDP from the Windows ecosystem. In the Windows ecosystem, RDS
    is technologically bound to Active Directory causing user management to be closely
    coupled with remote access strategies. In Linux we have no such ties. Deploying
    an RDP-based terminal server can be done using any user management system that
    we desire.'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 基于Linux的操作系统将支持我们所需的任何远程访问架构，甚至支持通常与其他操作系统相关的协议：即来自Windows生态系统的RDP。在Windows生态系统中，RDS技术上与Active
    Directory绑定，导致用户管理与远程访问策略紧密耦合。在Linux中，我们没有这样的约束。部署基于RDP的终端服务器可以使用我们想要的任何用户管理系统。
- en: Tools like terminal servers and VDI are far more likely to be used by end users,
    from office workers to developers, than by system administrators, but this is
    not exclusive. In my own deployment today we maintain both for use exclusively
    by system administration. I will use this as an example scenario to show how these
    technologies may be used effectively on the administration side of the fence.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 像终端服务器和 VDI 这样的工具，更有可能被终端用户使用，从办公室工作人员到开发者，而非系统管理员，但这并不是唯一的情况。在我当前的部署中，我们同时维护这两者，专门供系统管理使用。我将以此为示例场景，展示这些技术如何在管理方面有效地使用。
- en: On occasion, system administrators may benefit from having a graphical session
    for support. This may be because graphical tools like a notepad, screenshots,
    web interface or such make the work more efficient, or in some cases the tooling
    requires a graphical session. It is sadly common that many systems, rarely Linux
    itself but often systems required for use by Linux system administrators, will
    only provide a web-based GUI interface or worse, something like a Java application
    interface or even a native application. Having a Linux terminal server built for
    multi-user RDP support in our case located inside our main, trusted datacenter
    with a static IP allows our administration team to have access for any and all
    team members at any time to open a graphical session in a trusted location to
    perform whatever work is necessary.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，系统管理员可能会从拥有图形会话中受益。这可能是因为图形工具，如记事本、截图、网页界面等，使工作更高效，或者在某些情况下，工具本身需要图形会话。不幸的是，许多系统，虽然
    Linux 本身不常见，但常常是为 Linux 系统管理员所需的系统，只提供基于 Web 的 GUI 界面，或者更糟的是，像 Java 应用程序界面或甚至原生应用程序。我们在主信任数据中心内部，拥有一个专为多用户
    RDP 支持构建的 Linux 终端服务器，并且具有静态 IP 地址，这使得我们的管理团队可以随时随地为所有团队成员提供访问权限，在受信任的位置打开图形会话，执行任何必要的工作。
- en: Having a graphical interface is also at times highly beneficial for making documentation
    while working, doing training via screensharing, or similar tasks.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 拥有图形界面在进行文档编写、通过屏幕共享进行培训或类似任务时，往往会非常有益。
- en: Terminal servers are perfect, especially with Linux based operating systems,
    for providing a clean, standard environment that everyone shares. VDI provides
    a competing approach and we, like many companies, use VDI to provide highly customized
    environments that individual system administrators may require such as alternative
    operating systems or desktop environments that would create conflicts with other
    users if these were implemented on a shared server environment. VDI is also better
    for situations where individual system administrators may require to be administrators
    of their own environments, often for testing, that may not be wise or plausible
    from a security perspective on a shared environment.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 终端服务器非常适合，特别是在基于 Linux 的操作系统中，提供一个干净、标准的共享环境。VDI 提供了一种竞争的方式，我们和许多公司一样，使用 VDI
    提供高度定制化的环境，满足个别系统管理员的需求，例如替代操作系统或桌面环境，这些在共享服务器环境中实施时可能会与其他用户发生冲突。VDI 在某些情况下也更适合，个别系统管理员可能需要成为自己环境的管理员，通常是为了测试，但在共享环境中，这从安全角度来看可能不明智或不可行。
- en: Both terminal servers and VDI, whether graphical or command line only, can be
    useful as platforms to be used as jump boxes, management stations, remote execution
    environments and so forth. We can also use them, of course, as ways to provide
    Linux based desktop environments to end users. There is quite simply, no reason
    to limit these types of technologies conceptually to Windows, Linux can shine
    here as well and, in many cases, excel.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 无论是图形界面还是仅命令行的终端服务器和 VDI，都可以作为跳板、管理站、远程执行环境等平台使用。当然，我们还可以将它们用作向终端用户提供基于 Linux
    的桌面环境。简单来说，完全没有理由在概念上将这些技术仅限于 Windows，Linux 在这里也能大放异彩，而且在许多情况下，表现得更为出色。
- en: Summary
  id: totrans-173
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: Users and user access on Linux based operating systems is a complex topic, mostly
    because of the incredible flexibility that Linux affords us. We can approach where
    users exist, how we create them, how they are managed, where our source of truth
    resides, and how those users can access their systems in so many ways. We have
    ancient technologies, we have extremely modern technologies. We can use nearly
    any mechanism, from any era, from any ecosystem and we can have many that we build
    ourselves and our unique to us. We can stick to well-known traditional processes,
    or we can easily build our own and work in a unique way.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: Linux 操作系统上的用户和用户访问是一个复杂的话题，主要因为 Linux 给我们提供了极大的灵活性。我们可以从多个角度探讨用户的存在位置、如何创建用户、如何管理用户、我们信息的来源以及用户如何以多种方式访问他们的系统。我们有古老的技术，也有极其现代的技术。我们几乎可以使用任何机制，来自任何时代、任何生态系统，我们甚至可以自己构建并且是独一无二的。我们可以遵循传统的流程，也可以轻松地构建自己的流程，并以独特的方式工作。
- en: There is no simple best practice for user management on Linux. Instead, our
    best practice is, like it so often is, that we need to understand the range of
    technological possibilities, how different risks and benefits will apply to our
    unique organization and know the products that exist on the market from open source
    to commercial, from software to services and evaluate those needs across all axes
    to determine what is right for our organizations. There are no built-in assumptions.
    The use of local user accounts is not wrong, even when done at very large scale.
    Using remote users is not wrong, even at a very small scale. We do not have to
    maintain and run our own infrastructure for security, but we do not have to rely
    on third-party vendors to do it for us either. The sky is the limit – most approaches
    have benefits, but all of them have caveats, so they all warrant thorough investigation.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Linux 上没有简单的最佳用户管理实践。相反，我们的最佳实践通常是，我们需要理解技术的各种可能性，了解不同的风险和利益如何适应我们独特的组织，了解市场上现有的产品——从开源到商业，从软件到服务，并从各个方面评估这些需求，以确定适合我们组织的解决方案。没有预设假设。使用本地用户帐户并不错误，即使是在非常大规模的情况下。使用远程用户并不错误，即使是在非常小的规模下。我们不必为安全性维护和运行自己的基础设施，但也不必依赖第三方供应商来为我们做这件事。天空才是极限——大多数方法都有其优点，但所有方法都有其局限性，因此它们都值得彻底调查。
- en: There is always a tendency to feel a need to make any system overly complex.
    We are taught that complex is good, as it is advanced, and it feels right. But
    in the end, simplicity usually provides the lowest total cost of ownership while
    carrying the least risk. With simple systems and simple designs there are fewer
    moving parts providing fewer opportunities for mistakes and this typically wins
    the day.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 总是有一种倾向，认为任何系统都需要过度复杂化。我们被教导复杂就是好，因为它显得先进，而且感觉是对的。但最终，简单通常能提供最低的总体拥有成本，同时承载最少的风险。使用简单的系统和设计，部件更少，出错的机会也更少，这通常会取得成功。
- en: I hope that with all of this information that you are armed with the knowledge
    and courage to approach user management in a different light. Too many user management
    solutions are chosen out of a misunderstanding that industry trends should drive
    decisions or that common solutions are far more secure than they actually are.
    What is best is always what is best for your situation and what is right for you
    is rarely what is right for someone else that you are comparing against and only
    with extreme rarity has anyone that you will compare against taken the time to
    have truly evaluated their own needs so allowing others' decisions to overly influence
    us tend to be very dangerous.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 我希望通过这些信息，你能拥有知识和勇气，从不同的角度来看待用户管理。太多的用户管理解决方案是因为误解了行业趋势应该驱动决策，或者认为常见的解决方案比实际更加安全。最好的解决方案永远是最适合你情况的，而适合你的是很少是适合别人（你所比较的对象）的，只有在极少数情况下，任何你所比较的对象都花时间真正评估过他们自己的需求，因此，允许他人的决策过度影响我们往往是非常危险的。
- en: In our next chapter, we are going to be tackling the incredibly complex and
    often confusing topic of troubleshooting.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的下一章节中，我们将要讨论一个极其复杂且常常令人困惑的话题——故障排除。
