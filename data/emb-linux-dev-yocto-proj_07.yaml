- en: '7'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '7'
- en: Assimilating Packaging Support
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 同化打包支持
- en: This chapter presents the key concepts for understanding the aspects of Poky
    and BitBake related to packaging. We will learn about the supported binary package
    formats, shared state cache, package versioning components, how to set up and
    use binary package feeds to support our development process, and more.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章介绍了理解与打包相关的 Poky 和 BitBake 方面的关键概念。我们将了解支持的二进制包格式、共享状态缓存、包版本组件，如何设置和使用二进制包源来支持我们的开发过程等内容。
- en: Using supported package formats
  id: totrans-3
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用支持的包格式
- en: From a Yocto Project perspective, a recipe may generate one or more output packages.
    A package wraps a set of files and metadata in a way that makes them available
    in the future. They can be installed into one or more images or deployed for later
    use.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 从 Yocto 项目的角度来看，一个配方可能会生成一个或多个输出包。一个包将一组文件和元数据封装起来，使其在未来可用。它们可以被安装到一个或多个镜像中，或者部署以供后续使用。
- en: Packages are critical to Poky, as they enable the build system to produce diverse
    types of artifacts, such as images and toolchains.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 包对于 Poky 至关重要，因为它们使得构建系统能够生成各种类型的工件，如镜像和工具链。
- en: List of supported package formats
  id: totrans-6
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 支持的包格式列表
- en: 'Currently, BitBake supports four different package formats:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 当前，BitBake 支持四种不同的包格式：
- en: '**Red Hat Package Manager** (**RPM**): Originally named Red Hat Package Manager
    but now known as the RPM package format since its adoption by several other Linux
    distributions, this is a popular format in use in Linux distributions such as
    SuSE, OpenSuSE, Red Hat, Fedora, and CentOS.'
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Red Hat 包管理器** (**RPM**)：最初名为 Red Hat 包管理器，但现在被称为 RPM 包格式，因为它被多个其他 Linux
    发行版采用，这是在 Linux 发行版中广泛使用的格式，如 SuSE、OpenSuSE、Red Hat、Fedora 和 CentOS。'
- en: '**Debian Package Manager** (**DEB**): This is a widespread format used in Debian
    and several other Debian-based distributions – Ubuntu Linux and Linux Mint are
    the most widely known.'
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Debian 包管理器** (**DEB**)：这是一个广泛使用的格式，应用于 Debian 和多个其他基于 Debian 的发行版——Ubuntu
    Linux 和 Linux Mint 是最广为人知的两个。'
- en: '`opkg` package manager, which supports the IPK format, is used in several distributions
    such as OpenEmbedded Core, OpenWRT, and Poky.'
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 支持 IPK 格式的 `opkg` 包管理器，已在多个发行版中使用，如 OpenEmbedded Core、OpenWRT 和 Poky。
- en: '`tarball` file type used to group several files into just a single file.'
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`tarball` 文件类型用于将多个文件打包成一个单一文件。'
- en: Choosing a package format
  id: totrans-12
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 选择包格式
- en: 'The support for formats is provided using a set of classes (i.e., `package_rpm`,
    `package_deb`, and `package_ipk`). We can select one or more formats using the
    `PACKAGE_CLASSES` variable, as shown in the following example:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 格式支持是通过一组类（例如 `package_rpm`、`package_deb` 和 `package_ipk`）提供的。我们可以使用 `PACKAGE_CLASSES`
    变量选择一个或多个格式，如以下示例所示：
- en: '![Figure 7.1 – The variable used to configure which package format to use](img/Figure_7.01_B19361.jpg)'
  id: totrans-14
  prefs: []
  type: TYPE_IMG
  zh: '![图 7.1 – 用于配置使用哪种包格式的变量](img/Figure_7.01_B19361.jpg)'
- en: Figure 7.1 – The variable used to configure which package format to use
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.1 – 用于配置使用哪种包格式的变量
- en: You can configure one or more package formats – for example, in the `build/conf/local.conf`
    file.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以配置一个或多个包格式——例如，在 `build/conf/local.conf` 文件中。
- en: Tip
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 提示
- en: The first package format in `PACKAGE_CLASSES` is the one used for image generation.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: '`PACKAGE_CLASSES` 中的第一个包格式是用于生成镜像的格式。'
- en: Poky defaults to the RPM package format, which uses the DNF package manager.
    However, the format choice depends on several factors, such as package format-specific
    features, memory, and resource usage. OpenEmbedded Core defaults to the IPK and
    `opkg` as the package manager, as it offers a smaller memory and resource usage
    footprint.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: Poky 默认使用 RPM 包格式，该格式使用 DNF 包管理器。然而，选择包格式取决于多个因素，例如特定格式的特性、内存和资源使用。OpenEmbedded
    Core 默认使用 IPK 格式和 `opkg` 作为包管理器，因为它提供了更小的内存和资源占用。
- en: On the other hand, users familiar with Debian-based systems may prefer to use
    the APT and DEB package formats for their products.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，熟悉基于 Debian 的系统的用户可能更喜欢为他们的产品使用 APT 和 DEB 包格式。
- en: Running code during package installation
  id: totrans-21
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在包安装过程中运行代码
- en: 'Packages can use scripts as part of their installation and removal process.
    The included scripts are defined as follows:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 包可以在安装和移除过程中使用脚本。所包含的脚本定义如下：
- en: '`preinst`: This executes before unpacking the package. If the package has services,
    it must stop them for installation or upgrade.'
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`preinst`：此脚本在解包包之前执行。如果包包含服务，它必须在安装或升级之前停止这些服务。'
- en: '`postinst`: After unpacking, this typically completes any required configuration
    of the package. Many `postinst` scripts execute any command necessary to start
    or restart a service after installation or upgrade.'
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`postinst`：解包后，通常完成包的任何必要配置。许多`postinst`脚本在安装或升级后执行任何必要的命令来启动或重启服务。'
- en: '`prerm`: It usually stops any daemon associated with a package before removing
    files associated with the package.'
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`prerm`：它通常在删除与包相关的文件之前停止任何与包相关的守护进程。'
- en: '`postrm`: This commonly modifies links or other files created by the package.'
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`postrm`：这通常修改包创建的链接或其他文件。'
- en: The `preinst` and `prerm` scripts target complex use cases, such as data migration
    when updating packages. In the Yocto Project case, `postinst` and `postrm` are
    also responsible for stopping and starting the `systemd` or `sysvinit` services.
    A default script is provided when we use the `systemd` and `update-rc.d` classes.
    It can be customized to include any particular case.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: '`preinst`和`prerm`脚本针对复杂的使用场景，例如在更新包时进行数据迁移。在 Yocto 项目中，`postinst`和`postrm`还负责停止和启动`systemd`或`sysvinit`服务。当我们使用`systemd`和`update-rc.d`类时，会提供默认脚本。它可以定制以包含任何特定的用例。'
- en: 'The post-package installation (`postinst`) scripts are run during the `root`
    filesystem creation. The package is marked as installed if the script returns
    a success value. To add a `postinst` script for a package, we can use the following:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 后安装（`postinst`）脚本在创建`root`文件系统时运行。如果脚本返回成功值，包会被标记为已安装。要为包添加`postinst`脚本，我们可以使用以下方法：
- en: '![Figure 7.2 – An example of the pkg_postinst script](img/Figure_7.02_B19361.jpg)'
  id: totrans-29
  prefs: []
  type: TYPE_IMG
  zh: '![图 7.2 – pkg_postinst 脚本示例](img/Figure_7.02_B19361.jpg)'
- en: Figure 7.2 – An example of the pkg_postinst script
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.2 – pkg_postinst 脚本示例
- en: 'Sometimes, we need to ensure that `postinst` runs inside the target device
    itself. This can be done using the `postinst_ontarget` variant, such as the following:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，我们需要确保`postinst`脚本在目标设备本身内运行。这可以通过使用`postinst_ontarget`变体来实现，例如以下示例：
- en: '![Figure 7.3 – An example of the pkg_postinst_ontarget script](img/Figure_7.03_B19361.jpg)'
  id: totrans-32
  prefs: []
  type: TYPE_IMG
  zh: '![图 7.3 – pkg_postinst_ontarget 脚本示例](img/Figure_7.03_B19361.jpg)'
- en: Figure 7.3 – An example of the pkg_postinst_ontarget script
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.3 – pkg_postinst_ontarget 脚本示例
- en: Tip
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 提示
- en: Instead of using the package name itself, we can use the `PN` variable, which
    automatically expands the package name of the recipe.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用`PN`变量来代替包名本身，它会自动展开配方的包名。
- en: All post-installation scripts must succeed when we generate an image with `read-only-rootfs`
    in `IMAGE_FEATURES`. Because it is impossible to write in a read-only `rootfs`,
    the check must occur during build time. It ensures that we identify the problem
    while building the image, rather than during the initial boot operation in the
    target device. If there is a requirement to run any script inside the target device,
    the `do_rootfs` task fails.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 所有后安装脚本在生成包含`read-only-rootfs`的镜像时必须成功，因为在只读`rootfs`中无法写入，检查必须在构建时进行。这确保我们在构建镜像时识别问题，而不是在目标设备的初次启动时。如果有需求在目标设备内运行任何脚本，`do_rootfs`任务将失败。
- en: Tip
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 提示
- en: Eventually, using a whole image as read-only is not an option. For example,
    some projects may need to persist some data or even allow some applications to
    write to a volatile directory. Such use cases are outside the scope of this book.
    However, you might find some helpful information in the *Yocto Project Reference
    Manual* for the `overlayfs` ([https://docs.yoctoproject.org/4.0.4/ref-manual/classes.html#overlayfs-bbclass](https://docs.yoctoproject.org/4.0.4/ref-manual/classes.html#overlayfs-bbclass))
    and `overlayfs-etc` ([https://docs.yoctoproject.org/4.0.4/ref-manual/classes.html#overlayfs-etc-bbclass](https://docs.yoctoproject.org/4.0.4/ref-manual/classes.html#overlayfs-etc-bbclass))
    classes.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 最终，将整个镜像设为只读是不可行的。例如，一些项目可能需要持久化一些数据，甚至允许某些应用程序写入一个易失的目录。此类使用场景超出了本书的范围。然而，你可能会在*Yocto
    项目参考手册*中找到有关`overlayfs`（[https://docs.yoctoproject.org/4.0.4/ref-manual/classes.html#overlayfs-bbclass](https://docs.yoctoproject.org/4.0.4/ref-manual/classes.html#overlayfs-bbclass)）和`overlayfs-etc`（[https://docs.yoctoproject.org/4.0.4/ref-manual/classes.html#overlayfs-etc-bbclass](https://docs.yoctoproject.org/4.0.4/ref-manual/classes.html#overlayfs-etc-bbclass)）类的有用信息。
- en: 'One common oversight when creating post-installation scripts is the lack of
    the `D` variable in front of absolute paths. `D` has two traits:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建后安装脚本时，一个常见的疏忽是没有在绝对路径前加上`D`变量。`D`有两个特性：
- en: During `rootfs` generation, `D` is set to the root of the working directory
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在`rootfs`生成过程中，`D`被设置为工作目录的根目录
- en: Inside the device, `D` is empty
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在设备内，`D` 是空的
- en: 'Consequently, this ensures that paths are valid in both host and target environments.
    For example, consider the following code:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，这确保了路径在主机和目标环境中都是有效的。例如，考虑以下代码：
- en: '![Figure 7.4 – Sample source code using the D variable](img/Figure_7.04_B19361.jpg)'
  id: totrans-43
  prefs: []
  type: TYPE_IMG
  zh: '![图 7.4 – 使用 D 变量的示例源代码](img/Figure_7.04_B19361.jpg)'
- en: Figure 7.4 – Sample source code using the D variable
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.4 – 使用 D 变量的示例源代码
- en: In the example in *Figure 7**.4*, the `touch` command uses the `D` variable,
    so it works generically depending on its value.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 在 *图 7.4* 中的示例中，`touch` 命令使用了 `D` 变量，因此它根据其值通用地工作。
- en: Another common mistake is attempting to run processes specific to or dependent
    on the target architecture. The easiest solution, in this case, is to postpone
    the script execution to the target (using `pkg_postinst_ontarget`). However, as
    mentioned before, this prevents the use of read-only filesystems.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个常见的错误是尝试运行特定于或依赖于目标架构的进程。在这种情况下，最简单的解决方案是将脚本执行推迟到目标（使用`pkg_postinst_ontarget`）。然而，正如之前提到的，这会阻止使用只读文件系统。
- en: Understanding shared state cache
  id: totrans-47
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解共享状态缓存
- en: The default behavior of Poky is to build everything from scratch unless BitBake
    determines that a recipe does not need to be rebuilt. The main advantage of building
    everything from scratch is that the result is fresh, and there is no risk of previous
    data causing problems. However, rebuilding everything requires computational time
    and resources.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: Poky 的默认行为是从头开始构建所有内容，除非 BitBake 确定某个配方无需重新构建。从头开始构建的主要优势是结果是全新的，并且不会有以前的数据导致问题的风险。然而，重新构建所有内容需要计算时间和资源。
- en: The strategy to determine whether a recipe must be rebuilt is complex. BitBake
    tries to track as much information as possible about every task, variable, and
    piece of code used in the build process. BitBake then generates a checksum for
    the information used by every task, including dependencies from other tasks. In
    summary, BitBake recursively tracks used variables, task source code, and dependencies
    for the recipes and their dependencies.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 判断是否需要重新构建配方的策略非常复杂。BitBake 尝试尽可能多地追踪构建过程中每个任务、变量和代码块的信息。然后，BitBake 为每个任务使用的信息生成校验和，包括来自其他任务的依赖关系。总之，BitBake
    会递归地追踪使用的变量、任务源代码和配方及其依赖关系。
- en: Poky uses all this information provided by BitBake to store snapshots of those
    tasks as a set of packaged data, generated in a cache called the shared state
    cache (`sstate-cache`). This cache wraps the contents of each task output in packages
    stored in the `SSTATE_DIR` directory. Whenever BitBake prepares to run a task,
    it first checks the existence of a `sstate-cache` package that matches the required
    computed checksum. If the package is present, BitBake uses the prebuilt package.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: Poky 使用 BitBake 提供的所有这些信息，将这些任务的快照作为一组打包数据存储在一个名为共享状态缓存（`sstate-cache`）的缓存中。这个缓存将每个任务输出的内容包装在存储在
    `SSTATE_DIR` 目录中的包中。每当 BitBake 准备运行某个任务时，它首先检查是否存在与所需的计算校验和匹配的 `sstate-cache`
    包。如果该包存在，BitBake 将使用预构建的包。
- en: The whole shared state mechanism encompasses quite complex code, and the previous
    explanation simplifies it. For a detailed description, it is advised that you
    go through the *Shared State Cache* section of the *Yocto Project Overview and
    Concepts* *Manual* ([https://docs.yoctoproject.org/4.0.4/overview-manual/concepts.html#shared-state-cache](https://docs.yoctoproject.org/4.0.4/overview-manual/concepts.html#shared-state-cache)).
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 整个共享状态机制涵盖了相当复杂的代码，前面的解释对此进行了简化。为了获得详细的描述，建议你阅读 *Yocto 项目概述和概念* *手册* 中的 *共享状态缓存*
    部分（[https://docs.yoctoproject.org/4.0.4/overview-manual/concepts.html#shared-state-cache](https://docs.yoctoproject.org/4.0.4/overview-manual/concepts.html#shared-state-cache)）。
- en: 'When using Poky for several builds, we must remember that `sstate-cache` needs
    cleaning from time to time, since it keeps growing after every build. There is
    a straightforward way of cleaning it. Use the following command from the `poky`
    directory:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用 Poky 进行多次构建时，我们必须记住，`sstate-cache` 需要定期清理，因为它在每次构建后都会不断增长。清理它有一个直接的方法。请在
    `poky` 目录下使用以下命令：
- en: '![Figure 7.5 – The command line to remove a duplicated Shared State Cache](img/Figure_7.05_B19361.jpg)'
  id: totrans-53
  prefs: []
  type: TYPE_IMG
  zh: '![图 7.5 – 移除重复的共享状态缓存的命令行](img/Figure_7.05_B19361.jpg)'
- en: Figure 7.5 – The command line to remove a duplicated Shared State Cache
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.5 – 移除重复的共享状态缓存的命令行
- en: Tip
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 提示
- en: 'When we need to rebuild from scratch, we can do either of the following:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们需要从头开始重新构建时，可以执行以下任一操作：
- en: Remove `build/tmp` so that we can use `sstate-cache` to speed up the build
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 删除 `build/tmp` 以便我们可以使用 `sstate-cache` 来加速构建
- en: Remove both `build/tmp` and `sstate-cache` so that no cache is reused during
    the build
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 删除 `build/tmp` 和 `sstate-cache`，以便在构建过程中不重用任何缓存
- en: Explaining package versioning
  id: totrans-59
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 解释包版本控制
- en: Package versioning is used to differentiate the same package in distinct stages
    of its life cycle. From Poky’s perspective, it is also used as part of the equation
    that generates the checksum used by BitBake to verify whether a task must be rebuilt.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 包版本控制用于区分同一包在其生命周期不同阶段的版本。从 Poky 的角度来看，它也作为生成 BitBake 用于验证是否需要重新构建任务的校验和的公式的一部分。
- en: 'The package version, also known as `PV`, plays a leading role when we select
    which recipe to build. The default behavior of Poky is always to prefer the newest
    recipe version unless there is a different explicit preference, as discussed in
    [*Chapter 5*](B19361_05.xhtml#_idTextAnchor077), *Grasping the BitBake Tool*.
    For example, let’s suppose that we have two versions of the `myrecipe` recipe:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 包版本，也称为 `PV`，在我们选择构建哪个配方时起着主导作用。Poky 的默认行为是总是优先选择最新的配方版本，除非有其他明确的偏好，如[*第5章*](B19361_05.xhtml#_idTextAnchor077)《掌握
    BitBake 工具》中所讨论的那样。例如，假设我们有两个版本的 `myrecipe` 配方：
- en: '`myrecipe_1.0.bb`'
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`myrecipe_1.0.bb`'
- en: '`myrecipe_1.1.bb`'
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`myrecipe_1.1.bb`'
- en: BitBake, by default, builds the recipe with version `1.1`. Inside the recipe,
    we may have other variables that compose package versioning with the `PV` variable.
    These are the `PE`, and the `PR`.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，BitBake 会构建版本为 `1.1` 的配方。在配方内部，我们可能有其他变量与 `PV` 变量共同组成包的版本信息。这些变量是 `PE`
    和 `PR`。
- en: 'Those variables normally follow this pattern:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 这些变量通常遵循以下模式：
- en: '![Figure 7.6 – A complete versioning pattern](img/Figure_7.06_B19361.jpg)'
  id: totrans-66
  prefs: []
  type: TYPE_IMG
  zh: '![图 7.6 – 完整的版本模式](img/Figure_7.06_B19361.jpg)'
- en: Figure 7.6 – A complete versioning pattern
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.6 – 完整的版本模式
- en: The `PE` variable has a default value of zero. It is used when the package version
    schema is changed, breaking the possibility of usual ordering. `PE` is prepended
    in the package version, forcing a higher number when needed.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: '`PE` 变量的默认值为零。当包版本模式发生变化，打破常规排序的可能性时，`PE` 会被使用。`PE` 会被加到包版本中，在需要时强制使用更高的数字。'
- en: For example, suppose a package uses the date to compose `PV` variables such
    as `20220101`, and there is a version schema change to release the `1.0` version.
    It is impossible to determine whether version `1.0` is higher than version `20220101`.
    So, `PE = "1"` is used to change the recipe epoch, forcing version `1.0` to be
    higher than `20220101`, since `1:1.0` is greater than `0:20220101`.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，假设一个包使用日期来构成 `PV` 变量，如 `20220101`，并且有版本模式更改来发布 `1.0` 版本。那么，无法确定版本 `1.0` 是否高于版本
    `20220101`。因此，使用 `PE = "1"` 来更改配方纪元，强制版本 `1.0` 高于版本 `20220101`，因为 `1:1.0` 大于 `0:20220101`。
- en: The `PR` variable has a default value of `r0` and is a part of package versioning.
    When it is updated, it forces BitBake to rebuild all tasks of a specific recipe.
    We can update it manually in the recipe metadata to force a rebuild we know is
    needed. Still, it is fragile because it relies on human interaction and knowledge.
    BitBake uses task checksums to control what needs to be rebuilt. The manual `PR`
    increment is only used in rare cases when the task checksum does not change.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: '`PR` 变量的默认值为 `r0`，并且是包版本的一部分。当它被更新时，会强制 BitBake 重新构建特定配方的所有任务。我们可以在配方元数据中手动更新它，以强制我们知道需要重新构建的内容。但这是一种脆弱的做法，因为它依赖于人工干预和知识。BitBake
    使用任务校验和来控制需要重新构建的内容。手动递增 `PR` 仅在任务校验和没有变化时在极少数情况下使用。'
- en: Specifying runtime package dependencies
  id: totrans-71
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 指定运行时包依赖关系
- en: The results of most recipes are packages managed by the package manager. As
    we saw in the previous sections, it requires information about all those packages
    and how they relate. For example, a package may depend on or conflict with another.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数配方的结果是由包管理器管理的包。正如我们在前面几节中看到的，它需要关于这些包及其相互关系的信息。例如，一个包可能依赖或与另一个包冲突。
- en: Constraints exist within multiple package relationships; however, those constraints
    are package format-specific, so BitBake has specific metadata to abstract those
    constraints.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 包之间存在多重约束关系；然而，这些约束是特定于包格式的，因此 BitBake 有特定的元数据来抽象这些约束。
- en: 'Here is a list of the most used package runtime constraints:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是最常用的包运行时约束的列表：
- en: '`RDEPENDS`: The list of packages must be available at runtime, along with the
    package that defines it.'
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`RDEPENDS`：必须在运行时可用的包列表，连同定义它的包一起使用。'
- en: '`RPROVIDES`: This is the list of symbolic names a package provides. By default,
    a package always includes the package name as a symbolic name. It can also include
    alternative symbolic names provided by that package.'
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`RPROVIDES`：这是软件包提供的符号名称列表。默认情况下，软件包始终将软件包名称作为符号名称。它也可以包括该软件包提供的其他符号名称。'
- en: '`RCONFLICTS`: This is the list of packages known to conflict with the package.
    The final image must not include conflicting packages.'
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`RCONFLICTS`：这是已知与该软件包冲突的软件包列表。最终的镜像必须不包括冲突的软件包。'
- en: '`RREPLACES`: This is a list of symbolic names that the package can replace.'
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`RREPLACES`：这是一个符号名称列表，表示软件包可以替换的名称。'
- en: 'A full recipe, from `meta/recipes-devtools/python/python3-dbus_1.2.18.bb`,
    is as follows:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 来自`meta/recipes-devtools/python/python3-dbus_1.2.18.bb`的完整配方如下：
- en: '![Figure 7.7 – An example of how to use RDEPENDS](img/Figure_7.07_B19361.jpg)'
  id: totrans-80
  prefs: []
  type: TYPE_IMG
  zh: '![图 7.7 – 如何使用 RDEPENDS 的示例](img/Figure_7.07_B19361.jpg)'
- en: Figure 7.7 – An example of how to use RDEPENDS
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.7 – 如何使用 RDEPENDS 的示例
- en: The recipe from *Figure 7**.6* shows that the `python3-dbus` package has a list
    of runtime dependencies on several Python modules, on line 21.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 7.6*中的配方显示，`python3-dbus`软件包在第21行列出了几个Python模块的运行时依赖关系。'
- en: Using packages to generate a rootfs image
  id: totrans-83
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用软件包生成 rootfs 镜像
- en: 'One of the most common uses of Poky is the `rootfs` image generation. The `rootfs`
    image should be seen as a ready-to-use root filesystem for a target. The image
    can be composed of one or more filesystems. It may include other artifacts available
    during its generation, such as the Linux kernel, the device tree, and bootloader
    binaries. The process of generating the image is composed of several steps. Its
    most common uses are as follows:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: Poky最常用的功能之一是`rootfs`镜像生成。`rootfs`镜像应该视为一个用于目标的可用根文件系统。该镜像可以由一个或多个文件系统组成。它可能包括在生成过程中可用的其他工件，如Linux内核、设备树和引导加载程序二进制文件。生成镜像的过程包含多个步骤，其最常见的用途如下：
- en: Generating the `rootfs` directory
  id: totrans-85
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 生成`rootfs`目录
- en: Creating the required files
  id: totrans-86
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建所需的文件
- en: Wrapping the final filesystem according to the specific requirements (it may
    be a disk file with several partitions and contents)
  id: totrans-87
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 根据特定需求封装最终的文件系统（它可能是一个包含多个分区和内容的磁盘文件）
- en: Finally, compressing it, if applicable
  id: totrans-88
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，如果适用的话，进行压缩
- en: The sub-tasks of `do_rootfs` perform all these steps. `rootfs` is a directory
    with the desired packages installed, with the required tweaks applied afterward.
    The tweaks make minor adjustments to the `rootfs` contents – for example, when
    building a development image, `rootfs` is adjusted to allow us to log in as `root`
    without a password.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: '`do_rootfs`的子任务执行所有这些步骤。`rootfs`是一个包含所需软件包并且之后应用了必要调整的目录。这些调整对`rootfs`的内容进行细微修改——例如，在构建开发镜像时，`rootfs`会被调整，以便我们可以无密码登录为`root`。'
- en: The list of packages to be installed into `rootfs` is defined by a union of
    packages listed by `IMAGE_INSTALL` and the packages included with `IMAGE_FEATURES`;
    image customization is detailed in [*Chapter 12*](B19361_12.xhtml#_idTextAnchor147),
    *Creating Custom Layers*. Each image feature can include extra packages for installation
    – for example, `dev-pkgs`, which installs development libraries and headers of
    all packages listed to be installed in `rootfs`.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 要安装到`rootfs`中的软件包列表由`IMAGE_INSTALL`列出的软件包和`IMAGE_FEATURES`中包含的软件包的联合定义；镜像定制的详细信息见[*第
    12 章*](B19361_12.xhtml#_idTextAnchor147)，*创建自定义层*。每个镜像功能可以包括额外的软件包供安装——例如，`dev-pkgs`，它安装列出要安装到`rootfs`中的所有软件包的开发库和头文件。
- en: The list of packages to be installed is now filtered by the `PACKAGE_EXCLUDE`
    variable, which lists the packages that should not be installed. The packages
    listed in `PACKAGE_EXCLUDE` are only excluded from the list of packages to be
    explicitly installed.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 要安装的软件包列表现在由`PACKAGE_EXCLUDE`变量过滤，该变量列出了不应安装的软件包。列在`PACKAGE_EXCLUDE`中的软件包仅从明确要安装的软件包列表中排除。
- en: With the final set of packages to install, the `do_rootfs` task can initiate
    the process of unpacking and configuring each package, and its required dependencies,
    into the `rootfs` directory. The `rootfs` generation uses the local package feed,
    which we will cover in the next section.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 在确定最终安装的软件包列表后，`do_rootfs`任务可以启动解包并配置每个软件包及其所需的依赖项到`rootfs`目录中。`rootfs`生成使用本地软件包源，我们将在下一节中介绍。
- en: With the `rootfs` contents unpacked, the non-target post-installation scripts
    of the referred packages must run to avoid the penalty of running them during
    the first boot.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 在解压 `rootfs` 内容后，必须运行所引用软件包的非目标后安装脚本，以避免在第一次启动时执行它们带来的惩罚。
- en: Now, the directory is ready to generate the filesystem. `IMAGE_FSTYPES` lists
    the filesystem to be generated – for example, **EXT4** or **UBIFS**.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，目录已经准备好生成文件系统了。`IMAGE_FSTYPES` 列出了将要生成的文件系统类型——例如，**EXT4** 或 **UBIFS**。
- en: After the `do_rootfs` task has finished, the generated image file is placed
    in `build/tmp/deploy/image/<machine>/`. The process of creating our image and
    the possible values for `IMAGE_FEATURES` and `IMAGE_FSTYPES` are described in
    [*Chapter 12*](B19361_12.xhtml#_idTextAnchor147), *Creating* *Custom Layers*.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `do_rootfs` 任务完成后，生成的镜像文件会被放置在 `build/tmp/deploy/image/<machine>/` 目录下。创建镜像的过程及
    `IMAGE_FEATURES` 和 `IMAGE_FSTYPES` 的可能值在[*第12章*](B19361_12.xhtml#_idTextAnchor147)《创建自定义层》中有详细描述。
- en: Package feeds
  id: totrans-96
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 软件包源
- en: As discussed in [*Chapter 5*](B19361_05.xhtml#_idTextAnchor077), *Grasping the
    BitBake Tool*, packages play a vital role, as images and `do_rootfs` uses a local
    repository to fetch binary packages when generating those artifacts. This repository
    is known as a package feed.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 如在[*第5章*](B19361_05.xhtml#_idTextAnchor077)《掌握 BitBake 工具》中讨论的那样，软件包在生成镜像时起着至关重要的作用，因为
    `do_rootfs` 会使用本地仓库来获取二进制软件包。这个仓库被称为软件包源。
- en: 'There is no reason for this repository to be used just for the images or SDK
    build steps. Several valid reasons exist for making this repository remotely accessible,
    either internally in our development environment or publicly. Some of these reasons
    are as follows:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 这个仓库不应该仅仅用于镜像或 SDK 构建步骤。将此仓库设置为可远程访问是有多个合理原因的，既可以在我们的开发环境中内部使用，也可以公开访问。以下是其中的一些原因：
- en: You can easily test an updated application during the development stage, without
    requiring a complete system re-installation
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可以在开发阶段轻松测试更新后的应用程序，而无需重新安装整个系统。
- en: You can make additional packages more flexible so that they can be installed
    in a running image
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可以使附加软件包更加灵活，以便它们能够安装到运行中的镜像中
- en: You can update products in the field
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可以在现场更新产品
- en: To produce a solid package feed, we must ensure that we have consistent increments
    in the package revision every time the package is changed. It is almost impossible
    to do this manually, and the Yocto Project has a `PR` service specifically designed
    to help with this.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 为了生成一个稳定的软件包源，我们必须确保每次更改软件包时，软件包的修订版本都有一致的递增。手动实现这一点几乎是不可能的，Yocto 项目提供了一个专门的
    `PR` 服务来帮助实现这一目标。
- en: The `PR` without human interaction every time BitBake detects a checksum change
    in a task. It injects a suffix in `PR` in the `${PR}.X` format. For example, if
    we have `PR = "r34"` after subsequent `PR` service interactions, the `PR` value
    becomes `r34.1`, `r34.2`, `r34.3`, and so on. The use of the `PR` service is critical
    for solid package feeds, as it requires the version to increase linearly.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 每次 BitBake 检测到任务中的校验和变化时，`PR` 会在没有人工干预的情况下自动增加。它会以 `${PR}.X` 的格式在 `PR` 中注入一个后缀。例如，如果我们有
    `PR = "r34"`，那么在后续的 `PR` 服务交互后，`PR` 值将变为 `r34.1`、`r34.2`、`r34.3`，以此类推。使用 `PR`
    服务对于稳定的软件包源至关重要，因为它要求版本号按线性顺序增加。
- en: Tip
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 提示
- en: Even though we ought to use the `PR` service to have solid package versioning,
    it does not preclude the need to set `PR` manually in exceptional cases.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 即使我们应该使用 `PR` 服务来确保稳定的软件包版本管理，但在特殊情况下，仍然需要手动设置 `PR`。
- en: 'By default, the `PR` service is not enabled or running. We can enable it to
    run locally by adding the `PRSERV_HOST` variable in the BitBake configuration
    – for example, in `build/conf/local.conf`, as in the following:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，`PR` 服务并未启用或运行。我们可以通过在 BitBake 配置中添加 `PRSERV_HOST` 变量来启用它进行本地运行——例如，在
    `build/conf/local.conf` 中，配置如下：
- en: '![Figure 7.8 – How to configure a PR service to run locally](img/Figure_7.08_B19361.jpg)'
  id: totrans-107
  prefs: []
  type: TYPE_IMG
  zh: '![图 7.8 – 如何配置 PR 服务以本地运行](img/Figure_7.08_B19361.jpg)'
- en: Figure 7.8 – How to configure a PR service to run locally
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.8 – 如何配置 PR 服务以本地运行
- en: This approach is adequate when the build happens on a single computer, which
    builds every package of the package feed. BitBake starts and stops the server
    at each build and automatically increases the required `PR` values.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 当构建发生在单台计算机上时，这种方法是足够的，构建过程会处理软件包源中的每一个软件包。BitBake 在每次构建时启动和停止服务器，并自动增加所需的 `PR`
    值。
- en: 'For a more complex setup, with multiple computers working against a shared
    package feed, we must have a single `PR` service running, used by all building
    systems associated with the package feed. In this case, we need to start the `PR`
    service in the server using the `bitbake-prserv` command, shown as follows:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 对于更复杂的设置，多个计算机共同使用共享包源时，我们必须运行一个单一的 `PR` 服务，所有与包源相关的构建系统都需使用该服务。在这种情况下，我们需要在服务器上通过
    `bitbake-prserv` 命令启动 `PR` 服务，如下所示：
- en: '![Figure 7.9 – The command line to initiate the PR service server](img/Figure_7.09_B19361.jpg)'
  id: totrans-111
  prefs: []
  type: TYPE_IMG
  zh: '![图 7.9 – 启动 PR 服务服务器的命令行](img/Figure_7.09_B19361.jpg)'
- en: Figure 7.9 – The command line to initiate the PR service server
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.9 – 启动 PR 服务服务器的命令行
- en: In addition to manually-starting the service, we need to update the BitBake
    configuration file (for example, `build/conf/local.conf`) of each build system,
    which connects to a server using the `PRSERV_HOST` variable, as described earlier,
    so that each system points to the server `IP` and `port`.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 除了手动启动服务外，我们还需要更新每个构建系统的 BitBake 配置文件（例如 `build/conf/local.conf`），该文件通过 `PRSERV_HOST`
    变量连接到服务器，如前所述，以便每个系统指向服务器的 `IP` 和 `port`。
- en: Using package feeds
  id: totrans-114
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用包源
- en: 'To use package feeds, the following two components are required:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 使用包源时，以下两个组件是必需的：
- en: The server provides access to the packages
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 服务器提供对包的访问
- en: The client accesses the server and downloads the required packages
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 客户端访问服务器并下载所需的包
- en: 'The set of packages offered by the package feed is determined by the recipes
    we build. We can build one or more recipes and offer them, or build a set of images
    to generate the desired packages. Once satisfied with the packages offered, we
    must create the package index provided by the package feeds. The following command
    performs this:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 包源提供的包集由我们构建的配方决定。我们可以构建一个或多个配方并提供它们，或者构建一组镜像以生成所需的包。一旦对所提供的包满意，我们必须创建包源提供的包索引。以下命令可执行此操作：
- en: '![Figure 7.10 – The command line to create the package index](img/Figure_7.10_B19361.jpg)'
  id: totrans-119
  prefs: []
  type: TYPE_IMG
  zh: '![图 7.10 – 创建包索引的命令行](img/Figure_7.10_B19361.jpg)'
- en: Figure 7.10 – The command line to create the package index
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.10 – 创建包索引的命令行
- en: The packages are available inside the `build/tmp/deploy` directory. We must
    choose the respective sub-directory depending on the package format chosen. Poky
    uses RPM by default, so we must serve the content of the `build/tmp/deploy/rpm`
    directory.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 包可以在 `build/tmp/deploy` 目录中找到。我们必须根据所选的包格式选择相应的子目录。默认情况下，Poky 使用 RPM，因此我们必须提供
    `build/tmp/deploy/rpm` 目录中的内容。
- en: Tip
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 提示
- en: Make sure to run `bitbake package-index` after building all packages; otherwise,
    the package index will not include them.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 确保在构建所有包后运行 `bitbake package-index`，否则包索引将不包含这些包。
- en: 'The package index and packages must be made available through a transfer protocol
    such as HTTP. We can use any server we wish for this task, such as Apache, Nginx,
    and Lighttpd. A convenient way to make the packages available through HTTP for
    local development is by using the Python simple HTTP server, shown as follows:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 包索引和包必须通过传输协议（如 HTTP）提供。我们可以使用任何服务器来执行此任务，例如 Apache、Nginx 和 Lighttpd。为了方便在本地开发中通过
    HTTP 提供包，可以使用 Python 简单的 HTTP 服务器，如下所示：
- en: '![Figure 7.11 – How to provide the package feed by using the Python simple
    HTTP server](img/Figure_7.11_B19361.jpg)'
  id: totrans-125
  prefs: []
  type: TYPE_IMG
  zh: '![图 7.11 – 如何使用 Python 简单 HTTP 服务器提供包源](img/Figure_7.11_B19361.jpg)'
- en: Figure 7.11 – How to provide the package feed by using the Python simple HTTP
    server
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.11 – 如何使用 Python 简单 HTTP 服务器提供包源
- en: 'To add support for package management to the image, we have a couple of changes
    to make. We need to add `package-management` in `EXTRA_IMAGE_FEATURES` and set
    the URI for package fetching on `PACKAGE_FEED_URIS`. For example, we can add this
    to our `build/conf/local.conf`:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 为了向镜像中添加包管理支持，我们需要做一些更改。我们需要在 `EXTRA_IMAGE_FEATURES` 中添加 `package-management`，并在
    `PACKAGE_FEED_URIS` 中设置包获取的 URI。例如，我们可以将其添加到 `build/conf/local.conf` 中：
- en: '![Figure 7.12 – How to configure a remote package feed](img/Figure_7.12_B19361.jpg)'
  id: totrans-128
  prefs: []
  type: TYPE_IMG
  zh: '![图 7.12 – 如何配置远程包源](img/Figure_7.12_B19361.jpg)'
- en: Figure 7.12 – How to configure a remote package feed
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.12 – 如何配置远程包源
- en: We will detail the `IMAGE_FEATURES` and `EXTRA_IMAGE_FEATURES` variables in
    [*Chapter 12*](B19361_12.xhtml#_idTextAnchor147), *Creating Custom Layers*. If
    we want a small image with no package management support, we should omit `package-management`
    from `EXTRA_IMAGE_FEATURES`.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在[*第12章*](B19361_12.xhtml#_idTextAnchor147)《创建自定义层》中详细讲解`IMAGE_FEATURES`和`EXTRA_IMAGE_FEATURES`变量。如果我们想要一个不支持软件包管理的小型镜像，应该从`EXTRA_IMAGE_FEATURES`中省略`package-management`。
- en: The `PACKAGE_FEED_URIS` and `EXTRA_IMAGE_FEATURES` configurations guarantee
    that the image on the client side can access the server and has the utilities
    needed to install, remove, and upgrade its packages. After these steps, we can
    use the runtwime package management in the target device.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: '`PACKAGE_FEED_URIS`和`EXTRA_IMAGE_FEATURES`配置确保客户端上的镜像可以访问服务器，并且具备安装、删除和升级软件包所需的工具。在完成这些步骤后，我们可以在目标设备上使用运行时软件包管理。'
- en: 'For example, if we choose the RPM package format for the image, we can fetch
    the repository information using the following command:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果我们为镜像选择RPM软件包格式，可以使用以下命令获取仓库信息：
- en: '![Figure 7.13 – Command line to fetch the package feed repository](img/Figure_7.13_B19361.jpg)'
  id: totrans-133
  prefs: []
  type: TYPE_IMG
  zh: '![图7.13 – 获取软件包源仓库的命令行](img/Figure_7.13_B19361.jpg)'
- en: Figure 7.13 – Command line to fetch the package feed repository
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.13 – 获取软件包源仓库的命令行
- en: Use the `dnf search <package>`, and `dnf install <package>` commands to find
    and install packages from the repositories.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`dnf search <package>`和`dnf install <package>`命令可以从仓库中查找并安装软件包。
- en: 'Depending on the package format chosen, the commands for the target to update
    the package index, search for, and install a package are different. See the available
    command lines for each package format in the following table:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 根据选择的软件包格式，目标设备更新软件包索引、查找和安装软件包的命令是不同的。请参阅下表中针对每种软件包格式提供的命令行：
- en: '| **Package format** | **RPM** | **IPK** | **DEB** |'
  id: totrans-137
  prefs: []
  type: TYPE_TB
  zh: '| **软件包格式** | **RPM** | **IPK** | **DEB** |'
- en: '| Update the package index | `dnf check-updates` | `opkg update` | `apt-get
    update` |'
  id: totrans-138
  prefs: []
  type: TYPE_TB
  zh: '| 更新软件包索引 | `dnf check-updates` | `opkg update` | `apt-get update` |'
- en: '| Search for a package | `dnf search``<``package>` | `opkg search``<``package>`
    | `apt-cache search``<``package>` |'
  id: totrans-139
  prefs: []
  type: TYPE_TB
  zh: '| 查找软件包 | `dnf search``<``package>` | `opkg search``<``package>` | `apt-cache
    search``<``package>` |'
- en: '| Install a package | `dnf install``<``package>` | `opkg install``<``package>`
    | `apt-get install``<``package>` |'
  id: totrans-140
  prefs: []
  type: TYPE_TB
  zh: '| 安装软件包 | `dnf install``<``package>` | `opkg install``<``package>` | `apt-get
    install``<``package>` |'
- en: '| System upgrade | `dnf upgrade` | `opkg upgrade` | `apt-get` `dist- upgrade`
    |'
  id: totrans-141
  prefs: []
  type: TYPE_TB
  zh: '| 系统升级 | `dnf upgrade` | `opkg upgrade` | `apt-get` `dist-upgrade` |'
- en: Table 7.1 – A package management command comparison
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 表7.1 – 软件包管理命令比较
- en: The use of package feeds are great to use in a local development phase because
    they enable us to install packages in an already deployed image.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 在本地开发阶段使用软件包源非常有利，因为它们使我们能够在已经部署的镜像中安装软件包。
- en: Note
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: The use of package feeds for system upgrades in the field requires a huge test
    effort to guarantee that a system does not fall into a broken state. The testing
    effort is enormous to verify all different upgrade scenarios. Usually, full image
    upgrades are safer for production use.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 在实际使用中，使用软件包源进行系统升级需要大量的测试工作，以确保系统不会进入损坏状态。验证所有不同的升级场景需要巨大的测试工作量。通常，完整的镜像升级对于生产环境的使用来说更为安全。
- en: The management of a package feed is much more complex. It involves several other
    aspects, such as package dependency chains and different upgrade scenarios. Creating
    a complex package feed external server is out of this book’s scope, so please
    refer to the Yocto Project documentation for further details.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 软件包源的管理要复杂得多，它涉及到多个方面，如软件包依赖链和不同的升级场景。创建复杂的软件包源外部服务器超出了本书的范围，因此请参阅Yocto项目文档以获取更多详细信息。
- en: Summary
  id: totrans-147
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: This chapter presented the basic concepts of packaging, which has a significant
    role in Poky and BitBake (package versioning), and how this impacts Poky’s behavior
    when rebuilding packages and package feeds. It also showed us how to configure
    an image to be updated using prebuilt packages provided by a remote server.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 本章介绍了打包的基本概念，这在Poky和BitBake中扮演着重要角色（软件包版本控制），并且阐明了在重新构建软件包和软件包源时，如何影响Poky的行为。还展示了如何配置镜像，以便使用远程服务器提供的预构建软件包进行更新。
- en: In the next chapter, we will learn about the BitBake metadata syntax and its
    operators and how to append, prepend, and remove content from variables, variable
    expansions, and so on. We will then be able to better understand the language
    used in Yocto Project engines.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将学习关于 BitBake 元数据语法及其操作符的内容，以及如何向变量、变量扩展等追加、前置和移除内容。然后我们将能够更好地理解 Yocto
    项目引擎中使用的语言。
