<html><head></head><body>
<div id="sbo-rt-content"><div class="Basic-Text-Frame" id="_idContainer059">
<h1 class="chapterNumber">3</h1>
<h1 class="chapterTitle" id="_idParaDest-56">Managing Software Packages</h1>
<p class="normal">Now that you have a server installation set up, and you know how to manage users on it, it’s time to cover the management of software. The Ubuntu platform has a huge range of software available, featuring packages for everything from server administration to games. In fact, as of the time I’m writing this chapter, there are over 60,000 packages in Ubuntu’s repositories. That’s a lot of software packages, and in this chapter, we’ll take a look at how to manage them. We’ll cover how to install, remove, and update packages, as well as the use of related tools.</p>
<p class="normal">As we go through these concepts, we will cover:</p>
<ul>
<li class="bulletList">Understanding Linux package management</li>
<li class="bulletList">Understanding the differences between Debian and Snap packages</li>
<li class="bulletList">Installing and removing software</li>
<li class="bulletList">Searching for packages</li>
<li class="bulletList">Managing package repositories</li>
<li class="bulletList">Backing up and restoring Debian packages</li>
<li class="bulletList">Cleaning up orphaned APT packages</li>
<li class="bulletList">Taking advantage of hardware enablement updates</li>
</ul>
<p class="normal">To get started, let’s build an understanding of how software packages are distributed in Ubuntu, and the basic principles of the concept of package management.</p>
<h1 class="heading-1" id="_idParaDest-57">Understanding Linux package management</h1>
<p class="normal">Nowadays, <em class="italic">app stores</em> are <a id="_idIndexMarker158"/>all the rage on most platforms; typically, you’ll have one central location from which to retrieve applications, allowing you to install them on your device. Even phones and tablets utilize a central software repository in which software is curated and made available. The Android platform has Google Play, Apple has its App Store, and so on. For those that have used Linux for a while, this concept isn’t new. The concept of software repositories is similar to that of app stores and has been around within the Linux community since long before cellular phones even had color screens.</p>
<p class="normal">Linux has had package management since the ‘90s, initially<a id="_idIndexMarker159"/> popularized by <strong class="keyWord">Debian</strong> and <a id="_idIndexMarker160"/>then <strong class="keyWord">Red Hat</strong>. Software repositories are generally made available in the form of <strong class="keyWord">mirrors</strong>, to which your server subscribes. Mirrors are available across a multitude of geographic areas, so, typically, your installation of Ubuntu Server would subscribe to the mirror closest to you. These mirrors are populated with software packages that you’ll be able to install. Many packages depend on other packages, so various tools on the Linux platform exist to automatically handle these dependencies for you. Not all distributions of Linux feature package management and dependency resolution, but Ubuntu certainly does, benefiting from the groundwork already built by Debian.</p>
<p class="normal">Packages contained within these mirrors are constantly changing. Traditionally, an individual known<a id="_idIndexMarker161"/> as a <strong class="keyWord">package maintainer</strong> is responsible for one or more packages and ships new versions<a id="_idIndexMarker162"/> to the repositories for approval and, eventually, distribution to mirrors. Specific to Ubuntu’s repositories, a group of developers, rather than just a single maintainer, is responsible for maintaining packages. Most of the time, the new version of a package is provided in order to patch a security vulnerability, but otherwise it contains no new features. With the majority of Ubuntu’s packages being open source, anyone is able to look at the source code, find problems, and report issues. When vulnerabilities are found, the responsible team will review the claim and then release an updated version to correct it. This process happens very quickly, and I’ve seen severe vulnerabilities patched even on the same day that they were reported in some cases. Ubuntu developers are definitely on top of their game in terms of taking care of security issues.</p>
<p class="normal">New versions of packages are also sometimes feature updates, which are updates released to introduce new features not necessarily tied to a security vulnerability. This could be a new version of a desktop application such as Firefox or a server package such as MySQL. Most of the time, though, new versions of packages that are vastly different are held for the next Ubuntu release. The reason for this is that too much change can cause your server to not be as stable, and experience application or even entire OS-level crashes. Instead, known working and stable packages are preferred; however, given the fact that Ubuntu releases every six months, you don’t have to wait very long.</p>
<p class="normal">Specifically, feature updates in an Ubuntu release must go through an approval process before being made available in the default repositories, and these feature updates are specifically referred <a id="_idIndexMarker163"/>to as <strong class="keyWord">Stable Release Updates</strong> (<strong class="keyWord">SRUs</strong>). There’s an entire process around how these updates are approved, but the general takeaway is that there should be a good reason to implement a major version change in a stable, long-term Ubuntu release.</p>
<p class="normal">As a server administrator, you’ll often need to make a choice between security and feature updates. Security updates are the most important of all and allow you to patch your servers in response to security vulnerabilities. Sometimes, feature updates become required in your organization because it’s decided that new features may benefit you or may become required for current objectives. In this chapter, we won’t focus on installing security updates (we’ll take care of that in <em class="chapterRef">Chapter 21</em>, <em class="italic">Securing Your Server</em>), but it’s important to understand the reasons new packages are made available to you.</p>
<p class="normal">Package management is typically very convenient in Ubuntu, with security updates and bug fixes coming regularly. With just one command (which we’ll get to shortly), you can install a package along with all of its dependencies. Having performed manual dependency resolution myself, I can tell you first-hand that having dependencies handled automatically is a wonderful thing. </p>
<p class="normal">The main benefit of how packages are maintained on a<a id="_idIndexMarker164"/> Linux server is that you generally don’t have to search the internet for packages to download, as Ubuntu’s repositories contain most of the ones you’ll ever need. As we continue through this chapter, you’ll come to know everything you need in order to manage this software.</p>
<h1 class="heading-1" id="_idParaDest-58">Understanding the differences between Debian and Snap packages</h1>
<p class="normal">Now, before<a id="_idIndexMarker165"/> we<a id="_idIndexMarker166"/> get into the ins and outs of managing packages, there are actually two completely different types of packages available to you, and you should understand the differences between them. As of the time of writing, we’re at a kind of crossroads regarding the way in which software is managed in Linux.</p>
<p class="normal">Traditionally, each distribution has its own package format and its own utilities to manage them. Ubuntu <a id="_idIndexMarker167"/>utilizes <strong class="keyWord">Debian packages</strong> (with package names ending in <code class="inlineCode">.deb</code>) as the main package format, which Ubuntu inherits from the Debian distribution (Ubuntu is forked from Debian, which means that it uses Debian as a foundation). Ubuntu and Debian utilize the <code class="inlineCode">apt</code> and <code class="inlineCode">dpkg</code> commands to manage packages. On the other hand, distributions such as CentOS and Red Hat use <strong class="keyWord">RPM packages</strong> for<a id="_idIndexMarker168"/> their distributions, and the <code class="inlineCode">dnf</code> command to manage them. There are other distributions<a id="_idIndexMarker169"/> and package formats as well, but<a id="_idIndexMarker170"/> for this book, we’ll stick with what’s available in Ubuntu. First, let’s discuss Debian packages.</p>
<h2 class="heading-2" id="_idParaDest-59">Debian packages</h2>
<p class="normal"><strong class="keyWord">Debian packages</strong> have <a id="_idIndexMarker171"/>been the main type of package in Ubuntu for the entire existence of the distribution so far. When you search online for how to install something in Ubuntu, chances are, you’re going to be installing a Debian package. These packages are known as Debian packages because Ubuntu is built from Debian sources and utilizes the same commands in order to install these packages. So even though Ubuntu is not Debian (Debian is a completely different distribution), they both use the same package format primarily.</p>
<p class="normal">The naming may be confusing for newcomers, because if Ubuntu is considered a different distribution than Debian, then why refer to its packages as “Debian” packages? Debian packages have a filename that ends in <code class="inlineCode">.deb</code>, and this package format originated in Debian. Ubuntu didn’t develop its own package type; it uses the same package format as Debian. Therefore, whether we are installing packages in Debian or Ubuntu using a command such as <code class="inlineCode">apt</code>, Debian packages are the type of packages used for both.</p>
<p class="normal">If you’ve worked with Ubuntu before reading this book, then chances are, you’ve already used the <code class="inlineCode">apt</code> series of commands to carry out some package management. Debian packages are great because when paired with the <code class="inlineCode">apt</code> command, they are easy to use and handle dependency resolution for you. However, they present some challenges and major drawbacks.</p>
<p class="normal">First, the majority of the distribution is made up of Debian packages. This means that the Linux kernel, system packages, libraries, and security updates are all Debian packages that are installed when you install Ubuntu Server. When you install security updates, Debian packages are installed. The reason this may be a problem is that other software you’ll be installing, such as Apache, MariaDB, and so on, are also Debian packages, and may conflict with system packages when one package requires a pre-requisite package that conflicts with another. </p>
<p class="normal">This can lead to a situation where you can’t install packages at all. Package maintainers are generally good at avoiding this scenario, so conflicts aren’t incredibly common nowadays.</p>
<p class="normal">However, with Debian packages, if a system library gets corrupted, literally every piece of software that depends on it will fail. Ubuntu developers pay a great deal of attention to this, so you shouldn’t run into issues. But the truth is, this is a lot of work for the maintainers of Ubuntu to deal with.</p>
<p class="normal">Another concern with Debian packages is software availability. When a new major version of a package is released, it generally will not be offered to you until the next release of the distribution. This means that if you want a version of PHP, Apache, or some other piece of software that’s newer than what your current release of Ubuntu features, you generally will not have it offered to you. Instead, you typically wait until the next release of the entire distribution. There are some exceptions to this, such as Firefox in the desktop version of Ubuntu. As mentioned before, new major package versions are exceptions to the rule and come from the SRU approval process. While having tried-and-true software available that has been extensively tested offers better stability, sometimes you may require a newer version of particular software than what is available, which may lead you to consider alternative sources. After all, you don’t have to install a new version of Windows or macOS just to install newer applications!</p>
<p class="normal"><strong class="keyWord">Universal packages</strong> are <a id="_idIndexMarker172"/>a new concept for Linux and are intended to be a single package format that <a id="_idIndexMarker173"/>multiple distributions recognize. The idea is that a developer only has to compile one package (instead of a separate package for each distribution) and users would only need to download a single package regardless of their chosen Linux flavor. The next section will discuss a type of universal package called Snaps.</p>
<h2 class="heading-2" id="_idParaDest-60">Snap packages</h2>
<p class="normal">As it stands today, developers <a id="_idIndexMarker174"/>would need to create multiple package types to support Linux. Perhaps they’ll create Debian packages for Debian itself and Ubuntu, and then RPM packages for CentOS, Red Hat Enterprise Linux, and SuSE. And while you may think that having to create two package types isn’t all that bad, consider that each of the RPM-based distributions needs its own specific RPM package, and you can see how it might be tedious to a developer to have to create five or more different packages for any one release of their software.</p>
<p class="normal">As a result of this, there’s a push to adopt a single package format that each distribution can install that is independent of the system package type. This concept is known as <strong class="keyWord">universal packages</strong>, and the<a id="_idIndexMarker175"/> idea is to have a standard package type that can be installed on any Linux distribution. As a result, developers would only have to create one package to have their application work on all the popular distros.</p>
<div class="note">
<p class="normal">The Linux community commonly uses the word <em class="italic">distro</em> as a contraction of the term <em class="italic">distribution</em>.</p>
</div>
<p class="normal">Another benefit of universal packages is that they have all of their dependencies built in, so conflicts are less likely to occur; everything the application needs would be contained in one single package. This is great because the likelihood of you running into package conflicts with universal packages is next to non-existent.</p>
<p class="normal">As with all things in the IT industry, we can’t collectively be satisfied and decide on the proper technology. As such, there is debate among the community regarding which one of the multiple types of universal packages is the most suitable. I won’t get into the political debates in this book, as each has its strengths and weaknesses. But even easier for us in regards to Ubuntu Server, only one of them is ideal for server installations anyway. The competing technologies for universal packages include Flatpak, AppImage, and Snap packages.</p>
<p class="normal">Canonical, the makers of Ubuntu, understand the pain points that developers and users experience, and have been making a great effort to change how packages are managed. The type of universal<a id="_idIndexMarker176"/> package they’ve developed to address these concerns is known as the <strong class="keyWord">Snap package</strong>. Like all universal packages, Snap packages (or more simply, <em class="italic">Snaps</em>) have no impact on the underlying Debian packages at all and are completely independent, thus removing the possibility of conflicts with your system packages. This allows you to have a newer version of an application installed than what would otherwise be made available. Since Snaps are installed separately and independently from the underlying Debian packages, there’s no reason to withhold them. Snap packages are better in just about every way and are a great concept. The only downside might be that they are larger packages, since they include not only the application itself but also all the libraries they require in one single package. However, they’re really not that large and shouldn’t cause an issue with disk space. These packages are no bigger than a typical application on macOS or Windows.</p>
<p class="normal">So, which should you choose? It really just depends on your use case. Each of the universal package types is good at some things but has downsides. Flatpaks and AppImages are also great technologies, but where they fall behind for our use case is that they don’t support<a id="_idIndexMarker177"/> server (non-<strong class="keyWord">Graphical User Interface</strong>, or non-<strong class="keyWord">GUI</strong>) applications as well. This means that these package types are best for installing applications you’d normally find on a desktop Ubuntu installation, such as music players, browsers, graphical text editors, and so on. Snap packages target <em class="italic">both</em> GUI and non-GUI apps. Since server installations normally don’t contain a GUI at all, this makes our choice for us. It could be the case that Flatpaks and AppImages start supporting non-GUI apps better in the future, but for now, the choice of universal package format is simple.</p>
<p class="normal">As it stands today, though, the majority of the packages we’ll be installing are going to be Debian packages, as Snap packages are a bit slow to catch on. They’re making steady progress, but it remains to be seen how well the industry will embrace them. For now, it’s probably best to evaluate Snap packages when they’re available and to choose the most appropriate package type based on availability, security, version, and support.</p>
<p class="normal">With the differences <a id="_idIndexMarker178"/>between Snaps and Debian packages out of the way, let’s work through some examples of how to actually manage the software on our server. We’ll look at commands to search for available packages, and then we’ll install them and remove them.</p>
<h1 class="heading-1" id="_idParaDest-61">Installing and removing software</h1>
<p class="normal">Before we <a id="_idIndexMarker179"/>begin, we<a id="_idIndexMarker180"/> will want to research a bit regarding the application we want to install. In Ubuntu, there are multiple ways of installing software, so the best way to find out how to get started is by simply checking the documentation on the website for the application we want to install. Typically, a Google search will do (just make sure you check the domain and are on the correct site). Most software will have installation instructions for various platforms, including Ubuntu. Most of the time, it will just tell you to download the Debian package format via the <code class="inlineCode">apt install</code> command. Other times, the software may have a Snap available, or even a PPA repository (we’ll discuss PPA repositories later on in this chapter). Let’s start our package management journey by taking a look at the <code class="inlineCode">apt</code> commands that are used to install Debian packages.</p>
<h2 class="heading-2" id="_idParaDest-62">Managing Debian packages with apt</h2>
<p class="normal"><strong class="keyWord">APT</strong>, or <strong class="keyWord">Advanced Package Tool</strong>, is <a id="_idIndexMarker181"/>a suite of tools that <a id="_idIndexMarker182"/>allows<a id="_idIndexMarker183"/> us to install, remove, and update Debian packages. There are various sub-commands that make up this suite, which we’ll go over now. The most popular variation of the <code class="inlineCode">apt</code> command is <code class="inlineCode">apt install</code>. If you’ve ever read instructions for how to do something in Ubuntu, chances are you’ve already run that command to install a package. And that’s exactly what it does: it allows you to install packages for Ubuntu over the command line. For example, the following command will install the <code class="inlineCode">openssh-server</code> package:</p>
<pre class="programlisting con"><code class="hljs-con">sudo apt install openssh-server
</code></pre>
<p class="normal">You can also install multiple packages at a time by separating each with a space, instead of installing each package one at a time. The following example will install three different packages:</p>
<pre class="programlisting con"><code class="hljs-con">sudo apt install &lt;package1&gt; &lt;package2&gt; &lt;package3&gt;
</code></pre>
<p class="normal">In some books, blogs, and articles, you may see longer versions of <code class="inlineCode">apt</code> commands, such as <code class="inlineCode">apt-get install</code> instead of just <code class="inlineCode">apt install</code>. Being able to shorten commands such as <code class="inlineCode">apt-get install</code> to <code class="inlineCode">apt install</code> is a relatively new feature of <code class="inlineCode">apt</code> in Debian and Ubuntu. Both methods are perfectly valid, but simplifying APT commands down to just <code class="inlineCode">apt</code> is preferred going forward.</p>
<p class="normal">So, what actually happens when you install a package with <code class="inlineCode">apt</code>? If you’ve run through the process before, you’re probably accustomed to it already. But, typically, the process begins with <code class="inlineCode">apt</code> calculating dependencies. The majority of packages require other packages to function, so <code class="inlineCode">apt</code> will check to ensure that the package you’re requesting is available and that its dependencies are available as well. </p>
<p class="normal">First, you’ll see a summary of the changes that <code class="inlineCode">apt</code> wants to make to your server. In the case of installing the <code class="inlineCode">apache2</code> package on an unconfigured Ubuntu Server, I enter the following command:</p>
<pre class="programlisting con"><code class="hljs-con">sudo apt install apache2
</code></pre>
<p class="normal">I see the following output on my system when it starts to install:</p>
<figure class="mediaobject"><img alt="" height="384" src="../Images/B18425_03_01.png" width="881"/></figure>
<p class="packt_figref">Figure 3.1: Installing Apache on an example server</p>
<p class="normal">Even though I only asked for <code class="inlineCode">apache2</code>, <code class="inlineCode">apt</code> informs me that it also needs to install <code class="inlineCode">apache2-bin</code>, <code class="inlineCode">apache2-data</code>, <code class="inlineCode">apache2-utils</code>, and <code class="inlineCode">libapr1</code> (and others) in order to satisfy the dependencies for the <code class="inlineCode">apache2</code> package. <code class="inlineCode">apt</code> also suggests that I install <code class="inlineCode">apache2-doc</code>, <code class="inlineCode">apache2-suexec-pristine</code>, and a few others, though they are optional and are not required. You can install the suggested packages by adding the <code class="inlineCode">--install-suggests</code> option to the <code class="inlineCode">apt install</code> command, but that isn’t always a good idea as it may install a large number of packages that you may not need. You can, of course, cherry-pick the suggested packages individually by using the <code class="inlineCode">apt</code> command to install any one or more of them manually.</p>
<p class="normal">Most of the time, though, you <a id="_idIndexMarker184"/>probably won’t want to do this; it’s<a id="_idIndexMarker185"/> usually better to keep your installed packages to a lean minimum and install only the packages you need. As we’ll discuss in <em class="chapterRef">Chapter 21</em>, <em class="italic">Securing Your Server</em>, the fewer packages you install, the smaller the attack surface of your server.</p>
<p class="normal">While installing or updating packages via <code class="inlineCode">apt</code>, you might see a message come up that asks you whether or not you’re comfortable with having background services restarted as part of the process:</p>
<figure class="mediaobject"><img alt="" height="577" src="../Images/B18425_03_02.png" width="873"/></figure>
<p class="packt_figref">Figure 3.2: Service restart prompt during package installation/upgrade</p>
<p class="normal">We’ll cover concepts around process management in <em class="chapterRef">Chapter 7</em>, <em class="italic">Controlling and Managing Processes</em>, so it’s not something you should focus on right now. For a quick description in order to hold you over until then, there’s services running in the background on all Linux servers, and each one provides a particular function. Restarting a service will ensure it restarts with all the latest patches and tweaks applied, but any user connected to one of the services you restart will get disconnected. For now, you can simply press Enter to accept the defaults anytime you see this message.</p>
<p class="normal">Another option that is common with installing packages via <code class="inlineCode">apt</code> is the <code class="inlineCode">-y</code> option, which assumes <em class="italic">yes</em> to the confirmation prompt where you choose if you want to continue or not. For example, my previous output included the line <code class="inlineCode">Do you want to continue? [Y/n]</code>. If we had used <code class="inlineCode">-y</code>, the command would have proceeded to install the package without any confirmation. This can be useful for administrators in a hurry, though I personally don’t see the need for this unless you are scripting your package installations. In fact, it can sometimes be a bad idea, because by assuming <em class="italic">yes</em>, you may be confirming something you’d later regret.</p>
<p class="normal">Another neat default in Ubuntu Server is that it automatically configures most packages to make their daemons start up and also be enabled so that they start with each boot. Using the earlier example of <code class="inlineCode">apache2</code>, the <code class="inlineCode">apache2</code> service will start and the application will automatically start running as soon as you install the package. </p>
<p class="normal">This may seem like a good idea for the sake of convenience, but not everyone prefers this automation. As I’ve mentioned, the more packages installed on your server, the higher the attack surface, but running services (also known as daemons, or units) are each a method of entry for miscreants should there be a security vulnerability. Therefore, some distributions don’t enable and start daemons automatically when you install packages. The way I see it, though, you should only install packages you actually intend to use, so it stands to reason that if you go through the trouble of manually installing a package such as <code class="inlineCode">apache2</code>, you probably want to start using it.</p>
<p class="normal">When you install<a id="_idIndexMarker186"/> a <a id="_idIndexMarker187"/>package with the <code class="inlineCode">apt</code> command, it searches its local database for the package you named. If it doesn’t find it, it will throw an error. Sometimes, this error may be because the package isn’t available or perhaps the version that <code class="inlineCode">apt</code> wants to install no longer exists. Ubuntu’s repositories move very quickly; new versions of packages are added almost daily. When a new version of a package is added, its older equivalent may be removed. For this reason, it’s recommended that you update your package sources from time to time. Doing so is easy, using the following command:</p>
<pre class="programlisting con"><code class="hljs-con">sudo apt update
</code></pre>
<p class="normal">This command doesn’t actually update any packages; it merely checks in with your local mirror to see if any packages have been added or removed and updates your local index. This command is useful because installations of packages can fail if your sources aren’t up to date. In most cases, the symptom will be that <code class="inlineCode">apt</code> errors out of the process when it can’t find a package it’s looking for, something that would’ve been available normally.</p>
<p class="normal">Removing packages is also very easy and follows a very similar syntax; you would only need to replace the <code class="inlineCode">install</code> keyword with <code class="inlineCode">remove</code>:</p>
<pre class="programlisting con"><code class="hljs-con">sudo apt remove &lt;package&gt;
</code></pre>
<p class="normal">And, just like with the <code class="inlineCode">install</code> option, you can remove multiple packages at the same time. The following example will remove three packages:</p>
<pre class="programlisting con"><code class="hljs-con">sudo apt remove &lt;package1&gt; &lt;package2&gt; &lt;package3&gt;
</code></pre>
<p class="normal">If you’d like to not only remove a package but also wipe out its configuration, you can use the <code class="inlineCode">--purge</code> option:</p>
<pre class="programlisting con"><code class="hljs-con">sudo apt remove --purge &lt;package&gt;
</code></pre>
<p class="normal">This will not only remove the package but wipe out its configuration directory (applications<a id="_idIndexMarker188"/> typically <a id="_idIndexMarker189"/>store their configuration files in a sub-directory of <code class="inlineCode">/etc</code>).</p>
<p class="normal">So, that concludes the basics of managing Debian packages with <code class="inlineCode">apt</code>. Now, let’s move on to managing Snaps.</p>
<h2 class="heading-2" id="_idParaDest-63">Managing Snap packages with snap</h2>
<p class="normal">To manage Snap <a id="_idIndexMarker190"/>packages, we use the <code class="inlineCode">snap</code> command. The <code class="inlineCode">snap</code> command features several options we can use to search for, install, and remove Snap packages from our server or workstation. </p>
<p class="normal">To begin, we can use the <code class="inlineCode">snap find</code> command along with a keyword to display a list of Snap packages available to us that match that keyword:</p>
<pre class="programlisting con"><code class="hljs-con">snap find &lt;keyword&gt;
</code></pre>
<p class="normal">Basically, you just simply type the <code class="inlineCode">snap find</code> command along with a search term to look for. One example could be the <code class="inlineCode">nmap</code> application, which is a useful tool to have if we’re managing a network:</p>
<pre class="programlisting con"><code class="hljs-con">snap find nmap
</code></pre>
<p class="normal">In the case of <code class="inlineCode">nmap</code>, this utility is available in Ubuntu’s default repositories, so you don’t need to use the Snap package to install it. Typically, though, the Snap version will be newer and have more features than what is available in the APT repositories. If we wish to install the Snap version, we can use the following command to do so:</p>
<pre class="programlisting con"><code class="hljs-con">sudo snap install nmap
</code></pre>
<p class="normal">With the <code class="inlineCode">install</code> option, we need to use <code class="inlineCode">sudo</code> since the act of installing a package makes changes on the server. For a simple <code class="inlineCode">find</code>, we can omit <code class="inlineCode">sudo</code>.</p>
<p class="normal">Now that we have <code class="inlineCode">nmap</code> installed, we can check the location of the <code class="inlineCode">nmap</code> binary with the <code class="inlineCode">which</code> command. We can use the <code class="inlineCode">which</code> command to find the location of the binary file for commands that are available—it will show the path to the binary if the appropriate package is installed. If the command is not available, the <code class="inlineCode">which</code> command will show no output. So, if we run the following command, we should now see the path of that binary printed to the screen:</p>
<pre class="programlisting con"><code class="hljs-con">which nmap
</code></pre>
<p class="normal">This will return<a id="_idIndexMarker191"/> the following output, showing that the Snap version of <code class="inlineCode">nmap</code> is run from a special place:</p>
<figure class="mediaobject"><img alt="" height="148" src="../Images/B18425_03_03.png" width="608"/></figure>
<p class="packt_figref">Figure 3.3: Checking the location of the nmap binary</p>
<p class="normal">Now, when we run <code class="inlineCode">nmap</code>, we’re actually running it from <code class="inlineCode">/snap/bin/nmap</code>. If we were to install <code class="inlineCode">nmap</code> via <code class="inlineCode">apt</code>, it would run from <code class="inlineCode">/usr/bin/nmap</code> instead. If we also have the <code class="inlineCode">nmap</code> utility installed from Ubuntu’s APT repositories, then we can run either one at any time by calling out the full path to the binary we want to run, since Snap packages are independent of the APT packages. For example, if we had <code class="inlineCode">nmap</code> installed via both <code class="inlineCode">snap</code> and <code class="inlineCode">apt</code>, we could run Ubuntu’s version by running <code class="inlineCode">/usr/bin/nmap</code> and the Snap version by running <code class="inlineCode">/snap/bin/nmap</code>.</p>
<p class="normal">Removing an installed Snap package is easy. We simply use the <code class="inlineCode">remove</code> option:</p>
<pre class="programlisting con"><code class="hljs-con">sudo snap remove nmap
</code></pre>
<p class="normal">If we issue that command, then <code class="inlineCode">nmap</code> (or whichever Snap package we designate) is removed from the system.</p>
<p class="normal">To update a package, we use the <code class="inlineCode">refresh</code> option along with the name of a package to update:</p>
<pre class="programlisting con"><code class="hljs-con">sudo snap refresh &lt;package&gt;
</code></pre>
<p class="normal">With that command, the package will be updated to the newest version available. Going even further, we can attempt to update every Snap on our server with the same command (without specifying a package):</p>
<pre class="programlisting con"><code class="hljs-con">sudo snap refresh
</code></pre>
<p class="normal">As you can see, managing Snap packages is fairly straightforward. Using the <code class="inlineCode">snap</code> suite of commands, we can install, update, or remove packages from our server or workstation. The <code class="inlineCode">snap find</code> command allows us to find new Snap packages to install. Perhaps as the technology matures, we may find ourselves installing more Snap packages than Debian packages, but that remains to be seen. For now, it’s a nice benefit to have two options to consider when installing new software.</p>
<p class="normal">In addition to<a id="_idIndexMarker192"/> being able to install packages, there are some additional tips and considerations around searching for packages. After all, you can’t install a package if you don’t know what’s available. We’ll explore searching for packages in the next section.</p>
<h1 class="heading-1" id="_idParaDest-64">Searching for packages</h1>
<p class="normal">Unfortunately, the <a id="_idIndexMarker193"/>naming conventions used for packages in Ubuntu Server aren’t always obvious. Worse, package names are often very different from one distribution to another even for the same piece of software. While this book and other tutorials online will outline the exact steps needed to install software, if you’re ever on your own, it really doesn’t help much if you don’t know the name of the package you want to install. In this section, I’ll try to take some of the mystery out of searching for packages.</p>
<p class="normal">In the previous section, we went over searching for Snap packages, so I won’t repeat that here. The APT suite of utilities also has a means of searching for packages as well, which is the <code class="inlineCode">apt search</code> command. We can use the following command to search for packages, by providing a keyword:</p>
<pre class="programlisting con"><code class="hljs-con">apt search &lt;search term&gt;
</code></pre>
<p class="normal">The output from this command will show a list of packages that match your search criteria, with their names and descriptions. If, for example, you wanted to install the PHP plugin for Apache and you didn’t already know the name of the associated package, the following would narrow it down:</p>
<pre class="programlisting con"><code class="hljs-con">apt search apache php
</code></pre>
<p class="normal">In the output, we will get a list of more than a handful of packages, but we can deduce from the package descriptions in the output that <code class="inlineCode">libapache2-mod-php</code> is most likely the one we want. We can proceed to install it using <code class="inlineCode">apt</code>, as we would normally do. </p>
<p class="normal">If we’re not sure whether or not this is truly the package we want, we can view more information regarding this (or any other) package with the <code class="inlineCode">apt-cache show</code> command:</p>
<pre class="programlisting con"><code class="hljs-con">apt-cache show libapache2-mod-php
</code></pre>
<p class="normal">The output <a id="_idIndexMarker194"/>of this command is illustrated in the following screenshot:</p>
<figure class="mediaobject"><img alt="" height="479" src="../Images/B18425_03_04.png" width="877"/></figure>
<p class="packt_figref">Figure 3.4: Showing the info of a Debian package</p>
<p class="normal">With this command, we can see additional details regarding the package we’re considering installing. In this case, we learn that the <code class="inlineCode">libapache2-mod-php</code> package also depends on PHP itself, so that means if we install this package, we’ll get the PHP plugin as well as PHP itself.</p>
<p class="normal">Another method of searching for a package (if you have a web browser available) is to connect to the <em class="italic">Ubuntu Packages Search</em> page at <a href="https://packages.ubuntu.com/"><span class="url">https://packages.ubuntu.com/</span></a>, where you can navigate through the packages from their database for any currently supported version of Ubuntu. You won’t always have access to a web browser while working on your servers, but, when you do, this is a very useful way to search through packages, view their dependencies, descriptions, and more.</p>
<p class="normal">Using the <code class="inlineCode">apt search</code> command, as well as the <code class="inlineCode">snap find</code> command, should get you quite far in the process of determining the name of the packages you want to install. Package management skills come over time, so don’t expect to automatically know which packages to install right away. When in doubt, just perform a Google search, research the documentation of the software you want to run, and learn how to install it in Ubuntu. Typically, the instructions will lead you to the correct commands to use. The examples we’ll go over during the course of this book will guide you through the most common use cases for Ubuntu Server.</p>
<p class="normal">At this point, we should have a solid understanding of the different types of packages available and how to manage them. However, it’s sometimes the case that we need to run software<a id="_idIndexMarker195"/> on our server for which there is no package available within the standard repositories. Therefore, in the next section, we’ll learn how to add additional repositories from which to install software.</p>
<h1 class="heading-1" id="_idParaDest-65">Managing package repositories</h1>
<p class="normal">Often, the<a id="_idIndexMarker196"/> repositories that come pre-installed with Ubuntu will suffice for the majority of the Debian packages you’ll install via APT. Every now and then, though, you may need to install an additional repository in order to take advantage of software not normally provided by Ubuntu, or versions of packages newer than what you would normally have available. Adding additional repositories allows you to subscribe to additional sources of software and install packages from them in the same way as you would from any other source.</p>
<p class="normal">Adding additional repositories should be considered a last resort, however. When you install an additional repository, you’re effectively trusting the author of that repository with your organization’s server. Although I haven’t ever seen this happen first-hand, it’s theoretically possible for authors of software to include back doors or malware in software packages (intentionally or unintentionally), and then make them available for others via a software repository. Therefore, you should only add repositories from sources that you have reason to trust.</p>
<p class="normal">In addition, it sometimes happens that a maintainer of a repository simply gives up on it and disappears. This I have seen happen first-hand. In this situation, the repository may go offline (which would show errors during <code class="inlineCode">apt</code> transactions, indicating that it’s not able to connect to the repository), or worse, the repository stays online, but security updates are never made available, causing your server to become vulnerable to attack. Sometimes, you just don’t have a way around it. You need a specific application and Ubuntu doesn’t offer it by default. Your only option may be to compile an application from source or add a repository. The decision is yours, but just keep security in mind whenever possible. When in doubt, avoid adding a repository unless it’s the only way to obtain what you’re looking for. If you do add an additional repository and you haven’t seen packages from it updated in a decent amount of time, consider that a red flag and investigate <a id="_idIndexMarker197"/>whether or not the repository is abandoned. Repositories that are abandoned should be removed, and an alternative used in its place.</p>
<h2 class="heading-2" id="_idParaDest-66">Adding additional repositories</h2>
<p class="normal">Software repositories<a id="_idIndexMarker198"/> are essentially URLs in a text file, stored in one of two places. The main Ubuntu repository list is stored in <code class="inlineCode">/etc/apt/sources.list</code>. Inside that file, you’ll find a multitude of repositories for Ubuntu’s package manager to pull packages from. In addition, files with an extension of <code class="inlineCode">.list</code> are read from the <code class="inlineCode">/etc/apt/sources.list.d/</code> directory and are also used whenever you use <code class="inlineCode">apt</code>. I’ll demonstrate both methods.</p>
<p class="normal">A typical repository line in either of these two files will look similar to the following:</p>
<pre class="programlisting con"><code class="hljs-con">deb http://us.archive.ubuntu.com/ubuntu/ jammy main restricted 
</code></pre>
<p class="normal">The first section of each line will be either <code class="inlineCode">deb</code> or <code class="inlineCode">deb-src</code>, which references whether the <code class="inlineCode">apt</code> command will find binary packages (<code class="inlineCode">deb</code>) or source packages (<code class="inlineCode">deb-src</code>) there. Next, we have the actual URL that <code class="inlineCode">apt</code> will use in order to reach the repository. In the third section, we have the codename of the release; in this case, it’s <code class="inlineCode">jammy</code> (which refers to the codename for Ubuntu 22.04, <code class="inlineCode">Jammy Jellyfish</code>).</p>
<p class="normal">If you weren’t already aware, the codename for each Ubuntu release is based on an animal. Often, the animal chosen for a release will be rare. For example, the previous LTS release featured the fossa, which is an animal from Madagascar that somewhat resembles a cat but with curved ears. This time around, the chosen animal is the jellyfish, which I’m sure the majority of my readers are already familiar with.</p>
<p class="normal">Continuing, the fourth section of each repository line refers to the <code class="inlineCode">Component</code>, which references whether or not the repository contains software that is free and open source, and is supported officially by Canonical (the company that oversees Ubuntu’s development). The component can be <code class="inlineCode">main</code>, <code class="inlineCode">restricted</code>, <code class="inlineCode">universe</code>, or <code class="inlineCode">multiverse</code>. Repositories with a <code class="inlineCode">main</code> component include officially supported software. This generally means that the software packages have source code available, so Ubuntu developers are able to fix bugs. Software marked <code class="inlineCode">restricted</code> is still supported but may have a questionable license. <code class="inlineCode">universe</code> packages are supported by the community, not Canonical themselves. Finally, <code class="inlineCode">multiverse</code> packages contain software that is neither free nor supported, which you would be using at your own risk.</p>
<p class="normal">As you can see from looking at the <code class="inlineCode">/etc/apt/sources.list</code> file on your server, it’s possible for a repository <a id="_idIndexMarker199"/>line to feature software from more than one component. Each repository URL may include packages from several components, and the way you differentiate them is to only subscribe to the components you need for that repository. In our previous example, the repository line included both <code class="inlineCode">main</code> and <code class="inlineCode">restricted</code> components. This means that, for that particular example, the <code class="inlineCode">apt</code> utility will index both free (<code class="inlineCode">main</code>) and non-free (<code class="inlineCode">restricted</code>) packages from that repository.</p>
<p class="normal">You can add new repositories to the <code class="inlineCode">/etc/apt/sources.list</code> file (and it will function just fine), but that’s not typically the preferred method. Instead, as I mentioned earlier, <code class="inlineCode">apt</code> will scan the <code class="inlineCode">/etc/apt/sources.list.d/</code> directory for text files ending with the <code class="inlineCode">.list</code> extension. These text files are formatted the same as the <code class="inlineCode">/etc/apt/sources.list</code> file in the sense that you include one additional repository per line, but this method allows you to add a new repository by simply creating a file for it, and you can remove the repository by simply deleting that file.</p>
<p class="normal">This is safer than editing the <code class="inlineCode">/etc/apt/sources.list</code> file directly, since there’s always a chance you can make a typo and disrupt your ability to download packages from even the official repositories.</p>
<p class="normal">In addition, you may need to install a <strong class="keyWord">GNU Privacy Guard</strong> (<strong class="keyWord">GnuPG</strong>) key for a new repository, but this process differs from one application to another. Typically, the documentation will outline the entire process. This key basically protects you in that it makes sure that you’re installing signed packages. Not all developers protect their applications this way, but it’s definitely a good thing to do.</p>
<p class="normal">Once you have the repository (and possibly the key) installed on your server, you’ll need to run the following command to update your package index:</p>
<pre class="programlisting con"><code class="hljs-con">sudo apt update
</code></pre>
<p class="normal">As mentioned earlier in this chapter, this command updates your local cache as to which packages are available on the remote server. APT is only aware of packages that are in its database, so you <a id="_idIndexMarker200"/>will need to sync this with that command before you’ll be able to actually install the software contained within the repository.</p>
<h2 class="heading-2" id="_idParaDest-67">Adding Personal Package Archives</h2>
<p class="normal">On the Ubuntu platform, there also exists <a id="_idIndexMarker201"/>another type of repository, known as a <strong class="keyWord">Personal Package Archive</strong> (<strong class="keyWord">PPA</strong>). PPAs are essentially another form of APT repository, and you’ll even interact with their packages with the <code class="inlineCode">apt</code> command, as you would normally. PPAs are usually very small repositories, often including a single application that serves a single purpose. Think of PPAs as <em class="italic">mini-repositories</em>. A PPA is common in situations where a vendor doesn’t make their software available with their own repository and may only make their application available in the form of source code you would need to manually download, compile, and install. With the PPA platform, anyone can compile a package from source and easily make it available for others to download.</p>
<p class="normal">PPAs suffer from the same security concerns as regular repositories (you need to trust the vendor and so on), but are a bit worse considering that the software typically isn’t audited at all. In addition, if the PPA was to ever go down, you’d stop getting security updates for the application you install from it. Only use PPAs when you absolutely need to.</p>
<p class="normal">There is one use case for PPAs that may be compelling, specifically for a server platform that standard repositories aren’t able to handle very well, and that is software versioning. As I mentioned earlier, a major server component such as PHP or MySQL may be locked to a specific major version with each Ubuntu Server release. What do you do if you need to use Ubuntu Server, but the application you need to run is not available in the version your organization requires? In the past, you would literally need to choose between the distribution and the package, with some organizations even using a different distribution of Linux just to satisfy the need to have a specific application at a specific version. You can always compile the application from source (assuming its source code is available), but that can cause additional headaches in the sense that you’d be responsible for compiling new security patches yourself whenever they’re made available. PPAs potentially give you access to applications not normally available in the default repositories, and/or access to newer versions of packages than what is normally provided. This gives you, the server administrator, the ability to choose the approach that is best for your goal.</p>
<p class="normal">PPAs are generally added to your server with the <code class="inlineCode">apt-add-repository</code> command. The syntax generally uses the <code class="inlineCode">apt-add-repository</code> command, with a colon, followed by a username, and then the PPA name. The following command is a hypothetical example:</p>
<pre class="programlisting con"><code class="hljs-con">sudo apt-add-repository ppa:username/myawesomesoftware-1.0
</code></pre>
<p class="normal">To begin the process, you would start your search by visiting Ubuntu’s PPA website, which is available at <a href="https://launchpad.net/ubuntu/+ppas"><span class="url">https://launchpad.net/ubuntu/+ppas</span></a>. There, you can search among the available PPAs.</p>
<p class="normal">Before adding <a id="_idIndexMarker202"/>a PPA to your server, it’s best to first research whether or not it’s being maintained well. For example, if the PPA hasn’t had any updated packages in a very long time, that’s cause for concern—security fixes are fairly common with most packages. If a package isn’t being regularly updated and has therefore gone “stale,” it may be best to avoid it as it may cause more harm than good.</p>
<p class="normal">Once you find a PPA you would like to add to your server, you can add it simply by finding the name of the PPA and then adding it to your server with the <code class="inlineCode">apt-add-repository</code> command. </p>
<p class="normal">You should take a look at the page for the PPA, though, in case there are different instructions. For the most part, the <code class="inlineCode">apt-add-repository</code> command should work fine for you. Each PPA typically has a set of instructions attached, so there shouldn’t be any guesswork required here.</p>
<p class="normal">So, what exactly does the <code class="inlineCode">apt-add-repository</code> command do? Honestly, it’s not all that amazing. When you install a PPA, it’s essentially automating the process of adding a repository file to your <code class="inlineCode">/etc/apt/sources.list.d</code> directory and installing its key. Therefore, you can uninstall a PPA by simply deleting its file.</p>
<p class="normal">PPAs are a very useful feature if harnessed with care. PPAs offer Ubuntu a flexible way of adding additional software that wouldn’t normally be made available, though you will need to keep an eye on such repositories to ensure they are properly patched when vulnerabilities arise and are used only when absolutely necessary. Always prefer packages from Ubuntu’s default repositories as well as Snaps, but PPAs offer you another option in case you can’t find what you need anywhere else.</p>
<p class="normal">After you’ve maintained a server for a while, or finished setting it up for a particular goal, you’ll have installed a plethora of packages to suit its purpose. Exporting a list of installed packages can make it easier to<a id="_idIndexMarker203"/> rebuild a server should the need arise, and we’ll look at one method of doing that in the next section.</p>
<h1 class="heading-1" id="_idParaDest-68">Backing up and restoring Debian packages</h1>
<p class="normal">As you maintain<a id="_idIndexMarker204"/> your <a id="_idIndexMarker205"/>server, your list of installed packages will grow. If, for some reason, you needed to rebuild your server, you would need to reproduce exactly what you had installed before, which can be a pain. It’s always recommended that you document all changes made to your server via a change control process, but, at the very least, keeping track of which packages are installed is an absolute must. In some cases, a server may only include one or two extra packages in order to meet its goal, but, in other cases, you may need an exact combination of software and libraries in order to get things working like they were. Thankfully, the <code class="inlineCode">dpkg</code> command allows us to export and import a list of packages to install.</p>
<p class="normal">To export a list of installed packages, we can use the following command:</p>
<pre class="programlisting con"><code class="hljs-con">dpkg --get-selections &gt; packages.list
</code></pre>
<p class="normal">This command will dump a list of package selections to a standard text file. If you open it, you’ll see a list of your installed packages, one per line. A typical line within the exported file will look similar to the following:</p>
<pre class="programlisting con"><code class="hljs-con">tmux install
</code></pre>
<p class="normal">With this list, we can import our selections back into the server if we need to reinstall Ubuntu Server, or into a new server that will serve a similar purpose. First, before we manage any packages, we should update our index:</p>
<pre class="programlisting con"><code class="hljs-con">sudo apt update
</code></pre>
<p class="normal">Next, we’ll need to ensure we have the <code class="inlineCode">dselect</code> package installed. The <code class="inlineCode">dselect</code> package provides us with additional features when managing Debian packages. Its finer points are beyond the scope of this chapter, but for our current goal, we can use it to restore packages from our exported list. At your shell prompt, type <code class="inlineCode">which dselect</code> and you should see output similar to the following:</p>
<pre class="programlisting con"><code class="hljs-con">/usr/bin/dselect
</code></pre>
<p class="normal">If you don’t see the output, you’ll need to install the <code class="inlineCode">dselect</code> package with <code class="inlineCode">apt</code>:</p>
<pre class="programlisting con"><code class="hljs-con">sudo apt install dselect
</code></pre>
<p class="normal">Once that’s complete, you can now import your previously saved package list, and have the missing packages reinstalled on your server. The following commands will complete the process:</p>
<pre class="programlisting con"><code class="hljs-con">sudo dselect update
sudo dpkg --set-selections &lt; packages.list
sudo apt-get dselect-upgrade
</code></pre>
<p class="normal">Normally, we simply use <code class="inlineCode">apt</code> instead of <code class="inlineCode">apt-get</code> nowadays, but oddly enough, the <code class="inlineCode">dselect-upgrade</code> command only works with <code class="inlineCode">apt-get</code>.</p>
<p class="normal">After you have run those commands, the packages that are contained in your packages list but aren’t already installed will be installed once you confirm the changes. This method allows you to easily restore the packages previously installed on your server, if for some reason you need to rebuild it, as well as setting up a new server to be configured <a id="_idIndexMarker206"/>in<a id="_idIndexMarker207"/> a similar way to an existing one.</p>
<p class="normal">Now that we have an understanding of how to export and import a list of installed packages, we can also take a look at how to clean up unneeded packages to ensure our server is as free as possible from unnecessary bloat.</p>
<h1 class="heading-1" id="_idParaDest-69">Cleaning up orphaned apt packages</h1>
<p class="normal">As you manage <a id="_idIndexMarker208"/>packages on your server, you’ll eventually run into a situation where you’ll have packages on your system that are installed but not needed by anything. This occurs either when removing a package that has dependencies, or when the dependencies on an installed package change. As you’ll remember, when you install a package that requires other packages, those dependencies are also installed. But if you remove the package that required them, the dependencies will not be removed automatically.</p>
<p class="normal">To illustrate this situation, if I remove the <code class="inlineCode">apache2</code> package from one of my servers, I will see the following extra information if I then try to install something else:</p>
<figure class="mediaobject"><img alt="" height="314" src="../Images/B18425_03_05.png" width="877"/></figure>
<p class="packt_figref">Figure 3.5: Output with orphaned packages shown</p>
<p class="normal">In this example, I <a id="_idIndexMarker209"/>removed <code class="inlineCode">apache2</code> (that was done before the screenshot was taken), then I went on to install <code class="inlineCode">tmux</code>. The package I was trying to install is arbitrary; the important part is the text you see in the screenshot where it says <code class="inlineCode">The following packages were automatically installed and are no longer required</code>. Basically, if you have orphaned packages on your system, Ubuntu will remind you periodically as you use the APT suite of tools. In this case, I removed <code class="inlineCode">apache2</code> so all of the dependencies that were installed to support the <code class="inlineCode">apache2</code> package were no longer needed.</p>
<p class="normal">In the screenshot, I’m shown a list of packages that APT doesn’t think I need anymore. It may be right, but this is something we would need to investigate. As instructed in the output, we can use the <code class="inlineCode">apt autoremove</code> command as <code class="inlineCode">root</code> or with <code class="inlineCode">sudo</code> to remove them. This is a great way of keeping our installed packages clean but should be used with care. If you’ve just recently removed a package, it’s probably safe to do the cleanup manually.</p>
<p class="normal">Although we haven’t walked through updating packages (we’ll do that in <em class="chapterRef">Chapter 21</em>, <em class="italic">Securing Your Server</em>), a situation that may come up later is one in which you have outdated kernels that can be cleaned with the <code class="inlineCode">autoremove</code> option. These will appear in the same way as the example orphans I was shown in the previous screenshot, but the names will contain <code class="inlineCode">linux-image</code>. Take care with these; you should never remove outdated kernels from your server until you verify that the newly installed kernel is working correctly and the server doesn’t exhibit any unwanted or unexpected behavior. Generally, you would probably want to wait at least a week before running <code class="inlineCode">apt autoremove</code> when kernel packages are involved.</p>
<p class="normal">When it comes to other packages, they are generally safe to remove with the <code class="inlineCode">apt autoremove</code> command, since the majority of them will be packages that were installed as a dependency of another package that is no longer present on the system. However, double-check that you really do want to remove each of the packages before you do so. You can always reinstall a package if you didn’t mean to remove it, and as an added benefit, if you reinstall a package that was marked for auto-removal, it won’t show up in the output as an orphan package in the future.</p>
<p class="normal">As you’ve seen so far, there are a lot of options when it comes to managing software in Ubuntu, and as an administrator, you are able to choose the best possible method for your goal. Another<a id="_idIndexMarker210"/> special type of update is available, that can improve hardware support in a situation where your hardware is newer than your Ubuntu version, or provide compatibility for hardware that didn’t previously have support available.</p>
<h1 class="heading-1" id="_idParaDest-70">Taking advantage of hardware enablement updates</h1>
<p class="normal">One issue in the<a id="_idIndexMarker211"/> Linux industry has been hardware support. This is problematic in various Linux distributions because you may find yourself in a situation where you’re using a server (or even a desktop or laptop) that was released with the latest processor and chipset, but no newer version of your Linux distribution has been released yet that includes updated drivers that support it. Unlike platforms such as Windows, hardware drivers are typically built right into the Linux kernel. So, if you have an old release (which would contain an older kernel), you might be out of luck for hardware support until the next version of your Linux distribution is released.</p>
<p class="normal">Thankfully, Ubuntu has come up with a system to address this problem, and it’s one of the many things that set it apart from other distributions. Ubuntu features a set of updates known<a id="_idIndexMarker212"/> as the <strong class="keyWord">hardware enablement</strong> (<strong class="keyWord">HWE</strong>) stack, which is an exclusive <a id="_idIndexMarker213"/>feature of <strong class="keyWord">long-term support</strong> (<strong class="keyWord">LTS</strong>) releases. We discussed the difference between LTS and regular releases back in <em class="chapterRef">Chapter 1</em>, <em class="italic">Deploying Ubuntu Server</em>. HWE updates are optional, but they add additional compatibility with newer hardware that was released after the current LTS version was made available. A new HWE stack typically includes a new kernel and driver packages. However, since drivers are often built right into the Linux kernel, you’ll also get added support for things other than new video cards as well, such as newly released network cards.</p>
<p class="normal">HWE updates are generally made available from the second point release of an LTS version, and then again with each subsequent point release until the next LTS release becomes available. The new compatibility<a id="_idIndexMarker214"/> stack is <strong class="keyWord">backported</strong> from the most recent non-LTS release, which means that you get the same compatibility of the latest non-LTS release while being able to stay on an LTS release. For example, when Ubuntu 20.04.2 was released on February 4, 2021, it contained the kernel and driver packages backported from<a id="_idIndexMarker215"/> Ubuntu 20.10. This means that you were able to take advantage of the newer hardware support of Ubuntu 20.10 while being able to remain on 20.04 LTS and benefit from the longer support cycle of the LTS release.</p>
<p class="normal">At the time of writing, Ubuntu 22.04 is the latest LTS release of Ubuntu, so hardware enablement hasn’t been added yet. Historically, it’s most likely the case that hardware enablement will play out in 22.04 LTS the same way as it has in previous releases. If that’s the case, then the updated packages will be made available once Ubuntu 22.04.2 is released.</p>
<p class="normal">Once the new HWE stack is made available, you can choose to install it or to remain on the original 22.04 kernel with no change. On the desktop version of Ubuntu, people that enjoy computer games can really benefit from these updates, as the new drivers enable better performance when it comes to video cards and support newer gaming hardware. When it comes to the scope of this book, the new hardware enablement benefits us a bit less than desktop users. The reason is that if your server is running fine with no issues, then there really isn’t any reason to install the new hardware enablement unless the updated kernel contains new features you’d like to take advantage of.</p>
<p class="normal">A frustrating experience that sometimes comes up is having Ubuntu complain that there are no network cards available, even though you do actually have one. I’ve seen this most often when purchasing a new physical server that contains the latest hardware. It can be very frustrating to power on a brand-new server, only to realize you can’t get a network connection at all. This is a classic symptom of needing an updated compatibility stack. Perhaps your network card was released after the release date of the current Ubuntu release. This scenario is a good example of why hardware enablement updates exist, and why you will probably end up using them sooner or later.</p>
<p class="normal">If you don’t opt in<a id="_idIndexMarker216"/> to the HWE updates, your server will always have the same hardware enablement (kernel, drivers, and so on) as it did when your installed LTS release was first published. In that case, your kernel and related packages will only be updated when you install new security updates. At a later date, you can opt in to HWE updates manually if you wish. Generally, you only do this if you’ve added new hardware to a physical server that requires a new kernel. If your server is working perfectly fine and you haven’t added new hardware, there’s probably no reason to install a new HWE stack.</p>
<p class="normal">If you do decide to utilize these updates, there are two ways to do so. You can opt in to the newer HWE stack while installing Ubuntu Server, or you can manually install the required packages. At the time of writing, Ubuntu 22.04 is new to the scene, so it remains to be seen if the updated packages will be made available with 22.04.2, but it’s very likely given Ubuntu’s history. The following screenshot shows the first screen of the installer for Ubuntu 20.04.4. Assuming Ubuntu 22.04 follows the same plan, you’ll most likely see an option such as the one in the following screenshot once 22.04.2 is released:</p>
<figure class="mediaobject"><img alt="" height="365" src="../Images/B18425_03_06.png" width="627"/></figure>
<p class="packt_figref">Figure 3.6: Main menu of the installer for Ubuntu 20.04.4</p>
<p class="normal">Notice the <strong class="screenText">Install Ubuntu Server with the HWE kernel</strong> option. If you choose this option, then your installation of Ubuntu Server will contain the new HWE packages immediately.</p>
<p class="normal">If you’ve already installed Ubuntu Server and you’d like to install the HWE updates afterward, you can do so from the terminal. In Ubuntu 20.04, for example, you were able to switch to the HWE kernel with the following command:</p>
<pre class="programlisting con"><code class="hljs-con">sudo apt install --install-recommends linux-generic-hwe-20.04
</code></pre>
<p class="normal">When Ubuntu 22.04 releases its newer HWE stack, a similar command will likely be used to install it. If<a id="_idIndexMarker217"/> you need a newer HWE kernel, refer to the instructions in Ubuntu’s documentation pages when that time comes.</p>
<h1 class="heading-1" id="_idParaDest-71">Summary</h1>
<p class="normal">In this chapter, we have taken a crash course in the world of package management. As you can see, Ubuntu Server offers an amazing number of software packages and various tools that we can use to manage them. We began the chapter with a discussion of how package management with Ubuntu works, then we worked through installing packages, searching for packages, and managing repositories. Snap packages were also covered, which is a newer technology that aims to enhance software distribution on Ubuntu.</p>
<p class="normal">In <em class="chapterRef">Chapter 4</em>, <em class="italic">Navigating and Essential Commands</em>, we’ll take a look at foundational commands for navigating the Linux Shell, understanding the filesystem layout, and more.</p>
<h1 class="heading-1" id="_idParaDest-72">Relevant video</h1>
<ul>
<li class="bulletList">Linux Crash Course - APT (LearnLinuxTV): <a href="https://linux.video/lcc-apt"><span class="url">https://linux.video/lcc-apt</span></a></li>
</ul>
<h1 class="heading-1" id="_idParaDest-73">Further reading</h1>
<ul>
<li class="bulletList">LTSEnablementStack (Ubuntu wiki): <a href="https://learnlinux.link/lts-es"><span class="url">https://learnlinux.link/lts-es</span></a></li>
<li class="bulletList">Ubuntu Server Guide: <a href="https://ubuntu.com/server/docs"><span class="url">https://ubuntu.com/server/docs</span></a></li>
</ul>
<h1 class="heading-1">Join our community on Discord</h1>
<p class="normal">Join our community’s Discord space for discussions with the author and other readers: </p>
<p class="normal"><a href="https://packt.link/LWaZ0"><span class="url">https://packt.link/LWaZ0</span></a></p>
<p class="normal"><img alt="" height="177" src="../Images/QR_Code50046724-1955875156.png" width="177"/></p>
</div>
</div></body></html>