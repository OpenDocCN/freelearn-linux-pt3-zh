- en: '6'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '6'
- en: Selecting a Build System
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 选择构建系统
- en: 'The preceding chapters covered the first four elements of embedded Linux. You
    built a bootloader, kernel, and root filesystem step by step before combining
    them into a basic embedded Linux system. That’s a lot of steps! Now it is time
    to simplify the process by automating as much of it as possible. Embedded Linux
    build systems can help, and we will look at two in particular: Buildroot and The
    Yocto Project. Both are complex tools that require an entire book to explain how
    they work.'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 前几章介绍了嵌入式 Linux 的前四个元素。你逐步构建了引导加载程序、内核和根文件系统，然后将它们组合成一个基本的嵌入式 Linux 系统。这是一个繁琐的过程！现在是时候通过尽可能地自动化来简化这个过程了。嵌入式
    Linux 构建系统能够帮助实现这一点，我们将重点介绍两个：Buildroot 和 Yocto 项目。这两者都是复杂的工具，解释它们的工作原理需要整本书。
- en: In this chapter I will only present the general ideas behind build systems,
    laying the groundwork for *Chapters 7* and *8*. First, I will show you how to
    build a simple image to get an overall feel for the system. Then, I will show
    you how to make some useful modifications to the Nova board and Raspberry Pi 4
    examples from the previous chapters. In subsequent chapters, we will dive deeper
    into The Yocto Project, now the preeminent build system for embedded Linux.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我将仅介绍构建系统背后的基本思想，为*第7章*和*第8章*打下基础。首先，我将展示如何构建一个简单的镜像，以便对系统有一个整体的了解。然后，我将展示如何对前几章中的
    Nova 开发板和 Raspberry Pi 4 示例做一些有用的修改。在接下来的章节中，我们将深入探讨 Yocto 项目，这是当前嵌入式 Linux 的主要构建系统。
- en: 'In this chapter we will cover the following topics:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 本章我们将覆盖以下主题：
- en: Comparing build systems
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 比较构建系统
- en: Distributing binaries
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 分发二进制文件
- en: Introducing Buildroot
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 介绍 Buildroot
- en: Introducing The Yocto Project
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 介绍 Yocto 项目
- en: Technical requirements
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'To follow along with the examples, make sure you have the following:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 为了跟随示例，确保你拥有以下内容：
- en: An Ubuntu 24.04 or later LTS host system with at least 90 GB of free disk space
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 至少具有 90 GB 可用磁盘空间的 Ubuntu 24.04 或更高版本 LTS 主机系统
- en: A microSD card reader and card
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: microSD 卡读卡器和卡片
- en: balenaEtcher for Linux
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 适用于 Linux 的 balenaEtcher
- en: An Ethernet cable and router with an available port for network connectivity
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一根以太网电缆和一个可用端口的路由器，用于网络连接
- en: A USB-to-TTL serial cable with a 3.3 V logic level
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一根 3.3V 逻辑电平的 USB-to-TTL 串口线
- en: Raspberry Pi 4
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Raspberry Pi 4
- en: BeaglePlay
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: BeaglePlay
- en: A 5 V USB-C power supply capable of delivering 3A
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一款能够提供 3A 电流的 5V USB-C 电源
- en: 'The code used in this chapter can be found in the chapter folder in this book’s
    GitHub repository: [https://github.com/PacktPublishing/Mastering-Embedded-Linux-Development/tree/main/Chapter06](https://github.com/PacktPublishing/Mastering-Embedded-Linux-Development/tree/main/Chapter06).'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中使用的代码可以在本书 GitHub 仓库的本章文件夹中找到：[https://github.com/PacktPublishing/Mastering-Embedded-Linux-Development/tree/main/Chapter06](https://github.com/PacktPublishing/Mastering-Embedded-Linux-Development/tree/main/Chapter06)。
- en: Comparing build systems
  id: totrans-20
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 比较构建系统
- en: In [*Chapter 5*](Chapter_05.xhtml#_idTextAnchor138), I described the process
    of creating an image manually as the **Roll Your Own** (**RYO**) process. This
    approach gives you complete control over the software so that you can tailor it
    to do anything you like. If you want to do something truly odd but innovative,
    or if you want to reduce the memory footprint to the smallest size possible, then
    RYO is the way to go. But in most situations, building manually is a waste of
    time and produces inferior, unmaintainable systems.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 在[*第5章*](Chapter_05.xhtml#_idTextAnchor138)中，我描述了手动创建镜像的过程，这就是**自定义构建**（**RYO**）过程。这种方法让你完全掌控软件，以便按需进行定制。如果你想做一些真正奇特却具有创新性的事情，或者你想将内存占用减少到最小，那么自定义构建就是最佳选择。但在大多数情况下，手动构建是浪费时间的，并且会产生不稳定、不可维护的系统。
- en: 'The idea behind a build system is to automate all the steps described up to
    this point. A build system should be able to build some or all of the following
    from upstream source code:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 构建系统的理念是自动化完成到目前为止描述的所有步骤。构建系统应当能够从上游源代码构建以下某些或所有内容：
- en: toolchain
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 工具链
- en: bootloader
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 引导加载程序
- en: kernel
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 内核
- en: root filesystem
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 根文件系统
- en: Building from upstream source code is important for several reasons. It gives
    you the peace of mind that you can rebuild at any time without external dependencies.
    It also means you can debug at the source level and meet your license requirements
    to distribute the code to users where necessary.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 从上游源代码构建非常重要，原因有几个。它能让你放心地在任何时候都可以重新构建，而无需依赖外部组件。这也意味着你可以在源代码层面进行调试，并在必要时满足分发代码给用户的许可证要求。
- en: 'To do its job, a build system must be able to:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 为了完成任务，构建系统必须能够：
- en: Download the source code from upstream, either directly from the version control
    system or as an archive, and cache it locally.
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从上游下载源代码，既可以直接从版本控制系统获取，也可以作为归档文件下载，并将其缓存到本地。
- en: Apply patches to enable cross-compilation, fix architecture-dependent bugs,
    apply local configuration policies, and so on.
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应用补丁以启用交叉编译、修复架构相关的错误、应用本地配置策略等。
- en: Build the various components along with their compile-time and runtime dependencies.
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构建各种组件及其编译时和运行时的依赖关系。
- en: Create a staging area and assemble a root filesystem.
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个暂存区并组装根文件系统。
- en: Create image files in various formats ready to be loaded onto the target.
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建各种格式的镜像文件，准备好加载到目标设备上。
- en: 'Some other useful things are:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 其他一些有用的功能包括：
- en: Add your own packages containing applications or kernel changes.
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加你自己的软件包，包含应用程序或内核更改。
- en: 'Select various root filesystem profiles: large or small, with or without graphics,
    and other features.'
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 选择各种根文件系统配置文件：大或小，有或没有图形界面，及其他功能。
- en: Create a standalone SDK that you can distribute to other developers so they
    don’t have to install the complete build system.
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个独立的 SDK，你可以将其分发给其他开发者，这样他们就不需要安装完整的构建系统。
- en: Track which open source licenses are used by the various packages you selected.
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 跟踪你选择的各种软件包使用了哪些开源许可证。
- en: Have a friendly user interface.
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 提供一个友好的用户界面。
- en: In all cases, build systems encapsulate the components of a system into packages,
    some for the host and some for the target. Each package defines a set of rules
    to get the source, build it, and install the results in the correct location.
    There are dependencies between packages and a mechanism to resolve the dependencies
    and build the set of packages required.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 在所有情况下，构建系统将系统的组件封装为软件包，一些是针对主机的，一些是针对目标的。每个软件包都定义了一组规则，用于获取源代码、编译它，并将结果安装到正确的位置。软件包之间有依赖关系，并且有一个机制来解决这些依赖关系并构建所需的软件包集。
- en: 'Open source build systems have matured over the past few years. There are many
    around, including:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 开源构建系统在过去几年中已经成熟，市面上有很多这样的系统，包括：
- en: '**Buildroot**: Is an easy-to-use system using GNU Make and Kconfig ([https://buildroot.org/](https://buildroot.org/)).'
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Buildroot**：是一个易于使用的系统，使用 GNU Make 和 Kconfig ([https://buildroot.org/](https://buildroot.org/))。'
- en: '**OpenEmbedded**: Is a powerful system and a core component of Yocto ([https://openembedded.org](https://openembedded.org)).'
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**OpenEmbedded**：是一个强大的系统，也是 Yocto 的核心组件 ([https://openembedded.org](https://openembedded.org))。'
- en: '**OpenWrt**: Is a build tool oriented toward building firmware for wireless
    routers ([https://openwrt.org/](https://openwrt.org/)) that supports runtime package
    management out of the box. It is a derivative of Buildroot.'
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**OpenWrt**：是一个面向构建无线路由器固件的构建工具 ([https://openwrt.org/](https://openwrt.org/))，开箱即用支持运行时软件包管理。它是
    Buildroot 的衍生版本。'
- en: '**PTXdist**: Is an open source build system sponsored by Pengutronix ([https://www.ptxdist.org/](https://www.ptxdist.org/)).'
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**PTXdist**：是由 Pengutronix 提供支持的开源构建系统 ([https://www.ptxdist.org/](https://www.ptxdist.org/))。'
- en: '**Yocto**: Extends the OpenEmbedded core with metadata, tools, and documentation.
    It is the most popular embedded Linux build system today ([https://www.yoctoproject.org/](https://www.yoctoproject.org/)).'
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Yocto**：通过元数据、工具和文档扩展了 OpenEmbedded 核心。它是目前最流行的嵌入式 Linux 构建系统 ([https://www.yoctoproject.org/](https://www.yoctoproject.org/))。'
- en: 'I will concentrate on two of them: Buildroot and Yocto. They approach the problem
    in different ways and with different objectives.'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 我将专注于其中的两个：Buildroot 和 Yocto。它们以不同的方式解决问题，并且有不同的目标。
- en: Buildroot has the primary aim of building root filesystem images, hence the
    name. But it can build bootloaders, kernels, and even toolchains as well. It is
    easy to install and configure. Most importantly, Buildroot generates target images
    quickly.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: Buildroot 的主要目标是构建根文件系统镜像，因此得名。但它也可以构建引导加载程序、内核，甚至工具链。它易于安装和配置。最重要的是，Buildroot
    可以快速生成目标镜像。
- en: Yocto is more general in how it defines the target system, so it can build more
    complex embedded devices. Every component is generated as a binary package by
    default using the RPM format. Packages are then combined to make the filesystem
    image. You can install a package manager in the filesystem image that allows you
    to update packages at runtime. In other words, when you build with Yocto, you
    are creating your own custom Linux distribution. Bear in mind that enabling runtime
    package management also means provisioning and running your own corresponding
    package feed repository.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: Yocto 在定义目标系统方面更为通用，因此它可以构建更复杂的嵌入式设备。默认情况下，每个组件都作为二进制包使用 RPM 格式生成。然后将这些包组合起来，制作成文件系统镜像。你可以在文件系统镜像中安装一个包管理器，这样就可以在运行时更新包。换句话说，当你使用
    Yocto 构建时，你是在创建你自己的定制 Linux 发行版。请记住，启用运行时包管理也意味着你需要提供并运行自己对应的包源库。
- en: Distributing binaries
  id: totrans-50
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 分发二进制文件
- en: Mainstream Linux distributions are in most cases constructed from collections
    of binary (precompiled) packages in either RPM or DEB format. **RPM** stands for
    **Red Hat Package Manager** and is used in Red Hat, SUSE, Fedora, and other RPM-based
    distributions. Debian and Debian-derived distributions, including Ubuntu and Mint,
    use the **Debian package manager** (**DEB**) format. There is also a lightweight
    format for embedded devices known as the **Itsy package** (**IPK**) format, which
    is based on DEB.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 主流 Linux 发行版通常是由 RPM 或 DEB 格式的二进制（预编译）包集合构建而成的。**RPM** 代表 **Red Hat 包管理器**，用于
    Red Hat、SUSE、Fedora 以及其他基于 RPM 的发行版。Debian 及其衍生发行版，包括 Ubuntu 和 Mint，使用 **Debian
    包管理器**（**DEB**）格式。此外，还有一种适用于嵌入式设备的轻量级格式，称为 **Itsy 包**（**IPK**）格式，它基于 DEB。
- en: The ability to include a package manager on the device is one of the big differentiators
    between build systems. Once you have a package manager on the target device, you
    have an easy path to deploy new packages and to update the existing ones. I will
    talk about the implications of this in [*Chapter 10*](Chapter_10.xhtml#_idTextAnchor341).
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 在设备上包含包管理器的能力是构建系统之间的一个重要区别。一旦在目标设备上安装了包管理器，就可以轻松部署新包并更新现有的包。我将在[*第 10 章*](Chapter_10.xhtml#_idTextAnchor341)中讨论这方面的影响。
- en: Now for the main event. We will start with Buildroot. As the simpler of the
    two build systems, Buildroot is easier to get started with than Yocto and the
    quickest way of generating a bootable image for all three of our targets.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 现在进入重点。我们将从 Buildroot 开始。作为两种构建系统中更简单的一个，Buildroot 比 Yocto 更容易上手，并且是为我们的三个目标生成可引导镜像的最快方法。
- en: Introducing Buildroot
  id: totrans-54
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍 Buildroot
- en: The current versions of Buildroot can build a toolchain, a bootloader, a kernel,
    and a root filesystem. Buildroot uses GNU Make as its principal build tool. There
    is good online documentation at [https://buildroot.org/docs.html](https://buildroot.org/docs.html)
    along with *The Buildroot user manual* at [https://buildroot.org/downloads/manual/manual.html](https://buildroot.org/downloads/manual/manual.html).
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 目前的 Buildroot 版本可以构建工具链、引导加载程序、内核和根文件系统。Buildroot 使用 GNU Make 作为其主要构建工具。在[https://buildroot.org/docs.html](https://buildroot.org/docs.html)上有很好的在线文档，以及在[https://buildroot.org/downloads/manual/manual.html](https://buildroot.org/downloads/manual/manual.html)上的*Buildroot
    用户手册*。
- en: Background
  id: totrans-56
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 背景
- en: Buildroot was one of the first build systems. It began when the uClinux and
    uClibc projects needed a way to generate a small root filesystem for testing.
    Buildroot became a separate project in late 2001 and continued to evolve through
    2006, after which it went into a dormant phase.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: Buildroot 是最早的构建系统之一。它最初是因为 uClinux 和 uClibc 项目需要一种生成小型根文件系统进行测试的方法。Buildroot
    于 2001 年底成为一个独立的项目，并在 2006 年继续发展，之后进入了一个休眠阶段。
- en: However, since Peter Korsgaard took over stewardship in 2009, it has been developing
    rapidly, adding support for glibc-based toolchains and a greatly increased number
    of packages and target boards. Peter is still the lead maintainer of Buildroot
    and has had a long and illustrious career as a software engineer at Barco in Belgium.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，自从 Peter Korsgaard 在 2009 年接管管理工作以来，Buildroot 发展迅速，增加了对基于 glibc 的工具链的支持，并大幅增加了包和目标板的数量。Peter
    目前仍然是 Buildroot 的首席维护者，并且在比利时 Barco 公司担任软件工程师时，拥有长久而辉煌的职业生涯。
- en: Buildroot is the ancestor of OpenWrt, another popular build system that forked
    from Buildroot around 2004\. The primary focus of OpenWrt is to produce software
    for wireless routers so the package mix is oriented toward networking infrastructure.
    It also has a runtime IPK package manager so that a device can be updated or upgraded
    without a complete reflash of the image. Buildroot and OpenWrt have diverged to
    such an extent that they are now almost completely different build systems. Packages
    built with one are not compatible with the other.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: Buildroot 是 OpenWrt 的祖先，OpenWrt 是另一个流行的构建系统，约在 2004 年从 Buildroot 分支出来。OpenWrt
    的主要目标是为无线路由器生产软件，因此其软件包组合倾向于网络基础设施。它还具有一个运行时的 IPK 包管理器，允许设备在不完全重新刷写镜像的情况下进行更新或升级。Buildroot
    和 OpenWrt 已经发生了如此大的分歧，以至于它们现在几乎是完全不同的构建系统。用一个构建的包无法与另一个系统兼容。
- en: Stable releases and long-term support
  id: totrans-60
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 稳定版本和长期支持
- en: The Buildroot developers produce stable releases four times a year in February,
    May, August, and November. They are marked by Git tags of the form `<year>.02`,
    `<year>.05`, `<year>.08`, and `<year>.11`. Each `<year>.02` release is marked
    for **Long-Term Support** (**LTS**), which means there will be point releases
    to fix security and other important bugs for 12 months after the initial release.
    The `2017.02` release is the first to receive the LTS label.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: Buildroot 开发者每年发布四次稳定版本，分别在二月、五月、八月和十一月。这些版本通过 Git 标签进行标记，形式为 `<year>.02`、`<year>.05`、`<year>.08`
    和 `<year>.11`。每个 `<year>.02` 版本都会被标记为 **长期支持**（**LTS**），意味着在初始发布后的 12 个月内会有补丁发布来修复安全性和其他重要的
    bug。`2017.02` 版本是第一个获得 LTS 标签的版本。
- en: Installing
  id: totrans-62
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 安装
- en: 'You install Buildroot either by cloning the repository or downloading an archive.
    Here is an example of obtaining version `2024.02.6`, which was the latest stable
    version at the time of writing:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过克隆仓库或下载档案来安装 Buildroot。以下是获取 `2024.02.6` 版本的示例，这是本文写作时的最新稳定版本：
- en: '[PRE0]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The equivalent TAR archive is available at [https://buildroot.org/downloads/](https://buildroot.org/downloads/).
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 相应的 TAR 档案可以在 [https://buildroot.org/downloads/](https://buildroot.org/downloads/)
    获取。
- en: Read the section titled *System requirements* in *The Buildroot user manual*,
    available at [https://buildroot.org/downloads/manual/manual.html,](https://buildroot.org/downloads/manual/manual.html,)
    and make sure to install all the packages listed there.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 阅读《Buildroot 用户手册》中的 *系统要求* 部分，该手册可以在 [https://buildroot.org/downloads/manual/manual.html](https://buildroot.org/downloads/manual/manual.html)
    上找到，并确保安装手册中列出的所有软件包。
- en: Configuring
  id: totrans-67
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 配置
- en: Buildroot uses the kernel Kconfig/Kbuild mechanism I described in the *Understanding
    kernel configuration* section from [*Chapter 4*](Chapter_04.xhtml#_idTextAnchor096).
    You can configure Buildroot from scratch directly using `make menuconfig` (`xconfig`
    or `gconfig`). Or you can choose one of the 100+ configurations for various development
    boards that you can find stored in the `configs` directory. Typing `make list-defconfigs`
    lists all the default configurations.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: Buildroot 使用我在[*理解内核配置*](Chapter_04.xhtml#_idTextAnchor096)部分中描述的内核 Kconfig/Kbuild
    机制。你可以通过直接使用`make menuconfig`（`xconfig` 或 `gconfig`）从零开始配置 Buildroot。或者你也可以选择
    `configs` 目录中存储的 100 多个不同开发板的配置之一。输入 `make list-defconfigs` 会列出所有默认配置。
- en: 'Let’s begin by building a default configuration that you can run on the 64-bit
    Arm QEMU emulator:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从构建一个默认配置开始，这个配置可以在 64 位 Arm QEMU 模拟器上运行：
- en: '[PRE1]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '**IMPORTANT NOTE**'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: '**重要提示**'
- en: Do not tell GNU Make how many parallel jobs to run with the `-j` option. Buildroot
    will make optimum use of your CPU cores all by itself. If you want to limit the
    number of jobs, then run `make menuconfig` and look for **Number of jobs to run
    simultaneously** under **Build options**.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 不要使用 `-j` 选项告诉 GNU Make 要运行多少个并行任务。Buildroot 会自动充分利用你的 CPU 核心。如果你想限制任务数量，可以运行
    `make menuconfig` 并在 **构建选项**下查找 **同时运行的任务数**。
- en: 'The build can take up to an hour depending on how many CPU cores your host
    system has and the speed of your internet. It will download approximately 502
    MB of code and consume about 12 GB of disk space. When it completes, you will
    find two new directories have been created:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 构建过程可能需要一个小时，具体时间取决于你的主机系统有多少个 CPU 核心以及网络的速度。它将下载大约 502 MB 的代码，并消耗大约 12 GB 的磁盘空间。完成后，你会发现创建了两个新的目录：
- en: '`dl`: Contains archives of the upstream projects that Buildroot has built.'
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`dl`：包含 Buildroot 所构建的上游项目的档案。'
- en: '`output`: Contains all the intermediate and final compiled artifacts.'
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`output`：包含所有中间和最终编译的产物。'
- en: 'Inside `output` you will find the following subdirectories:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `output` 目录中，你会找到以下子目录：
- en: '`build`: Contains the build directory for each component.'
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`build`：包含每个组件的构建目录。'
- en: '`host`: Contains various tools required by Buildroot on the host, including
    the executables of the toolchain (in `output/host/usr/bin`).'
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`host`：包含 Buildroot 在主机上所需的各种工具，包括工具链的可执行文件（位于 `output/host/usr/bin`）。'
- en: '`images`: Contains the finished results of the build. Depending on what you
    selected when configuring, you will find a bootloader, a kernel, and one or more
    root filesystem images.'
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`images`：包含构建的最终结果。根据你在配置时选择的内容，你将找到引导加载程序、内核以及一个或多个根文件系统映像。'
- en: '`staging`: Is a symbolic link to the `sysroot` of the toolchain. The name of
    the link is a little confusing because it does not point to a staging area as
    defined in [*Chapter 5*](Chapter_05.xhtml#_idTextAnchor138).'
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`staging`：是工具链 `sysroot` 的符号链接。这个链接的名称可能有些令人困惑，因为它并没有指向如 [*第 5 章*](Chapter_05.xhtml#_idTextAnchor138)
    中定义的暂存区域。'
- en: '`target`: Is the staging area for the root directory. Note that you cannot
    use it as a root filesystem because the file ownership and permissions are not
    set correctly. Buildroot uses a device table as described in the previous chapter
    to set ownership and permissions when the filesystem image is created in the `image`
    directory.'
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`target`：是根目录的暂存区域。请注意，您不能将其用作根文件系统，因为文件的所有权和权限没有正确设置。Buildroot 使用前一章中描述的设备表，在创建
    `image` 目录中的文件系统映像时设置所有权和权限。'
- en: Running
  id: totrans-82
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 运行
- en: Some of the sample targets have a subfolder in the `board` directory containing
    custom configuration files and informationon how to install the results.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 一些示例目标在 `board` 目录中有一个子文件夹，包含自定义配置文件和安装结果的相关信息。
- en: 'In the case of the system you just built, the relevant file is `board/qemu/aarch64-virt/readme.txt`.
    This `readme.txt` file tells you how to start QEMU with this target. Assuming
    you have already installed `qemu-system-aarch64` as described in [*Chapter 1*](Chapter_01.xhtml#_idTextAnchor016),
    you can run QEMU with this command:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 对于你刚刚构建的系统，相关的文件是 `board/qemu/aarch64-virt/readme.txt`。这个 `readme.txt` 文件告诉你如何使用该目标启动
    QEMU。假设你已经按照 [*第 1 章*](Chapter_01.xhtml#_idTextAnchor016) 中的描述安装了 `qemu-system-aarch64`，你可以使用以下命令运行
    QEMU：
- en: '[PRE2]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'There is a script named `start-qemu.sh` in `output/images` that includes the
    command. When QEMU boots up, you should see the kernel boot messages appear in
    the same terminal window where you started QEMU followed by a login prompt:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `output/images` 中有一个名为 `start-qemu.sh` 的脚本，其中包含命令。当 QEMU 启动时，你应该能看到内核启动信息出现在启动
    QEMU 的同一终端窗口中，随后是登录提示符：
- en: '[PRE3]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Log in as `root` with no password.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 使用无密码的 `root` 用户登录。
- en: To exit QEMU type *Ctrl + A* and then *x*.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 要退出 QEMU，输入 *Ctrl + A*，然后按 *x*。
- en: Targeting real hardware
  id: totrans-90
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 定位真实硬件
- en: 'The steps for configuring and building a bootable image for Raspberry Pi 4
    are almost the same as for 64-bit Arm QEMU:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 配置和构建 Raspberry Pi 4 可启动映像的步骤几乎与构建 64 位 Arm QEMU 时相同：
- en: '[PRE4]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The finished image is written to a file named `output/images/sdcard.img`. The
    `post-image.sh` script and the `genimage.cfg.in` configuration file used to write
    the image file are both located in the `board/raspberrypi4-64 directory`. To write
    `sdcard.img` onto a microSD card and boot it on your Raspberry Pi 4:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 最终的映像被写入名为 `output/images/sdcard.img` 的文件中。用于写入映像文件的 `post-image.sh` 脚本和 `genimage.cfg.in`
    配置文件都位于 `board/raspberrypi4-64` 目录中。要将 `sdcard.img` 写入 microSD 卡并在 Raspberry Pi
    4 上启动：
- en: Insert a microSD card into your Linux host machine.
  id: totrans-94
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 microSD 卡插入你的 Linux 主机。
- en: Launch balenaEtcher.
  id: totrans-95
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 启动 balenaEtcher。
- en: Click **Flash from file** from Etcher.
  id: totrans-96
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 Etcher 中点击 **Flash from file** 按钮。
- en: Locate the `sdcard.img` image that you built for Raspberry Pi 4 and open it.
  id: totrans-97
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定位并打开你为 Raspberry Pi 4 构建的 `sdcard.img` 映像。
- en: Click **Select target** from Etcher.
  id: totrans-98
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 Etcher 中点击 **Select target** 按钮。
- en: Select the microSD card that you inserted in *step 1*.
  id: totrans-99
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择你在 *步骤 1* 中插入的 microSD 卡。
- en: Click **Flash** from Etcher to write the image.
  id: totrans-100
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 Etcher 中点击 **Flash** 按钮以写入映像。
- en: Eject the microSD card when Etcher is done flashing.
  id: totrans-101
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当 Etcher 完成闪存写入时，弹出 microSD 卡。
- en: Insert the microSD card into your Raspberry Pi 4.
  id: totrans-102
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 microSD 卡插入 Raspberry Pi 4。
- en: Apply power to Raspberry Pi 4 by way of the USB-C port.
  id: totrans-103
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过 USB-C 端口为 Raspberry Pi 4 提供电源。
- en: Confirm that your Raspberry Pi 4 booted successfully by plugging it into Ethernet
    and observing that the network activity lights blink. This default image is very
    minimal and includes little else besides BusyBox. To SSH into your Raspberry Pi
    4, you will need to add an SSH server like `dropbear` or `openssh` to your Buildroot
    image configuration.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 通过将树莓派4插入以太网并观察网络活动指示灯闪烁，确认树莓派4已成功启动。这个默认镜像非常简约，除了BusyBox几乎不包含其他内容。要通过SSH连接到树莓派4，您需要在Buildroot镜像配置中添加一个SSH服务器，例如`dropbear`或`openssh`。
- en: Creating a custom BSP
  id: totrans-105
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建自定义BSP
- en: Now let’s use Buildroot to create a **Board Support Package** (**BSP**) for
    our Nova board using the same versions of U-Boot and Linux from earlier chapters.
    You can see the changes I made to Buildroot during this section of the book under
    `MELD/Chapter06/buildroot`.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们使用Buildroot为我们的Nova开发板创建一个**板级支持包**（**BSP**），并使用前几章中相同版本的U-Boot和Linux。您可以在本书本节中的`MELD/Chapter06/buildroot`下查看我对Buildroot所做的更改。
- en: 'The recommended places to store your changes are:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 推荐存储更改的位置是：
- en: '`board/<organization>/<device>`: Contains any patches, blobs, extra build steps,
    and configuration files for Linux, U-Boot, and other components'
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`board/<organization>/<device>`：包含Linux、U-Boot以及其他组件的补丁、二进制文件、额外构建步骤和配置文件'
- en: '`configs/<device>_defconfig`: Contains the default configuration for the board'
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`configs/<device>_defconfig`：包含该开发板的默认配置'
- en: '`package/<organization>/<package_name>`: Is the place to put any additional
    packages for this board'
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`package/<organization>/<package_name>`：用于存放此开发板的任何附加包'
- en: 'Create a directory to store changes to the Nova board:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个目录来存储对Nova开发板的更改：
- en: '[PRE5]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Copy `nova_defconfig` from `MELD/Chapter06/buildroot/configs` to `buildroot`/`configs`:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 将`nova_defconfig`从`MELD/Chapter06/buildroot/configs`复制到`buildroot`/`configs`：
- en: '[PRE6]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Copy the contents of `MELD/Chapter06/buildroot/board/meld/nova` to `buildroot/board/meld/nova`:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 将`MELD/Chapter06/buildroot/board/meld/nova`中的内容复制到`buildroot/board/meld/nova`：
- en: '[PRE7]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Clean the artifacts from any previous build (always do this when changing configurations):'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 清理之前构建的所有产物（更改配置时总是要这么做）：
- en: '[PRE8]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Select the Nova configuration:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 选择Nova配置：
- en: '[PRE9]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The `make nova_defconfig` command configures Buildroot to build an image targeting
    the BeaglePlay. This configuration is a good starting point, but we still need
    to customize it for our Nova board. Let’s start by selecting the custom U-Boot
    patch we created for Nova.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: '`make nova_defconfig`命令将配置Buildroot，以便构建一个针对BeaglePlay的镜像。这个配置是一个良好的起点，但我们仍然需要为Nova开发板定制它。我们从选择为Nova创建的自定义U-Boot补丁开始。'
- en: U-Boot
  id: totrans-122
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: U-Boot
- en: In [*Chapter 3*](Chapter_03.xhtml#_idTextAnchor061)*,* we created a custom bootloader
    for Nova based on the `f036fb` version of TI’s U-Boot fork and created a patch
    file for it saved as `MELD/Chapter03/0001-BSP-for-Nova.patch`. We can configure
    Buildroot to select the same version of U-Boot and apply our patch. Running `make
    nova_defconfig` already set the U-Boot version to `f036fb`.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 在[*第3章*](Chapter_03.xhtml#_idTextAnchor061)中，我们为Nova创建了基于TI的U-Boot分支`f036fb`版本的自定义引导加载程序，并为其创建了一个补丁文件，保存为`MELD/Chapter03/0001-BSP-for-Nova.patch`。我们可以配置Buildroot来选择相同版本的U-Boot并应用我们的补丁。运行`make
    nova_defconfig`已经将U-Boot版本设置为`f036fb`。
- en: 'Copy the patch file into `board/meld/nova`:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 将补丁文件复制到`board/meld/nova`：
- en: '[PRE10]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Now run `make menuconfig` and drill down into the **Bootloaders** page. From
    that page, navigate down to **Custom U-Boot patches** and verify the path to our
    patch as shown:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 现在运行`make menuconfig`并进入**引导加载程序**页面。从该页面，进入**自定义U-Boot补丁**，并验证我们的补丁路径，如下所示：
- en: '![Figure 6.1 – Selecting custom U-Boot patches](img/B18466_06_01.png)'
  id: totrans-127
  prefs: []
  type: TYPE_IMG
  zh: '![图6.1 – 选择自定义U-Boot补丁](img/B18466_06_01.png)'
- en: Figure 6.1 – Selecting custom U-Boot patches
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.1 – 选择自定义U-Boot补丁
- en: Now that we’ve patched U-Boot for our Nova board, the next step is patching
    the kernel.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经为Nova开发板打了U-Boot补丁，接下来的步骤是为内核打补丁。
- en: Linux
  id: totrans-130
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Linux
- en: 'In [*Chapter 4*](Chapter_04.xhtml#_idTextAnchor096)*,* we based the kernel
    on Linux 6.6.46 and supplied a new device tree from `MELD/Chapter04/nova.dts`.
    Running `make nova_defconfig` already set the kernel version to Linux 6.6.46 and
    changed the kernel series used for kernel headers to match the kernel being built.
    Back out of the **Bootloaders** page and drill down into the **Kernel** page.
    Confirm that the value of **Out-of-tree Device Tree Source file paths** is set
    to `board/meld/nova/nova.dts`:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 在[*第4章*](Chapter_04.xhtml#_idTextAnchor096)中，我们基于Linux 6.6.46版本的内核，并提供了一个新的设备树文件，来自`MELD/Chapter04/nova.dts`。运行`make
    nova_defconfig`已经将内核版本设置为Linux 6.6.46，并将内核头文件使用的内核系列更改为与所构建内核匹配的版本。退出**引导加载程序**页面，并进入**内核**页面。确认**非树设备树源文件路径**的值已设置为`board/meld/nova/nova.dts`：
- en: '![Figure 6.2 – Selecting the device tree source](img/B18466_06_02.png)'
  id: totrans-132
  prefs: []
  type: TYPE_IMG
  zh: '![图6.2 – 选择设备树源](img/B18466_06_02.png)'
- en: Figure 6.2 – Selecting the device tree source
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.2 – 选择设备树源
- en: Now that we’ve defined the device tree, let’s build the system image complete
    with the kernel and root filesystem.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经定义了设备树，让我们构建包含内核和根文件系统的系统映像。
- en: Build
  id: totrans-135
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 构建
- en: 'In the last stage of the build, Buildroot uses a tool named `genimage` to create
    an image for the microSD that we can copy directly to the card. We need a configuration
    file to lay out the image in the right way. Modify the existing `board/meld/nova/genimage.cfg`
    file by replacing `"k3-am625-beagleplay.dtb"` with `"nova.dtb"` as shown:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 在构建的最后阶段，Buildroot使用一个名为`genimage`的工具来为microSD创建一个映像，我们可以直接将它复制到卡中。我们需要一个配置文件来以正确的方式布局映像。通过替换现有的`board/meld/nova/genimage.cfg`文件中的`"k3-am625-beagleplay.dtb"`为`"nova.dtb"`，如下所示：
- en: '[PRE11]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: This will create a file named `sdcard.img`, which contains two partitions named
    `u-boot` and `rootfs`. The first contains the boot files listed in `boot.vfat`
    and the second contains the root filesystem image named `rootfs.ext4`, which will
    be generated by Buildroot.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 这将创建一个名为`sdcard.img`的文件，其中包含两个分区，分别为`u-boot`和`rootfs`。第一个分区包含`boot.vfat`中列出的启动文件，第二个分区包含名为`rootfs.ext4`的根文件系统映像，这将由Buildroot生成。
- en: 'Finally, we need a `post-image.sh` script that will call `genimage` and create
    the microSD card image. See `board/meld/nova/post-image.sh`:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们需要一个`post-image.sh`脚本来调用`genimage`并创建microSD卡映像。请参见`board/meld/nova/post-image.sh`：
- en: '[PRE12]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: This script copies the R5 firmware image into the `output/images` directory
    and runs `genimage` with our configuration file.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 这个脚本将R5固件映像复制到`output/images`目录，并使用我们的配置文件运行`genimage`。
- en: 'Note that `post-image.sh` needs to be executable; otherwise the build will
    fail at the end:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，`post-image.sh`需要具有可执行权限，否则构建将在最后失败：
- en: '[PRE13]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Now, run `make menuconfig` and drill down into the **System configuration**
    page. From that page, navigate down to **Custom scripts to run before creating
    filesystem images** and notice the path to our `post-image.sh` script:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，运行`make menuconfig`并进入**系统配置**页面。在该页面，向下导航到**创建文件系统映像前要运行的自定义脚本**，注意到我们`post-image.sh`脚本的路径：
- en: '![Figure 6.3 – Selecting custom scripts to run after creating filesystem images](img/B18466_06_03.png)'
  id: totrans-145
  prefs: []
  type: TYPE_IMG
  zh: '![图6.3 – 选择在创建文件系统映像后要运行的自定义脚本](img/B18466_06_03.png)'
- en: Figure 6.3 – Selecting custom scripts to run after creating filesystem images
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.3 – 选择在创建文件系统映像后要运行的自定义脚本
- en: 'Finally, you can build Linux for the Nova board just by typing `make`. When
    the build is done, you will see these files in the `output/images` directory:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，你只需输入`make`命令即可为Nova板构建Linux。当构建完成后，你将在`output/images`目录中看到这些文件：
- en: '[PRE14]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: To test it, insert a microSD card into your card reader and use balenaEtcher
    to write `output/images/sdcard.img` out to a microSD card like we did for the
    Raspberry Pi 4\. There is no need to format the microSD beforehand like we did
    in the previous chapter because `genimage` has created the exact disk layout required.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 为了测试它，将microSD卡插入读卡器，并使用balenaEtcher将`output/images/sdcard.img`写入microSD卡，就像我们之前为Raspberry
    Pi 4所做的那样。无需像上一章那样先格式化microSD卡，因为`genimage`已创建了所需的磁盘布局。
- en: 'Having shown that our custom configuration for the Nova board works, it would
    be nice to save our changes back to the `nova_defconfig` file so that we and others
    can use it again. You can do that with this command:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经展示了我们为Nova板创建的自定义配置有效，现在最好将我们的更改保存回`nova_defconfig`文件，以便我们和其他人可以再次使用它。你可以通过以下命令来实现：
- en: '[PRE15]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Now you have a custom Buildroot configuration for the Nova board. You can retrieve
    this configuration by typing the following command:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你有了一个针对Nova板的自定义Buildroot配置。你可以通过输入以下命令来获取这个配置：
- en: '[PRE16]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: With that, we have successfully configured Buildroot. In the next section, we
    will learn how to add our own code to a Buildroot image.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 至此，我们已成功配置了Buildroot。在接下来的部分，我们将学习如何将自己的代码添加到Buildroot映像中。
- en: Adding your own code
  id: totrans-155
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 添加你自己的代码
- en: Suppose you develop a program and you want to include it in the build. You have
    two options. Firstly, build it separately using its own build system and then
    roll the binary into the final build as an overlay. Secondly, create a Buildroot
    package that can be selected from the menu and build it like any other.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你开发了一个程序，并且想将它包含在构建中。你有两种选择。首先，可以单独构建它，使用它自己的构建系统，然后将二进制文件作为覆盖层放入最终构建中。其次，创建一个Buildroot包，可以从菜单中选择并像其他任何包一样构建它。
- en: Overlays
  id: totrans-157
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 覆盖
- en: 'An overlay is simply a directory structure that is copied over the top of the
    Buildroot root filesystem at a later stage in the build process. It can contain
    executables, libraries, and anything else you may want to include. Note that any
    compiled code must be compatible with the libraries deployed at runtime, which
    means that it must be compiled with the same toolchain that Buildroot uses. Using
    the Buildroot toolchain is quite easy; just add it to `PATH`:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 覆盖层（overlay）只是一个目录结构，它会在构建过程中稍后的阶段覆盖到Buildroot根文件系统上。它可以包含可执行文件、库文件和你可能想要包含的任何其他内容。请注意，任何编译过的代码必须与运行时部署的库兼容，这意味着它必须使用与Buildroot相同的工具链进行编译。使用Buildroot工具链非常简单，只需将其添加到`PATH`中：
- en: '[PRE17]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'The prefix for the toolchain is `<ARCH>-linux-`. So, to compile a simple program,
    you would do something like this:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 工具链的前缀是`<ARCH>-linux-`。因此，要编译一个简单的程序，你可以做类似下面的操作：
- en: '[PRE18]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Once you have compiled your program with the correct toolchain, install the
    executables and other supporting files into a staging area and mark it as an overlay
    for Buildroot. For the `helloworld` example, you can put it in the `board/meld/nova`
    directory:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你用正确的工具链编译了你的程序，将可执行文件和其他支持文件安装到临时区，并将其标记为Buildroot的覆盖层。对于`helloworld`示例，你可以将其放在`board/meld/nova`目录下：
- en: '[PRE19]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Finally, set `BR2_ROOTFS_OVERLAY` to the path pointing at the overlay. It can
    be configured in `menuconfig` with the **System configuration | Root filesystem
    overlay directories** option.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，将`BR2_ROOTFS_OVERLAY`设置为指向覆盖层的路径。可以在`menuconfig`中通过**系统配置 | 根文件系统覆盖目录**选项进行配置。
- en: Adding a package
  id: totrans-165
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 添加一个包
- en: '[PRE20]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: '**IMPORTANT NOTE**'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: '**重要提醒**'
- en: Note that a Buildroot package does not contain the code, just the instructions
    to get the code by downloading a tarball, doing `git clone`, or whatever is necessary
    to obtain the upstream source.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，Buildroot包不包含代码，只是包含获取代码的指令，可能是下载一个tar包，执行`git clone`，或任何获取上游源代码所需的操作。
- en: The makefile is written in a format expected by Buildroot and contains directives
    that allow Buildroot to download, configure, compile, and install the program.
    Writing a new package makefile is a complex operation which is covered in detail
    in *The Buildroot user manual*.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: Makefile是按照Buildroot预期的格式编写的，包含指令，允许Buildroot下载、配置、编译并安装程序。编写一个新的包的Makefile是一个复杂的操作，详细内容可以参考*Buildroot用户手册*。
- en: 'Here is an example that shows you how to create a package for a simple program
    such as our `helloworld` program. Begin by creating a `package/helloworld` subdirectory
    with a `Config.in` file that looks like this:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是一个示例，展示如何为像`helloworld`这样的简单程序创建一个包。首先，创建一个`package/helloworld`子目录，并在其中创建一个类似如下的`Config.in`文件：
- en: '[PRE21]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: The first line must be of the format `BR2_PACKAGE_<uppercase package name>`.
    This is followed by `bool` and the package name as it will appear in the configuration
    menu. The second line is what enables a user to select this package. The `help`
    section is optional but usually a good idea because it acts as self-documentation.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 第一行必须是`BR2_PACKAGE_<大写包名>`的格式。接下来是`bool`和包名，这将在配置菜单中显示。第二行是启用用户选择此包的部分。`help`部分是可选的，但通常是一个好主意，因为它起到了自我文档的作用。
- en: 'Link the new package into the **Target Packages** menu by editing `package/Config.in`
    and sourcing the configuration file as shown below:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 通过编辑`package/Config.in`并引用配置文件，如下所示，将新包链接到**目标包**菜单中：
- en: '[PRE22]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: You could append this new `helloworld` package to an existing submenu, but it’s
    cleaner to create a new submenu with only our package and insert it before the
    **Audio and video applications** menu.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以将这个新的`helloworld`包附加到现有的子菜单中，但创建一个只包含我们包的新子菜单，并将其插入到**音频和视频应用**菜单之前会更加简洁。
- en: 'After inserting the **My programs** menu into `package/Config.in`, create a
    `package/helloworld/helloworld.mk` file to supply the data needed by Buildroot:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 在将**我的程序**菜单插入到`package/Config.in`后，创建一个`package/helloworld/helloworld.mk`文件，以提供Buildroot所需的数据：
- en: '[PRE23]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: You can find my `helloworld` package in the book’s code archive at `MELD/Chapter06/buildroot/package/helloworld`
    and the source code for the program in `MELD/Chapter06/helloworld`. The location
    of the code is hardcoded to a local path name.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在书籍的代码档案中找到我的`helloworld`包，路径是`MELD/Chapter06/buildroot/package/helloworld`，程序的源代码位于`MELD/Chapter06/helloworld`。代码的位置是硬编码的本地路径名称。
- en: In a more realistic case, you would get the code from a source code system or
    from a central server of some kind. There are details on how to do this in *The
    Buildroot user manual* and plenty of examples in other packages.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 在更现实的情况下，你会从源代码系统或某种中央服务器获取代码。有关如何操作的详细信息可以在*Buildroot用户手册*中找到，其他包中也有大量示例。
- en: License compliance
  id: totrans-180
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 许可证合规性
- en: 'Buildroot is based on open source software. So are the packages it compiles.
    At some point during the project, you should check the licenses by running:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: Buildroot基于开源软件，所编译的包也是如此。在项目的某个阶段，你应该通过运行以下命令检查许可证：
- en: '[PRE24]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: The license information is gathered in the `output/legal-info` directory. There
    are summaries of the licenses used to compile the host tools in `host-manifest.csv`
    and on the target in `manifest.csv`. There is more information in the `README`
    file and in *The Buildroot user manual*.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 许可信息会被收集到`output/legal-info`目录中。用于编译主机工具的许可证摘要保存在`host-manifest.csv`中，目标系统上的摘要保存在`manifest.csv`中。更多信息请参考`README`文件和*Buildroot用户手册*。
- en: Now let’s switch build systems and start learning about The Yocto Project.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们切换构建系统，开始学习Yocto项目。
- en: Introducing The Yocto Project
  id: totrans-185
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍Yocto项目
- en: The Yocto Project is a more complex beast than Buildroot. Not only can it build
    toolchains, bootloaders, kernels, and root filesystems, but it can generate an
    entire Linux distribution for you with binary packages that can be installed at
    runtime. The build process is structured around groups of recipes written using
    a combination of Python and shell script. The Yocto Project includes a task scheduler
    called **BitBake** that produces whatever you have configured from the recipes.
    There is plenty of online documentation at [https://www.yoctoproject.org/](https://www.yoctoproject.org/).
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: Yocto项目比Buildroot更加复杂。它不仅可以构建工具链、引导加载程序、内核和根文件系统，还能为你生成一个完整的Linux发行版，其中的二进制包可以在运行时安装。构建过程围绕着一组使用Python和Shell脚本编写的配方进行。Yocto项目包括一个名为**BitBake**的任务调度器，它根据配方生成你所配置的内容。有关更多在线文档，请访问[https://www.yoctoproject.org/](https://www.yoctoproject.org/)。
- en: Background
  id: totrans-187
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 背景
- en: The structure of The Yocto Project makes more sense if you look at the background
    first. Its roots are in **OpenEmbedded** ([https://openembedded.org](https://openembedded.org)),
    which grew out of a number of projects to port Linux to various hand-held computers,
    including the Sharp Zaurus and the Compaq iPAQ. OpenEmbedded came to life in 2003
    as the build system for those hand-held computers. Soon after, other developers
    began to use it as a general build system for devices running embedded Linux.
    It was developed and continues to be developed by an enthusiastic community of
    programmers.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 如果先了解背景，Yocto项目的结构就更加清晰。它的根源在于**OpenEmbedded**（[https://openembedded.org](https://openembedded.org)），OpenEmbedded源自多个项目，旨在将Linux移植到各种手持计算机上，包括Sharp
    Zaurus和Compaq iPAQ。OpenEmbedded于2003年诞生，作为这些手持计算机的构建系统。此后，其他开发者开始将它作为运行嵌入式Linux设备的通用构建系统。OpenEmbedded由一个充满热情的程序员社区开发并持续发展。
- en: The OpenEmbedded project set out to create a set of binary packages using the
    compact IPK format. These packages could then be installed on the target at runtime
    to create a variety of systems. It did this by creating recipes for each package
    and using BitBake as the task scheduler. OpenEmbedded is very flexible. By supplying
    the right metadata, you can create an entire Linux distribution according to your
    specifications.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: OpenEmbedded项目的目标是使用紧凑的IPK格式创建一组二进制包。这些包可以在运行时安装到目标系统上，以创建各种系统。它通过为每个包创建配方，并使用BitBake作为任务调度器来实现这一点。OpenEmbedded非常灵活。通过提供正确的元数据，你可以根据自己的需求创建一个完整的Linux发行版。
- en: Back in 2005, Richard Purdie, then a developer at OpenedHand, created a fork
    of OpenEmbedded that had a more conservative choice of packages and created releases
    that were stable over a period of time. He named it **Poky** (rhymes with hockey)
    after the Japanese snack. Although Poky was a fork, OpenEmbedded and Poky continued
    to track each other, sharing updates and keeping architectures in step. Intel
    bought OpenedHand in 2008 and transferred Poky to the Linux Foundation in 2010
    when they formed The Yocto Project.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 2005年，时任OpenedHand开发者的Richard Purdie创建了一个OpenEmbedded的分支，选择了更加保守的包，并创建了在一段时间内稳定的版本。他将其命名为**Poky**（发音类似hockey），以一种日本小吃命名。虽然Poky是一个分支，但OpenEmbedded和Poky依然保持同步，分享更新并保持架构一致。英特尔在2008年收购了OpenedHand，并于2010年将Poky移交给Linux基金会，成立了Yocto项目。
- en: Since 2010, the common components of OpenEmbedded and Poky have been combined
    into a separate project known as **OpenEmbedded Core**, or just **OE-Core**.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
- en: 'The Yocto Project collects together several components, the most important
    of which are:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
- en: '**OE-Core**: Is the core metadata that is shared with OpenEmbedded.'
  id: totrans-193
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**BitBake**: Is the task scheduler that is shared with OpenEmbedded and other
    projects.'
  id: totrans-194
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Poky**: Is the reference distribution. The Git repo for Poky also includes
    a `meta-yocto-bsp` layer with reference hardware machines.'
  id: totrans-195
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Documentation**: Is the user manuals and developer guides for each component.'
  id: totrans-196
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Toaster**: is a web-based interface to BitBake and its metadata.'
  id: totrans-197
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Yocto provides a stable base that can be used as-is or extended using **meta
    layers** which I will discuss later in this chapter. Many SoC vendors provide
    BSPs for their devices in this way. Meta layers can also be used to create extended
    or different build systems. Some are open source like Poky and others are commercial
    like Wind River Linux. Yocto has a branding and compatibility testing scheme to
    ensure that there is interoperability between components. You will see statements
    like “Yocto Project compatible” on various web pages.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
- en: Consequently, you should think of Yocto as the foundation for a whole sector
    of embedded Linux in addition to being a complete build system in its own right.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
- en: '**IMPORTANT NOTE**'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
- en: You may be wondering about the name. It turns out *yocto* is the SI prefix for
    10^(-24) in the same way that *micro* is 10^(-6). Why name the project Yocto?
    The name was chosen partly to indicate that it could build very small Linux systems
    (although to be fair so can other build systems). It is also a dig at the now
    defunct Ångström Distribution, which was based on OpenEmbedded. An Ångström is
    10^(10). That’s huge compared to a *yocto*!
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
- en: Stable releases and supports
  id: totrans-202
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Routinely, there is a release of Yocto every six months: in April and October.
    They are principally known by their code names, but it is also useful to know
    their Yocto and BitBake version numbers. Here is a table of the six most recent
    releases at the time of writing:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
- en: '| **Code Name** | **Release Date** | **Yocto Version** | **BitBake Version**
    |'
  id: totrans-204
  prefs: []
  type: TYPE_TB
- en: '| Scarthgap | April 2024 | 5.0 | 2.8 |'
  id: totrans-205
  prefs: []
  type: TYPE_TB
- en: '| Nanbield | November 2023 | 4.3 | 2.6 |'
  id: totrans-206
  prefs: []
  type: TYPE_TB
- en: '| Mickledore | May 2023 | 4.2 | 2.4 |'
  id: totrans-207
  prefs: []
  type: TYPE_TB
- en: '| Langdale | October 2022 | 4.1 | 2.2 |'
  id: totrans-208
  prefs: []
  type: TYPE_TB
- en: '| Kirkstone | May 2022 | 4.0 | 2.0 |'
  id: totrans-209
  prefs: []
  type: TYPE_TB
- en: '| Honister | October 2021 | 3.4 | 1.52 |'
  id: totrans-210
  prefs: []
  type: TYPE_TB
- en: Table 6.1 – Six most recent releases of Yocto
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
- en: The stable releases are supported with security and critical bug fixes for the
    current release cycle and the next cycle. In other words, each stable version
    is supported for approximately 12 months after release. In addition to stable
    releases, Yocto also provides LTS releases. The 3.1 (dunfell) release of Yocto
    back in April 2020 was the first LTS release. The LTS designation means that the
    version of Yocto will receive defect fixes and updates for an extended period
    of two years. Consequently, the plan going forward is to choose an LTS release
    of Yocto every two years.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
- en: As with Buildroot, if you want continued support, you can update to the next
    stable release or you can backport changes to your version. With Yocto, you also
    have the option of commercial support for several years from operating system
    vendors such as Siemens and Wind River.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
- en: Installing The Yocto Project
  id: totrans-214
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To get a copy of The Yocto Project, clone the repo choosing the code name (`scarthgap`
    in this case) as the branch:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Since we are building images for BeaglePlay, we also need to clone the `meta-ti`
    repo:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'And since the `meta-ti-bsp` layer depends on the `meta-arm` layer, we must
    clone that repo well:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Note that both the `meta-ti` and `meta-arm` branch names must match the Yocto
    code name to ensure these additional layers are compatible with the scarthgap
    version of Yocto. It is also good practice to run `git pull` periodically to grab
    the latest bug fixes and security patches from all the remote branches.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
- en: Read the *Compatible Linux Distribution* and *Build Host Packages* sections
    in the *Yocto Project Quick Build* guide ([https://docs.yoctoproject.org/brief-yoctoprojectqs/](https://docs.yoctoproject.org/brief-yoctoprojectqs/)).
    Make sure that the essential packages for your Ubuntu host distribution are installed
    on your host computer. The next step is configuring.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
- en: '**IMPORTANT NOTE**'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
- en: 'Ubuntu 24.04 LTS (Noble Numbat) was not officially supported by The Yocto Project
    at the time of writing. Upon Noble Numbat’s release, users experienced numerous
    BitBake errors related to permissions. These errors were a result of increased
    security restrictions placed on the operating system by AppArmor. To temporarily
    disable these AppArmor protections:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
- en: '`$ echo 0 | sudo tee /proc/sys/kernel/apparmor_restrict_unprivileged_userns`'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
- en: Remember to rerun this command every time you reboot your Ubuntu host before
    using Yocto.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
- en: Configuring
  id: totrans-227
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let’s begin by building the 64-bit Arm QEMU emulator. Start by sourcing a script
    to set up the environment:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: This creates a working directory for you named `build` and makes it the current
    directory. All the configuration, intermediate, and target image files will be
    put in this directory. You must source this script each time you want to work
    on this project.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
- en: 'To choose a different working directory, add it as a parameter to `oe-init-build-env`
    like so:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: This will put you into the `build-qemu-arm64` directory. This way, you can have
    several build directories, each for a different project. You choose which one
    you want to work with through the parameter passed to `oe-init-build-env`.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
- en: 'Initially, the `build` directory contains only one subdirectory named `conf`
    with the configuration files for this project:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
- en: '`local.conf`: Contains a specification of the device you are going to build
    and the build environment.'
  id: totrans-235
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`bblayers.conf`: Contains paths of the meta layers you are going to use. I
    will describe layers later.'
  id: totrans-236
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'For now, we just need to set the `MACHINE` variable in `conf/local.conf` to
    `qemuarm64` by removing the comment character (*#*) at the start of this line:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Now we are ready to build our first image with Yocto.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
- en: Building
  id: totrans-240
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To perform the build, you need to run BitBake and tell it which root filesystem
    image you want to create. Some common images are:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
- en: '`core-image-minimal`: Is a small console-based system that is useful for tests
    and as the basis for custom images.'
  id: totrans-242
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`core-image-minimal-initramfs`: Is similar to `core-image-minimal` but built
    as a RAM disk.'
  id: totrans-243
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`core-image-x11`: Is a basic image with support for graphics through an X11
    server and the XTerminal terminal app.'
  id: totrans-244
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`core-image-full-cmdline`: Is a console-based system that offers a standard
    CLI experience and full support for the target hardware.'
  id: totrans-245
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'By giving BitBake the final target, it will work backward and build all the
    dependencies starting with the toolchain. For now, we just want to create a minimal
    image to see how it works:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: The first build will take some time (likely more than an hour) even with several
    CPU cores and lots of RAM. It will download about 4.9 GB of source code and consume
    about 49 GB of disk space. When the build completes, you will find several new
    directories in the `build` directory.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
- en: 'These include `downloads`, which contains all the source downloaded for the
    build, and `tmp`, which contains most of the build artifacts. Inside `tmp` you
    will find the following:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
- en: '`work`: Contains the build directory and the staging area for the root filesystem.'
  id: totrans-250
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`deploy`: Contains the final binaries to be deployed on the target:'
  id: totrans-251
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`deploy/images/<machine name>`: Contains the bootloader, kernel, and root filesystem
    images for the target.'
  id: totrans-252
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`deploy/rpm`: Contains the RPM packages that make up the images.'
  id: totrans-253
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`deploy/licenses`: Contains the license files extracted from each package.'
  id: totrans-254
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When the build is done, we can boot the finished image on QEMU.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
- en: Running the QEMU target
  id: totrans-256
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When you build a QEMU target, an internal version of QEMU is generated. This
    eliminates the need to install the QEMU package for your distribution. There is
    a wrapper script named `runqemu` to run this internal version of QEMU.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
- en: 'To run the QEMU emulation, make sure to first run `source oe-init-build-env
    build-qemu-arm64` and then type:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: In this case, QEMU has been configured with a graphic console so that the login
    prompt appears in a black framebuffer. Log in as root without a password. Close
    the framebuffer window to exit QEMU.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
- en: 'To launch QEMU without the graphic window, add `nographic` to the command line:'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  id: totrans-262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: In the `nographic` case, close QEMU using the key sequence *Ctrl + A* and then
    *x*.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
- en: The `runqemu` script has many other options. Type `runqemu help` for more information.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
- en: Layers
  id: totrans-265
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Yocto metadata is structured as layers. A layer is a directory containing a
    collection of BitBake metadata in the form of recipe files. Each recipe file is
    used to build an individual software package. The layers are stacked on top of
    each other to build or “bake” all the software recipes into a finished Linux image
    much like baking a cake. By convention, each layer has a name beginning with `meta`.
    The core layers are:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
- en: '`meta`: Is the equivalent of an unmodified OpenEmbedded core.'
  id: totrans-267
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`meta-poky`: Is the metadata specific to the Poky distribution.'
  id: totrans-268
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`meta-yocto-bsp`: Contains the BSPs for the reference machines that Yocto regularly
    tests.'
  id: totrans-269
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The list of layers in which BitBake searches for recipes is stored in `<your
    build directory>/conf/bblayers.conf` and by default includes all three layers
    from the preceding list.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
- en: 'Structuring the recipes and other configuration data in this way makes it very
    easy to extend Yocto by adding new layers. Additional layers are available from
    SoC manufacturers, The Yocto Project itself, and a wide range of people wishing
    to add value to Yocto and OpenEmbedded. There is a useful list of layers at [https://layers.openembedded.org/layerindex/](https://layers.openembedded.org/layerindex/).
    Here are some examples:'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
- en: '`meta-qt5`: Qt 5 libraries and utilities'
  id: totrans-272
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`meta-intel`: BSPs for Intel CPUs and SoCs'
  id: totrans-273
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`meta-raspberrypi`: BSPs for the Raspberry Pi boards'
  id: totrans-274
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`meta-ti`: BSPs for TI Arm-based SoCs'
  id: totrans-275
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding a layer is as simple as copying the meta directory to a suitable location
    and adding it to `bblayers.conf`. Make sure that you read the `REAMDE` file that
    should accompany each layer to see what dependencies it has on other layers and
    which versions of Yocto it is compatible with.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
- en: To illustrate how layers work, let’s create a layer for our Nova board that
    we can use for the remainder of the chapter as we add features. You can see the
    complete implementation of the layer under `MELD/Chapter06/meta-nova` in the code
    archive.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
- en: Each meta layer must have at least one configuration file named `conf/layer.conf`
    and should also have a `README` file and a license.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
- en: 'To create our `meta-nova` layer, perform the following steps:'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  id: totrans-280
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'This will put you in a working directory named `build-nova` and create a layer
    named `meta-nova` with a `conf/layer.conf`, an outline `README`, and a `COPYING.MIT`
    license under `../meta-nova`. The `layer.conf` file looks like this:'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  id: totrans-282
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: The layer adds itself to `BBPATH` and the recipes it contains to `BBFILES`.
    From looking at the code, you can see that the recipes are found in the directories
    with names beginning with `recipes-` and have filenames ending in `.bb` (for normal
    BitBake recipes) or `.bbappend` (for recipes that extend existing recipes by overriding
    or adding to the instructions). This layer has the name `nova` and is added to
    the list of layers in `BBFILE_COLLECTIONS` with a priority of `6`. The layer priority
    is used if the same recipe appears in several layers. The one in the layer with
    the highest priority wins.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
- en: 'Before adding the Nova layer, we must first add the `meta-arm-toolchain`, `meta-arm`,
    and `meta-ti-bsp` layers in that precise order:'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  id: totrans-285
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Now add the Nova layer to your build configuration:'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  id: totrans-287
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Make sure to run all these `bitbake-layers add-layer` commands from your `build-nova`
    working directory after sourcing that environment.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
- en: 'Confirm that your layer structure is set up correctly like this:'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  id: totrans-290
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: There you can see the new layer. Because it has a priority of `6`, it can override
    recipes in the other layers that all have a lower priority.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
- en: Run a build using this empty layer. The final target will be the Nova board,
    but for now, build for the BeaglePlay by adding `MACHINE ?= "beagleplay-ti"` to
    `conf/local.conf`. Then build a small image using `bitbake core-image-minimal`
    like before.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
- en: In addition to recipes, layers may contain BitBake classes, configuration files,
    distributions, and more. I will look at recipes next and show you how to create
    a customized image and a package.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
- en: BitBake and recipes
  id: totrans-294
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'BitBake processes metadata of several different types:'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
- en: '**recipes** (files ending in `.bb`): Contain information about building a unit
    of software, including how to get a copy of the source code, the dependencies
    on other components, and how to build and install it.'
  id: totrans-296
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**append** (files ending in `.bbappend`): Override or extend some details of
    a recipe. A `.bbappend` file appends its instructions to the end of a recipe (`.bb`)
    file with the same root name.'
  id: totrans-297
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**include** (files ending in `.inc`): Contain information that is common to
    several recipes allowing information to be shared among them. The files may be
    included using the **include** or **require** keyword. The difference is that
    `require` produces an error if the file does not exist whereas `include` does
    not.'
  id: totrans-298
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**classes** (files ending in `.bbclass`): Contain common build information
    like how to build a kernel or how to build an Autotools project. Classes are inherited
    by recipes and by other classes using the `inherit` keyword. The class `classes/base.bbclass`
    is implicitly inherited by every recipe.'
  id: totrans-299
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**configuration** (files ending in `.conf`): Define various configuration variables
    that govern a project’s build process.'
  id: totrans-300
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'A **recipe** is a collection of tasks written in a combination of Python and
    shell script. The tasks have names such as `do_fetch`, `do_unpack`, `do_patch`,
    `do_configure`, `do_compile`, and `do_install`. You use BitBake to execute these
    tasks. The default task is `do_build`, which performs all the subtasks required
    to build the recipe. You can list the tasks available in a recipe using `bitbake
    -c listtasks <recipe>`. For example, to list the tasks in `core-image-minimal`:'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  id: totrans-302
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: '**IMPORTANT NOTE**'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
- en: The `-c` option tells BitBake to run a specific task from a recipe without having
    to include the `do_` part at the beginning of the task name.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
- en: '`do_listtasks` is a special task that lists all the tasks defined within a
    recipe. Here is the `fetch` task, which downloads the source code for a recipe:'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  id: totrans-306
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'To get the code for a target and all its dependencies (which is useful when
    you want to make sure you have downloaded all the code for the image you are about
    to build), use the following:'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  id: totrans-308
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: The recipe files are usually named `<package-name>_<version>.bb`. They may have
    dependencies on other recipes, which would allow BitBake to work out all the subtasks
    that need to be executed to complete the top-level job.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
- en: 'To create a recipe for our `helloworld` program in `meta-nova`, you would create
    a directory structure like this:'
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  id: totrans-311
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'The recipe is `helloworld_1.0.bb` and the source is kept local to the recipe
    in the `files` subdirectory. The recipe contains these instructions:'
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  id: totrans-313
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'The location of the source code is set by `SRC_URI`. In this case, the `file://`
    URI means that the code is local to the recipe directory. BitBake will search
    the `files`, `helloworld`, and `helloworld-1.0` directories relative to the directory
    that contains the recipe. The tasks that need to be defined are `do_compile` and
    `do_install`, which compile the source file and install it into the target root
    filesystem: `${D}` expands to the staging area of the recipe and `${bindir}` to
    the default `/usr/bin` binary directory.'
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
- en: Every recipe has a license defined by `LICENSE`, which is set to `GPL-2.0-only`
    here. The file containing the text of the license and a checksum is defined by
    `LIC_FILES_CHKSUM`. BitBake will terminate the build if the checksum does not
    match, indicating that the license has changed in some way. Note that the MD5
    checksum value and `COMMON_LICENSE_DIR` are on the same line separated by a semicolon.
    The license file may be part of the package, or it may point to one of the standard
    license texts in `meta/files/common-licenses` as is the case here.
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
- en: 'Commercial licenses are disallowed by default, but it is easy to enable them.
    You need to specify the license in the recipe as shown here:'
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  id: totrans-317
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Then, in your `conf/local.conf`, explicitly allow this license like so:'
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  id: totrans-319
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'To make sure that our `helloworld` recipe compiles correctly, ask BitBake to
    build it:'
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  id: totrans-321
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: If all goes well, you should see that it has created a working directory for
    it in `tmp/work/aarch64-poky-linux/helloworld`. You should also see that there
    is an RPM package for it in `tmp/deploy/rpm/aarch64/helloworld-1.0-r0.aarch64.rpm`.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
- en: 'The package is not part of the target image yet. The list of packages to be
    installed is held in a variable named `IMAGE_INSTALL`. You can append to the end
    of that list by adding this line to `conf/local.conf`:'
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  id: totrans-324
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Note that there needs to be a space between the opening double quote and the
    first package name. Now the package will be added to any image that you `bitbake`:'
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  id: totrans-326
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: If you look in `deploy-ti/images/beagleplay-ti/core-image-minimal-beagleplay-ti.rootfs.tar.xz`,
    you will see that `/usr/bin/helloworld` has indeed been installed.
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
- en: Customizing images via local.conf
  id: totrans-328
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'You often may want to add a package to an image during development or tweak
    it in other ways. As we’ve just seen, you can simply append to the list of packages
    to be installed by adding a statement like:'
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  id: totrans-330
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'You can make more sweeping changes via `EXTRA_IMAGE_FEATURES`. Here is a short
    list, which should give you an idea of the features you can enable:'
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
- en: '`dbg-pkgs`: Installs debug symbol packages for all the packages installed in
    the image.'
  id: totrans-332
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`debug-tweaks`: Allows `root` logins without passwords and other changes that
    make development easier. Never enable `debug-tweaks` in production images.'
  id: totrans-333
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`package-management`: Installs package management tools and preserves the package
    manager database.'
  id: totrans-334
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`read-only-rootfs`: Makes the root filesystem read-only. We will cover this
    in more detail in [*Chapter 9*](Chapter_09.xhtml#_idTextAnchor293).'
  id: totrans-335
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`x11`: Installs the X server.'
  id: totrans-336
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`x11-base`: Installs the X server with a minimal environment.'
  id: totrans-337
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There are many more features you can add in this way. I recommend you look at
    the *Image Features* section of the *Yocto Project Reference Manual* at [https://docs.yoctoproject.org/ref-manual/](https://docs.yoctoproject.org/ref-manual/)
    and read through the code in `meta/classes-recipe/core-image.bbclass`.
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
- en: Writing an image recipe
  id: totrans-339
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The problem with making changes to `local.conf` is that they are, well, local.
    If you want to create an image that is to be shared with other developers or to
    be loaded onto a production system, then you should put the changes in an **image
    recipe**.
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
- en: 'An image recipe contains instructions about how to create the image files for
    a target, including the bootloader, kernel, and root filesystem images. By convention,
    image recipes are put into a directory named `images`. You can get a list of all
    the images that are available by scanning the `poky` directory and any additional
    layers that you cloned:'
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  id: totrans-342
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: You will find that the recipe for `core-image-minimal` is in `poky`/`meta/recipes-core/images/core-image-minimal.bb`.
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
- en: A simple approach is to take an existing image recipe and modify it using statements
    like the ones you used in `local.conf`.
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
- en: 'Imagine that you want an image that is the same as `core-image-minimal` but
    includes your `helloworld` program and the `strace` utility. You can do that with
    a two-line recipe file that includes (using the `require` keyword) the base image
    and adds the packages you want. It is conventional to put the image in a directory
    named `images`, so add the recipe `nova-image.bb` with this content in `meta-nova/recipes-local/images`:'
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  id: totrans-346
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'Now remove the `IMAGE_INSTALL:append` line from your `local.conf` and build
    the image:'
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  id: totrans-348
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: This time, the build should proceed much quicker because BitBake reuses the
    intermediate build objects built during prior runs.
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
- en: Not only does BitBake build images for running on a target device, but it can
    also build an SDK for doing cross-development on a host machine.
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
- en: Creating an SDK
  id: totrans-351
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'It is very useful to be able to create a standalone toolchain that other developers
    can install. This avoids the need for everyone on the team to have a full installation
    of Yocto. Ideally, you want the toolchain to include development libraries and
    header files for all the libraries installed on the target. You can do that for
    any image using the `populate_sdk` task, as shown:'
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  id: totrans-353
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'The result is a self-installing shell script in `deploy-ti/sdk`:'
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  id: totrans-355
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'For the SDK built with the `nova-image` recipe:'
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  id: totrans-357
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'If you only want a basic toolchain with just C and C++ cross-compilers, the
    C library, and header files, then run this instead:'
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  id: totrans-359
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'To install the SDK, just run the shell script. The default install directory
    is `/opt/poky` but the install script allows you to change this:'
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  id: totrans-361
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'To make use of the toolchain, first source the environment and set up the script:'
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  id: totrans-363
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: '**TIP**'
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
- en: The `environment-setup-*` script that sets things up for the SDK is not compatible
    with the `oe-init-build-env` script that you source when working in the Yocto
    build directory. It is a good rule to always start a new terminal session before
    you source either script.
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
- en: 'The toolchain generated by The Yocto Project does not have a valid `sysroot`
    directory. We know this to be true because passing the `-print-sysroot` option
    to the toolchain’s compiler returns `/not/exist`:'
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  id: totrans-367
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'Consequently, if you try to cross-compile, it will fail like this:'
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  id: totrans-369
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'This is because the compiler has been configured to work for a wide range of
    Arm processors and the fine-tuning is done when you launch it using the right
    set of flags. Instead, you should use the shell variables that are created when
    you source the `environment-setup` script for cross-compiling. These include:'
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
- en: '`CC`: C compiler'
  id: totrans-371
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`CXX`: C++ compiler'
  id: totrans-372
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`CPP`: C preprocessor'
  id: totrans-373
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`AS`: Assembler'
  id: totrans-374
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`LD`: Linker'
  id: totrans-375
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'This is what we find `CC` has been set to:'
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  id: totrans-377
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'As long as you use `$CC` to compile, everything should work fine:'
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  id: totrans-379
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: The license audit
  id: totrans-380
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The Yocto Project insists that each package has a license. A copy of the license
    is placed in `tmp/deploy/licenses/<package name>` for each package as it is built.
    In addition, a summary of the packages and licenses used in an image is put into
    the directory: `<image name>-<machine name>.rootfs-<date stamp>`. For the `nova-image`
    we just built, the directory would be named something like this:'
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  id: totrans-382
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: This completes our survey of the two leading build systems for embedded Linux.
    Buildroot is simple and quick, making it a good choice for simple single-purpose
    devices. Yocto is more complex and flexible. Even though there is good support
    throughout the community and industry for Yocto, the tool still has a very steep
    learning curve. You can expect it will take several months for you to become proficient
    with Yocto, and even then, it will sometimes do things that surprise you.
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-384
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, you learned how to use both Buildroot and The Yocto Project
    to configure, customize, and build embedded Linux images. We used Buildroot to
    create a BSP with a custom U-Boot patch and device tree specification for a hypothetical
    board based on the BeaglePlay. We then learned how to add our own code to an image
    in the form of a Buildroot package. You were introduced to The Yocto Project,
    which we will cover in depth over the next two chapters. In particular, you learned
    some basic BitBake terminology, how to write an image recipe, and how to create
    an SDK.
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
- en: Don’t forget that any devices you create using these tools will need to be maintained
    in the field for a period of time, often over many years. Both Yocto and Buildroot
    provide point releases for about one year after the initial release, and Yocto
    now offers long-term support for at least four years. In either case, you will
    find yourself having to maintain your own releases or paying for commercial support.
    The third possibility, ignoring the problem, is not an option!
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
- en: Further study
  id: totrans-387
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '*The Buildroot user manual, Buildroot Association* –[https://buildroot.org/downloads/manual/manual.html](https://buildroot.org/downloads/manual/manual.html%0D%0A)'
  id: totrans-388
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Yocto Project Documentation, Yocto Project* –[https://docs.yoctoproject.org/](https://docs.yoctoproject.org/)'
  id: totrans-389
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
