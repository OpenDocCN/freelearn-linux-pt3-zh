<html><head></head><body>
		<div id="_idContainer213">
			<h1 id="_idParaDest-90" class="chapter-number"><a id="_idTextAnchor100"/>9</h1>
			<h1 id="_idParaDest-91"><a id="_idTextAnchor101"/>Linux Monitoring and Debugging Commands</h1>
			<p>Linux monitoring and debugging commands<a id="_idIndexMarker435"/> are a crucial set of tools widely employed by Linux system administrators for monitoring system performance, troubleshooting issues, and debugging problems in Linux environments. These commands provide real-time insights into the various components and processes of the system, enabling administrators to identify and address potential bottlenecks, errors, or performance issues promptly. The importance of these commands lies in their ability to ensure system stability, optimize resource utilization, and enhance overall system performance. By leveraging monitoring and debugging commands, administrators can proactively manage system health, mitigate risks, and maintain a reliable and efficient Linux environment. The primary objective of these commands is to equip system administrators with essential tools for effectively monitoring and diagnosing the status of their Linux systems. They can also provide valuable insights into critical system metrics, including CPU usage, memory utilization, disk I/O, network activity, and process information. By closely monitoring these metrics, administrators can proactively identify any unusual behavior, track system performance trends, and detect potential issues before they escalate into significant problems. Additionally, the debugging commands offer robust capabilities to investigate and resolve system errors, software bugs, and compatibility issues. They empower administrators to trace the execution of programs, capture error logs, analyze system logs, and perform troubleshooting steps to identify the underlying causes of issues and implement <span class="No-Break">appropriate remedies.</span></p>
			<p>These commands are among the most widely used tools by system administrators for several reasons. Firstly, these commands provide administrators with real-time and accurate insights into system performance and behavior, enabling them to make informed decisions and take proactive measures to optimize system resources. Secondly, the commands offer a wide range of functionalities, allowing administrators to monitor and analyze specific components or processes based on their requirements. This flexibility makes the commands adaptable to various use cases and scenarios. Additionally, the commands facilitate efficient troubleshooting and debugging processes by providing detailed information and diagnostic capabilities. This helps administrators save time and effort in identifying and resolving issues, leading to improved system stability and <span class="No-Break">reduced downtime.</span></p>
			<p>In this chapter, we are going to cover the following <span class="No-Break">main topics:</span></p>
			<ul>
				<li>The top, ps, pstree, strace, watch, smartctl, and <span class="No-Break">uptime commands</span></li>
				<li>The lsof, lsmod, last reboot, last, w, and <span class="No-Break">vmstat commands</span></li>
				<li>The <span class="No-Break">kill command</span></li>
				<li>The <span class="No-Break">pkill command</span></li>
			</ul>
			<p>As Linux gained popularity and became a prominent choice for server and enterprise environments, the need for robust monitoring and debugging tools became evident. The Linux community recognized the importance of having comprehensive tools that could provide insights into system performance, aid in troubleshooting, and enable efficient debugging of issues. Over time, numerous command-line utilities, software packages, and frameworks were developed to meet these needs. These tools aimed to provide administrators with real-time monitoring capabilities, detailed system information, and advanced debugging features. The continuous evolution of Linux monitoring and debugging commands<a id="_idIndexMarker436"/> has been driven by the ever-increasing complexity of modern systems, the demand for optimal performance, and the need to quickly identify and resolve issues. Today, Linux administrators have a vast array of powerful tools at their disposal to effectively monitor and debug their systems, ensuring the stability, reliability, and performance of their <span class="No-Break">Linux environments.</span></p>
			<h1 id="_idParaDest-92"><a id="_idTextAnchor102"/>The top command</h1>
			<p>The <strong class="source-inline">top</strong> command is a powerful Linux utility<a id="_idIndexMarker437"/> that provides real-time monitoring of system processes and resource usage. It is the go-to tool for system administrators to gain insights into the performance and health of their Linux systems. The primary purpose of the <strong class="source-inline">top</strong> command is to display a dynamic and interactive overview of system processes, CPU usage, memory utilization, load average, and other critical system statistics. By continuously updating this information, administrators can quickly identify resource-intensive processes, bottlenecks, or abnormalities that may impact system performance. The <strong class="source-inline">top</strong> command is a vital component of Linux monitoring, offering a comprehensive view of system activity and facilitating <span class="No-Break">efficient troubleshooting.</span></p>
			<p>One of the key reasons why the <strong class="source-inline">top</strong> command is widely used by system administrators is its versatility. It provides a wealth of information in a compact and easy-to-understand format, making it an invaluable tool for monitoring system health. Administrators can use the <strong class="source-inline">top</strong> command to observe real-time CPU usage, memory allocation, and process activity. This allows them to detect potential performance issues, identify processes consuming excessive resources, and take appropriate action to optimize system performance. Additionally, the <strong class="source-inline">top</strong> command provides information on the system load average, indicating the overall system workload and allowing administrators to determine if the system is under heavy utilization. The importance of the <strong class="source-inline">top</strong> command extends beyond monitoring system resources. It also serves as a diagnostic tool for troubleshooting system issues. Administrators can use the <strong class="source-inline">top</strong> command to investigate the behavior of specific processes, identify potential bottlenecks, and analyze resource consumption patterns. By understanding how system resources are allocated and utilized, administrators can make informed decisions to optimize system performance and resolve issues. The <strong class="source-inline">top</strong> command<a id="_idIndexMarker438"/> also supports interactive features, allowing administrators to dynamically adjust the display, sort processes based on various criteria, and send signals to individual processes for further analysis or control. This level of flexibility and control makes the <strong class="source-inline">top</strong> command an essential tool for Linux system administrators. Let’s dive into exploring the <strong class="source-inline">top</strong> command on our <span class="No-Break">CentOS terminal:</span></p>
			<ul>
				<li><strong class="bold">Viewing overall </strong><span class="No-Break"><strong class="bold">system statistics</strong></span><span class="No-Break">:</span><p class="list-inset">The <strong class="source-inline">top</strong> command provides real-time<a id="_idIndexMarker439"/> insights into system statistics, including CPU usage, memory utilization, and system load. This information is dynamically updated, offering a comprehensive overview of the system’s performance and <span class="No-Break">resource allocation:</span></p></li>
			</ul>
			<div>
				<div id="_idContainer188" class="IMG---Figure">
					<img src="image/B18212_09_1.jpg" alt="Figure 9.1 – Viewing overall system statistics"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.1 – Viewing overall system statistics</p>
			<ul>
				<li><strong class="bold">Sorting processes by </strong><span class="No-Break"><strong class="bold">CPU usage</strong></span><span class="No-Break">:</span><p class="list-inset">In addition to its regular<a id="_idIndexMarker440"/> functionalities, the <strong class="source-inline">top</strong> command also offers the capability to sort a displayed list of processes based on their CPU usage. This can be seen in the <span class="No-Break">following screenshot:</span></p></li>
			</ul>
			<div>
				<div id="_idContainer189" class="IMG---Figure">
					<img src="image/B18212_09_2.jpg" alt="Figure 9.2 – Sorting processes by CPU usage"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.2 – Sorting processes by CPU usage</p>
			<p class="list-inset">This feature allows you to quickly identify the process consuming the most CPU resources, as it will be listed at the top of the output. Such capability provides a convenient way to prioritize and monitor CPU-intensive processes. This, in turn, makes it easier for system administrators to identify potential performance bottlenecks and take appropriate actions<a id="_idIndexMarker441"/> to optimize <span class="No-Break">system resources.</span></p>
			<ul>
				<li><strong class="bold">Monitoring </strong><span class="No-Break"><strong class="bold">memory usage</strong></span><span class="No-Break">:</span><p class="list-inset">We use the <strong class="source-inline">-o %MEM</strong> option to monitor<a id="_idIndexMarker442"/> memory usage, as shown in the <span class="No-Break">following screenshot:</span></p></li>
			</ul>
			<div>
				<div id="_idContainer190" class="IMG---Figure">
					<img src="image/B18212_09_3.jpg" alt="Figure 9.3 – Command for monitoring memory usage"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.3 – Command for monitoring memory usage</p>
			<p class="list-inset">The result is <span class="No-Break">as follows:</span></p>
			<div>
				<div id="_idContainer191" class="IMG---Figure">
					<img src="image/B18212_09_4.jpg" alt="Figure 9.4 – Monitoring memory usage"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.4 – Monitoring memory usage</p>
			<p class="list-inset">The <strong class="source-inline">top</strong> command will display a list of processes sorted by their memory usage, allowing you to monitor<a id="_idIndexMarker443"/> which processes are utilizing the <span class="No-Break">most memory.</span></p>
			<ul>
				<li><strong class="bold">Filtering processes </strong><span class="No-Break"><strong class="bold">by user</strong></span><span class="No-Break">:</span><p class="list-inset">For this, we will be replacing <strong class="source-inline">username</strong> with the actual username<a id="_idIndexMarker444"/> we want <span class="No-Break">to filter:</span></p></li>
			</ul>
			<div>
				<div id="_idContainer192" class="IMG---Figure">
					<img src="image/B18212_09_5.jpg" alt="Figure 9.5 – Command to filter processes by user"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.5 – Command to filter processes by user</p>
			<p class="list-inset">The result is <span class="No-Break">as follows:</span></p>
			<div>
				<div id="_idContainer193" class="IMG---Figure">
					<img src="image/B18212_09_6.jpg" alt="Figure 9.6 – Using top to filter processes by user"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.6 – Using top to filter processes by user</p>
			<p class="list-inset">The <strong class="source-inline">top</strong> command filters the displayed processes to show only those owned by the <span class="No-Break">specified username.</span></p>
			<p>Overall, the <strong class="source-inline">top</strong> command<a id="_idIndexMarker445"/> is a versatile and essential tool for monitoring system processes and resource usage in Linux environments. Its real-time insights into system performance, interactive features, and diagnostic capabilities make it a valuable asset for system administrators. By utilizing the <strong class="source-inline">top</strong> command, system administrators can effectively monitor system health, identify resource-intensive processes, troubleshoot issues, and optimize system performance. Its widespread use among Linux system administrators is a testament<a id="_idIndexMarker446"/> to its importance and effectiveness in maintaining the stability, reliability, and optimal functioning of <span class="No-Break">Linux systems.</span></p>
			<h1 id="_idParaDest-93"><a id="_idTextAnchor103"/>The ps command</h1>
			<p>The <strong class="source-inline">ps</strong> command is a powerful utility<a id="_idIndexMarker447"/> in Linux used to provide information about the running processes on a system. It stands for <strong class="bold">process status</strong> and plays a fundamental<a id="_idIndexMarker448"/> role in monitoring and managing processes. The command<a id="_idIndexMarker449"/> offers insights into the current state of processes, including their <strong class="bold">process IDs</strong> (<strong class="bold">PIDs</strong>), CPU and memory usage, running time, and other attributes. By displaying this vital information, system administrators can gain a comprehensive view of processes running on their system and make informed decisions to optimize system performance, troubleshoot issues, and manage system resources effectively. The importance of the <strong class="source-inline">ps</strong> command lies in its ability to offer real-time visibility into the system’s running processes. It is a valuable tool for monitoring the health and efficiency of a system, allowing administrators to identify any misbehaving or resource-intensive processes that may be affecting <span class="No-Break">system performance.</span></p>
			<p>The primary use of the <strong class="source-inline">ps</strong> command is for process monitoring and management. Administrators can use it to view a snapshot of active processes on the system, including their status, resource utilization, and relationships with other processes. This information is vital for troubleshooting system issues, identifying potential bottlenecks, and optimizing <span class="No-Break">system performance.</span></p>
			<p>For example, the <strong class="source-inline">ps</strong> command can be used for <span class="No-Break">the following:</span></p>
			<ul>
				<li><strong class="bold">Viewing all </strong><span class="No-Break"><strong class="bold">running processes</strong></span><span class="No-Break">:</span><p class="list-inset">The <strong class="source-inline">ps</strong> command displays a list<a id="_idIndexMarker450"/> of all running processes in the system. It provides information about each process, including the PID, the terminal associated with the process, the CPU and memory usage since it was started, and the command that started <span class="No-Break">the process:</span></p></li>
			</ul>
			<div>
				<div id="_idContainer194" class="IMG---Figure">
					<img src="image/B18212_09_7.jpg" alt="Figure 9.7 – Using the ps command to view all running processes"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.7 – Using the ps command to view all running processes</p>
			<ul>
				<li><strong class="bold">Viewing processes owned by a </strong><span class="No-Break"><strong class="bold">specific user</strong></span><span class="No-Break">:</span><p class="list-inset">Executing the <strong class="source-inline">-e</strong> option with the <strong class="source-inline">ps</strong> command shows<a id="_idIndexMarker451"/> a list of processes owned by a specific user, where <strong class="source-inline">username</strong> is replaced with the actual username. It is useful for providing administrators an overview of processes belonging to a <span class="No-Break">particular user:</span></p></li>
			</ul>
			<div>
				<div id="_idContainer195" class="IMG---Figure">
					<img src="image/B18212_09_8.jpg" alt="Figure 9.8 – Viewing processes owned by a specific user"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.8 – Viewing processes owned by a specific user</p>
			<p>In summary, the <strong class="source-inline">ps</strong> command<a id="_idIndexMarker452"/> is a cornerstone tool for Linux system administrators, providing essential insights into running processes and facilitating process management and troubleshooting. Its real-time information about process status, resource utilization, and relationships enables administrators to ensure system stability, enhance performance, and efficiently allocate system resources. With its versatility and broad range of applications, the <strong class="source-inline">ps</strong> command remains an indispensable part of the Linux monitoring and <span class="No-Break">management toolkit.</span></p>
			<h1 id="_idParaDest-94"><a id="_idTextAnchor104"/>The pstree command</h1>
			<p>The <strong class="source-inline">pstree</strong> command is a Linux utility that displays<a id="_idIndexMarker453"/> a tree-like representation of running processes on the system. It provides a visual and hierarchical view of processes, showing their parent-child relationships. The command is particularly useful when trying to understand the process structure and how different processes are related to each other. By displaying processes in a tree format, administrators can quickly identify the parent process (<strong class="source-inline">init</strong> or <strong class="source-inline">system</strong>) and its descendants, helping them grasp the overall process hierarchy. This information is crucial for system debugging, performance analysis, and troubleshooting scenarios. The <strong class="source-inline">pstree</strong> command also aids in process management, as it allows administrators to visualize complex process structures and their dependencies, making it easier to identify potential issues and optimize system<a id="_idIndexMarker454"/> performance. Let’s take a closer look at how it can <span class="No-Break">be used:</span></p>
			<ul>
				<li><strong class="bold">Viewing a </strong><span class="No-Break"><strong class="bold">process tree</strong></span><span class="No-Break">:</span><ul><li>The command<a id="_idIndexMarker455"/> will display a process tree, showing the hierarchy of processes in a <span class="No-Break">tree-like structure</span></li><li>Each process will be listed with its parent process and child processes, making it easy to visualize the relationships between <span class="No-Break">different processes</span></li><li>Use the tree structure to analyze the process hierarchy and understand the relationships between <span class="No-Break">different processes</span></li></ul><p class="list-inset">The following output demonstrates the execution of the <span class="No-Break"><strong class="source-inline">pstree</strong></span><span class="No-Break"> command:</span></p></li>
			</ul>
			<div>
				<div id="_idContainer196" class="IMG---Figure">
					<img src="image/B18212_09_9.jpg" alt="Figure 9.9 – Viewing a process tree with the pstree command"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.9 – Viewing a process tree with the pstree command</p>
			<ul>
				<li><strong class="bold">Viewing </strong><span class="No-Break"><strong class="bold">a PID</strong></span><span class="No-Break">:</span><p class="list-inset">When you execute the <strong class="source-inline">pstree -p</strong> command<a id="_idIndexMarker456"/> in the terminal, it will show a hierarchical representation of all running processes on your system, similar to the standard <strong class="source-inline">pstree</strong> output, but with each process’s PID displayed next to its name. The PID is a unique ID assigned to each process by the <span class="No-Break">operating system:</span></p></li>
			</ul>
			<div>
				<div id="_idContainer197" class="IMG---Figure">
					<img src="image/B18212_09_10.jpg" alt="Figure 9.10 – Viewing a PID with pstree"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.10 – Viewing a PID with pstree</p>
			<p>The <strong class="source-inline">pstree -p</strong> command can be particularly<a id="_idIndexMarker457"/> useful when troubleshooting or investigating processes on your system. It allows you to quickly identify the parent-child relationships between processes and their corresponding PIDs. This can aid in understanding the structure of the processes running on your system and help you identify specific processes that might be causing issues or consuming <span class="No-Break">excessive resources.</span></p>
			<h1 id="_idParaDest-95"><a id="_idTextAnchor105"/>The strace command</h1>
			<p>The <strong class="source-inline">strace</strong> command is a powerful Linux tool<a id="_idIndexMarker458"/> used for tracing and debugging system calls made by a process. It intercepts and records the system calls a process makes while running, providing detailed information about interactions between the process and the Linux kernel. This level of visibility is invaluable for diagnosing and resolving issues related to system calls, application behavior, and software errors. By analyzing the output of <strong class="source-inline">strace</strong>, administrators can identify issues such as file access problems, library dependencies, permission errors, or resource conflicts. It is particularly useful for debugging complex applications, troubleshooting crashes, and ensuring correct program execution. The <strong class="source-inline">strace</strong> command is widely used by system administrators, developers, and support teams as a fundamental tool for investigating low-level system interactions and understanding the root cause of various software and performance problems. Please note that <strong class="source-inline">sudo</strong> access is required when using <strong class="source-inline">strace</strong> to trace processes with elevated permissions or system-level access. Both <strong class="source-inline">pstree</strong> and <strong class="source-inline">strace</strong> commands are essential tools in the Linux administrator’s arsenal. They provide valuable insights into the process hierarchy and system interactions, helping administrators understand system behavior, diagnose issues, and optimize performance. <strong class="source-inline">pstree</strong> facilitates a clear visualization of process relationships, enabling administrators to comprehend complex process structures and identify possible process bottlenecks. On the other hand, <strong class="source-inline">strace</strong> offers in-depth tracing of system calls, allowing administrators to monitor the interaction between processes and the kernel, thus aiding in debugging and identifying problems with software applications. The importance of these commands is evident in their ability to streamline the troubleshooting process, enhance system<a id="_idIndexMarker459"/> stability, and improve overall system performance, making them indispensable tools for Linux system administrators. We will explore illustrative examples of each of <span class="No-Break">the commands:</span></p>
			<ul>
				<li><strong class="bold">Filtering </strong><span class="No-Break"><strong class="bold">system calls</strong></span><span class="No-Break">:</span><ul><li>The <strong class="source-inline">strace</strong> command<a id="_idIndexMarker460"/> will trace only open and read system calls made by the <span class="No-Break"><strong class="source-inline">ls</strong></span><span class="No-Break"> command</span></li><li>Filtering system calls allows focusing on specific operations and reduces the amount of output generated <span class="No-Break">by </span><span class="No-Break"><strong class="source-inline">strace</strong></span></li><li>Analyze the filtered output to gain insights into how the <strong class="source-inline">ls</strong> command interacts with files by opening and <span class="No-Break">reading them:</span></li></ul></li>
			</ul>
			<div>
				<div id="_idContainer198" class="IMG---Figure">
					<img src="image/B18212_09_11.jpg" alt="Figure 9.11 – Filtering system calls with strace"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.11 – Filtering system calls with strace</p>
			<p>In conclusion, both the <strong class="source-inline">pstree</strong> and <strong class="source-inline">strace</strong> commands are indispensable tools for Linux system administrators, each serving unique purposes in system monitoring and debugging. The <strong class="source-inline">pstree</strong> command offers a clear and hierarchical view of running processes, simplifying the understanding of process relationships and dependencies. This visual representation aids in troubleshooting, performance analysis, and process management tasks, contributing to improved system stability and performance. On the other hand, the <strong class="source-inline">strace</strong> command excels in tracing system calls and providing detailed insights into process behavior, software errors, and low-level system interactions. This powerful level of visibility is crucial for diagnosing complex issues and identifying the root cause of software problems. System administrators and developers rely on <strong class="source-inline">strace</strong> for troubleshooting crashes, detecting<a id="_idIndexMarker461"/> permission errors, resolving library dependencies, and ensuring correct <span class="No-Break">program execution.</span></p>
			<h1 id="_idParaDest-96"><a id="_idTextAnchor106"/>The watch command</h1>
			<p>The <strong class="source-inline">watch</strong> command is a powerful utility in Linux<a id="_idIndexMarker462"/> that's used to execute a specified command repeatedly at defined intervals and display its output in the terminal. It is particularly useful for real-time monitoring and observing changes in system data over time. The command takes a command-line argument and refreshes the terminal screen at regular intervals to show the updated output of the given command. This continuous refresh provides a dynamic view of the data, making it easier for system administrators to track system metrics, analyze processes, or observe the behavior of certain commands. The <strong class="source-inline">watch</strong> command is valuable for monitoring tasks that require frequent updates, such as checking system resource usage, log file updates, or network activity. It streamlines the process of obtaining real-time information, allowing administrators to react promptly to any changes or anomalies, making it an essential tool in the Linux system <span class="No-Break">administrator’s toolkit.</span></p>
			<p>We can monitor network traffic in real time using the <strong class="source-inline">watch</strong> command with the <span class="No-Break"><strong class="source-inline">ifconfig</strong></span><span class="No-Break"> command:</span></p>
			<div>
				<div id="_idContainer199" class="IMG---Figure">
					<img src="image/B18212_09_12.jpg" alt="Figure 9.12 – Command to monitor network traffic in real time"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.12 – Command to monitor network traffic in real time</p>
			<p>The result is <span class="No-Break">as follows:</span></p>
			<div>
				<div id="_idContainer200" class="IMG---Figure">
					<img src="image/B18212_09_13.jpg" alt="Figure 9.13 – Combining the watch and ifconfig commands"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.13 – Combining the watch and ifconfig commands</p>
			<p>Let us now look <a id="_idIndexMarker463"/>at another command – the <span class="No-Break"><strong class="source-inline">smartctl</strong></span><span class="No-Break"> command.</span></p>
			<h1 id="_idParaDest-97"><a id="_idTextAnchor107"/>The smartctl command</h1>
			<p>The <strong class="source-inline">smartctl</strong> command is a vital tool for Linux system<a id="_idIndexMarker464"/> administrators responsible for managing hard drives<a id="_idIndexMarker465"/> and storage devices. It is part of the <strong class="bold">Self-Monitoring, Analysis, and Reporting Technology</strong> (<strong class="bold">S.M.A.R.T.</strong>) suite, which is built into most modern hard drives and <strong class="bold">solid-state drives</strong> (<strong class="bold">SSDs</strong>). The command enables administrators to access<a id="_idIndexMarker466"/> and interpret various attributes and health information of storage devices, providing insights into their overall health, performance, and potential issues. By using the <strong class="source-inline">smartctl</strong> command, administrators can proactively monitor the condition of their storage devices, detect signs of imminent failure, and take necessary action to prevent data loss and system downtime. This valuable information empowers system administrators to make informed decisions about storage maintenance, upgrade planning, and replacement strategies, ensuring data integrity and <span class="No-Break">system stability.</span></p>
			<p>We can retrieve the health<a id="_idIndexMarker467"/> and status of a storage device using the <span class="No-Break"><strong class="source-inline">smartctl</strong></span><span class="No-Break"> command:</span></p>
			<div>
				<div id="_idContainer201" class="IMG---Figure">
					<img src="image/B18212_09_14.jpg" alt="Figure 9.14 – Using smartctl to retrieve the health status of a storage device"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.14 – Using smartctl to retrieve the health status of a storage device</p>
			<h1 id="_idParaDest-98"><a id="_idTextAnchor108"/>The uptime command</h1>
			<p>The <strong class="source-inline">uptime</strong> command is a simple yet essential tool for Linux system<a id="_idIndexMarker468"/> administrators to quickly check the system’s current uptime and load average. When executed, the command displays the current time, the system’s running time since the last boot, the number of users currently logged in, and the load average for the last 1, 5, and 15 minutes. The load average represents the average number of processes in the system’s run queue over the specified time intervals. The <strong class="source-inline">uptime</strong> command is invaluable for assessing system performance, resource utilization, and system responsiveness. By regularly monitoring the uptime and load average, administrators can identify periods of high system activity and potential bottlenecks, allowing them to make informed decisions about system optimization, capacity planning, and resource allocation. This tool is particularly useful when troubleshooting performance issues, as it provides a quick snapshot of system health and helps administrators detect anomalies or periods of heavy <span class="No-Break">system load.</span></p>
			<p>By further exploring the provided examples of the aforementioned command, we will delve into how it can be efficiently employed<a id="_idIndexMarker469"/> by <span class="No-Break">system administrators:</span></p>
			<ul>
				<li><strong class="bold">Monitoring </strong><span class="No-Break"><strong class="bold">CPU usage</strong></span><span class="No-Break">:</span></li>
			</ul>
			<div>
				<div id="_idContainer202" class="IMG---Figure">
					<img src="image/B18212_09_15.jpg" alt="Figure 9.15 – Command ﻿for monitor﻿ing CPU usage"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.15 – Command for monitoring CPU usage</p>
			<p class="list-inset">The result<a id="_idIndexMarker470"/> is <span class="No-Break">as follows:</span></p>
			<div>
				<div id="_idContainer203" class="IMG---Figure">
					<img src="image/B18212_09_16.jpg" alt="Figure 9.16 – Monitoring CPU usage with uptime"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.16 – Monitoring CPU usage with uptime</p>
			<p>In conclusion, the <strong class="source-inline">watch</strong>, <strong class="source-inline">smartctl</strong>, and <strong class="source-inline">uptime</strong> commands are indispensable tools for Linux system administrators, offering valuable capabilities for real-time monitoring, storage device management, and system <span class="No-Break">performance evaluation.</span></p>
			<h1 id="_idParaDest-99"><a id="_idTextAnchor109"/>The lsof command</h1>
			<p>The <strong class="source-inline">lsof</strong> command in Linux stands for <strong class="bold">list open files</strong>, and it is a powerful utility used by system administrators<a id="_idIndexMarker471"/> to display information about files currently opened by processes<a id="_idIndexMarker472"/> on the system. It provides a comprehensive view of all open files, directories, and network connections, along with the corresponding processes that have them open. This information is invaluable for troubleshooting purposes, as it allows administrators to identify processes that are holding file locks, investigate resource utilization, and diagnose issues related to file access. It aids in monitoring and managing files, network connections, and devices, enabling administrators to detect any abnormal behavior, track file access patterns, and identify potential security risks. Furthermore, the <strong class="source-inline">lsof</strong> command allows system administrators to perform various administrative tasks, such as killing processes that are holding locks on critical files or identifying processes associated with specific <span class="No-Break">network connections.</span></p>
			<p>The primary use of the <strong class="source-inline">lsof</strong> command lies in its versatility and flexibility. It can be used to examine various types of resources, such as regular files, directories, network sockets, and character/block devices. This makes it an essential tool for investigating network-related issues, analyzing disk usage, managing mounted filesystems, and checking for potential resource leaks. Overall, the <strong class="source-inline">lsof</strong> command empowers Linux system administrators with a wealth of information about file and process interactions, contributing to efficient system management <span class="No-Break">and troubleshooting.</span></p>
			<p>We will list all open files in the system using the <span class="No-Break">following command:</span></p>
			<div>
				<div id="_idContainer204" class="IMG---Figure">
					<img src="image/B18212_09_17.jpg" alt="Figure 9.17 – Using lsof to list all open files in the system"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.17 – Using lsof to list all open files in the system</p>
			<p>Here’s a breakdown of <span class="No-Break">the command:</span></p>
			<ul>
				<li><strong class="source-inline">lsof</strong>: The executed command is <strong class="source-inline">lsof</strong>. It provides information about files and processes currently open and in use by <span class="No-Break">the system.</span></li>
				<li><strong class="source-inline">&gt;</strong>: This is the redirection operator in Linux. It is used to redirect the output of a command to a file instead of displaying it on <span class="No-Break">the terminal.</span></li>
				<li><strong class="source-inline">file.txt</strong>: This is the name of the file where the output of the <strong class="source-inline">lsof</strong> command will be saved. You can choose<a id="_idIndexMarker473"/> any desired filename, but <strong class="source-inline">file.txt</strong> is just <span class="No-Break">an example.</span></li>
			</ul>
			<h1 id="_idParaDest-100"><a id="_idTextAnchor110"/>The lsmod command</h1>
			<p>The <strong class="source-inline">lsmod</strong> command in Linux is used <a id="_idIndexMarker474"/>to display currently loaded kernel modules on the system. Kernel modules are small pieces of code that can be dynamically loaded or unloaded into the Linux kernel, adding or removing specific functionalities to the operating system. The <strong class="source-inline">lsmod</strong> command provides a concise and organized view of the kernel modules, showing their names, sizes, and the number of references or dependencies they have. The significance of the <strong class="source-inline">lsmod</strong> command lies in its capability to inspect the runtime configuration of the kernel. This command provides system administrators with the ability to confirm currently loaded and active modules in the kernel. This information holds immense importance when troubleshooting hardware-related problems, as kernel modules play a pivotal role in managing device drivers and other <span class="No-Break">critical functionalities.</span></p>
			<p>We will view currently loaded kernel modules using the <span class="No-Break">following command:</span></p>
			<div>
				<div id="_idContainer205" class="IMG---Figure">
					<img src="image/B18212_09_18.jpg" alt="Figure 9.18 – Using lsmod to view currently loaded kernel modules"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.18 – Using lsmod to view currently loaded kernel modules</p>
			<p>Here’s an explanation<a id="_idIndexMarker475"/> of <span class="No-Break">the output:</span></p>
			<ul>
				<li>The header row provides the names of the columns in the output. The three main columns are <strong class="source-inline">Module</strong>, <strong class="source-inline">Size</strong>, and <span class="No-Break"><strong class="source-inline">Used by</strong></span><span class="No-Break">.</span></li>
				<li>The <strong class="source-inline">Module</strong> column lists the names of the loaded kernel modules, and the <strong class="source-inline">Size</strong> and <strong class="source-inline">Used by</strong> columns indicate the size of each module in memory and the number of kernel components using each <span class="No-Break">module, respectively.</span></li>
				<li>The output displays information for several kernel modules that are currently loaded and in use by <span class="No-Break">the system.</span></li>
				<li>Each row corresponds to a specific kernel module, and the columns provide details about <span class="No-Break">that module.</span><p class="list-inset">For example, let’s look at the <span class="No-Break">first row:</span></p><ul><li>The <strong class="source-inline">nls_utf8</strong> module is loaded, and it occupies 16,384 bytes <span class="No-Break">in memory</span></li><li>There is one kernel component using the <span class="No-Break"><strong class="source-inline">nls_utf8</strong></span><span class="No-Break"> module</span></li></ul><p class="list-inset">Similarly, the other rows provide information about different modules that are currently loaded and their respective<a id="_idIndexMarker476"/> sizes <span class="No-Break">and usage.</span></p></li>
			</ul>
			<h1 id="_idParaDest-101"><a id="_idTextAnchor111"/>The last reboot command</h1>
			<p>The <strong class="source-inline">last reboot</strong> command in Linux is a simple yet crucial utility <a id="_idIndexMarker477"/>that provides information about the system’s reboot history. It displays the timestamps of previous system reboots, along with the time since the last reboot. This information is helpful for system administrators to track system availability and uptime. By regularly checking the last reboot timestamps, administrators can quickly identify if the system experienced any unexpected shutdowns or reboots. This information can be vital for diagnosing potential hardware or software issues that may be causing <span class="No-Break">system instability.</span></p>
			<p>The primary use of the <strong class="source-inline">last reboot</strong> command<a id="_idIndexMarker478"/> is for historical analysis<a id="_idIndexMarker479"/> and tracking system availability. System administrators can utilize this information to calculate the system’s <strong class="bold">mean time between failures</strong> (<strong class="bold">MTBF</strong>) and <strong class="bold">mean time to repair</strong> (<strong class="bold">MTTR</strong>), which are essential metrics for evaluating <span class="No-Break">system reliability.</span></p>
			<p>To display the system’s reboot history, we use the <span class="No-Break">following command:</span></p>
			<div>
				<div id="_idContainer206" class="IMG---Figure">
					<img src="image/B18212_09_19.jpg" alt="Figure 9.19 – Using last reboot to display the system’s reboot history"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.19 – Using last reboot to display the system’s reboot history</p>
			<h1 id="_idParaDest-102"><a id="_idTextAnchor112"/>The last command</h1>
			<p>The <strong class="source-inline">last</strong> command is a versatile<a id="_idIndexMarker480"/> and powerful tool used by Linux system administrators to view a history of user login activity on the system. It displays a list of previous login sessions, including the date, time, duration, and remote host from which the login occurred. This information is essential for monitoring user access to the system, identifying potential security breaches, and investigating unauthorized access attempts. The <strong class="source-inline">last</strong> command allows administrators to track user activities, detect unusual login patterns, and ensure the security and integrity of the system. Moreover, it facilitates auditing and compliance efforts by providing a comprehensive log of user login events, making it a crucial component of the system <span class="No-Break">administrator’s toolkit.</span></p>
			<p>The following example shows the last logged-in users and system <span class="No-Break">shutdown/reboot times:</span></p>
			<div>
				<div id="_idContainer207" class="IMG---Figure">
					<img src="image/B18212_09_20.jpg" alt="Figure 9.20 – Viewing last logged-in users and system shutdown/reboot times"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.20 – Viewing last logged-in users and system shutdown/reboot times</p>
			<h1 id="_idParaDest-103"><a id="_idTextAnchor113"/>The w command</h1>
			<p>The <strong class="source-inline">w</strong> command is a valuable utility that provides<a id="_idIndexMarker481"/> real-time information about logged-in users and their activities on the system. When executed, the <strong class="source-inline">w</strong> command displays a list of currently logged-in users, along with details such as their username, terminal, login time, idle time, and current processes. This command enables system administrators to monitor user sessions, check system load, and assess resource utilization. The <strong class="source-inline">w</strong> command is particularly useful for managing system resources and ensuring fair distribution of resources among users. It helps administrators identify users who may be consuming excessive resources or causing system performance issues. By having access to this real-time data, administrators can take proactive measures to optimize resource allocation, improve system efficiency, and ensure a smooth and responsive <span class="No-Break">user experience.</span></p>
			<p>The following example displays information<a id="_idIndexMarker482"/> about currently logged-in users and <span class="No-Break">their activities:</span></p>
			<div>
				<div id="_idContainer208" class="IMG---Figure">
					<img src="image/B18212_09_21.jpg" alt="Figure 9.21 – Using the w command to display information about currently logged-in users and their activities"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.21 – Using the w command to display information about currently logged-in users and their activities</p>
			<h1 id="_idParaDest-104"><a id="_idTextAnchor114"/>The vmstat command</h1>
			<p>The <strong class="source-inline">vmstat</strong> command is a powerful tool<a id="_idIndexMarker483"/> for monitoring system performance and analyzing resource usage. When executed, the <strong class="source-inline">vmstat</strong> command provides a detailed report on various system statistics, including CPU usage, memory usage, virtual memory, disk I/O, and system processes. This comprehensive overview allows system administrators to identify performance bottlenecks, detect potential issues, and make informed decisions about system optimization and resource allocation. The <strong class="source-inline">vmstat</strong> command is particularly valuable for performance tuning, capacity planning, and troubleshooting system slowdowns or resource constraints. It offers valuable insights into the system’s health and performance, enabling administrators to proactively address any emerging issues and ensure the smooth operation of the <span class="No-Break">Linux environment.</span></p>
			<p>The following example is to monitor system memory, processor, and I/O statistics in <span class="No-Break">real time:</span></p>
			<div>
				<div id="_idContainer209" class="IMG---Figure">
					<img src="image/B18212_09_22.jpg" alt="Figure 9.22 – Monitoring system memory and processes with vmstat"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.22 – Monitoring system memory and processes with vmstat</p>
			<p>This command is used for displaying information about virtual memory statistics, system processes, and <span class="No-Break">CPU utilization.</span></p>
			<p>Here is a breakdown of <span class="No-Break">the command:</span></p>
			<ul>
				<li><strong class="source-inline">procs</strong>: This displays information<a id="_idIndexMarker484"/> about processes and process states. The <strong class="source-inline">r</strong> column represents the number of processes in the <strong class="source-inline">running</strong> state, and the <strong class="source-inline">b</strong> column indicates the number of processes in the <strong class="source-inline">uninterruptible sleep</strong> or <span class="No-Break"><strong class="source-inline">blocked</strong></span><span class="No-Break"> state.</span></li>
				<li><strong class="source-inline">memory</strong>: This provides details about memory usage. The <strong class="source-inline">swpd</strong> column shows the amount of virtual memory used (in KB) that has been swapped to the disk. The <strong class="source-inline">free</strong> column displays the amount of free memory (in KB) available for processes. The <strong class="source-inline">buff</strong> column shows the amount of memory (in KB) used as buffer cache by the kernel. The <strong class="source-inline">cache</strong> column displays the amount of memory (in KB) used as page cache by <span class="No-Break">the kernel.</span></li>
				<li><strong class="source-inline">swap</strong>: This displays information about swap space usage. The <strong class="source-inline">si</strong> column represents the amount of memory (in KB) swapped in from disk per second, and the <strong class="source-inline">so</strong> column represents the amount of memory (in KB) swapped out to disk <span class="No-Break">per second.</span></li>
				<li><strong class="source-inline">io</strong>: This provides information about I/O operations. The <strong class="source-inline">bi</strong> column shows the number of blocks received from a block device (such as a hard disk) per second, and the <strong class="source-inline">bo</strong> column shows the number of blocks sent to a block device <span class="No-Break">per second.</span></li>
				<li><strong class="source-inline">system</strong>: This section displays system-related statistics. The <strong class="source-inline">in</strong> column represents the number of interrupts per second, and the <strong class="source-inline">cs</strong> column represents the number of context switches <span class="No-Break">per second.</span></li>
				<li><strong class="source-inline">cpu</strong>: This section provides CPU utilization statistics. The <strong class="source-inline">us</strong> column represents the percentage of CPU time spent in user-level processes. The <strong class="source-inline">sy</strong> column represents the percentage of CPU time spent in system-level processes. The <strong class="source-inline">id</strong> column represents the percentage of idle CPU time. The <strong class="source-inline">wa</strong> column represents the percentage of CPU time spent waiting for I/O operations. The <strong class="source-inline">st</strong> column represents<a id="_idIndexMarker485"/> the percentage of CPU<a id="_idIndexMarker486"/> time stolen from a <strong class="bold">virtual </strong><span class="No-Break"><strong class="bold">machine</strong></span><span class="No-Break"> (</span><span class="No-Break"><strong class="bold">VM</strong></span><span class="No-Break">).</span></li>
			</ul>
			<h1 id="_idParaDest-105"><a id="_idTextAnchor115"/>The kill command</h1>
			<p>The <strong class="source-inline">kill</strong> command is a fundamental<a id="_idIndexMarker487"/> and powerful utility in Linux used to terminate or send signals to running processes. In many cases, it requires superuser (<strong class="source-inline">sudo</strong>) privileges to terminate processes that belong to other users or are critical to system operation. Its primary purpose is to gracefully stop or forcibly terminate processes based on their PIDs. The <strong class="source-inline">kill</strong> command allows system administrators to manage and control the execution of processes, ensuring smooth system operation and resource management. One of the most common signals sent by the <strong class="source-inline">kill</strong> command is <strong class="source-inline">SIGTERM</strong> (signal 15), which politely asks a process to terminate, giving it a chance to perform cleanup tasks before exiting. Additionally, the <strong class="source-inline">kill</strong> command can send other signals such as <strong class="source-inline">SIGKILL</strong> (signal 9), which forcefully terminates a process without allowing it to perform any cleanup. This is useful in cases where a process is unresponsive or causing system instability. The <strong class="source-inline">kill</strong> command is crucial for handling unresponsive or problematic processes, preventing resource exhaustion, and maintaining system stability. Moreover, the <strong class="source-inline">kill</strong> command plays a vital role in process management, enabling administrators to prioritize certain processes over others. By sending different signals, administrators can alter the behavior of running processes. For example, sending the <strong class="source-inline">SIGSTOP</strong> signal suspends a process, while sending the <strong class="source-inline">SIGCONT</strong> signal resumes it. This capability is useful for pausing and resuming processes or controlling their execution based on specific conditions. The <strong class="source-inline">kill</strong> command is an essential tool for Linux system administrators when handling process-related issues, managing system resources, and ensuring efficient and reliable <span class="No-Break">system performance.</span></p>
			<p>Additionally, the <strong class="source-inline">kill</strong> command is integral to process coordination and <strong class="bold">inter-process communication</strong> (<strong class="bold">IPC</strong>). It allows processes to signal each other and synchronize<a id="_idIndexMarker488"/> their actions effectively. This feature is critical for complex system architectures, where multiple processes need to cooperate and interact with each other. By using the <strong class="source-inline">kill</strong> command, administrators can facilitate communication and coordination among processes, resulting in better overall system performance and functionality. The <strong class="source-inline">kill</strong> command is also commonly used in shell scripts and automation scripts to manage processes, making it a valuable tool for automating system tasks <span class="No-Break">and maintenance.</span></p>
			<p>The steps for killing a specific process with the <strong class="source-inline">kill</strong> command are set <span class="No-Break">out here:</span></p>
			<ol>
				<li>Find the PID of the target process using the <span class="No-Break"><strong class="source-inline">ps</strong></span><span class="No-Break"> command.</span></li>
				<li>Use the <strong class="source-inline">kill</strong> command followed by the PID to terminate <span class="No-Break">the process:</span></li>
			</ol>
			<div>
				<div id="_idContainer210" class="IMG---Figure">
					<img src="image/B18212_09_23.jpg" alt="Figure 9.23 – Killing a specific process with the kill command"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.23 – Killing a specific process with the kill command</p>
			<ol>
				<li value="3">We verify the process <a id="_idIndexMarker489"/>using the <strong class="source-inline">systemctl</strong> command, as <span class="No-Break">demonstrated here:</span></li>
			</ol>
			<div>
				<div id="_idContainer211" class="IMG---Figure">
					<img src="image/B18212_09_24.jpg" alt="Figure 9.24 – Verifying the kill process"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.24 – Verifying the kill process</p>
			<h1 id="_idParaDest-106"><a id="_idTextAnchor116"/>The pkill command</h1>
			<p>The <strong class="source-inline">pkill</strong> command is a powerful utility<a id="_idIndexMarker490"/> in Linux used to terminate or signal processes based on their names or other criteria. Its primary purpose is to provide a more user-friendly and efficient way to kill processes compared to using their PIDs. One of the key reasons for its importance is its ability to simplify the process of terminating multiple instances of a process with the same name. This is particularly useful when dealing with applications that run multiple processes, such as web servers or database servers. The <strong class="source-inline">pkill</strong> command ensures that all relevant processes are terminated without the need to identify and input individual PIDs. Its ease of use makes it a valuable tool for system administrators in various scenarios, including troubleshooting, process management, <span class="No-Break">and automation.</span></p>
			<p>We can kill multiple processes with the <span class="No-Break"><strong class="source-inline">pkill</strong></span><span class="No-Break"> command.</span></p>
			<p>Use the <strong class="source-inline">pkill</strong> command followed by the process name to terminate all processes with the <span class="No-Break">same name:</span></p>
			<div>
				<div id="_idContainer212" class="IMG---Figure">
					<img src="image/B18212_09_25.jpg" alt="Figure 9.25 – Killing multiple processes with the pkill command"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.25 – Killing multiple processes with the pkill command</p>
			<p>In conclusion, Linux monitoring<a id="_idIndexMarker491"/> and debugging commands are indispensable tools for Linux system administrators. These commands empower administrators to monitor system performance, troubleshoot issues, and ensure the stability and reliability of their Linux systems. With a wide range of commands at their disposal, administrators can gain valuable insights into system behavior, identify problems, and implement effective solutions. By mastering these commands, administrators can optimize system performance, enhance security, and deliver a seamless user experience. Overall, Linux monitoring and debugging commands are essential for maintaining the health<a id="_idIndexMarker492"/> and functionality of <span class="No-Break">Linux environments.</span></p>
			<h1 id="_idParaDest-107"><a id="_idTextAnchor117"/>Summary</h1>
			<p>This chapter delves into a diverse range of crucial tools designed to empower Linux system administrators in efficiently monitoring system performance and identifying and resolving potential issues. The chapter covers a wide array of commands, each serving a specific purpose in gaining insights into various aspects of the system. From real-time monitoring using commands such as <strong class="source-inline">top</strong> and <strong class="source-inline">vmstat</strong> to analyzing process relationships with <strong class="source-inline">pstree</strong> and debugging software issues using <strong class="source-inline">strace</strong>, this chapter equips administrators with valuable tools to ensure the stability, reliability, and optimal performance of their <span class="No-Break">Linux systems.</span></p>
			<p>Additionally, the chapter explores commands such as <strong class="source-inline">watch</strong>, <strong class="source-inline">smartctl</strong>, <strong class="source-inline">uptime</strong>, <strong class="source-inline">kill</strong>, and <strong class="source-inline">pkill</strong> that aid in repetitive command execution, managing storage devices, terminating processes, and checking system uptime and load average, respectively. The combination of these monitoring and debugging commands equips system administrators with comprehensive visibility into system health, resource utilization, and user activity, enabling them to make informed decisions and proactively address <span class="No-Break">potential issues.</span></p>
			<p>In the next chapter, we will delve into a comprehensive array of indispensable tools designed to facilitate network management and enhance system performance in Linux environments. This chapter covers a diverse range of commands, each serving a specific purpose in configuring and monitoring network settings. From <strong class="source-inline">iptables</strong> for firewall management to commands such as <strong class="source-inline">ifconfig</strong> and <strong class="source-inline">ip</strong> for network interface configuration and more, this chapter equips system administrators with essential tools to ensure smooth network operations and <span class="No-Break">secure communication.</span></p>
		</div>
	</body></html>