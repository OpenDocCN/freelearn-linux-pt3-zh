["```\n#!/bin/bash\n# V1.0 / Jasmin Redzepagic / 01/11/2021 Initial script version \n# Distribution allowed under GNU Licence V2.0\necho \"Number of directories in current directory is:\"\nfind . -type d | wc -l\necho \"Directory usage, sorted in descending order, is as follows:\"\nfind . -type d | du | sort -nr\necho \"Number of files in current directory is:\"\nfind . -type f | wc -l\necho \"File usage, sorted in descending order, is as follows:\"\nfind . -type f -exec ls -al {} \\; | sort -k 5 -nr | sed 's/ \\+/\\t/g' | cut -f5,9\n```", "```\n#!/bin/bash\n# V1.0 / Jasmin Redzepagic / 01/11/2021 Initial script version \n# Distribution allowed under GNU Licence V2.0 \n# First, let's find out if the destination directory exists by\n# using test function. If it does, go on with the script. If it\n# doesn't, create that destination directory. In our example,\n# destination directory is called copylocation.\nif [ -d \"./copylocation\" ]\nthen\n             echo \"Directory ./copylocation exists.\"\nelse\n              echo \"Error: Directory ./copylocation does not exist.\"\n              mkdir ./copylocation\nfi\n# next step, let's create a friendly file list with all of the files\n# in current folder\nfind . -type f -exec ls -al {} \\; | sed 's/  */ /g' | cut -f9 -d\" \" > filelist.txt\n# Last step, let's load this file into variable so that we can loop\n# over it and copy every file from it to our destination folder\nfile_list='cat filelist.txt'\nfor current_file in $file_list\ndo\n             echo \"Copying $current_file to destination\"\n             cp \"$current_file\" ./copylocation\ndone\n```", "```\n#!/bin/bash\n# V1.0 / Jasmin Redzepagic / 01/11/2021 Initial script version \n# Distribution allowed under GNU Licence V2.0 \n# First, we need to check if our environment variable UID is set to\n# 0 or not and branch that out to either yes or no with appropriate\n# status messages\nif [ \"$EUID\" -eq 0 ]\n             then\n                         echo \"You are running as root user. Please be careful!\"\n             else\n                         echo \"You are not root. It's all sunshine and roses, you can't do much damage!\"\nfi\nexit 0\n```", "```\nsudo apt-get -y install sysstat\n```", "```\nsudo yum -y install sysstat\n```", "```\nsudo systemctl enable --now sysstat\n```", "```\n#!/bin/bash\n# V1.0 / Jasmin Redzepagic / 01/11/2021 Initial script version \n# Distribution allowed under GNU Licence V2.0 \necho \"Hostname: $(hostname)\"\necho \"Current date: $(date)\"\necho \"Current kernel version and CPU architecture: $(uname -rp)\"\n# sar command has a default first line output telling us that it's\n# running on Linux, and which kernel we are using. It's pointless\n# to get this information four or five times, so let's filter that\n# out from the get-go (grep -v \"Linux\" part of every command)\necho \"Current CPU usage:\"\nsar -u 1 1| grep -v \"Linux\"\necho \"\"\necho \"Current memory usage:\"\nsar -r 1 1| grep -v \"Linux\"\necho \"\"\necho \"Current swap space usage:\"\nsar -S 1 1| grep -v \"Linux\"\necho \"\"\n# When sar displays disk I/O info, it displays that info per\n# device, which isn't all that important. What's important for\n# us are sd* and vd* devices, as well as the status line telling\n# us which specific metrics are shown in the column (DEV).\necho \"Current disk I/O:\"\nsar -d 1 1| grep -E \"(DEV|sd|vd)\" | grep -v \"Linux\"\necho \"\"\n# When sar displays network information, it shows it per device.\n# Having in mind that we have a loopback network device (lo) and \n# that its statistics isn't important, let's just filter that out\n# so that we can see network bandwidth info per real network device\necho \"Current network bandwidth usage:\"\nsar -n DEV 1 1| grep -v lo | grep -v \"Linux\"\n```", "```\n#!/usr/bin/bash\n# V1.0 / Jasmin Redzepagic / 01/11/2021 Initial script version \n# Distribution allowed under GNU Licence V2.0 \nread -p \"Enter directory to move file to: \" DESTDIR\necho -e \"\\n\"\n# Let's first establish a destination directory with a loop that can test if that directory exists or not\nif [ \"$DESTDIR\" == \"\" ];\nthen\n        echo \"You must specify a directory.\"\nelse\n        if [ ! -d \"$DESTDIR\" ]\n        then\n                echo \"Directory $DESTDIR must exist. Exiting!\"\n\n                exit\n        fi\nfi\n# Directory is ready, let's go to the main part of the script. First\n# step is selecting which type of search we want to use.\necho \"Enter number denoting criteria for search: \"\necho \"1 = by name \"\necho \"2 = by ownership \"\necho \"3 = by content extension \"\necho -e \"\\n\"\nread CRIT\n# Let's start our case loop against CRIT variable.\ncase $CRIT in\n        1)\n                read -p \"Enter name to search for: \" NAME\n                echo -e \"\\n\"\n                if [ ! -z  $NAME=\"\" ]\n                        then\n                                find / -name \"$NAME\" -exec cp {} $DESTDIR \\; 2> /dev/null\n                        else\n                                echo You have to enter the name!\n                fi\n                ;;\n        2)\n                read -p \"Enter owner to search for: \" OWNER\n                echo -e \"\\n\"\n                if [ ! -z $OWNER=\"\" ]\n                      then\n                                find / -user $OWNER -exec cp {} $DESTDIR \\;  2> /dev/null\n                        else\n                                echo You have to input an owner!\n                fi\n                ;;\n        3)\n                read -p \"Enter content extension: \" CEXT\n                echo -e \"\\n\"\n                if [ ! -z $CEXT=\"\" ]\n                        then\n                                read -p \"Where are we looking for files, in which directory?\" LOOKUP\n                                find \"$LOOKUP\" -type f -name \"$CEXT\" -exec cp {} $DESTDIR \\; 2> /dev/null\n                        else\n                                echo You have to enter the content type!\n                fi\n                  ;;\n        *)      echo please make a choice, either 1, 2 or 3!\nesac\n```", "```\n#!/bin/bash\n# V1.0 / Jasmin Redzepagic / 01/11/2021 Initial script version \n# Distribution allowed under GNU Licence V2.0 \n# This part of our script is just plain using date command to assign\n# values to \"obviously named variables\". This further shows two\n# things - how to assign a variable value from external command,\n# and how to use that principle on date and time data.\nhour=$(date +%H)\nminute=$(date +%M)\nsecond=$(date +%S)\nday=$(date +%d)\nmonth=$(date +%m)\nyear=$(date +%Y)\n# Let's print that out\necho \"Current time is: $hour:$minute:$second\"\necho \"Current date is: $day-$month-$year\"\n```", "```\nsystemctl status firewalld\n```", "```\nsystemctl status ufw\n```", "```\nsystemctl enable --now firewalld\n```", "```\nsystemctl enable --now ufw\n```", "```\nfirewall-cmd --get-services\n```", "```\n#!/bin/bash\n# V1.0 / Jasmin Redzepagic / 01/11/2021 Initial script version \n# Distribution allowed under GNU Licence V2.0 \necho \"1 = firewalld (CentOS) - manipulate service configuration - add\"\necho \"2 = firewalld (CentOS) - manipulate service configuration - remove\"\necho \"3 = firewalld (CentOS) - manipulate TCP ports - add\"\necho \"4 = firewalld (CentOS) - manipulate TCP ports - remove\"\necho \"5 = firewalld (CentOS) - manipulate UDP ports - add\"\necho \"6 = firewalld (CentOS) - manipulate UDP ports - remove\"\necho \"7 = firewalld (CentOS) - manipulate rich rules - add\"\necho \"8 = firewalld (CentOS) - manipulate rich rules - remove\"\necho \"9 = firewalld (CentOS) - list current configuration\"\necho -e \"Your choice:\"\nread CRIT\n# Let's start our case loop against CRIT variable.\ncase $CRIT in\n        1)\n                echo \"Enter service names, using space as separator.\"\n                echo \"Hint: ssh http https etc. Get list from firewall-cmd --get-services\"\n                echo \"Your input:\"\n                read -a FW1\n                for svcs1 in ${FW1[@]}\n                do\n                        firewall-cmd --permanent --add-service=$svcs1\n                done\n                firewall-cmd --reload\n                ;;\n        2)\n                echo \"Enter service names, using space as separator.\"\n                echo \"Hint: ssh http https etc. Get list from firewall-cmd --get-services\"\n                echo \"Your input:\"\n                read -a FW2\n                for svcs2 in ${FW2[@]}\n                do\n                        firewall-cmd --permanent --remove-service=$svcs2\n                done\n                firewall-cmd --reload\n                ;;\n        3)\n                echo \"Enter TCP port numbers, using space as separator.\"\n                echo \"Hint: 22 80 443 etc.\"\n                echo \"Your input:\"\n                read -a FW3\n                for svcs3 in ${FW3[@]}\n                do\n                        firewall-cmd --permanent --add-port=$svcs3/tcp\n                done\n                firewall-cmd --reload\n                ;;\n        4)\n                echo \"Enter TCP port numbers, using space as separator.\"\n                echo \"Hint: 22 80 443 etc.\"\n                echo \"Your input:\"\n                read -a FW4\n                for svcs4 in ${FW4[@]}\n                do\n                        firewall-cmd --permanent --remove-port=$svcs4/tcp\n                done\n                firewall-cmd --reload\n                ;;\n        5)\n                echo \"Enter UDP port numbers, using space as separator.\"\n                echo \"Hint: 22 80 443 etc.\"\n                echo \"Your input:\"\n                read -a FW5\n                for svcs5 in ${FW5[@]}\n                do\n                        firewall-cmd --permanent --add-port=$svcs5/udp\n                done\n                firewall-cmd --reload\n                ;;\n        6)\n                echo \"Enter UDP port numbers, using space as separator.\"\n                echo \"Hint: 22 80 443 etc.\"\n                echo \"Your input:\"\n                read -a FW6\n                for svcs6 in ${FW6[@]}\n                do\n                        firewall-cmd --permanent --remove-port=$svcs6/udp\n                done\n                firewall-cmd --reload\n                ;;\n        7)\n                echo \"Let's manipulate rich rules - to add specific IPs access to specific port.\"\n                echo \"Hint: first, we need an endpoint IP address, like 45.67.98.43                   \"\n                echo \"Your input (IP address):\"\n                read -a FW71\n                echo \"To which TCP port you want to allow access?\"\n                echo \"Your input (TCP port number):\"\n                echo \"Your input:\"\n                read -a FW72\n                for svcs71 in ${FW71[@]}\n                do\n                        for svcs72 in ${FW72[@]}\n                        do\n                                firewall-cmd --permanent --add-rich-rule='rule family=\"ipv4\" source address=\"'$svcs71'/32\" port protocol=\"tcp\" port=\"'$svcs72'\" accept'\n                        done\n                done\n                firewall-cmd --reload\n                ;;\n        8)\n                echo \"Let's manipulate rich rules - to add specific IPs access to specific port.\"\n                echo \"Hint: first, we need an endpoint IP address, like 45.67.98.43\"\n                echo \"Your input (IP address):\"\n                read -a FW81\n                echo \"To which TCP port you want to allow access?\"\n                echo \"Your input (TCP port number):\"\n                echo \"Your input:\"\n                read -a FW82\n                for svcs81 in ${FW81[@]}\n                do\n                        for svcs82 in ${FW82[@]}\n                        do\n                                firewall-cmd --permanent --remove-rich-rule='rule family=\"ipv4\" source address=\"'$svcs81'/32\" port protocol=\"tcp\" port=\"'$svcs82'\" accept'\n                        done\n                done\n                firewall-cmd --reload\n                ;;\n        9)\n                echo \"Let's just list the firewalld settings first:\"\n                firewall-cmd --list-all\n                echo \"Let's list all the rich rules, if any:\"\n                firewall-cmd --list-rich-rules\n                ;;\n        *)      echo \"Please make a correct choice, available choices are 1-9!\"\nesac\n```", "```\n#!/bin/bash\necho \"1 = ufw (Ubuntu) - manipulate service configuration - add\"\necho \"2 = ufw (Ubuntu) - manipulate service configuration - remove\"\necho \"3 = ufw (Ubuntu) - manipulate TCP ports - add\"\necho \"4 = ufw (Ubuntu) - manipulate TCP ports - remove\"\necho \"5 = ufw (Ubuntu) - manipulate UDP ports - add\"\necho \"6 = ufw (Ubuntu) - manipulate UDP ports - remove\"\necho \"7 = ufw (Ubuntu) - manipulate whitelist IP/port configuration - add\"\necho \"8 = ufw (Ubuntu) - manipulate whitelist IP/port configuration - remove\"\necho \"9 = ufw (Ubuntu) - list current configuration\"\necho -e \"Your choice:\"\nread CRIT\n# Let's start our case loop against CRIT variable.\ncase $CRIT in\n        1)\n                echo \"Enter service names, using space as separator.\"\n                echo \"Hint: ssh http https etc. Get list from /etc/services\"\n                echo \"Your input:\"\n                read -a FW1\n                for svcs1 in ${FW1[@]}\n                do\n                        ufw allow $svcs1\n                done\n                ;;\n        2)\n                echo \"Enter rule numbers from the list:\"\n                ufw status numbered\n                echo \"Your input, single number or multiple numbers separated by space:\"\n                echo \"Hint: Best way to do it would be backwards - from top rule number to bottom rule number!\"\n                read -a FW2\n                for svcs2 in ${FW2[@]}\n                do\n                       echo \"y\" | ufw delete $svcs2\n                done\n                ;;\n        3)\n                echo \"Enter TCP port numbers, using space as separator.\"\n                echo \"Hint: 22 80 443 etc.\"\n                echo \"Your input:\"\n                read -a FW3\n                for svcs3 in ${FW3[@]}\n                do\n                        ufw allow $svcs3/tcp\n                done\n                ;;\n        4)\n                echo \"Enter TCP port numbers, using space as separator.\"\n                echo \"Hint: 22 80 443 etc.\"\n                echo \"Your input:\"\n                read -a FW4\n                for svcs4 in ${FW4[@]}\n                do\n                        ufw delete allow $svcs4/tcp\n                done\n                ;;\n        5)\n                echo \"Enter UDP port numbers, using space as separator.\"\n                echo \"Hint: 22 80 443 etc.\"\n                echo \"Your input:\"\n                read -a FW5\n                for svcs5 in ${FW5[@]}\n                do\n                        ufw allow $svcs5/udp\n                done\n                ;;\n        6)\n                echo \"Enter UDP port numbers, using space as separator.\"\n                echo \"Hint: 22 80 443 etc.\"\n                echo \"Your input:\"\n                read -a FW6\n                for svcs6 in ${FW6[@]}\n                do\n                        ufw delete allow $svcs6/udp\n                done\n                ;;\n        7)\n                echo \"Let's manipulate whitelist rules - to add specific IPs access to specific port.\"\n                echo \"Hint: first, we need an endpoint IP address, like 45.67.98.43\"\n                echo \"Your input (IP address):\"\n                read -a FW71\n                echo \"To which port you want to allow access?\"\n                echo \"Your input (port number):\"\n                echo \"Your input:\"\n                read -a FW72\n                for svcs71 in ${FW71[@]}\n                do\n                        for svcs72 in ${FW72[@]}\n                        do\n                                ufw allow from $svcs71 to any port $svcs72\n                        done\n                done\n                ;;\n        8)\n                echo \"Let's manipulate whitelist rules - to remove specific IPs access to specific port.\"\n                echo \"Hint: first, we need an endpoint IP address, like 45.67.98.43\"\n                echo \"Your input (IP address):\"\n                read -a FW81\n                echo \"To which port you want to allow access?\"\n                echo \"Your input (port number):\"\n                echo \"Your input:\"\n                read -a FW82\n                for svcs81 in ${FW81[@]}\n                do\n                        for svcs82 in ${FW82[@]}\n                        do\n                                ufw delete allow from $svcs81 to any port $svcs82\n                        done\n                done\n                ;;\n        9)\n                echo \"Let's list the ufw settings:\"\n                ufw status\n                ;;\n        *)      echo \"Please make a correct choice, available choices are 1-9!\"\nesac\n```", "```\n#!/bin/bash\n# V1.0 / Jasmin Redzepagic / 01/11/2021 Initial script version \n# Distribution allowed under GNU Licence V2.0 \necho \"1 = nmcli - static IP address configuration for existing interface\"\necho \"2 = nmcli - reconfigure a static IP-based configuration to DHCP\"\necho \"3 = nmcli - list current device and connection status\"\necho -e \"Your choice:\"\nread CRIT\n# Let's start our case loop against CRIT variable.\ncase $CRIT in\n        1)\n                echo \"Let's first check current connection configuration:\"\n                nmcli con show\n                echo \"Which interface do you want to configure from this list?\"\n                echo \"HINT: We need to use an entry from NAME field\"\n                echo \"Type in the interface name: \"\n                read -a interface1\n                echo \"Type in the IP address/prefix: \"\n                read -a address1\n                echo \"Type in the default gateway IP address: \"\n                read -a gateway1\n                echo \"Type in DNS servers, use space to separate entries: \"\n                read -a dns1\n                echo\n                nmcli con mod $interface1 ipv4.address \"$address1\" ipv4.gateway \"$gateway1\"\n                nmcli con mod $interface1 ipv4.method manual\n                for dnsservers in ${dns1[@]}\n                do\n                        nmcli con mod $interface1 ipv4.dns $dnsservers\n                done\n                systemctl restart NetworkManager\n                ;;\n        2)\n                echo \"Let's first check current connection configuration:\"\n                nmcli con show\n                echo \"Which interface do you want to configure from this list?\"\n                echo \"HINT: We need to use an entry from NAME field\"\n                echo \"Type in the interface name: \"\n                read -a interface1\n                nmcli con mod $interface1 ipv4.method auto\n                systemctl restart NetworkManager\n                ;;\n        3)\n                echo \"Current status of network devices: \"\n                nmcli dev show\n                echo \"Current status of network connections: \"\n                nmcli con show\n                ;;\n        *)      echo \"Please make a correct choice, available choices are 1-3!\"\nesac\n```", "```\nsudo apt-get -y install tar\n```", "```\nsudo yum -y install tar\n```", "```\n#!/bin/sh\n# V1.0 / Jasmin Redzepagic / 01/11/2021 Initial script version \n# Distribution allowed under GNU Licence V2.0 \n# This script contains some pre-defined parameters:\n# - which directories we want to backup, used as a variable\n# backup_source\n# - destination folder, via variable called backup_dest\n# - indexing according to date, used as a variable date\n#\n# Also, it uses a shell script argument $1 (first argument that we\n# use to call on the script) to set value for variable filename\nfilename=$1\n# let's set the directory that we want to backup\n# if we want to backup more of them, we create a space-separated\n# list\nbackup_source=\"./\"\n# let's set the destination folder\nbackup_dest=\"/tmp\"\n# let's set value of the date variable in accordance to current date\ndate='date '+%d-%B-%Y''\n# let's set the value of the hostname variable in accordance to host\n# name\nhostname=$(hostname -s)\n# let's start the backup process\necho \"Starting backup\"\nsleep 2\ntar cvpzf   $backup_dest/$filename-$hostname-$date.tar.gz  $backup_source\n# let's announce the end of the backup process\necho \"Backup done\"\n```", "```\n#!/bin/bash\n# V1.0 / Jasmin Redzepagic / 01/11/2021 Initial script version \n# Distribution allowed under GNU Licence V2.0 \n# This script does a custom backup, based on our arguments\n# We need to give it a couple of arguments @start:\n# - backup file name\n# - list of directories (or a single directory) that we\n# want to backup\n# We also added a bit of code to skip standard error\necho -e \"Type in the backup file name, use something like file-date.tar.gz:\"\nread filename\necho -e \"Type in the list or a single directory that you want to backup:\"\nread directories\necho \"Let's do this thing!\"\ntar cfvz $filename $directories 2> /dev/null\n```"]