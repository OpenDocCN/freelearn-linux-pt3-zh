["```\n#!/bin/bash  ← [1]\n#\n# IDENTIFICATION  ← [2]\n#\n# VARIABLES  ← [3]\n# COMMANDS  ← [4]\n```", "```\n$ sudo -i\n```", "```\n    # mkdir class\n    # cd class\n    ```", "```\n    # vim mytasks.sh\n    ```", "```\n    date command gets formatted as 2023-06-18 20:50.\n    ```", "```\n    DATA_FILE=$WDIR/data\n    ```", "```\n    log levels (info, error, warn, and so on) allows you to distinguish the outputs of the activities.\n    ```", "```\necho \"$TIMESTAMP [INFO] Create data file\" >> $LOG\ncat /etc/passwd >> $DATA_FILE\ncat /etc/group >> $DATA_FILE\ncat /etc/shadow >> $DATA_FILE\n```", "```\n    # chmod +x mytasks.sh\n    ```", "```\n    # ./mytasks.sh\n    ```", "```\n    echo \"$TIMESTAMP [INFO] Verify the data file\" >> $LOG\n    if [ -f $DATA_FILE ];\n    then\n      echo \"$TIMESTAMP [OK] The data file exists\" >> $LOG\n    else\n      echo \"$TIMESTAMP [INFO] Create data file\" >> $LOG\n      cat /etc/passwd >> $DATA_FILE\n      cat /etc/group >> $DATA_FILE\n      cat /etc/shadow >> $DATA_FILE\n    data file can be turned into a basic for loop:\n\n    ```", "```\n\n    ```", "```\n    # rm -rf data\n    ```", "```\n# Version: 0.2 → Add data file validation\n```", "```\n    echo \"$TIMESTAMP [INFO] Verify users\" >> $LOG\n    ```", "```\n    USER_FILE=$WDIR/users\n    ```", "```\n    # Version: 1.0 → Add user creation and customization\n    ```", "```\n    $ git config --global user.name \"username\"\n    $ git config --global user.email user@your-mail.com\n    ```", "```\n    $ mkdir git-basics ; cd git-basics\n    ```", "```\n    $ git init .\n    Initialized empty Git repository in /home/username/git-basics/.git/\n    ```", "```\n    #\n    # Lines added for git-prompt\n    #\n    git_prompt_sh='/usr/share/git-core/contrib/completion/git-prompt.sh'\n    if [ -f ${git_prompt_sh} ]; then\n      source ${git_prompt_sh}\n      export GIT_PS1_SHOWDIRTYSTATE=true\n      export GIT_PS1_SHOWUNTRACKEDFILES=true\n      export PS1='[\\u@\\h \\W$(declare -F __git_ps1 &>/dev/null && __git_ps1 \" (%s)\")]\\$ '\n    fi\n    ```", "```\n    $ git branch –m master main\n    ```", "```\n    name = input(\"What's your name? \")\n    print(name + \" Welcome!\")\n    ```", "```\n    $ git status\n    ```", "```\n    $ git add my-script.py\n    ```", "```\n    $ python my-script.py\n    ```", "```\n    $ git log command:\n\n    ```", "```\n\n    ```", "```\n    $ git clone https://github.com/alex-sysadmin/daily-tasks-scripts.git\n    ```", "```\n    $ git add .\n    ```", "```\n    $ git push --set-upstream origin main\n    ```", "```\n    $ tar czvf daily-tasks-scripts.bkp.tar.gz ../wdir/daily-tasks-scripts\n    ```", "```\n    $ tar cjvf daily-tasks-scripts.bkp.tar.bz2 ../wdir/daily-tasks-scripts\n    ```", "```\n$ du -sb ../wdir/daily-tasks-scripts\ngzip algorithm, is 18947 bytes:\n\n```", "```\n$ du -sb daily-tasks-scripts.bkp.tar.bz2\n18594 daily-tasks-scripts.bkp.tar.bz2\n```", "```\n    $ git fetch --all\n    $ git pull --all\n    ```", "```\n    $ git branch acallejas/repo-enhancement\n    ```", "```\n$ README.md file that serves to document the use of the repository. Let’s update this file so that we can document our repository.\n\n1.  Update the **README.md** file so that it documents the repository:\n\n![Figure 10.45 – Updating the README.md file](img/B19121_10_45.jpg)\n\nFigure 10.45 – Updating the README.md file\nNote that the `README.md` file format uses the Markdown language. Markdown is a *markup language* that appears to human readers when it’s in its source code form.\nNote\nTo learn more about the basic syntax of the Markdown language, refer to the *Markdown guide* at [https://www.markdownguide.org/basic-syntax](https://www.markdownguide.org/basic-syntax).\nSave the changes and compare the differences between this branch and the main branch.\n\n1.  Use the **git diff** command to display the differences between the branches:\n\n    ```", "```\n\n![Figure 10.46 – Displaying the differences between the branches](img/B19121_10_46.jpg)\n\nFigure 10.46 – Displaying the differences between the branches\nThe lines that begin with plus (`+`) signs state the differences in the `README.md` file between the versions of the branches.\n\n1.  Add and commit the changes to the file to update the branch:\n\n    ```", "```\n\n     2.  Update the remote repository with the local enhancement branch. Use the **git push** command and the branch’s name to do so:\n\n    ```", "```\n\n![Figure 10.47 – Updating the remote repository](img/B19121_10_47.jpg)\n\nFigure 10.47 – Updating the remote repository\n\n1.  For the local repository, use the **git branch** command to show the branches of the local repository. The **-r** option lists the remote branches while **-a** lists all branches:\n\n    ```", "```\n\n![Figure 10.48 – Listing the branches](img/B19121_10_48.jpg)\n\nFigure 10.48 – Listing the branches\n\n1.  The web platform also displays the branches. Navigate to the repository and click on the **Branches** link:\n\n![Figure 10.49 – Branches](img/B19121_10_49.jpg)\n\nFigure 10.49 – Branches\nThe changes haven’t been applied to the *main branch* yet. To do this, we need to *merge* the branch with the enhancements. This should be done through a pull request.\nLet’s integrate the enhancements into the *main branch*.\n\n1.  In the **Branches** window, click on the **New pull** **request** button:\n\n![Figure 10.50 – The Branches window](img/B19121_10_50.jpg)\n\nFigure 10.50 – The Branches window\n\n1.  In the **Open a pull request** window, fill in the title and description fields of the change:\n\n![Figure 10.51 – The Open a pull request window](img/B19121_10_51.jpg)\n\nFigure 10.51 – The Open a pull request window\n\n1.  In this window, at the bottom, find and verify the details of the change.\n2.  In the right column, in the **Reviewers** section, select members of the team to *review the changes before merging them*, as good practice.\n3.  Once the request is ready, click on the **Create pull** **request** button.\n4.  The **Pull requests** window will appear, providing an overview of the change:\n\n![Figure 10.52 – The Pull requests screen](img/B19121_10_52.jpg)\n\nFigure 10.52 – The Pull requests screen\nThe **Commits** tab lists the changes committed, while the **Files changed** tab displays the difference between versions of the changed files.\n\n1.  If you agree with the merger of the branches, click on the **Merge pull** **request** button.\n2.  On confirming the merge, the repository on the web platform will display the changes that have been made:\n\n![Figure 10.53 – Remote repository updated](img/B19121_10_53.jpg)\n\nFigure 10.53 – Remote repository updated\nLet’s update the local repository.\n\n1.  In the local repository, switch to the main branch and update it:\n\n![Figure 10.54 – Local repository updated](img/B19121_10_54.jpg)\n\nFigure 10.54 – Local repository updated\nBy using the branches of the repository, a backup of our script directory of day-to-day tasks becomes available.\nBy archiving files to Git repositories, a backup could exist. Of course, there are software solutions that ease this task, even IT areas in charge of it. But the best practice is, regardless of these solutions, as the first law of the SysAdmin says: *always back up*. These activities, like many others, can be run in an automated fashion using scripts and/or scheduled tasks.\nNow, let’s look at a tool that might make it easier to automate tasks in Linux.\nAutomating with Ansible\n*Automate: A SysAdmin should automate as much as possible, except if it conflicts with the* *first law.*\nPreviously, we discussed one of the most well-known statements among SysAdmins:\n“*If you typed it twice, you should have scripted* *it once.*”\nIf a task gets scripted, it could be scheduled and, with this, automated. This means that the task must run without the SysAdmin’s intervention.\nHowever, not all scheduled tasks might be automated. The easiest way to determine this is by applying the *principles* *of automation*:\n\n*   The rule of **algorithmic thinking**\n\n    *Everything is a system*. Algorithmic thinking is a way of getting to a solution through a clear definition of the steps needed – *nothing happens* *by magic*.\n\n*   The rule of **bottlenecks**\n\n    *Bad decisions propagate*. Every system, regardless of how well it works, has at least one constraint (*a bottleneck*) that limits performance.\n\n*   The rule of **autonomy**\n\n    *Humans always play a role*. This challenges the idea that automation means completely eliminating the human element. Using the rule of algorithmic thinking, humans are another layer of abstraction in the system.\n\nTaking these principles into account and applying them allows us to define an ideal automation solution.\nThe **Ansible project** is an open source community sponsored by Red Hat, the developer of the automation tool. Ansible is available in the official Fedora Linux repositories.\n**Ansible** is an automation tool that focuses on simplicity and ease of use as its primary goals. Ansible enables us to configure systems, manage packages, and, in an advanced way, orchestrate tasks that support the continuous delivery cycle.\nAnsible works in two separate layers:\n\n*   *Control plane* (in the cloud): Generate instances and manage their resources\n*   *On instance*: Syart and stop services, push configuration files, install packages, and more\n\nThrough OpenSSH, an agentless service, Ansible manages systems and performs the tasks described previously.\nLet’s start with the basics of Ansible.\nThe basics\nThe Ansible use cases approach deals with automating processes. Let’s look at some of the most common options:\n\n*   Provisioning\n*   Configuration management\n*   Application deployment\n*   Continuous delivery\n*   Security and compliance\n*   Orchestration\n\nAnsible divides process automation into a variety of work unit levels:\n\n*   **Tasks**: A task is the smallest unit of work. It could consist of an action such as *install a database*, *install a web server*, or *copy this configuration file to* *the server*.\n*   **Plays**: A play consists of several tasks. For example, the play *Prepare a database for a web service* could consist of the following tasks:\n    1.  Install the database package.\n    2.  Set the password for the database administrator.\n    3.  Create the database.\n    4.  Define the access to the database.\n*   **Playbook**: A playbook consists of several plays. For example, the playbook *Install a website with a database backend* could consist of the following tasks:\n    1.  Configure the database server.\n    2.  Configure the web server.\n\nThe task automation process within Ansible requires two types of nodes to be defined: *control* and *managed*. The control node is the machine from where Ansible is running and the managed nodes are the machines where the tasks take place:\n![Figure 10.55 – Ansible nodes](img/B19121_10_55.jpg)\n\nFigure 10.55 – Ansible nodes\nLet’s learn how to prepare our workstation as the Ansible control node.\nFirst steps\nSo, let’s start with installing and configuring Ansible. Follow these steps:\n\n1.  Ansible is available in the official Fedora Linux repositories. Install the **ansible** package using the **dnf** command:\n\n    ```", "```\n\n     2.  Inside the working directory, create a directory named **ansible** and switch to it:\n\n    ```", "```\n\n     3.  Inside the **ansible** directory, create a configuration file called **ansible.cfg**. Only add the **defaults** section and set up the name of the **inventory** file, something like this:\n\n    ```", "```\n\n    Ansible does not install an agent on the managed nodes. Instead, it bases its communication with them through **SSH keys**. So, let’s create a key that we’ll use to manage the nodes.\n\n     4.  Create an **ssh** key pair and specify **rsa** with **2048** bits. Use the **ssh-keygen** command to do so:\n\n    ```", "```\n\n![Figure 10.56 – Generating the ssh key pair](img/B19121_10_56.jpg)\n\nFigure 10.56 – Generating the ssh key pair\nThe `ssh-keygen` command will ask you to confirm the path where the key should be generated. Note that the path must not be the *default path* but inside the working directory in the `ansible` directory.\nAfter this, the command prompts you to enter a passphrase instead of the user’s login password. As the connection must run *unattended*, leave this field empty and hit *Enter* twice to confirm the creation of the key pair.\nNote\nTo learn more about creating SSH keys, refer to the **ssh-keygen** man page.\nThis command generates the SSH key pair, which consists of a *public key* and a *private key*.\nLet’s test the communication with the key without using the user’s access password.\n\n1.  To test communication with the SSH key, copy the key to the same workstation. Use the **ssh-copy-id** command to do so:\n\n    ```", "```\n\n![Figure 10.57 – Copying the ssh public key](img/B19121_10_57.jpg)\n\nFigure 10.57 – Copying the ssh public key\nThe `ssh-copy-id` command copies the public key to the machine where the trust relationship gets established. In our case, this is the workstation itself.\nTo copy the key, the command asks for the user’s one-time login password.\nOnce access is granted, the command copies the content of the public key to the `authorized_keys` file in the hidden `.ssh` directory inside the user’s home directory.\n\n1.  To test the connection, use the **ssh** command to offer the private key:\n\n    ```", "```\n\n![Figure 10.58 – Testing the trust relationship](img/B19121_10_58.jpg)\n\nFigure 10.58 – Testing the trust relationship\nThe connection that uses the private key must allow access and run remote commands without requesting the user’s password.\nNow, let’s configure and automate simple tasks with Ansible.\n\n1.  Create the **inventory** file, adding **workstation** as a managed node, indicating the private key as a variable for the host. In the **inventory** file, add the following lines:\n\n    ```", "```\n\n    Let’s test the communication to the managed nodes using ad hoc commands. Ad hoc commands allow us to run basic tasks from the command line.\n\n     2.  Use the **ansible** command, along with the **ping** module, to verify the connection to all managed nodes:\n\n    ```", "```\n\n![Figure 10.59 – Testing communication with all managed nodes](img/B19121_10_59.jpg)\n\nFigure 10.59 – Testing communication with all managed nodes\nThis ad hoc command allows us to run any operating system command by passing it as an argument using the `-a` or `--``args` option:\n\n```", "```\n\n ![Figure 10.60 – Using ad hoc commands](img/B19121_10_60.jpg)\n\nFigure 10.60 – Using ad hoc commands\nNote\nFor more information, refer to the *Introduction to ad hoc commands* section of the Ansible documentation at [https://docs.ansible.com/ansible/latest/command_guide/intro_adhoc.html](https://docs.ansible.com/ansible/latest/command_guide/intro_adhoc.html).\nAs mentioned previously, the *tasks* and the set of them (*plays*) get grouped into a file. This file allows us to run them *sequentially or selectively*. These files are called *playbooks*.\n*Playbooks* come written in `YAML` format. This format, due to its simplicity, is based on a tree structure, which makes it more human-readable than a `JSON` or `XML` file. This means that it maintains its ideal of being the simplest implementation tool.\nLet’s analyze a *playbook* through a simple example. The following *playbook* runs the *tasks* to verify that a web server has the `httpd` package installed and running:\n\n```", "```\n\n ![Figure 10.61 – Ansible playbook](img/B19121_10_61.jpg)\n\nFigure 10.61 – Ansible playbook\nLet’s take a closer look:\n\n*   **<1>** **Identification block**: This assigns a *name* to the play and the *hosts* in the inventory where the play applies.\n*   **<2>** **Variables block**: This declares the *variables* used in the play.\n*   **<3>** **Tasks block**: This declares the *tasks* to run in the play.\n\nIn the preceding example, the *play* consists of two *tasks*:\n\n*   Verify that the **httpd** package has been installed as the latest version\n*   Verify that the **httpd** service has been enabled and started\n\nFor each of these tasks, the play uses two modules: `ansible.builtin.package` and `ansible.builtin.service`.\nThe modules consist of small units of code that perform tasks using instructions from the operating system. In the preceding example, the `ansible.builtin.package` module uses the `dnf` command to determine the *installation status* of the package.\nThe `ansible.builtin.service` module uses the `systemctl` command to determine the *status of* *the service*.\nSince the syntax of the playbooks uses the `YAML` file format, they are prone to indentation failures. Ansible provides a tool to check the syntax of playbooks – that is, the `ansible-playbook` command with the `--``syntax-check` option:\n\n```", "```\n\n ![Figure 10.62 – Verifying the syntax of the playbook](img/B19121_10_62.jpg)\n\nFigure 10.62 – Verifying the syntax of the playbook\nThe output of this command explains the syntax error. The error message shows where you can find the runtime error.\nNote\nAlthough the error message displays the error’s location, it could be a result of an error that wasn’t caused by the displayed location. As a best practice, confirm the correct indentation on the lines before the error message.\nAfter editing the playbook and fixing the error, run the syntax check again:\n\n```", "```\n\n ![Figure 10.63 – Running the syntax check on the playbook once more](img/B19121_10_63.jpg)\n\nFigure 10.63 – Running the syntax check on the playbook once more\nThis output indicates that our playbook has the correct syntax and is ready to run.\nAnother test tool provided by Ansible consists of running it in *dry-run mode*. Use the `ansible-playbook` command with the `--check` option to run in dry-run mode:\n\n```", "```\n\n ![Figure 10.64 – Running the playbook in dry-run mode](img/B19121_10_64.jpg)\n\nFigure 10.64 – Running the playbook in dry-run mode\nDry-run mode doesn’t send any error message, so it is considered positive. Note that no change occurred; the playbook only tested if the tasks could be run on the managed node.\nNow that there are no errors in the tests, run the playbook:\n\n```", "```\n\n ![Figure 10.65 – Running the playbook](img/B19121_10_65.jpg)\n\nFigure 10.65 – Running the playbook\nThe `failed=0` output indicates that the tasks were finished successfully.\nAs predicted, in dry-run mode, the playbook does not generate errors.\nConfirm this by logging into the host and verifying that the tasks are running:\n![Figure 10.66 – Verifying tasks](img/B19121_10_66.jpg)\n\nFigure 10.66 – Verifying tasks\nNote\nTo learn more about Ansible, refer to the Ansible documentation at [https://docs.ansible.com/index.html](https://docs.ansible.com/index.html).\nAutomating with Ansible simplifies day-to-day tasks.\n*Automate as much as possible, so long as that automation* *impacts backups.*\nAutomating enables us to get free time. Free time must be used to develop or learn new skills. *A SysAdmin never* *stops learning*.\nFinally, let’s take a look at a few resources where we can learn about and develop new skills.\nNever-ending study\n*Study: A SysAdmin must have free time to study, so long this free time does not conflict with the first or* *second law.*\nInfrastructure profiles have been evolving the most in recent years. It is not that it is going to disappear as a job role, but it is reinventing itself and new skills are emerging. Thus, professionals must gain new knowledge.\nThe best advice is to always go back to the basics – that is, to programming and coding. Knowing all sides of the system is what assures the *SysAdmin* that they can continue to play a fundamental role. Each new technology can mean better work in less time with greater control of the system.\nWhen new technology comes along, it takes time to study and implement it while keeping the system active, all while increasing productive leisure time.\nA SysAdmin needs commitment to continuous learning while keeping up to date with the latest technology trends and best practices.\nIn these same years, the boom of online education took place. Among the many resources available, there are several to take advantage of.\nLet’s review those that could develop our skills as a SysAdmin:\n\n*   A great place to develop **vim** editor skills is VimTricks. **VimTricks** ([https://vimtricks.com/](https://vimtricks.com/)) collects the necessary tricks, how-tos, guides, videos, links, and plugins and posts them on their social networks and as an e-newsletter. The site offers an extensive archive of published material, as well as a book and the possibility to register to receive the e-newsletter regularly:\n\n![Figure 10.67 – The VimTricks web page](img/B19121_10_67.jpg)\n\nFigure 10.67 – The VimTricks web page\n\n*   Another recommendation is a page that brings together the tools and training needed to develop with the new **Red Hat** technologies – that is, [https://developers.redhat.com/:](https://developers.redhat.com/:)\n\n![Figure 10.68 – The Red Hat Developer web page](img/B19121_10_68.jpg)\n\nFigure 10.68 – The Red Hat Developer web page\nRed Hat Developer is a community that provides tools, training, and technical talks designed to help developers improve their skills and keep up-to-date on the technologies that are shaping the future.\nSubscribers have access to weekly DevNation technical talks, technology deep dives, and open source tutorials.\nThe subscription is free – just sign up and you’ll also get access to other official Red Hat learning and reference sites.\n\n*   As a form of support to help you get solid knowledge of Ansible and automate tasks with this tool, you can go to [https://www.ansiblepilot.com/](https://www.ansiblepilot.com/):\n\n![Figure 10.69 – The Ansible Pilot learning page](img/B19121_10_69.jpg)\n\nFigure 10.69 – The Ansible Pilot learning page\n*Luca Berton*, Ansible automation expert and author of several books on automation, offers many examples, pieces of code, and videos of automating tasks of all kinds on his site. This is a great place to learn and practice task automation.\n\n*   **Kubernetes** is the *new paradigm of technology*. It is an open source container orchestrator that manages scalable applications. A good place to start with this technology is [https://kubebyexample.com/](https://kubebyexample.com/):\n\n![Figure 10.70 – The Kube by Example web page](img/B19121_10_70.jpg)\n\nFigure 10.70 – The Kube by Example web page\nWith Kube by Example, you can learn about Linux principles, the basics of Kubernetes, developing applications deployed on the platform, and applicable security best practices. It includes lots of downloadable code, practical examples, and videos so that learning can flow naturally.\n\n*   At **Packt Publishing** we don’t lag behind. You can access free learning content at [https://www.packtpub.com/free-learning](https://www.packtpub.com/free-learning):\n\n![Figure 10.71 – Packt free learning](img/B19121_10_71.jpg)\n\nFigure 10.71 – Packt free learning\nBy registering, you will have unlimited access to thousands of learning materials such as e-books and video courses – free content forever! Don’t miss the opportunity and sign up for your free trial.\n*Remember, a SysAdmin is always* *reinventing themselves.*\n*It’s not magic. It’s talent* *and sweat.*\nThere is a lot of reference material that could guide you in your development as a *SysAdmin*. However, if you want to look at it from a simple point of view, these three principles should help you create good habits that generate good practices.\nI hope you find them useful.\nIn the next chapter, we will discuss the use and practical application of operating system tuning.\nSummary\nIn this chapter, we reviewed the path to becoming a SysAdsmin and proposed three basic rules for the acquisition of good habits.\nFirst, we looked at *backing up* any information with which we have contact with the system. This backup will ensure that changes that are made can be returned safely in case they’re needed. It also provides a snapshot of the system at a certain point in time. Next, we looked at various task *automation* techniques to streamline our daily routine. This principle lightens your workload and allows SysAdmins to get free time that might be occupied with expanding their knowledge. The last point we considered was to *never stop learning*. Since technology is advancing faster and faster, this should be taken as a responsibility.\nIn the following chapters, we will make use of these principles and apply them to various particular aspects of *systems administration*. We will start by learning how to tune operating systems.\n\n```", "```\n\n```"]