- en: '5'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Introducing Files
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In Linux, everything is – or can be represented as – a file. Files are organized
    into a filesystem, which is just a hierarchy of files and directories (directories
    are just a special kind of file). As a developer, just about everything you do
    on a Linux system will require knowledge about files: writing and copying source
    code, building Docker images, application logging, configuring dependencies, and
    more.'
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we’ll cover the details of files in Linux. You’ll learn about
    the difference between plaintext files and binary files, which are the two most
    common types of file content you’ll be working with. We’ll show you how those
    are laid out and organized into a filesystem “tree” in Linux, before diving into
    the practical commands you’ll need to create, modify, move, and edit files. Then
    we’ll complete our tour of the basics with a practical introduction to file editing,
    using the most commonly available command-line text editors.
  prefs: []
  type: TYPE_NORMAL
- en: 'However, in this chapter, we don’t stop at the basics. Linux files are one
    topic where it pays (sometimes quite literally) to dive a bit deeper into some
    advanced knowledge. After all, “working with files” is one of the primary things
    you’ll be doing on Linux as a developer: writing and reading source code and configuration
    files, searching for specific file content, copying and moving log files around,
    and more. The more efficient you are at these basics, the more competent you’ll
    be as a well-rounded developer who doesn’t have to google basic Linux commands
    over and over, or get embarrassingly stuck in a command-line text editor during
    a troubleshooting Zoom call with your peers.'
  prefs: []
  type: TYPE_NORMAL
- en: First, we’ll talk about searching for files in the filesystem tree and finding
    specific content or patterns inside individual files. Then, we’ll talk about special
    files and alternate filesystems that you’re likely to come across, and what you
    need to know to work with them effectively.
  prefs: []
  type: TYPE_NORMAL
- en: 'By the end, you’ll know about:'
  prefs: []
  type: TYPE_NORMAL
- en: The many file types you might encounter, and what they’re used for
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The most important kinds of file data you’ll need to work with
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Linux filesystem and the commands you’ll use to work with it
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: File editing basics
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Some common problems and how to avoid them
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There’s a lot of content in this chapter, and it’s one of the most important
    foundations for the rest of your Linux skills. Make sure you understand each part
    before moving on – you don’t have to memorize everything on your first readthrough,
    but try to get as much practical experience as you can in your own Linux environment
    while working through this chapter. There’s a tangible payoff to knowing this
    stuff when you’re troubleshooting real-world problems or interviewing for a job.
  prefs: []
  type: TYPE_NORMAL
- en: 'Files on Linux: the absolute basics'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In order to break up the larger topic of files on Linux, let’s cover some of
    the absolute basics that you probably already have some intuition of: plaintext
    files and binary files. We’ll also cover a practical error that you might see
    if you move Windows files to a Unix system, or vice versa.'
  prefs: []
  type: TYPE_NORMAL
- en: Plaintext files
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: One of the simplest forms of text files you’ll encounter is the mighty plaintext
    file. While historically they were ASCII files, they are now typically UTF-8 encoded.
    You might come across other file encodings, but this is rare as they are generally
    considered obsolete.
  prefs: []
  type: TYPE_NORMAL
- en: What is a binary file?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Unix doesn’t differentiate between binary and text files, the way many other
    operating systems do. All files can be streamed through pipes, edited, and appended
    to. A file is just a file. When a file is set to be executable, Unix will do its
    best to execute it, either succeeding in the case of **ELF** (**Executable and
    Linkable Format**, probably the most widely used executable format today) or failing
    – for example, when trying to execute an image or audio file.
  prefs: []
  type: TYPE_NORMAL
- en: This simple mechanism opens up some amazing possibilities. For example, executables
    can be piped through a compression utility, then a network tunnel (such as SSH),
    before being decompressed and written back into a file – all in one command, without
    any temporary files.
  prefs: []
  type: TYPE_NORMAL
- en: It also means, however, that you should be careful to avoid creating a situation
    where random files, for example, ones uploaded or modified by users of a website
    (including log files!), have any possibility of being executed. This can lead
    to serious security issues.
  prefs: []
  type: TYPE_NORMAL
- en: Line endings
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: While Unix files, especially text files, function similarly to files on other
    operating systems, it is worth mentioning that Windows (and DOS), among others,
    uses a different line-ending character, which can produce errors in many programs
    that use those text files. Although this is only the case for files that were
    created on one kind of system and then copied to another (for example, moving
    a file from Linux to DOS), it’s worth knowing about.
  prefs: []
  type: TYPE_NORMAL
- en: The reasons for the different line endings are historical, and many tools (for
    example, Git and various text editors) will automatically handle that difference
    for you. However, in rare circumstances, you might have to convert files manually.
    There are famous commands like `dos2unix` to do so, but these have to be manually
    installed on most Unix-like operating systems.
  prefs: []
  type: TYPE_NORMAL
- en: There are, however, some methods to convert them using more traditional utilities.
  prefs: []
  type: TYPE_NORMAL
- en: 'Using `sed`: `sed ''s/^M$//'' original_dos_file > unix_file`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Using `tr`: `tr -d ''\r'' < original_dos_file > unix_file`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In place, using `perl`: `perl -pi -e ''s/\r\n/\n/g'' original_file`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Now that we’ve talked about the crucial basic concepts you need to know to
    understand files on Unix-like systems, let’s talk about the context that all of
    these files actually exist in: the Linux filesystem.'
  prefs: []
  type: TYPE_NORMAL
- en: The filesystem tree
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The **Filesystem Hierarchy Standard** (**FHS**) describes the conventional
    directory layout of Unix-like systems. Linux conforms to this standard, essentially
    making it “the official folder structure of Linux.” The FHS is a standardized
    tree structure where every file and directory stems from the root (a directory
    simply named “`/`"). This hierarchy is crucial: although there’s a place for end-users
    to go wild with their own directory structure, every single subdirectory inside
    of `/` (the root directory) has a specific purpose.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The basic layout of this filesystem hierarchy doesn’t take long to learn, and
    by investing a few minutes now, you’ll develop an intuition for where things go
    – whether they’re application binaries, logs, data files, or external devices
    that your code needs access to. In other words, it eases both development and
    troubleshooting: when you know where things *should* be, you spend less time confused
    and unsure of where to look during an incident. Additionally, this knowledge is
    required when it comes to writing your own scripts and doing the light system
    administration tasks expected of a senior developer.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are some of the important places in the filesystem that you’ll often see
    referenced, or have to use yourself:'
  prefs: []
  type: TYPE_NORMAL
- en: '`/etc`: System and software configuration files go here, organized into many
    subdirectories.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`/bin` and `/sbin`: System binaries go here. Don’t mess with these.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`/usr/bin` and `/usr/local/bin`: Your installed software and your own binaries
    go here, so that anyone on the system can see and execute them.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`/var/log` and `/var/lib`: `/var` contains variable data, things that are prone
    to change while the system is running, such as application logs (`/var/log`) and
    dynamic libraries (`/var/lib`), files, and other state for running applications.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`/var/lib/systemd`: One of several places on the filesystem that contain `systemd`
    configuration.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`/etc/systemd/system`: A good place for custom system unit files, if you’re
    creating services.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`/dev`: A special filesystem used to represent hardware devices.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`/proc`: A special filesystem used to query or change system state.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Basic filesystem operations
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'It’s time to dive into the foundational Unix commands you’ll use every single
    day as a developer. This set of commands will allow you to accomplish a range
    of basic command-line tasks you need to do on any system you interact with. Once
    you have learned and practiced the commands in this chapter, you’ll be able to
    do things like:'
  prefs: []
  type: TYPE_NORMAL
- en: Follow your application logs in real time.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Fix a broken configuration file to get your application working.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Move from one directory to another in a Git repository on your local macOS development
    machine.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let’s get started with listing a directory. Make sure you’re logged in to a
    Linux or Unix system (Ubuntu or macOS is fine), and have the Terminal application
    open, ready to follow along.
  prefs: []
  type: TYPE_NORMAL
- en: ls
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'List a file or directory. This command is similar to “opening a folder” in
    a graphical user interface. It lists the contents of the directory it’s given.
    By default, it uses your current directory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: In this example, my shell’s current location is the `/home/steve` directory,
    which contains a single file (`my_document.txt`).
  prefs: []
  type: TYPE_NORMAL
- en: 'You can ask `ls` to list any directory path on the system, though, by passing
    the directory as an argument:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: For a more orderly output, you may want to add the “`-l`" option. This will
    give you a “long listing,” which means a single file or directory per line, along
    with extra information.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: In short, the `ls` command is how you “look around” on a Unix filesystem.
  prefs: []
  type: TYPE_NORMAL
- en: pwd
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Short for “print working directory.” This shows “where you are” on the filesystem,
    in the context of your current shell session. If I’m logged in to a Linux system
    as the `steve` user, and I’m in my home directory, I can expect to see `pwd` print
    something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: cd
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Change the current working directory in your shell. The commands you run after
    using this command will run from the perspective of your new, changed location
    on the filesystem.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s an example directory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'If you’re sitting in the `Desktop` directory, but then change to the `documents`
    directory with `cd documents`, you’ll get a different listing from that new perspective
    when using the `ls` command. Let’s see this in action:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Now that we can see our surroundings (`ls`), move around on the filesystem (`cd`),
    and find out where we are (`pwd`), let’s get into actually affecting the filesystem
    by creating and modifying files.
  prefs: []
  type: TYPE_NORMAL
- en: touch
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This operation is written as `touch filepath`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Depending on whether the filepath you give it already exists or not, this `touch`
    command will do one of two things:'
  prefs: []
  type: TYPE_NORMAL
- en: 'If a file does not already exist at that path, `touch` will create it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'If a file *does* exist at that path, `touch` will update the access and modification
    times for that file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Notice that the only thing that’s changed is the modification time shown in
    the long listing.
  prefs: []
  type: TYPE_NORMAL
- en: less
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`less` is what’s known as a “pager” – a program that allows you to view file
    content, one screen (page) at a time:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'It’s interactive – once you’re using it to view a file, you can:'
  prefs: []
  type: TYPE_NORMAL
- en: Scroll up or down, line by line, using your mouse wheel or arrow keys.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Scroll down a whole page with **SPACE**.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Search with */* (enter your search pattern) *RETURN*.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Go to the next match: **n**.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use **q** to quit the program.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Practice using it for a minute or two, and you’ll be fine.
  prefs: []
  type: TYPE_NORMAL
- en: tail
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`tail` is used to view the last few lines of a file.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'The `-f` (follow) option for tail is very useful for live-streaming logs to
    your terminal:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Use **q** to quit out of tail.
  prefs: []
  type: TYPE_NORMAL
- en: mv
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`mv` (move) is used to move and rename files.'
  prefs: []
  type: TYPE_NORMAL
- en: Moving
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Imagine you have a file named `somefile.txt`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Provided you’re sitting in the same directory as the file, here’s how you’d
    move it to the `/var/log` directory, without renaming it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Renaming
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Now you want to rename that file to `foobar`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: That’s it!
  prefs: []
  type: TYPE_NORMAL
- en: cp
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To copy files and directories, use the `cp` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '`cp file destination` copies a file named `file` to a destination filepath,
    `destination`. The most commonly used option is `-r`, or `–recursive`; if you’re
    copying a directory, this will copy everything inside as well.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: mkdir
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Create a new, empty directory named `directoryname` with:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'A useful option is `-p`, which allows you to create nested directories in a
    single command. For example, if you want to create a `Documents` directory that
    contains a directory named `school`, which in turn contains a directory named
    `reports`, you could run the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: rm
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`rm` removes (deletes) files and directories:'
  prefs: []
  type: TYPE_NORMAL
- en: '`rm filename` deletes a file named `filename`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`rm -r directoryname` will delete a directory named `directoryname`, and every
    file and directory inside of it, recursively.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There’s a separate command for deleting empty directories named `rmdir`, but
    it’s usually only used in scripts where developers are being careful to limit
    the blast radius of an unintentional deletion.
  prefs: []
  type: TYPE_NORMAL
- en: Editing files
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Whether it’s updating configuration files, creating new Linux services, or taking
    notes during a troubleshooting session, your work on Linux is occasionally going
    to require you to edit files on the command line. We’re going to cover command-line
    file editing in detail in *Chapter 6*, *Editing Files on the Command Line*, but
    we’ll give you a very brief overview here.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you’re limited to a command-line-only environment, there are a few CLI text
    editors you might use:'
  prefs: []
  type: TYPE_NORMAL
- en: '**nano**: Almost always installed or available; easy to use'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**vi**: Installed almost everywhere; takes a bit of getting used to'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**vim**: Easy to install everywhere; more full-featured than `vi`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'If any of these are not installed, you can install them via your package manager.
    For example, if you’re using Ubuntu Linux, that’ll be a command like `sudo apt-get
    install nano` (or substitute `nano` for `vim`). We’ll dive deeper into package
    management commands in *Chapter 9*, *Managing Installed Software*. Regardless
    of which editor you choose, you’ll edit a file by simply typing `[$EDITOR filename]`
    on the command line; for example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: If the file exists, you’ll be able to edit it in your editor.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If it doesn’t, but the directory exists, you’ll create a new file at that path
    the first time you save it in the editor.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If the directory doesn’t exist, you might be able to edit the file, but the
    editor won’t be able to write it to the filesystem without a few extra steps.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the next chapter, *Chapter 6*, *Editing Files on the Command Line*, we’re
    going to dive much more deeply into the practical skills involved in file editing
    on the Linux command line. If you absolutely need to edit a file before you finish
    this chapter, just type nano `/path/to/the/file` and follow the on-screen cheatsheet
    to save and quit. In the meantime, let’s learn about the many kinds of files you’ll
    run into as a developer on Linux.
  prefs: []
  type: TYPE_NORMAL
- en: File types
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We’ve already covered “regular” files, such as plaintext files or the binary
    data in your image files and executable programs. But there are several other
    file types that you’ll need to know how to recognize and work with in Linux. Whether
    you’re looking for the USB stick or keyboard you just plugged into your machine,
    creating a link that points to a file, or inspecting the network sockets that
    a web process has opened, you’ll want to know a bit about *all* of these.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are all of the Linux file types and what they’re used for:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Regular file**: This is the most common file type, containing text or binary
    data. As a software engineer, you’ll encounter regular files in nearly every programming
    task, whether you’re writing code, editing configuration files, or executing programs.
    A typical example that you might see in a long listing could be a source code
    file like:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '**Directory**: Directories are special files that are used to organize other
    files and directories. You’re already familiar with directories if you’ve ever
    used Windows or macOS (where they’re called “folders”); they contain other files
    and directories. In a long listing, a directory like `/etc` will appear as:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '**Block special**: This special file type provides buffered access to hardware
    devices, which makes them particularly useful for devices like hard disks where
    data is accessed in large, fixed-size blocks. You’ll rarely work with these directly,
    except when mounting filesystems. An example could be a hard disk partition, shown
    as:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This represents a block device with read and write permissions for the owner
    and group.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**Character special**: Similar to block files, character files provide unbuffered,
    raw access to hardware devices, but they are designed for devices where data is
    not block-oriented, like keyboards or mice. You’ll never need to worry about these,
    although you may occasionally use them in the course of your work (for example,
    `/dev/urandom`, `/dev/null`, or `/dev/zero`). A character device like a terminal
    might appear in a long listing as:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '**FIFO special (“named pipes”)**: Named pipes, not to be confused with the
    anonymous pipes frequently used in shells, are used for interprocess communication.
    You’ll almost never have to deal with these, although you’ll be using their anonymous
    cousins to become a Unix wizard in *Chapter 11*, *Pipes and Redirection*. You
    won’t often come across these, but one example is a named pipe file, which might
    look like this:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '**Links**: Links are a kind of shortcut to another file. There are two types
    of links – hard and symbolic (soft). You’ll almost never need to deal with hard
    links, but you might use symbolic links to create convenient paths to frequently
    accessed files or to ensure multiple paths lead to the same file. We’ll cover
    these more below. A symbolic link may appear as:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This example indicates a link named `latest` that points to a file named `app-3.1`.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**Sockets**: Unix sockets are used for IPC, similar to pipe files. You might
    encounter socket files when troubleshooting services that need to talk to each
    other (“Why is nginx not able to reach my application server?”). A socket file
    – in this case a socket used by nginx and `php-fpm` to communicate so that a WordPress
    application can run – might look like this:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'This list has covered the additional, special file types you might encounter,
    and given you some intuition about how (and why) you might encounter them in the
    wild. To help you build useful practical skills, there are a few types in particular
    that we should explore in more detail. Let’s start by getting some real-world
    experience with the most common of these special file types: links.'
  prefs: []
  type: TYPE_NORMAL
- en: Symbolic links
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Symbolic links, often referred to as symlinks or soft links, are a type of file
    that serves as a reference to another file or directory. Unlike a hard link, a
    symbolic link can point to a file or directory across different filesystems, and
    it maintains a separate inode from the file or directory it references.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can create a symbolic link using this basic syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: '`ln` (lowercase L) is the “link” command.'
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, if you have a file named `file1.txt` in your current directory
    and you want to create a symlink to it named `link1`, you would use the command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, if you do a long listing of your directory with `ls -l`, you will see
    `link1` listed as a link to `file1.txt`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: When you access `link1`, for example, by printing out the file’s contents using
    `cat link1`, the system will automatically dereference the link and give you the
    contents of `file1.txt`. If `file1.txt` is moved, deleted, or renamed, the symbolic
    link will not update automatically and will be left pointing to a non-existing
    file (a broken link).
  prefs: []
  type: TYPE_NORMAL
- en: Symbolic links are particularly useful for creating shortcuts, organizing files
    and directories, and maintaining flexible and logical filesystem structures.
  prefs: []
  type: TYPE_NORMAL
- en: Hard links
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A hard link is an additional name for an existing file on the same filesystem,
    effectively acting as an alias. Both the original file and the hard link share
    the same inode, meaning changes to one are reflected in the other. Unlike symbolic
    links, hard links can’t cross filesystem boundaries or link to directories. If
    the original file is removed, the hard link will still maintain the data. To create
    a hard link named `link1` to a file named `file1.txt`, you would use the command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: The file command
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `file` command is a utility that can let you inspect the type of a file.
    The basic usage of the `file` command is simple: type `file` followed by the filename.
    For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'might output `mysecret.txt: ASCII text`, indicating that `mysecret.txt` is
    a plaintext file.'
  prefs: []
  type: TYPE_NORMAL
- en: 'If you have a binary file, like a compiled program named `mybinary`, running
    `file mybinary` might output something like `mybinary: ELF 64-bit LSB executable`,
    indicating that `program` is a binary executable file.'
  prefs: []
  type: TYPE_NORMAL
- en: 'For a directory, such as `/home/user`, running `file /home/user` will likely
    return `/home/user: directory`, signifying that `/home/user` is a directory.'
  prefs: []
  type: TYPE_NORMAL
- en: The `file` command is a powerful tool for quickly understanding the types of
    files you’re working with, especially when dealing with unknown or unfamiliar
    files.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you feel like exploring, use the `file` command to inspect the following
    files:'
  prefs: []
  type: TYPE_NORMAL
- en: '`file /bin/sh`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`file /dev/zero`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`file /dev/urandom`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`file /dev/sda1`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`file ~/.bashrc`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`file /bin/ls`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`file /home`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`file /proc/1/cwd`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Advanced file operations
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'When you’re working with files in Unix-like operating systems, you’ll often
    want to perform actions on them, with them, or with their content, but without
    directly modifying them in an editor. For example, you may want to:'
  prefs: []
  type: TYPE_NORMAL
- en: Search a file to see if it contains some content you’re looking for.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Identify a batch of files that was modified at a specific time.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Securely move a file to another system, instead of just copying it around with
    `mv` on the local machine.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You may even want to combine all three into a single action! This type of knowledge
    can really come in handy during troubleshooting (searching for a specific request
    ID or error code in a log), during development (finding recently modified source
    code files), or when you want to do some testing (copying updated application
    source code to a test system).
  prefs: []
  type: TYPE_NORMAL
- en: Here’s a quick look at these kinds of file operations, to give you an idea of
    the tools and commands you’ll use to accomplish them.
  prefs: []
  type: TYPE_NORMAL
- en: Searching file content with grep
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Text matching is traditionally done with `grep`. On your personal or work laptop,
    you may want to install `ag` or `rg`, which are more programmer-friendly and faster
    versions of this idea (for example, `sudo apt-get install silversearcher-ag`),
    but on production systems, you’ll always have `grep`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Search for the pattern `search_pattern` in the file `path/to/file`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'You can, of course, search for string literals like this, but `grep` is so
    powerful because it allows you to use regular expressions (regexes) to search
    for patterns. The following command will return lines that start with `startswith`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'And this command will return lines that end with `endswith`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: Regular expressions are tremendously useful, and every developer and Linux user
    should be familiar with the basics.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can also use `grep` to search recursively through a directory – that is,
    search through all files in all directories it contains:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: But what if you don’t want to find strings *inside* of a file – what if you
    want to find specific files themselves?
  prefs: []
  type: TYPE_NORMAL
- en: Finding files with find
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`find` can help you find files and directories by name, modification time,
    or other attributes. It’s essentially a breadth-first search of the filesystem
    tree, which is quite useful for things like:'
  prefs: []
  type: TYPE_NORMAL
- en: Finding all application log files that were created or modified in the last
    day.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Identifying all source code test files with names that end in `_test.go`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Locating all of the `php.ini` files left behind by an intern programmer so you
    can delete them.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In the following examples, `/search/path` is the part of the filesystem you
    want to search. If you want to search your current directory and all of its subdirectories,
    you can use the period character (`.`), for example, `find . -name ''file.txt''`:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Find files by extension:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Find files matching multiple path/name patterns:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Find directories matching a given name, in case-insensitive mode:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Find files matching a given pattern, excluding specific paths:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Find files matching a given size range:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Copying files between local and remote hosts with rsync
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '`rsync` is an extremely useful tool that copies files and directories between
    and across hosts. It works just like `cp`, except it works when one or both hosts
    are remote.'
  prefs: []
  type: TYPE_NORMAL
- en: '`rsync` is essentially a combination of `cp` (for copying data) and `ssh` (for
    secure, encrypted transport). If you’re unfamiliar with `ssh`, you’ll need to
    learn how it works (and set up your own SSH keys and access) before trying `rsync`
    commands.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are a few sample invocations, thanks to the `tldr` project:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Transfer a file from a local to a remote host:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Transfer a file from a remote host to the local host:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Transfer file in [`a`]rchive mode (to preserve attributes) and compressed ([`z`]ipped)
    mode with [`v`]erbose and [`h`]uman-readable [`P`]rogress:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: That last example is one I’ve used a hundred times to make quick, automated
    backups.
  prefs: []
  type: TYPE_NORMAL
- en: Combining find, grep, and rsync
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We’ll take a detailed look at combining commands with the `|` character in *Chapter
    11*, *Pipes and Redirection*, but here’s a quick preview.
  prefs: []
  type: TYPE_NORMAL
- en: 'If, for example, you want to combine the examples you just saw, for example,
    to make a backup of all files in the `/tmp` directory that were modified in the
    last week, that’s just one clever command away:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: First, we run `find`, looking for files that have a modification time of less
    than 7 days ago. We use find’s `-exec` flag to execute a `grep` command with the
    `-l` flag, which simply returns the filename of the matching file. Then, we pipe
    those filenames into the `xargs` command, which applies an action to every line
    of input that it receives from the previous command. In this case, the action
    is to run a made-up backup script on each matching file, along with a made-up
    destination path that someone might want to back this file up to.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we have the same files as in the `grep` section above, this wild-looking
    command will run two commands for you:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'It’s doing exactly what we wanted: running the backup script on ONLY the two
    files that contain the “hello world” content we care about *and* that were modified
    in the last 7 days.'
  prefs: []
  type: TYPE_NORMAL
- en: While a command like this can certainly take a few minutes (and some googling)
    to put together, it may save you hours in the long run. That’s the power of the
    command-line environment, combined with small, focused Unix tools that you can
    arrange together however you need.
  prefs: []
  type: TYPE_NORMAL
- en: You’ll learn more about Unix pipes and `xargs` in *Chapter 11*, *Pipes and Redirection*,
    but we’ve given you this example because it’s important for you to get a taste
    of how you’re going to combine all these simple commands together as you learn
    them.
  prefs: []
  type: TYPE_NORMAL
- en: Advanced filesystem knowledge for the real world
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You’ve gotten an introduction to the various Linux filetypes now, and have some
    experience working with the most common ones. Now let’s take a look at some less-common
    filesystem knowledge that will come in handy during your time working on Linux
    systems.
  prefs: []
  type: TYPE_NORMAL
- en: 'You’ll meet these when you’re:'
  prefs: []
  type: TYPE_NORMAL
- en: Troubleshooting your first Docker application that has mounted storage volumes.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Working on an application that talks to industrial controllers, cameras, or
    other external hardware.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Writing application code that needs access to randomness for securely generating
    passwords or API tokens. One of the special file types you’ll see are **block
    devices**, which are devices resembling some form of disk, where data is fetched
    and read in blocks.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Classical disk devices are block devices, and you’ll usually find them attached
    to your filesystem at these locations:'
  prefs: []
  type: TYPE_NORMAL
- en: '`/dev/hdX`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`/dev/sdX`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`/dev/nvmeN`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Where `X` and `N` are alphabetical or numerical indices of the respective disks,
    such as `/dev/sda` or `/dev/nvme0`. **Partitions** look just like disks, but with
    an additional digit or character appended, such as `/dev/sda0`, for the first
    partition on the first drive.
  prefs: []
  type: TYPE_NORMAL
- en: Note that even once the operating system detects a new hard drive and attaches
    it (and any detected partitions) in one of these locations, you’ll still have
    to intentionally “mount” the filesystem that’s on the drive, using the `mount`
    command. This isn’t a particularly common thing for developers to do, so we’ll
    leave it at that.
  prefs: []
  type: TYPE_NORMAL
- en: There are also special “**software devices**.” These range from `/dev/null`,
    which you might have seen output to be piped to in the form of `somecommand >
    /dev/null`, to `/dev/random` and `/dev/urandom`, which provide you with random
    bytes. This is where the programming language of your choice will most likely
    retrieve its cryptographically secure random numbers from.
  prefs: []
  type: TYPE_NORMAL
- en: Another directory is `/proc`, which is a filesystem popularized by the Plan
    9 operating system, but envisioned in the early days of Unix. As the name suggests,
    it was created to represent processes as files. `/proc` contains directories named
    after process IDs, which contain files that can be used to read those processes’
    state. Particularly on Linux, it has been extended with various other interfaces,
    including ways to configure kernel drivers, read hardware information and sensor
    outputs, and even interact with BIOS and UEFI.
  prefs: []
  type: TYPE_NORMAL
- en: 'FUSE: Even more fun with Unix filesystems'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'As you’ve just seen, many things can be interpreted as files in Unix. The philosophy
    is that it’s common to edit files, so commands and programming languages able
    to interact with files provide a well-understood interface. **FUSE**, short for
    **Filesystem in Userspace**, is an API that allows anyone to implement new Unix
    filesystems without having to become a kernel programmer. In other words, because
    lots of things can talk to files, it’s useful to be able to “fake” the Unix file
    API for things that aren’t the kind of normal, locally stored data that you’d
    expect a file to be. If this sounds a bit wild, check out some of the things people
    have written with FUSE. FUSE has been used to implement many classical filesystem
    drivers, for example, NTFS, so you can read your old Windows filesystems on a
    Linux machine. However, because of FUSE’s flexibility and accessibility, there
    are also some pretty wild filesystems that have been implemented this way:'
  prefs: []
  type: TYPE_NORMAL
- en: '`sshfs`, for example, allows you to locally mount a directory on another machine
    accessible via SSH.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Other FUSE filesystems allow you to mount remote cloud storage (like Amazon’s
    S3) as a local directory.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Some even more obscure ones allow you to mount Wikipedia as a directory of files,
    or to represent protocols such as IRC and services like weather APIs as filesystems.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: FUSE is so useful that it has found its way into many Unix-like operating systems
    besides Linux, and is now even available on Windows. It’s worth knowing about,
    not just because it’s a novel use of the file abstraction in Unix but because
    it can be extremely useful when you are dealing with information that’s stored
    somewhere without a classical API that your application can use at the application
    layer. Any programming language you’re likely to use has a standard library that
    lets you talk to files on a Unix filesystem, and FUSE is a way of creating that
    interface for just about any kind of information.
  prefs: []
  type: TYPE_NORMAL
- en: Conclusion
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter was an intense journey through the basics – and some of the more
    advanced bits – of files and the filesystem on Linux. You saw the difference between
    plaintext files and binary files, explored how the Linux filesystem tree is laid
    out, and learned all the basic commands you need to work with files. If you did
    it right, you also spent some time in your own Linux environment, practicing the
    important command-line file editing skills we showed you here.
  prefs: []
  type: TYPE_NORMAL
- en: After covering the basics, we jumped into the most critical intermediate and
    advanced topics that you’ll need. You saw how to find files and search them for
    content, and we also gave you a taste of special files and filesystems.
  prefs: []
  type: TYPE_NORMAL
- en: All of this together arms you with the most important skills and knowledge you
    need in order to use Linux to solve real-world problems. We hope you had fun on
    this whirlwind tour!
  prefs: []
  type: TYPE_NORMAL
- en: Learn more on Discord
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To join the Discord community for this book – where you can share feedback,
    ask questions to the author, and learn about new releases – follow the QR code
    below:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://packt.link/SecNet](https://packt.link/SecNet)'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/QR_Code1768422420210094187.png)'
  prefs: []
  type: TYPE_IMG
