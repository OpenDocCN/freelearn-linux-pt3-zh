- en: '10'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Debugging with the Yocto Project
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The debug process is an essential step in every development cycle. In this chapter,
    we will learn how to configure Poky to help us with the debugging process; for
    example, how we can configure our system to provide the tools needed for a remote
    debug using the `buildhistory`, and how we can use handy debug tools, such as
    `oe-pkgdata-util`, `bitbake-getvar`, and `devshell`.
  prefs: []
  type: TYPE_NORMAL
- en: Differentiating metadata and application debugging
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Before we delve into the details of debugging, we need to realize that there
    are different types of debugging, such as metadata and runtime code debugging.
  prefs: []
  type: TYPE_NORMAL
- en: Metadata debugging is needed to ensure that the behavior of BitBake’s tasks
    aligns with our goals and to identify the culprit when it’s not aligned. For example,
    a recipe may need to be fixed to enable a feature. In such a case, we can use
    several log files generated by BitBake in the host to help trace the execution
    path of the involved task.
  prefs: []
  type: TYPE_NORMAL
- en: On the other hand, debugging runtime code is more natural as it is essentially
    the same as the typical development cycle of an application, a library, or a kernel.
    Depending on the issue we are seeking to resolve, the right tool to help may vary
    from a debugger to code instrumentation (for example, adding debug prints).
  prefs: []
  type: TYPE_NORMAL
- en: Tracking image, package, and SDK contents
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The easiest way to ensure we have the image, packages, and `buildhistory` mechanism.
  prefs: []
  type: TYPE_NORMAL
- en: When a recipe is updated for a new version or has its code changed, it may influence
    the contents of the generated packages and, consequently, the image or SDK.
  prefs: []
  type: TYPE_NORMAL
- en: Poky deals with many recipes and images or SDKs frequently have tens or hundreds
    of packages. Therefore, it may be challenging to track the package contents. The
    Poky tool that helps in this task is `buildhistory`.
  prefs: []
  type: TYPE_NORMAL
- en: '`buildhistory`, as the name suggests, keeps a history of the contents of several
    artifacts built during the use of Poky. It tracks package, image, and SDK building
    and their contents.'
  prefs: []
  type: TYPE_NORMAL
- en: 'To enable `buildhistory` in our system, we need to add the following lines
    of code in our `build/conf/local.conf` file:'
  prefs: []
  type: TYPE_NORMAL
- en: "![Figure 10.1 – How to enable \uFEFFbuildhistory support](img/Figure_10.01_B19361.jpg)"
  prefs: []
  type: TYPE_IMG
- en: Figure 10.1 – How to enable buildhistory support
  prefs: []
  type: TYPE_NORMAL
- en: The `INHERIT` method includes the `buildhistory` class hooks in the building
    process. At the same time, the `BUILDHISTORY_COMMIT` line enables BitBake to create
    a new Git commit in the `buildhistory` repository for every new package, image,
    or SDK build. The Git commit makes tracking as simple as using `git diff` between
    two commits. The data is stored under the `build/buildhistory` directory as text
    files for ease of use.
  prefs: []
  type: TYPE_NORMAL
- en: Poky provides a utility that outputs the difference between two `buildhistory`
    states, called `buildhistory-diff`, in a more concise way, which is very useful
    when checking for changes. The `buildhistory-diff` utility outputs the difference
    between any two Git revisions more meaningfully.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, suppose we add the `strace` package in the `core-image-minimal`
    image and build it. In that case, the `buildhistory-diff` command can be used
    to check the resultant changes, as in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.2 – The result of buildhistory-diff](img/Figure_10.02_B19361.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10.2 – The result of buildhistory-diff
  prefs: []
  type: TYPE_NORMAL
- en: For every package build, `buildhistory` creates a list of generated sub-packages,
    installation scripts, a list of file ownership and sizes, the dependency relation,
    and more. In addition, the dependency relationship between the packages, filesystem
    files, and dependency graph is created for images and SDKs.
  prefs: []
  type: TYPE_NORMAL
- en: To better understand the capabilities and features provided by `buildhistory`,
    refer to *Maintaining Build Output Quality in Yocto Project Development Tasks*
    *Manual* ([https://docs.yoctoproject.org/4.0.4/dev-manual/common-tasks.html#maintaining-build-output-quality](https://docs.yoctoproject.org/4.0.4/dev-manual/common-tasks.html#maintaining-build-output-quality)).
  prefs: []
  type: TYPE_NORMAL
- en: Debugging packaging
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In more sophisticated recipes, we split the installed contents into several
    sub-packages. The sub-packages can be optional features, modules, or any other
    set of files that is optional to install.
  prefs: []
  type: TYPE_NORMAL
- en: To inspect how the recipe’s content has been split, we can use the `build/tmp/work/<arch>/<recipe
    name>/<software version>/packages-split` directory. It contains a sub-directory
    for every sub-package and has its contents in the sub-tree.
  prefs: []
  type: TYPE_NORMAL
- en: 'Among the possible reasons for a mistaken content split, we have defined the
    following:'
  prefs: []
  type: TYPE_NORMAL
- en: The contents not being installed (for example, an error in installation scripts)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An application or library configuration error (for example, a disabled feature)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Metadata errors (for example, the wrong package order)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Another common issue for build failure is lacking the required artifacts in
    the `sysroot` directory (for example, headers or dynamic libraries). The counterpart
    of the `sysroot` generation can be seen at `build/tmp/work/<arch>/<recipe_name>/<software_version>/sysroot-destdir`.
  prefs: []
  type: TYPE_NORMAL
- en: If this is not enough, we can instrument the task code with these logging functions
    to determine the logical error or bug that has caused the unexpected result.
  prefs: []
  type: TYPE_NORMAL
- en: Inspecting packages
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A central aspect of the Yocto Project is dealing with the packages. Therefore,
    the project has designed `oe-pkgdata-util` to help us to inspect the built packages
    and related data. For example, after running `bitbake bluez5`, we can use the
    following command to find all the packages related to `bluez`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.3 – Listing all the available packages and filtering those related
    with bluez](img/Figure_10.03_B19361.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10.3 – Listing all the available packages and filtering those related
    with bluez
  prefs: []
  type: TYPE_NORMAL
- en: 'Sometimes, we need to find the package that includes this specific file. We
    can inquire about the packages database using the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.4 – Finding which package provides /usr/bin/rfcomm](img/Figure_10.04_B19361.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10.4 – Finding which package provides /usr/bin/rfcomm
  prefs: []
  type: TYPE_NORMAL
- en: 'Another use case is when we need to find out the current version of a package.
    This can be done with the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.5 – Listing the package info for bluez5](img/Figure_10.05_B19361.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10.5 – Listing the package info for bluez5
  prefs: []
  type: TYPE_NORMAL
- en: 'We can also list all the files for the given package using the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.6 – Listing the files from the bluez5 package](img/Figure_10.06_B19361.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10.6 – Listing the files from the bluez5 package
  prefs: []
  type: TYPE_NORMAL
- en: The `oe-pkgdata-util` script is a handy tool to help us debug packaging.
  prefs: []
  type: TYPE_NORMAL
- en: Logging information during task execution
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The logging utilities provided by BitBake are handy for tracing the code execution
    path. BitBake provides logging functions for use in Python and Shell Script code,
    described as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`bb.fatal`, `bb.error`, `bb.warn`, `bb.note`, `bb.plain`, and `bb.debug`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`bbfatal`, `bberror`, `bbwarn`, `bbnote`, `bbplain`, and `bbdebug`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'These logging functions are very similar to each other but have minor differences,
    described as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`bb.fatal` and `bbfatal`: These have the highest priority for logging messages
    as they print the message and terminate the processing. They cause the build to
    be interrupted.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`bb.error` and `bberror`: These display an error but do not force the build
    to stop.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`bb.warn` and `bbwarn`: These warn the users about something.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`bb.note` and `bbnote`: These add a note to the user. They are only informative.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`bb.plain` and `bbplain`: These output a message.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`bb.debug` and `bbdebug`: These add debugging information that is shown depending
    on the debug level used.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There is one subtle difference between using the logging functions in Python
    and Shell Script. The logging functions in Python are directly handled by BitBake,
    seen on the console, and stored in the execution log inside `build/tmp/log/cooker/<machine>`.
    When the logging functions are used in Shell Script, the information is outputted
    to an individual task log file, which is available in `build/tmp/work/<arch>/<recipe`
    `name>/<software version>/temp`.
  prefs: []
  type: TYPE_NORMAL
- en: Inside the temp directory, we can inspect the scripts for every task with the
    `run.<task>.<pid>` pattern and use the `log.<task>.<pid>` pattern for its output.
    Symbolic links point to the last log files using the `log.<task>` pattern. For
    example, we can check for `log.do_compile` to verify whether the right files were
    used during the build process.
  prefs: []
  type: TYPE_NORMAL
- en: The `build/tmp/work` directory is detailed in [*Chapter 6*](B19361_06.xhtml#_idTextAnchor089),
    *Detailing the Temporary* *Build Directory*.
  prefs: []
  type: TYPE_NORMAL
- en: Debugging metadata variables
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To debug the metadata variables, we can use the `bitbake-getvar` script. It
    uses the BitBake internal data to get a specific variable value and its attribution
    history.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, to inspect the `PACKAGECONFIG` variable for the `procps` recipe,
    we can use the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.7 – The result of bitbake-getvar -r procps PACKAGECONFIG](img/Figure_10.07_B19361.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10.7 – The result of bitbake-getvar -r procps PACKAGECONFIG
  prefs: []
  type: TYPE_NORMAL
- en: From *Figure 10**.7*, we can see that `PACKAGECONFIG` at the end is empty. We
    can also see that `defaultval` was set to `"${@bb.utils.filter('DISTRO_FEATURES',
    'systemd', d)}"` at line 33 from the `meta/recipes-extended/procps/procps_3.3.17.bb`
    file.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can see the `procps` recipe lines 33 and 34 in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.8 - The procps recipe 33 and 34 lines](img/Figure_10.08_B19361.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10.8 - The procps recipe 33 and 34 lines
  prefs: []
  type: TYPE_NORMAL
- en: The `bitbake-getvar` script can be used to check whether a feature is enabled
    or to be sure a variable has been expanded as we expect.
  prefs: []
  type: TYPE_NORMAL
- en: Utilizing a development shell
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A development shell can be a helpful tool when editing packages or debugging
    build failures. The following steps take place when we use `devshell`:'
  prefs: []
  type: TYPE_NORMAL
- en: Source files are extracted into the working directory.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Patches are applied.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A new terminal is opened in the working directory.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: All the environment variables needed for the build are available in the new
    terminal, so we can use commands such as `configure` and `make`. The commands
    execute just as if the build system were running them.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following command is an example that uses `devshell` on a target named
    `linux-yocto`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.9 – Running devshell for the linux-yocto recipe](img/Figure_10.09_B19361.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10.9 – Running devshell for the linux-yocto recipe
  prefs: []
  type: TYPE_NORMAL
- en: 'The command from *Figure 10**.9* allows us to rework the Linux kernel source
    code, build it, and change its code as needed. In *Figure 10**.10*, you can see
    the log after executing the `bitbake linux-yocto -c` `devshell` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.10 – The log for bitbake linux-yocto -c devshell](img/Figure_10.10_B19361.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10.10 – The log for bitbake linux-yocto -c devshell
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: It is crucial to remember that changes made inside `devshell` do not persist
    between builds; thus, we must be careful to record any critical change before
    leaving it.
  prefs: []
  type: TYPE_NORMAL
- en: Since we have the source at our disposal, we can use it to generate extra patches.
    A convenient way of doing that is using Git and `git format-patch` to create the
    patch to be included in the recipe afterward.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following screenshot shows the `devshell` window open after calling the
    `devshell` task:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.11 – The list of files inside the WORKDIR directory](img/Figure_10.11_B19361.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10.11 – The list of files inside the WORKDIR directory
  prefs: []
  type: TYPE_NORMAL
- en: The `devshell` command is convenient for small tasks. But when a more involved
    change is needed, using an external toolchain or `devtool` might be a better option.
  prefs: []
  type: TYPE_NORMAL
- en: To include the generated patch in the recipe and make it persistent, see [*Chapter
    13*](B19361_13.xhtml#_idTextAnchor158), *Customizing* *Existing Recipes*.
  prefs: []
  type: TYPE_NORMAL
- en: Using the GNU Debugger for debugging
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: While developing any project, from time to time, we end up struggling to understand
    subtle bugs. The GDB is available as a package in Poky. It is installed in SDK
    images by default, as was detailed in [*Chapter 9*](B19361_09.xhtml#_idTextAnchor115),
    *Developing with the* *Yocto Project*.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: To install debugging packages containing the debug symbols and tools in an image,
    add `IMAGE_FEATURES += "dbg-pkgs tools-debug"` in `build/conf/local.conf`.
  prefs: []
  type: TYPE_NORMAL
- en: Using the SDK or an image with the debugging packages and tools installed allows
    us to debug applications directly in the target, replicating the same development
    workflow we usually do on our machine.
  prefs: []
  type: TYPE_NORMAL
- en: The GDB may not be usable on some targets because of memory or disk space constraints.
    The main reason for this limitation is that the GDB needs to load the debugging
    information and the binaries of the debugging process before starting the debugging
    process.
  prefs: []
  type: TYPE_NORMAL
- en: To overcome these constraints, we can use `gdbserver`, included by default when
    using `tools-debug` in `IMAGE_FEATURES`. It runs on the target and doesn’t load
    any debugging information from the debugged process. Instead, a GDB instance processes
    the debugging information on the build host. The host GDB sends control commands
    to `gdbserver` to control the debugged application, so the target does not need
    to have the debugging symbols installed.
  prefs: []
  type: TYPE_NORMAL
- en: However, we must ensure the host can access the binaries with their debugging
    information. Therefore, it is recommended that the target binaries are compiled
    with no optimization to facilitate the debugging process.
  prefs: []
  type: TYPE_NORMAL
- en: The process for using `gdbserver` and adequately configuring the host and target
    is detailed in the *Debugging With the GNU Project Debugger (GDB) Remotely section
    in Yocto Project Development Tasks* *Manual* ([https://docs.yoctoproject.org/4.0.4/dev-manual/common-tasks.html#debugging-with-the-gnu-project-debugger-gdb-remotely](https://docs.yoctoproject.org/4.0.4/dev-manual/common-tasks.html#debugging-with-the-gnu-project-debugger-gdb-remotely)).
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we learned how to configure Poky to help us with the debugging
    process. We learned about the contents of deployed directories that can be used
    for debugging and how we can track our changes using `buildhistory`. We also covered
    the use of `oe-pkgdata-util` to inspect package information, use `bitbake-getvar`
    to debug variable expansion, how we can use `devshell` to emulate the same build
    environment found by BitBake, and how we configure our system to provide the tools
    needed for GDB debugging.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will learn how to expand the Poky source code using
    external layers. First, we will introduce the concept of layering. Then, we will
    learn in detail about the directory structure and the content of each layer type.
  prefs: []
  type: TYPE_NORMAL
