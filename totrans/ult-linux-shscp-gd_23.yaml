- en: '23'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Using PowerShell on Linux
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**PowerShell** started its life as a closed-source, proprietary product that
    could only be installed on Windows operating systems. Now though, it’s Free Open
    Source Software, and is freely available for use on Linux-based and macOS-based
    machines.'
  prefs: []
  type: TYPE_NORMAL
- en: I can’t give you a complete course on PowerShell in this chapter, because it’s
    something that would require an entire book. Instead, I’ll just give you a high-level
    overview of the PowerShell philosophy, show you how to install it, and provide
    some useful examples. I’ll also provide some rationale on why you, as a Linux
    or Mac administrator, might like to learn PowerShell. And of course, you’ll find
    plenty of PowerShell reference material links both throughout the chapter and
    in the *Further Reading* section.
  prefs: []
  type: TYPE_NORMAL
- en: 'Topics in this chapter include:'
  prefs: []
  type: TYPE_NORMAL
- en: Installing PowerShell on Linux and macOS
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Reasons for Linux and Mac Admins to Learn PowerShell
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Differences Between PowerShell Scripting and Traditional Linux/Unix Scripting
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Viewing the Available PowerShell Commands
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Getting Help with PowerShell Commands
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Real-World Cross-Platform PowerShell Scripts
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If you’re ready, let’s get started.
  prefs: []
  type: TYPE_NORMAL
- en: Technical Requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You can use a Fedora, Ubuntu, or Debian virtual machine for this. You won’t
    be using your FreeBSD or OpenIndiana virtual machines, because PowerShell isn’t
    available for them.
  prefs: []
  type: TYPE_NORMAL
- en: 'As always, you can grab the scripts by doing:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Installing PowerShell on Linux and macOS
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We’ll first look at the methods for installing PowerShell on Linux, and then
    look at how to install it on macOS.
  prefs: []
  type: TYPE_NORMAL
- en: Installing PowerShell on Linux via a snap Package
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `snapd` system is a universal software packaging system that was invented
    by the developers of Ubuntu. It comes installed by default on Ubuntu operating
    systems, and can be installed on most other Linux distros.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you’re setting up a new Ubuntu Server, you can choose to install a selection
    of snap packages, including PowerShell, from the Ubuntu installer. Here’s what
    that looks like:'
  prefs: []
  type: TYPE_NORMAL
- en: '![B21693_23_1](img/B21693_23_01.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 23.1: Selecting the PowerShell snap package during Ubuntu installation'
  prefs: []
  type: TYPE_NORMAL
- en: 'You can install `snapd` on non-Ubuntu distros, but the installation instructions
    vary for different distros. You can find the installation instructions here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://snapcraft.io/docs/installing-snapd](https://snapcraft.io/docs/installing-snapd)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Once you’ve installed `snapd`, you can install PowerShell by doing:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Installing PowerShell on Fedora
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'On a Fedora system, you can use any of several methods for installing PowerShell.
    For example, you can install it either via a `.rpm` package, or via a Docker container.
    You’ll find detailed instructions for each of these methods, along with a few
    more, here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://fedoramagazine.org/install-powershell-on-fedora-linux/](https://fedoramagazine.org/install-powershell-on-fedora-linux/)'
  prefs: []
  type: TYPE_NORMAL
- en: Installing PowerShell on macOS
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'You can install PowerShell on a Mac via the Homebrew system. You’ll find detailed
    instructions for that here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://learn.microsoft.com/en-us/powershell/scripting/install/installing-powershell-on-macos?view=powershell-7.4](https://learn.microsoft.com/en-us/powershell/scripting/install/installing-powershell-on-macos?view=powershell-7.4)'
  prefs: []
  type: TYPE_NORMAL
- en: Invoking PowerShell
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Once PowerShell is installed, invoke it by entering the `pwsh` command. Your
    command-prompt will then look something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Now, before I show you any demos, let’s address the burning question of the
    day. Why should a Linux or Mac person such as yourself learn a scripting language
    that was invented at Microsoft?
  prefs: []
  type: TYPE_NORMAL
- en: Reasons for Linux and Mac Admins to Learn PowerShell
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Scripting in PowerShell is a somewhat different experience from scripting in
    the traditional Linux and Unix shells. But, it’s not hard, and you might even
    like it once you get used to it. At any rate, there are some valid reasons why
    a Linux administrator might like to learn PowerShell. Let’s take a look at some
    of those reasons.
  prefs: []
  type: TYPE_NORMAL
- en: Working with Mixed Operating System Environments
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The first reason is simply one of both convenience and flexibility. A lot of
    enterprises and organizations run a mixed bag of Linux and Windows servers, and
    usually run Windows on their workstations. It might be helpful if you could run
    one common scripting language across your Windows and Linux platforms. And, if
    you’re a Windows administrator who now needs to learn Linux administration, you
    might find it easier to do it with PowerShell, which you’ll likely already know.
    In fact, let me tell you a story about my own reason for learning PowerShell.
  prefs: []
  type: TYPE_NORMAL
- en: Throughout the years 2010 and 2011, I worked with a client who had taken on
    the Nagios company as one of his clients. The Nagios company produces the Nagios
    network monitoring system, which can monitor pretty much every type of network
    device. (This includes servers that run either Linux or Windows, as well as various
    types of networking equipment.) My client’s job was threefold. He was to produce
    training documentation, conduct Nagios training classes, and fly around the country
    to set up Nagios monitoring systems for clients of the Nagios company.
  prefs: []
  type: TYPE_NORMAL
- en: Anyway, every time my client needed to do anything with Windows servers, he
    would turn to me, because I knew Windows Server and he didn’t.
  prefs: []
  type: TYPE_NORMAL
- en: Okay, I’ve been guarding a dark secret, and I hope you won’t think badly of
    me. It’s just that back in 2006, before I got involved with Linux, I obtained
    my Microsoft Certified Systems Engineer (MCSE) certification for Windows Server
    2003\. When I first got into Linux, I thought that I would never use my MSCE training.
    Boy, was I wrong.
  prefs: []
  type: TYPE_NORMAL
- en: Unfortunately, my MCSE training didn’t include anything about PowerShell, because
    it hadn’t yet been invented. So, in order to come up with Windows Server monitoring
    solutions for my client, I had to give myself a crash course on PowerShell scripting.
  prefs: []
  type: TYPE_NORMAL
- en: The bottom line here is that if you’re involved with setting up any kind of
    network monitoring solution, even if you’re a Linux admin, learning PowerShell
    could be useful.
  prefs: []
  type: TYPE_NORMAL
- en: PowerShell Commands Can Be Simpler
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The second reason is that in some cases, PowerShell is just easier to deal
    with. You’ve seen how in the traditional Linux/Unix shell languages, commands
    to perform a certain task can become quite long and convoluted. For example, let’s
    say that you want to view all of the system processes that are using 200 Megabytes
    or more of the machine’s Random Access Memory (RAM), and you want to see only
    certain fields of the output. The traditional Linux/Unix way of doing this would
    involve using the `ps` command with the proper option switches, and then piping
    the `ps` output into `awk`, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'So, what’s the problem with this? Well first, you need to be familiar with
    the `ps` option switches, as well as with the various `ps` output fields. In this
    case, the `ps -e` command shows us something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'But, that doesn’t show the `RSS` field, which contains the memory use data
    that we want to see. So, I’ll add the `O rss` option, so that the final `ps` command
    will be `ps -eO rss`. It should now show something that looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: The problem now is that that’s more than we want to see. Piping this output
    into `awk` will filter out all of the unwanted stuff. But, to use `awk`, you’ll
    need to know what’s in every field of the `ps` output, so that you’ll know what
    fields to list in the `awk` command. In this case, we want to see the `PID`, `RSS`,
    and `COMMAND` fields, which are fields 1, 2, and 6\. We want to see all processes
    for which field 2 has a number that’s greater than 200 Megabytes, which we’re
    expressing here as `(1024*200)`.
  prefs: []
  type: TYPE_NORMAL
- en: Remember that the true definition of a Megabytes is 1024 Kilobytes. Since `awk`
    doesn’t understand measurements in Bytes, Kilobytes, Megabytes, and so forth,
    you’ll have to express your memory measurements as either a math formula or a
    normal integer. (The integer product of 1024*200 is 204800.)
  prefs: []
  type: TYPE_NORMAL
- en: Finally, the `printf` command will print out just the fields that we want to
    see, with the proper formatting options.
  prefs: []
  type: TYPE_NORMAL
- en: Okay, that’s doable. But, can we simplify that with PowerShell? Let’s see.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Yeah, I’m thinking that that’s a lot easier. It’s a lot shorter, which will
    make it less prone to error. The only field name you need to know is the `WorkingSet
    (WS)` field, which is equivalent to the `RSS` field in `ps`. Also, you see that
    we can pipe the output of one command (`Get-Process`) into another command (`Where-Object`),
    similarly to how we pipe the output of a Linux/Unix utility into another one.
    The best part is that this command is so intuitive, that I think you can figure
    out what it’s doing without me even explaining it.
  prefs: []
  type: TYPE_NORMAL
- en: All right, let’s move on to the next reason for learning PowerShell.
  prefs: []
  type: TYPE_NORMAL
- en: Enhanced Builtin Math Capabilities
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If you need to create scripts that are heavy on math, PowerShell might be just
    what you need. You can do floating point math without loading any external program,
    and a function library is available for advanced math functions. Let’s look at
    some examples.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, let’s do a simple division operation, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'As you see, PowerShell does floating point math by default, without having
    to invoke any special tricks. Now, let’s put some different math problems into
    the `math1.ps1` script, which looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: The first thing to note here is the `param` line at the top. This is the directive
    that creates the positional parameters that I’ll use to pass arguments into the
    script. Instead of using `$1` and `$2` as positional parameters, I’m using `param`
    to create the `$number1` and `$number2` positional parameters. Note how I need
    to create both positional parameters with just one `param` directive. If I use
    two separate `param` lines, the script will error out, because it won’t recognize
    the second `param` line. Also, I’ve specified that the `number1` and `number2`
    variables that I’m using for the positional parameters will be of the floating
    point number type.
  prefs: []
  type: TYPE_NORMAL
- en: 'The rest of the script is a straightforward demonstration of how to do addition,
    division, multiplication, and modulo operations. Instead of using `echo` or `printf`
    statements, I’m using PowerShell’s native `Write-Host` command. Also, note how
    variable names will always be preceded by a `$`, whether you’re defining them
    or calling back their values. Now, let’s run the script with 5 and 2 as our arguments:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Easy enough, right? Well, doing more advanced math in PowerShell is just as
    easy. To demonstrate, let’s create the `math2.ps1` script, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Here, you see how I’m using the `[math]::` construct to call in the functions
    that calculate the tangent, cosine, square root, and logarithm of my specified
    number. The only slight catch is that the tangent and cosine functions work with
    radians by default. To make it work with degrees, I had to divide the number of
    degrees that I input by 180, and then multiply that by the value of pi (π).
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let’s run this with 45 as my argument:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Oh yeah, looking good.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can read more about PowerShell math, including a more complete list of
    its math functions, here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://ss64.com/ps/syntax-math.html](https://ss64.com/ps/syntax-math.html)'
  prefs: []
  type: TYPE_NORMAL
- en: Next, let’s look at some fundamental differences between PowerShell and the
    more traditional shells.
  prefs: []
  type: TYPE_NORMAL
- en: Differences Between PowerShell Scripting and Traditional Linux/Unix Scripting
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: PowerShell still uses many of the same programming constructs as other scripting
    languages use, such as functions, loops, `if` constructs, and so forth. But, as
    you’ve already seen there are also some differences in the basic design of PowerShell
    that set it apart from traditional Linux/Unix shell scripting. Let’s look at a
    few examples.
  prefs: []
  type: TYPE_NORMAL
- en: Using Filename Extensions and the Executable Permission
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Throughout this book, you’ve seen me create normal Linux/Unix scripts with the
    `.sh` extensions on their filenames. In reality, you don’t have to use any filename
    extension on normal Linux/Unix scripts. This means that the `somescript.sh` script
    would work just as well if the its filename were just `somescript`. With PowerShell,
    the `.ps1` filename extension is mandatory for all PowerShell scripts. Without
    it, your PowerShell script just won’t run.
  prefs: []
  type: TYPE_NORMAL
- en: On the other hand, it’s not necessary to set the executable permission on PowerShell
    scripts, as it is for traditional Linux/Unix scripts. As long as the script file
    has `.ps1` at the end of its filename, and as long as you’re in the PowerShell
    environment, the script will run.
  prefs: []
  type: TYPE_NORMAL
- en: PowerShell is Object-oriented
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The traditional Linux and Unix shell scripting languages are strictly **procedural
    languages**. This means that the commands in the program or script that you create
    will work on data from some external source.
  prefs: []
  type: TYPE_NORMAL
- en: That source could be the keyboard, a file, a database, or even a *here* document
    that’s embedded within the script or program. Understand that the data and the
    commands that work on them are completely separate entities.
  prefs: []
  type: TYPE_NORMAL
- en: With **object-oriented programming**, which you’ll sometimes see referred to
    as **OOP**, the data and the procedures that operate on the data are packaged
    together in an **object**. This allows you to do cool things, like telling a numerical
    object to double itself. It also allows you to create other objects that inherit
    characteristics from their parent objects.
  prefs: []
  type: TYPE_NORMAL
- en: I know that this is a simplified explanation of object-oriented programming.
    But, a detailed explanation is way beyond the scope of this book. Of course, if
    you’ve ever programmed in languages like C++ or Java, you’ll know what I’m talking
    about.
  prefs: []
  type: TYPE_NORMAL
- en: PowerShell Uses Cmdlets
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Most PowerShell commands are actually referred to as **Cmdlets**, which you’ll
    pronounce as *command-lets*, while others are either aliases or functions. Each
    Cmdlet takes the form of a verb and a noun separated by a hyphen, such as `Get-Content`,
    which gets (reads) from a file, or `Set-Content`, which writes to a file. The
    way this works on Windows machines is that every Windows subsystem has its own
    set of Cmdlets. For example, a Windows machine that acts as a **Domain Name System**
    (**DNS**) server would have a set of Cmdlets to work with DNS, and a **Microsoft
    Exchange** server would have Cmdlets for working with Exchange.
  prefs: []
  type: TYPE_NORMAL
- en: The Linux and Mac versions of PowerShell have far fewer sets of Cmdlets, because
    all of the Windows-specific stuff has been stripped out. You’ll find what you
    need to work with Linux or macOS, but nothing else.
  prefs: []
  type: TYPE_NORMAL
- en: As you see, these Cmdlets are a lot different from the commands that Linux/Unix
    admins are used to using. For that reason, you might consider using aliases to
    help ease the transition to PowerShell. Let’s check that out next.
  prefs: []
  type: TYPE_NORMAL
- en: Using Aliases on PowerShell
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'On Windows machines, PowerShell has aliases already set up that allow you to
    use Linux/Unix commands in place of PowerShell commands. (Microsoft did this on
    purpose to make it easier for Linux/Unix admins to learn PowerShell.) For example,
    here’s how to list files in your current directory on PowerShell for Linux:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'You see that the `Get-ChildItem` command does pretty much the same job as an
    `ls -l` command. On a Windows machine, there will already be a PowerShell alias
    that allows you to use the `ls` command to run the `Get-ChildItem` command. Here’s
    how that looks on one of my Windows machines:'
  prefs: []
  type: TYPE_NORMAL
- en: '![B21693_23_2](img/B21693_23_02.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 23.2: Using the ls PowerShell alias on Windows'
  prefs: []
  type: TYPE_NORMAL
- en: 'So yeah, this looks just like the `Get-ChildItem` command. But, if you open
    a PowerShell session on Linux or Mac and run the `ls` command, you won’t invoke
    the alias, because no aliases are set up by default. Instead, you’ll invoke the
    actual `ls` command from your Linux or Mac operating system. Here’s how that looks:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: You see that this looks nothing like `Get-ChildItem`. In fact, it’s just the
    normal output from your normal `ls` command.
  prefs: []
  type: TYPE_NORMAL
- en: 'Fortunately though, you can create your own aliases on PowerShell, which can
    make typing PowerShell commands much easier. You can create aliases with either
    the `Set-Alias` or the `New-Alias` Cmdlets. Let’s first create the alias that
    will make `ls` run the `Get-ChildItem` command, using `Set-Alias`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'The other way is to use `New-Alias`, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Either way works equally well, but it’s only a temporary fix. Once you close
    your PowerShell session, you’ll lose the alias. To make your aliases permanent,
    you’ll need to edit your PowerShell profile file. You can find where it’s supposed
    to be by doing:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: The only problem is that the `.config/` directory is there, but neither the
    `powershell/` subdirectory nor the `Microsoft.PowerShell_profile.ps1` file is.
    So, you’ll need to create them.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can just use your normal Linux/Mac command to create the `powershell/`
    subdirectory, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, use your favorite text editor to create the `Microsoft.PowerShell_profile.ps1`
    file within that new `powershell/` subdirectory. Add this line to create the `ls`
    to `Get-ChildItem` alias:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: You can add as many aliases to this file as you like. Just remember to log out
    of your PowerShell session, and then log back in to ensure that the new profile
    takes effect.
  prefs: []
  type: TYPE_NORMAL
- en: '**Important**: If you intend to create PowerShell scripts that will run on
    multiple machines, be aware that the aliases that you’ve created might not be
    available on some of them. Your best bet in that case will be to forget about
    using your own aliases, and just use the native PowerShell commands.'
  prefs: []
  type: TYPE_NORMAL
- en: Next, let’s see how to view the available PowerShell Commands.
  prefs: []
  type: TYPE_NORMAL
- en: Viewing the Available PowerShell Commands
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To see what commands are available to you, just do:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Under `CommandType`, you see that we have aliases, functions, and Cmdlets. Under
    the `Source` column, you see the letter `M`, which means that these commands are
    all stored in some PowerShell module.
  prefs: []
  type: TYPE_NORMAL
- en: 'Of course, there aren’t nearly as many PowerShell commands for Linux as there
    are for Windows. To see how many there are, just do this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Here, we begin by piping the output of the `Get-Command` Cmdlet into the `Measure-Object`
    Cmdlet. The official explanation of `Measure-Object`, according to the help file,
    is that it calculates the property values of certain types of objects. In this
    case, we only want to see one of those calculations, which shows us how many commands
    there are. We’ll do that by piping the `Measure-Object` output into `Select-Object
    -Property Count`, which works the same as the Linux/Unix `wc -l` command. After
    all that, we see that there are 293 PowerShell commands available on this Linux
    machine.
  prefs: []
  type: TYPE_NORMAL
- en: 'As I’ve mentioned a few pages back in the *PowerShell Uses Cmdlets* section,
    all Cmdlets are in the *Verb-Noun* format. You can use `Get-Command` with either
    the `-Verb` or `-Noun` options to see all of the commands for a particular verb
    or noun. For example, let’s see all of the available commands for the `Date` noun:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'We see that there are only two Cmdlets for `Date`. Let’s see how many there
    are for the `Set` verb:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Now, you’re wondering how to find out what all of these PowerShell commands
    do. Well, let’s look at that next.
  prefs: []
  type: TYPE_NORMAL
- en: Getting Help with PowerShell Commands
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This one is easy. Just use the `Get-Help` Cmdlet, followed by the name of the
    command for which you need information. For example, you can see information about
    the `Get-Module` Cmdlet like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: What you’ll see will resemble a normal Linux/Unix man page.
  prefs: []
  type: TYPE_NORMAL
- en: 'At the bottom of every `Get-Help` screen, you’ll see commands that will show
    you how to see even more information. For example, if you need to see examples
    of how to use the `Get-Module` Cmdlet, do this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Sometimes, the help page for the command that you need to learn about isn’t
    available. In those cases, either run the `Update-Help` Cmdlet, or append the
    `-Online` option to the end of your `Get-Help` command.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another great resource is the PowerShell Commands page, which you can find
    here: [https://ss64.com/ps/](https://ss64.com/ps/)'
  prefs: []
  type: TYPE_NORMAL
- en: (Of course, a lot of the listed commands are Windows-specific, but you’ll also
    find quite a few that are cross-platform.)
  prefs: []
  type: TYPE_NORMAL
- en: Okay, I think that this does it for the PowerShell theory. Let’s look at a couple
    of real-world examples of PowerShell scripts.
  prefs: []
  type: TYPE_NORMAL
- en: Real-World Cross-Platform PowerShell Scripts
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To come up with some real-world examples of cross-platform PowerShell scripts,
    I did a DuckDuckGo search for the *PowerShell script examples Linux* text string.
    The coolest thing I found is the *Mega Collection of PowerShell Scripts* on Github.
    You can use `git` to download it by doing:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: Once it’s downloaded, `cd` into the `PowerShell/scripts/` directory, and take
    a look at what’s there. For our first example, let’s look at something simple
    that will run on all platforms.
  prefs: []
  type: TYPE_NORMAL
- en: The write-marquee.ps1 Script
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `write-marquee.ps1` script is truly cross-platform, because it doesn’t use
    any commands that are specific to any particular operating system. All it does
    is create a marquee message that flows across on your screen. I can’t show the
    entire script here, but you can look at your own local copy. So, let’s just look
    at the individual parts of it to see how it’s set up.
  prefs: []
  type: TYPE_NORMAL
- en: 'At the top, you see the comment section, which is surrounded by `<#` and `#>`.
    Actually, these are more than just comments. If you do `Get-Help ./write-marquee.ps1`,
    you’ll see that everything that’s within the `<#` and the `#>` will come up as
    a help screen, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, the `param([string]$Text =` line creates the string-type variable that
    contains the marquee message. It looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'The `[int]$Speed = 60) # 60 ms pause` part at the end of the variable definition
    determines the speed at which the marquee message will flow across the screen.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Next up is the `StartMarquee` function, which looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![B21693_23_3](img/B21693_23_03.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 23.3: The StartMarquee function'
  prefs: []
  type: TYPE_NORMAL
- en: After drawing the marquee box and using `$LinePos` lines to ensure that everything
    gets properly positioned, you see the `foreach` loop that prints the message out
    to the screen, one letter at a time.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, after the function definition, you see the function call:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'The function call passes the `$Text` variable, which contains the marquee message,
    into the `StartMarquee` function. In between each iteration of the `$Text` message,
    there will be three plus signs (`+++`). The script will keep running until it’s
    gone through all iterations of the `$Text` message. Anyway, here’s how it looks
    when I run it on my Ubuntu Server virtual machine:'
  prefs: []
  type: TYPE_NORMAL
- en: '![B21693_23_4](img/B21693_23_04.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 23.4: Running the write-marquee.ps1 script'
  prefs: []
  type: TYPE_NORMAL
- en: Pretty cool, eh? Now, let’s look at something that’s even more cool.
  prefs: []
  type: TYPE_NORMAL
- en: The check-cpu.ps1 Script
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `check-cpu.ps1` script attempts to retrieve the model number and name of
    your machine’s CPU, along with the CPU temperature.
  prefs: []
  type: TYPE_NORMAL
- en: If you want to see the CPU temperature, you’ll need to run this directly on
    a host Linux machine, instead of in a virtual machine. Running this in a virtual
    machine won’t allow the script to access the host machine’s temperature sensors.
  prefs: []
  type: TYPE_NORMAL
- en: 'I say *attempt*, because when I run this script on my Fedora workstation, I
    get this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'So, all it shows me is that I’m running some sort of 64-bit CPU with 16 cores.
    The actual truth is that this machine is running an Intel(R) Xeon(R) CPU E5-2670,
    with eight cores and hyperthreading enabled. But, if I run this same script on
    a Windows 10 machine, I’ll get this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![B21693_23_5](img/B21693_23_05.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 23.5: The check-cpu.ps1 script on a Windows machine'
  prefs: []
  type: TYPE_NORMAL
- en: On this ancient (circa 2008) Dell that’s running Windows 10 Pro, the script
    properly reports that the CPU is an old-school Core 2 Quad, model number Q9550\.
    On the other hand, the script properly reported the CPU temperature on the Linux
    machine, but not on the Windows machine. That part is easy to explain. It’s just
    that some computer motherboards, especially older ones, have temperature sensors
    that aren’t compatible with modern operating systems.
  prefs: []
  type: TYPE_NORMAL
- en: As far as getting the CPU model right, it seems that the PowerShell command
    for Linux can’t do that, but the command for Windows can. Let’s take a look at
    the script to see what’s going on with that.
  prefs: []
  type: TYPE_NORMAL
- en: 'Toward the top of the `check-cpu.ps1` script, you see the `GetCPUArchitecture`
    function, which looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'As you see, there’s a bit of difference in the syntax from what you’re used
    to in normal Linux/Unix scripting. One difference is that instead of surrounding
    a test condition with square brackets, PowerShell uses parentheses. Like this,
    for example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: All this line does is to return the value of the `PROCESSOR_ARCHITECTURE` environmental
    variable, if one exists. The rest of this function is specifically for Linux,
    as evidenced by the `if (IsLinux)` stanza. You see here that it detects whether
    the CPU is x86, x86_64, or ARM. For ARM, it detects whether it’s a 32-bit or 64-bit
    version.
  prefs: []
  type: TYPE_NORMAL
- en: 'The only part of this function that Windows uses is the first line, which is
    the `if ("$env:PROCESSOR_ARCHITECTURE" -ne "") { return "$env:PROCESSOR_ARCHITECTURE"
    }` line. And, the only thing that this does on my Windows 10 machine is to insert
    the “AMD64” string into the information that you see in the above graphic. On
    Windows, all other CPU information is obtained from the **Windows Management Instrumentation**
    (**WMI**) interface. The code for that is in the `else` clause of the `try` stanza,
    which begins on line 44\. (The `else` clause begins on line 54.) Here’s how it
    looks:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: You see in the `if..else` construct that if the machine is running Linux, it
    will call the `GetCPUArchitecture` function, and retrieve the CPU information
    from it. In the `else` section, you see the code for Windows. Although the script
    does obtain one piece of information for Windows from the `PROCESSOR_ARCHITECTURE`
    environmental variable, it obtains most of the CPU information from the **Windows
    Management Instrumentation** (**WMI**) subsystem. As it happens, the `PROCESSOR_ARCHITECTURE`
    variable doesn’t contain any information for this particular Fedora workstation.
    So, all I get on this machine is just the generic message about whether I’m running
    a 32-bit or 64-bit machine, and whether it’s an x86 or an ARM machine. That’s
    okay though, because I can modify the script to fix that.
  prefs: []
  type: TYPE_NORMAL
- en: 'Open the `check-cpu.ps1` script in your editor, and scroll down until you see
    this line in the `try` stanza, which should be line 47:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'We’re going to leave that line alone, because Windows also uses the `GetCPUArchitecture`
    function. Instead, we’re going to add the following line after the `if ($IsLinux)
    {` line, which is line 48:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: Instead of obtaining its value from the `GetCPUArchitecture` function, the `arch`
    variable now gets its value from a command substitution construct.
  prefs: []
  type: TYPE_NORMAL
- en: We see here a couple of other ways in which PowerShell scripting is different.
  prefs: []
  type: TYPE_NORMAL
- en: First, anytime you work with a PowerShell variable, you need to precede the
    variable name with a `$`. This means that whether you’re defining a variable or
    calling back its value, you need that `$`. Secondly, you see that in PowerShell,
    you don’t surround the command substitution construct with `$( )`. Instead, just
    write the command as you normally would.
  prefs: []
  type: TYPE_NORMAL
- en: Okay, let’s break this line down.
  prefs: []
  type: TYPE_NORMAL
- en: '`Get-Content`: This does the same job as the Linux/Unix `cat` command.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Select-String`: This does the same job as the Linux/Unix `grep` command.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Select-Object -Unique`: This does the same job as the Linux/Unix `uniq` command.
    We need it here because my machine has 16 virtual cores, and I only want to see
    the information for one of them.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Running the modified script on my Fedora workstation looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'That’s much better, but it’s not quite perfect. I really want to get rid of
    the “model name” text string at the start of the output. So, let’s make one more
    slight edit to the script, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'All I did here was to change the `$arch` to `$longarch` in the original `$arch`
    line. I’ll use that as my intermediate variable. Then, I added a new `$arch` line
    that uses the `-replace "model name\t: ", ""` command to delete the “model name”
    string, along with the following tab character, colon, and blank space. In this
    case, the `-replace` command is doing the same job as the Linux/Unix `sed` command.
    To put this into context, here’s how the relevant portion of the modified `try`
    stanza now looks:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'Here’s what running the new script looks like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: Perfect. This is exactly what I want to see, other than the fact that my workstation
    is running a bit hot for some reason. (Tomorrow, I’ll open it up to see if I need
    to blow out any dust bunnies.) The best part is that this is still a cross-platform
    script, because I didn’t do anything that would affect how it runs on Windows.
  prefs: []
  type: TYPE_NORMAL
- en: Okay, I think that does it for our introduction to the mysteries of PowerShell.
    Let’s summarize and then wrap things up.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this final chapter, I’ve shown you a bit about scripting in PowerShell on
    a Linux machine. I started by showing you a bit of history, and then showed you
    the philosophy of scripting on PowerShell and how it differs from scripting in
    traditional Linux/Unix shells. You also saw the basics about how to use PowerShell
    commands, and how to obtain help for the commands. Finally, I showed you some
    real world examples of actual PowerShell scripts that work on either Windows or
    Linux. But, as I’ve said before, all I can do in just one chapter is to present
    a high-level overview of PowerShell scripting. If you need to learn more about
    it, there are plenty of resources both on-line and in books.
  prefs: []
  type: TYPE_NORMAL
- en: Oh, I almost forgot the most important thing. I also showed you some reasons
    about why you, as a Linux or Mac administrator, might want to consider scripting
    in PowerShell. Yeah, it’s different and takes a bit of getting used to. But, there
    are some definite benefits, especially if you need to work in a mixed environment
    of Linux, macOS, and Windows computers.
  prefs: []
  type: TYPE_NORMAL
- en: This wraps up not only *Chapter 23*, but also the book. Along the way, you went
    from a command-line beginner to a shell-scripting guru. Of course, you might not
    be able to remember everything off the top of your head, and that’s okay. Just
    use this book, and any other resources you can find, as ready-references if you
    ever need help in creating an awesome script.
  prefs: []
  type: TYPE_NORMAL
- en: Anyway, it’s been a long journey, but I’ve enjoyed it, and hope that you have
    as well. Take care, and maybe we’ll meet up again some time.
  prefs: []
  type: TYPE_NORMAL
- en: Further Reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'PowerShell Core for Linux Administrators Cookbook: [https://www.packtpub.com/en-us/product/powershell-core-for-linux-administrators-cookbook-9781789137231](https://www.packtpub.com/en-us/product/powershell-core-for-linux-administrators-cookbook-9781789137231)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'I switched from bash to PowerShell, and it’s going great!: [https://www.starkandwayne.com/blog/i-switched-from-bash-to-powershell-and-its-going-great/index.html](https://www.starkandwayne.com/blog/i-switched-from-bash-to-powershell-and-its-going-great/index.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Install PowerShell on Fedora Linux: [https://fedoramagazine.org/install-powershell-on-fedora-linux/](https://fedoramagazine.org/install-powershell-on-fedora-linux/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'PowerShell equivalents for common Linux/Bash commands: [https://mathieubuisson.github.io/powershell-linux-bash/](https://mathieubuisson.github.io/powershell-linux-bash/
    )'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Bash vs. PowerShell: Comparing Scripting Shells: [https://smartscripter.com/bash-vs-powershell-choosing-the-right-scripting-shell/](https://smartscripter.com/bash-vs-powershell-choosing-the-right-scripting-shell/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'PowerShell differences on non-Windows platforms: [https://learn.microsoft.com/en-us/powershell/scripting/whats-new/unix-support?view=powershell-7.4](https://learn.microsoft.com/en-us/powershell/scripting/whats-new/unix-support?view=powershell-7.4)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'PowerShell’s Equvalent to Linux’s ls -al: An In-depth Guide: [https://thelinuxcode.com/equivalent-of-linux-ls-al-in-powershell/](https://thelinuxcode.com/equivalent-of-linux-ls-al-in-powershell/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Bash vs PowerShell Cheat Sheet: [https://blog.ironmansoftware.com/daily-powershell/bash-powershell-cheatsheet/](https://blog.ironmansoftware.com/daily-powershell/bash-powershell-cheatsheet/  )'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Leave a Review!
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Thank you for purchasing this book from Packt Publishing—we hope you enjoyed
    it! Your feedback is invaluable and helps us improve and grow. Please take a moment
    to leave an [Amazon review](https://packt.link/r/1835463576); it will only take
    a minute, but it makes a big difference for readers like you.
  prefs: []
  type: TYPE_NORMAL
- en: Scan the QR code below to receive a free ebook of your choice.
  prefs: []
  type: TYPE_NORMAL
- en: '[https://packt.link/NzOWQ](https://packt.link/NzOWQ)'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/review.png)'
  prefs: []
  type: TYPE_IMG
- en: '![](img/New_Packt_Logo1.png)'
  prefs: []
  type: TYPE_IMG
- en: '[packt.com](http://packt.com)'
  prefs: []
  type: TYPE_NORMAL
- en: Subscribe to our online digital library for full access to over 7,000 books
    and videos, as well as industry leading tools to help you plan your personal development
    and advance your career. For more information, please visit our website.
  prefs: []
  type: TYPE_NORMAL
- en: Why subscribe?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Spend less time learning and more time coding with practical eBooks and Videos
    from over 4,000 industry professionals
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Improve your learning with Skill Plans built especially for you
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Get a free eBook or video every month
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Fully searchable for easy access to vital information
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Copy and paste, print, and bookmark content
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: At [www.packt.com](http://www.packt.com), you can also read a collection of
    free technical articles, sign up for a range of free newsletters, and receive
    exclusive discounts and offers on Packt books and eBooks.
  prefs: []
  type: TYPE_NORMAL
- en: Other Books You May Enjoy
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'If you enjoyed this book, you may be interested in these other books by Packt:'
  prefs: []
  type: TYPE_NORMAL
- en: '[![](img/9781803232225.jpg)](https://www.packtpub.com/en-in/product/linux-kernel-programming-9781803232225)'
  prefs: []
  type: TYPE_NORMAL
- en: '**Linux Kernel Programming**'
  prefs: []
  type: TYPE_NORMAL
- en: Kaiwan N. Billimoria
  prefs: []
  type: TYPE_NORMAL
- en: 'ISBN: 9781803232225'
  prefs: []
  type: TYPE_NORMAL
- en: Configure and build the 6.1 LTS kernel from source
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Write high-quality modular kernel code (LKM framework) for 6.x kernels
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Explore modern Linux kernel architecture
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Get to grips with key internals details regarding memory management within the
    kernel
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understand and work with various dynamic kernel memory alloc/dealloc APIs
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Discover key internals aspects regarding CPU scheduling within the kernel, including
    cgroups v2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Gain a deeper understanding of kernel concurrency issues
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Learn how to work with key kernel synchronization primitives
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[![](img/9781804616925.png)](https://www.packtpub.com/en-in/product/the-software-developers-guide-to-linux-9781804616925)'
  prefs: []
  type: TYPE_NORMAL
- en: '**The Software Developer’s Guide to Linux**'
  prefs: []
  type: TYPE_NORMAL
- en: David Cohen, Christian Sturm
  prefs: []
  type: TYPE_NORMAL
- en: 'ISBN: 9781804616925'
  prefs: []
  type: TYPE_NORMAL
- en: Learn useful command-line tricks and tools that make software development, testing,
    and troubleshooting easy
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understand how Linux and command line environments actually work
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Create powerful, customized tools and save thousands of lines of code with developer-centric
    Linux utilities
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Gain hands-on experience with Docker, SSH, and Shell scripting tasks that make
    you a more effective developer
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Get comfortable searching logs and troubleshooting problems on Linux servers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Handle common command-line situations that stump other developers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Packt is searching for authors like you
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If you’re interested in becoming an author for Packt, please visit [authors.packtpub.com](http://authors.packtpub.com)
    and apply today. We have worked with thousands of developers and tech professionals,
    just like you, to help them share their insight with the global tech community.
    You can make a general application, apply for a specific hot topic that we are
    recruiting an author for, or submit your own idea.
  prefs: []
  type: TYPE_NORMAL
- en: Join our community on Discord!
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Read this book alongside other users, Linux experts, and the author himself.
  prefs: []
  type: TYPE_NORMAL
- en: Ask questions, provide solutions to other readers, chat with the author via
    Ask Me Anything sessions, and much more. Scan the QR code or visit the link to
    join the community.
  prefs: []
  type: TYPE_NORMAL
- en: '[https://packt.link/SecNet](https://packt.link/SecNet)'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/QR_Code10596186092701843.png)'
  prefs: []
  type: TYPE_IMG
