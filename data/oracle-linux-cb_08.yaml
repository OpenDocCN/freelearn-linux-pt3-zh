- en: '8'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '8'
- en: DevOps Automation Tools – Terraform, Ansible, Packer, and More
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: DevOps自动化工具——Terraform、Ansible、Packer等
- en: What good is an operating system if it doesn’t cater to developers? After all,
    an operating system that’s easy to develop on tends to enjoy a much stronger ecosystem
    than one that does not. You’ll be happy to learn that Oracle Linux plays very
    nicely with developers, and this chapter is all about common development tools
    that will make your life easier when setting out to work on your next project.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 如果操作系统不能满足开发者需求，那它又有什么用呢？毕竟，易于开发的操作系统往往比那些不适合开发的操作系统拥有更强大的生态系统。你会很高兴地知道，Oracle
    Linux非常适合开发者使用，本章将介绍一些常见的开发工具，它们将使你在开展下一个项目时更加轻松。
- en: There are countless development tools that work well on Oracle Linux, but the
    ones we’re focusing on in this chapter are all about automation. We’ll be talking
    about automating cloud infrastructure, automating the operating system build cycle,
    automating system administrators’ tasks, and automating the launching of virtual
    machines for development purposes.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 有无数的开发工具在Oracle Linux上运行良好，但本章重点讨论的工具都与自动化相关。我们将讨论如何自动化云基础设施、自动化操作系统构建周期、自动化系统管理员任务以及自动化为开发目的启动虚拟机。
- en: 'In this chapter, we’re going to cover the following recipes:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 本章我们将介绍以下内容：
- en: Do it once manually – rinse and repeat with Terraform
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 手动做一次——然后使用Terraform反复执行
- en: Creating portable roles for Ansible
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为Ansible创建可移植角色
- en: Managing secrets with Ansible Vault
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Ansible Vault管理机密
- en: Cooking up the perfect lab environment with Vagrant
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用Vagrant打造完美的实验环境
- en: Using Packer to modify source images
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Packer修改源镜像
- en: Pack it up, pack it in, let me begin, err, umm… build
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 收拾好行囊，准备开始，呃，嗯……构建
- en: Technical requirements
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: We’re covering a lot of technologies in this chapter. Let’s prepare your machine
    so that you can conveniently follow along with the recipes.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 本章我们将涵盖很多技术。让我们准备好你的机器，这样你就可以方便地跟随教程进行操作。
- en: Ansible
  id: totrans-13
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Ansible
- en: 'For Oracle Linux 8, we can install Ansible by leveraging the **Oracle Linux
    Automation Manager** repository, so let’s install the repository first, and then
    we’ll install Ansible:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 对于Oracle Linux 8，我们可以通过利用**Oracle Linux Automation Manager**库来安装Ansible，先安装该库，然后我们再安装Ansible：
- en: '[PRE0]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Packer, Vagrant, and Terraform
  id: totrans-16
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Packer、Vagrant和Terraform
- en: Packer is a tool used for automating the creation of machine images, Vagrant
    is used for managing the lifecycle of virtual machines, and Terraform is an infrastructure-as-code
    tool. Packer, Vagrant, and Terraform are all products of HashiCorp, but they work
    well on Oracle Linux.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: Packer是一个用于自动化创建机器镜像的工具，Vagrant用于管理虚拟机的生命周期，而Terraform是一个基础设施即代码的工具。Packer、Vagrant和Terraform都是HashiCorp的产品，但它们在Oracle
    Linux上表现良好。
- en: 'We’re going to install Packer, Vagrant, and Terraform directly from HashiCorp:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将直接从HashiCorp安装Packer、Vagrant和Terraform：
- en: '[PRE1]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Once that’s finished, let’s go ahead and install **Oracle VM VirtualBox**,
    as we’ll be using VirtualBox with **Packer** and **Vagrant**:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 完成后，我们继续安装**Oracle VM VirtualBox**，因为我们将与**Packer**和**Vagrant**一起使用VirtualBox：
- en: '[PRE2]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Finally, along with Terraform, we’ll also want to create an **Oracle Cloud Infrastructure**
    (**OCI**) account. If you prefer, you may opt to use a different cloud, but use
    OCI if you want to follow this tutorial directly.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，除了Terraform，我们还需要创建一个**Oracle Cloud Infrastructure**（**OCI**）账户。如果你愿意，可以选择使用其他云服务，但如果你希望直接跟随本教程，建议使用OCI。
- en: Important note
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: Be sure to remember your Cloud Account Name as this is an important detail required
    in order to access your OCI account.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 一定要记住你的云账户名称，因为这是访问你的OCI账户时需要的一个重要细节。
- en: Downloading the source code
  id: totrans-25
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 下载源代码
- en: The source code for the recipes in this chapter can be found at [https://github.com/PacktPublishing/Oracle-Linux-Cookbook/tree/main/ch8](https://github.com/PacktPublishing/Oracle-Linux-Cookbook/tree/main/ch8).
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的食谱源代码可以在[https://github.com/PacktPublishing/Oracle-Linux-Cookbook/tree/main/ch8](https://github.com/PacktPublishing/Oracle-Linux-Cookbook/tree/main/ch8)找到。
- en: Do it once manually – rinse and repeat with Terraform
  id: totrans-27
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 手动做一次——然后使用Terraform反复执行
- en: Terraform is an **infrastructure-as-code** (**IaC**) tool that lets you build,
    change, and version infrastructure safely and efficiently. This recipe will provide
    a general overview of a good technique for automating the *ugly* with **Terraform**.
    What do I mean by *ugly*? Well, it’s anything that’s being done manually. We want
    to cut out the manual steps and automate as much as possible. In the case of Terraform
    specifically, this means we’re going to automate the deployment of cloud infrastructure.
    Thanks to Terraform, we no longer need to click around through a hundred different
    menu settings. Instead, we’re going to define our **infrastructure as code**.
    This results in faster and more consistent deployments. Additionally, it’s also
    much easier to make changes to your infrastructure since it can all be edited
    via code.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: Terraform 是一个 **基础设施即代码** (**IaC**) 工具，它可以让你安全高效地构建、改变和版本化基础设施。本食谱将提供一个关于如何用
    **Terraform** 自动化 *繁琐* 任务的技术概览。*繁琐*是什么意思？嗯，就是任何手动完成的任务。我们想要去掉这些手动步骤，尽可能地实现自动化。具体到
    Terraform，这意味着我们将自动化云基础设施的部署。得益于 Terraform，我们不再需要通过数百个不同的菜单设置来点击操作。相反，我们将定义 **基础设施即代码**。这使得部署更快速、更一致。此外，由于所有内容都可以通过代码进行编辑，修改基础设施也变得更加容易。
- en: Getting started
  id: totrans-29
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 开始使用
- en: 'You will need the following for this recipe:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 你将需要以下内容来完成本食谱：
- en: Oracle Linux
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Oracle Linux
- en: Terraform
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Terraform
- en: Refer to the *Technical requirements* section at the beginning of this chapter
    if you need help installing Terraform.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你需要帮助安装 Terraform，请参考本章开头的 *技术要求* 部分。
- en: How to do it…
  id: totrans-34
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作…
- en: Any time you set out to automate something, it’s always a good idea to have
    a solid grasp on what needs to be done under the hood. Can you guess what that
    means? Yep, you’ve got to perform all the manual steps at least once before trying
    to automate it.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 每当你开始自动化某件事时，最好先深入理解底层需要做什么。你能猜到这是什么意思吗？没错，你必须至少手动完成所有步骤一次，然后再尝试自动化。
- en: First, do it once manually…
  id: totrans-36
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 首先，先手动操作一次…
- en: 'The goal for this recipe is to use Terraform to deploy a simple VM in the cloud.
    It’s an easy enough task, but before we jump into how this can be done using code,
    it’s generally best to do it manually first. So, with that being said, let’s go
    ahead and deploy a virtual machine using the OCI web GUI:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 本食谱的目标是使用 Terraform 在云中部署一个简单的虚拟机。这是一个足够简单的任务，但在我们跳入如何通过代码实现之前，通常最好先手动操作一次。所以，话虽如此，我们先通过
    OCI 网页界面部署一台虚拟机：
- en: Log in to the Oracle Cloud Infrastructure Console ([https://cloud.oracle.com/](https://cloud.oracle.com/)).
  id: totrans-38
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 登录到 Oracle 云基础设施控制台 ([https://cloud.oracle.com/](https://cloud.oracle.com/))。
- en: '![Figure 8.1 – OCI Console Login Page](img/B18349_08_01.jpg)'
  id: totrans-39
  prefs: []
  type: TYPE_IMG
  zh: '![图 8.1 – OCI 控制台登录页面](img/B18349_08_01.jpg)'
- en: Figure 8.1 – OCI Console Login Page
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.1 – OCI 控制台登录页面
- en: 'Click on the hamburger menu icon at the top left:'
  id: totrans-41
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击左上角的汉堡菜单图标：
- en: '![Figure 8.2 – OCI Console main screen](img/B18349_08_02.jpg)'
  id: totrans-42
  prefs: []
  type: TYPE_IMG
  zh: '![图 8.2 – OCI 控制台主屏幕](img/B18349_08_02.jpg)'
- en: Figure 8.2 – OCI Console main screen
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.2 – OCI 控制台主屏幕
- en: 'Then click on **Compute** | **Instances**:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 然后点击 **计算** | **实例**：
- en: '![Figure 8.3 – OCI Cloud Compute menu](img/B18349_08_03.jpg)'
  id: totrans-45
  prefs: []
  type: TYPE_IMG
  zh: '![图 8.3 – OCI 云计算菜单](img/B18349_08_03.jpg)'
- en: Figure 8.3 – OCI Cloud Compute menu
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.3 – OCI 云计算菜单
- en: 'Verify you are in the desired **Compartment**, and finally, click on **Create
    instance**:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 确认你在想要的 **隔离区** 中，最后点击 **创建实例**：
- en: '![Figure 8.4 – OCI Cloud Compute Instances](img/B18349_08_04.jpg)'
  id: totrans-48
  prefs: []
  type: TYPE_IMG
  zh: '![图 8.4 – OCI 云计算实例](img/B18349_08_04.jpg)'
- en: Figure 8.4 – OCI Cloud Compute Instances
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.4 – OCI 云计算实例
- en: Info
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 信息
- en: For brevity, when multiple menu items need to be clicked, the pipe symbol (|)
    indicates the sequence in which to click buttons/links.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 为了简洁，当需要点击多个菜单项时，管道符号（|）表示点击按钮/链接的顺序。
- en: We’re going to use the default Oracle Linux image, but if you want to change
    this, you can go to **Image and shape** and click on **Edit**.
  id: totrans-52
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将使用默认的 Oracle Linux 镜像，但如果你想更改，可以进入 **镜像和形状**，然后点击 **编辑**。
- en: '![Figure 8.5 – OCI Console Compute Image and shape](img/B18349_08_05.jpg)'
  id: totrans-53
  prefs: []
  type: TYPE_IMG
  zh: '![图 8.5 – OCI 控制台计算镜像和形状](img/B18349_08_05.jpg)'
- en: Figure 8.5 – OCI Console Compute Image and shape
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.5 – OCI 控制台计算镜像和形状
- en: Note
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: There’s no cost as long as you stick to all **Always Free-eligible** resources;
    however, at the time of writing, there is a bug that falsely shows a $2.00 per
    month charge for the boot volume. This is a bug as the boot volume uses block
    storage and OCI gives you up to 200 GB of block storage for free.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 只要你遵循所有**始终免费适用**的资源，就没有费用；然而，在写作时，存在一个错误，错误地显示了每月 $2.00 的启动卷费用。这个错误是因为启动卷使用的是块存储，而
    OCI 为你提供最多 200 GB 的块存储是免费的。
- en: 'At the time of writing, the latest version is *Oracle Linux 8* (image build:
    2023.06.30-0).'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 在写作时，最新版本是*Oracle Linux 8*（镜像构建：2023.06.30-0）。
- en: Under **Add SSH Keys**, select **Generate a key pair for me** and then click
    on **Save Private Key** and **Save** **Public Key**.
  id: totrans-58
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**添加 SSH 密钥**下，选择**为我生成一对密钥**，然后点击**保存私钥**和**保存公钥**。
- en: Tip
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 提示
- en: Choose a place that is easy for you to remember, as you’ll need this later when
    you seek to SSH into your VM.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 选择一个容易记住的地方，因为你稍后需要在 SSH 连接到你的虚拟机时使用这个位置。
- en: Finally, click on **Create**.
  id: totrans-61
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，点击**创建**。
- en: Note
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Feel free to grab a coffee while waiting for the image to build.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 等待图像构建时，随时可以去喝杯咖啡。
- en: 'Now, let’s use SSH to connect to the instance:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们使用 SSH 连接到实例：
- en: On the **Instance information** tab, click on **Copy** next to the **Public
    IP** **address** entry.
  id: totrans-65
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**实例信息**标签页中，点击**公共 IP** **地址**旁边的**复制**按钮。
- en: 'Open up a terminal application and use the `ssh` command to connect. We’ll
    use `-i` (where `i` stands for identify file) to reference the private key we
    saved in the previous steps. The default username for official Oracle Linux instances
    hosted in the OCI is `opc`, so we’ll instruct `ssh` to connect as `opc`. Finally,
    input the **Public IP address** you obtained in the previous step. Your command
    should look a bit like this:'
  id: totrans-66
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开一个终端应用程序，使用`ssh`命令连接。我们将使用`-i`（其中`i`代表身份文件）来引用我们在前面的步骤中保存的私钥。对于托管在 OCI 中的官方
    Oracle Linux 实例，默认的用户名是`opc`，因此我们将指示`ssh`以`opc`身份连接。最后，输入你在前一步中获得的**公共 IP 地址**。你的命令应该看起来像这样：
- en: '![Figure 8.6 – SSH into compute instance (failure)](img/B18349_08_06.jpg)'
  id: totrans-67
  prefs: []
  type: TYPE_IMG
  zh: '![图 8.6 – SSH 连接计算实例（失败）](img/B18349_08_06.jpg)'
- en: Figure 8.6 – SSH into compute instance (failure)
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.6 – SSH 连接计算实例（失败）
- en: 'Uh oh! Did you notice the big warning, as well as that last message? We were
    denied access because of bad permissions. Let’s fix that using `chmod` to give
    only the owner permission to access the key file:'
  id: totrans-69
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 哎呀！你注意到那个大警告以及最后的信息了吗？我们因为权限问题被拒绝访问。让我们通过使用`chmod`命令，只为文件的所有者赋予访问密钥文件的权限来修复它：
- en: '![](img/B18349_08_07.jpg)'
  id: totrans-70
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B18349_08_07.jpg)'
- en: Figure 8.7 – SSH into compute instance (success)
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.7 – SSH 连接计算实例（成功）
- en: Great! We’ve connected to the machine via SSH.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 太棒了！我们已经通过 SSH 连接到了机器。
- en: Now I do realize that this wasn’t all that difficult, but imagine if you had
    to do this a hundred times? Why not automate the process with Terraform?
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我知道这并不难，但想象一下如果你需要做一百次该怎么办？为什么不使用 Terraform 自动化这个过程呢？
- en: Now it’s time to rinse and repeat with Terraform
  id: totrans-74
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 现在是时候使用 Terraform 反复操作了
- en: 'This time around, we’re going to accomplish the exact same thing that was described
    earlier – that is, we’re going to create another virtual machine in OCI. However,
    this time around, we’re going to define our IaC using Terraform:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 这次我们将完成与之前描述的完全相同的操作——也就是，我们将再次在 OCI 中创建一个虚拟机。然而，这一次，我们将使用 Terraform 来定义我们的基础设施即代码（IaC）：
- en: 'First, let’s create three new files within the root of your project directory
    (I’m naming this one `terraform`) using your favorite code editor, and name them
    as follows:'
  id: totrans-76
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，让我们在项目目录的根目录下创建三个新文件（我将这个文件命名为`terraform`），使用你喜欢的代码编辑器，文件名如下：
- en: '`main.tf`'
  id: totrans-77
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`main.tf`'
- en: '`variables.tf`'
  id: totrans-78
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`variables.tf`'
- en: '`terraform.tfvars`'
  id: totrans-79
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`terraform.tfvars`'
- en: Next, let’s head to the Terraform Registry ([https://registry.terraform.io/](https://registry.terraform.io/))
    to find the provider for **Oracle Cloud** **Infrastructure** (**OCI**).
  id: totrans-80
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，让我们前往 Terraform 注册表 ([https://registry.terraform.io/](https://registry.terraform.io/))
    查找**Oracle Cloud** **基础设施**（**OCI**）的提供者。
- en: On the Terraform Registry, search for either `oci` or `oracle cloud infrastructure`
    and select **oracle/oci**.
  id: totrans-81
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 Terraform 注册表中，搜索`oci`或`oracle cloud infrastructure`，然后选择**oracle/oci**。
- en: Note
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Alternatively, you can click on **Browse Providers** and then click on the **Oracle
    Cloud** **Infrastructure** button.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，你可以点击**浏览提供者**，然后点击**Oracle Cloud** **Infrastructure** 按钮。
- en: 'Click on `main.tf` file:'
  id: totrans-84
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击`main.tf`文件：
- en: '![Figure 8.8 – Terraform OCI provider](img/B18349_08_08.jpg)'
  id: totrans-85
  prefs: []
  type: TYPE_IMG
  zh: '![图 8.8 – Terraform OCI 提供者](img/B18349_08_08.jpg)'
- en: Figure 8.8 – Terraform OCI provider
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.8 – Terraform OCI 提供者
- en: Notice the comment for `# Configuration options` under the `provider "oci"`.
    This tells us we may need to supply some configuration options in order to use
    the provider.
  id: totrans-87
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 注意 `provider "oci"` 下的 `# 配置选项` 注释。这告诉我们可能需要提供一些配置选项才能使用该提供者。
- en: 'Let’s take a look at how to do this:'
  id: totrans-88
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 让我们看看如何做到这一点：
- en: Click on the **Documentation** tab (it’s right next to **USE PROVIDER**), then
    find the link on **How to configure** **the provider**.
  id: totrans-89
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击 **文档** 标签（它就在 **使用提供者** 旁边），然后找到 **如何配置** **提供者** 的链接。
- en: 'You’ll find that the OCI Terraform provider supports four authentication methods:'
  id: totrans-90
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你会发现 OCI Terraform 提供者支持四种身份验证方法：
- en: '**API Key** **Authentication** (default)'
  id: totrans-91
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**API 密钥** **身份验证**（默认）'
- en: '**Instance** **Principal Authorization**'
  id: totrans-92
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**实例** **主体授权**'
- en: '**Resource** **Principal Authentication**'
  id: totrans-93
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**资源** **主体身份验证**'
- en: '**Security** **Token Authentication**'
  id: totrans-94
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**安全性** **令牌身份验证**'
- en: For this recipe, I’ll be using the default authentication method; that is, **API
    Key Authentication**. This method has the fewest limitations, but depending on
    your use case, you can choose the one that best meets your needs.
  id: totrans-95
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于本食谱，我将使用默认的身份验证方法；即 **API 密钥身份验证**。这种方法的限制最少，但根据你的使用情况，你可以选择最适合你需求的方法。
- en: Important note
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: There’s no shortcut to providing the authentication details; however, for some
    helpful guidance, you may want to reference the `oci-provider-conf.md` file in
    the GitHub repository associated with this recipe. If you want greater details,
    I recommend working through the documentation described in the **How to configure
    the provider** section referenced earlier.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 提供身份验证信息没有快捷方式；但是，若需要一些帮助的指导，你可以参考与本食谱相关的 GitHub 仓库中的 `oci-provider-conf.md`
    文件。如果你需要更多细节，我建议按照前面提到的 **如何配置提供者** 部分中描述的文档进行操作。
- en: 'If you decided to use `provider "oci"` in the `main.tf` file:'
  id: totrans-98
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果你决定在 `main.tf` 文件中使用 `provider "oci"`：
- en: '![Figure 8.9 – API key authentication details](img/B18349_08_09.jpg)'
  id: totrans-99
  prefs: []
  type: TYPE_IMG
  zh: '![图 8.9 – API 密钥身份验证详细信息](img/B18349_08_09.jpg)'
- en: Figure 8.9 – API key authentication details
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.9 – API 密钥身份验证详细信息
- en: In order to keep things clean, we’re going to reference variables for these
    values. I will provide more details on how to define/declare variables later in
    this recipe.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 为了保持整洁，我们将引用这些值的变量。稍后我将在本食谱中提供更多有关如何定义/声明变量的详细信息。
- en: Note
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: To illustrate that we’re adding to a file, I am using three series of three
    dots. This is meant to represent a continuation of what we did in the previous
    steps.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 为了说明我们正在向文件中添加内容，我使用了三组省略号。这是为了表示我们在前面步骤中所做的操作的延续。
- en: 'Here''s an example:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个示例：
- en: '`...`'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: '`...`'
- en: '`...`'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: '`...`'
- en: '`...`'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: '`...`'
- en: Now that we’ve got our provider set up, it’s not going to do much unless we
    add a resource. In this case, we want to add an `oci_core_instance`.
  id: totrans-108
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们已经设置好了提供者，除非我们添加资源，否则它不会做太多工作。在这种情况下，我们想要添加一个 `oci_core_instance`。
- en: Do you recall when we generated an SSH key pair during the manual process? Well,
    now we need to figure out a way to do this dynamically using code. The following
    instruction is how we can do this using Terraform. We’ll create a `tls_private_key`
    resource, and reference that as our `ssh_authorized_keys` under the metadata for
    the `oci_core_instance` resource.
  id: totrans-109
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 你还记得我们在手动过程中生成 SSH 密钥对时吗？现在，我们需要找出如何使用代码动态地做到这一点。以下指令是如何使用 Terraform 完成这一操作的。我们将创建一个
    `tls_private_key` 资源，并将其作为我们的 `ssh_authorized_keys` 引用到 `oci_core_instance` 资源的元数据中。
- en: 'Let’s start with the SSH key pair, which is created with the `tls_private_key`
    resource. Details on this resource can be found under the `hashicorp/tls` provider
    on the Terraform registry. Continue to edit the `main.tf` file, and add the following:'
  id: totrans-110
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们从 SSH 密钥对开始，它是通过 `tls_private_key` 资源创建的。有关此资源的详细信息，可以在 Terraform 注册表的 `hashicorp/tls`
    提供者下找到。继续编辑 `main.tf` 文件，并添加以下内容：
- en: '![Figure 8.10 – Defining SSH key pair with Terraform](img/B18349_08_10.jpg)'
  id: totrans-111
  prefs: []
  type: TYPE_IMG
  zh: '![图 8.10 – 使用 Terraform 定义 SSH 密钥对](img/B18349_08_10.jpg)'
- en: Figure 8.10 – Defining SSH key pair with Terraform
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.10 – 使用 Terraform 定义 SSH 密钥对
- en: 'You’ll need to define a valid availability domain. One way to do this is by
    using Terraform to query a list of availability domains and reference one of the
    items from that list, so let’s add the following code to the `main.tf` file:'
  id: totrans-113
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你需要定义一个有效的可用域。实现这一点的一种方式是使用 Terraform 查询可用域列表，并引用该列表中的一个项，所以让我们将以下代码添加到 `main.tf`
    文件中：
- en: '![Figure 8.11 – Getting a list of availability domains using Terraform](img/B18349_08_11.jpg)'
  id: totrans-114
  prefs: []
  type: TYPE_IMG
  zh: '![图 8.11 – 使用 Terraform 获取可用域列表](img/B18349_08_11.jpg)'
- en: Figure 8.11 – Getting a list of availability domains using Terraform
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.11 – 使用Terraform获取可用域列表
- en: 'Finally, we’re going to add a resource for `oci_core_instance`. If you review
    the `oci_core_instance` resource from the `oracle/oci` provider on the Terraform
    registry, you’ll see a long list of parameters that can be used to define the
    `oci_core_instance` resource; however, not everything from this list is required
    as many of the parameters are preceded with `#Optional`. For this recipe, we’re
    going to use the bare minimum that is required for this resource – so that should
    look something like this:'
  id: totrans-116
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们将添加一个`oci_core_instance`资源。如果你查看Terraform注册表中的`oracle/oci`提供程序下的`oci_core_instance`资源，你会看到一个很长的参数列表，这些参数可以用来定义`oci_core_instance`资源；然而，并不是所有的参数都是必需的，因为很多参数前面都有`#Optional`标记。在这个示例中，我们将使用此资源所需的最少参数——大致应该是这样的：
- en: '![Figure 8.12 – OCI Core instance resource details](img/B18349_08_12.jpg)'
  id: totrans-117
  prefs: []
  type: TYPE_IMG
  zh: '![图 8.12 – OCI 核心实例资源详细信息](img/B18349_08_12.jpg)'
- en: Figure 8.12 – OCI Core instance resource details
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.12 – OCI 核心实例资源详细信息
- en: 'Once you are finished with the `oci_core_instance` resource, your entire `main.tf`
    file should look something like this:'
  id: totrans-119
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦你完成了`oci_core_instance`资源，你的整个`main.tf`文件应该像这样：
- en: '![Figure 8.13 – Contents of main.tf file](img/B18349_08_13.jpg)'
  id: totrans-120
  prefs: []
  type: TYPE_IMG
  zh: '![图 8.13 – main.tf 文件的内容](img/B18349_08_13.jpg)'
- en: Figure 8.13 – Contents of main.tf file
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.13 – main.tf 文件的内容
- en: Now we need to declare all of those variables we referenced throughout the `main.tf`
    file. In order to keep things organized, let’s put them in the `variables.tf`
    file. Each variable should, at a minimum, contain a type; however, we’ll also
    add a description to explain the purpose of the variable.
  id: totrans-122
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们需要声明在`main.tf`文件中引用的所有变量。为了保持结构清晰，我们将它们放在`variables.tf`文件中。每个变量至少应包含一个类型；然而，我们还将添加描述以解释变量的用途。
- en: 'Input the following into your `variables.tf` file:'
  id: totrans-123
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 将以下内容输入到`variables.tf`文件中：
- en: '![Figure 8.14 – Declaration of variables in the variables.tf file](img/B18349_08_14.jpg)'
  id: totrans-124
  prefs: []
  type: TYPE_IMG
  zh: '![图 8.14 – 在variables.tf文件中声明变量](img/B18349_08_14.jpg)'
- en: Figure 8.14 – Declaration of variables in the variables.tf file
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.14 – 在variables.tf文件中声明变量
- en: 'Finally, we would want to assign values to the variables. For this, you can
    use the `terraform.tfvars` file. It should look something like this:'
  id: totrans-126
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们需要为变量分配值。为此，你可以使用`terraform.tfvars`文件。它应该像这样：
- en: '![Figure 8.15 – Content of terraform.tfvars file](img/B18349_08_15.jpg)'
  id: totrans-127
  prefs: []
  type: TYPE_IMG
  zh: '![图 8.15 – terraform.tfvars 文件的内容](img/B18349_08_15.jpg)'
- en: Figure 8.15 – Content of terraform.tfvars file
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.15 – terraform.tfvars 文件的内容
- en: Note
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: 'Reference the following guide to find the *ocid* for `tenancy_ocid`, `compartment_ocid`,
    `user_ocid`, `fingerprint`, `subnet_ocid`, and `private_key_path`: [https://docs.oracle.com/en-us/iaas/Content/API/SDKDocs/terraformproviderconfiguration.htm](https://docs.oracle.com/en-us/iaas/Content/API/SDKDocs/terraformproviderconfiguration.htm).'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 请参考以下指南，找到`tenancy_ocid`、`compartment_ocid`、`user_ocid`、`fingerprint`、`subnet_ocid`和`private_key_path`的*ocid*：[https://docs.oracle.com/en-us/iaas/Content/API/SDKDocs/terraformproviderconfiguration.htm](https://docs.oracle.com/en-us/iaas/Content/API/SDKDocs/terraformproviderconfiguration.htm)。
- en: 'To get the OCID for Oracle Linux 8, visit the following link: [https://docs.oracle.com/en-us/iaas/images/oracle-linux-8x/](https://docs.oracle.com/en-us/iaas/images/oracle-linux-8x/)
    is region specific as well as architecture specific, so you’ll want to find the
    latest Oracle Linux 8 image for x86 (or in other words, look for one without the
    `aarch64` text in the image name).'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 要获取Oracle Linux 8的OCID，请访问以下链接：[https://docs.oracle.com/en-us/iaas/images/oracle-linux-8x/](https://docs.oracle.com/en-us/iaas/images/oracle-linux-8x/)
    此链接是区域特定的，也与架构有关，因此你需要找到适用于x86的最新Oracle Linux 8镜像（换句话说，查找镜像名称中没有`aarch64`文本的版本）。
- en: Warning
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 警告
- en: Just be sure to add the `terraform.tfvars` file to your `.gitignore` list to
    avoid checking any sensitive information into version control.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 确保将`terraform.tfvars`文件添加到`.gitignore`列表中，以避免将任何敏感信息提交到版本控制中。
- en: 'Next, let’s run Terraform to see if we did everything correctly:'
  id: totrans-134
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，让我们运行Terraform，看看我们是否做对了：
- en: '[PRE3]'
  id: totrans-135
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Important note
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: If you get a `401-NotAuthenticated` error, make sure you’ve added your public
    key to the OCI console. This is the public key that pairs with `private_key_path`
    under the *API Key* *Authentication* method.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 如果遇到`401-NotAuthenticated`错误，请确保已将您的公钥添加到OCI控制台中。此公钥与*API 密钥* *认证*方法下的`private_key_path`配对。
- en: For help with adding your public key to the OCI console, visit [https://docs.oracle.com/en-us/iaas/Content/API/Concepts/apisigningkey.htm#three](https://docs.oracle.com/en-us/iaas/Content/API/Concepts/apisigningkey.htm#three).
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你需要帮助将公钥添加到 OCI 控制台，请访问 [https://docs.oracle.com/en-us/iaas/Content/API/Concepts/apisigningkey.htm#three](https://docs.oracle.com/en-us/iaas/Content/API/Concepts/apisigningkey.htm#three)。
- en: 'If all goes well, you should be able to watch as your resources are created.
    Once this is complete, you’ll see a message like this:'
  id: totrans-139
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果一切顺利，你应该能够看到资源被创建的过程。一旦完成，你会看到类似这样的信息：
- en: '[PRE4]'
  id: totrans-140
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '![Figure 8.16 – Terraform code that outputs connection details](img/B18349_08_16.jpg)'
  id: totrans-141
  prefs: []
  type: TYPE_IMG
  zh: '![图 8.16 – 输出连接详情的 Terraform 代码](img/B18349_08_16.jpg)'
- en: Figure 8.16 – Terraform code that outputs connection details
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.16 – 输出连接详情的 Terraform 代码
- en: 'Now that we have that in place, save your file and run `terraform apply` once
    more to see what this does:'
  id: totrans-143
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们已经完成了这部分，保存文件后，再次运行`terraform apply`，看看它的作用：
- en: '[PRE5]'
  id: totrans-144
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Terraform will do its thing, and at the end, you’ll see output that provides
    instructions on how to SSH into the newly created instance. That should look a
    bit like this:'
  id: totrans-145
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Terraform 将按照它的方式执行，最后你会看到输出，其中提供了如何通过 SSH 连接到新创建的实例的说明。它的输出应该看起来像这样：
- en: '![Figure 8.17 – Output of “terraform apply”](img/B18349_08_17.jpg)'
  id: totrans-146
  prefs: []
  type: TYPE_IMG
  zh: '![图 8.17 – “terraform apply” 的输出](img/B18349_08_17.jpg)'
- en: Figure 8.17 – Output of “terraform apply”
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.17 – “terraform apply” 的输出
- en: I realize that what we have just covered seems like a lot of information, but
    let’s consider what we’ve done here. We automated the deployment of an instance
    into the cloud. Every parameter is easily configurable within our `terraform.tfvars`
    file. Finally, trivial steps including generating SSH keys are also automated,
    and we even print a statement at the end that clearly instructs how to connect
    to the newly deployed instance. I hope you enjoyed this recipe and are starting
    to see the true value of **IaC**!
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 我意识到我们刚才讨论的内容似乎有很多信息，但让我们来回顾一下我们所做的工作。我们实现了将实例自动部署到云端。每个参数都可以在我们的`terraform.tfvars`文件中轻松配置。最后，包括生成
    SSH 密钥在内的琐碎步骤也被自动化处理，我们甚至在最后打印出一条信息，明确指导如何连接到新部署的实例。我希望你喜欢这个教程，并且开始看到**IaC**的真正价值！
- en: The source code for this recipe can be found at [https://github.com/PacktPublishing/Oracle-Linux-Cookbook/tree/main/ch8/terraform](https://github.com/PacktPublishing/Oracle-Linux-Cookbook/tree/main/ch8/terraform).
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 这个教程的源代码可以在以下地址找到：[https://github.com/PacktPublishing/Oracle-Linux-Cookbook/tree/main/ch8/terraform](https://github.com/PacktPublishing/Oracle-Linux-Cookbook/tree/main/ch8/terraform)。
- en: Creating portable roles for Ansible
  id: totrans-150
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为 Ansible 创建可移植角色
- en: 'Before attempting to follow this recipe, I recommend having some basic knowledge
    of Ansible and how to write an Ansible playbook. If you’ve never written an Ansible
    playbook, I recommend following the *Creating a playbook* guide from the official
    Ansible documentation. That can be found here: [https://docs.ansible.com/ansible/latest/getting_started/get_started_playbook.html](https://docs.ansible.com/ansible/latest/getting_started/get_started_playbook.html).'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 在尝试跟随这个教程之前，我建议你具备一些关于 Ansible 的基础知识，以及如何编写 Ansible playbook。如果你从未编写过 Ansible
    playbook，我建议你参考官方 Ansible 文档中的*创建 playbook*指南。你可以在这里找到该指南：[https://docs.ansible.com/ansible/latest/getting_started/get_started_playbook.html](https://docs.ansible.com/ansible/latest/getting_started/get_started_playbook.html)。
- en: In this recipe, you will learn how easy it is to move things around when using
    **Ansible roles**. When I first started using Ansible, I wrote my playbooks using
    *tasks* only. This to me seemed like a logical approach at the time and was more
    akin to traditional scripting since everything happened in chronological order.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个教程中，你将学到使用**Ansible 角色**时，移动内容是多么的简单。当我第一次开始使用 Ansible 时，我只用*任务*来编写 playbook。对我来说，这种方法在当时看起来是合乎逻辑的，并且更像传统的脚本编写方式，因为所有的操作都是按时间顺序执行的。
- en: The problem with writing playbooks in this way is there are no clear dependencies,
    and the tasks are defined along with the hosts, all in the same file. If you wanted
    to move things to another playbook, you’d have to be careful to grab the correct
    dependencies with each task, and you may be repeating yourself unnecessarily since
    tasks on their own are not reusable. As your playbooks become more complex and/or
    increase in size, you’ll eventually want something more portable for the sake
    of manageability.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 以这种方式编写 playbook 的问题在于没有明确的依赖关系，并且任务与主机一起定义，都在同一个文件中。如果你想把某些内容移到另一个 playbook，你就得小心地为每个任务抓取正确的依赖项，而且你可能会不必要地重复自己，因为任务本身不可复用。当你的
    playbook 变得更复杂和/或增大时，为了可管理性，你最终会希望有一些更便于迁移的东西。
- en: According to Red Hat, roles are designed to be *self-contained portable units*
    *of automation.*
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 根据 Red Hat 的说法，角色是设计成*自包含的可移植自动化单元*。
- en: Organizing your tasks into roles will allow you to easily reuse them and share
    them with others. In fact, if you visit Ansible Galaxy ([https://galaxy.ansible.com/](https://galaxy.ansible.com/))
    you will find plenty of content in the form of *pre-packaged units of work referred
    to in Ansible as roles and collections.* It’s much easier to reuse and share Ansible
    roles as organized units of automation because they are decoupled from the rest
    of the Ansible playbook framework.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 将任务组织成角色（roles）可以让您轻松地重复使用这些任务并与他人共享。事实上，如果您访问 Ansible Galaxy（[https://galaxy.ansible.com/](https://galaxy.ansible.com/)），您将会发现大量以*预打包的工作单元*（在
    Ansible 中称为角色和集合）的形式存在的内容。因为这些角色是与其他 Ansible playbook 框架解耦的，所以将 Ansible 角色作为组织化的自动化单元进行重用和共享要容易得多。
- en: If you’re a programmer, you can think of roles as functions or methods. Easy
    enough? Let’s get cooking!
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您是程序员，可以把角色看作是函数或方法。很简单吧？让我们开始吧！
- en: Getting started
  id: totrans-157
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 开始使用
- en: 'For this recipe, you will need the following:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个教程，您需要以下内容：
- en: Oracle Linux
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Oracle Linux
- en: Ansible
  id: totrans-160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Ansible
- en: Refer to the *Technical requirements* section at the beginning of this chapter
    if you need help installing Ansible.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您需要帮助安装 Ansible，请参考本章开头的*技术要求*部分。
- en: How to do it…
  id: totrans-162
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作…
- en: It’s not difficult to convert a series of tasks into roles. It’s really just
    a matter of stripping out the tasks and organizing them into categories that represent
    a role. This recipe aims to describe that process, and hopefully by the end, you
    will have a good understanding of how to do the same with your playbooks.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 将一系列任务转换成角色并不困难，实际上只是将任务拆分并将其组织成代表角色的类别。这个教程旨在描述这个过程，并希望到最后，您能够很好地理解如何在自己的 playbook
    中实现这一点。
- en: Original playbook
  id: totrans-164
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 原始 playbook
- en: To kick things off, let’s first take a look at a playbook that doesn’t leverage
    roles so we can dive into what needs to be done.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们首先来看一个不使用角色的 playbook，看看需要做什么。
- en: 'A typical playbook that does not leverage roles looks something like this:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 一个典型的没有使用角色的 playbook 可能是这样的：
- en: '![Figure 8.18 – Long playbook without roles](img/B18349_08_18.jpg)'
  id: totrans-167
  prefs: []
  type: TYPE_IMG
  zh: '![图 8.18 – 没有角色的长 playbook](img/B18349_08_18.jpg)'
- en: Figure 8.18 – Long playbook without roles
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.18 – 没有角色的长 playbook
- en: Note
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: The screenshot fades out at the end because it’s a long playbook and the entire
    contents of the playbook are not important.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 截图在最后消失是因为这是一个长 playbook，整个 playbook 的内容并不重要。
- en: This playbook automates several tasks. First, it creates a standard user if
    they do not already exist, then it installs Podman via the container-tools AppStream
    module, after which it launches an NGINX container, and then eventually it proceeds
    to upgrading all the packages on the system and checking whether the system needs
    to be rebooted.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 这个 playbook 自动化了几个任务。首先，如果标准用户不存在，它会创建一个，然后通过 container-tools AppStream 模块安装
    Podman，接着启动一个 NGINX 容器，最后升级系统中的所有软件包，并检查系统是否需要重启。
- en: As you can see from this example, if you write all your tasks directly into
    a playbook, it doesn’t take long for that file to become massive and unwieldy.
    Before long, you will find yourself repeating preparatory tasks throughout, and
    you’ll most likely add hash marks at the beginning of each line for unnecessary
    tasks, which will make the automation engine see it as a comment rather than code
    – you might even find yourself toggling between disabling and enabling tasks in
    order to target a specific task when running the playbook. This can become overwhelming,
    and if you’re not careful, you might end up removing bits of code when you don’t
    need them (even though sometimes, you might need them). Roles offer a better way
    to organize your playbooks. In fact, you can write as many roles as you want,
    and neatly call them in the playbook – this makes the playbook far easier to read
    and maintain over time.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，如果将所有任务直接写入一个 playbook，文件很快就会变得庞大而难以管理。不久之后，您会发现自己在文件中重复写入准备工作任务，并且很可能会在每行的开头添加注释符号，将不必要的任务标记为注释，从而让自动化引擎将它们视为注释而非代码——您甚至可能会在执行
    playbook 时切换任务的启用与禁用，以便针对某个特定任务。这可能会让人感到不堪重负，如果不小心，您可能会删除一些代码，尽管有时您可能仍然需要它们。角色提供了一种更好的组织
    playbook 的方式。事实上，您可以写尽可能多的角色，并将它们整齐地调用到 playbook 中——这样 playbook 会更易于阅读和维护。
- en: Creating a role
  id: totrans-173
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建角色
- en: 'In Ansible, roles are organized under the `roles` directory. You create a folder
    under `roles`, and whatever you name the folder will become the name of the role.
    Then within that folder, you create a minimum of one folder called `tasks`, which
    should contain a `main.yml` file defining the primary tasks that the role will
    perform:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Ansible 中，角色是组织在 `roles` 目录下的。你在 `roles` 下创建一个文件夹，文件夹的名称将成为角色的名称。然后在该文件夹中，至少要创建一个名为
    `tasks` 的文件夹，里面应包含一个定义该角色将执行的主要任务的 `main.yml` 文件：
- en: Let’s break things up and create a role for our users by creating a `users`
    folder in the `roles` directory.
  id: totrans-175
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们分解一下并通过在 `roles` 目录中创建一个 `users` 文件夹来为用户创建一个角色。
- en: 'Your directory structure should look a bit like this:'
  id: totrans-176
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 你的目录结构应该大致如下：
- en: '[PRE6]'
  id: totrans-177
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Now, create a `main.yml` file in the `tasks` directory, and let’s port our user-related
    tasks over into that file.
  id: totrans-178
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，在 `tasks` 目录中创建一个 `main.yml` 文件，将我们的用户相关任务迁移到该文件中。
- en: '![Figure 8.19 – Ansible role for provisioning users](img/B18349_08_19.jpg)'
  id: totrans-179
  prefs: []
  type: TYPE_IMG
  zh: '![图 8.19 – 用于配置用户的 Ansible 角色](img/B18349_08_19.jpg)'
- en: Figure 8.19 – Ansible role for provisioning users
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.19 – 用于配置用户的 Ansible 角色
- en: 'Now we have the beginnings of a role. We can take advantage of other features
    to facilitate pre-configuration operations. Here are two features that I tend
    to use most often – `files` and `meta`:'
  id: totrans-181
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们有了角色的雏形。我们可以利用其他功能来便于预配置操作。以下是我最常用的两个功能——`files` 和 `meta`：
- en: First, you’ll notice we are referencing a `files` directory. That is a special
    directory that belongs to a role, and contains files related to that role.
  id: totrans-182
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 首先，你会注意到我们引用了一个 `files` 目录。那是属于角色的一个特殊目录，包含与该角色相关的文件。
- en: The other is a `meta` directory that acts as a way to declare dependencies.
    For example, since the `users` role depends on certain groups to exist, it may
    be a good idea to make this role dependent on the `groups` role first. To do this,
    we can simply create a role for `groups` and then call this role from the `meta`
    directory.
  id: totrans-183
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 另一个是 `meta` 目录，它用于声明依赖项。例如，由于 `users` 角色依赖于某些组的存在，最好先使该角色依赖于 `groups` 角色。为此，我们只需为
    `groups` 创建一个角色，然后从 `meta` 目录中调用该角色。
- en: 'The `groups` role may look like the following. Notice the directory structure,
    along with the accompanying files – all of which are elements that make up a role.
    Your directory structure should look like this:'
  id: totrans-184
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`groups` 角色可能如下所示。请注意目录结构以及附带的文件——这些都是构成角色的元素。你的目录结构应如下所示：'
- en: '[PRE7]'
  id: totrans-185
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'The actual task should be written in the `main.yml` file with the following
    content:'
  id: totrans-186
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实际的任务应该写在 `main.yml` 文件中，内容如下：
- en: '![Figure 8.20 – Ansible role for user groups](img/B18349_08_20.jpg)'
  id: totrans-187
  prefs: []
  type: TYPE_IMG
  zh: '![图 8.20 – 用于用户组的 Ansible 角色](img/B18349_08_20.jpg)'
- en: Figure 8.20 – Ansible role for user groups
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.20 – 用于用户组的 Ansible 角色
- en: 'Now, in the `meta/main.yml` file for the `users` role, we just need to call
    the `groups` role as a dependency:'
  id: totrans-189
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，在 `users` 角色的 `meta/main.yml` 文件中，我们只需要将 `groups` 角色作为依赖项调用：
- en: '[PRE8]'
  id: totrans-190
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Finally, run the playbook with the following command:'
  id: totrans-191
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，使用以下命令运行剧本：
- en: '[PRE9]'
  id: totrans-192
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: You have successfully created a role within Ansible.
  id: totrans-193
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 你已经成功创建了一个 Ansible 角色。
- en: 'Next, repeat this process until you have everything organized into roles. For
    me, I ended up with the following directory structure:'
  id: totrans-194
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，重复这个过程，直到你将所有内容组织成角色。对我来说，最终我得到了以下的目录结构：
- en: '[PRE10]'
  id: totrans-195
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: New and improved playbook
  id: totrans-196
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 更新版的剧本
- en: 'As for the actual playbook itself, it can now be simplified to just the following:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 至于实际的剧本，它现在可以简化为如下内容：
- en: '![Figure 8.21 – Ansible playbook leveraging roles](img/B18349_08_21.jpg)'
  id: totrans-198
  prefs: []
  type: TYPE_IMG
  zh: '![图 8.21 – 利用角色的 Ansible 剧本](img/B18349_08_21.jpg)'
- en: Figure 8.21 – Ansible playbook leveraging roles
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.21 – 利用角色的 Ansible 剧本
- en: Note
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Notice that we are not listing out the `base_software` and `groups` roles in
    the playbook as these are dependencies we have defined under the `meta` directories.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们没有在剧本中列出 `base_software` 和 `groups` 角色，因为这些是我们在 `meta` 目录中定义的依赖项。
- en: As you can see, instead of `tasks`, we are now simply referencing `roles`. It
    is very neat and organized, and much easier to understand what the playbook is
    set out to do. If you want to understand what a specific role does, all you need
    to do is look into the `roles` directory for the name of the respective role and
    examine the `main.yml` file in the role’s `tasks` folder.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，我们现在不再引用 `tasks`，而是直接引用 `roles`。这种方式非常整洁有序，也更容易理解剧本的目的。如果你想了解某个特定角色的功能，只需进入
    `roles` 目录，找到相应角色的名称，并查看该角色 `tasks` 文件夹中的 `main.yml` 文件。
- en: 'When you’re ready, run the playbook just as you normally would:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 当你准备好时，像往常一样运行剧本：
- en: '[PRE11]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: If all went well, it should have accomplished everything that was being done
    in our original playbook; however, this time around we are using Ansible roles,
    and thus our playbook will be far easier to maintain going forward.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一切顺利，它应该已经完成了我们原本剧本中所做的所有工作；然而，这次我们使用的是 Ansible 角色，因此我们的剧本在未来将更容易维护。
- en: The source code for this recipe can be found at [https://github.com/PacktPublishing/Oracle-Linux-Cookbook/tree/main/ch8/ansible-roles](https://github.com/PacktPublishing/Oracle-Linux-Cookbook/tree/main/ch8/ansible-roles).
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 本食谱的源代码可以在[https://github.com/PacktPublishing/Oracle-Linux-Cookbook/tree/main/ch8/ansible-roles](https://github.com/PacktPublishing/Oracle-Linux-Cookbook/tree/main/ch8/ansible-roles)找到。
- en: Managing secrets with Ansible Vault
  id: totrans-207
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Ansible Vault 管理机密
- en: This recipe aims to provide guidance on leveraging **Ansible Vault** for *secrets
    management*.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 本食谱旨在提供关于如何利用**Ansible Vault**进行*机密管理*的指导。
- en: There are multiple ways to store secrets in Ansible. When starting out, you
    may be inclined to encrypt the entire `hosts` file. This works and keeps everything
    secure in the context of using a version control system without compromising your
    secrets/passwords; however, it is not manageable, nor does it provide any useful
    information in version control systems because all you’re left with is a long
    nonsensical string of encrypted characters.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Ansible 中存储机密有多种方法。刚开始时，你可能倾向于加密整个`hosts`文件。这种方法有效，并且在使用版本控制系统的上下文中保持所有内容安全，而不会泄露你的机密/密码；然而，它不可管理，也无法在版本控制系统中提供任何有用的信息，因为你剩下的只是一串长而毫无意义的加密字符。
- en: Getting started
  id: totrans-210
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 入门
- en: 'You will need the following for this recipe:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 你需要以下内容来完成这个操作：
- en: Oracle Linux
  id: totrans-212
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Oracle Linux
- en: Ansible
  id: totrans-213
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Ansible
- en: Refer to the *Technical requirements* section at the beginning of this chapter
    if you need help installing Ansible.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你需要帮助安装 Ansible，请参考本章开头的*技术要求*部分。
- en: How to do it…
  id: totrans-215
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作…
- en: First, let’s take a look at whole-file encryption. To begin, we’ll first need
    to define our Ansible host file in plain text.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们看看整个文件加密。首先，我们需要在明文中定义我们的 Ansible 主机文件。
- en: Whole-file encryption
  id: totrans-217
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 整个文件加密
- en: 'Typically, an Ansible hosts file will look something like this:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，Ansible 主机文件看起来像这样：
- en: '[PRE12]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'You can encrypt the file by running the following into the terminal/console:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过在终端/控制台中运行以下命令来加密文件：
- en: '[PRE13]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: I am using a randomly generated string as my vault password.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 我正在使用一个随机生成的字符串作为我的 vault 密码。
- en: Another way to encrypt the file is to use a `vault_password` and paste only
    the vault password into it.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 加密文件的另一种方式是使用`vault_password`，并将密码粘贴到其中。
- en: Note
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: It’s a good idea to set the permissions to `0600` on the `vault_password` file
    (this can be done by running `chmod 0600 ./vault_password`) so it’s protected
    from other users.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 最好将`vault_password`文件的权限设置为`0600`（可以通过运行`chmod 0600 ./vault_password`来实现），以保护它不被其他用户访问。
- en: 'Now, instead of using `--ask-vault-pass`, you can use the following:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，不再使用`--ask-vault-pass`，你可以使用以下命令：
- en: '[PRE14]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Cool! Just be sure to add the `vault_password` file to your `.gitignore` list
    to avoid checking that into version control.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 很棒！只要确保将`vault_password`文件添加到`.gitignore`列表中，以避免将其提交到版本控制中。
- en: 'Now if you `cat` your `hosts` file, you will see the contents are encrypted:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果你`cat`你的`hosts`文件，你会看到内容已被加密：
- en: '![Figure 8.22 – Contents of encrypted “hosts” file](img/B18349_08_22.jpg)'
  id: totrans-230
  prefs: []
  type: TYPE_IMG
  zh: '![图8.22 – 加密“hosts”文件的内容](img/B18349_08_22.jpg)'
- en: Figure 8.22 – Contents of encrypted “hosts” file
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.22 – 加密“hosts”文件的内容
- en: 'This is great, but anytime you need to make changes to the `hosts` file, you
    are faced with two options:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 这很好，但每当你需要修改`hosts`文件时，你面临两种选择：
- en: Decrypt the `hosts` file, make your changes, then encrypt it again
  id: totrans-233
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 解密`hosts`文件，进行更改，然后再次加密
- en: Use `ansible-vault edit hosts` to leverage ansible-vault’s *vim* mode to edit
    the file
  id: totrans-234
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`ansible-vault edit hosts`来利用 ansible-vault 的*vim*模式编辑文件
- en: These aren’t terrible options, but in practice this can become cumbersome. I
    propose a better way, which is to use the `encrypt_string` method within Ansible
    Vault to encrypt only the sensitive data, and use variables in place of passwords/secrets
    to reference those encrypted strings.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 这些选项并不糟糕，但实际上这可能会变得很繁琐。我建议一种更好的方法，即在 Ansible Vault 中使用`encrypt_string`方法，仅加密敏感数据，并使用变量代替密码/密钥来引用这些加密的字符串。
- en: Hiding passwords in plain sight
  id: totrans-236
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 将密码公然隐藏
- en: 'Hiding passwords in plain sight is in direct contrast to the whole-file encryption
    we described previously. We’re still going to encrypt our sensitive data, but
    this time around we’ll encrypt *only* the sensitive data, and leave everything
    else in plain, unencrypted text:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 将密码明文隐藏在明处与我们之前描述的整个文件加密直接相反。我们仍将加密我们的敏感数据，但这一次我们将*仅*加密敏感数据，而将其他所有内容保留在明文未加密状态：
- en: We will use the `encrypt_string` method. In this example, the password we want
    to encrypt is `B@by-Y0dA` and we will name the variable that identifies this password
    as `admin_password`.
  id: totrans-238
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将使用`encrypt_string`方法。在本示例中，我们要加密的密码是`B@by-Y0dA`，我们将使用标识此密码的变量命名为`admin_password`。
- en: '[PRE15]'
  id: totrans-239
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '![Figure 8.23 – Encrypting secrets](img/B18349_08_23.jpg)'
  id: totrans-240
  prefs: []
  type: TYPE_IMG
  zh: '![图 8.23 – 加密密码](img/B18349_08_23.jpg)'
- en: Figure 8.23 – Encrypting secrets
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.23 – 加密密码
- en: 'Next, we need to copy the output of that into a `secrets.yml` file (you could
    just append `>> secrets.yml` to the command entered previously to automatically
    copy the output to the file). Here''s an example:'
  id: totrans-242
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们需要将其输出到`secrets.yml`文件中（您可以简单地将`>> secrets.yml`追加到之前输入的命令中，以自动将输出复制到文件中）。这是一个示例：
- en: '[PRE16]'
  id: totrans-243
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: '![Figure 8.24 – Contents of secrets.yml file](img/B18349_08_24.jpg)'
  id: totrans-244
  prefs: []
  type: TYPE_IMG
  zh: '![图 8.24 – secrets.yml 文件内容](img/B18349_08_24.jpg)'
- en: Figure 8.24 – Contents of secrets.yml file
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.24 – secrets.yml 文件内容
- en: Important note
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: You may notice the encrypted value is different every time you run the command,
    even when you encrypt the same value using the same password. The random salt
    changes each time you encrypt it; this is by design, and the intent is to ensure
    that the final encrypted output is never the same (even when using the same content).
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 每次运行命令时，您可能会注意到加密后的值都不相同，即使使用相同的密码加密相同的值也是如此。每次加密时会改变随机盐；这是有意设计的，目的是确保最终加密输出永远不相同（即使使用相同内容）。
- en: 'Now that you have it encrypted, you can replace the `ansible_password` value
    in your host file with the name of the variable that references the password (in
    this case, `admin_password`):'
  id: totrans-248
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在您已加密，可以将主机文件中的 `ansible_password` 值替换为引用密码的变量名称（在本例中为 `admin_password`）：
- en: '[PRE17]'
  id: totrans-249
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Note
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: The advantage of **variable-level encryption** is that files can still easily
    be read and understood because there will be a mixture of plaintext alongside
    the encrypted variables.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: '**变量级加密**的优点在于文件仍然可以轻松阅读和理解，因为在加密变量旁边会有明文混合存在。'
- en: The source code for this recipe can be found at [https://github.com/PacktPublishing/Oracle-Linux-Cookbook/tree/main/ch8/ansible-vault](https://github.com/PacktPublishing/Oracle-Linux-Cookbook/tree/main/ch8/ansible-vault).
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 此配方的源代码可在 [https://github.com/PacktPublishing/Oracle-Linux-Cookbook/tree/main/ch8/ansible-vault](https://github.com/PacktPublishing/Oracle-Linux-Cookbook/tree/main/ch8/ansible-vault)
    找到。
- en: Cooking up the perfect lab environment with Vagrant
  id: totrans-253
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 用 Vagrant 打造完美的实验环境
- en: Recently at work, I was tasked with preparing a demo of **Oracle Linux Manager**
    and showcasing several features of the software. This is an easy enough thing
    to do, but there are several barriers to entry that stand in the way before you
    can access the web GUI for Oracle Linux Manager.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 最近在工作中，我被要求准备一个 **Oracle Linux Manager** 的演示，并展示软件的几个特性。这本来是一件容易的事情，但在您访问 Oracle
    Linux Manager 的 Web GUI 之前，有几个入门障碍需要克服。
- en: For starters, Oracle Linux Manager requires Oracle Linux 7; it’s not yet certified
    on Oracle Linux 8\. So, I set out to download the ISO for Oracle Linux 7 and proceeded
    to create a VM in VirtualBox and installed the OS. I then wanted to SSH into the
    box, so I had to go into the settings menu for that VM and configure port forwarding
    from the host to the guest. At this point, I was able to SSH in, and then followed
    the installation instructions for Oracle Linux Manager. It’s not that bad setting
    things up, but there were several speed-bumps along the way. For instance, I needed
    to decide on a database to use. Oracle supports only Oracle Database for use with
    Oracle Linux Manager, but for the sake of brevity (and since this was only ever
    intended as a lab demonstration of Oracle Linux Manager), I decided to use **PostgreSQL**.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，Oracle Linux Manager 需要 Oracle Linux 7；它尚未在 Oracle Linux 8 上认证。因此，我开始下载 Oracle
    Linux 7 的 ISO 并在 VirtualBox 中创建虚拟机并安装操作系统。然后我想要 SSH 进入该虚拟机，因此我不得不进入虚拟机的设置菜单，并配置主机到客户机的端口转发。此时，我能够成功
    SSH 登录，并按照 Oracle Linux Manager 的安装说明进行操作。设置起来并不是太糟糕，但中途出现了几个阻碍。例如，我需要决定使用哪个数据库。Oracle
    仅支持将 Oracle 数据库与 Oracle Linux Manager 配合使用，但为了简洁起见（并且因为这只是 Oracle Linux Manager
    的实验演示），我决定使用 **PostgreSQL**。
- en: With so many manual steps, I’d be inclined to keep my newly created virtual
    machine and take care of it like a pet. They say containers are like cattle, and
    virtual machines are like pets. That is, until you’ve started using tools like
    Vagrant. Vagrant does a good job making your virtual machines blend in with the
    cattle – thanks to how easy it is to recreate your virtual machines using Vagrant,
    you no longer need to care for them the way you had to previously if you weren’t
    using Vagrant.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 由于手动步骤繁多，我倾向于把我新创建的虚拟机当做宠物来照顾。人们常说容器像牛群，虚拟机像宠物。也就是说，直到你开始使用像Vagrant这样的工具。Vagrant做得很好，它让你的虚拟机和牛群融合在一起——感谢Vagrant让你能够轻松地重建虚拟机，你不再需要像以前那样照顾它们，尤其是当你不使用Vagrant时。
- en: This recipe will walk you through the process of creating a lab environment
    using **Vagrant**.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 本教程将指导你创建一个使用**Vagrant**的实验环境。
- en: Getting ready
  id: totrans-258
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'You will need the following for this recipe:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 你将需要以下内容来完成本教程：
- en: Oracle Linux
  id: totrans-260
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Oracle Linux
- en: Oracle VM VirtualBox
  id: totrans-261
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Oracle VM VirtualBox
- en: Vagrant
  id: totrans-262
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Vagrant
- en: Refer to the *Technical requirements* section at the beginning of this chapter
    if you need help installing Oracle VM VirtualBox and Vagrant.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你需要帮助安装Oracle VM VirtualBox和Vagrant，请参阅本章开始的*技术要求*部分。
- en: How to do it…
  id: totrans-264
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作……
- en: 'Vagrant is a tool used for managing the lifecycle of virtual machines. In this
    recipe, we’re going to create a Vagrant box that automatically installs and configures
    Oracle Linux Manager. Oracle Linux Manager requires Oracle Linux 7\. In this case,
    we can use the official **Oracle Linux 7 Vagrant Box** as our base:'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: Vagrant是一个用于管理虚拟机生命周期的工具。在本指南中，我们将创建一个Vagrant盒子，它会自动安装并配置Oracle Linux Manager。Oracle
    Linux Manager需要Oracle Linux 7。在这种情况下，我们可以使用官方的**Oracle Linux 7 Vagrant Box**作为基础：
- en: '[PRE18]'
  id: totrans-266
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Great, that has pulled in a nice base file for us to start with. Let’s look
    at the `Vagrantfile` file to see what’s inside:'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 很好，这已经为我们拉取了一个不错的基础文件。让我们看看`Vagrantfile`文件，看看里面有什么：
- en: '[PRE19]'
  id: totrans-268
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: The actual `Vagrantfile` generated by the `init` command contains 69 lines of
    code, but 65 of those lines are comments, hence I removed them to help make this
    recipe more easily comprehensible.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，由`init`命令生成的`Vagrantfile`包含69行代码，但其中65行是注释，因此我将它们移除，以帮助使这篇指南更容易理解。
- en: As we can see from this `Vagrantfile`, all we need is those four lines to launch
    an Oracle Linux 7 instance in `vagrant up` command and when it’s up and running,
    you can simply enter the `vagrant ssh` command to access the VM and see how it
    works. Once finished, type `vagrant destroy` to bring down the VM. Now, let’s
    dive into ways to make this more useful; because I want to be able to type `vagrant
    up` and have not only an Oracle Linux VM, but also want that same command to result
    in a working copy of Oracle Linux Manager.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们从这个`Vagrantfile`中看到的，启动Oracle Linux 7实例只需要这四行命令，当它启动并运行时，你只需输入`vagrant ssh`命令即可访问虚拟机并查看它如何工作。完成后，输入`vagrant
    destroy`命令以销毁虚拟机。现在，让我们深入研究如何使这更有用；因为我希望能够输入`vagrant up`，不仅启动一个Oracle Linux虚拟机，还希望同样的命令启动一个可以工作的Oracle
    Linux Manager副本。
- en: First things first, let’s review the installation and configuration instructions
    for Oracle Linux Manager – this can be found at [https://docs.oracle.com/en/operating-systems/oracle-linux-manager/2.10/install/#Oracle-Linux-Manager](https://docs.oracle.com/en/operating-systems/oracle-linux-manager/2.10/install/#Oracle-Linux-Manager).
    Since we aren’t using an Oracle database, we will divert slightly from the instructions
    outlined – this means we’ll skip anything related to Oracle databases (for example,
    we won’t need the Oracle Instant Client and *SQL*Plus* packages).
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们回顾一下Oracle Linux Manager的安装和配置说明——这些可以在[https://docs.oracle.com/en/operating-systems/oracle-linux-manager/2.10/install/#Oracle-Linux-Manager](https://docs.oracle.com/en/operating-systems/oracle-linux-manager/2.10/install/#Oracle-Linux-Manager)找到。由于我们不使用Oracle数据库，我们将稍微偏离这些说明——这意味着我们将跳过与Oracle数据库相关的内容（例如，我们不需要Oracle
    Instant Client和*SQL*Plus*包）。
- en: 'To illustrate what we’re going to do, I’ll list all the steps from the guide,
    applying **bold** style to the steps we want to keep. The ones that are not bold
    will be skipped:'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 为了说明我们将要做的事情，我将列出指南中的所有步骤，并将我们要保留的步骤用**粗体**标出。那些没有加粗的步骤将被跳过：
- en: '`sudo yum install` `oracle-instantclient18.5-basic-18.5.0.0.0-3.x86_64.rpm
    oracle-instantclient18.5-sqlplus-18.5.0.0.0-3.x86_64.rpm`'
  id: totrans-273
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`sudo yum install` `oracle-instantclient18.5-basic-18.5.0.0.0-3.x86_64.rpm
    oracle-instantclient18.5-sqlplus-18.5.0.0.0-3.x86_64.rpm`'
- en: '`echo "/usr/lib/oracle/18.5/client64/lib" | sudo` `tee /etc/ld.so.conf.d/oracle-instantclient18.5.conf`'
  id: totrans-274
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`echo "/usr/lib/oracle/18.5/client64/lib" | sudo` `tee /etc/ld.so.conf.d/oracle-instantclient18.5.conf`'
- en: '`sudo ldconfig`'
  id: totrans-275
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`sudo ldconfig`'
- en: '**sudo yum list installed |** **grep jta**'
  id: totrans-276
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**sudo yum list installed |** **grep jta**'
- en: '**sudo yum** **remove jta**'
  id: totrans-277
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**sudo yum** **remove jta**'
- en: '**echo «exclude=jta*» >> /****etc/yum.conf**'
  id: totrans-278
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**echo «exclude=jta*» >> /****etc/yum.conf**'
- en: '**sudo yum-config-manager –****disable ol7_addons**'
  id: totrans-279
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**sudo yum-config-manager –****disable ol7_addons**'
- en: '`sudo firewall-cmd --``permanent --add-port=69/udp`'
  id: totrans-280
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`sudo firewall-cmd --``permanent --add-port=69/udp`'
- en: '`sudo firewall-cmd --``permanent --add-port=80/tcp`'
  id: totrans-281
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`sudo firewall-cmd --``permanent --add-port=80/tcp`'
- en: '`sudo firewall-cmd --``permanent --add-port=443/tcp`'
  id: totrans-282
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`sudo firewall-cmd --``permanent --add-port=443/tcp`'
- en: '`sudo firewall-cmd --``permanent --add-port=5222/tcp`'
  id: totrans-283
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`sudo firewall-cmd --``permanent --add-port=5222/tcp`'
- en: '`sudo firewall-cmd --``permanent --add-port=5269/tcp`'
  id: totrans-284
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`sudo firewall-cmd --``permanent --add-port=5269/tcp`'
- en: '`sudo systemctl` `reload firewalld`'
  id: totrans-285
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`sudo systemctl` `reload firewalld`'
- en: '**sudo yum** **install oracle-release-el7**'
  id: totrans-286
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**sudo yum** **install oracle-release-el7**'
- en: '**sudo yum** **install oracle-linux-manager-server-release-el7**'
  id: totrans-287
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**sudo yum** **install oracle-linux-manager-server-release-el7**'
- en: '**sudo yum-config-manager --****enable ol7_optional_latest**'
  id: totrans-288
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**sudo yum-config-manager --****enable ol7_optional_latest**'
- en: '`spacewalk-oracle` **spacecmd spacewalk-utils**'
  id: totrans-289
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`spacewalk-oracle` **spacecmd spacewalk-utils**'
- en: '`sudo` `spacewalk-setup --external-oracle`'
  id: totrans-290
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`sudo` `spacewalk-setup --external-oracle`'
- en: 'And that’s basically it. The following is for additional changes that we need
    to make to use Oracle Linux Manager with PostgreSQL:'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 就这些了。以下是我们需要做出的其他更改，以便将Oracle Linux Manager与PostgreSQL一起使用：
- en: '[PRE20]'
  id: totrans-292
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Finally, we’ll need to provide an answer file since the automation we’re doing
    in Vagrant cannot be interactive:'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们需要提供一个答案文件，因为我们在Vagrant中进行的自动化不能进行交互式操作：
- en: '[PRE21]'
  id: totrans-294
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Create a file named `answer-file.txt` and place the following content into
    the file:'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个名为`answer-file.txt`的文件，并将以下内容放入该文件：
- en: '[PRE22]'
  id: totrans-296
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: This summarizes the bulk of the installation and configuration steps. Next,
    in order to make all of this work so that we can deploy and provision Oracle Linux
    Manager automatically using Vagrant, we need to make some very simple changes.
    All we really need to do is paste those steps into a *Bash shell script* file
    and tell Vagrant to use a provisioner to run these commands on the box. Also,
    again, since automation cannot be interactive, we just need to add `-y` to all
    the `yum` commands.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 这总结了大部分安装和配置步骤。接下来，为了使这些操作能够正常工作，以便我们可以通过Vagrant自动部署和配置Oracle Linux Manager，我们需要进行一些非常简单的修改。我们真正需要做的就是将这些步骤粘贴到一个*Bash
    shell脚本*文件中，并告诉Vagrant使用一个提供者在虚拟机上运行这些命令。同样，由于自动化不能进行交互操作，我们只需要在所有`yum`命令中添加`-y`。
- en: 'Therefore, to clean things up and prepare them for Vagrant, our Bash script
    will look something like this:'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，为了清理并为Vagrant做好准备，我们的Bash脚本将类似于以下内容：
- en: '[PRE23]'
  id: totrans-299
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Note
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: At some point while authoring this recipe, an update was made to the spacewalk-schema
    package making it no longer compatible with PostgreSQL. This can be fixed by pinning
    the spacewalk-schema package to `spacewalk-schema-2.10.14-1.el7` as shown in the
    preceding snippet.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 在编写本食谱的过程中，spacewalk-schema包做出了更新，导致其不再与PostgreSQL兼容。通过将spacewalk-schema包固定到`spacewalk-schema-2.10.14-1.el7`，如前面的代码片段所示，可以解决这个问题。
- en: I removed the call to `sudo` for each step since everything runs as root during
    the provisioning phase of Vagrant.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 我删除了每个步骤中的`sudo`调用，因为在Vagrant的配置阶段，一切都以root身份运行。
- en: 'Now for the `Vagrantfile`, add a few lines so that Vagrant can copy the `answer-file.txt`
    file to the guest machine, then tell Vagrant to execute the script we just wrote.
    We’ll also create a private network, which allows host-only access to the machine
    using a specific IP (this will allow us to easily access Oracle Linux Manager
    via our web browser):'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，对于`Vagrantfile`，我们添加几行代码，以便Vagrant可以将`answer-file.txt`文件复制到虚拟机上，然后告诉Vagrant执行我们刚刚编写的脚本。我们还将创建一个私有网络，允许通过特定的IP进行主机仅访问（这将使我们可以通过网页浏览器轻松访问Oracle
    Linux Manager）：
- en: "![F\uFEFFigure 8.25 – Vagrant file for deploying OLM](img/B18349_08_25.jpg)"
  id: totrans-304
  prefs: []
  type: TYPE_IMG
  zh: '![图8.25 – 用于部署OLM的Vagrant文件](img/B18349_08_25.jpg)'
- en: Figure 8.25 – Vagrant file for deploying OLM
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.25 – 用于部署OLM的Vagrant文件
- en: Note
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: On Linux/Unix-based systems, VirtualBox will only allow IP addresses in `192.168.56.0/21`
    range to be assigned to host-only adapters. This allows for IP addresses starting
    at `192.168.56.1` and ending at `192.168.63.254`.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 在Linux/Unix系统上，VirtualBox只允许将`192.168.56.0/21`范围内的IP地址分配给主机专用适配器。这允许从`192.168.56.1`开始的IP地址，直到`192.168.63.254`。
- en: 'Now we can review what our directory should look like:'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以查看我们的目录应该是什么样子的：
- en: '[PRE24]'
  id: totrans-309
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'We’re ready to fire things up:'
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 我们准备好启动了：
- en: '[PRE25]'
  id: totrans-311
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: You’ll watch as the provisioning script installs and configures Oracle Linux
    Manager, and within a matter of minutes, you’ll be able to point your browser
    to the IP address defined for the virtual machine to access Oracle Linux Manager.
    The best part about this is everything is **defined as code**. Everything we created
    in this recipe amounts to just 6 KB in size! Vagrant does an amazing job at solving
    the classic “*it works on my machine*” problem. You can take these 6 KB of code
    and deploy your work on any machine (Mac, Windows, Linux, etc.) – all you need
    is Vagrant and Oracle VM VirtualBox.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 你将看到配置脚本安装并配置Oracle Linux Manager，并且在短短几分钟内，你就能够通过浏览器访问虚拟机所定义的IP地址来访问Oracle
    Linux Manager。最棒的是，这一切都是**以代码形式定义**的。我们在本教程中创建的一切总共仅有6 KB大小！Vagrant在解决经典的“*它在我的机器上能用*”问题方面做得非常出色。你可以将这6
    KB的代码部署到任何机器上（Mac、Windows、Linux等）——所需要的只是Vagrant和Oracle VM VirtualBox。
- en: 'We could take this automation a few steps further to make it even more useful.
    For example, we could automate the creation of the first user for Oracle Linux
    Manager, automatically create the channels, repositories, and activation keys,
    then create clients for OLM and connect to them automatically. Getting into the
    details for all that is beyond the scope of this recipe, but if you’re interested
    in seeing how this is done, I’ve got the solution published on GitHub – you can
    find that here: [https://github.com/PacktPublishing/Oracle-Linux-Cookbook/tree/main/ch8/vagrant](https://github.com/PacktPublishing/Oracle-Linux-Cookbook/tree/main/ch8/vagrant).'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将这个自动化过程更进一步，使其更加有用。例如，我们可以自动化为Oracle Linux Manager创建第一个用户，自动创建频道、仓库和激活密钥，然后为OLM创建客户端并自动连接它们。深入讨论这些细节超出了本教程的范围，但如果你有兴趣了解如何实现，我已经将解决方案发布在GitHub上——你可以在这里找到：[https://github.com/PacktPublishing/Oracle-Linux-Cookbook/tree/main/ch8/vagrant](https://github.com/PacktPublishing/Oracle-Linux-Cookbook/tree/main/ch8/vagrant)。
- en: Using Packer to modify source images
  id: totrans-314
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Packer修改源镜像
- en: Packer is a tool used for automating the creation of machine images. In this
    recipe, we’re going to use Packer to reference an **Oracle Linux 8** platform
    image as its source, install something using a provisioner, and push up a new
    OCID image with these changes onto OCI.
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: Packer是一个用于自动化创建机器镜像的工具。在本教程中，我们将使用Packer引用一个**Oracle Linux 8**平台镜像作为源，使用配置器安装某些内容，并将这些更改推送到OCI中，创建一个新的OCID镜像。
- en: Note
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Although OCI features a free tier that contains “Always Free” resources, this
    does not include the ability to store images. If you wish to follow along with
    this recipe, you will need to use a paid account.
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管OCI提供了一个包含“永久免费”资源的免费层，但这不包括存储镜像的能力。如果你希望跟随本教程，你需要使用一个付费账户。
- en: Getting ready
  id: totrans-318
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'For this recipe, you will need the following:'
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 本教程需要以下内容：
- en: Oracle Linux
  id: totrans-320
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Oracle Linux
- en: Packer
  id: totrans-321
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Packer
- en: Refer to the *Technical requirements* section at the beginning of this chapter
    if you need help installing Packer.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你需要帮助安装Packer，请参考本章开头的*技术要求*部分。
- en: How to do it…
  id: totrans-323
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作…
- en: 'Packer is often overlooked because it seems so simple on the surface; however,
    don’t let this simplicity fool you – Packer is incredibly powerful and useful.
    In this recipe, we’re going to use Packer to reference some release of Oracle
    Linux 8 as its base image, install something using a provisioner, and push up
    a new OCID image with these changes onto the OCI:'
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: Packer常常被忽视，因为它看起来非常简单；然而，不要让这种简单性愚弄了你——Packer非常强大且有用。在本教程中，我们将使用Packer引用某个版本的Oracle
    Linux 8作为基础镜像，使用一个配置器安装某些内容，并将这些更改推送到OCI中，创建一个新的OCID镜像：
- en: 'First, we will specify a Packer plugin that provides a builder called `oracle-oci`,
    which enables Packer to create machine images for OCI. We can do that in a file
    named `oracle-oci.pkr.hcl`. Input the following at the beginning of the file:'
  id: totrans-325
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们将指定一个提供名为`oracle-oci`的构建器的Packer插件，该构建器使Packer能够为OCI创建机器镜像。我们可以在名为`oracle-oci.pkr.hcl`的文件中完成此操作。在文件开头输入以下内容：
- en: '![Figure 8.26 – Packer OCI builder plugin](img/B18349_08_26.jpg)'
  id: totrans-326
  prefs: []
  type: TYPE_IMG
  zh: '![图 8.26 – Packer OCI 构建器插件](img/B18349_08_26.jpg)'
- en: Figure 8.26 – Packer OCI builder plugin
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.26 – Packer OCI 构建器插件
- en: 'Next, we will configure our authentication to OCI using the configuration options
    specified by the `oracle-oci` builder. Details on configuring the `oracle-oci`
    builder can be reviewed at [https://developer.hashicorp.com/packer/plugins/builders/oracle/oci](https://developer.hashicorp.com/packer/plugins/builders/oracle/oci):'
  id: totrans-328
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们将使用 `oracle-oci` 构建器指定的配置选项来配置我们的 OCI 认证。有关配置 `oracle-oci` 构建器的详细信息，可以查看
    [https://developer.hashicorp.com/packer/plugins/builders/oracle/oci](https://developer.hashicorp.com/packer/plugins/builders/oracle/oci)：
- en: 'There are numerous ways to do this. One way is to reference variables for the
    authentication details directly in your `*.pkr.hcl` file, like this:'
  id: totrans-329
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有许多方法可以做到这一点。一种方法是直接在你的 `*.pkr.hcl` 文件中引用用于认证的变量，像这样：
- en: '![Figure 8.27 – Referencing variables in Packer](img/B18349_08_27.jpg)'
  id: totrans-330
  prefs: []
  type: TYPE_IMG
  zh: '![图 8.27 – 在 Packer 中引用变量](img/B18349_08_27.jpg)'
- en: Figure 8.27 – Referencing variables in Packer
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.27 – 在 Packer 中引用变量
- en: 'Then, we need to declare all of those variables in a file named `variables.pkr.hcl`.
    In this file, we declare the variable and specify the type, as well as providing
    a description to explain the purpose of the variable. Input the following into
    your `variables.pkr.hcl` file:'
  id: totrans-332
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 然后，我们需要在名为 `variables.pkr.hcl` 的文件中声明所有这些变量。在这个文件中，我们声明变量并指定类型，同时提供一个描述来解释变量的目的。将以下内容输入到你的
    `variables.pkr.hcl` 文件中：
- en: '![Figure 8.28 – Declaration of variables in Packer](img/B18349_08_28.jpg)'
  id: totrans-333
  prefs: []
  type: TYPE_IMG
  zh: '![图 8.28 – 在 Packer 中声明变量](img/B18349_08_28.jpg)'
- en: Figure 8.28 – Declaration of variables in Packer
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.28 – 在 Packer 中声明变量
- en: 'Finally, we want to assign values to the variables. We place them in a file
    named `variables.auto.pkrvars.hcl`. It should look something like this:'
  id: totrans-335
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后，我们要为变量分配值。我们将它们放在名为 `variables.auto.pkrvars.hcl` 的文件中。它应该看起来像这样：
- en: '![Figure 8.29 – Assigning variables in Packer](img/B18349_08_29.jpg)'
  id: totrans-336
  prefs: []
  type: TYPE_IMG
  zh: '![图 8.29 – 在 Packer 中分配变量](img/B18349_08_29.jpg)'
- en: Figure 8.29 – Assigning variables in Packer
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.29 – 在 Packer 中分配变量
- en: 'Another way is to configure your OCI CLI in `~/.oci/config`. That would look
    something like this:'
  id: totrans-338
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 另一种方法是配置你的 OCI CLI，在 `~/.oci/config` 文件中。这看起来像这样：
- en: '[PRE26]'
  id: totrans-339
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Note
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: 'Full details on configuring your OCI CLI can be found here: [https://docs.oracle.com/en-us/iaas/Content/API/Concepts/sdkconfig.htm](https://docs.oracle.com/en-us/iaas/Content/API/Concepts/sdkconfig.htm)'
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 关于配置 OCI CLI 的完整详细信息可以在这里找到：[https://docs.oracle.com/en-us/iaas/Content/API/Concepts/sdkconfig.htm](https://docs.oracle.com/en-us/iaas/Content/API/Concepts/sdkconfig.htm)
- en: 'Once you have the authentication configured, you can start by defining the
    base image. This should look something like the following:'
  id: totrans-342
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦你配置了认证，你可以开始定义基础镜像。它应该看起来像下面这样：
- en: '![Figure 8.30 –  Defining the base image in Packer](img/B18349_08_30.jpg)'
  id: totrans-343
  prefs: []
  type: TYPE_IMG
  zh: '![图 8.30 – 在 Packer 中定义基础镜像](img/B18349_08_30.jpg)'
- en: Figure 8.30 – Defining the base image in Packer
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.30 – 在 Packer 中定义基础镜像
- en: Note
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: 'To get the OCID for Oracle Linux 8, visit the following URL: [https://docs.oracle.com/en-us/iaas/images/oracle-linux-8x/](https://docs.oracle.com/en-us/iaas/images/oracle-linux-8x/).
    This is region specific as well as architecture specific, so you’ll want to find
    the latest Oracle Linux 8 image for x86 (or in other words, look for one without
    `aarch64` mentioned in the image name).'
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 要获取 Oracle Linux 8 的 OCID，请访问以下网址：[https://docs.oracle.com/en-us/iaas/images/oracle-linux-8x/](https://docs.oracle.com/en-us/iaas/images/oracle-linux-8x/)。这不仅与区域相关，还与架构相关，因此你需要查找适用于
    x86 的最新 Oracle Linux 8 镜像（换句话说，寻找镜像名称中没有 `aarch64` 的版本）。
- en: 'Once you’ve defined the source, you can move on to instructing Packer on what
    to do during the build process. In this case, we’ll call a provisioner so we can
    run a shell command to install Git:'
  id: totrans-347
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦你定义了源，你可以开始指导 Packer 在构建过程中该做什么。在这种情况下，我们将调用一个 provisioner，这样我们就可以运行一个 shell
    命令来安装 Git：
- en: '![Figure 8.31 – Packer provisioners](img/B18349_08_31.jpg)'
  id: totrans-348
  prefs: []
  type: TYPE_IMG
  zh: '![图 8.31 – Packer 的 provisioners](img/B18349_08_31.jpg)'
- en: Figure 8.31 – Packer provisioners
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.31 – Packer 的 provisioners
- en: 'At this point, we’ve told Packer about what we want to use for our source and
    described what we want to do for our build. Your entire file should look something
    like this:'
  id: totrans-350
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 到此为止，我们已经告诉 Packer 我们要使用什么源，并描述了我们在构建时希望做什么。你的完整文件应该像这样：
- en: '![Figure 8.32 – Complete Packer file for modifying base images](img/B18349_08_32.jpg)'
  id: totrans-351
  prefs: []
  type: TYPE_IMG
  zh: '![图 8.32 – 完整的 Packer 文件用于修改基础镜像](img/B18349_08_32.jpg)'
- en: Figure 8.32 – Complete Packer file for modifying base images
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.32 – 完整的 Packer 文件用于修改基础镜像
- en: Note
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: In the final file, I replaced the word `example` with `ol8u8` throughout to
    be a bit more descriptive about what I’m working with. This is simply a good form
    of self-documentation.
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 在最终文件中，我将 `example` 替换为 `ol8u8`，以便更清楚地描述我正在处理的内容。这只是良好的自我文档化方式。
- en: 'Next, we’re going to run `packer init` to download the external plugin:'
  id: totrans-355
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们将运行 `packer init` 来下载外部插件：
- en: '[PRE27]'
  id: totrans-356
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Finally, let’s go ahead and build the OCID image:'
  id: totrans-357
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，让我们继续构建 OCID 镜像：
- en: '[PRE28]'
  id: totrans-358
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: '![Figure 8.33 – Initial output after running packer build](img/B18349_08_33.jpg)'
  id: totrans-359
  prefs: []
  type: TYPE_IMG
  zh: '![图 8.33 – 运行 packer build 后的初始输出](img/B18349_08_33.jpg)'
- en: Figure 8.33 – Initial output after running packer build
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.33 – 运行 packer build 后的初始输出
- en: Once Git is installed, it will take a snapshot of the instance and export this
    as a new OCID image, giving us a new starting point for all future instances.
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 安装 Git 后，它将对实例进行快照，并将其导出为新的 OCID 镜像，为所有未来的实例提供一个新的起点。
- en: '![Figure 8.34 – Output as Packer completes the build process](img/B18349_08_34.jpg)'
  id: totrans-362
  prefs: []
  type: TYPE_IMG
  zh: '![图 8.34 – Packer 完成构建过程后的输出](img/B18349_08_34.jpg)'
- en: Figure 8.34 – Output as Packer completes the build process
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.34 – Packer 完成构建过程后的输出
- en: 'When Packer is finished, you can view the newly published image by navigating
    to the **Compute** | **Custom Images** on the OCI Console. Here’s an example of
    what that looks like:'
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: 当 Packer 完成时，您可以通过在 OCI 控制台中导航到 **计算** | **自定义镜像** 来查看新发布的镜像。以下是该界面的示例：
- en: '![Figure 8.35 – Viewing the recently published custom image on OCI](img/B18349_08_35.jpg)'
  id: totrans-365
  prefs: []
  type: TYPE_IMG
  zh: '![图 8.35 – 查看最近发布的自定义镜像](img/B18349_08_35.jpg)'
- en: Figure 8.35 – Viewing the recently published custom image on OCI
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.35 – 查看最近发布的自定义镜像
- en: The source code for this recipe can be found at [https://github.com/PacktPublishing/Oracle-Linux-Cookbook/tree/main/ch8/packer-cloud](https://github.com/PacktPublishing/Oracle-Linux-Cookbook/tree/main/ch8/packer-cloud).
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: 本食谱的源代码可以在 [https://github.com/PacktPublishing/Oracle-Linux-Cookbook/tree/main/ch8/packer-cloud](https://github.com/PacktPublishing/Oracle-Linux-Cookbook/tree/main/ch8/packer-cloud)
    找到。
- en: Pack it up, pack it in, let me begin, err, umm… build
  id: totrans-368
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 打包它，收起它，让我开始，嗯，呃……构建
- en: In this recipe, we’re going to use Packer to start from source media (such as
    an ISO) to create our very own Vagrant box from scratch.
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: 在本食谱中，我们将使用 Packer 从源媒体（如 ISO 文件）开始，从头创建我们的 Vagrant box。
- en: Getting started
  id: totrans-370
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 开始
- en: 'You will need the following for this recipe:'
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: 本食谱需要以下内容：
- en: Oracle Linux
  id: totrans-372
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Oracle Linux
- en: Oracle VM VirtualBox
  id: totrans-373
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Oracle VM VirtualBox
- en: Packer
  id: totrans-374
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Packer
- en: Refer to the *Technical requirements* section at the beginning of this chapter
    if you need help installing Oracle VM VirtualBox and Packer.
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: 如果需要帮助安装 Oracle VM VirtualBox 和 Packer，请参阅本章开头的 *技术要求* 部分。
- en: How to do it…
  id: totrans-376
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作……
- en: More often than not, you can search the Vagrant catalog and find pre-made **Vagrantfiles**
    containing the operating system you’re looking for. But what happens if what you
    need is not there? Or maybe you don’t trust the author of the Vagrantfile and/or
    you simply prefer to create your own. You can do this manually, or you can do
    this entirely with code, by leveraging Packer. In this recipe, we’ll use Packer
    to bake up a fresh Vagrant box from the Oracle Linux 8.8 source ISO. At a high
    level, Packer will download the ISO image for the operating system we wish to
    use, it will then spin up a VM using Oracle VM VirtualBox and install the VM.
    Afterward, it will export the VM in **Open Virtualization Format** (**OVF**).
    Finally, it will compress this file and convert it into a Vagrant box file.
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: 更常见的是，您可以在 Vagrant 目录中搜索并找到包含所需操作系统的预制 **Vagrantfiles**。但是如果您需要的内容没有呢？或者也许您不信任
    Vagrantfile 的作者和/或您更倾向于自己创建一个。您可以手动完成此操作，或者可以完全通过代码来实现，使用 Packer。在本食谱中，我们将使用 Packer
    从 Oracle Linux 8.8 源 ISO 创建一个全新的 Vagrant box。从高层次来看，Packer 将下载我们希望使用的操作系统的 ISO
    镜像，然后使用 Oracle VM VirtualBox 启动一个虚拟机并安装它。之后，它会将虚拟机导出为 **开放虚拟化格式**（**OVF**）。最后，它将压缩此文件并将其转换为
    Vagrant box 文件。
- en: Oracle Linux 8 kickstart file
  id: totrans-378
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Oracle Linux 8 kickstart 文件
- en: 'For this magic to work, you’ll need to provide a kickstart file to automate
    the installation of the ISO. You can create your own, or use one from the Oracle
    Linux Image Tools found in the official Oracle Linux repository on GitHub. For
    this recipe, I’ll be using one from the Oracle Linux Image Tools:'
  id: totrans-379
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了让这项操作生效，您需要提供一个 kickstart 文件来自动化 ISO 的安装。您可以自己创建一个，或者使用 Oracle Linux Image
    Tools 中的一个文件，该文件可以在 GitHub 上的官方 Oracle Linux 仓库中找到。在本食谱中，我将使用来自 Oracle Linux Image
    Tools 的一个文件：
- en: https://github.com/oracle/oracle-linux/blob/main/oracle-linux-image-tools/distr/ol8-slim/ol8-ks.cfg
  id: totrans-380
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: https://github.com/oracle/oracle-linux/blob/main/oracle-linux-image-tools/distr/ol8-slim/ol8-ks.cfg
- en: 'Now, to get started with this recipe, we’ll create a new directory called `ol8-vagrant`.
    In this directory, create a Packer file and name it `vagrant-ol8.pkr.hcl`, and
    go ahead and create a folder called `http` and place the kickstart file there.
    Once this is done, your file structure should look like this:'
  id: totrans-381
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，为了开始使用这个配置，我们将创建一个名为 `ol8-vagrant` 的新目录。在该目录下，创建一个 Packer 文件，并命名为 `vagrant-ol8.pkr.hcl`，然后创建一个名为
    `http` 的文件夹，并将 kickstart 文件放在其中。完成后，您的文件结构应如下所示：
- en: '[PRE29]'
  id: totrans-382
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: In our kickstart file, we just need to set the password for the root user. So,
    in this case, we’ll change the line that reads `rootpw --lock` to `rootpw --``plaintext
    vagrant`.
  id: totrans-383
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在我们的 kickstart 文件中，我们只需要设置 root 用户的密码。因此，在这种情况下，我们将 `rootpw --lock` 这一行修改为 `rootpw
    --``plaintext vagrant`。
- en: 'Next, we’ll go ahead and work on the `vagrant-ol8.pkr.hcl` file. The first
    thing we’ll need to do here is specify the plugins we’ll need. Let’s use the VirtualBox
    Builder since we want to create a VM from an ISO image, and the Vagrant Builder
    since we’re going to convert our OVF file into a Vagrant box file. These can be
    added by placing the following code into your Packer configuration file:'
  id: totrans-384
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们将继续处理 `vagrant-ol8.pkr.hcl` 文件。首先，我们需要指定我们需要的插件。由于我们想从 ISO 镜像创建虚拟机，所以使用
    VirtualBox Builder，另外由于我们要将 OVF 文件转换为 Vagrant box 文件，因此使用 Vagrant Builder。可以通过在
    Packer 配置文件中添加以下代码来完成这些设置：
- en: "![Figure 8.36 – Packer VirtualBox and Vagrant builder plu\uFEFFgins](img/B18349_08_36.jpg)"
  id: totrans-385
  prefs: []
  type: TYPE_IMG
  zh: '![图 8.36 – Packer VirtualBox 和 Vagrant 构建插件](img/B18349_08_36.jpg)'
- en: Figure 8.36 – Packer VirtualBox and Vagrant builder plugins
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.36 – Packer VirtualBox 和 Vagrant 构建插件
- en: 'Info:'
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: 信息：
- en: 'More info on the Packer VirtualBox plugin can be found here: [https://www.packer.io/plugins/builders/virtualbox](https://www.packer.io/plugins/builders/virtualbox).'
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: 有关 Packer VirtualBox 插件的更多信息，请访问：[https://www.packer.io/plugins/builders/virtualbox](https://www.packer.io/plugins/builders/virtualbox)。
- en: 'Now we need to define a source. In this case, we want to use the Oracle Linux
    8.8 ISO. Add the following to your `vagrant-ol8.pkr.hcl` file:'
  id: totrans-389
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们需要定义一个源。在这种情况下，我们希望使用 Oracle Linux 8.8 的 ISO。请将以下内容添加到 `vagrant-ol8.pkr.hcl`
    文件中：
- en: '![Figure 8.37 – Packer file for building Vagrant boxes](img/B18349_08_37.jpg)'
  id: totrans-390
  prefs: []
  type: TYPE_IMG
  zh: '![图 8.37 – 用于构建 Vagrant box 的 Packer 文件](img/B18349_08_37.jpg)'
- en: Figure 8.37 – Packer file for building Vagrant boxes
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.37 – 用于构建 Vagrant box 的 Packer 文件
- en: Important note
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: Notice the `modifyvm` command, which sets `--nat-localhostreachable1` to `on`.
    This is a new setting that is `off` by default in Oracle VM VirtualBox 7\. Setting
    this value to `on` fixes a networking issue that prevents Packer from sending
    the kickstart file to the VM. In other words, it’s important to include this if
    you’re using VirtualBox 7 to build your VM, but if you’re on VirtualBox 6, you’ll
    need to remove this line or your build will fail.
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: 注意 `modifyvm` 命令，它将 `--nat-localhostreachable1` 设置为 `on`。这是一个新的设置，在 Oracle VM
    VirtualBox 7 中默认是 `off`。将此值设置为 `on` 可以解决一个网络问题，防止 Packer 将 kickstart 文件发送到虚拟机。换句话说，如果你正在使用
    VirtualBox 7 来构建虚拟机，务必包含此设置，但如果你使用的是 VirtualBox 6，则需要移除此行，否则构建将失败。
- en: So, in the preceding code, we specified the `guest_os_type` as `"Oracle_64"`
    because we’re building from an Oracle Linux ISO. Next, we input the URL for the
    ISO as well as the checksum. For `ssh_username`, we’ll use `"root"` and for `ssh_password`,
    we’ll use `"vagrant"` because these are the defaults that Vagrant expects in order
    to make things easy – especially if you plan to distribute your box publicly.
    If you intend to keep your box for private use only, it is best to use different
    values, as this will keep the box more secure.
  id: totrans-394
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们将 `guest_os_type` 指定为 `"Oracle_64"`，因为我们是从 Oracle Linux ISO 构建虚拟机的。接下来，我们输入
    ISO 的 URL 以及校验和。对于 `ssh_username`，我们使用 `"root"`，对于 `ssh_password`，我们使用 `"vagrant"`，因为这些是
    Vagrant 默认的设置，旨在简化操作，特别是如果你计划公开发布你的 box。如果你打算将 box 保留为私人使用，最好使用不同的值，这样可以提高安全性。
- en: Info
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: 信息
- en: For more information on Vagrant usernames and passwords, visit [https://www.vagrantup.com/docs/boxes/base#vagrant-user](https://www.vagrantup.com/docs/boxes/base#vagrant-user).
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: 有关 Vagrant 用户名和密码的更多信息，请访问：[https://www.vagrantup.com/docs/boxes/base#vagrant-user](https://www.vagrantup.com/docs/boxes/base#vagrant-user)。
- en: We’ll set `headless` to `"true"` in order to prevent the virtual machine from
    starting the VirtualBox GUI. We increase the time for `ssh_wait_timeout` to give
    the operating system sufficient time to install and to get up and running. All
    of this is self-explanatory; that is, until we get to the `http_directory` setting.
  id: totrans-397
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将 `headless` 设置为 `"true"`，以防止虚拟机启动 VirtualBox GUI。我们将 `ssh_wait_timeout` 的时间增加，以给操作系统足够的时间进行安装并启动。一切都不言自明，直到我们遇到
    `http_directory` 设置。
- en: All you really need to know is that we’ll leverage the `http_directory` option
    as a convenient way to serve a directory using an HTTP server. It does this so
    that the boot command can point to a kickstart file – which we’ve placed in the
    `http` directory. `http://{{ .HTTPIP }}:{{ .HTTPPort }}/ol8-ks.cfg` tells the
    operating system exactly what it needs to reach the kickstart file. You don’t
    really need to worry about the syntax of `{{ .HTTPIP }}` and `{{ .HTTPPort }}`;
    these are just template variables that are processed by the Packer templating
    engine.
  id: totrans-398
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你需要知道的就是，我们将利用`http_directory`选项作为一种便捷的方式，通过HTTP服务器提供一个目录。这样做是为了让引导命令能够指向一个kickstart文件——我们已经将它放置在`http`目录中。`http://{{
    .HTTPIP }}:{{ .HTTPPort }}/ol8-ks.cfg`会告诉操作系统如何找到这个kickstart文件。你不需要担心`{{ .HTTPIP
    }}`和`{{ .HTTPPort }}`的语法，这些只是由Packer模板引擎处理的模板变量。
- en: For `nic_type`, the default value is `82540EM`, which equates to Intel PRO/1000
    MT Desktop. That’s a safe choice and is great when running old operating systems,
    but Oracle Linux 8 is a modern operating system so we’re setting this to `virtio`.
    VirtIO is a para-virtualized driver and will give us better networking performance
    in the VM.
  id: totrans-399
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于`nic_type`，默认值是`82540EM`，它等同于Intel PRO/1000 MT桌面版。这是一个安全的选择，非常适合运行旧操作系统，但Oracle
    Linux 8是一个现代操作系统，所以我们将其设置为`virtio`。VirtIO是一个准虚拟化驱动程序，它能为虚拟机提供更好的网络性能。
- en: Now, on to the `boot_command`. Basically, we need to figure out what sequence
    of key presses are required in order to send a boot command to the operating system
    at boot time. In the case of Oracle Linux 8, we send key presses of *up* and *Tab*,
    and then we send instructions on where to find the kickstart file, and finally
    we tell it to press *Enter* to begin installing the OS.
  id: totrans-400
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们来看看`boot_command`。基本上，我们需要弄清楚，在启动时，操作系统接收引导命令所需的按键序列。对于Oracle Linux 8，我们发送*up*和*Tab*键，然后发送指令以告知从哪里找到kickstart文件，最后我们告诉它按*Enter*键开始安装操作系统。
- en: For `vboxmanage`, I found that, by default, Packer tried to launch my VM with
    only 512 MB of memory, and that resulted in an error during the installation of
    the OS. In order to resolve this issue, I increased the memory to `2048`. I also
    gave it two CPUs just for good measure.
  id: totrans-401
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于`vboxmanage`，我发现默认情况下，Packer尝试以仅512MB内存启动我的虚拟机，这导致在操作系统安装时发生错误。为了解决这个问题，我将内存增加到`2048`。为了安全起见，我还为虚拟机分配了两个CPU。
- en: Finally, with the `shutdown_command`, we simply tell Packer how to shut down
    the system gracefully once all the provisioning is done. If we leave this blank
    Packer would forcefully shut down the machine.
  id: totrans-402
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，使用`shutdown_command`，我们只需告诉Packer如何在所有配置完成后优雅地关闭系统。如果我们留空此项，Packer会强制关闭机器。
- en: Info
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
  zh: 信息
- en: For a complete overview of available configuration options, see [https://www.packer.io/plugins/builders/virtualbox/iso](https://www.packer.io/plugins/builders/virtualbox/iso).
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看可用配置选项的完整概述，请参阅[https://www.packer.io/plugins/builders/virtualbox/iso](https://www.packer.io/plugins/builders/virtualbox/iso)。
- en: At this point, we have enough to install the OS automatically, but we need to
    do a few more things to prepare the virtual machine for Vagrant. To be specific,
    we need to add a user called `vagrant`, populate that user’s authorized keys with
    a known public key for that user, and finally we’ll want to install VirtualBox
    Guest Additions.
  id: totrans-405
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经完成了自动安装操作系统所需的步骤，但还需要做一些事情来准备虚拟机以适应Vagrant。具体来说，我们需要添加一个名为`vagrant`的用户，为该用户填充已知的公共密钥，最后我们还需要安装VirtualBox
    Guest Additions。
- en: For these tasks, we’ll leverage a provisioner to execute a shell script. This
    task takes place after the operating system is installed and while the virtual
    machine is still running. It’s the last thing we’ll do before we shut down the
    system and convert it to a Vagrant box.
  id: totrans-406
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 对于这些任务，我们将使用一个提供程序来执行一个shell脚本。这个任务发生在操作系统安装完成后，并且虚拟机仍在运行时。这是我们在关闭系统并将其转换为Vagrant
    box之前需要做的最后一件事。
- en: 'Go ahead and add the following to the `vagrant-ol8.pkr.hcl` file:'
  id: totrans-407
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 接下来，请将以下内容添加到`vagrant-ol8.pkr.hcl`文件中：
- en: '![Figure 8.38 – Packer file for building Vagrant boxes (continued)](img/B18349_08_38.jpg)'
  id: totrans-408
  prefs: []
  type: TYPE_IMG
  zh: '![图 8.38 – 用于构建Vagrant盒子的Packer文件（续）](img/B18349_08_38.jpg)'
- en: Figure 8.38 – Packer file for building Vagrant boxes (continued)
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.38 – 用于构建Vagrant盒子的Packer文件（续）
- en: Info
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
  zh: 信息
- en: 'More info on post-processors can be found here: [https://www.packer.io/plugins/post-processors/vagrant/vagrant#virtualbox](https://www.packer.io/plugins/post-processors/vagrant/vagrant#virtualbox).'
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
  zh: 有关后处理程序的更多信息，请参阅：[https://www.packer.io/plugins/post-processors/vagrant/vagrant#virtualbox](https://www.packer.io/plugins/post-processors/vagrant/vagrant#virtualbox)。
- en: 'As you can see from the preceding screenshot, we’re going to create a new folder
    called `scripts` and place the shell script in there:'
  id: totrans-412
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从上面的截图可以看到，我们将创建一个名为 `scripts` 的新文件夹，并将 shell 脚本放入其中：
- en: '[PRE30]'
  id: totrans-413
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Now, in the `vagrant-base-box.sh` script, we’ll add this:'
  id: totrans-414
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，在 `vagrant-base-box.sh` 脚本中，我们将添加以下内容：
- en: '![Figure 8.39 – Contents of the vagrant-base-box.sh script](img/B18349_08_39.jpg)'
  id: totrans-415
  prefs: []
  type: TYPE_IMG
  zh: '![图 8.39 – vagrant-base-box.sh 脚本的内容](img/B18349_08_39.jpg)'
- en: Figure 8.39 – Contents of the vagrant-base-box.sh script
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.39 – vagrant-base-box.sh 脚本的内容
- en: 'Next, we’re going to run `packer init` to download the external plugin:'
  id: totrans-417
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们将运行 `packer init` 来下载外部插件：
- en: '[PRE31]'
  id: totrans-418
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Now we’re ready to build the Vagrant box. This part is simple, just run the
    following:'
  id: totrans-419
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们准备好构建 Vagrant box 了。这部分很简单，只需运行以下命令：
- en: '[PRE32]'
  id: totrans-420
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'After entering the command, you will see something like the following:'
  id: totrans-421
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 输入命令后，你将看到如下内容：
- en: '![Figure 8.40 – Output of the “packer build” command](img/B18349_08_40.jpg)'
  id: totrans-422
  prefs: []
  type: TYPE_IMG
  zh: '![图 8.40 – “packer build” 命令的输出](img/B18349_08_40.jpg)'
- en: Figure 8.40 – Output of the “packer build” command
  id: totrans-423
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.40 – “packer build” 命令的输出
- en: 'This will take a while, because it’s actually doing quite a bit here. Remember
    what we talked about from a high level: Packer is going to download the ISO, create
    a VM, and install the OS, and afterward it will run everything in the script you
    just defined, but once all of this is done, you will be left with a nice neat
    `.box` file (which is exactly what we need to for use with Vagrant).'
  id: totrans-424
  prefs: []
  type: TYPE_NORMAL
  zh: 这将需要一些时间，因为实际上这里有很多操作。记住我们之前讨论过的高层次内容：Packer 将下载 ISO 文件，创建虚拟机，安装操作系统，之后它将运行你刚才定义的所有脚本，但一旦这些完成，你将得到一个整洁的
    `.box` 文件（这正是我们需要用于 Vagrant 的）。
- en: If you switch over to VirtualBox, you’ll eventually see a new VM that was created
    by Packer. You can just leave it be and let Packer do its thing, but knowing this
    detail gives you the ability to know what’s going on behind the scenes.
  id: totrans-425
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你切换到 VirtualBox，你将最终看到一个由 Packer 创建的新虚拟机。你可以不管它，让 Packer 自行操作，但了解这个细节能让你知道背后的过程发生了什么。
- en: '![Figure 8.41 – Screenshot of VM being built and configured with Packer](img/B18349_08_41.jpg)'
  id: totrans-426
  prefs: []
  type: TYPE_IMG
  zh: '![图 8.41 – 使用 Packer 构建并配置虚拟机的截图](img/B18349_08_41.jpg)'
- en: Figure 8.41 – Screenshot of VM being built and configured with Packer
  id: totrans-427
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.41 – 使用 Packer 构建并配置虚拟机的截图
- en: 'Once the build is complete, you should see output similar to the following:'
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
  zh: 构建完成后，你应该会看到类似以下内容的输出：
- en: '![Figure 8.42 – Screenshot of completed build of Vagrant box](img/B18349_08_42.jpg)'
  id: totrans-429
  prefs: []
  type: TYPE_IMG
  zh: '![图 8.42 – 完成构建的 Vagrant box 截图](img/B18349_08_42.jpg)'
- en: Figure 8.42 – Screenshot of completed build of Vagrant box
  id: totrans-430
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.42 – 完成构建的 Vagrant box 截图
- en: Note
  id: totrans-431
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: The Oracle Linux ISO file is several gigabytes, so this really could take a
    while. Now may be the perfect time to take a break and have a coffee. 😉
  id: totrans-432
  prefs: []
  type: TYPE_NORMAL
  zh: Oracle Linux ISO 文件有几个 GB，因此这可能需要一些时间。现在或许是休息一下，喝杯咖啡的好时机。😉
- en: 'Now it’s time to prepare our box for use with Vagrant. We’ll just run `vagrant
    init` to build our Vagrantfile:'
  id: totrans-433
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在是时候准备我们的 Vagrant box 以便与 Vagrant 一起使用了。我们将运行 `vagrant init` 来构建 Vagrantfile：
- en: '[PRE33]'
  id: totrans-434
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'The output is as follows:'
  id: totrans-435
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 输出如下所示：
- en: '![Figure 8.43 – Initializing Vagrant box](img/B18349_08_43.jpg)'
  id: totrans-436
  prefs: []
  type: TYPE_IMG
  zh: '![图 8.43 – 初始化 Vagrant box](img/B18349_08_43.jpg)'
- en: Figure 8.43 – Initializing Vagrant box
  id: totrans-437
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.43 – 初始化 Vagrant box
- en: Helpful tip
  id: totrans-438
  prefs: []
  type: TYPE_NORMAL
  zh: 有用的提示
- en: You could run `vagrant init` and `vagrant init .` , but it’s best to specify
    the filename of the box. This way, Vagrant will automatically specify the proper
    value of the box inside the Vagrantfile. That’s why for this recipe, we are running
    `vagrant` `init ol8-x64-virtualbox.box`.
  id: totrans-439
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以运行 `vagrant init` 和 `vagrant init .`，但最好指定 box 的文件名。这样，Vagrant 会自动在 Vagrantfile
    中指定正确的 box 值。正因如此，在这个食谱中，我们运行的是 `vagrant init ol8-x64-virtualbox.box`。
- en: 'Finally, it’s time to test out our new Vagrant box by running `vagrant up`:'
  id: totrans-440
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，是时候通过运行 `vagrant up` 来测试我们的新 Vagrant box 了：
- en: '[PRE34]'
  id: totrans-441
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'The output of this command is shown in the following screenshot:'
  id: totrans-442
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这个命令的输出如下所示：
- en: '![Figure 8.44 – Output of the “vagrant up” command](img/B18349_08_44.jpg)'
  id: totrans-443
  prefs: []
  type: TYPE_IMG
  zh: '![图 8.44 – “vagrant up” 命令的输出](img/B18349_08_44.jpg)'
- en: Figure 8.44 – Output of the “vagrant up” command
  id: totrans-444
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.44 – “vagrant up” 命令的输出
- en: And there you have it. After a few short moments, your virtual machine will
    be up and running, and you can interact with it using the convenient commands
    made possible by Vagrant.
  id: totrans-445
  prefs: []
  type: TYPE_NORMAL
  zh: 就这样。几分钟后，你的虚拟机将启动并运行，你可以使用 Vagrant 提供的便捷命令与之交互。
- en: The source code for this recipe can be found at [https://github.com/PacktPublishing/Oracle-Linux-Cookbook/tree/main/ch8/packer-vagrant](https://github.com/PacktPublishing/Oracle-Linux-Cookbook/tree/main/ch8/packer-vagrant).
  id: totrans-446
  prefs: []
  type: TYPE_NORMAL
  zh: 本食谱的源代码可以在[https://github.com/PacktPublishing/Oracle-Linux-Cookbook/tree/main/ch8/packer-vagrant](https://github.com/PacktPublishing/Oracle-Linux-Cookbook/tree/main/ch8/packer-vagrant)找到。
- en: Important note
  id: totrans-447
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: If you’re still developing your Vagrant box and need to test after each build,
    you’ll want to make sure you’re testing the latest box that you’ve built. I actually
    ran into an issue thinking that my changes weren’t persisting until I realized
    Vagrant was using a cached box from a previous build. You can remove old boxes
    with `vagrant box` `remove ol8-x64-virtualbox.box`.
  id: totrans-448
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你还在开发你的Vagrant盒子，并且需要在每次构建后进行测试，你会希望确保你正在测试最新构建的盒子。我曾经遇到过一个问题，认为我的更改没有保存，直到我意识到Vagrant正在使用之前构建的缓存盒子。你可以使用`vagrant
    box` `remove ol8-x64-virtualbox.box`命令来删除旧盒子。
