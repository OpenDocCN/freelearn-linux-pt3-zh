- en: '3'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '3'
- en: Exploring the Various Boot Options and Kernels in Oracle Linux
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 探索 Oracle Linux 中的各种启动选项和内核
- en: This chapter will teach you about **boot** and its options, kernels, and more.
    You will also learn about many exciting opportunities, tools, and applications
    to make your life easier and more enjoyable. For example, you will learn how to
    change your booting kernel and remove and reinstall a kernel on your system. You
    will even learn how to use the boot process to switch between Linux kernels.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将教你关于**启动**及其选项、内核等内容。你还将学习到许多令人兴奋的机会、工具和应用，帮助你使生活更加轻松愉快。例如，你将学会如何更改启动内核，移除并重新安装系统上的内核。你甚至将学会如何利用启动过程在不同的
    Linux 内核之间切换。
- en: Booting involves more than just loading the operating system; it also helps
    secure the system using Secure Boot or TrenchBoot.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 启动不仅仅是加载操作系统，它还通过使用安全启动（Secure Boot）或 TrenchBoot 来帮助保护系统安全。
- en: 'This chapter has the following recipes:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 本章包含以下内容：
- en: Kernel basics – UEK and RHCK
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 内核基础 – UEK 和 RHCK
- en: Playing with UEFI
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 玩转 UEFI
- en: Playing with Secure Boot
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 玩转安全启动
- en: TrenchBoot – improving boot security and integrity
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: TrenchBoot – 提升启动安全性和完整性
- en: Removing the RHCK
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 移除 RHCK
- en: Kernel basics – UEK and RHCK
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 内核基础 – UEK 和 RHCK
- en: Before we get started with UEK and RHCK, let's understand what is a Linux kernel.
    A Linux kernel release refers to an updated version of the core component of the
    Linux operating system. Its main function is to act as a bridge between the hardware
    and software layers of a computer system. The Linux kernel is a collaborative
    development effort by a large community of developers worldwide, with Linus Torvalds
    as the original creator and official maintainer of the mainline kernel. These
    kernel updates are introduced periodically to provide new features, improvements,
    bug fixes, security patches, and hardware support.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始讨论 UEK 和 RHCK 之前，首先来了解什么是 Linux 内核。Linux 内核发布指的是 Linux 操作系统核心组件的更新版本。它的主要功能是作为计算机系统硬件和软件层之间的桥梁。Linux
    内核是由全球大量开发者共同开发的，Linus Torvalds 是内核主线的原始创建者和官方维护者。这些内核更新定期发布，提供新功能、改进、错误修复、安全补丁和硬件支持。
- en: 'Linux kernel releases are assigned a version number that consists of three
    components: major version, minor version, and patch level. For instance, a kernel
    version is represented as X.Y.Z, where X represents the major version, Y is the
    minor version, and Z is the patch level. The major version is usually incremented
    for significant changes that may affect compatibility, while the minor version
    and patch level represent incremental updates and bug fixes.'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: Linux 内核发布会分配一个由三个部分组成的版本号：主版本、次版本和补丁级别。例如，一个内核版本表示为 X.Y.Z，其中 X 代表主版本，Y 是次版本，Z
    是补丁级别。主版本通常在发生可能影响兼容性的重大更改时增加，而次版本和补丁级别则表示增量更新和错误修复。
- en: Linux kernel releases are distributed as source code, and various distributions
    or operating systems based on Linux typically package and distribute their own
    versions of the kernel, incorporating it into their respective releases. In addition,
    users who want to compile and install the kernel directly on their systems can
    access the source code. The following table shows the Linux kernel mainline releases
    for Linux 7, 8, and 9.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: Linux 内核发布作为源代码分发，各种基于 Linux 的发行版或操作系统通常会打包并分发他们自己的内核版本，将其纳入各自的发行版中。此外，用户如果希望在自己的系统上直接编译和安装内核，可以访问源代码。下表显示了
    Linux 7、8 和 9 版本的 Linux 内核主线发布。
- en: '| **OS Version** | **RHCK Release** | **Latest** **UEK Release** |'
  id: totrans-14
  prefs: []
  type: TYPE_TB
  zh: '| **操作系统版本** | **RHCK 版本** | **最新的** **UEK 版本** |'
- en: '| Linux 7 | Linux 3.x | UEK 6/Linux 5.4 |'
  id: totrans-15
  prefs: []
  type: TYPE_TB
  zh: '| Linux 7 | Linux 3.x | UEK 6/Linux 5.4 |'
- en: '| Linux 8 | Linux 4.x | UEK 7/Linux 5.15 |'
  id: totrans-16
  prefs: []
  type: TYPE_TB
  zh: '| Linux 8 | Linux 4.x | UEK 7/Linux 5.15 |'
- en: '| Linux 9 | Linux 5.14 | UEK 7/Linux 5.15 |'
  id: totrans-17
  prefs: []
  type: TYPE_TB
  zh: '| Linux 9 | Linux 5.14 | UEK 7/Linux 5.15 |'
- en: Table 3.1 – Available Kernel options by release
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 表 3.1 – 按版本列出的可用内核选项
- en: Kernel basics – UEK and RHCK
  id: totrans-19
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 内核基础 – UEK 和 RHCK
- en: With a fresh installation of Oracle Linux, the **Unbreakable Enterprise Kernel**
    (**UEK**) is the default. However, in some cases, you may want to switch to the
    **Red Hat Compatible** **Kernel** (**RHCK**).
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 在全新安装的 Oracle Linux 系统中，**Unbreakable Enterprise Kernel**（**UEK**）是默认内核。然而，在某些情况下，你可能希望切换到**Red
    Hat Compatible** **Kernel**（**RHCK**）。
- en: 'The default kernel might not be the correct version to use in some scenarios:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 默认内核在某些场景下可能不是最合适的版本：
- en: UEK releases are based on newer kernel releases than the **RHCK** version, which
    is the standard for Red Hat servers. With Oracle Linux, you have the option to
    use the UEK, which provides a more up-to-date kernel release.
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: UEK 发布版本是基于比 **RHCK** 版本更新的内核版本，后者是 Red Hat 服务器的标准。使用 Oracle Linux 时，您可以选择使用
    UEK，该版本提供了更新的内核发布。
- en: The current kernel version might be incompatible with your particular hardware.
    A UEK system will boot on new hardware, while the older RHCK will not. An example
    of this is UEK 7, which supports the **Microsoft Azure Network Adapter** (**MANA**),
    whereas UEK 6 does not.
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当前的内核版本可能与您的特定硬件不兼容。UEK 系统将在新硬件上引导，而较旧的 RHCK 则不会。一个例子是 UEK 7，它支持 **Microsoft
    Azure Network Adapter**（**MANA**），而 UEK 6 则不支持。
- en: Suppose a UEK beta or technical preview release is installed on the system.
    In that case, UEK needs to be demoted to ensure that the kernel is used only if
    intentionally and manually selected as the boot kernel by an administrator.
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 假设系统上安装了 UEK 的 beta 或技术预览版本。在这种情况下，UEK 需要降级，以确保内核只有在管理员有意识并手动选择作为引导内核时才会使用。
- en: The UEK for Oracle Linux provides many advantages, such as significant performance
    improvements and new features. The Linux operating system is a modular system
    in which the kernel interacts with the hardware and controls and schedules access
    to resources on behalf of applications. Most applications run in what is called
    user space and call only a stable set of system libraries to ask for kernel services.
    The exceptions are applications that directly access the kernel, most commonly
    security applications.
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Oracle Linux 的 UEK 提供了许多优势，如显著的性能改进和新功能。Linux 操作系统是一个模块化系统，其中内核与硬件交互，并在应用程序代表访问资源时控制和调度访问。大多数应用程序运行在称为用户空间的地方，并且只调用一组稳定的系统库来请求内核服务。唯一的例外是直接访问内核的应用程序，最常见的是安全应用程序。
- en: Installing the UEK does not change system libraries such as glibc, which is
    the interface that nearly all applications, including Oracle Database, use. The
    glibc version is the same whether you run Oracle Linux with the UEK or with the
    RHCK. This is not limited to just gloc, but is the case for all system libraries,
    such as libssl, libcurl, and libcrypt.
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 安装 UEK 不会更改系统库，例如几乎所有应用程序（包括 Oracle 数据库）使用的接口 glibc。无论您是否使用 UEK 或 RHCK 运行 Oracle
    Linux，glibc 版本都是相同的。这不仅限于 gloc，对于所有系统库，如 libssl、libcurl 和 libcrypt，情况都是如此。
- en: Note
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Multiple versions of the UEK may be available for any baseline operating system
    release. Choosing the version of the UEK is up to the application team and must
    reflect any compatibility requirements.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 对于任何基线操作系统发布，可能会有多个 UEK 版本可用。选择 UEK 的版本取决于应用团队，并且必须反映出任何兼容性要求。
- en: These examples and similar cases require you to switch between kernel types.
    In older releases, managing the default kernel was performed by configuring the
    GRUB boot loader. However, with Oracle Linux 8 and later, you should use the `grubby`
    command to control and manage the configuration for booting the kernel. `grubby`
    is part of the **Grand Unified Bootloader version 2** (**GRUB 2**) boot loader,
    which is available from the GNU project. GRUB is the default bootloader for many
    Linux distributions on the market. After loading it into memory, it transfers
    control to the operating system kernel.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 这些示例及类似情况需要您在不同的内核类型之间进行切换。在旧版本中，管理默认内核是通过配置 GRUB 引导加载程序完成的。但是，从 Oracle Linux
    8 开始，您应该使用 `grubby` 命令来控制和管理引导内核的配置。`grubby` 是 **Grand Unified Bootloader version
    2**（**GRUB 2**）引导加载程序的一部分，它来自 GNU 项目。GRUB 是市场上许多 Linux 发行版的默认引导加载程序。加载到内存后，它将控制权转移给操作系统内核。
- en: GRUB 2 is the default bootloader program used on Oracle Linux, and it can load
    many different operating systems, including Microsoft Windows.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: GRUB 2 是 Oracle Linux 上使用的默认引导加载程序，它可以加载许多不同的操作系统，包括 Microsoft Windows。
- en: Getting ready
  id: totrans-31
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备就绪
- en: Let’s start by looking deeper at the boot process to better understand it.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从更深入地了解引导过程开始。
- en: The boot process
  id: totrans-33
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 引导过程
- en: You have an understanding of how Oracle Linux boot options help you troubleshoot
    problems encountered when booting the system. This knowledge is beneficial when
    using new hardware or cloud environments.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 您了解 Oracle Linux 引导选项如何帮助您解决系统引导时遇到的问题是很有益的。在使用新硬件或云环境时，这种知识尤其重要。
- en: As an Oracle Linux system boots, it performs many tasks that may change depending
    on the type of firmware your hardware uses to handle the system boot. It could
    be `.efi` file in a particular partition on the system’s drive. Using the `.efi`
    file gives a user more control of the boot process, including the ability to take
    advantage of new security features. An example of a new security feature is Secure
    Boot, which is covered in this chapter.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 当 Oracle Linux 系统启动时，它会执行许多任务，这些任务可能会根据硬件使用的固件类型来改变，以处理系统的启动。它可能是系统驱动器上某个分区中的
    `.efi` 文件。使用 `.efi` 文件让用户对启动过程有更多控制，包括能够利用新的安全功能。一个新的安全功能示例是安全启动（Secure Boot），该功能将在本章中介绍。
- en: The UEFI-based booting sequence
  id: totrans-36
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 基于 UEFI 的启动顺序
- en: 'The following sequence order is used by UEFI-based booting hardware:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是基于 UEFI 启动硬件使用的顺序：
- en: The system first performs a **power-on self-test** (**POST**), which identifies
    the system’s configuration and all possible boot identifiers.
  id: totrans-38
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 系统首先执行 **自检启动**（**POST**），以识别系统的配置和所有可能的启动标识符。
- en: UEFI searches for a **GUID Partition Table** (**GPT**) partition with a specific
    **Globally Unique Identifier** (**GUID**) that identifies it as the **EFI System
    Partition** (**ESP**), containing **Extensible Firmware Interface** (**EFI**)
    applications such as booters. If there are multiple boot devices, the UEFI boot
    manager determines the appropriate ESP based on the order defined in the boot
    manager. With the **efibootmgr** tool, you can specify a different order if you
    do not use the default definition.
  id: totrans-39
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: UEFI 会搜索具有特定 **全球唯一标识符**（**GUID**）的 **GUID 分区表**（**GPT**）分区，将其标识为 **EFI 系统分区**（**ESP**），该分区包含诸如启动器等
    **可扩展固件接口**（**EFI**）应用程序。如果有多个启动设备，UEFI 启动管理器将根据启动管理器中定义的顺序确定适当的 ESP。使用 **efibootmgr**
    工具，如果你不使用默认定义，可以指定一个不同的顺序。
- en: The UEFI boot manager checks whether Secure Boot is enabled. If Secure Boot
    is not enabled, the boot manager runs the GRUB 2 boot loader on the ESP. Otherwise,
    the boot manager requests a certificate from the boot loader and validates this
    against keys stored in the UEFI Secure Boot key database. The environment is configured
    to perform a two-stage boot process, and the shim to handle the certificate validation
    `process.efi` application that is responsible for the certification is loaded
    first before loading the GRUB 2 boot loader. If the certificate is valid, the
    boot loader runs and, in turn, validates the kernel that it is configured to load.
  id: totrans-40
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: UEFI 启动管理器检查是否启用了安全启动。如果没有启用安全启动，启动管理器将运行 ESP 上的 GRUB 2 启动加载程序。否则，启动管理器将请求启动加载程序的证书，并将其与存储在
    UEFI 安全启动密钥数据库中的密钥进行验证。环境配置为执行两阶段启动过程，负责证书验证的 `process.efi` 应用程序的 shim 首先加载，然后才加载
    GRUB 2 启动加载程序。如果证书有效，启动加载程序运行，并进一步验证其配置要加载的内核。
- en: The boot loader first loads the `vmlinuz` kernel image into memory and then
    creates a temporary RAM-based filesystem called `tmpfs`. This is then used to
    extract the contents of the `initramfs` image file. `vmlinuz` is the name of the
    bootable compressed Linux kernel executable. The root filesystem embedded into
    the Linux kernel and loaded early in the boot process is called `initramfs`.
  id: totrans-41
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 启动加载程序首先将 `vmlinuz` 内核镜像加载到内存中，然后创建一个名为 `tmpfs` 的临时 RAM 文件系统。然后它用于提取 `initramfs`
    镜像文件的内容。`vmlinuz` 是可引导的压缩 Linux 内核可执行文件的名称。内核中嵌入的根文件系统，并在启动过程中早期加载，称为 `initramfs`。
- en: Driver modules are then loaded from the `initramfs` filesystem. These are needed
    to allow the kernel to access the root filesystem.
  id: totrans-42
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 驱动程序模块随后从 `initramfs` 文件系统加载。这些模块允许内核访问根文件系统。
- en: The system then starts with the first process, systemd. All future processes
    spawn from this process. The systemd process will always have a process ID of
    1.
  id: totrans-43
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后系统从第一个进程 systemd 启动。所有未来的进程都将从这个进程派生。systemd 进程的进程 ID 始终为 1。
- en: The systemd process will run any additional processes defined for it. You can
    specify any other actions to be processed during the boot process by defining
    your systemd unit. This method is advised to be used instead of the `/etc/rc.
    local` file approach.
  id: totrans-44
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: systemd 进程将运行为其定义的任何额外进程。你可以通过定义你的 systemd 单元来指定在启动过程中要处理的其他操作。建议使用这种方法，而不是使用
    `/etc/rc.local` 文件的方法。
- en: The legacy BIOS sequence
  id: totrans-45
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 传统 BIOS 启动顺序
- en: 'Legacy BIOS booting hardware uses the following sequence order:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 传统 BIOS 启动硬件使用以下顺序：
- en: The system first performs a POST, which identifies the configuration of the
    system, tests memory, and identifies all possible boot devices.
  id: totrans-47
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 系统首先执行POST（开机自检），它识别系统的配置、测试内存并识别所有可能的启动设备。
- en: Once the BIOS has identified the boot device, it reads the first sector of the
    device, which is the **Master Boot Record** (**MBR**). The MBR contains the boot
    loader, which is a small program that is responsible for loading the operating
    system. The MBR reads the partition table, to determine the boot partition. Additionally,
    the MBR includes the pointer to the boot loader program called GRUB 2\. GRUB can
    then run a boot on the same device that GRUB is installed on or a separate device.
    This is helpful when multi-booting the same system with both Linux and Windows.
  id: totrans-48
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦BIOS识别了启动设备，它就会读取设备的第一个扇区，即**主引导记录**（**MBR**）。MBR包含引导加载程序，它是一个负责加载操作系统的小程序。MBR读取分区表，以确定启动分区。此外，MBR还包含指向名为GRUB
    2的引导加载程序的指针。GRUB接着可以在安装了GRUB的同一设备或其他设备上运行引导。这在进行双系统引导（例如同时运行Linux和Windows）时非常有用。
- en: The boot loader first loads the `vmlinuz` kernel image into memory and then
    creates a temporary RAM-based filesystem called `tmpfs`. This is then used to
    extract the contents of the `initramfs` image file. `vmlinuz` is the name of the
    bootable compressed Linux kernel executable. The root filesystem embedded in the
    Linux kernel and loaded early in the boot process is called initramfs.
  id: totrans-49
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 引导加载程序首先将`vmlinuz`内核镜像加载到内存中，然后创建一个名为`tmpfs`的临时基于内存的文件系统。接着，`tmpfs`用于提取`initramfs`镜像文件的内容。`vmlinuz`是可引导的压缩Linux内核可执行文件的名称。嵌入在Linux内核中并在引导过程中早期加载的根文件系统称为initramfs。
- en: Driver modules are then loaded from the initramfs filesystem. These modules
    are needed to allow the kernel to access the root filesystem.
  id: totrans-50
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 驱动程序模块随后从initramfs文件系统中加载。这些模块是允许内核访问根文件系统所必需的。
- en: The kernel then starts the systemd process.
  id: totrans-51
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 内核随后启动systemd进程。
- en: The systemd process runs any other processes defined for it. You can specify
    any additional actions to be processed during the boot process by defining your
    systemd unit. This method is recommended instead of the `/etc/rc. local` file
    approach.
  id: totrans-52
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: systemd进程运行任何为其定义的其他进程。你可以通过定义systemd单元来指定在引导过程中处理的任何额外操作。推荐使用这种方法，而不是使用`/etc/rc.local`文件方法。
- en: How to do it…
  id: totrans-53
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作…
- en: Now that we have discussed the basics, we can leave behind all the boring parts
    and get to the action. It is time to play and learn!
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经讨论了基础知识，接下来可以告别那些枯燥的部分，进入实际操作。是时候玩起来并学习了！
- en: 'One of the first things we can do is determine the currently loaded kernel
    in our system. The following command will display all kernels that are installed
    and configured within our Linux system (please run as root):'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以做的第一件事是确定当前加载的内核。以下命令将显示我们Linux系统中已安装并配置的所有内核（请以root身份运行）：
- en: '[PRE0]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Here is one example of the output:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个输出示例：
- en: '![Figure 3.1 – grubby output](img/B18349_03_01.jpg)'
  id: totrans-58
  prefs: []
  type: TYPE_IMG
  zh: '![图 3.1 – grubby 输出](img/B18349_03_01.jpg)'
- en: Figure 3.1 – grubby output
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.1 – grubby 输出
- en: Note
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: The sample is done using an Arm system, hence the `aarch64` suffix. x86_64 systems
    will show `x86_64` suffixes.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 该示例使用的是Arm系统，因此显示了`aarch64`后缀。x86_64系统将显示`x86_64`后缀。
- en: 'We can also determine the default kernel in use by executing the following
    command:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以通过执行以下命令来确定当前使用的默认内核：
- en: '[PRE1]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Here is one example of an output:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个输出示例：
- en: '![Figure 3.2 – grubby default kernel](img/B18349_03_02.jpg)'
  id: totrans-65
  prefs: []
  type: TYPE_IMG
  zh: '![图 3.2 – grubby 默认内核](img/B18349_03_02.jpg)'
- en: Figure 3.2 – grubby default kernel
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.2 – grubby 默认内核
- en: 'We can configure a specific kernel to be used as the default boot kernel by
    running the following command:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过运行以下命令来配置特定的内核作为默认引导内核：
- en: '[PRE2]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Here is one example of using the preceding command to change the default kernel
    in use. Knowing that RHCK is going to be a version 4 kernel, we will use `4.18.0-425.13.1.el8_7.x86_64`.
    Next, we need to point to the file in `/boot`, adding `vmlinuz-` to the name.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 这是使用前述命令更改正在使用的默认内核的示例。我们知道RHCK将是一个版本4内核，因此我们将使用`4.18.0-425.13.1.el8_7.x86_64`。接下来，我们需要指向`/boot`中的文件，并在名称前加上`vmlinuz-`。
- en: '![Figure 3.3 – Changing the default kernel with grubby](img/B18349_03_03.jpg)'
  id: totrans-70
  prefs: []
  type: TYPE_IMG
  zh: '![图 3.3 – 使用grubby更改默认内核](img/B18349_03_03.jpg)'
- en: Figure 3.3 – Changing the default kernel with grubby
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.3 – 使用grubby更改默认内核
- en: 'Another possible use of the `grubby` command is to use it to update a kernel
    configuration entry or to add or remove boot arguments that should be passed to
    the kernel by default; the following is one example of it. But first, we will
    show all the information about a specific kernel in the system:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个可能用途是使用`grubby`命令更新内核配置条目，或者添加或删除应默认传递给内核的启动参数；以下是一个示例。但首先，我们将展示系统中特定内核的所有信息：
- en: '[PRE3]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'This will show the details for the specified kernel, including the patch to
    the kernel and any arguments:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 这将显示指定内核的详细信息，包括内核的修补程序和任何参数：
- en: '![Figure 3.4 – grubby kernel info](img/B18349_03_04.jpg)'
  id: totrans-75
  prefs: []
  type: TYPE_IMG
  zh: '![图 3.4 – grubby 内核信息](img/B18349_03_04.jpg)'
- en: Figure 3.4 – grubby kernel info
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.4 – grubby 内核信息
- en: 'With these kernel details, we remove the `rhgb quiet` configuration from the
    kernel arguments and add a new `test` by using the following command:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这些内核详细信息，我们通过以下命令删除内核参数中的`rhgb quiet`配置，并添加一个新的`test`：
- en: '[PRE4]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: As you can see, we used the kernel name to update the arguments on that kernel
    (we used the `–-remove-args` attribute to remove an argument configuration and
    the `--args` attribute to add a new one). Now, we can check whether the argument’s
    structure changed by running the `grubby –-info=$BOOTENV` command with the boot
    environment as seen in the following figure.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您所见，我们使用内核名称来更新该内核上的参数（我们使用`–-remove-args`属性来移除一个参数配置，并使用`--args`属性添加一个新的参数）。现在，我们可以通过运行`grubby
    –-info=$BOOTENV`命令来检查参数结构是否发生了变化，其中的引导环境如下图所示。
- en: 'Note that you can always use the `man grubby` command to review all the options
    available within the `grubby` command:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，您可以随时使用`man grubby`命令查看`grubby`命令中的所有可用选项：
- en: '![Figure 3.5 – grubby info after making the change](img/B18349_03_05.jpg)'
  id: totrans-81
  prefs: []
  type: TYPE_IMG
  zh: '![图 3.5 – 在进行更改后的 grubby 信息](img/B18349_03_05.jpg)'
- en: Figure 3.5 – grubby info after making the change
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.5 – 在进行更改后的 grubby 信息
- en: How it works…
  id: totrans-83
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理…
- en: 'As mentioned before, Oracle Linux comes with two flavors of kernels: the UEK,
    which is Oracle’s default flavor of Linux kernel, and the RHCK, which is compatible
    with the RHEL kernel. Regardless of what kernel is used, the rest of the operating
    system is the same; that is, it has the same applications, libraries, and file
    locations.'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，Oracle Linux 提供两种内核版本：UEK，这是 Oracle 的默认 Linux 内核版本，以及 RHCK，与 RHEL 内核兼容。无论使用哪种内核，操作系统的其余部分都是相同的；即具有相同的应用程序、库和文件位置。
- en: This section will teach you how to switch the default kernel (UEK) to the RHCK
    and vice versa. So, let’s get started.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 本节将教您如何将默认内核（UEK）切换到 RHCK 或反之。让我们开始吧。
- en: 'First, once again, we will use the `grubby` command to check the default kernel
    in use and, again, to check all kernels available within your system by using
    the `grubby -–info=DEFAULT` and `grubby –-info=ALL` commands. The difference between
    the two commands is with the `DEFAULT` option, only the booting info is shown.
    With the `ALL` option, all available kernels are shown:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们再次使用`grubby`命令来检查正在使用的默认内核，并再次使用`grubby -–info=DEFAULT`和`grubby –-info=ALL`命令来检查系统中所有可用的内核。两个命令的区别在于`DEFAULT`选项仅显示引导信息。使用`ALL`选项，则显示所有可用的内核：
- en: '![Figure 3.6 – Kernel version before swapping to RHCK](img/B18349_03_06.jpg)'
  id: totrans-87
  prefs: []
  type: TYPE_IMG
  zh: '![图 3.6 – 切换到 RHCK 前的内核版本](img/B18349_03_06.jpg)'
- en: Figure 3.6 – Kernel version before swapping to RHCK
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.6 – 切换到 RHCK 前的内核版本
- en: 'In the preceding example, you can see that, in this case, the default kernel
    in use is `/boot/vmlinuz-5.15.0-8.91.4.1.el8uek.x86_64`, which is a UEK flavor
    of the kernel. A UEK system should always have `uek` after `el#`. You can also
    check the current kernel using the `uname -``a` command:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述示例中，您可以看到，在这种情况下，正在使用的默认内核是`/boot/vmlinuz-5.15.0-8.91.4.1.el8uek.x86_64`，这是一个
    UEK 内核的变种。UEK 系统应该在`el#`后始终有`uek`。您还可以使用`uname -a`命令检查当前内核：
- en: '![Figure 3.7 – uname -a before swapping to the RHCK](img/B18349_03_07.jpg)'
  id: totrans-90
  prefs: []
  type: TYPE_IMG
  zh: '![图 3.7 – 在切换到 RHCK 之前的 uname -a](img/B18349_03_07.jpg)'
- en: Figure 3.7 – uname -a before swapping to the RHCK
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.7 – 在切换到 RHCK 之前的 uname -a
- en: 'To check all the kernels available on the system, we could use the data from
    the previously run `grubby –info` command, or use the `rpm -qa` `kernel*core*`
    command:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 要检查系统上所有可用的内核，我们可以使用先前运行的`grubby –info`命令中的数据，或者使用`rpm -qa` `kernel*core*`命令：
- en: '![Figure 3.8 – Checking the kernels using the rpm command](img/B18349_03_08.jpg)'
  id: totrans-93
  prefs: []
  type: TYPE_IMG
  zh: '![图 3.8 – 使用 rpm 命令检查内核](img/B18349_03_08.jpg)'
- en: Figure 3.8 – Checking the kernels using the rpm command
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.8 – 使用 rpm 命令检查内核
- en: 'When checking all available kernels, we can quickly identify two versions of
    the UEK and two versions of the RHCK. For this example, we will use the RHCK version
    called `4.18.0-425.13.1.el8_7`, which is found in `boot` at `/boot/vmlinuz-` `4.18.0-425.13.1.el8_7`.
    So now, let’s use the `grubby –-set-default` command to make the selected RHCK
    the new default. We then check the default kernel using the `grubby --``info=DEFAULT`
    command:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 在检查所有可用内核时，我们可以快速识别出两种版本的 UEK 和两种版本的 RHCK。在这个例子中，我们将使用名为 `4.18.0-425.13.1.el8_7`
    的 RHCK 版本，它位于 `/boot/vmlinuz-` `4.18.0-425.13.1.el8_7`。所以现在，我们使用 `grubby --set-default`
    命令将所选的 RHCK 设置为默认内核。然后，我们使用 `grubby --info=DEFAULT` 命令检查默认内核：
- en: '![Figure 3.9 – Switching to the RHCK](img/B18349_03_09.jpg)'
  id: totrans-96
  prefs: []
  type: TYPE_IMG
  zh: '![图 3.9 – 切换到 RHCK](img/B18349_03_09.jpg)'
- en: Figure 3.9 – Switching to the RHCK
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.9 – 切换到 RHCK
- en: And that’s it. Now all we need to do is reboot the system to reflect the kernel
    change. Then, if you want to switch it back to the previous RHCK flavor of the
    kernel, all you need to do is run the `grubby –-set-default` command again, but
    this time specify the name of the RHCK version that you want.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 就是这样。现在，我们需要做的就是重启系统以反映内核更改。然后，如果你想将其切换回之前的 RHCK 内核版本，只需再次运行`grubby --set-default`命令，但这次指定你想要的
    RHCK 版本名称。
- en: Playing with UEFI
  id: totrans-99
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 玩转 UEFI
- en: One way hackers can compromise systems is by attacking the system before it
    boots. In order to prevent this, you must secure the operating system by enabling
    security in UEFI. In other words, you cannot run software if it cannot be trusted
    to execute code correctly because untrusted software can tamper with your bootloader
    or, even worse, compromise your firmware. To solve this, a new, secure method
    is required to boot systems, called UEFI. UEFI is implemented in the firmware
    and has become the interface between your hardware and the operating system, replacing
    the legacy BIOS firmware that was previously the industry default. A feature of
    UEFI is Secure Boot, which ensures that your system boots by only using software
    trusted by the hardware manufacturer of your system. In addition, it provides
    a verification mechanism (by verifying each piece of boot software by using cryptographic
    checksums and signatures) to ensure that the code that is launched is trusted
    by validating the boot loader before executing it (even before loading the operating
    system). If the feature is available, UEFI systems can also boot in legacy BIOS
    mode via a compatibility support module.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 黑客入侵系统的一种方式是在系统启动之前攻击它。为了防止这种情况，你必须通过启用 UEFI 中的安全性来保护操作系统。换句话说，如果无法信任软件正确执行代码，就不能运行该软件，因为不受信任的软件可能会篡改引导加载程序，甚至更糟，危害固件。为了解决这个问题，启动系统需要一种新的安全方法，这就是
    UEFI。UEFI 实现于固件中，已经成为硬件和操作系统之间的接口，取代了之前行业默认的传统 BIOS 固件。UEFI 的一项功能是安全启动（Secure
    Boot），它确保系统仅使用硬件制造商信任的软件来启动系统。此外，它提供了一个验证机制（通过使用加密校验和和签名验证每个启动软件），以确保在执行之前通过验证启动加载程序来确保启动的代码是受信任的（甚至在加载操作系统之前）。如果该功能可用，UEFI
    系统还可以通过兼容性支持模块以传统 BIOS 模式启动。
- en: Getting ready
  id: totrans-101
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: To boot in UEFI mode, Oracle Linux requires the UEFI firmware to be present
    during the system installation as it is detected at installation time. Next, a
    GPT is automatically set up, creating an ESP on the `/boot/efi` mount, which contains
    the files needed for the UEFI booting. GPT is a way of storing partitioning information
    on a drive that includes information such as where partitions begin and end on
    a physical disk. GPT is a new standard that gradually replaces the MBR standard
    previously widely used. GPT doesn’t suffer from MBR’s limits, such as the number
    of partitions and the drivers’ size, with size limits depending on the operating
    system and its filesystems. Note that GPT is the type of partition table required
    by UEFI and was initiated by Intel.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 要在 UEFI 模式下启动，Oracle Linux 在系统安装过程中需要检测到 UEFI 固件。接下来，GPT 会自动设置，并在 `/boot/efi`
    挂载点创建一个 ESP，其中包含用于 UEFI 启动所需的文件。GPT 是一种存储驱动器分区信息的方式，包括分区在物理磁盘上的起始和结束位置等信息。GPT
    是一种新的标准，逐步取代了以前广泛使用的 MBR 标准。GPT 不受 MBR 的限制，如分区数量和驱动程序大小，且大小限制取决于操作系统及其文件系统。请注意，GPT
    是 UEFI 所要求的分区表类型，由英特尔发起。
- en: MBR versus GPT
  id: totrans-103
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: MBR 与 GPT
- en: When it comes to partitioning schemes on storage devices such as hard drives
    and solid-state drives, MBR and GPT are two distinct options. To help distinguish
    between the two, here are the primary differences to keep in mind.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 对于硬盘和固态硬盘等存储设备的分区方案，MBR 和 GPT 是两种不同的选项。为了帮助区分它们，以下是需要记住的主要差异。
- en: '**Partitioning capacity**:'
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**分区容量**：'
- en: '**MBR**: Your computer’s MBR allows either four primary partitions or three
    primary partitions and one extended partition, which can be further divided into
    multiple logical partitions. However, it does have a capacity restriction of a
    maximum disk size of 2 TB.'
  id: totrans-106
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**MBR**：计算机的 MBR 允许最多四个主分区，或者三个主分区和一个扩展分区，后者可以进一步划分为多个逻辑分区。然而，MBR 的最大磁盘容量限制为
    2 TB。'
- en: '**GPT**: By default, GPT can support up to 128 partitions and it is not limited
    in terms of partition count. Additionally, it can accommodate larger disk sizes
    of up to 9.4 ZB.'
  id: totrans-107
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**GPT**：默认情况下，GPT 支持最多 128 个分区，并且没有分区数量的限制。此外，它还能支持最大 9.4 ZB 的较大磁盘容量。'
- en: '**Compatibility**:'
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**兼容性**：'
- en: '**MBR**: MBR provides improved compatibility with legacy systems and operating
    systems. It is widely supported by BIOS-based computers, as well as old versions
    of Windows and Linux.'
  id: totrans-109
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**MBR**：MBR 提供更好的与旧版系统和操作系统的兼容性。它在基于 BIOS 的计算机以及旧版 Windows 和 Linux 系统中得到了广泛支持。'
- en: '**GPT**: Modern systems, especially those utilizing UEFI instead of BIOS, exhibit
    better compatibility with GPT. This partitioning scheme is backed by most contemporary
    operating systems, such as Windows, macOS, and Linux.'
  id: totrans-110
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**GPT**：现代系统，特别是那些使用 UEFI 而非 BIOS 的系统，在兼容性方面表现更好。大多数现代操作系统（如 Windows、macOS
    和 Linux）都支持这种分区方案。'
- en: When deciding whether to use MBR or GPT, it’s important to take into account
    factors such as disk size, desired partition count, compatibility needs, and the
    specific system or operating system you plan to use. For large disks and new systems,
    GPT is usually the better choice, while MBR remains viable for old systems or
    small disks that require compatibility with the older booting partition.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 在决定使用 MBR 还是 GPT 时，需要考虑磁盘大小、所需的分区数量、兼容性需求以及你计划使用的具体系统或操作系统等因素。对于大磁盘和新系统，GPT
    通常是更好的选择，而 MBR 仍然适用于需要与旧版引导分区兼容的老旧系统或小磁盘。
- en: How to do it…
  id: totrans-112
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何执行…
- en: 'Let’s run the `df -h` command to view the partitions in the system. Please
    notice that `/boot/efi` is mounted on the `/dev/sda1` partition in this example:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 我们运行 `df -h` 命令来查看系统中的分区。请注意，在此示例中，`/boot/efi` 被挂载在 `/dev/sda1` 分区：
- en: '![Figure 3.10 – df -h command](img/B18349_03_10.jpg)'
  id: totrans-114
  prefs: []
  type: TYPE_IMG
  zh: '![图 3.10 – df -h 命令](img/B18349_03_10.jpg)'
- en: Figure 3.10 – df -h command
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.10 – df -h 命令
- en: 'If you run the `ls -l /boot/efi/EFI/redhat` command, this directory contains
    a first-stage bootloader called `shimx64.efi`, a GRUB 2 bootloader called `grubx64.efi`,
    and a GRUB 2 configuration file called `grub.cfg`. The location of the `grub.cfg`
    file is different in BIOS mode as it resides in `/boot/grub2`:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你运行 `ls -l /boot/efi/EFI/redhat` 命令，目录中包含一个名为 `shimx64.efi` 的第一阶段引导加载程序，一个名为
    `grubx64.efi` 的 GRUB 2 引导加载程序，以及一个名为 `grub.cfg` 的 GRUB 2 配置文件。在 BIOS 模式下，`grub.cfg`
    文件的位置有所不同，它位于 `/boot/grub2`：
- en: '[PRE5]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The `/etc/default/grub` file is responsible for containing the user settings
    for the `grub.cfg` file. Note that this file is also located in the same location
    when in BIOS mode. Furthermore, if you make any changes to this file, the `grub.cfg`
    file will need to be rebuilt:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: '`/etc/default/grub` 文件负责包含用户对 `grub.cfg` 文件的设置。请注意，当处于 BIOS 模式时，该文件的位置也是相同的。此外，如果你对该文件进行了更改，`grub.cfg`
    文件需要重新生成：'
- en: '[PRE6]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'To rebuild the `grub.cfg` file, please use the `grub2-mkconfig` command specifying
    the output file, using the `-o` option, such as `/boot/efi/EFI/redhat/grub.cfg`:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 要重建 `grub.cfg` 文件，请使用 `grub2-mkconfig` 命令并指定输出文件，使用 `-o` 选项，例如 `/boot/efi/EFI/redhat/grub.cfg`：
- en: '[PRE7]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'The utility used to manage the UEFI boot process is called `efibootmgr` (it
    provides a boot menu showing the boot entries). It also allows us to manipulate
    boot entries by doing the following:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 用于管理 UEFI 引导过程的工具称为 `efibootmgr`（它提供一个显示引导条目的引导菜单）。它还允许我们通过以下方式操作引导条目：
- en: Altering the boot order
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 修改引导顺序
- en: Creating boot entries
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建引导条目
- en: Removing boot entries
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 删除引导条目
- en: Specifying the boot entry for the next boot
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 指定下次引导时使用的引导条目
- en: How it works…
  id: totrans-127
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: 'You can view a summary of boot entries by running the `efibootmgr` command
    with no options. For more details, add the `-v` option to it:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过运行不带选项的 `efibootmgr` 命令来查看引导条目的摘要。若要查看更多详细信息，可以添加 `-v` 选项：
- en: '[PRE8]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: As you can see in the preceding example, boot `0004` (Oracle Linux) is the boot
    entry used to start the currently running system, called `BootCurrent`. `BootOrder`
    is the boot order used in the boot manager; consequently, the boot manager will
    boot the first active entry in the list. If it’s not successful, it will try the
    next entry, and so on. If you’re using UEFI on your system, `efibootmgr` is a
    handy command-line tool that enables you to manage your EFI boot entries. With
    this utility, you can easily view, create, modify, and delete boot entries in
    the EFI boot manager.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 如你在上面的示例中看到的那样，启动`0004`（Oracle Linux）是用来启动当前运行系统的启动项，称为`BootCurrent`。`BootOrder`是启动管理器中使用的启动顺序；因此，启动管理器将启动列表中的第一个活动项。如果启动失败，它将尝试下一个项，依此类推。如果你的系统使用UEFI，`efibootmgr`是一个方便的命令行工具，能够帮助你管理EFI启动项。通过这个工具，你可以轻松查看、创建、修改和删除EFI启动管理器中的启动项。
- en: 'If you want to delete a boot entry, you can use the `-B` option. In this case,
    we will delete the CDROM record (`0001`) option using the following command:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想删除启动项，可以使用`-B`选项。在这种情况下，我们将使用以下命令删除CDROM记录（`0001`）选项：
- en: '[PRE9]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'You can also change the boot order with the `-o` option. In the following command,
    we will change the boot order to make the UFEI shell the default boot:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以使用`-o`选项更改启动顺序。在以下命令中，我们将更改启动顺序，使UEFI Shell成为默认启动项：
- en: '[PRE10]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Please use the `man` command to learn more about the `efibootmgr` command.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 请使用`man`命令了解更多关于`efibootmgr`命令的信息。
- en: Warning
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 警告
- en: Be very careful when changing the config. Accidentally changing the boot order
    to a device that is not bootable can put you in a situation where you are recovering
    the system. This is even more important if you are running in an environment where
    you do not have access to the console.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 在更改配置时要非常小心。意外地将启动顺序更改为不可启动的设备，可能会导致你进入系统恢复状态。如果你在没有访问控制台的环境中运行系统，这一点尤其重要。
- en: Playing with Secure Boot
  id: totrans-138
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 玩转安全启动
- en: '**Secure Boot** is an additional optional feature implemented in UEFI intended
    to help prevent malware execution during a boot process. To enable or disable
    Secure Boot, you need to access your specific UEFI setup program. This is different
    for each system manufacturer. Check your system documentation to see how to access
    the UEFI configuration.'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: '**安全启动**是UEFI中实现的一个额外的可选功能，旨在帮助防止在启动过程中恶意软件的执行。要启用或禁用安全启动，你需要访问特定的UEFI设置程序。不同系统制造商的设置程序各不相同，请查阅系统文档了解如何访问UEFI配置。'
- en: 'The Secure Boot steps are identical to the regular UEFI booting but an important
    exception is that it requires the components to be signed and authenticated to
    be loaded and executed (private and public key pairs are used for authentication).
    It consists of two launch **Roots of Trust** (**RoT**) to build the transitive
    trust chains:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 安全启动步骤与常规UEFI启动相同，但有一个重要的例外，那就是它要求加载和执行的组件必须经过签名和身份验证（使用公私钥对进行身份验证）。它包括两个启动**信任根**（**RoT**），以构建传递的信任链：
- en: The verification RoT is responsible for the signature verification. The verification
    RoT is the launch RoT, which is what most are referring to when speaking about
    Secure Boot, and it will lie on the boot flash drive as the RoT for storage to
    protect the key database. Verify only after the **Driver eXecution Environment**
    (**DXE**) phase, not during the **SECurity** (**SEC**) phase.
  id: totrans-141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 验证RoT负责签名验证。验证RoT是启动RoT，这是大多数人在谈论安全启动时所指的内容，它将位于启动闪存驱动器上，作为存储的RoT来保护密钥数据库。仅在**驱动程序执行环境**（**DXE**）阶段进行验证，而不是在**安全**（**SEC**）阶段进行验证。
- en: The measurement RoT is responsible for the measurement collection.
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 测量RoT负责测量数据的收集。
- en: 'Secure Boot will establish a chain of trust by following this process:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 安全启动将通过以下过程建立信任链：
- en: First, the first-stage bootloader (shim) signed by Oracle and Microsoft is authenticated;
    then, it loads the GRUB 2 loader.
  id: totrans-144
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，会验证由Oracle和Microsoft签名的第一阶段引导加载程序（shim）；然后，它加载GRUB 2加载程序。
- en: The GRUB 2 bootloader validates the kernel signature signed by Oracle and authenticates
    it before loading and executing the kernel.
  id: totrans-145
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: GRUB 2引导加载程序验证由Oracle签名的内核签名，并在加载和执行内核之前进行身份验证。
- en: The kernel signed by Oracle is authenticated and executed. Secure Boot loads
    signed/authenticated kernel modules only (for example, all kernel modules included
    with the kernel RPM and those used with Oracle Ksplice have the corresponding
    Oracle signatures and the signed/authenticated kernel module running validated,
    or they would not be loaded).
  id: totrans-146
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Oracle签署的内核已通过身份验证并执行。Secure Boot只加载已签名/已验证的内核模块（例如，所有与内核RPM一起包含的内核模块以及与Oracle
    Ksplice一起使用的内核模块都有相应的Oracle签名，并且已签名/验证的内核模块运行时得到验证，否则将无法加载）。
- en: Now that we have covered some basics of Secure Boot, let’s learn how to sign
    kernel modules with it. First, before you can sign a module, you will need to
    install several required packages, including the source for the kernel. Furthermore,
    you will need to create a signing certificate for a key pair. The private key
    is used to sign the kernel module, and a public key is added to Secure Boot to
    a kernel keyring to allow the system to verify the signature.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经讲解了Secure Boot的基础知识，接下来让我们学习如何使用它来签署内核模块。首先，在你能够签署模块之前，需要安装几个必需的软件包，包括内核源代码。此外，你还需要为密钥对创建签名证书。私钥用于签署内核模块，公钥会被添加到Secure
    Boot的内核密钥环中，允许系统验证签名。
- en: Getting ready
  id: totrans-148
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'The first step is to install the UEK development libraries. This is done with
    the following command:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 第一步是安装UEK开发库。可以使用以下命令完成：
- en: '[PRE11]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Note
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: While you can just run `dnf install kernel-uek-devel`, adding the `uname` option
    to the command makes sure that you install the `devel` packages for the kernel
    you are currently running. Also, don’t forget to make sure your `devel` packages
    are updated after you patch.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然你可以直接运行`dnf install kernel-uek-devel`，但在命令中添加`uname`选项可以确保你安装的是当前运行的内核的`devel`软件包。另外，别忘了在打补丁后确保更新你的`devel`软件包。
- en: 'As a good practice, it is always recommended to update the system to ensure
    that you have the most recent kernel and related packages available:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 作为一种好习惯，强烈建议更新系统，以确保你拥有最新的内核和相关软件包：
- en: '[PRE12]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: This update can take some time, depending on when you last patched the system.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 这个更新可能需要一些时间，具体取决于你上次更新系统的时间。
- en: If you are using the UEK, the kernel headers required to compile kernel modules
    are available in the `kernel-uek-devel` package. When using the UEFI Secure Boot
    functionality, Oracle recommends installing and using the UEK. When installing
    the UEK, also install the `devel` packages. `uname -r` is added to the command
    to make sure the correct headers are installed. This is important if you are not
    running on the latest kernel version. If you are using the RHCK, use `kernel-devel`
    instead of `kernel-uek-devel`.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你使用的是UEK，编译内核模块所需的内核头文件可以通过`kernel-uek-devel`包获得。在使用UEFI Secure Boot功能时，Oracle推荐安装并使用UEK。在安装UEK时，还需要安装`devel`软件包。通过命令中添加`uname
    -r`，确保安装正确的头文件。如果你不是使用最新版本的内核，这一点尤其重要。如果你使用的是RHCK，则应使用`kernel-devel`，而不是`kernel-uek-devel`。
- en: 'It is time to install the utilities required to perform the module signing
    operations (`openssl`, `keyutils`, `mokutil`, and `pesign`):'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是时候安装执行模块签名操作所需的工具（`openssl`、`keyutils`、`mokutil` 和 `pesign`）：
- en: '[PRE13]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'If you require building a module from a source, you can optionally install
    the `Development Tools` group to ensure the option to create tools is available:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你需要从源代码构建模块，你可以选择安装`Development Tools`组，以确保可以创建工具的选项：
- en: '[PRE14]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: How to do it…
  id: totrans-161
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作…
- en: 'Create a configuration file that OpenSSL can use to obtain default values when
    generating your certificates. You can create this file at any location, but it
    is useful to keep it with the rest of your OpenSSL configuration in `/etc/ssl/x509.conf`.
    The file should look similar to the following:'
  id: totrans-162
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个配置文件，供OpenSSL在生成证书时使用，以获取默认值。你可以将此文件放在任何位置，但最好将其与其他OpenSSL配置文件一起保存在`/etc/ssl/x509.conf`中。该文件应类似于以下内容：
- en: '[PRE15]'
  id: totrans-163
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: You should edit the `O`, `CN`, and `emailAddress` fields to be more appropriate.
    Note that in the `extensions` section of the configuration, the `keyUsage` field
    is set as `digitalSignature`. Additionally, the `extendedKeyUsage` option is set
    to `codeSigning` for compatibility with key verification tools.
  id: totrans-164
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 你应编辑`O`、`CN` 和 `emailAddress` 字段，使其更为合适。注意，在配置的`extensions`部分，`keyUsage`字段被设置为`digitalSignature`。此外，`extendedKeyUsage`选项被设置为`codeSigning`，以便与密钥验证工具兼容。
- en: 'Generate a new key pair using this configuration file:'
  id: totrans-165
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用此配置文件生成新的密钥对：
- en: '[PRE16]'
  id: totrans-166
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: This signing certificate is valid for 10 years (3,650 days). Ensure that the
    keys are adequately protected. This can be done by copying the keys off the server
    and storing them in a secure location. Placing the keys on a USB stick and putting
    that in a desk drawer is *not* a secure location. Use a locked location, such
    as a safe.
  id: totrans-167
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 此签名证书有效期为10年（3,650天）。确保密钥得到充分保护。可以通过将密钥从服务器复制并存储在安全位置来实现。将密钥放在USB闪存盘上并将其放入办公桌抽屉中是*不*安全的位置。请使用锁定的位置，如保险箱。
- en: 'Export the certificate in PEM format:'
  id: totrans-168
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导出证书为PEM格式：
- en: '[PRE17]'
  id: totrans-169
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Signing the module
  id: totrans-170
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 签署模块
- en: The `sign-file` utility ensures that the module is signed correctly for the
    kernel. This utility is provided within the kernel source. The following instructions
    assume that you are signing a module for the currently running kernel. If you
    intend to sign a module for a different kernel, you must provide the path to the
    `sign-file` utility within the correct kernel version source. If you do not use
    the right utility, the signature type for your module may not align correctly
    with the expected signature type.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: '`sign-file`工具确保模块已正确签署以适配内核。此工具包含在内核源代码中。以下说明假定您正在为当前运行的内核签署模块。如果您打算为不同的内核签署模块，则必须提供`sign-file`工具所在的正确内核版本源的路径。如果您使用了错误的工具，模块的签名类型可能与预期的签名类型不匹配。'
- en: 'To sign the module, run the `sign-file` utility for your currently running
    kernel and provide it with the path to your private key and the public key that
    you created for the purpose of signing your modules (for this example, I''ve used
    a public module called `hello`):'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 要签署模块，请运行当前内核的`sign-file`工具，并提供私钥和您为签署模块而创建的公钥路径（在此示例中，我使用了一个名为`hello`的公有模块）：
- en: '[PRE18]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Note that the module should already be installed into `/lib/modules/`, and you
    need to provide the correct path to the module.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，模块应已安装到`/lib/modules/`目录中，并且您需要提供正确的模块路径。
- en: Updating the Machine Owner Key database
  id: totrans-175
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 更新机器所有者密钥数据库
- en: '**Machine Owner Key** (**MOK**) is a security feature designed to protect the
    boot process of a computer system from unauthorized modifications or attacks.
    It is typically used in systems that support **UEFI** and Secure Boot, which require
    all bootloaders and kernel modules to be signed by trusted entities.'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: '**机器所有者密钥**（**MOK**）是一项安全功能，旨在保护计算机系统的启动过程，防止未经授权的修改或攻击。它通常用于支持**UEFI**和安全启动的系统，这些系统要求所有启动加载程序和内核模块必须由受信任的实体进行签名。'
- en: The MOK database is stored in a non-volatile memory location within the system’s
    firmware and contains a list of public keys that are allowed to sign the bootloaders
    and kernel modules. Each key in the MOK database is associated with a unique identifier
    and is used to verify the digital signature of the bootloaders and kernel modules.
    If a digital signature is valid, the boot process continues and the software is
    loaded. If a digital signature is not valid or the key used to sign the software
    is not in the MOK database, the boot process is halted and the system will not
    boot.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: MOK数据库存储在系统固件中的非易失性内存位置，包含一个公钥列表，这些公钥允许用于签署启动加载程序和内核模块。MOK数据库中的每个密钥都与唯一标识符相关联，并用于验证启动加载程序和内核模块的数字签名。如果数字签名有效，启动过程将继续，软件将被加载。如果数字签名无效，或用于签署软件的密钥不在MOK数据库中，启动过程将被中止，系统将无法启动。
- en: To enroll an MOK key, you must manually do so on each target system using the
    UEFI system console.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 要注册MOK密钥，您必须在每个目标系统上使用UEFI系统控制台手动进行。
- en: 'Because the key that you created is not included in the UEFI Secure Boot key
    database, you must enroll in the MOK database in the shim by using the `mokutil`
    command:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 由于您创建的密钥不包含在UEFI安全启动密钥数据库中，因此您必须使用`mokutil`命令将其注册到Shim中的MOK数据库：
- en: '[PRE19]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: The previous command prompts you for a single-use password that you use when
    the MOK management service enrolls the key after you reboot the system.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的命令提示您输入一个一次性密码，该密码用于在系统重启后，当MOK管理服务注册密钥时使用。
- en: Reboot the system
  id: totrans-182
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 重启系统
- en: 'The UEFI shim should automatically start the shim UEFI key manager at boot,
    as shown in the following figure. If you do not hit any key within 10 seconds,
    you will be unable to enroll your MOK key:'
  id: totrans-183
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: UEFI Shim应在启动时自动启动Shim UEFI密钥管理器，如下图所示。如果在10秒钟内未按下任何键，您将无法注册您的MOK密钥：
- en: '![Figure 3.11 – Shim utility](img/B18349_03_11.jpg)'
  id: totrans-184
  prefs: []
  type: TYPE_IMG
  zh: '![图3.11 – Shim工具](img/B18349_03_11.jpg)'
- en: Figure 3.11 – Shim utility
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.11 – Shim工具
- en: Press any key to continue.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 按任意键继续。
- en: Then you should see the shim main menu. Select **Enroll MOK** from the menu.
  id: totrans-187
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后您应该会看到Shim主菜单。从菜单中选择**注册 MOK**。
- en: '![Figure 3.12 – Shim main menu](img/B18349_03_12.jpg)'
  id: totrans-188
  prefs: []
  type: TYPE_IMG
  zh: '![图 3.12 – Shim 主菜单](img/B18349_03_12.jpg)'
- en: Figure 3.12 – Shim main menu
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.12 – Shim 主菜单
- en: This will let you continue to enroll the key or view the key.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 这样，您可以继续注册密钥或查看密钥。
- en: Select **View key 0** from the menu (as shown in the following figure) to display
    the key details.
  id: totrans-191
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从菜单中选择**查看密钥 0**（如下图所示）以显示密钥详情。
- en: '![Figure 3.13 – View key](img/B18349_03_13.jpg)'
  id: totrans-192
  prefs: []
  type: TYPE_IMG
  zh: '![图 3.13 – 查看密钥](img/B18349_03_13.jpg)'
- en: Figure 3.13 – View key
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.13 – 查看密钥
- en: 'This will then display the key details. Verify that the values presented match
    the key you used to sign the module and that you inserted into the kernel image:'
  id: totrans-194
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这将显示密钥详情。验证显示的值是否与您用于签署模块的密钥匹配，并且该密钥已插入内核映像中：
- en: '![Figure 3.14 – Key details](img/B18349_03_14.jpg)'
  id: totrans-195
  prefs: []
  type: TYPE_IMG
  zh: '![图 3.14 – 密钥详情](img/B18349_03_14.jpg)'
- en: Figure 3.14 – Key details
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.14 – 密钥详情
- en: Then press any key to return to the **Enroll** **MOK** menu.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 然后按任意键返回到**注册** **MOK**菜单。
- en: Select **Continue** from the menu.
  id: totrans-198
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从菜单中选择**继续**。
- en: The **Enroll the key(s)?** screen is displayed, and you can now select **Yes**
    from the menu (as shown in the following figure).
  id: totrans-199
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 显示**注册密钥？**屏幕，现在可以从菜单中选择**是**（如下图所示）。
- en: '![Figure 3.15 – Enrolling the key](img/B18349_03_15.jpg)'
  id: totrans-200
  prefs: []
  type: TYPE_IMG
  zh: '![图 3.15 – 注册密钥](img/B18349_03_15.jpg)'
- en: Figure 3.15 – Enrolling the key
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.15 – 注册密钥
- en: Select **Yes** to enroll the key.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 选择**是**以注册密钥。
- en: You will then be prompted for a password. Enter the password you used when you
    imported the key using the `mokutil` command.
  id: totrans-203
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后会提示您输入密码。请输入使用`mokutil`命令导入密钥时使用的密码。
- en: The key is enrolled within the UEFI Secure Boot key database.
  id: totrans-204
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 密钥已注册到UEFI安全启动密钥数据库中。
- en: You are now redirected to the main menu. Select **Reboot** from the menu.
  id: totrans-205
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您现在将被重定向到主菜单。从菜单中选择**重启**。
- en: '![Figure 3.16 – Reboot when done](img/B18349_03_16.jpg)'
  id: totrans-206
  prefs: []
  type: TYPE_IMG
  zh: '![图 3.16 – 完成后重启](img/B18349_03_16.jpg)'
- en: Figure 3.16 – Reboot when done
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.16 – 完成后重启
- en: How it works…
  id: totrans-208
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理……
- en: After booting the system, you can validate whether a key is included in the
    appropriate kernel keyring. Validation depends on the kernel version that you
    are running. Also, the keyring name that you need to check varies, as the implementation
    has changed across kernel versions.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 启动系统后，您可以验证密钥是否已包含在适当的内核密钥环中。验证取决于您正在运行的内核版本。此外，您需要检查的密钥环名称有所不同，因为各个内核版本中的实现有所变化。
- en: If the key generated for signing custom modules is listed within the correct
    keyring, you can load modules signed with this key while in Secure Boot mode.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 如果为签署自定义模块生成的密钥已列在正确的密钥环中，您可以在安全启动模式下加载使用此密钥签署的模块。
- en: For RHCK on Oracle Linux 8 and UEK R6U3 kernels or later, keys within both the
    `builtin_trusted_keys` keyring and the `platform` keyring are trusted for both
    module signing and for the `kexec` tools, which means you can follow the standard
    procedure to sign a module and add it to the MOK database for the key to appear
    in the `platform` keyring, and it is automatically trusted.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 对于Oracle Linux 8上的RHCK和UEK R6U3内核或更高版本，`builtin_trusted_keys`密钥环和`platform`密钥环中的密钥都被信任用于模块签名以及`kexec`工具，这意味着您可以按照标准程序签署模块并将其添加到MOK数据库中，使密钥出现在`platform`密钥环中，并且会自动被信任。
- en: 'Because a key can be loaded into the `builtin_trusted_keys` keyring, you should
    check both keyrings for the module signing key. Here’s an example:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 由于密钥可以加载到`builtin_trusted_keys`密钥环中，因此您应检查两个密钥环中的模块签名密钥。以下是一个示例：
- en: '[PRE20]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: TrenchBoot – improving boot security and integrity
  id: totrans-214
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: TrenchBoot – 提高启动安全性和完整性
- en: '**TrenchBoot** is a GitHub cross-community and cross-platform framework integration
    that grew from an idea by Apertus Solutions that originated in 2014 to deal with
    the limitations of using tboot to launch Xen for the OpenXT project and other
    contributors, such as Oracle (Intel), 3mdep (AMD), and Citrix ([https://github.com/TrenchBoot](https://github.com/TrenchBoot)).
    Its primary purpose is to expand the mechanism of security and the integrity of
    the boot process by using a standard and unified approach (between Xen, KVM, Linux,
    BSDs, and potentially proprietary kernels). A common location where you will see
    this being used is Oracle Cloud’s shielded instances.'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: '**TrenchBoot** 是一个 GitHub 跨社区、跨平台框架集成，源自 2014 年 Apertus Solutions 的一个想法，旨在解决使用
    tboot 启动 Xen 时的局限性，服务于 OpenXT 项目及其他贡献者，如 Oracle（Intel）、3mdep（AMD）和 Citrix（[https://github.com/TrenchBoot](https://github.com/TrenchBoot)）。其主要目的是通过使用统一的标准方法（适用于
    Xen、KVM、Linux、BSD 及可能的专有内核），扩展安全性机制和引导过程的完整性。一个常见的应用场景是 Oracle Cloud 的受保护实例。'
- en: Getting ready
  id: totrans-216
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 准备就绪
- en: 'One of the main capabilities of TrenchBoot is securely launching Linux. This
    feature enables the Linux kernel to be dynamically launched by AMD and Intel by
    introducing an intermediate phase to the boot launch. Unlike traditional first-launch
    scenarios, such as the bootstrap phase used by open source dynamic launch tools
    such as XMHF, OSLO, OpenText Secure Boot, and tboot, TrenchBoot provides the ability
    to launch kernel upgrades through a key exec. You could then launch an integrity
    kernel that could dynamically inspect the system and establish the integrity of
    the platform before persisting everything to a diskless embedded environment during
    a shutdown. Note that the newly introduced **intermediate p****hase** includes
    an **intermediate loader** called **TrenchBoot Loader** that various bootstrap
    solutions can launch. TrenchBoot Loader contains the **TrenchBoot Security Engine**,
    which implements integrity processing. Please refer to the following diagram:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: TrenchBoot 的主要功能之一是安全地启动 Linux。此功能通过引入一个中间阶段来动态启动 AMD 和 Intel 的 Linux 内核。与传统的首次启动场景（如
    XMHF、OSLO、OpenText Secure Boot 和 tboot 等开源动态启动工具使用的引导阶段）不同，TrenchBoot 提供了通过关键执行启动内核升级的能力。然后，您可以启动一个完整性内核，它能够动态检查系统并在关机时将平台的完整性建立在一个无盘嵌入式环境中。请注意，新的**中间阶段**包括一个名为**TrenchBoot
    Loader**的**中间加载程序**，各种引导解决方案可以启动它。TrenchBoot Loader 包含**TrenchBoot 安全引擎**，它实现了完整性处理。请参阅以下图示：
- en: '![Figure 3.17 – TrenchBoot process overview](img/B18349_03_17.jpg)'
  id: totrans-218
  prefs: []
  type: TYPE_IMG
  zh: '![图 3.17 – TrenchBoot 过程概述](img/B18349_03_17.jpg)'
- en: Figure 3.17 – TrenchBoot process overview
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.17 – TrenchBoot 过程概述
- en: Oracle has added more TrenchBoot support to the Oracle Linux kernel to enable
    a Secure Boot protocol for the Linux kernel for multiple use cases, such as **two-factor
    authentication** (**2FA**) for laptops or crowdsourcing integrity handling; this
    option is the best choice.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: Oracle 在 Oracle Linux 内核中添加了更多的 TrenchBoot 支持，以启用 Linux 内核的安全启动协议，适用于多个用例，如笔记本的**双因素认证**（**2FA**）或众包完整性处理；这个选项是最佳选择。
- en: Note
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: You can see some of Oracle’s efforts by reading the kernel.org archive at [https://lore.kernel.org/lkml/20230504145023.835096-1-ross.philipson@oracle.com/](mailto:https://lore.kernel.org/lkml/20230504145023.835096-1-ross.philipson@oracle.com/).
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过阅读 kernel.org 存档来了解 Oracle 的一些努力，链接为：[https://lore.kernel.org/lkml/20230504145023.835096-1-ross.philipson@oracle.com/](mailto:https://lore.kernel.org/lkml/20230504145023.835096-1-ross.philipson@oracle.com/)。
- en: How it works…
  id: totrans-223
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: 'The TrenchBoot Loader is composed of well-known components such as Linux and
    u-root. Let’s take a closer look at the main components within it:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: TrenchBoot 引导程序由一些知名组件构成，如 Linux 和 u-root。让我们深入了解其中的主要组件：
- en: A TrenchBoot-enabled kernel with integrated TrenchBoot u-root initramfs
  id: totrans-225
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 启用 TrenchBoot 的内核，集成 TrenchBoot u-root initramfs
- en: Integrated TrenchBoot Security Engine as an extension to u-root
  id: totrans-226
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 作为 u-root 扩展的集成 TrenchBoot 安全引擎
- en: A new image that can be launched by the boot loader
  id: totrans-227
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个可以通过引导程序启动的新镜像
- en: 'This build process is shown in the following diagram:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 该构建过程如下图所示：
- en: '![Figure 3.18 – TrenchBoot image process](img/B18349_03_18.jpg)'
  id: totrans-229
  prefs: []
  type: TYPE_IMG
  zh: '![图 3.18 – TrenchBoot 镜像处理过程](img/B18349_03_18.jpg)'
- en: Figure 3.18 – TrenchBoot image process
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.18 – TrenchBoot 镜像处理过程
- en: 'The main benefits of using TrenchBoot are as follows:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 TrenchBoot 的主要优势如下：
- en: '**Secure boot**: TrenchBoot provides a Secure Boot process that ensures that
    only trusted software is executed on the system. This prevents the execution of
    malicious software that could compromise the system.'
  id: totrans-232
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**安全启动**：TrenchBoot提供一个安全启动过程，确保系统上只执行可信的软件。这可以防止执行可能危及系统的恶意软件。'
- en: '**Runtime integrity**: TrenchBoot ensures that the system remains secure even
    after booting by verifying the integrity of the software and data at runtime.
    It uses technologies such as Intel SGX and AMD SEV to provide hardware-based isolation
    and attestation.'
  id: totrans-233
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**运行时完整性**：TrenchBoot通过在运行时验证软件和数据的完整性，确保系统在启动后仍然保持安全。它使用诸如Intel SGX和AMD SEV等技术来提供基于硬件的隔离和认证。'
- en: '**Protection against attacks**: TrenchBoot provides protection against various
    types of attacks, including firmware attacks, malware, and kernel rootkits.'
  id: totrans-234
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**防御攻击**：TrenchBoot提供对各种类型攻击的防护，包括固件攻击、恶意软件和内核rootkit。'
- en: '**Platform-agnostic**: TrenchBoot is platform-agnostic and can be used on different
    hardware platforms, including x86, Arm, and RISC-V.'
  id: totrans-235
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**平台无关性**：TrenchBoot是平台无关的，可以在不同的硬件平台上使用，包括x86、Arm和RISC-V。'
- en: '**Open source**: TrenchBoot is an open source project, which means that anyone
    can inspect the code and contribute to its development. This makes TrenchBoot
    more transparent and trustworthy.'
  id: totrans-236
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**开源**：TrenchBoot是一个开源项目，任何人都可以检查其代码并为其开发做出贡献。这使得TrenchBoot更加透明和值得信赖。'
- en: Removing the RHCK
  id: totrans-237
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 移除RHCK
- en: In this recipe, you will learn how to remove RHCK and its unique package dependencies
    while keeping all of UEK dependencies. Remember that when installing Oracle Linux,
    the installer automatically installs the Oracle UEK as the default kernel, but
    you can install RHCK for compatibility purposes.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个教程中，你将学习如何移除RHCK及其独特的软件包依赖关系，同时保留所有UEK依赖关系。记住，在安装Oracle Linux时，安装程序会自动安装Oracle
    UEK作为默认内核，但你可以为了兼容性目的安装RHCK。
- en: Getting ready
  id: totrans-239
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: Old versions of Oracle Linux required a special tool called the `kernel-transition`
    package to manage dependencies. With new versions of Oracle Linux, a much easier
    process is available. For example, with Oracle Linux 8, this requirement is obsolete.
    All packages are purposely built to avoid any dependencies with regard to the
    system running on a UEK or RHCK. This makes it significantly easier to remove
    the UEK or RHCK from the system.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 旧版本的Oracle Linux需要一个叫做`kernel-transition`的工具来管理依赖关系。在新版本的Oracle Linux中，提供了一个更简便的过程。例如，在Oracle
    Linux 8中，这一要求已经过时。所有软件包都特别构建以避免与系统上运行的UEK或RHCK相关的任何依赖关系。这使得从系统中移除UEK或RHCK变得更加容易。
- en: How to do it…
  id: totrans-241
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作……
- en: 'Let’s see how to remove RHCK from our system:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看如何从系统中移除RHCK：
- en: 'First, let’s check all kernels running within our system by using the `grubby`
    command:'
  id: totrans-243
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，让我们使用`grubby`命令检查系统中所有正在运行的内核：
- en: '![Figure 3.19 – Checking the kernels](img/B18349_03_19.jpg)'
  id: totrans-244
  prefs: []
  type: TYPE_IMG
  zh: '![图3.19 – 检查内核](img/B18349_03_19.jpg)'
- en: Figure 3.19 – Checking the kernels
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.19 – 检查内核
- en: We can see in the preceding output that the default kernel in use is `/boot/vmlinuz-5.15.0-8.91.4.1.el8uek.x86_64`,
    which is a UEK; also, we can see that we have a couple of RHCKs installed, `/boot/vmlinuz-4.18.0-425.13.1.el8_7.x86_64`
    and `/boot/vmlinuz-4.18.0-425.3.1.el8.x86_64`, that we can safely remove.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在前面的输出中看到，当前使用的默认内核是`/boot/vmlinuz-5.15.0-8.91.4.1.el8uek.x86_64`，这是一个UEK；同时，我们也可以看到安装了几个RHCK，`/boot/vmlinuz-4.18.0-425.13.1.el8_7.x86_64`和`/boot/vmlinuz-4.18.0-425.3.1.el8.x86_64`，这些我们可以安全地移除。
- en: Now that we know that we are using a UEK, we can safely remove the desired RHCK
    using the `dnf remove kernel` command as recommended in the Oracle Linux manual.
    It will detect the unused kernels and show the dependencies within them.
  id: totrans-247
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们知道我们正在使用UEK，可以安全地按照Oracle Linux手册中推荐的方式使用`dnf remove kernel`命令来移除所需的RHCK。它会检测未使用的内核并显示其中的依赖关系。
- en: '![Figure 3.20 – dnf remove kernel](img/B18349_03_20.jpg)'
  id: totrans-248
  prefs: []
  type: TYPE_IMG
  zh: '![图3.20 – dnf remove kernel](img/B18349_03_20.jpg)'
- en: Figure 3.20 – dnf remove kernel
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.20 – dnf remove kernel
- en: As you can see in the preceding screenshot, both installed RHCKs were detected
    and deleted from the system. Now, let’s run the `grubby` command again to see
    whether the RHCKs were really removed from our system boot options.
  id: totrans-250
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如你在上面的截图中看到的，系统中已检测到并删除了所有已安装的RHCK。现在，让我们再次运行`grubby`命令，查看RHCK是否真的从系统启动选项中移除。
- en: Warning
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 警告
- en: Do not run `dnf remove kernel` a second time. This may accidentally remove the
    booting kernel, resulting in a system that will no longer boot.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 不要第二次运行`dnf remove kernel`。这样可能会意外地删除启动内核，导致系统无法启动。
- en: '![Figure 3.21 – RHCK removed](img/B18349_03_21.jpg)'
  id: totrans-253
  prefs: []
  type: TYPE_IMG
  zh: '![图 3.21 – RHCK 已移除](img/B18349_03_21.jpg)'
- en: Figure 3.21 – RHCK removed
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.21 – RHCK 已移除
- en: Sadly, both kernels are still there. The RHCK `kernel-<version>` package is
    merely a metadata package containing no files. It is intended to ensure all dependent
    kernel packages are correctly installed. So, in other words, removing the `"kernel-<version>.el8"`
    RPM does not remove any of the kernel-subpackages, which includes the packages
    that update the `/boot` associated files and the boot loader entries.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 很遗憾，两个内核仍然存在。RHCK 的 `kernel-<version>` 包仅仅是一个元数据包，不包含任何文件。它的作用是确保所有依赖的内核包都正确安装。换句话说，移除
    `"kernel-<version>.el8"` RPM 并不会删除任何内核子包，其中包括更新 `/boot` 相关文件和启动加载器条目的包。
- en: To solve this situation, we need to remove the corresponding `kernel-core-<version>`
    packages containing the `/boot/` and all kernel-related files/directories.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解决这个问题，我们需要移除包含 `/boot/` 以及所有内核相关文件/目录的对应 `kernel-core-<version>` 包。
- en: 'As shown in the following screenshot, we will use the `dnf erase kernel-core`
    command to remove all related `kernel-core` packages:'
  id: totrans-257
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如下图所示，我们将使用 `dnf erase kernel-core` 命令来删除所有相关的 `kernel-core` 包：
- en: '![Figure 3.22 – dnf erase kernel-core](img/B18349_03_22.jpg)'
  id: totrans-258
  prefs: []
  type: TYPE_IMG
  zh: '![图 3.22 – dnf 删除 kernel-core](img/B18349_03_22.jpg)'
- en: Figure 3.22 – dnf erase kernel-core
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.22 – dnf 删除 kernel-core
- en: 'Now, let’s rerun the `grubby` command to see whether the RHCKs were removed
    this time from our system:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们重新运行 `grubby` 命令，看看这次是否从系统中移除了 RHCK：
- en: '![Figure 3.23 –  grubby post RHCK removal](img/B18349_03_23.jpg)'
  id: totrans-261
  prefs: []
  type: TYPE_IMG
  zh: '![图 3.23 – 移除 RHCK 后的 grubby](img/B18349_03_23.jpg)'
- en: Figure 3.23 – grubby post RHCK removal
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.23 – 移除 RHCK 后的 grubby
- en: As you can now see, all RHCKs were removed from our system.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，所有 RHCK 已从我们的系统中移除。
- en: 'Furthermore, if you later decide to restore the deleted RHCKs, you can quickly
    restore them using the `dnf install` `kernel` command:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，如果您之后决定恢复已删除的 RHCK，您可以通过 `dnf install` `kernel` 命令快速恢复它们：
- en: '![Figure 3.24 – Reinstalling the RHCK](img/B18349_03_24.jpg)'
  id: totrans-265
  prefs: []
  type: TYPE_IMG
  zh: '![图 3.24 – 重新安装 RHCK](img/B18349_03_24.jpg)'
- en: Figure 3.24 – Reinstalling the RHCK
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.24 – 重新安装 RHCK
- en: As you can see, with Oracle Linux, switching kernels is a simple task, as is
    removing kernels from the operating system. When you have a chance, compare the
    system performance between the RHCK and UEKs; you will be pleasantly surprised
    how much faster tasks such as I/O are with the more modern UEK.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，在 Oracle Linux 上，切换内核是一项简单的任务，移除操作系统中的内核也是如此。您有机会时，可以比较 RHCK 和 UEK 之间的系统性能；您会惊讶地发现，UEK
    在处理 I/O 等任务时要快得多。
