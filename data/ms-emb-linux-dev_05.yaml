- en: '4'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '4'
- en: Configuring and Building the Kernel
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 配置和构建内核
- en: The kernel is the third element of embedded Linux. It is the component that
    is responsible for managing resources and interfacing with hardware. As such,
    it affects almost every aspect of your final software build. Each finished kernel
    is usually configured for some specific hardware. However, device trees enable
    us to employ a generic kernel and tailor it for our custom hardware using the
    contents of the DTB, as we saw in [*Chapter 3*](Chapter_03.xhtml#_idTextAnchor061).
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 内核是嵌入式Linux的第三个组成部分。它是负责管理资源和与硬件接口的组件。因此，它几乎影响你最终软件构建的方方面面。每个完成的内核通常会为某些特定硬件进行配置。然而，设备树使我们能够使用通用内核，并通过DTB的内容将其定制为我们的硬件，就像我们在[*第3章*](Chapter_03.xhtml#_idTextAnchor061)中看到的那样。
- en: In this chapter, we will look at how to get a kernel for a board and how to
    configure and compile it. We will look again at Bootstrap, this time, focusing
    on the part the kernel plays. We will also look at device drivers and how they
    pick up information from the device tree.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将探讨如何为一个开发板获取内核，如何配置和编译内核。我们将再次回顾引导过程，这次重点讨论内核的角色。我们还将探讨设备驱动程序以及它们如何从设备树中获取信息。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将覆盖以下主题：
- en: What does the kernel do?
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 内核的作用是什么？
- en: Choosing a kernel
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 选择一个内核
- en: Configuring the kernel
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 配置内核
- en: Compiling with `Kbuild`
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`Kbuild`进行编译
- en: Building and booting the kernel
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构建和启动内核
- en: Observing the kernel boot process
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 观察内核启动过程
- en: Porting Linux to a new board
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将Linux移植到新板子上
- en: Technical requirements
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'To follow along with the examples, make sure you have the following:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 为了跟随示例，请确保你具备以下设备：
- en: An Ubuntu 24.04 or later LTS-based host system
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个基于Ubuntu 24.04或更高版本LTS的主机系统
- en: A Bootlin `aarch64` toolchain from [*Chapter 2*](Chapter_01.xhtml#_idTextAnchor028)
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个来自[*第2章*](Chapter_01.xhtml#_idTextAnchor028)的Bootlin `aarch64`工具链
- en: A microSD card reader and card
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个microSD卡读卡器和卡
- en: A microSD card with U-Boot installed from [*Chapter 3*](Chapter_03.xhtml#_idTextAnchor061)
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个安装了U-Boot的microSD卡，来自[*第3章*](Chapter_03.xhtml#_idTextAnchor061)
- en: A USB to TTL serial cable with 3.3V logic level
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一条具有3.3V逻辑电平的USB至TTL串口电缆
- en: The Raspberry Pi 4
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Raspberry Pi 4
- en: The BeaglePlay
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: BeaglePlay
- en: A 5V USB-C power supply capable of delivering 3A
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个能够提供3A电流的5V USB-C电源供应器
- en: 'The code used in this chapter can be found in the chapter folder in this book’s
    GitHub repository: [https://github.com/PacktPublishing/Mastering-Embedded-Linux-Development/tree/main/Chapter04](https://github.com/PacktPublishing/Mastering-Embedded-Linux-Development/tree/main/Chapter04).'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 本章使用的代码可以在本书GitHub仓库中的章节文件夹中找到：[https://github.com/PacktPublishing/Mastering-Embedded-Linux-Development/tree/main/Chapter04](https://github.com/PacktPublishing/Mastering-Embedded-Linux-Development/tree/main/Chapter04)。
- en: What does the kernel do?
  id: totrans-23
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 内核的作用是什么？
- en: 'Linux began in 1991 when Linus Torvalds started writing an operating system
    for Intel 386- and 486-based personal computers. He was inspired by the MINIX
    operating system written by Andrew S. Tanenbaum four years earlier. Linux differed
    in many ways from MINIX; the main differences being that it was a 32-bit virtual
    memory kernel, and the code was open source, later released under the GPL v2 license.
    He announced it on 25th August 1991 on the `comp.os.minix` newsgroup in a famous
    post that began with:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: Linux始于1991年，当时Linus Torvalds开始为Intel 386和486架构的个人计算机编写操作系统。他受到四年前Andrew S.
    Tanenbaum编写的MINIX操作系统的启发。Linux与MINIX在许多方面有所不同；主要的区别是，Linux是一个32位虚拟内存内核，而且它的代码是开源的，后来以GPL
    v2许可证发布。他在1991年8月25日通过`comp.os.minix`新闻组发表了一篇著名的帖子，内容如下：
- en: Hello everybody out there using minix—I’m doing a (free) operating system (just
    a hobby, won’t be big and professional like GNU) for 386(486) AT clones. This
    has been brewing since April, and is starting to get ready. I’d like any feedback
    on things people like/dislike in minix, as my OS resembles it somewhat (same physical
    layout of the filesystem (due to practical reasons) among other things).
  id: totrans-25
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 大家好，正在使用minix的朋友们——我正在为386(486) AT克隆机编写一个（免费的）操作系统（只是一个爱好，不会像GNU那样大而专业）。这个项目自四月以来一直在酝酿，现已开始准备就绪。我希望能得到关于minix中大家喜欢/不喜欢的反馈，因为我的操作系统在某些方面与它相似（例如相同的文件系统物理布局（出于实际原因）等）。
- en: To be strictly accurate, Linus did not write an operating system. He wrote a
    kernel, which is only one component of an operating system. To create a complete
    operating system with user space commands and a shell command interpreter, he
    used components from the GNU project, especially the toolchain, the C library,
    and basic command-line tools. That distinction remains today and gives Linux a
    lot of flexibility in the way it is used.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 严格来说，Linus 并没有编写一个操作系统。他编写了一个内核，而内核只是操作系统的一个组成部分。为了创建一个完整的操作系统，其中包含用户空间命令和一个
    shell 命令解释器，他使用了来自 GNU 项目的组件，特别是工具链、C 库和基本的命令行工具。这一区别至今仍然存在，并且赋予了 Linux 在使用方式上的极大灵活性。
- en: '**Berkeley Software Distribution** (**BSD**) predates Linux by many years.
    BSD began as a research project at the University of California, Berkeley’s renowned
    Computer Systems Research Group sometime in the late 1970s. Originally known as
    Berkeley Unix, BSD was based on the original Unix source code developed at Bell
    Labs. Now a defunct operating system, BSD lives on in the form of its open source
    descendants including FreeBSD, OpenBSD, and NetBSD. Most notably, the Darwin open
    source operating system used in Apple’s macOS and iOS is a derivative of BSD.'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: '**伯克利软件分发版**（**BSD**）比 Linux 早了很多年。BSD 起源于 1970 年代末期，加利福尼亚大学伯克利分校著名的计算机系统研究小组的一个研究项目。最初称为伯克利
    Unix，BSD 基于贝尔实验室开发的原始 Unix 源代码。如今，BSD 已成为一个废弃的操作系统，但它的开源后代，如 FreeBSD、OpenBSD 和
    NetBSD 仍在延续。最著名的例子是，苹果公司 macOS 和 iOS 操作系统中的开源系统 Darwin 就是 BSD 的衍生版本。'
- en: The Linux kernel can be combined with a GNU user space to create a full Linux
    distribution that runs on desktops and servers, which is sometimes called GNU/Linux.
    It can be combined with an Android user space to create the well-known mobile
    operating system, or it can be combined with a small BusyBox-based user space
    to create a compact embedded system.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: Linux 内核可以与 GNU 用户空间结合，创建一个完整的 Linux 发行版，运行在桌面和服务器上，这通常被称为 GNU/Linux。它还可以与 Android
    用户空间结合，创建著名的移动操作系统，或者它可以与一个基于 BusyBox 的小型用户空间结合，创建一个紧凑的嵌入式系统。
- en: Contrast this with the BSD operating systems (FreeBSD, OpenBSD, and NetBSD)
    in which the kernel, toolchain, and user space are combined into a single code
    base. By removing the toolchain, you can deploy slimmer runtime images without
    a compiler or header files. By decoupling user space from the kernel, you gain
    options in terms of init systems (`runit` vs `systemd`), C libraries (`musl` vs
    `glibc`) and package formats (`.apk` vs `.deb`).
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 与此对比的是 BSD 操作系统（FreeBSD、OpenBSD 和 NetBSD），在这些系统中，内核、工具链和用户空间被组合成一个统一的代码库。通过去除工具链，你可以部署更简洁的运行时镜像，而不需要编译器或头文件。通过将用户空间与内核解耦，你可以在初始化系统（`runit`
    与 `systemd`）、C 库（`musl` 与 `glibc`）以及软件包格式（`.apk` 与 `.deb`）上获得更多选择。
- en: 'The kernel has three main jobs – to manage resources, to interface with hardware,
    and to provide an API that offers a useful level of abstraction to user space
    programs, as summarized in the following diagram:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 内核有三个主要功能——管理资源、与硬件交互，并提供一个 API，为用户空间程序提供有用的抽象层，概述如下图：
- en: '![Figure 4.1 − User space, kernel space, and hardware](img/B18466_04_01.png)'
  id: totrans-31
  prefs: []
  type: TYPE_IMG
  zh: '![图 4.1 − 用户空间、内核空间和硬件](img/B18466_04_01.png)'
- en: Figure 4.1 − User space, kernel space, and hardware
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.1 − 用户空间、内核空间和硬件
- en: Applications running in **user space** run at a low CPU privilege level. They
    can do very little other than make library calls. The primary interface between
    user space and **kernel space** is the **C library,** which translates user-level
    functions, such as those defined by POSIX, into kernel system calls. The system
    call interface uses an architecture-specific method, such as a trap or a software
    interrupt, to switch the CPU from low-privilege user mode to high-privilege kernel
    mode. A CPU running in kernel mode has access to all memory addresses and CPU
    registers.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 运行在**用户空间**的应用程序运行在较低的 CPU 特权级别。它们几乎只能做一些库调用。用户空间和**内核空间**之间的主要接口是**C 库**，它将用户级函数（如
    POSIX 定义的函数）转换为内核系统调用。系统调用接口使用架构特定的方法，如陷阱或软件中断，将 CPU 从低特权用户模式切换到高特权内核模式。运行在内核模式下的
    CPU 可以访问所有内存地址和 CPU 寄存器。
- en: The system call handler dispatches the call to the appropriate kernel subsystem.
    Memory allocation calls go to the memory manager, filesystem calls to the filesystem
    code, and so on. Some of those calls require input from the underlying hardware
    and will be passed down to a device driver. In some cases, the hardware itself
    invokes a kernel function by raising an interrupt.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 系统调用处理程序将调用分派给适当的内核子系统。内存分配调用会交给内存管理器，文件系统调用会交给文件系统代码，依此类推。某些调用需要底层硬件的输入，并会传递给设备驱动程序。在某些情况下，硬件本身通过触发中断来调用内核函数。
- en: '**IMPORTANT NOTE**'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: '**重要提示**'
- en: 'The diagram in *Figure 4.1* shows that there is a second entry point into kernel
    code: hardware interrupts. Interrupts can only be handled in a device driver,
    never by a user space application.'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 4.1*中的图示表明，内核代码有第二个入口点：硬件中断。中断只能在设备驱动程序中处理，用户空间应用程序无法处理。'
- en: In other words, all the useful things that your application does are done through
    the kernel. The kernel is therefore one of the most important elements in the
    system. So, it is important to understand how to choose one.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 换句话说，你的应用程序所做的所有有用的事情，都是通过内核来完成的。因此，内核是系统中最重要的元素之一。所以，理解如何选择一个内核非常重要。
- en: Choosing a kernel
  id: totrans-38
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 选择内核
- en: The next step is to choose the kernel for your project. It is important to balance
    your desire to always use the latest version of software against the need for
    vendor-specific additions and an interest in the long-term support of the code
    base.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是为你的项目选择内核。需要平衡你总是使用最新软件版本的愿望与对供应商特定补丁的需求，以及对代码库长期支持的兴趣。
- en: Kernel development cycle
  id: totrans-40
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 内核开发周期
- en: Linux is developed at a fast pace with a new version being released every 8
    to 12 weeks. The way that the version numbers are constructed has changed over
    the years. Before July 2011, there was a three-number version scheme with version
    numbers that looked like 2.6.39\. The middle number indicated whether it was a
    developer or stable release. Odd numbers (2.1.x, 2.3.x, 2.5.x) were for developers.
    Even numbers were for end users.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: Linux 的开发速度非常快，每 8 到 12 周就会发布一个新版本。版本号的构建方式多年来发生了变化。在 2011 年 7 月之前，使用三位数版本方案，版本号像
    2.6.39。中间的数字表示它是开发者版本还是稳定版本。奇数（2.1.x、2.3.x、2.5.x）是给开发者的，偶数版本是给最终用户的。
- en: From version 2.6 onward, the idea of a long-lived development branch (the odd
    numbers) was dropped, as it slowed down the rate at which new features were made
    available to the users. The change in numbering from 2.6.39 to 3.0 in July 2011
    was purely because Linus felt that the numbers were becoming too large.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 从 2.6 版本开始，Linux 放弃了长生命周期的开发分支（奇数版本），因为它减缓了新功能对用户的发布速度。2011 年 7 月，从 2.6.39 到
    3.0 的版本号变更，纯粹是因为 Linus 觉得版本号变得太大了。
- en: 'There was no huge leap in the features or architecture of Linux between those
    two versions. He also took the opportunity to drop the middle number. Since then,
    Linus has bumped the major version three more times: next in April 2015 (3 to
    4), again in March 2019 (4 to 5), and most recently, in October 2022 (5 to 6).
    Each time, he did this purely for neatness, not because of any large architectural
    shift.'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 在这两个版本之间，Linux 的功能或架构没有发生巨大变化。他还借此机会去掉了中间的数字。从那时起，Linus 已经将主版本号提升了三次：2015 年
    4 月（从 3 升级到 4），2019 年 3 月（从 4 升级到 5），以及最近的 2022 年 10 月（从 5 升级到 6）。每次版本号的提升都是出于整洁的考虑，而不是因为有大的架构变化。
- en: 'Linus manages the development kernel tree. You can follow him by cloning the
    Git tree like so:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: Linus 管理着开发内核树。你可以通过克隆 Git 树来关注他，方法如下：
- en: '[PRE0]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: This will check the source out into a subdirectory named `linux`. You can keep
    up to date by running the command `git pull` in that directory from time to time.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 这将把源代码检出到一个名为`linux`的子目录。你可以通过时不时在该目录下运行`git pull`命令来保持最新。
- en: A full cycle of kernel development begins with a merge window of two weeks during
    which Linus will accept patches for new features. At the end of the merge window,
    a stabilization phase begins. Once the merge window closes, Linus will produce
    weekly release candidates with version numbers ending in `-rc1`, `-rc2`, and so
    on, usually up to `-rc7` or `-rc8`. During this time, people test the candidates
    and submit bug reports and fixes. When all significant bugs have been fixed, the
    kernel is released.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 内核开发的完整周期始于为期两周的合并窗口，在此期间，Linus 会接受用于新特性的补丁。合并窗口结束时，进入稳定化阶段。一旦合并窗口关闭，Linus 会发布带有版本号
    `-rc1`、`-rc2` 等的每周发布候选版本，通常会发布到 `-rc7` 或 `-rc8`。在此期间，人们会测试候选版本并提交错误报告和修复。当所有重大错误都被修复后，内核正式发布。
- en: The code incorporated during the merge window needs to be fairly mature already.
    Usually, it is pulled from the repositories of the many subsystems and architecture
    maintainers of the kernel. By keeping to a short development cycle, features can
    be merged when they are ready. If a feature is deemed not sufficiently stable
    or well developed by the kernel maintainers, it can simply be delayed until the
    next release.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 在合并窗口期间合并的代码通常已经相当成熟。通常，它是从许多子系统和内核架构维护者的仓库中拉取的。通过保持短周期的开发，特性可以在准备好时进行合并。如果内核维护者认为某个特性不够稳定或不够完善，它可以被推迟到下一个版本。
- en: Keeping track of what has changed from release to release is not easy. You can
    read the commit log in Linus’ Git repository but, with so many entries, it is
    not easy to get an overview. Thankfully, there is the Linux **Kernel Newbies**
    website ([https://kernelnewbies.org](https://kernelnewbies.org)) where you can
    find a succinct overview of each version at [https://kernelnewbies.org/LinuxVersions](https://kernelnewbies.org/LinuxVersions).
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 跟踪每个版本之间的变化并不容易。你可以阅读 Linus 的 Git 仓库中的提交日志，但由于条目过多，很难获得整体概览。幸运的是，Linux 有一个**Kernel
    Newbies**网站（[https://kernelnewbies.org](https://kernelnewbies.org)），你可以在 [https://kernelnewbies.org/LinuxVersions](https://kernelnewbies.org/LinuxVersions)
    上找到每个版本的简明概览。
- en: Stable and long-term support releases
  id: totrans-50
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 稳定版和长期支持版发布
- en: 'The rapid rate of change of Linux is a good thing in that it brings new features
    into the mainline code base, but it does not fit very well with the longer life
    cycle of embedded projects. Kernel developers address this in two ways: stable
    releases and long-term releases. After the release of a mainline kernel (maintained
    by Linus Torvalds), it is moved to the **stable** tree (maintained by Greg Kroah-Hartman).
    Bug fixes are applied to the stable kernel while the mainline kernel begins the
    next development cycle.'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: Linux 的快速变化速度是一件好事，因为它将新特性引入主线代码库，但它与嵌入式项目较长的生命周期并不完全匹配。内核开发者通过两种方式来解决这个问题：稳定版发布和长期支持版发布。在主线内核（由
    Linus Torvalds 维护）发布后，它会被移到**稳定**树（由 Greg Kroah-Hartman 维护）。错误修复会应用到稳定版内核，而主线内核则进入下一个开发周期。
- en: Point releases of the stable kernel are marked by a third number (3.18.1, 3.18.2,
    and so on). Before version 3, there were four release numbers (2.6.29.1, 2.6.39.2,
    and so on).
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 稳定版内核的点版本通过第三个数字来标记（例如 3.18.1、3.18.2 等）。在版本3之前，有四个版本号（例如 2.6.29.1、2.6.39.2 等）。
- en: 'You can get the stable tree by using the following command:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过以下命令获取稳定树：
- en: '[PRE1]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'You can use `git` `checkout` to get a particular version like 6.6.46:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用 `git` `checkout` 来获取特定版本，例如 6.6.46：
- en: '[PRE2]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The stable kernel is usually updated only until the next mainline release (8
    to 12 weeks later) so you will see that there are just one or sometimes two stable
    kernels at [https://www.kernel.org/](https://www.kernel.org/). To cater to those
    users who would like updates for longer, some kernels are labeled **long-term**
    and maintained for two or more years. Long-term kernels come with the assurance
    that any bugs will be found and fixed. There is at least one long-term kernel
    release each year.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 稳定版内核通常只会更新到下一个主线版本（大约8到12周后），因此你会看到 [https://www.kernel.org/](https://www.kernel.org/)
    上通常只有一个或两个稳定版内核。为了满足那些需要更长时间更新的用户，一些内核被标记为**长期支持**，并维持两年或更长时间。长期支持内核保证会发现并修复所有错误。每年至少会发布一个长期支持的内核版本。
- en: 'Looking at [https://www.kernel.org/](https://www.kernel.org/) in August of
    2024, there are a total of six long-term kernels: 6.6, 6.1, 5.15, 5.10, 5.4, and
    4.19\. The oldest has been maintained for nearly six years and is at version 4.19.319\.
    If you are building a product that you will have to maintain for this length of
    time, then the latest long-term kernel might well be a good choice.'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 以 2024 年 8 月查看[https://www.kernel.org/](https://www.kernel.org/)时，共有六个长期维护的内核版本：6.6、6.1、5.15、5.10、5.4
    和 4.19。最老的版本已经维护了近六年，当前版本为 4.19.319。如果你正在构建一个需要长期维护的产品，那么最新的长期维护内核可能是一个不错的选择。
- en: Vendor support
  id: totrans-59
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 供应商支持
- en: In an ideal world, you would be able to download a kernel from [https://www.kernel.org/](https://www.kernel.org/)
    and configure it for any device that claims to support Linux. However, that is
    not always possible. In fact, mainline Linux has solid support for only a small
    subset of the many devices that can run Linux. You may find support for your board
    or SoC from independent open source projects like Linaro ([https://www.linaro.org/](https://www.linaro.org/))
    or The Yocto Project ([https://www.yoctoproject.org/](https://www.yoctoproject.org/)).
    There are some companies that offer paid third-party support for embedded Linux.
    But in many cases, you will be obliged to look to the vendor of your SoC or board
    for a working kernel.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 在理想的情况下，你应该能够从[https://www.kernel.org/](https://www.kernel.org/)下载内核，并为任何声称支持
    Linux 的设备配置它。然而，现实中并非总是如此。事实上，主线 Linux 只对能运行 Linux 的众多设备中的一小部分提供了稳定支持。你可能会在一些独立的开源项目中找到对你的开发板或
    SoC 的支持，比如 Linaro ([https://www.linaro.org/](https://www.linaro.org/)) 或 Yocto
    项目 ([https://www.yoctoproject.org/](https://www.yoctoproject.org/))。有些公司提供嵌入式
    Linux 的付费第三方支持。但在许多情况下，你将不得不依赖于 SoC 或开发板供应商提供的可用内核。
- en: As we know, some vendors are better at supporting Linux than others. My advice
    at this point is to choose vendors who give good support or, even better, who
    take the trouble to get their kernel changes into the mainline. Search the Linux
    kernel mailing list or commit history for recent activity around a candidate SoC
    or board. When upstream changes are absent from the mainline kernel, the verdict
    as to whether a vendor offers good support is largely based on word of mouth.
    Some vendors are notorious for releasing only one kernel code drop before redirecting
    all their energies toward their newer SoCs.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所知，一些供应商比其他供应商更擅长支持 Linux。在此阶段，我的建议是选择那些提供良好支持的供应商，或者更好的是，选择那些努力将其内核更改提交到主线的供应商。可以通过搜索
    Linux 内核邮件列表或提交历史，查看候选的 SoC 或开发板是否有最近的活动。当主线内核中没有上游更改时，判断一个供应商是否提供良好支持，往往依赖于口碑。有些供应商因只发布一个内核代码版本后，就将所有精力转向更新的
    SoC，声名狼藉。
- en: Licensing
  id: totrans-62
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 许可证
- en: The Linux source code is licensed under GPL v2\. That means you must make the
    source code of your kernel available in one of the ways specified in the license.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: Linux 源代码是按照 GPL v2 许可证授权的。这意味着你必须以许可证中规定的某种方式提供你的内核源代码。
- en: The actual text of the license for the kernel is in the file `COPYING`. It begins
    with an addendum written by Linus that states that code calling the kernel from
    user space via the system call interface is not considered a derivative work of
    the kernel and so is not covered by the license. Hence, there is no problem with
    proprietary applications running on top of Linux.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 内核的实际许可证文本位于文件 `COPYING` 中。它以 Linus 撰写的附录开始，声明通过系统调用接口从用户空间调用内核的代码不被视为内核的衍生作品，因此不受许可证约束。因此，专有应用程序运行在
    Linux 上并没有问题。
- en: 'However, there is one area of Linux licensing that causes endless confusion
    and debate: kernel modules. A **kernel module** is simply a piece of code that
    is dynamically linked with the kernel at runtime thereby extending the functionality
    of the kernel. The **General Public License** (**GPL**) makes no distinction between
    static and dynamic linking, so it would appear that the source for kernel modules
    is covered by the GPL. In the early days of Linux, there were debates about exceptions
    to this rule, for example, in connection with the **Andrew File System** (**AFS**).
    This code predates Linux and, therefore (it was argued), is not a derivative work
    so the license does not apply.'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，Linux 许可证中有一个领域引起了无休止的混淆和争议：内核模块。**内核模块**只是一个在运行时与内核动态链接的代码片段，从而扩展了内核的功能。**通用公共许可证**（**GPL**）并未区分静态链接和动态链接，因此，内核模块的源代码似乎受
    GPL 的覆盖。在 Linux 的早期，关于这个规则的例外存在争议，例如与 **安德鲁文件系统**（**AFS**）相关的争论。因为这个代码早于 Linux，因此（有人辩称）它不是衍生作品，因此不受许可证的约束。
- en: Similar discussions took place over the years with respect to other pieces of
    code with the result that it is now accepted practice that the GPL does not necessarily
    apply to kernel modules. This is codified by the kernel `MODULE_LICENSE` macro,
    which may take the value `Proprietary` to indicate that it is not released under
    the GPL. If you plan to use the same arguments yourself, you may want to read
    through an oft-quoted email thread titled *Linux GPL and binary module exception
    clause?*, which is archived at [https://yarchive.net/comp/linux/gpl_modules.html](https://yarchive.net/comp/linux/gpl_modules.html).
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 多年来，就其他代码片段进行过类似的讨论，结果现在已接受的做法是，GPL 不一定适用于内核模块。这一点通过内核中的`MODULE_LICENSE`宏进行了规定，该宏可以设置为`Proprietary`，表示该模块没有遵循
    GPL 许可证。如果你打算使用相同的论据，可能需要阅读一封经常被引用的邮件线程，标题为*Linux GPL 和二进制模块例外条款？*，该邮件已存档于[https://yarchive.net/comp/linux/gpl_modules.html](https://yarchive.net/comp/linux/gpl_modules.html)。
- en: The GPL should be considered a good thing because it guarantees that when we
    are working on embedded projects, we can always get the source code for the kernel.
    Without it, embedded Linux would be much harder to use and more fragmented.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: GPL 应该被视为一件好事，因为它确保了我们在进行嵌入式项目时，总是能够获取内核的源码。没有它，嵌入式 Linux 将变得更加难以使用且更加支离破碎。
- en: Best practices
  id: totrans-68
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 最佳实践
- en: That said, to choose a kernel, you need to weigh the benefits of using the latest
    version against the need for vendor-specific enhancements and driver stability.
    Also, the rapid Linux development cycle allows features to be integrated quickly,
    with stable and long-term support releases available for extended maintenance.
    The long-term kernels, which receive updates for over two years, are ideal for
    long-term projects. Vendor support is also crucial, so make sure to choose vendors
    who actively support Linux and contribute to the mainline kernel. Lastly, licensing
    under GPL v2 ensures access to the kernel source code, which makes it easier to
    use and maintain for embedded projects.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 话虽如此，选择内核时，你需要权衡使用最新版本的好处与厂商特定增强功能和驱动程序稳定性的需求。此外，快速发展的 Linux 开发周期使得新特性能够迅速集成，并且有稳定的长期支持版本可供扩展维护。长期支持内核会获得超过两年的更新，非常适合长期项目。厂商支持也至关重要，因此，确保选择那些积极支持
    Linux 并为主线内核做出贡献的厂商。最后，GPL v2 许可证确保了内核源码的获取，这使得在嵌入式项目中使用和维护内核变得更加容易。
- en: Configuring the kernel
  id: totrans-70
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 配置内核
- en: Having decided which kernel to base your image on, the next step is configuring
    the kernel.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦决定了基于哪个内核来构建镜像，接下来的步骤是配置内核。
- en: Getting the source
  id: totrans-72
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 获取源码
- en: All three of the targets used in this book (Raspberry Pi 4, BeaglePlay, and
    QEMU) are well supported by the mainline kernel. Therefore, it makes sense to
    use the latest long-term kernel available from [https://www.kernel.org/](https://www.kernel.org/),
    which, at the time of writing, was 6.6.46\. When you come to do this for yourself,
    you should check to see if there is a later version of the 6.6 kernel and use
    that instead since it will have fixes for bugs found after 6.6.46 was released.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 本书中使用的三个目标（Raspberry Pi 4、BeaglePlay 和 QEMU）都得到了主线内核的良好支持。因此，使用来自[https://www.kernel.org/](https://www.kernel.org/)的最新长期支持内核是有意义的，在写作时，该内核版本为6.6.46。当你自己操作时，应该检查是否有6.6内核的更新版本，并使用该版本，因为它会修复6.6.46发布后发现的错误。
- en: '**IMPORTANT NOTE**'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: '**重要说明**'
- en: If there is a later long-term release, you may want to consider using that one.
    However, be aware that there may have been changes that mean that the following
    sequence of commands does not work exactly as given.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 如果有更晚的长期发布版本，你可能希望考虑使用那个版本。但要注意，可能已经有一些变化，意味着以下命令序列无法完全按给定的方式工作。
- en: 'To fetch and extract a release tarball of the 6.6.46 Linux kernel, use the
    following:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 要获取并提取6.6.46版本的 Linux 内核发布 tarball，可以使用以下命令：
- en: '[PRE3]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: To fetch a later version, replace `6.6.46` after `linux-` with the desired long-term
    release.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 要获取更新版本，只需将`linux-`后的`6.6.46`替换为所需的长期支持版本。
- en: 'There is a lot of code here. There are over 81,000 files in the 6.6 kernel
    containing C source code, header files, and assembly code amounting to a total
    of over 24 million lines of code as measured by the SLOCCount utility. Nevertheless,
    it is worth knowing the basic layout of the code and approximately where to look
    for a particular component. The main directories of interest are:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有大量代码。6.6 内核中有超过 81,000 个文件，包含 C 源代码、头文件和汇编代码，总计超过 2400 万行代码，根据 SLOCCount
    工具的测量结果。尽管如此，了解代码的基本布局以及大概在哪个地方查找特定组件是很有价值的。主要的关注目录有：
- en: '`arch`: Contains architecture-specific files. There is one subdirectory per
    architecture.'
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`arch`：包含特定于体系结构的文件。每种体系结构都有一个子目录。'
- en: '`Documentation`: Contains kernel documentation. Always look here first if you
    want to find more information about an aspect of Linux.'
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Documentation`：包含内核文档。如果想找到有关Linux某方面更多信息，总是首先查看此处。'
- en: '`drivers`: Contains device drivers, thousands of them. There is a subdirectory
    for each type of driver.'
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`drivers`：包含设备驱动程序，数以千计。每种类型的驱动程序都有一个子目录。'
- en: '`fs`: Contains filesystem code.'
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`fs`：包含文件系统代码。'
- en: '`include`: Contains kernel header files including those required when building
    the toolchain.'
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`include`：包含内核头文件，包括在构建工具链时需要的文件。'
- en: '`init`: Contains the kernel start-up code.'
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`init`：包含内核启动代码。'
- en: '`kernel`: Contains core functions including scheduling, locking, timers, power
    management, and debug/trace code.'
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`kernel`：包含核心功能，包括调度、锁定、定时器、电源管理以及调试/跟踪代码。'
- en: '`mm`: Contains memory management.'
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`mm`：包含内存管理。'
- en: '`net`: Contains network protocols.'
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`net`：包含网络协议。'
- en: '`scripts`: Contains many useful scripts including the device tree compiler,
    which I described in [*Chapter 3*](Chapter_03.xhtml#_idTextAnchor061).'
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`scripts`：包含许多有用的脚本，包括设备树编译器，在[*第3章*](Chapter_03.xhtml#_idTextAnchor061)中有描述。'
- en: '`tools`: Contains many useful tools including the Linux performance counters
    tool (`perf`), which I will describe in [*Chapter 20*](Chapter_16.xhtml#_idTextAnchor538).'
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`tools`：包含许多有用的工具，包括Linux性能计数器工具（`perf`），我将在[*第20章*](Chapter_16.xhtml#_idTextAnchor538)中描述。'
- en: Over time, you will become familiar with this structure and realize that if
    you are looking for the serial port code of a particular SoC, you will find it
    in `drivers/tty/serial` and not in `arch/$ARCH/mach-foo` because it is a device
    driver and not something CPU architecture-specific.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 随着时间的推移，你会熟悉这种结构，并意识到，如果你要找特定SoC的串口代码，你会在`drivers/tty/serial`找到它，而不是在`arch/$ARCH/mach-foo`中，因为它是设备驱动，而不是特定于CPU架构的内容。
- en: Understanding kernel configuration– Kconfig
  id: totrans-92
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 理解内核配置– Kconfig
- en: One of the strengths of Linux is the degree to which you can configure the kernel
    to suit different jobs, from a small, dedicated device such as a smart thermostat
    to a complex mobile handset. In current versions, there are many thousands of
    configuration options. Getting the configuration right is a task in itself, but
    before we get into that, I want to show you how it works so that you can better
    understand what is going on.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: Linux的一个优点是可以根据不同的需求配置内核，从小型的专用设备（如智能恒温器）到复杂的移动电话。在当前版本中，有成千上万的配置选项。正确配置配置本身就是一项任务，但在深入讨论之前，我想先向你展示它是如何工作的，这样你可以更好地理解正在发生的事情。
- en: The configuration mechanism is called `Kconfig`, and the build system that it
    integrates with is called `Kbuild`. Both are documented in `Documentation/kbuild`.
    `Kconfig`/`Kbuild` is used in a number of other projects besides the kernel including
    Crosstool-NG, U-Boot, Barebox, and BusyBox.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 配置机制被称为`Kconfig`，与之集成的构建系统被称为`Kbuild`。这两者的文档位于`Documentation/kbuild`中。`Kconfig`/`Kbuild`不仅在内核项目中使用，还包括Crosstool-NG、U-Boot、Barebox和BusyBox等其他项目。
- en: The configuration options are declared in a hierarchy of files named `Kconfig`
    using a syntax described in `Documentation/kbuild/kconfig-language.rst`.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 配置选项在名为`Kconfig`的一系列文件中声明，使用的语法在`Documentation/kbuild/kconfig-language.rst`中描述。
- en: 'In Linux, the top-level `Kconfig` looks like this:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 在Linux中，顶层的`Kconfig`看起来像这样：
- en: '[PRE4]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'And the first line of `arch/Kconfig` is:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: '`arch/Kconfig`的第一行是：'
- en: '[PRE5]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: That line includes the architecture-dependent configuration file, which sources
    other `Kconfig` files depending on which options are enabled.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 该行包括依赖于启用了哪些选项的其他`Kconfig`文件的体系结构相关配置文件。
- en: 'Having the architecture play such a prominent role has three implications:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 让体系结构发挥如此重要作用有三个含义：
- en: First, you must specify an architecture when configuring Linux by setting `ARCH=<architecture>`;
    otherwise, it will default to the local machine architecture.
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 首先，在配置Linux时必须指定一个体系结构，设置`ARCH=<architecture>`；否则，它将默认为本地机器体系结构。
- en: Second, the value you set for `ARCH` usually determines the value of `SRCARCH`
    so you rarely need to set `SRCARCH` explicitly.
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 其次，通常情况下，你设置的`ARCH`的值决定了`SRCARCH`的值，因此你很少需要显式设置`SRCARCH`。
- en: Third, the layout of the top-level menu is different for each architecture.
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第三，每种体系结构的顶级菜单布局都不同。
- en: The value you put into `ARCH` is one of the subdirectories you find in the directory
    `arch` with the oddity that `ARCH=i386` and `ARCH=x86_64` both source `arch/x86/Kconfig`.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 你在`ARCH`中设置的值是`arch`目录中找到的子目录之一，唯一的特殊情况是`ARCH=i386`和`ARCH=x86_64`都会引用`arch/x86/Kconfig`。
- en: The `Kconfig` files consist largely of menus delineated by the `menu` and `endmenu`
    keywords. Menu items are marked by the keyword `config`.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: '`Kconfig`文件大部分由`menu`和`endmenu`关键字划定的菜单组成。菜单项由`config`关键字标记。'
- en: 'Here is an example taken from `drivers/char/Kconfig`:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是一个来自`drivers/char/Kconfig`的示例：
- en: '[PRE6]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The parameter following `config` names a variable, which, in this case, is
    `DEVMEM`. Since this option is a `bool` (Boolean), it can only have two values:
    if it is enabled, it is assigned `y`, and if it is not enabled, the variable is
    not defined at all. The name of the menu item that is displayed on the screen
    is the string following the `bool` keyword.'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 紧跟在`config`后面的参数指定了一个变量，这里是`DEVMEM`。由于此选项是`bool`（布尔值），它只能有两个值：如果启用，它的值为`y`，如果未启用，则该变量根本不定义。屏幕上显示的菜单项名称是`bool`关键字后面的字符串。
- en: This configuration item, along with all the others, is stored in a file named
    `.config`.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 此配置项及其他所有配置项存储在名为`.config`的文件中。
- en: '**TIP**'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: '**提示**'
- en: The leading dot (`.`) in `.config` means that it is a hidden file that will
    not be shown by the `ls` command unless you type `ls -a` to show all files.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: '`.config`中的前导点（`.`）表示它是一个隐藏文件，默认情况下，`ls`命令不会显示，除非你使用`ls -a`来显示所有文件。'
- en: 'The line corresponding to this configuration item reads:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 与此配置项对应的行是：
- en: '[PRE7]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'There are several other data types in addition to `bool`. Here is the complete
    list:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 除了`bool`之外，还有几种其他数据类型。以下是完整的列表：
- en: '`bool`: Either `y` or not defined.'
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`bool`：要么是`y`，要么未定义。'
- en: '`tristate`: Used where a feature can be built as a kernel module or built into
    the main kernel image. The values are `m` for a module, `y` to be built in, and
    not defined if the feature is not enabled.'
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`tristate`：用于某个功能可以作为内核模块或内核映像的一部分进行构建的情况。其值为`m`表示作为模块，`y`表示构建为内核的一部分，若未启用该功能，则未定义。'
- en: '`int`: An integer value using decimal notation.'
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`int`：使用十进制表示法的整数值。'
- en: '`hex`: An unsigned integer value using hexadecimal notation.'
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`hex`：使用十六进制表示法的无符号整数值。'
- en: '`string`: A string value.'
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`string`：字符串值。'
- en: 'There may be dependencies between items expressed by the `depends on` construct,
    as shown here:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 项目之间可能存在依赖关系，依赖关系通过`depends on`构造来表示，如下所示：
- en: '[PRE8]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: If `CONFIG_MTD` has not been enabled elsewhere, this menu option is not shown
    and so cannot be selected.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`CONFIG_MTD`在其他地方未启用，则该菜单选项不会显示，因此无法选择。
- en: 'There are also reverse dependencies. The `select` keyword enables other options
    if this one is enabled. The `Kconfig` file in `arch/$ARCH` has numerous `select`
    statements that enable features specific to the architecture, as seen here for
    Arm:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 还有反向依赖关系。`select`关键字在启用某个选项时，会启用其他选项。`arch/$ARCH`中的`Kconfig`文件包含了许多`select`语句，启用了特定于架构的功能，下面是Arm架构的示例：
- en: '[PRE9]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: By selecting `ARCH_CLOCKSOURCE_DATA` and `ARCH_HAS_DEVMEM_IS_ALLOWED`, we are
    assigning a value of `y` to these variables so that these features are built statically
    into the kernel.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 通过选择`ARCH_CLOCKSOURCE_DATA`和`ARCH_HAS_DEVMEM_IS_ALLOWED`，我们将这两个变量的值设置为`y`，以便将这些功能静态构建到内核中。
- en: There are several configuration utilities that can read the `Kconfig` files
    and produce a `.config` file. Some of them display the menus on the screen and
    allow you to make choices interactively. `menuconfig` is probably the one most
    people are familiar with but there are also `xconfig` and `gconfig`.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 有几种配置工具可以读取`Kconfig`文件并生成`.config`文件。它们中的一些会在屏幕上显示菜单并允许你进行交互式选择。`menuconfig`可能是大多数人熟悉的工具，但也有`xconfig`和`gconfig`。
- en: 'To use `menuconfig`, you first need to have `ncurses`, `flex`, and `bison`
    installed. The following command installs all these prerequisites on Ubuntu:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`menuconfig`之前，你需要先安装`ncurses`、`flex`和`bison`。以下命令在Ubuntu上安装所有这些依赖项：
- en: '[PRE10]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'You launch `menuconfig` via the `make` command, remembering that, in the case
    of the kernel, you need to supply an architecture, as illustrated here:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过`make`命令启动`menuconfig`，请记住，在内核的情况下，你需要提供一个架构，如下所示：
- en: '[PRE11]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Make sure that your `PATH` variable points to the 64-bit toolchain you downloaded
    back in [*Chapter 2*](Chapter_01.xhtml#_idTextAnchor028).
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 确保你的`PATH`变量指向你在[*第2章*](Chapter_01.xhtml#_idTextAnchor028)中下载的64位工具链。
- en: 'Here you can see `menuconfig` with the `DEVMEM` config option highlighted previously:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 这里你可以看到带有先前突出显示的`DEVMEM`配置选项的`menuconfig`：
- en: '![Figure 4.2 − Selecting DEVMEM](img/B18466_04_02.png)'
  id: totrans-134
  prefs: []
  type: TYPE_IMG
  zh: '![图 4.2 − 选择 DEVMEM](img/B18466_04_02.png)'
- en: Figure 4.2 − Selecting DEVMEM
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.2 − 选择 DEVMEM
- en: The star (`*`) to the left of an item means that the driver has been selected
    to be built statically into the kernel. If it is an `M`, then it has been selected
    to be built as a kernel module for insertion into the kernel at runtime.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 位于项目前的星号（`*`）表示该驱动已被选择为静态编译到内核中。如果是`M`，则表示它已被选择为内核模块，以便在运行时插入内核中。
- en: '**TIP**'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: '**提示**'
- en: You often see instructions like enable `CONFIG_BLK_DEV_INITRD` but, with so
    many menus to browse through, it can take a while to find the place where that
    configuration is set. All configuration editors have a search function. You can
    access it in `menuconfig` by pressing the forward slash key */*. In `xconfig`,
    it is in the **Edit** menu but make sure you leave off the `CONFIG_` part of the
    configuration item you are searching for.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 你经常会看到类似于启用`CONFIG_BLK_DEV_INITRD`的指令，但由于有很多菜单可供浏览，找到设置该配置项的地方可能需要一段时间。所有配置编辑器都有一个搜索功能。你可以在`menuconfig`中通过按下斜杠键`*/`来访问它。在`xconfig`中，它位于**编辑**菜单下，但请确保在搜索配置项时不包括`CONFIG_`部分。
- en: With so many things to configure, it is unreasonable to start with a clean sheet
    each time you want to build a kernel, so there are a set of known working configuration
    files in `arch/$ARCH/configs`, each containing suitable configuration values for
    a single SoC or a group of SoCs.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 由于需要配置的内容太多，每次构建内核时从头开始是不现实的，因此在`arch/$ARCH/configs`中有一组已知的工作配置文件，每个文件包含适用于单个SoC或一组SoC的配置值。
- en: 'You can select one with the `make <configuration file name>` command. For example,
    to configure Linux to run on a wide range of 64-bit Arm SoCs, you would type:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用`make <配置文件名称>`命令来选择一个配置。例如，要配置Linux以支持广泛的64位Arm SoC，你需要输入：
- en: '[PRE12]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: This is a generic kernel that runs on various boards. For a more specialized
    application, like when using a vendor-supplied kernel, the default configuration
    file is part of the board support package. You will need to find out which one
    to use before you can build the kernel.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个通用内核，适用于各种开发板。对于更专业的应用，比如使用厂商提供的内核，默认配置文件是板级支持包的一部分。在你开始构建内核之前，你需要确定使用哪个配置文件。
- en: There is another useful configuration target named `oldconfig`. You use it when
    moving a configuration to a new kernel version. This target takes an existing
    `.config` file and prompts you with questions about new configuration options.
    Copy `.config` from the old kernel to the new source directory and run the `make
    ARCH=arm64 oldconfig` command to bring it up to date.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一个有用的配置目标叫做`oldconfig`。当你将配置迁移到新内核版本时使用它。该目标会采用一个现有的`.config`文件，并向你提问有关新配置选项的问题。将旧内核的`.config`文件复制到新源目录并运行`make
    ARCH=arm64 oldconfig`命令，以使其与新版本同步。
- en: The `oldconfig` target can also be used to validate a `.config` file that you
    have edited manually (ignoring the text *Automatically generated file; DO NOT
    EDIT* that occurs at the top).
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: '`oldconfig`目标也可以用来验证你手动编辑过的`.config`文件（忽略顶部出现的文本*自动生成的文件；请勿编辑*）。'
- en: If you do make changes to the configuration, then the modified `.config` file
    becomes part of your board support package and needs to be placed under source
    code control.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你对配置进行了更改，那么修改后的`.config`文件将成为你的板级支持包的一部分，并需要放置在源代码管理之下。
- en: When you start the kernel build, a header file named `include/generated/autoconf.h`
    is generated. This header file contains a `#define` for each configuration value
    so that it can be included in the kernel source.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 当你开始构建内核时，会生成一个名为`include/generated/autoconf.h`的头文件。这个头文件包含每个配置值的`#define`，以便它可以包含在内核源代码中。
- en: Now that we have settled on a kernel and learned how to configure it, we will
    identify it.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经确定了内核并学会了如何配置它，我们将进行标识。
- en: Using LOCALVERSION to identify your kernel
  id: totrans-148
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用LOCALVERSION来标识你的内核
- en: 'You can discover the kernel version and release that you have built using the
    `make kernelversion` and `make kernelrelease` targets:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过使用`make kernelversion`和`make kernelrelease`目标来发现你构建的内核版本和发布版本：
- en: '[PRE13]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: This is reported at runtime through the `uname` command and is also used in
    naming the directory where kernel modules are stored.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 这可以通过`uname`命令在运行时报告，并且也用于命名存储内核模块的目录。
- en: 'If you change the configuration from the default, it is advisable to append
    your version information, which you can configure by setting `CONFIG_LOCALVERSION`
    using `menuconfig`:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你更改了默认配置，建议你附加版本信息，可以通过在`menuconfig`中设置`CONFIG_LOCALVERSION`来配置：
- en: '[PRE14]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'For example, if I wanted to mark the kernel I am building with the identifier
    `meld` and version `1.0`, then I would define the local version in `menuconfig`
    like this:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果我想标记我正在构建的内核，使用标识符`meld`和版本`1.0`，那么我会在`menuconfig`中这样定义本地版本：
- en: '![Figure 4.3 – Appending to kernel release version](img/B18466_04_03.png)'
  id: totrans-155
  prefs: []
  type: TYPE_IMG
  zh: '![图 4.3 – 追加到内核发布版本](img/B18466_04_03.png)'
- en: Figure 4.3 – Appending to kernel release version
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.3 – 追加到内核发布版本
- en: Exit out of `menuconfig` and choose **Yes** when asked to save your new configuration.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 退出`menuconfig`并在被询问是否保存新配置时选择**是**。
- en: 'Run `make prepare` to refresh the `Makefile` with the new `kernelrelease` version:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 运行`make prepare`以使用新的`kernelrelease`版本刷新`Makefile`：
- en: '[PRE15]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Running `make kernelversion` produces the same output as before, but if I run
    `make kernelrelease` now, I see:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 运行`make kernelversion`会产生与之前相同的输出，但如果我现在运行`make kernelrelease`，我会看到：
- en: '[PRE16]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: That was a pleasant detour into kernel versioning, but now let’s get back to
    the business of configuring our kernel for compilation.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个愉快的绕道，关于内核版本管理，但现在让我们回到配置内核以进行编译的正题。
- en: When to use kernel modules
  id: totrans-163
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 何时使用内核模块
- en: I have mentioned kernel modules several times already. Desktop Linux distributions
    use them extensively so that the correct device and kernel functions can be loaded
    at runtime depending on the hardware detected and features required. Without them,
    every single driver and feature would have to be statically linked into the kernel,
    making it infeasibly large.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 我已经多次提到内核模块了。桌面Linux发行版广泛使用它们，以便根据检测到的硬件和所需的功能在运行时加载正确的设备和内核功能。如果没有内核模块，每个驱动程序和功能都必须静态链接到内核中，这会使内核变得异常庞大。
- en: On the other hand, with embedded devices, the hardware and kernel configuration
    is usually known at the time the kernel is built; therefore, modules are not so
    useful. In fact, they cause a problem because they create a version dependency
    between the kernel and the root filesystem, which can cause boot failures if one
    is updated but not the other. Consequently, it is quite common for embedded kernels
    to be built without any modules at all.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，对于嵌入式设备，硬件和内核配置通常在构建内核时就已知，因此模块不是那么有用。事实上，它们会造成一个问题，因为它们在内核和根文件系统之间创建了版本依赖关系，如果其中一个更新而另一个没有更新，就可能导致引导失败。因此，嵌入式内核通常是构建时没有任何模块的。
- en: 'Here are a few cases where kernel modules are a good idea in embedded systems:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是内核模块在嵌入式系统中是一个好主意的几个场景：
- en: When you have proprietary modules, for the licensing reasons given in the preceding
    section.
  id: totrans-167
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当你有专有模块时，出于前面部分提到的许可原因。
- en: To reduce boot time by deferring the loading of non-essential drivers.
  id: totrans-168
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过推迟加载非必要的驱动程序来减少启动时间。
- en: When there are several drivers to potentially load and it would take up too
    much memory to compile them statically. For example, you have a USB interface
    that supports a range of devices. This is essentially the same argument used in
    desktop distributions.
  id: totrans-169
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当有多个驱动程序可能需要加载，而静态编译它们会占用太多内存时。例如，你有一个支持多种设备的USB接口。这基本上与桌面发行版中的相同论点。
- en: Next, let’s learn how to compile a kernel image with or without kernel modules
    using `Kbuild`.
  id: totrans-170
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 接下来，让我们学习如何使用或不使用内核模块通过`Kbuild`编译内核映像。
- en: Compiling with Kbuild
  id: totrans-171
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Kbuild进行编译
- en: 'The kernel build system (`Kbuild`) is a set of `make` scripts that take the
    configuration information from the `.config` file, work out the dependencies,
    and compile everything necessary to produce a kernel image. This kernel image
    contains all the statically linked components, an optional device tree binary,
    and any kernel modules. The dependencies are expressed within Makefiles inside
    each directory with buildable components. For instance, the following two lines
    are taken from `drivers/char/Makefile`:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 内核构建系统（`Kbuild`）是一组`make`脚本，它从`.config`文件中获取配置信息，计算依赖关系，并编译所有必要的内容以生成内核映像。该内核映像包含所有静态链接的组件、可选的设备树二进制文件以及任何内核模块。依赖关系通过每个目录中的Makefile表示，包含可构建组件。例如，以下两行来自`drivers/char/Makefile`：
- en: '[PRE17]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: The `obj-y` rule unconditionally compiles a file to produce the target, so `mem.c`
    and `random.c` are always part of the kernel. In the second line, `ttyprintk.c`
    is dependent on a configuration parameter. If `CONFIG_TTY_PRINTK` is `y`, then
    it is compiled as a built-in. If it is `m`, then it is built as a module. If the
    parameter is undefined, then it is not compiled at all.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: '`obj-y`规则无条件地编译文件以生成目标，因此`mem.c`和`random.c`始终是内核的一部分。在第二行中，`ttyprintk.c`依赖于一个配置参数。如果`CONFIG_TTY_PRINTK`为`y`，则它作为内置模块编译。如果为`m`，则编译为模块。如果该参数未定义，则完全不编译。'
- en: For most targets, just typing `make` (with the appropriate `ARCH` and `CROSS_COMPILE`)
    will do the job, but it is instructive to take it one step at a time. See the
    last section of [*Chapter 2*](Chapter_01.xhtml#_idTextAnchor028) for the meaning
    of the `CROSS_COMPILE` `make` variable.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 对于大多数目标，只需键入`make`（并设置合适的`ARCH`和`CROSS_COMPILE`）即可完成工作，但逐步执行是有教育意义的。请参见[*第2章*](Chapter_01.xhtml#_idTextAnchor028)的最后部分，了解`CROSS_COMPILE`的`make`变量的含义。
- en: Finding out which kernel target to build
  id: totrans-176
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 确定要构建的内核目标
- en: 'To build a kernel image, you need to know what your bootloader expects. This
    is a rough guide:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 要构建内核镜像，您需要了解引导加载程序的要求。以下是一个粗略的指南：
- en: '**U-Boot**: Can load a compressed `Image.gz` file for 64-bit Arm. Can also
    load a self-extracting `zImage` file for 32-bit Arm using the `bootz` command.'
  id: totrans-178
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**U-Boot**：可以为64位Arm加载压缩的`Image.gz`文件。也可以使用`bootz`命令为32位Arm加载自解压的`zImage`文件。'
- en: '**x86 targets**: Require a `bzImage` file.'
  id: totrans-179
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**x86目标**：需要一个`bzImage`文件。'
- en: '**Most other bootloaders**: Require a `zImage` file.'
  id: totrans-180
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**大多数其他引导加载程序**：需要一个`zImage`文件。'
- en: 'Here is an example of building an `Image.gz` file for 64-bit Arm:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 这是为64位Arm构建`Image.gz`文件的示例：
- en: '[PRE18]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Make sure that your `PATH` variable points to the 64-bit toolchain you downloaded
    back in [*Chapter 2*](Chapter_01.xhtml#_idTextAnchor028).
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 确保您的`PATH`变量指向您在[*第2章*](Chapter_01.xhtml#_idTextAnchor028)中下载的64位工具链。
- en: '**IMPORTANT NOTE**'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: '**重要提示**'
- en: 'The first time you run `make` on the kernel source tree, you may be prompted
    to include or omit various features, options, and plugins. Most of these features
    and options offer increased security so there is no harm in adding them. There
    is one notable exception. When prompted for GCC plugins, make sure to enter `n`
    for no as shown:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 当您第一次在内核源树上运行`make`时，可能会提示您包括或省略各种功能、选项和插件。这些功能和选项大多数提供了更高的安全性，因此添加它们是没有坏处的。有一个显著的例外。在提示选择GCC插件时，确保选择`n`表示否，如下所示：
- en: '[PRE19]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Otherwise, the build will fail because `make` cannot find `g++`.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 否则，构建将失败，因为`make`找不到`g++`。
- en: Remember to replace `<n>` after `make -j` with the number of CPU cores available
    on your host machine to speed up your build.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，在`make -j`后替换`<n>`为您主机上可用的CPU核心数，以加速构建过程。
- en: '**TIP**'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: '**提示**'
- en: The `-j<n>` option tells `make` how many jobs to run in parallel, which reduces
    the time it takes to build. `make -j4` runs four jobs. A rough guide is to run
    as many jobs as you have CPU cores.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: '`-j<n>`选项告诉`make`并行运行多少个作业，这样可以减少构建所需的时间。`make -j4`将运行四个作业。一个粗略的指南是，运行的作业数应该与您主机上的CPU核心数相等。'
- en: The AArch64 kernel does not currently provide a decompressor and, therefore,
    requires decompression (`gzip`, etc.) to be performed by the bootloader if a compressed
    `Image` target (e.g., `Image.gz`) is used.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，AArch64内核不提供解压器，因此，如果使用压缩的`Image`目标（例如`Image.gz`），需要由引导加载程序执行解压（`gzip`等）。
- en: Regardless of which kernel image format we target, the same two build artifacts
    (`vmlinux` and `System.map`) are first created before the bootable image is generated.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 无论我们目标的是哪种内核镜像格式，在生成可引导镜像之前，始终先生成这两个构建产物（`vmlinux`和`System.map`）。
- en: Build artifacts
  id: totrans-193
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 构建构件
- en: 'A kernel build generates two files in the top-level directory: `vmlinux` and
    `System.map`. The first, `vmlinux`, is the kernel as an ELF binary. If you have
    compiled your kernel with debug enabled (`CONFIG_DEBUG_INFO=y`), it will contain
    debug symbols that can be used with debuggers like `kgdb`. You can also use other
    ELF binary tools, such as `size` to measure the length of each segment (`text`,
    `data`, and `bss`) that comprises the `vmlinux` executable:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 内核构建会在顶级目录中生成两个文件：`vmlinux`和`System.map`。第一个文件`vmlinux`是作为ELF二进制文件的内核。如果您在编译内核时启用了调试（`CONFIG_DEBUG_INFO=y`），它将包含可用于调试器（如`kgdb`）的调试符号。您还可以使用其他ELF二进制工具，例如`size`，来衡量每个段（`text`、`data`和`bss`）的长度，这些段组成了`vmlinux`可执行文件：
- en: '[PRE20]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: A program like the kernel is divided into segments in memory. The `text` segment
    contains executable instructions (code). The `data` segment contains initialized
    global and static variables. The `bss` segment contains uninitialized global and
    static variables. The `dec` and `hex` values are the total file size in decimal
    and hexadecimal, respectively.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 像内核这样的程序在内存中被划分为多个段。`text` 段包含可执行指令（代码）。`data` 段包含初始化的全局和静态变量。`bss` 段包含未初始化的全局和静态变量。`dec`
    和 `hex` 值分别是文件大小的十进制和十六进制表示。
- en: '`System.map` contains the symbol table in human-readable form.'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: '`System.map` 包含符号表，以人类可读的形式展示。'
- en: 'Most bootloaders cannot handle ELF code directly. There is a further stage
    of processing that takes `vmlinux` and places binaries that are suitable for the
    various bootloaders in `arch/$ARCH/boot`:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数引导加载程序无法直接处理 ELF 代码。因此，需要进一步的处理步骤，将 `vmlinux` 转换为适合各种引导加载程序的二进制文件，并放置在 `arch/$ARCH/boot`
    目录中：
- en: '`Image`: `vmlinux` converted to raw binary format.'
  id: totrans-199
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Image`：将 `vmlinux` 转换为原始二进制格式。'
- en: '`zImage`: For the PowerPC architecture, this is just a compressed version of
    `Image`, implying that the bootloader must do the decompression. For all other
    architectures, the compressed `Image` is piggybacked onto a stub of code that
    decompresses and relocates it.'
  id: totrans-200
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`zImage`：对于 PowerPC 架构，这只是 `Image` 的压缩版本，意味着引导加载程序必须进行解压缩。对于其他所有架构，压缩后的 `Image`
    会附加在一个解压缩并重定位它的代码存根上。'
- en: '`uImage`: `zImage` plus a 64-byte U-Boot header.'
  id: totrans-201
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`uImage`：`zImage` 加上一个 64 字节的 U-Boot 头。'
- en: 'While the build is running, you will see a summary of the commands being executed:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 在构建过程中，你将看到正在执行的命令摘要：
- en: '[PRE21]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'When the kernel build fails, it is sometimes useful to see the actual commands
    being executed. To do that, add `V=1` to the command line:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 当内核构建失败时，有时查看实际执行的命令会很有用。为此，可以在命令行中添加 `V=1`：
- en: '[PRE22]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: In this section, we learned how `Kbuild` takes a precompiled `vmlinux` ELF binary
    and converts it into a bootable kernel image. Next, we will look at how we can
    compile device trees.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一部分，我们了解了 `Kbuild` 如何将预编译的 `vmlinux` ELF 二进制文件转换为可引导的内核镜像。接下来，我们将探讨如何编译设备树。
- en: Compiling device trees
  id: totrans-207
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 编译设备树
- en: '[PRE23]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: '[PRE24]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: The compiled `.dtb` files are generated in the `../build_arm64` output directory.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 编译后的 `.dtb` 文件会生成在 `../build_arm64` 输出目录中。
- en: Compiling modules
  id: totrans-211
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 编译模块
- en: 'If you have configured some features to be built as modules, then you can build
    them separately using the `modules` target:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你配置了一些功能作为模块进行构建，那么你可以使用 `modules` 目标单独构建它们：
- en: '[PRE25]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Replace `<n>` after `make -j` with the number of CPU cores available on your
    host machine to speed up your build.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 将 `make -j` 后面的 `<n>` 替换为主机机器上可用的 CPU 核心数，以加快构建速度。
- en: The compiled modules have a `.ko` suffix and are generated in the same directory
    as the source code, meaning that they are scattered all around the kernel source
    tree. Finding them is a little tricky, but you can use the `modules_install` target
    to install them in the right place.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 编译后的模块具有 `.ko` 后缀，并生成在与源代码相同的目录中，这意味着它们散布在整个内核源代码树中。找到它们有点棘手，但你可以使用 `modules_install`
    目标将它们安装到正确的位置。
- en: 'The default location is `/lib/modules` in your development system, which is
    almost certainly not what you want. To install them into the staging area of your
    root filesystem, provide the path using `INSTALL_MOD_PATH`:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 默认位置是开发系统中的 `/lib/modules`，这几乎肯定不是你想要的位置。要将它们安装到根文件系统的暂存区，使用 `INSTALL_MOD_PATH`
    提供路径：
- en: '[PRE26]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Kernel modules are put into the directory `/lib/modules/<kernel version>` relative
    to the root of the filesystem.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 内核模块被放置在相对于文件系统根目录的 `/lib/modules/<kernel version>` 目录下。
- en: Cleaning kernel sources
  id: totrans-219
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 清理内核源代码
- en: 'There are three make targets for cleaning the kernel source tree:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 有三个用于清理内核源代码树的 `make` 目标：
- en: '**clean**: Removes object files and most intermediates.'
  id: totrans-221
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**clean**：删除目标文件和大多数中间文件。'
- en: '**mrproper**: Removes all intermediate files including the `.config` file.
    Use this target to return the source tree to the state it was in immediately after
    cloning or extracting the source code. Mr. Proper is a cleaning product common
    in some parts of the world. The purpose of `make mrproper` is to give the kernel
    sources a really good scrub.'
  id: totrans-222
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**mrproper**：删除所有中间文件，包括 `.config` 文件。使用此目标可以将源代码树恢复到克隆或提取源代码后立即的状态。Mr. Proper
    是一种清洁产品，在一些地区很常见。`make mrproper` 的目的是对内核源代码进行彻底清理。'
- en: '**distclean**: This is the same as `mrproper` but also deletes editor backup
    files, patch files, and other artifacts of software development.'
  id: totrans-223
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**distclean**：与 `mrproper` 相同，但还会删除编辑器备份文件、补丁文件和其他软件开发的产物。'
- en: Building and booting the kernel
  id: totrans-224
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建和启动内核
- en: Building and booting Linux is highly device-dependent. In this section, I will
    show you how it works for the Raspberry Pi 4, BeaglePlay, and QEMU. For other
    target boards, you must consult the information from the vendor or from the community
    project if there is one.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 构建和启动Linux高度依赖于设备。在本节中，我将展示如何在树莓派4、BeaglePlay和QEMU上实现。对于其他目标板，您必须咨询供应商或社区项目的相关信息（如果有的话）。
- en: Building a kernel for the Raspberry Pi 4
  id: totrans-226
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 为树莓派4构建内核
- en: Even though there is support for the Raspberry Pi 4 in the mainline kernel,
    I prefer to use the Raspberry Pi Foundation’s fork of Linux ([https://github.com/raspberrypi/linux](https://github.com/raspberrypi/linux))
    for stability. 6.6 was the latest long-term kernel supported by that fork in August
    2024, so that is the version we shall build.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管主线内核已支持树莓派4，我更倾向于使用树莓派基金会的Linux分支（[https://github.com/raspberrypi/linux](https://github.com/raspberrypi/linux)）以保证稳定性。2024年8月，该分支的最新长期支持内核版本为6.6，因此我们将构建该版本。
- en: Since the Raspberry Pi 4 has a 64-bit quad-core Arm Cortex-A72 CPU, we will
    use the Bootlin toolchain from [*Chapter 2*](Chapter_01.xhtml#_idTextAnchor028)*,*
    to cross-compile a 64-bit kernel for it.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 由于树莓派4使用64位四核Arm Cortex-A72 CPU，我们将使用[*第2章*](Chapter_01.xhtml#_idTextAnchor028)*,*中的Bootlin工具链为其交叉编译一个64位内核。
- en: 'Install a package we need to build the kernel:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 安装构建内核所需的包：
- en: '[PRE27]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Now that you have the requisite toolchain and packages installed, clone the
    `6.6.y` branch of the kernel repo one-level deep to a directory named `linux-rpi`
    and export some prebuilt binaries to a `boot` subdirectory:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经安装了所需的工具链和软件包，克隆内核仓库的`6.6.y`分支（一层深度）到一个名为`linux-rpi`的目录，并将一些预构建的二进制文件导出到`boot`子目录：
- en: '[PRE28]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: The `--depth=n` argument instructs Git to fetch only the last `n` commits when
    cloning.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: '`--depth=n`参数指示Git在克隆时仅获取最后`n`个提交。'
- en: 'Navigate to the newly cloned `linux-rpi` directory and build the kernel:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 导航到新克隆的`linux-rpi`目录并构建内核：
- en: '[PRE29]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Replace `<n>` after `make -j` with the number of CPU cores available on your
    host machine to speed up your build.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 将`make -j`后的`<n>`替换为主机机器上可用的CPU核心数，以加速构建过程。
- en: 'When the build finishes, copy the kernel image, device tree blobs, and boot
    parameters to the boot subdirectory:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 构建完成后，将内核镜像、设备树二进制文件和启动参数复制到boot子目录：
- en: '[PRE30]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'The preceding commands are all found in the script `MELD/Chapter04/build-linux-rpi4.sh`.
    Note that the kernel command line written to `cmdline.txt` must be all on one
    line. Let’s break these steps down into stages:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 上述命令都可以在脚本`MELD/Chapter04/build-linux-rpi4.sh`中找到。请注意，写入`cmdline.txt`的内核命令行必须全部在一行内。让我们将这些步骤分解为几个阶段：
- en: Clone the `rpi-6.6.y` branch of the Raspberry Pi Foundation’s kernel fork into
    a `linux-rpi` directory.
  id: totrans-240
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将树莓派基金会的`rpi-6.6.y`分支克隆到`linux-rpi`目录。
- en: Clone the `1.20240529` tag of the Raspberry Pi Foundation’s firmware rep into
    a `firmware-rpi` directory.
  id: totrans-241
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将树莓派基金会的`1.20240529`标签的固件仓库克隆到`firmware-rpi`目录。
- en: Move the `boot` subdirectory from the Raspberry Pi Foundation’s `firmware` repo
    to a `boot` directory.
  id: totrans-242
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将树莓派基金会的`firmware`仓库中的`boot`子目录移动到`boot`目录中。
- en: Delete the existing kernel image[s], device tree blobs, and device tree overlays
    from the `boot` directory.
  id: totrans-243
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从`boot`目录删除现有的内核镜像、设备树二进制文件和设备树覆盖。
- en: From the `linux-rpi` directory, build the 64-bit kernel, modules, and device
    tree for the Raspberry Pi 4.
  id: totrans-244
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从`linux-rpi`目录，构建树莓派4的64位内核、模块和设备树。
- en: Copy the newly-built kernel image, device tree blobs, and device tree overlays
    from ./build_rpi/`arch/arm64/boot` to the `boot` directory.
  id: totrans-245
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将新构建的内核镜像、设备树二进制文件和设备树覆盖从./build_rpi/`arch/arm64/boot`复制到`boot`目录。
- en: Write `config.txt` and `cmdline.txt` files out to the `boot` directory for the
    Raspberry Pi 4’s bootloader to read and pass to the kernel.
  id: totrans-246
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`config.txt`和`cmdline.txt`文件写入`boot`目录，以供树莓派4的引导加载程序读取并传递给内核。
- en: Let’s look at the settings in `config.txt`. The `enable_uart=1` line enables
    the serial console during boot, which is disabled by default. The `arm_64bit=1`
    line instructs the Raspberry Pi 4’s bootloader to start the CPU in 64-bit mode
    and load the kernel image from a file named `kernel8.img`.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一下`config.txt`中的设置。`enable_uart=1`这一行在启动过程中启用串口控制台，而默认情况下是禁用的。`arm_64bit=1`这一行指示树莓派4的引导加载程序以64位模式启动CPU，并从名为`kernel8.img`的文件中加载内核镜像。
- en: Now, let’s look at `cmdline.txt`. The `console=serial0,115200` and `console=tty1`
    kernel command-line parameters instruct the kernel to output log messages to the
    serial console as our kernel boots.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们来看一下`cmdline.txt`。`console=serial0,115200`和`console=tty1`内核命令行参数指示内核在启动过程中将日志消息输出到串口控制台。
- en: Booting the Raspberry Pi 4
  id: totrans-249
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 启动Raspberry Pi 4
- en: Raspberry Pi devices use a proprietary bootloader provided by Broadcom instead
    of U-Boot. Unlike previous Raspberry Pi models, the Raspberry Pi 4’s bootloader
    resides on an onboard SPI EEPROM rather than on a microSD card. We still need
    to put the kernel image and device tree blobs for the Raspberry Pi 4 on a microSD
    to boot our 64-bit kernel.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: Raspberry Pi设备使用Broadcom提供的专有引导加载程序，而不是U-Boot。与以前的Raspberry Pi型号不同，Raspberry
    Pi 4的引导加载程序驻留在板载SPI EEPROM中，而不是在microSD卡上。我们仍然需要将Raspberry Pi 4的内核镜像和设备树blob放到microSD卡上，以便启动我们的64位内核。
- en: Before proceeding, you need a microSD card with a FAT32 `boot` partition large
    enough to hold the necessary kernel build artifacts. The `boot` partition needs
    to be the first partition on the microSD card. A partition size of 1 GB is sufficient.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 在继续之前，你需要一张带有FAT32 `boot`分区的microSD卡，分区足够大以容纳必要的内核构建文件。`boot`分区需要是microSD卡的第一个分区，1
    GB的分区大小足够。
- en: For guidance on connecting a USB-to-TTL serial cable to the Raspberry Pi 4,
    see [https://learn.adafruit.com/adafruits-raspberry-pi-lesson-5-using-a-console-cable/connect-the-lead](https://learn.adafruit.com/adafruits-raspberry-pi-lesson-5-using-a-console-cable/connect-the-lead).
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 有关如何将USB到TTL串口电缆连接到Raspberry Pi 4的指导，请参见[https://learn.adafruit.com/adafruits-raspberry-pi-lesson-5-using-a-console-cable/connect-the-lead](https://learn.adafruit.com/adafruits-raspberry-pi-lesson-5-using-a-console-cable/connect-the-lead)。
- en: 'To prepare a microSD card with your newly built kernel image and boot it on
    your Raspberry Pi 4:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 要准备一张microSD卡，加载你新构建的内核镜像并在Raspberry Pi 4上启动：
- en: 'First, navigate one level above the `boot` directory:'
  id: totrans-254
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，进入`boot`目录的上一级：
- en: '[PRE31]'
  id: totrans-255
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Next, insert the microSD card into your card reader and copy the entire contents
    of the `boot` directory to the `boot` partition.
  id: totrans-256
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，将microSD卡插入卡读卡器，并将`boot`目录的所有内容复制到`boot`分区。
- en: Unmount the card and insert it into the Raspberry Pi 4.
  id: totrans-257
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 卸载卡并将其插入Raspberry Pi 4。
- en: Connect your USB-to-TTL serial cable to the GND, TXD, and RXD pins on the 40-pin
    GPIO header.
  id: totrans-258
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将你的USB到TTL串口电缆连接到40针GPIO头的GND、TXD和RXD引脚。
- en: Start a terminal emulator like `gtkterm`.
  id: totrans-259
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 启动一个终端仿真器，如`gtkterm`。
- en: Lastly, power on the Raspberry Pi 4.
  id: totrans-260
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，启动Raspberry Pi 4。
- en: 'You should see the following output on the serial console:'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该能在串口控制台看到以下输出：
- en: '[PRE32]'
  id: totrans-262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: The sequence will end in a kernel panic because the kernel cannot locate a root
    filesystem on the microSD card. I’ll explain what a kernel panic is later in this
    chapter.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 该序列将以内核恐慌结束，因为内核无法在microSD卡上找到根文件系统。我将在本章后面解释什么是内核恐慌。
- en: Building a kernel for the BeaglePlay
  id: totrans-264
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 为BeaglePlay构建内核
- en: 'Here is the sequence of commands to build a kernel, modules, and device tree
    for the BeaglePlay:'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是为BeaglePlay构建内核、模块和设备树的命令序列：
- en: 'First, add the 64-bit Arm toolchain to your `PATH` if you haven’t already:'
  id: totrans-266
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，如果尚未添加，将64位Arm工具链添加到你的`PATH`中：
- en: '[PRE33]'
  id: totrans-267
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Next, navigate back to the mainline Linux source tree:'
  id: totrans-268
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，返回主线Linux源树：
- en: '[PRE34]'
  id: totrans-269
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Set the `ARCH` and `CROSS_COMPILE` environment variables for 64-bit Arm:'
  id: totrans-270
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为64位Arm设置`ARCH`和`CROSS_COMPILE`环境变量：
- en: '[PRE35]'
  id: totrans-271
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Run `make defconfig` to configure a kernel suitable for most 64-bit Arm SoCs:'
  id: totrans-272
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行`make defconfig`来配置一个适用于大多数64位Arm SoC的内核：
- en: '[PRE36]'
  id: totrans-273
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Run `make menuconfig` to continue configuring the kernel:'
  id: totrans-274
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行`make menuconfig`继续配置内核：
- en: '[PRE37]'
  id: totrans-275
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Drill down into the **General architecture-dependent options** submenu.
  id: totrans-276
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 进入**通用架构相关选项**子菜单。
- en: Deselect **GCC plugins** if it is set.
  id: totrans-277
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果已选择**GCC插件**，请取消选择。
- en: Back out of the **General architecture-dependent options** submenu.
  id: totrans-278
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 退出**通用架构相关选项**子菜单。
- en: Drill down into the **Platform selection** submenu.
  id: totrans-279
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 进入**平台选择**子菜单。
- en: Deselect support for all SoCs except for **Texas Instruments Inc. K3 multicore
    SoC architecture**.
  id: totrans-280
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 取消选择所有SoC的支持，除了**德州仪器公司K3多核SoC架构**。
- en: Back out of the **Platform selection** submenu.
  id: totrans-281
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 退出**平台选择**子菜单。
- en: Drill down into the **Device drivers** | **Graphics support** submenu
  id: totrans-282
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 进入**设备驱动程序** | **图形支持**子菜单
- en: Deselect **Direct Rendering Manager**.
  id: totrans-283
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 取消选择**直接渲染管理器**。
- en: Back out of the **Graphics support** and **Device drivers** submenus.
  id: totrans-284
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 退出**图形支持**和**设备驱动程序**子菜单。
- en: Exit out of `menuconfig` and choose **Yes** when asked to save your new configuration.
  id: totrans-285
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 退出`menuconfig`并在询问是否保存新配置时选择**是**。
- en: 'Lastly, build a kernel, modules, and device tree for the BeaglePlay:'
  id: totrans-286
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，为BeaglePlay构建内核、模块和设备树：
- en: '[PRE38]'
  id: totrans-287
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Replace `<n>` after `make -j` with the number of CPU cores available on your
    host machine to speed up your build.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 将`make -j`后面的`<n>`替换为你主机上可用的CPU核心数，以加快构建速度。
- en: Booting the BeaglePlay
  id: totrans-289
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 启动BeaglePlay
- en: 'Before proceeding, you need a microSD card with U-Boot installed, as described
    in the section titled *Installing U-Boot* from [*Chapter 3*](Chapter_03.xhtml#_idTextAnchor061):'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 在继续之前，你需要一张已经安装了U-Boot的microSD卡，如[*第3章*](Chapter_03.xhtml#_idTextAnchor061)中的*安装U-Boot*部分所描述：
- en: 'First, navigate one level above the `build_beagleplay` directory:'
  id: totrans-291
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，进入`build_beagleplay`目录的上一层：
- en: '[PRE39]'
  id: totrans-292
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Next, insert the microSD card into your card reader and copy the `build_beagleplay/arch/arm64/boot/Image.gz`
    and `build_beagleplay/arch/arm64/boot/dts/ti/k3-am625-beagleplay.dtb` files to
    the FAT32 `boot` partition.
  id: totrans-293
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，将microSD卡插入卡读卡器，并将`build_beagleplay/arch/arm64/boot/Image.gz`和`build_beagleplay/arch/arm64/boot/dts/ti/k3-am625-beagleplay.dtb`文件复制到FAT32的`boot`分区中。
- en: Unmount the card and insert it into the BeaglePlay.
  id: totrans-294
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 卸载卡并将其插入BeaglePlay。
- en: Start a terminal emulator like `gtkterm` and be prepared to press the spacebar
    as soon as you see the U-Boot messages appear.
  id: totrans-295
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 启动终端模拟器，如`gtkterm`，并准备在看到U-Boot消息出现时立即按下空格键。
- en: Power on the BeaglePlay while holding down the USR button and press the spacebar.
  id: totrans-296
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按住USR按钮并按下空格键启动BeaglePlay。
- en: 'Lastly, enter the following commands at the U-Boot prompt:'
  id: totrans-297
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，在U-Boot提示符下输入以下命令：
- en: '[PRE40]'
  id: totrans-298
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'You should see the following output on the serial console:'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该在串行控制台看到以下输出：
- en: '[PRE41]'
  id: totrans-300
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: Note that we set the kernel command line to `console=ttyS2`. That tells Linux
    which UART device to use for console output. Without this, we would not see any
    messages after `Starting the kernel...` and so would be unable to tell if it was
    working or not. The sequence ends in a kernel panic, just as it did for the Raspberry
    Pi 4.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们将内核命令行设置为`console=ttyS2`。这告诉Linux使用哪个UART设备来输出控制台信息。如果没有这个设置，我们将无法看到`Starting
    the kernel...`之后的任何信息，也无法知道系统是否正常工作。序列会以内核崩溃结束，正如Raspberry Pi 4所表现的一样。
- en: Building a kernel for QEMU
  id: totrans-302
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 为QEMU构建内核
- en: 'Here is the sequence of commands to build Linux for the `virt` generic virtual
    platform emulated by QEMU:'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 这是为QEMU模拟的`virt`通用虚拟平台构建Linux的命令序列：
- en: 'First, add the 64-bit Arm toolchain to your `PATH` if you haven’t already:'
  id: totrans-304
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果你还没有添加64位Arm工具链到`PATH`，请首先添加：
- en: '[PRE42]'
  id: totrans-305
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Next, navigate back to the mainline Linux source tree:'
  id: totrans-306
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，返回到主线Linux源码树：
- en: '[PRE43]'
  id: totrans-307
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Set the `ARCH` and `CROSS_COMPILE` environment variables for 64-bit Arm:'
  id: totrans-308
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为64位Arm设置`ARCH`和`CROSS_COMPILE`环境变量：
- en: '[PRE44]'
  id: totrans-309
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Run `make defconfig` to configure a kernel suitable for most 64-bit Arm SoCs:'
  id: totrans-310
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行`make defconfig`来配置适用于大多数64位Arm SoC的内核：
- en: '[PRE45]'
  id: totrans-311
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Run `make menuconfig` to continue configuring the kernel:'
  id: totrans-312
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行`make menuconfig`继续配置内核：
- en: '[PRE46]'
  id: totrans-313
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE46]'
- en: Drill down into the **Platform selection** submenu.
  id: totrans-314
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 进入**平台选择**子菜单。
- en: Deselect support for all SoCs except for **ARMv8 software model (Versatile Express)**.
  id: totrans-315
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 取消选择除**ARMv8软件模型（Versatile Express）**外的所有SoC支持。
- en: Back out of the **Platform selection** submenu.
  id: totrans-316
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 退出**平台选择**子菜单。
- en: Select **ACPI (Advanced Configuration and Power Interface) Support**.
  id: totrans-317
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择**ACPI（高级配置和电源接口）支持**。
- en: Exit out of `menuconfig` and choose **Yes** when asked to save your new configuration.
  id: totrans-318
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 退出`menuconfig`，并在被询问是否保存新配置时选择**Yes**。
- en: 'Lastly, build a kernel, modules, and device tree for QEMU:'
  id: totrans-319
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，为QEMU构建内核、模块和设备树：
- en: '[PRE47]'
  id: totrans-320
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE47]'
- en: Replace `<n>` after `make -j` with the number of CPU cores available on your
    host machine to speed up your build.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 将`make -j`后面的`<n>`替换为你主机上可用的CPU核心数，以加快构建速度。
- en: Booting QEMU
  id: totrans-322
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 启动QEMU
- en: 'Assuming that you have already installed `qemu-system-aarch64`, you can launch
    QEMU from the mainline kernel source tree as follows:'
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你已经安装了`qemu-system-aarch64`，你可以通过以下命令从主线内核源码树启动QEMU：
- en: '[PRE48]'
  id: totrans-324
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: As with the Raspberry Pi 4 and BeaglePlay, this will end with a kernel panic
    and the system will halt. To exit from QEMU, type *Ctrl + A* and then *x* (two
    separate keystrokes).
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 与Raspberry Pi 4和BeaglePlay一样，这将以内核崩溃并导致系统停止。要退出QEMU，按*Ctrl + A*然后按*x*（分别按下两个键）。
- en: Observing the kernel boot process
  id: totrans-326
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 观察内核启动过程
- en: At this point, you should have the kernel image files and the device tree blobs
    for the Raspberry Pi 4, BeaglePlay, and QEMU. Let’s start by looking at a kernel
    panic.
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 到此为止，你应该已经拥有了Raspberry Pi 4、BeaglePlay和QEMU的内核映像文件和设备树文件。让我们首先看一下内核崩溃。
- en: Kernel panic
  id: totrans-328
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 内核崩溃
- en: 'While things started off well on QEMU, they ended badly:'
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管在QEMU上起步顺利，但最终结果却不如人意：
- en: '[PRE49]'
  id: totrans-330
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: This is a good example of a kernel panic. A panic occurs when the kernel encounters
    an unrecoverable error. By default, it will print out a message to the console
    and then halt. You can set the panic command-line parameter to allow a few seconds
    before reboots following a panic. In this case, the unrecoverable error is no
    root filesystem, illustrating that a kernel is useless without a user space to
    control it. You can supply a user space by providing a root filesystem, either
    as a RAM disk or on a mountable mass storage device. We will talk about how to
    create a root filesystem in the next chapter, but first, I want to describe the
    sequence of events that leads up to panic.
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个内核恐慌的好例子。当内核遇到无法恢复的错误时，就会发生恐慌。默认情况下，它会在控制台打印一条消息，然后停止。你可以设置恐慌命令行参数，允许在重启前等待几秒钟。在这种情况下，无法恢复的错误是没有根文件系统，这说明没有用户空间来控制内核时，内核是无用的。你可以通过提供根文件系统来提供用户空间，根文件系统可以是一个RAM磁盘或可挂载的外部存储设备。我们将在下一章讨论如何创建根文件系统，但首先，我想描述一下导致恐慌的事件顺序。
- en: Early user space
  id: totrans-332
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 早期用户空间
- en: To transition from kernel initialization to user space, the kernel has to mount
    a root filesystem and execute a program in that root filesystem. This can be achieved
    via a RAM disk or by mounting a real filesystem on a block device. The code for
    all of this is in `init/main.c` starting with the function `rest_init()`, which
    creates the first thread with PID 1 and runs the code in `kernel_init()`. If there
    is a RAM disk, it will try to execute the program `/init`, which will take on
    the task of setting up the user space.
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 为了从内核初始化过渡到用户空间，内核必须挂载根文件系统并执行该根文件系统中的程序。这可以通过RAM磁盘或将真实的文件系统挂载到块设备上来实现。所有这些代码都位于`init/main.c`中，从`rest_init()`函数开始，`rest_init()`创建了第一个线程，PID为1，并运行`kernel_init()`中的代码。如果有RAM磁盘，它将尝试执行程序`/init`，该程序将负责设置用户空间。
- en: 'If the kernel fails to find and run `/init`, it tries to mount a filesystem
    by calling the function `prepare_namespace()` in `init/do_mounts.c`. This requires
    a `root=` command line to give the name of the block device to use for mounting
    usually in the form:'
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 如果内核无法找到并运行`/init`，它会尝试通过调用`init/do_mounts.c`中的`prepare_namespace()`函数来挂载文件系统。这需要一个`root=`命令行来提供用于挂载的块设备的名称，通常是以下形式：
- en: '[PRE50]'
  id: totrans-335
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'Or for SD cards and eMMC:'
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 或者对于SD卡和eMMC：
- en: '[PRE51]'
  id: totrans-337
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: For example, for the first partition on an SD card, that would be `root=/dev/mmcblk0p1`.
    If the mount succeeds, it will try to execute `/sbin/init`, followed by `/etc/init`,
    `/bin/init`, and then `/bin/sh`, stopping at the first one that works. The program
    can be overridden on the command line. For a RAM disk, use `rdinit=`. For a filesystem,
    use `init=`.
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，对于SD卡的第一个分区，应该是`root=/dev/mmcblk0p1`。如果挂载成功，它会尝试执行`/sbin/init`，然后是`/etc/init`、`/bin/init`，最后是`/bin/sh`，并在第一个成功的程序处停止。这个程序可以在命令行上被覆盖。对于RAM磁盘，使用`rdinit=`。对于文件系统，使用`init=`。
- en: Kernel messages
  id: totrans-339
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 内核消息
- en: 'Kernel developers are fond of printing out useful information through the liberal
    use of `printk()` and similar functions. The messages are categorized according
    to importance, with `0` being the highest:'
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 内核开发人员喜欢通过广泛使用`printk()`和类似的函数打印有用的信息。这些消息按重要性进行分类，`0`为最高级别：
- en: '| **Level** | **Value** | **Meaning** |'
  id: totrans-341
  prefs: []
  type: TYPE_TB
  zh: '| **级别** | **值** | **含义** |'
- en: '| `KERN_EMERG` | `0` | The system is unusable |'
  id: totrans-342
  prefs: []
  type: TYPE_TB
  zh: '| `KERN_EMERG` | `0` | 系统不可用 |'
- en: '| `KERN_ALERT` | `1` | Action must be taken immediately |'
  id: totrans-343
  prefs: []
  type: TYPE_TB
  zh: '| `KERN_ALERT` | `1` | 必须立即采取行动 |'
- en: '| `KERN_CRIT` | `2` | Critical conditions |'
  id: totrans-344
  prefs: []
  type: TYPE_TB
  zh: '| `KERN_CRIT` | `2` | 严重条件 |'
- en: '| `KERN_ERR` | `3` | Error conditions |'
  id: totrans-345
  prefs: []
  type: TYPE_TB
  zh: '| `KERN_ERR` | `3` | 错误条件 |'
- en: '| `KERN_WARNING` | `4` | Warning conditions |'
  id: totrans-346
  prefs: []
  type: TYPE_TB
  zh: '| `KERN_WARNING` | `4` | 警告条件 |'
- en: '| `KERN_NOTICE` | `5` | Normal but significant conditions |'
  id: totrans-347
  prefs: []
  type: TYPE_TB
  zh: '| `KERN_NOTICE` | `5` | 正常但重要的条件 |'
- en: '| `KERN_INFO` | `6` | Informational |'
  id: totrans-348
  prefs: []
  type: TYPE_TB
  zh: '| `KERN_INFO` | `6` | 信息性 |'
- en: '| `KERN_DEBUG` | `7` | Debug-level messages |'
  id: totrans-349
  prefs: []
  type: TYPE_TB
  zh: '| `KERN_DEBUG` | `7` | 调试级别的消息 |'
- en: Table 4.1 – List of kernel messages
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 表4.1 – 内核消息列表
- en: They are first written to a buffer named `__log_buf`, the size of which is two
    to the power of `CONFIG_LOG_BUF_SHIFT`. For example, if `CONFIG_LOG_BUF_SHIFT`
    is `16`, then `__log_buf` is 64 KB. You can dump the entire buffer using the command
    `dmesg`.
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 它们首先被写入名为`__log_buf`的缓冲区，其大小是`CONFIG_LOG_BUF_SHIFT`的2的幂次方。例如，如果`CONFIG_LOG_BUF_SHIFT`是`16`，则`__log_buf`为64KB。你可以使用`dmesg`命令转储整个缓冲区。
- en: If the level of a message is less than the console log level, it is displayed
    on the console as well as placed in `__log_buf`. The default console log level
    is `7`. This means that messages of level `6` and lower are displayed while filtering
    out `KERN_DEBUG`, which is level `7`.
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 如果消息的级别低于控制台日志级别，则该消息会显示在控制台上并被放入 `__log_buf` 中。默认的控制台日志级别是 `7`。这意味着级别为 `6`
    及以下的消息会显示，而 `KERN_DEBUG` 级别（即级别 `7`）的消息会被过滤掉。
- en: You can change the console log level in several ways, including by using the
    kernel parameter `loglevel=<level>` or the command `dmesg -n <level>`.
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过几种方式更改控制台日志级别，包括使用内核参数 `loglevel=<level>` 或命令 `dmesg -n <level>`。
- en: Kernel command line
  id: totrans-354
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 内核命令行
- en: The kernel command line is a string that is passed to the kernel by the bootloader
    via the `bootargs` variable in the case of U-Boot. It can also be defined in the
    device tree or set as part of the kernel configuration in `CONFIG_CMDLINE`.
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 内核命令行是一个字符串，由引导加载程序通过 `bootargs` 变量传递给内核，在 U-Boot 的情况下就是这样。它也可以在设备树中定义，或作为内核配置的一部分在
    `CONFIG_CMDLINE` 中设置。
- en: 'We have seen some examples of the kernel command line already but there are
    many more. There is a complete list in `Documentation/admin-guide/kernel-parameters.txt`.
    Here is a smaller list of the most useful ones:'
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看过一些内核命令行的例子，但还有很多其他的。完整的列表可以在 `Documentation/admin-guide/kernel-parameters.txt`
    中找到。以下是一些最常用的参数：
- en: '`debug`: Sets the console log level to the highest level (`8`) to ensure that
    you see all the kernel messages on the console.'
  id: totrans-357
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`debug`：将控制台日志级别设置为最高级别（`8`），确保在控制台上看到所有内核消息。'
- en: '`init=`: The `init` program to run from a mounted root filesystem. Defaults
    to `/sbin/init`.'
  id: totrans-358
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`init=`：从挂载的根文件系统中运行的 `init` 程序。默认为 `/sbin/init`。'
- en: '`lpj=`: Sets `loops_per_jiffy` to a given constant. There is a description
    of the significance of this in the paragraph following this list.'
  id: totrans-359
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`lpj=`：将 `loops_per_jiffy` 设置为给定的常数。在此列表后的段落中有关于此的详细说明。'
- en: '`panic=`: Behavior when the kernel panics. If it is greater than zero, it gives
    the number of seconds before rebooting; if it is zero, it waits forever (default);
    or if it is less than zero, it reboots without any delay.'
  id: totrans-360
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`panic=`：当内核出现 panic 时的行为。如果该值大于零，则表示在重启前的等待秒数；如果为零，则表示永远等待（默认）；如果小于零，则会在没有任何延迟的情况下重启。'
- en: '`quiet`: Sets the console log level to silent, suppressing all but emergency
    messages. Since most devices have a serial console, it takes time to output all
    those strings. Consequently, reducing the number of messages using this option
    reduces boot time.'
  id: totrans-361
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`quiet`：将控制台日志级别设置为静默，抑制所有非紧急信息。由于大多数设备具有串行控制台，因此输出所有这些字符串需要时间。因此，使用此选项减少消息数量会缩短启动时间。'
- en: '`rdinit=`: The init program to run from a RAM disk. Defaults to `/init`.'
  id: totrans-362
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`rdinit=`：从 RAM 磁盘中运行的 init 程序。默认为 `/init`。'
- en: '`ro`: Mounts the root device as read-only. Has no effect on a RAM disk, which
    is always read/write.'
  id: totrans-363
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ro`：以只读模式挂载根设备。对 RAM 磁盘没有影响，RAM 磁盘始终是读写的。'
- en: '`root=`: Device to mount the root filesystem.'
  id: totrans-364
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`root=`：挂载根文件系统的设备。'
- en: '`rootdelay=`: Number of seconds to wait before trying to mount the root device.
    Defaults to zero. Useful if the device takes time to probe the hardware. Also
    see `rootwait`.'
  id: totrans-365
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`rootdelay=`：在尝试挂载根设备之前等待的秒数。默认为零。如果设备需要时间来探测硬件，则此参数非常有用。另见 `rootwait`。'
- en: '`rootfstype=`: Filesystem type for the root device. In many cases, it is auto-detected
    during mount, although it is required for jffs2 filesystems.'
  id: totrans-366
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`rootfstype=`：根设备的文件系统类型。在许多情况下，它会在挂载过程中自动检测，尽管对于 jffs2 文件系统是必需的。'
- en: '`rootwait`: Waits indefinitely for the root device to be detected, usually
    necessary with MMC devices.'
  id: totrans-367
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`rootwait`：无限期等待根设备被检测到，通常在 MMC 设备中需要使用。'
- en: '`rw`: Mounts the root device as read-write (default).'
  id: totrans-368
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`rw`：以读写模式挂载根设备（默认）。'
- en: 'The `lpj` parameter is often mentioned in connection with reducing the kernel
    boot time. During initialization, the kernel loops for approximately 250 ms to
    calibrate a delay loop. The value is stored in the variable `loops_per_jiffy`
    and reported like this:'
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: '`lpj` 参数常与减少内核启动时间相关提及。在初始化过程中，内核会循环大约 250 毫秒来校准延迟循环。该值存储在变量 `loops_per_jiffy`
    中，并以如下方式报告：'
- en: '[PRE52]'
  id: totrans-370
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: If the kernel always runs on the same hardware, it will always calculate the
    same value. You can shave 250 ms off the boot time by adding `lpj=4980736` to
    the command line.
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: 如果内核始终运行在相同的硬件上，它将始终计算相同的值。通过在命令行中添加 `lpj=4980736`，你可以将启动时间缩短 250 毫秒。
- en: In the next section, we will learn how to port Linux to a new board based on
    the BeaglePlay, our hypothetical Nova board.
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将学习如何基于 BeaglePlay（我们假设的 Nova 开发板）将 Linux 移植到新开发板上。
- en: Porting Linux to a new board
  id: totrans-373
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将 Linux 移植到新板卡
- en: Porting Linux to a new board can be easy or difficult, depending on how similar
    your board is to an existing development board. In [*Chapter 3*](Chapter_03.xhtml#_idTextAnchor061)*,*
    we ported U-Boot to a new board named Nova based on the BeaglePlay. Very few changes
    need to be made to the kernel code, so it is very easy. If you are porting to
    completely new and innovative hardware, then there will be more to do. I am only
    going to consider the simple case. We will delve deeper into the topic of additional
    hardware peripherals throughout [*Chapter 12*](#_idTextAnchor126).
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: 将 Linux 移植到新板卡可以简单也可以复杂，这取决于你的板卡与现有开发板的相似程度。在[*第 3 章*](Chapter_03.xhtml#_idTextAnchor061)中，我们将
    U-Boot 移植到名为 Nova 的新板卡上，该板卡基于 BeaglePlay。对内核代码几乎不需要做任何修改，因此非常容易。如果你正在将其移植到全新且创新的硬件上，那就需要做更多的工作。我这里只考虑简单的情况。关于附加硬件外设的主题，我们将在[*第
    12 章*](#_idTextAnchor126)中进行更深入的讨论。
- en: The organization of architecture-specific code in `arch/$ARCH` differs from
    one system to another. The x86 architecture is fairly clean because most hardware
    details are detected at runtime. The PowerPC architecture organizes SoC- and board-specific
    files into subdirectories under `platforms`. The 32-bit Arm architecture, on the
    other hand, is quite messy because there is a lot of variability between the many
    Arm-based SoCs. Platform-dependent code is put in directories named `mach-*`,
    approximately one per SoC. There are other directories named `plat-*`, which contain
    code common to several versions of an SoC.
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: '`arch/$ARCH` 中架构特定代码的组织在不同系统之间有所不同。x86 架构相对简洁，因为大多数硬件细节在运行时被检测到。PowerPC 架构将
    SoC 和板卡特定的文件组织到 `platforms` 下的子目录中。另一方面，32 位 Arm 架构相对混乱，因为许多基于 Arm 的 SoC 之间存在很大的差异。与平台相关的代码被放置在名为
    `mach-*` 的目录中，几乎每个 SoC 都有一个对应的目录。还有其他名为 `plat-*` 的目录，其中包含多个版本的 SoC 公共代码。'
- en: In the following sections, I am going to explain how to create a device tree
    for a new 64-bit Arm board.
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的章节中，我将解释如何为新的 64 位 Arm 板卡创建设备树。
- en: A new device tree
  id: totrans-377
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 新的设备树
- en: 'The first thing to do is create a device tree for the board and modify it to
    describe the additional or changed hardware of the Nova board. In this simple
    case, we just copy `k3-am625-beagleplay`.`dts` to `nova.dts` and change the model
    name to Nova, as shown here:'
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: 首先要做的是为板卡创建一个设备树，并修改它以描述 Nova 板卡的附加或更改硬件。在这个简单的例子中，我们只是将 `k3-am625-beagleplay.dts`
    复制到 `nova.dts`，并将模型名称更改为 Nova，如下所示：
- en: '[PRE53]'
  id: totrans-379
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: Complete all the steps from *Building a kernel for the BeaglePlay*.
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: 完成*为 BeaglePlay 构建内核*中的所有步骤。
- en: 'Add the following dependency to `linux-stable/arch/arm64/boot/dts/ti/Makefile`:'
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: 向 `linux-stable/arch/arm64/boot/dts/ti/Makefile` 添加以下依赖：
- en: '[PRE54]'
  id: totrans-382
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: This entry ensures that the device tree for Nova is compiled whenever an AM62x
    target is selected.
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: 这个条目确保在选择 AM62x 目标时，Nova 的设备树会被编译。
- en: 'Build the Nova device tree binary like this:'
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: 如下所示构建 Nova 设备树二进制文件：
- en: '[PRE55]'
  id: totrans-385
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'We can see the effect of using the Nova device tree by booting the BeaglePlay.
    Follow the same procedure as in *Booting the BeaglePlay*. Insert the same microSD
    card into your card reader and copy the `build_beagleplay/arch/arm64/boot/dts/ti/nova.dtb`
    file to the FAT32 `boot` partition. Use the same `Image.gz` file as before but
    load `nova.dtb` in place of `k3-am625-beagleplay`.`dtb`. The following output
    is the point at which the machine model is printed out:'
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过启动 BeaglePlay 来看到使用 Nova 设备树的效果。按照与*启动 BeaglePlay*相同的步骤操作。将同一张 microSD
    卡插入读卡器，并将 `build_beagleplay/arch/arm64/boot/dts/ti/nova.dtb` 文件复制到 FAT32 `boot`
    分区中。使用与之前相同的 `Image.gz` 文件，但加载 `nova.dtb` 替代 `k3-am625-beagleplay.dtb`。以下输出显示机器模型被打印出来的位置：
- en: '[PRE56]'
  id: totrans-387
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: Now that we have a device tree specifically for the Nova board, we could modify
    it to describe the hardware differences between Nova and BeaglePlay. There are
    quite likely to be changes to the kernel configuration as well. In that case,
    you would create a custom configuration file based on a copy of `arch/arm64/configs/defconfig`.
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经有了专门为 Nova 板卡准备的设备树，我们可以修改它，以描述 Nova 和 BeaglePlay 之间的硬件差异。内核配置也很可能需要做出相应的更改。在这种情况下，你需要基于
    `arch/arm64/configs/defconfig` 的副本创建一个自定义配置文件。
- en: Summary
  id: totrans-389
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: What makes Linux so powerful is the ability to configure the kernel however
    we need to. The definitive place to get the kernel source code is [https://www.kernel.org/](https://www.kernel.org/),
    but you will probably need to get the source for a particular SoC or board from
    the vendor of that device or a third party that supports that device. The customization
    of the kernel for a particular target may consist of changes to the core kernel
    code, additional drivers for devices that are not in mainline Linux, a default
    kernel configuration file, and a device tree source file.
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: Linux之所以强大，是因为它能够根据需求配置内核。获取内核源代码的权威来源是[https://www.kernel.org/](https://www.kernel.org/)，但你可能需要从设备厂商或支持该设备的第三方处获取特定SoC或开发板的源代码。为特定目标定制内核可能包括对核心内核代码的修改、为未包含在主线Linux中的设备添加驱动程序、一个默认的内核配置文件以及设备树源文件。
- en: Normally, you start with the default configuration for your target board and
    then tweak it by running one of the configuration tools such as `menuconfig`.
    One of the things you should consider at this point is whether the kernel features
    and drivers should be disabled, compiled as modules, or built-in. Kernel modules
    are usually no great advantage for embedded systems where the feature set and
    hardware are usually well defined. However, modules offer a way to import proprietary
    code into the kernel and reduce boot times by loading non-essential drivers after
    booting. Disabling unused kernel features and drivers altogether reduces compile
    times as well as boot times.
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，你从目标开发板的默认配置开始，然后通过运行配置工具之一（如`menuconfig`）进行调整。在这个阶段，你应该考虑的一件事是内核特性和驱动程序是否应该被禁用、作为模块编译，或是内建到内核中。对于嵌入式系统来说，内核模块通常没有太大优势，因为嵌入式系统的特性和硬件通常是明确规定的。然而，模块提供了一种将专有代码导入内核的方式，并通过在启动后加载非必要的驱动程序来减少启动时间。完全禁用不使用的内核特性和驱动程序可以减少编译时间以及启动时间。
- en: Building the kernel produces a compressed kernel image file named `zImage`,
    `Image.gz`, or `bzImage`, depending on the bootloader you will be using and the
    target architecture. A kernel build will also generate any kernel modules (`.ko`
    files) that you have configured and device tree binaries (`.dtb` files) if your
    target requires them.
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
  zh: 构建内核会生成一个压缩的内核镜像文件，文件名为`zImage`、`Image.gz`或`bzImage`，具体取决于你将使用的引导加载程序和目标架构。内核构建还会生成你配置的任何内核模块（`.ko`文件）和设备树二进制文件（`.dtb`文件），如果你的目标需要它们的话。
- en: Porting Linux to a new target board can be quite simple or very difficult, depending
    on how different the hardware is from that in the mainline or vendor-supplied
    kernel. If your hardware is based on a well-known reference design, then it may
    be just a question of making changes to the device tree or the platform data.
    You may well need to add device drivers, which we’ll discuss in [*Chapter 11*](Chapter_11.xhtml#_idTextAnchor373).
    However, if the hardware is radically different from a reference design, you may
    need additional core support, which is outside the scope of this book.
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: 将Linux移植到一个新目标开发板可能非常简单，也可能非常困难，这取决于硬件与主线或厂商提供的内核有多大的差异。如果你的硬件基于一个众所周知的参考设计，那么可能只需要修改设备树或平台数据。你可能需要添加设备驱动程序，我们将在[*第11章*](Chapter_11.xhtml#_idTextAnchor373)中讨论。不过，如果硬件与参考设计有很大不同，你可能需要额外的核心支持，这超出了本书的范围。
- en: The kernel is the core of a Linux-based system but it cannot work by itself.
    It requires a root filesystem that contains the user space components. The root
    filesystem can be a RAM disk or a filesystem accessed via a block device, which
    will be the subject of the next chapter. As we have seen, booting a kernel without
    a root filesystem results in kernel panic.
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: 内核是基于Linux系统的核心，但它无法独立工作。它需要一个包含用户空间组件的根文件系统。根文件系统可以是RAM磁盘或通过块设备访问的文件系统，这将是下一章的主题。正如我们所见，没有根文件系统的内核启动会导致内核崩溃（kernel
    panic）。
- en: Further study
  id: totrans-395
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 深入学习
- en: '*So You Want to Build an Embedded Linux System?* by Jay Carlson – [https://jaycarlson.net/embedded-linux/](https://jaycarlson.net/embedded-linux/)'
  id: totrans-396
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*你想构建一个嵌入式Linux系统吗？* 由Jay Carlson编写 – [https://jaycarlson.net/embedded-linux/](https://jaycarlson.net/embedded-linux/)'
- en: '*Embedded Linux training* – [https://bootlin.com/training/embedded-linux/](https://bootlin.com/training/embedded-linux/%0D%0A)'
  id: totrans-397
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*嵌入式Linux培训* – [https://bootlin.com/training/embedded-linux/](https://bootlin.com/training/embedded-linux/%0D%0A)'
- en: '*Linux Weekly News* – [https://lwn.net/](https://lwn.net/)'
  id: totrans-398
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*Linux每周新闻* – [https://lwn.net/](https://lwn.net/)'
- en: '*Raspberry Pi Forums* – [https://forums.raspberrypi.com/](https://forums.raspberrypi.com/)'
  id: totrans-399
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*树莓派论坛* – [https://forums.raspberrypi.com/](https://forums.raspberrypi.com/)'
- en: '*Linux Kernel Development, Third Edition*, by Robert Love'
  id: totrans-400
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*Linux Kernel Development, Third Edition*, by Robert Love'
