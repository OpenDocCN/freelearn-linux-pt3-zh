- en: '8'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Writing Our First Script – Turning Simple Cmdlets into Reusable Code
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Starting in this chapter, we’re going to look at how we can put the basic concepts
    we’ve learned together into scripts and tools that we can reuse, adapt, and distribute
    for others. In the coming chapters, we’re going to look at creating functions
    and script blocks, error handling and debugging, creating modules that allow us
    to distribute our code as tools, and finally, securing PowerShell. In this chapter,
    though, we’re going to start with the basics: turning a handful of cmdlets into
    a script.'
  prefs: []
  type: TYPE_NORMAL
- en: We’ll start by discussing scripts in general and why we might want to write
    one. After that, we’ll take a quick look at where we can find PowerShell scripts
    online, and then we’ll cover how we can run scripts.
  prefs: []
  type: TYPE_NORMAL
- en: Once we understand how to use other people’s scripts, we’ll dive into writing
    our own. First, we’ll learn how to identify changing values in a working cmdlet
    pipeline, then we’ll learn how to turn those into parameters so we can pass the
    values into the cmdlets when we run the script, rather than having to edit the
    script each time. We’ll cover how to make parameters mandatory, how to take values
    from the pipeline, and how to create switch parameters, before moving on to cover
    how to help ourselves and others use our scripts.
  prefs: []
  type: TYPE_NORMAL
- en: In the second part of this chapter, we’ll cover how to add comments and comment
    blocks to our script that explain what we’re trying to do in each part and help
    us and others edit and adapt the script. Next, we’ll look at how we can write
    help information that can be accessed from outside the script using the `Get-Help`
    cmdlet. After that, we’ll move on to a script construct that can help us understand
    what is going on when the script is producing unexpected output – the `Write-Verbose`
    cmdlet. Finally, we’ll cover how to add help messages for mandatory parameters,
    which will prompt users with information about how to use the parameter.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we are going to cover the following main topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Introduction to scripting
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Writing a script
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Identifying changing values
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Working with parameters
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Providing help for our script
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction to scripting
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A script is a sequence of instructions written in a human-readable form for
    a computer to carry out. They are usually written in a scripting language such
    as PowerShell, Python, or JavaScript. We covered the differences between scripting
    languages and programming languages back in [*Chapter 1*](B17600_01.xhtml#_idTextAnchor013),
    *Introduction to PowerShell 7 – What It Is and How to Get It*; the key thing to
    remember is that scripting languages are interpreted and so need a program (such
    as PowerShell) to be running on the client to run the script, whereas programming
    languages are compiled; they will run directly in the operating system.
  prefs: []
  type: TYPE_NORMAL
- en: Scripting, to me, is an art form. It’s probably the truest cybernetic art form;
    what we write in a script has to make sense to both human beings and machines.
    In [*Chapter 6*](B17600_06.xhtml#_idTextAnchor117), *PowerShell and Files – Reading,
    Writing, and Manipulating Data*, we talked about *Exercises in Programming Style*
    by Cristina Videira Lopes, where a term frequency task was solved in dozens of
    different ways. This is equally true of scripts in PowerShell. There is no one
    way to write a script, and what seems lovely to one person may be really ugly
    to another; I have a deep loathing of code golf, where a script is written with
    as few lines and characters as possible, but that is a personal preference – other
    people love it. Simplicity, and clean and functional code – these things are beautiful,
    and it requires a creative and inventive mind to write it. In this chapter, we’re
    going to cover how I approach writing scripts.
  prefs: []
  type: TYPE_NORMAL
- en: Why do we want to write scripts?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Fundamentally, because we are lazy. A script allows us to capture a series of
    steps that may be complicated or time-consuming, and repeat them easily without
    work. Secondly, because we are fallible and easily distracted. The longer and
    more complicated a task is, the more likely we are to make a mistake. Writing
    a script means the task will be completed in the same way every time. If we can
    get it right once and capture that process, then we almost never need to get it
    right again. We can go and make our mistakes somewhere else. Finally, because
    we don’t want to do the thing at all; if we write a script, we can give it to
    somebody else to do.
  prefs: []
  type: TYPE_NORMAL
- en: Script writing is an example of toolmaking, where we create something to make
    our task easier to accomplish. Some script writing might be proper automation,
    but generally, automation includes the concept of a feedback loop, where the tool
    responds to an external stimulus without user intervention. A central heating
    boiler is a tool; it makes heating your house much easier than building a fire
    in each room. A thermostat is automation; when the temperature is too low, it
    turns the boiler on, and when it is too high, it turns the boiler off. If we’ve
    set it correctly, then we should never be too warm or too cold.
  prefs: []
  type: TYPE_NORMAL
- en: 'There is some theory around toolmaking and automation that is worth considering,
    as it can help us decide whether we want to write a script or not. Let’s quickly
    cover the three basic principles of automation:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Compensatory principle**: This is based on the concept that machines are
    better at some tasks than people, and people are better at some tasks than machines.
    Automation and tools based on this principle divide work based on the strengths
    and weaknesses of people and machines.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Complementarity principle**: Constantly using tools to accomplish difficult
    tasks can de-skill the human operator; we forget how to do things. Then, when
    we really need to take over, when things are going wrong, we can’t fix the problem.
    We use this principle where the human operator must retain the skills that the
    automation is replacing. Aircraft autopilots are a good example of this; the operator
    doesn’t use them all the time or may only use part of them so that they retain
    the skills they need when the autopilot can’t land the plane because of weather
    or a mechanical failure.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Left-over principle**: This is the principle we most commonly associate with
    scripting. It’s the idea that we automate everything we can, and then manually
    do what is left over.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Of course, it’s a little bit more complicated than that. Sometimes, tasks are
    too hard to automate, or we do them so rarely it’s not worth bothering. We’ll
    not save any time or effort by writing a script. A rule of thumb is to script
    anything that will take less time to script than you will spend doing it manually
    over three years. So, if you have a task that you do every weekday that takes
    5 minutes, and it will take you 4 hours to script, then that works out at 62 hours
    over 3 years. By spending 4 hours scripting it, you’ll save over a week of work
    for yourself, over 3 years. Let’s start by understanding where we can get scripts
    that other people have written.
  prefs: []
  type: TYPE_NORMAL
- en: Getting scripts
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We discussed different places to get PowerShell modules and cmdlets in [*Chapter
    2*](B17600_02.xhtml#_idTextAnchor034), *Exploring PowerShell Cmdlets and Syntax*.
    We can use those same places to find PowerShell scripts as well. Let’s just recap
    them:'
  prefs: []
  type: TYPE_NORMAL
- en: '**PowerShell repositories**: Whether it’s the official PowerShell repository
    at [https://www.powershellgallery.com/](https://www.powershellgallery.com/), the
    Microsoft Learn repository at [https://learn.microsoft.com/en-us/samples/browse/](https://learn.microsoft.com/en-us/samples/browse/),
    or an internal one, repositories are great places to find scripts. Generally speaking,
    scripts in the PowerShell Gallery have undergone some minimal validation and will
    have information about the author, the version, and the license for use.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**GitHub**: This is also a good source for PowerShell scripts, but they’re
    generally not validated and may not be complete or functional.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Online elsewhere**: There are very good scripts elsewhere online. For example,
    the Practical 365 site ([https://practical365.com](https://practical365.com))
    has some extremely useful scripts for working with Microsoft 365\. However, the
    quality of online scripts may be variable.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Whenever we get a script from an author we don’t know or trust, we should be
    careful to understand what the script does and how it does it before running it
    in an environment we care about. We should do this even when we do trust the author,
    of course. It is worth starting a sandbox or virtual machine to test the script
    first.
  prefs: []
  type: TYPE_NORMAL
- en: Running scripts
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There are two things we need to be aware of before we can run a script. The
    first is that PowerShell scripts always have an extension of `.ps1`. Files with
    this extension are not registered as executables, so double-clicking them in Windows
    Explorer will open them in Notepad or another editor; it won’t run the script.
    Files with this extension also require a relative or absolute path to run from
    the PowerShell terminal, so with either `PS C:\myscripts> .\MySuperScript.ps1`
    (relative path) or `PS C:\> C:\myscripts\MySuperScript.ps1` (absolute path) without
    the `.\`, the script won’t run.
  prefs: []
  type: TYPE_NORMAL
- en: 'Secondly, PowerShell has an execution policy for running scripts, but only
    on Windows computers. By default, on a Windows client, the execution policy is
    `Restricted`, which means that scripts cannot run. Happily, we can change this
    for the current user by running the following cmdlet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: This will allow the current user to run scripts that have been written on the
    local machine, or scripts downloaded from the internet that include a code signature.
    We’ll be covering execution policy and code signing in detail in [*Chapter 12*](B17600_12.xhtml#_idTextAnchor236),
    *Securing PowerShell*, but for now, run this cmdlet so that we can get on with
    writing a script.
  prefs: []
  type: TYPE_NORMAL
- en: If we are using a Linux or Mac client, we don’t need to do this. The policy
    is effectively `Unrestricted` for those computers because of differences in the
    way security is implemented in the Linux and macOS operating systems.
  prefs: []
  type: TYPE_NORMAL
- en: 'That’s enough introduction; let’s get on with what we’re here for: writing
    a script.'
  prefs: []
  type: TYPE_NORMAL
- en: Writing a script
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'How do we go about writing a script? Pretty much every script I write from
    scratch starts with writing down the steps and cmdlets I need to complete a task.
    Once I can complete the task with only the information in the list, and all the
    cmdlets work, I know I am ready. Let’s start our script with a working command.
    As an example, consider the following cmdlet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: This cmdlet gets some weather data for my location from the API service from
    the Weather API, using a personal key, and writes it to an HTML file for display.
    Obviously, I’ve not put my real personal key in the preceding cmdlet, so it will
    fail with an API key error if we run that exact code. Let’s consider how we might
    turn this cmdlet into a script. To continue, we’ll need to get our own personal
    key.
  prefs: []
  type: TYPE_NORMAL
- en: Getting a Personal Key for the Weather API Service
  prefs: []
  type: TYPE_NORMAL
- en: 'To work through this chapter, we’ll need our own personal key for the Weather
    API service:'
  prefs: []
  type: TYPE_NORMAL
- en: 1\. Go to [https://www.weatherapi.com](https://www.weatherapi.com) and click
    the **Sign** **Up** button.
  prefs: []
  type: TYPE_NORMAL
- en: 2\. Enter an email address (twice) and a new password (twice), accept the terms
    and conditions, complete the CAPTCHA, and we will be sent a verification email.
  prefs: []
  type: TYPE_NORMAL
- en: 3\. Clicking the link in the verification email will open a web page to tell
    us that we are verified, and will invite us to log in.
  prefs: []
  type: TYPE_NORMAL
- en: 4\. Do this by clicking the login link and entering our email address and the
    password we have just created. At the top of the next page is our personal API
    key. This is the key we will use to run this cmdlet.
  prefs: []
  type: TYPE_NORMAL
- en: 5\. Copy it and save it in a text file somewhere safe. You can always find it
    again by logging in to the service.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we’ve got a key, let’s open VS Code and create a new file. Call it `weatherdata.ps1`.
    Type the following, using the key we’ve just generated from the Weather API instead
    of `<our new` `key here>`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Let’s think about tidying this cmdlet up so that it is more readable. The cmdlet
    does two things; it gets information from the API, and it outputs that information
    to a file, so let’s split those up:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: So now, we are storing the response in a variable and then outputting it in
    the second line.
  prefs: []
  type: TYPE_NORMAL
- en: 'How else might we make this more readable? That first cmdlet is very long.
    We could break out the headers and the URI to make it more readable, as we can
    see in the following figure:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.1 – Readable code](img/B17600_08_001.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8.1 – Readable code
  prefs: []
  type: TYPE_NORMAL
- en: 'If we save `weatherdata.ps1`, we can now run it from the PowerShell console
    by switching to the directory we save it in and running the following at the prompt:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: While the code is readable, it’s not very flexible. It does one thing, and if
    we want it to do something slightly different (for instance, produce the data
    for a different city) or if we want to share it with someone else, we need to
    make some changes. Let’s look at where we might start with that.
  prefs: []
  type: TYPE_NORMAL
- en: Identifying changing values
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let’s think about things we might want to change in this code. We want it to
    get weather information from the web and write it to a HTML document. This means
    it’s unlikely that we want to change the `Invoke-RestMethod`, `Convertto-Html`,
    and `Out-File` cmdlets. Think about what values might change before we move on.
  prefs: []
  type: TYPE_NORMAL
- en: Ready? Good.
  prefs: []
  type: TYPE_NORMAL
- en: 'These are some things that we might want to be able to change the values of
    when we run the script:'
  prefs: []
  type: TYPE_NORMAL
- en: We might want to change the city.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We might want to change where we save the HTML output.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We might want to change the API key.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We might not want to hardcode the API key in the script at all.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We can pass values for these things when we call the script by making them parameters
    within the script. The next section will be all about parameterizing our script.
  prefs: []
  type: TYPE_NORMAL
- en: Working with parameters
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Parameters are values for script variables that can be passed when we run the
    script, rather than being hardcoded into the script. As we’ve just seen in the
    previous section, we run the script in much the same way as we run any other cmdlet,
    and, as with cmdlets, we can pass parameter values to our script. Let’s look at
    how we do that.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first thing we need is the `CmdletBinding` attribute. Attributes are a
    way of telling PowerShell how we want it to process the elements of our script.
    We’ve used them before in [*Chapter 4*](B17600_04.xhtml#_idTextAnchor071), *PowerShell
    Variables and Data Structures*, when we learned how to cast variables. The `CmdletBinding`
    attribute tells PowerShell that we want it to treat the script as a cmdlet. Some
    of the big advantages this has are that our script will be able to access common
    parameters such as `-Verbose`, as well as positional binding. Let’s add it. At
    the top of our script, create a new line and add this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we need to create a `Param()` block to hold the variables we want to
    use as parameters. On a line directly under the `CmdletBinding` attribute, type
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'The `Param()` block must precede all the code that we’re going to write. We
    will add our parameters inside the brackets, so it’s best to press *Enter* a couple
    of times inside the brackets so that we have some space to add them:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Now, we’re ready to start creating parameters.
  prefs: []
  type: TYPE_NORMAL
- en: Creating useful parameters
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The most useful parameters are values that change. Let’s start with the city
    we’re getting weather data for. The city is embedded in the `$uri` variable, which
    is a string. We can easily create a new variable to just hold the city name and
    pass it to the `$uri` variable. Try this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'And change the `$uri` variable to look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Remember we need to use double quotes here (`"`) so that the `$City` variable
    will be expanded. We can check our code against the following figure:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.2 – Adding the CmdletBinding attribute and a param() block](img/B17600_08_002.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8.2 – Adding the CmdletBinding attribute and a param() block
  prefs: []
  type: TYPE_NORMAL
- en: This will write the value of `$city` into the `$uri` value when we run it.
  prefs: []
  type: TYPE_NORMAL
- en: Test, Test, Test
  prefs: []
  type: TYPE_NORMAL
- en: This is really important; if we make two changes and the script stops working,
    we will have to work out which change broke the script. Test after every change.
    Make sure it all still works before moving on to another change.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s test it. From the console, make sure we’re in the directory where we’ve
    saved the script, and type the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, check the `WeatherData.html` file. It should look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.3 – Welcome to beautiful Paris](img/B17600_08_003.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8.3 – Welcome to beautiful Paris
  prefs: []
  type: TYPE_NORMAL
- en: If this has worked for you, congratulations! You have parameterized your first
    script. Let’s look at what we’ve done.
  prefs: []
  type: TYPE_NORMAL
- en: By putting the `$City` variable into the `Param()` block, we’ve made it accessible
    from outside the script so that we can pass values to it when we run the script.
    By assigning a value to the variable, writing `$City = "London"`, we’ve set a
    default value so that if we don’t pass a value via a parameter, the script will
    still run.
  prefs: []
  type: TYPE_NORMAL
- en: We can put as many variables as we like in the `Param()` block, but we must
    separate each one with a comma (`,`). Let’s do another one; try the following
    activity.
  prefs: []
  type: TYPE_NORMAL
- en: Activity 1
  prefs: []
  type: TYPE_NORMAL
- en: How might we pass the location where we want to save the output? And how might
    we make that as easy as possible?
  prefs: []
  type: TYPE_NORMAL
- en: 'Hint: if we pass just a filename, it will save the output in the same location
    as the script is running from. Would we want that every time?'
  prefs: []
  type: TYPE_NORMAL
- en: Let’s look at what we could do with the key. Keys are a long string of random
    characters, so it’s not going to be practical to type that into a parameter. How
    might we get around this?
  prefs: []
  type: TYPE_NORMAL
- en: We could save the key to a file, and then use `Get-Content` to extract the string
    from the file and use it that way. In [*Chapter 7*](B17600_07.xhtml#_idTextAnchor140),
    *PowerShell and the Web – HTTP, REST, and JSON* we saw there are two ways of passing
    a key to `Invoke-RestMethod`. We can either pass it to the `-Key` parameter or
    include it in the `-Headers` parameter, as we are doing in this script. The important
    difference is that in one scenario the key must be encoded, and in the other,
    it must be plain text. Can you remember which is which? Look back to the last
    chapter to find out.
  prefs: []
  type: TYPE_NORMAL
- en: If you remembered, well done. If you worked it out from how our script currently
    works, even better. We’re already passing an unencoded string in the header, so
    we don’t need to encode our key before saving it.
  prefs: []
  type: TYPE_NORMAL
- en: Open a new text document using your preferred text editor and save it as `key.txt`
    in the same folder as the script – in my case, `c:\temp\poshbook\ch8`. Copy and
    paste your `WeatherApi` key into it and save it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now all we need to do is add a parameter that points to the file, and a line
    that gets the content from the file. Then, we can add that to the `$headers` variable.
    It might look something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: We’ve identified our changing values and created our parameters.
  prefs: []
  type: TYPE_NORMAL
- en: Activity 2
  prefs: []
  type: TYPE_NORMAL
- en: Knowing what we know from previous chapters, how might we rewrite our script
    so that we can accept multiple values for the `-``City` parameter?
  prefs: []
  type: TYPE_NORMAL
- en: 'Hint 1: Look at a help file for a cmdlet that accepts multiple strings in a
    parameter to see how we could write an attribute for the `-City` parameter. `Get-Random`
    accepts multiple objects for `-InputObject`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Hint 2: We’re going to want a way of processing each string in turn. Remember,
    multiple strings passed into a parameter are an array.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Hint 3: We’re going to want to send each city to a different output.'
  prefs: []
  type: TYPE_NORMAL
- en: Let’s look at how we might improve them using attributes.
  prefs: []
  type: TYPE_NORMAL
- en: Specifying type
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We can limit the possibility of errors by specifying the type of the parameter
    in the same way as we specify the type of a variable, by typing the attribute
    before the variable. In your script, replace the `$City = "London"` line with
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Now, whatever we pass in the `-City` parameter will be cast to a string.
  prefs: []
  type: TYPE_NORMAL
- en: Making parameters mandatory
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We might want our script to require an explicit value for the `–City` parameter
    each time we run it. We could do that by changing the `-City` parameter like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'We’ve added the line `[Parameter(Mandatory = $true)]` before the `$City` parameter.
    Note that there is no comma (`,`) after the attribute. Now we’ve done that, the
    script ignores the default value for the parameter (`"London"`), and it prompts
    for a city:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.4 – Mandatory parameters](img/B17600_08_004.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8.4 – Mandatory parameters
  prefs: []
  type: TYPE_NORMAL
- en: In the figure, we can see that because we didn’t include a value for the `-City`
    parameter, we get prompted. One of the most useful things we can do with a script
    is to make it accept parameter values from the pipeline. Let’s have a look at
    how we can do that.
  prefs: []
  type: TYPE_NORMAL
- en: Taking values from the pipeline
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We covered how parameters can take values from the pipeline in [*Chapter 3*](B17600_03.xhtml#_idTextAnchor049),
    *The PowerShell Pipeline – How to String Cmdlets Together*. In this section, we’re
    going to see how easy it is to make our script accept pipeline values. Remember,
    there are two ways that a parameter can take values from the pipeline: `ByValue`
    and `ByName`. For our script, it would be best if we let the `-City` parameter
    accept pipeline input by value, so let’s do this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'All we’ve done is add the line `[Parameter(ValueFromPipeline)]` to the `Param()`
    block. We can see the difference it makes in the following figure:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.5 – Accepting values from the pipeline](img/B17600_08_005.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8.5 – Accepting values from the pipeline
  prefs: []
  type: TYPE_NORMAL
- en: In the first example, we can see that we’ve created a string, `"cwmbran"`, and
    tried to pass it through the pipeline to the script. The script doesn’t accept
    values from the pipeline, and we get an error message in red telling us just that.
    If we then alter the `-City` parameter to accept values from the pipeline, we
    can see the script completing without error in the second example.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s see what happens if we try feeding two values into the script through
    the pipeline, as in this example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'We will only get an output for the last item. To make this work properly, we
    need to include the part of the script we want to repeat for each item in a `process
    {}` block, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.6 – Making pipeline input work properly](img/B17600_08_006.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8.6 – Making pipeline input work properly
  prefs: []
  type: TYPE_NORMAL
- en: 'I’m opening a `process {}` block on line `44`, and then closing it on line
    `61`. I can now feed multiple cities into the pipeline and get an HTML file for
    each of them, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Note that doesn’t mean we can get rid of the `foreach` loop from *Activity 2*
    entirely, though. If we pass multiple cities explicitly using the `-City` parameter,
    we will still need to process them individually with a loop.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are lots of other things we can do with parameters, which are detailed
    in the article here: [https://learn.microsoft.com/en-us/powershell/scripting/lang-spec/chapter-12](https://learn.microsoft.com/en-us/powershell/scripting/lang-spec/chapter-12).'
  prefs: []
  type: TYPE_NORMAL
- en: 'Many of them can be used to validate the parameter input: making sure that
    it is the correct type, or even selecting input from a list of accepted values.'
  prefs: []
  type: TYPE_NORMAL
- en: Switch parameters
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'There’s one last feature of parameters we should talk about before moving on:
    switch parameters. Many of the cmdlets we’ve been using have parameters that act
    as switches; they don’t take a value, they just have to be present to change the
    behavior of the cmdlet. For example, using the `-Full` parameter in `Get-Help`
    changes the amount of help information that is returned. We can do that in our
    script too. Try this – after the `param()` block, add the following lines:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Then on the last line of the `param()` block, add the following line before
    the closing parenthesis. Remember, you will also need to add a comma after the
    previous parameter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'The following figure shows how it looks in my script and shows the output when
    we use our new `-``Joke` parameter:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.7 – Only joking](img/B17600_08_007.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8.7 – Only joking
  prefs: []
  type: TYPE_NORMAL
- en: In line `40`, I’ve added a comma after the parameter, so PowerShell knows there’s
    another parameter coming. I’ve added the new `-Joke` switch parameter in line
    `41`, and then on lines `44`-`46`, I’ve added an `If` statement to tell PowerShell
    what to do if the switch is present. Finally, I’ve used the switch in the terminal
    at the bottom when I called the script, and the script told me the best joke in
    the world. Simple, huh?
  prefs: []
  type: TYPE_NORMAL
- en: Note that when we’re looking at other people’s scripts on the internet, we may
    well see a different construction for switch parameters. Instead of using `If
    ($Joke.IsPresent)`, we will often see `If ($Joke -eq $true)`. While this will
    work, it’s a much older way of doing things and could be confusing. Using the
    `.IsPresent` method of the parameter is the way Microsoft recommends.
  prefs: []
  type: TYPE_NORMAL
- en: We’ll be using parameters a lot as we go through the rest of the book, but for
    now, let’s look at the other main topic of this chapter, providing help in our
    scripts.
  prefs: []
  type: TYPE_NORMAL
- en: Providing help for our script
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Writing scripts is great fun, and we learn new things every time we write one.
    We include the new techniques or shortcuts, finish the script, put it to work,
    and then forget about it. The next time we look at it might be months or even
    years later, by which time we might well have forgotten how it works or why we
    wrote it the way we did. The answer to this is to write comprehensive help for
    the script, explaining how our script works and how to use it. This is even more
    important for scripts that we make available for other people to use.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we’re going to cover four ways of providing help. First, we’re
    going to briefly look at how we can comment our code to help ourselves and others.
    After that, we’ll look at creating comment-based help for use with the `Get-Help`
    cmdlet. Then, we’re going to look at the `Write-Verbose` cmdlet, and how we can
    use it to understand what the script is doing. Finally, we’ll look at how we can
    provide help for mandatory parameters.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s start with commenting our code.
  prefs: []
  type: TYPE_NORMAL
- en: Comments
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We briefly mentioned comments in [*Chapter 5*](B17600_05.xhtml#_idTextAnchor096),
    *PowerShell Control Flow – Conditionals and Loops*. We saw that a single line
    may be turned into a comment by adding a hash at the start (`#`), and we could
    create multiline comments by enclosing a body of text like this: `<# … #>`. However,
    we didn’t really talk about why comments are useful. PowerShell is a scripting
    language – a particularly friendly one, in my opinion. Most of the time, it is
    reasonably obvious to someone who knows the language what a line of code will
    do, but a line of explanation means that we don’t need to parse each line to know
    what was intended. And, of course, what we write doesn’t always do what we intend.
    A comment that records what we want the line to do makes our lives a lot easier
    when we’re digging through four or five hundred lines of code. When the script
    is being adapted by somebody else, comments are invaluable. Have a look at the
    example below:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: The comment line tells us exactly what the slightly unreadable code is hopefully
    going to achieve.
  prefs: []
  type: TYPE_NORMAL
- en: Comment blocks
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Comments are intended to be read in an editor of some sort. To make them easier
    to read, we will want to split a long comment across multiple lines. We could
    use the backtick character (`` ` ``) to escape manual line breaks, but that doesn’t
    really make it easier to read, particularly for some editors and some fonts. It’s
    better to use the blockquote construct, `<#...#>`. Have a look at the following
    figure:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.8 – Comment blocks](img/B17600_08_008.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8.8 – Comment blocks
  prefs: []
  type: TYPE_NORMAL
- en: 'The comment block is in green and explains the intention of the following lines.
    Let’s have a look at some dos and don’ts for writing good comments:'
  prefs: []
  type: TYPE_NORMAL
- en: Comment on a separate line; adding a comment on the same line makes the line
    either too long or causes it to wrap in the editor.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Comment before the line you’re explaining; prepare the reader for what’s coming
    next in the script, not what’s been.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Don’t comment on the obvious; generally speaking, too many comments are better
    than too few but don’t waste your time explaining things that don’t need it. Better
    to comment what a block of simple lines does than each individual line.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let’s look at how we can provide help for our script with the `Get-Help` cmdlet.
  prefs: []
  type: TYPE_NORMAL
- en: Comment-based help
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `Get-Help` cmdlet reads XML help files included with the main PowerShell
    program, and for modules and functions that have them. However, it can also read
    correctly formatted comments embedded in a script. This is called **comment-based
    help**. We can write comment-based help by adding special help comment keywords
    at the start of our script.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are a number of rules to remember about writing comment-based help:'
  prefs: []
  type: TYPE_NORMAL
- en: It must be either at the start or the end of a script. For a couple of reasons,
    including the best practices for comments we covered previously, we should put
    it at the start.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Comment-based help must be contiguous. We can’t split it up into different comment
    blocks.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Each section of the help must start with a legitimate keyword. The keyword is
    not case-sensitive, but it must be preceded by a dot (`.`).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There must be two blank lines after the comment-based help.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Luckily, VS Code makes writing comment-based help a breeze. Let’s see it working.
  prefs: []
  type: TYPE_NORMAL
- en: In our script, create a new line at the start of the script, and type `comm`.
    As we can see in the following figure, VS Code will offer us the `comment-help`
    function helper if we have the PowerShell extension installed.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.9 – The comment-help function in VS Code](img/B17600_08_009.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8.9 – The comment-help function in VS Code
  prefs: []
  type: TYPE_NORMAL
- en: Go ahead and select it. VS Code will create a comment-based help template for
    us with the most commonly used keywords, correctly formatted, and even add the
    two blank lines after the block for us.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s have a look at the common sections:'
  prefs: []
  type: TYPE_NORMAL
- en: '`.SYNOPSIS`: This section should be one line that summarizes what the script
    does.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`.DESCRIPTION`: This is where we put the full description, including how it
    works, what it should be used for, different ways to use it, and so on.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`.NOTES`: This is where we should put warnings about incompatibilities, prerequisites
    for running the script (for instance, that we need to have a `weatherapi` key
    saved to a text file), and any other useful information that doesn’t fit in the
    description.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`.LINK`: This will provide a link for `Get-Help -Online` to consume. Personally,
    I never use it and delete it from the help section.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`.EXAMPLE`: We can put examples of usage here to explain how to use the parameters.
    Separate each example with a new `.EXAMPLE` keyword on a new line.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'I’ll admit, the first time I did this, it was a real thrill seeing my script
    help looking like the real thing. It doesn’t get old:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.10 – Retrieving comment-based help for a script](img/B17600_08_010.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8.10 – Retrieving comment-based help for a script
  prefs: []
  type: TYPE_NORMAL
- en: This works just like anything else with `Get-Help`. To see the notes, type `Get-Help
    .\weatherdata.ps1 -Detailed`. To get everything, use the `-``Full` parameter.
  prefs: []
  type: TYPE_NORMAL
- en: Activity 3
  prefs: []
  type: TYPE_NORMAL
- en: Write a short comment-based help for the script. Test it by calling `Get-Help
    .\weatherdata.ps1` from the console.
  prefs: []
  type: TYPE_NORMAL
- en: 'That’s it for comment-based help. It’s incredibly useful, whether we read it
    in the editor or using the `Get-Help` cmdlet. I recommend we use it as often as
    we can. Let’s look at something else now, that isn’t strictly help, but is definitely
    helpful: the `Write-Verbose` cmdlet.'
  prefs: []
  type: TYPE_NORMAL
- en: Write-Verbose
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Back in [*Chapter 3*](B17600_03.xhtml#_idTextAnchor049), *The PowerShell Pipeline
    – How to String Cmdlets Together*, we talked briefly about the standard streams:
    output streams that exist in most programming languages and classify and direct
    output. The verbose stream is one of them and is intended for messages that help
    users understand what a cmdlet is doing. It’s particularly useful for troubleshooting
    long-running cmdlets that don’t appear to be doing anything. Every PowerShell
    cmdlet has a `-Verbose` switch parameter that allows us to see what the cmdlet
    is doing and whether it’s got stuck, although not all of them produce a verbose
    stream output. We can see this in action already in our script because the `Invoke-RestMethod`
    cmdlet has a particularly useful verbose output. Try this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'You should see something like the following figure:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.11 – Verbose output from inside our script](img/B17600_08_011.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8.11 – Verbose output from inside our script
  prefs: []
  type: TYPE_NORMAL
- en: We’re able to access this verbose output because we have used the `CmdletBinding()`
    attribute at the start of the script, which gives us access to advanced functions.
    Without it, we can call the `-Verbose` parameter without an error, but it won’t
    produce any output.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can do even more than this, though; we can write our own verbose stream
    messages with the `Write-Verbose` cmdlet. Why is this useful? Because when we
    are processing many items in a loop in our script, it can tell us which item in
    the loop is failing. Let’s say we ask our script to produce the data for three
    cities as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we’ll get an error saying that when `Invoke-RestMethod` ran, a matching
    location couldn’t be found, but the line of code that threw the error is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: So it could be any of the cities that doesn’t exist.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can fix this by changing the start of the `foreach` loop:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'We’ve added the line `Write-Verbose "Processing $Item"` at the start of the
    loop, which means that if we use the `-Verbose` parameter now, the script tells
    us which city it’s processing, and we can see which of our cities is fictitious,
    as in the following figure:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.12 – Using Write-Verbose to illuminate the Bible-black](img/B17600_08_012.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8.12 – Using Write-Verbose to illuminate the Bible-black
  prefs: []
  type: TYPE_NORMAL
- en: 'When we run the script in the first line, all we see is the error, but when
    we run it with the `-Verbose` parameter, it tells us which city it was processing
    when it encountered the error. Let’s look at the final type of help we’ll cover
    in this chapter: parameter help messages.'
  prefs: []
  type: TYPE_NORMAL
- en: Parameter help messages
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'As well as controlling how parameters work in a script, we can also write helpful
    comments to guide people in using parameters in our scripts. These comments only
    apply to mandatory comments and are available if the mandatory parameter isn’t
    provided. Let’s try it. Edit the `$City` parameter like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, when we run it without supplying a value for the `$City` parameter, we
    get a message suggesting we type an interrobang (`!?`) for help:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.13 – Accessing the HelpMessage parameter](img/B17600_08_013.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8.13 – Accessing the HelpMessage parameter
  prefs: []
  type: TYPE_NORMAL
- en: Once we type the interrobang, the message we wrote in the script is presented.
    It’s as easy as that; just remember that we can only use parameter help messages
    with mandatory parameters.
  prefs: []
  type: TYPE_NORMAL
- en: That about wraps it up for this chapter. Let’s review what we’ve learned.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we’ve moved on from learning the building blocks of PowerShell
    syntax, and now we’re beginning to put things together. The techniques we’ve learned
    may not be familiar to us, but with time and practice, they will become familiar
    and easy. As we go through the rest of the book, we will have plenty of opportunities
    to use them.
  prefs: []
  type: TYPE_NORMAL
- en: We started by talking about what scripts are and why we might want to write
    scripts at all. We looked briefly at where we can find other people’s scripts,
    and what we need to do to run them on our machines.
  prefs: []
  type: TYPE_NORMAL
- en: We’ve done a lot of practical work in this chapter. Firstly, we looked at how
    we might make it easier for people to read what we’re doing by breaking long pipelines
    up and substituting variables for hardcoded values in cmdlets, particularly values
    that might change.
  prefs: []
  type: TYPE_NORMAL
- en: We moved on to look at how we could pass those values into the script from outside
    using parameters, and we looked at various ways we could define and manipulate
    those parameters by making them mandatory or taking values from the pipeline.
  prefs: []
  type: TYPE_NORMAL
- en: We then looked at how we could make our scripts more easily understood by providing
    comments, before creating full-blown comment-based help for them, so that we can
    use the `Get-Help` cmdlet.
  prefs: []
  type: TYPE_NORMAL
- en: After that, we looked at using the `Write-Verbose` cmdlet to provide verbose
    output. This helps us understand what our script is doing when it doesn’t seem
    to be working as we hoped.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we looked at providing help messages for mandatory parameters to make
    it easier for people to run our scripts.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we’re going to look at how we can make our code simpler
    and easier to write using script blocks, lambdas, and functions.
  prefs: []
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Output streams: https://learn.microsoft.com/en-us/powershell/module/microsoft.powershell.core/about/about_output_streams'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Some automation theory: https://poshidiot.wordpress.com/2018/06/12/how-do-i-know-what-to-automate/'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*The Practice of Cloud System Administration*, Limoncelli, T., Hogan, C., and
    Chalup, S. (2017) Boston: Addison-Wesley, [*Chapter 12*](B17600_12.xhtml#_idTextAnchor236).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Time Management for System Administrators*, Sebastopol: Limoncelli, T. (2008),
    O’Reilly Media, Inc., [*Chapter 13*](B17600_13.xhtml#_idTextAnchor267).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Why the Fitts list has persisted throughout the history of function allocation*:
    de Winter, J. C. F., and Dodou, D. (2014), Journal of Cognition, Technology &
    Work'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Learn more about attributes and parameters: https://learn.microsoft.com/en-us/powershell/scripting/lang-spec/chapter-12'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Exercises
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: On attempting to run a script we’ve written, another user on our machine gets
    an error message that says `running scripts is disabled on this system`. What
    do we have to do to allow them to run the script?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'We have a young relative who loves *Dungeons and Dragons*, but they’ve lost
    their 20-sided die. We write a short PowerShell script for them, `Get-Die.ps1`,
    as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This will produce a random number between 1 and 20 every time it is run. Which
    value in this line of code is most likely to change if they lose another die with
    a different number of sides?
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: In the `Get-Die.ps1` script from the previous question, how would we parameterize
    the changing value?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What type of parameter should it be, and how would we specify it?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: They like the script, and now they’ve lost their four-sided die. They’ve discovered
    that they can put any number they like into the parameter. While this was quite
    cool at first, now they want the script to only let them roll the dice that are
    used in the game. How could we do that? We need to know that *Dungeons and Dragons*
    uses 4-, 6-, 8-, 10-, 12-, and 20-sided dice, and we’ll also need to read the
    link about parameters given in the text.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Our relative explains that sometimes they need to roll more than one die of
    the same type at a time and asks whether there is a way to do this. Well, of course
    there is… let’s write it for them.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: They’ve noticed that sometimes they forget to put the number of dice in, and
    they get a total of 0\. How could we stop that from happening?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We’re not always going to be around, and sometimes they aren’t sure what to
    put in the parameters. How could we make it easier for them?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'They are really trying our patience. Every now and then, they need to roll
    something they call a d100\. This is a 10-sided die, with numbers going up in
    tens: 0, 10, 20, 30, and so on, plus a roll of a normal 10-sided die, which added
    together gives them a number between 1 and 100\. Promising ourselves we’ll never
    babysit for them again, how do we do that?'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
