- en: '*Chapter 1*: Understanding the Need for systemd'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this first chapter, we''ll first briefly look at the history of Linux `init`
    systems. We''ll then look at the shortcomings of the legacy `init` systems and
    why certain Linux engineers felt the need to develop a new type of `init` system.
    Finally, we''ll look at the controversy that has surrounded `systemd`. For easy
    reference, here''s a list of the topics:'
  prefs: []
  type: TYPE_NORMAL
- en: The history of Linux `init` systems
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The shortcomings of SysV `init` and upstart
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The advantages of `systemd`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `systemd` controversy
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: So, with the introductory comments out of the way, let's jump in.
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For this chapter, all you need is a Linux virtual machine that runs `systemd`.
    As you read through this chapter, you might want to look at some of the files
    on the virtual machine.
  prefs: []
  type: TYPE_NORMAL
- en: The history of Linux init systems
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So, what is an `init` system? Well, `init` is short for *initialization*. An
    `init` system, then, initializes the operating system upon bootup. After the bootup
    has completed, the `init` system will continue working, managing system processes
    and services. Each system process is assigned a process ID number, or *PID*. The
    `init` process is always PID 1, and every other process that gets started on the
    system is either a child or a grandchild of the `init` process.
  prefs: []
  type: TYPE_NORMAL
- en: For many years, the `init` system for Linux-based operating systems (SysV is
    short for *System 5*. The *V* is the Roman numeral for 5). SysV `init` was originally
    developed by Bell Labs engineers for the Unix operating system, all the way back
    in the early 1970s. (At that time, I was a young pup in junior high school, and
    I still had a full head of hair.)
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: There are actually a few more Linux `init` systems besides the ones that I'm
    mentioning here. But these were the most commonly used ones in the pre-`systemd`
    days.
  prefs: []
  type: TYPE_NORMAL
- en: SysV `init` worked well in its day, but it was never perfect. Nowadays, with
    new high-performance hardware, SysV `init` has shown both its age and its deficiencies.
    The first attempt to come up with something better occurred in July 2009, when
    Ubuntu engineers released the first version of the `init` system. Although it
    was better than SysV, it still had its share of problems, especially the early
    versions which were quite buggy.
  prefs: []
  type: TYPE_NORMAL
- en: The shortcomings of SysV Init and upstart
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The first problem with SysV is that of its rather lengthy boot-up times. When
    you boot up a SysV machine, all of its services have to start up in sequential
    order. That might not be so bad on a normal desktop machine, but it can be a bit
    problematic on a server that needs to run lots of services. In that case, each
    service would have to wait its turn to start, which could take a while.
  prefs: []
  type: TYPE_NORMAL
- en: 'The next problem with SysV is its complexity. Instead of simple, easy-to-understand
    configuration files, SysV does everything with complex Bash shell scripts. The
    `init` scripts that control system services all have to be assigned a priority
    number, so that services will start and stop in the proper order. Take, for example,
    the `init` script that starts the Apache web server on a CentOS 5 machine. First,
    we can see that it''s a fairly lengthy script, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'You can see from the `wc -l` output that it consists of 131 lines. As you can
    see here, 37 of those lines are comments, which still leaves us with 94 lines
    of actual code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Look inside, and you''ll see that it''s quite complex and convoluted. Here''s
    just the first part of it:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/Figure_1.1_B17491.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 1.1 – An old-fashioned SysV Init script
  prefs: []
  type: TYPE_NORMAL
- en: 'Toward the end of the script, you''ll see the code that stops, starts, restarts,
    and reloads the Apache daemon, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/Figure_1.2_B17491.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 1.2 – The start, stop, restart, reload section of an init script
  prefs: []
  type: TYPE_NORMAL
- en: This code, or code similar to this, has to be in every `init` script so that
    the human user can control the daemon. To complicate things even more, developers
    didn't always write this code consistently for different programs. So, for example,
    a status display for one daemon didn't always look the same as the status display
    for another daemon.
  prefs: []
  type: TYPE_NORMAL
- en: Then, there's the problem of inconsistent implementation across the different
    families of Linux distros. With SysV, there were at least three different methods
    of implementation. Red Hat-type distros used one method, Debian-type distros used
    another method, and Slackware-type distros use yet another. For example, the Red
    Hat way of controlling services required using the `service` and `chkconfig` commands.
    When working with Debian-type systems, I always used to have to look up the service
    management commands, because I could never remember them. With Slackware, you
    don't have any service management commands. To enable or disable a service on
    a Slackware machine, you just set or remove the executable permission from the
    appropriate `init` script.
  prefs: []
  type: TYPE_NORMAL
- en: 'Runlevels were also a source of confusion, because each family of distro had
    its own set of runlevel definitions. For example, here are the definitions for
    the graphical runlevel:'
  prefs: []
  type: TYPE_NORMAL
- en: The Red Hat family used runlevel 5.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Slackware family uses runlevel 4.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Debian family used no specific runlevel for either text mode or graphical
    mode. Instead, you enabled or disabled graphical mode by enabling or disabling
    the X server daemon.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: So, you can see that this was all quite confusing, especially for anyone who
    worked in a mixed environment. It should be fairly obvious that we needed something
    that was a bit less confusing.
  prefs: []
  type: TYPE_NORMAL
- en: As if this weren't enough, there was also the issue of performance. SysV worked
    well in its day, when computing hardware was more primitive. But, on modern hardware
    with multiple CPUs that each have multiple cores, we need something a bit more
    robust. Ubuntu's upstart was supposed to fix this, but it didn't quite live up
    to its promise. Nowadays, Upstart is completely dead, but there are still some
    diehards who refuse to give up SysV. In the enterprise, `systemd` is king.
  prefs: []
  type: TYPE_NORMAL
- en: The advantages of systemd
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We've just seen the problems with SysV and upstart. Now, let's look at what
    makes `systemd` better.
  prefs: []
  type: TYPE_NORMAL
- en: systemd's simplicity
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In contrast to SysV, `systemd` is really quite simple to configure. For example,
    look at how short the Apache service file is on a CentOS 7 machine with `systemd`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'There are only 22 lines, and 5 of those lines are comments, as you can see
    here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/Figure_1.3_B17491.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 1.3 – A systemd service file
  prefs: []
  type: TYPE_NORMAL
- en: I'll explain everything in the `systemd` files later. For now, I just want to
    show you that a `systemd` service file is much simpler than a SysV `init` script.
    (As we'll soon see in the upcoming chapters, it's easier to learn how to use the
    `systemd` directives than it is to learn how to write shell-scripting code for
    `init` scripts.)
  prefs: []
  type: TYPE_NORMAL
- en: systemd's consistency
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The next `systemd` advantage is its consistency. Yes, boys and girls, you no
    longer have to remember multiple sets of system management commands for multiple
    families of Linux distros. Instead, you'll now use the same commands on all Linux
    distros that use `systemd`. So, this eliminates a major source of frustration
    for administrators, and for anyone who's studying to take a Linux certification
    exam.
  prefs: []
  type: TYPE_NORMAL
- en: systemd's performance
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In contrast to SysV, `systemd` can start services in parallel, rather than just
    one at a time in sequence. This makes for much quicker boot-up times than for
    SysV. Once the machine is booted, performance is more robust than that of SysV.
  prefs: []
  type: TYPE_NORMAL
- en: With `systemd`, we have a much cleaner way of killing processes. For example,
    if you needed to use the `kill` command to forcefully terminate the Apache web
    server service on a SysV machine, you would only terminate the Apache process
    itself. If the web server process had spawned any child processes due to running
    CGI scripts, for example, those processes would continue on for a while longer
    as *zombie* processes. But, when you kill a service with `systemd`, all processes
    that are associated with that service will also get terminated.
  prefs: []
  type: TYPE_NORMAL
- en: systemd security
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'An added bonus is that you can configure `systemd` service files to control
    certain aspects of system security. Here are some of the things that you can do:'
  prefs: []
  type: TYPE_NORMAL
- en: You can create a `systemd` service that can restrict access to or from certain
    directories, or that can only access or be accessed from certain network addresses.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By using namespaces, you can effectively isolate services from the rest of the
    system. This also allows you to create containers without having to run Docker.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can use `cgroups` to limit resource usage. This can help prevent certain
    types of denial-of-service attacks.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can specify which root-level kernel capabilities a service is allowed to
    have.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: With all this, you can make `systemd` somewhat emulate a mandatory access control
    system, such as SELinux or AppArmor.
  prefs: []
  type: TYPE_NORMAL
- en: All the way around, `systemd` is much better than any `init` system that came
    before it. But it hasn't made everyone happy.
  prefs: []
  type: TYPE_NORMAL
- en: The systemd controversy
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If you've been in the computer world for any length of time, you may have seen
    that we geeks can get quite passionate about our operating systems. In the early
    1990s, I finally replaced my text mode-only 8088 machine with one that could run
    a graphical interface. I first gave Windows 3.1 a try, and quickly decided that
    I really hated it. So, I bought a copy of OS/2, which I liked much better and
    ran for quite a few years on my home-built 486 machine. But, all of my geek buddies
    at work were big Windows fans, and they kept arguing with me about how much better
    Windows is. I thought that they were all crazy, and we kept getting into some
    rather heated arguments.
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, when I got into Linux, I quickly learned that you don''t want to go into
    any Linux forum and ask which Linux distro is the best for a newbie to start with.
    All that does is start fights, leaving the poor newbie more confused than ever.
    And now, the fight is over whether or not `systemd` is a *good thing*. Here are
    some of the objections:'
  prefs: []
  type: TYPE_NORMAL
- en: By trying to do too much, `systemd` violates the Unix concept of having each
    utility just do one thing but having it do it well.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It's controlled by a large corporation (Red Hat).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It's a security problem.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Its `journald` component saves system logs to a binary format, which some people
    believe is more easily corrupted than the plain-text files that `rsyslog` creates.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'If you look at things objectively, you might see that the objections aren''t
    so bad:'
  prefs: []
  type: TYPE_NORMAL
- en: Yes, the `systemd` ecosystem includes more than just the `init` system. It also
    includes network, bootloader, logging, and log-in components. But those components
    are all optional, and not all Linux distros use them in a default setup.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It was created primarily by Red Hat, and the project leader is a Red Hat employee.
    But Red Hat released it under a free-as-in-speech software license, which means
    that no one company can ever take full control of it. Even if Red Hat were to
    suddenly decide that future versions of `systemd` were to be proprietary, the
    free code is still out there, and someone would fork it into a new free version.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Yes, there have been some security bugs in `systemd`. But that's also true of
    OpenSSL, the Bash shell, and even the Linux kernel itself. To complain about `systemd's`
    security would only be valid if the bugs hadn't gotten fixed.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `journald` component does create log files in a binary format. But it's
    still possible to run `rsyslog` on `systemd` distros, and most do. Some distros,
    such as the Red Hat Enterprise Linux 8 family, use `journald` to gather system
    information and then just have `journald` pass the information to `rsyslog` in
    order to create normal text files. So, with RHEL 8, we have the best of both worlds.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Soon after the release of `systemd`, some people who had never even tried it
    put up blog posts that explained why `systemd` was pure evil and that they would
    never use it. A few years ago, I created a `systemd` tutorial playlist on my BeginLinux
    Guru channel on YouTube. The first video is called *Why systemd?*. Quite a few
    people left comments about why they would never use `systemd` and said that they
    would change to either a non-`systemd` Linux distro or to a FreeBSD-type distro
    in order to avoid it.
  prefs: []
  type: TYPE_NORMAL
- en: 'The bottom line is this: all enterprise-grade Linux distros now use `systemd`.
    So, I think that it might be here to stay.'
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this first chapter, we've looked at the history of the most common Linux
    init systems. We've seen the ways in which the legacy init systems are deficient,
    and we've seen why `systemd` is a much better replacement. We wrapped things up
    by looking at the objections against `systemd`.
  prefs: []
  type: TYPE_NORMAL
- en: One of the challenges of learning `systemd` is that, until now, there hasn't
    been any real comprehensive documentation about it. There's basic usage documentation
    on the Red Hat website, but it doesn't even cover all components of the `systemd`
    ecosystem. There are only two `systemd`-specific books that I could find, which
    are a few years old. (One book is specific to Fedora, the other is specific to
    Ubuntu.) Even those books leave some things out. So, the challenge I've set for
    myself is to create a comprehensive, hands-on guide for all things `systemd`.
    In the chapters that follow, I'll do my best to accomplish that goal.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we'll go on a quick tour of the `systemd` directories and
    files. I'll see you there.
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Who created the original SysV `init` system?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: a. Bell Labs
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: b. Red Hat
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: c. Debian
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: d. Ubuntu
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Which of the following is true about SysV?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: a. It's a modern, robust `init` system.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: b. When booting a machine, it can start services in parallel.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: c. When booting a machine, it can only start services sequentially.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: d. It has security features that `systemd` doesn't have.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Which of the following is *not* true about `systemd`?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: a. It has security features that can somewhat emulate a mandatory access control
    system.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: b. It can start services in parallel.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: c. It can use `cgroups` to limit resource usage.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: d. It's a legacy system that needs to be replaced.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Answers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: C
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: D
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'An overview of Linux `init` systems:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://www.tecmint.com/best-linux-init-systems/](https://www.tecmint.com/best-linux-init-systems/)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Why `init` needed to be replaced with `systemd`:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://www.tecmint.com/systemd-replaces-init-in-linux/](https://www.tecmint.com/systemd-replaces-init-in-linux/)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Red Hat''s `systemd` documentation:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://access.redhat.com/documentation/en-us/red_hat_enterprise_linux/8/html/configuring_basic_system_settings/index](https://access.redhat.com/documentation/en-us/red_hat_enterprise_linux/8/html/configuring_basic_system_settings/index)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Some arguments against `systemd`:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://textplain.net/blog/2015/problems-with-systemd-and-why-i-like-bsd-init/](https://textplain.net/blog/2015/problems-with-systemd-and-why-i-like-bsd-init/)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[https://www.theregister.com/2014/10/21/unix_greybeards_threaten_debian_fork_over_systemd_plan/](https://www.theregister.com/2014/10/21/unix_greybeards_threaten_debian_fork_over_systemd_plan/)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
