- en: '16'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '16'
- en: Working with PowerShell and .NET
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 PowerShell 和 .NET
- en: Here we are then, the last chapter. We’re going to look at the product that
    PowerShell 7 is built on, .NET, and how we can use it to expand the range of things
    we can do in PowerShell. Note that this chapter can’t be anything more than a
    whistlestop tour; .NET is a huge subject, and there are many, many more books
    written for it than there are for PowerShell. PowerShell is just one application
    written on .NET, and it only touches a subset of the things that we can do with
    .NET. That being said, let’s have a look at how it works and some of the exciting
    things we can use it for.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们来到了最后一章。我们将探讨 PowerShell 7 所依赖的产品——.NET，以及如何利用它扩展我们在 PowerShell 中能做的事情。需要注意的是，这一章只能提供一个简短的概览；.NET
    是一个庞大的主题，关于它的书籍远远多于关于 PowerShell 的书籍。PowerShell 只是一个基于 .NET 编写的应用程序，它仅触及了我们在 .NET
    中可以做的一部分事情。话虽如此，还是让我们来看看它的工作原理，以及我们可以用它做一些什么令人兴奋的事情。
- en: 'The main topics we will cover in this chapter are as follows:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖的主要内容如下：
- en: Exploring .NET
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 探索 .NET
- en: The components of .NET
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: .NET 的组件
- en: Working with .NET in PowerShell
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 PowerShell 中使用 .NET
- en: Using .NET
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 .NET
- en: Exploring .NET
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 探索 .NET
- en: '**.NET** (**dot-net**) is a software framework. It’s free and open source and
    can be used to write web applications, command-line applications, and applications
    that run in a **Graphical User Interface** (**GUI**). It is based on the proprietary
    coded .NET Framework, which is the software framework that the Windows operating
    system uses. It can be used with a range of programming languages, including C#,
    F#, and Visual Basic .NET. Let’s unpack all that, shall we?'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: '**.NET**（**dot-net**）是一个软件框架。它是免费的、开源的，可以用来编写 Web 应用程序、命令行应用程序和运行在 **图形用户界面**
    (**GUI**) 下的应用程序。它基于专有的 .NET 框架，这个框架是 Windows 操作系统所使用的。它可以与多种编程语言一起使用，包括 C#、F#
    和 Visual Basic .NET。让我们来详细了解一下吧？'
- en: Software frameworks explained
  id: totrans-10
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 软件框架解释
- en: A software framework is a tool for constructing applications. Some frameworks
    are written for specific purposes and specific languages; AngularJS is a framework
    for developing the frontends of web applications in JavaScript. PhaserJS is a
    game development framework, again for JavaScript. While frameworks contain many
    libraries, they differ from libraries in that libraries provide tools for our
    code that we can use in any way we like; with a framework, we need to work within
    the structure. The basics of an application are provided; we need to provide the
    specifics.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 软件框架是构建应用程序的工具。一些框架是为特定目的和特定语言编写的；AngularJS 是一个用于开发 JavaScript Web 应用程序前端的框架。PhaserJS
    是一个游戏开发框架，同样适用于 JavaScript。虽然框架包含了许多类库，但与类库不同，框架需要在其结构内工作。类库为我们的代码提供工具，可以随意使用；而框架则规定了应用程序的基本结构，我们需要在此基础上提供具体的实现。
- en: .NET implements a **Common Language Infrastructure** (**CLI**) that allows different
    high-level languages (such as C#) to be used on multiple operating system platforms,
    without needing to be rewritten for each architecture; this is how PowerShell
    7 can work on Intel and ARM processors. By installing the correct version of .NET,
    our PowerShell code can then run anywhere.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: .NET 实现了 **公共语言基础设施** (**CLI**)，允许不同的高级语言（如 C#）在多个操作系统平台上使用，而无需为每个架构重写代码；这就是
    PowerShell 7 如何能够在 Intel 和 ARM 处理器上运行的原因。通过安装正确版本的 .NET，我们的 PowerShell 代码就能在任何地方运行。
- en: A .NET component called **CoreFX** houses the .NET libraries of classes, interfaces,
    and value types in a **Framework Class Library**. .NET provides more than just
    libraries, though. .NET applications run in a virtual machine called **CoreCLR**,
    in the same way that Java applications run inside the Java Virtual Machine.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 一个名为 **CoreFX** 的 .NET 组件包含了 .NET 类库、接口和值类型，组成了 **框架类库**。不过，.NET 提供的不仅仅是类库。
    .NET 应用程序在一个名为 **CoreCLR** 的虚拟机中运行，就像 Java 应用程序在 Java 虚拟机中运行一样。
- en: Common language infrastructure
  id: totrans-14
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 公共语言基础设施
- en: 'The CLI is an open technical standard developed by Microsoft and is largely
    only found in variations of .NET, although there is an open development platform
    called **Mono** that uses it as well. The CLI specifies five things:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: CLI 是由微软开发的开放技术标准，主要只存在于 .NET 的不同变种中，尽管也有一个叫做 **Mono** 的开放开发平台也使用它。CLI 定义了五个要素：
- en: '**Common Type System (CTS)** – the set of types that can be accessed by programming
    languages using the framework.'
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**公共类型系统（CTS）** – 可由编程语言通过框架访问的类型集合。'
- en: '**Metadata**, which is used to describe the program structure.'
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**元数据**，用于描述程序结构。'
- en: '**Common Language Specification (CLS)** – rules for using the framework.'
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**公共语言规范（CLS）** – 使用框架的规则。'
- en: '**Virtual Execution System (VES)** – this loads and executes applications.
    It uses metadata to run code generated in compliant languages at runtime, compiling
    them into a platform-agnostic **Common Intermediate Language** (**CIL**), which
    is then compiled to a platform-specific machine language in real time. In .NET,
    the VES is implemented in the CoreCLR component.'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**虚拟执行系统（VES）** – 它加载并执行应用程序。它使用元数据在运行时执行用兼容语言生成的代码，并将其编译成平台无关的 **公共中间语言（CIL）**，然后将其即时编译为平台特定的机器语言。在
    .NET 中，VES 是通过 CoreCLR 组件实现的。'
- en: '**Standard libraries**, which provide common functions, such as accessing networks
    and files.'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**标准库**，提供常用功能，如访问网络和文件。'
- en: Let’s look at the CoreCLR component.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看一下 CoreCLR 组件。
- en: Common language runtime – CoreCLR
  id: totrans-22
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 公共语言运行时 – CoreCLR
- en: CoreCLR provides a common language runtime, which is a layer that sits between
    the application and the operating system. It is similar in principle to the PowerShell
    program; .NET applications need .NET to be running on the machine to interpret
    the application code as machine code. This means PowerShell needs .NET to be running,
    as PowerShell is a .NET application.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: CoreCLR 提供了一个公共语言运行时，这是一个位于应用程序和操作系统之间的层。它的原理类似于 PowerShell 程序；.NET 应用程序需要在机器上运行
    .NET 才能将应用程序代码解释为机器代码。这意味着 PowerShell 需要 .NET 运行，因为 PowerShell 本身是一个 .NET 应用程序。
- en: However, CoreCLR doesn’t just provide a runtime. It also includes additional
    services such as memory management (allocating portions of virtual memory to applications),
    garbage collection (recovering unused memory that is no longer needed), and thread
    management. This means that when we use .NET to write applications, we don’t need
    to worry about memory leaks or memory addressing errors, as all that is handled
    for us by CoreCLR.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，CoreCLR 不仅仅提供运行时。它还包括额外的服务，如内存管理（为应用程序分配虚拟内存的一部分）、垃圾回收（回收不再需要的未使用内存）和线程管理。这意味着，当我们使用
    .NET 编写应用程序时，我们无需担心内存泄漏或内存寻址错误，因为这些都由 CoreCLR 为我们处理。
- en: Happily, we don’t need to know much about how CoreCLR works to use .NET with
    PowerShell. Most of what we are interested in is held in the libraries – CoreFX.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，我们不需要知道 CoreCLR 是如何工作的，就能在 PowerShell 中使用 .NET。我们感兴趣的大部分内容都在库中 – CoreFX。
- en: Framework Class Library – CoreFX
  id: totrans-26
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 框架类库 – CoreFX
- en: 'CoreFX contains the class libraries that .NET uses, which include types, functions,
    and classes. All the PowerShell data types, for instance, are a subset of the
    available .NET types. We’ve seen this already; in [*Chapter 4*](B17600_04.xhtml#_idTextAnchor071),
    *PowerShell Variables and Data Structures*, we saw that changing the contents
    of a PowerShell array was resource-intensive because each time we change an array,
    we create a new one and delete the old one. We saw that one of the solutions to
    this was to use a .NET type that is not available natively inside PowerShell,
    `ArrayList`, like this:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: CoreFX 包含了 .NET 使用的类库，其中包括类型、函数和类。例如，所有 PowerShell 数据类型都是可用 .NET 类型的一个子集。我们已经看到这一点；在
    [*第 4 章*](B17600_04.xhtml#_idTextAnchor071)《PowerShell 变量与数据结构》中，我们看到改变 PowerShell
    数组内容是资源密集型的，因为每次改变数组时，我们会创建一个新数组并删除旧数组。我们看到，解决这个问题的方法之一是使用一个在 PowerShell 中原生不可用的
    .NET 类型 `ArrayList`，就像这样：
- en: '[PRE0]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: We use the `[System.Collections.ArrayList]` full .NET type to set the array
    as `ArrayList`. Sometimes, working with .NET really is that easy.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用 `[System.Collections.ArrayList]` 完整的 .NET 类型来将数组设置为 `ArrayList`。有时候，使用
    .NET 确实是这么简单。
- en: .NET history
  id: totrans-30
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: .NET 历史
- en: .NET Framework was first released in 2002 and was intended to create Windows
    applications. It introduced the Microsoft concept of **managed code**, code that
    would only interact with the CLI. Managed code could be more tightly controlled,
    both in terms of resource use and security, and it was also less prone to causing
    system crashes – the dreaded Blue Screen of Death – because it only touched the
    CLR, not the underlying operating system. In time, many of Microsoft’s most popular
    applications, such as Microsoft Exchange Server, were written in managed code
    and required .NET Framework to run. .NET Framework will only run on Windows and
    contains many Windows-specific features.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: .NET Framework首次发布于2002年，旨在创建Windows应用程序。它引入了微软的**托管代码**概念，即只与CLI交互的代码。托管代码可以更严格地控制资源使用和安全性，并且由于只接触CLR而不是底层操作系统，它也不太容易导致系统崩溃（蓝屏），这就是其特点之一。随着时间推移，微软的许多最受欢迎的应用程序，如Microsoft
    Exchange Server，都是用托管代码编写的，需要.NET Framework来运行。.NET Framework仅能在Windows上运行，并包含许多Windows特定的功能。
- en: In 2014, Microsoft released .NET Core, an open source, cross-platform implementation
    of the CLI. This shared many features of .NET Framework but not all of them, and
    similarly, it contained many features that were not implemented in .NET Framework,
    notably the ability to run on different operating systems. In 2022, Microsoft
    released a new version of .NET Core, simply called .NET 5; the intention was that
    .NET would eventually overtake .NET Framework. As happened with PowerShell and
    Windows PowerShell, in practice, both versions now exist side by side. The latest
    release of .NET Framework, at the time of writing, is version 4.8.1 in August
    2022, whereas .NET is released annually, around November; the latest version is
    .NET 8.0, released in November 2023.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 在2014年，微软发布了.NET Core，这是一个开源的、跨平台实现CLI的项目。它与.NET Framework共享许多特性，但并非全部，并且它还包含了许多.NET
    Framework中没有实现的功能，特别是在不同操作系统上运行的能力。2022年，微软发布了一个新版本的.NET Core，简称.NET 5；其意图是最终取代.NET
    Framework。就像PowerShell和Windows PowerShell一样，实际上，两个版本现在并存。截至撰写本文时，最新的.NET Framework版本是2022年8月发布的4.8.1版本，而.NET每年发布一次，大约在11月左右；最新版本是2023年11月发布的.NET
    8.0版本。
- en: So, what can we use .NET for? Let’s take a look.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，我们可以用.NET做什么呢？让我们来看看。
- en: The uses of .NET
  id: totrans-34
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: .NET的用途
- en: .NET Framework was developed to create Windows applications – while we can use
    it for command-line programs, it includes the **Windows Presentation Foundation**
    (**WPF**) framework, ASP.NET (for internet applications), and Windows Forms for
    graphical applications.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: .NET Framework是为创建Windows应用程序而开发的——尽管我们可以将其用于命令行程序，它包括**Windows Presentation
    Foundation**（**WPF**）框架、用于Internet应用程序的ASP.NET以及用于图形应用程序的Windows Forms。
- en: The current iteration of .NET includes libraries for cloud-native applications
    and serverless functions on Azure, cross-platform desktop applications and games,
    mobile apps using .NET **Multi Application User Interface** (**MAUI**), machine
    learning applications with ML.NET, and Internet of Things applications with .NET
    IoT.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 当前的.NET版本包括云原生应用程序和Azure上的无服务器函数的库、跨平台桌面应用程序和游戏、使用.NET **Multi Application User
    Interface**（**MAUI**）的移动应用程序、带有ML.NET的机器学习应用程序以及带有.NET IoT的物联网应用程序。
- en: The most mature libraries, however, are for Windows, and they include libraries
    for Windows Desktop apps with WPF, Windows Forms, and the **Universal Windows
    Platform** (**UWP**) and Windows services libraries that allow us to run applications
    as services.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，最成熟的库是为Windows开发的，它们包括用于WPF、Windows Forms和**Universal Windows Platform**（**UWP**）的Windows桌面应用程序库以及允许我们将应用程序作为服务运行的Windows服务库。
- en: It would be easy to write a whole series of books on .NET, and many people have.
    However, we are mostly interested in how we can use .NET with PowerShell. We are
    going to focus on the .NET libraries and how we can access their contents from
    PowerShell, accessing in turn the APIs we wish to work with. Let’s start by looking
    at the structure of the .NET libraries.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 谈到.NET，可以轻易写一整套的书籍，而且许多人已经这么做了。然而，我们更感兴趣的是如何在PowerShell中使用.NET。我们将重点关注.NET库以及如何从PowerShell访问其内容，进而访问我们希望使用的API。让我们首先看一下.NET库的结构。
- en: The components of .NET
  id: totrans-39
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: .NET的组件
- en: Before we can start using the .NET libraries, we need to understand how they
    are structured. **Members** (properties, methods, etc.) are contained inside **types**,
    which in turn are contained in **namespaces**. This is **logical type containment**.
    There is also **physical type containment**. These logical structures are physically
    held in **assemblies**. We’ve already seen many of these components in PowerShell.
    Let’s start with assemblies.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始使用 .NET 库之前，我们需要理解它们的结构。**成员**（属性、方法等）包含在**类型**中，而类型又包含在**命名空间**中。这就是**逻辑类型封装**。还有**物理类型封装**。这些逻辑结构在物理上由**程序集**保存。我们在
    PowerShell 中已经看到过这些组件。我们先从程序集开始。
- en: Assemblies
  id: totrans-41
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 程序集
- en: 'Assemblies are collections of types and the resources needed to support them.
    They can be either **static**, loaded from a file, or **dynamic**, existing solely
    in memory. PowerShell will load a number of default assemblies at startup, and
    then, as we import modules, that list will expand. We can see the list of assemblies
    we have loaded with the following:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 程序集是类型和支持它们所需资源的集合。它们可以是**静态的**，从文件加载，或者**动态的**，仅存在于内存中。PowerShell 在启动时会加载一组默认程序集，然后随着我们导入模块，这个列表会扩展。我们可以通过以下方式查看加载的程序集列表：
- en: '[PRE1]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'That will output a table like this:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 这将输出如下表格：
- en: '![Figure 16.1 – Enumerating assemblies](img/B17600_16_1.jpg)'
  id: totrans-45
  prefs: []
  type: TYPE_IMG
  zh: '![图 16.1 – 枚举程序集](img/B17600_16_1.jpg)'
- en: Figure 16.1 – Enumerating assemblies
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 图 16.1 – 枚举程序集
- en: We can see the version and the location of the files that these static assemblies
    are stored in. There is another column, `GAC`, which refers to the `False`. We
    can use assemblies that are usually stored in the GAC by installing them with
    NuGet, the .NET package manager; we just can’t access them from the GAC. We can
    also see that the assemblies are `.dll` files, which we talked about when discussing
    binary modules in [*Chapter 11*](B17600_11.xhtml#_idTextAnchor218), *Creating
    Our First Module*, and we also saw that binary modules are a type of .NET assembly.
    We can think of loading .NET assemblies as similar to loading binary modules.
    PowerShell loads a set of default assemblies when it starts, and these assemblies
    define the types that are available to us. To access other types, we need to load
    further assemblies.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以查看这些静态程序集的版本和文件存储位置。还有一列，`GAC`，表示 `False`。我们可以通过使用 .NET 包管理器 NuGet 安装通常存储在
    GAC 中的程序集来使用它们；只不过我们不能从 GAC 访问它们。我们还可以看到这些程序集是 `.dll` 文件，这在我们讨论二进制模块时提到过，[*第 11
    章*](B17600_11.xhtml#_idTextAnchor218)，*创建我们的第一个模块*，我们还看到二进制模块是 .NET 程序集的一种类型。我们可以将加载
    .NET 程序集看作类似于加载二进制模块。PowerShell 在启动时加载一组默认程序集，这些程序集定义了我们可以使用的类型。要访问其他类型，我们需要加载更多程序集。
- en: Types
  id: totrans-48
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 类型
- en: We first encountered types in [*Chapter 4*](B17600_04.xhtml#_idTextAnchor071),
    *PowerShell Variables and Data Structures*. The PowerShell types are a subset
    of the types found in .NET. We used a .NET type earlier in the chapter when we
    created an `ArrayList` object. Types are enclosed in square brackets.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 我们第一次遇到类型是在 [*第 4 章*](B17600_04.xhtml#_idTextAnchor071)，*PowerShell 变量和数据结构*
    中。PowerShell 类型是 .NET 中类型的一个子集。在本章之前，我们在创建 `ArrayList` 对象时使用了一个 .NET 类型。类型用方括号括起来。
- en: Type versus class
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 类型与类
- en: In type theory, a type is an abstract concept, whereas a class is a set of instructions
    to create an object of a given type. An object is of a certain type – for example,
    a string or an imaginary bike. A class is an implementation of the type. An object
    is an instance of the class. For instance, we could have multiple different classes
    of an imaginary bike that would all be of type `Imaginary.Bike`, but they could
    all have different features – for example, ape hanger handlebars or drop handlebars.
    We could then create many instances of each class (i.e., objects) – in this case,
    imaginary bikes.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 在类型理论中，类型是一个抽象概念，而类是一组创建给定类型对象的指令。一个对象属于某种类型——例如，一个字符串或一辆虚构的自行车。类是类型的实现。对象是类的实例。例如，我们可以有多个不同的虚拟自行车类，它们都属于类型
    `Imaginary.Bike`，但它们可能具有不同的特征——例如，猿把手或下拉把手。然后，我们可以为每个类创建多个实例（即对象）——在这种情况下，虚拟自行车。
- en: In practice, classes are user-defined in PowerShell, whereas types are provided
    by .NET – except, of course, where that isn’t true.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 在实践中，PowerShell 中的类是用户定义的，而类型是由 .NET 提供的——当然，除非情况并非如此。
- en: Enumerations
  id: totrans-53
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 枚举类型
- en: 'An enumeration is a list of constant values. While we haven’t discussed them
    before, we have certainly used them. In [*Chapter 10*](B17600_10.xhtml#_idTextAnchor201),
    *Error Handling – Oh No! It’s Gone Wrong!*, we saw the `$ErrorActionPreference`
    automatic variable and how, by changing the value of the variable, we could control
    how PowerShell handles errors temporarily. We can check the type of the `$ErrorActionPreference`
    variable by calling the variable `GetType()` method, and we can see that it is
    a `System.Enum` type in the following screenshot:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 枚举是常量值的列表。虽然我们之前没有讨论过它们，但我们肯定用过它们。在[*第 10 章*](B17600_10.xhtml#_idTextAnchor201)，*错误处理
    – 哎呀！出错了！*中，我们看到自动变量`$ErrorActionPreference`以及通过更改该变量的值，如何临时控制 PowerShell 处理错误的方式。我们可以通过调用变量的`GetType()`方法来检查`$ErrorActionPreference`变量的类型，并且可以在以下截图中看到它是`System.Enum`类型：
- en: '![Figure 16.2 – How can I set thee? Let me count the ways](img/B17600_16_2.jpg)'
  id: totrans-55
  prefs: []
  type: TYPE_IMG
  zh: '![图 16.2 – 如何设置你？让我数一数有哪些方式](img/B17600_16_2.jpg)'
- en: Figure 16.2 – How can I set thee? Let me count the ways
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 图 16.2 – 如何设置你？让我数一数有哪些方式
- en: We can list out the list of possible values with the `GetEnumValues()` method,
    and we can see the familiar list of possible values. `$ErrorActionPreference`
    can only have those values, and we can’t change them.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用`GetEnumValues()`方法列出可能的值，并看到熟悉的可能值列表。`$ErrorActionPreference`只能拥有这些值，且无法更改。
- en: Classes
  id: totrans-58
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 类
- en: A class is a logical definition of an object that defines the properties and
    methods of the object – a recipe. It is an implementation of a type. Back in [*Chapter
    4*](B17600_04.xhtml#_idTextAnchor071), *PowerShell Variables and Data Structures*,
    we created three objects of type `Imaginary.Bike`, by creating the objects and
    their properties and labeling them as `Imaginary.Bike`. We could also have defined
    a class of objects called `Imaginary.Bike` with the same properties and methods,
    using a **constructor** to create actual instances of the class. We use classes
    when we want to be able to create objects easily and repeatably.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 类是对象的逻辑定义，它定义了对象的属性和方法——就像一份食谱。它是某种类型的实现。回到[*第 4 章*](B17600_04.xhtml#_idTextAnchor071)，*PowerShell
    变量与数据结构*，我们通过创建类型为`Imaginary.Bike`的三个对象，定义了这些对象及其属性，并将其标记为`Imaginary.Bike`。我们也可以定义一个名为`Imaginary.Bike`的类，并赋予它相同的属性和方法，使用**构造函数**来创建该类的实际实例。当我们希望能够轻松且可重复地创建对象时，我们使用类。
- en: Namespaces
  id: totrans-60
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 命名空间
- en: 'Namespaces are analogous to folders in a filesystem; we saw namespaces used
    in this context in [*Chapter 13*](B17600_13.xhtml#_idTextAnchor267), *Working
    With PowerShell 7 and Windows*, when we discussed CIM classes. Most PowerShell
    types and functions are found in the `System.Management.Automation` namespace.
    When we interact with the filesystem, we use the `System.IO` namespace. We don’t
    need to write `System` when we refer to a namespace in PowerShell, as the `System`
    namespace is automatically searched; `Management.Automation` is functionally the
    same as `System.Management.Automation`. Unfortunately, we need to specify the
    namespace of any type that isn’t immediately in the `System` namespace, like this:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 命名空间类似于文件系统中的文件夹；我们在[*第 13 章*](B17600_13.xhtml#_idTextAnchor267)，*使用 PowerShell
    7 和 Windows*中讨论 CIM 类时看到了命名空间的使用。大多数 PowerShell 类型和函数都位于`System.Management.Automation`命名空间中。当我们与文件系统交互时，我们使用`System.IO`命名空间。我们在
    PowerShell 中引用命名空间时，不需要写`System`，因为会自动搜索`System`命名空间；`Management.Automation`在功能上与`System.Management.Automation`相同。不幸的是，我们需要为任何不在`System`命名空间中的类型指定命名空间，如下所示：
- en: '![Figure 16.3 – Accessing namespaces](img/B17600_16_3.jpg)'
  id: totrans-62
  prefs: []
  type: TYPE_IMG
  zh: '![图 16.3 – 访问命名空间](img/B17600_16_3.jpg)'
- en: Figure 16.3 – Accessing namespaces
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 图 16.3 – 访问命名空间
- en: The `Path` type defines the file path of an object and is in the `System.IO`
    namespace. If we try to reference it without specifying the namespace in line
    1, we get an error. In line 2, we specify the full namespace, but in line 3, we
    can see that we don’t need to specify the `System` portion of the namespace, as
    it is implied.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: '`Path`类型定义了对象的文件路径，并位于`System.IO`命名空间中。如果我们在第 1 行没有指定命名空间来引用它，就会出现错误。在第 2 行，我们指定了完整的命名空间，但在第
    3 行，我们可以看到无需指定`System`部分的命名空间，因为它是隐式的。'
- en: 'We can also use the `using` keyword to load the namespace, like this:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以使用`using`关键字来加载命名空间，如下所示：
- en: '[PRE2]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'After running this, we can call the `Path` type without specifying the namespace,
    like this:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 运行此操作后，我们可以像这样调用`Path`类型，而无需指定命名空间：
- en: '![Figure 16.4 – The using keyword in action](img/B17600_16_4.jpg)'
  id: totrans-68
  prefs: []
  type: TYPE_IMG
  zh: '![图 16.4 – `using`关键字的作用](img/B17600_16_4.jpg)'
- en: Figure 16.4 – The using keyword in action
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 图 16.4 – `using`关键字的作用
- en: We saw the `using` keyword in [*Chapter 11*](B17600_11.xhtml#_idTextAnchor218),
    *Creating Our First Module*, where we learned it was the recommended way of loading
    modules inside a script. As we can see, we can also use it to load namespaces
    and assemblies. Unfortunately, in the console, only the most recent `using` statement
    is applied, so if we access another namespace with it in the current session,
    we will lose access to the `System.IO` namespace. Scripts allow multiple `using`
    statements, written at the start of the script; they can only be preceded by comments.
    We can load multiple namespaces in the console by using semicolons (`;`) to separate
    the `using` statements.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在[*第11章*](B17600_11.xhtml#_idTextAnchor218)《创建我们的第一个模块》中看到过`using`关键字，我们了解它是脚本中加载模块的推荐方式。正如我们所看到的，我们也可以使用它来加载命名空间和程序集。不幸的是，在控制台中，只有最新的`using`语句会生效，因此如果我们在当前会话中使用它访问另一个命名空间，就会失去对`System.IO`命名空间的访问权限。脚本允许多个`using`语句，通常写在脚本的开头；它们只能被注释符号所前置。我们可以通过使用分号(`;`)分隔`using`语句，在控制台中加载多个命名空间。
- en: Members
  id: totrans-71
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 成员
- en: Types and classes have members; throughout the book, we have used the `Get-Member`
    command to examine the properties and methods available on objects, and we’ve
    seen that objects are instances of a specific type. .NET types have a member we
    have not seen before, the constructor. Constructors provide ways of instantiating
    objects of the given class and take the same name as the class. They don’t appear
    when we run `Get-Member` against the class and can’t be directly called. Constructors
    may have parameters that we can use to populate the data members of the new object,
    or they may not; the object is created with a set of null value properties. Constructors
    may have overloads, where different sets of arguments can be passed when constructing
    the object. Most .NET classes have an automatic constructor called `new()`, which
    is a static method added by PowerShell.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 类型和类有成员；在本书中，我们使用了`Get-Member`命令来检查对象的属性和方法，并且我们已经看到对象是某种特定类型的实例。 .NET 类型有一个我们之前没有见过的成员——构造函数。构造函数提供了实例化给定类对象的方式，并与类同名。当我们对类运行`Get-Member`时，构造函数不会出现，也无法直接调用。构造函数可能有参数，我们可以使用这些参数来填充新对象的数据成员，也可能没有；如果没有参数，则对象会被创建时具有一组空值属性。构造函数可能有重载，可以在构造对象时传递不同的参数集。大多数
    .NET 类都有一个自动构造函数`new()`，这是PowerShell添加的一个静态方法。
- en: 'Let’s look at an example. The `[string]` type is immutable; when we change
    a string, we destroy the old string and create a new one. If we need the string
    to change frequently, this can cause a performance problem, much the same as the
    issue we have seen with arrays. There is a class in .NET that defines mutable
    strings that get around this problem; it’s called the `StringBuilder` class, and
    objects of this class are of type `System.Text.Stringbuilder`. If we create a
    new `StringBuilder` object with the default automatic constructor, we get an object
    with three properties, `Capacity`, `MaxCapacity`, and `Length`, in characters.
    If we call the `new()` method without the brackets, then we can see a list of
    the possible overloads:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一个例子。`[string]`类型是不可变的；当我们修改字符串时，我们会销毁旧字符串并创建一个新字符串。如果我们需要字符串频繁变化，这可能会导致性能问题，这与我们在数组中看到的问题类似。在.NET中有一个定义可变字符串的类，它解决了这个问题；它被称为`StringBuilder`类，该类的对象是`System.Text.StringBuilder`类型。如果我们使用默认的自动构造函数创建一个新的`StringBuilder`对象，我们会得到一个具有三个属性的对象：`Capacity`、`MaxCapacity`和`Length`，这些属性的单位是字符。如果我们不带括号调用`new()`方法，我们就能看到所有可能的重载列表：
- en: '![Figure 16.5 – The overloads of the StringBuilder class](img/B17600_16_5.jpg)'
  id: totrans-74
  prefs: []
  type: TYPE_IMG
  zh: '![图 16.5 – `StringBuilder`类的重载](img/B17600_16_5.jpg)'
- en: Figure 16.5 – The overloads of the StringBuilder class
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 图 16.5 – `StringBuilder`类的重载
- en: 'As we can see, we can pass different combinations of arguments to the `new()`
    method to construct `StringBuilder` objects with different properties. Let’s try
    it. Type the following:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所看到的，我们可以向`new()`方法传递不同的参数组合，从而构造具有不同属性的`StringBuilder`对象。让我们试试看。输入以下内容：
- en: '[PRE3]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Now, if we call `$string1` and `$string2`, we can see that `$string1` is empty
    and has a capacity of 32\. `$string2` has a length of 2 and a capacity of 16\.
    That’s because we called the overload `new(int capacity)` for `$string1` and the
    overload `new(string value)` for `$string2`.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果我们调用`$string1`和`$string2`，我们会看到`$string1`是空的，且其容量为32；`$string2`的长度为2，容量为16。这是因为我们对`$string1`调用了重载`new(int
    capacity)`，对`$string2`调用了重载`new(string value)`。
- en: 'We can use the `ToString()` method to see the contents, like this:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用`ToString()`方法查看内容，如下所示：
- en: '[PRE4]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '`$string1` is empty, and `$string2` contains the `''32''` string. If we use
    the `GetType()` method, we can see that both are `StringBuilder` objects. If we
    pipe them to the `Get-Member` cmdlet, we can also see that the `new()` method
    isn’t listed because it’s a constructor.'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: '`$string1` 是空的，而 `$string2` 包含 `''32''` 字符串。如果我们使用 `GetType()` 方法，我们可以看到两者都是
    `StringBuilder` 对象。如果我们将它们传递给 `Get-Member` cmdlet，我们还可以看到 `new()` 方法没有列出，因为它是一个构造函数。'
- en: Versioning
  id: totrans-82
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 版本管理
- en: An assembly is a `.dll` file that contains metadata called the assembly manifest,
    which lists the contents of the file, as well as the name and the version of the
    file. The concept of strong names was introduced in .NET; a strong name consists
    of the name of the module, the version, and also a cryptographic hash that validates
    the file author. When .NET programs are linked to a strong named assembly, then
    the name, version, and hash of the file must match the linked strong name. If
    we simply replace the `.dll` file with a later version, then the program will
    fail to load it. This leads to different versions of `.dll` that have the same
    version number to prevent introducing breaking changes. Great.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 程序集是一个包含称为程序集清单的元数据的 `.dll` 文件，清单列出了文件的内容以及文件的名称和版本。强名称的概念是在 .NET 中引入的；一个强名称由模块的名称、版本以及用于验证文件作者的加密哈希组成。当
    .NET 程序链接到一个强名称程序集时，文件的名称、版本和哈希必须与链接的强名称匹配。如果我们只是简单地用一个较新的版本替换 `.dll` 文件，那么程序将无法加载它。这导致了具有相同版本号的
    `.dll` 文件的不同版本，以防止引入破坏性更改。太棒了。
- en: There are many other components, but these are the things we most need to be
    aware of when working with .NET and PowerShell. Let’s look now at how PowerShell
    makes use of .NET.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 还有许多其他组件，但这些是我们在使用 .NET 和 PowerShell 时最需要注意的内容。现在，让我们来看看 PowerShell 如何利用 .NET。
- en: Working with .NET in PowerShell
  id: totrans-85
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在 PowerShell 中使用 .NET
- en: In this section, we are going to look at some of the details of how PowerShell
    accesses .NET libraries. We’ll look at the default assemblies, how PowerShell
    finds types, and another way of creating objects.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将查看 PowerShell 如何访问 .NET 库的详细信息。我们将了解默认的程序集、PowerShell 如何查找类型，以及另一种创建对象的方法。
- en: Why bother?
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么要在乎？
- en: PowerShell and C# are part of the .NET family and thus work well together, as
    they are based on the same .NET foundation. They share many features, such as
    classes and libraries. We can call C# inside PowerShell by using `Add-Type`, allowing
    us to compile and run the C# code when we run the PowerShell script. This lets
    us take advantage of the simplicity and ease of PowerShell, but we have C# available
    whenever we need it, without having to write an entire program.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: PowerShell 和 C# 都是 .NET 家族的一部分，因此它们可以很好地协同工作，因为它们基于相同的 .NET 基础。它们共享许多功能，例如类和库。我们可以通过使用
    `Add-Type` 在 PowerShell 中调用 C#，这让我们在运行 PowerShell 脚本时编译并运行 C# 代码。这样我们就能利用 PowerShell
    的简洁和易用性，但当需要时，C# 也能随时调用，而不必编写整个程序。
- en: PowerShell assemblies
  id: totrans-89
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: PowerShell 程序集
- en: 'We saw at the start of the chapter that we could list the loaded assemblies
    with the statement:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在章节开始时看到，可以通过以下语句列出已加载的程序集：
- en: '[PRE5]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '`AppDomain` is a class that encapsulates and isolates the execution environment;
    it’s a bit like `PSSession` but even more secure; each instance of `PSSession`
    shares a set of assemblies, whereas each instance of `AppDomain` loads its own
    assemblies. `CurrentDomain` gets the current execution environment. The double
    colon (`::`) represents the C# namespace alias operator; we need to use it to
    access a member of an aliased namespace, and it goes between two identifiers.
    Let’s run the statement again, like this:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: '`AppDomain` 是一个封装和隔离执行环境的类；它有点像 `PSSession`，但更加安全；每个 `PSSession` 实例共享一组程序集，而每个
    `AppDomain` 实例加载自己的程序集。`CurrentDomain` 获取当前执行环境。双冒号（`::`）是 C# 命名空间别名运算符；我们需要使用它来访问别名命名空间的成员，它位于两个标识符之间。让我们像这样再次运行语句：'
- en: '[PRE6]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Then, we can see a list of the strong names of the assemblies we’ve loaded:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们可以看到已加载程序集的强名称列表：
- en: '![Figure 16.6 – Default assemblies and their strong names](img/B17600_16_6.jpg)'
  id: totrans-95
  prefs: []
  type: TYPE_IMG
  zh: '![图 16.6 – 默认程序集及其强名称](img/B17600_16_6.jpg)'
- en: Figure 16.6 – Default assemblies and their strong names
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 图 16.6 – 默认程序集及其强名称
- en: Note that each strong name contains a short name, a version, a culture identifier,
    and the cryptographic key that identifies the author.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，每个强名称包含一个短名称、一个版本、一个文化标识符和一个加密密钥，该密钥标识作者。
- en: Dynamic assembly loading
  id: totrans-98
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 动态程序集加载
- en: Automatic loading works for compiled programs such as `pwsh.exe`, but it relies
    on the required assembly list in the executable. We can add required assemblies
    to a module manifest as well, in the `RequiredAssemblies` element. If we need
    to load non-default assemblies when writing scripts, we can use the preceding
    `using` keyword, the `Add-Type` cmdlet, or even the `Import-Module` cmdlet if
    the assembly is in a `.``dll` file.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 自动加载适用于像`pwsh.exe`这样的已编译程序，但它依赖于可执行文件中的所需程序集列表。我们也可以将所需的程序集添加到模块清单中的`RequiredAssemblies`元素。如果在编写脚本时需要加载非默认程序集，我们可以使用前面的`using`关键字、`Add-Type`
    cmdlet，甚至使用`Import-Module` cmdlet，如果程序集在一个`.dll`文件中。
- en: 'The `Add-Type` cmdlet has five parameter sets; three of them are for defining
    new types, but we can also use it to import assemblies from a named path, or to
    just import the types we need from the assembly, such as the following:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: '`Add-Type` cmdlet有五个参数集；其中三个用于定义新类型，但我们也可以使用它从指定路径导入程序集，或仅从程序集导入我们需要的类型，例如以下内容：'
- en: '[PRE7]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: This will add the assemblies required to call simple Windows GUI elements from
    within PowerShell.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 这将添加所需的程序集，以便从PowerShell中调用简单的Windows GUI元素。
- en: Once we’ve imported (or created) our new type, we can create instances of types
    with the `New-Object` cmdlet.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们导入（或创建）了新的类型，就可以使用`New-Object` cmdlet来创建该类型的实例。
- en: Creating instances of types
  id: totrans-104
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建类型的实例
- en: 'The `New-Object` cmdlet creates an instance of a type. Either the type must
    exist inside the PowerShell default assemblies, or we must import it first with
    `Add-Type`. `New-Object` is easy to use. All we need to provide is `TypeName`
    and a list of arguments that matches one of the available overloads. For instance,
    one of the overloads on the `StringBuilder` type allows a string to define the
    value of the new object, and an integer to define the initial capacity. Note that
    it takes a string value, (`System.Text.String.Builder`), not a namespace and namespace
    alias qualifier (`[System.Text.StringBuilder]::`), so we can do this:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: '`New-Object` cmdlet创建一个类型的实例。该类型必须存在于PowerShell默认的程序集内，或者我们必须先使用`Add-Type`导入它。`New-Object`很容易使用。我们只需要提供`TypeName`和一个与可用重载匹配的参数列表。例如，`StringBuilder`类型的一个重载允许使用一个字符串来定义新对象的值，另一个整数来定义初始容量。请注意，它接受一个字符串值（`System.Text.String.Builder`），而不是命名空间和命名空间别名限定符（`[System.Text.StringBuilder]::`），所以我们可以这样做：'
- en: '[PRE8]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'That will create a variable called `$loveit` that contains the `"i love PowerShell"`
    string and has an initial capacity of 128 characters:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 这将创建一个名为`$loveit`的变量，它包含`"i love PowerShell"`字符串，并且初始容量为128个字符：
- en: '![Figure 16.7 – Loving it](img/B17600_16_7.jpg)'
  id: totrans-108
  prefs: []
  type: TYPE_IMG
  zh: '![图 16.7 – 喜欢它](img/B17600_16_7.jpg)'
- en: Figure 16.7 – Loving it
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 图 16.7 – 喜欢它
- en: We can see in the preceding screenshot that the initial capacity is 128, whereas
    we would expect it to be 17, the length of the string, if we had just passed a
    string value. Note that we have to understand the required arguments for the overload
    we wish to use as a constructor – in this instance, `"i love powershell"` and
    `128`. For instance, if we supply two strings, we will get an error.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在前面的截图中看到，初始容量是128，而如果我们只传递一个字符串值的话，预计它应该是17，即字符串的长度。请注意，我们需要理解我们希望使用的构造函数的重载所需的参数——在本例中是`"i
    love powershell"`和`128`。例如，如果我们提供两个字符串，则会出错。
- en: An alternative is to use the `-Property` parameter, which accepts a hashtable
    of property names and the required values. We’ll see how to use that in the next
    section, but note that if you misspell a property, PowerShell will simply add
    the misspelled property to the object, rather than tell you that you have it wrong.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种选择是使用`-Property`参数，它接受一个包含属性名称和所需值的哈希表。我们将在下一节中看到如何使用它，但请注意，如果你拼写错误，PowerShell会将拼写错误的属性添加到对象中，而不是告诉你有错误。
- en: Let’s try a couple of examples to get a feel for how we can use .NET with PowerShell.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们尝试几个例子，以便更好地了解如何在PowerShell中使用 .NET。
- en: Using .NET
  id: totrans-113
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 .NET
- en: We’ll try two examples in this section – an alternative way of getting an action
    to fire, such as a script, and how we can call Windows GUI elements from PowerShell.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将尝试两个示例——一种触发操作的替代方法，比如脚本，以及如何从PowerShell中调用Windows GUI元素。
- en: An alternative to the Task Scheduler
  id: totrans-115
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 任务调度程序的替代方案
- en: In this example, we’re going to create a timer object and then use the `Register-Event`
    cmdlet to fire an action at regular intervals.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们将创建一个定时器对象，然后使用`Register-Event` cmdlet在定时的间隔内触发一个操作。
- en: 'First, let’s make a timer:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们创建一个定时器：
- en: '[PRE9]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Now, we need to register the event and define an action:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们需要注册事件并定义一个操作：
- en: '[PRE10]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Now, let’s start the timer going with the following:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们开始计时，操作如下：
- en: '[PRE11]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Then, we should see the `hello` string appear on the screen, every five seconds,
    until we type the following:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们应该看到`hello`字符串每隔五秒钟出现在屏幕上，直到我们输入以下内容：
- en: '[PRE12]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'This is how it looks on my machine:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是它在我机器上的样子：
- en: '![Figure 16.8 – hello](img/B17600_16_8.jpg)'
  id: totrans-126
  prefs: []
  type: TYPE_IMG
  zh: '![图16.8 – hello](img/B17600_16_8.jpg)'
- en: Figure 16.8 – hello
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 图16.8 – hello
- en: We can see the command firing every time the timer reaches 5,000 milliseconds.
    Cool, eh?
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到每当计时器达到5000毫秒时，命令就会被触发。酷吧？
- en: Let’s try creating a GUI message box.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们尝试创建一个GUI消息框。
- en: Creating GUI objects
  id: totrans-130
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建GUI对象
- en: 'This example will create a pop-up message box in Windows with a pair of yes/no
    buttons. The value of the pressed button is recorded in the PowerShell session:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子将在Windows中创建一个弹出消息框，包含一对“是/否”按钮。按下的按钮值将记录在PowerShell会话中：
- en: '[PRE13]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'We could use this in conjunction with the preceding timer object to display
    a message box, allowing people to cancel a long-running script. This is how it
    looks on my machine:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将这个与前面的计时器对象结合使用，显示一个消息框，允许用户取消长时间运行的脚本。这是它在我机器上的样子：
- en: '![Figure 16.9 – Of course you do](img/B17600_16_9.jpg)'
  id: totrans-134
  prefs: []
  type: TYPE_IMG
  zh: '![图16.9 – 当然你会](img/B17600_16_9.jpg)'
- en: Figure 16.9 – Of course you do
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 图16.9 – 当然你会
- en: Note that the default answer is **Yes**. We could also use the response to set
    parameters, add an event, or trigger a conditional statement.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，默认答案是**是**。我们还可以使用响应来设置参数、添加事件或触发条件语句。
- en: Let’s summarize what we’ve seen in this chapter.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们总结一下本章的内容。
- en: Summary
  id: totrans-138
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: We started out by understanding what .NET is – a software framework. We learned
    that it is based on the Common Language Infrastructure and is similar to .NET
    Framework in Windows, but it is not the same. We saw that it includes its own
    runtime, CoreCLR, and a set of libraries, CoreFX. We learned about the relationship
    between .NET and .NET Framework and how they co-exist. We saw that .NET can be
    used for many things, including machine learning and Internet of Things applications,
    but is mostly used for Azure and Windows.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先了解了什么是.NET——一个软件框架。我们了解到它是基于公共语言基础结构（Common Language Infrastructure）并且类似于Windows中的.NET
    Framework，但并不完全相同。我们看到它包含了自己的运行时CoreCLR和一套库CoreFX。我们了解了.NET和.NET Framework之间的关系以及它们如何共存。我们看到.NET可以用于许多领域，包括机器学习和物联网应用，但它主要用于Azure和Windows。
- en: We went through the components of .NET, and we understood how they are related
    to each other and are represented in PowerShell. We saw the constructor member,
    a special type of method for instantiating objects, and understood why versioning
    is frequently confusing.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 我们了解了.NET的各个组件，并理解了它们如何相互关联，并在PowerShell中表示。我们看到了构造函数成员，这是用于实例化对象的一种特殊类型的方法，并理解了为什么版本控制经常让人困惑。
- en: We then looked at the specifics of how we access .NET libraries from PowerShell,
    learned about dynamic loading, and then saw how to use the `New-Object` cmdlet
    to create instances of classes.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们查看了如何从PowerShell访问.NET库的具体方法，学习了动态加载，并看到了如何使用`New-Object` cmdlet来创建类的实例。
- en: Finally, we worked through two examples of things we can do using .NET – creating
    an event timer and a Windows message box.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们通过两个例子演示了可以使用.NET做的事情——创建事件计时器和Windows消息框。
- en: What’s next? Well, it depends. If you want to learn more about PowerShell, then
    there are great books such as *Mastering PowerShell Scripting* by Chris Dent from
    Packt, or the absolute bible, *Windows PowerShell in Action* by Bruce Payette
    et al. Whichever you choose, what you need to do is practice, practice, practice.
    The best way to become confident with a language, any language, is to use it.
    If you are interested in .NET, then PowerShell is a good start, but sooner or
    later, you will want to use a compiled language with it, such as C#. While it’s
    technically possible to write a machine learning application in PowerShell, I
    think it would be a lot easier to do it with C#.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来呢？这取决于你的需求。如果你想了解更多PowerShell的内容，有很多很棒的书籍，比如Packt出版的Chris Dent的《Mastering
    PowerShell Scripting》，或者Bruce Payette等人编写的绝对经典之作《Windows PowerShell in Action》。无论你选择哪本书，你需要做的就是多加练习。任何语言，最好的学习方式就是用它。若你对.NET感兴趣，PowerShell是一个不错的起点，但迟早你会想使用编译型语言，比如C#。虽然在PowerShell中编写机器学习应用程序从技术上来说是可行的，但我认为用C#做会容易得多。
- en: That’s it. That’s the end of the book. Thank you for sticking with it alongside
    me; I hope you enjoyed reading it as much as I enjoyed writing it. I can assure
    you I have learned a lot in the process, and hopefully, so have you. I hope you’ve
    enjoyed my company as much as I’ve enjoyed yours.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 就这样。这本书到此为止。感谢你与我一起坚持读完，希望你读得和我写得一样愉快。我可以向你保证，我在这个过程中学到了很多，希望你也有所收获。希望你像我享受陪伴一样也享受我的陪伴。
- en: Exercises
  id: totrans-145
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 练习
- en: How do you create a new instance of a .NET class in PowerShell?
  id: totrans-146
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如何在 PowerShell 中创建 .NET 类的新实例？
- en: What command in PowerShell is used to add a .NET assembly to the session?
  id: totrans-147
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: PowerShell 中用于将 .NET 程序集添加到会话的命令是什么？
- en: How do you call a static method of a .NET class in PowerShell?
  id: totrans-148
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如何在 PowerShell 中调用 .NET 类的静态方法？
- en: In PowerShell, how can you access a static property of a .NET class?
  id: totrans-149
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 PowerShell 中，如何访问 .NET 类的静态属性？
- en: How can you invoke a .NET constructor with parameters in PowerShell?
  id: totrans-150
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如何在 PowerShell 中调用带参数的 .NET 构造函数？
- en: What is the PowerShell cmdlet to load a .NET assembly from a file?
  id: totrans-151
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 用于从文件加载 .NET 程序集的 PowerShell cmdlet 是什么？
- en: How can you determine the .NET type of an object in PowerShell?
  id: totrans-152
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如何在 PowerShell 中确定对象的 .NET 类型？
- en: In PowerShell, how do you list all the methods of a .NET object?
  id: totrans-153
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 PowerShell 中，如何列出 .NET 对象的所有方法？
- en: What is the syntax to invoke an instance method of a .NET object in PowerShell?
  id: totrans-154
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 PowerShell 中，调用 .NET 对象实例方法的语法是什么？
- en: How do you access an instance property of a .NET object in PowerShell?
  id: totrans-155
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如何在 PowerShell 中访问 .NET 对象的实例属性？
- en: Further reading
  id: totrans-156
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: 'What is .NET?: [https://dotnet.microsoft.com/en-us/learn/dotnet/what-is-dotnet](https://dotnet.microsoft.com/en-us/learn/dotnet/what-is-dotnet)'
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 什么是 .NET？：[https://dotnet.microsoft.com/en-us/learn/dotnet/what-is-dotnet](https://dotnet.microsoft.com/en-us/learn/dotnet/what-is-dotnet)
- en: 'The Microsoft .NET documentation: [https://learn.microsoft.com/en-us/dotnet/core/introduction](https://learn.microsoft.com/en-us/dotnet/core/introduction)'
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 微软 .NET 文档：[https://learn.microsoft.com/en-us/dotnet/core/introduction](https://learn.microsoft.com/en-us/dotnet/core/introduction)
- en: 'The original .NET documentation; surprisingly useful: [https://learn.microsoft.com/en-us/previous-versions/tn-archive/bb496996(v=technet.10)](https://learn.microsoft.com/en-us/previous-versions/tn-archive/bb496996(v=technet.10))'
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 原始的 .NET 文档；出奇的有用：[https://learn.microsoft.com/en-us/previous-versions/tn-archive/bb496996(v=technet.10)](https://learn.microsoft.com/en-us/previous-versions/tn-archive/bb496996(v=technet.10))
- en: 'The `System.Management.Automation` namespace: [https://learn.microsoft.com/en-gb/dotnet/api/system.management.automation](https://learn.microsoft.com/en-gb/dotnet/api/system.management.automation)'
  id: totrans-160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`System.Management.Automation` 命名空间：[https://learn.microsoft.com/en-gb/dotnet/api/system.management.automation](https://learn.microsoft.com/en-gb/dotnet/api/system.management.automation)'
- en: 'Classes: [https://learn.microsoft.com/en-us/powershell/module/microsoft.powershell.core/about/about_classes](https://learn.microsoft.com/en-us/powershell/module/microsoft.powershell.core/about/about_classes)'
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 类：[https://learn.microsoft.com/en-us/powershell/module/microsoft.powershell.core/about/about_classes](https://learn.microsoft.com/en-us/powershell/module/microsoft.powershell.core/about/about_classes)
- en: 'Constructors: [https://learn.microsoft.com/en-us/powershell/module/microsoft.powershell.core/about/about_classes_constructors](https://learn.microsoft.com/en-us/powershell/module/microsoft.powershell.core/about/about_classes_constructors)'
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构造函数：[https://learn.microsoft.com/en-us/powershell/module/microsoft.powershell.core/about/about_classes_constructors](https://learn.microsoft.com/en-us/powershell/module/microsoft.powershell.core/about/about_classes_constructors)
- en: 'The `StringBuilder` class: [https://learn.microsoft.com/en-gb/dotnet/api/system.text.stringbuilder](https://learn.microsoft.com/en-gb/dotnet/api/system.text.stringbuilder)'
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`StringBuilder` 类：[https://learn.microsoft.com/en-gb/dotnet/api/system.text.stringbuilder](https://learn.microsoft.com/en-gb/dotnet/api/system.text.stringbuilder)'
- en: '`Add-Type`: [https://learn.microsoft.com/en-us/powershell/module/microsoft.powershell.utility/add-type](https://learn.microsoft.com/en-us/powershell/module/microsoft.powershell.utility/add-type)'
  id: totrans-164
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Add-Type`：[https://learn.microsoft.com/en-us/powershell/module/microsoft.powershell.utility/add-type](https://learn.microsoft.com/en-us/powershell/module/microsoft.powershell.utility/add-type)'
- en: '`New-Object`: [https://learn.microsoft.com/en-us/powershell/module/microsoft.powershell.utility/new-object](https://learn.microsoft.com/en-us/powershell/module/microsoft.powershell.utility/new-object)'
  id: totrans-165
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`New-Object`：[https://learn.microsoft.com/en-us/powershell/module/microsoft.powershell.utility/new-object](https://learn.microsoft.com/en-us/powershell/module/microsoft.powershell.utility/new-object)'
- en: 'The `Timer` class: [https://learn.microsoft.com/en-us/dotnet/api/system.timers.timer](https://learn.microsoft.com/en-us/dotnet/api/system.timers.timer)'
  id: totrans-166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Timer` 类：[https://learn.microsoft.com/en-us/dotnet/api/system.timers.timer](https://learn.microsoft.com/en-us/dotnet/api/system.timers.timer)'
- en: '`Register-ObjectEvent`: [https://learn.microsoft.com/en-us/powershell/module/microsoft.powershell.utility/register-objectevent](https://learn.microsoft.com/en-us/powershell/module/microsoft.powershell.utility/register-objectevent)'
  id: totrans-167
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Register-ObjectEvent`: [https://learn.microsoft.com/en-us/powershell/module/microsoft.powershell.utility/register-objectevent](https://learn.microsoft.com/en-us/powershell/module/microsoft.powershell.utility/register-objectevent)'
- en: 'PowerShell Eventing: [https://devblogs.microsoft.com/powershell/powershell-eventing-quickstart/](https://devblogs.microsoft.com/powershell/powershell-eventing-quickstart/)'
  id: totrans-168
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'PowerShell 事件系统: [https://devblogs.microsoft.com/powershell/powershell-eventing-quickstart/](https://devblogs.microsoft.com/powershell/powershell-eventing-quickstart/)'
- en: 'Learn C#: [https://dotnet.microsoft.com/en-us/learn/csharp](https://dotnet.microsoft.com/en-us/learn/csharp)'
  id: totrans-169
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '学习 C#: [https://dotnet.microsoft.com/en-us/learn/csharp](https://dotnet.microsoft.com/en-us/learn/csharp)'
- en: Answers to Activities and Exercises
  id: totrans-170
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 活动和练习的答案
- en: '[Chapter 1](B17600_01.xhtml#_idTextAnchor013)'
  id: totrans-171
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '[第 1 章](B17600_01.xhtml#_idTextAnchor013)'
- en: Activities
  id: totrans-172
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 活动
- en: 'You can use `ADD_FILE_CONTEXT_MENU_RUNPOWERSHELL`, like this:'
  id: totrans-173
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你可以像这样使用 `ADD_FILE_CONTEXT_MENU_RUNPOWERSHELL`：
- en: '[PRE14]'
  id: totrans-174
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '![Figure A.1 – Some PowerShell processes](img/B17600_Assessments_001.jpg)'
  id: totrans-175
  prefs: []
  type: TYPE_IMG
  zh: '![图 A.1 – 一些 PowerShell 进程](img/B17600_Assessments_001.jpg)'
- en: Figure A.1 – Some PowerShell processes
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 图 A.1 – 一些 PowerShell 进程
- en: 'Let’s get rid of `4052`:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们去掉 `4052`：
- en: '![Figure A.2 – Fewer PowerShell processes](img/B17600_Assessments_002.jpg)'
  id: totrans-178
  prefs: []
  type: TYPE_IMG
  zh: '![图 A.2 – 更少的 PowerShell 进程](img/B17600_Assessments_002.jpg)'
- en: Figure A.2 – Fewer PowerShell processes
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 图 A.2 – 更少的 PowerShell 进程
- en: Exercises
  id: totrans-180
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习
- en: Input `Get-Random`.
  id: totrans-181
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 输入 `Get-Random`。
- en: Input `Get-Random -Minimum 1 -``Maximum 11`.
  id: totrans-182
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 输入 `Get-Random -Minimum 1 -Maximum 11`。
- en: Input `Get-ChildItem -``Path <folderpath>`.
  id: totrans-183
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 输入 `Get-ChildItem -Path <文件夹路径>`。
- en: Input `Get-ChildItem -Path <``folderpath> -Recurse`.
  id: totrans-184
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 输入 `Get-ChildItem -Path <文件夹路径> -Recurse`。
- en: Input `New-Item -Path <folder path> -Name <item` `name> -ItemType`.
  id: totrans-185
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 输入 `New-Item -Path <文件夹路径> -Name <项目名称> -ItemType`。
- en: Directory.
  id: totrans-186
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 目录。
- en: Input `Get-Uptime`.
  id: totrans-187
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 输入 `Get-Uptime`。
- en: Input `Out-File`.
  id: totrans-188
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 输入 `Out-File`。
- en: Store a username and password for use later in the shell or in a script.
  id: totrans-189
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 存储一个用户名和密码，以便在 shell 或脚本中稍后使用。
- en: This cmdlet converts the output of a previous cmdlet or pipeline to HTML, which
    can then be displayed in a web browser. Note that you might need to save it as
    a file using `out-file` as well, or it will just display the HTML code in the
    shell.
  id: totrans-190
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这个 cmdlet 会将之前 cmdlet 或管道的输出转换为 HTML，然后可以在 web 浏览器中显示。请注意，你可能还需要使用 `out-file`
    保存为文件，否则它只会在 shell 中显示 HTML 代码。
- en: '[Chapter 2](B17600_02.xhtml#_idTextAnchor034)'
  id: totrans-191
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '[第 2 章](B17600_02.xhtml#_idTextAnchor034)'
- en: Activities
  id: totrans-192
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 活动
- en: '`New` creates a new object. For instance, `New-Item C:\foo\bar.tx``t` will
    create an empty text file called `bar.txt` in the `C:\foo` directory. Add will
    add things to the existing object, so `Add-Content C:\foo\bar.txt "PowerShell
    rocks my world``"`will add that string to the previously empty text file.'
  id: totrans-193
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`New` 用于创建一个新对象。例如，`New-Item C:\foo\bar.txt` 将在 `C:\foo` 目录下创建一个名为 `bar.txt`
    的空文本文件。`Add` 会将内容添加到现有对象中，因此 `Add-Content C:\foo\bar.txt "PowerShell rocks my
    world"` 会将该字符串添加到之前空的文本文件中。'
- en: 'Just specify the `-InputObject` parameter like this: `Get-Random -``InputObject
    20`.'
  id: totrans-194
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 只需像这样指定 `-InputObject` 参数：`Get-Random -InputObject 20`。
- en: Use the `-Prefix` parameter. This is particularly useful when using remote sessions.
  id: totrans-195
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `-Prefix` 参数。这个参数在使用远程会话时特别有用。
- en: Exercises
  id: totrans-196
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习
- en: '`Get-Content` is correct. This is a bit of a trick question, as the *Approved
    Verbs for PowerShell Commands* web page says that `Get` should be reserved for
    getting information *about* an object, not its contents. Nonetheless, `Get-Content`
    is right, as we are getting the contents of a file and reserving it for future
    use *as an object*, as opposed to reading data from a remote resource such as
    a web page. `Read-Host` is an example of a cmdlet that reads things—in this case,
    information from the shell.'
  id: totrans-197
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`Get-Content` 是正确的。这个问题有点狡猾，因为 *PowerShell 命令的批准动词* 网页上指出，`Get` 应该保留用来获取有关对象的信息，而不是其内容。然而，`Get-Content`
    是正确的，因为我们是获取文件的内容，并将其作为一个对象保留，以供将来使用，而不是从远程资源（如网页）读取数据。`Read-Host` 是一个读取数据的 cmdlet
    示例——在这种情况下，它从 shell 中读取信息。'
- en: You should see the words `alive alive` printed on the screen. This is because
    `oh` is an alias for `Out-Host`, which takes an object—in this case, the string
    `alive alive`—and prints it to the default host, usually the screen.
  id: totrans-198
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你应该看到屏幕上打印出 `alive alive` 这两个词。这是因为 `oh` 是 `Out-Host` 的别名，它接收一个对象——在这种情况下是字符串
    `alive alive`——并将其打印到默认的主机，通常是屏幕上。
- en: '`Get-ChildItem` has two parameter sets. The parameter that determines which
    set you use is `-LiteralPath`.'
  id: totrans-199
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`Get-ChildItem` 有两个参数集。决定使用哪一组的参数是 `-LiteralPath`。'
- en: '`*.exe` is being passed to the `-filter` parameter. If you look at the help
    file, you can see that `-filter` is a positional parameter with a position of
    1, so the second value without a specified parameter will be understood as a filter
    argument.'
  id: totrans-200
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`*.exe` 被传递给 `-filter` 参数。如果查看帮助文件，你会看到 `-filter` 是一个位置参数，位置为1，因此没有指定参数的第二个值将被理解为过滤器参数。'
- en: No. the `-Filter` parameter only takes a single argument. If you want this cmdlet
    to run, then `Get-ChildItem c:\foo\* -include *.exe, *.txt` will work.
  id: totrans-201
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 不行。`-Filter` 参数只能接受一个参数。如果你希望这个 cmdlet 执行，`Get-ChildItem c:\foo\* -include *.exe,
    *.txt` 会有效。
- en: '`Find-module *aws*` will find lots of official modules for working with AWS,
    provided by Amazon.'
  id: totrans-202
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`Find-module *aws*` 将查找许多由 Amazon 提供的用于与 AWS 工作的官方模块。'
- en: At the time of writing, there aren’t any on the PowerShell Gallery, but there
    are some on GitHub. I’m not sure how official they are, though. Be wary.
  id: totrans-203
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 截至写作时，PowerShell Gallery 上没有，但 GitHub 上有一些。我不确定它们的官方性，使用时要小心。
- en: Holding the *Ctrl* key and scrolling the mouse wheel is the easiest temporary
    way of doing it. *Ctrl* and *+* (plus) or *Ctrl* and *-* (minus) will also do
    it. To change it permanently, open **Settings**, click on the profile you wish
    to change, and go into the **Appearance** subsection.
  id: totrans-204
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按住 *Ctrl* 键并滚动鼠标滚轮是最简单的临时方式。*Ctrl* 和 *+*（加号）或 *Ctrl* 和 *-*（减号）也可以实现。如果要永久更改，请打开**设置**，点击你想要更改的配置文件，进入**外观**子部分。
- en: '[Chapter 3](B17600_03.xhtml#_idTextAnchor049)'
  id: totrans-205
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '[第3章](B17600_03.xhtml#_idTextAnchor049)'
- en: Activities
  id: totrans-206
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 活动
- en: 'We can combine `-first`, `-last`, and `-skip` to do this, like so:'
  id: totrans-207
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以结合使用 `-first`、`-last` 和 `-skip` 来实现这一点，如下所示：
- en: '[PRE15]'
  id: totrans-208
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '![Figure A.3 – Output when we use first, last, and skip](img/B17600_Assessments_003.jpg)'
  id: totrans-209
  prefs: []
  type: TYPE_IMG
  zh: '![图 A.3 – 使用 first、last 和 skip 时的输出](img/B17600_Assessments_003.jpg)'
- en: Figure A.3 – Output when we use first, last, and skip
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 图 A.3 – 使用 first、last 和 skip 时的输出
- en: This is because `-contains` doesn’t support wildcards. The value must match
    exactly, except that it is not case sensitive.
  id: totrans-211
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这是因为 `-contains` 不支持通配符。值必须完全匹配，除了它不区分大小写。
- en: '`Get-Command -ParameterName filter` will do this for us. If you run it, you
    will see that there are lots of them. Most of them make use of the same `filter`
    block syntax we’ve been looking at in this chapter.'
  id: totrans-212
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`Get-Command -ParameterName filter` 会为我们完成此操作。如果你运行它，你会看到有很多这样的命令。它们大多数都使用我们在本章中看到的相同的
    `filter` 块语法。'
- en: Exercises
  id: totrans-213
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习
- en: '`Get-Command` will let us find the `Get-Date` cmdlet. Next, we need to use
    `Get-Member` to see the properties of the object that `Get-Date` produces. Finally,
    we need to use `Select-Object` to just show the `DayOfWeek` property – **Day**
    returns the day of the month.'
  id: totrans-214
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`Get-Command` 让我们可以找到 `Get-Date` cmdlet。接下来，我们需要使用 `Get-Member` 查看 `Get-Date`
    返回的对象的属性。最后，我们需要使用 `Select-Object` 只显示 `DayOfWeek` 属性 – **Day** 返回月份中的天数。'
- en: '`path` isn’t a property that is displayed when we run `Get-Process`, so we
    will need to use `Get-Member` to find it.'
  id: totrans-215
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`path` 不是我们运行 `Get-Process` 时显示的属性，所以我们需要使用 `Get-Member` 来查找它。'
- en: '**Get-Process | select-object name, cpu, path | sort-object** **path -descending**'
  id: totrans-216
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**Get-Process | select-object name, cpu, path | sort-object** **path -descending**'
- en: Simple.
  id: totrans-217
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 简单。
- en: '`Where-Object` needs to come early. Remember, *filter left*.'
  id: totrans-218
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`Where-Object` 需要尽早使用。记住，*过滤要从左侧开始*。'
- en: 'It’s best to make use of the filtering properties of a cmdlet rather than passing
    everything through the pipeline to `Where-Object`, so the following code is the
    most efficient way:'
  id: totrans-219
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最好利用 cmdlet 的过滤属性，而不是将所有内容通过管道传递给 `Where-Object`，因此以下代码是最有效的方式：
- en: '[PRE16]'
  id: totrans-220
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: ForEach-Object interactively.
  id: totrans-221
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 交互式的 ForEach-Object。
- en: '[PRE17]'
  id: totrans-222
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '`Get-Content` is the cmdlet you need, and we’ll be covering this in [*Chapter
    6*](B17600_06.xhtml#_idTextAnchor117), *PowerShell and Files – Reading, Writing,
    and Manipulating Data*. You will remember from the work we have done earlier in
    this chapter that the `-Name` parameter for `Get-Process` doesn’t accept objects
    `ByValue`, only `ByProcessName`, so we can’t use `Get-Content` to grab the list
    of names. Instead, we must use parentheses and feed them directly to the `-``Name`
    parameter.'
  id: totrans-223
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`Get-Content` 是你需要的 cmdlet，我们将在[*第6章*](B17600_06.xhtml#_idTextAnchor117)中详细讲解，*PowerShell
    与文件 – 读取、写入和操作数据*。你会记得在本章之前的工作中，`Get-Process`的`-Name`参数只接受`ByProcessName`，而不是对象`ByValue`，因此我们不能使用`Get-Content`来获取名称列表。相反，我们必须使用括号并将其直接传递给`-Name`参数。'
- en: 'It won’t run like that; although the `-computername` parameter accepts a `system.string`
    object, it does so `ByPropertyName`, not `ByValue`. The correct way to run this
    is as follows:'
  id: totrans-224
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这样无法运行；虽然 `-computername` 参数接受一个 `system.string` 对象，但它是通过 `ByPropertyName` 而不是
    `ByValue` 方式进行的。正确的运行方式如下：
- en: '[PRE18]'
  id: totrans-225
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: '[Chapter 4](B17600_04.xhtml#_idTextAnchor071)'
  id: totrans-226
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '[第 4 章](B17600_04.xhtml#_idTextAnchor071)'
- en: Activities
  id: totrans-227
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 活动
- en: It’s all about memory. As we mentioned, the stack has limited space, and value-type
    objects are held in the stack. Therefore, it makes sense to conserve memory as
    much as possible while being transparent to the human writing the code. `[Int64]`
    type objects take up twice as much space on the stack as `[Int32]` type objects.
  id: totrans-228
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这完全是关于内存的。如前所述，栈的空间有限，值类型对象存储在栈中。因此，在尽量节省内存的同时，对编写代码的人透明是有意义的。`[Int64]` 类型的对象在栈上占用的空间是
    `[Int32]` 类型对象的两倍。
- en: '`MyString` has been told to take the contents of `MyVariable`, the integer
    `42`, and treat it as a string. We can subsequently put an integer in `MyString`,
    because we didn’t constrain it in any way when we created it.'
  id: totrans-229
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`MyString` 被告知获取 `MyVariable` 的内容，即整数 `42`，并将其作为字符串处理。随后，我们可以将一个整数放入 `MyString`，因为在创建时我们没有对其进行任何限制。'
- en: Doing it the other way around, with `[string]$MyOtherString`, constrains `MyOtherString`
    to only be able to contain strings.
  id: totrans-230
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 反过来，用 `[string]$MyOtherString`，会将 `MyOtherString` 限制为只能包含字符串。
- en: Exercises
  id: totrans-231
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习
- en: There’s a space in there – spaces aren’t allowed. If we really must use a space
    in the variable name, then we must enclose it in curly braces – `{My Variable}`,
    which is arguably more work than using a variable name that doesn’t include a
    space.
  id: totrans-232
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 里面有一个空格——空格是不允许的。如果我们真的必须在变量名中使用空格，那么必须将其括在大括号中——`{My Variable}`，这比使用不包含空格的变量名可能更麻烦。
- en: '`System.Management.Automation.PSVariable`, `PSVariable`, or even `Variable`.'
  id: totrans-233
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`System.Management.Automation.PSVariable`、`PSVariable`，甚至是 `Variable`。'
- en: Use the preference variable `$ErrorView`. By default, it is set to `ConciseView`,
    a shorter, reader-friendly message containing just the error. This was introduced
    in PowerShell 7.0 and replaced a slightly more oblique format. This old format
    can still be seen by setting `$ErrorView` to `NormalView`. Interestingly, the
    PowerShell documentation lists `$ErrorView` as both a preference and an automatic
    variable – I suspect this is wrong; I think it’s a preference variable.
  id: totrans-234
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用首选项变量 `$ErrorView`。默认情况下，它设置为 `ConciseView`，这是一个较短、便于阅读的消息，只包含错误信息。这个功能是在
    PowerShell 7.0 中引入的，取代了稍显模糊的格式。我们仍然可以通过将 `$ErrorView` 设置为 `NormalView` 来查看旧格式。有趣的是，PowerShell
    文档将 `$ErrorView` 列为首选项变量和自动变量——我怀疑这是错误的；我认为它是一个首选项变量。
- en: '`$Null` will do this. `$Null` is different from 0 and is still a value; it’s
    just an empty value.'
  id: totrans-235
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`$Null` 会这样做。`$Null` 与 0 不同，它仍然是一个值，只是一个空值。'
- en: 'We can use the `CompareTo()` method. This will give us three possible outputs:
    `0` if the integers are the same, `-1` if the first integer is smaller than the
    second, or `1` if it is larger. Try the following:'
  id: totrans-236
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以使用 `CompareTo()` 方法。这将给我们三个可能的输出：如果整数相同，则为 `0`；如果第一个整数小于第二个，则为 `-1`；如果第一个整数大于第二个，则为
    `1`。尝试以下操作：
- en: '[PRE19]'
  id: totrans-237
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: This sort of thing will come in handy in the next chapter, [*Chapter 5*](B17600_05.xhtml#_idTextAnchor096),
    *PowerShell Control Flow – Conditionals and Loops*, where we will be looking at
    conditional statements.
  id: totrans-238
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这种用法将在下一章中派上用场，[*第 5 章*](B17600_05.xhtml#_idTextAnchor096)，*PowerShell 控制流 –
    条件语句与循环*，我们将在其中探讨条件语句。
- en: It’s a `System.Array` object or array.
  id: totrans-239
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 它是一个 `System.Array` 对象或数组。
- en: '`MyString.ToCharArray()` will output each `char` as an element of an array
    on a separate line.PowerShell Variables and Data Structures 34'
  id: totrans-240
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`MyString.ToCharArray()` 将把每个 `char` 输出为数组中的一个元素，并且每个元素占一行。'
- en: Because we are only using single quote marks, the output will be `My Name is
    $MyName`. If we want the variable to be expanded, we must use double quotes.
  id: totrans-241
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 因为我们只使用了单引号，所以输出将是 `My Name is $MyName`。如果我们希望变量被展开，就必须使用双引号。
- en: 'This is the `TypeName` of an ordered hashtable, and we can create it using
    the `[ordered]` accelerator. Remember, this goes on the right-hand side of the
    statement, not the left, like so:'
  id: totrans-242
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这是一个有序哈希表的 `TypeName`，我们可以使用 `[ordered]` 加速器来创建它。记住，这个放在语句的右侧，而不是左侧，像这样：
- en: '[PRE20]'
  id: totrans-243
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: '[Chapter 5](B17600_05.xhtml#_idTextAnchor096)'
  id: totrans-244
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '[第 5 章](B17600_05.xhtml#_idTextAnchor096)'
- en: Activities
  id: totrans-245
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 活动
- en: Because the switch is `7 { Write-Output 'contains 7' }`, which is looking for
    an integer. The line it is searching is a string, and so contains no integers.
    If we replaced the `7` in the `switch` statement with `'*7'`, making it a string,
    then it would work.
  id: totrans-246
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 因为这个 `switch` 是 `7 { Write-Output 'contains 7' }`，它在查找一个整数，而它正在搜索的这一行是一个字符串，因此没有包含任何整数。如果我们把
    `switch` 语句中的 `7` 替换为 `'*7'`，使其成为一个字符串，那么它就能正常工作。
- en: It’s because we’re executing the increment statement before we write the output.
    Switching the two statements around would demonstrate that the scriptblock doesn’t
    execute when the condition isn’t met.
  id: totrans-247
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这是因为我们在输出之前执行了递增语句。如果交换这两个语句，便能证明当条件不满足时，脚本块并不会执行。
- en: Exercises
  id: totrans-248
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习
- en: None. The statement only produces output if `$x` is larger than 4\. There is
    no `else` statement here to produce alternative output. This is a true conditional
    statement, rather than a conditional that provides alternate flows.
  id: totrans-249
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 没有。该语句只有在`$x`大于4时才会产生输出。这里没有`else`语句来提供替代的输出。这是一个真正的条件语句，而不是提供替代流程的条件语句。
- en: '`$x = 4 ; IF ($x -gt 4) {Write-Host ''$x is larger than 4''}Else {Write-Host
    ''$x is not larger` `than 4''}`'
  id: totrans-250
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`$x = 4 ; IF ($x -gt 4) {Write-Host ''$x is larger than 4''}Else {Write-Host
    ''$x is not larger` `than 4''}`'
- en: '`$x = 4 ; IF ($x -gt 4) {Write-Host ''$x is larger than 4''}elseif ($x -lt
    4) {Write-Host ''$x is smaller than 4''} Else {Write-Host ''$x` `is 4''}`'
  id: totrans-251
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`$x = 4 ; IF ($x -gt 4) {Write-Host ''$x is larger than 4''}elseif ($x -lt
    4) {Write-Host ''$x is smaller than 4''} Else {Write-Host ''$x` `is 4''}`'
- en: '`$x = 4 ; ($x -gt 4) ? (Write-Host ''$x is larger than 4'') : (Write-Host ''$x
    is not larger` `than 4'')`'
  id: totrans-252
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`$x = 4 ; ($x -gt 4) ? (Write-Host ''$x is larger than 4'') : (Write-Host ''$x
    is not larger` `than 4'')`'
- en: 'Because `foreach` is after a pipe character, there is only a single statement
    here, and `foreach` is interpreted as an alias of `ForEach-Object`, so the syntax
    is wrong. We can make it right by replacing the pipe character with a semicolon.
    This separates it into two statements, and `foreach` is correctly interpreted:'
  id: totrans-253
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由于`foreach`位于管道字符之后，这里只有一个语句，并且`foreach`被解释为`ForEach-Object`的别名，因此语法是错误的。我们可以通过将管道字符替换为分号来纠正它。这将其分为两个语句，`foreach`被正确地解释：
- en: '[PRE21]'
  id: totrans-254
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: '`number = 0 ; Do {$number ++ ; Write-Host "Number is $number"} While (!($number
    -eq 5))` will work. We’ll see that construction using the `not` operator alias
    (`!`) to reverse a statement quite often.'
  id: totrans-255
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`number = 0 ; Do {$number ++ ; Write-Host "Number is $number"} While (!($number
    -eq 5))`将能正常工作。我们会看到使用`not`运算符别名（`!`）来反转语句的结构会很常见。'
- en: 't’s missing the iterator. This will work: `for ($i = 0 ; $i -lt 5 ; $i ++)
    {``Write-Host $i}.`'
  id: totrans-256
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 它缺少迭代器。这样写就能正常工作：`for ($i = 0 ; $i -lt 5 ; $i ++) {``Write-Host $i}.`
- en: '`switch` statements. Using them outside loops and `switch` statements can lead
    to unpredictable outcomes.'
  id: totrans-257
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`switch`语句。将它们用于循环外部或`switch`语句中可能会导致不可预测的结果。'
- en: 'There are a few ways to do this; any that work are right, but my solution involves
    substituting a `for` loop instead of the existing `while` loop to implement the
    counter. I’ve also added an extra `elseif` statement to handle a winning condition,
    like this:'
  id: totrans-258
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 有几种方法可以实现这个；任何有效的方式都是对的，但我的解决方案是用`for`循环替换现有的`while`循环来实现计数器。我还添加了一个额外的`elseif`语句来处理胜利条件，像这样：
- en: '![Figure A.4 – Guess limited Brucie](img/B17600_Assessments_004.jpg)'
  id: totrans-259
  prefs: []
  type: TYPE_IMG
  zh: '![图A.4 – 猜限量布鲁西](img/B17600_Assessments_004.jpg)'
- en: Figure A.4 – Guess limited Brucie
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 图A.4 – 猜限量布鲁西
- en: There are lots of ways of writing this on the internet – I’ve chosen this way
    just to use concepts that we’ve covered in this chapter.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 网络上有很多写法——我选择了这种方式，主要是使用了我们在本章中介绍的概念。
- en: '[Chapter 6](B17600_06.xhtml#_idTextAnchor117)'
  id: totrans-262
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '[第6章](B17600_06.xhtml#_idTextAnchor117)'
- en: Activity
  id: totrans-263
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 活动
- en: 'This is just one way of doing it. If you got something different that worked,
    well done. That’s the right way – one of them, anyway. According to *Exercises
    in Programming Style*, there are at least 41 others:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 这只是实现的方法之一。如果你有其他有效的做法，恭喜你。那也是正确的方式——至少是其中之一。根据*编程风格练习*，至少有41种其他方法：
- en: '[PRE22]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Here it is running:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是运行的结果：
- en: '![Figure A.5 – The ten most frequent words in an English translation of The
    Trial](img/B17600_Assessments_005.jpg)'
  id: totrans-267
  prefs: []
  type: TYPE_IMG
  zh: '![图A.5 – 《审判》英文版中最常见的十个单词](img/B17600_Assessments_005.jpg)'
- en: Figure A.5 – The ten most frequent words in an English translation of The Trial
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 图A.5 – 《审判》英文版中最常见的十个单词
- en: 'Let’s step through it quickly:'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们快速地回顾一下：
- en: Lines 1 and 2 bring our two files into PowerShell using `Get-Content`, in `Raw`
    format as single strings.
  id: totrans-270
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第1行和第2行使用`Get-Content`将我们的两个文件导入PowerShell，以`Raw`格式作为单一字符串。
- en: Line 3 adds some extra delimiters and removes empty strings. I don’t expect
    you to know about the string split options, so I gave you this in the hint.
  id: totrans-271
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第3行添加了一些额外的分隔符并移除了空字符串。我不指望你了解字符串拆分选项，所以我在提示中给了你这个信息。
- en: Line 5 creates an empty array list to hold interesting words; if we used a PowerShell
    array, this would be painfully slow.
  id: totrans-272
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第5行创建了一个空的数组列表来存储有趣的单词；如果我们使用PowerShell数组，这将非常缓慢。
- en: Line 7 starts a `Foreach` loop to step through each word in `$TrialWords`.
  id: totrans-273
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第7行开始了一个`Foreach`循环，遍历`$TrialWords`中的每个单词。
- en: Line 8 creates a variable and casts each word to lowercase into it each time
    the loop repeats.
  id: totrans-274
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 行 8 创建了一个变量，并且每次循环重复时，都将每个单词转换为小写。
- en: Line 9 starts an `if` statement matching the condition “`$Lword` is not in `$StopWords`.”
    Note we are using the `-Contains` method, which matches substrings in a single
    string, so it is searching the `$StopWords` string for substrings that match `$LWord`.
  id: totrans-275
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 行 9 开始一个 `if` 语句，匹配条件“`$Lword` 不在 `$StopWords` 中”。请注意，我们使用的是 `-Contains` 方法，它匹配单个字符串中的子字符串，因此它在
    `$StopWords` 字符串中搜索与 `$LWord` 匹配的子字符串。
- en: Line 10 adds `$Word` to the `$Words` array list if the condition is true.
  id: totrans-276
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果条件为真，行 10 会将 `$Word` 添加到 `$Words` 数组列表中。
- en: Line 13 groups and sorts the words in `$Words`.
  id: totrans-277
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 行 13 将 `$Words` 中的单词分组并排序。
- en: Line 14 returns the 10 most frequent words, in descending order.
  id: totrans-278
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 行 14 返回前 10 个最常见的单词，按降序排列。
- en: Exercises
  id: totrans-279
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习
- en: '**Get-Childitem -Path C:\Temp -File | Format-Wide -****Column 3**'
  id: totrans-280
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**Get-Childitem -Path C:\Temp -File | Format-Wide -****Column 3**'
- en: '**Get-Process | Format-Wide -column 5 | Where-Object id -****gt 100**'
  id: totrans-281
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**Get-Process | Format-Wide -column 5 | Where-Object id -****gt 100**'
- en: 'It will produce no output. Remember, **Format Right**. The correct code should
    be as follows:'
  id: totrans-282
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 它将不会产生任何输出。记住，**格式正确**。正确的代码应该如下：
- en: '[PRE23]'
  id: totrans-283
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: '**“I love PowerShell” | Out-File -****Path Q3.txt**'
  id: totrans-284
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**“我爱 PowerShell” | Out-File -****Path Q3.txt**'
- en: '**“Sooo much” | Out-File -Path** **Q3.txt -Append**'
  id: totrans-285
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**“Sooo much” | Out-File -Path** **Q3.txt -Append**'
- en: '**Get-ChildItem | Export-Csv -Path items.csv -****Delimiter “;”**'
  id: totrans-286
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**Get-ChildItem | Export-Csv -Path items.csv -****Delimiter “;”**'
- en: '**(****Get-ChildItem Function:).count**'
  id: totrans-287
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**(****Get-ChildItem 函数：).count**'
- en: '**Get-Content Q3.txt -Delimiter “ “** Or **(Get-Content** **Q3.txt).Split(“
    “)**'
  id: totrans-288
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**Get-Content Q3.txt -Delimiter “ “** 或 **(Get-Content** **Q3.txt).Split(“
    “)**'
- en: '`PSCustomObjects`.'
  id: totrans-289
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`PSCustomObjects`。'
- en: '**Import-Clixml: Element ‘Objs’ with namespace name ‘http:// schemas.microsoft.com/powershell/2004/04’
    was** **not found.**'
  id: totrans-290
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**Import-Clixml: 找不到命名空间名称为 ‘http:// schemas.microsoft.com/powershell/2004/04’
    的元素 ‘Objs’。**'
- en: The XML file we are trying to import wasn’t formatted correctly for the cmdlet
    or it isn’t a PowerShell object.
  id: totrans-291
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们尝试导入的 XML 文件格式不正确，无法被 cmdlet 识别，或者它不是 PowerShell 对象。
- en: '[Chapter 7](B17600_07.xhtml#_idTextAnchor140)'
  id: totrans-292
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '[第 7 章](B17600_07.xhtml#_idTextAnchor140)'
- en: Activity
  id: totrans-293
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 活动
- en: 'Here is my solution:'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我的解决方案：
- en: '![Figure A.6 – One solution](img/B17600_Assessments_006.jpg)'
  id: totrans-295
  prefs: []
  type: TYPE_IMG
  zh: '![图 A.6 – 一个解决方案](img/B17600_Assessments_006.jpg)'
- en: Figure A.6 – One solution
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 图 A.6 – 一个解决方案
- en: 'Line 2 grabs the data in JSON format from the API and puts it in a variable.
    If we look at the `$astronauts` variable, we can see it has two key-value pairs,
    `message` and `people`. `people` contains an array of JSON objects, which themselves
    have two key-value pairs; `name` and `craft`. We can see this in the following
    figure:'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 行 2 从 API 获取 JSON 格式的数据，并将其放入一个变量中。如果我们查看 `$astronauts` 变量，我们可以看到它有两个键值对，`message`
    和 `people`。`people` 包含一个 JSON 对象数组，这些对象本身有两个键值对；`name` 和 `craft`。我们可以在下图中看到这一点：
- en: '![Figure A.7 – Getting the JSON data](img/B17600_Assessments_007.jpg)'
  id: totrans-298
  prefs: []
  type: TYPE_IMG
  zh: '![图 A.7 – 获取 JSON 数据](img/B17600_Assessments_007.jpg)'
- en: Figure A.7 – Getting the JSON data
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 图 A.7 – 获取 JSON 数据
- en: So, we know the data we need are in the `$astronauts.people.name` key-value
    pair. All we need to do now is display it in a pleasing manner. We covered how
    to use `ConvertTo-Html` in [*Chapter 6*](B17600_06.xhtml#_idTextAnchor117), *PowerShell
    and Files – Reading, Writing, and Manipulating Data*, and this is the way I’ve
    chosen.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们知道所需的数据在 `$astronauts.people.name` 键值对中。现在我们只需要以一种愉悦的方式显示它。我们在 [*第 6 章*](B17600_06.xhtml#_idTextAnchor117)
    中讨论了如何使用 `ConvertTo-Html`，*PowerShell 和文件 - 读取、写入与处理数据*，这是我选择的方式。
- en: 'On line 5, we set up a `$params` hashtable so we can splat all the parameters
    we need. I’ve chosen to include a CSS stylesheet that displays a lovely image,
    but that’s not necessary. This is my CSS:'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 在第 5 行，我们设置了一个 `$params` 哈希表，这样就可以展开我们需要的所有参数。我选择包括一个 CSS 样式表来显示一张美丽的图片，但这是不必要的。这是我的
    CSS：
- en: '[PRE24]'
  id: totrans-302
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Finally, the magic happens on line 12\. We feed the values we are interested
    in into `ConvertTo- Html` via the pipeline and then use `Out-File` to write the
    HTML to a file. We can then open this file in the browser of our choosing.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，魔法发生在第 12 行。我们通过管道将感兴趣的值传递给 `ConvertTo- Html`，然后使用 `Out-File` 将 HTML 写入文件。之后，我们可以在我们选择的浏览器中打开此文件。
- en: Hopefully, this has shown you how easy it is to obtain, manipulate, and display
    data using an API.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 希望这已经向你展示了使用 API 获取、处理和显示数据是多么简单。
- en: Exercises
  id: totrans-305
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习
- en: '**Invoke-WebRequest -Uri ‘https://httpbin.org/delete’ -****Method Delete**'
  id: totrans-306
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**Invoke-WebRequest -Uri ‘https://httpbin.org/delete’ -****Method Delete**'
- en: We use the `-SessionVariable` parameter in the first request (usually a login
    request) to supply a string, and then, in subsequent requests, we supply the session
    variable as a variable using the `-``WebSession` parameter.
  id: totrans-307
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们在第一次请求（通常是登录请求）中使用`-SessionVariable`参数传递一个字符串，然后在后续的请求中，我们使用`-WebSession`参数作为变量传递会话变量。
- en: We can use the `-SkipCertificateCheck` parameter, but we should only do this
    if we’re really sure that the site is valid and not malicious.
  id: totrans-308
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以使用`-SkipCertificateCheck`参数，但只有在我们确定该站点有效且不具恶意时才应该这么做。
- en: The mistake we made is in encoding the token before supplying it via the header.
    Encode the token to supply it as a parameter and keep it in plain text for headers.
    This means that supplying it as a parameter is slightly more secure, but not all
    services will accept it that way.
  id: totrans-309
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们犯的错误是在通过请求头提供令牌之前对其进行编码。应该将令牌编码为参数并以明文形式提供给请求头。这意味着通过参数传递稍微更安全，但并不是所有服务都会接受这种方式。
- en: WebSocket APIs are usually stateful. This means information about the requestor
    is persisted through multiple requests; this makes it more complicated to use,
    as we need to persist session information, and susceptible to network conditions.
  id: totrans-310
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: WebSocket API 通常是有状态的。这意味着关于请求者的信息会在多个请求之间持续存在；这使得使用起来更加复杂，因为我们需要持续保存会话信息，而且也容易受到网络条件的影响。
- en: 'There are lots of ways to do this, but the most straightforward is probably
    this:'
  id: totrans-311
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 有很多方法可以做到这一点，但最直接的方法可能就是这个：
- en: '[PRE25]'
  id: totrans-312
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: We can either pass it a long string describing the custom schema using the `-Schema`
    parameter, or we can pass it a file location using `-SchemaFile`. You’re right!
    This isn’t in the chapter. You hopefully read the help file to get the answer.
  id: totrans-313
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以通过`-Schema`参数传递一个描述自定义模式的长字符串，或者我们可以通过`-SchemaFile`传递一个文件位置。你说得对！这一点没有在章节中提到。希望你通过阅读帮助文件找到了答案。
- en: '[Chapter 8](B17600_08.xhtml#_idTextAnchor162)'
  id: totrans-314
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '[第8章](B17600_08.xhtml#_idTextAnchor162)'
- en: Activities
  id: totrans-315
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 活动
- en: 'The easy way to do this is to create an `$Output` variable in the `Param()`
    block, and pass that as a parameter to the `Out-File` cmdlet in the script, like
    this:'
  id: totrans-316
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 做这件事的简单方法是在`Param()`块中创建一个`$Output`变量，然后将其作为参数传递给脚本中的`Out-File` cmdlet，像这样：
- en: '[PRE26]'
  id: totrans-317
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'The trouble with that is if we want to change the filename, we need to type
    both the filename and the path each time. It’s likely that we will want to change
    the filename far more often than we want to change the path. Let’s separate out
    the path and the filename like this:'
  id: totrans-318
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这样做的问题是，如果我们想更改文件名，每次都需要输入文件名和路径。我们更有可能更频繁地更改文件名，而不是更改路径。让我们像这样将路径和文件名分开：
- en: '![Figure A.8 – Separating the filename and file path](img/B17600_Assessments_008.jpg)'
  id: totrans-319
  prefs: []
  type: TYPE_IMG
  zh: '![图 A.8 – 分离文件名和文件路径](img/B17600_Assessments_008.jpg)'
- en: Figure A.8 – Separating the filename and file path
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 图 A.8 – 分离文件名和文件路径
- en: Now, we can just pass a different filename when we want to, and a different
    path if we want to, without having to type out the whole thing each time.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们只需在需要时传递一个不同的文件名，或者在需要时传递一个不同的路径，而不必每次都输入整个内容。
- en: 'From the help file of a cmdlet that has a parameter that takes multiple strings,
    we can see that the attribute contains an empty pair of square brackets, like
    this: `[string[]]`. That part is easy enough. We also need to process each element
    of the array that is then passed to the `-City` parameter. To do that, we’ll need
    a `foreach` loop as well, wrapped around the working part of the script.'
  id: totrans-322
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从一个具有可以接收多个字符串的参数的 cmdlet 帮助文件中，我们可以看到该属性包含一对空的方括号，像这样：[string[]]。这一部分相对简单。我们还需要处理传递给`-City`参数的数组中的每个元素。为了做到这一点，我们还需要一个`foreach`循环，将其包裹在脚本的工作部分周围。
- en: Finally, we’ll need some way of sending each city’s data to a separate output
    file. I’ve chosen to do that by passing the `$item` variable from the `foreach`
    loop. Here’s my solution. Yours may look different, but if it works, that’s great.
  id: totrans-323
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 最后，我们需要某种方式将每个城市的数据发送到单独的输出文件。我选择通过传递`foreach`循环中的`$item`变量来实现。以下是我的解决方案。你的方案可能会有所不同，但只要它能工作，那就太好了。
- en: '![Figure A.9 – Processing multiple cities](img/B17600_Assessments_009.jpg)'
  id: totrans-324
  prefs: []
  type: TYPE_IMG
  zh: '![图 A.9 – 处理多个城市](img/B17600_Assessments_009.jpg)'
- en: Figure A.9 – Processing multiple cities
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 图 A.9 – 处理多个城市
- en: In line `3`, I’ve added the `[string[]]` attribute to the `-City` parameter
    to allow it to take multiple strings.
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 在第`3`行，我已将`[string[]]`属性添加到`-City`参数中，以允许它接收多个字符串。
- en: I’ve opened a `foreach` loop on line `9` and closed it on line `22`. The lines
    in between will now be repeated for each `$item` in the array of strings held
    in the `$City` parameter. I’ve also indented the lines in between to make it easier
    to read.
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 我在第`9`行打开了一个`foreach`循环，并在第`22`行关闭。中间的行现在将为`$City`参数中包含的每个字符串`$item`重复。我还缩进了中间的行，以便更容易阅读。
- en: I’ve changed line `17` so that it uses the `$item` variable (the current city)
    rather than the array in `$City` because that would cause an error – the API only
    accepts a single string at a time.
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 我已将第`17`行更改为使用`$item`变量（当前城市），而不是`$City`中的数组，因为那样会导致错误——API一次只接受一个字符串。
- en: Finally, I’ve changed line `11` so that it sends each output to a file that
    includes the name of the city.
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我更改了第`11`行，使其将每个输出发送到一个包含城市名称的文件中。
- en: 'Here’s my example. Yours may differ but, hopefully, you’ve included warnings
    about needing the API key in advance:'
  id: totrans-330
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这是我的示例。你的可能不同，但希望你提前包含了关于需要API密钥的警告：
- en: '[PRE27]'
  id: totrans-331
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Exercises
  id: totrans-332
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习
- en: This might be because of a few settings, but let’s imagine it is the simplest;
    the execution policy is correct for you, but not for them. This implies that the
    `CurrentUser` policy is restricting them.
  id: totrans-333
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这可能是由于一些设置问题，但让我们假设它是最简单的情况：执行策略对你来说是正确的，但对他们来说不正确。这意味着`CurrentUser`策略在限制他们。
- en: 'Using the following should do it if the script was written on the local machine,
    or if we have signed it with a code-signing certificate on another machine:'
  id: totrans-334
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 使用以下方法应该可以，如果脚本是在本地机器上编写的，或者如果我们在另一台机器上使用代码签名证书签名过：
- en: '[PRE28]'
  id: totrans-335
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: The `-Maximum` parameter. I’m not aware of any *Dungeons and Dragons* dice that
    start at a number other than 1 (except for the d100, but we’ll come to that in
    a question shortly).
  id: totrans-336
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`-Maximum` 参数。我没有见过任何*龙与地下城*的骰子是从1以外的数字开始的（除了d100，但稍后我们会在一个问题中讨论它）。'
- en: 'Well, there are a few ways we could do it, but hopefully, you’ve come up with
    something like this:'
  id: totrans-337
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 嗯，我们可以有几种方法来做到这一点，但希望你能想出类似这样的解决方案：
- en: '[PRE29]'
  id: totrans-338
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: You don’t need to have the `CmdletBinding()` attribute in there, but I always
    put it in.
  id: totrans-339
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 你不需要在其中包含`CmdletBinding()`属性，但我总是会加上。
- en: 'It should be an integer, and we’d specify it with the `[``int]` attribute:'
  id: totrans-340
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 它应该是一个整数，我们会用`[``int]`属性来指定：
- en: '[PRE30]'
  id: totrans-341
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'So, if we read the link, we can see that we can assign the `ValidateSet` attribute
    to a parameter and pass it an array of legal values, which looks like this:'
  id: totrans-342
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 所以，如果我们阅读这个链接，我们可以看到我们可以将`ValidateSet`属性分配给一个参数，并传递一个合法值的数组，它看起来是这样的：
- en: '[PRE31]'
  id: totrans-343
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'To do this, we’re going to need a loop and to specify the number of times we
    run the loop with a parameter, then add the output of each loop to a running total.
    It might look like this:'
  id: totrans-344
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了做到这一点，我们需要一个循环，并通过参数指定运行循环的次数，然后将每次循环的输出添加到累积总和中。它可能像这样：
- en: '[PRE32]'
  id: totrans-345
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'This is because there is no default value assigned for `$Dice`. We could assign
    it a default, but it might be better to make it a mandatory parameter by adding
    `[Parameter(Mandatory)]` like this:'
  id: totrans-346
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这是因为没有为`$Dice`分配默认值。我们可以为它分配一个默认值，但更好的方法可能是通过添加`[Parameter(Mandatory)]`使其成为一个必需的参数，如下所示：
- en: '[PRE33]'
  id: totrans-347
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE33]'
- en: We could make both parameters mandatory and include a `HelpMessage` attribute
    that explains what to put for each parameter.
  id: totrans-348
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以使两个参数都成为必需参数，并包括一个`HelpMessage`属性，解释每个参数需要输入什么。
- en: So, the first thing to do is to add the value of `100` to the `ValidateSet`
    attribute of the `$``sides` parameter.
  id: totrans-349
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 所以，第一件事是将`100`的值添加到`$``sides`参数的`ValidateSet`属性中。
- en: 'Once that’s done, we need to treat the value of `100` differently, so we can’t
    just add it to the loop. I’ve used an `if` and an `else` statement. Here’s my
    resulting script:'
  id: totrans-350
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 完成后，我们需要以不同的方式处理`100`的值，所以不能只是将它添加到循环中。我使用了`if`和`else`语句。以下是我的最终脚本：
- en: '![Figure A.10 – My level 15 paladin will crush your chaotic evil cleric](img/B17600_Assessments_010.jpg)'
  id: totrans-351
  prefs: []
  type: TYPE_IMG
  zh: '![图A.10 – 我的15级圣武士会击败你的混乱邪恶牧师](img/B17600_Assessments_010.jpg)'
- en: Figure A.10 – My level 15 paladin will crush your chaotic evil cleric
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 图A.10 – 我的15级圣武士会击败你的混乱邪恶牧师
- en: Remember, there are lots of ways to do this; if your code is completely different
    to mine but it works, that’s fine.
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，有很多方法可以做到这一点；如果你的代码与我的完全不同，但它能正常工作，那也没问题。
- en: '[Chapter 9](B17600_09.xhtml#_idTextAnchor184)'
  id: totrans-354
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '[第9章](B17600_09.xhtml#_idTextAnchor184)'
- en: Activities
  id: totrans-355
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 活动
- en: 'Nothing, because our parameter is not written to accept pipeline input. As
    we discovered in [*Chapter 8*](B17600_08.xhtml#_idTextAnchor162), *Writing Our
    First Script – Turning Simple Cmdlets into Reusable Code*, to allow a parameter
    to accept pipeline input, we must add a parameter argument, like this:'
  id: totrans-356
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 没有任何效果，因为我们的参数没有写成接受管道输入。正如我们在 [*第8章*](B17600_08.xhtml#_idTextAnchor162) 中发现的，*编写我们的第一个脚本
    – 将简单的 Cmdlet 转化为可重用的代码*，要使参数接受管道输入，我们必须添加一个参数，如下所示：
- en: '![Figure A.11 –  Accepting values from the pipeline](img/B17600_Assessments_011.jpg)'
  id: totrans-357
  prefs: []
  type: TYPE_IMG
  zh: '![图 A.11 – 从管道接收值](img/B17600_Assessments_011.jpg)'
- en: Figure A.11 – Accepting values from the pipeline
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 图 A.11 – 从管道接收值
- en: On line `9`, we’ve added a `ValueFromPipeline` argument to the parameter, which
    allows it to accept values from the pipeline. We’ve also enclosed the function
    in a `process` block, opening on line `12` and closing on line `20`; if we don’t
    have a `process` block, then the function will only act on the last value in the
    pipeline.
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 在第 `9` 行，我们为参数添加了 `ValueFromPipeline` 参数，这样它就可以接受来自管道的值。我们还将函数包含在一个 `process`
    块中，在第 `12` 行打开，第 `20` 行关闭；如果没有 `process` 块，函数将仅作用于管道中的最后一个值。
- en: Because `Get-Random` only accepts one positional parameter, `-Maximum`. If we
    run it as previously, then the maximum will be set as `15`, and the cmdlet has
    no idea what to do with the `20` value. Similarly, `Get-Fifteen20 15 -maximum
    20` won’t work because the `-Maximum` parameter is already filled by the named
    value, `20`, so it doesn’t know what to do with the `15` value. `Get-Fifteen20
    -minimum 15 20` will work, however.
  id: totrans-360
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 因为 `Get-Random` 只接受一个位置参数，`-Maximum`。如果我们像之前那样运行，那么最大值将被设置为 `15`，而 cmdlet 不知道如何处理
    `20` 这个值。同样，`Get-Fifteen20 15 -maximum 20` 也无法正常工作，因为 `-Maximum` 参数已经由命名值 `20`
    填充，所以它不知道如何处理 `15` 这个值。然而，`Get-Fifteen20 -minimum 15 20` 是可以工作的。
- en: 'There are lots of ways to do this, as always. My method is as follows:'
  id: totrans-361
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这总是有很多方法可以做。我的方法如下：
- en: '[PRE34]'
  id: totrans-362
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE34]'
- en: I’ve created a function called `Remove-Log` that I can call in my script. I’ve
    created a variable called `$limit` that gets a date seven days less than when
    it is run. I then get all the items in the `C:\temp` directory that start with
    the string `MyLogFile`, using a wildcard. I’ve then filtered the list using `Where-Object`
    to select only the files older than my `$limit` date. Finally, I’ve piped that
    to `Remove-Item` with the `-Force` parameter to suppress any confirmations.
  id: totrans-363
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我创建了一个名为 `Remove-Log` 的函数， 我可以在脚本中调用它。我创建了一个名为 `$limit` 的变量，它获取运行时日期前七天的日期。然后我使用通配符从
    `C:\temp` 目录中获取所有以 `MyLogFile` 开头的项。接着我使用 `Where-Object` 对列表进行过滤，只选择早于 `$limit`
    日期的文件。最后，我将其管道传输到 `Remove-Item`，并使用 `-Force` 参数来抑制任何确认。
- en: Exercises
  id: totrans-364
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习
- en: Avoid Hasty Abstractions – it’s a software engineering principle that encourages
    us to only create an abstraction, such as a function, when we know we will need
    it and we know exactly what we need it to do.
  id: totrans-365
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 避免草率的抽象化 – 这是一个软件工程原则，鼓励我们仅在知道需要它并且确切知道它需要做什么时才创建抽象，例如函数。
- en: Because dot sourcing causes whatever it is calling to be run in the local, or
    parent, scope rather than the appropriate child scope.
  id: totrans-366
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 因为点源会导致被调用的内容在本地或父作用域中运行，而不是在适当的子作用域中运行。
- en: Because just calling the variable will produce the code in the scriptblock;
    it won’t run it. We need to use the `invoke()` method, the call operator, or the
    `Invoke-Command` cmdlet. What we shouldn’t do is dot source it without careful
    consideration.
  id: totrans-367
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 因为仅仅调用变量会产生脚本块中的代码；但它不会执行。我们需要使用 `invoke()` 方法、调用操作符或 `Invoke-Command` cmdlet。我们不应该在没有仔细考虑的情况下点源它。
- en: The `ValidatePattern` validation attribute should do it, but we’d need to use
    a regular expression. Ugh! Hopefully, you looked this up in the help file mentioned
    in the *Further* *reading* section.
  id: totrans-368
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`ValidatePattern` 验证属性应该能解决这个问题，但我们需要使用正则表达式。唉！希望你已经查阅了 *进一步阅读* 部分中提到的帮助文件。'
- en: Because filters expect pipeline input, and we haven’t supplied any. However,
    `365 | get-square` would work.
  id: totrans-369
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 因为过滤器期望管道输入，而我们没有提供任何输入。然而，`365 | get-square` 将是有效的。
- en: We’re preventing the `$number` variable from being accessed from another scope.
  id: totrans-370
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们正在防止 `$number` 变量从另一个作用域中访问。
- en: A function is named, whereas a scriptblock is anonymous.
  id: totrans-371
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 函数是有名字的，而脚本块是匿名的。
- en: We’re trying to feed a value through the pipeline, but there’s no parameter
    that accepts pipeline input. We need to either make it an advanced function and
    create a parameter that accepts pipeline input, or we need to use `$Args`.
  id: totrans-372
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们正尝试通过管道传递一个值，但没有参数接受管道输入。我们需要将其设置为高级函数并创建一个接受管道输入的参数，或者我们需要使用 `$Args`。
- en: 'We will write the function as follows:'
  id: totrans-373
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将按如下方式编写函数：
- en: '[PRE35]'
  id: totrans-374
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'We can use it like this:'
  id: totrans-375
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们可以这样使用它：
- en: '![Figure A.12 – Getting a root the easy way](img/B17600_Assessments_012.jpg)'
  id: totrans-376
  prefs: []
  type: TYPE_IMG
  zh: '![图 A.12 – 简单获取根的方式](img/B17600_Assessments_012.jpg)'
- en: Figure A.12 – Getting a root the easy way
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: 图 A.12 – 简单获取根的方式
- en: '[Chapter 10](B17600_10.xhtml#_idTextAnchor201)'
  id: totrans-378
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '[第 10 章](B17600_10.xhtml#_idTextAnchor201)'
- en: Activities
  id: totrans-379
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 活动
- en: The `-ErrorAction` parameter will override the `$ErrorActionPreference` variable,
    and the `nosuchfile` string will cause a terminating error. Because it’s a terminating
    error, the cmdlet will not process `bar.txt`.
  id: totrans-380
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`-ErrorAction` 参数将覆盖 `$ErrorActionPreference` 变量，而 `nosuchfile` 字符串将导致一个终止错误。由于这是一个终止错误，cmdlet
    将不会处理 `bar.txt`。'
- en: Because if there is an error, then the error object is put into the pipeline,
    replacing the string that caused the error.
  id: totrans-381
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 因为如果出现错误，错误对象会被放入管道中，替代导致错误的字符串。
- en: Exercises
  id: totrans-382
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习
- en: Terminating errors stop the script altogether. Non-terminating errors may stop
    the script from doing the current step, but PowerShell will move the script on
    to the next step.
  id: totrans-383
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 终止错误会完全停止脚本执行。非终止错误可能会停止脚本执行当前步骤，但 PowerShell 会继续执行脚本的下一步。
- en: Either with the `Get-Error` cmdlet, which displays the most recent error object,
    or with the `$Error` variable. This has an array of all the error objects created
    during a session up to a default maximum of 256.
  id: totrans-384
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 可以使用 `Get-Error` 命令，它会显示最近的错误对象，或者使用 `$Error` 变量。这个变量包含了会话期间创建的所有错误对象，默认最大数量为
    256。
- en: The `-ErrorActionPreference` variable allows us to set the default error action
    preference for all cmdlets and scripts running in a specific PowerShell session.
    It determines whether errors should be displayed, ignored, or handled in a specific
    way.
  id: totrans-385
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`-ErrorActionPreference` 变量允许我们为特定 PowerShell 会话中运行的所有 cmdlet 和脚本设置默认的错误处理偏好。它决定了错误是否应该显示、忽略，或者以特定方式处理。'
- en: The `Write-Error` cmdlet allows us to manually generate and display custom non-terminating
    error messages within a script. It is useful when we want to explicitly signal
    an error condition to the user or the calling code.
  id: totrans-386
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`Write-Error` cmdlet 允许我们手动生成并在脚本中显示自定义的非终止错误消息。当我们希望明确向用户或调用代码信号错误状态时，它非常有用。'
- en: To generate a terminating error that can be handled by a `try`/`catch` statement
    pair.
  id: totrans-387
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 生成一个终止错误，这个错误可以通过 `try`/`catch` 语句对进行处理。
- en: By either using the `-Debug` parameter with a cmdlet or advanced script or by
    setting the `$DebugPreference` variable to `Continue`; the default is `SilentlyContinue`.
  id: totrans-388
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 可以通过在 cmdlet 或高级脚本中使用 `-Debug` 参数，或者将 `$DebugPreference` 变量设置为 `Continue` 来启用调试；默认值是
    `SilentlyContinue`。
- en: By using the `Write-Debug` cmdlet in the script. Debug messages are for people
    who write code; error messages are for people who use code. As such, a debug message
    should include detailed information about what is going on in the script at that
    point, possibly including variable values and step counts.
  id: totrans-389
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过在脚本中使用 `Write-Debug` cmdlet。调试消息是为编写代码的人提供的；错误消息是为使用代码的人提供的。因此，调试消息应该包含有关脚本当前状态的详细信息，可能包括变量值和步骤计数。
- en: A breakpoint is a marker set in the script to pause its execution at a specific
    line or condition. It allows us to inspect the state of the script and variables
    at that point. A break point in tennis is quite different.
  id: totrans-390
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 断点是设置在脚本中的一个标记，用于在特定行或条件下暂停脚本执行。它允许我们检查该点时脚本和变量的状态。网球中的断点与此完全不同。
- en: It executes the current line of a script and moves on to the next line but treats
    whole functions as a single line. So, if the next line of code is a function,
    or we are currently in a function, then the whole function call will complete,
    rather than moving on to the next line in the function.
  id: totrans-391
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 它执行脚本的当前行并继续到下一行，但会把整个函数当作一行来执行。所以，如果下一行代码是一个函数，或者我们当前在一个函数中，那么整个函数调用会完成，而不是继续执行函数中的下一行。
- en: '[Chapter 11](B17600_11.xhtml#_idTextAnchor218)'
  id: totrans-392
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '[第 11 章](B17600_11.xhtml#_idTextAnchor218)'
- en: Activity
  id: totrans-393
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 活动
- en: Try running `Remove-Module` to get rid of the module we’ve just installed, and
    then running `Get-Square`. What happens? Why does this happen?
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试运行 `Remove-Module` 来移除我们刚刚安装的模块，然后运行 `Get-Square`。会发生什么？为什么会发生这种情况？
- en: 'The `Get-Square` cmdlet is still available. This is because we saved the module
    in the module path correctly; this means that PowerShell will autoload the module
    when we call a function in the module. We can see it working in the following
    screenshot:'
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: '`Get-Square` cmdlet 仍然可用。这是因为我们正确地将模块保存在模块路径中；这意味着当我们调用模块中的函数时，PowerShell 会自动加载该模块。我们可以在以下截图中看到它的工作原理：'
- en: '![Figure A.13 – Autoloading with PowerShell](img/B17600_Assessments_013.jpg)'
  id: totrans-396
  prefs: []
  type: TYPE_IMG
  zh: '![图 A.13 – 使用 PowerShell 自动加载](img/B17600_Assessments_013.jpg)'
- en: Figure A.13 – Autoloading with PowerShell
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
  zh: 图 A.13 – 使用 PowerShell 自动加载
- en: In the first line, I list the loaded modules. Then, I run `Get-Square 7`, which
    autoloads `MyFirstModule`. After that, I confirm that’s what happened by running
    `Get-Module` again. We can see that `Remove-Module` removes the `Get-Square` cmdlet
    by running it with the `-Verbose` switch in the last line.
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一行，我列出了加载的模块。然后，我运行 `Get-Square 7`，这将自动加载 `MyFirstModule`。之后，我通过再次运行 `Get-Module`
    确认了这一点。我们可以看到，通过在最后一行使用 `-Verbose` 开关运行 `Remove-Module`，它移除了 `Get-Square` cmdlet。
- en: Exercises
  id: totrans-399
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习
- en: '**Get-Module**'
  id: totrans-400
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**Get-Module**'
- en: It imports a module into the global scope. Note that when we import a module
    from the command prompt, it is already imported into the global scope – we use
    this when we’re importing a module from inside another module; a nested module.
  id: totrans-401
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 它将模块导入到全局作用域。请注意，当我们从命令提示符导入模块时，它已经被导入到全局作用域——我们在从另一个模块内部导入模块时会使用这一点；这就是嵌套模块的情况。
- en: We need to give the full path to the module in the `-Name` parameter of `Import-Module`.
  id: totrans-402
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们需要在 `Import-Module` 的 `-Name` 参数中提供模块的完整路径。
- en: Either use the `-NoClobber` parameter if they are not functions we want to use
    or use the `-Prefix` parameter if they are.
  id: totrans-403
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果它们不是我们要使用的函数，可以使用 `-NoClobber` 参数，或者如果是我们要使用的函数，可以使用 `-Prefix` 参数。
- en: Either with the `Export-ModuleMembers` cmdlet in the module file or with a module
    manifest.
  id: totrans-404
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 可以通过模块文件中的 `Export-ModuleMembers` cmdlet 或使用模块清单来实现。
- en: It provides a link to the online documentation for the module, allowing the
    help to be updated.
  id: totrans-405
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 它提供了一个指向模块在线文档的链接，允许帮助文档得到更新。
- en: In the context of a module, it might be either formatting information for function
    or cmdlet output, or it might be custom type information.
  id: totrans-406
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在模块的上下文中，它可能是函数或 cmdlet 输出的格式化信息，或者是自定义类型信息。
- en: We’ll get cmdlets; a `.dll` extension signifies a binary module, so the commands
    inside it will be of the `Cmdlet` type. Script modules contain commands of the
    `Function` type.
  id: totrans-407
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将获取 cmdlet；`.dll` 扩展名表示二进制模块，因此其中的命令将属于 `Cmdlet` 类型。脚本模块包含 `Function` 类型的命令。
- en: Because they are slow. The CDXML gets parsed to a PowerShell script, which then
    has to be interpreted.
  id: totrans-408
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 因为它们很慢。CDXML 会被解析成 PowerShell 脚本，然后该脚本需要被解释。
- en: '[Chapter 12](B17600_12.xhtml#_idTextAnchor236)'
  id: totrans-409
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '[第12章](B17600_12.xhtml#_idTextAnchor236)'
- en: Exercises
  id: totrans-410
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习
- en: '`New-PSSession` creates a persistent session, but an ad hoc session can be
    created with `Enter- PSSession`.'
  id: totrans-411
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`New-PSSession` 创建一个持久会话，但可以使用 `Enter-PSSession` 创建一个临时会话。'
- en: By using SSH.
  id: totrans-412
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过使用 SSH。
- en: The `AllSigned` execution policy only allows scripts signed by a trusted publisher
    to run.
  id: totrans-413
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`AllSigned` 执行策略只允许运行由受信发布者签名的脚本。'
- en: The `-ExecutionPolicy Bypass` switch is used to temporarily bypass an execution
    policy when running a script.
  id: totrans-414
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`-ExecutionPolicy Bypass` 开关用于在运行脚本时暂时绕过执行策略。'
- en: PowerShell AMSI.
  id: totrans-415
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: PowerShell AMSI。
- en: The constrained language mode is used to restrict access to dangerous cmdlets
    and scripting features in PowerShell.
  id: totrans-416
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 受限语言模式用于限制访问 PowerShell 中的危险 cmdlet 和脚本功能。
- en: By using JEA.
  id: totrans-417
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过使用 JEA。
- en: Script block logging records the content of script blocks executed in PowerShell,
    providing visibility into potentially malicious actions. It records the contents
    in the `PowerShellCore` operational event log in Windows and in the systemd log
    in Linux.
  id: totrans-418
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 脚本块日志记录会记录在 PowerShell 中执行的脚本块的内容，从而提供对潜在恶意操作的可视性。它将内容记录在 Windows 的 `PowerShellCore`
    操作事件日志中，在 Linux 中则记录在 systemd 日志中。
- en: A secure string is a PowerShell object of type `System.Security.SecureString`,
    and an encrypted string is a string object that has been encrypted with a key
    so that it cannot be read in a file.
  id: totrans-419
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 安全字符串是类型为 `System.Security.SecureString` 的 PowerShell 对象，已加密字符串是已使用密钥加密的字符串对象，因此无法在文件中读取。
- en: '[Chapter 13](B17600_13.xhtml#_idTextAnchor267)'
  id: totrans-420
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '[第13章](B17600_13.xhtml#_idTextAnchor267)'
- en: Activities
  id: totrans-421
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 活动
- en: 'We could write a fairly complicated cmdlet with `Invoke-CimMethod`, but that
    isn’t the best way to do it. Instead, we should use the cmdlet specifically written
    for this purpose, `Stop- Process`, with the `ProcessId` of the `notepad` process:'
  id: totrans-422
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以用`Invoke-CimMethod`编写一个相当复杂的cmdlet，但这不是最好的方法。相反，我们应该使用专门为此目的编写的cmdlet，`Stop-Process`，并指定`notepad`进程的`ProcessId`：
- en: '[PRE36]'
  id: totrans-423
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE36]'
- en: '![Figure A.14 – Setting a default printer with CIM commands](img/B17600_Assessments_014.jpg)'
  id: totrans-424
  prefs: []
  type: TYPE_IMG
  zh: '![图A.14 – 使用CIM命令设置默认打印机](img/B17600_Assessments_014.jpg)'
- en: Figure A.14 – Setting a default printer with CIM commands
  id: totrans-425
  prefs: []
  type: TYPE_NORMAL
  zh: 图A.14 – 使用CIM命令设置默认打印机
- en: In the first command, I put the printer object into a variable, then I used
    that variable as the input object for `Invoke-CimMethod` and invoked the `SetDefaultPrinter`
    method. The return value of `0` indicates success.
  id: totrans-426
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一个命令中，我将打印机对象放入一个变量中，然后使用该变量作为`Invoke-CimMethod`的输入对象，并调用`SetDefaultPrinter`方法。返回值`0`表示成功。
- en: 'Note that the `SetDefaultPrinter` method doesn’t appear on the `$printer` variable.
    Unfortunately, we need to read the documentation to discover this method:'
  id: totrans-427
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，`SetDefaultPrinter`方法没有出现在`$printer`变量中。不幸的是，我们需要阅读文档来发现这个方法：
- en: '[https://learn.microsoft.com/en-us/windows/win32/cimwin32prov/win32-printer-methods](https://learn.microsoft.com/en-us/windows/win32/cimwin32prov/win32-printer-methods)'
  id: totrans-428
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://learn.microsoft.com/en-us/windows/win32/cimwin32prov/win32-printer-methods](https://learn.microsoft.com/en-us/windows/win32/cimwin32prov/win32-printer-methods)'
- en: '[https://learn.microsoft.com/en-us/windows/win32/cimwin32prov/setdefaultprinter-method-in-class-win32-printer](https://learn.microsoft.com/en-us/windows/win32/cimwin32prov/setdefaultprinter-method-in-class-win32-printer)'
  id: totrans-429
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://learn.microsoft.com/en-us/windows/win32/cimwin32prov/setdefaultprinter-method-in-class-win32-printer](https://learn.microsoft.com/en-us/windows/win32/cimwin32prov/setdefaultprinter-method-in-class-win32-printer)'
- en: Exercises
  id: totrans-430
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习
- en: Manifest modules.
  id: totrans-431
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 显示模块。
- en: It may have been written before PowerShell Core was released, the author may
    not have included compatibility information in the manifest, or it may not be
    a manifest module.
  id: totrans-432
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 它可能是在PowerShell Core发布之前编写的，作者可能没有在清单中包含兼容性信息，或者它可能不是一个清单模块。
- en: Windows PowerShell 5.1.
  id: totrans-433
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Windows PowerShell 5.1。
- en: Deserialized ones.
  id: totrans-434
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 反序列化的对象。
- en: Use the `-``UseWindowsPowershell` parameter.
  id: totrans-435
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`-` `UseWindowsPowershell`参数。
- en: '`__NAMESPACE`'
  id: totrans-436
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`__NAMESPACE`'
- en: It allows us to specify a different timeout when querying remote machines, as
    the default is 3 minutes per machine.
  id: totrans-437
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 它允许我们在查询远程机器时指定不同的超时时间，因为默认情况下每台机器的超时时间是3分钟。
- en: Possibly we could use `Set-CimInstance`, but because many properties are not
    writable, we more likely will use `Invoke-CimMethod`.
  id: totrans-438
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可能可以使用`Set-CimInstance`，但由于许多属性是不可写的，我们更可能会使用`Invoke-CimMethod`。
- en: We pass them as an i`Dictionary` hash table to the `-``Arguments` parameter.
  id: totrans-439
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将它们作为`Dictionary`哈希表传递给`-` `Arguments`参数。
- en: '[Chapter 14](B17600_14.xhtml#_idTextAnchor280)'
  id: totrans-440
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '[第14章](B17600_14.xhtml#_idTextAnchor280)'
- en: Activity
  id: totrans-441
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 活动
- en: 'Because PowerShell is very forgiving about file path separators, the only bit
    of code that needs to be different depending on the platform is how we get the
    name of the machine. Everything else is straightforward. Here’s my solution; yours
    could be very different and still achieve the task:'
  id: totrans-442
  prefs: []
  type: TYPE_NORMAL
  zh: 由于PowerShell对于文件路径分隔符非常宽容，唯一需要根据平台不同而不同的代码部分是如何获取机器名称。其他部分非常简单。这是我的解决方案；你的解决方案可能会有很大不同，但仍能完成任务：
- en: '[PRE37]'
  id: totrans-443
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Because we need to use different ways to get the machine name, those two lines
    are within `if` statements. Everything else works the same on Linux and Windows,
    so it’s very straightforward. This is how it looks running on my CentOS box:'
  id: totrans-444
  prefs: []
  type: TYPE_NORMAL
  zh: 因为我们需要使用不同的方法来获取机器名称，所以这两行代码位于`if`语句中。其他部分在Linux和Windows上工作相同，所以非常简单。这是在我的CentOS机器上运行时的样子：
- en: '![Figure A.15 – Running a cross-platform script on CentOS](img/B17600_Assessments_015.jpg)'
  id: totrans-445
  prefs: []
  type: TYPE_IMG
  zh: '![图A.15 – 在CentOS上运行跨平台脚本](img/B17600_Assessments_015.jpg)'
- en: Figure A.15 – Running a cross-platform script on CentOS
  id: totrans-446
  prefs: []
  type: TYPE_NORMAL
  zh: 图A.15 – 在CentOS上运行跨平台脚本
- en: As we can see, it works just fine. The script would be better for some error
    checking; for instance, what if both automatic variables are `false`?
  id: totrans-447
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，它运行得很好。这个脚本可以加入一些错误检查；例如，如果两个自动变量都是`false`，该怎么办？
- en: Exercises
  id: totrans-448
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习
- en: The internet. As with most Linux distributions, Kali Linux is not supported
    by Microsoft.
  id: totrans-449
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 互联网。与大多数Linux发行版一样，Kali Linux不受Microsoft支持。
- en: Trick question. We are actually calling the `ls` Bash command on Linux. When
    we type it on Windows, we are calling `Get-ChildItem` via the `ls` alias.
  id: totrans-450
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 诱导性问题。实际上，我们在Linux上调用的是`ls` Bash命令。当我们在Windows上输入它时，实际上是通过`ls`别名调用`Get-ChildItem`。
- en: Either `\` or `/`. It doesn’t matter, thankfully. This means it’s a lot easier
    to write cross-platform scripts.
  id: totrans-451
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 无论是`\`还是`/`，都可以，幸运的是。这意味着编写跨平台脚本变得更加容易。
- en: By calling the `$IsMacOS` variable. If it returns `true`, then we are running
    on macOS.
  id: totrans-452
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过调用`$IsMacOS`变量。如果返回`true`，那么我们就在macOS上运行。
- en: By starting PowerShell with the `sudo pwsh` command. There is no way to elevate
    privilege during a PowerShell session.
  id: totrans-453
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过使用`sudo pwsh`命令启动PowerShell。PowerShell会话中没有提升权限的方式。
- en: '`New-PSSession` with the `-``HostName` parameter.'
  id: totrans-454
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用带有`-``HostName`参数的`New-PSSession`。
- en: '`New-PSSession` and the `-``KeyFilePath` parameter.'
  id: totrans-455
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用带有`-``KeyFilePath`参数的`New-PSSession`。
- en: It’s a file transfer program that is included in the PowerShell 7 packages.
  id: totrans-456
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这是一个文件传输程序，包含在PowerShell 7的安装包中。
- en: Ed25519 is a recent, more secure encryption algorithm for digital signatures
    based on public/private keys.
  id: totrans-457
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Ed25519是一种基于公钥/私钥的数字签名加密算法，较新且更安全。
- en: '[Chapter 15](B17600_15.xhtml#_idTextAnchor302)'
  id: totrans-458
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '[第15章](B17600_15.xhtml#_idTextAnchor302)'
- en: Answers
  id: totrans-459
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 答案
- en: Because the Zero and Pico use an ARMv6 chip architecture, which isn’t compatible
    with .NET since it requires ARMv7 or ARMv8.
  id: totrans-460
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 因为Zero和Pico使用ARMv6芯片架构，这与.NET不兼容，因为.NET要求ARMv7或ARMv8架构。
- en: Either `C:\Users\<username>\.sshconfig` or `C:\ProgramData\ssh\ssh_config`.
  id: totrans-461
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 无论是`C:\Users\<用户名>\.sshconfig`还是`C:\ProgramData\ssh\ssh_config`。
- en: '**Test-NetConnection**'
  id: totrans-462
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**Test-NetConnection**'
- en: '**ssh <username>@<hostname>**'
  id: totrans-463
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**ssh <用户名>@<主机名>**'
- en: '**sudo** **bash ./install.sh**'
  id: totrans-464
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**sudo** **bash ./install.sh**'
- en: Because it’s a pain typing `~/powershell/pwsh`.
  id: totrans-465
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 因为每次都输入`~/powershell/pwsh`很麻烦。
- en: '**sudo ln -s ~/****powershell/pwsh /usr/bin/pwsh**'
  id: totrans-466
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**sudo ln -s ~/****powershell/pwsh /usr/bin/pwsh**'
- en: Use the `-Raw` switch parameter with the `Get-GpioPin` cmdlet.
  id: totrans-467
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用带有`-Raw`开关参数的`Get-GpioPin` cmdlet。
- en: Debian Linux, similar to Ubuntu.
  id: totrans-468
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Debian Linux，类似于Ubuntu。
- en: '[Chapter 16](B17600_16.xhtml#_idTextAnchor320)'
  id: totrans-469
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '[第16章](B17600_16.xhtml#_idTextAnchor320)'
- en: Exercises
  id: totrans-470
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习
- en: '**$object = New-Object -****TypeName Namespace.ClassName**'
  id: totrans-471
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**$object = New-Object -****TypeName Namespace.ClassName**'
- en: '**Add-Type -****AssemblyName “AssemblyName”**'
  id: totrans-472
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**Add-Type -****AssemblyName “AssemblyName”**'
- en: '**[****Namespace.ClassName]::MethodName()**'
  id: totrans-473
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**[****Namespace.ClassName]::MethodName()**'
- en: '**[****Namespace.ClassName]::PropertyName**'
  id: totrans-474
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**[****Namespace.ClassName]::PropertyName**'
- en: '**$object = New-Object -TypeName Namespace.ClassName -ArgumentList (arg1,**
    **arg2, ...)**'
  id: totrans-475
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**$object = New-Object -TypeName Namespace.ClassName -ArgumentList (arg1,**
    **arg2, ...)**'
- en: '**Add-Type -****Path “Path\To\Assembly.dll”**'
  id: totrans-476
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**Add-Type -****Path “Path\To\Assembly.dll”**'
- en: '**Using $object.GetType()**'
  id: totrans-477
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**使用 $object.GetType()**'
- en: '**$object | Get-Member -****MemberType Method**'
  id: totrans-478
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**$object | Get-Member -****MemberType Method**'
- en: '**$****object.MethodName()**'
  id: totrans-479
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**$****object.MethodName()**'
- en: '**$****object.PropertyName**'
  id: totrans-480
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**$****object.PropertyName**'
