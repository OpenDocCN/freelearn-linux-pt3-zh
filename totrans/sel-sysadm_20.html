<html><head></head><body><div id="sbo-rt-content" class="calibre1"><div id="_idContainer047" class="calibre2">
			<h1 id="_idParaDest-404" class="calibre5"><a id="_idTextAnchor409" class="pcalibre calibre6 pcalibre1"/>Assessments</h1>
			<div class="calibre11" id="calibre_pb_0"/>
</div>
	</div>

<div id="sbo-rt-content" class="calibre1">
<div id="_idContainer047" class="calibre2">
<h1 id="_idParaDest-405" class="calibre5"><em class="italic"><a id="_idTextAnchor410" class="pcalibre calibre6 pcalibre1"/></em><a href="B16276_01_Final_VK.xhtml#_idTextAnchor018" class="pcalibre calibre6 pcalibre1"><em class="italic">Chapter 1</em></a></h1>
			<ol class="calibre18">
				<li class="calibre9">The most important difference is that, with a DAC system, the user has full control over who gets which kind of access to the user's data. It is left to the discretion of the user, hence the name. With MAC systems, the system administrator (or security administrator) defines how accesses are handled and enforced. Access is mandated by a policy, and users cannot work around this if the administrator does not allow it.</li>
				<li class="calibre9">Linux has introduced hooks inside its kernel code, which developers can subscribe to with their own code. These hooks are part of the <strong class="bold">Linux Security Module</strong> (<strong class="bold">LSM</strong>) framework, an extensible framework that is natively part of the Linux kernel.<p class="calibre3">SELinux is one of the MAC technologies that use this LSM framework (and the hooks it offers) to provide mandatory access control capabilities to the Linux kernel and its applications. Other technologies also exist, including AppArmor.</p><p class="calibre3">The SELinux subsystem code itself is also made part of the main Linux kernel, as are the main other LSM implementations, although this is not a mandatory requirement for LSM-capable technologies. It does, however, support the notion that SELinux is a well-established, open source technology.</p></li>
				<li class="calibre9">The four fields of an SELinux context are as follows: the SELinux user, the SELinux role, the SELinux type, and the sensitivity level (or the sensitivity range). The sensitivity level might not always be present: Linux distributions might opt to disable support for sensitivities in their policies. In that case, the SELinux context will only have the first three fields.</li>
				<li class="calibre9">SELinux has the concept of a role, which SELinux types can be associated with. As SELinux mostly focuses on the types to handle its enforcement (SELinux is mostly a type enforcement system), the role-based access control is implemented by limiting the types that a role can be associated with.<p class="calibre3">A user that has a DBA-related role will only be able to interact with the system from within DBA-associated types. As that role does not have any associations with other types, the user cannot acquire the privileges of these other types either.</p></li>
				<li class="calibre9">While there is a project called the reference policy, most Linux distributions will deviate from this policy for several reasons. The main reason why no single SELinux policy exists is because SELinux is a fine-grained system, and thus can be tweaked and adjusted to fit the design and usage principles of a Linux distribution.<p class="calibre3">Asking why no single SELinux policy exists for all Linux distributions is almost the same as asking why there are multiple Linux distributions. Each distribution has its own focus, design, principles, and decisions behind it, and the SELinux policy needs to be aligned with these in order to be successful.</p></li>
			</ol>
			<div class="calibre11" id="calibre_pb_1"/>
</div>
	</div>

<div id="sbo-rt-content" class="calibre1">
<div id="_idContainer047" class="calibre2">
<h1 id="_idParaDest-406" class="calibre5"><em class="italic"><a id="_idTextAnchor411" class="pcalibre calibre6 pcalibre1"/></em><a href="B16276_02_Final_VK.xhtml#_idTextAnchor045" class="pcalibre calibre6 pcalibre1"><em class="italic">Chapter 2</em></a></h1>
			<ol class="calibre18">
				<li value="1" class="calibre9">Administrators should first analyze the situation to see why a problem is being triggered. Perhaps the problem is due to an incorrectly assigned context, or the process has not been started using the correct methods.<p class="calibre3">If the denial itself were to be allowed, administrators should create an update to the SELinux policy (just like they would update firewall rules as required).</p><p class="calibre3">If this is not feasible, then administrators should consider putting SELinux in permissive mode, but only for that particular application that is causing problems.</p><p class="calibre3">If that is also not feasible, then administrators should put the system in permissive mode, but making sure that this is accepted by the organization and security principles of the environment.</p><p class="calibre3">Only if even this is not feasible or solves the problem should an administrator shake their head, curse the higher powers, and disable SELinux.</p></li>
				<li class="calibre9">If the system has the audit daemon running, then SELinux logging will be part of the audit logs. They can be displayed using tools such as <strong class="source-inline">ausearch</strong>, or read directly from the system at <strong class="source-inline">/var/log/audit</strong>.<p class="calibre3">If no audit daemon is running, then the SELinux log events will be picked up by the system logger or be available through the kernel ring buffer. The kernel ring buffer can be read using the <strong class="source-inline">dmesg</strong> command. If the system logger is picking up the events, they will most likely reside in <strong class="source-inline">/var/log/messages</strong>.</p></li>
				<li class="calibre9">Applications that actively query the SELinux policy or SELinux system will link with the <strong class="source-inline">libselinux</strong> library. If that is the case, then this can be seen using <strong class="source-inline">readelf</strong>, <strong class="source-inline">ldd,</strong> or <strong class="source-inline">objdump</strong>, showing that <strong class="source-inline">/lib64/libselinux.so.1</strong> (or similar) is used:<p class="source-code"><strong class="bold">$ ldd /bin/ls | grep selinux</strong></p><p class="source-code"><strong class="bold">libselinux.so.1 =&gt; /lib64/libselinux.so.1 </strong><strong class="bold">(0x00005d415f3f03f0)</strong></p><p class="calibre3">While applications could build statically (meaning they include the necessary code in their final build and will not show any dynamic linking with the <strong class="source-inline">libselinux</strong> library), this is more the exception than the rule for most Linux systems.</p></li>
				<li class="calibre9">The AVC, or Access Vector Cache, is a cache that contains the recent and most frequently used enforcement checks, allowing the SELinux subsystem to query more rapidly whether an action can be granted. Without the AVC, the SELinux subsystem would need to go through the entire policy over and over again for each action that is taken on the system.<p class="calibre3">Suffice to say that this would slow down the system tremendously.</p></li>
				<li class="calibre9">No, there are a couple of other log events that administrators should look out for when specifically dealing with SELinux. One is <strong class="source-inline">USER_AVC</strong>, which is used for AVC-like events, but triggered from an application that uses the SELinux policy, and does the enforcements itself (rather than through the Linux kernel). The other one is <strong class="source-inline">SELINUX_ERR</strong>, which is used when an internal error or violation is triggered that is not related to regular type enforcement.<p class="calibre3">Other event types that are closely related, but are not exclusive to SELinux, exist as well. For instance, <strong class="source-inline">MAC_POLICY_LOAD</strong>, <strong class="source-inline">MAC_POLICY_CHANGE</strong>, and <strong class="source-inline">MAC_STATUS</strong> are events that are triggered whenever a MAC system state or policy is changed.</p></li>
			</ol>
			<div class="calibre11" id="calibre_pb_2"/>
</div>
	</div>

<div id="sbo-rt-content" class="calibre1">
<div id="_idContainer047" class="calibre2">
<h1 id="_idParaDest-407" class="calibre5"><em class="italic"><a id="_idTextAnchor412" class="pcalibre calibre6 pcalibre1"/></em><a href="B16276_03_Final_VK.xhtml#_idTextAnchor071" class="pcalibre calibre6 pcalibre1"><em class="italic">Chapter 3</em></a></h1>
			<ol class="calibre18">
				<li value="1" class="calibre9">There is an intermediate step needed to associate a role with a Linux account, and that is the SELinux user. A Linux account (or login) is mapped to an SELinux user. The SELinux user is then mapped to one or more SELinux roles that that SELinux user can be in.<p class="calibre3">If we want to assign an additional role to a Linux user, we need to add it to the SELinux role that that Linux account is mapped to. However, if more Linux accounts are mapped to the same SELinux user, then we first need to make sure that all these accounts are indeed allowed to use this role. If not, a dedicated SELinux user has to be created for the Linux account.</p></li>
				<li class="calibre9">Yes, the mappings are considered when a user logs in through a particular service. It is possible for administrators to tune the mappings to be dependent on the service, as seen in the <em class="italic">Customizing logins toward services</em> section.</li>
				<li class="calibre9">Most SELinux domains do not allow the SELinux user of a context to be changed. This allows the tracking of activities based on the SELinux user, even when the regular Linux user has changed their user ID. Note that this is not exclusive to SELinux, however. Linux does support a distinction between the real user ID (which stays static as much as possible) and the effective user ID (which can change, for instance, when executing a setuid application).<p class="calibre3">SELinux users also allow granularity as regards the SELinux policy, for instance, when using user-based access control. In that case, SELinux users cannot access resources that are owned by a different SELinux user.</p></li>
				<li class="calibre9">PAM is a flexible, modular system that Linux uses to authenticate users. Rather than having all the different technologies and services on a system implement authentication over and over again, they use PAM to handle the authentication flow. Administrators only then need to focus on PAM or PAM-related configurations to ensure that their systems are properly accessed.<p class="calibre3">For SELinux, PAM is needed to allow the authentication to check the mappings (between Linux users and SELinux users), which is supported through <strong class="source-inline">pam_selinux.so</strong>.</p></li>
			</ol>
			<div class="calibre11" id="calibre_pb_3"/>
</div>
	</div>

<div id="sbo-rt-content" class="calibre1">
<div id="_idContainer047" class="calibre2">
<h1 id="_idParaDest-408" class="calibre5"><em class="italic"><a id="_idTextAnchor413" class="pcalibre calibre6 pcalibre1"/></em><a href="B16276_04_Final_VK.xhtml#_idTextAnchor095" class="pcalibre calibre6 pcalibre1"><em class="italic">Chapter 4</em></a></h1>
			<ol class="calibre18">
				<li value="1" class="calibre9">The most common option is -Z, and is supported by tools such as ls, mv, and ps. The same character is also used by systemd's tmpfiles application to explicitly set SELinux contexts on resources. However, while this is the most commonly used option, not all tools follow this convention, so we recommend to always consult the tool's help or manual page.</li>
				<li class="calibre9">In most cases, the context is stored as an extended attribute of the file or directory within the filesystem. This extended attribute is the <strong class="source-inline">security.selinux</strong> attribute, and can be queried with tools such as <strong class="source-inline">getfattr</strong> or <strong class="source-inline">stat</strong>.<p class="calibre3">However, not all filesystems support extended attributes. In that case, the SELinux context is obtained through the mount options of that filesystem, and all resources on the filesystem then use the same context.</p></li>
				<li class="calibre9">The <strong class="source-inline">chcon</strong> application directly alters the SELinux context for a file, but does not adjust the system's file context definitions. If, at any point in time, the system or an administrator relabels the file or the entire filesystem (which is a common remediation for SELinux issues), then the SELinux context of the file is changed back.<p class="calibre3">Hence, <strong class="source-inline">chcon</strong> is only recommended for transient SELinux context changes or to validate whether a context change solves an issue. Once confident that the new context is needed, it should be registered in the system's file context definition through <strong class="source-inline">semanage fcontext</strong>.</p></li>
				<li class="calibre9">Yes. While SELinux's tools have the concept of <em class="italic">most specific rule wins</em> for the context definitions provided by the Linux distribution, this concept does not apply to file context definitions that are local to the system (in other words, executed by the system administrator).<p class="calibre3">For locally defined file context definitions, the first rule that matches a patch will be used, regardless of the context definitions that follow.</p></li>
				<li class="calibre9">If you only want to relabel a selected set of files, such as recursive applications to a given directory, the <strong class="source-inline">restorecon</strong> command should be used. If the entire filesystem needs to be relabeled, either use <strong class="source-inline">fixfiles</strong> (CentOS and related distributions) or <strong class="source-inline">rlpkg</strong> (Gentoo).<p class="calibre3">Another method is to create an empty file called <strong class="source-inline">/.autorelabel</strong> and reboot the system. The system will detect this file, relabel the entire filesystem, remove this file, and then reboot again.</p></li>
				<li class="calibre9">The source domain needs the transition privilege vis-à-vis the target domain. It also requires the execute privilege on the executable file. This executable file has to be marked as an entry point for the target domain. Finally, the role for which a transition is to occur has to have the target domain as an allowed type.</li>
				<li class="calibre9">Multiple SELinux types can be assigned an SELinux attribute, and the SELinux policy can then use this attribute as a source or target for its rules. Such attribute-based rules then automatically apply to all types assigned from this attribute.</li>
			</ol>
			<div class="calibre11" id="calibre_pb_4"/>
</div>
	</div>

<div id="sbo-rt-content" class="calibre1">
<div id="_idContainer047" class="calibre2">
<h1 id="_idParaDest-409" class="calibre5"><em class="italic"><a id="_idTextAnchor414" class="pcalibre calibre6 pcalibre1"/></em><a href="B16276_05_Final_VK.xhtml#_idTextAnchor138" class="pcalibre calibre6 pcalibre1"><em class="italic">Chapter 5</em></a></h1>
			<ol class="calibre18">
				<li value="1" class="calibre9">The command to apply a type to a TCP port is created with <strong class="source-inline">semanage</strong>. For instance, to apply the <strong class="source-inline">ssh_port_t</strong> type to TCP port <strong class="source-inline">10122</strong>, execute the following command:<p class="source-code"><strong class="bold"># semanage port -a -t ssh_port_t -p tcp 10122</strong></p><p class="calibre3">However, this only works as long as the port itself is not already explicitly mapped to an SELinux type. You can query whether this is the case with <strong class="source-inline">sepolicy</strong>, for example:</p><p class="source-code"><strong class="bold"># sepolicy network -p 10122</strong></p><p class="calibre3">If the port is part of an unreserved range, then it can be altered.</p></li>
				<li class="calibre9">No, SECMARK is local to the system. Once a network packet is received by the Linux host, the SECMARK rules will associate a label with that network packet, but this label is only retained in memory on the system itself. Once a packet leaves the Linux system, it will not show any trace of SECMARK labeling.</li>
				<li class="calibre9">The subcommands used by <strong class="source-inline">semanage</strong> are <strong class="source-inline">ibendport</strong> (to apply a label or sensitivity to an InfiniBand network port) and <strong class="source-inline">ibpkey</strong> (to apply a label or sensitivity to a partition key).</li>
				<li class="calibre9">While labeled IPsec itself does not require specialized equipment, it does require all participating hosts to have the same view on what each label implies. This means that all hosts, in the case of SELinux-based labeling, need to have SELinux active, and preferably with exactly the same SELinux policy.</li>
			</ol>
			<div class="calibre11" id="calibre_pb_5"/>
</div>
	</div>

<div id="sbo-rt-content" class="calibre1">
<div id="_idContainer047" class="calibre2">
<h1 id="_idParaDest-410" class="calibre5"><em class="italic"><a id="_idTextAnchor415" class="pcalibre calibre6 pcalibre1"/></em><a href="B16276_06_Final_VK.xhtml#_idTextAnchor174" class="pcalibre calibre6 pcalibre1"><em class="italic">Chapter 6</em></a></h1>
			<ol class="calibre18">
				<li value="1" class="calibre9">Ansible (using <strong class="source-inline">setype</strong> within the file module) and Puppet (using <strong class="source-inline">seltype</strong> in its file module) are the only two tools that have native support for explicitly setting SELinux contexts on resources. However, Chef will automatically relabel resources according to the defined file context rules, but you cannot natively override this behavior.</li>
				<li class="calibre9">Except for SaltStack, all orchestration tools have support for community-built and community-supported modules that extend native support of the tools. Ansible's Galaxy, Puppet's Forge, and Chef's Supermarket are the main communities for these customizations.<p class="calibre3">All orchestration tools (including SaltStack) are flexible enough to use commands and simple checks to check state and make changes, effectively allowing administrators to customize the definitions to their liking.</p></li>
				<li class="calibre9">All tools have their own view and design on how they approach things. Ansible, for instance, pushes its changes to the remote nodes, whereas the others generally use remote agents to connect to the central system to obtain the latest changes. SaltStack even supports both approaches.<p class="calibre3">While all tools have some SELinux support included, some have many more SELinux features enabled out of the box than others. Luckily, through the use of the community-supported additions (modules), the SELinux support for almost all of the orchestration tools can easily be augmented.</p></li>
			</ol>
			<div class="calibre11" id="calibre_pb_6"/>
</div>
	</div>

<div id="sbo-rt-content" class="calibre1">
<div id="_idContainer047" class="calibre2">
<h1 id="_idParaDest-411" class="calibre5"><em class="italic"><a id="_idTextAnchor416" class="pcalibre calibre6 pcalibre1"/></em><a href="B16276_07_Final_VK.xhtml#_idTextAnchor216" class="pcalibre calibre6 pcalibre1"><em class="italic">Chapter 7</em></a></h1>
			<ol class="calibre18">
				<li value="1" class="calibre9">The unit files in <strong class="source-inline">/usr/lib/systemd/system</strong> are managed by the Linux distribution itself. Whenever a new update to the software is deployed on the system, these files are overwritten.<p class="calibre3">Modifications to unit files should be placed in <strong class="source-inline">/etc/systemd/system</strong> instead, as they overrule the settings in <strong class="source-inline">/usr/lib/systemd</strong>, and software deployments should not place any of their unit files in that location.</p></li>
				<li class="calibre9">The application is tmpfiles, and is part of the systemd suite. To have it reset a context, a configuration file has to be created (in <strong class="source-inline">/etc/tmpfiles.d</strong> for locally defined changes) and use the <strong class="source-inline">z</strong> directive (to reset the context of a single file) or the <strong class="source-inline">Z</strong> directive (to recursively set the context of an entire directory).</li>
				<li class="calibre9">The <strong class="source-inline">journalctl</strong> command allows filtering on variables that it obtained from the event itself. One of these variables is the SELinux context of the service that generated the event.<p class="calibre3">To filter on a particular value, you use the variable name as an argument to the <strong class="source-inline">journalctl</strong> command like so:</p><p class="source-code"><strong class="bold"># journalctl _SELINUX_CONTEXT=system_u:system_r:init_t:s0</strong></p><p class="calibre3">If you do not know what SELinux context to use, then the Bash completion might be of assistance. Just declare <strong class="source-inline">_SELINUX_CONTEXT=</strong> in the preceding command, and then press <em class="italic">Tab</em> twice to see all the valid values.</p></li>
				<li class="calibre9">If the SELinux policy itself does not have a proper named file transition rule in place (which would automatically have the node created with the correct SELinux context), then you can tell udev to do this for you.<p class="calibre3">Find the udev rule that would create the device node for the device, and copy this rule into <strong class="source-inline">/etc/udev/rules.d</strong>. Then, update the rule by adding a <strong class="source-inline">SECLABEL{selinux}=</strong> action, like so:</p><p class="source-code"><strong class="bold">KERNEL=="fd0", ..., SECLABEL{selinux}="system_u:object_r:my_device_t:s0"</strong></p><p class="calibre3">Such rules have to be placed in <strong class="source-inline">/etc/udev/rules.d</strong> rather than <strong class="source-inline">/usr/lib/udev/rules.d</strong> as the latter location is managed by the distribution, and new installations or updates will overwrite the files located therein.</p></li>
				<li class="calibre9">No. The SELinux policy is only checked by D-Bus if the D-Bus policy file itself refers to an SELinux context (using the <strong class="source-inline">busconfig</strong> &gt; <strong class="source-inline">selinux</strong> &gt; <strong class="source-inline">associate</strong> XML entities). If no SELinux mapping is defined in the policy, then D-Bus cannot know which association to validate.<p class="calibre3">This is unlike the message flows, however, which are immediately governed by D-Bus through the SELinux policy.</p></li>
				<li class="calibre9">Apache can be made SELinux-aware because it has a modular design, and allows third-party modules to be applied to its own environment. While no SELinux support is enabled within the core Apache code, additional modules (such as <strong class="source-inline">mod_selinux</strong>) can be added that do enable SELinux support.</li>
			</ol>
			<div class="calibre11" id="calibre_pb_7"/>
</div>
	</div>

<div id="sbo-rt-content" class="calibre1">
<div id="_idContainer047" class="calibre2">
<h1 id="_idParaDest-412" class="calibre5"><em class="italic"><a id="_idTextAnchor417" class="pcalibre calibre6 pcalibre1"/></em><a href="B16276_08_Final_VK.xhtml#_idTextAnchor237" class="pcalibre calibre6 pcalibre1"><em class="italic">Chapter 8</em></a></h1>
			<ol class="calibre18">
				<li value="1" class="calibre9">It is, although it is not natively enabled. SEPostgreSQL is offered through one of the additionally supplied modules within PostgreSQL called <strong class="source-inline">sepgsql</strong>. As such, it is part of the default technology, but not enabled by default.</li>
				<li class="calibre9">As the <strong class="source-inline">sepgsql</strong> module requires a session context, the PostgreSQL database needs to either only be accessed from the local system (using the Unix domain sockets), or labeled networking needs to be enabled and set up in the network.<p class="calibre3">Without labeled networking, any remote connection to the database will fail to provide any context information, and <strong class="source-inline">sepgsql</strong> will refuse the connection.</p></li>
				<li class="calibre9">When a database object is created in PostgreSQL, it will automatically receive an SELinux label. Administrators or database owners can change the labels using the <strong class="source-inline">SECURITY LABEL</strong> statement in PostgreSQL:<p class="source-code"><strong class="bold">db_test=# SECURITY LABEL ON COLUMN tb_users.phash IS 'system_u:object_r:sepgsql_secret_table_t:s0';</strong></p><p class="calibre3">To query the current label, consult the <strong class="source-inline">pg_seclabels</strong> table in PostgreSQL:</p><p class="source-code"><strong class="bold">db_test=# SELECT objname,provider,label FROM pg_seclabels WHERE objname='tb_users.phash';</strong></p><p class="calibre3">If you do not know the object name by heart, use <strong class="source-inline">LIKE</strong> and use <strong class="source-inline">%</strong> as a glob character.</p></li>
				<li class="calibre9">The <strong class="source-inline">sepgsql</strong> module does not interact with the Linux audit subsystem, relying instead on the logging capabilities and interface used by PostgreSQL. As a result, any decision logging that <strong class="source-inline">sepgsql</strong> does will be found in the PostgreSQL system logs.</li>
			</ol>
			<div class="calibre11" id="calibre_pb_8"/>
</div>
	</div>

<div id="sbo-rt-content" class="calibre1">
<div id="_idContainer047" class="calibre2">
<h1 id="_idParaDest-413" class="calibre5"><em class="italic"><a id="_idTextAnchor418" class="pcalibre calibre6 pcalibre1"/></em><a href="B16276_09_Final_VK.xhtml#_idTextAnchor257" class="pcalibre calibre6 pcalibre1"><em class="italic">Chapter 9</em></a></h1>
			<ol class="calibre18">
				<li value="1" class="calibre9">The unique idea that sVirt has that differentiates it from a more standard SELinux configuration is to use SELinux's MCS support to the next level. By randomly assigning two categories to a guest, sVirt can deal with isolating thousands of guests even when far fewer categories are available to use.</li>
				<li class="calibre9">The two main security measures that SELinux implements on top of the virtualization layer are as follows:<p class="calibre3">- Intra-guest isolation, ensuring that guests cannot attack one another, or leak information between guests</p><p class="calibre3">- Guest/host isolation, ensuring that guests can only access and interact with the resources on the host that are needed</p><p class="calibre3">While both are, of course, also implemented within the hypervisor code, any design flaw could lead to high-impact problems. By implementing these isolations within SELinux, we use the strength of the SELinux subsystem as an independent (and much more flexible) access control system.</p></li>
				<li class="calibre9">The <strong class="source-inline">virt_image_t</strong> label is used for guest images when the guest is not running. Once it is running, the image is relabeled to <strong class="source-inline">svirt_image_t</strong> and assigned the correct set of categories. The <strong class="source-inline">virt_content_t</strong> label, on the other hand, is used for read-only media, such as CD images.</li>
				<li class="calibre9">The labels can be changed by editing the guest's XML information:<p class="source-code"><strong class="bold"># virsh edit myGuestName</strong></p><p class="calibre3">At the end of the XML file presented, the appropriate <strong class="source-inline">seclabel</strong> tags can be added to define target labels. </p></li>
				<li class="calibre9">Vagrant, by default, does not have support for sVirt, but thanks to its plugin model, we can install the libvirt plugin for Vagrant. Once installed, Vagrant will use libvirt as its virtualization layer, automatically allowing us to use sVirt with Vagrant.</li>
			</ol>
			<div class="calibre11" id="calibre_pb_9"/>
</div>
	</div>

<div id="sbo-rt-content" class="calibre1">
<div id="_idContainer047" class="calibre2">
<h1 id="_idParaDest-414" class="calibre5"><em class="italic"><a id="_idTextAnchor419" class="pcalibre calibre6 pcalibre1"/></em><a href="B16276_10_Final_VK.xhtml#_idTextAnchor279" class="pcalibre calibre6 pcalibre1"><em class="italic">Chapter 10</em></a></h1>
			<ol class="calibre18">
				<li value="1" class="calibre9">SELinux works within the Linux kernel. Xen, however, is a hypervisor that sits between the hardware and the operating systems and does not use a full operating system as its base (unlike, for instance, QEMU and KVM). <p class="calibre3">When we interact with Xen through Linux, we are actually interacting with Xen through the dom0 guest. Within this guest, SELinux can be running (and we even recommend it), but SELinux will remain within the virtualized guest.</p><p class="calibre3">Xen, however, copied the SELinux approach and implemented it in its Xen Security Module framework.</p></li>
				<li class="calibre9">You can assign a label to a Xen guest by editing its configuration file (inside <strong class="source-inline">/etc/xen</strong>) and adding the <strong class="source-inline">seclabel</strong> parameter, like so:<p class="source-code">seclabel = 'system_u:system_r:prot_domU_t'</p><p class="calibre3">You will need to relaunch the guest for the changes to take effect. Once the guest is booted again (using <strong class="source-inline">xl create</strong>), you can see its active label using <strong class="source-inline">xl list -Z</strong>.</p><p class="calibre3">What are the common Xen commands that deal with XSM labels?</p><p class="calibre3">The common commands to use are the following:</p><p class="calibre3">- With <strong class="source-inline">xl list -Z</strong>, we can list the guests and their currently assigned labels.</p><p class="calibre3">- With <strong class="source-inline">xl getenforce</strong>, we can query the current enforcement state of XSM.</p><p class="calibre3">- With <strong class="source-inline">xl setenforce</strong>, we can set the new enforcement state of XSM.</p><p class="calibre3">- With <strong class="source-inline">xl dmesg</strong>, we can see the Xen logging, including the XSM AVC log entries.</p><p class="calibre3">- With <strong class="source-inline">flask-get-bool</strong>, we can query the current XSM-FLASK Booleans and their values.</p><p class="calibre3">- With <strong class="source-inline">flask-set-bool</strong>, we can set a new value for an XSM-FLASK Boolean.</p><p class="calibre3">- With <strong class="source-inline">flask-label-pci</strong>, we can assign a new XSM-FLASK type to a PCI device.</p><p class="calibre3">We can also use SELinux tools that can analyze a policy file, such as <strong class="source-inline">seinfo</strong> or <strong class="source-inline">sesearch</strong>.</p></li>
				<li class="calibre9">The command to load a custom policy is <strong class="source-inline">xl loadpolicy</strong>, or <strong class="source-inline">flask-loadpolicy</strong>. As long as the new policy file is not put in <strong class="source-inline">/boot</strong> to be automatically picked up, this loaded policy will only be active until a reboot is done, or until a new policy is loaded.</li>
			</ol>
			<div class="calibre11" id="calibre_pb_10"/>
</div>
	</div>

<div id="sbo-rt-content" class="calibre1">
<div id="_idContainer047" class="calibre2">
<h1 id="_idParaDest-415" class="calibre5"><em class="italic"><a id="_idTextAnchor420" class="pcalibre calibre6 pcalibre1"/></em><a href="B16276_11_Final_VK.xhtml#_idTextAnchor293" class="pcalibre calibre6 pcalibre1"><em class="italic">Chapter 11</em></a></h1>
			<ol class="calibre18">
				<li value="1" class="calibre9">The <strong class="source-inline">machinectl</strong> command does not allow administrators to change the SELinux type of the running containers. This results in all containers running by default under an unconfined domain, whereas we want confined domains to be used—preferably even with sVirt support so that containers cannot influence one another either.</li>
				<li class="calibre9">When a container is launched with a location mapping, we should use the <strong class="source-inline">:Z</strong> option (in case of a private mapping) or the <strong class="source-inline">:z</strong> option (in case of a shared mapping) to ensure that the resources are relabeled with a container-accessible SELinux type:<p class="source-code"><strong class="bold"># podman run -dit --name postgresql-test -v /srv/db/postgresql-test:/bitnami/postgresql:Z -p 5432:5432 postgresql</strong></p><p class="calibre3">Without this option, the label of the resource remains untouched, which generally means that the container runtime cannot access the resource at all.</p></li>
				<li class="calibre9">We can use the <strong class="source-inline">udica</strong> application to generate a custom policy. The application uses the information that is provided from a <strong class="source-inline">podman inspect</strong> (or <strong class="source-inline">docker inspect</strong>) command, which shows the current container definition, and builds a custom policy specific to that container.<p class="calibre3">The policy, once loaded, can then be used by the container through the <strong class="source-inline">--security-opt</strong> argument.</p></li>
				<li class="calibre9">The main place for SELinux settings is inside the manifest under the <strong class="source-inline">spec</strong> configuration parameter. There, we can create the <strong class="source-inline">securityContext</strong> definition, which supports SELinux options through the <strong class="source-inline">seLinuxOptions</strong> object.</li>
			</ol>
			<div class="calibre11" id="calibre_pb_11"/>
</div>
	</div>

<div id="sbo-rt-content" class="calibre1">
<div id="_idContainer047" class="calibre2">
<h1 id="_idParaDest-416" class="calibre5"><em class="italic"><a id="_idTextAnchor421" class="pcalibre calibre6 pcalibre1"/></em><a href="B16276_12_Final_VK.xhtml#_idTextAnchor312" class="pcalibre calibre6 pcalibre1"><em class="italic">Chapter 12</em></a></h1>
			<ol class="calibre18">
				<li value="1" class="calibre9">When SELinux Booleans are changed through the <strong class="source-inline">/sys/fs/selinux/booleans</strong> filesystem, the changes are not automatically committed. For that to occur, you also need to write the value <strong class="source-inline">1</strong> into <strong class="source-inline">/sys/fs/selinux/commit_pending_bools</strong>.</li>
				<li class="calibre9">The <strong class="source-inline">sesearch</strong> command is used to query the active policy, and can be used to query the impact of SELinux Booleans as well. Add the <strong class="source-inline">-b &lt;boolean&gt;</strong> argument to limit the query to rules that are influenced by the SELinux Boolean.</li>
				<li class="calibre9">When an SELinux policy module is loaded, it is assigned a priority that tells the system whether it should be the active module. Administrators can load new modules at a higher priority to test them out, and remove them again, without risking that no proper SELinux rules are active on the system at all.<p class="calibre3">Likewise, administrators can load a policy at a lower priority, ensuring that it is not yet active, and later on remove the module at the higher priority so that the newly loaded policy becomes active.</p><p class="calibre3">This is unlike enabling or disabling modules, which affects all priorities.</p></li>
				<li class="calibre9">The SELinux utility <strong class="source-inline">audit2allow</strong> transforms all SELinux-related audit events into SELinux policy code. The code can use both the legacy style (using <strong class="source-inline">-M</strong>) or the reference policy style (using <strong class="source-inline">-R -M</strong>). Regardless of the style chosen, a loadable SELinux policy module (with the suffix <strong class="source-inline">.pp</strong>) will be created:<p class="source-code"><strong class="bold"># grep btmp /var/log/audit/audit.log | audit2allow -R \</strong></p><p class="source-code"><strong class="bold">    -M custom_staff_su_faillog</strong></p><p class="calibre3">The resulting file (<strong class="source-inline">custom_staff_su_faillog.pp</strong>) can be loaded using <strong class="source-inline">semodule -i</strong>.</p></li>
			</ol>
			<div class="calibre11" id="calibre_pb_12"/>
</div>
	</div>

<div id="sbo-rt-content" class="calibre1">
<div id="_idContainer047" class="calibre2">
<h1 id="_idParaDest-417" class="calibre5"><em class="italic"><a id="_idTextAnchor422" class="pcalibre calibre6 pcalibre1"/></em><a href="B16276_13_Final_VK.xhtml#_idTextAnchor330" class="pcalibre calibre6 pcalibre1"><em class="italic">Chapter 13</em></a></h1>
			<ol class="calibre18">
				<li value="1" class="calibre9">The <strong class="source-inline">seinfo</strong> application is used to query the policy for its type content, but not for its rules. For instance, you list the types within the policy with <strong class="source-inline">seinfo</strong>, but you don't query what these types can do.<p class="calibre3">The <strong class="source-inline">sesearch</strong> application, on the other hand, is used to query the rules within the policy, but does not reveal anything about the various definitions inside the policy that are not really rules (such as attribute definitions and supported classes).</p><p class="calibre3">Hence, the main difference is that <strong class="source-inline">seinfo</strong> focuses on the structure of the policy, whereas <strong class="source-inline">sesearch</strong> focuses on the enforcements defined within the policy.</p></li>
				<li class="calibre9">Reaching a domain implies domain transitions. Hence, what we are looking for is how you can transition from your current domain (say <strong class="source-inline">staff_t</strong>) to the target domain (say <strong class="source-inline">unconfined_t</strong>) and through which means—generally, this is done by executing a binary or script that triggers a type transition.<p class="calibre3">Analyzing domain transitions can be done using <strong class="source-inline">apol</strong> (the graphical user interface), <strong class="source-inline">sedta</strong>, or <strong class="source-inline">sepolicy transition</strong>. However, the latter might not reveal the correct paths, so it is recommended to use <strong class="source-inline">sedta</strong> or <strong class="source-inline">apol</strong> for this.</p></li>
				<li class="calibre9">Information flow analysis has to take up considerably more paths than a domain transition. Domain transitions are between process domains, and only a small number of actions can trigger a transition. Information flow, on the other hand, can be effected over many, many actions.<p class="calibre3">Such analysis not only needs to consider read and write statements, but also file descriptor usage, socket usage, signaling, the locking and unlocking of resources, and more besides. As a result, information flow analysis uses permission maps to identify the various permissions to check, and how important (weight) a permission is for an information flow analysis session.</p></li>
				<li class="calibre9">Not using the tools currently at hand. The tool that compares policies, <strong class="source-inline">sediff</strong>, shows the differences between the policies, but is not, by itself, capable of generating SELinux policies that contain the differences between policies.<p class="calibre3">Furthermore, SELinux policy modules can only add additional rules to the active policy, not remove them. Hence, even if <strong class="source-inline">sediff</strong> generated compatible output, it would still not be able to generate any statements that would remove existing rules from the active policy.</p></li>
			</ol>
			<div class="calibre11" id="calibre_pb_13"/>
</div>
	</div>

<div id="sbo-rt-content" class="calibre1">
<div id="_idContainer047" class="calibre2">
<h1 id="_idParaDest-418" class="calibre5"><em class="italic"><a id="_idTextAnchor423" class="pcalibre calibre6 pcalibre1"/></em><a href="B16276_14_Final_VK.xhtml#_idTextAnchor354" class="pcalibre calibre6 pcalibre1"><em class="italic">Chapter 14</em></a></h1>
			<ol class="calibre18">
				<li value="1" class="calibre9">An unconfined domain is still fully controlled and enforced by SELinux. It is called unconfined because such domains are granted extensive privileges by the SELinux policy. However, unlike what the name implies, they are still somewhat confined.<p class="calibre3">Permissive domains, on the contrary, are not confined. SELinux will only log violations against the policy, but it will not enforce them.</p></li>
				<li class="calibre9">The SELinux sandbox utility can be used to run applications in a very restricted domain. The utility will both force the application to run in a very restricted domain (<strong class="source-inline">sandbox_t</strong> for regular, non-graphical end user applications, or <strong class="source-inline">sandbox_xserver_t</strong> for graphical applications), as well as isolate or hide access to other system resources through the use of Linux's namespaces.</li>
				<li class="calibre9">When the init system (such as systemd) launches a daemon, it will execute a specific binary or script for it. The label of this binary or script will generally define the target domain. For instance, if the resource is labeled with <strong class="source-inline">bin_t</strong>, then systemd will make sure that the target service runs as <strong class="source-inline">unconfined_service_t</strong>. If it is labeled with <strong class="source-inline">postgresql_exec_t</strong>, then the target service will run with the <strong class="source-inline">postgresql_t</strong> type.<p class="calibre3">While other permissions are also involved (such as the source context requiring transition permissions to the target), unless we are building a new policy from scratch, switching domains will be as simple as changing the label for its executable resource, and relabeling its main locations on the filesystem (such as log locations and runtime information).</p></li>
				<li class="calibre9">The default skeleton application that <strong class="source-inline">sepolicy generate</strong> builds contains the <strong class="source-inline">permissive</strong> statement, which implies that the policy will run in a permissive mode. Since this means SELinux will not enforce any controls, it is very likely that the application will work flawlessly with this policy enabled.<p class="calibre3">That is, however, not the target state, and administrators will need to remove the <strong class="source-inline">permissive</strong> setting from the policy and adjust as needed.</p></li>
			</ol>
			<div class="calibre11" id="calibre_pb_14"/>
</div>
	</div>

<div id="sbo-rt-content" class="calibre1">
<div id="_idContainer047" class="calibre2">
<h1 id="_idParaDest-419" class="calibre5"><em class="italic"><a id="_idTextAnchor424" class="pcalibre calibre6 pcalibre1"/></em><a href="B16276_15_Final_VK.xhtml#_idTextAnchor373" class="pcalibre calibre6 pcalibre1"><em class="italic">Chapter 15</em></a></h1>
			<ol class="calibre18">
				<li value="1" class="calibre9">Many Linux distributions add services and tools that fit the distribution's purpose and principles, yet which might be contradictory to what the reference policy is about. For instance, Red Hat Enterprise Linux and its derived Linux distributions will enable unconfined domains for many applications, whereas the reference policy will strive toward confinement of all applications.<p class="calibre3">As a result, many Linux distributions base their policy on the reference policy, but augment and adjust it for their specific purpose.</p></li>
				<li class="calibre9">The three main policy files are the following:<p class="calibre3">- A type enforcement file, with the suffix <strong class="source-inline">.te</strong>, which contains the rules for the SELinux policy module, focusing on its owned domains.</p><p class="calibre3">- An interface file, with the suffix <strong class="source-inline">.if</strong>, which exposes the interaction patterns and privileges vis-à-vis the domains and resources owned by this SELinux policy module. These interfaces are then used by other SELinux policy modules.</p><p class="calibre3">- A context file, with the suffix <strong class="source-inline">.fc</strong>, which contains the file contexts for the various paths related to this SELinux policy module.</p><p class="calibre3">Policy modules can be created with only a single file. In that case, the build system will assume that the other files are empty.</p></li>
				<li class="calibre9">The use of a permission set allows policy developers to easily adjust and extend the permission set when needed, without having to change all possible SELinux policy module code entries.<p class="calibre3">This is especially critical when a new permission is added by Linux (and the SELinux subsystem). For instance, suppose that the memory map system call (<strong class="source-inline">map</strong>) was not present yet, and is introduced later. We would need to add the map privilege to all execute calls. By using permission sets, we can add this to the appropriate permission set only.</p></li>
				<li class="calibre9">Interfaces will grant privileges to domains or roles. They do not add or remove SELinux objects to the policy. Templates, on the other hand, will generate new SELinux types, roles, Booleans, or other objects. As a consequence, templates are not allowed to be called from within any Boolean-triggered block.</li>
				<li class="calibre9">The database administration role does not use <strong class="source-inline">userdom_admin_user_template</strong> because it is not a system-wide administration role, but very specific to databases. <strong class="source-inline">userdom_admin_user_template</strong> would grant the role many more privileges than are needed to administer databases.</li>
			</ol>
			<div class="calibre11" id="calibre_pb_15"/>
</div>
	</div>

<div id="sbo-rt-content" class="calibre1">
<div id="_idContainer047" class="calibre2">
<h1 id="_idParaDest-420" class="calibre5"><em class="italic"><a id="_idTextAnchor425" class="pcalibre calibre6 pcalibre1"/></em><a href="B16276_16_Final_VK.xhtml#_idTextAnchor391" class="pcalibre calibre6 pcalibre1"><em class="italic">Chapter 16</em></a></h1>
			<ol class="calibre18">
				<li value="1" class="calibre9">The SELinux <strong class="bold">Common Intermediate Language</strong> (<strong class="bold">CIL</strong>) is not an extension to SELinux that can be easily removed. It is at the heart of SELinux policy development and support, although mainly under the hood: all SELinux policy modules that are loaded on the system are first converted into CIL before actually being loaded in memory.<p class="calibre3">The CIL format is the only format used to interact with the Linux kernel and the SELinux subsystem. Because it is used as part of the SELinux user space utilities, it is not always as obvious to administrators or developers, but it is definitely a core component within SELinux.</p></li>
				<li class="calibre9">No, it is not mandatory, but is recommended. The attribute is used to refer to types and roles in a modular fashion, and to ensure that these references are valid. CIL internally requires types and roles to be defined before they are used, and without using an attribute to force such declarations, the order of loading modules might result in failures.<p class="calibre3">While other attributes could be declared for this purpose, or other means introduced, the use of the <strong class="source-inline">cil_gen_require</strong> attribute is supported through the SELinux user space utilities. As such, aligning with this practice is recommended.</p></li>
				<li class="calibre9">With CIL, developers can create additional port mappings, declaring a new type and assigning it to an available port. With other SELinux language styles, this is only possible when rebuilding the entire policy rather than through the modules.<p class="calibre3">Another example is to introduce constraints. SELinux constraints are not supported to be loaded in SELinux modules using other language styles. However, while constraints are a powerful construct within SELinux, they can be confusing for administrators as constraint-related failures do not result in obvious messages, and administrators who query the current policy for allow rules may notice that allow rules exist even though things still fail.</p></li>
				<li class="calibre9">CIL supports macros, which are made part of the SELinux module (and the namespace), and which can be called using the <strong class="source-inline">call</strong> statement from elsewhere in the SELinux policy. We can create macros as part of a module to be similar to interfaces in reference policy, while creating macros as part of the global namespace to be similar to the support macros in reference policy.</li>
			</ol>
		</div>
	</div></body></html>