<html><head></head><body>
		<div id="_idContainer031">
			<h1 id="_idParaDest-90"><em class="italic"><a id="_idTextAnchor091"/>Chapter 7</em>: Understanding systemd Timers</h1>
			<p>Busy system administrators like to find ways to make their lives easier. One way to do that is to automate as many of their routine tasks as possible by setting them up to automatically run on a set schedule. In this chapter, we'll look at how to do this with <strong class="source-inline">systemd</strong> timers. The specific topics that we'll look at include the following:</p>
			<ul>
				<li>Comparing <strong class="source-inline">systemd</strong> timers with <strong class="source-inline">cron</strong></li>
				<li>Understanding timer options</li>
				<li>Creating timers</li>
			</ul>
			<p>If you're ready, let's get started.</p>
			<h1 id="_idParaDest-91"><a id="_idTextAnchor092"/>Technical requirements</h1>
			<p>As always, we'll be using an Ubuntu Server 20.04 virtual machine and an Alma Linux 8 virtual machine for our demonstrations. It's all hands-on, so feel free to follow along with your own virtual machines.</p>
			<p>Check out the following link to see the Code in Action video: <a href="https://bit.ly/31pQdfS">https://bit.ly/31pQdfS</a></p>
			<h1 id="_idParaDest-92"><a id="_idTextAnchor093"/>Comparing systemd timers with cron</h1>
			<p>The <strong class="source-inline">cron</strong> family <a id="_idIndexMarker192"/>of scheduling utilities has been a part of <a id="_idIndexMarker193"/>Unix and Unix-like operating systems since May 1975. In the 1980s, as part of Richard Stallman's new <em class="italic">free software</em> movement, several free-as-in-speech versions of <strong class="source-inline">cron</strong> were created. Paul Vixie, a member of the <em class="italic">Internet Hall of Fame</em>, created his own free version in 1987. Vixie's version became the most widely used version in the Linux world. (In fact, if you look at the <strong class="source-inline">cron</strong> man page, you'll still see Paul Vixie's name in the <strong class="bold">Authors</strong> section at the bottom.)</p>
			<p>A big advantage of <strong class="source-inline">cron</strong> is its sheer simplicity. All it takes to create a <strong class="source-inline">cron</strong> job is one simple line of code, which would look something like this:</p>
			<div>
				<div id="_idContainer027" class="IMG---Figure">
					<img src="image/Figure_7.1_B17491.jpg" alt=""/>
				</div>
			</div>
			<p class="figure-caption">Figure 7.1 – An example of a cron job</p>
			<p>In this very simple example, which I took from one of my ancient CentOS 6 virtual machines, I'm running a simple task at 25 minutes and 55 minutes past every hour of every day. Twice every hour, this <strong class="source-inline">cron</strong> job inserts a message into the system log file. Any non-privileged user who needs to can create a <strong class="source-inline">cron</strong> job to perform some non-privileged task and anyone with the proper root-level privileges can create a system-level job. Jobs can be set up to run on a particular day of the week, a particular day of the month, at particular times of the day, or upon rebooting the machine. There's a lot of flexibility here, and it's all very simple to set up.</p>
			<p>Another <a id="_idIndexMarker194"/>advantage of <strong class="source-inline">cron</strong> is that it's everywhere in <a id="_idIndexMarker195"/>the world of Unix and Unix-like operating systems, while <strong class="source-inline">systemd</strong> only exists in the world of Linux. If you're a system administrator in a large shop with a mix of both Unix and Linux servers, you might find it easier to stick with <strong class="source-inline">cron</strong>.</p>
			<p>Setting up <strong class="source-inline">systemd</strong> timers isn't hard, but it does take a bit more time and effort. To begin with, you can't directly access a command or a script from a <strong class="source-inline">systemd</strong> timer. You first have to create a <strong class="source-inline">systemd</strong> service, then call that service from the timer. However, there are quite a few advantages of using <strong class="source-inline">systemd</strong> timers, so learning how to use them could be well worth the effort.</p>
			<p>With <strong class="source-inline">systemd</strong> timers, you have a lot more flexibility and accuracy in the way you set up task schedules. The services that you create to go along with your timers can take advantage of resource management, security, and all of the other goodness that comes with using <strong class="source-inline">systemd</strong>. You can create timers that trigger upon some predefined event, or you can specify the calendar and clock time for when you want to trigger the timer. As an added bonus, <strong class="source-inline">systemd</strong> will log the completion of a timer event in the system log file. With <strong class="source-inline">cron</strong> jobs, you don't have any of that.</p>
			<p>So, you're now wondering which of these two task-scheduling systems you should use. Well, <strong class="source-inline">cron</strong> does still come installed on modern Linux systems. If you just need to quickly create a simple job, there's certainly nothing wrong with using <strong class="source-inline">cron</strong>. But, if you need to set up something a bit fancier, then definitely go with a <strong class="source-inline">systemd</strong> timer. Even if you do just need something simple, it might still be worth your while to set up a timer in order to get familiar with the process.</p>
			<p>Okay, that's <a id="_idIndexMarker196"/>probably enough for the introduction. Let's <a id="_idIndexMarker197"/>look at how to view information about the <strong class="source-inline">systemd</strong> timers on your system.</p>
			<h2 id="_idParaDest-93"><a id="_idTextAnchor094"/>Viewing timer information</h2>
			<p>When you first <a id="_idIndexMarker198"/>install a Linux operating system, you'll see that there are already some active timers that take care of certain administrative tasks. You can see them by using the <strong class="source-inline">systemctl list-unit-files -t timer</strong> command. On your Alma Linux machine, the output should look something like this:</p>
			<div>
				<div id="_idContainer028" class="IMG---Figure">
					<img src="image/Figure_7.2_B17491.jpg" alt=""/>
				</div>
			</div>
			<p class="figure-caption">Figure 7.2 – Timers on Alma Linux</p>
			<p>We see that 12 timers are installed, but only two are enabled. Two are static, which means that they can't be either enabled or disabled, and all the rest are disabled.</p>
			<p>On the Ubuntu server machine, we see that quite a few more timers are enabled:</p>
			<div>
				<div id="_idContainer029" class="IMG---Figure">
					<img src="image/Figure_7.3_B17491.jpg" alt=""/>
				</div>
			</div>
			<p class="figure-caption">Figure 7.3 – Timers on Ubuntu server</p>
			<p>The <strong class="source-inline">systemctl list-timers</strong> command <a id="_idIndexMarker199"/>shows you six fields of information, which look like this:</p>
			<div>
				<div id="_idContainer030" class="IMG---Figure">
					<img src="image/Figure_7.4_B17491.jpg" alt=""/>
				</div>
			</div>
			<p class="figure-caption">Figure 7.4 – systemctl list-timers</p>
			<p>The six fields are as follows:</p>
			<ul>
				<li><strong class="bold">NEXT</strong>: This shows the next time that the timer is scheduled to run.</li>
				<li><strong class="bold">LEFT</strong>: This shows how much time is left before the timer runs again.</li>
				<li><strong class="bold">LAST</strong>: This shows the time at which the timer last ran.</li>
				<li><strong class="bold">PASSED</strong>: This shows how much time has elapsed since the timer last ran.</li>
				<li><strong class="bold">UNIT</strong>: This is the name of the unit file for the timer.</li>
				<li><strong class="bold">ACTIVATES</strong>: This is the name of the service that the timer runs. This will normally be the same name as the timer, but it doesn't have to be.</li>
			</ul>
			<p>You can view<a id="_idIndexMarker200"/> some of this information with <strong class="source-inline">systemctl status</strong>, like this:</p>
			<p class="source-code">[donnie@localhost ~]$ systemctl status dnf-makecache.timer</p>
			<p class="source-code">• dnf-makecache.timer - dnf makecache --timer</p>
			<p class="source-code">   Loaded: loaded (/usr/lib/systemd/system/dnf-makecache.timer; enabled; vendor preset: enabled)</p>
			<p class="source-code">   Active: active (waiting) since Thu 2021-05-20 12:29:35 EDT; 2h 55min ago</p>
			<p class="source-code">  Trigger: Thu 2021-05-20 15:39:35 EDT; 14min left</p>
			<p class="source-code">May 20 12:29:35 localhost.localdomain systemd[1]: Started dnf makecache --timer.</p>
			<p class="source-code">[donnie@localhost ~]$</p>
			<p>Just as you can do with services and targets, you can view the dependency tree for a timer, as follows:</p>
			<p class="source-code">[donnie@localhost ~]$ systemctl list-dependencies dnf-makecache.timer</p>
			<p class="source-code">dnf-makecache.timer</p>
			<p class="source-code">• ├─network-online.target</p>
			<p class="source-code">• │ └─NetworkManager-wait-online.service</p>
			<p class="source-code">• └─sysinit.target</p>
			<p class="source-code">•   ├─dev-hugepages.mount</p>
			<p class="source-code">•   ├─dev-mqueue.mount</p>
			<p class="source-code">•   ├─dracut-shutdown.service</p>
			<p class="source-code">•   ├─import-state.service</p>
			<p class="source-code">•   ├─iscsi-onboot.service</p>
			<p class="source-code">•   ├─kmod-static-nodes.service</p>
			<p class="source-code">•   ├─ldconfig.service</p>
			<p class="source-code">. . .</p>
			<p class="source-code">. . .</p>
			<p>We've seen<a id="_idIndexMarker201"/> several ways to view information about the timers on your system. Let's move on and look at some of the configuration options.</p>
			<h1 id="_idParaDest-94"><a id="_idTextAnchor095"/>Understanding timer options</h1>
			<p>The best way to <a id="_idIndexMarker202"/>start explaining the timer options is to look at some examples of timers that are already on our systems. We'll begin by looking at a timer on the Alma Linux machine.</p>
			<h2 id="_idParaDest-95"><a id="_idTextAnchor096"/>Understanding monotonic timers</h2>
			<p>There are <a id="_idIndexMarker203"/>two ways to specify the time at which <a id="_idIndexMarker204"/>you want a service to automatically run. In this section, we'll look at the <em class="italic">monotonic</em> method. This means that instead of configuring the job to run at a specific calendar and clock time, you'll instead configure the job to run after some sort of event that serves as a starting point. A starting point can be system bootup, timer activation, the time since a timer's associated service last ran, or any of several other things (you can see all of the monotonic starting points by looking at the <strong class="source-inline">systemd.timer</strong> man page). For an example of a monotonic timer, let's look at <strong class="source-inline">dnf-makecache.timer</strong> on the Alma Linux machine.</p>
			<p>Red Hat-type operating systems, such as Alma Linux, use the <strong class="source-inline">dnf</strong> utility to perform update and package management. As with all Linux package management systems, <strong class="source-inline">dnf</strong> maintains a local cache of information about what is in the distro's package repositories. Periodically, the cache needs to be refreshed. We could do that manually with a <strong class="source-inline">sudo dnf makecache</strong> command, but Red Hat-type systems all come with a timer to do it <a id="_idIndexMarker205"/>automatically. Here's what the timer <a id="_idIndexMarker206"/>looks like:</p>
			<p class="source-code">[Unit]</p>
			<p class="source-code">Description=dnf makecache --timer</p>
			<p class="source-code">ConditionKernelCommandLine=!rd.live.image</p>
			<p class="source-code"># See comment in dnf-makecache.service</p>
			<p class="source-code">ConditionPathExists=!/run/ostree-booted</p>
			<p class="source-code">Wants=network-online.target</p>
			<p class="source-code">[Timer]</p>
			<p class="source-code">OnBootSec=10min</p>
			<p class="source-code">OnUnitInactiveSec=1h</p>
			<p class="source-code">Unit=dnf-makecache.service</p>
			<p class="source-code">[Install]</p>
			<p class="source-code">WantedBy=timers.target</p>
			<p>In the <strong class="source-inline">[Unit]</strong> section, we see:</p>
			<ul>
				<li><strong class="source-inline">ConditionKernelCommandLine=!rd.live.image</strong>: This prevents the timer from running if the machine is booted from some sort of live media, such as a live DVD. </li>
				<li><strong class="source-inline">ConditionPathExists=!/run/ostree-booted</strong>: This looks for the <strong class="source-inline">/run/ostree-booted</strong> directory, and prevents the timer from running if this directory is found. (According to the <strong class="source-inline">ostree</strong> man page, you would use <strong class="source-inline">ostree</strong> to manage different versions of filesystem trees. These filesystem trees are mounted as read-only, so trying to update the cache on them wouldn't do much good.) </li>
				<li><strong class="source-inline">Wants=network-online.target</strong>: This prevents the timer from running until after <a id="_idIndexMarker207"/>network services are available. (Already, you're<a id="_idIndexMarker208"/> seeing things you can do with <strong class="source-inline">systemd</strong> timers that you can't do with <strong class="source-inline">cron</strong>.)</li>
			</ul>
			<p>Next, we see the <strong class="source-inline">[Timer]</strong> section, with two examples of monotonic timer settings. As I've already mentioned, monotonic timers are defined relative to a certain starting point, rather than by calendar and clock time: </p>
			<ul>
				<li><strong class="source-inline">OnBootSec=10min</strong>: As we'll see in a moment, this timer activates the <strong class="source-inline">dnf-makecache.service</strong>. This line causes the service to run 10 minutes after the system has booted up.</li>
				<li><strong class="source-inline">OnUnitInactiveSec=1h</strong>: This line says that the timer will run the <strong class="source-inline">dnf-makecache.service</strong> again one hour after the last time it ran. In other words, this line causes the service to run approximately every hour.</li>
				<li><strong class="source-inline">Unit=dnf-makecache.service</strong>: In this case, it's not necessary to have this line. By default, a timer will activate a service that has the same name as the timer. The only time you really have to have this line is if the timer activates a service with a different name. Still though, some people like to use this parameter in any case, and there's nothing wrong with that.<p class="callout-heading">Note</p><p class="callout">You can see the rest of the monotonic timer parameters on the <strong class="source-inline">systemd.timer</strong> man page.</p></li>
			</ul>
			<p>The <strong class="source-inline">[Install]</strong> section is fairly standard stuff. All we see there is the <strong class="source-inline">WantedBy=timers.target</strong> line, which causes this timer to run when the <strong class="source-inline">timers.target</strong> starts.</p>
			<p>While we're at it, we<a id="_idIndexMarker209"/> might as well look at <a id="_idIndexMarker210"/>the <strong class="source-inline">dnf-makecache.service</strong> that this timer activates:</p>
			<p class="source-code">[Unit]</p>
			<p class="source-code">Description=dnf makecache</p>
			<p class="source-code">ConditionPathExists=!/run/ostree-booted</p>
			<p class="source-code">After=network-online.target</p>
			<p class="source-code">[Service]</p>
			<p class="source-code">Type=oneshot</p>
			<p class="source-code">Nice=19</p>
			<p class="source-code">IOSchedulingClass=2</p>
			<p class="source-code">IOSchedulingPriority=7</p>
			<p class="source-code">Environment="ABRT_IGNORE_PYTHON=1"</p>
			<p class="source-code">ExecStart=/usr/bin/dnf makecache --timer</p>
			<p>In the <strong class="source-inline">[Service]</strong> section, we see a few things that we haven't seen in service files before:</p>
			<ul>
				<li><strong class="source-inline">Type=oneshot</strong>: Okay, we actually have seen this one before. I just want to show here that you need to use the <strong class="source-inline">oneshot</strong> type for services that are called by timers. (It really makes sense when you think about it.)</li>
				<li><strong class="source-inline">Nice=19</strong>: This causes the service to run with a niceness value of <strong class="source-inline">19</strong>, which means that the service will run with the lowest possible priority. (Niceness values range from<strong class="source-inline"> -20</strong> to positive <strong class="source-inline">19</strong>. Although it seems counterintuitive, <strong class="source-inline">-20</strong> denotes the highest priority that can be assigned to a process, and positive <strong class="source-inline">19</strong> denotes the lowest.) This setting helps prevent this service from bogging down other processes that might be more important.</li>
				<li><strong class="source-inline">IOSchedulingClass=2</strong>: This sets the type of input/output scheduler scheme that we want to use. A value of <strong class="source-inline">2</strong> means that we want to use the <strong class="source-inline">best-effort</strong> type scheduling class. (You can see the other <strong class="source-inline">IOSchedulingClass</strong> types in the <strong class="source-inline">systemd.exec</strong> man page.)</li>
				<li><strong class="source-inline">IOSchedulingPriority=7</strong>: <strong class="source-inline">IOSchedulingPriority</strong> values range from <strong class="source-inline">0</strong> through <strong class="source-inline">7</strong>, with <strong class="source-inline">0</strong> as the highest priority and <strong class="source-inline">7</strong> as the lowest. This is just another<a id="_idIndexMarker211"/> way to keep this service from <a id="_idIndexMarker212"/>bogging down the rest of the system.</li>
				<li><strong class="source-inline">ExecStart=/usr/bin/dnf makecache --timer</strong>: The <strong class="source-inline">--timer</strong> option here has nothing to do with <strong class="source-inline">systemd</strong> timers. Instead, this is an option that goes along with the <strong class="source-inline">dnf</strong> command. According to the <strong class="source-inline">dnf</strong> man page, <strong class="source-inline">--timer</strong> causes <strong class="source-inline">dnf</strong> to be more resource-aware, so that it won't run if the computer is running on battery power. It also causes the <strong class="source-inline">dnf makecache</strong> command to immediately abort if it has already been run recently. </li>
			</ul>
			<p>The <strong class="source-inline">[Install]</strong> section of this service file is conspicuous by its absence. Not having the <strong class="source-inline">[Install]</strong> section makes this a <em class="italic">static</em> type of service that you can't enable. Instead, it will just run whenever the <strong class="source-inline">dnf-makecache.timer</strong> activates it.</p>
			<p>Okay, that about does it for this example. Next, we'll look at the other ways to specify when to run a job.</p>
			<h2 id="_idParaDest-96"><a id="_idTextAnchor097"/>Understanding real-time timers</h2>
			<p>You can <a id="_idIndexMarker213"/>use a <em class="italic">real-time</em> timer to run a job on <a id="_idIndexMarker214"/>whatever calendar day and at whatever clock time you want it to run. For our first simple example, let's look at the <strong class="source-inline">fstrim.timer</strong> on the Alma machine:</p>
			<p class="source-code">[Unit]</p>
			<p class="source-code">Description=Discard unused blocks once a week</p>
			<p class="source-code">Documentation=man:fstrim</p>
			<p class="source-code">[Timer]</p>
			<p class="source-code">OnCalendar=weekly</p>
			<p class="source-code">AccuracySec=1h</p>
			<p class="source-code">Persistent=true</p>
			<p class="source-code">[Install]</p>
			<p class="source-code">WantedBy=timers.target</p>
			<p>Here's the breakdown:</p>
			<ul>
				<li><strong class="source-inline">OnCalendar=weekly</strong>: You'll use the <strong class="source-inline">OnCalendar</strong> parameter to specify the time at which you want the job to run. Setting this job up to run weekly means that it will run every Monday morning at midnight. (We'll see in a bit where these parameters are defined.)</li>
				<li><strong class="source-inline">AccuracySec=1h</strong>: This defines the amount of time by which the job is allowed to be delayed. A one-hour delay means that this job could run at any time from midnight to one o'clock on Monday morning. If you leave this line out, the default delay will be one minute. If you want the job to run exactly at midnight on Monday, you can change the <strong class="source-inline">1h</strong> to <strong class="source-inline">1us</strong>, which gives the greatest accuracy.</li>
				<li><strong class="source-inline">Persistent=true</strong>: So, what happens if your machine is shut down at midnight on Monday morning? Without this line, this job will just be skipped. With this line, the job will run the next time you boot up the machine.</li>
			</ul>
			<p>As you can see, there's no <strong class="source-inline">Unit=</strong> line in this timer, as there was in the previous example. So, by default, this <strong class="source-inline">fstrim.timer</strong> will activate the <strong class="source-inline">fstrim.service</strong>, which clears out unused blocks on your storage drives. Here's what the service looks like:</p>
			<p class="source-code">[Unit]</p>
			<p class="source-code">Description=Discard unused blocks</p>
			<p class="source-code">[Service]</p>
			<p class="source-code">Type=oneshot</p>
			<p class="source-code">ExecStart=/usr/sbin/fstrim -av</p>
			<p>Okay, so there's nothing new here. It's just a standard static, <strong class="source-inline">oneshot</strong> type of service, as we saw in the previous example.</p>
			<p>The <strong class="source-inline">fstrim.timer</strong> is disabled<a id="_idIndexMarker215"/> by default on the <a id="_idIndexMarker216"/>Alma machine, as we see here:</p>
			<p class="source-code">[donnie@localhost ~]$ systemctl is-enabled fstrim.timer</p>
			<p class="source-code">disabled</p>
			<p class="source-code">[donnie@localhost ~]$</p>
			<p>The <strong class="source-inline">fstrim.timer</strong> comes in handy if you're running either a solid-state drive or thinly provisioned storage. If you need to enable the timer, just do it the same way that you'd enable a service, as shown here:</p>
			<p class="source-code">[donnie@localhost ~]$ sudo systemctl enable --now fstrim.timer</p>
			<p class="source-code">[sudo] password for donnie: </p>
			<p class="source-code">Created symlink /etc/systemd/system/timers.target.wants/fstrim.timer → /usr/lib/systemd/system/fstrim.timer.</p>
			<p class="source-code">[donnie@localhost ~]$</p>
			<p>On the Ubuntu machine, you'll see that the <strong class="source-inline">fstrim.timer</strong> is enabled by default:</p>
			<p class="source-code">donnie@ubuntu2004:~$ systemctl is-enabled fstrim.timer</p>
			<p class="source-code">enabled</p>
			<p class="source-code">donnie@ubuntu2004:~$</p>
			<p>Next, let's take a <a id="_idIndexMarker217"/>closer look at how to define<a id="_idIndexMarker218"/> the <strong class="source-inline">OnCalendar</strong> times.</p>
			<h2 id="_idParaDest-97"><a id="_idTextAnchor098"/>Understanding calendar events for real-time timers</h2>
			<p>Okay, here's<a id="_idIndexMarker219"/> where things can <a id="_idIndexMarker220"/>get a bit sticky. I mean, configuring<a id="_idIndexMarker221"/> times for <strong class="source-inline">cron</strong> jobs is easy and straightforward. Understanding how to set up times for a <strong class="source-inline">systemd</strong> timer takes a bit of getting used to. Your best bet is to open the <strong class="source-inline">systemd.time</strong> man page, and scroll down to the <strong class="bold">CALENDAR EVENTS</strong> section. The explanation there isn't as clear as it could be, but you can pretty much figure it out by looking at the examples. Let's see if we can make any sense of it.</p>
			<p>In the <strong class="source-inline">fstrim.timer</strong> example that we just looked at, we saw the <strong class="source-inline">OnCalendar=weekly</strong> line, which causes the job to run at midnight every Monday morning. In the <strong class="bold">CALENDAR EVENTS</strong> section of the <strong class="source-inline">systemd.time</strong> man page, you'll see the complete list of predefined event times:</p>
			<p class="source-code">minutely → *-*-* *:*:00</p>
			<p class="source-code">hourly → *-*-* *:00:00</p>
			<p class="source-code">daily → *-*-* 00:00:00</p>
			<p class="source-code">monthly → *-*-01 00:00:00</p>
			<p class="source-code">weekly → Mon *-*-* 00:00:00</p>
			<p class="source-code">yearly → *-01-01 00:00:00</p>
			<p class="source-code">quarterly → *-01,04,07,10-01 00:00:00</p>
			<p class="source-code">semiannually → *-01,07-01 00:00:00</p>
			<p>Most of these are easy to figure out. The only ones that might throw you a bit are <strong class="source-inline">quarterly</strong> and <strong class="source-inline">semiannually</strong>. A <strong class="source-inline">quarterly</strong> job will run at midnight on the first day of January, April, July, and October, as denoted by the <strong class="source-inline">01,04,07,10</strong> part. A <strong class="source-inline">semiannually</strong> job will run at midnight on the first day of January and July, as denoted by the <strong class="source-inline">01,07</strong> part.</p>
			<p>Scroll down the <strong class="source-inline">systemd.time</strong> page a bit more and you'll see a whole big list of examples of how you can set up your job times. Rather than try to show you the whole list, I'll just show you one example, and then break it down for you. Here we go:</p>
			<p class="source-code">2003-03-05 → 2003-03-05 00:00:00</p>
			<p>The left-hand side shows you the date and time as a human would normally write it. The right-hand side shows you the value that you'd use as an <strong class="source-inline">OnCalendar=</strong> parameter. I chose this example because it uses all of the fields. (And yes, I know that 2003 is in the past, but this is what's in the man page.) To create a job that would have run at midnight on March 3, 2003, the <strong class="source-inline">OnCalendar=</strong> line would look like this:</p>
			<p class="source-code">OnCalendar=2003-03-05 00:00:00</p>
			<p>Since that's <a id="_idIndexMarker222"/>several years in <a id="_idIndexMarker223"/>the <a id="_idIndexMarker224"/>past, let's fix this so that it will run in the future:</p>
			<p class="source-code">OnCalendar=2525-03-05 00:00:00</p>
			<p>Ah, yes.<em class="italic"> In the year 2525, if man is still alive, and if woman can still survive. . .</em> (Who besides me is old enough to remember that silly song?)</p>
			<p>Seriously though, this isn't near as hard as it first seems to be. We have <strong class="source-inline">Year-Month-Date</strong>, followed by <strong class="source-inline">Hour:Minute:Second</strong> in 24-hour format. So yeah, it's actually quite easy-peasy. Now, let's say that we want this to run every day at 6:15 in the evening. We'll just replace the <strong class="source-inline">Year-Month-Date</strong> fields with the standard wildcard symbol ( <strong class="source-inline">*</strong> ), and change the time:</p>
			<p class="source-code">OnCalendar=*-*-* 18:15:00</p>
			<p>That's good, but I've changed my mind about running it every single day. I think I'll change it so that it will only run on the fifth day of every month, like so:</p>
			<p class="source-code">OnCalendar=*-*-05 18:15:00</p>
			<p>Nah, that's not often enough. Let's make it run on the fifth, tenth, and fifteenth days of every month:</p>
			<p class="source-code">OnCalendar=*-*-05,10,15 18:15:00</p>
			<p>The <strong class="source-inline">Day-of-Week</strong> field is optional. Let's make the job run on the fifth, tenth, and fifteenth days of the month, but only if they happen to fall on either a Monday or a Wednesday:</p>
			<p class="source-code">OnCalendar=Mon,Wed *-*-05,10,15 18:15:00</p>
			<p>Better yet, let's just make it run every Monday and Wednesday:</p>
			<p class="source-code">OnCalendar=Mon,Wed *-*-* 18:15:00</p>
			<p>You can use the tilde ( <strong class="source-inline">~</strong> ) symbol to count a specified number of days back from the end of a month. To <a id="_idIndexMarker225"/>have the <a id="_idIndexMarker226"/>job<a id="_idIndexMarker227"/> run on the third from last day of every February, just do this:</p>
			<p class="source-code">OnCalendar=*-02~03 18:15:00</p>
			<p>Now, let's make the job run on the last Monday of every May:</p>
			<p class="source-code">OnCalendar=Mon *-05~07/1 18:15:00</p>
			<p>Finally, let's get really crazy and make the job run every ten minutes:</p>
			<p class="source-code">OnCalendar=*:00/10</p>
			<p>Okay, that should be enough to give you a clue. If you need to see any more examples, just look at the <strong class="source-inline">systemd.time</strong> man page.</p>
			<h1 id="_idParaDest-98"><a id="_idTextAnchor099"/>Creating timers</h1>
			<p>Creating your<a id="_idIndexMarker228"/> own timer is a two-stage process. You'll first create the service that you want to run, and then you'll create and enable the timer. </p>
			<h2 id="_idParaDest-99"><a id="_idTextAnchor100"/>Creating a system-level timer</h2>
			<p>Let's say that <a id="_idIndexMarker229"/>you're a security-conscious soul who suspects that someone might try to plant some rootkits on your machines. You want to set up Rootkit Hunter so that it will run every day after work hours. </p>
			<p class="callout-heading">Note</p>
			<p class="callout">I wanted to do this with both Ubuntu and Alma Linux. Unfortunately, there's a bug in the Rootkit Hunter package for Ubuntu that prevents Rootkit Hunter from updating its signature database. That's not too surprising, because Ubuntu quality control has always been somewhat less than perfect. So, for this example, we'll just go with Alma.</p>
			<p>Because there's a bug in the Rootkit Hunter package in Ubuntu, we'll just do this on the Alma machine. Rootkit Hunter isn't in the normal Alma repositories, so you'll first need to install the EPEL repository, like so:</p>
			<p class="source-code">sudo dnf install epel-release</p>
			<p class="source-code">sudo dnf update</p>
			<p class="source-code">sudo dnf install rkhunter</p>
			<p>Create <a id="_idIndexMarker230"/>the <strong class="source-inline">rkhunter.service</strong> file by doing:</p>
			<p class="source-code">sudo systemctl edit --full --force rkhunter.service</p>
			<p>Make the file look like this:</p>
			<p class="source-code">[Unit]</p>
			<p class="source-code">Description=Rootkit Hunter</p>
			<p class="source-code">[Service]</p>
			<p class="source-code">Type=oneshot</p>
			<p class="source-code">ExecStartPre=/usr/bin/rkhunter --propupd</p>
			<p class="source-code">ExecStartPre=/usr/bin/rkhunter --update</p>
			<p class="source-code">ExecStart=/usr/bin/rkhunter -c --cronjob --rwo</p>
			<p>Before we do the actual scan, we want to create the <strong class="source-inline">rkhunter.dat</strong> file to store file properties and update the database of rootkit signatures. We'll do that with the two <strong class="source-inline">ExecStartPre=</strong> lines. In the <strong class="source-inline">ExecStart=</strong> line, we have three options, as follows:</p>
			<ul>
				<li><strong class="source-inline">-c</strong>: This is the <em class="italic">check</em> option, which does the actual scan.</li>
				<li><strong class="source-inline">--cronjob</strong>: Normally, Rootkit Hunter will pause several times during a scan and wait for user input. This option causes Rootkit Hunter to complete its run without pausing.</li>
				<li><strong class="source-inline">--rwo</strong>: This option causes Rootkit Hunter to only report any problems that it finds.</li>
			</ul>
			<p>Before creating the timer, it's a good idea to start the service manually to verify that it works. We'll do that with:</p>
			<p class="source-code">[donnie@localhost ~]$ sudo systemctl start rkhunter</p>
			<p>When it's finished <a id="_idIndexMarker231"/>running, look at the <strong class="source-inline">/var/log/rkhunter/rkhunter.log</strong> file to verify that there aren't any problems. If everything looks good, we're ready to create the timer. Do that with:</p>
			<p class="source-code">[donnie@localhost ~]$ sudo systemctl edit --full --force rkhunter.timer</p>
			<p>For demonstration purposes, set the <strong class="source-inline">OnCalendar=</strong> time to just a few minutes into the future. That way, you won't have to wait long for it to run. When you're done, the file should look something like this:</p>
			<p class="source-code">[Unit]</p>
			<p class="source-code">Description=Rootkit Hunter</p>
			<p class="source-code">[Timer]</p>
			<p class="source-code">OnCalendar=*-*-* 17:50:00</p>
			<p class="source-code">Persistent=true</p>
			<p class="source-code">[Install]</p>
			<p class="source-code">WantedBy=timer.target</p>
			<p>Do a <strong class="source-inline">daemon-reload</strong>, and then enable the timer:</p>
			<p class="source-code">[donnie@localhost ~]$ sudo systemctl daemon-reload</p>
			<p class="source-code">[donnie@localhost ~]$ sudo systemctl enable --now rkhunter.timer</p>
			<p class="source-code">Created symlink /etc/systemd/system/timer.target.wants/rkhunter.timer → /etc/systemd/system/rkhunter.timer.</p>
			<p class="source-code">[donnie@localhost ~]$</p>
			<p>Now it's just a matter of waiting for the timer to run to see whether it works. After it has finished, you <a id="_idIndexMarker232"/>can view the results in the <strong class="source-inline">/var/log/rkhunter/rkhunter.log</strong> file. </p>
			<p>Next, let's allow a normal, non-privileged user to create a timer.</p>
			<h2 id="_idParaDest-100"><a id="_idTextAnchor101"/>Creating a user-level timer</h2>
			<p>You can try<a id="_idIndexMarker233"/> this demonstration on either the Ubuntu or the Alma virtual machine. I haven't shown much love to the Ubuntu machine for a while, so I'll go with that one.</p>
			<p>Now, let's say that you're just a normal user who wants to back up your home directory to one of those handy-dandy portable drives. You'll plug it into the USB port of your computer, and the system will automatically mount it under the <strong class="source-inline">/media/backup/</strong> directory. </p>
			<p class="callout-heading">Note</p>
			<p class="callout">If you don't have a portable backup drive, you can simulate this by manually creating a backup directory, and setting the permissions so that normal users can write to it, like this:</p>
			<p class="callout"><strong class="bold">sudo mkdir /media/backup</strong></p>
			<p class="callout"><strong class="bold">sudo chmod 777 /media/backup</strong></p>
			<p>Now it's just a matter of creating the service and the timer. Any non-privileged user can do that by using the <strong class="source-inline">--user</strong> option switch.</p>
			<p>As before, we'll start by creating the service, like this:</p>
			<p class="source-code">donnie@ubuntu2004:~$ systemctl edit --user --full --force backup.service</p>
			<p>This will automatically create the necessary files and directories under the <strong class="source-inline">/home/donnie/.config/</strong> directory. I'll use <strong class="source-inline">rsync</strong> to do the backup, so my <strong class="source-inline">backup.service</strong> file will look like this:</p>
			<p class="source-code">[Unit]</p>
			<p class="source-code">Description=Backup my home directory</p>
			<p class="source-code">[Service]</p>
			<p class="source-code">Type=oneshot</p>
			<p class="source-code">ExecStart=/usr/bin/rsync -a /home/donnie /media/backup</p>
			<p>I want to make <a id="_idIndexMarker234"/>sure that this works, so I'll do a <strong class="source-inline">daemon-reload</strong> and then try running the service manually before I create the timer:</p>
			<p class="source-code">donnie@ubuntu2004:~$ systemctl daemon-reload --user</p>
			<p class="source-code">donnie@ubuntu2004:~$ systemctl start --user backup.service</p>
			<p class="source-code">donnie@ubuntu2004:~$</p>
			<p>If it runs successfully, I should see a <strong class="source-inline">donnie/</strong> directory under <strong class="source-inline">/media/backup/</strong>:</p>
			<p class="source-code">donnie@ubuntu2004:~$ ls -l /media/backup/</p>
			<p class="source-code">total 20</p>
			<p class="source-code">drwxr-xr-x 6 donnie donnie  4096 May 21 15:58 donnie</p>
			<p class="source-code">drwx------ 2 root   root   16384 May 22 15:34 lost+found</p>
			<p class="source-code">donnie@ubuntu2004:~$</p>
			<p>So far, so good. Let's see what's in that <strong class="source-inline">donnie/</strong> directory:</p>
			<p class="source-code">donnie@ubuntu2004:~$ ls -la /media/backup/donnie/</p>
			<p class="source-code">total 44</p>
			<p class="source-code">drwxr-xr-x 6 donnie donnie 4096 May 21 15:58 .</p>
			<p class="source-code">drwxrwxrwx 4 root   root   4096 May 22 15:49 ..</p>
			<p class="source-code">-rw------- 1 donnie donnie 3242 May 21 22:07 .bash_history</p>
			<p class="source-code">-rw-r--r-- 1 donnie donnie  220 Feb 25  2020 .bash_logout</p>
			<p class="source-code">-rw-r--r-- 1 donnie donnie 3771 Feb 25  2020 .bashrc</p>
			<p class="source-code">drwx------ 2 donnie donnie 4096 Jan  6 01:47 .cache</p>
			<p class="source-code">drwxr-xr-x 4 donnie donnie 4096 May 21 20:30 .config</p>
			<p class="source-code">-rw------- 1 donnie donnie  263 Apr  3 19:00 .lesshst</p>
			<p class="source-code">drwxrwxr-x 3 donnie donnie 4096 May 21 15:58 .local</p>
			<p class="source-code">-rw-r--r-- 1 donnie donnie  807 Feb 25  2020 .profile</p>
			<p class="source-code">-rw-r--r-- 1 donnie donnie    0 Jan  6 01:47 .sudo_as_admin_successful</p>
			<p class="source-code">drwxr-xr-x 3 donnie donnie 4096 Jan  6 01:56 snap</p>
			<p class="source-code">donnie@ubuntu2004:~$</p>
			<p>Nice. The backup <a id="_idIndexMarker235"/>service works, and I have achieved coolness. Now, it's time to create the timer:</p>
			<p class="source-code">donnie@ubuntu2004:~$ systemctl edit --user --full --force backup.timer</p>
			<p>I'll just have it run daily at midnight, so I'll make it look like this:</p>
			<p class="source-code">[Unit]</p>
			<p class="source-code">Description=Back up my home directory</p>
			<p class="source-code">[Timer]</p>
			<p class="source-code">OnCalendar=daily</p>
			<p class="source-code">Persistent=true</p>
			<p class="source-code">[Install]</p>
			<p class="source-code">WantedBy=timer.target default.target</p>
			<p>Of course, if you don't want to wait around until midnight to see whether this works, just set the <strong class="source-inline">OnCalendar=</strong> time to whatever you want.</p>
			<p>Note that when we use the <strong class="source-inline">--user</strong> option, we need to have the <strong class="source-inline">default.target</strong> in the <strong class="source-inline">WantedBy=</strong> line.</p>
			<p>Next, I'll <a id="_idIndexMarker236"/>do a <strong class="source-inline">daemon-reload</strong> and enable the timer:</p>
			<p class="source-code">donnie@ubuntu2004:~$ systemctl daemon-reload --user</p>
			<p class="source-code">donnie@ubuntu2004:~$ systemctl enable --user --now backup.timer</p>
			<p class="source-code">Created symlink /home/donnie/.config/systemd/user/timer.target.wants/backup.timer → /home/donnie/.config/systemd/user/backup.timer.</p>
			<p class="source-code">Created symlink /home/donnie/.config/systemd/user/default.target.wants/backup.timer → /home/donnie/.config/systemd/user/backup.timer.</p>
			<p class="source-code">donnie@ubuntu2004:~$</p>
			<p>I can also use the <strong class="source-inline">--user</strong> switch to view information about this timer:</p>
			<p class="source-code">donnie@ubuntu2004:~$ systemctl list-timers --user</p>
			<p class="source-code">NEXT                        LEFT    LAST                        PASSED    UNIT         ACTIVATES     </p>
			<p class="source-code">Sun 2021-05-23 00:00:00 UTC 7h left Sat 2021-05-22 15:47:05 UTC 41min ago backup.timer backup.service</p>
			<p class="source-code">1 timers listed.</p>
			<p class="source-code">Pass --all to see loaded but inactive timers, too.</p>
			<p class="source-code">donnie@ubuntu2004:~$</p>
			<p>As things stand now, this timer will only run while I'm actually logged in to the system. To ensure that it runs even when I'm not logged in, I'll enable the <strong class="source-inline">linger</strong> function for myself:</p>
			<p class="source-code">donnie@ubuntu2004:~$ loginctl enable-linger donnie</p>
			<p class="source-code">donnie@ubuntu2004:~$</p>
			<p>Okay, I think<a id="_idIndexMarker237"/> that does it for this chapter. Let's go ahead and wrap it up.</p>
			<h1 id="_idParaDest-101"><a id="_idTextAnchor102"/>Summary</h1>
			<p>In this chapter, we've looked at <strong class="source-inline">systemd</strong> timers, and compared them to the legacy <strong class="source-inline">cron</strong> system. We looked at different timer options, and at different ways to specify when a timer should run. Finally, we looked at how to create timers for both system-level and user-level jobs.</p>
			<p>In the next chapter, we'll take a brief look at the bootup process under <strong class="source-inline">systemd</strong>. I'll see you there.</p>
			<h1 id="_idParaDest-102"><a id="_idTextAnchor103"/>Questions</h1>
			<ol>
				<li>How do <strong class="source-inline">cron</strong> and <strong class="source-inline">systemd</strong> timers differ?<p>a. It's much easier to set up <strong class="source-inline">systemd</strong> timers.</p><p>b. Non-privileged users can set up their own <strong class="source-inline">cron</strong> jobs, but they can't set up their own timers.</p><p>c. A <strong class="source-inline">cron</strong> job can run a command or script directly, but a <strong class="source-inline">systemd</strong> timer can only run an associated service.</p><p>d. Non-privileged users can set up their own <strong class="source-inline">systemd</strong> timers, but they can't set up their own <strong class="source-inline">cron</strong> jobs.</p></li>
				<li>What are the two ways of specifying when a job will run? (Choose two.)<p>a. monotonic</p><p>b. wallclock</p><p>c. calendartime</p><p>d. realtime</p></li>
				<li>Which of the following man pages would tell you how to format times for the <strong class="source-inline">OnCalendar=</strong> parameter?<p>a. <strong class="source-inline">systemd.time</strong></p><p>b. <strong class="source-inline">systemd.timer</strong></p><p>c. <strong class="source-inline">systemd.unit</strong></p><p>d. <strong class="source-inline">systemd.exec</strong></p></li>
				<li>Which of the following time configurations equates to the monthly setting?<p>a. <strong class="source-inline">*-01-01 00:00:00</strong></p><p>b. <strong class="source-inline">*-*-* 00:00:00</strong></p><p>c. <strong class="source-inline">*-*-01 00:00:00</strong></p><p>d. <strong class="source-inline">*-01-01 00:00:00</strong></p></li>
			</ol>
			<h1 id="_idParaDest-103"><a id="_idTextAnchor104"/>Answers</h1>
			<ol>
				<li value="1">c</li>
				<li>a, d</li>
				<li>a</li>
				<li>c</li>
			</ol>
			<h1 id="_idParaDest-104"><a id="_idTextAnchor105"/>Further reading</h1>
			<ul>
				<li>Comparing <strong class="source-inline">systemd</strong> timers with <strong class="source-inline">cron</strong>:<p><a href="https://trstringer.com/systemd-timer-vs-cronjob/">https://trstringer.com/systemd-timer-vs-cronjob/</a></p><p><a href="https://medium.com/horrible-hacks/using-systemd-as-a-better-cron-a4023eea996d">https://medium.com/horrible-hacks/using-systemd-as-a-better-cron-a4023eea996d</a></p></li>
				<li>Using <strong class="source-inline">systemd</strong> timers with Docker:<p><a href="https://matthiasadler.info/blog/running-scheduled-tasks-in-docker-containers-with-systemd/&#13;">https://matthiasadler.info/blog/running-scheduled-tasks-in-docker-containers-with-systemd/</a></p></li>
				<li>Using <strong class="source-inline">systemd</strong> timers as a <strong class="source-inline">cron</strong> replacement:<p><a href="https://www.maketecheasier.com/use-systemd-timers-as-cron-replacement/&#13;">https://www.maketecheasier.com/use-systemd-timers-as-cron-replacement/</a></p></li>
			</ul>
		</div>
	</body></html>