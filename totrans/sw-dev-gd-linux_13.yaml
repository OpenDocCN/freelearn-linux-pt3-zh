- en: '13'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Secure Remote Access with SSH
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The **Secure Shell Protocol** (**SSH**) is a Swiss Army knife – a do-everything
    tool – for creating secure connections and tunneling data through them. During
    your career, you’ll use SSH for a bit of everything:'
  prefs: []
  type: TYPE_NORMAL
- en: Securely logging in to a remote system
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Cloning your private Git repository
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Transferring files from your laptop to a server, or between servers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Mapping a web service behind a VPN to a local port on your laptop so that someone
    on your home network can use it
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Various other tasks that involve tunneling traffic or sending files through
    multiple network connections
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In this chapter, we’ll give you everything you need to be comfortable with the
    basics. You’ll learn how public key cryptography works, which is essential to
    being able to reason about these kinds of tools and their usage. You’ll create
    SSH keys and use them to log in to a remote server. To cement the basics, we’ve
    even created a small project for you, where you’ll set up key-based logins for
    a remote host that you work with often.
  prefs: []
  type: TYPE_NORMAL
- en: For those times when you inevitably have issues when using SSH, we’ve collected
    some of the most common SSH errors we see in the wild. You’ll learn what the most
    common error messages indicate, and how to use SSH’s built-in “debug” option to
    troubleshoot your way out of them.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we’ll cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: A primer in public key cryptography
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Message encryption
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Message signing
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: SSH keys
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Converting SSH2 keys to the OpenSSH format
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: File transfer
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: SSH tunneling
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The configuration file
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let’s jump right in with the very basics of what you need to understand about
    public key cryptography so that the rest of this chapter doesn’t just sound like
    obscure black magic to you.
  prefs: []
  type: TYPE_NORMAL
- en: Public key cryptography primer
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Depending on what path your career has taken, you may have already come across
    the topic of public key cryptography. While cryptography is its own field, and
    this is not a book about cryptography, it *is* important to have an understanding
    of the basics. Thankfully, the core concepts are very simple and will get you
    far. We’ll make this section as short as possible, and then dive right into the
    commands you need to configure and use secure access with SSH.
  prefs: []
  type: TYPE_NORMAL
- en: Public key cryptography is a system that uses two separate keys, called the
    public key and the private key. Together, these make up what is called a key pair.
    As the names imply, the public key is a key that can be shared with everyone,
    while the private key is supposed to remain private at all costs.
  prefs: []
  type: TYPE_NORMAL
- en: Message encryption
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Once you’ve created a key pair, any message that has been encrypted using that
    key pair’s public key can be decrypted with the corresponding private key.
  prefs: []
  type: TYPE_NORMAL
- en: Imagine a person named Alice, who wants to send Bob an encrypted message. To
    do this, Alice downloads Bob’s public key and uses it to encrypt the message.
    Alice then sends the encrypted message to Bob. As he owns the matching private
    key, Bob will be able to decrypt and read the message. Even if someone else sees
    the encrypted message, they won’t be able to decrypt and read it because only
    Bob has the private key.
  prefs: []
  type: TYPE_NORMAL
- en: For this reason, it is important to *never* share your private key with a third
    party. Doing so would be a breach of security.
  prefs: []
  type: TYPE_NORMAL
- en: Message signing
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'There is another way to use these two keys: they can be used to sign a message.
    “Signing” a message is a way to cryptographically prove that a message was really
    written by the person owning the key. This makes use of the fact that while a
    message encrypted with the public key can be decrypted with the private key, the
    reverse is also true – a message *encrypted* with the private key can be *decrypted*
    using the public key.'
  prefs: []
  type: TYPE_NORMAL
- en: When Alice wants to sign a message, the private key can be used to encrypt the
    message (or a cryptographically secure hash of the message). Everyone who possesses
    Alice’s public key can use it to decrypt the message and, if it works, knows that
    it must have been encrypted with Alice’s private key.
  prefs: []
  type: TYPE_NORMAL
- en: Both mechanisms, encryption and signing, are often used together. Additionally,
    signatures themselves are frequently used to ensure security (by verifying authorship)
    when you’re downloading software, for example, through package managers or app
    stores.
  prefs: []
  type: TYPE_NORMAL
- en: It’s worth noting that these core public-key encryption and signing mechanisms
    are used for everything from encrypting emails to securing HTTPS web traffic to
    thousands of other things in the modern world. In other words, Alice and Bob don’t
    have to be people; they can be computers, services, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: Now that you’ve seen the basic cryptographic building blocks that SSH takes
    advantage of to secure your remote access, you’re ready to make practical use
    of all of this fancy technology!
  prefs: []
  type: TYPE_NORMAL
- en: SSH keys
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'One of the first things you are likely to do when it comes to SSH is create
    your very own key pair. This will allow you to authenticate to an SSH server.
    A classic command for creating a key pair is this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: This will create an `ed25519` (a modern elliptic curve cryptography algorithm)
    key pair using `John Doe <john.doe@example.org>` as a comment. Comments are like
    the comments you know from programming languages, in that they can be any string
    of text and won’t interfere with anything on a functional level. In the case of
    SSH, this comment will be appended to your public key, making it easier to distinguish
    keys when they are uploaded to a server, for example, in an `authorized_keys`
    file. Later in this chapter, we’ll dive deeper into the `authorized_keys` files
    and how to use them to set up seamless, secure access to remote servers.
  prefs: []
  type: TYPE_NORMAL
- en: After you run this command, OpenSSH will ask you a few questions about where
    to store the key files it creates and what password you’d like to use to encrypt
    the private key. Since this will be the key used to access remote systems, make
    sure to set a strong password.
  prefs: []
  type: TYPE_NORMAL
- en: '**Note**'
  prefs: []
  type: TYPE_NORMAL
- en: By default, keys will be placed in your `~/.ssh` directory.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that you’ve created a key pair, it’s time to reiterate the most important
    practical point: never, ever share the private key. Doing so would allow a third
    party to impersonate you. No service should ever ask you to share your private
    key. The public key, which is supposed to be shared and is safe to make public,
    will contain a `.pub` suffix, so you can tell the difference.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Thankfully, the contents of these files look very different, so if you ever
    get confused, you can peek at them to see which is which:'
  prefs: []
  type: TYPE_NORMAL
- en: The public key is in the format of `<algorithm> <key> <comment>`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The private key starts with a line like `-----BEGIN OPENSSH PRIVATE KEY-----`,
    followed by the key and a similar ending line.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Be careful never to overwrite these key files, and ensure that you have stored
    both of them in a secure backup. Again, your password manager is a good choice
    for this. Many password managers even have a specific option to store private
    key files or generic text.
  prefs: []
  type: TYPE_NORMAL
- en: Exceptions to these rules
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For personal use – on your laptop, for example – you’ll always want to encrypt
    your private key (by specifying a password during key creation), and then never
    share it, as mentioned before.
  prefs: []
  type: TYPE_NORMAL
- en: However, there are some situations where it’s okay to break these rules – specifically
    when setting up keys for automated systems to use. If you want your build server
    to authenticate to GitHub before checking out your code base, you’d likely use
    a key pair whose private key is *not* encrypted (unless you want to have to manually
    type in that password every time your build service runs).
  prefs: []
  type: TYPE_NORMAL
- en: Machine-to-machine authentication and encryption are great reasons to use cryptographic
    key pairs. Just be sure to always make dedicated, single-purpose key pairs for
    jobs like these, and do not reuse or share those key pairs across machines or
    services.
  prefs: []
  type: TYPE_NORMAL
- en: Logging in and authenticating
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Logging in to a remote system using SSH-based authentication looks similar
    to this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: '`user` is the username that you want to log in as, and `example.org` is a stand-in
    for any remote system you’d like to connect to. This is often just an IP address,
    as opposed to a fully qualified domain name.'
  prefs: []
  type: TYPE_NORMAL
- en: 'If you’re logging in with an SSH key, or you need to specify a specific key
    (identity, or `-i)`, it’ll look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: When accessing an SSH server that you have never connected to before, you will
    be presented with the fingerprint of the remote server. This allows you to make
    sure that the server you are talking to is indeed the one you intend to connect
    to and that no man-in-the-middle attack is taking place. You should make sure
    this is correct.
  prefs: []
  type: TYPE_NORMAL
- en: Once you type `yes` and mark that fingerprint as trusted, it will be saved to
    a file. Should it ever change – for example, if someone sets up a malicious server
    at the same IP address that your trusted server was using before – you will be
    notified by your SSH client, and authentication will not be possible.
  prefs: []
  type: TYPE_NORMAL
- en: After you mark the server as trusted, your local client and the server will
    negotiate which form of authentication to use. OpenSSH offers a wide variety of
    options, with the two most common ones involving a password or a key pair. Depending
    on which is chosen, OpenSSH will ask you to enter the password (or the password
    to decrypt your private key). Once the authentication step succeeds, you will
    be logged in.
  prefs: []
  type: TYPE_NORMAL
- en: 'Practical project: Set up a key-based login to a remote server'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Presuming you have access to a long-running Linux server that you want to allow
    key-based login on, follow these steps.
  prefs: []
  type: TYPE_NORMAL
- en: 'Step 1: Open your terminal on the SSH client (not the server)'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You’ll be using your local command-line environment for the rest of these steps.
  prefs: []
  type: TYPE_NORMAL
- en: 'Step 2: Generate the key pair'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If you’ve already set up a key pair because you were following along earlier
    in this chapter, good for you! You can skip this step.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you don’t yet have an SSH key pair, create one by typing the following command
    and hitting *Enter*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: As mentioned before, we strongly recommend adding a passphrase for extra security.
  prefs: []
  type: TYPE_NORMAL
- en: 'Step 3: Copy the public key to your server'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: After generating the keys, you’ll need to place the public key on your server.
    The public key usually has the extension `.pub` and by default will be located
    in your `~/.ssh` directory.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can manually copy it to the remote user’s `authorized_keys` file (a file
    that contains all authorized public keys for that user, one key per line), or
    you can condense all of those actions into a single command using the `ssh-copy-id`
    program:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Replace `username` with your user on the remote server and `remote_server_address`
    with the server’s IP address or domain name.
  prefs: []
  type: TYPE_NORMAL
- en: This command will ask for your user password on the remote server. After entering
    it, the public key will be appended to the `~/.ssh/authorized_keys` file of the
    remote user’s home directory. This allows you to log in and execute commands on
    the remote machine without being prompted for a password.
  prefs: []
  type: TYPE_NORMAL
- en: 'Step 4: Test it out!'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now try logging in to the server:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: If everything worked, you should be logged in without being asked for a password
    (unless you set up a passphrase for your SSH key). Instead of using a small password
    string that might be guessed by an attacker, you’re now using a *much* more secure
    cryptographic key to authenticate yourself.
  prefs: []
  type: TYPE_NORMAL
- en: Welcome to the wonderful world of secure, password-free SSH access!
  prefs: []
  type: TYPE_NORMAL
- en: Converting SSH2 keys to the OpenSSH format
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When not using a Unix-based operating system, you’ll often come across the SSH2
    public key format. PuTTY is probably the most famous software using this format
    and many people using Windows use it to connect via SSH. To connect to an **SSH
    File Transfer Protocol** (**SFTP**) server, Git repository, or other system that
    uses the OpenSSH key format, you need to convert an SSH2 public key into the OpenSSH
    format. Here is how to convert it.
  prefs: []
  type: TYPE_NORMAL
- en: What we are trying to achieve
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We start with an SSH2-formatted public key that looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'The goal is to convert it to an OpenSSH public key like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: How to convert the SSH2-formatted key to OpenSSH
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `ssh-keygen` command, which we used to create a new key, can also convert
    it with this very simple command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: The command above will take the key from the file `ssh2.pub` and write it to
    `openssh.pub`.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you just want to look at the OpenSSH key material or have it ready for copying
    and pasting, then you don’t have to worry about piping stdout into a file (the
    same command as above, without the last part):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: This will simply display the public key in the OpenSSH format.
  prefs: []
  type: TYPE_NORMAL
- en: 'A more practical example of this might be converting and appending a coworker’s
    key to a server’s `authorized_keys` file. This can be achieved using the following
    command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: After this, a coworker using the relevant private key will be able to log in
    to the system as the user who runs this command.
  prefs: []
  type: TYPE_NORMAL
- en: 'The other direction: Converting SSH2 keys to the OpenSSH format'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The opposite – converting OpenSSH to SSH2 keys – is also possible. Simply use
    the `-e` (for export) flag, instead of `-i` (for import):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: SSH-agent
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When you’re frequently logging in to servers using SSH keys, it can be annoying
    to have to retype your private key password over and over, every time you connect
    (or reconnect) to a host. SSH-Agent allows you to store an identity (private key)
    for a local session – in other words, it lets you decrypt your private key once,
    and then keep it in memory until you log out or start a new shell session. This
    means that you add an identity (key pair) once, and get to use it over and over
    again without re-decrypting your private key.
  prefs: []
  type: TYPE_NORMAL
- en: '**Note**'
  prefs: []
  type: TYPE_NORMAL
- en: The SSH Agent doesn’t always run in your local shell session – various IDEs,
    window managers, desktop managers, and password managers can also run an agent
    for you. You’ll know this is the case when you only have to enter the password
    for an identity once.
  prefs: []
  type: TYPE_NORMAL
- en: 'To add a key to the agent, just use the `ssh-add` command – the argument is
    the path to your private key for that identity:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'We recommend that you make it a habit to use the `–t` option, which adds a
    time limit to how long your keys are kept decrypted in memory. The following command
    is the same as the one above, except it sets a time limit of 30 seconds, after
    which the agent will delete the keys from memory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'To show which keys have been added to the agent, use the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'To remove all identities from the SSH agent, use `-D`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: '**Note**'
  prefs: []
  type: TYPE_NORMAL
- en: If you’ve added more than three identities to the agent, you may still have
    to specify `-i $YOUR_IDENTITY` when logging in via SSH. This is because most servers
    are configured to reject logins after three incorrect attempts, and SSH will try
    each of the keys stored in the agent, one by one, when logging in. If the first
    key doesn’t work, it’ll try the second one, and so on. If the server aborts the
    login attempt after three tries, you’ll never get to the fourth key in your agent.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can enable agent forwarding when using SSH to log in to remote machines
    with `-A`; however, you should do so sparingly and carefully, for reasons we’ll
    explain:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: After logging in to `remotehost` with this command, SSH will forward your keys
    to that host so you can use them to jump to additional hosts from there. The reason
    we recommend doing this sparingly is that it allows a compromised host to see
    your private keys, which we’ve hopefully taught you should always stay private,
    preferably on your machine or, during your wildest moments, in your password manager.
    In other words, if `remotehost` has been hacked, then your SSH keys are now compromised.
  prefs: []
  type: TYPE_NORMAL
- en: 'One final note about security: some Linux desktop environments like GNOME/MATE
    will keep your SSH key in memory indefinitely when you use and decrypt it once.
    This happens by default and is a security risk you should be aware of.'
  prefs: []
  type: TYPE_NORMAL
- en: Common SSH errors and the -v (verbose) argument
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `-v` flag in the SSH command enables verbose mode, which prints out a detailed,
    step-by-step log of the connection process. This feature is particularly useful
    for diagnosing common issues such as authentication failures, connection timeouts,
    and key mismatches. Use it like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: You’ll receive step-by-step information about each stage of the SSH handshake
    and connection, making it easier to identify and resolve any issues that may arise.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are some of the frequent errors that you might encounter, which verbose
    output can help you diagnose:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Permission Denied (public key/password)**: This indicates that the server
    rejected your login attempt. The verbose log will show you which keys were tried,
    helping you to pinpoint whether the correct key was used or even offered. This
    is an *incredibly* common issue when you have more than three key pairs stored
    on the client, and the server only allows three tries.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Connection Timed Out**: If the connection is taking too long, you might have
    a network issue or an incorrect IP address or port. The `-v` flag will show where
    the process gets stuck, helping you understand whether the client even reached
    the server.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Connection Refused**: This usually means that SSH isn’t running (or reachable)
    on the target port on the server. The verbose output will clearly indicate that
    the connection attempt was rejected, helping you focus on firewall rules or SSH
    server settings.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Host Key Verification Failed**: The server’s key doesn’t match the one saved
    in your system’s `known_hosts` file. The `–v` flag will show the mismatched keys,
    at which point you can focus on figuring out **why** (for example, is there a
    new server at this IP address or hostname?).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Could not resolve hostname**: Often related to DNS or network issues.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**No Route to Host**: This suggests network issues, maybe involving firewalls
    or incorrect routing.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Too Many Authentication Failures**: The maximum number of authentication
    attempts has been reached. The verbose mode will show all the methods tried, which
    may include unwanted or unexpected key offers.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Key Load Errors**: These usually indicate a problem with the format or permissions
    of your SSH key. The `-v` flag will identify which key the SSH client is trying
    to load, allowing you to check for formatting or permission issues.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using the `–v` flag will help you understand what exactly is going wrong and
    how you might be able to fix it. At the very least, it will help you start looking
    in the right direction.
  prefs: []
  type: TYPE_NORMAL
- en: File transfer
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the sections below we will explore the `sftp` and `scp` commands for file
    transfer. Going through a few examples using these commands will help you understand
    how you can handle files in most situations. That said, we will also cover file
    transfer without SFTP or SCP, in case they are disabled on the server.
  prefs: []
  type: TYPE_NORMAL
- en: SFTP
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: While OpenSSH is frequently used as a way to log in to remote systems, it also
    allows for file transfer independently of a login session. This is usually accomplished
    via the SFTP subsystem. Though SFTP resembles **File Transfer Protocol** (**FTP**),
    it is actually a completely custom protocol. Like FTP, SFTP allows authenticated
    users to transfer files to and from remote servers. Unlike FTP, which is insecure,
    SFTP’s authentication and file transfers are secure and fully encrypted.
  prefs: []
  type: TYPE_NORMAL
- en: There are many FTP clients that also support SFTP. One famous example is Filezilla,
    which has an excellent graphical user interface. However, since this is a book
    about the Linux command line, we will give you a basic overview of how to use
    SFTP on the command line.
  prefs: []
  type: TYPE_NORMAL
- en: 'Authentication is nearly identical to `ssh`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'After this, you’ll be presented with an FTP-style interface. It accepts simpler/modified
    versions of some shell commands that we have already gone over in previous chapters,
    and also introduces some new ones. Here are the most common commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '`help`: lists all commands and gives a short summary'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ls`: lists the contents of a remote directory'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`lls`: lists the contents of a local directory'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`cd`: changes the remote directory'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`lcd`: changes the local directory'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`pwd`: displays the remote directory you are in'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`lpwd`: displays the local directory you are in'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`get`: downloads a file from the remote server'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`put`: uploads a file to the remote server'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`chmod`: changes the permissions of a remote file or directory'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`chown`: changes the owner of a remote file or directory'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`quit`, `exit`, `bye`: exits SFTP (*CTRL*+*D* also works)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: SCP
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `scp` command is often a more practical way to upload and download files
    and directories than `sftp`. While it was historically independent of SFTP, today
    it uses the SFTP subsystem. It is meant to work as a replacement for the `cp`
    command, except that it allows copying to and from remote servers.
  prefs: []
  type: TYPE_NORMAL
- en: 'Commands are in the following format:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: '`$SOURCE`, `$DESTINATION`, or both can be remote systems; `scp` uses the SSH
    `user@example.org` syntax that you’ve already seen.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is what it looks like in practice:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'This will do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Connect to `example.org`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Authenticate as `user` (prompting you for a password unless you’re using SSH
    keys and the SSH agent).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Copy the file to the local path `/home/user/my_local_file`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: As you can see, the argument order is the same as for the Linux `cp` (copy)
    command.
  prefs: []
  type: TYPE_NORMAL
- en: 'Reversing the source and destination arguments – uploading a file, instead
    of downloading it – looks like you might expect:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Just like with `cp`, you can specify relative paths. The following command
    will copy the remote file to the current (local) directory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'As with the `cp` command, it is also possible to recursively copy an entire
    directory using the `-r` (recurse, also `-R` on some systems) flag:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Clever examples
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'As with all commands and tools, `ssh` and `scp` can also be used in scripts;
    for example, you can use ssh to quickly back up a database:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: If you use clever shell hacks like this in a script, take care to alert on errors;
    otherwise, the process might just silently remain stuck when it runs into an issue.
    For development situations, this kind of command can really come in handy.
  prefs: []
  type: TYPE_NORMAL
- en: Without SFTP or SCP
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In some rare situations, you’ll find that SFTP has been disabled on a server
    and you can only log in to an interactive shell. You still want to transfer a
    file to the remote system, and while it might be possible to just open a file
    in an editor, this isn’t always possible (for example, with whole directories
    or binary files). Here are a few tricks that you can use to still achieve your
    goal (they all make use of the Unix pipe in combination with an SSH session).
  prefs: []
  type: TYPE_NORMAL
- en: 'The simplest case is downloading a file from a remote server:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'This command will do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Log in to the server.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Run the command `cat /path/to/file` on the remote server, which will result
    in the contents of that file being streamed to `stdout`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`stdout` can then be locally piped into a file of our choice.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Like most well-behaved Unix software, errors and other possibly interfering
    output will be sent to `STDERR`, so you do not have to fear that a password prompt
    will get in the way and corrupt the file content being piped across your SSH tunnel,
    as an example.
  prefs: []
  type: TYPE_NORMAL
- en: Directory upload and .tar.gz compression
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Let’s do something different and upload a whole directory. Since this is potentially
    quite a lot of data, we will also compress it with the `tar` program. `tar` is
    a command that turns multiple files and/or directories into a single file (an
    “archive”).
  prefs: []
  type: TYPE_NORMAL
- en: 'It’s common to add a compression step after archiving – you’ve probably seen
    files with the `tar.gz` or `tar.bz2` endings, for example. This means that the
    files have first been archived into a single file with `tar`, and then compressed
    using `gzip` or `bzip2`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: Here, we first archive `/home/user/directory` with `tar`, turning the result
    into a stream of bytes.
  prefs: []
  type: TYPE_NORMAL
- en: The `-` is the target file. In the case that you want to store it immediately
    instead of streaming it to another program, this would be something like `/home/user/directory.tar.gz`.
    As is customary with many Unix commands, a dash symbolizes that this should instead
    be written to stdout.
  prefs: []
  type: TYPE_NORMAL
- en: This resulting stream will then be piped into the `ssh` process, which uses
    it as input (`stdin`) for a `tar` command on the remote system, which decompresses
    and unarchives that stream, writing the resulting directory to `/home/user/directory_to_upload`.
  prefs: []
  type: TYPE_NORMAL
- en: Tunnels
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'SSH tunnelling is used to transport data over an SSH connection. In the following
    sections, we will look at two methods of tunnelling: local forwarding and proxying.'
  prefs: []
  type: TYPE_NORMAL
- en: Local forwarding
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: SSH can create secure, encrypted tunnels to remote systems. This functionality
    is similar to what a VPN provides and can allow you to access services reachable
    from the remote system.
  prefs: []
  type: TYPE_NORMAL
- en: That’s powerful functionality, and with SSH, it’s actually simple to achieve.
    All you have to do is specify an additional argument, `-L`, with the destination
    and the local port to bind it to when establishing an SSH session.
  prefs: []
  type: TYPE_NORMAL
- en: 'Imagine a remote system running an HTTP server on port `8080`. You want to
    access it on your laptop, on port `3000`. Here is how to accomplish that with
    a simple command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: You can now open a browser and visit `http://localhost:3000/` to access the
    web server as if you were opening that browser on the remote system and visiting
    `http://localhost:8080`.
  prefs: []
  type: TYPE_NORMAL
- en: Proxying
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The same would be true if you wanted to access a server that you don’t have
    access to, but the remote server does. Imagine `app.example.org` is where your
    web application runs. This web application connects to a database server like
    PostgreSQL at `db.example.org`, which is only accessible from the `www.example.org`
    internal network. Like most production databases, it’s guarded by a firewall that
    prevents direct connections from outside.
  prefs: []
  type: TYPE_NORMAL
- en: 'From a network perspective, it looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '`(localhost) ——-> (app.example.org) ——-> (db.example.org)`'
  prefs: []
  type: TYPE_NORMAL
- en: 'You might want to use your local `psql` Postgres client to connect to that
    database. What you’d do is create a tunnel like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: This will open a new SSH session to `app.example.org`, reach out to the DB server
    from there, and map `db.example.org:5432` to `localhost:5000`.
  prefs: []
  type: TYPE_NORMAL
- en: Now, running `psql --port=5000 --host=localhost dbname` on your laptop will
    connect you to the Postgres database at `db.example.org:5432`, by bouncing through
    `app.example.org` to get access.
  prefs: []
  type: TYPE_NORMAL
- en: The configuration file
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'It is possible to specify host configuration in `.ssh/config`. This can be
    helpful in various situations, as it allows you to specify:'
  prefs: []
  type: TYPE_NORMAL
- en: Custom (friendly) names for hosts
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The default user to use
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The port
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Tunnels to open before connecting
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Identity files (keys)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Among many other things.
  prefs: []
  type: TYPE_NORMAL
- en: '**Note**'
  prefs: []
  type: TYPE_NORMAL
- en: If a server you connect to has a permanent IP address, it can make sense to
    specify it in your SSH config file to avoid relying on DNS or CDNs during a disaster
    recovery situation.
  prefs: []
  type: TYPE_NORMAL
- en: 'SSH configuration files aren’t particularly complicated, so we’ll show you
    an example here that uses many of the available features:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: Conclusion
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'OpenSSH is a very versatile tool, and we hope that the introduction you received
    in this chapter has motivated you to experiment and learn more. Just think of
    everything we’ve covered:'
  prefs: []
  type: TYPE_NORMAL
- en: You’ve learned the basics of how public key cryptography works, which is essential
    to being able to reason about these kinds of tools and their usage. You saw how
    to create SSH keys and use them for remote shell sessions.
  prefs: []
  type: TYPE_NORMAL
- en: Hopefully, you got some practical experience, too, by following along and setting
    up key-based logins for a remote host that you work with often. If that remote
    host happens to be on **Amazon Web Services** (**AWS**) or another platform that
    uses `.pem` keys, you learned how to convert between key formats (that trick alone
    is sure to impress your coworkers).
  prefs: []
  type: TYPE_NORMAL
- en: Even if you didn’t run into them yourself, we exposed you to some of the most
    common SSH errors we see people get stuck on in the wild, and how to track them
    down with the `–v` option.
  prefs: []
  type: TYPE_NORMAL
- en: 'We even covered SSH usage beyond remote interactive shell sessions – file transfers,
    tunneling network traffic, and setting up custom configurations for different
    servers. Surprisingly, there’s even more that OpenSSH can do:'
  prefs: []
  type: TYPE_NORMAL
- en: Encrypt and sign files with `ssh-keygen`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Add two-factor authentication via FIDO/U2F, storing your key on an external
    device
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Force certain commands to be run after login, which both limits the attack vector
    and allows SSH to be an interface to a service
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The OpenSSH project provides excellent documentation on its manual pages and
    on its website. If you have a problem that requires secure connections between
    machines and you want technology that is battle-tested and proven, OpenSSH is
    worth checking out. Now go forth and encrypt!
  prefs: []
  type: TYPE_NORMAL
- en: Learn more on Discord
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To join the Discord community for this book – where you can share feedback,
    ask questions to the author, and learn about new releases – follow the QR code
    below:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://packt.link/SecNet](https://packt.link/SecNet)'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/QR_Code1768422420210094187.png)'
  prefs: []
  type: TYPE_IMG
