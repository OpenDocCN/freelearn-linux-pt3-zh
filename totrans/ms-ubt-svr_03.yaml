- en: '3'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Managing Software Packages
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that you have a server installation set up, and you know how to manage users
    on it, it’s time to cover the management of software. The Ubuntu platform has
    a huge range of software available, featuring packages for everything from server
    administration to games. In fact, as of the time I’m writing this chapter, there
    are over 60,000 packages in Ubuntu’s repositories. That’s a lot of software packages,
    and in this chapter, we’ll take a look at how to manage them. We’ll cover how
    to install, remove, and update packages, as well as the use of related tools.
  prefs: []
  type: TYPE_NORMAL
- en: 'As we go through these concepts, we will cover:'
  prefs: []
  type: TYPE_NORMAL
- en: Understanding Linux package management
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding the differences between Debian and Snap packages
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Installing and removing software
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Searching for packages
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Managing package repositories
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Backing up and restoring Debian packages
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Cleaning up orphaned APT packages
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Taking advantage of hardware enablement updates
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To get started, let’s build an understanding of how software packages are distributed
    in Ubuntu, and the basic principles of the concept of package management.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding Linux package management
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Nowadays, *app stores* are all the rage on most platforms; typically, you’ll
    have one central location from which to retrieve applications, allowing you to
    install them on your device. Even phones and tablets utilize a central software
    repository in which software is curated and made available. The Android platform
    has Google Play, Apple has its App Store, and so on. For those that have used
    Linux for a while, this concept isn’t new. The concept of software repositories
    is similar to that of app stores and has been around within the Linux community
    since long before cellular phones even had color screens.
  prefs: []
  type: TYPE_NORMAL
- en: Linux has had package management since the ‘90s, initially popularized by **Debian**
    and then **Red Hat**. Software repositories are generally made available in the
    form of **mirrors**, to which your server subscribes. Mirrors are available across
    a multitude of geographic areas, so, typically, your installation of Ubuntu Server
    would subscribe to the mirror closest to you. These mirrors are populated with
    software packages that you’ll be able to install. Many packages depend on other
    packages, so various tools on the Linux platform exist to automatically handle
    these dependencies for you. Not all distributions of Linux feature package management
    and dependency resolution, but Ubuntu certainly does, benefiting from the groundwork
    already built by Debian.
  prefs: []
  type: TYPE_NORMAL
- en: Packages contained within these mirrors are constantly changing. Traditionally,
    an individual known as a **package maintainer** is responsible for one or more
    packages and ships new versions to the repositories for approval and, eventually,
    distribution to mirrors. Specific to Ubuntu’s repositories, a group of developers,
    rather than just a single maintainer, is responsible for maintaining packages.
    Most of the time, the new version of a package is provided in order to patch a
    security vulnerability, but otherwise it contains no new features. With the majority
    of Ubuntu’s packages being open source, anyone is able to look at the source code,
    find problems, and report issues. When vulnerabilities are found, the responsible
    team will review the claim and then release an updated version to correct it.
    This process happens very quickly, and I’ve seen severe vulnerabilities patched
    even on the same day that they were reported in some cases. Ubuntu developers
    are definitely on top of their game in terms of taking care of security issues.
  prefs: []
  type: TYPE_NORMAL
- en: New versions of packages are also sometimes feature updates, which are updates
    released to introduce new features not necessarily tied to a security vulnerability.
    This could be a new version of a desktop application such as Firefox or a server
    package such as MySQL. Most of the time, though, new versions of packages that
    are vastly different are held for the next Ubuntu release. The reason for this
    is that too much change can cause your server to not be as stable, and experience
    application or even entire OS-level crashes. Instead, known working and stable
    packages are preferred; however, given the fact that Ubuntu releases every six
    months, you don’t have to wait very long.
  prefs: []
  type: TYPE_NORMAL
- en: Specifically, feature updates in an Ubuntu release must go through an approval
    process before being made available in the default repositories, and these feature
    updates are specifically referred to as **Stable Release Updates** (**SRUs**).
    There’s an entire process around how these updates are approved, but the general
    takeaway is that there should be a good reason to implement a major version change
    in a stable, long-term Ubuntu release.
  prefs: []
  type: TYPE_NORMAL
- en: As a server administrator, you’ll often need to make a choice between security
    and feature updates. Security updates are the most important of all and allow
    you to patch your servers in response to security vulnerabilities. Sometimes,
    feature updates become required in your organization because it’s decided that
    new features may benefit you or may become required for current objectives. In
    this chapter, we won’t focus on installing security updates (we’ll take care of
    that in *Chapter 21*, *Securing Your Server*), but it’s important to understand
    the reasons new packages are made available to you.
  prefs: []
  type: TYPE_NORMAL
- en: Package management is typically very convenient in Ubuntu, with security updates
    and bug fixes coming regularly. With just one command (which we’ll get to shortly),
    you can install a package along with all of its dependencies. Having performed
    manual dependency resolution myself, I can tell you first-hand that having dependencies
    handled automatically is a wonderful thing.
  prefs: []
  type: TYPE_NORMAL
- en: The main benefit of how packages are maintained on a Linux server is that you
    generally don’t have to search the internet for packages to download, as Ubuntu’s
    repositories contain most of the ones you’ll ever need. As we continue through
    this chapter, you’ll come to know everything you need in order to manage this
    software.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the differences between Debian and Snap packages
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now, before we get into the ins and outs of managing packages, there are actually
    two completely different types of packages available to you, and you should understand
    the differences between them. As of the time of writing, we’re at a kind of crossroads
    regarding the way in which software is managed in Linux.
  prefs: []
  type: TYPE_NORMAL
- en: Traditionally, each distribution has its own package format and its own utilities
    to manage them. Ubuntu utilizes **Debian packages** (with package names ending
    in `.deb`) as the main package format, which Ubuntu inherits from the Debian distribution
    (Ubuntu is forked from Debian, which means that it uses Debian as a foundation).
    Ubuntu and Debian utilize the `apt` and `dpkg` commands to manage packages. On
    the other hand, distributions such as CentOS and Red Hat use **RPM packages**
    for their distributions, and the `dnf` command to manage them. There are other
    distributions and package formats as well, but for this book, we’ll stick with
    what’s available in Ubuntu. First, let’s discuss Debian packages.
  prefs: []
  type: TYPE_NORMAL
- en: Debian packages
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Debian packages** have been the main type of package in Ubuntu for the entire
    existence of the distribution so far. When you search online for how to install
    something in Ubuntu, chances are, you’re going to be installing a Debian package.
    These packages are known as Debian packages because Ubuntu is built from Debian
    sources and utilizes the same commands in order to install these packages. So
    even though Ubuntu is not Debian (Debian is a completely different distribution),
    they both use the same package format primarily.'
  prefs: []
  type: TYPE_NORMAL
- en: The naming may be confusing for newcomers, because if Ubuntu is considered a
    different distribution than Debian, then why refer to its packages as “Debian”
    packages? Debian packages have a filename that ends in `.deb`, and this package
    format originated in Debian. Ubuntu didn’t develop its own package type; it uses
    the same package format as Debian. Therefore, whether we are installing packages
    in Debian or Ubuntu using a command such as `apt`, Debian packages are the type
    of packages used for both.
  prefs: []
  type: TYPE_NORMAL
- en: If you’ve worked with Ubuntu before reading this book, then chances are, you’ve
    already used the `apt` series of commands to carry out some package management.
    Debian packages are great because when paired with the `apt` command, they are
    easy to use and handle dependency resolution for you. However, they present some
    challenges and major drawbacks.
  prefs: []
  type: TYPE_NORMAL
- en: First, the majority of the distribution is made up of Debian packages. This
    means that the Linux kernel, system packages, libraries, and security updates
    are all Debian packages that are installed when you install Ubuntu Server. When
    you install security updates, Debian packages are installed. The reason this may
    be a problem is that other software you’ll be installing, such as Apache, MariaDB,
    and so on, are also Debian packages, and may conflict with system packages when
    one package requires a pre-requisite package that conflicts with another.
  prefs: []
  type: TYPE_NORMAL
- en: This can lead to a situation where you can’t install packages at all. Package
    maintainers are generally good at avoiding this scenario, so conflicts aren’t
    incredibly common nowadays.
  prefs: []
  type: TYPE_NORMAL
- en: However, with Debian packages, if a system library gets corrupted, literally
    every piece of software that depends on it will fail. Ubuntu developers pay a
    great deal of attention to this, so you shouldn’t run into issues. But the truth
    is, this is a lot of work for the maintainers of Ubuntu to deal with.
  prefs: []
  type: TYPE_NORMAL
- en: Another concern with Debian packages is software availability. When a new major
    version of a package is released, it generally will not be offered to you until
    the next release of the distribution. This means that if you want a version of
    PHP, Apache, or some other piece of software that’s newer than what your current
    release of Ubuntu features, you generally will not have it offered to you. Instead,
    you typically wait until the next release of the entire distribution. There are
    some exceptions to this, such as Firefox in the desktop version of Ubuntu. As
    mentioned before, new major package versions are exceptions to the rule and come
    from the SRU approval process. While having tried-and-true software available
    that has been extensively tested offers better stability, sometimes you may require
    a newer version of particular software than what is available, which may lead
    you to consider alternative sources. After all, you don’t have to install a new
    version of Windows or macOS just to install newer applications!
  prefs: []
  type: TYPE_NORMAL
- en: '**Universal packages** are a new concept for Linux and are intended to be a
    single package format that multiple distributions recognize. The idea is that
    a developer only has to compile one package (instead of a separate package for
    each distribution) and users would only need to download a single package regardless
    of their chosen Linux flavor. The next section will discuss a type of universal
    package called Snaps.'
  prefs: []
  type: TYPE_NORMAL
- en: Snap packages
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As it stands today, developers would need to create multiple package types to
    support Linux. Perhaps they’ll create Debian packages for Debian itself and Ubuntu,
    and then RPM packages for CentOS, Red Hat Enterprise Linux, and SuSE. And while
    you may think that having to create two package types isn’t all that bad, consider
    that each of the RPM-based distributions needs its own specific RPM package, and
    you can see how it might be tedious to a developer to have to create five or more
    different packages for any one release of their software.
  prefs: []
  type: TYPE_NORMAL
- en: As a result of this, there’s a push to adopt a single package format that each
    distribution can install that is independent of the system package type. This
    concept is known as **universal packages**, and the idea is to have a standard
    package type that can be installed on any Linux distribution. As a result, developers
    would only have to create one package to have their application work on all the
    popular distros.
  prefs: []
  type: TYPE_NORMAL
- en: The Linux community commonly uses the word *distro* as a contraction of the
    term *distribution*.
  prefs: []
  type: TYPE_NORMAL
- en: Another benefit of universal packages is that they have all of their dependencies
    built in, so conflicts are less likely to occur; everything the application needs
    would be contained in one single package. This is great because the likelihood
    of you running into package conflicts with universal packages is next to non-existent.
  prefs: []
  type: TYPE_NORMAL
- en: As with all things in the IT industry, we can’t collectively be satisfied and
    decide on the proper technology. As such, there is debate among the community
    regarding which one of the multiple types of universal packages is the most suitable.
    I won’t get into the political debates in this book, as each has its strengths
    and weaknesses. But even easier for us in regards to Ubuntu Server, only one of
    them is ideal for server installations anyway. The competing technologies for
    universal packages include Flatpak, AppImage, and Snap packages.
  prefs: []
  type: TYPE_NORMAL
- en: Canonical, the makers of Ubuntu, understand the pain points that developers
    and users experience, and have been making a great effort to change how packages
    are managed. The type of universal package they’ve developed to address these
    concerns is known as the **Snap package**. Like all universal packages, Snap packages
    (or more simply, *Snaps*) have no impact on the underlying Debian packages at
    all and are completely independent, thus removing the possibility of conflicts
    with your system packages. This allows you to have a newer version of an application
    installed than what would otherwise be made available. Since Snaps are installed
    separately and independently from the underlying Debian packages, there’s no reason
    to withhold them. Snap packages are better in just about every way and are a great
    concept. The only downside might be that they are larger packages, since they
    include not only the application itself but also all the libraries they require
    in one single package. However, they’re really not that large and shouldn’t cause
    an issue with disk space. These packages are no bigger than a typical application
    on macOS or Windows.
  prefs: []
  type: TYPE_NORMAL
- en: So, which should you choose? It really just depends on your use case. Each of
    the universal package types is good at some things but has downsides. Flatpaks
    and AppImages are also great technologies, but where they fall behind for our
    use case is that they don’t support server (non-**Graphical User Interface**,
    or non-**GUI**) applications as well. This means that these package types are
    best for installing applications you’d normally find on a desktop Ubuntu installation,
    such as music players, browsers, graphical text editors, and so on. Snap packages
    target *both* GUI and non-GUI apps. Since server installations normally don’t
    contain a GUI at all, this makes our choice for us. It could be the case that
    Flatpaks and AppImages start supporting non-GUI apps better in the future, but
    for now, the choice of universal package format is simple.
  prefs: []
  type: TYPE_NORMAL
- en: As it stands today, though, the majority of the packages we’ll be installing
    are going to be Debian packages, as Snap packages are a bit slow to catch on.
    They’re making steady progress, but it remains to be seen how well the industry
    will embrace them. For now, it’s probably best to evaluate Snap packages when
    they’re available and to choose the most appropriate package type based on availability,
    security, version, and support.
  prefs: []
  type: TYPE_NORMAL
- en: With the differences between Snaps and Debian packages out of the way, let’s
    work through some examples of how to actually manage the software on our server.
    We’ll look at commands to search for available packages, and then we’ll install
    them and remove them.
  prefs: []
  type: TYPE_NORMAL
- en: Installing and removing software
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Before we begin, we will want to research a bit regarding the application we
    want to install. In Ubuntu, there are multiple ways of installing software, so
    the best way to find out how to get started is by simply checking the documentation
    on the website for the application we want to install. Typically, a Google search
    will do (just make sure you check the domain and are on the correct site). Most
    software will have installation instructions for various platforms, including
    Ubuntu. Most of the time, it will just tell you to download the Debian package
    format via the `apt install` command. Other times, the software may have a Snap
    available, or even a PPA repository (we’ll discuss PPA repositories later on in
    this chapter). Let’s start our package management journey by taking a look at
    the `apt` commands that are used to install Debian packages.
  prefs: []
  type: TYPE_NORMAL
- en: Managing Debian packages with apt
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**APT**, or **Advanced Package Tool**, is a suite of tools that allows us to
    install, remove, and update Debian packages. There are various sub-commands that
    make up this suite, which we’ll go over now. The most popular variation of the
    `apt` command is `apt install`. If you’ve ever read instructions for how to do
    something in Ubuntu, chances are you’ve already run that command to install a
    package. And that’s exactly what it does: it allows you to install packages for
    Ubuntu over the command line. For example, the following command will install
    the `openssh-server` package:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'You can also install multiple packages at a time by separating each with a
    space, instead of installing each package one at a time. The following example
    will install three different packages:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: In some books, blogs, and articles, you may see longer versions of `apt` commands,
    such as `apt-get install` instead of just `apt install`. Being able to shorten
    commands such as `apt-get install` to `apt install` is a relatively new feature
    of `apt` in Debian and Ubuntu. Both methods are perfectly valid, but simplifying
    APT commands down to just `apt` is preferred going forward.
  prefs: []
  type: TYPE_NORMAL
- en: So, what actually happens when you install a package with `apt`? If you’ve run
    through the process before, you’re probably accustomed to it already. But, typically,
    the process begins with `apt` calculating dependencies. The majority of packages
    require other packages to function, so `apt` will check to ensure that the package
    you’re requesting is available and that its dependencies are available as well.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, you’ll see a summary of the changes that `apt` wants to make to your
    server. In the case of installing the `apache2` package on an unconfigured Ubuntu
    Server, I enter the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'I see the following output on my system when it starts to install:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B18425_03_01.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 3.1: Installing Apache on an example server'
  prefs: []
  type: TYPE_NORMAL
- en: Even though I only asked for `apache2`, `apt` informs me that it also needs
    to install `apache2-bin`, `apache2-data`, `apache2-utils`, and `libapr1` (and
    others) in order to satisfy the dependencies for the `apache2` package. `apt`
    also suggests that I install `apache2-doc`, `apache2-suexec-pristine`, and a few
    others, though they are optional and are not required. You can install the suggested
    packages by adding the `--install-suggests` option to the `apt install` command,
    but that isn’t always a good idea as it may install a large number of packages
    that you may not need. You can, of course, cherry-pick the suggested packages
    individually by using the `apt` command to install any one or more of them manually.
  prefs: []
  type: TYPE_NORMAL
- en: Most of the time, though, you probably won’t want to do this; it’s usually better
    to keep your installed packages to a lean minimum and install only the packages
    you need. As we’ll discuss in *Chapter 21*, *Securing Your Server*, the fewer
    packages you install, the smaller the attack surface of your server.
  prefs: []
  type: TYPE_NORMAL
- en: 'While installing or updating packages via `apt`, you might see a message come
    up that asks you whether or not you’re comfortable with having background services
    restarted as part of the process:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B18425_03_02.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 3.2: Service restart prompt during package installation/upgrade'
  prefs: []
  type: TYPE_NORMAL
- en: We’ll cover concepts around process management in *Chapter 7*, *Controlling
    and Managing Processes*, so it’s not something you should focus on right now.
    For a quick description in order to hold you over until then, there’s services
    running in the background on all Linux servers, and each one provides a particular
    function. Restarting a service will ensure it restarts with all the latest patches
    and tweaks applied, but any user connected to one of the services you restart
    will get disconnected. For now, you can simply press Enter to accept the defaults
    anytime you see this message.
  prefs: []
  type: TYPE_NORMAL
- en: Another option that is common with installing packages via `apt` is the `-y`
    option, which assumes *yes* to the confirmation prompt where you choose if you
    want to continue or not. For example, my previous output included the line `Do
    you want to continue? [Y/n]`. If we had used `-y`, the command would have proceeded
    to install the package without any confirmation. This can be useful for administrators
    in a hurry, though I personally don’t see the need for this unless you are scripting
    your package installations. In fact, it can sometimes be a bad idea, because by
    assuming *yes*, you may be confirming something you’d later regret.
  prefs: []
  type: TYPE_NORMAL
- en: Another neat default in Ubuntu Server is that it automatically configures most
    packages to make their daemons start up and also be enabled so that they start
    with each boot. Using the earlier example of `apache2`, the `apache2` service
    will start and the application will automatically start running as soon as you
    install the package.
  prefs: []
  type: TYPE_NORMAL
- en: This may seem like a good idea for the sake of convenience, but not everyone
    prefers this automation. As I’ve mentioned, the more packages installed on your
    server, the higher the attack surface, but running services (also known as daemons,
    or units) are each a method of entry for miscreants should there be a security
    vulnerability. Therefore, some distributions don’t enable and start daemons automatically
    when you install packages. The way I see it, though, you should only install packages
    you actually intend to use, so it stands to reason that if you go through the
    trouble of manually installing a package such as `apache2`, you probably want
    to start using it.
  prefs: []
  type: TYPE_NORMAL
- en: 'When you install a package with the `apt` command, it searches its local database
    for the package you named. If it doesn’t find it, it will throw an error. Sometimes,
    this error may be because the package isn’t available or perhaps the version that
    `apt` wants to install no longer exists. Ubuntu’s repositories move very quickly;
    new versions of packages are added almost daily. When a new version of a package
    is added, its older equivalent may be removed. For this reason, it’s recommended
    that you update your package sources from time to time. Doing so is easy, using
    the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: This command doesn’t actually update any packages; it merely checks in with
    your local mirror to see if any packages have been added or removed and updates
    your local index. This command is useful because installations of packages can
    fail if your sources aren’t up to date. In most cases, the symptom will be that
    `apt` errors out of the process when it can’t find a package it’s looking for,
    something that would’ve been available normally.
  prefs: []
  type: TYPE_NORMAL
- en: 'Removing packages is also very easy and follows a very similar syntax; you
    would only need to replace the `install` keyword with `remove`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'And, just like with the `install` option, you can remove multiple packages
    at the same time. The following example will remove three packages:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'If you’d like to not only remove a package but also wipe out its configuration,
    you can use the `--purge` option:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: This will not only remove the package but wipe out its configuration directory
    (applications typically store their configuration files in a sub-directory of
    `/etc`).
  prefs: []
  type: TYPE_NORMAL
- en: So, that concludes the basics of managing Debian packages with `apt`. Now, let’s
    move on to managing Snaps.
  prefs: []
  type: TYPE_NORMAL
- en: Managing Snap packages with snap
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To manage Snap packages, we use the `snap` command. The `snap` command features
    several options we can use to search for, install, and remove Snap packages from
    our server or workstation.
  prefs: []
  type: TYPE_NORMAL
- en: 'To begin, we can use the `snap find` command along with a keyword to display
    a list of Snap packages available to us that match that keyword:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Basically, you just simply type the `snap find` command along with a search
    term to look for. One example could be the `nmap` application, which is a useful
    tool to have if we’re managing a network:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'In the case of `nmap`, this utility is available in Ubuntu’s default repositories,
    so you don’t need to use the Snap package to install it. Typically, though, the
    Snap version will be newer and have more features than what is available in the
    APT repositories. If we wish to install the Snap version, we can use the following
    command to do so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: With the `install` option, we need to use `sudo` since the act of installing
    a package makes changes on the server. For a simple `find`, we can omit `sudo`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have `nmap` installed, we can check the location of the `nmap`
    binary with the `which` command. We can use the `which` command to find the location
    of the binary file for commands that are available—it will show the path to the
    binary if the appropriate package is installed. If the command is not available,
    the `which` command will show no output. So, if we run the following command,
    we should now see the path of that binary printed to the screen:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'This will return the following output, showing that the Snap version of `nmap`
    is run from a special place:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B18425_03_03.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 3.3: Checking the location of the nmap binary'
  prefs: []
  type: TYPE_NORMAL
- en: Now, when we run `nmap`, we’re actually running it from `/snap/bin/nmap`. If
    we were to install `nmap` via `apt`, it would run from `/usr/bin/nmap` instead.
    If we also have the `nmap` utility installed from Ubuntu’s APT repositories, then
    we can run either one at any time by calling out the full path to the binary we
    want to run, since Snap packages are independent of the APT packages. For example,
    if we had `nmap` installed via both `snap` and `apt`, we could run Ubuntu’s version
    by running `/usr/bin/nmap` and the Snap version by running `/snap/bin/nmap`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Removing an installed Snap package is easy. We simply use the `remove` option:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: If we issue that command, then `nmap` (or whichever Snap package we designate)
    is removed from the system.
  prefs: []
  type: TYPE_NORMAL
- en: 'To update a package, we use the `refresh` option along with the name of a package
    to update:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'With that command, the package will be updated to the newest version available.
    Going even further, we can attempt to update every Snap on our server with the
    same command (without specifying a package):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, managing Snap packages is fairly straightforward. Using the
    `snap` suite of commands, we can install, update, or remove packages from our
    server or workstation. The `snap find` command allows us to find new Snap packages
    to install. Perhaps as the technology matures, we may find ourselves installing
    more Snap packages than Debian packages, but that remains to be seen. For now,
    it’s a nice benefit to have two options to consider when installing new software.
  prefs: []
  type: TYPE_NORMAL
- en: In addition to being able to install packages, there are some additional tips
    and considerations around searching for packages. After all, you can’t install
    a package if you don’t know what’s available. We’ll explore searching for packages
    in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Searching for packages
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Unfortunately, the naming conventions used for packages in Ubuntu Server aren’t
    always obvious. Worse, package names are often very different from one distribution
    to another even for the same piece of software. While this book and other tutorials
    online will outline the exact steps needed to install software, if you’re ever
    on your own, it really doesn’t help much if you don’t know the name of the package
    you want to install. In this section, I’ll try to take some of the mystery out
    of searching for packages.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the previous section, we went over searching for Snap packages, so I won’t
    repeat that here. The APT suite of utilities also has a means of searching for
    packages as well, which is the `apt search` command. We can use the following
    command to search for packages, by providing a keyword:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'The output from this command will show a list of packages that match your search
    criteria, with their names and descriptions. If, for example, you wanted to install
    the PHP plugin for Apache and you didn’t already know the name of the associated
    package, the following would narrow it down:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: In the output, we will get a list of more than a handful of packages, but we
    can deduce from the package descriptions in the output that `libapache2-mod-php`
    is most likely the one we want. We can proceed to install it using `apt`, as we
    would normally do.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we’re not sure whether or not this is truly the package we want, we can
    view more information regarding this (or any other) package with the `apt-cache
    show` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'The output of this command is illustrated in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B18425_03_04.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 3.4: Showing the info of a Debian package'
  prefs: []
  type: TYPE_NORMAL
- en: With this command, we can see additional details regarding the package we’re
    considering installing. In this case, we learn that the `libapache2-mod-php` package
    also depends on PHP itself, so that means if we install this package, we’ll get
    the PHP plugin as well as PHP itself.
  prefs: []
  type: TYPE_NORMAL
- en: Another method of searching for a package (if you have a web browser available)
    is to connect to the *Ubuntu Packages Search* page at [https://packages.ubuntu.com/](https://packages.ubuntu.com/),
    where you can navigate through the packages from their database for any currently
    supported version of Ubuntu. You won’t always have access to a web browser while
    working on your servers, but, when you do, this is a very useful way to search
    through packages, view their dependencies, descriptions, and more.
  prefs: []
  type: TYPE_NORMAL
- en: Using the `apt search` command, as well as the `snap find` command, should get
    you quite far in the process of determining the name of the packages you want
    to install. Package management skills come over time, so don’t expect to automatically
    know which packages to install right away. When in doubt, just perform a Google
    search, research the documentation of the software you want to run, and learn
    how to install it in Ubuntu. Typically, the instructions will lead you to the
    correct commands to use. The examples we’ll go over during the course of this
    book will guide you through the most common use cases for Ubuntu Server.
  prefs: []
  type: TYPE_NORMAL
- en: At this point, we should have a solid understanding of the different types of
    packages available and how to manage them. However, it’s sometimes the case that
    we need to run software on our server for which there is no package available
    within the standard repositories. Therefore, in the next section, we’ll learn
    how to add additional repositories from which to install software.
  prefs: []
  type: TYPE_NORMAL
- en: Managing package repositories
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Often, the repositories that come pre-installed with Ubuntu will suffice for
    the majority of the Debian packages you’ll install via APT. Every now and then,
    though, you may need to install an additional repository in order to take advantage
    of software not normally provided by Ubuntu, or versions of packages newer than
    what you would normally have available. Adding additional repositories allows
    you to subscribe to additional sources of software and install packages from them
    in the same way as you would from any other source.
  prefs: []
  type: TYPE_NORMAL
- en: Adding additional repositories should be considered a last resort, however.
    When you install an additional repository, you’re effectively trusting the author
    of that repository with your organization’s server. Although I haven’t ever seen
    this happen first-hand, it’s theoretically possible for authors of software to
    include back doors or malware in software packages (intentionally or unintentionally),
    and then make them available for others via a software repository. Therefore,
    you should only add repositories from sources that you have reason to trust.
  prefs: []
  type: TYPE_NORMAL
- en: In addition, it sometimes happens that a maintainer of a repository simply gives
    up on it and disappears. This I have seen happen first-hand. In this situation,
    the repository may go offline (which would show errors during `apt` transactions,
    indicating that it’s not able to connect to the repository), or worse, the repository
    stays online, but security updates are never made available, causing your server
    to become vulnerable to attack. Sometimes, you just don’t have a way around it.
    You need a specific application and Ubuntu doesn’t offer it by default. Your only
    option may be to compile an application from source or add a repository. The decision
    is yours, but just keep security in mind whenever possible. When in doubt, avoid
    adding a repository unless it’s the only way to obtain what you’re looking for.
    If you do add an additional repository and you haven’t seen packages from it updated
    in a decent amount of time, consider that a red flag and investigate whether or
    not the repository is abandoned. Repositories that are abandoned should be removed,
    and an alternative used in its place.
  prefs: []
  type: TYPE_NORMAL
- en: Adding additional repositories
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Software repositories are essentially URLs in a text file, stored in one of
    two places. The main Ubuntu repository list is stored in `/etc/apt/sources.list`.
    Inside that file, you’ll find a multitude of repositories for Ubuntu’s package
    manager to pull packages from. In addition, files with an extension of `.list`
    are read from the `/etc/apt/sources.list.d/` directory and are also used whenever
    you use `apt`. I’ll demonstrate both methods.
  prefs: []
  type: TYPE_NORMAL
- en: 'A typical repository line in either of these two files will look similar to
    the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: The first section of each line will be either `deb` or `deb-src`, which references
    whether the `apt` command will find binary packages (`deb`) or source packages
    (`deb-src`) there. Next, we have the actual URL that `apt` will use in order to
    reach the repository. In the third section, we have the codename of the release;
    in this case, it’s `jammy` (which refers to the codename for Ubuntu 22.04, `Jammy
    Jellyfish`).
  prefs: []
  type: TYPE_NORMAL
- en: If you weren’t already aware, the codename for each Ubuntu release is based
    on an animal. Often, the animal chosen for a release will be rare. For example,
    the previous LTS release featured the fossa, which is an animal from Madagascar
    that somewhat resembles a cat but with curved ears. This time around, the chosen
    animal is the jellyfish, which I’m sure the majority of my readers are already
    familiar with.
  prefs: []
  type: TYPE_NORMAL
- en: Continuing, the fourth section of each repository line refers to the `Component`,
    which references whether or not the repository contains software that is free
    and open source, and is supported officially by Canonical (the company that oversees
    Ubuntu’s development). The component can be `main`, `restricted`, `universe`,
    or `multiverse`. Repositories with a `main` component include officially supported
    software. This generally means that the software packages have source code available,
    so Ubuntu developers are able to fix bugs. Software marked `restricted` is still
    supported but may have a questionable license. `universe` packages are supported
    by the community, not Canonical themselves. Finally, `multiverse` packages contain
    software that is neither free nor supported, which you would be using at your
    own risk.
  prefs: []
  type: TYPE_NORMAL
- en: As you can see from looking at the `/etc/apt/sources.list` file on your server,
    it’s possible for a repository line to feature software from more than one component.
    Each repository URL may include packages from several components, and the way
    you differentiate them is to only subscribe to the components you need for that
    repository. In our previous example, the repository line included both `main`
    and `restricted` components. This means that, for that particular example, the
    `apt` utility will index both free (`main`) and non-free (`restricted`) packages
    from that repository.
  prefs: []
  type: TYPE_NORMAL
- en: You can add new repositories to the `/etc/apt/sources.list` file (and it will
    function just fine), but that’s not typically the preferred method. Instead, as
    I mentioned earlier, `apt` will scan the `/etc/apt/sources.list.d/` directory
    for text files ending with the `.list` extension. These text files are formatted
    the same as the `/etc/apt/sources.list` file in the sense that you include one
    additional repository per line, but this method allows you to add a new repository
    by simply creating a file for it, and you can remove the repository by simply
    deleting that file.
  prefs: []
  type: TYPE_NORMAL
- en: This is safer than editing the `/etc/apt/sources.list` file directly, since
    there’s always a chance you can make a typo and disrupt your ability to download
    packages from even the official repositories.
  prefs: []
  type: TYPE_NORMAL
- en: In addition, you may need to install a **GNU Privacy Guard** (**GnuPG**) key
    for a new repository, but this process differs from one application to another.
    Typically, the documentation will outline the entire process. This key basically
    protects you in that it makes sure that you’re installing signed packages. Not
    all developers protect their applications this way, but it’s definitely a good
    thing to do.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once you have the repository (and possibly the key) installed on your server,
    you’ll need to run the following command to update your package index:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: As mentioned earlier in this chapter, this command updates your local cache
    as to which packages are available on the remote server. APT is only aware of
    packages that are in its database, so you will need to sync this with that command
    before you’ll be able to actually install the software contained within the repository.
  prefs: []
  type: TYPE_NORMAL
- en: Adding Personal Package Archives
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: On the Ubuntu platform, there also exists another type of repository, known
    as a **Personal Package Archive** (**PPA**). PPAs are essentially another form
    of APT repository, and you’ll even interact with their packages with the `apt`
    command, as you would normally. PPAs are usually very small repositories, often
    including a single application that serves a single purpose. Think of PPAs as
    *mini-repositories*. A PPA is common in situations where a vendor doesn’t make
    their software available with their own repository and may only make their application
    available in the form of source code you would need to manually download, compile,
    and install. With the PPA platform, anyone can compile a package from source and
    easily make it available for others to download.
  prefs: []
  type: TYPE_NORMAL
- en: PPAs suffer from the same security concerns as regular repositories (you need
    to trust the vendor and so on), but are a bit worse considering that the software
    typically isn’t audited at all. In addition, if the PPA was to ever go down, you’d
    stop getting security updates for the application you install from it. Only use
    PPAs when you absolutely need to.
  prefs: []
  type: TYPE_NORMAL
- en: There is one use case for PPAs that may be compelling, specifically for a server
    platform that standard repositories aren’t able to handle very well, and that
    is software versioning. As I mentioned earlier, a major server component such
    as PHP or MySQL may be locked to a specific major version with each Ubuntu Server
    release. What do you do if you need to use Ubuntu Server, but the application
    you need to run is not available in the version your organization requires? In
    the past, you would literally need to choose between the distribution and the
    package, with some organizations even using a different distribution of Linux
    just to satisfy the need to have a specific application at a specific version.
    You can always compile the application from source (assuming its source code is
    available), but that can cause additional headaches in the sense that you’d be
    responsible for compiling new security patches yourself whenever they’re made
    available. PPAs potentially give you access to applications not normally available
    in the default repositories, and/or access to newer versions of packages than
    what is normally provided. This gives you, the server administrator, the ability
    to choose the approach that is best for your goal.
  prefs: []
  type: TYPE_NORMAL
- en: 'PPAs are generally added to your server with the `apt-add-repository` command.
    The syntax generally uses the `apt-add-repository` command, with a colon, followed
    by a username, and then the PPA name. The following command is a hypothetical
    example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: To begin the process, you would start your search by visiting Ubuntu’s PPA website,
    which is available at [https://launchpad.net/ubuntu/+ppas](https://launchpad.net/ubuntu/+ppas).
    There, you can search among the available PPAs.
  prefs: []
  type: TYPE_NORMAL
- en: Before adding a PPA to your server, it’s best to first research whether or not
    it’s being maintained well. For example, if the PPA hasn’t had any updated packages
    in a very long time, that’s cause for concern—security fixes are fairly common
    with most packages. If a package isn’t being regularly updated and has therefore
    gone “stale,” it may be best to avoid it as it may cause more harm than good.
  prefs: []
  type: TYPE_NORMAL
- en: Once you find a PPA you would like to add to your server, you can add it simply
    by finding the name of the PPA and then adding it to your server with the `apt-add-repository`
    command.
  prefs: []
  type: TYPE_NORMAL
- en: You should take a look at the page for the PPA, though, in case there are different
    instructions. For the most part, the `apt-add-repository` command should work
    fine for you. Each PPA typically has a set of instructions attached, so there
    shouldn’t be any guesswork required here.
  prefs: []
  type: TYPE_NORMAL
- en: So, what exactly does the `apt-add-repository` command do? Honestly, it’s not
    all that amazing. When you install a PPA, it’s essentially automating the process
    of adding a repository file to your `/etc/apt/sources.list.d` directory and installing
    its key. Therefore, you can uninstall a PPA by simply deleting its file.
  prefs: []
  type: TYPE_NORMAL
- en: PPAs are a very useful feature if harnessed with care. PPAs offer Ubuntu a flexible
    way of adding additional software that wouldn’t normally be made available, though
    you will need to keep an eye on such repositories to ensure they are properly
    patched when vulnerabilities arise and are used only when absolutely necessary.
    Always prefer packages from Ubuntu’s default repositories as well as Snaps, but
    PPAs offer you another option in case you can’t find what you need anywhere else.
  prefs: []
  type: TYPE_NORMAL
- en: After you’ve maintained a server for a while, or finished setting it up for
    a particular goal, you’ll have installed a plethora of packages to suit its purpose.
    Exporting a list of installed packages can make it easier to rebuild a server
    should the need arise, and we’ll look at one method of doing that in the next
    section.
  prefs: []
  type: TYPE_NORMAL
- en: Backing up and restoring Debian packages
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As you maintain your server, your list of installed packages will grow. If,
    for some reason, you needed to rebuild your server, you would need to reproduce
    exactly what you had installed before, which can be a pain. It’s always recommended
    that you document all changes made to your server via a change control process,
    but, at the very least, keeping track of which packages are installed is an absolute
    must. In some cases, a server may only include one or two extra packages in order
    to meet its goal, but, in other cases, you may need an exact combination of software
    and libraries in order to get things working like they were. Thankfully, the `dpkg`
    command allows us to export and import a list of packages to install.
  prefs: []
  type: TYPE_NORMAL
- en: 'To export a list of installed packages, we can use the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'This command will dump a list of package selections to a standard text file.
    If you open it, you’ll see a list of your installed packages, one per line. A
    typical line within the exported file will look similar to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'With this list, we can import our selections back into the server if we need
    to reinstall Ubuntu Server, or into a new server that will serve a similar purpose.
    First, before we manage any packages, we should update our index:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we’ll need to ensure we have the `dselect` package installed. The `dselect`
    package provides us with additional features when managing Debian packages. Its
    finer points are beyond the scope of this chapter, but for our current goal, we
    can use it to restore packages from our exported list. At your shell prompt, type
    `which dselect` and you should see output similar to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'If you don’t see the output, you’ll need to install the `dselect` package with
    `apt`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Once that’s complete, you can now import your previously saved package list,
    and have the missing packages reinstalled on your server. The following commands
    will complete the process:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: Normally, we simply use `apt` instead of `apt-get` nowadays, but oddly enough,
    the `dselect-upgrade` command only works with `apt-get`.
  prefs: []
  type: TYPE_NORMAL
- en: After you have run those commands, the packages that are contained in your packages
    list but aren’t already installed will be installed once you confirm the changes.
    This method allows you to easily restore the packages previously installed on
    your server, if for some reason you need to rebuild it, as well as setting up
    a new server to be configured in a similar way to an existing one.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have an understanding of how to export and import a list of installed
    packages, we can also take a look at how to clean up unneeded packages to ensure
    our server is as free as possible from unnecessary bloat.
  prefs: []
  type: TYPE_NORMAL
- en: Cleaning up orphaned apt packages
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As you manage packages on your server, you’ll eventually run into a situation
    where you’ll have packages on your system that are installed but not needed by
    anything. This occurs either when removing a package that has dependencies, or
    when the dependencies on an installed package change. As you’ll remember, when
    you install a package that requires other packages, those dependencies are also
    installed. But if you remove the package that required them, the dependencies
    will not be removed automatically.
  prefs: []
  type: TYPE_NORMAL
- en: 'To illustrate this situation, if I remove the `apache2` package from one of
    my servers, I will see the following extra information if I then try to install
    something else:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B18425_03_05.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 3.5: Output with orphaned packages shown'
  prefs: []
  type: TYPE_NORMAL
- en: In this example, I removed `apache2` (that was done before the screenshot was
    taken), then I went on to install `tmux`. The package I was trying to install
    is arbitrary; the important part is the text you see in the screenshot where it
    says `The following packages were automatically installed and are no longer required`.
    Basically, if you have orphaned packages on your system, Ubuntu will remind you
    periodically as you use the APT suite of tools. In this case, I removed `apache2`
    so all of the dependencies that were installed to support the `apache2` package
    were no longer needed.
  prefs: []
  type: TYPE_NORMAL
- en: In the screenshot, I’m shown a list of packages that APT doesn’t think I need
    anymore. It may be right, but this is something we would need to investigate.
    As instructed in the output, we can use the `apt autoremove` command as `root`
    or with `sudo` to remove them. This is a great way of keeping our installed packages
    clean but should be used with care. If you’ve just recently removed a package,
    it’s probably safe to do the cleanup manually.
  prefs: []
  type: TYPE_NORMAL
- en: Although we haven’t walked through updating packages (we’ll do that in *Chapter
    21*, *Securing Your Server*), a situation that may come up later is one in which
    you have outdated kernels that can be cleaned with the `autoremove` option. These
    will appear in the same way as the example orphans I was shown in the previous
    screenshot, but the names will contain `linux-image`. Take care with these; you
    should never remove outdated kernels from your server until you verify that the
    newly installed kernel is working correctly and the server doesn’t exhibit any
    unwanted or unexpected behavior. Generally, you would probably want to wait at
    least a week before running `apt autoremove` when kernel packages are involved.
  prefs: []
  type: TYPE_NORMAL
- en: When it comes to other packages, they are generally safe to remove with the
    `apt autoremove` command, since the majority of them will be packages that were
    installed as a dependency of another package that is no longer present on the
    system. However, double-check that you really do want to remove each of the packages
    before you do so. You can always reinstall a package if you didn’t mean to remove
    it, and as an added benefit, if you reinstall a package that was marked for auto-removal,
    it won’t show up in the output as an orphan package in the future.
  prefs: []
  type: TYPE_NORMAL
- en: As you’ve seen so far, there are a lot of options when it comes to managing
    software in Ubuntu, and as an administrator, you are able to choose the best possible
    method for your goal. Another special type of update is available, that can improve
    hardware support in a situation where your hardware is newer than your Ubuntu
    version, or provide compatibility for hardware that didn’t previously have support
    available.
  prefs: []
  type: TYPE_NORMAL
- en: Taking advantage of hardware enablement updates
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One issue in the Linux industry has been hardware support. This is problematic
    in various Linux distributions because you may find yourself in a situation where
    you’re using a server (or even a desktop or laptop) that was released with the
    latest processor and chipset, but no newer version of your Linux distribution
    has been released yet that includes updated drivers that support it. Unlike platforms
    such as Windows, hardware drivers are typically built right into the Linux kernel.
    So, if you have an old release (which would contain an older kernel), you might
    be out of luck for hardware support until the next version of your Linux distribution
    is released.
  prefs: []
  type: TYPE_NORMAL
- en: Thankfully, Ubuntu has come up with a system to address this problem, and it’s
    one of the many things that set it apart from other distributions. Ubuntu features
    a set of updates known as the **hardware enablement** (**HWE**) stack, which is
    an exclusive feature of **long-term support** (**LTS**) releases. We discussed
    the difference between LTS and regular releases back in *Chapter 1*, *Deploying
    Ubuntu Server*. HWE updates are optional, but they add additional compatibility
    with newer hardware that was released after the current LTS version was made available.
    A new HWE stack typically includes a new kernel and driver packages. However,
    since drivers are often built right into the Linux kernel, you’ll also get added
    support for things other than new video cards as well, such as newly released
    network cards.
  prefs: []
  type: TYPE_NORMAL
- en: HWE updates are generally made available from the second point release of an
    LTS version, and then again with each subsequent point release until the next
    LTS release becomes available. The new compatibility stack is **backported** from
    the most recent non-LTS release, which means that you get the same compatibility
    of the latest non-LTS release while being able to stay on an LTS release. For
    example, when Ubuntu 20.04.2 was released on February 4, 2021, it contained the
    kernel and driver packages backported from Ubuntu 20.10\. This means that you
    were able to take advantage of the newer hardware support of Ubuntu 20.10 while
    being able to remain on 20.04 LTS and benefit from the longer support cycle of
    the LTS release.
  prefs: []
  type: TYPE_NORMAL
- en: At the time of writing, Ubuntu 22.04 is the latest LTS release of Ubuntu, so
    hardware enablement hasn’t been added yet. Historically, it’s most likely the
    case that hardware enablement will play out in 22.04 LTS the same way as it has
    in previous releases. If that’s the case, then the updated packages will be made
    available once Ubuntu 22.04.2 is released.
  prefs: []
  type: TYPE_NORMAL
- en: Once the new HWE stack is made available, you can choose to install it or to
    remain on the original 22.04 kernel with no change. On the desktop version of
    Ubuntu, people that enjoy computer games can really benefit from these updates,
    as the new drivers enable better performance when it comes to video cards and
    support newer gaming hardware. When it comes to the scope of this book, the new
    hardware enablement benefits us a bit less than desktop users. The reason is that
    if your server is running fine with no issues, then there really isn’t any reason
    to install the new hardware enablement unless the updated kernel contains new
    features you’d like to take advantage of.
  prefs: []
  type: TYPE_NORMAL
- en: A frustrating experience that sometimes comes up is having Ubuntu complain that
    there are no network cards available, even though you do actually have one. I’ve
    seen this most often when purchasing a new physical server that contains the latest
    hardware. It can be very frustrating to power on a brand-new server, only to realize
    you can’t get a network connection at all. This is a classic symptom of needing
    an updated compatibility stack. Perhaps your network card was released after the
    release date of the current Ubuntu release. This scenario is a good example of
    why hardware enablement updates exist, and why you will probably end up using
    them sooner or later.
  prefs: []
  type: TYPE_NORMAL
- en: If you don’t opt in to the HWE updates, your server will always have the same
    hardware enablement (kernel, drivers, and so on) as it did when your installed
    LTS release was first published. In that case, your kernel and related packages
    will only be updated when you install new security updates. At a later date, you
    can opt in to HWE updates manually if you wish. Generally, you only do this if
    you’ve added new hardware to a physical server that requires a new kernel. If
    your server is working perfectly fine and you haven’t added new hardware, there’s
    probably no reason to install a new HWE stack.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you do decide to utilize these updates, there are two ways to do so. You
    can opt in to the newer HWE stack while installing Ubuntu Server, or you can manually
    install the required packages. At the time of writing, Ubuntu 22.04 is new to
    the scene, so it remains to be seen if the updated packages will be made available
    with 22.04.2, but it’s very likely given Ubuntu’s history. The following screenshot
    shows the first screen of the installer for Ubuntu 20.04.4\. Assuming Ubuntu 22.04
    follows the same plan, you’ll most likely see an option such as the one in the
    following screenshot once 22.04.2 is released:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B18425_03_06.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 3.6: Main menu of the installer for Ubuntu 20.04.4'
  prefs: []
  type: TYPE_NORMAL
- en: Notice the **Install Ubuntu Server with the HWE kernel** option. If you choose
    this option, then your installation of Ubuntu Server will contain the new HWE
    packages immediately.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you’ve already installed Ubuntu Server and you’d like to install the HWE
    updates afterward, you can do so from the terminal. In Ubuntu 20.04, for example,
    you were able to switch to the HWE kernel with the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: When Ubuntu 22.04 releases its newer HWE stack, a similar command will likely
    be used to install it. If you need a newer HWE kernel, refer to the instructions
    in Ubuntu’s documentation pages when that time comes.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we have taken a crash course in the world of package management.
    As you can see, Ubuntu Server offers an amazing number of software packages and
    various tools that we can use to manage them. We began the chapter with a discussion
    of how package management with Ubuntu works, then we worked through installing
    packages, searching for packages, and managing repositories. Snap packages were
    also covered, which is a newer technology that aims to enhance software distribution
    on Ubuntu.
  prefs: []
  type: TYPE_NORMAL
- en: In *Chapter 4*, *Navigating and Essential Commands*, we’ll take a look at foundational
    commands for navigating the Linux Shell, understanding the filesystem layout,
    and more.
  prefs: []
  type: TYPE_NORMAL
- en: Relevant video
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Linux Crash Course - APT (LearnLinuxTV): [https://linux.video/lcc-apt](https://linux.video/lcc-apt)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'LTSEnablementStack (Ubuntu wiki): [https://learnlinux.link/lts-es](https://learnlinux.link/lts-es)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Ubuntu Server Guide: [https://ubuntu.com/server/docs](https://ubuntu.com/server/docs)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Join our community on Discord
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Join our community’s Discord space for discussions with the author and other
    readers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://packt.link/LWaZ0](https://packt.link/LWaZ0)'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/QR_Code50046724-1955875156.png)'
  prefs: []
  type: TYPE_IMG
