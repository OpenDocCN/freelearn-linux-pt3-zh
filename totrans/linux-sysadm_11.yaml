- en: '11'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Logging Configuration and Remote Logging
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Logging is an important aspect of any operating system, including Linux. It
    provides a way to collect and analyze system events and activities, which can
    be useful for troubleshooting, monitoring, and auditing purposes. In this chapter,
    we will explore the different aspects of logging configuration and remote logging
    in Linux.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Logging configuration
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Log rotation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Journald
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Log forwarding
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Logging configuration
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Linux uses the syslog system for logging. The syslog daemon collects messages
    from different parts of the system and writes them to log files. The syslog configuration
    file is usually located at `/etc/syslog.conf` or `/etc/rsyslog.conf`, depending
    on the distribution. This file contains the rules that specify which messages
    to log and where to store them.
  prefs: []
  type: TYPE_NORMAL
- en: 'There is a critical parameter called `facility.severity` that is a crucial
    part of the logging configuration in Linux. It allows you to control which log
    messages should be recorded and where they should be stored. The facility and
    severity can be specified either numerically or using their symbolic names. For
    example, the following rule logs all messages with a severity level of warning
    or higher from the auth facility to the `/``var/log/auth.log` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'The target part of the configuration file specifies where to store the logged
    messages. The target can be a file, a remote host, or a program that processes
    the messages. The target syntax is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'The target type can be one of the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '`file`: Stores the messages in a local file'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`remote`: Sends the messages to a remote host using the syslog protocol'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`program`: Sends the messages to a local program for processing'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'For example, the following rule sends all messages with a severity level of
    error or higher to a remote host with an IP address of `192.168.1.100` using the
    syslog protocol:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'After modifying the syslog configuration file, the syslog daemon must be restarted
    to apply the changes. The command to restart the syslog daemon varies depending
    on the distribution. For example, on Ubuntu, the command is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: A log message’s primary focus is on log data. Alternatively stated, log data
    is the explanation behind a log message. If you use an image, file, or other resources
    on a website, the server that hosts your site will likely keep track of that fact.
    You may see who accessed a certain resource by examining the log data – in this
    case, the user’s username.
  prefs: []
  type: TYPE_NORMAL
- en: The term *logs* is shorthand for a collection of log messages that can be pieced
    together to provide context for an event.
  prefs: []
  type: TYPE_NORMAL
- en: 'Each entry in the log file can be roughly classified as one of the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Informational**: Purposely vague, these messages aim to inform users and
    administrators that a positive change has occurred. For instance, Cisco IOS will
    notify appropriate parties whenever the system reboots. However, caution is required.
    If a restart occurs at an inconvenient time, such as outside of maintenance or
    business hours, you may have cause for concern. The next few chapters of this
    book will teach you the knowledge and techniques you’ll need to deal with a situation
    like this.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Debug**: When something goes wrong with running application code, debug messages
    are sent by the system to help developers identify and address the problem.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Warning**: This is issued when something is lacking or needed for a system,
    but not to the point where its absence would prevent the system from functioning.
    Some programs may log a notice to the user or operator if they don’t receive the
    expected number of arguments on the command line, even though they can still operate
    normally without them.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Error**: In the event of an error, the computer system stores the relevant
    information in a log that may be analyzed later. An OS might generate an error
    log, for instance, if it is unable to synchronize buffers to disk. Unfortunately,
    many error messages simply provide a broad outline of the problem. More investigation
    is usually required to determine the root of a problem.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Alert**: The purpose of an alert is to draw your attention to a noteworthy
    development. In most cases, notifications will come from security-related devices
    and systems, although this is not always the case. All incoming data to a network
    can be inspected by an **intrusion prevention system** (**IPS**) placed at its
    entrance. It examines the information included in the packets to determine whether
    or not to enable a certain network connection. The IPS can react in several predetermined
    ways if it detects a potentially malicious connection. The action and the decision
    will be documented.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Next, we’ll quickly go through the processes involved in transmitting and collecting
    log data. Then, we’ll discuss what a log message is.
  prefs: []
  type: TYPE_NORMAL
- en: How does log data get sent and gathered?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: It’s easy to send and gather log data. Syslog is a protocol used for sending
    and gathering log data in computer networks. It is a standard protocol that allows
    different devices to send log messages to a central logging server or device.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s how it typically works:'
  prefs: []
  type: TYPE_NORMAL
- en: A device generates a log message. This could be a server, network device, application,
    or any other device that generates logs.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The device sends the log message to a syslog server using the syslog protocol.
    The syslog server can be located on-premises or in the cloud.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The syslog server receives the log message and processes it. It can store the
    log message in a file or database, or forward it to other systems for further
    analysis.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The syslog server can also apply filters and rules to the log messages it receives.
    For example, it can discard log messages that are not relevant or send an alert
    when a critical error occurs.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: System administrators and analysts can access the log data stored in the syslog
    server for troubleshooting, analysis, and reporting.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The following are some of the advantages of using a centralized log collector:'
  prefs: []
  type: TYPE_NORMAL
- en: It’s a centralized repository for all of your log messages
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Logs can be stored there for safekeeping
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This is where all of your server’s log information may be inspected
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Log analysis is crucial to the health of applications and server architecture,
    but it can be laborious if data is dispersed in multiple locations. Why not have
    just one consolidated logbook rather than a bunch of individual ones? Rsyslog
    may be the solution you’ve been looking for.
  prefs: []
  type: TYPE_NORMAL
- en: Using a centralized logging system, you may collect the logs from all of your
    servers and programs into one centralized area. In addition, this tutorial will
    help you implement centralized logging on Linux nodes by use of the rsyslog configuration.
  prefs: []
  type: TYPE_NORMAL
- en: This section is meant to be a practical example.
  prefs: []
  type: TYPE_NORMAL
- en: Checking rsyslog service on all servers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A high-performance log processing system called rsyslog is pre-installed and
    ready to use on both Debian and RHEL systems.
  prefs: []
  type: TYPE_NORMAL
- en: The syslog protocol has been improved with rsyslog, which gives it more contemporary
    and dependable features. These additional features include a large number of inputs
    and outputs, a modular design, and excellent filtering.
  prefs: []
  type: TYPE_NORMAL
- en: The most recent version of rsyslog as of this writing is v8.2112.0\. Therefore,
    you will verify the rsyslog service’s status and the version of rsyslog installed
    on your computer. This will guarantee that rsyslog is running at its most recent
    version.
  prefs: []
  type: TYPE_NORMAL
- en: Open a command prompt and use the following `sudo su` command to take control
    of all servers. When prompted, enter your password.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following screenshot, you’ll find that Centos 8 ships with rsyslog v8.2102.0
    by default:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.1 – Checking the rsyslog version](img/B18575_11_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 11.1 – Checking the rsyslog version
  prefs: []
  type: TYPE_NORMAL
- en: 'Check the status of the rsyslog service by running the `systemctl status` `rsyslog`
    command:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.2 – Checking the status of the rsyslog service](img/B18575_11_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 11.2 – Checking the status of the rsyslog service
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, the service is active and running.
  prefs: []
  type: TYPE_NORMAL
- en: 'To check the status of the rsyslog service on multiple servers, you can use
    a configuration management tool such as Ansible or write a simple bash script
    to automate the process. Here’s an example of how to check the rsyslog service
    on all servers using a bash script:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a file called `servers.txt` and add the list of servers you want to
    check, one per line:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create a new bash script called `check_rsyslog_service.sh` and add the following
    code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Make the script executable:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Run the script:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The script will iterate through the list of servers in `servers.txt` and execute
    the `systemctl status rsyslog` command over SSH to check the status of the rsyslog
    service on each server. The output will be displayed in the Terminal. You can
    modify the script to perform other actions on the servers, such as restarting
    the rsyslog service or updating the rsyslog configuration.
  prefs: []
  type: TYPE_NORMAL
- en: Configuring rsyslog for centralized logging
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Centralized logging using the `central-rsyslog` server can be set up after you’ve
    updated to the most recent version of rsyslog.
  prefs: []
  type: TYPE_NORMAL
- en: The central logging setup is created by turning on the rsyslog UDP input module,
    `imudp`, and building the rsyslog template to receive log messages from other
    servers. The `imudp` input module allows syslog messages to be broadcast over
    UDP to be received by the `central-rsyslog` server.
  prefs: []
  type: TYPE_NORMAL
- en: Enable the options shown in the following screenshot in `/etc/rsyslog.conf`
    (the rsyslog configuration file) before saving the file and closing the editor.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `imudp` input module needs to be configured to utilize the default UDP
    port of `514` to work:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.3 – imudp module configuration](img/B18575_11_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 11.3 – imudp module configuration
  prefs: []
  type: TYPE_NORMAL
- en: Then, create a new rsyslog template (`/etc/rsyslog.d/50-remote-logs.conf`) and
    paste the configuration indicated in *Figure 11**.4*.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following rsyslog template will allow you to collect logs from other servers
    and store them in the `/var/log/remotelogs/` directory on the `main-rsyslog` server:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.4 – Template configuration](img/B18575_11_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 11.4 – Template configuration
  prefs: []
  type: TYPE_NORMAL
- en: 'To establish a new log directory (`/var/log/remotelogs/`) owned by the root
    user with the `adm` group, run the following instructions. By doing this, the
    rsyslog service will be able to create logs in the `/``var/log/remotelogs` folder:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, change the ownership of the `remotelogs` folder:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'To check the rsyslog settings (`/etc/rsyslog.conf` and `/etc/rsyslog.d/50-remote-logs.conf`),
    simply execute the `rsyslogd` commands provided here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.5 – Checking the syntax](img/B18575_11_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 11.5 – Checking the syntax
  prefs: []
  type: TYPE_NORMAL
- en: 'After double-checking the settings, you can restart the rsyslog service using
    the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'The rsyslog service, which has the `imudp` input module enabled, has exposed
    the syslog protocol’s default UDP port, `514`. Now, hosts can communicate with
    the `main-rsyslog` server by sending their logs there:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'You can double-check that your ports have been properly opened by running the
    `ss` command, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Here’s the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.6 – Command to see ports listening](img/B18575_11_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 11.6 – Command to see ports listening
  prefs: []
  type: TYPE_NORMAL
- en: Syslog is a simple and efficient protocol for collecting and managing log data
    in a distributed network environment. It provides a centralized location for storing
    logs, which makes it easier to manage, monitor, and troubleshoot systems.
  prefs: []
  type: TYPE_NORMAL
- en: Sending logs to a centralized rsyslog server
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You’ve already taken the first step toward streamlined log handling by configuring
    syslog on the `main-rsyslog` server. But how do you know that the `main-rsyslog`
    server is receiving the logs? Logs can be sent from a remote client system to
    a `main-rsyslog` server by activating and configuring the rsyslog output module
    (`main-rsyslog`).
  prefs: []
  type: TYPE_NORMAL
- en: In this example, the `client01` machine uses the rsyslog output module, `omfwd`,
    to transmit logs to the `main-rsyslog` server.
  prefs: []
  type: TYPE_NORMAL
- en: To process messages and logs, the `omfwd` module must be installed (it will
    be already). It can be used in conjunction with rsyslog templates. Finally, the
    module uses the rsyslog action object to transmit the data through UDP and TCP
    to the specified destinations.
  prefs: []
  type: TYPE_NORMAL
- en: Set up the client machine so that it can submit logs to the `main-rsyslog` server.
  prefs: []
  type: TYPE_NORMAL
- en: Create a new rsyslog configuration (`/etc/rsyslog.d/20-forward-logs.conf`) in
    your preferred text editor and enter the settings shown in *Figure 11**.7*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Using the `SendRemote` template, log messages are formatted before being sent
    via the UDP protocol to the `main-rsyslog` server (`192.168.1.111`). In this case,
    the IP address should be replaced with the IP address of your primary rsyslog
    server:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.7 – Template for SendRemote](img/B18575_11_07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 11.7 – Template for SendRemote
  prefs: []
  type: TYPE_NORMAL
- en: The preceding screenshot shows the content of a template file for log forwarding.
  prefs: []
  type: TYPE_NORMAL
- en: 'Check if the syntax is correct by running this command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Restart rsyslog by running the `sudo systemctl restart rsyslog` command and
    check whether the syslog server is receiving logs from the client.
  prefs: []
  type: TYPE_NORMAL
- en: Log rotation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Log rotation is a crucial process in Linux systems to manage log files efficiently.
    As applications and services generate log data over time, log files can grow significantly,
    consuming disk space and potentially leading to performance issues. Log rotation
    allows for the periodic compression, archival, and removal of old log files, ensuring
    the system maintains a manageable log history.
  prefs: []
  type: TYPE_NORMAL
- en: In Linux, log rotation is typically handled by a log rotation tool called `logrotate`.
    The configuration file for `logrotate` is located at `/etc/logrotate.conf`, and
    it includes references to individual log rotation configurations in the `/``etc/logrotate.d/`
    directory.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s a step-by-step guide on how to configure log rotation in Linux:'
  prefs: []
  type: TYPE_NORMAL
- en: '`logrotate` pre-installed. However, if it’s not available on your system, you
    can install it using the package manager specific to your Linux distribution.
    For example, on Debian/Ubuntu-based systems, you can install it with the following
    commands:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE21]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '**Create a log rotation configuration file**: You can create a new log rotation
    configuration file for your specific application/service or use the default one.
    It’s recommended to create separate files for different applications for easier
    management.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Navigate to the `/etc/logrotate.d/` directory and create a new configuration
    file – for example, `myapp_logrotate`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: '`logrotate` configuration file follows a specific syntax. Here’s a basic example:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE24]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE25]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE26]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE27]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE28]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE29]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE30]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Replace `/path/to/your/logfile.log` with the actual path to your log file. Replace
    `<N>` with the desired number of log files to keep before removal (for example,
    `rotate 7` to keep 7 days’ worth of logs). Replace `<mode>`, `<user>`, and `<group>`
    with the appropriate permissions and ownership for the newly created log file.
  prefs: []
  type: TYPE_NORMAL
- en: Save the configuration file and exit the text editor.
  prefs: []
  type: TYPE_NORMAL
- en: '`logrotate` configuration is error-free, you can run the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The `-d` flag is for debugging, and it will show you what `logrotate` would
    do without actually rotating the log files.
  prefs: []
  type: TYPE_NORMAL
- en: '**Perform a manual log rotation**: Once you are confident that the configuration
    is correct, you can manually trigger log rotation with the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`logrotate` at regular intervals. You can add an entry to `crontab` using the
    following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Then, add the following line to run `logrotate` daily at midnight:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: Save `crontab` and exit the text editor.
  prefs: []
  type: TYPE_NORMAL
- en: Now, your log files will be automatically rotated and archived based on the
    configuration settings. You can adjust the rotation frequency and other options
    in the `logrotate` configuration file to suit your specific needs.
  prefs: []
  type: TYPE_NORMAL
- en: Journald
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Journal is part of systemd. Messages from various parts of a systemd-enabled
    Linux machine are collected here. This comprises notifications from the kernel
    and boot process, syslog, and other services.
  prefs: []
  type: TYPE_NORMAL
- en: Traditionally, during Linux’s boot process, the OS’s many subsystems and application
    daemons would each log messages in text files. Different levels of detail would
    be logged for each subsystem’s messages. When troubleshooting, administrators
    often had to sift through messages from several files spanning different periods
    and then correlate the contents. The journaling feature eliminates this problem
    by centrally logging all system and application-level messages.
  prefs: []
  type: TYPE_NORMAL
- en: The systemd-journald daemon is in charge of the journal. It gathers data from
    several resources and inserts the gathered messages into the diary.
  prefs: []
  type: TYPE_NORMAL
- en: When systemd is using in-memory journaling, the journal files are generated
    under the `/run/log/journal` folder. If there isn’t already such a directory,
    one will be made. The journal is generated with persistent storage in the `/var/log/journal`
    directory; again, systemd will establish this directory if necessary. Logs will
    be written to `/run/log/journal` in a non-persistent fashion if this directory
    is destroyed; systemd-journald will not recreate it automatically. When the daemon
    is restarted, the directory is recreated.
  prefs: []
  type: TYPE_NORMAL
- en: The `journalctl` command is useful for debugging services and processes since
    it allows you to examine and modify the systemd logs.
  prefs: []
  type: TYPE_NORMAL
- en: The `journalctl` command and its numerous display options will be described
    next, along with how to view systemd logs. Since each machine has its own set
    of records, the results will vary.
  prefs: []
  type: TYPE_NORMAL
- en: 'To show all journal entries, use the `journalctl` command without any options:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'The output shows the time range of the log data. The columns contain the following
    data in order from left to right:'
  prefs: []
  type: TYPE_NORMAL
- en: Date and time
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Host
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Log source
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Log message
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'To show logs specific to the current boot, use the `-b` tag, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'If you want to see the logs from the last 10 minutes, for example, then you
    can use `journalctl -S "10` `minutes ago"`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'If you want to display only kernel journal log messages, then use the `-k`
    option, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'You can also filter log messages based on priority using the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'The following are the priorities levels:'
  prefs: []
  type: TYPE_NORMAL
- en: '`0` or `emerg`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`1` or `alert`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`2` or `crit`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`3` or `err`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`4` or `warning`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`5` or `notice`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`6` or `info`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`7` or `debug`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can find all the parameters available for `journalctl` using the `man` `journalctl`
    command.
  prefs: []
  type: TYPE_NORMAL
- en: DMESG
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**dmesg** is a command-line tool in Linux that allows you to view the kernel
    ring buffer messages. The kernel ring buffer is a circular buffer in memory that
    stores messages generated by the kernel, such as hardware events, device driver
    information, and system error messages.'
  prefs: []
  type: TYPE_NORMAL
- en: The `dmesg` command displays the contents of this kernel ring buffer, allowing
    you to view messages that have been generated since the system was last booted.
    These messages can be useful for debugging system problems, identifying hardware
    issues, and monitoring system events.
  prefs: []
  type: TYPE_NORMAL
- en: 'Some of the common use cases of `dmesg` include the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '`dmesg` can be used to identify and diagnose system problems by displaying
    error messages, warnings, and other relevant information'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`dmesg` can provide information about hardware devices and drivers, such as
    when a device is detected or when a driver fails to load'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`dmesg` can be used to monitor system events, such as when a user plugs in
    a USB device or when a system service starts or stops'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Here are some commonly used options that are used with the `dmesg` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '`-T`: Displays the timestamp in human-readable format'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`-H`: Displays the output in a more human-readable format'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`-l level`: Displays only messages of the specified log level (`debug`, `info`,
    `notice`, `warning`, `err`, `crit`, `alert`, or `emerg`)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`-k`: Displays only kernel messages'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Overall, `dmesg` is a powerful tool that can help you troubleshoot system problems
    and monitor system events in Linux.
  prefs: []
  type: TYPE_NORMAL
- en: The `dmesg` command provides a window into the inner workings of Linux. This
    *fault finder’s friend* allows you to read and observe messages sent by the kernel’s
    hardware devices and drivers from the kernel’s internal ring buffer.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the ring buffer in Linux
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When a computer is powered on, several events occur in a specific order; in
    Linux and Unix-like systems, these activities are referred to as booting and startup,
    respectively.
  prefs: []
  type: TYPE_NORMAL
- en: After the initialization of the system has been completed by the boot procedures
    (BIOS or UEFI, MBR, and GRUB), the kernel is loaded into memory, the initial ramdisk
    (initrd or initramfs) is connected to the kernel, and systemd is launched.
  prefs: []
  type: TYPE_NORMAL
- en: The OS is handed over to the startup routines, which finish the setup. When
    a system is first booted, it may take a while for logging daemons such as syslogd
    and rsyslogd to become operational. The kernel features a ring buffer that it
    employs as a message cache to ensure that critical error messages and warnings
    from this phase of initialization are not lost.
  prefs: []
  type: TYPE_NORMAL
- en: A ring buffer is a special area of memory where messages can be stored. It has
    a standard size and straightforward construction. When it reaches capacity, newer
    messages replace older ones. It can be seen conceptually as a *circular buffer*.
  prefs: []
  type: TYPE_NORMAL
- en: Information such as device driver initialization messages, hardware messages,
    and kernel module messages are all kept in the kernel ring buffer. The ring buffer
    is a handy place to begin troubleshooting hardware faults or other startup issues
    because it stores these low-level messages.
  prefs: []
  type: TYPE_NORMAL
- en: 'With the `dmesg` command, you can examine the log of messages saved in the
    system’s ring buffer:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: I added `-T` to show the timestamps in a readable format, and `less` to make
    it scrollable.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is the output of the preceding command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: The `dmesg --follow` command is a variation of the `dmesg` command that continuously
    displays new messages as they are generated in the kernel ring buffer.
  prefs: []
  type: TYPE_NORMAL
- en: When you run `dmesg --follow` in a Terminal, it will display the most recent
    kernel messages and then continue to display any new messages that are generated
    in real time. This can be useful for monitoring system events as they occur or
    for diagnosing issues that may be occurring in real time.
  prefs: []
  type: TYPE_NORMAL
- en: The `--follow` option is equivalent to the `-w` or `--wait` option, which tells
    `dmesg` to wait for new messages to be added to the kernel ring buffer and display
    them as they come in.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are some use cases for the `dmesg --``follow` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '`dmesg --follow` to monitor the kernel messages as you plug or unplug devices,
    or as you interact with hardware'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`dmesg --follow` can help you see what’s happening in real time and identify
    any patterns or issues that may be causing the problem'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`dmesg --follow` to watch for any error messages or warnings that may be generated
    in the kernel ring buffer'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'It’s worth noting that because `dmesg --follow` continuously displays new messages,
    the output can quickly become overwhelming and difficult to read. To stop the
    `dmesg` command from running, you can press *Ctrl* + *C* in the terminal:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: Observe that you are not taken back to the prompt where you entered commands.
    Whenever fresh messages are received, `dmesg` will show them in the Terminal’s
    footer.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can see the last 15 messages, for example, by using the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'Alternatively, you can search for specific terms (for example, `memory`) using
    the `dmesg | grep -I` `memory` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: Use the `man` command to find out all the magic that you can do with one command.
    `dmesg` is a very powerful tool for investigating logs.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, you learned about logs and how to configure rsyslog for centralized
    logging. Using various rsyslog input and output plugins, you transmitted server
    logs over the network to the consolidated rsyslog server. Your rsyslog server
    is now the only location you need to look for logs.
  prefs: []
  type: TYPE_NORMAL
- en: We also provided examples of how to read systemd journal logs. The `journalctl`
    command is a powerful resource for diagnosing issues with Linux services and finding
    problems in the OS.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, you learned about the power of the `dmesg` command and how it can be
    used. `dmesg` is a powerful tool that can help you troubleshoot system problems
    and monitor system events in Linux.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will talk about centralized authentication, where you
    can use a single server for all your clients to authenticate against.
  prefs: []
  type: TYPE_NORMAL
