- en: '*Chapter 11*: Enhancing the Security of Containerized Workloads'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第11章*：增强容器化工作负载的安全性'
- en: Container platforms and management frameworks provide application-level abstraction
    to administrators and developers. Lightweight container frameworks allow for rapid
    development and deployment of new applications, whereas heavier container platforms
    allow for optimal resource consumption and highly resilient hosting platforms.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 容器平台和管理框架为管理员和开发者提供了应用层抽象。轻量级容器框架允许快速开发和部署新应用，而较重的容器平台则可以实现资源的最优消耗和高度弹性的托管平台。
- en: SELinux plays a vital role in many of these frameworks and platforms, ensuring
    that untrusted containers cannot escape or interact with resources they are not
    supported to interact with. In this chapter, we look at how SELinux is supported,
    ranging from `systemd-nspawn` to `podman` (and Docker), and finally in larger
    environments with Kubernetes. We also learn how to create custom SELinux domains
    for containers using the `udica` utility.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: SELinux在许多框架和平台中发挥着重要作用，确保不受信任的容器无法逃脱或与它们不应交互的资源进行交互。在本章中，我们将探讨SELinux如何得到支持，从`systemd-nspawn`到`podman`（以及Docker），最后是在更大的环境中与Kubernetes结合使用。我们还将学习如何使用`udica`工具为容器创建自定义的SELinux域。
- en: 'In this chapter, we''re going to cover the following main topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主要内容：
- en: Using SELinux with systemd's container support
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用SELinux与systemd的容器支持
- en: Configuring podman
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 配置podman
- en: Leveraging Kubernetes' SELinux support
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 利用Kubernetes的SELinux支持
- en: Technical requirements
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'Check out the following video to see the Code in Action: [https://bit.ly/34aHOfl](https://bit.ly/34aHOfl)'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 查看以下视频，观看代码实际运行： [https://bit.ly/34aHOfl](https://bit.ly/34aHOfl)
- en: Using SELinux with systemd's container support
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用SELinux与systemd的容器支持
- en: In [*Chapter 7*](B16276_07_Final_VK.xhtml#_idTextAnchor216), *Configuring Application-Specific
    SELinux Controls*, we introduced systemd as an SELinux-aware application suite,
    capable of launching different services with configurable SELinux contexts. Besides
    service support, systemd has quite a few other features up its sleeve. One of
    these features is `systemd-nspawn`.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 在[*第7章*](B16276_07_Final_VK.xhtml#_idTextAnchor216)，*配置特定应用的SELinux控制*中，我们介绍了systemd作为一个SELinux感知的应用套件，能够以可配置的SELinux上下文启动不同的服务。除了服务支持外，systemd还拥有其他不少功能。其中之一就是`systemd-nspawn`。
- en: With `systemd-nspawn`, systemd provides container capabilities, allowing administrators
    to interact with systemd-managed containers in an integrated way, almost as if
    these containers were services themselves. It uses the same primitives as LXC
    from the Linux Containers project (which was the predecessor of the modern container
    frameworks) and Docker, based upon namespaces (hence the `n` in `nspawn`).
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`systemd-nspawn`，systemd提供容器功能，允许管理员以集成的方式与systemd管理的容器进行交互，几乎就像这些容器本身就是服务一样。它使用与Linux
    Containers项目（现代容器框架的前身）和Docker相同的原语，基于命名空间（因此有`nspawn`中的`n`）。
- en: Informational note
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 信息性说明
- en: '**The Linux Containers project** has a product called **LXC** that combines
    several isolation and resource management services within the Linux kernel, such
    as **control groups** (**cgroups**) and namespace isolation. cgroups allow for
    capping or throttling resource consumption in the CPU, memory, and I/O, whereas
    namespaces allow for hiding information and limiting the view on system resources.
    Early versions of Docker were built upon LXC, although Docker has since embraced
    the Linux services itself directly without using LXC.'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: '**Linux Containers项目**有一个名为**LXC**的产品，它结合了Linux内核中的多个隔离和资源管理服务，如**控制组**（**cgroups**）和命名空间隔离。cgroups允许对CPU、内存和I/O的资源消耗进行限制或调节，而命名空间则允许隐藏信息并限制对系统资源的访问视图。Docker的早期版本是建立在LXC之上的，尽管Docker后来直接使用了Linux服务本身，而不再使用LXC。'
- en: SELinux-wise, the software running inside the container might not have a correct
    view on the SELinux state (depending on the container configuration) as the container
    is isolated from the host itself. SELinux does not yet have namespace support
    to allow containers or other isolated processes to have their own SELinux view,
    so if a container has a view on the SELinux state, it should never be allowed
    to modify it.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在SELinux方面，容器内运行的软件可能无法正确地查看SELinux的状态（这取决于容器配置），因为容器与主机本身是隔离的。SELinux目前尚不支持命名空间，无法让容器或其他隔离进程拥有自己的SELinux视图，因此，如果容器能够查看SELinux状态，它绝不应该被允许修改它。
- en: Now, unlike Docker, `podman`, and Kubernetes, which can use the sVirt approach
    we saw in [*Chapter 9*](B16276_09_Final_VK.xhtml#_idTextAnchor257), *Secure Virtualization*,
    the `systemd-nspawn` approach does not support this technology.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，与可以使用我们在[*第9章*](B16276_09_Final_VK.xhtml#_idTextAnchor257)中看到的sVirt方法的Docker、`podman`和Kubernetes不同，*安全虚拟化*，`systemd-nspawn`方法不支持此技术。
- en: Informational note
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 说明性备注
- en: The `systemd-nspawn` command might not be installed by default. On CentOS, Debian,
    and related distributions, the package that provides this tool is called `systemd-container`.
    Other distributions such as Gentoo and Arch Linux have it installed as part of
    the default systemd installation.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: '`systemd-nspawn`命令可能没有默认安装。在CentOS、Debian及相关发行版中，提供此工具的软件包名为`systemd-container`。其他发行版如Gentoo和Arch
    Linux则将其作为默认的systemd安装的一部分。'
- en: Let's see how `systemd-nspawn` works and what its SELinux support looks like.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看`systemd-nspawn`是如何工作的，以及它的SELinux支持情况。
- en: Initializing a systemd container
  id: totrans-19
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 初始化systemd容器
- en: 'To create a systemd container, we need to create a place on the filesystem
    where its files will be stored, and then call `systemd-nspawn` with the correct
    arguments. To prepare the filesystem, we can download prebuilt container images,
    or create one ourselves. Let''s use the Jailkit software, as used in [*Chapter
    7*](B16276_07_Final_VK.xhtml#_idTextAnchor216), *Configuring Application-Specific
    SELinux Controls*, and build a container from it:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建一个systemd容器，我们需要在文件系统中创建一个存放其文件的位置，然后使用正确的参数调用`systemd-nspawn`。为了准备文件系统，我们可以下载预构建的容器镜像，或自行创建一个。让我们使用Jailkit软件，正如在[*第7章*](B16276_07_Final_VK.xhtml#_idTextAnchor216)中使用的那样，*配置应用程序特定的SELinux控制*，并从中构建一个容器：
- en: 'First, create the directory the container runtimes will be hosted in:'
  id: totrans-21
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，创建容器运行时将托管的目录：
- en: '[PRE0]'
  id: totrans-22
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Edit the `/etc/jailkit/jk_init.ini` file and include the following section:'
  id: totrans-23
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编辑`/etc/jailkit/jk_init.ini`文件，并包含以下部分：
- en: '[PRE1]'
  id: totrans-24
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: This section tells Jailkit what it should copy into the directory, and which
    users to support.
  id: totrans-25
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 本节告诉Jailkit应该将哪些内容复制到目录中，并支持哪些用户。
- en: 'Execute the `jk_init` command to populate the directory:'
  id: totrans-26
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 执行`jk_init`命令以填充目录：
- en: '[PRE2]'
  id: totrans-27
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Finally, start the container using `systemd-nspawn`:'
  id: totrans-28
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，使用`systemd-nspawn`启动容器：
- en: '[PRE3]'
  id: totrans-29
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: As Nginx will by default attempt to run as a daemon, the container would immediately
    stop as it no longer has an active process. By launching with the `daemon off`
    option, `nginx` will remain in the foreground, and the container can continue
    to work.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 由于Nginx默认会尝试作为守护进程运行，因此容器会立即停止，因为它没有活动进程。通过使用`daemon off`选项启动，`nginx`将保持在前台，容器可以继续工作。
- en: Using a specific SELinux context
  id: totrans-31
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用特定的SELinux上下文
- en: 'When we launch a container directly, this container will run with the SELinux
    context of the user. We can, however, pass on the target context for the container
    using command-line arguments:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们直接启动容器时，该容器将以用户的SELinux上下文运行。然而，我们可以通过命令行参数传递容器的目标上下文：
- en: The `--selinux-context=` option (`-Z` for short) allows the administrator to
    define the SELinux context for the runtime processes of the container.
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`--selinux-context=`选项（简写为`-Z`）允许管理员为容器的运行时进程定义SELinux上下文。'
- en: The `--selinux-apifs-context=` option (`-L` for short) allows the administrator
    to define the SELinux context for the files and filesystem of the container.
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`--selinux-apifs-context=`选项（简写为`-L`）允许管理员为容器的文件和文件系统定义SELinux上下文。'
- en: The SELinux types that can be used here, however, need to be carefully selected.
    The processes running inside a container cannot perform any type of transitions,
    so regular SELinux domains are often not feasible to use. Taking our Nginx example
    again, the `httpd_t` domain cannot be used for this container.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，必须仔细选择可用的SELinux类型。容器内运行的进程不能执行任何类型的转换，因此通常无法使用常规的SELinux域。以我们的Nginx示例为例，`httpd_t`域不能用于该容器。
- en: We can use the SELinux types that the distribution provides for container workloads.
    Recent CentOS versions will use a domain such as `container_t` (which was previously
    known as `svirt_lxc_net_t`) and a file-oriented SELinux type, `container_file_t`.
    While this domain does not hold all possible privileges needed for any container,
    it provides a good baseline for containers.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用发行版为容器工作负载提供的SELinux类型。最近的CentOS版本将使用如`container_t`（以前称为`svirt_lxc_net_t`）这样的域，以及面向文件的SELinux类型`container_file_t`。虽然这个域不具备容器所需的所有可能权限，但它为容器提供了一个良好的基准。
- en: 'Let''s use this type for our container:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们为我们的容器使用这种类型：
- en: 'First, we need to extend the `container_t` privileges with some additional
    rights for the `nginx` daemon. Create a CIL policy file with the following content:'
  id: totrans-38
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们需要通过一些附加权限扩展`container_t`权限，以支持`nginx`守护进程。创建一个包含以下内容的CIL策略文件：
- en: '[PRE4]'
  id: totrans-39
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Load this file as a new SELinux module:'
  id: totrans-40
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将此文件作为新的SELinux模块加载：
- en: '[PRE5]'
  id: totrans-41
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Relabel the files of the container with the `container_file_t` SELinux type:'
  id: totrans-42
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`container_file_t` SELinux类型重新标记容器的文件：
- en: '[PRE6]'
  id: totrans-43
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Launch the container with the appropriate labels:'
  id: totrans-44
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用适当的标签启动容器：
- en: '[PRE7]'
  id: totrans-45
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Whenever a container is launched, it remains attached to the current session.
    We can of course create service files that launch the containers in the background,
    or use session management services such as `screen` or `tmux`. A more user-friendly
    approach, however, is to use `machinectl`.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 每当容器启动时，它都会保持附加到当前会话。当然，我们可以创建服务文件来在后台启动容器，或者使用`screen`或`tmux`等会话管理服务。然而，更加用户友好的方法是使用`machinectl`。
- en: Facilitating container management with machinectl
  id: totrans-47
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用machinectl简化容器管理
- en: The `machinectl` command allows administrators to manage containers or even
    virtual machines more easily through systemd. For containers, `machinectl` will
    use `systemd-nspawn`.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: '`machinectl`命令允许管理员通过systemd更轻松地管理容器甚至虚拟机。对于容器，`machinectl`将使用`systemd-nspawn`。'
- en: 'Let''s use this `machinectl` command to download, start, and stop a container:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用这个`machinectl`命令来下载、启动和停止一个容器：
- en: 'First, download a ready-to-go container image with the `pull-tar` argument
    and prepare it on the system:'
  id: totrans-50
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，使用`pull-tar`参数下载一个准备好的容器镜像，并将其准备好在系统上使用：
- en: '[PRE8]'
  id: totrans-51
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'List the available images with the `list-images` argument:'
  id: totrans-52
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`list-images`参数列出可用的镜像：
- en: '[PRE9]'
  id: totrans-53
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'We can now clone this image and launch the container:'
  id: totrans-54
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们可以克隆这个镜像并启动容器：
- en: '[PRE10]'
  id: totrans-55
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'To access the container environment, use the `shell` argument:'
  id: totrans-56
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要访问容器环境，请使用`shell`参数：
- en: '[PRE11]'
  id: totrans-57
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'We can shut down the container using the `poweroff` argument:'
  id: totrans-58
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以使用`poweroff`参数关闭容器：
- en: '[PRE12]'
  id: totrans-59
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: When we use `machinectl`, the containers will run in the `unconfined_service_t`
    SELinux domain. There is currently no way to override this. Luckily, we have other
    tools available to facilitate container management that do have more significant
    built-in SELinux support, such as Docker and `podman`.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们使用`machinectl`时，容器将运行在`unconfined_service_t` SELinux域中。目前无法覆盖此设置。幸运的是，我们还有其他工具可用于简化容器管理，这些工具在内置SELinux支持方面更强大，例如Docker和`podman`。
- en: Configuring podman
  id: totrans-61
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 配置podman
- en: The `podman` utility is the default container management utility on CentOS 8
    and other distributions derived from Red Hat Enterprise Linux. Other distributions
    such as Gentoo can also easily get access to `podman` by installing `libpod`.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: '`podman`工具是CentOS 8及其他源自Red Hat Enterprise Linux的发行版的默认容器管理工具。其他发行版，如Gentoo，也可以通过安装`libpod`轻松获取`podman`。'
- en: Selecting podman over Docker
  id: totrans-63
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 选择podman而非Docker
- en: When we compare `podman` with Docker, we might not see a big difference when
    we are simply using it for basic container management operations. The commands
    are very similar, and `podman` even has a Docker compatibility layer that facilitates
    the usage of `podman` for administrators who are used to working with Docker.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们将`podman`与Docker进行比较时，如果只是用它来进行基本的容器管理操作，可能看不出太大区别。命令非常相似，`podman`甚至具有一个Docker兼容层，这使得习惯使用Docker的管理员也能方便地使用`podman`。
- en: Under the hood though, there are quite a few differences. For one, `podman`
    is a daemon-less container management system, which allows end users to easily
    run containers within their confined space. The `libpod` project also uses different
    design principles and supports a different container runtime, which supports the
    **Open Container Initiative** (**OCI**)-based definitions, called the **Container
    Runtime Interface for OCI** (**CRI-O**).
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，从底层来看，存在许多差异。首先，`podman`是一个无守护进程的容器管理系统，允许最终用户轻松地在其受限空间内运行容器。`libpod`项目还采用了不同的设计原则，并支持不同的容器运行时，支持基于**开放容器倡议**（**OCI**）定义的容器运行时接口（**CRI-O**）。
- en: 'Let''s use `podman` to deploy a PostgreSQL container on the system:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用`podman`在系统上部署一个PostgreSQL容器：
- en: 'First, we need to find the appropriate container. We can use the `podman search`
    command for this:'
  id: totrans-67
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们需要找到合适的容器。我们可以使用`podman search`命令来查找：
- en: '[PRE13]'
  id: totrans-68
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Of the various PostgreSQL containers listed, we pick the Bitnami one:'
  id: totrans-69
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在列出的各种PostgreSQL容器中，我们选择了Bitnami版本：
- en: '[PRE14]'
  id: totrans-70
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'We can now launch a container, assign a password to the PostgreSQL superuser
    (`postgres`), and make sure that the PostgreSQL port (`5432`) is made available
    to the system:'
  id: totrans-71
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们可以启动一个容器，为 PostgreSQL 超级用户（`postgres`）设置密码，并确保 PostgreSQL 端口（`5432`）对系统可用：
- en: '[PRE15]'
  id: totrans-72
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: This command will create a container definition, based on the container base
    we've just downloaded, and start it on the system.
  id: totrans-73
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 此命令将基于我们刚刚下载的容器基础创建一个容器定义，并在系统上启动它。
- en: 'We can use `psql` to validate that the database runs:'
  id: totrans-74
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以使用`psql`来验证数据库是否运行：
- en: '[PRE16]'
  id: totrans-75
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'When we''re done with the container, we can stop it (using `podman stop`),
    which keeps the current container information, allowing us to revive it again
    later (using `podman start`) or remove the container from the system completely:'
  id: totrans-76
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当我们完成容器操作时，可以停止它（使用`podman stop`），这样会保留当前的容器信息，允许我们稍后重新启动它（使用`podman start`）或完全从系统中删除容器：
- en: '[PRE17]'
  id: totrans-77
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Removing the container removes the container runtime, but the base container
    image remains on the system:'
  id: totrans-78
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 删除容器会移除容器运行时，但基础容器镜像仍然保留在系统上：
- en: '[PRE18]'
  id: totrans-79
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: This allows us to quickly start another container without having to download
    the files again.
  id: totrans-80
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这样，我们可以快速启动另一个容器，而无需重新下载文件。
- en: Using containers is a fast and effective way to quickly install and deploy software
    on the system. Additionally, SELinux provides some additional protections to make
    sure that these containers do not misbehave.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 使用容器是一种快速有效的方式，可以迅速在系统上安装和部署软件。此外，SELinux 提供了一些额外的保护措施，确保这些容器不会出现不当行为。
- en: Using containers with SELinux
  id: totrans-82
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 SELinux 的容器
- en: 'When we look at the active runtime, we will notice that SELinux is already
    confining these containers in a way we understand:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们查看活动的运行时时，我们会注意到 SELinux 已经以我们理解的方式限制了这些容器：
- en: '[PRE19]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'The running processes have two categories assigned and are executing in the
    `container_t` SELinux domain. This is the sVirt approach we saw in [*Chapter 9*](B16276_09_Final_VK.xhtml#_idTextAnchor257),
    *Secure Virtualization*. Unlike virtual machines though, containers are often
    used in a more transient way: when a new version of the container base is released,
    the containers are scrapped, and new ones are started. Virtual machines often
    undergo in-system upgrades, and thus have a longer lifespan.'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 正在运行的进程被分配到两个类别，并在`container_t` SELinux 域中执行。这是我们在[*第 9 章*](B16276_09_Final_VK.xhtml#_idTextAnchor257)中看到的sVirt方法，*安全虚拟化*。然而，与虚拟机不同，容器通常以更为临时的方式使用：当容器基础的新版本发布时，容器会被废弃，新的容器会启动。虚拟机通常会进行系统内升级，因此具有更长的生命周期。
- en: The transient approach with containers also means that we need to provide data
    persistence in a different way. The approach that most containers use is to allow
    mapping locations from the host into the container environment.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 容器的临时性方式还意味着我们需要以不同的方式提供数据持久性。大多数容器使用的方法是允许从主机将位置映射到容器环境中。
- en: 'Let''s use `podman` to map a location outside the container to the `/bitnami/postgresql`
    location inside the container, as needed by the PostgreSQL container:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用`podman`将容器外部的位置映射到容器内部的`/bitnami/postgresql`位置，这是 PostgreSQL 容器所需要的：
- en: 'First, create the location where we want to store the PostgreSQL data(base)
    on the host:'
  id: totrans-88
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，在主机上创建我们想要存储 PostgreSQL 数据（库）的位置：
- en: '[PRE20]'
  id: totrans-89
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Next, change the ownership of this location to the user with user ID `1001`
    (the user ID that the container uses internally):'
  id: totrans-90
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，将此位置的所有权更改为具有用户 ID `1001` 的用户（这是容器内部使用的用户 ID）：
- en: '[PRE21]'
  id: totrans-91
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Now start the container, creating a mapping from this location to the container:'
  id: totrans-92
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在启动容器，创建从此位置到容器的映射：
- en: '[PRE22]'
  id: totrans-93
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: The mapping itself contains an SELinux-specific variable, namely the trailing
    `:Z`. If we were to omit this from the mapping, then the location would still
    be made accessible inside the container. However, the PostgreSQL runtime would
    not be able to use it.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 映射本身包含一个 SELinux 特定的变量，即尾部的`:Z`。如果我们省略此映射中的`：Z`，该位置仍然可以在容器内部访问。然而，PostgreSQL
    运行时将无法使用它。
- en: Important note
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: The use of `:Z` in directory mappings (or `:Z` (or `:z`, as we will see shortly)
    than not!
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 在目录映射中使用`:Z`（或稍后我们会看到的`:Z`（或`:z`））要比不使用好！
- en: Containers are still part of the host operating system. When we create the `/srv/db/postgresql-test`
    location, it will receive the `var_t` SELinux type by default. Containers that
    want to use this location would require write privileges to `var_t`. However,
    this privilege is not one we want to provide. After all, the containers should
    be isolated as much as possible from the host—this isolation is what the sVirt
    technology is about after all.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 容器仍然是主机操作系统的一部分。当我们创建`/srv/db/postgresql-test`这个位置时，默认会收到`var_t`的SELinux类型。希望使用该位置的容器将需要`var_t`的写入权限。然而，这个权限并不是我们希望提供的。毕竟，容器应该尽可能与主机隔离——这正是sVirt技术的核心所在。
- en: 'Hence, we need to relabel this location accordingly. The SELinux type to use
    for generic containers is `container_file_t`. Moreover, we want to make sure that
    only the right container can access this location. Restricting and isolating access
    is what the `:Z` (with a capitalized `Z`) does in the command: labeling the directory
    with the `container_file_t` type and associating the right categories with it.'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们需要相应地重新标记这个位置。通用容器使用的SELinux类型是`container_file_t`。此外，我们希望确保只有正确的容器能够访问这个位置。限制和隔离访问就是命令中`:Z`（大写的`Z`）所做的：用`container_file_t`类型标记该目录，并为其关联正确的类别。
- en: 'If we want to have a location accessible by *multiple containers*, we can tell
    `podman` to *share* the location, yet still be labeled with the `container_file_t`
    SELinux type. To accomplish that, we would use the `:z` argument (with a lowercase
    `z`), like so:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们希望某个位置可以被*多个容器*访问，我们可以告诉`podman`*共享*这个位置，但仍然使用`container_file_t`的SELinux类型进行标记。为了实现这一点，我们需要使用`:z`参数（小写的`z`），如下所示：
- en: '[PRE23]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Creating appropriate mappings is not the only approach where SELinux configuration
    comes into play. If we want, we can also tell `podman` to use different SELinux
    domains for the container as well.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 创建适当的映射并不是SELinux配置中的唯一方法。如果需要，我们还可以告诉`podman`为容器使用不同的SELinux域。
- en: Changing a container's SELinux domain
  id: totrans-102
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 更改容器的SELinux域
- en: 'To control the SELinux context under which a container is launched, we use
    the `--security-opt` argument to the `podman` command. For instance, to run an
    Nginx container with the `container_logreader_t` SELinux domain, we use the following:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 要控制容器启动时的SELinux上下文，我们可以在`podman`命令中使用`--security-opt`参数。例如，要使用`container_logreader_t`
    SELinux域运行Nginx容器，我们可以使用如下命令：
- en: '[PRE24]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: This domain is slightly more privileged than the default `container_t` domain,
    as it also has read privileges on log files. We could use this to have a web server
    expose the log files, for instance.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 该域比默认的`container_t`域权限稍高，因为它还具有对日志文件的读取权限。例如，我们可以用它来让Web服务器公开日志文件。
- en: 'Other labeling options that we can pass on are as follows:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以传递的其他标记选项如下：
- en: The SELinux user, with the `label=user:<SELinux user>` argument.
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: SELinux用户，使用`label=user:<SELinux user>`参数。
- en: The SELinux role, with the `label=role:<SELinux role>` argument.
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: SELinux角色，使用`label=role:<SELinux role>`参数。
- en: The SELinux sensitivity level, with the `label=level:<SELinux level>` argument.
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: SELinux敏感度级别，使用`label=level:<SELinux level>`参数。
- en: The SELinux type for the files, with the `label=filetype:<SELinux type>` argument.
    This sets the SELinux context for the location mappings that have the `:Z` and
    `:z` suffixes set. The selected type must be an entry point for the container's
    SELinux domain.
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 文件的SELinux类型，使用`label=filetype:<SELinux type>`参数。这会设置带有`:Z`和`:z`后缀的定位映射的SELinux上下文。所选类型必须是容器SELinux域的入口点。
- en: 'There is also another option that we can use, namely `label=disable`. With
    this argument set, a container will run without any SELinux isolation. Now, it
    does not disable SELinux for the container, but associates an unconfined domain
    called `spc_t` with the container:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以使用另一个选项，即`label=disable`。设置这个参数后，容器将运行时不使用任何SELinux隔离。这个选项并不禁用容器的SELinux，而是将一个名为`spc_t`的未受限域与容器关联：
- en: '[PRE25]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: While for most use cases, the default `container_t` domain is sufficiently privileged,
    it might be too privileged for some. Luckily, we can easily create new SELinux
    domains specific to our use case.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 对于大多数使用场景，默认的`container_t`域已经具有足够的权限，但对于某些情况，它的权限可能过于宽泛。幸运的是，我们可以轻松创建与我们使用场景相匹配的新的SELinux域。
- en: Creating custom domains with udica
  id: totrans-114
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用udica创建自定义域
- en: The `container_t` domain is configured to be widely reusable, which implies
    that it has many privileges for common use cases, which you might not want to
    give to each container. Furthermore, if we would launch a container but need to
    associate more privileges with it, then we would have to extend `container_t`
    with more privileges, resulting in all containers receiving this privilege extension.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: '`container_t` 域被配置为广泛可重用，这意味着它对常见用例有许多特权，这些特权您可能不想给每个容器。此外，如果我们启动一个容器，但需要为其关联更多特权，那么我们将不得不扩展
    `container_t` 以获取更多特权，结果是所有容器都会收到此特权扩展。'
- en: To quickly build up new policies, a tool called `udica` can be used. The `udica`
    tool reads the container definition and creates a custom SELinux policy from it.
    We can then use this custom policy for this particular container, allowing other
    containers to remain untouched.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 为了快速建立新策略，可以使用名为 `udica` 的工具。`udica` 工具读取容器定义并从中创建自定义 SELinux 策略。然后，我们可以将此自定义策略用于此特定容器，允许其他容器保持不变。
- en: 'Let''s use this for a Jupyter Notebook, which we want to grant read/write privileges
    to a (shared) user home directory location:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们将其用于 Jupyter Notebook，我们希望为（共享的）用户主目录位置授予读/写权限：
- en: 'First, we create the definition of the container:'
  id: totrans-118
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们创建容器的定义：
- en: '[PRE26]'
  id: totrans-119
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Next, inspect this container using `podman inspect` and store the results in
    a file:'
  id: totrans-120
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，使用 `podman inspect` 检查此容器并将结果存储在文件中：
- en: '[PRE27]'
  id: totrans-121
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Use `udica` to generate an SELinux policy for it:'
  id: totrans-122
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `udica` 为其生成 SELinux 策略：
- en: '[PRE28]'
  id: totrans-123
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Load the custom policy as mentioned by the `udica` output:'
  id: totrans-124
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 根据 `udica` 输出加载自定义策略：
- en: '[PRE29]'
  id: totrans-125
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Stop and remove the container, and then recreate it with the parameter as mentioned
    in the `udica` output:'
  id: totrans-126
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 停止并删除容器，然后根据 `udica` 输出重新创建它：
- en: '[PRE30]'
  id: totrans-127
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: The custom SELinux policy has the privileges to write to the home directory,
    as the container had a mapping from `/home/lisa/work`, and `udica` automatically
    created the permissions for it. If we wanted the container to only have read-only
    privileges, we could use a mapping with a trailing `:ro` (rather than `:Z` or
    `:z` for SELinux-specific changes). This would map the location inside the container
    with read-only access, and `udica` would only create read privileges for the associated
    SELinux type.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 自定义 SELinux 策略具有写入主目录的特权，因为容器从 `/home/lisa/work` 映射，并且 `udica` 自动为其创建了权限。如果我们希望容器仅具有只读特权，我们可以使用带有尾部
    `:ro` 的映射（而不是 `:Z` 或 `:z` 用于 SELinux 特定更改）。这将映射容器内部的位置，并且 `udica` 仅为关联的 SELinux
    类型创建读权限。
- en: If creating custom policies is a bit too specific, we can also fine-tune the
    privileges of the `container_t` domain with the appropriate SELinux booleans.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 如果创建自定义策略有点过于具体，我们还可以使用适当的 SELinux 布尔值来微调 `container_t` 域的特权。
- en: Toggling container_t privileges with SELinux booleans
  id: totrans-130
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 SELinux 布尔值切换 `container_t` 特权
- en: The `container_t` SELinux domain is associated with the `svirt_sandbox_domain`
    attribute, and through that association, will automatically be managed by several
    of the `virt_*` SELinux booleans that we saw in [*Chapter 9*](B16276_09_Final_VK.xhtml#_idTextAnchor257),
    *Secure Virtualization*.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: '`container_t` SELinux 域与 `svirt_sandbox_domain` 属性关联，通过这种关联，将自动由我们在[*第9章*](B16276_09_Final_VK.xhtml#_idTextAnchor257)中看到的
    `virt_*` SELinux 布尔值管理。'
- en: 'There are a few container-specific SELinux booleans as well:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 也有一些特定于容器的 SELinux 布尔值：
- en: With `container_use_cephfs`, containers can use CephFS-based storage. This is
    predominantly used when the containers are managed by larger container-cluster
    software such as Kubernetes.
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `container_use_cephfs`，容器可以使用基于 CephFS 的存储。这主要用于容器由较大的容器集群软件（如 Kubernetes）管理时。
- en: With `container_manage_cgroup`, containers can manage cgroups. This is needed
    when the container hosts systemd inside, which is often the case for full-blown
    container runtimes (rather than process-specific containers). Such containers
    host almost complete Linux systems.
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `container_manage_cgroup`，容器可以管理 cgroups。当容器内部托管有 systemd 时，这是必需的，这种情况通常适用于完整的容器运行时（而不是特定进程的容器）。这些容器托管几乎完整的
    Linux 系统。
- en: With `container_connect_any`, the `container_t` SELinux domain can connect to
    any TCP port.
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `container_connect_any`，`container_t` SELinux 域可以连接到任何 TCP 端口。
- en: Keep in mind though that these booleans influence the privileges of the `container_t`
    domain, and thus are in effect for all containers.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，这些布尔值影响 `container_t` 域的特权，因此对所有容器都有效。
- en: Tuning the container hosting environment
  id: totrans-137
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 调整容器托管环境
- en: The `podman` utility will by default store its container volumes and base images
    in `/var/lib/containers`. Administrators can add more locations through the `storage.conf`
    configuration file available in `/etc/containers`. However, you need to adjust
    the SELinux configuration accordingly as well.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: '`podman` 工具默认会将其容器卷和基础镜像存储在`/var/lib/containers`目录中。管理员可以通过位于`/etc/containers`的`storage.conf`配置文件添加更多存储位置。然而，你还需要相应地调整SELinux配置。'
- en: 'Suppose that the `/srv/containers` location will be used, then we need to create
    an equivalence rule to make sure that this location is labeled appropriately:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们将使用`/srv/containers`位置，那么我们需要创建一个等价规则，确保该位置的标签被正确设置：
- en: '[PRE31]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: If the location is a network mount, you might need to change the appropriate
    SELinux booleans as well.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 如果该位置是网络挂载点，你可能还需要更改相应的SELinux布尔值。
- en: Leveraging Kubernetes' SELinux support
  id: totrans-142
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 利用Kubernetes的SELinux支持
- en: When containers are used in a larger environment, they are often managed through
    container orchestration frameworks that allow scaling container deployment and
    management across multiple systems. Kubernetes is a popular container orchestration
    framework with a good community, as well as commercial support.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 当容器在更大的环境中使用时，它们通常通过容器编排框架进行管理，这些框架允许跨多个系统扩展容器部署和管理。Kubernetes是一个受欢迎的容器编排框架，拥有良好的社区支持和商业支持。
- en: Kubernetes uses the container software found on the machines under the hood.
    When, for instance, we install Kubernetes on Fedora's CoreOS, it will detect that
    Docker is available and use the Docker engine for managing the containers.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes使用机器上找到的容器软件。例如，当我们在Fedora的CoreOS上安装Kubernetes时，它会检测到Docker可用，并使用Docker引擎来管理容器。
- en: Configuring Kubernetes with SELinux support
  id: totrans-145
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 配置Kubernetes以支持SELinux
- en: Installing Kubernetes can be a daunting task, and several methods exist, ranging
    from single-node playground deployments up to commercially supported installations.
    One of the well-documented installation methods on the Kubernetes website is to
    use `kubeadm` for bootstrapping Kubernetes clusters.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 安装Kubernetes可能是一项艰巨的任务，存在多种方法，范围从单节点的实验部署到商业支持的安装方法。在Kubernetes网站上，有一种经过充分记录的安装方法是使用`kubeadm`来引导Kubernetes集群的创建。
- en: Important note
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: The installation of Kubernetes is documented on the Kubernetes website at [https://kubernetes.io/docs/setup/production-environment/tools/kubeadm](https://kubernetes.io/docs/setup/production-environment/tools/kubeadm).
    In this section, we will not go through the individual steps to set up a working
    Kubernetes instance, but give pointers as to which changes are needed for having
    proper SELinux support.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes的安装文档可以在Kubernetes官网找到，链接为[https://kubernetes.io/docs/setup/production-environment/tools/kubeadm](https://kubernetes.io/docs/setup/production-environment/tools/kubeadm)。在本节中，我们不会逐步讲解如何设置一个工作的Kubernetes实例，而是提供一些指引，说明需要进行哪些更改以支持SELinux。
- en: The `kubeadm` command, when initializing the Kubernetes cluster, will download
    and run the various Kubernetes services as containers. Unfortunately, Kubernetes'
    services use several mappings from the host system into the container to facilitate
    their operations. These mappings are not done using the `:Z` or `:z` options—it
    would even be wrong to do so, as the locations are system-wide locations that
    should retain their current SELinux labels.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 当初始化Kubernetes集群时，`kubeadm`命令会下载并运行各种Kubernetes服务作为容器。不幸的是，Kubernetes的服务使用了多个从主机系统到容器的映射，以便其正常运行。这些映射没有使用`:Z`或`:z`选项——甚至这样做是错误的，因为这些位置是系统范围内的，应该保留当前的SELinux标签。
- en: As a result, Kubernetes' services will be running with the default `container_t`
    SELinux domain (as Docker will happily apply the sVirt protections), which does
    not have access to these locations. The most obvious change we can apply is to
    have the services run with the highly privileged `spc_t` domain for now. Applying
    this change however during the installation is hard, as we would need to change
    the domain sufficiently quickly before the installation fails.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 结果，Kubernetes的服务将以默认的`container_t` SELinux域运行（因为Docker会愉快地应用sVirt保护），而无法访问这些位置。我们可以应用的最明显更改是让服务暂时使用特权更高的`spc_t`域。然而，在安装过程中进行此更改是困难的，因为我们需要在安装失败之前快速更改域。
- en: 'While we can create deployment configuration information for Kubernetes that
    immediately configures the services with `spc_t`, another method can be pursued:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然我们可以为Kubernetes创建部署配置，这会立即使用`spc_t`配置服务，但也可以采取另一种方法：
- en: 'Mark the `container_t` type as a permissive domain before the installation
    starts. While this will prevent any SELinux controls on the container, we can
    argue that the installation of Kubernetes is done in a contained and supervised
    manner:'
  id: totrans-152
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在安装开始之前，将 `container_t` 类型标记为宽松域。虽然这会防止 SELinux 对容器的控制，但我们可以认为 Kubernetes 的安装是以封闭和受监督的方式进行的：
- en: '[PRE32]'
  id: totrans-153
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Run `kubeadm init`, which will install the services on the system:'
  id: totrans-154
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行 `kubeadm init`，它将在系统上安装服务：
- en: '[PRE33]'
  id: totrans-155
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'When the services are installed, go to `/etc/kubernetes/manifests`. Inside
    this directory, you will find four manifests, each one representing a Kubernetes
    service:'
  id: totrans-156
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 安装服务后，转到 `/etc/kubernetes/manifests`。在此目录中，您将找到四个清单，每个清单代表一个 Kubernetes 服务：
- en: '[PRE34]'
  id: totrans-157
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Edit each manifest file (`etcd.yaml`, `kube-apiserver.yml`, `kube-controller-manager.yml`,
    and `kube-scheduler.yml`) and add a security context definition that configures
    the service to run with the `spc_t` domain. This is done as a configuration directive
    under the `containers` section:'
  id: totrans-158
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编辑每个清单文件（`etcd.yaml`、`kube-apiserver.yml`、`kube-controller-manager.yml` 和 `kube-scheduler.yml`），并添加一个安全上下文定义，使服务以
    `spc_t` 域运行。此操作作为 `containers` 部分下的配置指令进行：
- en: '[PRE35]'
  id: totrans-159
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'During the Kubernetes installation, the `kubelet` service will be installed,
    which will detect that these files have been changed, and will automatically restart
    the containers. If not, you can shut down and remove the container definitions
    within Docker, and `kubelet` will automatically recreate them:'
  id: totrans-160
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 Kubernetes 安装过程中，将安装 `kubelet` 服务，它会检测到这些文件已被更改，并会自动重启容器。如果没有，您可以关闭并删除 Docker
    中的容器定义，`kubelet` 将自动重新创建它们：
- en: '[PRE36]'
  id: totrans-161
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Verify that the services are now running with the privileged `spc_t` domain:'
  id: totrans-162
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 验证服务是否现在以特权 `spc_t` 域运行：
- en: '[PRE37]'
  id: totrans-163
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Remove the permissive state of `container_t` so that it is back to enforcing
    mode:'
  id: totrans-164
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 移除 `container_t` 的宽松状态，使其恢复到强制模式：
- en: '[PRE38]'
  id: totrans-165
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE38]'
- en: With these slight adjustments during the installation, Kubernetes is now running
    fine with SELinux support enabled.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 在安装过程中进行这些微小调整后，Kubernetes 现在可以正常运行，并启用了 SELinux 支持。
- en: Setting SELinux contexts for pods
  id: totrans-167
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 设置 SELinux 上下文以用于 pods
- en: 'Within Kubernetes, containers are part of pods. A `podman` utility is also
    able to use the pods concept (hence the name). For instance, we could put the
    Nginx container in a pod called `webserver` like so:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Kubernetes 中，容器是 pod 的一部分。`podman` 工具也能够使用 pod 的概念（因此得名）。例如，我们可以将 Nginx 容器放入一个名为
    `webserver` 的 pod 中，如下所示：
- en: '[PRE39]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Unlike `podman`, Kubernetes does not rely on command-line interaction to create
    and manage resources such as pods. Instead, it uses manifest files (as we've briefly
    touched upon in the *Configuring Kubernetes with SELinux support* section). Kubernetes
    administrators or DevOps teams will create manifest files and apply those to the
    environment.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 与 `podman` 不同，Kubernetes 不依赖命令行交互来创建和管理如 pods 之类的资源。相反，它使用清单文件（正如我们在 *配置带 SELinux
    支持的 Kubernetes* 部分简要提到的那样）。Kubernetes 管理员或 DevOps 团队将创建清单文件，并将其应用于环境。
- en: 'For instance, to have the Nginx containers run on Kubernetes, the following
    manifest could be used:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，为了让 Nginx 容器在 Kubernetes 上运行，可以使用以下清单：
- en: '[PRE40]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'This manifest is a Kubernetes deployment, and tells Kubernetes that we want
    to run two Nginx containers. To apply this to the environment, use `kubectl apply`:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 这个清单是一个 Kubernetes 部署，它告诉 Kubernetes 我们想要运行两个 Nginx 容器。要将其应用于环境，使用 `kubectl
    apply`：
- en: '[PRE41]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'As with the manifests for the Kubernetes services, we can tell Kubernetes to
    use a specific SELinux type:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 与 Kubernetes 服务的清单一样，我们可以告诉 Kubernetes 使用特定的 SELinux 类型：
- en: '[PRE42]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: The `seLinuxOptions` block can contain `user`, `role`, `type`, and `level` to
    define the SELinux user, SELinux role, SELinux type and SELinux sensitivity level.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: '`seLinuxOptions` 块可以包含 `user`、`role`、`type` 和 `level`，用于定义 SELinux 用户、SELinux
    角色、SELinux 类型和 SELinux 敏感级别。'
- en: 'Unlike the regular container management services (such as Docker or CRI-O),
    Kubernetes does not allow changing SELinux labels on mapped volumes (except on
    single-node deployments): when we map volumes into containers, they retain their
    current SELinux label on the system. Hence, if you want to make sure that the
    resources are accessible from a regular `container_t` domain, you need to make
    sure these locations are labeled with `container_file_t`.'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 与常规容器管理服务（如 Docker 或 CRI-O）不同，Kubernetes 不允许更改映射卷上的 SELinux 标签（单节点部署除外）：当我们将卷映射到容器时，它们会保留系统上当前的
    SELinux 标签。因此，如果您希望确保资源可以从常规的 `container_t` 域访问，您需要确保这些位置被标记为 `container_file_t`。
- en: Kubernetes does offer advanced access controls itself. Enabling volumes within
    the containers is also handled by a plugin architecture, with several plugins
    already available. When the plugin enables SELinux labeling, then Kubernetes will
    attempt to relabel the resource and assign the categories (as with sVirt). However,
    this support is currently only made available on single-node deployments (using
    the local host storage plugin)—and for such deployments, using `podman` is much
    simpler.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes 确实提供了先进的访问控制。容器内的卷启用也是通过插件架构来处理的，已有多个插件可用。当插件启用 SELinux 标签时，Kubernetes
    会尝试重新标记资源并分配类别（与 sVirt 相同）。然而，目前该功能仅在单节点部署（使用本地主机存储插件）中可用——对于这样的部署，使用 `podman`
    要简单得多。
- en: Summary
  id: totrans-180
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: Containerized workloads allow administrators to add capabilities quickly and
    easily to a system, while retaining possible dependencies within a container.
    Each container hosts its own dependencies, allowing containers to be removed and
    added from the system without affecting others. With SELinux, this workload is
    further isolated from the host and, in case of sVirt protections, also from each
    other.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 容器化工作负载允许管理员快速且轻松地为系统添加功能，同时保持容器内可能的依赖关系。每个容器都托管自己的依赖项，允许容器从系统中移除或添加，而不会影响其他容器。通过
    SELinux，这些工作负载进一步与主机隔离，并且在启用 sVirt 保护的情况下，相互之间也得到了隔离。
- en: We've seen how systemd has container support but lacks sVirt-based protections,
    and how `podman` can apply sVirt protections on its own container environments.
    We learned that Docker and `podman` are very similar in usage, yet different under
    the hood. Both frameworks allow us to apply different SELinux types to the containers
    and resources, and with `udica` we've learned how to create custom policies without
    much development effort. Finally, we've seen how Kubernetes can be configured
    to use SELinux labeling as well.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到 systemd 支持容器，但缺乏基于 sVirt 的保护，也了解了 `podman` 如何在其容器环境中应用 sVirt 保护。我们了解到，Docker
    和 `podman` 在使用上非常相似，但在底层实现上有所不同。这两个框架都允许我们将不同的 SELinux 类型应用于容器和资源，并且通过 `udica`，我们学会了如何在不进行大量开发的情况下创建自定义策略。最后，我们还了解了如何配置
    Kubernetes 使用 SELinux 标签。
- en: With all these SELinux-capable technologies behind us, we are ready to tackle
    the SELinux policy development itself. In the next chapter, we'll learn to work
    with SELinux policies in depth and tune the policies to our needs.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 在所有这些支持 SELinux 的技术背后，我们已经准备好迎接 SELinux 策略的开发了。在接下来的章节中，我们将深入学习如何与 SELinux 策略打交道，并根据需要调整策略。
- en: Questions
  id: totrans-184
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: Why is Docker or `podman` preferred over `machinectl` for SELinux?
  id: totrans-185
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为什么在 SELinux 中，`docker` 或 `podman` 比 `machinectl` 更受欢迎？
- en: How do we ensure host data is properly mapped within a container?
  id: totrans-186
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们如何确保主机数据在容器内得到正确映射？
- en: How can we create a custom policy from a container definition?
  id: totrans-187
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们如何从容器定义中创建自定义策略？
- en: Where in Kubernetes' manifests can we place SELinux settings?
  id: totrans-188
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 Kubernetes 的清单中，我们可以将 SELinux 设置放在哪里？
