- en: '11'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Performance Tuning Best Practices
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Performance tuning system resources is one of the main (or even the most important)
    tasks of any system administrator. Performance tuning is the process of tweaking
    a system’s configuration to improve the use of computing resources, data throughput,
    or user experience. It requires a thorough understanding of the hardware and software
    components of a system, as well as the many interactions between them.
  prefs: []
  type: TYPE_NORMAL
- en: Performance tuning is often confused with troubleshooting, but there are significant
    differences between them. In a troubleshooting process, the main goal is finding
    and solving a problem to make the system work. In performance tuning, the goal
    is to get the system running with the best possible performance while taking advantage
    of the resources and environment it operates in.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we are going to cover the following main topics on how to
    get the best performance regarding the key aspects of the system:'
  prefs: []
  type: TYPE_NORMAL
- en: Understanding kernel tuning
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Main tuning – CPU and memory
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Don’t ignore storage tuning
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Boosting performance with network tuning
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To complete the topics in this chapter, you will need to install the packages
    indicated in each section. There, you will find instructions for each package
    that needs to be installed.
  prefs: []
  type: TYPE_NORMAL
- en: 'The examples that were created for this chapter can be downloaded from this
    book’s GitHub repository: [https://github.com/PacktPublishing/Fedora-Linux-System-Administration/tree/main/chapter11](https://github.com/PacktPublishing/Fedora-Linux-System-Administration/tree/main/chapter11).'
  prefs: []
  type: TYPE_NORMAL
- en: Understanding kernel tuning
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Linux kernel exposes *user-space tunable information and configurations*
    through the `/proc` directory. The `/proc` filesystem acts as an interface to
    the **kernel** data structures and runtime information. It provides a way to access
    detailed information about processes, system configuration, hardware, and more,
    exposing this data through a hierarchy of virtual files.
  prefs: []
  type: TYPE_NORMAL
- en: The files in the `/proc` directory contain system information such as memory
    (`meminfo`), CPU (`cpuinfo`), and available filesystems.
  prefs: []
  type: TYPE_NORMAL
- en: The `/proc/sys` subdirectory contains configurable parameters to adjust kernel
    behavior and activity. Most files in `/proc/sys` can be modified by the `root`
    user. Modifying files in `/proc/sys` causes immediate changes to the running system.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: Changing the files in **/proc/sys** could improve the performance of the running
    system, but it could also degrade it. Be careful when applying any changes to
    these files. Remember to back up before making any changes to them.
  prefs: []
  type: TYPE_NORMAL
- en: 'Within `/proc/sys`, the files get organized into a subdirectory tree by tunable
    kernel type:'
  prefs: []
  type: TYPE_NORMAL
- en: '**/proc/sys/dev**: Contains tunables for **system devices**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**/proc/sys/fs**: Contains tunable variables related to the **filesystem**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**/proc/sys/kernel**: Includes tweaks that change the **internal** **kernel
    operation**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**/proc/sys/net**: Contains tunables that change the **network configuration**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**/proc/sys/vm**: This contains parameters that change the management of the
    **virtual memory of** **the kernel**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: Remember, not all files in **/proc/sys** are writable. Some of them only get
    altered by the operating system itself.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s see how we can change these kernel tunables.
  prefs: []
  type: TYPE_NORMAL
- en: Tuning kernel parameters
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The following figure illustrates how the kernel parameters can be changed in
    different ways:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.1 – Linux Performance Tuning Tools, by Brendan Gregg (CC BY-SA
    4.0)](img/B19121_11_1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 11.1 – Linux Performance Tuning Tools, by Brendan Gregg (CC BY-SA 4.0)
  prefs: []
  type: TYPE_NORMAL
- en: 'As system administrators, the best practice is to make changes through the
    command line, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Using a text editor to change **/****proc/sys** files
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using the **echo** command to set simple values in the tunables
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using the **sysctl** command to set a parameter by name
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Create files with the desired parameters in the **/****etc/sysctl.d** directory
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: Changing the configurable values in the kernel tunables directly does not make
    them *persistent* at reboot. To do this, you must use the **sysctl** command or
    create a file with the change in the **/****etc/sysctl.d** directory.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s see an example of each of the different ways we can do this. Follow these
    steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Review the content of the tunable **icmp_echo_ignore_all** inside the **/****proc/sys/net/ipv4**
    directory:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'This value (`0`) indicates that `icmp` (`ping`) support exists:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 11.2 – The workstation supports ping](img/B19121_11_2.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 11.2 – The workstation supports ping
  prefs: []
  type: TYPE_NORMAL
- en: Let’s change it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Use the **echo** command to change the value of the tunable from *false* (**0**)
    to *true* (**1**):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Confirm the change of the tunable:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'As you will see, the operating system no longer allows *pinging*:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 11.3 – Ping not allowed by the operating system](img/B19121_11_3.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 11.3 – Ping not allowed by the operating system
  prefs: []
  type: TYPE_NORMAL
- en: This change can also be made using the `sysctl` command.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s do it.
  prefs: []
  type: TYPE_NORMAL
- en: 'The path of the tunable to change can be represented by replacing the slashes
    under **/proc/sys** with dots. In our example, the tunable is as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: sysctl -w net.ipv4.icmp_echo_ignore_all="0"
  prefs:
  - PREF_IND
  - PREF_H1
  type: TYPE_NORMAL
- en: net.ipv4.icmp_echo_ignore_all = 0
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '![Figure 11.4 – Ping allowed](img/B19121_11_4.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 11.4 – Ping allowed
  prefs: []
  type: TYPE_NORMAL
- en: However, this change is not persistent on reboot.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s see how to do this.
  prefs: []
  type: TYPE_NORMAL
- en: 'On boot, the kernel loads the tunable settings from the configuration files
    found in these directories:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`.conf` extension, with the tunable set to `true`:'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
- en: sysctl -p /etc/sysctl.d/ping.conf
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_H1
  type: TYPE_NORMAL
- en: net.ipv4.icmp_echo_ignore_all = 1
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
- en: '![Figure 11.5 – Ping not allowed](img/B19121_11_5.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 11.5 – Ping not allowed
  prefs: []
  type: TYPE_NORMAL
- en: 'These are the different ways to change the kernel tunables. To get the list
    of kernel tunables, use the `-a` option of the `sysctl` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: '![Figure 11.6 – Kernel tunables list](img/B19121_11_6.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 11.6 – Kernel tunables list
  prefs: []
  type: TYPE_NORMAL
- en: Changes that are made to the kernel tunables modify the behavior of the operating
    system. Now, let’s take a look at the changes in some specific aspects of the
    main components of the operating system.
  prefs: []
  type: TYPE_NORMAL
- en: Main tuning – CPU and memory
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous section, *Figure 11**.1* illustrated the different tools that
    help us collect performance information on the use of system resources.
  prefs: []
  type: TYPE_NORMAL
- en: The tools display system information such as free disk space, CPU temperature,
    and other essential components, as well as network information such as the system’s
    IP address and current upload and download rates.
  prefs: []
  type: TYPE_NORMAL
- en: Monitoring the resources of the running system represents one of the many main
    tasks of a system administrator. The goal of system monitoring is to determine
    whether the current performance meets the specified technical requirements.
  prefs: []
  type: TYPE_NORMAL
- en: Monitoring the performance of resources helps us know about the areas that need
    improving.
  prefs: []
  type: TYPE_NORMAL
- en: Before changing the CPU and memory usage configuration, let’s take a brief look
    at the basic monitoring tools included in Fedora Linux.
  prefs: []
  type: TYPE_NORMAL
- en: Overview of monitoring tools
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Monitoring tools provide per-process statistics and are based on process structures
    or system-wide statistics from the kernel. Monitoring tools usually become available
    to *unprivileged users*, but for a more granular level of detail, system administrator
    privileges are required.
  prefs: []
  type: TYPE_NORMAL
- en: The `ps` and `top` commands are the most common commands that provide process
    statistics, including CPU and memory.
  prefs: []
  type: TYPE_NORMAL
- en: 'As the `root` user, running the `ps` command with the `aux` option lists the
    processes with extended details by user:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: '![Figure 11.7 – Output of the ps aux command](img/B19121_11_7.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 11.7 – Output of the ps aux command
  prefs: []
  type: TYPE_NORMAL
- en: 'The following table describes the output of the `ps aux` command column by
    column:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Column** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| `USER` | The user running the process. |'
  prefs: []
  type: TYPE_TB
- en: '| `PID` | Process ID of this process. |'
  prefs: []
  type: TYPE_TB
- en: '| `%``CPU` | CPU time used (in percent) by this process. |'
  prefs: []
  type: TYPE_TB
- en: '| `%``MEM` | Physical memory used (in percentage) by this process. |'
  prefs: []
  type: TYPE_TB
- en: '| `VSZ` | Virtual memory used (in bytes) by this process. |'
  prefs: []
  type: TYPE_TB
- en: '| `RSS` | Resident Set Size, *non-swappable* physical memory used (in KiB*)
    by this process. |'
  prefs: []
  type: TYPE_TB
- en: '| `TTY` | Terminal from which the process started.The *question mark* (`?`)
    indicates that the process wasn’t started from a terminal. |'
  prefs: []
  type: TYPE_TB
- en: '| `STAT` | Process state. |'
  prefs: []
  type: TYPE_TB
- en: '| `START` | Starting time and date of the process. |'
  prefs: []
  type: TYPE_TB
- en: '| `TIME` | Total CPU time used by this process. |'
  prefs: []
  type: TYPE_TB
- en: '| `COMMAND` | The command, with all its arguments, that started the process.
    |'
  prefs: []
  type: TYPE_TB
- en: Table 11.1 – The ps aux command’s output description column by column
  prefs: []
  type: TYPE_NORMAL
- en: '*More details will be provided in the following section.'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: For more information about the *process stat codes*, refer to the **ps** manual
    pages. Use the **man** **ps** command.
  prefs: []
  type: TYPE_NORMAL
- en: 'Unlike the `ps` command, where the output is static, the `top` command provides
    a real-time report of process activity. It also provides an interface for filtering
    and manipulating the monitoring data:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: '![Figure 11.8 – Output of the top command](img/B19121_11_8.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 11.8 – Output of the top command
  prefs: []
  type: TYPE_NORMAL
- en: 'The command output header provides general information on the current behavior
    of the system:'
  prefs: []
  type: TYPE_NORMAL
- en: The first line includes the current time, how long the system runs for, the
    number of users connected, and the average load in the last 1, 5, and 15 minutes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The second line shows the number of tasks and their statuses: running, sleeping,
    stopped, or zombies'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The third line shows different CPU usage values (at runtime):'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**us**: Time that **CPU** spends running processes for users in *user space*'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**sy**: Time spent running *system kernel* *space* processes'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**ni**: Time spent running processes with a manually set **nice** value'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**id**: **CPU** idle time'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**wa**: Time that **CPU** spends waiting for **I/O** tasks to complete'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**hi**: Time spent servicing *hardware interrupts*'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**si**: Time spent servicing *software interrupts*'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**st**: Time lost due to running virtual machines (*steal time*)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The fourth line shows the total amount (in KiB) of physical memory, and how
    much is free, used, and buffered or cached
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The fifth line shows the total amount (in KiB) of swap memory, and how much
    is free, used, and available
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following table describes the output of the `top` command column by column:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Column** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| `PID` | Process ID |'
  prefs: []
  type: TYPE_TB
- en: '| `USER` | User owner of the process |'
  prefs: []
  type: TYPE_TB
- en: '| `PR` | Process priority |'
  prefs: []
  type: TYPE_TB
- en: '| `NI` | Nice value of the process |'
  prefs: []
  type: TYPE_TB
- en: '| `VIRT` | Virtual memory used by the process |'
  prefs: []
  type: TYPE_TB
- en: '| `RES` | Resident memory used by the process |'
  prefs: []
  type: TYPE_TB
- en: '| `SHR` | Shared memory used by the process |'
  prefs: []
  type: TYPE_TB
- en: '| `S` | Status of the process |'
  prefs: []
  type: TYPE_TB
- en: '| `%``CPU` | Share of CPU time used (in percentage) by the process since the
    last update |'
  prefs: []
  type: TYPE_TB
- en: '| `%``MEM` | Share of physical `memory` used (in percentage) |'
  prefs: []
  type: TYPE_TB
- en: '| `TIME+` | Total CPU time used by the task in hundredths of a second |'
  prefs: []
  type: TYPE_TB
- en: '| `COMMAND` | The command, with all its arguments, that started the process
    |'
  prefs: []
  type: TYPE_TB
- en: Table 11.2 – The top command’s output description column by column
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: For more information about the process status codes, refer to the **top** manual
    pages. Use the **man top** command to do so.
  prefs: []
  type: TYPE_NORMAL
- en: 'Regarding `memory`, the `free` command lists the free and used *physical* and
    *swap* `memory`. By using the `-b`, `-k`, `-m`, and `-g` options, the output will
    be displayed in bytes, KB, MB, and GB, respectively:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: '![Figure 11.9 – Outputs after running the different options of the free command](img/B19121_11_9.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 11.9 – Outputs after running the different options of the free command
  prefs: []
  type: TYPE_NORMAL
- en: 'The GNOME desktop provides a graphical tool for resource monitoring. From the
    main menu, under `system monitor`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.10 – GNOME System Monitor from Activities Overview](img/B19121_11_10.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 11.10 – GNOME System Monitor from Activities Overview
  prefs: []
  type: TYPE_NORMAL
- en: 'You can also open the utility from the Terminal by running the `gnome-system-monitor`
    command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: '![Figure 11.11 – GNOME System Monitor](img/B19121_11_11.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 11.11 – GNOME System Monitor
  prefs: []
  type: TYPE_NORMAL
- en: Fedora Linux, through its official repositories, provides a package that integrates
    several monitoring tools. The `sysstat` package takes the *raw data* from the
    kernel counters and allows you to display and store the metrics in a historical
    *process* *running* database.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following utilities are included in this package:'
  prefs: []
  type: TYPE_NORMAL
- en: '**mpstat**: Reports individual or combined **CPU**-related statistics'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**iostat**: Reports **CPU** and I/O statistics for devices, partitions, and
    the network filesystem'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**pidstat**: Reports statistics for processes, including disk **I/O**, **CPU**,
    and **memory** usage'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**cifsiostat**: Reports statistics about shared filesystems, printers, or network
    serial ports'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**sar**: Collects, reports, and stores system activity'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'To install the package, from the Terminal, run the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: All these tools are useful for measuring and storing system resource usage information.
    And with this, we can determine which aspect of the resources has points for improvement.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s start with `CPU` usage.
  prefs: []
  type: TYPE_NORMAL
- en: Improving CPU usage
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To find points of improvement in CPU usage, first, observe the behavior of
    the CPU. Let’s learn how to check CPU usage with the different monitoring tools.
    Follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Use the **ps** command to list the processes with the highest CPU usage:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '![Figure 11.12 – Output of the ps command listing the processes with the highest
    CPU usage](img/B19121_11_12.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 11.12 – Output of the ps command listing the processes with the highest
    CPU usage
  prefs: []
  type: TYPE_NORMAL
- en: This mode of the `ps ax` command formats the output by process identifier (`pid`),
    percentage of CPU usage, and the command that started the process, sorting by
    the percentage of CPU usage.
  prefs: []
  type: TYPE_NORMAL
- en: The output shows that the process with the highest CPU usage is SSH, which should
    be considered normal for administrative tasks.
  prefs: []
  type: TYPE_NORMAL
- en: In our system, a web server is running. Let’s analyze its CPU usage.
  prefs: []
  type: TYPE_NORMAL
- en: 'Use the **ps** command to identify the **httpd** process and its CPU usage:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '![Figure 11.13 – Identifying the httpd process and its CPU usage](img/B19121_11_13.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 11.13 – Identifying the httpd process and its CPU usage
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: Enclosing the first character of the process in square brackets limits the search,
    ignoring the **grep** command itself at the output.
  prefs: []
  type: TYPE_NORMAL
- en: Note that the CPU usage displayed is not significant, so further research needs
    to focus on finding the real value of CPU usage.
  prefs: []
  type: TYPE_NORMAL
- en: 'Use the process identifier (**pid**) to find the resource usage with the **top**
    command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '![Figure 11.14 – Monitoring resource usage with the top command](img/B19121_11_14.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 11.14 – Monitoring resource usage with the top command
  prefs: []
  type: TYPE_NORMAL
- en: Now, let’s use the utility included in the `sysstat` package to get more information
    about the process’s performance.
  prefs: []
  type: TYPE_NORMAL
- en: 'Use the **pidstat** command with the process identifier (**pid**) to get the
    CPU usage of the process at the *1-second interval*:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '![Figure 11.15 – Process CPU usage percentage](img/B19121_11_15.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 11.15 – Process CPU usage percentage
  prefs: []
  type: TYPE_NORMAL
- en: A single CPU can only run *one process at a time*. To make the Linux system
    run multiple processes simultaneously, through multitasking, processes interleave
    their running on the CPU.
  prefs: []
  type: TYPE_NORMAL
- en: The kernel uses the *process scheduler* to determine which process to run at
    any given time. The process scheduler must balance several options, based on certain
    criteria, such as determining which process gets the next turn of execution, getting
    a fair share of CPU time but allowing high-priority processes a larger share and
    preempting lower-priority processes, or being predictable and scalable under different
    workload conditions.
  prefs: []
  type: TYPE_NORMAL
- en: 'The scheduler controls the order of running based on the scheduling priority
    policy assigned to each thread or process. These scheduling policies are divided
    into two groups: **non-real-time policies** and **real-time policies**.'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: '**Real-time computing** (**RTC**) guarantees the response of a system from
    the event to the response itself, within specified time constraints. A *real-time
    system* describes a system that controls an environment. It receives data, processes
    it, and returns the results fast enough to affect the environment at that time.'
  prefs: []
  type: TYPE_NORMAL
- en: The priority of the process using real-time policies is a value between `1`
    (*lowest*) and `99` (*highest*) and is known as a `0`.
  prefs: []
  type: TYPE_NORMAL
- en: The priority of the process could *increase* and *decrease* during the lifetime
    of the process; this is known as the `nice` or `renice` commands.
  prefs: []
  type: TYPE_NORMAL
- en: Since the static priority of non-real-time processes is set to `0`, the nice
    value determines the *relative scheduling* of non-real-time processes. The nice
    value ranges from `-20` (*highest*) to `19` (*lowest*).
  prefs: []
  type: TYPE_NORMAL
- en: 'Fedora Linux provides six scheduling policies divided into two groups: `real-time`
    and `non-real-time` scheduling classes. The following table lists the policies
    available in each scheduling class:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Class** | **Policies** | **Definition** |'
  prefs: []
  type: TYPE_TB
- en: '| Real-time scheduler | `SCHED_FIFO` | Uses the *first-in*, *first-out* scheduling
    algorithm without timeslices. |'
  prefs: []
  type: TYPE_TB
- en: '| `SCHED_RR` | Uses the *round-robin* scheduling algorithm with timeslices.
    |'
  prefs: []
  type: TYPE_TB
- en: '| **Completely Fair** **Scheduler** (**CFS**) | `SCHED_NORMAL` (*also known*
    *as* `SCHED_OTHER`) | Defines the *round-robin* style time-sharing schedule. |'
  prefs: []
  type: TYPE_TB
- en: '| `SCHED_BATCH` | Benefits *batch-oriented* workloads. |'
  prefs: []
  type: TYPE_TB
- en: '| `SCHED_IDLE` | Benefits running low-priority applications. |'
  prefs: []
  type: TYPE_TB
- en: '| Deadline scheduler | `SCHED_DEADLINE` | The scheduler guarantees real-time
    task scheduling, even under high load conditions. It does so by using three parameters
    – `period`, `deadline`, and `runtime` – to define a task in nanoseconds. |'
  prefs: []
  type: TYPE_TB
- en: Table 11.3 – Scheduling policies
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s continue using the previous example of the web server to analyze the
    priority of its process. Follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Use the **ps** command to list the priority of processes:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '![Figure 11.16 – Reviewing process priority](img/B19121_11_16.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 11.16 – Reviewing process priority
  prefs: []
  type: TYPE_NORMAL
- en: Here, the `pri` column shows `19`), the `rtprio` column shows real time priority
    (`-`), the `ni` column shows `0`), and the `cls` column shows the `TS` represents
    **time-sharing**.
  prefs: []
  type: TYPE_NORMAL
- en: The preceding output indicates that the process has low priority in its run.
    Let’s change this.
  prefs: []
  type: TYPE_NORMAL
- en: 'Use the **chrt** command to display the scheduling policy and priority of the
    web server processes:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '![Figure 11.17 – Scheduling the policy and priority of web server processes](img/B19121_11_17.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 11.17 – Scheduling the policy and priority of web server processes
  prefs: []
  type: TYPE_NORMAL
- en: The scheduled priority of all processes is `0` and their scheduling policy is
    `SCHED_NORMAL` (or `SCHED_OTHER`). Let’s improve the process run.
  prefs: []
  type: TYPE_NORMAL
- en: 'Stop the web server service and restart it by changing the scheduled policy
    to **SCHED_FIFO** and the scheduled priority to **38**. Use the **chrt** command
    and the process binary:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '![Figure 11.18 – Changing the scheduling policy and priority](img/B19121_11_18.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 11.18 – Changing the scheduling policy and priority
  prefs: []
  type: TYPE_NORMAL
- en: Review the scheduling policy and priority of the web server processes.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: For more information about the **chrt** command’s options, refer to the manual
    pages by running the **man** **chrt** command.
  prefs: []
  type: TYPE_NORMAL
- en: This change is temporary. When the process restarts, the scheduled policy and
    scheduled priority should apply again.
  prefs: []
  type: TYPE_NORMAL
- en: To set a scheduled policy and priority to improve the performance of the process
    each time it starts, it must be added to the service’s `unit` file.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s do it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a scheduled configuration file for the **httpd** service with the following
    content:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '![Figure 11.19 – Creating the service configuration file](img/B19121_11_19.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 11.19 – Creating the service configuration file
  prefs: []
  type: TYPE_NORMAL
- en: 'Unit configuration policies are set to change the priority of a service during
    the boot process. The directives in the `[Service]` section change the scheduling
    policy and priority:'
  prefs: []
  type: TYPE_NORMAL
- en: '**CPUSchedulingPriority** (**Nice**): Sets the default **nice** level for the
    service. The *nice* level is set as a number between **-20** (*highest priority*)
    and **19** (*lowest priority*).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**CPUSchedulingPolicy**: Sets the **CPU** scheduling policy for the service.
    The policy is set with the **other**, **batch**, **idle**, **fifo**, and **rr**
    values.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: At the time of writing, the **CPUSchedulingPolicy** variable does not support
    the **SCHED_DEADLINE** policy setting.
  prefs: []
  type: TYPE_NORMAL
- en: 'Reload the configuration of the services that were loaded in by `systemd` before
    restarting the web server service. Use the `systemctl` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Restart the service to apply the policy and priority changes.
  prefs: []
  type: TYPE_NORMAL
- en: 'Use the **systemctl** command to restart the web server service:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '![Figure 11.20 – Restarting the web server service](img/B19121_11_20.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 11.20 – Restarting the web server service
  prefs: []
  type: TYPE_NORMAL
- en: Review the scheduling policy and priority of the web server processes.
  prefs: []
  type: TYPE_NORMAL
- en: The change of priority and scheduled policy should apply when the service starts.
    This change improves the performance of the service.
  prefs: []
  type: TYPE_NORMAL
- en: What we’ve covered here applies to the case of processing. Now, let’s learn
    how to improve memory usage.
  prefs: []
  type: TYPE_NORMAL
- en: Improving memory usage
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `ps` and `top` utilities differentiate between two statistics: `VIRT` (or
    `VSZ`), the total amount of virtual memory a process has requested, and `RES`
    (or `RSS`), the total amount of virtual memory a process is currently mapping
    into physical memory. `RSS` is the most critical value.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Using the preceding example, observe the virtual memory value mapped to the
    web server process with the `ps` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: '![Figure 11.21 – Reviewing the virtual memory mapped to the web server](img/B19121_11_21.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 11.21 – Reviewing the virtual memory mapped to the web server
  prefs: []
  type: TYPE_NORMAL
- en: When a process requests memory, virtual memory addresses get reserved, but the
    kernel doesn’t allocate them to physical page frames. The kernel only allocates
    physical page frames when the process starts using `memory`.
  prefs: []
  type: TYPE_NORMAL
- en: In the same way that the priority and scheduled policy are changed for processing,
    the memory that an application consumes could change.
  prefs: []
  type: TYPE_NORMAL
- en: 'Follow this step to adjust the `MemoryLimit` parameter of the `sshd` process:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Using the **sysctl** command, adjust the **MemoryLimit** parameter:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: A memory size can be specified in kilobytes, megabytes, gigabytes, or terabytes
    using the **K**, **M**, **G**, or **T** suffix, respectively.
  prefs: []
  type: TYPE_NORMAL
- en: This command changes the service startup configuration file.
  prefs: []
  type: TYPE_NORMAL
- en: 'Use the `sysctl` command to display the service unit file. Filter the `Memory`
    parameter:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.22 – Reviewing the MemoryLimit parameter](img/B19121_11_22.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 11.22 – Reviewing the MemoryLimit parameter
  prefs: []
  type: TYPE_NORMAL
- en: In *Figure 11**.22*, we find that the kernel assigned the service 10 MB of memory
    and, by setting the `MemoryLimit` parameter, ensures that it only uses up to 1
    GB.
  prefs: []
  type: TYPE_NORMAL
- en: Keeping control of the resources assigned to the services allows them to improve
    their performance and that of the operating system as well.
  prefs: []
  type: TYPE_NORMAL
- en: Managing unallocated memory is the task that requires the most intense monitoring
    in Linux. The kernel uses most of the unallocated memory as a cache to store data
    that gets read from or written to disk. The next time a process needs that data,
    the system fetches it from RAM instead of disk. The caching mechanism improves
    performance in general since storage is usually much slower than physical memory.
  prefs: []
  type: TYPE_NORMAL
- en: Besides cache pages, the system uses anonymous pages. Anonymous pages have no
    data associated with them on disk. These anonymous pages represent the pages that
    processes allocate and use to store their work data.
  prefs: []
  type: TYPE_NORMAL
- en: We have different tools and utilities that help us monitor both.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s have a brief overview of these tools and utilities.
  prefs: []
  type: TYPE_NORMAL
- en: 'Inspect the memory usage with the `free` and `vmstat` commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: '![Figure 11.23 – Output of the free command](img/B19121_11_23.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 11.23 – Output of the free command
  prefs: []
  type: TYPE_NORMAL
- en: In this system, there’s 8 GiB of RAM. The cache pages (the `buff/cache` column)
    consume 1 GiB.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s compare this with the output of the `vmstat` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: '![Figure 11.24 – Output of the vmstat command](img/B19121_11_24.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 11.24 – Output of the vmstat command
  prefs: []
  type: TYPE_NORMAL
- en: From the output of the `vmstat` command, note that the size of the page cache
    is the sum of the `buff` and `cache` columns. Buffers are part of the page cache.
    Buffers store blocks of data read *directly* from a block device, not from the
    filesystem.
  prefs: []
  type: TYPE_NORMAL
- en: Anonymous pages get moved to the swap area when the system is under memory pressure.
    The kernel chooses between retrieving anonymous pages or pages from the page cache.
    The availability of swap increases the amount of effective memory.
  prefs: []
  type: TYPE_NORMAL
- en: 'From the output of the `vmstat` command (*Figure 11**.24*), in the `swap` section,
    we can see the values of the anonymous pages:'
  prefs: []
  type: TYPE_NORMAL
- en: '**si**: Pages *swapped in* per second'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**so**: Pages *swapped out* per second'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *swap area* was a subject of discussion for many years. At the beginning
    of the computer era, several myths about how to calculate the swap area were created
    among system administrators from those days. They were not only taken as good
    practices but as a must-have during the creation of the swap area. This was because,
    in those days, physical storage was expensive.
  prefs: []
  type: TYPE_NORMAL
- en: Nowadays, with new technologies, storage has become cheaper and more affordable.
    So, the creation of the swap area is considered under the use case criteria.
  prefs: []
  type: TYPE_NORMAL
- en: 'Red Hat proposes the following table as a basis for use cases for sizing when
    creating the swap area:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **RAM** | **Swap Space** |'
  prefs: []
  type: TYPE_TB
- en: '| 2 GiB or less | *Two times* the RAM |'
  prefs: []
  type: TYPE_TB
- en: '| Between 2 GiB and 8 GiB | Equal to RAM |'
  prefs: []
  type: TYPE_TB
- en: '| Between 8 GiB and 64 GiB | At least 4 GiB |'
  prefs: []
  type: TYPE_TB
- en: '| More than 64 GiB | At least 4 GiB |'
  prefs: []
  type: TYPE_TB
- en: Table 11.4 – Basic guidance on swap area sizing
  prefs: []
  type: TYPE_NORMAL
- en: Keep in mind that when a process requests memory, the kernel only reserves virtual
    memory and doesn’t consume any RAM. Since the kernel only allocates physical page
    frames when the process starts, this allows applications to allocate more memory
    than what’s available in the system. This feature function is called memory overcommitment.
  prefs: []
  type: TYPE_NORMAL
- en: 'The memory overcommit policy of the system can be tuned using the `sysctl`
    variable, `vm.overcommit_memory`. You can set it to one of the following values:'
  prefs: []
  type: TYPE_NORMAL
- en: '**0**: The kernel uses a *heuristic overcommit algorithm*. This is the configured
    system default.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**1**: The kernel *always* overcommits memory. It always grants memory allocations,
    regardless of whether there is enough free memory.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**2**: The kernel strictly controls memory overcommitment. It only commits
    an amount of memory equal to the *amount of swap space plus a percentage* (the
    default is 50%) of physical memory. This percentage gets defined with the **vm.overcommit_ratio**
    variable.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Use the `sysctl` command to verify both variables:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: '![Figure 11.25 – Reviewing the memory overcommit variables](img/B19121_11_25.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 11.25 – Reviewing the memory overcommit variables
  prefs: []
  type: TYPE_NORMAL
- en: Monitoring these basic aspects of memory helps improve the performance of the
    system and the services it provides.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s see how to do the same with storage.
  prefs: []
  type: TYPE_NORMAL
- en: Don’t ignore storage tuning
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Unlike other system resources, storage may optimize its performance as soon
    it gets sized. It can also be tuned when its usage gets analyzed.
  prefs: []
  type: TYPE_NORMAL
- en: For this, it is necessary to consider that the correct sizing depends on differentiating
    the measures used in the storage allocation process.
  prefs: []
  type: TYPE_NORMAL
- en: A very common mistake is to size with the wrong storage measurements, causing
    storage space to go unused or wasted.
  prefs: []
  type: TYPE_NORMAL
- en: The key point to consider is how disk manufacturers overcome the challenge of
    creating a device that lives in two worlds. A disk is a raw physical device with
    no virtual or data structures before creating a filesystem. A raw disk becomes
    a block disk structure when it gets formatted as a filesystem. Filesystems are
    binary structures.
  prefs: []
  type: TYPE_NORMAL
- en: This means that we must create a physical device, created under the physical
    rules of the real world, and turn it into a data structure in the digital world.
  prefs: []
  type: TYPE_NORMAL
- en: The `-` for *kilo-*) and adding the letters `-` *bi* `-` for *binary*.
  prefs: []
  type: TYPE_NORMAL
- en: 'The point of error occurs when the values get confused. Note the difference
    in the following comparison table:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **SI** **decimal prefixes** |'
  prefs: []
  type: TYPE_TB
- en: '| **Prefix** | **Nomenclature** | **base** | **Bytes** |'
  prefs: []
  type: TYPE_TB
- en: '| kilo- | k | 103 | 1,000 |'
  prefs: []
  type: TYPE_TB
- en: '| mega- | M | 106 | 1,000,000 |'
  prefs: []
  type: TYPE_TB
- en: '| giga- | G | 109 | 1,000,000,000 |'
  prefs: []
  type: TYPE_TB
- en: '| tera- | T | 1012 | 1,000,000,000,000 |'
  prefs: []
  type: TYPE_TB
- en: '| **IEC** **binary prefixes** |'
  prefs: []
  type: TYPE_TB
- en: '| kibi- | Ki | 210 | 1,024 |'
  prefs: []
  type: TYPE_TB
- en: '| mebi- | Mi | 220 | 1,048,576 |'
  prefs: []
  type: TYPE_TB
- en: '| gibi- | Gi | 230 | 1,073,741,824 |'
  prefs: []
  type: TYPE_TB
- en: '| tebi- | Ti | 240 | 1,099,511,627,776 |'
  prefs: []
  type: TYPE_TB
- en: Table 11.5 – Prefixes comparison
  prefs: []
  type: TYPE_NORMAL
- en: So, how many bytes are on a 1 TB disk?
  prefs: []
  type: TYPE_NORMAL
- en: 1 TB is 1 x 1,012 bytes = 1,000,000,000,000.
  prefs: []
  type: TYPE_NORMAL
- en: As mentioned previously, to create a filesystem on disk, binary structures use
    a block size (by default) of 4,096 (4 KiB). Using this nomenclature, a terabyte
    means 1,012 bytes.
  prefs: []
  type: TYPE_NORMAL
- en: Thus, some operating system tools could report in TB, but actually, they measure
    in binary tebibytes (TiB).
  prefs: []
  type: TYPE_NORMAL
- en: A tool that reports disk size in TB, but measures TB as tebibytes, would report
    that a 1 TB disk is only 0.91 TB in size (equal to 0.91 TiB), a difference of
    almost 10%.
  prefs: []
  type: TYPE_NORMAL
- en: Thus, it is very important to clearly state which units get used to analyze
    the sizing in a system report – otherwise, significant errors could occur in the
    analysis.
  prefs: []
  type: TYPE_NORMAL
- en: Now, let’s learn how to analyze storage space usage.
  prefs: []
  type: TYPE_NORMAL
- en: Improving storage space usage
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A big issue in analyzing storage space usage involves identifying it correctly.
    A stable identifier that maps to a filesystem is its **UUID**. This is a hexadecimal
    number that acts as a **Universal** **Unique Identifier**.
  prefs: []
  type: TYPE_NORMAL
- en: The UUID is part of the filesystem and remains the same so long as the filesystem
    is not regenerated again.
  prefs: []
  type: TYPE_NORMAL
- en: The utility for listing block devices is the `lsblk` command.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `lsblk` command with the `-fp` option displays the full path to the device,
    as well as the UUIDs and mount points, plus the filesystem type of the physical
    disk partition:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: '![Figure 11.26 – Output of the lsblk command](img/B19121_11_26.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 11.26 – Output of the lsblk command
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: If the filesystem is not mounted, the mount point appears blank.
  prefs: []
  type: TYPE_NORMAL
- en: 'The most used tool for obtaining information about total filesystem usage is
    the `df` command. With the `-h` option, the output is displayed in a human-readable
    format:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: '![Figure 11.27 – Output of the df -h command](img/B19121_11_27.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 11.27 – Output of the df -h command
  prefs: []
  type: TYPE_NORMAL
- en: By installing the `sysstat` package, as mentioned previously, we receive tools
    for monitoring system performance. In the case of storage, the `iostat` command
    displays I/O statistics per disk, as well as workload, usage, and saturation metrics.
  prefs: []
  type: TYPE_NORMAL
- en: 'Running the `iostat` command without arguments returns the CPU usage and disk
    I/O metrics:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: '![Figure 11.28 – Output of the iostat command](img/B19121_11_28.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 11.28 – Output of the iostat command
  prefs: []
  type: TYPE_NORMAL
- en: 'By combining the different options of the `iostat` command, we can generate
    very useful statistics for usage analysis. Here’s an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: '![Figure 11.29 – Output of the iostat -dyz command](img/B19121_11_29.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 11.29 – Output of the iostat -dyz command
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s look at the options that were used:'
  prefs: []
  type: TYPE_NORMAL
- en: '**-d** displays the disk I/O usage report'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**-y** skips the first report with statistics since when the system started'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**-z** skips inactive devices'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The interval is a second
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The count is an output of three reports every interval
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: For more information about the **iostat** command options, refer to the manual
    pages. You can find them by running the **man** **iostat** command.
  prefs: []
  type: TYPE_NORMAL
- en: As mentioned in the previous section, having swap space increases the effective
    amount of memory. Let’s learn how to create a swap space in the system with effective
    sizing.
  prefs: []
  type: TYPE_NORMAL
- en: We’ll use the `/dev/sdc` disk we used in [*Chapter 4*](B19121_04.xhtml#_idTextAnchor121)
    to create the filesystem with Stratis. Please follow the instructions in the aforementioned
    chapter to remove the pool and wipe the filesystem from the disk.
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Use the **wipefs** command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: This command destroys the filesystem information of the device. Please be very
    careful and verify that the device you wish to wipe is the correct one.
  prefs: []
  type: TYPE_NORMAL
- en: Now, let’s create the partition for the swap area.
  prefs: []
  type: TYPE_NORMAL
- en: 'Inspect the **/dev/sdc** disk to confirm that no partitions have been created.
    Use the **parted** command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '![Figure 11.30 – Listing the /dev/sdc disk partitions](img/B19121_11_30.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 11.30 – Listing the /dev/sdc disk partitions
  prefs: []
  type: TYPE_NORMAL
- en: Create a 512 MB partition.
  prefs: []
  type: TYPE_NORMAL
- en: 'Use the **parted** command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '![Figure 11.31 – Creating a swap partition](img/B19121_11_31.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 11.31 – Creating a swap partition
  prefs: []
  type: TYPE_NORMAL
- en: Using the `parted` command without a subcommand opens an interactive `parted`
    session.
  prefs: []
  type: TYPE_NORMAL
- en: 'Inside the interactive session, do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Run the **mkpart** subcommand to create the partition.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Set **swap1** as the partition’s name.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Set the filesystem type to **linux-swap**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The partition should start at 2,049 KB and end at 513 MB so that the size is
    512 MB.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: It is important to start a partition in the first block of the underlying storage.
    Starting at sector **2048** is the default value for modern Linux and is stored
    on all storage types. This is known as the initial offset or partition alignment.
  prefs: []
  type: TYPE_NORMAL
- en: Verify that the partition was created by running the `print` subcommand.
  prefs: []
  type: TYPE_NORMAL
- en: Type `quit` to exit the interactive `parted` session.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: The **parted** command can display output on a *binary basis* as well.
  prefs: []
  type: TYPE_NORMAL
- en: 'Run the `# parted /dev/sdc unit MiB` `print` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.32 – Output of the parted command displayed on a binary basis](img/B19121_11_32.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 11.32 – Output of the parted command displayed on a binary basis
  prefs: []
  type: TYPE_NORMAL
- en: Ask the system to detect the new partition and create the associated device
    file in the `/``dev` directory.
  prefs: []
  type: TYPE_NORMAL
- en: 'Run the **udevadm settle** command to observe the **udev** event queue and
    update it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Now, format the partition.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Use the **mkswap** command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '![Figure 11.33 – Formatting the partition](img/B19121_11_33.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 11.33 – Formatting the partition
  prefs: []
  type: TYPE_NORMAL
- en: Review the swap area of the system.
  prefs: []
  type: TYPE_NORMAL
- en: 'Use the **free** command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '![Figure 11.34 – Reviewing swap memory](img/B19121_11_34.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 11.34 – Reviewing swap memory
  prefs: []
  type: TYPE_NORMAL
- en: Activate the swap partition in the system.
  prefs: []
  type: TYPE_NORMAL
- en: 'Use the **swapon** command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '![Figure 11.35 – Activating the swap partition](img/B19121_11_35.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 11.35 – Activating the swap partition
  prefs: []
  type: TYPE_NORMAL
- en: Now, verify the swap area of the system.
  prefs: []
  type: TYPE_NORMAL
- en: The new swap area partition is active and available to the system. To make it
    persistently active, we need to create an entry in the `/``etc/fstab` file.
  prefs: []
  type: TYPE_NORMAL
- en: 'Identify the UUID of the swap partition and create an entry in the **/etc/fstab**
    file. Use the **lsblk** command to do so:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '![Figure 11.36 – Identifying the UUID of the swap partition](img/B19121_11_36.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 11.36 – Identifying the UUID of the swap partition
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following line to the `/``etc/fstab` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: '![Figure 11.37 – Adding the swap partition to the /etc/fstab file](img/B19121_11_37.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 11.37 – Adding the swap partition to the /etc/fstab file
  prefs: []
  type: TYPE_NORMAL
- en: In this way, the swap partition remains persistently available to the system.
    With this, the system’s performance improves since physical memory becomes available.
    At this stage, the storage space is optimized for the swap space.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, let’s learn how to improve the performance of the network connection
    to the system.
  prefs: []
  type: TYPE_NORMAL
- en: Boosting performance with network tuning
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The network represents one of the most complex and key elements involved in
    tuning the system. Being an externally self-organizing element, some network elements
    could affect performance. To identify and adjust them, it is necessary to know
    the flow that a packet follows both when transmitted and received by a system,
    as well as the tuning options available for them.
  prefs: []
  type: TYPE_NORMAL
- en: 'The transmission and reception flow of the packet is roughly as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Transmission**:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Data gets written to a socket (an object such as a file) and sent to the transmit
    buffer.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: The kernel encapsulates the data in a **protocol data** **unit** (**PDU**).
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: The PDUs go to the device’s transmit queue.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: The network device driver copies the PDU from the transmit queue header to the
    NIC.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: The NIC sends the data and triggers an interrupt when transmitted.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Reception**:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The NIC receives a frame and uses DMA to copy the frame to the receive buffer.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: The NIC triggers a hard interrupt.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: The kernel handles the hard interrupt and schedules a soft interrupt to handle
    the packet.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: The soft interrupt handles and moves the packet to the IP layer.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 'If the packet is intended for local delivery, the PDU is de-encapsulated and
    placed in a socket receive buffer:'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: If a process is waiting in this socket, it processes the data in the receive
    buffer
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: The tunables for the case of improving network flow consist of buffer limits.
    The kernel adjusts the size of these buffers based on the current network use
    but within the limits specified by the kernel tunables. The default values of
    these variables get calculated at boot time based on the amount of available memory.
  prefs: []
  type: TYPE_NORMAL
- en: 'The kernel tunables, which could change when running the `sysctl` command,
    are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**net.ipv4.tcp_mem**: This specifies the TCP system memory limits. It considers
    three fields: **min**, **max**, and **pressure** (when the amount of memory used
    in TCP/UDP exceeds this number, pages get moderated until they drop and return
    to the **min** value). These values represent the number of pages, not bytes.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Net.ipv4.udp_mem**: This specifies the UDP system memory limits. It considers
    three fields: **min**, **max**, and **pressure**. These values represent the number
    of pages, not bytes.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**net.core.rmem_max**: The maximum network core socket receive/send (**read/write**)
    buffers. Values are in bytes.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**net.core.wmem_max**: The maximum network core socket receive/send (**read/write**)
    buffers. Values are in bytes.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**net.ipv4.tcp_rmem**: The maximum TCP socket receive/send (**read/write**)
    buffers. It considers three fields: **min**, **default**, and **max**. Values
    are in bytes.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**net.ipv4.tcp_wmem**: The maximum TCP socket receive/send (**read/write**)
    buffers. It considers three fields: **min**, **default**, and **max**. Values
    are in bytes.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: The change of these values should take place after a behavioral analysis.
  prefs: []
  type: TYPE_NORMAL
- en: In general, tunable values should be changed after the system’s behavior has
    been analyzed.
  prefs: []
  type: TYPE_NORMAL
- en: For this purpose, several tools and utilities exist, which we have used throughout
    this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Now, let’s look at a tool that complements the use of `sysstat` and provides
    a graphical display of the collected metrics.
  prefs: []
  type: TYPE_NORMAL
- en: Analyzing metrics
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Besides installing the `sysstat` package to monitor tools, it can also be run
    as a service:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: '![Figure 11.38 – Reviewing the status of the sysstat service](img/B19121_11_38.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 11.38 – Reviewing the status of the sysstat service
  prefs: []
  type: TYPE_NORMAL
- en: 'The `sysstat` service collects, reports, or saves information about system
    activity. It stores operating system counters in the `/var/log/sa/sadd` file.
    From the data that’s been collected, a lot of information about the system can
    be received:'
  prefs: []
  type: TYPE_NORMAL
- en: CPU usage
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Memory paging and usage
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Network I/O and transfer statistics
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Process creation activity
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The activity of all block devices
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Interrupts per second
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We can get the collected data with the `sar` command:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Use the **sar** command with the **-u** option to get the CPU usage report:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '![Figure 11.39 – Output of the sar –u command](img/B19121_11_39.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 11.39 – Output of the sar –u command
  prefs: []
  type: TYPE_NORMAL
- en: This command is also used to read the history files where the daily data is
    recorded.
  prefs: []
  type: TYPE_NORMAL
- en: 'Use the **sar** command to read one of the log files from **/var/log/sa**:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '![Figure 11.40 – The log file’s content](img/B19121_11_40.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 11.40 – The log file’s content
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: For more information about **sar** command options, refer to the manual pages
    by running the **man** **sar** command.
  prefs: []
  type: TYPE_NORMAL
- en: From these files, it is possible to generate graphs and export them as images
    or even a PDF report. The most commonly used tool for this is `ksar`.
  prefs: []
  type: TYPE_NORMAL
- en: 'To get `ksar`, download it from their website at [https://sourceforge.net/projects/ksar/](https://sourceforge.net/projects/ksar/):'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.41 – The ksar website](img/B19121_11_41.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 11.41 – The ksar website
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: 'A more updated version of the **ksar** tool can be downloaded from its GitHub
    repository: [https://github.com/vlsi/ksar/releases](https://github.com/vlsi/ksar/releases).'
  prefs: []
  type: TYPE_NORMAL
- en: 'The `ksar` tool comes as a `jar` file, so it requires the `java-17-openjdk`
    package to be installed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: LC_ALL=C sar -A > /tmp/sar.data.txt
  prefs:
  - PREF_IND
  - PREF_H1
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: $ java -jar kSar.jar
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
