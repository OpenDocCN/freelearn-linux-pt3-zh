- en: '11'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '11'
- en: Creating Our First Module
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建我们的第一个模块
- en: Most programming languages include the concept of a library – an object that
    contains code, documentation, programming objects such as classes, message templates,
    and a host of other things. These libraries extend what we can do with that language
    by helping us to use other people’s code and reuse our own. In this chapter, we’re
    going to explore PowerShell modules – a convenient way of distributing PowerShell
    code.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数编程语言都包含库的概念——它是一个包含代码、文档、编程对象（如类）、消息模板以及许多其他内容的对象。这些库通过帮助我们使用他人的代码和重用我们自己的代码，扩展了我们可以用该语言做的事情。在本章中，我们将探讨
    PowerShell 模块——一种分发 PowerShell 代码的便捷方式。
- en: We’ll start by briefly recapping how to work with modules and the cmdlets we
    use to do that. Then, we’ll look at the components of a module. We’ll learn how
    to write a module manually, before wrapping up with a brief look at using a module
    scaffolding application called **Plaster**.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从简要回顾如何使用模块以及用于此的 cmdlet 开始。接下来，我们将查看模块的组成部分。我们将学习如何手动编写模块，然后简单介绍一下使用一个名为
    **Plaster** 的模块脚手架应用程序。
- en: 'The main topics we will cover in this chapter are as follows:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 本章我们将涵盖的主要主题如下：
- en: Working with modules
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用模块
- en: Writing a simple module
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编写一个简单的模块
- en: Module manifests
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 模块清单
- en: Using scaffolding tools such as Plaster
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用如 Plaster 这样的脚手架工具
- en: Working with modules
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用模块
- en: Back in [*Chapter 2*](B17600_02.xhtml#_idTextAnchor034), *Exploring PowerShell
    Cmdlets and Syntax*, we spent some time exploring how we can use modules to find
    new cmdlets. In this chapter, we’ll be writing modules, but first, let’s recap
    what we learned previously and place it in some sort of context.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 回到[*第二章*](B17600_02.xhtml#_idTextAnchor034)，*探索 PowerShell Cmdlet 和语法*，我们花了一些时间探讨了如何使用模块来查找新的
    cmdlet。在本章中，我们将编写模块，但首先，让我们回顾一下之前所学的内容，并将其放置在某种上下文中。
- en: Modules allow us to reuse and distribute code so that it can be easily automated
    by including the cmdlets that manipulate modules in our scripts. So, if we need
    a cmdlet from the PowerShell math module in our script, then we can programmatically
    import that module (or just the required cmdlet) and use it. We can do this in
    a predictable and controllable fashion, without user intervention.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 模块允许我们重用和分发代码，以便通过将操作模块的 cmdlet 包含在我们的脚本中轻松实现自动化。所以，如果我们需要在脚本中使用 PowerShell
    数学模块的 cmdlet，我们可以通过编程方式导入该模块（或仅导入所需的 cmdlet）并使用它。我们可以以可预测且可控的方式进行，而无需用户干预。
- en: 'Modules fulfill three basic functions:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 模块履行三个基本功能：
- en: '**Configuring the environment**: They provide a repeatable custom work environment
    – for example, the PowerShell module for Exchange, as well as Exchange-specific
    cmdlets – configuring the PowerShell environment to work in a particular way with
    Exchange'
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**配置环境**：它们提供一个可重复的自定义工作环境——例如，Exchange 的 PowerShell 模块，以及特定于 Exchange 的 cmdlet——将
    PowerShell 环境配置为以特定方式与 Exchange 协同工作。'
- en: '**Code reuse**: They provide libraries of functions that we or other people
    can use, such as the math module'
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**代码重用**：它们提供函数库，供我们或他人使用，例如数学模块。'
- en: '**Solution engineering**: Because modules can be nested inside other modules,
    whole groups of modules may be distributed to create an application for redistribution
    – this is common in Windows administration environments'
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**解决方案工程**：因为模块可以嵌套在其他模块中，所以可以将一整组模块分发出去，创建一个应用程序进行再分发——这在 Windows 管理环境中很常见。'
- en: We can find modules on the internet, in places such as GitHub, where they’ve
    been distributed with software, in a public repository such as the PowerShell
    Gallery or internal repositories in our workplace or school, or via friends and
    colleagues.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在互联网上找到模块，例如 GitHub，这里有软件发布的模块；也可以在公共仓库（如 PowerShell Gallery）或我们工作场所或学校的内部仓库中找到，或者通过朋友和同事获得。
- en: By installing the modules in standard locations, we can control access to them
    on a given machine, or we can add to the default list of places that PowerShell
    will search for modules. Let’s start by looking at the common locations for modules
    on our client device.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 通过将模块安装到标准位置，我们可以控制在特定机器上的访问权限，或者我们可以将 PowerShell 搜索模块的默认位置列表进行扩展。让我们从查看客户端设备上模块的常见位置开始。
- en: Module locations
  id: totrans-18
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 模块位置
- en: 'There are three default locations for modules. These are shown in the following
    table:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 模块有三个默认位置。这些位置如下表所示：
- en: '|  | **Windows** | **Linux** |'
  id: totrans-20
  prefs: []
  type: TYPE_TB
  zh: '|  | **Windows** | **Linux** |'
- en: '| **System** | None for PowerShell 7, but Windows PowerShell uses `C:\WINDOWS\system32\WindowsPowerShell\v1.0\Modules\`
    | `/``opt/Microsoft/PowerShell/7/Modules` |'
  id: totrans-21
  prefs: []
  type: TYPE_TB
- en: '| **AllUsers** |'
  id: totrans-22
  prefs: []
  type: TYPE_TB
- en: '`C:\Program Files\PowerShell\Modules`'
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`C:\Program Files\PowerShell\7\Modules`'
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '| `/``usr/local/share/PowerShell/Modules` |'
  id: totrans-25
  prefs: []
  type: TYPE_TB
- en: '| **User** | `C:\Users\<user name>\Documents\PowerShell\Modules` | `/``home/<username>/.local/share/PowerShell/Modules`
    |'
  id: totrans-26
  prefs: []
  type: TYPE_TB
- en: Table 11.1 – Default module locations in Windows and Linux
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
- en: The System location is reserved for Microsoft modules. The User location does
    not exist by default in Windows and will need to be created before it can be used.
    The AllUsers location was introduced in PowerShell v4 to provide a location for
    non-Microsoft modules that need to run under the system account. This also gives
    us a place to install modules for any user on the client to use. Modules downloaded
    from the PowerShell Gallery are placed here by default.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
- en: 'As we saw in [*Chapter 2*](B17600_02.xhtml#_idTextAnchor034), *Exploring PowerShell
    Cmdlets and Syntax*, we can add locations where we may install modules by manipulating
    the `$ENV:PSModulePath` variable. Locations should be separated by a semicolon
    (`;`) in Windows and a colon (`:`) in Linux, as shown here:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.1 – The $env:PSModulePath variable in Linux](img/B17600_11_001.jpg)'
  id: totrans-30
  prefs: []
  type: TYPE_IMG
- en: Figure 11.1 – The $env:PSModulePath variable in Linux
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
- en: We can make this listing tidier by calling the `$env:PSModulePath -Split ":"`
    variable, which will output each location on a separate line. Obviously, on a
    Windows client, the separator should be a semicolon (`;`). Paths often get added
    to this variable when installing applications.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
- en: Module autoloading
  id: totrans-33
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We can load modules automatically under certain circumstances. Modules in correctly
    named folders in the module paths defined in `$env:PSModulePath` are automatically
    discovered by PowerShell. We can do this by doing the following:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
- en: Running a cmdlet from the module
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using `Get-Command` for a cmdlet in the module
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using `Get-Help` for a cmdlet in the module
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Module autoloading is great for when we’re working interactively in the shell,
    but we shouldn’t rely on it in a script. The recommended way to load modules inside
    a script is with the `using` keyword, like this:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Here’s an example:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Note that some caveats on this are covered in the *Nested* *modules* section.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
- en: Importing modules
  id: totrans-43
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Autoloading modules is convenient, but it’s not particularly controlled. For
    instance, it loads everything in the module, some of which we might not need,
    and we cannot control the version of the module that is loaded. It can also consume
    a lot of memory. Therefore, we might choose to manually import modules into a
    session using the `Import-Module` cmdlet, which gives us several options to control
    how and what we import:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
- en: '`-Name`: Use this to specify the name of the module to import. We can also
    include a path here if the module is not in the module path specified in `$ENV:PSModulePath`.'
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`-Cmdlet`: This allows us to import a selection of cmdlets from an array of
    strings. Similar parameters, such as `-Alias`, `-Function`, and `-Variable`, have
    the expected effect.'
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`-Force`: This forces a module to reload completely. By default, if a module
    is already loaded, then `Import-Module` does not reimport it. This is useful if
    we are developing a module and need to test it repeatedly.'
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`-RequiredVersion`: Use this to specify the version of the module to be imported.'
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`-Prefix`: This parameter adds a prefix to the nouns in cmdlets that are imported
    from the module, to prevent confusion with cmdlets that already exist in the session.'
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`-NoClobber`: This prevents cmdlets from being imported if they have the same
    name as cmdlets that already exist in the session.'
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There are several other parameters, but we won’t consider them here.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
- en: We can unload a module using the `Remove-Module` cmdlet. Why might we want to
    do that? Well, when we first import a module, we import all the nested modules
    that it requires as well. However, if we then use `Import-Module -Force` to reload
    the module, it only reloads the named module, not the nested modules. `Remove-Module`
    also removes the nested modules. In practice, of course, just starting a new session
    is often quicker and cleaner.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
- en: Very often, we’ll see scripts on the internet using the `Import-Module` cmdlet
    to make module contents available inside a script. I do this too, despite it not
    being the recommended way of doing it; it just feels more readable to me. Microsoft
    recommends we do this with the `using` keyword, though. My doctor recommends I
    eat less salt; I tend to ignore that advice as well.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
- en: PowerShellGet
  id: totrans-54
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Microsoft has a module called `PowerShellGet` that includes a lot of resources
    for working with repositories and modules. This module is included in PowerShell
    7\. It allows us to work easily with the PowerShell Gallery so that we can find,
    register, and unregister other repositories, which allows us to find, install,
    and uninstall modules and scripts in repositories, as well as manipulate those
    modules and scripts. We covered the basic uses of `PowerShellGet` at some length
    in [*Chapter 2*](B17600_02.xhtml#_idTextAnchor034),*Exploring PowerShell Cmdlets*
    *and Syntax*.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
- en: From PowerShell 7.4 onwards, the PowerShellGet v2.2.5 module will be accompanied
    by version 3\. The version 3 module is called `Microsoft.Powershell.PSResourceGet`
    and replaces the `Install-Module` and `Install-Script` cmdlets with the single
    `Install-PSResource` cmdlet, among many other changes. In PowerShell 7.4, the
    two modules will ship side by side, allowing any current resources that use `PowerShellGet`
    to continue working. However, no compatibility layer will be included, so scripts
    written for v2.2.5 and earlier won’t work with version 3 unless we use the separate
    `CompatPowerShellGet` module that will be included in PowerShell 7.5.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
- en: Next, we’ll learn how to create a module, but first, a word of caution. There
    is a PowerShell cmdlet called `New-Module`. This creates a very specific type
    of module – a `New-Module`, either.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
- en: Writing a simple module
  id: totrans-58
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A module, at its most basic, is a script file containing functions, saved with
    a `.psm1` extension. That’s it. That’s the simplest possible module. Try it –
    save the following lines as a `.psm1` file, in a folder with the same name as
    the file, inside your `\users\<username>\documents\powershell\modules` folder
    (or the `home/<user>/.local/share/powershell/Modules` folder in Linux):'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'It doesn’t matter what you call the file, so long as the file and folder name
    are the same, and the folder is in the module path so that PowerShell can find
    it, like this:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.2 – Saving a module in the module path correctly](img/B17600_11_002.jpg)'
  id: totrans-62
  prefs: []
  type: TYPE_IMG
- en: Figure 11.2 – Saving a module in the module path correctly
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, if we start a PowerShell session, we can type the following:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'PowerShell will load it. Once it is loaded, we can use the functions inside,
    like this:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.3 – Using our first module](img/B17600_11_003.jpg)'
  id: totrans-67
  prefs: []
  type: TYPE_IMG
- en: Figure 11.3 – Using our first module
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, the `Import-Module` cmdlet produces no output, but the function
    inside the module is available. If we run `Remove-Module`, the function disappears
    as well. Or does it?
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
- en: Activity 1
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
- en: Try running `Remove-Module` to get rid of the module we’ve just installed, and
    then running `Get-Square`. What happens? Why does this happen?
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
- en: Before we look at ways to create modules, let’s talk about the earliest method
    of building libraries in PowerShell – dot-sourcing.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
- en: A word of caution – dot-sourcing
  id: totrans-73
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In the very first version of PowerShell, there was only one way to include
    the functions in one script inside another: `Dot-Source.ps1` in a suitable folder
    – I’m using `c:\temp\poshbook\ch11`:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'It should be obvious that if we run this, it isn’t going to work. There is
    no cmdlet called `Write-Message`, and the script doesn’t define one. Let’s create
    a `Write-Message` function in another script, and save it as `Write-Message.ps1`:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Now, let’s go back to `Dot-Source.ps1` and add this line at the start:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Change the path to reflect the location where you saved `Write-Message.ps1`.
    Now, when we run `Dot-Source.ps1`, our message should be displayed, as shown here:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.4 – Using dot-sourcing in a script](img/B17600_11_004.jpg)'
  id: totrans-81
  prefs: []
  type: TYPE_IMG
- en: Figure 11.4 – Using dot-sourcing in a script
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
- en: 'We can do this interactively as well, in a PowerShell session, just by dot-sourcing
    the script, as shown here:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.5 – Interactive dot-sourcing](img/B17600_11_005.jpg)'
  id: totrans-84
  prefs: []
  type: TYPE_IMG
- en: Figure 11.5 – Interactive dot-sourcing
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
- en: So, if dot-sourcing is so straightforward, why should we bother with modules
    at all? The reason is the management problems that dot-sourcing introduces. When
    we dot-source a script, we bring the members of that script, as well as the variables
    and functions, into the parent scope. We can see this in the preceding screenshot;
    if we call the `$text` variable, then we get the `default message` string. Remember,
    the concept of scope was introduced to protect us from ambiguously written code;
    by dot-sourcing code, we remove that protection. When we interactively dot-sourced
    `Write-Message.ps1`, we brought a function into the global scope that we now have
    no easy way of removing. Any variables in that script outside the function would
    be brought in as well. If those variables are poorly named, they may conflict
    with important existing variables, leading to, as they say, hilarious consequences.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，如果点源（dot-sourcing）这么简单，为什么我们还需要使用模块呢？原因是点源带来的管理问题。当我们进行点源时，我们将脚本的成员以及变量和函数引入到父作用域中。我们可以在前面的截图中看到这一点；如果我们调用`$text`变量，就会得到`default
    message`字符串。记住，作用域的概念是为了保护我们免受不明确代码的影响；通过点源代码，我们去除了这种保护。当我们交互式地点源`Write-Message.ps1`时，我们将一个函数带入了全局作用域，而现在我们没有简单的方法将其删除。该脚本中函数外的任何变量也会被引入。如果这些变量命名不当，可能会与现有的重要变量发生冲突，导致“可笑的后果”。
- en: 'If we are unsure where a function has come from, we can use the `File` property
    on the object to check, like this:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们不确定一个函数的来源，可以使用对象的`File`属性进行检查，像这样：
- en: '[PRE7]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'This will give us the path of the file that contains that function. We can
    also remove it from a session with the `Remove-Item` cmdlet, as shown here:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 这将给我们该函数所在文件的路径。我们还可以使用`Remove-Item` cmdlet从会话中删除它，如下所示：
- en: '![Figure 11.6 – Finding the source of functions and removing them](img/B17600_11_006.jpg)'
  id: totrans-90
  prefs: []
  type: TYPE_IMG
  zh: '![图 11.6 – 查找函数来源并删除它们](img/B17600_11_006.jpg)'
- en: Figure 11.6 – Finding the source of functions and removing them
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.6 – 查找函数来源并删除它们
- en: Modules allow us to control what functions and variables are exported from our
    code, and to control those as a group. Let’s see how we can turn an existing script
    into a module.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 模块允许我们控制从代码中导出的函数和变量，并将它们作为一个整体进行控制。让我们看看如何将现有的脚本转换为模块。
- en: Turning a script into a module
  id: totrans-93
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将脚本转换为模块
- en: As we saw at the start of this section, the basic process for turning a script
    into a module is to change the file extension from `.ps1` to `.psm1`. Let’s do
    that now with the `Write-Message.ps1` script we wrote previously, and save a copy
    of it as `Write-Message.psm1`.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在本节开始时看到的，将脚本转换为模块的基本过程是将文件扩展名从`.ps1`更改为`.psm1`。现在，我们来处理之前写的`Write-Message.ps1`脚本，并将其保存为`Write-Message.psm1`。
- en: 'Now, we can open a new session and import our module into the session with
    the following command:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以打开一个新的会话，并使用以下命令将我们的模块导入到会话中：
- en: '[PRE8]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Let’s take a look at this module in detail:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们详细查看这个模块：
- en: '![Figure 11.7 – Details of the Write-Message module](img/B17600_11_007.jpg)'
  id: totrans-98
  prefs: []
  type: TYPE_IMG
  zh: '![图 11.7 – `Write-Message`模块的详细信息](img/B17600_11_007.jpg)'
- en: Figure 11.7 – Details of the Write-Message module
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.7 – `Write-Message`模块的详细信息
- en: 'In the first line, we imported the module. We used the full path because we
    haven’t saved it in a location included in the module path. This is to prevent
    PowerShell from autoloading it. Now, let’s run the following command:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一行中，我们导入了模块。我们使用了完整路径，因为我们没有将其保存到包含在模块路径中的位置。这是为了防止PowerShell自动加载它。现在，让我们运行以下命令：
- en: '[PRE9]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'We’ll see a script module, its location, and the exported command – that is,
    `Write-Module`. Now, let’s run the following command:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将看到一个脚本模块、它的位置以及导出的命令——也就是`Write-Module`。现在，让我们运行以下命令：
- en: '[PRE10]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: We will see that only the function is exported, not the variable.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将看到只有函数被导出，而不是变量。
- en: We can check the details of the `Write-Message` function with `Get-Command`
    and see that the source is the `Write-Message` module.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用`Get-Command`检查`Write-Message`函数的详细信息，查看其来源是`Write-Message`模块。
- en: 'Let’s try some other things with this module. Open the module file and add
    the following code:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们尝试使用这个模块做一些其他事情。打开模块文件并添加以下代码：
- en: '[PRE11]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Import the module again, using the `-Force` parameter to reload it. Now, we
    have two functions in our module. If we run `Get-Module` again, we’ll see that
    they are both visible:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 再次导入模块，使用`-Force`参数重新加载它。现在，我们的模块中有两个函数。如果我们再次运行`Get-Module`，我们会看到它们都已经显示出来：
- en: '![Figure 11.8 – Multiple exports](img/B17600_11_008.jpg)'
  id: totrans-109
  prefs: []
  type: TYPE_IMG
  zh: '![图 11.8 – 多重导出](img/B17600_11_008.jpg)'
- en: Figure 11.8 – Multiple exports
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.8 – 多重导出
- en: 'As you can see, the `setMessage` cmdlet is available for us to use. What happens
    if we don’t want that? The name we’ve used doesn’t conform with cmdlet naming
    conventions and is generally one we’d use to signify a private function; something
    that we need to be available to the other functions within the module, but not
    something we want available for use outside those functions. We can control access
    using the `Export-ModuleMember` cmdlet. Add the following line to the bottom of
    `Write-Message.psm1`:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Then, import the module again with the `-Force` parameter. The results are
    shown in the following screenshot:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.9 – Controlling exported functions](img/B17600_11_009.jpg)'
  id: totrans-114
  prefs: []
  type: TYPE_IMG
- en: Figure 11.9 – Controlling exported functions
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, only the `Write-Message` function is exported, and when we try and run
    `setMessage`, this time, we get an error. We can also use `Export-ModuleMember`
    to export variables and aliases from the module, which aren’t exported by default,
    like this:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: If we don’t explicitly use `Export-ModuleMember`, all the functions in a module
    will be exported, but nothing other than functions.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
- en: 'In the introduction to this chapter, we mentioned one of the use cases for
    modules: building applications and solutions. To do this, we will often call a
    module from within another module – this is called nesting modules, and that’s
    what we’re going to look at next.'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
- en: Nested modules
  id: totrans-120
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In [*Chapter 9*](B17600_09.xhtml#_idTextAnchor184), *Don’t Repeat Yourself
    – Functions and Scriptblocks*, we looked at some functions for writing output
    to log files. It would be useful to write those functions in a module so that
    we could just call them when we needed them, rather than having to write them
    in every script we create. These are great examples of functions we would want
    to keep private, rather than export them for general use. Let’s do this. Copy
    the `Write-Log.ps1` script we wrote previously to a module file called `Write-Log.psm1`
    in a suitable location. We’ll need to edit the `.psm1` file to remove the following
    line:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'This is how my module file looks:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.10 – The Write-Log.psm1 module](img/B17600_11_010.jpg)'
  id: totrans-124
  prefs: []
  type: TYPE_IMG
- en: Figure 11.10 – The Write-Log.psm1 module
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
- en: As we can see, I’ve remarked line 11, rather than deleting it. We are left with
    two functions and a variable – that is, `Write-Log`, `Remove-Log`, and `$LogFile`.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
- en: 'We can now add a couple of lines to our `Write-Message.psm1` module so that
    we can call the `Write-Log` module and run one of the functions in it. Edit your
    `Write-Message` function, like this:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'I’ve added the first line to import the `Write-Log` module and the fifth line
    to call the `Write-Log` function from it. I’ve also removed the `Export-ModuleMember`
    line. Now, let’s see what happens when we import the `Write-Message` module:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.11 – Nested modules](img/B17600_11_011.jpg)'
  id: totrans-130
  prefs: []
  type: TYPE_IMG
- en: Figure 11.11 – Nested modules
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
- en: As we can see, the module is imported as before and works as we expect. We can
    see from the output of `Get-Module` that there are four exported functions – two
    from `Write-Message` and two from `Write-Log` – and we can see that the `Write-Log`
    module is nested. When we attempt to access it with `Get-Command`, however, we
    don’t see any loaded functions, and `Get-Module Write-Log` returns nothing. However,
    if we check the log file that was created, we’ll see a message stating `nested
    module test`, so it is working.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
- en: 'This is because nested modules are only visible to the calling module, so we
    can’t access `Write-Log` directly. However, because we removed the `Export-ModuleMember`
    line, all functions are exported, including the functions from nested modules;
    they appear as functions of the calling module. We’ll be able to see the `Write-Log`
    module if we use `Get-Module -All`, though, and we can find the real location
    of the `Write-Log` function as before – that is, by calling the `File` property:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.12 – Finding nested modules](img/B17600_11_012.jpg)'
  id: totrans-134
  prefs: []
  type: TYPE_IMG
- en: Figure 11.12 – Finding nested modules
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
- en: As we can see, the `Write-Log` function is defined in the `write-log.psm1` file.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
- en: 'Sometimes, we may not want nested modules to be hidden like this; if that’s
    the case, then we can use the `-Global` parameter of `Import-Module`, like this:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The `Write-Log` module will be imported at the same top level as the `Write-Message`
    module.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
- en: Now, let’s look at some other types of modules, including binary and manifest
    modules.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
- en: More modules
  id: totrans-141
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'You may have noticed that when we create a function in a module, we use it
    like a cmdlet, but it’s still called a function. It will behave as a cmdlet, with
    parameters, help, members, and so on, but it’s not a cmdlet. Consider the following:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.13 – Functions and cmdlets](img/B17600_11_013.jpg)'
  id: totrans-143
  prefs: []
  type: TYPE_IMG
- en: Figure 11.13 – Functions and cmdlets
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
- en: As we can see, `Write-Message` is of the `Function` type, whereas the Microsoft
    `Get-Service` command is of the `Cmdlet` type.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
- en: To write custom cmdlets, we need to write a binary module. Remember that PowerShell
    is based on .NET and is an interpreted language, written in a compiled language,
    usually C#, in the same way that Python is an interpreted language written in
    C.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
- en: We’re not going to cover writing modules in C# here, but we will discuss how
    they work and how they are used.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
- en: 'A binary module does not have a `.psm1` extension – it is a .NET assembly compiled
    from code such as C# and has a `.dll` extension. We can create it by writing our
    C# code within a `Here-String` declaration, a block of multi-line text inside
    the `@" "@` construct, and then use the `Add-Type -OutputAssembly` cmdlet to compile
    it:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Other than that, we can import it in the same way as a script module with `Import-Module`:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: If we were to run `Get-Module` on our fictional `MyBinaryModule`, we would see
    that `ModuleType` is `Binary` and that it has exported cmdlets, rather than exported
    functions.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
- en: The main difference between binary modules and script modules is that once they’re
    loaded into a session, they can’t be unloaded. If we need to make a change to
    a binary module we are writing, we will need to close PowerShell first.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
- en: We may also see PowerShell modules written in CDXML, an XML wrapper for Common
    Information Model commands. This used to be quite common for Windows administration
    modules, but it is largely deprecated now since modules written this way are slower
    to load and run than script modules due to the extra effort required to parse
    the XML into PowerShell, which then itself needs parsing. In the words of the
    official documentation, “*Avoid CDXML.*” Similarly, we may see references to PowerShell
    SnapIns. These are deprecated forms of Windows PowerShell that aren’t supported
    in PowerShell 7, so we don’t need to worry about them.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
- en: There’s one more type of module for us to consider – the manifest module. A
    manifest module is a script or binary module that includes a module manifest.
    That’s what we’re going to look at in the next section.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
- en: Module manifests
  id: totrans-156
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The script modules we’ve been playing with so far are monolithic single files,
    either standalone or nested. That’s fine for hobbyist use, but it’s not great
    in a production environment, where we might want to split our functions into separate
    files and include version information and a whole bunch of other metadata and
    resources, such as XML formatting files or binaries. To organize a more complex
    module, we need a document that explains how it is to be loaded and implemented;
    this document is called a module manifest, and it is a hash table saved with a
    `.psd1` extension. Let’s have a look at an example. if we browse to the PowerShellGet
    module in `C:\Program Files\PowerShell\7\Modules` (or `/opt/microsoft/PowerShell/7/Modules`
    in Linux), we will see the following files and folders:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.14 – The PowerShellGet module](img/B17600_11_014.jpg)'
  id: totrans-158
  prefs: []
  type: TYPE_IMG
- en: Figure 11.14 – The PowerShellGet module
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
- en: As we can see, there are four files and three folders. These folders contain
    several `.psm1` and `.psd1` files that define functions and manifests for nested
    modules. The main code for the module is in `PSModule.psm1`. `PSGet.Format.ps1xml`
    contains formatting information for displaying the output of functions. `PowerShellGet.psd1`
    is the module manifest. `PSGet.Resource.psd1` is a set of output strings for the
    module to use; we won’t worry about it here. If we open the `PSModule.psm1` file,
    we will see it is written in PowerShell, not C#, so it is a script module. It’s
    a big file, with a lot of functions defined in it. Let’s take a look at the `PowerShellGet.psd1`
    file.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
- en: The first thing to note is that it is given the same name as the folder it’s
    housed in. This is deliberate; if there is a manifest present in a module folder,
    it must have the same name as the folder; otherwise, the module won’t load. Giving
    the same name to the `.psm1` file, in the absence of a manifest, allows PowerShell
    to easily find it for autoloading, but otherwise, this doesn’t matter. It’s different
    for manifests.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s open it up and look inside:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.15 – The PowerShellGet manifest](img/B17600_11_015.jpg)'
  id: totrans-163
  prefs: []
  type: TYPE_IMG
- en: Figure 11.15 – The PowerShellGet manifest
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
- en: On line 1, we can see that this is a hash table from `@{`, and that everything
    after that takes the format of a key-value pair. As we can see, this is a long
    file with a lot of information in it; over 200 lines, although much of this is
    a big blob of text with the `ReleaseNotes` key.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
- en: A manifest consists of up to 37 different key-value pairs that may contain strings
    or arrays. We can add additional code to a manifest, including comparison and
    arithmetic operators, basic data types, and the `if` statement, but we’re not
    going to cover that here; I’ve never needed to do it. Let’s create a new manifest
    for ourselves and see what’s in it.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
- en: 'In a suitable directory, create a folder called `ManifestModule`. Now, open
    a PowerShell session and type the following cmdlet:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'At the prompt, supply the path and the name of the new manifest file, like
    this:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'That’s it – this creates a new manifest file for a module called `ManifestModule`.
    Let’s open it up in VS Code:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.16 – A basic module manifest](img/B17600_11_016.jpg)'
  id: totrans-172
  prefs: []
  type: TYPE_IMG
- en: Figure 11.16 – A basic module manifest
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
- en: The first thing to notice is that some of the values have been generated for
    you. `ModuleVersion` is `0.0.1`, there is an autogenerated `GUID` to ensure that
    this module can be differentiated from any other modules with the same name, and
    the `Author`, `CompanyName`, and `Copyright` keys are populated. Other than that,
    everything is empty and generally remarked out.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
- en: 'The keys in a manifest fall into three groups that cover the following aspects:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
- en: '**Production data**: Who wrote it, when, who for, and what sort of systems
    it will run on.'
  id: totrans-176
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`RootModule` defines the main module file that calls everything else – the
    main `.``psm1` file.'
  id: totrans-177
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Module content**: These are lists of all the modules, files, and other assets
    that are included in the module. These keys are optional, but generally, they
    should be populated accurately.'
  id: totrans-178
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We can populate the keys when we call the `New-ModuleManifest` cmdlet, by adding
    the key name as a parameter:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'The alternative is to edit the manifest file directly in a text editor or VS
    Code. If we edit it directly, there is always the possibility of mistyping something
    and breaking the file, so it’s a good idea to test our edited manifest, like this:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'We can see the results in the following figure:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.17 – Testing a module manifest file](img/B17600_11_017.jpg)'
  id: totrans-184
  prefs: []
  type: TYPE_IMG
- en: Figure 11.17 – Testing a module manifest file
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
- en: If the module’s information is returned, then the file has been formatted correctly.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
- en: As we’ve seen, module construction can get complicated pretty quickly. Let’s
    finish this chapter by taking a look at a tool that can make it very much easier
    – Plaster.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
- en: Using scaffolding tools such as Plaster
  id: totrans-188
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If we are working long-term on a module, or collaborating with other people,
    then it’s a really good idea to use a framework that splits everything up into
    separate files and assets. This is where a scaffolding tool comes in. My choice
    of tool is Plaster, a module that was originally produced by Microsoft but is
    now maintained by PowerShell.Org, one of the most prolific online PowerShell communities.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
- en: 'Plaster uses a template file that consists of a manifest (similar to the module
    manifest) and a set of content files and directories. The template is written
    in XML and is highly customizable. The manifest has three sections:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
- en: Metadata, which contains information about the template, such as its name, version,
    and author
  id: totrans-191
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Parameters, which defines choices that the user can make about their module
    structure – what files and folders to create and include
  id: totrans-192
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Content, which specifies the actions that Plaster will perform – copying files,
    modifying files, and checking that required modules are installed.
  id: totrans-193
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let’s start by installing the module from the PowerShell gallery. Type the
    following to download the module:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'We may need to acknowledge that the PowerShell gallery is an untrusted repository.
    Now, let’s import the module:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'And that’s it – we’re ready to go. Let’s see what we’ve got:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.18 – Examining the Plaster module](img/B17600_11_018.jpg)'
  id: totrans-199
  prefs: []
  type: TYPE_IMG
- en: Figure 11.18 – Examining the Plaster module
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
- en: 'As we can see, we’ve installed version 1.1.4 of the module, and we’ve got four
    new commands to play with:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
- en: '`Get-PlasterTemplate`: This lists the existing templates available for us to
    use. We can write or download templates as XML files. Only two are included, and
    the one we need is `NewPowerShellScriptModule`.'
  id: totrans-202
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Invoke-Plaster`: This runs the Plaster scaffolding tool.'
  id: totrans-203
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`New-PlasterManifest`: This command creates a new manifest.'
  id: totrans-204
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Test-PlasterManifest`: This command tests that the manifest is formatted correctly.'
  id: totrans-205
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let’s run it and see what we get:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Then, copy the path for `NewPowerShellScriptModule`. Now, type the following:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: You’ll be asked for the path to the default template and then a destination
    path; this needs to be a folder, not a file.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
- en: 'You’ll also be asked to provide the module’s name and version, as well as whether
    you want to set VS Code as the default editor. Here’s how it looked for me:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.19 – Invoking Plaster](img/B17600_11_019.jpg)'
  id: totrans-212
  prefs: []
  type: TYPE_IMG
- en: Figure 11.19 – Invoking Plaster
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
- en: As we can see, one of the required modules, Pester, is missing from my sandbox
    machine. Pester is a module that makes it a breeze to do unit testing and test-driven
    development, but it’s a bit beyond the scope of this book.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s see what has been created in the destination path:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.20 – A module created with the default Plaster template](img/B17600_11_020.jpg)'
  id: totrans-216
  prefs: []
  type: TYPE_IMG
- en: Figure 11.20 – A module created with the default Plaster template
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
- en: As we can see, Plaster has created two files – a script module file and a module
    manifest file – a folder for test scripts, and a folder for VS Code settings.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
- en: 'The `NewPlasterModule.psm1` file looks like this:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.21 – A basic module file generated by Plaster](img/B17600_11_021.jpg)'
  id: totrans-220
  prefs: []
  type: TYPE_IMG
- en: Figure 11.21 – A basic module file generated by Plaster
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
- en: As we can see, it’s very simple, but it includes a great trick – if the functions
    in the file are named with standard cmdlet naming conventions, such as `Verb-Noun`,
    then they will be exported. If they are not, like the `setMessage` function we
    wrote earlier in this chapter, then they will not be exported. Neat.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
- en: The beauty of Plaster is how extensible it is; it’s easy to write templates
    to create folder structures for public and private functions and classes, and
    it can all be done in a repeatable way. To get some idea of how versatile Plaster
    is, have a look at Kevin Marquette’s blog at [https://powershellexplained.com/2017-05-12-Powershell-Plaster-adventures-in/](https://powershellexplained.com/2017-05-12-Powershell-Plaster-adventures-in/)
    and his GitHub page at [https://github.com/KevinMarquette/PlasterTemplates](https://github.com/KevinMarquette/PlasterTemplates).
    Have a play with his example templates.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
- en: That is as much as we’re going to cover regarding Plaster – there are several
    other scaffolding modules available, so if you don’t like Plaster, take a look
    at some of the others. That also wraps up this chapter; let’s recap what we’ve
    done.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-225
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We started this chapter by reminding ourselves of what we learned in earlier
    chapters regarding modules and placing that into a more formal context. We looked
    at the standard module locations and how we can add locations by editing the `$ENV:PSModulePath`
    variable. We saw how PowerShell uses these locations to facilitate autoloading,
    and we saw how sometimes, we might not want that to happen. Then, we looked at
    how we can manually import modules and finished up our review by looking at the
    `PowerShellGet` module.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
- en: After, we started to write our own modules. We began by looking at the earliest
    method for importing code, known as dot-sourcing, and saw why that could be a
    bad idea. Then, we created our first module by writing a script and converting
    it. Next, we looked at how we can build applications by nesting modules, before
    discussing some other types of modules, such as binary modules.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
- en: Then, we looked at the most common complex module type – the manifest module.
    We saw how the manifest file controls what is loaded and exported, and how to
    write and test a manifest file. Finally, we looked at a tool that can make writing
    modules much simpler – Plaster.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we are going to look at the security aspects of PowerShell,
    and how we can best go about making ourselves and our colleagues and users safe
    with such a powerful tool.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
- en: Exercises
  id: totrans-230
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Here are the exercises for this chapter:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
- en: How can you list all imported modules in the current PowerShell session?
  id: totrans-232
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is the purpose of the `-Global` parameter when importing a module?
  id: totrans-233
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How do we import a module that isn’t in a path specified in the `$``ENV:PSModulePath`
    variable?
  id: totrans-234
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We want to import a module that contains functions that have the same name as
    cmdlets that already exist in our session. What are two ways we can get around
    this?
  id: totrans-235
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: By default, all the functions of a module are exported. What are two ways we
    can control what functions are exported?
  id: totrans-236
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is the purpose of the `HelpInfoURI` key in a module manifest?
  id: totrans-237
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What might be in a file with the`.ps1xml` extension?
  id: totrans-238
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If we load a module with the `.dll` extension, what sort of commands will we
    get?
  id: totrans-239
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Why don’t we write CDXML modules?
  id: totrans-240
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Further reading
  id: totrans-241
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To learn more about the topics that were covered in this chapter, take a look
    at the following resources:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
- en: '`PowerShellGet` and its replacement:'
  id: totrans-243
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://devblogs.microsoft.com/powershell/powershellget-in-powershell-7-4-updates/](https://devblogs.microsoft.com/powershell/powershellget-in-powershell-7-4-updates/)'
  id: totrans-244
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://learn.microsoft.com/en-us/powershell/module/microsoft.powershell.psresourceget/?view=powershellget-3.x](https://learn.microsoft.com/en-us/powershell/module/microsoft.powershell.psresourceget/?view=powershellget-3.x)'
  id: totrans-245
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://learn.microsoft.com/en-us/powershell/module/powershellget/?view=powershellget-2.x](https://learn.microsoft.com/en-us/powershell/module/powershellget/?view=powershellget-2.x)'
  id: totrans-246
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Writing module manifests: [https://learn.microsoft.com/en-us/powershell/scripting/developer/module/how-to-write-a-powershell-module-manifest](https://learn.microsoft.com/en-us/powershell/scripting/developer/module/how-to-write-a-powershell-module-manifest)'
  id: totrans-247
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Plaster: [https://powershellexplained.com/2017-05-12-Powershell-Plaster-adventures-in/#template-folder-and-file-structure](https://powershellexplained.com/2017-05-12-Powershell-Plaster-adventures-in/#template-folder-and-file-structure)'
  id: totrans-248
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
