- en: '16'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '16'
- en: Monitoring Application Logs
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 监控应用程序日志
- en: Welcome to the world of Linux logging! As software developers, understanding
    logging in Linux, especially with tools like `systemd` and `journald`, is crucial.
    Here’s a breakdown of what you need to know.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 欢迎进入 Linux 日志的世界！作为软件开发者，理解 Linux 中的日志，特别是使用像`systemd`和`journald`这样的工具，是至关重要的。下面是你需要了解的内容概览。
- en: '**Logs** are records of events happening in a software application or operating
    system. It’s a flexible format and unique to each application, but how logs are
    processed, stored, and retrieved is more uniform on modern systems. It’s essential
    for you to understand logs as a developer because the logs you can access in Linux
    provide insights into the behavior of the operating system and all applications
    running on it. You’ll use this knowledge to understand errors, track application
    performance, and debug. Logs are your first line of defense in troubleshooting,
    so prepare to get comfortable with them.'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: '**日志**是记录软件应用程序或操作系统中发生事件的记录。它是一种灵活的格式，并且每个应用程序的日志格式各不相同，但日志是如何处理、存储和检索的，在现代系统中相对统一。作为开发者，理解日志至关重要，因为你在
    Linux 中可以访问的日志能为你提供操作系统及其上运行的所有应用程序的行为洞察。你将利用这些知识来理解错误、跟踪应用程序性能以及进行调试。日志是故障排除的第一道防线，因此准备好与它们建立亲密关系。'
- en: 'In this chapter, we’ll give you an overview of Unix and Linux logging, and
    show you the most common ways that software developers interact with logs. You’ll
    see:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将为你概述 Unix 和 Linux 的日志系统，并展示软件开发者与日志互动的最常见方式。你将看到：
- en: How logs are emitted by the system and applications running on it
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 系统及其上运行的应用程序如何生成日志
- en: Where logs are collected on most modern Linux systems
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 大多数现代 Linux 系统上日志的收集位置
- en: Some historical knowledge about how logging worked in the past, which still
    comes in handy on many production systems you’ll run into
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 过去日志如何工作的历史知识，这些知识在你遇到许多生产系统时仍然非常有用
- en: How to find and view logs when you’re troubleshooting an application
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何在故障排除应用程序时查找和查看日志
- en: How logs are being centralized at companies and when services are deployed in
    cloud environments
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在公司以及云环境中部署服务时，日志如何被集中化管理
- en: We’ll also give a few tips on getting the most out of structured logging while
    avoiding some common pitfalls that developers often fall into.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将提供一些关于如何充分利用结构化日志的技巧，并避免开发者常犯的一些常见陷阱。
- en: Introduction to logging
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 日志简介
- en: 'As we saw in the introduction, **logs** are simply informational messages –
    records of events happening in a software application or operating system. Like
    many Unix concepts, there are few hard and fast rules: if you write a two-line
    script that writes a timestamp into a text file, that might count as a log. Some
    logs are simple plaintext strings sent to well-known file locations on the system,
    and others are highly structured binary data managed exclusively by a daemon such
    as `systemd`.'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在介绍中看到的，**日志**仅仅是信息性消息——记录软件应用程序或操作系统中发生的事件。像许多 Unix 概念一样，日志并没有硬性规定：如果你写了一个两行的脚本，往文本文件中写入时间戳，那也可能算作一条日志。有些日志是简单的纯文本字符串，发送到系统上的已知文件位置，其他则是由像`systemd`这样的守护进程专门管理的高度结构化的二进制数据。
- en: 'As a developer, you’re probably familiar with **log levels**, which are labels
    that indicate the urgency of events on your software. Think “error,” “info,” and
    “debug” messages, which you’ve surely seen scrolling past in the terminal while
    developing software. We’ll cover these common log levels later, but for now, you
    should be aware of three main *sources* of logs in a modern, full-featured Linux
    environment: **system**, **service**, and non-service **application** logs. The
    source of the log can give you important contextual information about what’s happening
    in a specific log message.'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 作为开发者，你可能对**日志级别**比较熟悉，它们是表示软件中事件紧急程度的标签。例如“错误”、“信息”和“调试”信息，你肯定在开发软件时看到过它们在终端滚动显示。我们稍后会介绍这些常见的日志级别，但目前，你需要了解在现代的、功能齐全的
    Linux 环境中，日志有三大主要的*来源*：**系统**、**服务**和非服务**应用程序**日志。日志的来源可以为你提供关于特定日志消息的关键信息。
- en: '**System logs** are logs sent by the operating system (“the kernel”) itself.
    These include errors, messages about hardware events, resource consumption and
    limits, configuration and security, and noteworthy changes in the system state.'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: '**系统日志**是操作系统（“内核”）本身发送的日志。这些日志包括错误、硬件事件消息、资源消耗与限制、配置与安全性，以及系统状态中的显著变化。'
- en: '**Service logs** are emitted by the services running on a system. Specifically
    on Linux, they are emitted by the services managed by the `systemd` init system,
    which do their logging through a service called `journald`. They can provide insights
    into the health and status of various services.'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: '**服务日志**是由系统上运行的服务产生的。具体来说，在 Linux 上，它们是由`systemd`初始化系统管理的服务产生的，这些服务通过名为`journald`的服务进行日志记录。它们可以提供有关各种服务的健康状况和状态的洞察。'
- en: On the systems you’re likely to encounter, system and service logs are both
    commingled in `journald`. We’ll learn all about `systemd` and `journald` (and
    `journalctl`) as we progress through this chapter.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 在你可能遇到的系统上，系统日志和服务日志通常会一起混合在`journald`中。随着我们深入本章，你将学习到关于`systemd`、`journald`（和`journalctl`）的所有内容。
- en: '**Non-systemd-managed applications** are the outliers that don’t generally
    log through `journald`. You’ll have to find their log files via documentation
    for each application, although well-behaved applications usually write their own
    log files in a directory like `/var/log/$APPLICATION_NAME/`, where `$APPLICATION_NAME`
    is the name of the application.'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: '**非 systemd 管理的应用程序**是那些通常不通过`journald`进行日志记录的特例。你需要通过每个应用程序的文档来查找它们的日志文件，尽管行为规范的应用程序通常会在像`/var/log/$APPLICATION_NAME/`这样的目录中写入自己的日志文件，其中`$APPLICATION_NAME`是应用程序的名称。'
- en: As we go through this chapter, the importance of understanding journald and
    journalctl commands will become apparent. However, before we go into that, we
    should note a few details about Linux logging.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，当我们深入学习时，你会发现理解`journald`和`journalctl`命令的重要性。然而，在进入这些内容之前，我们应该先说明一些关于 Linux
    日志记录的细节。
- en: Logging on Linux can get... weird
  id: totrans-19
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在 Linux 上的日志记录可能会变得...怪异
- en: You’ve seen by now that Unix-like systems are tremendously flexible. If you
    don’t like the default way that things are done, you can break with convention
    and configure things to work the way you want.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 你现在应该已经看到，类 Unix 系统是极其灵活的。如果你不喜欢默认的做法，你可以打破常规，按自己的方式进行配置。
- en: This is also a tremendous downside when you’re learning the basics of Unix and
    Linux. Many things – from software configuration to default user settings – can
    be configured in many different ways, and there’s no way to know what the convention
    is in a new environment except to ask (and sometimes, troubleshoot).
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 这也是在学习 Unix 和 Linux 基础时的一个巨大缺点。许多事情——从软件配置到默认用户设置——可以通过多种方式进行配置，而且在新环境中没有办法知道常规做法是什么，除非问（有时还需要排除故障）。
- en: Nowhere is that truer than when it comes to logging, which has been especially
    affected by the recent shifts in how companies do their computing. Logging was
    done a certain way for decades, when most companies directly purchased, configured,
    and managed long-lived physical servers with a single OS installed on them. As
    workloads have shifted to the cloud, and things have shifted to many operating
    systems per physical machine (VMs) and even many environments per OS (containers),
    traditional ideas of how logging should work have shifted as well.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 这种怪异现象在日志记录中尤为明显，尤其是随着最近公司计算方式的变化而产生的影响。日志记录在过去几十年里是按一种方式进行的，当时大多数公司直接购买、配置和管理长期使用的物理服务器，每台服务器上安装着单一的操作系统。随着工作负载转向云计算，以及每台物理机器上运行多个操作系统（虚拟机）甚至每个操作系统上运行多个环境（容器），传统的日志记录方式也发生了变化。
- en: That’s all to say that when it comes to figuring out logging in a new job or
    team, the question is not, “How is logging done on Linux?” but rather, “How is
    logging currently done here?” It really depends on decisions made by the developers
    of the software you’re using. When learning about logging in this chapter, we
    advise that you keep this in mind.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 这也就是说，当你在新工作或团队中了解日志记录时，问题不是“Linux 上是如何进行日志记录的？”，而是“这里目前是如何进行日志记录的？”这实际上取决于你使用的软件开发人员所做的决定。在学习本章关于日志记录的内容时，我们建议你记住这一点。
- en: Sending log messages
  id: totrans-24
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 发送日志消息
- en: 'While, in most situations, services will log either through a library or by
    simply writing to `stdout`, Unix-like systems provide a command that logs to a
    syslog server. We’ll look at what that means below. Since both `syslogd` and `systemd`
    provide a syslog server no matter what kind of system you are using, there is
    a unified command to send a log message:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然在大多数情况下，服务会通过库或仅仅写入`stdout`来进行日志记录，类 Unix 系统提供了一条命令来将日志发送到 syslog 服务器。我们将在下面讨论这意味着什么。由于`syslogd`和`systemd`提供了一个
    syslog 服务器，无论你使用什么类型的系统，因此有一个统一的命令来发送日志消息：
- en: '[PRE0]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: This will log `Hello World`. The logger command has many options, and it can
    be a valuable tool when debugging any issues, when wanting to log in a shell script,
    or when explaining how logging works.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 这将记录 `Hello World`。`logger` 命令有很多选项，它在调试问题时、希望在 shell 脚本中记录日志时，或解释日志如何工作的过程中都非常有用。
- en: The systemd journal
  id: totrans-28
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: systemd 日志
- en: When a system uses `systemd`, `journald` takes over the logging side. When you’re
    troubleshooting a Linux machine running `systemd`, this is the first place you
    should be looking for logs. By default, journald captures all output from supervised
    processes. Anything emitted on `stderr` is treated as an error. So, unless the
    software is configured or hardcoded to log to a location that’s not `stderr/stdout`,
    you will find the logs in the `systemd` journal.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 当系统使用 `systemd` 时，`journald` 会负责日志记录工作。当你在排查一个运行 `systemd` 的 Linux 机器时，这是你应该首先查看的日志位置。默认情况下，journald
    会捕获所有受控进程的输出。任何在 `stderr` 上发出的内容都会被视为错误。因此，除非软件被配置或硬编码为记录到不在 `stderr/stdout` 位置的地方，否则你将会在
    `systemd` 日志中找到这些日志。
- en: Logs logged to `journald` can be queried via the `journalctl` command. It provides
    a means to query based on individual services, time, and system restarts and allows
    one to use options similar to the `tail` command. Let’s jump in and get some practice
    using `journalctl`.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 记录到 `journald` 的日志可以通过 `journalctl` 命令进行查询。它提供了基于单个服务、时间和系统重启进行查询的方法，并允许使用类似
    `tail` 命令的选项。让我们开始使用 `journalctl` 进行一些实践。
- en: Example journalctl commands
  id: totrans-31
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 示例 journalctl 命令
- en: The basics of working with `journalctl` are simple. Think about it; when you’re
    troubleshooting an application, what do you need to be able to do with its logs?
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `journalctl` 的基本操作非常简单。想想看，当你在排查应用程序问题时，你需要做什么来查看日志？
- en: First, you’ll want to be able to find and view the current set of logs. `journalctl`
    will give you that, but you’ll quickly realize you didn’t actually want *all*
    the logs, just the most recent ones. So, let’s filter with the `-n` flag.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，你需要能够找到并查看当前的日志。`journalctl` 可以为你提供这个功能，但你会很快意识到，你实际上并不需要 *所有* 的日志，只是需要查看最近的日志。所以，让我们使用
    `-n` 选项进行过滤。
- en: 'To get a look at the last 100 log messages in `journald`, try this command:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看 `journald` 中最后 100 条日志消息，可以尝试以下命令：
- en: '[PRE1]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: This will print out the last 100 lines logged to the system. You will notice
    that this is similar to the `tail` command explained earlier in this book. If
    you followed along, these lines will likely contain the “Hello World!” message
    from above.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 这将打印出系统记录的最后 100 行日志。你会注意到，这与本书前面解释的 `tail` 命令类似。如果你跟着做，这些日志很可能包含上面的“Hello World!”消息。
- en: Following active logs for a unit
  id: totrans-37
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 跟踪单元的实时日志
- en: 'You might also want to see logs in real time. For example, following your application
    logs during startup can help you see exactly when things go wrong:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能还想实时查看日志。例如，在启动过程中跟踪你的应用程序日志可以帮助你准确地看到问题发生的时间：
- en: '[PRE2]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The `-f` flag stands for “follow,” and the `-u` flag stands for “unit” – the
    system unit (or “service”) that you want to filter logs for.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: '`-f` 选项表示“跟踪”，而 `-u` 选项表示“单元”——即你想要过滤日志的系统单元（或“服务”）。'
- en: Filtering by time
  id: totrans-41
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 按时间过滤
- en: 'Even when you filter down to a specific unit that you’re interested in, you
    may still be overwhelmed by the number of logs that match. Filtering by time can
    be useful here, especially when you are trying to correlate a known external problem
    (outage, error, and so on) to the application logs from that moment in time forward.
    Use `--since and --until` for this:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 即使你过滤到一个特定的单元，你仍然可能会被匹配的日志数量所淹没。按时间过滤在这里特别有用，尤其是在你尝试将已知的外部问题（如停机、错误等）与从那一刻起的应用程序日志关联时。可以使用
    `--since` 和 `--until` 来实现：
- en: '[PRE3]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'You can also use some shorthand for this, like `today`:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以使用一些简写方式，如 `today`：
- en: '[PRE4]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'You can also use `–until` to set an end time for your filter and mix these
    up to get pretty specific. For example:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以使用 `--until` 设置过滤器的结束时间，并将这些选项组合起来，达到非常具体的过滤效果。例如：
- en: '[PRE5]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '**Note**'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: One caveat to viewing and filtering logs by time is that you’ll almost always
    want to use the `--utc` option for `journalctl`, which displays timestamps in
    UTC. When you’re helping an ops team troubleshoot an outage, this is almost exclusively
    done using UTC times to prevent timezone-related confusion.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 使用时间过滤和查看日志时的一个注意事项是，你几乎总是需要使用 `--utc` 选项，它会以 UTC 时间显示时间戳。当你帮助运维团队排查停机故障时，几乎总是使用
    UTC 时间，这样可以避免时区相关的混淆。
- en: There are additional filters for things like user/group ID.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一些其他过滤器，如按用户/组 ID 过滤。
- en: Filtering for a specific log level
  id: totrans-51
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 按特定日志级别过滤
- en: 'If you know you’re looking for an error, you can tell `journalctl` to show
    you only errors (or any of the other log levels listed at [https://wiki.archlinux.org/title/Systemd/Journal#Priority_level](https://wiki.archlinux.org/title/Systemd/Journal#Priority_level)
    in descending order of criticality: `emerg`, `alert`, `crit`, `err`, `warning`,
    `notice`, `info`, `debug`):'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你知道自己要查找的是错误信息，可以告诉 `journalctl` 只显示错误日志（或列出的其他日志级别，按照优先级递减的顺序：[https://wiki.archlinux.org/title/Systemd/Journal#Priority_level](https://wiki.archlinux.org/title/Systemd/Journal#Priority_level)：`emerg`、`alert`、`crit`、`err`、`warning`、`notice`、`info`、`debug`）：
- en: '[PRE6]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Inspecting logs from a previous boot
  id: totrans-54
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 检查之前启动的日志
- en: 'Sometimes things get really wild, and a fault actually causes a reboot. In
    those cases, you’ll want to see logs from a previous boot of the system. You can
    view all available boots with `--list-boots`, like so:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 有时候，情况会变得非常混乱，故障甚至会导致系统重启。在这种情况下，你可能需要查看之前启动时的日志。你可以使用 `--list-boots` 查看所有可用的启动记录，如下所示：
- en: '[PRE7]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Then select a specific boot from the list with the `-b` argument. In this case,
    we want the one labeled `2`:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 然后使用 `-b` 参数从列表中选择一个特定的启动记录。在这种情况下，我们要选择标签为 `2` 的那一项：
- en: '[PRE8]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: By itself, the `–b` flag means “the current system boot.”
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 单独使用 `–b` 标志表示“当前系统启动”。
- en: Kernel messages
  id: totrans-60
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 内核消息
- en: In the introduction, we mentioned that system-level log messages are sent by
    the operating system (“the kernel,” in Linux jargon). To see just those messages,
    use the `--k` (or `--dmesg`, for historical reasons) flag.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 在引言中，我们提到过，系统级日志消息是由操作系统（在 Linux 术语中是“内核”）发送的。要查看仅由系统发送的这些消息，请使用 `--k`（或者出于历史原因，使用
    `--dmesg`）标志。
- en: Logging in Docker containers
  id: totrans-62
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在 Docker 容器中记录日志
- en: In a Docker container, the most common way to treat logs is to simply assume
    that the container’s main process is the one we want output from and that it’s
    logging to the standard output (`stdout`). Container orchestrators (that is, tools
    like Kubernetes and Nomad), as well as various cloud services that are responsible
    for executing containers, will assume `stdout` to be where relevant logs will
    go and, depending on the configuration, will forward it accordingly. We will go
    a bit more into this in the *Centralized logging* section below.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Docker 容器中，处理日志的最常见方式是简单地假设容器的主进程就是我们需要输出的目标，而且它将日志写入标准输出（`stdout`）。容器编排工具（比如
    Kubernetes 和 Nomad）以及负责执行容器的各种云服务，都会假设 `stdout` 是日志输出的目标，并根据配置进行转发。我们将在下面的 *集中式日志记录*
    部分进一步讨论这一点。
- en: Syslog basics
  id: totrans-64
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Syslog 基础
- en: Compared to the `systemd`/`journald` logging we’ve shown you, syslog may seem
    a bit archaic. We prefer to think of it as having a *storied history* – although
    it’s been around since the 1980s, it’s still a useful, flexible, and widely-used
    logging tool. More importantly, you’re almost guaranteed to come across it on
    real production systems, so it’s worth knowing the basics to avoid being caught
    off guard during an outage where time is critical.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 相比我们之前展示的 `systemd`/`journald` 日志，syslog 看起来可能有些过时。我们更愿意认为它有着 *悠久的历史*——虽然自1980年代以来它就已经存在，但它依然是一个有用、灵活且广泛使用的日志工具。更重要的是，你几乎可以肯定会在实际生产系统中遇到它，因此了解其基础知识是值得的，以免在停机事件中被突如其来的情况搞得措手不及，而时间又至关重要。
- en: On a Unix-like system, logging to syslog is often equivalent to logging to a
    file in `/var/log`, with the majority of messages typically going to `/var/log/messages`.
    Keep in mind, however, that not everything you find in `/var/log` necessarily
    went through syslog. Various pieces of software also implement their own way of
    writing log files, skipping the syslog daemon entirely.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 在类 Unix 系统中，记录日志到 syslog 通常等同于记录到 `/var/log` 中的一个文件，其中大部分消息通常会写入 `/var/log/messages`。但请记住，并非你在
    `/var/log` 中找到的所有内容都一定经过了 syslog。许多软件也实现了自己记录日志文件的方式，完全跳过了 syslog 守护进程。
- en: This works by syslog ingesting all the logs sent to it and depending on various
    parameters, like the facilities mentioned below, outputting them into a file.
    On virtually all systems, the default for this is `/var/log/messages`. If you
    followed along and your system uses syslog, then this is also where you’ll find
    the `Hello World!` message from above.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 其原理是，syslog 会接收所有发送给它的日志，并根据以下提到的各种参数，将其输出到一个文件中。在几乎所有系统中，默认的输出路径是 `/var/log/messages`。如果你跟着操作并且你的系统使用了
    syslog，那么这里也会找到之前提到的 `Hello World!` 消息。
- en: Syslog is a standardized protocol for logging. While, at the time of this writing,
    `syslogd` mostly deals with log lines, the current standard [`RFC 5424`] also
    allows for structured logging. However, since this isn’t widely supported, we
    will just briefly go over its basic concepts as a protocol for line/message-based
    logging. If you don’t interact with syslog at all, feel free to skip this section.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: Syslog 是一种标准化的日志协议。尽管在撰写本文时，`syslogd` 主要处理日志行，但当前标准 [`RFC 5424`] 也允许进行结构化日志记录。然而，由于这尚未得到广泛支持，我们将简要介绍它作为行/消息日志协议的基本概念。如果你完全不与
    syslog 交互，可以跳过本节。
- en: As mentioned earlier, syslog is a protocol. While it’s most frequently used
    for software, such as databases that want to log locally, production setups usually
    have a centralized logging server that logs are shipped to. Being only a protocol,
    various software (such as PostgreSQL, nginx, and so on) can emit logs using this
    protocol, and various logging-related software, like `Logstash`, `Loki`, `syslogd`,
    `syslog-ng`, and others can ingest its logs. It usually uses either port 514 (UDP)
    or port 6514 (TCP).
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，syslog 是一种协议。虽然它最常用于软件，例如希望本地记录日志的数据库，但在生产环境中，通常会有一个集中式日志服务器，日志会发送到该服务器。作为一个协议，各种软件（如
    PostgreSQL、nginx 等）可以使用该协议生成日志，此外，诸如 `Logstash`、`Loki`、`syslogd`、`syslog-ng` 等日志相关软件可以接收其日志。它通常使用端口
    514（UDP）或端口 6514（TCP）。
- en: Facilities
  id: totrans-70
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 设施
- en: 'Since syslog is a very old protocol from the 1980s, some of its concepts might
    look archaic. It uses pre-defined *facilities* to specify the type of log message.
    Each facility has its own code:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 syslog 是一种非常古老的协议，起源于 1980 年代，所以它的一些概念可能显得有些过时。它使用预定义的 *设施* 来指定日志消息的类型。每个设施都有自己的代码：
- en: '0: `kern` – Kernel messages.'
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '0: `kern` – 内核消息。'
- en: '1: `user` – User-level messages. These are often used by processes.'
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '1: `user` – 用户级消息。这些消息通常由进程使用。'
- en: '2: `mail` – Mail system. Mostly useful for mail servers, SMTP, IMAP, and POP3\.
    Spam-related daemons and software usually log here.'
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '2: `mail` – 邮件系统。主要用于邮件服务器，如 SMTP、IMAP 和 POP3。与垃圾邮件相关的守护进程和软件通常会在此记录日志。'
- en: '3: `daemon` – System daemons. Daemons, especially ones related to the OS (such
    as for NTP), log here.'
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '3: `daemon` – 系统守护进程。守护进程，特别是与操作系统相关的守护进程（如 NTP），会在此记录日志。'
- en: '4: `auth` – Security/authentication messages. You will typically find login
    attempts, for example, locally, via SSH, but also for various other services here.'
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '4: `auth` – 安全/认证消息。你通常会在此找到本地的登录尝试，例如通过 SSH，也可以找到各种其他服务的相关日志。'
- en: '5: `syslog` – Messages generated internally by `syslogd`. These will be messages
    related to syslog itself.'
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '5: `syslog` – `syslogd` 内部生成的消息。这些将是与 syslog 本身相关的消息。'
- en: '6: `lpr` – Line printer subsystem. Printer-related logs.'
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '6: `lpr` – 行打印机子系统。与打印机相关的日志。'
- en: '7: `news` – Network news subsystem. This is historical, and not typically used
    anymore.'
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '7: `news` – 网络新闻子系统。这是历史遗留的，现今通常不再使用。'
- en: '8: `uucp` – UUCP subsystem. This is historical, and not typically used anymore.'
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '8: `uucp` – UUCP 子系统。这是历史遗留的，现今通常不再使用。'
- en: '9: `cron` – Cron subsystem. Logs related to cron jobs. These can be very useful
    for debugging cron jobs.'
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '9: `cron` – Cron 子系统。与 cron 作业相关的日志。这些日志对调试 cron 作业非常有用。'
- en: '10: `authpriv` – Security/authentication messages. This is similar to `auth`
    but is usually considered to be logged to a more restricted set of destinations.
    Most Linux software logs here instead of auth.'
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '10: `authpriv` – 安全/认证消息。这类似于 `auth`，但通常被认为是记录到更受限的目的地。大多数 Linux 软件会在此而非 auth
    中记录日志。'
- en: '11: `ftp` – FTP daemon. Mostly historical. Logs for FTP servers.'
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '11: `ftp` – FTP 守护进程。主要是历史遗留的日志，记录 FTP 服务器的相关信息。'
- en: '12: `ntp` – NTP subsystem. Logs for the **Network Time Protocol** (**NTP**),
    so clock synchronization.'
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '12: `ntp` – NTP 子系统。**网络时间协议** (**NTP**) 的日志，用于时钟同步。'
- en: '13: `security` – Log audit. Security-related events.'
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '13: `security` – 日志审计。与安全相关的事件。'
- en: '14: `console` – Log alert. Messages related to the “local console.”'
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '14: `console` – 日志警报。与“本地控制台”相关的消息。'
- en: '15: `solaris-cron` – Clock daemon.'
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '15: `solaris-cron` – 时钟守护进程。'
- en: '16 to 23: `local0` to `local7` – Locally used facilities, meaning local software.
    PostgreSQL, for example, logs to `local0` per default when logging to syslog.'
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '16 到 23: `local0` 到 `local7` – 本地使用的设施，意味着本地软件。例如，PostgreSQL 在默认情况下会将日志记录到
    `local0`。'
- en: On many systems, you’ll find files in `/var/log/` that are named similarly to
    these facilities. So, for example, if you need to debug a cron job on a system
    not using journald, you’ll likely find the output in `/var/log/cron`, `/var/cron/log`,
    `/var/log/messages`, or similar.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 在许多系统中，你会在 `/var/log/` 目录下找到与这些设施类似命名的文件。例如，如果你需要调试一个不使用 journald 的系统中的 cron
    任务，你可能会在 `/var/log/cron`、`/var/cron/log`、`/var/log/messages` 或类似文件中找到输出。
- en: Keep in mind that what exactly is logged in each facility is not standardized.
    You will likely come across situations where different operating systems or similar
    software might not agree on which facility to log to.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，每个设施中具体记录的内容并没有标准化。你很可能会遇到不同操作系统或类似软件在选择记录到哪个设施时没有达成一致的情况。
- en: Severity levels
  id: totrans-91
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 严重性级别
- en: 'This is a concept you are probably more familiar with. Messages come with a
    severity of one of seven different levels:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 这是你可能更熟悉的概念。消息会附带七个不同级别中的一个严重性：
- en: '0: `emerg` – Emergency'
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '0: `emerg` – 紧急'
- en: '0: `alert` – Alert'
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '0: `alert` – 警报'
- en: '0: `crit` – Critical'
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '0: `crit` – 严重'
- en: '0: `err` – Error'
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '0: `err` – 错误'
- en: '0: `warning` – Warning'
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '0: `warning` – 警告'
- en: '0: `notice` – Notice'
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '0: `notice` – 通知'
- en: '0: `info` – Informational'
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '0: `info` – 信息'
- en: '0: `debug` – Debug'
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '0: `debug` – 调试'
- en: As with facilities, what exactly constitutes each severity level depends on
    the software used.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 和设施一样，具体什么构成每个严重性级别取决于使用的软件。
- en: Configuration and implementations
  id: totrans-102
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 配置和实现
- en: Syslog has many implementations. These typically allow you to configure filtering,
    and save and forward messages based on facilities and severity levels. Some systems
    come with a service called `syslogd`, `rsyslog`, or `syslog-ng`, which can be
    configured in `/etc/syslog.conf`, `/etc/syslog-ng/`. Loki, Logstash, and other
    distributed log management tools have their own respective ways of configuring
    logging, usually in a three-fold structure, with one place to define input, another
    to filter and transform, and a third to store or forward the output.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: Syslog 有多种实现方式。这些通常允许你配置过滤、保存和转发基于设施和严重性级别的消息。有些系统提供名为 `syslogd`、`rsyslog` 或
    `syslog-ng` 的服务，可以在 `/etc/syslog.conf`、`/etc/syslog-ng/` 中进行配置。Loki、Logstash 以及其他分布式日志管理工具也有各自的日志配置方式，通常采用三重结构：一个地方定义输入，另一个地方进行过滤和转换，第三个地方存储或转发输出。
- en: Tips for logging
  id: totrans-104
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 日志记录技巧
- en: Everyone does logging a bit differently and what is considered best practice
    can vary across projects and time. However, there are some things you should be
    aware of.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 每个人的日志记录方式略有不同，什么是最佳实践也会因项目和时间而异。然而，有一些事情是你应该了解的。
- en: Keywords when using structured logging
  id: totrans-106
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用结构化日志时的关键词
- en: When using any kind of structured logging, try to make sure to share common
    keywords, such as request and user IDs, while also trying to avoid conflicting
    keywords used for similar, but not exactly the same, things. Depending on the
    backing database, you might also run into issues with types here, for example,
    in a situation where `user` might be the key for an integer, a string, or its
    own nested structure, like a JSON object.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用任何类型的结构化日志时，尽量确保共享常见的关键词，比如请求和用户 ID，同时避免使用相似但不完全相同的关键词。根据后端数据库的不同，你可能还会遇到类型相关的问题，比如在
    `user` 可能是整数、字符串或嵌套结构（如 JSON 对象）的情况下。
- en: Sometimes it’s possible to avoid any overlaps by creating per-service namespaces
    and keeping a list of “globally used” keys, along with definitions for them.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 有时通过创建每个服务的命名空间并保持“全局使用”键的列表及其定义，可以避免任何重叠。
- en: Severity
  id: totrans-109
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 严重性
- en: When developing software, it makes sense to have some internal document explaining
    which severity has which meaning. This avoids situations where failed login attempts
    to a publicly reachable service, or 404 error codes from crawlers requesting obsolete
    websites, raise an alarm and wake a colleague in the middle of the night. But
    even if that’s not the case, it can make debugging and being aware of problems
    a lot easier.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 在开发软件时，有一份内部文档来解释每个严重性对应的含义是很有意义的。这可以避免因为公开可访问的服务的登录失败尝试，或者爬虫请求过时网站时返回的 404
    错误代码，触发警报并在半夜叫醒同事的情况。但即使不是这种情况，它也能让调试和识别问题变得更加容易。
- en: 'For this reason, it’s a good idea to clearly distinguish between the following:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，最好能清楚区分以下几点：
- en: Situations that *might* indicate a problem
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可能*表明*存在问题的情况
- en: Situations that should not happen, but *can* happen
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不应该发生的情况，但*可能*发生
- en: Situations that clearly indicate a bug or more severe problem
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 清楚表明存在缺陷或更严重问题的情况
- en: Logs have the tendency to become more complex as software grows and services
    get added, so it’s a good investment to be clear about what to log and when from
    the very beginning.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 随着软件的增长和服务的增加，日志往往会变得更加复杂，因此，从一开始就明确记录什么以及何时记录日志是一个很好的投资。
- en: Centralized logging
  id: totrans-116
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 集中式日志
- en: In a corporate setting, it is typical to centralize logs. This makes it easier
    to connect the dots when debugging issues. It also means that in a distributed
    application, not every log on each physical or virtual machine or container has
    to be looked at individually. These centralized logging services typically make
    it easy and fast to query large amounts of logs, especially when the company uses
    structured logging and services adhere to a uniform log structure.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 在企业环境中，通常会将日志集中管理。这样，在调试问题时，连接各个线索会更加容易。这也意味着，在分布式应用程序中，不必单独查看每台物理或虚拟机、容器上的每个日志。这些集中式日志服务通常使查询大量日志变得简单和快速，特别是在公司使用结构化日志并且服务遵循统一日志结构时。
- en: These logging services are either their own products, such as rsyslog, Loki,
    the ELK stack (Elastic Search, Logstash, and Kibana), and Graylog, or they are
    managed services. These can, for example, be the hosted variants of the services
    we just mentioned or cloud-specific logging solutions, such as Google’s operations
    suite (formerly known as Stackdriver), AWS CloudWatch, or Azure Monitor. There
    are many similarities between these systems in that they provide mechanisms to
    “ship” logs from files or via some kind of API, filter and restructure them, and
    eventually, save them into final storage, ready to be queried.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 这些日志服务可以是它们自己的产品，例如 rsyslog、Loki、ELK 堆栈（Elastic Search、Logstash 和 Kibana）以及
    Graylog，或者它们是托管服务。例如，它们可以是我们刚才提到的服务的托管变体，或者是云特定的日志解决方案，如 Google 的操作套件（前称 Stackdriver）、AWS
    CloudWatch 或 Azure Monitor。这些系统之间有许多相似之处，它们提供机制以“传送”日志（通过文件或某种 API），过滤和重构日志，最终将其保存到最终存储中，准备好进行查询。
- en: In microservice architectures, it’s common to pass along context, such as a
    request ID, so a request from a client can easily be traced through the various
    services, which is essential for debugging architectures that involve many services.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 在微服务架构中，通常会传递上下文信息，例如请求 ID，以便客户端的请求能够轻松地在各个服务之间追踪，这是调试涉及多个服务的架构时至关重要的。
- en: As mentioned, most of these systems have mechanisms to ship logs to the central
    log server or cluster. They go by names like Logstash (the L in ELK stack) and
    Promtail (used with Loki) and typically provide multiple ways of ingesting logs.
    For example, they might be configured to create an HTTP server, act as a syslog
    server, tap into journald, read from any other log shipping services, use cloud
    APIs, or simply tail files. They are run either as additional daemons on systems,
    as a Pod in Kubernetes, or as part of a Nomad setup. Since they are meant to allow
    centralizing logs no matter what software is in use, they tend to allow for a
    variety of log inputs and are typically very flexible on the setup side – for
    example, allowing one to create a hierarchy by forwarding between individual log-shipping
    services. On container orchestrators like Kubernetes and Nomad, this is often
    implemented with a “sidecar container” that runs next to your application containers
    and captures logs from all containers in that Pod/allocation/node before shipping
    them to their destination.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，这些系统中的大多数都有机制将日志传送到中央日志服务器或集群。它们通常使用如 Logstash（ELK 堆栈中的 L）和 Promtail（与
    Loki 配合使用）等名称，通常提供多种日志摄取方式。例如，它们可以配置为创建一个 HTTP 服务器，作为 syslog 服务器，接入 journald，从任何其他日志传输服务读取，使用云
    API，或只是跟踪文件。它们通常作为系统上的附加守护进程、Kubernetes 中的 Pod 或 Nomad 设置的一部分运行。由于它们旨在允许无论使用什么软件都能集中日志，因此它们通常允许各种日志输入，并且在设置方面通常非常灵活——例如，允许通过在各个日志传输服务之间转发来创建层次结构。在像
    Kubernetes 和 Nomad 这样的容器编排工具上，这通常通过“侧车容器”来实现，侧车容器与应用容器一起运行，捕获来自该 Pod/分配/节点中所有容器的日志，然后将其传送到目的地。
- en: '![](img/B19251_16_01.png)'
  id: totrans-121
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B19251_16_01.png)'
- en: 'Figure 16.1: Container orchestration with a sidecar container'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 图 16.1：带侧车容器的容器编排
- en: As you can see, while there are many technologies and products surrounding logging,
    they all fall into at least one of the categories described above, so when you
    centralize logging in your environment, this should give you an idea of how the
    parts relate to each other.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您所看到的，虽然周围有许多技术和产品涉及日志，但它们都至少属于上述某一类别，因此，当您在环境中集中管理日志时，这应该能帮助您了解各个部分如何彼此关联。
- en: Conclusion
  id: totrans-124
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 结论
- en: Logging can be a moving target in modern production environments. Learning and
    experimenting with the basics covered in this chapter should give you a good foundation.
    It is our hope that getting comfortable with syslog and journalctl will also equip
    you with a low-level understanding and historical perspective that will make it
    easier for you to work out how tomorrow’s logging-as-a-service solution actually
    works under the covers.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 日志记录在现代生产环境中可能是一个不断变化的目标。本章所涵盖的基础内容，学习和实验后应能为你提供一个良好的基础。我们希望，通过熟悉syslog和journalctl，你能够掌握低级的理解和历史视角，这将使你更容易理解明天的日志即服务解决方案是如何在幕后工作的。
- en: We think you’ll find that the skills you learned in this chapter give you a
    practical, measurable advantage when it comes to designing, debugging, and optimizing
    the applications you create and deploy. Mastering the basics of journald, as you
    just saw, lets you swiftly diagnose and pinpoint issues, whether they are related
    to your application specifically or to the larger Linux system around it. Having
    some understanding of alternative and historical Linux logging approaches will
    help when you’re troubleshooting systems (or people) that haven’t been updated
    in a long time.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 我们认为，你会发现本章所学的技能，在设计、调试和优化你创建和部署的应用时，能给你带来实际且可衡量的优势。正如你刚刚看到的，掌握journald的基础知识可以让你迅速诊断和定位问题，无论问题是与应用本身相关，还是与周围更大的Linux系统有关。了解一些替代的和历史上的Linux日志记录方法，也有助于你在排除故障时处理那些很久没有更新的系统（或人）。
- en: It’s not just about solving issues; it’s also about making your life easier
    and your work better. Plus, it’s a skill that makes you stand out. In short, knowing
    your way around Linux logs makes you a smarter, more effective developer.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 这不仅仅是解决问题；它还关乎让你的生活更轻松，工作更高效。此外，它是一项让你脱颖而出的技能。简而言之，了解Linux日志的运作方式会让你成为一个更聪明、更高效的开发者。
- en: Learn more on Discord
  id: totrans-128
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在Discord上了解更多
- en: 'To join the Discord community for this book – where you can share feedback,
    ask questions to the author, and learn about new releases – follow the QR code
    below:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 加入本书的Discord社区——在这里你可以分享反馈、向作者提问并了解新版本——请扫描下面的二维码：
- en: '[https://packt.link/SecNet](https://packt.link/SecNet)'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://packt.link/SecNet](https://packt.link/SecNet)'
- en: '![](img/QR_Code1768422420210094187.png)'
  id: totrans-131
  prefs: []
  type: TYPE_IMG
  zh: '![](img/QR_Code1768422420210094187.png)'
