<html><head></head><body>
		<div id="_idContainer009">
			<h1 id="_idParaDest-16"><em class="italic"><a id="_idTextAnchor015"/>Chapter 1</em>: Understanding the Need for systemd</h1>
			<p>In this first chapter, we'll first briefly look at the history of Linux <strong class="source-inline">init</strong> systems. We'll then look at the shortcomings of the legacy <strong class="source-inline">init</strong> systems and why certain Linux engineers felt the need to develop a new type of <strong class="source-inline">init</strong> system. Finally, we'll look at the controversy that has surrounded <strong class="source-inline">systemd</strong>. For easy reference, here's a list of the topics:</p>
			<ul>
				<li>The history of Linux <strong class="source-inline">init</strong> systems</li>
				<li>The shortcomings of SysV <strong class="source-inline">init</strong> and upstart</li>
				<li>The advantages of <strong class="source-inline">systemd</strong></li>
				<li>The <strong class="source-inline">systemd</strong> controversy</li>
			</ul>
			<p>So, with the introductory comments out of the way, let's jump in.</p>
			<h1 id="_idParaDest-17"><a id="_idTextAnchor016"/>Technical requirements</h1>
			<p>For this chapter, all you need is a Linux virtual machine that runs <strong class="source-inline">systemd</strong>. As you read through this chapter, you might want to look at some of the files on the virtual machine.</p>
			<h1 id="_idParaDest-18"><a id="_idTextAnchor017"/>The history of Linux init systems</h1>
			<p>So, what is an <strong class="source-inline">init</strong> system? Well, <strong class="source-inline">init</strong> is short for <em class="italic">initialization</em>. An <strong class="source-inline">init</strong> system, then, initializes the <a id="_idIndexMarker000"/>operating system upon bootup. After the bootup has completed, the <strong class="source-inline">init</strong> system will continue working, managing system processes and services. Each system process is assigned a process ID number, or <em class="italic">PID</em>. The <strong class="source-inline">init</strong> process is always PID 1, and every other process that gets started on the system is either <a id="_idIndexMarker001"/>a child or a grandchild of the <strong class="source-inline">init</strong> process.</p>
			<p>For many years, the <strong class="bold">SysV Init</strong> system was the primary <strong class="source-inline">init</strong> system for Linux-based operating systems (SysV is short for <em class="italic">System 5</em>. The <em class="italic">V</em> is the Roman numeral for 5). SysV <strong class="source-inline">init</strong> was originally developed by Bell Labs engineers for the Unix operating system, all the way back in the early 1970s. (At that time, I was a young pup in junior high school, and I still had a full head of hair.)</p>
			<p class="callout-heading">Note</p>
			<p class="callout">There are actually a few more Linux <strong class="source-inline">init</strong> systems besides the ones that I'm mentioning here. But these were the most commonly used ones in the pre-<strong class="source-inline">systemd</strong> days.</p>
			<p>SysV <strong class="source-inline">init</strong> worked well in its day, but it was never perfect. Nowadays, with new high-performance hardware, SysV <strong class="source-inline">init</strong> has shown both its age and its deficiencies. The first attempt to come <a id="_idIndexMarker002"/>up with something better occurred in July 2009, when Ubuntu <a id="_idIndexMarker003"/>engineers released the first version of the <strong class="bold">upstart</strong> <strong class="source-inline">init</strong> system. Although it was better than SysV, it still had its share of problems, especially the early versions which were quite buggy.</p>
			<h1 id="_idParaDest-19"><a id="_idTextAnchor018"/>The shortcomings of SysV Init and upstart</h1>
			<p>The first problem with SysV is that of its rather lengthy boot-up times. When you boot up a SysV machine, all of its services have to start up in sequential order. That might not be so bad <a id="_idIndexMarker004"/>on a normal desktop machine, but it can be a bit problematic on a server that needs to run lots of services. In that case, each service would have <a id="_idIndexMarker005"/>to wait its turn to start, which could take a while.</p>
			<p>The next problem with SysV is its complexity. Instead of simple, easy-to-understand configuration files, SysV does everything with complex Bash shell scripts. The <strong class="source-inline">init</strong> scripts that control system services all have to be assigned a priority number, so that services will start and stop in the proper order. Take, for example, the <strong class="source-inline">init</strong> script that starts the Apache web server on a CentOS 5 machine. First, we can see that it's a fairly lengthy script, as shown here:</p>
			<p class="source-code">[student@localhost init.d]$ pwd</p>
			<p class="source-code">/etc/init.d</p>
			<p class="source-code">[student@localhost init.d]$ ls -l httpd</p>
			<p class="source-code">-rwxr-xr-x 1 root root 3523 Sep 16  2014 httpd</p>
			<p class="source-code">[student@localhost init.d]$ wc -l httpd</p>
			<p class="source-code">131 httpd</p>
			<p class="source-code">[student@localhost init.d]$</p>
			<p>You can <a id="_idIndexMarker006"/>see from the <strong class="source-inline">wc -l</strong> output that it consists of 131 lines. As you <a id="_idIndexMarker007"/>can see here, 37 of those lines are comments, which still leaves us with 94 lines of actual code:</p>
			<p class="source-code">[student@localhost init.d]$ grep ^# httpd | wc -l</p>
			<p class="source-code">37</p>
			<p class="source-code">[student@localhost init.d]$</p>
			<p>Look inside, and you'll see that it's quite complex and convoluted. Here's just the first part of it:</p>
			<div>
				<div id="_idContainer006" class="IMG---Figure">
					<img src="image/Figure_1.1_B17491.jpg" alt=""/>
				</div>
			</div>
			<p class="figure-caption">Figure 1.1 – An old-fashioned SysV Init script</p>
			<p>Toward the end of the script, you'll see the code that stops, starts, restarts, and reloads the Apache daemon, as shown here:</p>
			<div>
				<div id="_idContainer007" class="IMG---Figure">
					<img src="image/Figure_1.2_B17491.jpg" alt=""/>
				</div>
			</div>
			<p class="figure-caption">Figure 1.2 – The start, stop, restart, reload section of an init script</p>
			<p>This code, or code similar to this, has to be in every <strong class="source-inline">init</strong> script so that the human user can control the daemon. To complicate things even more, developers didn't always write this <a id="_idIndexMarker008"/>code consistently for different programs. So, for example, a status <a id="_idIndexMarker009"/>display for one daemon didn't always look the same as the status display for another daemon.</p>
			<p>Then, there's the problem of inconsistent implementation across the different families of Linux distros. With SysV, there were at least three different methods of implementation. Red Hat-type distros used one method, Debian-type distros used another method, and Slackware-type distros use yet another. For example, the Red Hat way of controlling services required using the <strong class="source-inline">service</strong> and <strong class="source-inline">chkconfig</strong> commands. When working with Debian-type systems, I always used to have to look up the service management commands, because I could never remember them. With Slackware, you don't have any service management commands. To enable or disable a service on a Slackware machine, you just set or remove the executable permission from the appropriate <strong class="source-inline">init</strong> script.</p>
			<p>Runlevels were also a source of confusion, because each family of distro had its own set of runlevel definitions. For example, here are the definitions for the graphical runlevel:</p>
			<ul>
				<li>The Red Hat family used runlevel 5.</li>
				<li>The Slackware family uses runlevel 4.</li>
				<li>The Debian family used no specific runlevel for either text mode or graphical mode. Instead, you enabled or disabled graphical mode by enabling or disabling the X server daemon.</li>
			</ul>
			<p>So, you can see <a id="_idIndexMarker010"/>that this was all quite confusing, especially for <a id="_idIndexMarker011"/>anyone who worked in a mixed environment. It should be fairly obvious that we needed something that was a bit less confusing.</p>
			<p>As if this weren't enough, there was also the issue of performance. SysV worked well in its day, when computing hardware was more primitive. But, on modern hardware with multiple CPUs that each have multiple cores, we need something a bit more robust. Ubuntu's upstart was supposed to fix this, but it didn't quite live up to its promise. Nowadays, Upstart is completely dead, but there are still some diehards who refuse to give up SysV. In the enterprise, <strong class="source-inline">systemd</strong> is king.</p>
			<h1 id="_idParaDest-20"><a id="_idTextAnchor019"/>The advantages of systemd</h1>
			<p>We've just <a id="_idIndexMarker012"/>seen the problems with SysV and upstart. Now, let's look at what makes <strong class="source-inline">systemd</strong> better.</p>
			<h2 id="_idParaDest-21"><a id="_idTextAnchor020"/>systemd's simplicity</h2>
			<p>In contrast <a id="_idIndexMarker013"/>to SysV, <strong class="source-inline">systemd</strong> is really quite simple to configure. For example, look at how short the Apache service file is on a CentOS 7 machine with <strong class="source-inline">systemd</strong>:</p>
			<p class="source-code">[donnie@localhost ~]$ cd /lib/systemd/system</p>
			<p class="source-code">[donnie@localhost system]$ ls -l httpd.service</p>
			<p class="source-code">-rw-r--r--. 1 root root 752 Jun 26  2018 httpd.service</p>
			<p class="source-code">[donnie@localhost system]$ wc -l httpd.service</p>
			<p class="source-code">22 httpd.service</p>
			<p class="source-code">[donnie@localhost system]$</p>
			<p>There are <a id="_idIndexMarker014"/>only 22 lines, and 5 of those lines are comments, as you can see here:</p>
			<div>
				<div id="_idContainer008" class="IMG---Figure">
					<img src="image/Figure_1.3_B17491.jpg" alt=""/>
				</div>
			</div>
			<p class="figure-caption">Figure 1.3 – A systemd service file</p>
			<p>I'll explain everything in the <strong class="source-inline">systemd</strong> files later. For now, I just want to show you that a <strong class="source-inline">systemd</strong> service file is much simpler than a SysV <strong class="source-inline">init</strong> script. (As we'll soon see in the upcoming chapters, it's easier to learn how to use the <strong class="source-inline">systemd</strong> directives than it is to learn how to write shell-scripting code for <strong class="source-inline">init</strong> scripts.)</p>
			<h2 id="_idParaDest-22"><a id="_idTextAnchor021"/>systemd's consistency</h2>
			<p>The next <strong class="source-inline">systemd</strong> advantage is its consistency. Yes, boys and girls, you no longer have to remember <a id="_idIndexMarker015"/>multiple sets of system management commands for multiple families of Linux distros. Instead, you'll now use the same commands on all Linux distros that use <strong class="source-inline">systemd</strong>. So, this eliminates a major source of frustration for administrators, and for anyone who's studying to take a Linux certification exam.</p>
			<h2 id="_idParaDest-23"><a id="_idTextAnchor022"/>systemd's performance</h2>
			<p>In contrast to SysV, <strong class="source-inline">systemd</strong> can start services in parallel, rather than just one at a time in <a id="_idIndexMarker016"/>sequence. This makes for much quicker boot-up times than for SysV. Once the machine is booted, performance is more robust than that of SysV.</p>
			<p>With <strong class="source-inline">systemd</strong>, we have a much cleaner way of killing processes. For example, if you needed to use the <strong class="source-inline">kill</strong> command to forcefully terminate the Apache web server service on a SysV machine, you would only terminate the Apache process itself. If the web server process had spawned any child processes due to running CGI scripts, for example, those processes would continue on for a while longer as <em class="italic">zombie</em> processes. But, when you kill a service with <strong class="source-inline">systemd</strong>, all processes that are associated with that service will also get terminated.</p>
			<h2 id="_idParaDest-24"><a id="_idTextAnchor023"/>systemd security</h2>
			<p>An added bonus <a id="_idIndexMarker017"/>is that you can configure <strong class="source-inline">systemd</strong> service files to control certain aspects of system security. Here are some of the things that you can do:</p>
			<ul>
				<li>You can create a <strong class="source-inline">systemd</strong> service that can restrict access to or from certain directories, or that can only access or be accessed from certain network addresses. </li>
				<li>By using namespaces, you can effectively isolate services from the rest of the system. This also allows you to create containers without having to run Docker.</li>
				<li>You can use <strong class="source-inline">cgroups</strong> to limit resource usage. This can help prevent certain types of denial-of-service attacks.</li>
				<li>You can specify which root-level kernel capabilities a service is allowed to have.</li>
			</ul>
			<p>With all this, you can make <strong class="source-inline">systemd</strong> somewhat emulate a mandatory access control system, such as SELinux or AppArmor.</p>
			<p>All the way around, <strong class="source-inline">systemd</strong> is much better than any <strong class="source-inline">init</strong> system that came before it. But it hasn't made everyone happy.</p>
			<h1 id="_idParaDest-25"><a id="_idTextAnchor024"/>The systemd controversy</h1>
			<p>If you've been in the computer world for any length of time, you may have seen that we geeks can get <a id="_idIndexMarker018"/>quite passionate about our operating systems. In the early 1990s, I finally replaced my text mode-only 8088 machine with one that could run a graphical interface. I first gave Windows 3.1 a try, and quickly decided that I really hated it. So, I bought a copy of OS/2, which I liked much better and ran for quite a few years on my home-built 486 machine. But, all of my geek buddies at work were big Windows fans, and they kept arguing with me about how much better Windows is. I thought that they were all crazy, and we kept getting into some rather heated arguments.</p>
			<p>Then, when I got into Linux, I quickly learned that you don't want to go into any Linux forum and ask which Linux distro is the best for a newbie to start with. All that does is start fights, leaving the poor newbie more confused than ever. And now, the fight is over whether or not <strong class="source-inline">systemd</strong> is a <em class="italic">good thing</em>. Here are some of the objections:</p>
			<ul>
				<li>By trying to do too much, <strong class="source-inline">systemd</strong> violates the Unix concept of having each utility just do one thing but having it do it well.</li>
				<li>It's controlled by a large corporation (Red Hat).</li>
				<li>It's a security problem.</li>
				<li>Its <strong class="source-inline">journald</strong> component saves system logs to a binary format, which some people believe is more easily corrupted than the plain-text files that <strong class="source-inline">rsyslog</strong> creates.</li>
			</ul>
			<p>If you look at things objectively, you might see that the objections aren't so bad:</p>
			<ul>
				<li>Yes, the <strong class="source-inline">systemd</strong> ecosystem includes more than just the <strong class="source-inline">init</strong> system. It also includes network, bootloader, logging, and log-in components. But those components are all optional, and not all Linux distros use them in a default setup.</li>
				<li>It was created primarily by Red Hat, and the project leader is a Red Hat employee. But Red Hat released it under a free-as-in-speech software license, which means that no one company can ever take full control of it. Even if Red Hat were to suddenly decide that future versions of <strong class="source-inline">systemd</strong> were to be proprietary, the free code is still out there, and someone would fork it into a new free version.</li>
				<li>Yes, there have been some security bugs in <strong class="source-inline">systemd</strong>. But that's also true of OpenSSL, the Bash shell, and even the Linux kernel itself. To complain about <strong class="source-inline">systemd's</strong> security would only be valid if the bugs hadn't gotten fixed.</li>
				<li>The <strong class="source-inline">journald</strong> component does create log files in a binary format. But it's still possible to run <strong class="source-inline">rsyslog</strong> on <strong class="source-inline">systemd</strong> distros, and most do. Some distros, such as the Red Hat Enterprise Linux 8 family, use <strong class="source-inline">journald</strong> to gather system information and then just have <strong class="source-inline">journald</strong> pass the information to <strong class="source-inline">rsyslog</strong> in order to create normal text files. So, with RHEL 8, we have the best of both worlds.</li>
			</ul>
			<p>Soon after the <a id="_idIndexMarker019"/>release of <strong class="source-inline">systemd</strong>, some people who had never even tried it put up blog posts that explained why <strong class="source-inline">systemd</strong> was pure evil and that they would never use it. A few years ago, I created a <strong class="source-inline">systemd</strong> tutorial playlist on my BeginLinux Guru channel on YouTube. The first video is called <em class="italic">Why systemd?</em>. Quite a few people left comments about why they would never use <strong class="source-inline">systemd</strong> and said that they would change to either a non-<strong class="source-inline">systemd</strong> Linux distro or to a FreeBSD-type distro in order to avoid it.</p>
			<p>The bottom line is this: all enterprise-grade Linux distros now use <strong class="source-inline">systemd</strong>. So, I think that it might be here to stay.</p>
			<h1 id="_idParaDest-26"><a id="_idTextAnchor025"/>Summary</h1>
			<p>In this first chapter, we've looked at the history of the most common Linux init systems. We've seen the ways in which the legacy init systems are deficient, and we've seen why <strong class="source-inline">systemd</strong> is a much better replacement. We wrapped things up by looking at the objections against <strong class="source-inline">systemd</strong>.</p>
			<p>One of the challenges of learning <strong class="source-inline">systemd</strong> is that, until now, there hasn't been any real comprehensive documentation about it. There's basic usage documentation on the Red Hat website, but it doesn't even cover all components of the <strong class="source-inline">systemd</strong> ecosystem. There are only two <strong class="source-inline">systemd</strong>-specific books that I could find, which are a few years old. (One book is specific to Fedora, the other is specific to Ubuntu.) Even those books leave some things out. So, the challenge I've set for myself is to create a comprehensive, hands-on guide for all things <strong class="source-inline">systemd</strong>. In the chapters that follow, I'll do my best to accomplish that goal.</p>
			<p>In the next chapter, we'll go on a quick tour of the <strong class="source-inline">systemd</strong> directories and files. I'll see you there.</p>
			<h1 id="_idParaDest-27"><a id="_idTextAnchor026"/>Questions</h1>
			<ol>
				<li>Who created the original SysV <strong class="source-inline">init</strong> system?<p>a. Bell Labs</p><p>b. Red Hat</p><p>c. Debian</p><p>d. Ubuntu</p></li>
				<li>Which of the following is true about SysV?<p>a. It's a modern, robust <strong class="source-inline">init</strong> system.</p><p>b. When booting a machine, it can start services in parallel.</p><p>c. When booting a machine, it can only start services sequentially.</p><p>d. It has security features that <strong class="source-inline">systemd</strong> doesn't have.</p></li>
				<li>Which of the following is <em class="italic">not</em> true about <strong class="source-inline">systemd</strong>?<p>a. It has security features that can somewhat emulate a mandatory access control system.</p><p>b. It can start services in parallel.</p><p>c. It can use <strong class="source-inline">cgroups</strong> to limit resource usage.</p><p>d. It's a legacy system that needs to be replaced.</p></li>
			</ol>
			<h1 id="_idParaDest-28"><a id="_idTextAnchor027"/>Answers</h1>
			<ol>
				<li value="1">A</li>
				<li>C</li>
				<li>D</li>
			</ol>
			<h1 id="_idParaDest-29"><a id="_idTextAnchor028"/>Further reading</h1>
			<ul>
				<li>An overview of Linux <strong class="source-inline">init</strong> systems: <p><a href="https://www.tecmint.com/best-linux-init-systems/">https://www.tecmint.com/best-linux-init-systems/</a></p></li>
				<li>Why <strong class="source-inline">init</strong> needed to be replaced with <strong class="source-inline">systemd</strong>: <p><a href="https://www.tecmint.com/systemd-replaces-init-in-linux/">https://www.tecmint.com/systemd-replaces-init-in-linux/</a></p></li>
				<li>Red Hat's <strong class="source-inline">systemd</strong> documentation: <p><a href="https://access.redhat.com/documentation/en-us/red_hat_enterprise_linux/8/html/configuring_basic_system_settings/index">https://access.redhat.com/documentation/en-us/red_hat_enterprise_linux/8/html/configuring_basic_system_settings/index</a></p></li>
				<li>Some arguments against <strong class="source-inline">systemd</strong>:<p><a href="https://textplain.net/blog/2015/problems-with-systemd-and-why-i-like-bsd-init/">https://textplain.net/blog/2015/problems-with-systemd-and-why-i-like-bsd-init/</a></p><p><a href="https://www.theregister.com/2014/10/21/unix_greybeards_threaten_debian_fork_over_systemd_plan/">https://www.theregister.com/2014/10/21/unix_greybeards_threaten_debian_fork_over_systemd_plan/</a></p></li>
			</ul>
		</div>
	</body></html>