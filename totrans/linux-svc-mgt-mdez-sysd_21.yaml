- en: '*Chapter 18*: Understanding systemd-logind'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第18章*：理解 systemd-logind'
- en: 'Yes, it''s true – there''s even a new way of managing user logins and user
    sessions in systemd. In this chapter, we''ll delve into the mysteries of `systemd-logind`,
    and show you some fairly nifty user management tricks. Knowing these tricks can
    definitely help you out in a business environment. Specific topics in this chapter
    include:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 是的，的确如此——systemd 中甚至有一种新的管理用户登录和用户会话的方式。在本章中，我们将深入探讨 `systemd-logind`，并向你展示一些相当巧妙的用户管理技巧。掌握这些技巧无疑能帮助你在商业环境中发挥作用。本章的具体主题包括：
- en: Understanding the need for a new login service
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解需要一个新的登录服务
- en: Understanding `systemd-logind.service`
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解 `systemd-logind.service`
- en: Understanding `logind.conf`
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解 `logind.conf`
- en: Understanding `loginctl`
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解 `loginctl`
- en: Understanding `polkit`
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解 `polkit`
- en: All right, let's get started.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，让我们开始吧。
- en: Technical requirements
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: We won't need anything fancy for this chapter. Just use your normal `logind.conf`
    demos, because restarting the `systemd-logind` service is problematic on graphical
    mode machines (I'll explain more about that in a bit). At the end of the chapter,
    there will be a couple of demos for which it will be handy to have a desktop interface,
    so you'll want an Alma machine with the **Gnome 3** desktop for them.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 对于本章，我们不需要任何复杂的配置。只需要使用你常规的 `logind.conf` 演示，因为在图形模式的机器上重启 `systemd-logind`
    服务是有问题的（稍后我会详细解释）。在本章结束时，会有几个演示需要桌面界面，因此你需要一台带有 **Gnome 3** 桌面的 Alma 机器来进行这些演示。
- en: All right, let's begin by looking at the `systemd-logind.service` file.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，让我们开始查看 `systemd-logind.service` 文件。
- en: 'Check out the following link to see the Code in Action video: [https://bit.ly/3EiIHSD](https://bit.ly/3EiIHSD)'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 查看以下链接，观看《代码演示》视频：[https://bit.ly/3EiIHSD](https://bit.ly/3EiIHSD)
- en: Understanding the need for a new login service
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解需要一个新的登录服务
- en: I know, you're wondering, *Why do we even need a new login service?* One reason
    is because of the tight integration between `systemd` and `cgroups`. The `systemd-logind`
    service does several things for us, but its main job is to create cgroup slices
    and scopes for everyone who logs into a system. As we go through this chapter,
    we'll look at a few other things that `systemd-logind` also does for us. (To read
    a short description about all of the things that `systemd-logind` does, see the
    `systemd-logind` man page.)
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 我知道，你在想，*为什么我们需要一个新的登录服务？* 其中一个原因是因为 `systemd` 和 `cgroups` 的紧密集成。`systemd-logind`
    服务为我们做了很多事情，但它的主要工作是为每个登录系统的用户创建 cgroup 切片和范围。随着本章的展开，我们还会看到 `systemd-logind`
    为我们做的一些其他事情。（想要了解 `systemd-logind` 所做所有事情的简短描述，请参阅 `systemd-logind` 的手册页。）
- en: Understanding systemd-logind.service
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解 systemd-logind.service
- en: There's a considerable difference in how this unit file is set up on RHEL-type
    systems and Ubuntu. Let's first look at the RHEL-type setup on the Alma machine.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在 RHEL 类型系统和 Ubuntu 中，单元文件的设置有显著差异。我们首先来看 Alma 机器上 RHEL 类型的配置。
- en: The Alma Linux systemd-logind.service file
  id: totrans-16
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Alma Linux 的 systemd-logind.service 文件
- en: 'On the Alma machine, the `[Unit]` section of the `/lib/systemd/system/systemd-logind.service`
    file looks like this:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Alma 机器上，`/lib/systemd/system/systemd-logind.service` 文件的 `[Unit]` 部分如下所示：
- en: '[PRE0]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Here''s the breakdown:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是详细分解：
- en: '`Wants=user.slice`: This makes total sense. Due to systemd''s tight integration
    with cgroups, a user slice must be created for every user who logs in.'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Wants=user.slice`：这完全有道理。由于 systemd 与 cgroups 的紧密集成，必须为每个登录的用户创建一个用户切片。'
- en: '`After=nss-user-lookup.target`: The `/etc/nsswitch.conf` file, which we''ll
    discuss next.'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`After=nss-user-lookup.target`：这是 `/etc/nsswitch.conf` 文件，我们接下来会讨论。'
- en: '`Wants=dbus.socket` and `After=dbus.socket`: There''s no `[Install]` section
    of this service file, so this service won''t automatically start when we reach
    either the multi-user or graphical target. Instead, a `dbus` message will get
    generated when the first user logs in for the first time, which will automatically
    start the service.'
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Wants=dbus.socket` 和 `After=dbus.socket`：这个服务文件没有 `[Install]` 部分，因此当我们进入多用户或图形目标时，服务不会自动启动。相反，当第一个用户首次登录时，会生成一个
    `dbus` 消息，从而自动启动该服务。'
- en: 'Okay, let''s look at the relevant lines of the `/etc/nsswitch.conf` file. Open
    it and look for these four lines:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，让我们查看 `/etc/nsswitch.conf` 文件中的相关行。打开文件并查找这四行：
- en: '[PRE1]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: In the `passwd:`, `shadow:`, and `group:` lines of the file, the `sss` means
    that user and group information will be pulled from the `sssd` allows you to use
    `/etc/passwd`, `/etc/group`, `/etc/shadow`, and `/etc/gshadow` files. If the system
    can't find information about the user who's logging in in either `sss` or `files`,
    then it will go to `systemd`. The `systemd` setting allows the system to authenticate
    a dynamic user that might be configured in a service unit file, and that wouldn't
    have an entry in either the `/etc/passwd` or `/etc/shadow` files.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 在`passwd:`、`shadow:`和`group:`行中，`sss`表示用户和组信息将从`sssd`中提取，这使得你可以使用`/etc/passwd`、`/etc/group`、`/etc/shadow`和`/etc/gshadow`文件。如果系统在`sss`或`files`中找不到登录用户的信息，它会转向`systemd`。`systemd`设置允许系统验证动态用户，这些用户可能在服务单元文件中配置，并且在`/etc/passwd`或`/etc/shadow`文件中没有条目。
- en: Note
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: '*Dynamic users*, to which I alluded in the preceding paragraph, aren''t for
    normal human users who would log into a computer. They''re *system accounts* that
    are used for running services with reduced privileges. A dynamic user gets created
    on-the-fly whenever a service that uses one starts, and gets destroyed whenever
    the service stops. You''ll never see an entry for a dynamic user in the `/etc/passwd`,
    `/etc/group`, `/etc/gshadow`, or `/etc/shadow` files.'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: '*动态用户*，如前文所提到的，并不是用于普通的登录计算机的人的用户。它们是*系统账户*，用于以减少的权限运行服务。每当使用动态用户的服务启动时，动态用户就会动态创建，并在服务停止时被销毁。你永远不会在`/etc/passwd`、`/etc/group`、`/etc/gshadow`或`/etc/shadow`文件中看到动态用户的条目。'
- en: 'Now, let''s get back to the `systemd-logind.service` file, and look at the
    `[Service]` section. I can''t show it all to you at once, so here''s the top part:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们回到`systemd-logind.service`文件，看看`[Service]`部分。我不能一次性展示给你所有内容，所以这里是顶部部分：
- en: '[PRE2]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'It''s mainly the standard stuff that we''ve gone over before, so you should
    have a good handle on it already. The main thing I want you to notice is the `CapabilityBoundingSet=`
    line, which grants a lot of root-level capabilities to this service. The second
    part of the `[Service]` section consists of a lot of security and resource control
    directives:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 这主要是我们之前讲过的标准内容，所以你应该已经掌握了。我要你注意的重点是`CapabilityBoundingSet=`行，它为该服务授予了许多root级别的能力。`[Service]`部分的第二部分包含了很多安全性和资源控制指令：
- en: '[PRE3]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: As always, I'll leave it to you to look these directives up in the `systemd.directives`
    man page.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 和往常一样，我会留给你自己查阅`systemd.directives`手册页面中的这些指令。
- en: All right, that's it for the `systemd-logind.service` file on the Alma machine.
    Let's look at the one on the Ubuntu machine.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，这就是Alma机器上的`systemd-logind.service`文件。让我们看看Ubuntu机器上的文件。
- en: The Ubuntu Server systemd-logind.service file
  id: totrans-34
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Ubuntu Server的`systemd-logind.service`文件
- en: 'The `systemd-logind.service` file on the Ubuntu machine is considerably different
    from the one on the Alma machine. Let''s look at the `[Unit]` section first:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: Ubuntu机器上的`systemd-logind.service`文件与Alma机器上的有很大不同。我们先来看一下`[Unit]`部分：
- en: '[PRE4]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The first difference we see is that the `Wants=` line calls in the `modprobe@.service`
    to load the `drm`) kernel module. I''m not sure why that is, because this seems
    like something that should get loaded when you boot the machine. In fact, this
    seems to be the case on the Alma machine, as we see here:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 我们看到的第一个区别是，`Wants=`行调用了`modprobe@.service`来加载`drm`内核模块。我不确定为什么这样，因为这看起来应该是在启动机器时加载的。实际上，这在Alma机器上似乎是这样，如我们所见：
- en: '[PRE5]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: For some reason that I don't know, the Ubuntu developers decided to load the
    `drm` module when the `systemd-logind` service starts, instead of at boot-up.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 出于我不明白的原因，Ubuntu的开发人员决定在`systemd-logind`服务启动时加载`drm`模块，而不是在启动时加载。
- en: 'The `[Service]` section on the Ubuntu machine is much larger, because it contains
    more security directives than what you saw on the Alma machine. Why? Well remember,
    the Alma machine is running `systemd-logind.service` file give us some good *Mandatory
    Access Control* protection that AppArmor doesn''t give us. Here''s a snippet of
    the `[Service]` section, which shows some of the extra directives for Ubuntu:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: Ubuntu机器上的`[Service]`部分要大得多，因为它包含了比Alma机器上更多的安全指令。为什么？请记住，Alma机器正在运行的`systemd-logind.service`文件为我们提供了一些AppArmor无法提供的良好的*强制访问控制*保护。以下是`[Service]`部分的一个片段，显示了Ubuntu的一些额外指令：
- en: '[PRE6]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: As always, I'll let you read about these security directives in the man pages.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 和往常一样，我让你在手册页面中阅读这些安全指令。
- en: Next, let's look at the configuration file for `systemd-logind.service`.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们来看一下`systemd-logind.service`的配置文件。
- en: Understanding logind.conf
  id: totrans-44
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解logind.conf
- en: The `/etc/systemd/logind.conf` file is the configuration file for the `systemd-logind`
    service. Now, before we get too far, I want to recommend that you use a text-mode
    virtual machine for this section. The demos will have you make several changes
    to the `logind.conf` file, and you'll need to restart the `systemd-logind` service
    after each one. If you do that on a graphical mode machine, you'll get logged
    out of the desktop, and will have to log back in. The desktop doesn't always come
    back up correctly, and you'll end up having to restart the machine. With a text-mode
    machine, that isn't a problem. So, since the Ubuntu Server machine is already
    in text mode, we'll use it for the demos.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: '`/etc/systemd/logind.conf` 文件是 `systemd-logind` 服务的配置文件。在我们深入之前，我建议你使用文本模式虚拟机进行本节操作。演示将要求你对
    `logind.conf` 文件做几个修改，并且每次修改后都需要重启 `systemd-logind` 服务。如果你在图形模式的机器上进行操作，你会被登出桌面，然后需要重新登录。桌面不一定能正确恢复，你可能会需要重启机器。而在文本模式机器上就没有这个问题。因此，由于
    Ubuntu Server 机器已经处于文本模式，我们将用它进行演示。'
- en: 'The good news is that the `logind.conf` file is identical on both the Ubuntu
    machine and the Alma machine. Here''s what it looks like:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 好消息是，`logind.conf` 文件在 Ubuntu 机器和 Alma 机器上是完全相同的。它看起来是这样的：
- en: '![](img/B17491_Figure_18.1.jpg)'
  id: totrans-47
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B17491_Figure_18.1.jpg)'
- en: Figure 18.1 – The logind.conf file
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 图 18.1 – logind.conf 文件
- en: As is the case with all of the configuration files in `/etc/systemd/`, all directives
    are commented out. The values shown are the default ones that are compiled into
    the `systemd-logind` executable. You can probably figure out what many of these
    directives do just by looking at their names, and you can consult the `logind.conf`
    man page to read about the ones that aren't so obvious. So, rather than cover
    each directive in detail, I just want to go over a few of the more interesting
    ones. Let's start with the *virtual terminals* setting.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 和 `/etc/systemd/` 下的所有配置文件一样，所有指令都被注释掉了。显示的值是编译进 `systemd-logind` 可执行文件中的默认值。你可能通过查看这些指令的名称就能猜出它们的作用，如果不太明白的部分，你可以查阅
    `logind.conf` 的手册页。所以，与其详细介绍每个指令，我更想讲解几个较为有趣的指令。我们先从 *虚拟终端* 设置开始。
- en: Virtual terminals
  id: totrans-50
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 虚拟终端
- en: 'At the top, we see the `#NAutoVTs=6` line. This sets the number of available
    *virtual terminals*. Virtual terminals don''t do much for you on a desktop machine,
    because you can just open multiple terminal emulators from the `ssh` into my other
    GPU mining rig from the **F4** terminal. On a graphical mode desktop machine,
    one virtual terminal is reserved for the desktop. (It''s usually the **F1** terminal,
    but that could vary with different distros.) You can try this on your virtual
    machine, but there''s a bit of a trick to it. If your host machine is running
    **Windows**, just do the *Ctrl-Alt-Function* key sequence from your normal keyboard,
    as you''d do on a bare-metal Linux machine. But, if your host machine is running
    Linux, you''ll need to open the **VirtualBox** **Input/Keyboard** menu and bring
    up the **Soft Keyboard**:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 在顶部，我们看到 `#NAutoVTs=6` 这一行。这设置了可用的 *虚拟终端* 数量。虚拟终端对桌面机器来说没什么用，因为你可以直接从 **F4**
    终端通过 `ssh` 打开多个终端模拟器来连接到其他 GPU 挖矿设备。在图形模式的桌面机器上，一个虚拟终端通常保留给桌面。（它通常是 **F1** 终端，但不同的发行版可能会有所不同。）你可以在虚拟机上尝试这个，但是有一个小技巧。如果你的主机是运行
    **Windows**，就像在裸机 Linux 上那样直接按 *Ctrl-Alt-Function* 键序列。但如果你的主机是运行 Linux，你需要打开
    **VirtualBox** 的 **输入/键盘** 菜单，并启动 **软键盘**：
- en: '![](img/B17491_Figure_18.2.jpg)'
  id: totrans-52
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B17491_Figure_18.2.jpg)'
- en: Figure 18.2 – The VirtualBox Soft Keyboard
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 图 18.2 – 虚拟机的软键盘
- en: Then, do your *Ctrl-Alt-Function* key sequence by clicking on the soft keyboard.
    If you try to do it the normal way with your normal keyboard, the key sequence
    will be intercepted by the host machine.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，通过点击软键盘来执行你的 *Ctrl-Alt-Function* 键序列。如果你试图用普通键盘来做，主机机器会拦截这个键序列。
- en: 'You''ll likely never edit this line, because six virtual terminals are enough
    for most people. But if you ever do need more, you can add them here. For example,
    let''s say that you need to have eight virtual terminals instead of just six.
    Just change the `#NAutoVTs=6` line to `#NAutoVTs=8`. Then, restart the `systemd-logind`
    service:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能永远不会编辑这一行，因为六个虚拟终端对于大多数人来说已经足够了。但如果你需要更多虚拟终端，你可以在这里添加。例如，假设你需要八个虚拟终端而不仅仅是六个，只需将
    `#NAutoVTs=6` 改为 `#NAutoVTs=8`。然后，重启 `systemd-logind` 服务：
- en: '[PRE7]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: You can see the extra two virtual terminals by doing *Ctrl + Alt + F7* and *Ctrl
    + Alt + F8*.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过按 *Ctrl + Alt + F7* 和 *Ctrl + Alt + F8* 来查看额外的两个虚拟终端。
- en: Next, let's see how users can keep processes going after they log out.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们看看用户如何在退出后保持进程继续运行。
- en: Keeping user processes going after logout
  id: totrans-59
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 保持用户进程在退出后继续运行
- en: 'These next three lines work together:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 以下三行是一起工作的：
- en: '[PRE8]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'If you''re an old-timer like me, you''ll likely remember how this worked in
    the old SysV days. You''d log into a Linux server, start a process from the command
    line, and then log out while the process was still going. The problem was that
    the process would stop as soon as you logged out. If you logged in remotely and
    started a process, it would stop if you accidentally closed the remote terminal
    of your local machine or if the local machine were to reboot. In order to keep
    the process on the remote machine going if any of those things happened, you''d
    need to start the process with either `screen` or `nohup`. Now though, you don''t
    have to worry about that as long as these three lines stay as you see them here.
    To demonstrate, create an account on the text-mode Ubuntu machine for Frank, if
    you haven''t done so already:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你像我一样是老一辈人，你可能还记得在旧的SysV时代它是如何工作的。你会登录到Linux服务器，从命令行启动一个进程，然后在进程仍在运行时退出。问题是，一旦你退出，进程就会停止。如果你远程登录并启动了一个进程，那么如果不小心关闭了本地机器的远程终端，或者本地机器重新启动，进程也会停止。为了确保进程在远程机器上继续运行，防止出现上述情况，你需要使用`screen`或`nohup`启动进程。现在，只要这三行保持不变，你就不必担心这个问题。为了演示，如果你还没有为Frank创建账户，可以在文本模式的Ubuntu机器上为他创建一个账户：
- en: '[PRE9]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Then, have him remotely log in. Have him create the `loop.sh` shell script
    in his own home directory, like this:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，让他远程登录。让他在自己的主目录中创建`loop.sh`脚本，像这样：
- en: '[PRE10]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'It''s a silly little loop that does nothing but create an entry in a text file
    every five seconds. That''s okay though, because it serves our purpose. (Also,
    note that I didn''t upload this script to `loop.sh` file:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个小小的循环，什么也不做，只是每隔五秒钟在文本文件中创建一个条目。没关系，因为它达到了我们的目的。（另外，请注意，我并没有上传这个脚本到`loop.sh`文件中：）
- en: '[PRE11]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Now, have Frank start the script as a background process:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让Frank将脚本作为后台进程启动：
- en: '[PRE12]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Verify that the script is running by doing `tail -f number.txt`:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 通过执行`tail -f number.txt`来验证脚本是否正在运行：
- en: '[PRE13]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Do a *Ctrl + C* to stop the `tail -f` process. Then, have Frank log out by typing
    `exit`.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 执行*Ctrl + C*来停止`tail -f`进程。然后，让Frank通过输入`exit`退出。
- en: 'Next, have Frank log in again, and again have him do `tail -f number.txt`.
    You should see that the number list keeps incrementing, which means that the process
    kept going after Frank logged out. To stop the process, use `ps aux` to get the
    `PID` number, and then use that PID number in a `kill` command:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让Frank重新登录，然后再次让他执行`tail -f number.txt`。你应该能看到数字列表不断递增，这意味着即使Frank退出，进程仍然在继续。要停止该进程，使用`ps
    aux`获取`PID`号，然后在`kill`命令中使用该PID号：
- en: '[PRE14]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Then, have Frank log out by typing `exit`.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，让Frank通过输入`exit`退出。
- en: 'Now, let''s say that we don''t want Frank to keep his processes going after
    he logs out. In your own terminal, open the `/etc/systemd/logind.conf` file in
    your text editor. Change the `#KillOnlyUsers=` line so that it looks like this:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，假设我们不希望Frank在退出后继续保持其进程运行。在你自己的终端中，打开`/etc/systemd/logind.conf`文件。将`#KillOnlyUsers=`这一行修改成如下所示：
- en: '[PRE15]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Save the file and restart the `systemd-logind` service:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 保存文件并重启`systemd-logind`服务：
- en: '[PRE16]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Note that there's no `reload` option for this service.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，这个服务没有`reload`选项。
- en: Go back to Frank's terminal, and have him log back in. Have him start the `loop.sh`
    script in the background, as you did before. When you do a `tail -f number.txt`
    command this time, you should see that the number list no longer increments.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 回到Frank的终端，让他重新登录。让他像之前一样在后台启动`loop.sh`脚本。当你这次执行`tail -f number.txt`命令时，你应该能看到数字列表不再递增。
- en: Okay, we're through with Frank for now, so go ahead and have him log out.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，现在我们暂时不需要Frank了，让他退出吧。
- en: Note
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: A few days ago, the day that I started writing this chapter, Frank the cat decided
    to help out. He pressed some keys on my keyboard and deleted a whole paragraph,
    replacing it with a string of dashes. (Thank goodness for the **Undo** feature.)
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 几天前，就是我开始写这一章的那天，猫Frank决定帮忙。他按了一些键并删除了整段文字，用一串破折号替换了它。（幸好有**撤销**功能。）
- en: Next, let's look at a few *power management directives*.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们看一下几个*电源管理指令*。
- en: Power management directives
  id: totrans-86
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 电源管理指令
- en: Further down in the `/etc/systemd/logind.conf` file, you'll see the `HandlePowerKey=`,
    `HandleSuspendKey=`, `HandleHibernateKey=`, `HandleLidSwitch=`, `HandleLidSwitchExternalPower=`,
    and the `HandleLidSwitchDocked=` power management directives. You can probably
    figure out what these directives do just by looking at their names, and you can
    see the default settings in the `logind.conf` file. To see the other settings
    that you can use for these directives, just consult the `logind.conf` man page.
    It's a good write-up, so I won't repeat any of that here. But, I will offer one
    example.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `/etc/systemd/logind.conf` 文件的更下方，您会看到 `HandlePowerKey=`, `HandleSuspendKey=`,
    `HandleHibernateKey=`, `HandleLidSwitch=`, `HandleLidSwitchExternalPower=` 和 `HandleLidSwitchDocked=`
    等电源管理指令。您大概可以从这些指令的名称推测它们的作用，您也可以在 `logind.conf` 文件中看到默认设置。要查看可以为这些指令使用的其他设置，只需查看
    `logind.conf` 的手册页。那是一个很好的写法，我在这里就不重复了。不过，我会给出一个例子。
- en: 'Let''s say you have a laptop, and you need it to keep running when you shut
    the lid. Just look for this line:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 假设您有一台笔记本电脑，并且您希望它在合上盖子时继续运行。只需查找这行：
- en: '[PRE17]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Change it to look like this:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 将其更改为如下所示：
- en: '[PRE18]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: I'm going to assume that you're running your laptop in graphical mode. (Doesn't
    everyone?) Since restarting `systemd-logind.service` doesn't work well on graphical
    mode machines, your best bet would be to just reboot the machine so that the new
    setting can take effect. Now, instead of suspending the laptop when you close
    the lid, it will continue running as merrily as it did with the lid open. (You
    can try this on your virtual machine if you really want to. But, since your virtual
    machine doesn't have a lid, you won't see anything happen.).
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 我假设您在图形模式下运行笔记本电脑。（难道不是每个人都这样吗？）由于在图形模式下重启 `systemd-logind.service` 效果不佳，最佳选择是直接重启机器，以便新设置生效。现在，当您合上笔记本电脑的盖子时，它将继续像打开盖子时一样运行。（如果您真的想试试，可以在虚拟机上做这个。但由于您的虚拟机没有盖子，您不会看到任何变化。）
- en: For our last example, let's do some *Idle Action*.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的最后一个例子中，来做一些 *空闲操作*。
- en: The IdleAction directives
  id: totrans-94
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 空闲操作指令
- en: '`IdleAction`, eh? Boy, if that isn''t an oxymoron, I don''t know what is. But
    seriously, you can configure these next two directives to control what happens
    when you leave the computer sitting idle for a specified period of time:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: '`IdleAction`，嗯？如果这不是个矛盾修饰法，那我就不知道什么才是了。但说正经的，您可以配置接下来的两个指令来控制当计算机在指定时间段内处于空闲状态时会发生什么：'
- en: '[PRE19]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'By default, the machine will just keep running until you shut it down. Just
    for fun, change these two lines so that they look like this:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，机器会一直运行，直到您关闭它。为了好玩，把这两行改成如下所示：
- en: '[PRE20]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Restart `systemd-logind.service`, and then just wait, without touching the virtual
    machine. After three minutes, you should see the machine automatically shut down.
    Of course, you don't want to leave the virtual machine with this configuration,
    so boot it up again and change these settings back to their default values. Then,
    restart `systemd-logind.service`.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 重启 `systemd-logind.service`，然后等待，不要触碰虚拟机。大约三分钟后，您应该会看到虚拟机自动关闭。当然，您不希望将虚拟机保持这种配置，因此重新启动虚拟机并将这些设置恢复为默认值。然后，再次重启
    `systemd-logind.service`。
- en: There are still a few directives that I didn't cover, but you can read about
    them in the `logind.conf` man page. Let's move on to the `loginctl` management
    utility.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 仍然有一些指令我没有覆盖，但您可以在 `logind.conf` 的手册页中阅读到。接下来，我们将继续介绍 `loginctl` 管理工具。
- en: Understanding loginctl
  id: totrans-101
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解 `loginctl`
- en: Another bit of good news is that `loginctl` works identically on both Ubuntu
    and Alma. You can use it to keep an eye on what other users are doing, change
    certain settings for a user's login environment, or even as a security tool to
    get rid of malicious users.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个好消息是，`loginctl` 在 Ubuntu 和 Alma 上的表现完全相同。您可以使用它来监视其他用户的活动，修改某个用户的登录环境设置，甚至作为安全工具清除恶意用户。
- en: Note
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: For this section, we'll continue with the Ubuntu Server machine. Create user
    accounts for Pogo, Vicky, and Frank, if you haven't already done so. Log yourself
    in from the local terminal, and again from a remote terminal. Do *Ctrl-Alt-F2*
    on the virtual machine to get to the second virtual terminal, and have Vicky log
    in there. Then, have Pogo and Frank log in from their own remote terminals.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这一部分，我们将继续使用 Ubuntu Server 机器。如果尚未创建 Pogo、Vicky 和 Frank 的用户帐户，请创建。通过本地终端登录，并再次通过远程终端登录。按
    *Ctrl-Alt-F2* 在虚拟机上进入第二个虚拟终端，让 Vicky 在那里登录。然后，让 Pogo 和 Frank 从他们各自的远程终端登录。
- en: 'Before we get into the real meat of the matter, we need to define a couple
    of terms:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 在进入正题之前，我们需要定义几个术语：
- en: '**session**: A *session* gets created whenever a user logs into the system.
    Each session is assigned a decimal number as its ID.'
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**session**：每当用户登录系统时，都会创建一个*会话*。每个会话都会被分配一个十进制数字作为其ID。'
- en: '`seat0` is the only seat that you will ever see. Creating new seats involves
    configuring `udev` rules, which is beyond the scope of this book.'
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`seat0`是你永远会看到的唯一座位。创建新的座位涉及配置`udev`规则，而这超出了本书的范围。'
- en: 'Doing either `loginctl` without any options or `loginctl list-sessions` shows
    you who is logged in and where they''ve logged in from:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 执行`loginctl`没有任何选项或`loginctl list-sessions`会显示谁已登录以及他们是从哪里登录的：
- en: '[PRE21]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: You see that Vicky and I are the only ones with assigned seats, while Frank
    and Pogo have to remain standing. (Yeah I know, bad joke.) But seriously, Vicky
    and I were assigned to `seat0` because we're both logged in at the local terminal.
    I logged in from `tty1`, which is the default virtual terminal. Then, I did *Ctrl-Alt-F2*
    to get to the second virtual terminal (`tty2`), and had Vicky log in there. It's
    probably not real likely that you'll have two people log into two different virtual
    terminals of the same local machine, but it could happen. I did it now to show
    you that more than one user can be assigned to the same seat. You also see that
    I have two sessions going for myself, because I'm logged in from both the local
    terminal and from a remote `ssh` session on the `pts/0` terminal. Frank and Pogo
    are only logged in remotely, which is why they don't have seats. Also, note that
    every session has its own assigned ID number in the first column.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 你会看到，只有Vicky和我有指定的座位，而Frank和Pogo则必须站着。（是的，我知道，这是个糟糕的笑话。）但说正经的，Vicky和我被分配到`seat0`，因为我们都从本地终端登录。我从`tty1`登录，它是默认的虚拟终端。然后，我按下*Ctrl-Alt-F2*切换到第二个虚拟终端（`tty2`），并让Vicky在那边登录。可能并不常见两个人登录到同一台本地机器的两个不同虚拟终端，但这种情况也是可能发生的。我现在这么做是为了展示，可以将多个用户分配到同一个座位。你还会看到，我有两个会话在进行，因为我既从本地终端登录，也通过远程`ssh`会话登录到了`pts/0`终端。Frank和Pogo仅通过远程登录，这就是他们没有座位的原因。另请注意，每个会话在第一列都有自己分配的ID号。
- en: Note
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: I've just shown you how the `list-sessions` option works on Ubuntu. On a RHEL
    8-type distro such as Alma, the `SEAT` and `TTY` columns will both be empty for
    any users who have logged in remotely. (I have no idea why.) However, you will
    see the `pts` information for a user when you use either a `user-status` or a
    `session-status` option, which I'll explain next.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 我刚刚向你展示了`list-sessions`选项在Ubuntu上的工作方式。在RHEL 8类型的发行版中，例如Alma，任何远程登录的用户，`SEAT`和`TTY`列都会为空。（我也不知道为什么。）不过，当你使用`user-status`或`session-status`选项时，你会看到用户的`pts`信息，我接下来会解释。
- en: 'Use the `user-status` option to see detailed information about a user. If you
    don''t specify a username, you''ll see information about your own user account.
    Right now, let''s see what kind of mischief our intrepid opossum, Pogo, is up
    to:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`user-status`选项查看用户的详细信息。如果你没有指定用户名，系统会显示你自己账户的信息。现在，让我们看看我们无畏的负鼠Pogo到底在搞什么小动作：
- en: '[PRE22]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'To see slightly less information, we''ll look at Pogo''s `session-status`.
    We see that he''s in session number `16`, so the command and output will look
    like this:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 为了查看稍少一些的信息，我们来看一下Pogo的`session-status`。我们看到他处于会话号`16`，所以命令和输出看起来会是这样：
- en: '[PRE23]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'We''ve seen examples of how to get information about users and sessions. Let''s
    look at how to get information about seats. A `list-seat` command shows you all
    of the available seats:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看过如何获取有关用户和会话的信息。接下来，让我们看看如何获取关于座位的信息。`list-seat`命令会显示所有可用的座位：
- en: '[PRE24]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Unless you''ve configured one or more `udev` rules, `seat0` is the only one
    you''ll ever see. Now, use the `seat-status` option to see the hardware that this
    seat includes:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 除非你配置了一个或多个`udev`规则，否则`seat0`是你永远看到的唯一座位。现在，使用`seat-status`选项查看此座位包含的硬件：
- en: '[PRE25]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: There are several more options for getting information about users, sessions,
    and seats, but you get the idea. Besides, you can get more information from the
    `loginctl` man page.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 获取有关用户、会话和座位的信息还有其他一些选项，但你已经大致了解了。况且，你可以从`loginctl`的手册页中获取更多信息。
- en: 'Next, let''s say that for whatever reason, you want to kick Frank out of his
    session. Just use the `terminate-session` option, followed by Frank''s session
    ID number, like this:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，假设出于某种原因，你想把Frank踢出他的会话。只需使用`terminate-session`选项，后面跟上Frank的会话ID号，像这样：
- en: '[PRE26]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Here, you see that Frank''s session really has been terminated:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，你可以看到Frank的会话确实已经被终止：
- en: '[PRE27]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'If a user is logged into multiple sessions and you want to shut down all of
    their sessions, use the `terminate-user` option, like this:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一个用户登录了多个会话，并且你希望关闭所有这些会话，可以使用 `terminate-user` 选项，像这样：
- en: '[PRE28]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: There are a few other management commands that you might find useful. They're
    easy to understand, and there's a good write-up about them in the `loginctl` man
    page.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一些其他的管理命令，可能对你有帮助。它们很容易理解，并且在 `loginctl` 的手册页中有详细的说明。
- en: Next, let's cover a cool tool that can replace `sudo` in *some* instances.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们介绍一个在 *某些* 场合可以替代 `sudo` 的酷工具。
- en: Understanding polkit
  id: totrans-130
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解 polkit
- en: '`systemd-logind` does provide access to `polkit` functionality. PolicyKit was
    a **Red Hat** innovation that came on the scene quite a few years ago, and it
    could be used on various Unix-like operating systems. In 2012, a new version was
    released with the brand new name, *polkit*. The developers changed the name as
    a reminder that this is a whole new code base that isn''t compatible with the
    older version.'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: '`systemd-logind` 确实提供对 `polkit` 功能的访问。PolicyKit 是 **Red Hat** 的一项创新，出现在多年前，并且可以在各种类似
    Unix 的操作系统上使用。2012 年，发布了一个新版本，并改名为 *polkit*。开发者更改名称是为了提醒大家，这是一套全新的代码库，与旧版本不兼容。'
- en: The `polkit` service is similar to `sudo` in that it allows a normally non-privileged
    user to perform certain privileged tasks. There is, however, a big difference
    between the two.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: '`polkit` 服务与 `sudo` 类似，它允许通常没有特权的用户执行某些特权任务。不过，二者之间有一个重要的区别。'
- en: The `sudo` utility is quite easy to configure, and you can easily grant pretty
    much any admin privilege or privileges to any user. When you install the operating
    system, you'll have full `sudo` privileges for yourself, and nobody else will
    have any. On the other hand, `polkit` comes pre-configured with a set of administrative
    tasks for which it can grant root privileges. You can add more tasks, and there
    might be times when you'll want to. Keep in mind though, that writing rules and
    actions for `polkit` is more complex than writing rules for `sudo`. So, you'll
    want to study the examples that are already on the system and read the documentation
    before you try to write your own. Before we look at these rules and actions, let's
    see how `polkit` grants root privileges.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: '`sudo` 工具非常容易配置，你可以轻松地将几乎任何管理员权限授予任何用户。当你安装操作系统时，你会为自己配置完整的 `sudo` 权限，其他用户则没有权限。另一方面，`polkit`
    默认配置了一些可以授予 root 权限的管理任务。你可以添加更多任务，有时你可能会需要这样做。但请记住，编写 `polkit` 的规则和操作比编写 `sudo`
    的规则要复杂。因此，在尝试自己编写之前，你需要研究系统中已经存在的示例并阅读文档。我们在查看这些规则和操作之前，先来看一下 `polkit` 如何授予 root
    权限。'
- en: 'We''ll start with the Alma Linux machine. We need root privileges to peek into
    some of the `polkit` directories, so let''s just go to the `root` shell:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从 Alma Linux 机器开始。为了查看一些 `polkit` 目录的内容，我们需要 root 权限，所以让我们切换到 `root` shell：
- en: '[PRE29]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Now, look in the `/etc/polkit-1/rules.d/` directory:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，查看 `/etc/polkit-1/rules.d/` 目录：
- en: '[PRE30]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'The file we want is the `50-default.rules` file, which looks like this:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要的文件是 `50-default.rules` 文件，其内容如下所示：
- en: '[PRE31]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Take note of the final stanza:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意最后一行：
- en: '[PRE32]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: This means that if `polkit` detects someone trying to perform an administrative
    task without using `sudo`, it will look in the wheel group to see if anyone is
    there. If there is someone in the wheel group, then it will prompt the user to
    enter the password of that person. If the wheel group has no members, that means
    that the root user has an assigned password. If that's the case, `polkit` will
    prompt for the root user password.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着，如果 `polkit` 检测到某人试图执行管理员任务而没有使用 `sudo`，它会检查 wheel 组中是否有成员。如果 wheel 组中有成员，它将提示用户输入该成员的密码。如果
    wheel 组没有成员，则表示 root 用户已设置密码。如果是这种情况，`polkit` 会提示输入 root 用户的密码。
- en: 'On the Ubuntu machine, the files we need to see are in the `/etc/polkit-1/localauthority.conf.d/`
    directory, and we don''t need root privileges to enter it:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Ubuntu 机器上，我们需要查看的文件位于 `/etc/polkit-1/localauthority.conf.d/` 目录下，并且我们不需要
    root 权限即可访问：
- en: '[PRE33]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'The `50-localauthority.conf` file looks like this:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: '`50-localauthority.conf` 文件如下所示：'
- en: '[PRE34]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'There''s only one important line here, which looks for the root user. (That''s
    the `unix-user` with UID `0`.) The other file looks for members of the `sudo`
    or `admin` groups:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 这里只需要一行重要的内容，它会查找 root 用户（即 UID 为 `0` 的 `unix-user`）。另一个文件则查找 `sudo` 或 `admin`
    组的成员：
- en: '[PRE35]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: The biggest difference between the Red Hat and Ubuntu worlds so far is that
    on Red Hat-type systems, members of the wheel group have full sudo privileges.
    On Ubuntu systems, members of either the sudo group or the admin group have full
    sudo privileges. Now, let's see how this works.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，Red Hat和Ubuntu系统之间最大的区别是，在Red Hat类型的系统中，wheel组的成员具有完全的sudo权限。而在Ubuntu系统中，sudo组或admin组的成员拥有完全的sudo权限。现在，让我们看看它是如何工作的。
- en: 'On the Ubuntu machine, try to reload the `ssh` service without using sudo:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 在Ubuntu机器上，尝试不使用sudo重新加载`ssh`服务：
- en: '[PRE36]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'As you see, polkit asks for my password because I''m the only member of the
    sudo group. Now, let''s try using polkit to look at the firewall configuration:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，polkit要求输入我的密码，因为我是唯一一个属于sudo组的成员。现在，让我们尝试使用polkit查看防火墙配置：
- en: '[PRE37]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: It failed, because polkit isn't configured to work with the `iptables` command.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 它失败了，因为polkit没有配置为与`iptables`命令一起使用。
- en: 'Next, let''s see what happens if Pogo tries to use polkit. For it to work though,
    his password will need to be different from your own password. If it''s the same,
    change it to something else:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们看看如果Pogo尝试使用polkit会发生什么。然而，为了使其正常工作，他的密码需要与您的密码不同。如果是相同的，请将其更改为其他密码：
- en: '[PRE38]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Now, let''s have Pogo try to reload `ssh`:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们让Pogo尝试重新加载`ssh`：
- en: '[PRE39]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: As before, polkit asks for my password, because I'm a member of the sudo group
    and Pogo isn't. Pogo doesn't know my password, so he can't perform this command.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，polkit要求输入我的密码，因为我是sudo组的成员，而Pogo不是。Pogo不知道我的密码，所以他无法执行此命令。
- en: 'While we''re still on the Ubuntu machine, let''s see what some of these rules
    look like. We''ll `cd` into the `/usr/share/polkit-1/rules.d/` directory and peek
    inside the `systemd-networkd.rules` file:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们仍然使用Ubuntu机器时，让我们看看这些规则中的一些内容。我们将`cd`进入`/usr/share/polkit-1/rules.d/`目录，并查看`systemd-networkd.rules`文件：
- en: '[PRE40]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Here, we're assigning root privileges to the `systemd-networkd` system user
    account so that it can perform these three tasks without prompting for a password.
    (The `return polkit.Result.YES;` line is what prevents it from asking for a password.)
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们将root权限分配给`systemd-networkd`系统用户帐户，以便它可以在不提示密码的情况下执行这三项任务。（`return polkit.Result.YES;`这一行是防止它要求输入密码的原因。）
- en: 'For something a bit more complex, let''s `cd` into the `/usr/share/polkit-1/actions/`
    directory and peek inside one of its files. We''ll choose the `com.ubuntu.languageselector.policy`
    file, since it''s the shortest. The only part that we need to look at is the `action
    id=` section, which looks like this:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 对于更复杂的情况，让我们`cd`进入`/usr/share/polkit-1/actions/`目录，并查看其中一个文件。我们将选择`com.ubuntu.languageselector.policy`文件，因为它是最短的。我们只需要查看`action
    id=`部分，它看起来是这样的：
- en: '[PRE41]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'The `<default>` stanza at the bottom is where we define who can perform this
    action. Here''s the breakdown:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 底部的`<default>`段落是我们定义谁可以执行此操作的地方。下面是详细说明：
- en: '`<allow_any>`: This tag sets authorizations for any client machine. The `auth_admin`
    setting requires the user to enter the administrative password before the action
    can be performed.'
  id: totrans-166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`<allow_any>`：此标签设置对任何客户端机器的授权。`auth_admin`设置要求用户输入管理员密码，然后才能执行该操作。'
- en: '`<allow_inactive>`: This tag sets authorizations for clients in inactive sessions
    on the local console. It''s set to `no` here, which prevents these clients from
    having any authorization.'
  id: totrans-167
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`<allow_inactive>`：此标签设置在本地控制台上处于非活动会话中的客户端的授权。此处设置为`no`，这会阻止这些客户端获得任何授权。'
- en: '`<allow_active>`: This is for clients in an active session on the local console.
    The `auth_admin_keep` value requires that the user enter the admin password. It
    also allows the user to maintain authorization for a short period of time.'
  id: totrans-168
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`<allow_active>`：这是为处于本地控制台活动会话中的客户端设置的。`auth_admin_keep`值要求用户输入管理员密码。它还允许用户在短时间内保持授权。'
- en: The other action files are set up in a similar manner, and I'll leave it to
    you to peruse through them. For more details on the rules and actions, see the
    `polkit` man page.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 其他操作文件以类似的方式设置，我将留给你自己查看它们。有关规则和操作的更多详细信息，请参阅`polkit`的手册页。
- en: 'The polkit service is activated by a `dbus` message whenever someone tries
    to perform an administrative action that''s configured in `polkit`, as we see
    by the `Type=dbus` line in its unit file:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 每当有人尝试执行在`polkit`中配置的管理操作时，`polkit`服务都会通过`dbus`消息被激活，正如我们在其单元文件中的`Type=dbus`行所看到的那样：
- en: '[PRE42]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Okay, that does it for the Ubuntu machine. Things are pretty much the same
    on the Alma machine, except that you need root privileges to `cd` into the `rules.d/`
    directory, as we see here:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，Ubuntu机器的部分就到这里。Alma机器基本相同，不过你需要root权限才能`cd`进入`rules.d/`目录，如下所示：
- en: '[PRE43]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Now, let''s shift over to the local graphical terminal of the Alma virtual
    machine. If you''re still in the root shell, type `exit` to get back to your own
    shell. Now, try to reload `sshd`, and you''ll see a dialog box pop up to ask for
    the admin password:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们转到Alma虚拟机的本地图形终端。如果你还在root shell中，输入`exit`以返回到自己的shell。现在，尝试重新加载`sshd`，你会看到一个对话框弹出来，要求输入管理员密码：
- en: '![](img/B17491_Figure_18.3.jpg)'
  id: totrans-175
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B17491_Figure_18.3.jpg)'
- en: Figure 18.3 – The graphical polkit password dialog box
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 图18.3 – 图形polkit密码对话框
- en: Okay, I think that that's about it for polkit. Let's summarize what we've learned
    and wrap things up.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，我觉得关于polkit的内容差不多了。让我们总结一下学到的内容，完成这部分。
- en: Summary
  id: totrans-178
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: As always, we've seen some cool stuff in this chapter. We began with a discussion
    about the `systemd-logind.service` file, and saw how it's set up differently on
    the Ubuntu and Alma machines. We then looked at the `logind.conf` file, and played
    with some of its configuration options. After that, we played with `loginctl`
    and wrapped up with a discussion of polkit.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 和往常一样，本章我们学习了一些很酷的东西。我们从`systemd-logind.service`文件的讨论开始，了解了它在Ubuntu和Alma机器上的不同配置。接着我们研究了`logind.conf`文件，并尝试了一些配置选项。之后，我们玩了下`loginctl`，最后讨论了polkit。
- en: And that, guys and gals, wraps things up not only for this chapter, but also
    for the whole book. I hope that you've enjoyed our journey through the idyllic
    *land of systemd* as much as I have. Take care, and I hope to see you again soon.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 各位，今天的内容不仅仅是本章的总结，也是整本书的总结。希望你们和我一样，喜欢这趟穿越理想化的*systemd世界*的旅程。保重，期待很快再见。
- en: Questions
  id: totrans-181
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: How does the `systemd-logind` service get activated?
  id: totrans-182
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`systemd-logind`服务是如何激活的？'
- en: A. As part of the multi-user target
  id: totrans-183
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: A. 作为多用户目标的一部分
- en: B. As part of the graphical target
  id: totrans-184
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: B. 作为图形目标的一部分
- en: C. When it receives a `dbus` message
  id: totrans-185
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: C. 当它收到`dbus`消息时
- en: D. As part of the `sysinit` target
  id: totrans-186
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: D. 作为`sysinit`目标的一部分
- en: What happens when two different users remotely log into a Linux server?
  id: totrans-187
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当两个不同的用户远程登录到Linux服务器时，会发生什么？
- en: A. They both get assigned to `seat0`.
  id: totrans-188
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: A. 它们都分配给`seat0`。
- en: B. One gets assigned to `seat0` and the other gets assigned to `seat1`.
  id: totrans-189
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: B. 一个分配给`seat0`，另一个分配给`seat1`。
- en: C. They both get assigned to `seat1`.
  id: totrans-190
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: C. 它们都分配给`seat1`。
- en: D. Neither of them gets an assigned seat.
  id: totrans-191
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: D. 它们都没有分配座位。
- en: In which of the following files does `systemd-logind` look to find out how to
    do user authentication?
  id: totrans-192
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下哪一文件中`systemd-logind`会查看如何进行用户认证？
- en: A. `/etc/nsswitch.conf`
  id: totrans-193
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: A. `/etc/nsswitch.conf`
- en: B. `/etc/default/nsswitch.conf`
  id: totrans-194
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: B. `/etc/default/nsswitch.conf`
- en: C. `/etc/sysconfig/nsswitch.conf`
  id: totrans-195
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: C. `/etc/sysconfig/nsswitch.conf`
- en: D. `/etc/authenticate.conf`
  id: totrans-196
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: D. `/etc/authenticate.conf`
- en: Which of the following statements is true about polkit?
  id: totrans-197
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 关于polkit，以下哪个说法是正确的？
- en: A. In its default configuration, it works with only a pre-defined set of administrative
    commands.
  id: totrans-198
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: A. 在默认配置下，它只与预定义的一组管理命令一起工作。
- en: B. In its default configuration, it works with all administrative commands,
    just as sudo does.
  id: totrans-199
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: B. 在默认配置下，它与所有管理命令一起工作，就像sudo一样。
- en: C. It only works with the root user password.
  id: totrans-200
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: C. 仅适用于root用户密码。
- en: D. It can only be used on text-mode machines.
  id: totrans-201
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: D. 只能在文本模式机器上使用。
- en: Answers
  id: totrans-202
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 答案
- en: C
  id: totrans-203
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: C
- en: D
  id: totrans-204
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: D
- en: A
  id: totrans-205
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: A
- en: A
  id: totrans-206
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: A
- en: Further reading
  id: totrans-207
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: 'The SSSD home page: [https://sssd.io/](https://sssd.io/ )'
  id: totrans-208
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'SSSD主页: [https://sssd.io/](https://sssd.io/ )'
- en: 'An explanation of seats and sessions: [https://www.man7.org/linux/man-pages/man3/sd-login.3.html](https://www.man7.org/linux/man-pages/man3/sd-login.3.html
    )'
  id: totrans-209
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '关于座位和会话的解释: [https://www.man7.org/linux/man-pages/man3/sd-login.3.html](https://www.man7.org/linux/man-pages/man3/sd-login.3.html
    )'
- en: 'The polkit reference manual: [https://www.freedesktop.org/software/polkit/docs/latest/polkit.8.html](https://www.freedesktop.org/software/polkit/docs/latest/polkit.8.html)'
  id: totrans-210
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'polkit参考手册: [https://www.freedesktop.org/software/polkit/docs/latest/polkit.8.html](https://www.freedesktop.org/software/polkit/docs/latest/polkit.8.html)'
