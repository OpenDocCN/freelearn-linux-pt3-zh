- en: '*Chapter 3*: Using Commands and Services for Process Management'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Managing processes is an important job of a Linux system administrator. That
    can be for a variety of reasons – maybe some processes got stuck and we need to
    finish them, or we want to set some process(es) to work in the background or even
    to be started periodically or at a later date. Whatever the scenario is, it's
    important to know how to administer processes and make them do the work that needs
    to be done efficiently and with regard to other processes running on the system.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we are going to learn about the following recipes:'
  prefs: []
  type: TYPE_NORMAL
- en: Process management tools
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Managing background jobs
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Managing process priorities
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Configuring `crond`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'For these recipes, we''re going to use a Linux machine – we can use any virtual
    machine from our previous recipes. Again, we can just continue using the `cli1`
    machine that we used in the previous chapter. So, to sum this up, we need the
    following:'
  prefs: []
  type: TYPE_NORMAL
- en: A virtual machine with Linux installed, any distribution (in our case, it's
    going to be Ubuntu 20.10)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: So, start your virtual machine and let's get cracking!
  prefs: []
  type: TYPE_NORMAL
- en: Process management tools
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Managing processes means learning about the ways in which processes work and
    the specific text-mode tools that we can use to manage them. We are going to start
    by introducing some simple concepts – explain what processes are and which states
    they can be in – and then we're going to move on to commands and how to use them
    to manage processes from an administrative standpoint. That means that we are
    going to learn 10+ new commands/concepts that are necessary to understand how
    all of this works.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The vast majority of commands and utilities that we are going to use in this
    recipe come pre-installed with our Linux distribution. That being said, there
    are a couple of cool additional tools we can use to further drive the point of
    managing processes and system resources home. So, let''s install one more utility
    as it''s capable of being used as a tool to monitor system resources along with
    low-level stuff, such as working with processes. It''s called `glances`; let''s
    install it by typing the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: That should cover everything that we need in this recipe, so let's get cracking!
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The first two commands that we must cover are `ps` and `top`. These are commands
    that Linux system administrators use dozens of times on a daily basis if they're
    managing a Linux server. Both of these commands are very valuable, as we can get
    a lot of information about our system if we know how to use them properly, especially
    `ps`.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, let''s first use `ps` as a command without any additional options (of which
    there are many):'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.1 – Default ps command output'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_3.1_B16269.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 3.1 – Default ps command output
  prefs: []
  type: TYPE_NORMAL
- en: By default, `ps` gives us a report about currently running processes. By starting
    it in a shell without any additional options, we can get a list of processes running
    in our current shell. We can already see some interesting information in this
    output. For starters, we can see five processes and their IDs (the `PID` field
    on the left side). Then, we can see where they're running, which is what the `TTY`
    field is all about. The `TIME` field tells us how much accumulated CPU time the
    process has used so far. Furthest to the right, we can see the `CMD` field, which
    tells us the name of an actual process that was started.
  prefs: []
  type: TYPE_NORMAL
- en: 'To fully appreciate the power of the `ps` command, we really need to look to
    its man page. There''s a really nice `EXAMPLES` section in it. Here''s an excerpt
    from that section:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.2 – Example for using the ps command'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_3.2_B16269.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 3.2 – Example for using the ps command
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s use an extreme derivative of one of these examples. Let''s type the
    following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'We used the `| less` part of this command to output just the first page of
    the `ps` command output. The output should look something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.3 – ps auwwx command output (much more verbose)'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_3.3_B16269.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 3.3 – ps auwwx command output (much more verbose)
  prefs: []
  type: TYPE_NORMAL
- en: 'As we can clearly see, there''s a lot more detail in this output sorted by
    `PID`. Some of the newly added fields include the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '`USER`: This field tells us the name of the user who started the process.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`%CPU`: This field tells us how much CPU time the process uses.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`%MEM`: This field tells us how much memory the process uses.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`VSZ`: This field tells us how much virtual memory the process uses.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`RSS`: Resident Set Size, the amount of non-swapped memory used by the process.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`STAT`: Process status code.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`START`: Time when the process was started.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Just as an example, a lot of system administrators use the `%CPU` and `%MEM`
    fields to find processes that are using too much CPU or memory.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s say that we need to find a process by name. There are multiple ways
    of doing this, the most common two being using either the `ps` command or the
    `pgrep` command. Let''s see how that would work:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.4 – Using pgrep or ps to find a process by name'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_3.4_B16269.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 3.4 – Using pgrep or ps to find a process by name
  prefs: []
  type: TYPE_NORMAL
- en: 'As a command, we tend to use `grep` to create a filter that will find a text
    sample by going through text output. We can see that both commands gave us the
    result that we needed – it''s just formatted differently and with a different
    level of detail. We can also use the `pidof` command to find a PID for any given
    process, similar to `pgrep`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.5 – Using the pidof command'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_3.5_B16269.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 3.5 – Using the pidof command
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s now explain the idea of the `top` command. After we start the `top`
    command, we should get something similar to this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.6 – Using the top command'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_3.6_B16269.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 3.6 – Using the top command
  prefs: []
  type: TYPE_NORMAL
- en: 'There are multiple things happening in this interactive output at the same
    time:'
  prefs: []
  type: TYPE_NORMAL
- en: The `top` line is actually output from the `uptime` command. If we add the next
    four lines (beginning with `Tasks`, `%Cpu(s)`, `Mib Mem`, and `MiB Swap`), that
    is what we call the top *summary area*.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: After that, we can clearly see that `top` acts as a frontend to the `ps` command
    but is implemented in an interactive sense.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The interactive part of the `top` command stems from the fact that it actually
    refreshes regularly – by default, every 3 seconds. We can change that default
    refresh interval by pressing the *S* key, which will make `top` ask us to change
    the delay from `3.0` to any number. If we want to change the refresh interval
    to `1` second, we just press `1` and *Enter*.
  prefs: []
  type: TYPE_NORMAL
- en: We can ask `top` to show us processes by a single user (by pressing *U* and
    typing in the user's login name) and to kill processes (by pressing *K* and typing
    in the PID and the signal we want to send to that PID). We can also manipulate
    process priority, which we will cover in our *third* recipe of this chapter. All
    in all, `top` is a very useful and often-used command to do process management.
    It acts as a frontend to many different commands, such as `nice`, `renice`, and
    `kill`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The next set of commands that we need to learn about is `kill` and `killall`.
    We shouldn''t use the literal translation of these utilities to try to instinctively
    understand what they do as we''ll be surprised that that translation doesn''t
    apply. Specifically, the `kill` command is used when we want to kill a process
    by its corresponding PID. `killall`, in contrast, is used to kill processes by
    name. There are – of course – viable use cases for both. To show an example for
    both of these commands, we are going to use the following `top` output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.7 – top output – notice the top command being started twice by the
    student user'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_3.7_B16269.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 3.7 – top output – notice the top command being started twice by the
    student user
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s kill both of these `top` processes in a separate shell. If we want to
    kill the first one by using the `kill` command, we need to type the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'If we want to kill all of the started `top` commands by name, we can type the
    following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'When using the `kill` command, we''re killing a single PID. When using the
    `killall` command, we are killing all the started `top` processes. Of course,
    in order for us to be able to kill a process by using either of these commands,
    we have to log in as either root or `student`. Only the user that started the
    process and root can kill a user process. We need to remember that the default
    signal of both of these commands is the `SIGTERM` signal (signal number `15`).
    If we want to kill a process by using a custom signal, we can achieve that by
    adding that number to any of these two commands preceded by a minus sign. Here''s
    an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: This will send the `SIGKILL` signal to the process. Both of these signals are
    explained in the *How it works…* section of this recipe.
  prefs: []
  type: TYPE_NORMAL
- en: 'It''s also good to note the fact that sometimes we need to find the PID of
    a currently running shell or a parent PID of a shell. We can do that by using
    the following two commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.8 – PID of our current shell process, the parent process'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_3.8_B16269.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 3.8 – PID of our current shell process, the parent process
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s now check how `glances` can help us check what''s happening with our
    system. If we just start the command, we''re going to get the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.9 – glances default output'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_3.9_B16269.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 3.9 – glances default output
  prefs: []
  type: TYPE_NORMAL
- en: 'It''s easy to see the level of detail, as well as the different formats, that
    `glances` uses. Furthermore, we really appreciate the fact that it uses color
    output as default, which makes the information a bit easier to read. We can go
    into different methods of displaying data. For example, we can type `1` to switch
    between per-CPU core versus aggregated statistics. We can also use it in server
    mode (by starting it with the `-s` switch) so that we can monitor remote hosts.
    So, from the server perspective, we would start it with the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'From the client perspective, we would start `glances` with the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: '`glances` is cross-platform (it''s Python-based), as it supports Linux, OS
    X, Windows, and FreeBSD. It also has a built-in web UI that can be used via a
    web browser if we''re more into using the GUI than the CLI. But one of the most
    convenient features that it has is the ability to export data in various different
    formats – CSV, Elasticsearch, RabbitMQ, Cassandra, and others.'
  prefs: []
  type: TYPE_NORMAL
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A process is a unit of command execution that an operating system initializes
    so that it can be managed both from the operating system standpoint and from our
    standpoint as system administrators. That means that a process acts like an instance
    of any given program, and it has some common properties (state, PID, and many
    others that we will describe in this chapter), as well as some tasks that it needs
    to do. For example, after we start a command (`process`), that command can open
    and read from the file, user input, or other programs, do something with that
    input, and then terminate after the work is done.
  prefs: []
  type: TYPE_NORMAL
- en: It is important to note that processes aren't *paused* if we reboot a machine
    – they get stopped and then start as our Linux machine boots or we start it manually
    after the reboot. So, *there's no process persistence across reboots*. Most of
    the time (except for most of the processes that are a part of the operating system
    startup procedure), they don't even keep the same PID across a reboot.
  prefs: []
  type: TYPE_NORMAL
- en: 'In terms of process types, we have five different types:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Parent and child processes**: In simple terms, a parent process is a process
    that creates additional processes that we call child processes. Child processes
    exit when the parent process exits. A parent process doesn''t exit if a child
    process exits.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Zombie and orphan processes**: There are situations where the parent process
    gets killed before the child process exits. The remaining child process is called
    an orphan process. On the other hand, a zombie process is a situation where a
    process is killed but still exists in the process table.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Daemons**: Daemons are usually related to some system tasks that usually
    involve working with other processes and servicing them. They also don''t use
    a terminal as they run in the background.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In terms of states, we have these:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Running/runnable**: Running state refers to a state where a process is being
    executed by a CPU. Runnable state, on the other hand, means that a process is
    ready to be executed but is currently not consuming CPU or queued to be executed
    by a CPU.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Interruptible/uninterruptible sleep**: In an interruptible sleep state, a
    process can be awakened and it can accept **signals** aimed at it. In an uninterruptible
    sleep state, that doesn''t happen, and the process remains asleep. This scenario
    often includes a **system call** – a process can''t do a system call and can''t
    be paused or killed until it finishes its job.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Stopped**: A process is often stopped when it receives a signal and when
    we''re debugging a process.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Zombie**: A dead process that''s been halted but still exists in the process
    table is in a zombie state.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: From the operating system perspective, processes are units of execution – for
    a program or service. Processes get scheduled by the operating system and that
    means assigning them resources so that they can run from a programmatic perspective
    (context), and some basic attributes so that they can be managed from the system
    administrative perspective. That includes creating an entry in a process table
    with a PID (number of the process) and other types of attribute data. We are going
    to explain these attributes and how to notice process states a bit later in this
    chapter, when we start discussing practical aspects of working with commands such
    as `top` and `ps`.
  prefs: []
  type: TYPE_NORMAL
- en: 'We mentioned the concept of a signal. When we''re dealing with different ways
    of establishing communication between a kernel and userspace program, there are
    two ways of achieving that – via either a system call or a signal. Usually, we
    use commands such as `kill` or `killall` if we want to send a signal to a process
    by assigning a signal number or name along with the command. Let''s take a look
    at an excerpt from the signal list:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.10 – Excerpt from the signal man page'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_3.10_B16269.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 3.10 – Excerpt from the signal man page
  prefs: []
  type: TYPE_NORMAL
- en: 'As we can see, there are many of them, and approximately 30 of these signals
    have been implemented by the Linux kernel. Also, there are two types of signals
    from the process perspective:'
  prefs: []
  type: TYPE_NORMAL
- en: '`SIGHUP` signal (number 1)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`SIGKILL` signal (number 9)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The word *handled* is used in a programmatic sense here – handling something
    means using some kind of *handler* to write a piece of code that's going to intercept
    the signal message and redirect it to something, such as a function or subroutine.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are major differences between these two types. Let''s use an example
    of a daemon process such as an *Apache web server*. If a daemon process receives
    the `SIGHUP` signal and it supports it (it has a routine in its source code handling
    the `SIGHUP` signal, like Apache does), the most common thing that it will do
    after receiving `SIGHUP` is to refresh its state by re-reading its configuration.
    To quote the Apache manual:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Sending the HUP or restart signal to the parent causes it to kill off its
    children like in TERM, but the parent doesn''t exit. It re-reads its configuration
    files, and re-opens any log files. Then it spawns a new set of children and continues
    serving hits*.'
  prefs: []
  type: TYPE_NORMAL
- en: Unlike this scenario, when you send the `SIGKILL` signal to Apache, it will
    be terminated without giving any regard to refreshing its configuration, content,
    or anything of the sort. We can't write a handle to redirect this signal to anything
    other than the process being killed. We can think of it as a *kernel sucking the
    life out of a process* type of scenario, as the process can't get access to resources
    to run and is effectively eradicated by the system (kernel).
  prefs: []
  type: TYPE_NORMAL
- en: The third commonly used signal is `SIGTERM` (number 15). It's also used to terminate
    the process (such as `SIGKILL`), but it does it in a graceful way. We can think
    of it as a *Hello, Mr. Process, would you please be so kind as to terminate yourself
    gracefully? Thank you very much!* message from the kernel. Then the process does
    what it needs to do and shuts itself down.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we've had a brief primer on how processes and signals work, let's continue
    our quest for knowledge about processes by learning about the management of background
    processes. As we already explained the basics of background processes, that shouldn't
    be a difficult task.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'If you need more information about processes, signals, and similar concepts,
    make sure that you check out the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Basics of Linux processes**: [http://www.science.unitn.it/~fiorella/guidelinux/tlk/node45.html](http://www.science.unitn.it/~fiorella/guidelinux/tlk/node45.html%0D)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Linux command basics** – Seven commands for process management: [https://www.redhat.com/sysadmin/linux-command-basics-7-commands-process-management](https://www.redhat.com/sysadmin/linux-command-basics-7-commands-process-management%0D)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Signal man page**: [https://man7.org/linux/man-pages/man7/signal.7.html](https://man7.org/linux/man-pages/man7/signal.7.html%0D)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Basics of glances**: [https://www.tecmint.com/glances-an-advanced-real-time-system-monitoring-tool-for-linux/](https://www.tecmint.com/glances-an-advanced-real-time-system-monitoring-tool-for-linux/%0D)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**TLDP Chapter 4: Processes**: [https://tldp.org/LDP/tlk/kernel/processes.html](https://tldp.org/LDP/tlk/kernel/processes.html%0D)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Managing background jobs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are various types of situations where we would like to start a process
    and run it in the background. For example, let's say that we want to start a process,
    log off, and then come back tomorrow and check the result of that process. Let's
    learn how this works by using an example.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Keep the `cli1` virtual machine powered on and let's use the shell to explain
    how the idea of a background process works, as opposed to a foreground process.
    We will make sure that we also explain the concept in the *How it works…* section.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let's imagine a scenario in which we want to download a large file by using
    shell tools. The *usual suspect* that we'd use for this kind of task in Linux
    is a program called `wget`. We want to start a `wget` session (`wget` is a `shell`
    command that enables us to download files from the `http` and `ftp` URIs) to download
    a large ISO file, but we want to log off (or do something else) while the download
    is taking place. This is achieved by putting the `wget` process in the background.
    This is just one common example of using a background process to our advantage.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we need to install `wget`. Let''s do that by using the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: '`wget` is a common utility, and it''s mostly installed by default. But either
    way, by using this command, we''ll make sure that it''s installed.'
  prefs: []
  type: TYPE_NORMAL
- en: Let's use the `Ubuntu 20.04 ISO` file as the file that we want to download by
    using two examples. The first one is going to be running `wget` as a *foreground*
    process, and the second one is going to be running `wget` as a *background* process.
    The second example can actually be done in two different ways as `wget` has a
    built-in option that can be used to put it in the background. Of course, as we're
    trying to explain the *system-wide* concept, not a specific utility, let's make
    sure that we do both.
  prefs: []
  type: TYPE_NORMAL
- en: 'At the time of writing, the `Ubuntu 20.04 ISO` file can be found here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://releases.ubuntu.com/20.04/ubuntu-20.04.3-live-server-amd64.iso](https://releases.ubuntu.com/20.04/ubuntu-20.04.3-live-server-amd64.iso%0D)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s use `wget` to download it as a foreground process, by typing in the
    following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'The result should look something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.11 – Foreground process – exclusively locks the shell access'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_3.11_B16269.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 3.11 – Foreground process – exclusively locks the shell access
  prefs: []
  type: TYPE_NORMAL
- en: 'As we can clearly see, the download is working, but the problem is the fact
    that for the next 12+ minutes, we can''t do anything in this shell, as the underlying
    shell session is being exclusively used by `wget`. We can''t write commands, get
    command results – nothing. The only thing that we could do to prevent that would
    be to use a *Ctrl* + *C* sequence to quit the download and be thrown into the
    shell. But that''s not what we want to do. What we want to do is the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Start the download.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Be thrown back into the shell with the download still working.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'This is a situation in which running a process as a background task can be
    very helpful. So, let''s add one additional parameter to the previous command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'The `&` sign at the end of this command tells the kernel to put this process
    in the background. Let''s see what the end result is:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.12 – Starting the process in the background'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_3.12_B16269.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 3.12 – Starting the process in the background
  prefs: []
  type: TYPE_NORMAL
- en: We can clearly see that we've been thrown back into the shell (`root@cli1` prompt)
    and that we can keep writing additional commands. We can also see that a `wget`
    process was started with PID `43787`, which we could use to issue a `kill` command
    if we so choose.
  prefs: []
  type: TYPE_NORMAL
- en: Obviously, we can issue multiple commands with `&` at the end, and then we'd
    have multiple processes running in the background. This is where the `[1]` part
    of the previous output comes in handy. This number represents an index number
    assigned to the background process. In other words, the `wget` that we started
    with PID `43787` is the first background process. If we were to start multiple
    background processes, each new background process would get the next number –
    `2`, `3`, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: 'Obviously, we need to learn how to manage multiple background jobs. This is
    what the `jobs` command is all about. Let''s see how that works. First, we are
    going to start multiple background jobs:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.13 – Starting multiple background processes'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_3.13_B16269.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 3.13 – Starting multiple background processes
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, let''s use the `jobs` and `kill` commands to work out which background
    jobs we have and kill them by index (not by using their PID). This is the way
    to do it:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.14 – Checking and killing multiple background processes'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_3.14_B16269.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 3.14 – Checking and killing multiple background processes
  prefs: []
  type: TYPE_NORMAL
- en: 'By using the `kill %index_number` syntax, we were able to kill background jobs
    by their index number, instead of their PIDs. This syntax is shorter and shouldn''t
    be discounted in everyday life as it makes a lot of things easier – as long as
    we don''t log off. If we log off, the whole idea changes a bit as we can''t access
    these processes by using their index numbers, but we can definitely manage them
    by using PIDs. So, let''s imagine for a second that we started two `wget` sessions
    as background processes, and then logged off and logged back on. Let''s try to
    list these processes as background processes, then as just regular, general processes,
    and kill them by PID. This is what happens after that:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.15 – jobs provides no output, but the ps command does'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_3.15_B16269.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 3.15 – jobs provides no output, but the ps command does
  prefs: []
  type: TYPE_NORMAL
- en: We can clearly see that the `jobs` command provides no output (can't find index
    numbers of background jobs), but our processes are still running. Why? Well, background
    processes that we started were created in the shell that's no longer active. After
    we logged off, we started a new shell, and, because of the way in which the `jobs`
    command works, we can't see those background jobs anymore. But we can definitely
    see them as processes running on the system, and, if we want to do so, we can
    kill them successfully by using their PIDs, as we did with the `kill` command.
    We used the `ps` command here and filtered its output by using `grep` – a command
    that is able to search specific pieces of text from a text-based output (in our
    case, we were searching through the whole table of processes by using `ps` `auwwx`,
    created a serial pipeline by using the pipe sign ( `|` ), and then threw the output
    from the `ps` command in the `grep` command.
  prefs: []
  type: TYPE_NORMAL
- en: 'We mentioned that the `wget` command has the capability to start itself in
    the background by using a command-line option (`-b`). This is not all that common,
    but it''s definitely useful. So, say we were to use the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'This should be the end result:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.16 – wget can be started in the background by using the -b switch'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_3.16_B16269.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 3.16 – wget can be started in the background by using the -b switch
  prefs: []
  type: TYPE_NORMAL
- en: 'What''s really interesting about this procedure is the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '`wget` clearly states that it''s starting itself in the background, but it
    doesn''t give us an index number.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If we use the `jobs` command, we can't see it as a background process.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We can kill it by using regular means, a `kill` command.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'This is a bit of a different concept, as `wget` effectively achieves this `jobs`
    *command invisibility* by creating a `wget` child process and terminating the
    parent process. Since the parent process is no longer there, it''s no longer associated
    with a specific shell, and therefore not indexed. The result is that it''s not
    visible in the jobs table for the current shell. We can achieve something similar
    by using the `disown` command. Let''s start a process in the current shell, and
    then do the thing that `wget` basically does:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.17 – Disowning a background process'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_3.17_B16269.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 3.17 – Disowning a background process
  prefs: []
  type: TYPE_NORMAL
- en: There are other ways of making sure that a process goes to the background. The
    most common scenario is we want to start a process in the background, we forget
    to put the `&` sign at the end of our command, and we're stuck with the foreground
    process. What to do then?
  prefs: []
  type: TYPE_NORMAL
- en: 'The answer is simple – we press *Ctrl* + *Z* (to put the process in the suspended
    state), and then type in the `bg` command. It''s going to put the process in the
    background, as if we started it with the `&` sign from the start. Combining all
    of that with `jobs`, `disown` and `kill` would look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.18 – Using Ctrl + Z and bg to put a process in the background'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_3.18_B16269.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 3.18 – Using Ctrl + Z and bg to put a process in the background
  prefs: []
  type: TYPE_NORMAL
- en: We started `wget` in the foreground and put it in a suspended state by typing
    *Ctrl* + *Z*. Then, we moved that process to the background by using the `bg`
    command. Since it's job number `1` in our shell, we disowned it, used `ps` to
    find its PID, and killed it.
  prefs: []
  type: TYPE_NORMAL
- en: 'If, for some reason, we wanted to go from the background to the foreground
    with a process (providing that it has an index number and was started in the current
    shell), we can do that by using the `fg` command. So, if we use the previous procedure
    as an example, it would look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.19 – Using Ctrl + Z, bg, and fg to move a process to the background
    and back to the foreground'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_3.19_B16269.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 3.19 – Using Ctrl + Z, bg, and fg to move a process to the background
    and back to the foreground
  prefs: []
  type: TYPE_NORMAL
- en: We can clearly see that the `wget` process went to the background (*Ctrl* +
    *Z* and `bg` commands), then went to the foreground (the `fg` command), and was
    terminated at the end by using *Ctrl* + *C*. If we have multiple background processes
    in our current shell, we can also use indexing with the `fg` command (`fg index_number`).
  prefs: []
  type: TYPE_NORMAL
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Processes can run in two different ways:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Foreground**: If we start a process from the shell, that process is going
    to occupy our current shell and will not allow us to type in additional commands.
    A kind of exception to that rule is a scenario in which the started process requires
    additional user input, but that input needs to be baked into the core of the process
    that we''re executing (a part of the programming code). In this scenario, the
    shell is exclusively used by the started process until either the process finishes,
    we put it in the background, or it gets killed by other external factors (such
    as other processes or the kernel, or if it crashes for some reason).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Background**: If we start a process in the background, it runs and frees
    up our shell so that we can continue using it to type other commands.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When a process goes to the background in the current shell, it gets an index
    number so that we have the capability to manage it by using its index number.
    We can use `fg`, `kill`, and similar commands by using this index number (for
    example, `kill %1` would kill the first job in the job index table).
  prefs: []
  type: TYPE_NORMAL
- en: As we saw in our practical demonstration, there are multiple ways of making
    sure that processes are started in the background – either when they are started
    or after they are started. What makes this concept plausible is the fact that
    we can easily put processes in the background, to be handled by the operating
    system, while we're away from it, which sometimes means freeing our precious time.
  prefs: []
  type: TYPE_NORMAL
- en: There's more…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'If we need to learn more about foreground and background processes, we can
    check the following links:'
  prefs: []
  type: TYPE_NORMAL
- en: '`jobs`, `bg`, and `fg`: [https://www.redhat.com/sysadmin/jobs-bg-fg](https://www.redhat.com/sysadmin/jobs-bg-fg%0D)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Linux command basics** – seven commands for process management: [https://www.redhat.com/sysadmin/linux-command-basics-7-commands-process-management](https://www.redhat.com/sysadmin/linux-command-basics-7-commands-process-management)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Managing process priorities
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'When we were explaining how to work with the `top` command, we intentionally
    omitted some details to give them their own time and place to discuss them later
    on in this chapter. We''ll discuss one of these details here: the difference between
    the `PR` and `NI` fields in the `top` output. Let''s do that now.'
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Keep the `cli1` virtual machine powered on and let's continue using our shell.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We are going to learn how to use the `top`, `nice`, and `renice` commands to
    manage process scheduling in accordance with our wishes. First, let''s use the
    `top` command. Let''s `renice` a running process to a more negative value and
    a more positive value. Let''s use the following `top` output for that:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.20 – Starting point – processes started by the student user'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_3.20_B16269.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 3.20 – Starting point – processes started by the student user
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s now change the priority of the process with PID `47160` (`top`). Press
    the *R* key and the `top` output will change this output to something such as
    the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.21 – Let''s renice a PID'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_3.21_B16269.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 3.21 – Let's renice a PID
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, again, type in the number `47160` and press *Enter*, followed by the
    niceness level – let''s say, `-10`. We should get something like this as a result:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.22 – End result – more negative niceness level, higher priority'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_3.22_B16269.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 3.22 – End result – more negative niceness level, higher priority
  prefs: []
  type: TYPE_NORMAL
- en: We can clearly see that the `NI` field of our PID changed from `0` to `-10`.
    Since we gave it a more negative niceness level, that means higher priority.
  prefs: []
  type: TYPE_NORMAL
- en: 'This example explains how to `renice` an already running process. But clearly,
    we can''t use that to set the niceness level before we start the process. That''s
    why we have the `nice` command. Here''s an example of using the `nice` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'If we start this command as root and check the output, after we give it a bit
    of time, we should see something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.23 – Using nice to pre-assign priority to a process at process start'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_3.23_B16269.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 3.23 – Using nice to pre-assign priority to a process at process start
  prefs: []
  type: TYPE_NORMAL
- en: Obviously, there's a caveat here – if we tried to start this command as a regular
    user, that wouldn't work. Regular users don't have a right to use the `nice` command
    – imagine how many different possibilities of abusing the system and/or crashing
    it would be given to any user if they did have that right. There are ways around
    this if we want to give the right to use the `nice` command to some users – we
    can do it via PAM modules or the `sudo` system. But for the time being, let's
    agree that this is not something that needs to be *urbi et orbi*, just as an exception.
  prefs: []
  type: TYPE_NORMAL
- en: Let's now explain how these concepts work.
  prefs: []
  type: TYPE_NORMAL
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s start by executing the `top` command and checking the important part
    of its output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.24 – top output related to process priority'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_3.24_B16269.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 3.24 – top output related to process priority
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s briefly explain the difference between these two fields:'
  prefs: []
  type: TYPE_NORMAL
- en: '`PR` (priority field): Real, kernel-scheduled priority at the moment of looking,
    assigned by the kernel. The `rt` mark means real time; it ranges between `0` and
    `139`, although it can have negative static values for real-time processes.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`NI` (niceness field): The process priority that it should have, assigned in
    user space (not kernel space) by default or by additional commands (`nice` and
    `renice`). The lower the number, the higher the priority, on a scale from `-20`
    to `+19`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Obviously, there's a big difference between these two numbers, seeing that one
    of them is *the real deal* (`PR`) and the other one is like *advice* (`NI`). Explaining
    process priorities is relatively easy in theory, but it becomes a bit more challenging
    to put into practice because of some architectural reasons. So, we'll try to explain
    this with an example that used to be possible but is not anymore as the speed
    of modern CPUs and memory is many times over what it used to be 10 years ago.
    So, let's first discuss the theoretical concept and then use an example.
  prefs: []
  type: TYPE_NORMAL
- en: Theoretically speaking, when we use the `nice` and `renice` commands, what we're
    doing is assigning a specific amount of CPU context to a process – a running one
    (`renice`) or a soon-to-be-running one (`nice`). We use the word *context* here
    in a programmatic sense from a CPU perspective. Translation – if we want to run
    a process, the kernel needs to assign it some CPU. If we have a running process
    and we `renice` it to a more negative value, that is going to tell the kernel
    and its scheduler to pay more attention to that specific process, therefore giving
    it more access to the CPU. If we `renice` it to a more positive value, that's
    going to tell the kernel to pay less attention to giving CPU resources to that
    process. By assigning more CPU to a process, there's a chance that that process
    is going to work faster and do its job faster as a result.
  prefs: []
  type: TYPE_NORMAL
- en: Obviously, this is a bit of a simplification as there are other factors at play
    here. For example, every process needs some memory to work, and the busier the
    memory is with other processes, the less speed the process has to access memory
    content, therefore lowering the memory bandwidth and increasing the latency of
    memory access. So, assigning a more negative value to niceness doesn't always
    directly translate to more performance out of a process. Also, what if the process
    doesn't need more CPU as it's currently idling and not doing anything of significance?
    There can be many more factors here – **Non-Unified Memory Access** (**NUMA**)
    operating system/application compatibility, effective usage of multiple threads/cores,
    locking mechanisms, and others. So, this is more of a general, academic discussion
    that can have exceptions that can happen for a variety of reasons, the state of
    the system being one of the most common ones.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we've taken care of the theoretical background, let's use an example
    that used to be very easy to demonstrate as a lot of people had these sorts of
    experiences in the past, when CPU and memory were much, much less capable than
    they are today.
  prefs: []
  type: TYPE_NORMAL
- en: 10 years ago, if we were to use an average computer of the day to display a
    high-resolution Flash video from YouTube, we had a problem. CPUs were kind of
    strong enough to do that, but only just. So, in order for us to be able to watch
    them in Linux by using a web browser (for example, Firefox), we had to tune the
    system to do it. So, we started the web browser, found a video that we wanted
    to watch, and pressed the *play* button, and it would work for a couple of seconds
    and then stutter. Then, it would work again, then stutter again. This was a frustrating
    experience. In those days, we didn't have GPU acceleration for Flash, so the CPU
    was the only device that could be of any assistance in these scenarios.
  prefs: []
  type: TYPE_NORMAL
- en: But if we knew how to set process priority, we could've solved that problem
    in most cases, depending on the CPU speed. We could go to the shell, find the
    PID of the Firefox process, and `renice` it to a much more negative value. All
    of a sudden, the kernel would instruct its scheduler to pay more attention to
    Firefox as a process, and lo and behold – our video would stop stuttering. Why?
    Because the kernel – by virtue of us using the `renice` command – realized that
    we wanted to give that process more priority and therefore ordered the CPU scheduler
    to make it happen.
  prefs: []
  type: TYPE_NORMAL
- en: There are many more aspects of tuning CPU performance. Modern Linux distributions
    have many options for this as the kernel gets more and more programmatic in terms
    of its approach to CPU scheduling. That's why various Linux distributions introduced
    concepts such as **tuned**, a profile-driven system that's able to tune our system
    performance based on pre-assigned or manually created profiles, and **tuna**,
    a utility that enables deep application-specific tuning. We always need to have
    the capability to go deep with tuning so that our system can have optimized performance
    for any specific use case.
  prefs: []
  type: TYPE_NORMAL
- en: There's more…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'If we need to learn more about these concepts, we can check the following links:'
  prefs: []
  type: TYPE_NORMAL
- en: '**A guide to the Linux top command**: [https://www.booleanworld.com/guide-linux-top-command/](https://www.booleanworld.com/guide-linux-top-command/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**CPU scheduling**: [https://access.redhat.com/documentation/en-us/red_hat_enterprise_linux/6/html/performance_tuning_guide/s-cpu-scheduler](https://access.redhat.com/documentation/en-us/red_hat_enterprise_linux/6/html/performance_tuning_guide/s-cpu-scheduler)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**top man page**: [https://man7.org/linux/man-pages/man1/top.1.html](https://man7.org/linux/man-pages/man1/top.1.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**nice man page**: [https://man7.org/linux/man-pages/man1/nice.1.html](https://man7.org/linux/man-pages/man1/nice.1.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**renice man page**: [https://man7.org/linux/man-pages/man1/renice.1.html](https://man7.org/linux/man-pages/man1/renice.1.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Getting started with tuned**: [https://access.redhat.com/documentation/en-us/red_hat_enterprise_linux/8/html/monitoring_and_managing_system_status_and_performance/getting-started-with-tuned_monitoring-and-managing-system-status-and-performance](https://access.redhat.com/documentation/en-us/red_hat_enterprise_linux/8/html/monitoring_and_managing_system_status_and_performance/getting-started-with-tuned_monitoring-and-managing-system-status-and-performance)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Reviewing a system using the tuna interface**: [https://access.redhat.com/documentation/en-us/red_hat_enterprise_linux/8/html/monitoring_and_managing_system_status_and_performance/reviewing-a-system-using-tuna-interface_monitoring-and-managing-system-status-and-performance](https://access.redhat.com/documentation/en-us/red_hat_enterprise_linux/8/html/monitoring_and_managing_system_status_and_performance/reviewing-a-system-using-tuna-interface_monitoring-and-managing-system-status-and-performance)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Configuring crond
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Having the capability to run jobs on a schedule is very important for everyday
    system administration. We schedule backups, run cleanup procedures, send reports,
    do antivirus checks, and do other tasks that business procedures need. Scheduling
    them means a certain level of automation and getting rid of the manual approach
    to things, which in turn again gives us more time to focus on more important tasks.
    Generally speaking, we use either commands or scripts as a way to do these scheduled
    tasks, and to execute them, we use `cron daemon` (`crond`). Let's learn how to
    use `crond` to schedule jobs in accordance with our needs.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Keep the `cli1` virtual machine powered on and let's create some scheduled jobs
    via `crond`.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s start by using root to create a cron job. We are going to achieve that
    by typing in the following command as root:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'In Ubuntu, we are going to be asked to select which editor we want to use.
    For continuity reasons, let''s say that we choose the vi editor (`vi.basic`).
    Let''s add the following entry to the end of the file that we''re editing in vi:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'If we save the file as is, we just created the first root cron job – the one
    that''s going to execute every minute. The `*` signs are actually *frequency fields*
    in these crontab files. Look at the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Now scroll a bit lower on the man page; we''re going to find the following
    examples:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.25 – Excerpt from man 5 crontab page'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_3.25_B16269.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 3.25 – Excerpt from man 5 crontab page
  prefs: []
  type: TYPE_NORMAL
- en: The first part explains the fields, as there are six of them. The first five
    are related to the frequency of executing the six fields. We can use space or
    *Tab* as delimiters between these fields.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first five fields are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The `minute` field: At which minute the job should be executed'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The `hour` field: At which hour the job should be executed'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The `day of month` field: On which day of the month the job should be executed'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The `month` field: On which month the job should be executed'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The `day of week` field: On which day of the week the job should be executed'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'All of these fields support various types of syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '`75` in the `minute` field, that doesn''t make any sense as single numbers
    in the `minute` field go from `0` to `59`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`3-47` in the `hour` field, that won''t work as the number range for hours
    is `0-23`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`0-10/2` in the first field, which `cron` translates to *from the 0th to 10th
    minute, every second minute*.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`0`,`2`,`4`,`6`,`8`,`10`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Combination thereof**: Any combination of previously mentioned syntaxes.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: All of these syntaxes give us many different options to configure which jobs
    we want to execute and when, down to the minute. We also need to remember that
    `cron` doesn't allow frequency smaller than a minute. If we need to do something
    like that, we need to work *around* that fact (using the `sleep` function, the
    `at` command, and others).
  prefs: []
  type: TYPE_NORMAL
- en: 'If we are logged in as root, that gives us the capability to manage a user''s
    cron jobs as well. For example, say we type in the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: We are going to be editing `crontab` for the `student` user.
  prefs: []
  type: TYPE_NORMAL
- en: 'Furthermore, if we want to remove `student`''s cron jobs, we can do it like
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'If we just need to list cron jobs from the `student` user, we can use the following
    command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s go back to system cron jobs, the second most common type of cron jobs.
    These are configured in system folders under the `/etc` directory, such as `/etc/cron.daily`
    and `/etc/cron.hourly`. The keyword that follows `cron.` in the directory name
    tells us the frequency for all of the jobs configured in that folder. For example,
    let''s take a look at the `cron.daily` folder:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.26 – Daily system cron jobs'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_3.26_B16269.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 3.26 – Daily system cron jobs
  prefs: []
  type: TYPE_NORMAL
- en: 'Some of these filenames probably sound familiar. `logrotate` does log rotation,
    the `mlocate` job updates the file/folder database used by the `updatedb` command,
    and so on. At any given moment, there can be dozens of these system-wide cron
    jobs in those directories, depending on which packages we installed on our Linux
    server and how many additional system jobs we created ourselves. Let''s use the
    `logrotate` file as an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.27 – logrotate cron.daily job, which actually executes a simple
    shell script'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_3.27_B16269.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 3.27 – logrotate cron.daily job, which actually executes a simple shell
    script
  prefs: []
  type: TYPE_NORMAL
- en: As we can see, this cron job actually executes a shell script, and its configuration
    is the polar opposite of what we saw in user cron jobs where `crontab` files have
    a very strict syntax. Here, we have much more freedom and the fact that we can
    just write outright shell script code in these files makes our job easier. We
    have a lot of additional content about shell scripting coming up later in this
    book, from [*Chapter 9*](B16269_09_Final_PD_ePub.xhtml#_idTextAnchor206), *An
    Introduction to Shell Scripting*, all the way to the end of the book. So, let's
    table that discussion for a later time when we introduce all the necessary concepts
    – variables, loops, functions, arrays, and so on. It is going to be a lot of fun
    indeed.
  prefs: []
  type: TYPE_NORMAL
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`crond` is a spooling type of service – it creates queues of tasks that it
    needs to do and then executes them in accordance with specified criteria. In larger
    enterprises, we might consider `crond` criteria to be a part of a bigger picture
    that we usually call policy. Businesses rely on IT-related policies to implement
    standards and levels of service, and in that sense, IT policies are nothing more
    than objects describing a certain need. A need to do scheduled, daily backups,
    a need to run regular security checks by using an `crond`, it''s one of those
    essential tools to deliver those policies.'
  prefs: []
  type: TYPE_NORMAL
- en: '`crond` takes care of different types of scheduled jobs:'
  prefs: []
  type: TYPE_NORMAL
- en: '**System-related scheduled jobs**: Daily, hourly, weekly, and other jobs that
    are executed in order for the system to work properly.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`crond` to make sure to execute them later if we install the `anacron` package,
    which takes care of scenarios such as constant server shutdowns that would lead
    to periodic tasks not being executed regularly.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**User-based crond jobs**: These are per-user jobs that regular system users
    can create so that they can execute a job at a given moment.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: First and foremost, we need to learn how user-based cron jobs work, as these
    are the most common jobs on multi-user servers.
  prefs: []
  type: TYPE_NORMAL
- en: 'When we use the `crontab -e` command for any given user, a `crontab` file gets
    created in one of the `crond` directories. These files are nothing special in
    terms of complexity – there''s obviously a bit of syntax involved, but they''re
    really well documented even when starting from scratch so that most users won''t
    have problems with figuring this out. In Ubuntu, `crontab` files are created in
    the `/var/spool/cron/crontabs` directory, where all user cron jobs get saved as
    a text file per user. If a file in that directory is named as root, that means
    that the root user has a cron job. If there''s a file named `student`, that means
    that the user called `student` has a cron job scheduled. This makes it easier
    to debug if it ever comes to that. Also, we need to take note of the fact that
    there are people who prefer to edit those files rather than using the `crontab`
    command. At the end of the day, whichever way we solve the IT problem that we
    need to solve is good, as long as it works properly. Let''s take a look at one
    of those files – in this case, it''s going to be an excerpt from the root user''s
    `crontab` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.28 – Root''s crontab file'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_3.28_B16269.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 3.28 – Root's crontab file
  prefs: []
  type: TYPE_NORMAL
- en: We can clearly see that root scheduled a job to be executed every minute here.
    That job lists the content of the `/root` directory and saves it to a file in
    the `/tmp` directory called `root.txt`. It's simple enough, but it clearly shows
    the way in which `crontab` configuration files are created.
  prefs: []
  type: TYPE_NORMAL
- en: '`crond` regularly checks these files and executes configuration stored in them
    at the scheduled time. This is the reason why it''s very important to be careful
    what we put in these files. We really shouldn''t put plain-text passwords, login
    information, or anything similar to these concepts in `crontab` files. By using
    the first five fields in the user''s `crontab` file, `crond` determines the frequency
    for any given scheduled job. It parses these files line by line, which means that
    we can easily schedule multiple cron jobs as users, without any problems.'
  prefs: []
  type: TYPE_NORMAL
- en: 'If we run into problems with users scheduling too many cron jobs eating away
    at the performance of our server, we can always ban them from using `crontab`.
    For example, if we want to deny the `student` user the capability of creating
    user cron jobs, we just need to edit the `/etc/cron.deny` file and add a user
    name per line, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'If we do that, and the user called `student` tries to create a cron job by
    using `crontab -e`, this is the expected result:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.29 – Using cron.deny to disable a user''s right to use crontab'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_3.29_B16269.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 3.29 – Using cron.deny to disable a user's right to use crontab
  prefs: []
  type: TYPE_NORMAL
- en: That's a wrap for this chapter. The next chapter is going to be all about using
    the shell to configure network settings, which includes both network interfaces
    and firewalls. Stay tuned!
  prefs: []
  type: TYPE_NORMAL
- en: There's more…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'If we need to learn more about these concepts, we can check the following links:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Automating system tasks**: [https://access.redhat.com/documentation/en-us/red_hat_enterprise_linux/7/html/system_administrators_guide/ch-automating_system_tasks](https://access.redhat.com/documentation/en-us/red_hat_enterprise_linux/7/html/system_administrators_guide/ch-automating_system_tasks)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Crontab man page, chapter 5**: [https://man7.org/linux/man-pages/man5/crontab.5.html](https://man7.org/linux/man-pages/man5/crontab.5.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**How I use cron in Linux**: [https://opensource.com/article/17/11/how-use-cron-linux](https://opensource.com/article/17/11/how-use-cron-linux)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Use anacron for a better crontab**: [https://opensource.com/article/21/2/linux-automation](https://opensource.com/article/21/2/linux-automation)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
