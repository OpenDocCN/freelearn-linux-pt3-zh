<html><head></head><body>
		<div id="_idContainer161">
			<h1 id="_idParaDest-71" class="chapter-number"><a id="_idTextAnchor076"/>6</h1>
			<h1 id="_idParaDest-72"><a id="_idTextAnchor077"/>Printer and Email – Setting Up Printers and Email Services on Linux Servers </h1>
			<p>In this chapter, we are going to set up printer and email services. These services are vital to any company, big or small. The ability to print documentation is a necessity for many things. This can include documentation and handouts. Along with printing, we will be setting up email services for servers. This will allow mail servers to send out emails of the reports we create based on the type of reports we set up or programs that utilize email to complete tasks, such as alerting the user or providing configuration compliance reports. Through the use of email services, we will be able to ensure that nothing is overlooked when it comes to <span class="No-Break">our systems.</span></p>
			<p>In this chapter, we’re going to cover the following <span class="No-Break">main topics:</span></p>
			<ul>
				<li>Learning about printer services and setting them <span class="No-Break">up manually</span></li>
				<li>Setting up printer services via <span class="No-Break">Ansible Automation</span></li>
				<li>Learning about email services and setting them <span class="No-Break">up manually</span></li>
				<li>Setting up email services via <span class="No-Break">Ansible Automation</span></li>
			</ul>
			<h1 id="_idParaDest-73"><a id="_idTextAnchor078"/>Technical requirements</h1>
			<p>You need to have applied the configuration from <a href="B18607_01.xhtml#_idTextAnchor016"><span class="No-Break"><em class="italic">Chapter 1</em></span></a>, <em class="italic">Block Storage – Learning How to Provision Block Storage on Red Hat Enterprise Linux</em>, in order to do the hands-on portion of this chapter. The relevant example files and playbooks can be found on the GitHub repository <span class="No-Break">at </span><a href="https://github.com/PacktPublishing/Red-Hat-Certified-Specialist-in-Services-Management-and-Automation-EX358-Exam-Guide/tree/main/Chapter06"><span class="No-Break">https://github.com/PacktPublishing/Red-Hat-Certified-Specialist-in-Services-Management-and-Automation-EX358-Exam-Guide/tree/main/Chapter06</span></a><span class="No-Break">.</span></p>
			<h2 id="_idParaDest-74"><a id="_idTextAnchor079"/>Setting up GitHub access</h2>
			<p>Please refer to the instructions found in <a href="B18607_01.xhtml#_idTextAnchor016"><span class="No-Break"><em class="italic">Chapter 1</em></span></a>, <em class="italic">Block Storage – Learning How to Provision Block Storage on Red Hat Enterprise Linux</em>, to gain access to GitHub. You can find the Ansible automation playbooks for this chapter at <a href="https://github.com/PacktPublishing/Red-Hat-Certified-Specialist-in-Services-Management-and-Automation-EX358-/tree/main/ch6">https://github.com/PacktPublishing/Red-Hat-Certified-Specialist-in-Services-Management-and-Automation-EX358-/tree/main/ch6</a>. Remember, these are only suggested playbooks, they do not represent the only way these solutions can <span class="No-Break">be written.</span></p>
			<p>You can always change them using raw, shell, or cmd to achieve the same results, but we seek to demonstrate the best way to accomplish our goals. Also keep in mind that we are not using the FCQN required in future versions of Ansible, as that will not be supported in the exam, which tests against <span class="No-Break">Ansible 2.9.</span></p>
			<h1 id="_idParaDest-75"><a id="_idTextAnchor080"/>Learning about printer services and setting them up manually</h1>
			<p>Systems need the ability to print in many cases. This could be in order to output some data that you need to deliver at a presentation, or due to the need to print material for later referencing. Through the use of printer services, we can set up and configure a print queue that will allow us to <a id="_idIndexMarker310"/>do just that. We will be able to control how and when the printer prints as well as which printer is set as the default. With this knowledge, you can set up printers on both RHEL desktops and servers. For the hands-on portion of the exercise, you will need a network printer on the same network as <span class="No-Break">your servers.</span></p>
			<p>Let’s get started. First, we are going to install the <strong class="source-inline">cups</strong> package to provide the dependencies that we need to aggregate. We will do this with the commands in the <span class="No-Break">following screenshot:</span></p>
			<div>
				<div id="_idContainer137" class="IMG---Figure">
					<img src="image/Figure_6.01_B18607.jpg" alt="Figure 6.1 – Install cups package"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 6.1 – Install cups package</p>
			<p>By installing the <strong class="source-inline">cups</strong> package, we install all the packages needed to create print queues and query printers directly <a id="_idIndexMarker311"/>attached to other servers or print servers. We will need to enable and start the service, as shown in the <span class="No-Break">following screenshot:</span></p>
			<div>
				<div id="_idContainer138" class="IMG---Figure">
					<img src="image/Figure_6.02_B18607.jpg" alt="Figure 6.2 – Start and enable cups for printer setup"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 6.2 – Start and enable cups for printer setup</p>
			<p>Next, we are going to <a id="_idIndexMarker312"/>enable firewall rules to allow <strong class="source-inline">631/tcp</strong>, which is the typical port that printers serve from. We also enable mDNS, which allows dynamic<a id="_idIndexMarker313"/> discovery through the <strong class="bold">Internet Printing Protocol</strong> (<strong class="bold">IPP</strong>). The commands needed are in the <span class="No-Break">following screenshot:</span></p>
			<div>
				<div id="_idContainer139" class="IMG---Figure">
					<img src="image/Figure_6.03_B18607.jpg" alt="Figure 6.3 – Add the required firewall rules to discover printers and printing"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 6.3 – Add the required firewall rules to discover printers and printing</p>
			<p>The next step for setting up<a id="_idIndexMarker314"/> printing on your system is to look up network printers. We will use the <strong class="source-inline">ippfind</strong> tool to do that with the command shown in the <span class="No-Break">following screenshot:</span></p>
			<div>
				<div id="_idContainer140" class="IMG---Figure">
					<img src="image/Figure_6.04_B18607.jpg" alt="Figure 6.4 – Use the ippfind tool to look up network printers"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 6.4 – Use the ippfind tool to look up network printers</p>
			<p>After we have located our printers, we<a id="_idIndexMarker315"/> will take the one we would like to target and create a print queue for it. This will allow us to queue up print jobs to send to the printer. This provides the ability to enable and disable the printer’s printing functionality, while maintaining the print queue when the printer is offline or disabled (unless you intervene manually or through Ansible Automation). We can see the print queue created with the <strong class="source-inline">lpadmin</strong> command. (Note that is an <em class="italic">L</em> at the start of <strong class="source-inline">lpadmin</strong>.) We will utilize the following flags: <strong class="source-inline">-p</strong>, <strong class="source-inline">-v</strong>, <strong class="source-inline">-m</strong>, and <strong class="source-inline">-E</strong>. These mean the following: <strong class="source-inline">-p queue</strong> name, <strong class="source-inline">-v device</strong> url, while <strong class="source-inline">-m everywhere</strong> is the IPP definition, and <strong class="source-inline">-E</strong> is for immediate enabling of the printer queue. Please first ensure that the DNS name is routable for the printer or add it to <strong class="source-inline">/etc/hosts</strong> in order to ensure reachability. The full command utilized can be seen in the <span class="No-Break">following screenshot:</span></p>
			<div>
				<div id="_idContainer141" class="IMG---Figure">
					<img src="image/Figure_6.05_B18607.jpg" alt="Figure 6.5 – Configure the print queue"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 6.5 – Configure the print queue</p>
			<p>Next, we are going to set the default printer so that when you create a print job it is sent to the right printer. This is <a id="_idIndexMarker316"/>normally used when you have multiple printers and need to ensure you print to the right one, perhaps at a specific location in a building or due to needing to utilize a certain type of printer. The command to set the default printer can be seen in the <span class="No-Break">following screenshot:</span></p>
			<div>
				<div id="_idContainer142" class="IMG---Figure">
					<img src="image/Figure_6.06_B18607.jpg" alt="Figure 6.6 – Set the default printer"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 6.6 – Set the default printer</p>
			<p>Next, we are going to<a id="_idIndexMarker317"/> create a simple text file to print and test that our print queue is set up correctly. In my case, my file looks like the <span class="No-Break">following screenshot:</span></p>
			<div>
				<div id="_idContainer143" class="IMG---Figure">
					<img src="image/Figure_6.07_B18607.jpg" alt="Figure 6.7 – Create a test document to print"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 6.7 – Create a test document to print</p>
			<p>After we have created<a id="_idIndexMarker318"/> the text file to print, we are going to go and actually print it. This is done with the command found in the <span class="No-Break">following screenshot:</span></p>
			<div>
				<div id="_idContainer144" class="IMG---Figure">
					<img src="image/Figure_6.08_B18607.jpg" alt="Figure 6.8 – Print test document"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 6.8 – Print test document</p>
			<p>If the printer successfully printed your page, then you are able to create and control printer jobs <span class="No-Break">on </span><span class="No-Break"><strong class="source-inline">rhel1.example.com</strong></span><span class="No-Break">.</span></p>
			<p>Next, let’s see how<a id="_idIndexMarker319"/> to disable and enable the print queue. When you disable the printer, it will queue the print jobs instead of sending them to the printer. This can be seen in the <span class="No-Break">following screenshot:</span></p>
			<div>
				<div id="_idContainer145" class="IMG---Figure">
					<img src="image/Figure_6.09_B18607.jpg" alt="Figure 6.9 – Disable printer and then attempt to print"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 6.9 – Disable printer and then attempt to print</p>
			<p>We are then going to<a id="_idIndexMarker320"/> check the current print queue and how it is not moving forward as the printer is disabled. After that, we will cancel the print jobs so that they do not print when we re-enable the printer. Going to the home directory and using the commands found in the following screenshot will show the print queue and cancel the <span class="No-Break">print jobs:</span></p>
			<div>
				<div id="_idContainer146" class="IMG---Figure">
					<img src="image/Figure_6.10_B18607.jpg" alt="Figure 6.10 – Print queue shows stalled jobs due to the printer being disabled"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 6.10 – Print queue shows stalled jobs due to the printer being disabled</p>
			<p>To ensure that we will still be able<a id="_idIndexMarker321"/> to print, next we are going to re-enable the print queue. This will allow any print jobs to be sent to our default printer. This is accomplished by the command in the <span class="No-Break">following screenshot:</span></p>
			<div>
				<div id="_idContainer147" class="IMG---Figure">
					<img src="image/Figure_6.11_B18607.jpg" alt="Figure 6.11 – Re-enable the print queue after clearing the print queue"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 6.11 – Re-enable the print queue after clearing the print queue</p>
			<p>In this section, we set up a print queue to allow a Linux device to print to a network printer. This information is crucial when you need to be able to create physical documentation. This could be for handouts at a company event or for an internal meeting. The ability to<a id="_idIndexMarker322"/> print is necessary and knowing how to set up a print queue enables that ability. Next, we are going to set up a print queue using <span class="No-Break">Ansible Automation.</span></p>
			<h1 id="_idParaDest-76"><a id="_idTextAnchor081"/>Setting up printer services via Ansible Automation</h1>
			<p>We are going to start this section off by<a id="_idIndexMarker323"/> creating a playbook<a id="_idIndexMarker324"/> for enabling print services using <strong class="source-inline">cups</strong>. We will then create playbooks to enable and disable the print queues and also to drain any queued print jobs that might be in line to print. This will allow us to control<a id="_idIndexMarker325"/> setting up printers over many devices via automation, which will shorten the time to <span class="No-Break">completion considerably.</span></p>
			<p>First, we will start with a playbook directory, inside of which we will have an inventory file with a list of the servers we want to set up services on. In our case, we are going to set up a print queue on <strong class="source-inline">rhel1.example.com</strong> and <strong class="source-inline">rhel2.example.com</strong>. This will allow us to showcase using Ansible Automation in more than just a single playbook. We are going to <a id="_idIndexMarker326"/>create a <strong class="source-inline">cups_playbook</strong> directory, inside of which we are going to first create the inventory file shown in the <span class="No-Break">following screenshot:</span></p>
			<div>
				<div id="_idContainer148" class="IMG---Figure">
					<img src="image/Figure_6.12_B18607.jpg" alt="Figure 6.12 – Inventory file for playbook"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 6.12 – Inventory file for playbook</p>
			<p>Next, we are going to start the playbook as we always have by creating the top level of the playbook. The following shows the format that is required for the beginning of all playbooks when using Ansible Automation. The start of the playbook can be seen in the <span class="No-Break">following code:</span></p>
			<pre class="source-code">
---
- name: Cups printer queue setup
  hosts: cups_servers
  become: true
  become_method: sudo</pre>
			<p>Next, let’s move on to the tasks. These include installing <strong class="source-inline">cups</strong>, configuring firewall rules, and setting up the<a id="_idIndexMarker327"/> printer queue. For this, you will need to know the URL of the printer ahead of time, so<a id="_idIndexMarker328"/> you might need to gather that information from the server using the <span class="No-Break">following code:</span></p>
			<pre class="source-code">
[emcleroy@rhel1 ~]$ ippfind -T 20
ipp://HPE070EA601518.local:631/ipp/print
ipp://EPSON04046D.local:631/ipp/print
ipp://BRW9C305BC2B044.local:631/ipp/print</pre>
			<p>In my case, I will be using the Brother printer that is at the bottom of the printer-finding command output in the <span class="No-Break">preceding snippet.</span></p>
			<p>With that information, we can write out the command that we learned earlier to set up the print queue. You can see the tasks for installing <strong class="source-inline">cups</strong>, firewall configuration, and print queue setup in the <span class="No-Break">following code:</span></p>
			<pre class="source-code">
  tasks:
    - name: Install cups
      package:
        name: cups
        state: latest
    - name: Start and enable cups service
      service:
        name: cups
        state: started
        enabled: true
    - name: Enable firewall rules
      firewalld:
        service: mdns
        permanent: true
        state: enabled
    - name: Enable firewall rules
      firewalld:
        port: 631/tcp
        permanent: true
        state: enabled
    - name: Reload firewall
      command:
        cmd: firewall-cmd --reload
    - name: Setup print queue
      command:
        cmd: lpadmin -p printer-queue -v ipp://BRW9C305BC2B044.local:631/ipp/print -m everywhere -E
    - name: Set default print queue
      command:
        cmd: lpadmin -d printer-queue
    - name: Test to ensure print queue is setup correctly
      command:
        cmd: lpstat -p printer-queue</pre>
			<p>We will run the playbook with<a id="_idIndexMarker329"/> the following command, including the <strong class="source-inline">-v</strong> flag for verbose output such as<a id="_idIndexMarker330"/> when the print queue is <span class="No-Break">shown enabled:</span></p>
			<pre class="console">
[emcleroy@rhel3 cups_playbook]$ ansible-playbook -i inventory cups_playbook.yml -u emcleroy –k –-ask-become -v</pre>
			<p>The output from this successful playbook run is truncated but you can see where the print queue was enabled in the <span class="No-Break">following screenshot:</span></p>
			<div>
				<div id="_idContainer149" class="IMG---Figure">
					<img src="image/Figure_6.13_B18607.jpg" alt="Figure 6.13 – Successful playbook run for the cups create playbook"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 6.13 – Successful playbook run for the cups create playbook</p>
			<p>Next, we are going to write a playbook<a id="_idIndexMarker331"/> to disable the print queue and then another to enable it. Here you can see<a id="_idIndexMarker332"/> the playbook code to disable the <span class="No-Break">print queue:</span></p>
			<pre class="source-code">
---
- name: Cups printer queue setup
  hosts: cups_servers
  become: true
  become_method: sudo
  tasks:
    - name: Disable print queue
      command:
        cmd: cupsdisable printer-queue</pre>
			<p>The output of this playbook run for disabling the print queue can be seen in the <span class="No-Break">following screenshot:</span></p>
			<div>
				<div id="_idContainer150" class="IMG---Figure">
					<img src="image/Figure_6.14_B18607.jpg" alt="Figure 6.14 – Successful playbook run for the cups disable playbook"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 6.14 – Successful playbook run for the cups disable playbook</p>
			<p>The <a id="_idIndexMarker333"/>playbook shown in the following code enables<a id="_idIndexMarker334"/> the <span class="No-Break">print queue:</span></p>
			<pre class="source-code">
---
- name: Cups printer queue setup
  hosts: cups_servers
  become: true
  become_method: sudo
  tasks:
    - name: Enable print queue
      command:
        cmd: cupsenable printer-queue</pre>
			<p>The output for enabling the print queue can be seen in the <span class="No-Break">following screenshot:</span></p>
			<div>
				<div id="_idContainer151" class="IMG---Figure">
					<img src="image/Figure_6.15_B18607.jpg" alt="Figure 6.15 – Successful playbook run for the cups enable playbook"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 6.15 – Successful playbook run for the cups enable playbook</p>
			<p>In this section, we<a id="_idIndexMarker335"/> learned how to set up print queues <a id="_idIndexMarker336"/>through Ansible Automation. This can be extremely useful in an enterprise environment where you might be setting up many servers that need to print to the same printer. By setting up Ansible Automation playbooks to do the work for you, you free up your time for other more <span class="No-Break">meaningful work.</span></p>
			<h1 id="_idParaDest-77"><a id="_idTextAnchor082"/>Learning about email services and setting them up manually</h1>
			<p>Email services are an<a id="_idIndexMarker337"/> essential part of any infrastructure. The ability to send email reports or alerts to a dedicated email list is one of the reasons that email is so useful. Using the <strong class="source-inline">postfix</strong> package, you are able to set up full email relays or null clients that forward emails to other relays. This allows you to control how your email is routed in your network. In this section, we will see how to set up a null client for these purposes. We will install <strong class="source-inline">postfix</strong> to control email from the server, set up firewall rules, and finally set up the null client settings both manually and through <span class="No-Break">Ansible Automation.</span></p>
			<p>The first thing we have to do is install <strong class="source-inline">postfix</strong>. Running the command to install <strong class="source-inline">postfix</strong> can be seen in the <span class="No-Break">following screenshot:</span></p>
			<div>
				<div id="_idContainer152" class="IMG---Figure">
					<img src="image/Figure_6.16_B18607.jpg" alt="Figure 6.16 – Install postfix"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 6.16 – Install postfix</p>
			<p>We are then going to view the configuration file for <strong class="source-inline">postfix</strong>. This is not the best way to set up <strong class="source-inline">postfix</strong> as the <strong class="source-inline">postconf</strong> command is normally used to change the required settings. The configuration file can be seen truncated in the following screenshot and is located <span class="No-Break">at </span><span class="No-Break"><strong class="source-inline">/etc/postfix/main.cf</strong></span><span class="No-Break">:</span></p>
			<div>
				<div id="_idContainer153" class="IMG---Figure">
					<img src="image/Figure_6.17_B18607.jpg" alt="Figure 6.17 – Postfix main.cf truncated"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 6.17 – Postfix main.cf truncated</p>
			<p>Using the <strong class="source-inline">postconf</strong> command, you <a id="_idIndexMarker338"/>can see the same configuration without the comments, as shown in the <span class="No-Break">following screenshot:</span></p>
			<div>
				<div id="_idContainer154" class="IMG---Figure">
					<img src="image/Figure_6.18_B18607.jpg" alt="Figure 6.18 – Output from ﻿the postconf command truncated"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 6.18 – Output from the postconf command truncated</p>
			<p>Next, we are going to make the<a id="_idIndexMarker339"/> required changes to the system to set up what is needed for <strong class="source-inline">postfix</strong> to work as a null client, as shown in the <span class="No-Break">following screenshot:</span></p>
			<div>
				<div id="_idContainer155" class="IMG---Figure">
					<img src="image/Figure_6.19_B18607.jpg" alt="Figure 6.19 – Using the postconf command to change configuration values"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 6.19 – Using the postconf command to change configuration values</p>
			<p>This allows you to make<a id="_idIndexMarker340"/> changes to your <strong class="source-inline">postfix</strong> configuration based on the requirements set by Red Hat during <span class="No-Break">your exam.</span></p>
			<p>Let’s look at an example of what you may need to set for a null client setup. A null client is just a server that passes emails on to another server and does not accept any <span class="No-Break">email itself.</span></p>
			<p>The first setting to change is <strong class="source-inline">inet_interfaces</strong>, making it <strong class="source-inline">loopback-only</strong>, as shown in the <span class="No-Break">following command:</span></p>
			<pre class="console">
[emcleroy@rhel1 ~]$ sudo postconf -e "inet_interfaces = loopback-only"
[sudo] password for emcleroy:
[emcleroy@rhel1 ~]$ sudo postconf inet_interfaces
inet_interfaces = loopback-only</pre>
			<p>Then we are going to set the <strong class="source-inline">myorigin</strong> parameter to use the domain name, in our case, <strong class="source-inline">example.com</strong>, as seen in the <span class="No-Break">following code:</span></p>
			<pre class="console">
[emcleroy@rhel1 ~]$ sudo postconf -e "myorigin = example.com"
[emcleroy@rhel1 ~]$ sudo postconf myorigin
myorigin = example.com</pre>
			<p>Next, we are going <a id="_idIndexMarker341"/>to set <strong class="source-inline">inet_protocols</strong> to <strong class="source-inline">ipv4</strong> purely for simplicity, as shown in the <span class="No-Break">following code:</span></p>
			<pre class="console">
[emcleroy@rhel1 ~]$ sudo postconf -e "inet_protocols = ipv4"
[emcleroy@rhel1 ~]$ sudo postconf inet_protocols
inet_protocols = ipv4</pre>
			<p>The next setting we are going to change is the <strong class="source-inline">mydestination</strong> parameter, as <strong class="source-inline">postfix</strong> is allowed to deliver mail if this value is populated. To ensure that nothing is delivered to this server locally, we will remove all settings. We are going to change the <strong class="source-inline">mydestination</strong> setting to blank, per the <span class="No-Break">following code:</span></p>
			<pre class="console">
[emcleroy@rhel1 ~]$ sudo postconf -e "mydestination ="
[emcleroy@rhel1 ~]$ sudo postconf mydestination
mydestination =</pre>
			<p>Next, let’s alter the <strong class="source-inline">mynetworks</strong> parameter in order to submit messages to the mail relay for any network hosts. We will set this to our loopback IP in order for it to take effect, as seen in the <span class="No-Break">following code:</span></p>
			<pre class="console">
[emcleroy@rhel1 ~]$ sudo postconf -e "mynetworks = 127.0.0.0/8"
[emcleroy@rhel1 ~]$ sudo postconf mynetworks
mynetworks = 127.0.0.0/8</pre>
			<p>The next thing we are going to set is an error message for local delivery. This helps us confirm that local delivery is<a id="_idIndexMarker342"/> disabled. This is accomplished in the <span class="No-Break">following code:</span></p>
			<pre class="console">
[emcleroy@rhel1 ~]$ sudo postconf -e "local_transport = error: no local delivery"
[emcleroy@rhel1 ~]$ sudo postconf local_transport
local_transport = error: no local delivery</pre>
			<p>Finally, we are going to point to an active mail relay that can deliver email locally and to the company’s mail servers. This is done with the <span class="No-Break">following code:</span></p>
			<pre class="console">
[emcleroy@rhel1 ~]$ sudo postconf -e "relayhost = [rhel2.example.com]"
[emcleroy@rhel1 ~]$ sudo postconf relayhost
relayhost = [rhel2.example.com]</pre>
			<p>We have now set up the <strong class="source-inline">postfix</strong> mail service. Now, let’s open the firewall, start the service, and enable it. These commands can be seen in the <span class="No-Break">following screenshot:</span></p>
			<div>
				<div id="_idContainer156" class="IMG---Figure">
					<img src="image/Figure_6.20_B18607.jpg" alt="Figure 6.20 – Enable and start the service, add firewall rules, and reload the firewall"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 6.20 – Enable and start the service, add firewall rules, and reload the firewall</p>
			<p>If you start and<a id="_idIndexMarker343"/> enable the <strong class="source-inline">postfix</strong> service before configuring, you need to make sure to reload the service again to ensure that the changes have been accepted and check the status, as shown in the <span class="No-Break">following screenshot:</span></p>
			<div>
				<div id="_idContainer157" class="IMG---Figure">
					<img src="image/Figure_6.21_B18607.jpg" alt="Figure 6.21 – Check the status of postfix"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 6.21 – Check the status of postfix</p>
			<p>In this section, we<a id="_idIndexMarker344"/> learned how to set up a null client email server. This is useful for setting up email notifications to be sent from a server to send reports or alerts. We learned how to manipulate <strong class="source-inline">postfix</strong> with the <strong class="source-inline">postconf</strong> command and which variables need to be changed to create a <span class="No-Break">null client.</span></p>
			<h1 id="_idParaDest-78"><a id="_idTextAnchor083"/>Setting up email services via Ansible Automation</h1>
			<p>We are going to set up <strong class="source-inline">postfix</strong> with Ansible <a id="_idIndexMarker345"/>Automation using a set of<a id="_idIndexMarker346"/> variables and a loop. This will allow us to create the same setup that we got when doing things manually, but done here in an iterative manner using a loop. First, we will set up our playbook directory and then our inventory file. The inventory file can be seen in the <span class="No-Break">following screenshot:</span></p>
			<div>
				<div id="_idContainer158" class="IMG---Figure">
					<img src="image/Figure_6.22_B18607.jpg" alt="Figure 6.22 – Inventory for email playbook"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 6.22 – Inventory for email playbook</p>
			<p>We are going to start our<a id="_idIndexMarker347"/> playbook with the <a id="_idIndexMarker348"/>normal starting format, as seen in the <span class="No-Break">following code:</span></p>
			<pre class="source-code">
---
- name: Setup null client email server
  hosts: email_servers
  become: true
  become_method: sudo</pre>
			<p>After we have set up the beginning of the playbook, let’s create the tasks required to get the playbook to <a id="_idIndexMarker349"/>successfully configure a null client. We will <a id="_idIndexMarker350"/>use a loop and loop over the variables we provide to the playbook. We can see the playbook in the <span class="No-Break">following code:</span></p>
			<pre class="source-code">
  tasks:
    - name: Install postfix
      package:
        name: postfix
        state: latest
    - name: Open firewall rules for postfix
      firewalld:
        service: smtp
        state: enabled
        permanent: true
    - name: Reload firewall
      command:
        cmd: firewall-cmd --reload
    - name: Set configuration settings using a loop
      command:
        cmd: postconf -e "{{ item.name }} = {{ item.value }}"
      loop:
        - { name: 'inet_interfaces', value: 'loopback-only' }
        - { name: 'myorigin', value: 'example.com' }
        - { name: 'inet_protocols', value: 'ipv4' }
        - { name: 'mydestination', value: '' }
        - { name: 'mynetworks', value: '127.0.0.0/8' }
        - { name: 'local_transport', value: 'error: no local delivery' }
        - { name: 'relayhost', value: '[smtp.example.com]' }
    - name: Restart and enable postfix to refresh config
      service:
        name: postfix
        state: restarted
        enabled: true</pre>
			<p>With that done, let’s run<a id="_idIndexMarker351"/> the playbook with the <span class="No-Break">following </span><span class="No-Break"><a id="_idIndexMarker352"/></span><span class="No-Break">command:</span></p>
			<pre class="source-code">
[emcleroy@rhel3 email_playbook]$ ansible-playbook -i inventory email_playbook.yml -u emcleroy -k --ask-become -v</pre>
			<p>The truncated output of this playbook when successfully run can be seen in the <span class="No-Break">following screenshot:</span></p>
			<div>
				<div id="_idContainer159" class="IMG---Figure">
					<img src="image/Figure_6.23_B18607.jpg" alt="Figure 6.23 – Successful email setup playbook run"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 6.23 – Successful email setup playbook run</p>
			<p>Finally, let’s check and confirm <a id="_idIndexMarker353"/>our configuration of <strong class="source-inline">mynetworks</strong> to ensure <a id="_idIndexMarker354"/>that it is only using <strong class="source-inline">127.0.0.0/8</strong>, as shown in the <span class="No-Break">following screenshot:</span></p>
			<div>
				<div id="_idContainer160" class="IMG---Figure">
					<img src="image/Figure_6.24_B18607.jpg" alt="Figure 6.24 – Confirming the settings changed in the postfix configuration"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 6.24 – Confirming the settings changed in the postfix configuration</p>
			<p>In this section, we learned <a id="_idIndexMarker355"/>how to set up a <strong class="source-inline">postfix</strong> null<a id="_idIndexMarker356"/> client using Ansible Automation. This is a great way to set up your mail servers easily using predetermined values that can span multiple hosts. This allows you to quickly set up these servers without having to install and then type in the configuration commands on each and <span class="No-Break">every server.</span></p>
			<h1 id="_idParaDest-79"><a id="_idTextAnchor084"/>Summary</h1>
			<p>In this chapter, we went over how to print from a server and how to set up email hosts to correctly forward emails to a relay using a null server. This allows you to set up subordinate systems to other masters. With this knowledge, you can successfully print from your servers or Linux clients along with sending and receiving mail transmissions. In the next chapter, we are going to work with MariaDB and the MySQL commands that are available for it. A database is a powerful tool that allows you to create backends for web servers and for programs that need a database to run. This will allow you to control your data points with ease. We will do this both manually and via Ansible Automation to make your life easier when setting up multiple databases throughout the course of <span class="No-Break">your career.</span></p>
		</div>
	</body></html>