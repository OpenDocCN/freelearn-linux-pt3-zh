- en: '3'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: All about Bootloaders
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The bootloader is the second element of embedded Linux. It is the part that
    starts the system and loads the operating system kernel. In this chapter, we will
    look at the role of the bootloader and how it passes control from itself to the
    kernel using a data structure called a **device tree**, also known as a **flattened
    device tree** or **FDT**.
  prefs: []
  type: TYPE_NORMAL
- en: I will cover the basics of device trees so that you will be able to follow the
    connections described in a device tree and relate them to real hardware. I will
    focus on a popular open source bootloader known as U-Boot and show you how to
    use it to boot a target device. I will also show you how to customize U-Boot to
    run on a new device using BeaglePlay as an example.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: What does a bootloader do?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Boot sequence
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Moving from the bootloader to the kernel
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introducing device trees
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: U-Boot
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To work through the examples, make sure you have the following:'
  prefs: []
  type: TYPE_NORMAL
- en: An Ubuntu 24.04 or later LTS host system with `device-tree-compiler`, `git`,
    `make`, `patch`, and `u-boot-tools` installed
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A Bootlin toolchain for BeaglePlay from [*Chapter 2*](Chapter_01.xhtml#_idTextAnchor028)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A microSD card reader and card
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A USB-to-TTL serial cable with a 3.3 V logic level
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: BeaglePlay
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A 5 V USB-C power supply capable of delivering 3 A
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'All of the code for this chapter can be found in the `Chapter03` folder from
    the book’s GitHub repository: [https://github.com/PacktPublishing/Mastering-Embedded-Linux-Development/tree/main/Chapter03](https://github.com/PacktPublishing/Mastering-Embedded-Linux-Development/tree/main/Chapter03).'
  prefs: []
  type: TYPE_NORMAL
- en: What does a bootloader do?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In an embedded Linux system, the bootloader has two main jobs: initializing
    the system to a basic level and loading the kernel. In fact, the first job is
    somewhat subsidiary to the second in that it is only necessary to get as much
    of the system working as is needed to load the kernel.'
  prefs: []
  type: TYPE_NORMAL
- en: When the first lines of the bootloader code are executed, following a power-on
    or reset, the system is in a very minimal state. The **Dynamic Random Access Memory**
    (**DRAM**) controller is not set up, so the main memory is not accessible. Likewise,
    other interfaces are not configured, so storage that’s accessed via **NAND** (**NOT
    AND**) **flash** controllers, **MultiMediaCard** (**MMC**) controllers, and so
    on is unavailable. Typically, the only resources that are operational at the beginning
    are a single CPU core, some on-chip **Static Random Access Memory** (**SRAM**),
    and the boot **Read-Only Memory** (**ROM**).
  prefs: []
  type: TYPE_NORMAL
- en: A system bootstrap consists of several phases of code, each bringing more of
    the system into operation. The final act of the bootloader is to load the kernel
    into RAM and create an execution environment for it. The details of the interface
    between the bootloader and the kernel are architecture-specific, but in each case,
    it has to do two things. First, the bootloader has to pass a pointer to a structure
    containing information about the hardware configuration. Second, it has to pass
    a pointer to the kernel command line.
  prefs: []
  type: TYPE_NORMAL
- en: The kernel command line is a text string that controls the behavior of Linux.
    Once the kernel has begun executing, the bootloader is no longer needed and all
    the memory it was using can be reclaimed.
  prefs: []
  type: TYPE_NORMAL
- en: A subsidiary job of the bootloader is to provide a maintenance mode for updating
    boot configurations, loading new boot images into memory, and maybe running diagnostics.
    This is usually controlled by a simple command-line user interface, commonly over
    a serial console.
  prefs: []
  type: TYPE_NORMAL
- en: Boot sequence
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Some years ago, we only needed to place the bootloader in non-volatile memory
    at the reset vector of the processor. **NOR** (**NOT OR**) **flash** memory was
    common at that time and, since it can be mapped directly into the address space,
    it was the ideal method of storage. The following diagram shows such a configuration
    with the **reset vector** at `0xfffffffc` at the top end of an area of flash memory:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.1 – NOR flash](img/B18466_03_01.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.1 – NOR flash
  prefs: []
  type: TYPE_NORMAL
- en: The bootloader is linked so that there is a jump instruction at that location
    that points to the start of the bootloader code. From that point on, the bootloader
    code running in NOR flash memory can initialize the DRAM controller so that the
    main memory – the **DRAM** – becomes available, and then it copies itself into
    the DRAM. Once fully operational, the bootloader can load the kernel from flash
    memory into DRAM and transfer control to it.
  prefs: []
  type: TYPE_NORMAL
- en: However, once you move away from a simple linearly addressable storage medium
    such as NOR flash, the boot sequence becomes a complex, multi-stage procedure.
    The details are very specific to each SoC, but they generally go through the following
    phases.
  prefs: []
  type: TYPE_NORMAL
- en: Phase 1 – ROM code
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the absence of reliable external memory, the code that runs immediately after
    a reset or power-on is stored on-chip in the SoC. This is known as **ROM code**.
    It is loaded into the chip when it is manufactured, and hence the ROM code is
    proprietary and cannot be replaced by an open source equivalent.
  prefs: []
  type: TYPE_NORMAL
- en: ROM code does not include code to initialize the memory controller because DRAM
    configurations are highly device-specific, and so it can only use SRAM, which
    does not require a memory controller. Most embedded SoC designs have a small amount
    of SRAM on chip, varying in size from as little as 4 KB to several hundred KB.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.2 – Phase 1 – ROM code](img/B18466_03_02.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.2 – Phase 1 – ROM code
  prefs: []
  type: TYPE_NORMAL
- en: The ROM code can load a small chunk of code from one of several pre-programmed
    locations into SRAM. As an example, TI Sitara chips try to load code from the
    first few pages of NAND flash memory, or from flash memory connected through a
    **Serial Peripheral Interface** (**SPI**). They also try to load code from the
    first sectors of an MMC device like an eMMC chip or SD card, or from a file named
    **MLO** (**Memory Loader**) on the first partition of an MMC device. If reading
    from all these memory devices fails, then it tries reading a byte stream from
    Ethernet, USB, or UART. The latter is provided mainly as a way to load code into
    flash memory at production rather than for use in normal operation.
  prefs: []
  type: TYPE_NORMAL
- en: Most embedded SoCs have ROM code that works in a similar way. In SoCs where
    the SRAM is not large enough to load a full bootloader such as U-Boot, there needs
    to be an intermediate loader called the **Secondary Program Loader** (**SPL**).
    At the end of the ROM code phase, the SPL is present in the SRAM and the ROM code
    jumps to the beginning of that code.
  prefs: []
  type: TYPE_NORMAL
- en: Phase 2 – Secondary Program Loader
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The SPL must set up the memory controller and other essential parts of the system
    in preparation for loading the **Tertiary Program Loader** (**TPL**) into DRAM.
    The functionality of the SPL is limited by the size of the SRAM. It can read a
    program from a list of storage devices, as can the ROM code, once again using
    pre-programmed offsets from the start of a flash device.
  prefs: []
  type: TYPE_NORMAL
- en: 'If the SPL has filesystem drivers built into it, it can read well-known filenames
    such as `u-boot.img` from a disk partition. The SPL usually doesn’t allow any
    user interaction, but it may print version information and progress messages that
    you can see on the console. The following diagram displays the phase 2 architecture:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.3 – Phase 2 – SPL](img/B18466_03_03.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.3 – Phase 2 – SPL
  prefs: []
  type: TYPE_NORMAL
- en: The preceding diagram shows the jump from ROM code to SPL. As the SPL executes
    within SRAM, it loads the TPL into DRAM. At the end of the second phase, the TPL
    is present in DRAM and the SPL can make a jump to that area.
  prefs: []
  type: TYPE_NORMAL
- en: The SPL may be open source, as is the case with Atmel AT91Bootstrap, but it
    is quite common for it to contain proprietary code that is supplied by the manufacturer
    as a binary blob.
  prefs: []
  type: TYPE_NORMAL
- en: Phase 3 – Tertiary Program Loader
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'At this point, we are running a full bootloader, such as U-Boot, which we will
    learn about a bit later in this chapter. Usually, there is a simple command-line
    user interface that lets you perform maintenance tasks such as loading new boot
    and kernel images into flash storage, as well as a way to load the kernel automatically
    without user intervention. The following diagram explains the phase 3 architecture:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.4 – Phase 3 – TPL](img/B18466_03_04.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.4 – Phase 3 – TPL
  prefs: []
  type: TYPE_NORMAL
- en: The preceding diagram shows the jump from SPL in SRAM to TPL in DRAM. As the
    TPL executes, it loads the kernel into DRAM. We also have the choice of appending
    an FDT and/or initial RAM disk to the image in DRAM if we want. Either way, at
    the end of the third phase, there is a kernel in memory waiting to be started.
  prefs: []
  type: TYPE_NORMAL
- en: Embedded bootloaders usually disappear from memory once the kernel is running
    and have no further part in the operation of the system. Before that happens,
    the TPL needs to hand off control of the boot process to the kernel.
  prefs: []
  type: TYPE_NORMAL
- en: Moving from the bootloader to the kernel
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'When the bootloader passes control to the kernel, it has to pass some basic
    information, which includes the following:'
  prefs: []
  type: TYPE_NORMAL
- en: The machine number, which is used on PowerPC and Arm platforms without support
    for a device tree, to identify the type of the SoC
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Basic details of the hardware that’s been detected so far, including (at the
    very least) the size and location of the physical RAM and the CPU’s clock speed
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The kernel command line
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Optionally, the location and size of a device tree binary
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Optionally, the location and size of an initial RAM disk, called the **initial
    RAM file system** (**initramfs**)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The kernel command line is a plain ASCII string that controls the behavior of
    Linux by giving it, for example, the name of the device that contains the root
    filesystem. We will look at the kernel command line in detail in the next chapter.
    It is common to provide the root filesystem as a RAM disk, in which case it is
    the responsibility of the bootloader to load the RAM disk image into memory. We
    will cover how to create initial RAM disks in [*Chapter 5*](Chapter_05.xhtml#_idTextAnchor138).
  prefs: []
  type: TYPE_NORMAL
- en: The way this information is passed is dependent on the architecture and has
    changed in recent years. For instance, with PowerPC, the bootloader simply used
    to pass a pointer to a board information structure, whereas with Arm, it passed
    a pointer to a list of A tags. There is a good description of the format of A
    tags in the kernel source tree at `Documentation/arch/arm/booting.rst`. Browse
    the kernel source tree at [https://github.com/torvalds/linux](https://github.com/torvalds/linux).
  prefs: []
  type: TYPE_NORMAL
- en: In both cases, the amount of information being passed is very limited, leaving
    the bulk to be discovered at runtime or hard-coded into the kernel as **platform
    data**. The widespread use of platform data meant that each board had to have
    a kernel configured and modified for that platform. A better way was needed, and
    that way is the device tree.
  prefs: []
  type: TYPE_NORMAL
- en: In the Arm world, the move away from A tags began in earnest in February 2013
    with the release of Linux 3.8\. Today, almost all Arm systems use device trees
    to gather information about the specifics of the hardware platform. This allows
    a single kernel binary to run on a wide range of Arm platforms.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we’ve learned what a bootloader does, what the stages of the boot sequence
    are, and how it passes control to the kernel, let’s learn how to configure a bootloader
    so that it runs on popular embedded SoCs.
  prefs: []
  type: TYPE_NORMAL
- en: Introducing device trees
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If you are working with Arm or PowerPC SoCs, you are almost certainly going
    to encounter device trees at some point. This section aims to give you a quick
    overview of what they are and how they work. We will revisit the topic of device
    trees repeatedly throughout the course of this book.
  prefs: []
  type: TYPE_NORMAL
- en: A device tree is a flexible way of defining the hardware components of a computer
    system. Bear in mind that a device tree is just static data, not executable code.
    Usually, the device tree is loaded by the bootloader and passed to the kernel,
    although it is possible to bundle the device tree with the kernel image itself
    to cater to bootloaders that are not capable of loading them separately.
  prefs: []
  type: TYPE_NORMAL
- en: The format is derived from a Sun Microsystems bootloader known as **OpenBoot**,
    which was formalized as the Open Firmware specification (IEEE standard IEEE1275-1994).
    It was used in PowerPC-based Macintosh computers and so was a logical choice for
    the PowerPC Linux port. Since then, it has been adopted at a large scale by the
    many Arm Linux implementations and, to a lesser extent, by MIPS, MicroBlaze, ARC,
    and other architectures.
  prefs: []
  type: TYPE_NORMAL
- en: I recommend visiting [https://www.devicetree.org](https://www.devicetree.org)
    for more information.
  prefs: []
  type: TYPE_NORMAL
- en: Device tree basics
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The Linux kernel contains a large number of device tree source files in `arch/$ARCH/boot/dts`,
    and this is a good starting point for learning about device trees. Additionally,
    the U-Boot source code contains a smaller number of sources in `arch/$ARCH/dts`.
    If you acquired your hardware from a third party, the `dts` file forms part of
    the board support package, so you should expect to receive one along with the
    other source files.
  prefs: []
  type: TYPE_NORMAL
- en: 'The device tree represents a computer system as a collection of components
    joined together in a hierarchy. Every device tree begins with a root node represented
    by a forward slash, `/`, which contains subsequent child nodes describing the
    hardware of the system. Each node has a name and contains several properties in
    the form `name = "value"`. Here is a simple example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Here, we have a root node that contains a `cpus` node and a `memory` node. The
    `cpus` node contains a single CPU node named `cpu@0`. The names of these nodes
    often include an `@` followed by an address that distinguishes the node from other
    nodes of the same type. `@` is required if the node has a `reg` property.
  prefs: []
  type: TYPE_NORMAL
- en: Both the root and CPU nodes have a `compatible` property. The Linux kernel uses
    this property to find a matching device driver by comparing it with the strings
    that are exported by each device driver in an `of_device_id` structure (more on
    this in [*Chapter 11*](Chapter_11.xhtml#_idTextAnchor373)).
  prefs: []
  type: TYPE_NORMAL
- en: '**IMPORTANT NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: It is a convention that the value of the `compatible` property is composed of
    a manufacturer name and a component name to reduce confusion between similar devices
    made by different manufacturers, hence `ti,am33xx` and `arm,cortex-a8`. It is
    also quite common to have more than one value for the `compatible` property when
    there is more than one driver that can handle this device. They are listed with
    the most suitable mentioned first.
  prefs: []
  type: TYPE_NORMAL
- en: The CPU node and the memory node have a `device_type` property that describes
    the class of the device. The node name is often derived from `device_type`.
  prefs: []
  type: TYPE_NORMAL
- en: reg property
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `memory` and `cpu` nodes shown earlier have a `reg` property, which refers
    to a range of units in a register space. A `reg` property consists of two values
    representing the real physical address and the size (length) of the range. Both
    are written as zero or more 32-bit integers called cells. Hence, the previous
    `memory` node refers to a single bank of memory that begins at `0x80000000` and
    is `0x20000000` bytes long.
  prefs: []
  type: TYPE_NORMAL
- en: 'Understanding `reg` properties becomes more complex when the address or size
    values cannot be represented in 32 bits. For example, on a device with 64-bit
    addressing, you need two cells for each:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: The information about the number of cells required is held in the `#address-cells`
    and `#size_cells` properties in an ancestor node. In other words, to understand
    a `reg` property, you have to look backward down the node hierarchy until you
    find `#address-cells` and `#size_cells`. If there are none, the default values
    are `1` for each – but it is bad practice for device tree writers to depend on
    defaults. Default values may or may not be obvious, so being explicit prevents
    any misunderstandings.
  prefs: []
  type: TYPE_NORMAL
- en: Now, let’s return to the `cpu` and `cpus` nodes. CPUs have addresses as well.
    In a quadcore device, they might be addressed as `0`, `1`, `2`, and `3`. That
    can be thought of as a one-dimensional array without any depth, so the size is
    zero. Therefore, you can see that we have `#address-cells = <1>` and `#size-cells
    = <0>` in the `cpus` node. And in the child node, `cpu@0`, we assign a single
    value to the `reg` property with `reg = <0>`.
  prefs: []
  type: TYPE_NORMAL
- en: Labels and interrupts
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The structure of the device tree described so far assumes that there is a single
    hierarchy of components when there are, in fact, several. Besides the obvious
    data connection between a component and other parts of the system, a node might
    also be connected to an interrupt controller, to a clock source, and to a voltage
    regulator.
  prefs: []
  type: TYPE_NORMAL
- en: To express these connections, we can add a label to a node and reference the
    label from other nodes. These labels are sometimes referred to as **phandles**
    because when the device tree is compiled, nodes with a reference from another
    node are assigned a unique numerical value in a property called `phandle`.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can see phandles if you decompile the device tree binary. Take as an example
    a system containing an LCD controller that can generate `interrupts` and an `interrupt-controller`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Here, we have the `interrupt-controller@48200000` node with a label of `intc`.
    The `interrupt-controller` property identifies it as an interrupt controller.
    Like all interrupt controllers, it has an `#interrupt-cells` property, which tells
    us how many cells are needed to represent an interrupt source. In this case, there
    is only one that represents the **Interrupt Request** (**IRQ**) number.
  prefs: []
  type: TYPE_NORMAL
- en: Other interrupt controllers may use additional cells to characterize the interrupt,
    for example, to indicate whether it is edge or level triggered. The number of
    interrupt cells and their meanings are described in the bindings for each interrupt
    controller. The device tree bindings can be found in the Linux kernel source in
    the `Documentation/devicetree/bindings` directory.
  prefs: []
  type: TYPE_NORMAL
- en: Looking at the `lcdc@4830e000` node, it has an `interrupt-parent` property,
    which references the interrupt controller it is connected to using the label.
    It also has an `interrupts` property, which is `36` in this case. Note that this
    node has its own label, `lcdc`, which is used elsewhere. Any node can have a label.
  prefs: []
  type: TYPE_NORMAL
- en: Device tree include files
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Look through the `.dts` files in the kernel and you will find an alternative
    `include` statement that is borrowed from C; for example, this is in `am335x-boneblack.dts`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is another example from `am33xx.dtsi`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Lastly, `include/dt-bindings/pinctrl/am33xx.h` contains normal C macros:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: All of this is resolved if the device tree sources are built using the Kbuild
    system, which runs them through the C preprocessor, CPP. CPP processes the `#include`
    and `#define` statements into text that is suitable for the device tree compiler.
    The motivation is illustrated by the previous example. It means that the device
    tree sources can use the same definitions of constants as the kernel code.
  prefs: []
  type: TYPE_NORMAL
- en: 'When we include files using either syntax, the nodes are overlaid on top of
    one another to create a composite tree in which the outer layers extend or modify
    the inner ones. For example, `am33xx.dtsi`, which is general to all `am33xx` SoCs,
    defines the first MMC controller interface like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Note that `status` is `disabled`, meaning that no device driver should be bound
    to it, and that it has a label of `mmc1`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Both BeagleBone and BeagleBone Black have a microSD card interface attached
    to `mmc1`. This is why, in `am335x-bone-common.dtsi`, the same node is referenced
    by an ampersand and its label, `&mmc1`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Referencing a node by an ampersand and its label lets us overwrite properties
    from previous `mmc1` entries. Here, the `status` property is set to `okay`, which
    causes the MMC device driver to bind with this interface at runtime on both variants
    of BeagleBone. Also, a reference to a label is added to the pin control configuration,
    `mmc1_pins`. Alas, there is not sufficient space here to describe pin control
    and pin multiplexing. The Linux kernel source contains some information in the
    `Documentation/devicetree/bindings/pinctrl` directory.
  prefs: []
  type: TYPE_NORMAL
- en: 'However, the `mmc1` interface is connected to a different voltage regulator
    on BeagleBone Black. This is expressed in `am335x-boneblack.dts`, where you will
    see another reference to `mmc1`, which associates it with the voltage regulator
    via the `vmmcsd_fixed` label:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: So, layering the device tree source files like this gives us flexibility and
    reduces the need for duplicated code.
  prefs: []
  type: TYPE_NORMAL
- en: Compiling a device tree
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The bootloader and kernel require a binary representation of the device tree,
    so it has to be compiled using the device tree compiler, that is, `dtc`. The result
    is a file ending with `.dtb`, which is referred to as a device tree binary or
    a device tree blob.
  prefs: []
  type: TYPE_NORMAL
- en: 'There is a copy of `dtc` in the Linux source in `scripts/dtc/dtc`, and it is
    also available as a package on many Linux distributions. You can use it to compile
    a simple device tree (one that does not use `#include`) like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Be wary of the fact that `dtc` does not give helpful error messages and makes
    no checks other than on the basic syntax of the language. This means that debugging
    a typing error in a device tree source file can be a lengthy process.
  prefs: []
  type: TYPE_NORMAL
- en: To build more complex examples, you will have to use the Kbuild kernel as shown
    in [*Chapter 4*](Chapter_04.xhtml#_idTextAnchor096).
  prefs: []
  type: TYPE_NORMAL
- en: Like the kernel, the bootloader can use a device tree to initialize an embedded
    SoC and its peripherals. This device tree is critical when you’re loading the
    kernel from a mass storage device such as a QSPI flash. While embedded Linux offers
    a choice of bootloaders, we will only cover one. Let’s dig deep into that bootloader
    next.
  prefs: []
  type: TYPE_NORMAL
- en: U-Boot
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We are going to focus on U-Boot exclusively because it supports a good number
    of processor architectures and most individual boards and devices. U-Boot, or
    to give its full name, **Das U-Boot**, began life as an open source bootloader
    for embedded PowerPC boards. Then, it was ported to Arm-based boards and later
    to other architectures, including **Microprocessor without Interlocked Pipeline
    Stages** (**MIPS**) and **SuperH** (**SH**).
  prefs: []
  type: TYPE_NORMAL
- en: U-Boot has been around for a long time and has a good community. The project
    is hosted and maintained by DENX Software Engineering. There is plenty of information
    available on it, and a good place to start is [https://u-boot.readthedocs.io](https://u-boot.readthedocs.io).
    There is also a mailing list at [u-boot@lists.denx.de](https://u-boot@lists.denx.de)
    that you can subscribe to by filling out and submitting the form provided at [https://lists.denx.de/listinfo/u-boot](https://lists.denx.de/listinfo/u-boot).
  prefs: []
  type: TYPE_NORMAL
- en: Building U-Boot
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Begin by getting the source code. As with most projects, the recommended way
    is to clone the Git repository and check out the tag you intend to use:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Alternatively, you can download a tarball from [https://ftp.denx.de/pub/u-boot/](https://ftp.denx.de/pub/u-boot/).
  prefs: []
  type: TYPE_NORMAL
- en: There are more than 1,000 configuration files for common development boards
    and devices in the `configs` directory. In most cases, you can take a good guess
    regarding which to use based on the filename. But you can get more detailed information
    by looking through the `.rst` files in the `doc/board` directory. Or you can find
    information in an appropriate web tutorial or forum.
  prefs: []
  type: TYPE_NORMAL
- en: 'Taking BeaglePlay as an example, we will find that there is a configuration
    file named `am62x_evm_a53_defconfig` in the `configs` directory. In that same
    directory, there is another configuration file named `am62x_evm_r5_defconfig`
    that is for BeaglePlay’s Arm Cortex-R5F microcontroller. The ROM code runs on
    the Arm Cortex-R5F microcontroller and the TPL runs on the main Arm Cortex-A53
    CPU. There are two U-Boot SPLs: one that runs on the R5 and another that runs
    on the main CPU. There is a sequence diagram explaining BeaglePlay’s unique boot
    flow in detail inside `doc/board/beagle/am62x_beagleplay.rst`. Take a close look
    at this sequence diagram and make sure you understand it. As you progress through
    the remainder of this chapter, refer to this diagram for clarification.'
  prefs: []
  type: TYPE_NORMAL
- en: Building U-Boot for BeaglePlay is a multi-stage process. The Arm Cortex-M4F
    and Cortex-R5F in BeaglePlay’s `am62x` SoC are 32-bit processors, so they require
    a 32-bit toolchain. A software component called **TI Foundational Security** (**TIFS**)
    runs on the M4\. TIFS starts the R5 and asks it to load a firmware image to the
    TIFS core. That means we need to bundle a TIFS binary firmware image for the M4
    together with a U-Boot SPL when generating a bootloader image for the R5\. Next,
    we need to build **Trusted Firmware-A** (**TF-A**) for the main A53 CPU using
    a 64-bit toolchain. Lastly, we configure and build a U-Boot SPL and TPL for the
    main CPU.
  prefs: []
  type: TYPE_NORMAL
- en: Obtaining a 32-bit toolchain
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Point your web browser at [https://developer.arm.com/downloads/-/arm-gnu-toolchain-downloads](https://developer.arm.com/downloads/-/arm-gnu-toolchain-downloads).
    Search for **Downloads: 13.2.Rel1** and click on the plus sign in front to expand
    that section. Then click on the `arm-gnu-toolchain-13.2.rel1-x86_64-arm-none-eabi.tar.xz`
    file under x86_64 Linux hosted cross toolchains **AArch32 bare-metal target**(**arm-none-eabi**)
    to download the toolchain.'
  prefs: []
  type: TYPE_NORMAL
- en: The following R5 exercises were successfully performed with that version of
    the Arm GNU toolchain. I recommend downloading the same version from that web
    page (if it is still available) to prevent any problems.
  prefs: []
  type: TYPE_NORMAL
- en: 'Install the 32-bit toolchain in your home directory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Add the 32-bit toolchain to your `PATH` environment variable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: You are now ready to build U-Boot for the R5\. Make sure to replace `13.2.rel1`
    and `13.2.Rel1` in the preceding commands with the actual version of the 32-bit
    toolchain you downloaded.
  prefs: []
  type: TYPE_NORMAL
- en: Building U-Boot SPL for R5
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Support for BeaglePlay in mainline U-Boot was very new back in November 2023
    when I wrote this. For this reason, I have instead opted to use BeagleBoard.org’s
    U-Boot fork for BeaglePlay. I suggest building the U-Boot source from the same
    Git repo (if it is still available) to prevent any problems.
  prefs: []
  type: TYPE_NORMAL
- en: 'Clone the U-Boot fork to your home directory and check out a stable commit:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Install the packages needed to build U-Boot for BeaglePlay:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Configure and build U-Boot for the R5:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, create a build directory for the R5 one level up to share build artifacts
    across builds:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, set the `ARCH` and `CROSS_COMPILE` environment variables for 32-bit Arm:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Select `am62x_evm_r5_defconfig` for building:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Run `make menuconfig` to configure U-Boot further for building:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Drill down into the **Environment** submenu.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Select **Environment is in a EXT4 filesystem**.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '![Figure 3.5 – Selecting Environment is in a EXT4 fileystem](img/B18466_03_05.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.5 – Selecting Environment is in a EXT4 fileystem
  prefs: []
  type: TYPE_NORMAL
- en: Deselect any other options (e.g., MMC, NAND, and SPI) for environment storage
    on that menu page.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Enter `mmc` in the **Name of the block device for the environment** text field.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 3.6 – Name of the block device for the environment](img/B18466_03_06.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.6 – Name of the block device for the environment
  prefs: []
  type: TYPE_NORMAL
- en: Enter `1:2` in the **Device and partition for where to store the environment
    in EXT4** text field.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 3.7 – Device and partition for where to store the environment in EXT4](img/B18466_03_07.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.7 – Device and partition for where to store the environment in EXT4
  prefs: []
  type: TYPE_NORMAL
- en: Ensure `/uboot.env` is the **Name of the EXT4 file to use for the environment**
    text field.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 3.8 – Environment](img/B18466_03_08.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.8 – Environment
  prefs: []
  type: TYPE_NORMAL
- en: Back out of the **Environment** submenu.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Drill down into the **SPL/TPL** submenu.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select **Support EXT filesystems**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 3.9 – Select Support EXT4 filesystems](img/B18466_03_09.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.9 – Select Support EXT4 filesystems
  prefs: []
  type: TYPE_NORMAL
- en: Back out of the **SPL/TPL** submenu.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Drill down into the **Boot Options** submenu.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select **Enable a default value for bootcmd**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 3.10 – Select Enable a default value for bootcmd](img/B18466_03_10.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.10 – Select Enable a default value for bootcmd
  prefs: []
  type: TYPE_NORMAL
- en: Enter `echo 'no bootcmd yet'` in the **bootcmd value** text field.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 3.11 – bootcmd value](img/B18466_03_11.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.11 – bootcmd value
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.12 – Boot options](img/B18466_03_12.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.12 – Boot options
  prefs: []
  type: TYPE_NORMAL
- en: Exit out of `menuconfig` and choose **Yes** when asked to save your new configuration.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Lastly, build the U-Boot for the R5:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: When U-Boot is done building, there should be an SPL binary for the R5 in `../build_uboot/r5/spl`.
  prefs: []
  type: TYPE_NORMAL
- en: Refer to the boot flow sequence diagram in `doc/board/beagle/am62x_beagleplay.rst`.
  prefs: []
  type: TYPE_NORMAL
- en: Generating an image for the R5
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Recall that the TIFS firmware image that gets loaded into the M4 needs to be
    bundled together with the U-Boot SPL for the R5\. We obtain the binary TIFS firmware
    image directly from TI.
  prefs: []
  type: TYPE_NORMAL
- en: 'Clone the TI firmware repo to your home directory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Bundling the TIFS firmware image for the M4 together with the U-Boot SPL for
    the R5 requires a tool named `k3-image-gen`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Clone the `k3-image-gen` repo to your home directory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Generate the combined image for the R5 by running `make` in the `k3-image-gen`
    directory with paths to the U-Boot SPL and TIFS firmware image passed in as arguments:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: There should now be a `tiboot3.bin` file in the `k3-image-gen` directory.
  prefs: []
  type: TYPE_NORMAL
- en: Refer to the boot flow sequence diagram in `doc/board/beagle/am62x_beagleplay.rst`.
  prefs: []
  type: TYPE_NORMAL
- en: Building TF-A for the main A53 CPU
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The A53 in BeaglePlay’s `am62x` SoC is a 64-bit CPU, so we must switch to a
    64-bit toolchain to cross-compile source code for it. We will use the same 64-bit
    Bootlin toolchain from [*Chapter 2*](Chapter_01.xhtml#_idTextAnchor028) that you
    installed in your home directory.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add that 64-bit Bootlin toolchain to your `PATH` environment variable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: Make sure to replace `2024.02-1` in the preceding commands with the actual version
    of the 64-bit toolchain you downloaded.
  prefs: []
  type: TYPE_NORMAL
- en: 'Clone the TF-A source code to your home directory and check out a stable release
    tag:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Configure and build TF-A for the A53:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Set the `ARCH` and `CROSS_COMPILE` environment variables for 64-bit Arm:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Build TF-A for the A53 specifying `k3` as the platform and `lite` as the target
    board:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: When TF-A is done building, there should be a `bl31.bin` for the A53 in `./build/k3/lite/release`.
  prefs: []
  type: TYPE_NORMAL
- en: Refer to the boot flow sequence diagram in `doc/board/beagle/am62x_beagleplay.rst`.
  prefs: []
  type: TYPE_NORMAL
- en: Building U-Boot for the main A53 CPU
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: All the build steps performed up until now are unique to the `am62x` SoC in
    BeaglePlay. Building U-Boot for most targets only requires compiling an SPL and
    TPL for the main CPU. We will use the same 64-bit Bootlin toolchain from [*Chapter
    2*](Chapter_01.xhtml#_idTextAnchor028)that you installed in your home directory.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add that 64-bit Bootlin toolchain to your `PATH` environment variable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: Make sure to replace `2024.02-1` in the preceding commands with the actual version
    of the 64-bit toolchain you downloaded.
  prefs: []
  type: TYPE_NORMAL
- en: 'Configure and build U-Boot for the A53:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, navigate back to the `u-boot` source tree for BeaglePlay:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, create a build directory for the A53 one level up:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Set the `ARCH` and `CROSS_COMPILE` environment variables for 64-bit Arm:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Select `am62x_evm_a53_defconfig` for building:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Run `make menuconfig` to configure U-Boot further for building:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Drill down into the **Environment** submenu.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select **Environment is in a EXT4 filesystem**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Deselect any other options (e.g., MMC, NAND, and SPI) for environment storage
    on that menu page.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Enter `mmc` in the **Name of the block device for the environment** text field.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Enter `1:2` in the **Device and partition for where to store the environment
    in EXT4** text field.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Ensure `/uboot.env` is entered in the **Name of the EXT4 file to use for the
    environment** text field.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Back out of the **Environment** submenu.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Drill down into the **SPL/TPL** submenu.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select **Support EXT filesystems**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Back out of the **SPL/TPL** submenu.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Drill down into the **Boot Options** submenu.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select **Enable a default value for bootcmd**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Enter `echo 'no bootcmd yet'` in the **bootcmd value** text field.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Exit out of `menuconfig` and choose **Yes** when asked to save your new configuration.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Lastly, build U-Boot for the A53 passing paths to TI’s TF-A and DM firmware
    as arguments to `make`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '**IMPORTANT NOTE**'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Always use absolute paths as opposed to relative `./` paths to point to the
    `ATF` and `DM` firmware in your `make` command. Otherwise, the resulting SPL and
    U-Boot binaries will be incorrect in size and content.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'The results of the compilation are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`u-boot`: U-Boot in ELF format, suitable for use with a debugger'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`u-boot.map`: The symbol table'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`u-boot.bin`: U-Boot in raw binary format, suitable for running on your device'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`u-boot.img`: `u-boot.bin` with a U-Boot header added, suitable for uploading
    to a running copy of U-Boot'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`u-boot.srec`: U-Boot in Motorola S-record (**SRECORD** or **SRE**) format,
    suitable for transferring over a serial connection'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'BeaglePlay also requires an SPL, as described earlier. This is built at the
    same time and is named `tispl.bin` (the boot flow sequence diagram in `doc/board/beagle/am62x_beagleplay.rst`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: The procedure is similar for other targets.
  prefs: []
  type: TYPE_NORMAL
- en: Installing U-Boot
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Installing a bootloader on a board for the first time requires some manual intervention.
    If the board has a hardware debug interface, such as a **Joint Test Action Group**
    (**JTAG**), it is usually possible to load a copy of U-Boot directly into RAM
    and get it running. From that point, you can use U-Boot commands so that it copies
    itself into flash memory. The details are very board-specific and outside the
    scope of this book.
  prefs: []
  type: TYPE_NORMAL
- en: Many SoC designs have a boot ROM built in that can be used to read boot code
    from various external sources, such as SD cards, serial interfaces, or USB mass
    storage. This is the case with the `am62x` chip in the Beagle, which makes it
    easy to try out new software.
  prefs: []
  type: TYPE_NORMAL
- en: 'You will need a microSD card reader to write the images to a card. There are
    two types: external readers that plug into a USB port and the internal SD readers
    that are present on many laptops. A device name is assigned by Linux when a card
    is plugged into the reader. The `lsblk` command is a useful tool for finding out
    which device has been allocated. For example, this is what I see when I plug a
    nominal 32 GB microSD card into my card reader:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: In this case, `nvme0n1` is my 512 GB hard drive and `sda` is the microSD card.
    It has a single partition, `sda1`, which is mounted as the `/media/frank/6662-6262`
    directory.
  prefs: []
  type: TYPE_NORMAL
- en: 'If I use the built-in SD card slot, I see this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: In this case, the microSD card appears as `mmcblk0`, and the partition is `mmcblk0p1`.
    Note that the microSD card you use may have been formatted differently than this
    one, so you may see a different number of partitions with different mount points.
    When formatting an SD card, it is very important to be sure of its device name.
    You really don’t want to mistake your hard drive for an SD card and format that
    instead.
  prefs: []
  type: TYPE_NORMAL
- en: 'This has happened to me more than once. So, I have provided a shell script
    in this book’s code repo named `MELD/format-sdcard.sh`, which has a reasonable
    number of checks to prevent you (and me) from using the wrong device name. The
    parameter is the device name of the microSD card, which would be `sda` in the
    first example and `mmcblk0` in the second. Here is an example of its use:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: The script creates two partitions. The first is 128 MB and formatted as FAT32,
    and it will contain the bootloader, while the second is 1 GB and formatted as
    ext4, which you will use in [*Chapter 5*](Chapter_05.xhtml#_idTextAnchor138).
    The script aborts when it’s applied to any drive greater than 128 GB so be prepared
    to modify it if you are using larger microSD cards.
  prefs: []
  type: TYPE_NORMAL
- en: Once you have formatted the microSD card, remove it from the card reader and
    then reinsert it. Roll over and click on one of the USB stick icons that appears
    to the left of the Ubuntu desktop so that a window opens for the `boot` partition.
    On current versions of Ubuntu, the two partitions are mounted as `/media/<user>/boot`
    and `/media/<user>/rootfs`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Copy `tiboot3.bin`, `tispl.bin` and `u-boot.img` to the `boot` partition like
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: Right-click on either of the two USB stick icons and select **Eject** to unmount
    the microSD card. Lastly, remove the microSD card from your host machine’s card
    reader.
  prefs: []
  type: TYPE_NORMAL
- en: 'To boot BeaglePlay from your newly prepared microSD card:'
  prefs: []
  type: TYPE_NORMAL
- en: With no power on BeaglePlay, insert the microSD card into BeaglePlay’s reader.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Plug the USB side of your USB-to-TTL serial cable into your host machine. Make
    sure your cable has a 3.3 V logic level.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The three-pin UART connector is right next to the USB-C connector on BeaglePlay.
    Do not connect a fourth red wire from your cable. A red wire typically indicates
    power, which is unnecessary in this instance and could damage the board.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Connect the TX wire from the cable to the RX pin on BeaglePlay.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Connect the RX wire from the cable to the TX pin on BeaglePlay.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Connect the GND (black) wire from the cable to the GND pin on BeaglePlay.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A serial port should appear on your PC as `/dev/ttyUSB0`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Start a suitable terminal program, like `gtkterm`, `minicom`, or `picocom`,
    and attach it to the port at 115,200 **bits per second** (**bps**) with no flow
    control. `gtkterm` is probably the easiest to set up and use:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: If you get a permissions error, then you may need to add yourself to the `dialout`
    group to use this port or launch `gtkterm` with `sudo`. If garbled or no output
    appears on the serial console, then swap the wires connected to the RX and TX
    pins on BeaglePlay.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Press and hold the USR button on BeaglePlay.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Power up the board using USB-C.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Release the button after about 5 seconds.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'You should see some output followed by a U-Boot prompt on the serial console:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: Hit any key on your keyboard to stop U-Boot from autobooting with the default
    environment. Now that we have a U-Boot prompt in front of us, let’s put U-Boot
    through its paces.
  prefs: []
  type: TYPE_NORMAL
- en: Using U-Boot
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this section, I describe some of the common tasks that can be performed with
    U-Boot.
  prefs: []
  type: TYPE_NORMAL
- en: U-Boot provides a command-line interface over a serial port. It provides a command
    prompt that is customized for each board. In these examples, I use `=>` for the
    command prompt. Typing `help` prints out all the commands that have been configured
    in this version of U-Boot. Typing `help <command>` prints out more information
    about a particular command.
  prefs: []
  type: TYPE_NORMAL
- en: The default command interpreter for BeaglePlay is quite simple. You cannot do
    command-line editing by pressing the left or right keys. There is no command completion
    by pressing the *Tab* key, and there is no command history by pressing the up
    arrow key. Pressing any of these keys will disrupt the command you are currently
    trying to type, and you will have to type *Ctrl + C* and start all over again.
    The only line editing key you can safely use is the backspace.
  prefs: []
  type: TYPE_NORMAL
- en: As an option, you can configure a different command shell called **Hush**, which
    has more sophisticated interactive support, including command-line editing.
  prefs: []
  type: TYPE_NORMAL
- en: 'The default number format is hexadecimal. Consider the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: This will read `0x200000` bytes from offset `0x400000` from the start of the
    NAND flash memory into RAM address `0x82000000`.
  prefs: []
  type: TYPE_NORMAL
- en: Environment variables
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'U-Boot uses environment variables extensively to store and pass information
    between functions and even to create scripts. Environment variables are simple
    `name=value` pairs that are stored in an area of memory. The initial population
    of variables may be coded in the board configuration header file like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: You can create and modify variables from the U-Boot command line using `setenv`.
    For example, `setenv foo bar` creates the `foo` variable with the `bar` value.
    Note that there is no `=` sign between the variable name and the value. You can
    delete a variable by setting it to a null string using `setenv foo`. You can print
    all the variables to the console using `printenv`, or you can print a single variable
    using `printenv foo`.
  prefs: []
  type: TYPE_NORMAL
- en: If U-Boot has been configured with space to store the environment, you can use
    the `saveenv` command to save it. If there is raw NAND or NOR flash, then an erase
    block can be reserved for this purpose, often with another erase block being used
    as a redundant copy to guard against corruption. If there is eMMC or SD card storage,
    it can be stored in a reserved array of sectors, or in a file named `uboot.env`
    in a partition of the disk. Other options include storing it in serial **Electrical
    Erasable Programmable Read Only Memory** (**EEPROM**) connected via an I2C or
    SPI interface or non-volatile RAM.
  prefs: []
  type: TYPE_NORMAL
- en: Boot image format
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'U-Boot doesn’t have a filesystem. Instead, it tags blocks of information with
    a 64-byte header so that it can track the contents. We prepare files for U-Boot
    using the `mkimage` command-line tool, which comes bundled with the `u-boot-tools`
    package on Ubuntu. You can also get `mkimage` by running `make tools` from within
    the U-Boot source tree and then invoke it as `tools/mkimage`. Here is a summary
    of the command’s usage:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'For example, to prepare a kernel image for a 32-bit Arm processor, you can
    use the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: In this instance, the architecture is `arm`, the operating system is `linux`,
    and the image type is `kernel`. Additionally, the compression scheme is `gzip`,
    the load address is `0x80008000`, and the entry point is the same as the load
    address. Lastly, the image name is `Linux`, the image datafile is named `zImage`,
    and the image being generated is named `uImage`.
  prefs: []
  type: TYPE_NORMAL
- en: Loading images
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Usually, you load images from removable storage such as an SD card or over
    a network. SD cards are handled in U-Boot by the MMC driver. Here is an example
    of loading a file from a microSD card into memory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'The `mmc rescan` command re-initializes the MMC driver, perhaps to detect that
    an SD card has recently been inserted. Next, `fatload` is used to read a file
    from a FAT-formatted partition on the SD card. Note that `tiboot3.bin` is the
    firmware image for the R5, not a Linux kernel image, so it cannot be executed
    at this point in the boot sequence. The format for the `fatload` command is as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: If `<interface>` is `mmc`, as in our case, then `<dev:part>` is the device number
    of the MMC interface counting from zero and the partition number counting from
    one. Hence, `<1:1>` is the first partition on the second device, which is `mmc
    1` for the microSD card on BeaglePlay (the onboard eMMC is `mmc 0`). The chosen
    memory location of `0x80000000` is in an area of RAM that is not being used at
    this moment.
  prefs: []
  type: TYPE_NORMAL
- en: To load kernel image files over a network, you must use the **Trivial File Transfer
    Protocol** (**TFTP**). This requires you to install `tftpd` (a TFTP daemon) on
    your development system and start running it. You must also configure any firewalls
    between your PC and the target board to allow the TFTP protocol on UDP port `69`
    to pass through.
  prefs: []
  type: TYPE_NORMAL
- en: 'The default configuration of TFTP only allows access to the `/var/lib/tftpboot`
    directory. The next step is to copy the files you want to transfer to the target
    into that directory. Then, assuming that you are using a pair of static IP addresses,
    which removes the need for further network administration, the sequence of commands
    to load a kernel image file looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, let’s look at how to program images into NAND flash memory and read
    them back. This is handled by the `nand` command. This example loads a kernel
    image via TFTP and programs it into flash:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, you can load the kernel from flash memory using the `nand read` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: Once the kernel has been loaded into RAM, we can boot it.
  prefs: []
  type: TYPE_NORMAL
- en: Booting Linux
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `bootm` command starts a kernel image running. The syntax is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'The address of the kernel image is necessary, but the addresses of the `ramdisk`
    and `dtb` can be omitted if the kernel configuration does not need them. If there
    is a `dtb` but no `initramfs`, then the second address can be replaced with a
    dash. That would look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: Typing a long series of commands to boot your board each time it is powered
    up is clearly not acceptable. Let’s look at how to automate the boot process.
  prefs: []
  type: TYPE_NORMAL
- en: Automating the boot with U-Boot scripts
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: U-Boot stores a sequence of commands in environment variables. If a special
    variable named `bootcmd` contains a script, then it is run at power-up after a
    delay of `bootdelay` seconds. If you watch this on the serial console, you will
    see the delay counting down to zero. You can press any key during this period
    to terminate the countdown and enter an interactive session with U-Boot.
  prefs: []
  type: TYPE_NORMAL
- en: 'The way that you create scripts is simple, though it’s not easy to read. You
    simply append commands separated by semicolons, which must be preceded by a *\*
    escape character. For example, to load a kernel image from an offset in flash
    memory and boot it, you might use the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: We now know how to boot a kernel on BeaglePlay using U-Boot. But how do we port
    U-Boot to a new board that has no BSP? We’ll cover that in the remainder of this
    chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Porting U-Boot to a new board
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let’s assume that your hardware department has created a new board called **Nova**
    that is based on BeaglePlay and that you need to port U-Boot to it. You will need
    to understand the layout of the U-Boot code and how the board configuration mechanism
    works. In this section, I will show you how to create a variant of an existing
    board – BeaglePlay – which you could go on to use as the basis for further customizations.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are quite a few files that need to be changed. I have put them together
    into a patch file at `MELD/Chapter03/0001-BSP-for-Nova.patch` in the book’s code
    repo. You can simply apply that patch to a clean copy of the U-Boot fork for BeaglePlay
    and rebuild it like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'If you want to use a different version of U-Boot, you will have to regenerate
    the patch yourself for it to apply cleanly. The remainder of this section describes
    how the patch was created. To skip these details, run the preceding commands and
    jump to the end of the *Building and testing* portion of this section. To follow
    along step by step, you will need a clean copy of the U-Boot fork for BeaglePlay
    without the Nova BSP patch applied. The main directories we will be dealing with
    are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`arch`: Contains code that’s specific to each supported architecture in the
    `arm`, `mips`, and `powerpc` directories. Within each architecture, there is a
    subdirectory for each member of the family. For example, in `arch/arm/cpu` there
    are directories for the various architecture variants, including `arm926ejs`,
    `armv7`, and `armv8`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`board`: Contains code that’s specific to a board. Where there are several
    boards from the same vendor, they are collected into a subdirectory. Hence, the
    code for the `am62x` EVM board, which BeaglePlay is based on, is in `board/ti/am62x`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`common`: Contains core functions including the command shells and the commands
    that can be called from them each in a file named `cmd_<command name>.c`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`doc`: Contains several `.rst` files describing various aspects of U-Boot.
    If you are wondering how to proceed with your U-Boot port, this is a good place
    to start.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`include`: In addition to many shared header files, this contains the important
    `include/configs` subdirectory, where you will find the majority of the board
    configuration settings.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The way that `Kconfig` extracts configuration information from `Kconfig` files
    and stores the total system configuration in a file named `.config` will be described
    in some detail in [*Chapter 4*](Chapter_04.xhtml#_idTextAnchor096). Each board
    has a default configuration stored in `configs/<board name>_defconfig`. For the
    Nova board, we can begin by making a copy of the configuration for the EVM:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, edit `configs/nova_defconfig` and replace `CONFIG_TARGET_AM625_A53_EVM=y`
    with `CONFIG_TARGET_NOVA=y` as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: Note that `CONFIG_ARM=y` causes the contents of `arch/arm/Kconfig` to be included.
  prefs: []
  type: TYPE_NORMAL
- en: We are now done modifying `configs/nova_defconfig`.
  prefs: []
  type: TYPE_NORMAL
- en: Board-specific files
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Each board has a subdirectory named `board/<board name>` or `board/<vendor>/<board
    name>` that should contain the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Kconfig`: Contains the configuration options for the board.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`MAINTAINERS`: Contains a record of whether the board is currently maintained
    and, if so, by whom.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Makefile`: Used to build the board-specific code.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In addition, there may be source files for board-specific functions.
  prefs: []
  type: TYPE_NORMAL
- en: 'Our Nova board is based on BeaglePlay, which in turn is based on a TI `am62x`
    EVM. So, we should make copies of the `am62x` board files:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: 'First, modify `board/ti/nova/Makefile` so that `nova.c` is compiled instead
    of `evm.c`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: Duplicating `evm.c` as `nova.c` lets you change how U-Boot interacts with your
    custom board.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, edit `board/ti/nova/Kconfig`:'
  prefs: []
  type: TYPE_NORMAL
- en: Change the `"TI K3 AM62x based boards"` string under `prompt` to say `"TI K3
    AM62x based Nova! board"`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Rename `TARGET_AM625_A53_EVM` to `TARGET_NOVA`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Delete `TARGET_AM625_R5_EVM` along with all its items.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Set `SYS_BOARD` to `"nova"` so that it will build the files in `board/ti/nova`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Set `SYS_CONFIG_NAME` to `"nova"` so that it will use `include/configs/nova.h`
    as the configuration file.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The modified `board/ti/nova/Konfig` should look as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we need to link the `Kconfig` file for Nova into the chain of `Kconfig`
    files. First, edit `arch/arm/Kconfig` and insert `source "board/ti/nova/Kconfig"`
    after `source "board/tcl/sl50/Kconfig"`, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: Now that we have copied and modified the board-specific files for our Nova board,
    let’s move on to the header files.
  prefs: []
  type: TYPE_NORMAL
- en: Configuring header files
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Each board has a header file in `include/configs` that contains most of the
    configuration information. The file is named by the `SYS_CONFIG_NAME` identifier
    in the board’s `Kconfig` file. The format of this file is described in detail
    in the `README` file at the top level of the U-Boot source tree. For the purposes
    of our Nova board, simply copy `include/configs/am62x_evm.h` into `include/configs/nova.h`
    and make a few changes, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: First, replace `__CONFIG_AM625_EVM_H` with `__CONFIG_NOVA_H`. Next, redefine
    `CONFIG_SYS_PROMPT` so that we can identify this bootloader at runtime. Lastly,
    replace `CONFIG_TARGET_AM625_A53_EVM` with `CONFIG_TARGET_NOVA` so that `CONFIG_SPL_MAX_SIZE`
    and `CONFIG_SYS_INIT_SP_ADDR` are defined correctly.
  prefs: []
  type: TYPE_NORMAL
- en: With the source tree fully modified, we are now ready to build U-Boot for our
    custom board.
  prefs: []
  type: TYPE_NORMAL
- en: Building and testing
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To build U-Boot for the Nova board:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, navigate back to the U-Boot source tree for BeaglePlay:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, set the `ARCH` and `CROSS_COMPILE` environment variables for 64-bit Arm:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Clean out any previous build artifacts:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Select `nova_defconfig` for building:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Run `make menuconfig` to configure U-Boot further for building:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Drill down into the **Environment** submenu.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select **Environment is in a EXT4 filesystem**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Deselect any other options (e.g., MMC, NAND, and SPI) for environment storage
    on that menu page.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Enter `mmc` in the **Name of the block device for the environment** text field.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Enter `1:2` in the **Device and partition for where to store the environment
    in EXT4** text field.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Ensure `/uboot.env` is entered in the **Name of the EXT4 file to use for the
    environment** text field.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Back out of the **Environment** submenu.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Drill down into the **SPL/TPL** submenu.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select **Support EXT filesystems**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Back out of the **SPL/TPL** submenu.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Drill down into the **Boot Options** submenu.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select **Enable a default value for bootcmd**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Enter `echo 'no bootcmd yet'` in the **bootcmd value** text field.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Exit out of `menuconfig` and choose **Yes** when asked to save your new configuration.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Save the modified `defconfig`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Update `nova_defconfig` with your changes:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Lastly, build U-Boot for the A53, passing paths to TI’s TF-A and DM firmware
    as arguments to `make`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Copy `tispl.bin` and `u-boot.img` to the `boot` partition of the microSD card
    you created earlier:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Reinsert the microSD card into BeaglePlay and reapply power while holding down
    the USR button. You should see output like this (note the custom command prompt)
    on the serial console:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: 'You can create a patch for all these changes by checking them into Git and
    using the `git format-patch` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: Generating this patch concludes our coverage of U-Boot as a TPL. U-Boot can
    also be configured to bypass the TPL stage of the boot process altogether. Next,
    let’s examine this alternate approach to booting Linux.
  prefs: []
  type: TYPE_NORMAL
- en: Falcon mode
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We are used to the idea that booting a modern embedded processor involves the
    boot ROM loading an SPL, which loads `u-boot.bin`, which then loads a Linux kernel.
    You may be wondering if there is a way to reduce the number of steps, thereby
    simplifying and speeding up the boot process. The answer is U-Boot Falcon mode.
  prefs: []
  type: TYPE_NORMAL
- en: 'The idea is simple: have the SPL load a kernel image directly skipping over
    `u-boot.bin`. There is no user interaction and there are no scripts. It just loads
    a kernel from a known location in flash memory or eMMC into memory, passes it
    a pre-prepared parameter block, and starts running it. The details of configuring
    Falcon mode are beyond the scope of this book.'
  prefs: []
  type: TYPE_NORMAL
- en: '**IMPORTANT NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: Falcon mode is named after the peregrine falcon, which is the fastest bird of
    all, capable of reaching speeds of more than 200 miles per hour in a dive.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Every system needs a bootloader to bring the hardware to life and to load a
    kernel. U-Boot has found favor with many developers because it supports a useful
    range of hardware, and it is fairly easy to port to a new device.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we learned how to inspect and drive U-Boot interactively from
    the command line over a serial console. These command-line exercises included
    loading a kernel over a network using TFTP for rapid iteration. Lastly, we learned
    how to port U-Boot to a new device by generating a patch for our Nova board.
  prefs: []
  type: TYPE_NORMAL
- en: Over the last few years, the complexity and ever-increasing variety of embedded
    hardware has led to the introduction of the device tree as a way of describing
    hardware. The device tree is simply a textual representation of a system that
    is compiled into a device tree binary, which is passed to the kernel when it loads.
    It is up to the kernel to interpret the device tree and to load and initialize
    drivers for the devices it finds there.
  prefs: []
  type: TYPE_NORMAL
- en: U-Boot is very flexible, allowing images to be loaded from mass storage, flash
    memory, or a network and then booted. Having covered some of the intricacies of
    booting Linux, in the next chapter, we will cover the next stage of the process.
    This is the third element of your embedded project – the kernel.
  prefs: []
  type: TYPE_NORMAL
