- en: '*Chapter 15*: Troubleshooting Shell Scripts'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第15章*：Shell 脚本故障排除'
- en: If you have come this far, you must have a lot of ideas about how to write a
    shell script, and even more questions about the ways you can make particular things
    in scripts work. This is completely normal. Your scripting journey has just started.
    No amount of reading can make up for time spent writing scripts, trying out different
    solutions, and understanding how different commands work.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你已经读到这里，说明你一定对如何编写 shell 脚本有了很多想法，也会有更多关于如何让脚本中的某些功能正常工作的问题。这是完全正常的。你的脚本之旅才刚刚开始。没有多少阅读能代替写脚本、尝试不同解决方案以及理解不同命令如何工作的实践时间。
- en: We have some good news and some bad news for you. Being good at scripting takes
    a long time and, in scripting, most of that time is going to be spent trying to
    understand what your script should be doing and, usually, why it is doing it wrong.
    The good news is that scripting is never boring.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有一些好消息和一些坏消息要告诉你。擅长编写脚本需要很长时间，而且在编写脚本时，大部分时间将用于理解你的脚本应该做什么，通常还要搞清楚为什么它做错了。好消息是，编写脚本永远不会让人感到无聊。
- en: In this chapter, we will try to give you the tools needed to debug and troubleshoot
    scripts quickly and without a lot of confusion. The tools are going to be in the
    form of different methods you can use to maximize your ability to find logical
    and, sometimes, syntactical errors in scripts. We are going to start with the
    basic recipes and go on to more complex ways to work on scripts.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将尽量为你提供调试和排除脚本故障的工具，帮助你快速而不混乱地解决问题。这些工具将以不同的方法形式出现，帮助你最大化找到脚本中的逻辑和有时是语法错误的能力。我们将从基本的技巧开始，逐步过渡到更复杂的脚本调试方法。
- en: 'We will cover the following recipes in this chapter:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下几个方法：
- en: Common scripting mistakes
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 常见的脚本错误
- en: Simple debugging approach – echoing values during script execution
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 简单的调试方法——在脚本执行期间输出变量值
- en: Using the `bash` `-x` and `-v` options
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `bash` 的 `-x` 和 `-v` 选项
- en: Using `set` to debug a part of the script
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `set` 来调试脚本的一部分
- en: Technical requirements
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'In this chapter, we are going to use the same machine as in all the previous
    chapters on scripting in this book. Do not be alarmed that there are a couple
    of screenshots that are made in Windows. They are there just to illustrate a point;
    you don''t need Windows to do anything. Just like earlier, we are using the following:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将使用与本书前面所有关于脚本编写章节相同的机器。请不要因为有几张截图是 Windows 系统下制作的而感到惊慌。它们仅用于说明某个观点；你并不需要
    Windows 来做任何事情。就像之前一样，我们使用的是以下内容：
- en: A virtual machine with Linux installed, any distribution (in our case, it's
    going to be *Ubuntu 20.10*)
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 安装了 Linux 的虚拟机，任何版本的 Linux（在我们的案例中，将是*Ubuntu 20.10*）
- en: Now, let's dive into troubleshooting.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们深入探讨故障排除。
- en: Common scripting mistakes
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 常见的脚本错误
- en: Writing a script will present many problems, including how to design it, how
    to find the right solutions to different problems, and how to make all of this
    usable in the target environment. These can be things you can easily solve in
    a couple of minutes, or things you will spend days or even weeks trying to solve.
    All this time will probably just be a small percentage of the total time you will
    spend debugging and troubleshooting scripts. Writing and troubleshooting scripts
    are two wholly different things – while you usually write your own scripts from
    scratch, you will not only debug and troubleshoot your own code.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 编写脚本将会遇到许多问题，包括如何设计脚本、如何找到适合不同问题的解决方案，以及如何将这一切应用到目标环境中。这些问题有些可能在几分钟内就能轻松解决，也有些可能需要你花费几天甚至几周时间来解决。所有这些时间可能只是你调试和排除脚本问题时所花费时间的一小部分。编写脚本和排除脚本问题是两件完全不同的事情——虽然你通常会从零开始编写自己的脚本，但你不仅仅会调试和排除自己的代码。
- en: Writing requires skill and deep knowledge of your environment, but it can be
    argued that to debug and troubleshoot, you need even more understanding of both
    your task and the way your script is trying to accomplish it. In this recipe,
    we are going to work on the skills you need to understand not only how to troubleshoot
    scripts you have written, but also any scripting code you run into, whether it's
    a part of something you've created or a separate system created by someone else
    that you are responsible for getting running.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 编写脚本需要技巧和对环境的深刻理解，但可以说，为了调试和排查故障，你需要更深入地理解任务以及脚本试图如何完成任务。在这个教程中，我们将学习如何掌握技能，不仅能够调试自己编写的脚本，还能理解任何遇到的脚本代码，无论是你自己创建的部分，还是由其他人创建的系统，你需要负责让它正常运行。
- en: Getting ready
  id: totrans-16
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备开始
- en: Troubleshooting and debugging sound and look like the same task, but they are
    subtly different. In general, when we are debugging, we are concentrating on finding
    logical and other errors in our scripts. When troubleshooting, we are not only
    debugging but also trying gain more understanding of what should be done and how
    your application is trying to accomplish it. In the recipes in this chapter, we
    are going to use both these expressions for one thing – trying to make something
    that is not working correctly work as it should, or at least better.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 故障排除和调试看起来像是同一任务，但它们有细微的不同。一般来说，当我们在调试时，我们集中精力寻找脚本中的逻辑错误和其他错误。而在故障排除时，我们不仅在调试，还在尝试更好地理解应该做什么，以及你的应用程序如何尝试完成这些任务。在本章的教程中，我们将这两个术语一起使用——试图让那些不正常工作的东西恢复正常，或者至少表现得更好。
- en: There are a few things you can do to make this as easy as possible, and one
    of them is to get as much knowledge as possible about scripting under your belt.
    Being able to understand scripts and the specific ways things are done to solve
    them will enable you to quickly understand not only what the problem is but also
    how to solve it.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 有一些方法可以让这个过程尽可能简单，其中之一就是尽量掌握关于脚本的知识。能够理解脚本以及解决问题的具体方法，不仅能帮助你快速了解问题所在，还能帮助你找到解决方法。
- en: Sometimes the solution may be to simplify a part of code using a standard solution,
    or break code into different, more standardized modules.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 有时候，解决方案可能是使用标准的解决方案简化代码的某个部分，或者将代码拆分成不同的、更标准化的模块。
- en: When faced with a more complex script, this method of breaking code down into
    more manageable and understandable modules can be amazingly successful since even
    the greatest script-writers sometimes completely miss the point of what they are
    doing and complicate even the simplest tasks.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 当面对更复杂的脚本时，将代码分解成更易管理和理解的模块，这种方法可能会非常成功，因为即使是最优秀的脚本编写者，有时也会完全忽略他们所做事情的关键，甚至把最简单的任务都搞复杂了。
- en: 'When talking about debugging, we need to talk about errors. Broadly, we can
    have four different outcomes from our script:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 说到调试，我们需要谈谈错误。大致来说，我们的脚本可能有四种不同的结果：
- en: The script works as desired.
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 脚本按预期工作。
- en: The script throws an error.
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 脚本抛出错误。
- en: The script works but not completely, making errors.
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 脚本工作，但不完全，产生错误。
- en: The script works but sometimes silently breaks something either in the input
    or output data.
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 脚本可以工作，但有时会默默地破坏输入或输出数据中的某些内容。
- en: When we have the time, we can work on any of these possible outcomes and make
    a script behave better, even one that works correctly. Sometimes it pays to spend
    some time to make your script more beautiful, more commented, and more readable,
    even if it works alright.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们有时间时，我们可以着手处理这些可能的结果，并让脚本表现得更好，即使它已经正常工作。有时，花点时间让你的脚本更加优雅、注释更加清晰、代码更具可读性，哪怕它本来就能正常工作，这也是值得的。
- en: Another case is scripts throwing an error. Bash has a reputation for having
    cryptic and generic error messages. Some of them are too vague to be of much assistance,
    and sometimes they make no sense at all and don't help us to understand what is
    actually wrong.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个情况是脚本抛出错误。Bash因其晦涩且通用的错误信息而闻名。其中一些信息过于模糊，难以提供帮助，有时甚至完全没有意义，无法帮助我们理解到底哪里出了问题。
- en: 'One common example that you will notice from time to time is not understanding
    ends of lines correctly. Windows and Linux treat ends of lines differently. While
    Windows terminate text files using both the carriage return and new line characters,
    Linux only uses new line characters for line termination. Bash can have a problem
    with that, and scripts written on Windows will sometimes break for no apparent
    reason. This is the same script on Windows and Linux, with an editor that shows
    all the characters in a file:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 一个常见的例子是有时无法正确理解行尾字符。Windows 和 Linux 处理行尾的方式不同。Windows 在终止文本文件时使用回车符和换行符，而 Linux
    只使用换行符来终止行。Bash 可能会遇到问题，Windows 上编写的脚本有时会在 Linux 上莫名其妙地出错。这是 Windows 和 Linux 上相同的脚本，使用一个显示文件中所有字符的编辑器：
- en: '![Figure 15.1 – In Linux, lines are terminated by a single character'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 15.1 – 在 Linux 中，行通过单个字符终止'
- en: '](img/Figure_15.1_B16269.jpg)'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_15.1_B16269.jpg)'
- en: Figure 15.1 – In Linux, lines are terminated by a single character
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 图 15.1 – 在 Linux 中，行通过单个字符终止
- en: 'In Windows, it looks similar, but we can see that line ends have two characters:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Windows 中，表现类似，但我们可以看到行尾有两个字符：
- en: '![Figure 15.2 – In Windows, two characters are used to terminate a line'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 15.2 – 在 Windows 中，使用两个字符来终止一行'
- en: '](img/Figure_15.2_B16269.jpg)'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_15.2_B16269.jpg)'
- en: Figure 15.2 – In Windows, two characters are used to terminate a line
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 图 15.2 – 在 Windows 中，使用两个字符来终止一行
- en: 'In Linux, if we do not edit the file correctly and forget to strip out extra
    characters, we will end up with characters that will be invisible in a normal
    editor and break the code at the same time:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Linux 中，如果我们没有正确编辑文件并忘记去除多余的字符，最终我们会得到一些在普通编辑器中不可见的字符，并同时破坏代码：
- en: '![Figure 15.3 – In vim, you need to turn on a couple of options to see special
    characters'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 15.3 – 在 vim 中，你需要打开几个选项来查看特殊字符'
- en: '](img/Figure_15.3_B16269.jpg)'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_15.3_B16269.jpg)'
- en: Figure 15.3 – In vim, you need to turn on a couple of options to see special
    characters
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 图 15.3 – 在 vim 中，你需要打开几个选项来查看特殊字符
- en: Note that there is a utility called `dos2unix` (and `unix2dos` if you need conversion
    the other way around) that fixes ends of lines when transferring files. This problem
    is system wide and more than a couple of programs will behave strangely when they
    encounter text files from Windows.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，有一个工具叫做`dos2unix`（如果你需要转换为另一种格式，也有`unix2dos`），它能在传输文件时修复行尾问题。这个问题是系统范围的，许多程序在遇到来自
    Windows 的文本文件时会表现得异常。
- en: 'If we do not deal with characters at the ends of lines, the script will break.
    For example, we tried running the file that came from Windows in Linux, we get
    completely cryptic errors mentioning commands that look like they are not even
    in the script. We are using `dos.sh` as the name of the script that we saved in
    Linux:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们不处理行尾的字符，脚本会出错。例如，我们尝试在 Linux 上运行从 Windows 获取的文件时，出现了完全无法理解的错误，错误信息中提到了看似根本不在脚本中的命令。我们使用`dos.sh`作为在
    Linux 上保存的脚本名称：
- en: '[PRE0]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Also, we need to make it clear that if you use copy and paste to move files
    between your environments, this will fix the problem directly. When you paste
    a line in a particular operating system, it will automatically create the right
    line endings. This does not cover copying and pasting the entire file; if you
    do that, you are transferring the entire file's content.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们需要明确的是，如果你使用复制和粘贴在不同环境之间移动文件，这将直接解决问题。当你在某个操作系统中粘贴一行时，它会自动创建正确的行尾。这个方法并不适用于复制和粘贴整个文件；如果你这么做，你是在传输整个文件的内容。
- en: 'Another common syntax error that can be difficult to find is using the wrong
    quote, either by mixing them up or using a quote instead of a backtick character
    when executing commands inside scripts:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个常见的语法错误是使用错误的引号字符，无论是混用引号，还是在脚本中执行命令时将反引号替换为引号：
- en: '![Figure 15.4 – Completely normal script, highlighted by syntax in vim'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 15.4 – 完全正常的脚本，在 vim 中用语法高亮显示'
- en: '](img/Figure_15.4_B16269.jpg)'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_15.4_B16269.jpg)'
- en: Figure 15.4 – Completely normal script, highlighted by syntax in vim
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 图 15.4 – 完全正常的脚本，在 vim 中用语法高亮显示
- en: 'If we change one backtick to a quote, this will turn into the following:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们将一个反引号改成引号，它将变成如下所示：
- en: '![Figure 15.5 – Without proper highlighting, an error like this can cause serious
    problems'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 15.5 – 如果没有正确的高亮显示，像这样的错误可能会引发严重问题'
- en: '](img/Figure_15.5_B16269.jpg)'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_15.5_B16269.jpg)'
- en: Figure 15.5 – Without proper highlighting, an error like this can cause serious
    problems
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 图 15.5 – 如果没有正确的高亮显示，像这样的错误可能会引发严重问题
- en: We are using vim here, and you will notice the change right away. The editor
    understands syntax and highlights the appropriate code block in a different color.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里使用的是vim，你会立即注意到变化。编辑器理解语法，并以不同的颜色高亮显示适当的代码块。
- en: 'If we try to run this script, it will throw an error:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们尝试运行这个脚本，它会抛出一个错误：
- en: '[PRE1]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: This error is a little confusing. Bash is telling us that it got to the end
    of the file while trying to find the closing quote.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 这个错误有点令人困惑。Bash告诉我们，在试图找到结束引号时，它已经到达了文件的末尾。
- en: One thing all of these errors have in common is using different fonts in different
    editors. Sometimes, the difference between characters is so minor that it is extremely
    hard to spot. Bash makes it even harder by reporting errors that are sometimes
    pointing to a completely different part of the code.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些错误的共同点是使用不同编辑器中的不同字体。有时，字符之间的差异非常微小，难以察觉。Bash通过报告错误时，有时会指向完全不同的代码部分，使得问题更难以发现。
- en: The solution to this is using a font you know is legible and using an editor
    that is able to pair characters such as parentheses. Quotes and backticks will
    probably remain a problem since most applications are unable to match them. Editors
    such as vim will, however, highlight comments and, as we saw in the previous example,
    this will make errors such as this visible.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 解决这个问题的方法是使用你知道能清晰显示的字体，并且使用一个能够配对括号等字符的编辑器。引号和反引号可能仍然是个问题，因为大多数应用程序无法匹配它们。然而，像vim这样的编辑器会高亮显示注释，正如我们在之前的例子中看到的，这样就能让像这样的错误变得可见。
- en: 'This is an example of highlighted brackets in Notepad++ on Windows, since we
    mentioned the multi-platform approach:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 这是在Windows上的Notepad++中高亮显示括号的一个例子，因为我们提到了多平台的方法：
- en: '![Figure 15.6 – Highlighting brackets in Notepad'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 15.6 – 在Notepad中高亮显示括号'
- en: '](img/Figure_15.6_B16269.jpg)'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_15.6_B16269.jpg)'
- en: Figure 15.6 – Highlighting brackets in Notepad
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 图 15.6 – 在Notepad中高亮显示括号
- en: 'Of course, we also have our standard run-of-the-mill syntax errors that are
    inevitable. A good editor will also help with these:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，我们还有一些标准的、不可避免的语法错误。一个好的编辑器也能帮助我们发现这些错误：
- en: '![Figure 15.7 – Having an editor that''s capable of highlighting braces and
    parentheses will save you'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 15.7 – 使用一个能够高亮显示大括号和括号的编辑器将为你节省时间'
- en: '](img/Figure_15.7_B16269.jpg)'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_15.7_B16269.jpg)'
- en: Figure 15.7 – Having an editor that's capable of highlighting braces and parentheses
    will save you
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 图 15.7 – 使用一个能够高亮显示大括号和括号的编辑器将为你节省时间
- en: The error is in the `then` keyword, and vim highlights that by making the keyword
    white instead of the yellow that it uses for regular keywords.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 错误出现在`then`关键字上，vim通过将该关键字的颜色改为白色（而不是通常的黄色）来高亮显示它。
- en: After dealing with syntax, it is time to see how to avoid arguably more complicated
    and tougher-to-spot errors in logic.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 处理完语法问题后，接下来是看看如何避免那些可以说是更复杂且更难发现的逻辑错误。
- en: How to do it…
  id: totrans-68
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做……
- en: Mentioning logic in scripting can be deceiving. Logic can, in the very strict
    definition of the term, be formal logic in clauses that require logic expressions
    to work, or can more broadly mean any decision-making inside the script. When
    we say *error in logic*, we usually think of the latter; problems that are created
    when our script behaves like we told it to, not like we thought we told it to.
    Every unexpected behavior that is not a result of a syntax error falls into this
    category.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 在脚本中提到逻辑可能会造成误导。逻辑可以在术语的严格定义下，是指需要逻辑表达式来工作的条款中的形式逻辑，或者更广泛地说，是指脚本中的任何决策。当我们说*逻辑错误*时，我们通常指的是后者；即当我们的脚本按照我们告诉它的方式运行，而不是我们认为我们告诉它的方式时，所产生的问题。所有非语法错误导致的意外行为都属于这一类。
- en: 'For example, let''s presume that we want to sort a couple of numbers using
    the `sort` command. This may look easy but has a small flaw. `sort`, by default,
    sorts alphabetically, and not numerically:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，假设我们想使用`sort`命令对几个数字进行排序。这看起来很简单，但有一个小缺陷。`sort`默认是按字母顺序排序，而不是按数字顺序：
- en: '[PRE2]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'We end up having value of `264` being larger than `0` but smaller than `4`,
    which is wrong. If we want to sort something as we intended to, we should be using
    the appropriate switch:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 我们最终得到的值是`264`，它大于`0`但小于`4`，这是错误的。如果我们想按照预期排序，我们应该使用适当的开关：
- en: '[PRE3]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: This is much better. Errors like this are not strictly a problem with Bash but
    instead happen when we are unsure of how a command is used, the result of which
    is that our script will misbehave.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 这种情况要好得多。像这样的错误不完全是Bash的问题，而是在我们不确定如何使用某个命令时发生的，结果就是我们的脚本会出现异常行为。
- en: 'Another thing you are going to see frequently is invalid index referencing.
    In arrays, indices start from `0`, but people usually count from `1`:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 另一件你经常会看到的事情是无效的索引引用。在数组中，索引从`0`开始，但人们通常从`1`开始计数：
- en: '![Figure 15.8 – Misnumbering indices is common when programming in any language'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 15.8 – 在任何语言中编程时，索引编号错误很常见'
- en: '](img/Figure_15.8_B16269.jpg)'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_15.8_B16269.jpg)'
- en: Figure 15.8 – Misnumbering indices is common when programming in any language
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 图 15.8 – 在任何语言中编程时，索引编号错误很常见
- en: 'When we try and run this, we are going to lose one pair of variables in our
    output since we missed the first element in the array:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们尝试运行时，我们将在输出中丢失一对变量，因为我们错过了数组中的第一个元素：
- en: '[PRE4]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The errors that doing this creates are sometimes easy to spot when the script
    is run, but some use cases, especially those that deal with only a part of an
    array, may create strange problems. The same problem can and will happen in loops
    using arguments, like in this example, and if we do not print the values straight
    away, we may not notice that we are processing only part of the array.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 当运行脚本时，执行这些操作会产生的错误有时很容易发现，但某些用例，特别是仅涉及数组部分的用例，可能会产生奇怪的问题。同样的问题可能会在使用参数的循环中发生，并且如果我们不立即打印值，我们可能不会注意到我们只处理了数组的一部分。
- en: Fundamentally, the problem is that definition of the number we are counting
    from is pretty arbitrary. Usually, we use 0 as the first index, but there are
    some exceptions to this. If you're not completely sure, check.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 从根本上讲，问题在于我们计数的起始数字的定义是非常任意的。通常情况下，我们使用0作为第一个索引，但也有一些例外。如果你不确定，可以进行检查。
- en: All of these problems are mentioned here very broadly. You need to know them,
    but the way you are going to deal with them in your scripts is going to be different
    for every script you create. Our intention here is to make you aware that the
    problem exists, so you can spot it before it becomes dangerous.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些问题都在这里广泛提到。你需要知道它们，但是你在你的脚本中处理它们的方式将会因每个脚本的不同而不同。我们在这里的目的是让你意识到问题的存在，这样你就可以在它变得危险之前发现它。
- en: The last big problem we mentioned was with scripts that work correctly most
    of the time, failing only in some cases and then failing only partially. This
    is the worst kind of problem, one that is dangerous since you cannot fully trust
    the output of the script, and hard to find since the output will be completely
    fine most of the time. The only way to deal with these problems is to carefully
    go through all the edge cases of your problem and test them on the script itself.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 我们提到的最后一个大问题是，有些脚本大部分时间工作正常，只在某些情况下失败，并且仅部分失败。这是最糟糕的问题，因为你不能完全信任脚本的输出，并且很难发现，因为大部分时间输出都是完全正常的。处理这些问题的唯一方法是仔细检查问题的所有边界情况，并在脚本本身上对它们进行测试。
- en: How it works…
  id: totrans-85
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理…
- en: In this recipe, we were annoyingly vague when describing possible problems,
    and we did it on purpose. As with all things that are directly connected with
    making errors while working on some problem, we would like to avoid all of them,
    but it is impossible to define what to avoid until we make an error. Most problems
    we see will be the result of a poor presumption or a false understanding of a
    fact. Sometimes, it is going to be a simple typing error that will go unnoticed.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们在描述可能问题时故意模糊不清。就像所有直接与在解决某些问题时出错相关的事物一样，我们希望避免所有这些问题，但在出现错误之前不可能定义避免的内容。我们看到的大多数问题将是假设不当或对事实的错误理解的结果。有时，这将是一个简单的打字错误，将不会被注意到。
- en: There is also one more thing you can do to make things better when writing scripts.
    In order to avoid the most common problems with syntax and logic, primarily syntax,
    you can use automated tools.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 当编写脚本时，还有一件事可以做得更好。为了避免语法和逻辑（主要是语法）中的最常见问题，您可以使用自动化工具。
- en: There are two types of tools you can use. We have already mentioned one, although
    we didn't explicitly mention that it is an actual tool. We instead said that your
    editor is going to take care of most of your problems. Editors that are currently
    available usually include functionality that enables them to understand the syntax
    of the language you are using and to offer help if they notice something wrong.
    Support of this kind in editors is usually rudimentary and limits itself to being
    able to understand keywords and the lexical structure of a particular language.
    It is not uncommon for an editor to switch this functionality on as soon as it
    is able to identify the file and to autodetect the language you are trying to
    use. We have already seen examples of this. For more, please review [*Chapter
    2*](B16269_02_Final_PD_ePub.xhtml#_idTextAnchor037), *Using Text Editors*.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用两种类型的工具。我们已经提到过其中一种，尽管我们没有明确提到它是一个实际的工具。我们只是说过你的编辑器会处理大部分问题。当前可用的编辑器通常包含一些功能，使其能够理解你正在使用的语言的语法，并在发现问题时提供帮助。编辑器中这种支持通常是基础性的，它只限于能够理解关键词和特定语言的词汇结构。当编辑器能够识别文件并自动检测你正在使用的语言时，通常会开启此功能。我们已经看过类似的例子。如需更多信息，请查阅
    [*第二章*](B16269_02_Final_PD_ePub.xhtml#_idTextAnchor037)，*使用文本编辑器*。
- en: There is, however, another set of tools you can use. We are talking about completely
    automated tools that are not only able to find errors in your scripts but are
    also able to find potential problems in your commands, and to even advise you
    how to improve your code.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，确实还有另一类工具可供使用。我们在这里说的完全是自动化工具，这些工具不仅能找到你脚本中的错误，还能够发现你命令中的潜在问题，甚至能够建议你如何改进代码。
- en: You may wonder if it makes any sense to run an application on a script that
    will report the same errors as Bash would, and your question is valid. Bash is
    by itself completely capable of reporting any syntax errors, but it includes only
    a minimal set of messages to help you solve the problem. In essence, Bash reports
    only those errors that stop your code from working.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会想，运行一个会报告与 Bash 相同错误的脚本是否有意义，你的问题是合理的。Bash 本身完全能够报告任何语法错误，但它只包括一组最小的消息来帮助你解决问题。从本质上讲，Bash
    只会报告那些会阻止代码正常运行的错误。
- en: A good tool for *code analysis*, and this is the term used when talking about
    these applications, will find problems in your code and will give you suggestions
    to improve the code you have written. Things that are going to be reported may
    be obvious at first glance, but some of them are also errors that can lead to
    problems, such as missing quotes or misplaced variable assignment.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 一个好的 *代码分析* 工具（在谈论这些应用时通常使用这个术语）会找到你代码中的问题，并给出改进代码的建议。报告的内容可能一眼就能看出来，但其中也有一些错误可能会导致问题，例如缺少引号或变量赋值错误。
- en: 'One such tool is **ShellCheck**, which is available both online and offline
    in the form of a package. In order to use it offline, you must install it using
    this command:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 其中一个这样的工具是 **ShellCheck**，它既有在线版也有离线版，离线版以包的形式提供。要使用离线版，你必须使用以下命令进行安装：
- en: '[PRE5]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: After that, it's only a matter of running it on your script. We will do that
    later when we touch upon how you can also run this tool online in a browser, and
    it will give you the same results as the offline version. The only difference
    is the interface and the simplicity of clicking on a link inside a browser. Both
    versions report exactly the same errors and behave the same when it comes to recommendations.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，只需要在你的脚本上运行它。我们稍后会介绍如何在浏览器中运行这个工具，它会给出与离线版本完全相同的结果。唯一的区别是界面和在浏览器中点击链接的简便性。两个版本报告的错误完全相同，建议也完全一样。
- en: 'We are going to run this tool on a couple of our scripts to see what it has
    to say about the quality of our code. First, we are going to see what happens
    when we make a simple syntax error. We are using the script we used when we introduced
    the `if` statement. The script is named `testif3.sh`, and we have simply removed
    one line containing the `then` keyword:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将对我们的一些脚本运行这个工具，看看它对我们的代码质量有什么评价。首先，我们将看到在我们犯了一个简单的语法错误时会发生什么。我们使用的是在介绍 `if`
    语句时用过的脚本。这个脚本名为 `testif3.sh`，我们只是删除了包含 `then` 关键字的一行：
- en: '![Figure 15.9 – ShellCheck provides much better warnings about syntax errors
    than Bash does'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 15.9 – ShellCheck 提供的语法错误警告比 Bash 更加详细]'
- en: '](img/Figure_15.9_B16269.jpg)'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_15.9_B16269.jpg)'
- en: Figure 15.9 – ShellCheck provides much better warnings about syntax errors than
    Bash does
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 图15.9 – ShellCheck 提供的语法错误警告比 Bash 更好
- en: We can see that the tool has found the problem immediately and has not only
    reported it, but has also given us a suggestion about what to do next. The interesting
    thing is that it has marked the `if` statement that has the error in it, while
    Bash gave us an error that was comparatively misdirected, pointing to a piece
    of code that comes in much later in the script.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到该工具立即找到了问题，不仅报告了它，还给出了下一步应该做什么的建议。有趣的是，它标记了包含错误的`if`语句，而 Bash 给出的错误提示相对误导，指向了脚本中稍后的代码片段。
- en: 'If we fix the error, we can rerun the tool, as shown here:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们修复了错误，可以重新运行工具，如下所示：
- en: '[PRE6]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: If there is no output from the tool, this means that no errors were detected.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 如果工具没有输出内容，意味着没有检测到错误。
- en: 'Now, let''s do it on a more complex script. In this case, we are working with
    a script named `funcglobal.sh` from [*Chapter 12*](B16269_12_Final_PD_ePub.xhtml#_idTextAnchor283)*,
    Using Arguments and Functions*:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们在一个更复杂的脚本中进行尝试。在这个例子中，我们使用的是名为`funcglobal.sh`的脚本，来自[*第12章*](B16269_12_Final_PD_ePub.xhtml#_idTextAnchor283)*，使用参数和函数*：
- en: '![Figure 15.10 – Using variables in this way is not an error as such but it
    can lead to problems'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: '![图15.10 – 以这种方式使用变量本身不是错误，但可能会引发问题'
- en: '](img/Figure_15.10_B16269.jpg)'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_15.10_B16269.jpg)'
- en: Figure 15.10 – Using variables in this way is not an error as such but it can
    lead to problems
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 图15.10 – 以这种方式使用变量本身不是错误，但可能会引发问题
- en: The output does not look pretty because of the large font size in the terminal,
    but it gives us an idea of what to do better in our script. As we mentioned earlier,
    spaces are a big problem and so by using double quotes, we will prevent a space
    character completely messing up our script.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 输出看起来不太美观，因为终端中的字体过大，但它给了我们关于如何改进脚本的提示。正如我们之前提到的，空格是一个大问题，因此通过使用双引号，我们可以避免空格字符完全搞乱我们的脚本。
- en: 'We are going to do one more example, a modified version of a script we used
    earlier and saved under the name `functions.sh`:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将做另一个例子，这是我们之前使用过的脚本的修改版，保存为`functions.sh`：
- en: '[PRE7]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'If we run ShellCheck on this, we are going to end up with a long output, part
    of which looks like the following:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们对这个脚本运行 ShellCheck，最终会得到一份长输出，其中一部分如下所示：
- en: '![Figure 15.11 – Output of ShellCheck is going to warn you if it sees logical
    errors'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: '![图15.11 – 如果 ShellCheck 发现逻辑错误，它将发出警告'
- en: '](img/Figure_15.11_B16269.jpg)'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_15.11_B16269.jpg)'
- en: Figure 15.11 – Output of ShellCheck is going to warn you if it sees logical
    errors
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 图15.11 – 如果 ShellCheck 发现逻辑错误，它将发出警告
- en: 'If we click on the link that ShellCheck provides as the last line of the output,
    we are taken to a detailed explanation of why this is a problem, as can be seen
    in this screenshot:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们点击 ShellCheck 提供的作为输出最后一行的链接，会引导我们到详细的解释页面，正如这个截图所示：
- en: '![Figure 15.12 – Links that ShellCheck provides give you detailed information
    about the error'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: '![图15.12 – ShellCheck 提供的链接为你提供有关错误的详细信息'
- en: '](img/Figure_15.12_B16269.jpg)'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_15.12_B16269.jpg)'
- en: Figure 15.12 – Links that ShellCheck provides give you detailed information
    about the error
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 图15.12 – ShellCheck 提供的链接为你提供有关错误的详细信息
- en: This explanation is not only useful, but it also contains more links for when
    we want to understand what actually went wrong, why it went wrong, and what is
    the reason for this being an issue to look at in the first place. Sometimes, the
    problems that the tool detects are going to have limited scope and will be solved
    in some versions of the Bash interpreter yet misbehave in another.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 这个解释不仅有用，而且还包含了更多的链接，供我们在了解究竟哪里出了问题、为什么出问题以及为什么这个问题需要注意时参考。有时，工具检测到的问题范围有限，可能在某些版本的
    Bash 解释器中得到解决，但在另一些版本中依然存在问题。
- en: See also…
  id: totrans-119
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另见…
- en: 'Troubleshooting is complicated since we are unable to anticipate all the possible
    problems. Some of them as follows are, however, common:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 故障排除是复杂的，因为我们无法预见所有可能的问题。不过，以下是一些常见问题：
- en: '[https://mywiki.wooledge.org/BashPitfalls](https://mywiki.wooledge.org/BashPitfalls)'
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://mywiki.wooledge.org/BashPitfalls](https://mywiki.wooledge.org/BashPitfalls)'
- en: '[https://mywiki.wooledge.org/BashGuide](https://mywiki.wooledge.org/BashGuide)'
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://mywiki.wooledge.org/BashGuide](https://mywiki.wooledge.org/BashGuide)'
- en: '[https://www.shellcheck.net/](https://www.shellcheck.net/)'
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://www.shellcheck.net/](https://www.shellcheck.net/)'
- en: Simple debugging approach – echoing values during script execution
  id: totrans-124
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简单的调试方法 – 在脚本执行期间回显值
- en: The first thing you will learn when using Bash is how to regularly use the `echo`
    command when running any script. This approach is simple as it gives us an opportunity
    to follow the workflow of the script and to print the values of the variables
    as they are in different points of the script. Being able to understand both those
    things is going to help us to follow all the inputs to our script and to see how
    they transform into outputs that we expect.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 当你开始使用 Bash 时，首先学会的就是如何在运行任何脚本时定期使用 `echo` 命令。这种方法很简单，因为它让我们有机会跟踪脚本的工作流，并在脚本的不同位置打印变量的值。能够理解这两点将帮助我们跟踪脚本的所有输入，并看到它们如何转化为我们预期的输出。
- en: Getting ready
  id: totrans-126
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备好
- en: In this recipe, we are going to deal with simple ways we can make our script
    help us understand what is happening during its run. There are three ways we can
    use this simple method.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个教程中，我们将探讨一些简单的方法，使得我们的脚本可以帮助我们理解其运行过程。我们可以使用这三种简单的方法。
- en: 'The first thing we can do is use the `echo` command in every place in the script
    that we think is helpful. As an example, take a look at one of the scripts from
    previous chapters (`funcglobal.sh`) that is already pretty verbose:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 我们能做的第一件事是，在脚本中我们认为有帮助的地方使用 `echo` 命令。举个例子，看看前面章节中的一个脚本（`funcglobal.sh`），它已经相当冗长：
- en: '![Figure 15.13 – Using echo to debug program flow is useful when dealing with
    functions'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 15.13 – 使用 echo 调试程序流程，在处理函数时非常有用](img/Figure_15.13_B16269.jpg)'
- en: '](img/Figure_15.13_B16269.jpg)'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_15.13_B16269.jpg)'
- en: Figure 15.13 – Using echo to debug program flow is useful when dealing with
    functions
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 图 15.13 – 使用 echo 调试程序流程，在处理函数时非常有用
- en: 'We are going to add even more `echo` statements here to enable us to see exactly
    what is happening and in what order:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将增加更多的 `echo` 语句，让我们能够准确看到发生了什么，并且以什么顺序发生：
- en: '![Figure 15.14 – There are never enough echo commands when debugging'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 15.14 – 在调试时，echo 命令永远不会太多](img/Figure_15.14_B16269.jpg)'
- en: '](img/Figure_15.14_B16269.jpg)'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_15.14_B16269.jpg)'
- en: Figure 15.14 – There are never enough echo commands when debugging
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 图 15.14 – 在调试时，echo 命令永远不会太多
- en: 'If we now run our modified script, we will be able to precisely follow the
    flow of the script:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 如果现在运行我们修改后的脚本，我们将能够精确地跟踪脚本的执行流程：
- en: '[PRE8]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: This is particularly useful when we're dealing with a lot of code blocks, functions,
    and conditional statements. The rough idea here is that we can use `echo` to announce
    entering and leaving each code block so that we can see if our script ran correctly.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法在处理大量代码块、函数和条件语句时特别有用。这里的基本思路是，我们可以使用 `echo` 来宣布进入和离开每个代码块，从而看到我们的脚本是否正确执行。
- en: Another thing we are going to do is to print the values of variables during
    the script execution. While doing this, we suggest you always mention the place
    this particular command is printing variables from in the code of the script.
    When debugging this way, the values of the variables are going to be printed to
    the output in the order they are assigned, helping us follow the flow of the script.
    Our previous example already does that.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 另一件我们要做的事情是，在脚本执行期间打印变量的值。在这样做的时候，我们建议你在脚本的代码中始终注明这个特定命令打印变量的地方。当以这种方式调试时，变量的值会按照它们被赋值的顺序打印到输出中，帮助我们跟踪脚本的执行流程。我们之前的示例已经做了这一点。
- en: How to do it…
  id: totrans-140
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作…
- en: There is one more thing you can do to make your scripts provide more information
    when you are debugging them. There is a command built into bash called `trap`.
    The main reason it is there is to help you react to interrupts and to ensure that
    your script works even if something unexpected happens. The syntax it uses is
    simple – we need to tell it what to do and under what circumstances to do it.
    By circumstances, we mean any interrupt signal possible under Linux. The most
    common ones are `SIGHUP`, `SIGKILL`, and `SIGQUIT`, but a lot of others are used.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以做一件事，使你的脚本在调试时提供更多信息。bash 中有一个内建命令叫做 `trap`。它的主要作用是帮助你响应中断信号，并确保即使发生意外情况，脚本也能继续运行。它的语法很简单
    —— 我们只需要告诉它在什么情况下做什么。这里的“情况”指的是 Linux 下的任何中断信号。最常见的有 `SIGHUP`、`SIGKILL` 和 `SIGQUIT`，但还有很多其他信号。
- en: 'For example, we can create a script like this:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，我们可以创建一个像这样的脚本：
- en: '![Figure 15.15 – Using trap inside the script to stop Ctrl + C'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 15.15 – 在脚本中使用 trap 停止 Ctrl + C](img/Figure_15.15_B16269.jpg)'
- en: '](img/Figure_15.15_B16269.jpg)'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_15.15_B16269.jpg)'
- en: Figure 15.15 – Using trap inside the script to stop Ctrl + C
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 图 15.15 – 在脚本中使用 trap 停止 Ctrl + C
- en: 'What this first line does is that it establishes something considered to be
    an interrupt routine. If at any point in our script someone uses *Ctrl + C* to
    interrupt it, our script will detect that and execute two commands inside quotes:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 这一行代码的作用是建立一个被视为中断例程的东西。如果在脚本的任何时刻，有人按下*Ctrl + C*来中断它，我们的脚本会检测到这一点并执行引号内的两条命令：
- en: '[PRE9]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: When we first tried, we pressed the interrupt key and our *routine* did what
    we told it to, which was to exit the script right away and give us a warning about
    it. This command can also be very useful to block attempts to stop the script
    since it will execute whatever we tell it to and then just continue running the
    script.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们第一次尝试时，我们按下了中断键，我们的*例程*按预定操作执行，立刻退出脚本并给出警告。这条命令也非常有用，可以阻止中断脚本的尝试，因为它会执行我们告诉它的任何操作，然后继续执行脚本。
- en: 'Another thing that you can do is to use `EXIT` as the keyword in the `trap`
    command like this:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以做的另一件事是将`EXIT`作为`trap`命令中的关键字，如下所示：
- en: '[PRE10]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: This keyword covers any possible way to exit from a script, meaning that this
    `trap` is going to be executed no matter what happens to the script, and it will
    run right before the control returns to whatever process ran our script.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 这个关键字涵盖了任何可能的退出脚本的方式，这意味着无论脚本发生什么，这个`trap`都会执行，并且会在控制权返回给运行脚本的进程之前运行。
- en: When used this way, `trap` is useful not only for debugging but also for cleaning
    up after your script, since it will run as the last command, enabling you to do
    whatever needs to be done to close the files and clean things up after your script.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 以这种方式使用时，`trap`不仅对调试有用，还对脚本结束后的清理工作非常有帮助，因为它将在最后一个命令执行，允许你在脚本执行后进行必要的操作，如关闭文件和清理资源。
- en: How it works…
  id: totrans-153
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的……
- en: No matter which way you choose to debug your scripts, it all boils down to heavily
    modifying it. Using `echo` is useful but at the same time requires adding a lot
    of commands to the script we are debugging. Having said that, this is probably
    going to be the first thing you will try when debugging any script since it enables
    you not only to understand how the values inside the scripts change but also how
    the entire script works because you have the exact information of where your command
    is executed from, enabling you to understand both the variables and the workflow
    of the script.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 无论你选择哪种方式来调试脚本，归根结底都是要对其进行大量修改。使用`echo`非常有用，但同时也需要在我们调试的脚本中添加很多命令。话虽如此，当你调试任何脚本时，这可能是你会尝试的第一个方法，因为它不仅可以帮助你理解脚本内部的值如何变化，还能让你了解整个脚本的工作原理，因为你能够获取到命令执行的确切位置，从而帮助你理解脚本的变量和工作流程。
- en: Using `trap` is a slightly more nuanced way of debugging and can be very useful
    to gain knowledge of what is happening when we go outside of the program flow
    we imagined. If a script breaks or gets interrupted in any other way, `trap` will
    give you information on what happened and where.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`trap`是一种稍微更为细致的调试方法，当我们偏离了预期的程序流程时，它非常有用。若脚本中断或以其他方式停止，`trap`会为你提供发生了什么和发生地点的信息。
- en: There isn't a particular way of debugging to recommend here as all of them work
    in a particular scenario. What we can say is that you should try using all of
    them and see which fits a particular scenario.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 这里并没有特定的调试方法推荐，因为每种方法都在特定的场景下有效。我们可以说的是，你应该尝试所有方法，看看哪种最适合特定的场景。
- en: See also
  id: totrans-157
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另见
- en: '[https://www.linuxjournal.com/content/bash-trap-command](https://www.linuxjournal.com/content/bash-trap-command)'
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://www.linuxjournal.com/content/bash-trap-command](https://www.linuxjournal.com/content/bash-trap-command)'
- en: '[https://tldp.org/LDP/Bash-Beginners-Guide/html/sect_12_02.html](https://tldp.org/LDP/Bash-Beginners-Guide/html/sect_12_02.html)'
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://tldp.org/LDP/Bash-Beginners-Guide/html/sect_12_02.html](https://tldp.org/LDP/Bash-Beginners-Guide/html/sect_12_02.html)'
- en: Using the bash -x and -v options
  id: totrans-160
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用bash的-x和-v选项
- en: Up to this point, we have tried debugging using different methods that involved
    commands inserted into our scripts. Regardless of the command we used, this approach
    has one drawback – whatever we do, using commands inside the script is either
    very localized to a particular part of a given script or too global since it has
    to cover a good chunk of code. We are not saying that this is not a valid way
    of solving problems in scripts, but we still need more ways to debug.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经尝试了使用不同方法调试脚本，这些方法都涉及在脚本中插入命令。不管我们使用的是哪条命令，这种方法有一个缺点——不管我们怎么做，脚本内部的命令要么非常局限于脚本的某个特定部分，要么过于广泛，因为它需要覆盖大段的代码。我们并不是说这种方法在解决脚本问题时无效，但我们仍然需要更多的调试方法。
- en: Getting ready
  id: totrans-162
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备就绪
- en: 'The only thing we need to know before we start using this is that we will be
    running scripts by invoking them as parameters of the interpreter, so something
    like this:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 在开始使用这些选项之前，我们需要了解的一点是，我们将通过将脚本作为解释器的参数来运行它们，所以会是这样的一种形式：
- en: '[PRE11]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: This is important since we can not use any of these options if we invoke scripts
    in any other way.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 这很重要，因为如果我们以其他方式调用脚本，就无法使用这些选项。
- en: How to do it…
  id: totrans-166
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到…
- en: Bash is in this respect pretty complicated since it offers little, in fact almost
    nothing, in terms of support for any reasonable systematic debugging, and we have
    already mentioned that. There is a glimmer of hope, however, and that comes in
    the form of two switches, `-x` and `-v`. The first one turns on the printing of
    every command that is run in the script and it also prints all the command arguments
    used. This makes understanding the workflow of commands easy.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 在这方面，Bash相当复杂，因为它几乎没有提供任何系统性调试的支持，实际上几乎没有，我们已经提到过这一点。然而，仍然有一线希望，这就是两个开关，`-x`和`-v`。第一个开关会启动打印脚本中运行的每个命令，并且还会打印出所有使用的命令参数。这使得理解命令的工作流程变得简单。
- en: Using `-v` is arguably less useful. It simply prints all the script lines as
    they are read.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`-v`的效果可以说不那么有用。它只是简单地打印出脚本每一行被读取时的内容。
- en: In order to understand these options, we are going to create a small example
    using one of the scripts we used in a different recipe, but this time we are going
    to use different switches when running it.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 为了理解这些选项，我们将创建一个小示例，使用我们在另一个配方中使用的脚本，但这次我们将使用不同的开关来运行它。
- en: 'First, we are going to use `-v`:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将使用`-v`：
- en: '[PRE12]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Now, we are going to use `-x` to run the script:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将使用`-x`来运行脚本：
- en: '[PRE13]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Both switches have their place in debugging. When we said that `-v` is less
    useful than `-x`, we meant that it only gives us an insight into how Bash interpreted
    your script, but nothing more than that.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个开关在调试中各有其作用。当我们说`-v`比`-x`不那么有用时，我们的意思是它仅仅让我们了解Bash如何解析脚本，但除此之外没有更多信息。
- en: Using `-x` shows us how Bash executed the script and what commands it ran during
    the execution. What you must understand is that this is not going to be the list
    of all commands in the script but only those that actually ran. If a particular
    part of the script was not used, for example, if it belonged to a block of commands
    that are in the code only for a specific condition, this way of running a script
    will not show that.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`-x`可以让我们看到Bash是如何执行脚本以及在执行过程中运行了哪些命令。你必须明白的是，这不会是脚本中所有命令的列表，而仅仅是那些实际上执行了的命令。如果脚本的某一部分没有被使用，例如它属于一个仅在特定条件下才会执行的命令块，那么这种运行脚本的方式就不会显示出来。
- en: How it works…
  id: totrans-176
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: The most common thing is using both switches together, since it enables us to
    quickly understand what the script looks like and what Bash does when executing
    it. In a large script, this is going to generate a lot of output, but this is
    usually what we actually want to do. Then, we can go through the script step by
    step and understand the logic it implements.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 最常见的做法是同时使用两个开关，因为它使我们能快速了解脚本的样子以及Bash在执行时做了什么。在一个较大的脚本中，这将生成大量的输出，但通常这正是我们实际想要做的。然后，我们可以逐步查看脚本，理解它实现的逻辑。
- en: 'On the other hand, we cannot consider this as a universal solution to anything.
    Although it gives us a lot of information about the command it runs, it is very
    limited by what the variable values are and what is actually going on when processing
    data. Take, for example, this loop included in the file `forloop1.sh`, available
    as part of the files included with the book:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，我们不能将其视为解决任何问题的普适方案。虽然它为我们提供了很多关于所运行命令的信息，但它在变量值和数据处理过程中实际发生的情况方面非常有限。以文件`forloop1.sh`中的这个循环为例，它是书中附带的文件的一部分：
- en: '[PRE14]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: We are not going to copy the entire output since it has no other useful information.
    Here, we can see that we are looping in a `for` loop, and we can see possible
    values but the actual value of a particular variable is not seen unless we print
    it. This means that we will have to combine this way of debugging with the other
    ways we presented in this chapter.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不会复制整个输出，因为它没有其他有用的信息。这里，我们可以看到我们正在一个`for`循环中循环，并且可以看到可能的值，但除非我们打印它，否则无法看到特定变量的实际值。这意味着，我们将不得不将这种调试方式与本章中介绍的其他调试方法结合使用。
- en: See also…
  id: totrans-181
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另见…
- en: '[https://linux.die.net/man/1/bash](https://linux.die.net/man/1/bash)'
  id: totrans-182
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://linux.die.net/man/1/bash](https://linux.die.net/man/1/bash)'
- en: '[https://tldp.org/LDP/Bash-Beginners-Guide/html/sect_02_03.html](https://tldp.org/LDP/Bash-Beginners-Guide/html/sect_02_03.html)'
  id: totrans-183
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://tldp.org/LDP/Bash-Beginners-Guide/html/sect_02_03.html](https://tldp.org/LDP/Bash-Beginners-Guide/html/sect_02_03.html)'
- en: Using set to debug a part of the script
  id: totrans-184
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用`set`调试脚本的一部分
- en: In the previous recipe, we dealt with globally using two options to tell Bash
    to include a lot of useful information in its output. We mentioned that this offers
    another way to deal with debugging and troubleshooting how your scripts work.
    At the same time, we mentioned that this approach is in stark contrast with using
    commands in the script itself since we can deal with things globally without too
    many changes to the scripts when debugging.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 在前一个示例中，我们处理了全局使用两个选项来告诉Bash在输出中包含大量有用信息。我们提到这提供了另一种处理调试和排查脚本问题的方法。同时，我们也提到，这种方法与在脚本本身中使用命令的方式形成鲜明对比，因为在调试时我们可以全局处理，而无需对脚本做太多更改。
- en: In this recipe, we are going to cover another way to debug, one that shares
    a lot of similarities with the ones we introduced before, while also being different.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个方法中，我们将介绍另一种调试方式，这种方式与之前介绍的方式有很多相似之处，同时也有所不同。
- en: Getting ready
  id: totrans-187
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备就绪
- en: One very interesting built-in command in Bash is `set`. What it does is give
    us the ability to change the options Bash uses. A lot of things can be changed
    by using `set`, and by a lot we mean almost every option Bash has. In this recipe,
    we are using only two of them, but you can turn all of them on or off.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 在Bash中，一个非常有趣的内置命令是`set`。它的作用是让我们能够改变Bash使用的选项。通过使用`set`，我们可以更改许多内容，几乎是Bash所有的选项。在这个例子中，我们只使用了其中的两个，但你可以开启或关闭所有选项。
- en: '`set` enables us to set a particular option on in just a small block of code,
    instead of using it globally. You also need to know that `set` can turn an option
    both on and off. If we use `set` with a `–` sign, we turn the option on. For example,
    we could use this:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: '`set`使我们能够在代码的小块中启用特定的选项，而不是全局使用它。你还需要知道，`set`可以同时开启和关闭选项。如果我们使用带有`–`符号的`set`，则会启用选项。例如，我们可以这样使用：'
- en: '[PRE15]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: This is telling Bash to start showing us commands as they are executed.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 这告诉Bash在执行命令时显示它们。
- en: 'A slightly confusing way is if we turn off any option that is currently used.
    To do that, we have to use the `+` sign, something that is a little bit counterintuitive
    since *adding* is usually used to turn something on, not off. For example, look
    at this command:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 一种稍微令人困惑的方式是，如果我们关闭当前使用的任何选项。为了做到这一点，我们必须使用`+`符号，这有点反直觉，因为通常*加*符号用于打开某些东西，而不是关闭。例如，看看这个命令：
- en: '[PRE16]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: This will turn off the output of commands in Bash.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 这将关闭Bash中命令的输出。
- en: We are going to see a couple of examples of this just to make you comfortable.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将通过几个例子来帮助你更好地理解。
- en: How to do it…
  id: totrans-196
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何实现…
- en: Using `set` is simple. In any script we wish to debug, we are going to insert
    the `set` statement right before the place we are starting our trace from. After
    we no longer need to trace our script, we simply unset the option and we are done.
    We can do this as many times as we need to.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`set`非常简单。在任何我们希望调试的脚本中，我们只需在开始跟踪的地方之前插入`set`语句。当我们不再需要跟踪脚本时，只需取消设置该选项，就完成了。我们可以根据需要多次执行此操作。
- en: 'Here''s an example:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个例子：
- en: '![Figure 15.16 – How to set and unset options while running the script'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 15.16 – 在运行脚本时如何设置和取消设置选项](img/Figure_15.16_B16269.jpg)'
- en: '](img/Figure_15.16_B16269.jpg)'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_15.16_B16269.jpg)'
- en: Figure 15.16 – How to set and unset options while running the script
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 图 15.16 – 在运行脚本时如何设置和取消设置选项
- en: 'In this example, we are starting our trace just before we do the test of our
    variable. This means that we are going to start tracing right before we do a test
    and stop tracing right before we continue the loop. The result is this:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们在测试变量之前开始跟踪。这意味着我们将在进行测试之前开始跟踪，并在继续循环之前停止跟踪。结果是这样的：
- en: '[PRE17]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: We can even consider this way of debugging as a special case of using options
    globally. We are basically doing the same thing as in previous examples where
    we used `set` globally, but this time we are limiting the scope to make the output
    more readable. Sometimes that can make working a lot easier since we are not creating
    much irrelevant output.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 我们甚至可以把这种调试方式看作是全局使用选项的一种特殊情况。我们基本上做的和之前示例中的`set`全局使用相同，但这次我们限制了作用范围，使输出更易读。有时，这可以让工作变得更轻松，因为我们不会生成太多无关的输出。
- en: How it works…
  id: totrans-205
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: The `set` command can be used for one more thing, and that is to force Bash
    to do some things differently than are usually done. For example, we can make
    scripts fail if any command inside them fails, we can make scripts fail if they
    reference a value of a variable that is not set, or we can even change the way
    Bash expands characters in the command line.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: '`set` 命令还可以用于一个额外的功能，那就是强制 Bash 执行一些与平常不同的操作。例如，我们可以让脚本在其中任何命令失败时终止，或者当脚本引用一个未设置的变量值时让其失败，甚至可以改变
    Bash 在命令行中扩展字符的方式。'
- en: All these things can be useful when working but at the same time, can be a little
    too much to grasp all at once when you first begin scripting, so we decided to
    not include them in these recipes.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些内容在工作时可能非常有用，但在刚开始编写脚本时，可能会有点过于复杂，难以一次性掌握，因此我们决定在这些教程中不包括它们。
- en: See also…
  id: totrans-208
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另见…
- en: '[https://linuxhint.com/debug-bash-script/](https://linuxhint.com/debug-bash-script/)'
  id: totrans-209
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://linuxhint.com/debug-bash-script/](https://linuxhint.com/debug-bash-script/)'
- en: '[https://www.gnu.org/software/bash/manual/html_node/The-Set-Builtin.html](https://www.gnu.org/software/bash/manual/html_node/The-Set-Builtin.html)'
  id: totrans-210
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://www.gnu.org/software/bash/manual/html_node/The-Set-Builtin.html](https://www.gnu.org/software/bash/manual/html_node/The-Set-Builtin.html)'
