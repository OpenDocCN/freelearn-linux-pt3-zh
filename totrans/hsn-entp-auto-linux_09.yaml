- en: Configuration Management with Ansible
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Ansible 进行配置管理
- en: So far in this book, we have established a solid framework for our Enterprise
    Linux infrastructure, one that lends itself well to the large-scale deployments
    typical in an enterprise, and to automated management with Ansible at this scale.
    In this chapter, we now proceed to go into depth on the automated management aspect
    of this infrastructure, starting with the installation and configuration of software
    packages.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，在本书中，我们已经为我们的企业 Linux 基础设施建立了一个坚实的框架，这个框架非常适合企业中的大规模部署，并且可以在这种规模下使用 Ansible
    进行自动化管理。在本章中，我们将深入探讨这一基础设施的自动化管理方面，从软件包的安装和配置开始。
- en: In just about every enterprise, one task is almost guaranteed to be required
    during the lifespan of a standardized Linux system—the installation and configuration
    of a service. This might simply involve the configuration of an existing system
    service, or possibly even the installation of the service itself, followed by
    post-configuration work.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 几乎在每个企业中，几乎可以肯定在标准化 Linux 系统的生命周期内都会需要执行一项任务——服务的安装和配置。这可能仅仅涉及现有系统服务的配置，或者甚至可能是服务本身的安装，然后是后续的配置工作。
- en: 'We will cover the following topics in this chapter, to explore Ansible configuration
    management in greater depth:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将探讨以下主题，以深入了解 Ansible 配置管理：
- en: Installing new software
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 安装新软件
- en: Making configuration changes with Ansible
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Ansible 进行配置更改
- en: Managing configuration at an enterprise scale
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在企业规模上管理配置
- en: Technical requirements
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'This chapter includes examples based on the following technologies:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 本章包括基于以下技术的示例：
- en: Ubuntu Server 18.04 LTS
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Ubuntu Server 18.04 LTS
- en: CentOS 7.6
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: CentOS 7.6
- en: Ansible 2.8
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Ansible 2.8
- en: To run through these examples, you will need access to two servers or virtual
    machines running one of each of the operating systems listed here, and also Ansible.
    Note that the examples given in this chapter may be destructive in nature (for
    example, they install and uninstall software packages and make changes to server
    configuration), and if run as-is, they are only intended to be run in an isolated
    test environment.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 为了运行这些示例，你需要访问两台服务器或虚拟机，每台运行一个操作系统，并且需要安装 Ansible。请注意，本章给出的示例可能具有破坏性（例如，它们会安装和卸载软件包并修改服务器配置），如果按原样运行，这些示例仅适用于在隔离的测试环境中执行。
- en: Once you are satisfied that you have a safe environment in which to operate,
    let's get started on looking at the installation of new software packages with
    Ansible.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你确信你拥有一个安全的操作环境，我们就开始学习如何使用 Ansible 安装新的软件包。
- en: All example code discussed in this chapter is available from GitHub, at the
    following URL: [https://github.com/PacktPublishing/Hands-On-Enterprise-Automation-on-Linux/tree/master/chapter07](https://github.com/PacktPublishing/Hands-On-Enterprise-Automation-on-Linux/tree/master/chapter07).
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 本章讨论的所有示例代码可以从 GitHub 获取，网址为：[https://github.com/PacktPublishing/Hands-On-Enterprise-Automation-on-Linux/tree/master/chapter07](https://github.com/PacktPublishing/Hands-On-Enterprise-Automation-on-Linux/tree/master/chapter07)。
- en: Installing new software
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 安装新软件
- en: Depending on your requirements, it is quite possible that your SOE operating
    system build has sufficient software installed, and requires only configuration
    work. However, for many people, that will not be the case, so we will begin this
    chapter with a section covering the installation of software. As with all our
    work so far, our desire is that anything we do here is repeatable and lends itself
    well to automation, and thus, even if new software is required, it is desirable
    that we do not install it by hand.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 根据你的需求，可能你的 SOE 操作系统构建已经安装了足够的软件，仅需要配置工作。然而，对于许多人来说，情况可能并非如此，因此我们将以软件安装部分开始本章内容。就像我们到目前为止做的所有工作一样，我们希望我们在这里做的任何事情都是可重复的，并且适合自动化，因此，即使需要新的软件，也希望我们不通过手动安装它。
- en: Let's start by looking at the simplest possible case here—installing a native
    operating system package.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从最简单的情况开始——安装一个本地操作系统软件包。
- en: Installing a package from operating system default repositories
  id: totrans-18
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从操作系统默认的仓库中安装软件包
- en: Suppose that you are rolling out a new service that requires a database server—for
    example, MariaDB. It is unlikely that you will have installed and enabled MariaDB
    in all of your SOE images, and hence, the first task before you do anything else
    will be to install the software package.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你正在推出一个新服务，需要一个数据库服务器——例如MariaDB。你不太可能在所有SOE镜像中都已安装并启用了MariaDB，因此，在做任何其他事情之前，第一项任务将是安装该软件包。
- en: 'Both of our example operating systems in this book (and indeed, many of their
    derivatives) include native packages for MariaDB, so we could quite easily make
    use of these. When it comes to package installation, there is, of course, a need
    to understand what is going on behind the scenes in our target operating system.
    For example, on Ubuntu, we know that we would normally install our chosen software
    by using the APT package manager. Thus, if we wanted to install this manually,
    including the matching client for management purposes, we would issue the following
    command:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 本书中的两个示例操作系统（实际上，许多衍生版本也如此）都包含了MariaDB的本地包，因此我们可以轻松使用这些包。至于包安装，当然，需要了解我们的目标操作系统背后发生的事情。例如，在Ubuntu上，我们知道通常会通过APT包管理器来安装选定的软件。因此，如果我们想手动安装它，包括用于管理的匹配客户端，我们会发出以下命令：
- en: '[PRE0]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Of course, on CentOS, things are quite different—even though packages are available
    for MariaDB, the command to install them would instead be the following one:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，在CentOS上，情况完全不同——尽管MariaDB有可用的包，但安装它们的命令将是以下命令：
- en: '[PRE1]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Although Ansible can automate a great deal of your Enterprise Linux requirements,
    it cannot abstract away some of the fundamental differences between different
    Linux operating systems. Fortunately, though, Ansible makes everything else quite
    straightforward. Consider the following inventory:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管Ansible可以自动化很多企业Linux的需求，但它不能抽象掉不同Linux操作系统之间的一些根本差异。然而，幸运的是，Ansible使得其他一切都变得相当简单。考虑以下清单：
- en: '[PRE2]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: We have advocated building a standard operating environment throughout this
    book, so this inventory is rather unlikely to occur in real life—however, it serves
    as a good example here as we can demonstrate how to install a MariaDB server on
    two differing platforms. As with earlier examples in this book, we'll complete
    this task by making use of roles.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书中，我们一直倡导构建标准操作环境，因此这个清单在实际生活中不太可能出现——然而，它在这里作为一个很好的示例，因为我们可以展示如何在两个不同的平台上安装MariaDB服务器。像本书中的早期示例一样，我们将通过使用角色来完成这个任务。
- en: 'Building on our work on templates from earlier in this book, consider the following
    role:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 基于我们在本书前面关于模板的工作，考虑以下角色：
- en: '[PRE3]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: This neatly packaged role will operate correctly on both Ubuntu and CentOS (and,
    indeed, **Red Hat Enterprise Linux** (**RHEL**) and Debian, if required), and
    takes account of both the differing package managers and different package names.
    Naturally, if you are fortunate enough to have an environment that is completely
    unified (for example, only Ubuntu Server-based), then the code can be simplified
    even further.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 这个打包好的角色将在Ubuntu和CentOS上（如果需要，也可以在**Red Hat Enterprise Linux**（**RHEL**）和Debian上）正确运行，并考虑到了不同的包管理器和不同的包名称。当然，如果你幸运地拥有一个完全统一的环境（例如，只有基于Ubuntu
    Server的环境），那么代码可以进一步简化。
- en: There exists an Ansible module called `package` that attempts to detect the
    correct package manager to use, based on the operating system the playbook is
    run against. Although this removes the need for separate yum- and apt- based tasks,
    such as the ones we used previously, you still need to take into account the different
    package naming between different Linux operating systems, so you may still require
    a `when` clause.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 有一个名为`package`的Ansible模块，它会根据执行Playbook的操作系统尝试检测正确的包管理器。尽管这消除了之前我们使用的基于yum和apt的任务的需求，但你仍然需要考虑不同Linux操作系统之间包命名的差异，因此你可能仍然需要使用`when`条件。
- en: 'We will define a simple playbook to call the role, as follows:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将定义一个简单的Playbook来调用角色，如下所示：
- en: '[PRE4]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Now, we can run the playbook and observe what happens, as follows:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以运行Playbook并观察发生了什么，如下所示：
- en: '![](img/e4e725fc-b55e-466c-9a15-af9836f065e1.png)'
  id: totrans-34
  prefs: []
  type: TYPE_IMG
  zh: '![](img/e4e725fc-b55e-466c-9a15-af9836f065e1.png)'
- en: From the preceding output, you can see how the tasks that are irrelevant to
    each system are skipped, while the successful installation of our desired package
    results in a `changed` status. Also, note that the task status returned was `ok` when
    installing the MariaDB client package called `mariadb` on our CentOS test system.
    The reason for this is that the `loop` defined in our `role` iterates over each
    listed package in turn, installing it; on CentOS, the `mariadb` package is a dependency
    of the `mariadb-server` package, and so it was installed when that particular
    task was run.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 从前面的输出中，你可以看到与每个系统无关的任务被跳过，而我们想要的包成功安装后返回了`changed`状态。此外，注意到在我们CentOS测试系统上安装名为`mariadb`的MariaDB客户端包时，任务状态返回了`ok`。这是因为在我们的`role`中定义的`loop`会逐个遍历每个列出的包并安装它；在CentOS中，`mariadb`包是`mariadb-server`包的依赖，因此在执行该任务时，它也被安装了。
- en: Although specifying this manually could be seen as redundant, it does no harm
    to keep it in our role as it ensures that whatever happens, the client package
    is present. It is also a form of self-documentation—in a few years, someone could
    come back to this playbook and understand that both the MariaDB client and server
    packages were required, even if they were unaware of this nuance of the CentOS
    7 operating system.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管手动指定这点看起来可能是多余的，但它对我们在角色中保留它没有坏处，因为它确保无论发生什么，客户端包都会存在。这也是一种自我文档化的方式——几年后，某人可能会回到这个playbook并理解无论如何，MariaDB客户端和服务器包都是必需的，即使他们不知道CentOS
    7操作系统的这一细节。
- en: 'Before we build on this example, a note on package removal. Ansible tasks are,
    as we have discussed previously, idempotent. For example, if we run our playbook
    a second time, we will see that the results returned are all `ok`. In the following
    instance, Ansible has detected that our chosen packages are already installed,
    and doesn''t attempt a second installation:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 在继续构建这个示例之前，关于包移除的一点说明。正如我们之前讨论过的那样，Ansible任务是幂等的。例如，如果我们第二次运行我们的playbook，我们会看到返回的结果都是`ok`。在下面的例子中，Ansible已检测到我们选择的包已经安装，并且不会尝试第二次安装：
- en: '![](img/786cc962-eb89-4d1f-b0b6-d3dd70619b3a.png)'
  id: totrans-38
  prefs: []
  type: TYPE_IMG
  zh: '![](img/786cc962-eb89-4d1f-b0b6-d3dd70619b3a.png)'
- en: 'However, what if you need to tidy something up? Perhaps a package that features
    in the standard image has become obsolete or needs removing, for security reasons.
    In this instance, it is not sufficient simply to remove the playbook or role.
    While the presence of our example role ensures the installation of packages, the
    removal of the role does not reverse this. In short, we must manually uninstall
    or remove changes if they are not required. Backing out of our installation would
    require a role such as this:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果你需要整理一些东西呢？也许一个标准镜像中包含的包已经过时或者由于安全原因需要删除。在这种情况下，单纯删除playbook或角色并不足够。虽然我们示例中的角色确保了包的安装，但删除角色并不会撤销这个过程。简而言之，如果不再需要这些包，我们必须手动卸载或移除更改。撤销我们的安装将需要如下的角色：
- en: '[PRE5]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Notice the almost identical nature of the role, except that we are now using
    `state: absent` instead of `state: present`. This is common to most Ansible tasks
    you might run—if you want to define a procedure for backing out or otherwise reverting
    a change, you will need to write that separately. Now, when we run the preceding
    role by calling it from a suitable playbook, we can see that the packages are
    cleanly uninstalled, as shown in the following screenshot:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: '请注意，角色几乎完全相同，唯一的区别是我们现在使用的是`state: absent`而不是`state: present`。这在大多数你可能运行的Ansible任务中是常见的——如果你想定义一个过程来撤销或以其他方式恢复更改，你需要单独编写。现在，当我们通过适当的playbook调用上述角色时，我们可以看到包被干净地卸载，如下图所示：'
- en: '![](img/1afc7d9c-e3a7-48cb-933c-2143ebd5e33b.png)'
  id: totrans-42
  prefs: []
  type: TYPE_IMG
  zh: '![](img/1afc7d9c-e3a7-48cb-933c-2143ebd5e33b.png)'
- en: Sometimes, of course, the packages we want to install are not available as part
    of the default operating system package repositories.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，有时我们想要安装的包并不包含在默认的操作系统包仓库中。
- en: In the next section, we will look at how to handle this in accordance with the
    automation principles we have set out so far.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的部分，我们将讨论如何根据我们目前设定的自动化原则来处理这个问题。
- en: Installing non-native packages
  id: totrans-45
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 安装非原生包
- en: Thankfully, the installation of non-native packages is not significantly more
    difficult with Ansible than with native ones. Ideally, in an enterprise environment,
    all required packages would be served out of an internal repository, and indeed,
    we will cover this later in the book. In this instance, the enterprise repository
    would be used in conjunction with Ansible roles, such as those from the previous
    section.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，使用 Ansible 安装非本地软件包并不比安装本地软件包更难。理想情况下，在企业环境中，所有所需的软件包都会通过内部仓库提供，实际上我们会在本书后面介绍这一点。在这个例子中，企业仓库将与
    Ansible 角色一起使用，类似于前一节中提到的那些。
- en: Occasionally, though, this may not be possible, or desirable. Take, for instance,
    a development or test system where a new package is being evaluated—here, you
    would probably not want to upload a test package to an enterprise repository server
    when it is not known whether there will be a requirement for the package moving
    forward. Nonetheless, we wish to adhere to our principles of automation and ensure
    that we perform our testing in a repeatable, self-documenting manner.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，偶尔这可能不可行或不希望如此。例如，考虑一个开发或测试系统，在这里正在评估一个新软件包——在这种情况下，你可能不希望将一个测试包上传到企业仓库服务器，特别是当尚不清楚是否会有持续使用该软件包的需求时。尽管如此，我们仍希望遵循自动化的原则，确保我们以可重复、自动文档化的方式进行测试。
- en: Suppose you are evaluating the Duplicati backup software for your enterprise
    and need to install the latest beta version to perform some testing. Obviously,
    you could download this manually from their releases page, copy it across to your
    target server, and install it by hand. However, this is inefficient, and certainly
    not a repeatable process. Luckily, the `apt` and `yum` modules we used earlier
    support the installation of packages, both from a local path and a remote URL.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你正在为企业评估 Duplicati 备份软件，并需要安装最新的测试版进行一些测试。显然，你可以从他们的发布页面手动下载这个版本，复制到目标服务器，然后手动安装。然而，这种方式效率低下，显然也不是可重复的过程。幸运的是，我们之前使用的
    `apt` 和 `yum` 模块支持从本地路径和远程 URL 安装软件包。
- en: 'Thus, to test the installation of Duplicati beta version 2.0.4.23, you could
    write a role such as this:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，要测试 Duplicati 测试版 2.0.4.23 的安装，你可以编写如下角色：
- en: '[PRE6]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'As you can see from this role, the installation proceeds without needing to
    separately download the package first, as shown in the following screenshot:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 从这个角色可以看到，安装过程不需要先单独下载软件包，正如以下截图所示：
- en: '![](img/2cca5511-c3bd-4179-82f3-0ed287f9e8e9.png)'
  id: totrans-52
  prefs: []
  type: TYPE_IMG
  zh: '![](img/2cca5511-c3bd-4179-82f3-0ed287f9e8e9.png)'
- en: Thus, in this way, whether for testing or production purposes, you can install
    packages that are not available in the default package repositories of your chosen
    operating system, and maintain the benefits of automation. In the next section,
    we will explore how Ansible can install software that is not packaged at all and
    that requires manual installation.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，无论是用于测试还是生产目的，你都可以安装在所选操作系统的默认软件包仓库中不可用的软件包，并保持自动化的好处。在接下来的部分中，我们将探讨 Ansible
    如何安装完全没有打包且需要手动安装的软件。
- en: Installing unpackaged software
  id: totrans-54
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 安装未打包的软件
- en: Some software, of course, doesn't come neatly packaged and requires a more manual
    approach to installation. Take, for example, the hosting control panel software
    **Virtualmin**. This, at the time of writing, normally requires the user to download
    a shell script and execute it to perform the installation.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，有些软件没有 neatly 打包，需要更手动的安装方法。例如，考虑一下托管控制面板软件 **Virtualmin**。在写作本文时，通常需要用户下载一个
    shell 脚本并执行它来完成安装。
- en: 'Fortunately, once again, Ansible can help here—consider the following role:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，再一次，Ansible 可以提供帮助——考虑以下角色：
- en: '[PRE7]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Here, we are making use of the Ansible `get_url` module to download the installation
    script and then using the `shell` module to run it. Notice also how we can put
    helpful instructions into the task names—although no substitute for good documentation,
    this is incredibly helpful as it tells anyone running the script how to check
    on the progress of the installation using the `tail` command.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们使用了 Ansible 的 `get_url` 模块来下载安装脚本，然后使用 `shell` 模块来执行它。还请注意，我们可以将有用的说明添加到任务名称中——虽然这不能替代好的文档，但它非常有帮助，因为它告诉任何运行脚本的人如何使用
    `tail` 命令查看安装进度。
- en: Note that the `shell` module requires some care in its use—as it cannot possibly
    know whether the shell task you have given it has been run before, it runs the
    command every time the playbook is run. Thus, if you run the preceding role a
    second time, it will attempt to install Virtualmin again. You should use a `when` clause
    under your `shell` task to ensure it only runs under certain conditions—perhaps
    in the preceding example, when `/usr/sbin/virtualmin` (which is installed by `install.sh`)
    is not present.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，`shell` 模块在使用时需要小心——因为它无法知道你给它的 shell 任务是否已经运行过，所以每次运行 playbook 时，它都会执行该命令。因此，如果你第二次运行之前的角色，它会尝试重新安装
    Virtualmin。你应该在 `shell` 任务下使用 `when` 子句，以确保它只在特定条件下运行——比如在之前的示例中，当 `/usr/sbin/virtualmin`（由
    `install.sh` 安装）不存在时。
- en: This method could be extended to almost any software you can imagine—you could
    even download a source code tarball and extract it and build the code using a
    series of `shell` module calls in Ansible. This is an unlikely case, of course,
    but the emphasis here is that Ansible can help you create repeatable installations,
    even if you don't have access to pre-packaged software in an RPM or DEB format.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法几乎可以扩展到任何你能想象的软件——你甚至可以下载一个源代码 tar 包，提取它并使用一系列 `shell` 模块调用在 Ansible 中构建代码。当然，这种情况不太可能发生，但这里的重点是
    Ansible 可以帮助你创建可重复的安装，即使你没有访问 RPM 或 DEB 格式的预打包软件。
- en: In this manner, almost any software can be installed—after all, the process
    of software installation is to download a file (or archive), put it into the right
    location, and configure it. This is, in essence, what package managers such as `yum`
    and `apt` are doing behind the scenes, and Ansible can handle this kind of activity
    just as well, as we have demonstrated here. In the next section, we will explore
    the use of Ansible to make configuration changes on systems on which you have
    built and/or installed software.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这种方式，几乎可以安装任何软件——毕竟，软件安装过程就是下载文件（或归档文件）、将其放入正确的位置并进行配置。从本质上讲，`yum` 和 `apt`
    等包管理器在幕后做的正是这些工作，Ansible 也能像我们在这里演示的那样处理这类活动。在接下来的章节中，我们将探讨如何使用 Ansible 在已经构建和/或安装了软件的系统上进行配置更改。
- en: Making configuration changes with Ansible
  id: totrans-62
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Ansible 进行配置更改
- en: When it comes to configuring a new service, the task is rarely completed by
    simply installing the required software. There is almost always a configuration
    stage required after the installation.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 在配置新服务时，任务很少仅仅通过安装所需的软件就完成。几乎总是需要在安装后进行配置阶段。
- en: Let's consider in detail some fundamental examples of the myriad of configuration
    changes that might be required.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们详细考虑一些可能需要的基础配置更改示例。
- en: Making small configuration changes with Ansible
  id: totrans-65
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Ansible 进行小规模配置更改
- en: When it comes to making configuration changes, the `lineinfile` Ansible module
    is often your first port of call and can handle a lot of the small-scale changes
    that might be required. Consider the example of deploying a MariaDB server that
    we started earlier in this chapter. Although we successfully installed the packages,
    they will have been installed with their default configuration, and this is unlikely
    to suit all but the most basic of use cases.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 在进行配置更改时，`lineinfile` Ansible 模块通常是你的首选工具，能够处理许多可能需要的小规模更改。考虑一下我们在本章早些时候提到的部署
    MariaDB 服务器的例子。尽管我们成功安装了软件包，但它们将会以默认配置安装，这不太适用于除最基本使用案例之外的所有情况。
- en: For example, the default bind address for the MariaDB server is `127.0.0.1`,
    meaning that it is not possible to make use of our MariaDB installation from an
    external application. We have well established the need to make changes in a reliable,
    repeatable manner, so let's take a look at how we might change this using Ansible.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，MariaDB 服务器的默认绑定地址是`127.0.0.1`，这意味着无法通过外部应用程序使用我们的 MariaDB 安装。我们已经明确了需要以可靠、可重复的方式进行更改，那么让我们来看看如何使用
    Ansible 来更改这个配置。
- en: In order to change this configuration, the first thing we need to do is establish
    where the default configuration is located and what it looks like. From here,
    we will define an Ansible task, to rewrite the configuration.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更改这个配置，首先我们需要做的是确定默认配置的位置以及其内容。接下来，我们将定义一个 Ansible 任务来重写配置。
- en: 'Taking our Ubuntu server by way of example, the service bind-address is configured
    in the `/etc/mysql/mariadb.conf.d/50-server.cnf` file—the default directive looks
    like this:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 以我们的 Ubuntu 服务器为例，服务的 bind-address 配置在 `/etc/mysql/mariadb.conf.d/50-server.cnf`
    文件中——默认指令如下所示：
- en: '[PRE8]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Thus, in order to change this, we might employ a simple role, like this:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，为了更改这一点，我们可能会采用一个简单的角色，如下所示：
- en: '[PRE9]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Let''s break the `lineinfile` task down and look at it in more detail:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们详细分解 `lineinfile` 任务并逐步解析：
- en: '`path`: Tells the module which configuration file to modify.'
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`path`：告诉模块要修改哪个配置文件。'
- en: '`regexp`: Used to locate an existing line to modify if there is one so that
    we don''t end up with two conflicting `bind-address` directives.'
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`regexp`：用于定位现有的行进行修改，如果该行存在，以免我们最终会有两个冲突的 `bind-address` 指令。'
- en: '`line`: The line to replace/insert into the configuration file.'
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`line`：要替换/插入到配置文件中的行。'
- en: '`insertafter`: If the `regexp` is not matched (that is, the line is not present
    in the file), this directive ensures that the `lineinfile` module inserts a new
    line after the `[mysqld]` statement, thus ensuring it is in the correct part of
    the file.'
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`insertafter`：如果 `regexp` 未匹配（即，文件中没有该行），该指令确保 `lineinfile` 模块将在 `[mysqld]`
    声明后插入新行，从而确保它位于文件的正确部分。'
- en: '`state`: Setting this to `present` state ensures that the line is present in
    the file, even if the original `regexp` is not matched—in this instance, a line
    is added to the file in accordance with the value of `line`.'
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`state`：将其设置为 `present` 状态可确保该行出现在文件中，即使原始的 `regexp` 没有匹配——在这种情况下，会根据 `line`
    的值将一行添加到文件中。'
- en: 'Following on from this modification, we know that the MariaDB server will not
    pick up any configuration changes unless we restart it, so we do exactly that
    at the end of the role. Now, if we run this, we can see that it has the desired
    effect, as shown in the following screenshot:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 在进行此修改后，我们知道 MariaDB 服务器不会立即生效任何配置更改，除非我们重启它，因此在角色的最后，我们会进行重启。现在，如果我们运行此命令，可以看到它达到了预期效果，如下图所示：
- en: '![](img/60622338-2858-477d-9329-d34bce89455a.png)'
  id: totrans-80
  prefs: []
  type: TYPE_IMG
  zh: '![](img/60622338-2858-477d-9329-d34bce89455a.png)'
- en: For simple configuration adjustments such as this, on a small number of systems,
    this achieves exactly the result that we desire. There are, however, drawbacks
    to this approach that need to be addressed, especially when it comes to not just
    the point in time where the change is made, but also to the long-term integrity
    of the system. Even with the best automation strategies in the world, someone
    making manual changes can remove the consistency and standardization that is core
    to good automation practice, and hence there is a real need to ensure that future
    playbook runs will still yield the desired end result. We will explore this issue
    in the next section.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 对于像这样的简单配置调整，在少量系统上，这可以精确地实现我们所期望的结果。然而，这种方法也有一些需要解决的缺点，特别是在修改时机以及系统长期完整性方面。即使有最好的自动化策略，手动更改也可能会破坏一致性和标准化，而这些恰恰是良好自动化实践的核心。因此，必须确保未来的剧本运行仍然能够得到预期的最终结果。我们将在下一节中探讨这个问题。
- en: Maintaining configuration integrity
  id: totrans-82
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 保持配置的完整性
- en: The issue with making changes in this manner is that they do not scale well.
    Tuning a MariaDB server for a production workload often requires setting perhaps
    half a dozen, or more, parameters. Thus, that simple role that we wrote previously
    could well grow to become a tangle of regular expressions and directives that
    are difficult to decipher, let alone manage.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 以这种方式进行更改的问题在于，它们不具有良好的可扩展性。为生产工作负载调优 MariaDB 服务器通常需要设置六个或更多的参数。因此，我们之前编写的简单角色可能会发展成一堆难以解读的正则表达式和指令，管理起来更是困难。
- en: 'Regular expressions themselves are not foolproof and are only as good as they
    are written to be. In our previous example, we used the following line to look
    for the bind-address directive, with a view to changing it. The regular expression `^bind-address\s+=` means
    to look for lines in the file that have the following:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 正则表达式本身并不是万无一失的，它们的效果取决于编写的质量。在我们之前的示例中，我们使用了以下这一行来查找 bind-address 指令，并计划修改它。正则表达式
    `^bind-address\s+=` 意味着查找文件中符合以下条件的行：
- en: Have the bind-address literal string at the start of the line (denoted by the `^`)
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在行首有 bind-address 字面字符串（由 `^` 表示）
- en: Have one or more spaces after the `bind-address` literal string
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 `bind-address` 字面字符串后面留一个或多个空格
- en: Have a `=` sign after these spaces
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在这些空格后面加上一个 `=` 符号
- en: 'The idea behind this regular expression is to ensure that we ignore comments
    such as the following one:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 这个正则表达式的目的是确保我们忽略如下的注释：
- en: '[PRE10]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'However, MariaDB is quite tolerant of whitespace in its configuration files,
    and the regular expression we have defined here will fail to match the following
    permutations of this line, all of which are equally valid:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，MariaDB对其配置文件中的空白符相当宽容，我们在这里定义的正则表达式将无法匹配以下这些有效的排列形式：
- en: '[PRE11]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'In these instances, since the `regexp` parameter didn''t match, our role will
    add a new line to the configuration file with the `bind-address = 0.0.0.0` directive. As
    MariaDB treats the preceding examples as valid configuration, we end up with two
    configuration directives in the file which, may well give you unexpected results.
    Different software packages will handle this differently too, adding to the confusion.
    There are other complexities to consider too. Many Linux services feature highly
    complex configurations that are often broken down across multiple files to make
    them easier to manage. The documentation that comes with the native MariaDB server
    package on our test Ubuntu system states the following:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 在这些情况下，由于`regexp`参数没有匹配，我们的角色将会向配置文件中添加一行，内容是`bind-address = 0.0.0.0`指令。由于MariaDB将前面的例子视为有效的配置，最终我们会在文件中得到两个配置指令，这可能会导致意外的结果。不同的软件包也会以不同的方式处理这些情况，进一步增加了混淆。还有其他复杂性需要考虑。许多Linux服务具有高度复杂的配置，通常将配置拆分到多个文件中以便于管理。我们在测试的Ubuntu系统上使用的原生MariaDB服务器包的文档中指出了以下内容：
- en: '[PRE12]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'However, this configuration order is dictated by the `/etc/mysql/mariadb.cnf` file, which
    at the bottom has directives to include the files listed on lines 2 and 3 in the
    preceding code block. It is entirely possible for someone (well-meaning or otherwise)
    to simply come along and overwrite `/etc/mysql/mariadb.cnf` with a new version
    that removes the include statements for these subdirectories, and instead includes
    the following:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这个配置顺序是由`/etc/mysql/mariadb.cnf`文件决定的，该文件的底部有指令包括前面代码块中的第2和第3行所列的文件。完全有可能有人（无论是好心还是其他）简单地覆盖`/etc/mysql/mariadb.cnf`文件，使用一个新版本，这个新版本删除了这些子目录的包含语句，而是包含了以下内容：
- en: '[PRE13]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: As our role that makes use of `lineinfile` is completely unaware of this file,
    it will faithfully set the parameter in `/etc/mysql/mariadb.conf.d/50-server.cnf`, without
    understanding that this configuration file is no longer being referenced, and
    again, the results on the server will—at best—be unpredictable.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们的角色使用`lineinfile`完全不知道这个文件，它将忠实地在`/etc/mysql/mariadb.conf.d/50-server.cnf`中设置该参数，而不理解这个配置文件已经不再被引用，结果在服务器上的表现——最多——是不可预测的。
- en: While the goal of enterprise automation is that all systems should have their
    changes managed centrally with a tool such as Ansible, the reality is that you
    cannot always guarantee that this will occur. Occasionally, things will break,
    and people who are in a hurry to fix them may be forced to bypass processes to
    save time. Equally, new staff members who are unfamiliar with systems may make
    changes in a manner such as we have suggested here.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然企业自动化的目标是所有系统的变更都应该通过类似Ansible的工具集中管理，但现实情况是，你不能总是保证这一点。有时，事情会出错，急于修复问题的人可能会被迫绕过流程以节省时间。同样，不熟悉系统的新员工可能会像我们在这里建议的那样进行更改。
- en: 'Alternatively, take—for example—our proposed SSH daemon configuration from
    [Chapter 5](3802fb48-9f14-4a52-98c5-280d381260a4.xhtml), *Using Ansible to Build
    Virtual Machine Templates for Deployment*. Here, we proposed a simple role (shown
    again in the following code block, for reference) that would disable root logins
    over SSH, one of a number of recommended security parameters for the SSH daemon:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，例如，参考我们在[第5章](3802fb48-9f14-4a52-98c5-280d381260a4.xhtml)《使用Ansible构建虚拟机模板以便部署》中提出的SSH守护进程配置。这里，我们提出了一个简单的角色（再次在以下代码块中展示，供参考），它将禁用通过SSH的root登录，这是为SSH守护进程推荐的多个安全参数之一：
- en: '[PRE14]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Note that our `regexp` has the same weaknesses as our other role when it comes
    to whitespace. When `sshd` has two duplicate parameters in its configuration file,
    it takes the first value as the correct one. Thus, if I knew that the role listed
    in the previous code block was being run against a system, all I would have to
    do is put these lines at the *very top* of `/etc/ssh/sshd_config`:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们的`regexp`在处理空白字符时与我们的其他角色存在相同的弱点。当`sshd`在其配置文件中有两个重复的参数时，它会将第一个值视为正确的值。因此，如果我知道上面代码块中的角色正在对一个系统运行，我所需要做的就是将这些行放在`/etc/ssh/sshd_config`的*最上面*：
- en: '[PRE15]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Thus, our Ansible role will run faithfully against this server and report that
    it has successfully managed the SSH daemon configuration, while in reality, we
    have overridden it and enabled root logins.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们的Ansible角色将忠实地在这台服务器上运行，并报告成功管理了SSH守护进程的配置，而实际上，我们已经覆盖了该配置并启用了root登录。
- en: 'These examples show us two things. First of all, be very careful when working
    with regular expressions. The more thorough you can be, especially when dealing
    with whitespace, the better. Obviously, in an ideal world, this would not even
    be necessary, but unexpected changes such as this have brought down many systems.
    To prevent the preceding SSH daemon example from being possible, we might try
    the following regular expression:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 这些示例向我们展示了两件事。首先，在处理正则表达式时要非常小心。你越是彻底，特别是在处理空白字符时，效果越好。显然，在理想的世界里，这些工作是不必要的，但像这样的意外变化已经导致许多系统崩溃。为了防止前面提到的SSH守护进程示例成为可能，我们可以尝试以下正则表达式：
- en: '[PRE16]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: This will take account of zero or more spaces before the `PermitRootLogin` keyword, and
    then take account of one or more spaces afterward, all while taking account of
    the whitespace tolerance built into `sshd`. However, regular expressions are very
    literal, and we haven't even taken account of tabs yet!
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 这将考虑`PermitRootLogin`关键字前的零个或多个空格，然后考虑后面一个或多个空格，同时考虑到`sshd`中内建的空白容忍度。然而，正则表达式非常字面化，我们还没有考虑制表符的情况！
- en: Ultimately, this brings us to the second factor demonstrated through these examples—that
    to maintain configuration and, hence, system integrity at enterprise scale, and
    ensure that you have a high degree of confidence in both your automation and the
    systems it produces, another approach might be required for configuration management.
    This is exactly what we go on to explore in the next section—techniques for reliably
    managing configuration at large, enterprise scales.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 最终，这将引导我们到第二个因素——通过这些示例展示的因素——即为了在企业规模上保持配置和系统完整性，并确保对自动化以及其所生成的系统具有高度信心，可能需要另一种配置管理方法。这正是我们在下一节中要探讨的内容——在大型企业规模下可靠地管理配置的技术。
- en: Managing configuration at an enterprise scale
  id: totrans-107
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在企业规模上管理配置
- en: Clearly, from these examples, another approach is required for the management
    of configuration at an enterprise scale. There is nothing wrong with the `lineinfile` approach
    we discussed previously when it comes to making small numbers of changes in a
    well-controlled environment, yet let us consider a more robust approach to configuration
    management, better suited to a large organization.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，从这些示例来看，在企业规模上管理配置需要采用另一种方法。在一个控制良好的环境中，对于做少量更改的情况，我们之前讨论的`lineinfile`方法没有问题，但让我们考虑一种更稳健的配置管理方法，更适合大型组织。
- en: We will start by considering scalable methods for simple static configuration
    changes (that is, those that are the same across all servers) in the next section.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从考虑用于简单静态配置更改（即所有服务器都相同的更改）的可扩展方法开始，下一节将详细讨论。
- en: Making scalable static configuration changes
  id: totrans-110
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进行可扩展的静态配置更改
- en: It is vital that the configuration changes that we make are version controlled,
    repeatable, and reliable—thus, let's consider an approach that achieves this aim.
    Let's start with a simple example by revisiting our SSH daemon configuration.
    On most servers, this is likely to be static, as requirements such as restricting
    remote root logins and disabling password-based logins are likely to apply across
    an entire estate. Equally, the SSH daemon is normally configured through one central
    file—`/etc/ssh/sshd_config`.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 配置更改至关重要，它们必须是版本控制的、可重复的和可靠的——因此，让我们考虑一种能够实现这一目标的方法。让我们通过重新审视我们的SSH守护进程配置来开始一个简单的示例。在大多数服务器上，这可能是静态的，因为诸如限制远程root登录和禁用基于密码的登录等要求可能适用于整个系统。同样，SSH守护进程通常通过一个中央文件配置——`/etc/ssh/sshd_config`。
- en: 'On an Ubuntu server, the default configuration is very simple, consisting of
    just six lines if we remove all the whitespace and comments. Let''s make some
    modifications to this file so that remote root logins are denied, `X11Forwarding`
    is disabled, and only key-based logins are allowed, as follows:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'We will store this file within our `roles/` directory structure and deploy
    it with the following role tasks:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Here, we use the Ansible `copy` module to copy the `sshd_config` file we have
    created and stored within the role itself to our target host and ensure it has
    the ownership and mode that''s suitable for the SSH daemon. Finally, we restart
    the SSH daemon to pick up the changes (note that this service name is valid on
    Ubuntu Server and may vary on other Linux distributions). Thus, our completed
    `roles` directory structure looks like this:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Now, we can run this to deploy the configuration to our test host, as follows:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/a3db5082-bbf1-4afb-997a-02eb6f7f5834.png)'
  id: totrans-119
  prefs: []
  type: TYPE_IMG
- en: 'Now, deploying the configuration through this means gives us a number of advantages
    over the methods we have explored previously, as listed here:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
- en: The role itself can be committed to a version control system, thus implicitly
    bringing the configuration file itself (in the `files/` directory of the role)
    under version control.
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Our role tasks are very simple—it is very easy for someone else to pick up this
    code and understand what it does, without the need to decipher the regular expressions.
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It doesn't matter what happens to our target machine configuration, especially
    in terms of whitespace or configuration format. The pitfalls discussed at the
    end of the previous section are avoided completely because we simply overwrite
    the file on deployment.
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: All machines have an identical configuration, not just in terms of directives,
    but in terms of order and formatting, thus ensuring it is easy to audit configuration
    across an enterprise.
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Thus, this role represents a big step forward in terms of enterprise-scale
    configuration management. However, let''s see what happens if we run the role
    against the same host a second time. The resulting output can be seen in the following
    screenshot:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/a3db5082-bbf1-4afb-997a-02eb6f7f5834.png)'
  id: totrans-126
  prefs: []
  type: TYPE_IMG
- en: From the preceding screenshot, we can see that Ansible has determined that the
    SSH configuration file is unmodified from the last run, and hence, the `ok` status
    is returned. However, in spite of this, the `changed` status of the `Restart SSH
    daemon` task indicates that the SSH daemon has been restarted, even though no
    configuration change was made. Restarting system services is normally disruptive,
    and so it should be avoided unless absolutely necessary. In this case, we would
    not wish to restart the SSH daemon unless a configuration change is made.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
- en: 'The recommended way to handle this is with a `handler`. A `handler` is an Ansible
    construct that is much like a task, except that it only gets called when a change
    is made. Also, when multiple changes are made to a configuration, the handler
    can be notified multiple times (once for each applicable change), and yet the
    Ansible engine batches up all handler calls and runs the handler once, only after
    the tasks complete. This ensures that when it is used to restart a service, such
    as in this example, the service is only restarted once, and only then when a change
    is made. Let''s test this now, as follows:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
- en: 'First of all, remove the service restart task from the role and add a `notify`
    clause to notify the handler (we shall create this in a minute). The resulting
    role tasks should look like this:'
  id: totrans-129
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Now, we need to create a `handlers/` directory in the role and add our previously
    removed handler code to it so that it looks like this:'
  id: totrans-131
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'The resulting `roles` directory structure should now look like this:'
  id: totrans-133
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Now, when we run the playbook twice on the same server (having initially reverted
    the SSH configuration to the original one), we see that the SSH daemon is only
    restarted in the instance where we have actually changed the configuration, as
    shown in the following screenshot:'
  id: totrans-135
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/fa05dc02-d7f8-4f14-bebe-7de0a2ec42c8.png)'
  id: totrans-136
  prefs: []
  type: TYPE_IMG
- en: 'To further demonstrate handlers before we move on, let''s consider this enhancement
    to the role tasks:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Here, we deploy our configuration file and perform an additional modification.
    We are putting a comment into the head of the file, which includes an Ansible
    variable, with the hostname of the target host.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
- en: 'This will result in two changed statuses on our target host, and yet, if we
    revert to the default SSH daemon configuration and then run our new playbook,
    we see the following:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/fc3fea96-62c6-4b72-bdd6-7054844eff25.png)'
  id: totrans-141
  prefs: []
  type: TYPE_IMG
- en: Pay careful attention to the preceding output and the sequence in which the
    tasks are run. You will note that the handler is not run in sequence and is actually
    run once at the end of the play.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
- en: Even though our tasks both changed and hence would have notified the handler
    twice, the handler was only run at the end of the playbook run, minimizing restarts,
    just as required.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
- en: In this manner, we can make changes to static configuration files at large scales,
    across many hundreds—if not thousands—of machines. In the next section, we will
    build on this to demonstrate ways of managing configuration where dynamic data
    is required—for example, configuration parameters that might change on a per-host
    or per-group basis.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
- en: Making scalable dynamic configuration changes
  id: totrans-145
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: While the preceding examples resolve many of the challenges of making automated
    configuration changes at scale in an enterprise, it is noticeable that our final
    example was somewhat inefficient. We deployed a static, version-controlled configuration
    file, and made a change to it using the `lineinfile` module again.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
- en: This allowed us to insert an Ansible variable into the file, which in many instances
    is incredibly useful, especially when configuring more complex services. However,
    it is—at best—inelegant to split this change across two tasks. Also, reverting
    to the use of the `lineinfile` module again exposes us to the risks we discussed
    earlier and means we would need one `lineinfile` task for every variable we wish
    to insert into a configuration.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
- en: Thankfully, Ansible includes just the answer to such a problem. In this case,
    the concept of Jinja2 templating comes to our rescue.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
- en: Jinja2 is a templating language for Python that is incredibly powerful and easy
    to use. As Ansible is coded almost entirely in Python, it lends itself well to
    the use of Jinja2 templates. So, what is a Jinja2 template? At its most fundamental
    level, it is a static configuration file, such as the one we deployed for the
    SSH daemon earlier, but with the possibility of variable substitutions. Of course,
    Jinja2 is far more powerful than that—it is, in essence, a language in its own
    right, and features common language constructs such as `for` loops and `if...elif...else` constructs,
    just as you would find in other languages. This makes it incredibly powerful and
    flexible, and entire sections of a configuration file (for example) can be omitted,
    depending on how an `if` statement evaluates.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
- en: As you can imagine, Jinja2 deserves a book of its own to cover the detail of
    the language—however, here, we will provide a practical hands-on introduction
    to Jinja2 templating for the automation of configuration management in an enterprise.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s go back to our SSH daemon example for a minute, where we wanted to put
    the target hostname into a comment at the head of the file. While this is a contrived
    example, progressing it from the `copy`/`lineinfile` example to a single `template` task
    will show the benefits that templating brings. From here, we can progress to a
    more comprehensive example. To start with, let''s define our Jinja2 template for
    the `sshd_config` file, as follows:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Notice that the file is identical to the file we deployed using the copy module
    earlier, only now, we have included the comment in the file header and used the
    Ansible variable construct (denoted by pairs of curly braces) to insert the `inventory_hostname` variable.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
- en: Now, for the sake of our sanity, we will call this file `sshd_config.j2` to
    ensure we can differentiate templates from flat configuration files. Templates
    are normally placed into a `templates/` subdirectory within the role, and so are
    subject to version control in the same way that playbook, roles, and any associated
    flat configuration files are.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
- en: Now, rather than copying the flat file and then performing substitutions with
    one or more `lineinfile` tasks, we can use the Ansible `template` module to deploy
    this template and parse all Jinja2 constructs.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
- en: 'Thus, our tasks now look like this:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Notice that the task is almost identical to our earlier `copy` task and that
    we call our handler, just as before.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
- en: 'The completed module directory structure now looks like this:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Let''s run this and evaluate the results, which can be seen in the following
    screenshot:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/0f735768-f96d-47c3-b238-69fd6252aa07.png)'
  id: totrans-162
  prefs: []
  type: TYPE_IMG
- en: As can be seen here, the template has been copied across to the target host,
    and the variable in the header comment has been processed and the appropriate
    value substituted.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
- en: 'This becomes incredibly powerful as our configuration becomes more complex
    as, no matter how large and complex the template, the role still only requires
    the one `template` task. Returning to our MariaDB server, suppose that we want
    to set a number of parameters on a per-server basis to effect tuning appropriate
    to the different workloads we are deploying. Perhaps we want to set the following:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
- en: The server bind-address, defined by `bind-address`
  id: totrans-165
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The maximum binary log size, defined by `max_binlog_size`
  id: totrans-166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The TCP port that MariaDB listens on, as defined by `port`
  id: totrans-167
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'All of these parameters are defined in `/etc/mysql/mariadb.conf.d/50-server.cnf`.
    However, as discussed earlier, we need to also ensure the integrity of `/etc/mysql/mariadb.cnf` to
    ensure it includes this (and other) files, to reduce the possibility of someone
    overriding our configuration. Let''s start building our templates—first of all,
    a simplified version of the `50-server.cnf` file, with some variable substitutions.
    The first part of this file is shown in the following code—note the `port` and
    `bind-address` parameters, which are now defined using Ansible variables, denoted
    in the usual manner with pairs of curly braces:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'The second part of this file looks as follows—you will observe here the presence
    of the `mariadb_max_binlog_size` variable, while all other parameters remain static:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Now, let''s also add in a templated version of `/etc/mysql/mariadb.cnf`, as
    follows:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: This file might be short, but it serves a really important purpose. It is the
    first file that is read by the MariaDB service when it loads, and it references
    other files or directories to be included. If we did not maintain control of this
    file using Ansible, then anyone with sufficient privileges could log in and edit
    the file, possibly including entirely different configurations and bypassing our
    Ansible-defined configuration entirely. Whenever you deploy configuration with
    Ansible, it is important to consider factors such as this, as otherwise, your
    configuration changes might be bypassed by a well-meaning (or otherwise) administrator.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
- en: A template doesn't have to have any Jinja2 constructs in it—if there are no
    variables to insert, as in our second example, the file will simply be copied
    as-is to the target machine.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
- en: 'Obviously, it would be slightly more efficient to use the copy module to send
    this static configuration file to the remote server, but this requires two tasks,
    where we can use just one with a loop to process all our templates. Such an example
    is shown in the following code block:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Finally, we define a handler to restart MariaDB if the configuration has changed,
    as follows:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Now, before we run this, a word on variables. In Ansible, variables can be defined
    at a wide number of levels. In a case such as this, where we are applying a different
    configuration to different hosts with differing purposes, it makes sense to define
    the variables at the host or hostgroup level. However, what happens if someone
    were to forget to put these in the inventory, or in another appropriate location?
    Fortunately, we can leverage the variable precedence order of Ansible to our advantage
    here and define default variables for our role. These are second lowest on the
    order of precedence, so are almost always overridden by another setting elsewhere,
    yet they provide a safety net, should they be missed accidentally. As our preceding
    templates have been written, if the variables are not defined anywhere, the configuration
    file will be invalid and the MariaDB server will refuse to start—a case we would
    definitely like to avoid.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s define the default values for these variables in our role now under
    `defaults/main.yml`, as follows:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'With this complete, our role structure should look like this:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Naturally, we want to override the default values, so we will define these in
    our inventory grouping—this is a good use case for inventory groups. All MariaDB
    servers that serve the same function would go in one inventory group, and then
    have a common set of inventory variables assigned to them, such that they all
    receive the same configuration. However, the use of templates in our role means
    that we can reuse this role in a number of situations, simply by providing differing
    configurations through variable definition. We will create an inventory for our
    test host that looks like this:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'With this complete, we can finally run our playbook and observe what happens.
    The result is shown in the following screenshot:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/33ce9b9d-89fb-489d-ae12-f0c91c7fe9b9.png)'
  id: totrans-188
  prefs: []
  type: TYPE_IMG
- en: With this successfully run, we have shown a complete end-to-end example of how
    to manage configuration on an enterprise scale, all while avoiding the pitfalls
    of regular expression substitutions and multi-part configurations. Although these
    examples are simple, they should serve as the basis for any well-thought-out enterprise
    automation strategy where a configuration is required.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-190
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Managing configuration across an enterprise Linux estate is filled with pitfalls
    and the potential for configuration drift. This can be caused by people with good
    intentions, even in *break-fix* scenarios where changes have to be made in a hurry.
    However, it can also be caused by those with malicious intent, seeking to circumvent
    security requirements. Good use of Ansible, especially templating, enables the
    construction of easy-to-read, concise playbooks that make it easy to ensure configuration
    management is reliable, repeatable, auditable, and version-controlled—all the
    basic tenets we set out earlier in this book for good enterprise automation practice.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, you gained practical experience in extending a Linux machine
    with new software packages. You then learned how to apply simple, static configuration
    changes to those packages, and the potential pitfalls associated with this. Finally,
    you learned best practices for managing configuration across an enterprise using
    Ansible. In the next chapter, we proceed to look at internal repository management
    with Pulp.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  id: totrans-193
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: What are the different Ansible modules commonly used for making changes to configuration
    files?
  id: totrans-194
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How does templating work in Ansible?
  id: totrans-195
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Why must you consider configuration file structure when making changes with
    Ansible?
  id: totrans-196
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What are the pitfalls of using regular expressions when making file modifications?
  id: totrans-197
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How does a template behave if there are no variables in it?
  id: totrans-198
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How can you check that a configuration template you have deployed is valid before
    committing it to disk?
  id: totrans-199
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How can you quickly audit the configuration of 100 machines against a known
    template with Ansible?
  id: totrans-200
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Further reading
  id: totrans-201
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For an in-depth understanding of Ansible, please refer to *Mastering Ansible,
    Third Edition*, by* James Freeman* and *Jesse Keating* ([https://www.packtpub.com/gb/virtualization-and-cloud/mastering-ansible-third-edition](https://www.packtpub.com/gb/virtualization-and-cloud/mastering-ansible-third-edition)).
  id: totrans-202
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
