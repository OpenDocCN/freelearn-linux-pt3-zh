- en: '9'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Comprehensive Review and Test Exam Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we will go over the different things we have learned throughout
    this book. We will be working through mock exam questions that will help familiarize
    you with the format of questions that you may encounter on the exam. We will attempt
    to cover all things that could possibly be on the exam per the public listed information
    by Red Hat, which can be found here: [https://www.redhat.com/en/services/training/ex358-red-hat-certified-specialist-services-management-automation-exam?section=Objectives](https://www.redhat.com/en/services/training/ex358-red-hat-certified-specialist-services-management-automation-exam?section=Objectives).'
  prefs: []
  type: TYPE_NORMAL
- en: The outcome of this chapter will be preparing you fully to take the exam confidently
    and give you the information needed for you to pass the exam. We will go into
    other things that may not have been touched on in the book until now but will
    explain each topic as we go. We will also be covering the request to complete
    each question manually and to also do so with Ansible Automation. Let’s get started.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we’re going to cover the following:'
  prefs: []
  type: TYPE_NORMAL
- en: A comprehensive review of all exam objectives and mock exams for you to test
    your newfound skills
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We will be using the setup of the systems that is used in [*Chapter 1*](B18607_01.xhtml#_idTextAnchor016),
    *Block Storage – Learning How to Provision Block Storage on Red Hat Enterprise
    Linux*. We will utilize this setup along with the setup from the additional **Network
    Interface Controllers** (**NICs**) for the teaming exercise, which can be found
    in [*Chapter 3*](B18607_03.xhtml#_idTextAnchor039), *Link Aggregation Creation
    – Creating Your Own Link and Mastering the Networking Domain*. This will allow
    you to utilize all the upcoming questions as if you were in a test environment.
  prefs: []
  type: TYPE_NORMAL
- en: Setting up GitHub access
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Please refer to the instructions found in [*Chapter 1*](B18607_01.xhtml#_idTextAnchor016),
    *Block Storage – Learning How to Provision Block Storage on Red Hat Enterprise
    Linux*, to gain access to GitHub for the book’s repo. You will find the Ansible
    Automation playbooks for this chapter at the following link: [https://github.com/PacktPublishing/Red-Hat-Certified-Specialist-in-Services-Management-and-Automation-EX358-Exam-Guide/tree/main/Chapter09](https://github.com/PacktPublishing/Red-Hat-Certified-Specialist-in-Services-Management-and-Automation-EX358-Exam-Guide/tree/main/Chapter09).
    Remember these are suggested playbooks and are not the only way you can write
    them to make them work for you.'
  prefs: []
  type: TYPE_NORMAL
- en: You can always change them up using `raw`, `shell`, or `cmd` to achieve the
    same results, but we are demonstrating the best way to accomplish the goals. Also,
    keep in mind that we are not using the FCQN that is needed in future versions
    of Ansible, as that will not be supported in the exam, as it tests against Ansible
    2.9.
  prefs: []
  type: TYPE_NORMAL
- en: A comprehensive review of all exam objectives and mock exams for you to test
    your newfound skills
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We will present a mock exam with a mix of questions based on the skills you
    have learned throughout the entire book. We will go into more detail based on
    the items that you might run into in the exam itself. This will help prepare you
    to take the EX358 exam. These are not official questions; otherwise, they would
    not be provided in this book. Instead, they are theoretical scenarios you may
    face with differing information. Please set up your configuration as noted at
    the beginning of the chapter and then take note of your IP addresses, system names,
    and so on. This will allow you to grab the needed information fast for use within
    the exam so that you are not slowed down, as you only have 4 hours.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s get started with the exam. We will start with the information for my
    lab to give you an idea of how to write this out for your setup:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: You can see that I have access to the information I need. If you set up your
    configuration to use hostnames through either DNS or your host file, you can connect
    to your devices easily. This also makes using the inventory a little easier in
    the Ansible inventory, as you do not have to add the `ansible_host` parameter.
    For our purposes, I will still be using `ansible_host` in my inventory file.
  prefs: []
  type: TYPE_NORMAL
- en: Another thing that makes everything easier is setting up RSA keys and sharing
    them across the system instead of using passwords. This is shown in the [*Chapter
    1*](B18607_01.xhtml#_idTextAnchor016), *Block Storage – Learning How to Provision
    Block Storage on Red Hat Enterprise Linux*, setup process as well. This makes
    running the playbooks easier, as they do not need to be run with the `-u emcleroy
    -k --ask-become` portion of the command added to pass the SSH and the escalated
    privilege password. We will be using the command with the extra parameters to
    make sure that you understand how to use the full command, if necessary, during
    the exam.
  prefs: []
  type: TYPE_NORMAL
- en: 'After you have set up your system as required, we will get started with the
    mock exam and go through each topic to review the items we have learned about.
    The questions will be in the order laid out by Red Hat on the objectives page
    found here: [https://www.redhat.com/en/services/training/ex358-red-hat-certified-specialist-services-management-automation-exam?section=Objectives](https://www.redhat.com/en/services/training/ex358-red-hat-certified-specialist-services-management-automation-exam?section=Objectives).'
  prefs: []
  type: TYPE_NORMAL
- en: The questions follow. The answers will come directly after the questions, but
    please try to answer the questions without looking at the answers. I recommend
    attempting the questions once by yourself before looking at the solution. If you
    get feel stuck, feel free to read the answers and go through the solution to refresh
    your memory.
  prefs: []
  type: TYPE_NORMAL
- en: Managing network services
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Managing network services is our first objective as noted by Red Hat for this
    exam.
  prefs: []
  type: TYPE_NORMAL
- en: First up, we will set up IP connectivity for the network interfaces.
  prefs: []
  type: TYPE_NORMAL
- en: '*Question 1* – For this question, we would like you to provision the NICs on
    the servers with static addresses. Using the DHCP IP addresses, we would like
    you to change to the static IPs that were noted at the start of the instructions.
    (These will differ depending on your network):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Once these are set up statically, you should be able to route between the two.
  prefs: []
  type: TYPE_NORMAL
- en: '*Answer 1* – To set a static IP up manually, we will need to SSH to the device
    using the DHCP IP addresses and then modify them to the static addresses.'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we will use the `nmtui` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.1 – NetworkManager TUI initial display](img/Figure_9.01_B18607.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.1 – NetworkManager TUI initial display
  prefs: []
  type: TYPE_NORMAL
- en: 'We will then choose to edit the connection and, from there, you will see the
    interfaces available, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.2 – NMTUI interface choices](img/Figure_9.02_B18607.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.2 – NMTUI interface choices
  prefs: []
  type: TYPE_NORMAL
- en: 'After choosing which interface to change, we will then move on to the settings
    to enable a static IP, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.3 – Manual setting choice for the selected interface](img/Figure_9.03_B18607.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.3 – Manual setting choice for the selected interface
  prefs: []
  type: TYPE_NORMAL
- en: 'We will then configure the required settings, such as the static IP, gateway,
    and DNS server, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.4 – Static IP, gateway, and DNS settings](img/Figure_9.04_B18607.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.4 – Static IP, gateway, and DNS settings
  prefs: []
  type: TYPE_NORMAL
- en: 'After we have saved these settings, we will need to restart the network interface
    in order for it to change to the newly configured IP. We will do this by using
    the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we will test to ensure the new address is reachable, as shown using the
    `ping` test in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.5 – IP ping test to ensure connectivity](img/Figure_9.05_B18607.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.5 – IP ping test to ensure connectivity
  prefs: []
  type: TYPE_NORMAL
- en: Next up, we will dig into setting up the IPV6 address configuration for previously
    configured network interfaces.
  prefs: []
  type: TYPE_NORMAL
- en: '*Question 2* – For this question, we would like you to set up an IPv6 address
    on the already-configured NIC while maintaining connectivity via IPv4:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: These should be routable, and you should maintain IPv4 routable connectivity
    as well once the change has been made.
  prefs: []
  type: TYPE_NORMAL
- en: '*Answer 2* – We will use the `nmtui` command to set this up:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.6 – NMTUI network menu](img/Figure_9.06_B18607.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.6 – NMTUI network menu
  prefs: []
  type: TYPE_NORMAL
- en: 'After we initiate the `nmtui` menu, we will then choose to edit a connection,
    which will take you to the menu in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.7 – NMTUI interface selection screen](img/Figure_9.07_B18607.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.7 – NMTUI interface selection screen
  prefs: []
  type: TYPE_NORMAL
- en: 'After choosing the correct interface – in our case, **enp0s3**, but in your
    setup, it may be different depending on your lab – we will then be able to make
    configuration changes, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.8 – NMTUI interface configuration settings](img/Figure_9.08_B18607.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.8 – NMTUI interface configuration settings
  prefs: []
  type: TYPE_NORMAL
- en: 'After we choose **Manual** for **IPv6 CONFIGURATION**, we can then edit the
    values of the IPv6 address and gateway, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.9 – IPv6 interface settings](img/Figure_9.09_B18607.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.9 – IPv6 interface settings
  prefs: []
  type: TYPE_NORMAL
- en: 'After we set up the configuration as shown, we will then save the configuration.
    In order for the changes to take effect, we will need to run the following command
    to refresh the connectivity:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'After both servers have been configured, we can then run IPv6 `ping` tests
    across the two interfaces to ensure connectivity, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.10 – IPv6 ping tests](img/Figure_9.10_B18607.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.10 – IPv6 ping tests
  prefs: []
  type: TYPE_NORMAL
- en: We have shown one way to solve the issue of configuring your network with the
    preceding information. Now, we will move on to working with firewall services.
  prefs: []
  type: TYPE_NORMAL
- en: Managing firewall services
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this section, we will go over setting up firewall rules. We will talk about
    rich rules and other items that will block specific connectivity and allow connectivity
    for network traffic that is not currently allowed.
  prefs: []
  type: TYPE_NORMAL
- en: '*Question 1* – For this question, we would like you to allow access to services
    and ports through the firewall. This will allow connectivity to web services that
    might be running on your servers in production. Please open access to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Please do this manually and also set it up in an Ansible Automation playbook.
  prefs: []
  type: TYPE_NORMAL
- en: '*Answer 1* – We will use the following commands to set up the firewall to allow
    connectivity to these services:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.11 – Firewall commands utilized to allow service connectivity](img/Figure_9.11_B18607.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.11 – Firewall commands utilized to allow service connectivity
  prefs: []
  type: TYPE_NORMAL
- en: 'The Ansible playbook for setting up `firewalld` services is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Please see the following screenshot with the inventory for your reference:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.12 – Playbook inventory for all labs](img/Figure_9.12_B18607.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.12 – Playbook inventory for all labs
  prefs: []
  type: TYPE_NORMAL
- en: 'After we have set up and run the playbook with `ansible-playbook -i inventory
    firewalld.yml -u emcleroy -k –ask-become -v`, we will see the output in the following
    screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.13 – Successful Ansible playbook completion](img/Figure_9.13_B18607.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.13 – Successful Ansible playbook completion
  prefs: []
  type: TYPE_NORMAL
- en: '*Question 2* – For this question, we would like you to provide access to HTTP
    via the `192.168.1.0`/`24` domain, but block access via the `172.16.1.0/24` domain.'
  prefs: []
  type: TYPE_NORMAL
- en: Please do this manually and also set it up in an Ansible Automation playbook.
  prefs: []
  type: TYPE_NORMAL
- en: '*Answer 2* – We will use `firewall-cmd` rich rules to accomplish this change.
    We will use the following commands to successfully complete this exercise:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let’s create an Ansible playbook to accomplish the same changes to the
    firewall rules, which can be seen in the following playbook:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'After we have run the playbook using `ansible-playbook -i inventory richrule.yml
    -u emcleroy -k –ask-become -v`, we will see the output in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.14 – Successful Ansible playbook completion output](img/Figure_9.14_B18607.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.14 – Successful Ansible playbook completion output
  prefs: []
  type: TYPE_NORMAL
- en: Managing SELinux
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this section, we will be working to fix SELinux issues when creating files
    and folders to ensure there are no permission issues.
  prefs: []
  type: TYPE_NORMAL
- en: '*Question 1* – For this question, we would like you to create a folder and
    text file in the root directory and then repair the SELinux contexts to the correct
    permissions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Please do this manually and also set it up in an Ansible Automation playbook.
  prefs: []
  type: TYPE_NORMAL
- en: '*Answer 1* – We will use the following commands to successfully create and
    resolve any SELinux context issues:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we will accomplish this action with an Ansible playbook as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'After we have created the Ansible playbook, we will run it with this command:
    `ansible-playbook -i inventory selinux.yml -u emcleroy -k --ask-become -v`. You
    can see the results in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.15 – Successful Ansible Automation playbook run output](img/Figure_9.15_B18607.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.15 – Successful Ansible Automation playbook run output
  prefs: []
  type: TYPE_NORMAL
- en: We learned how to resolve SELinux issues with files and folders in this section
    with easy-to-remember commands that should address issues you run into in the
    exam. Next, we will showcase how to control system processes that are running
    on your servers.
  prefs: []
  type: TYPE_NORMAL
- en: Managing system processes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this section, we will start and enable services. We will also install packages,
    as they are needed for us to start and enable a service that is not already running.
    We are using `postgresql` as an example, but this will work for all the services
    you install, such as DHCP, DNS, and SMB.
  prefs: []
  type: TYPE_NORMAL
- en: '*Question 1* – For this question, we would like you to install `postgresql`
    and start and enable it on `rhel1`.'
  prefs: []
  type: TYPE_NORMAL
- en: Please do this manually and also set it up in an Ansible Automation playbook.
  prefs: []
  type: TYPE_NORMAL
- en: '*Answer 1* – We will use the following commands to install, enable, and start
    `postgresql` on `rhel1`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'After we have completed the installation and startup of `postgresql` manually,
    we need to uninstall `postgresql` so that Ansible can install it. We will use
    the following command to remove `postgresql` from `rhel1`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Once `postgresql` has been removed, we will set up an Ansible playbook as follows
    to install, enable, and start the `postgresql` service:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: We have added `ignore_errors` to the initialization step due to possible failures
    that do not affect the starting or enabling of the service.
  prefs: []
  type: TYPE_NORMAL
- en: 'After we have completed writing the playbook, we will run it using the `ansible-playbook
    -i inventory postgresql.yml -u emcleroy -k --ask-become -v` command. The result
    of running the playbook is shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.16 – Successful run of the postgresql playbook](img/Figure_9.16_B18607.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.16 – Successful run of the postgresql playbook
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we learned how to install, start, and enable services with
    the `postgresql` service as an example. These commands can be used with all services
    that you can install on an RHEL 8.1 system. In the next section, we will delve
    into network teaming.
  prefs: []
  type: TYPE_NORMAL
- en: Managing link aggregation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this section, we will set up network teaming:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Question 1* – For this question, we would like you to set up network teaming
    on the additional NICs that were provisioned in the setup process:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: My setup has the NICs as **enp0s8** and **enp0s9** – yours might be different
    depending on your setup. Set up the connectivity as round-robin runner. You should
    be able to connect to each server using these IPs once set up. You should have
    connectivity to the network team when both NICs are up and when one of the two
    goes down. The connectivity of your main SSH IP should remain up and connected.
  prefs: []
  type: TYPE_NORMAL
- en: Please do this manually and also set it up in an Ansible Automation playbook.
  prefs: []
  type: TYPE_NORMAL
- en: '*Answer 1* – We will be using the following commands to set up the team on
    both systems. Please make sure you use the correct IPv4 address per server:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, repeat the process for `Rhel2`. Once that is complete, you should have
    a `team1` interface that is up and running with `roundrobin` connectivity. You
    can use `ping` to test the interface, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.17 – ping tests to ensure connectivity to the newly set up team](img/Figure_9.17_B18607.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.17 – ping tests to ensure connectivity to the newly set up team
  prefs: []
  type: TYPE_NORMAL
- en: 'After we have completed the team creation manually, we will set up an Ansible
    playbook as follows to create the teams:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'We will then add host variables to our inventory so that each server gets the
    correct IP, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.18 – Updated inventory file with host variables](img/Figure_9.18_B18607.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.18 – Updated inventory file with host variables
  prefs: []
  type: TYPE_NORMAL
- en: 'After we have created the playbook, we can run it using the `ansible-playbook
    -i inventory networkteam.yml -u emcleroy -k --ask-become -v` command – the partial
    output is shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.19 – Successful network teaming playbook run](img/Figure_9.19_B18607.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.19 – Successful network teaming playbook run
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we learned how to team network interfaces together to provide
    redundancy across multiple NICs. In the next section, we will set up and manage
    DNS services.
  prefs: []
  type: TYPE_NORMAL
- en: Managing DNS
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this section, we will set up a DNS server.
  prefs: []
  type: TYPE_NORMAL
- en: '*Question 1* – For this question, we would like you to set up a DNS server.
    We would like you to add forward and reverse records for IPv4\. We will set up
    the DNS server on `rhel1.example.com`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'A and reverse aka PTR records will use the following information:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: '*Answer 1* – We will start by installing the `bind` package:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we will set up the firewall rules to allow for connectivity and the delivery
    of DNS records:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'From installing the package to setting up firewall rules, we will now configure
    the config DNS file, `/etc/named.conf`. This file should look like the following
    screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.20 – Configuration example settings](img/Figure_9.20_B18607.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.20 – Configuration example settings
  prefs: []
  type: TYPE_NORMAL
- en: 'Make sure to include the new zones in the configuration file as shown in the
    following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.21 – Zone information in the configuration file](img/Figure_9.21_B18607.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.21 – Zone information in the configuration file
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we need to create the zone files in the `/var/named` directory. These
    will include the forward and reverse zone records of `192.168.1.zone` and `example.com.zone`.
    We can see an example of each one in the following screenshots:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.22 – DNS zone file setup](img/Figure_9.22_B18607.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.22 – DNS zone file setup
  prefs: []
  type: TYPE_NORMAL
- en: 'After we have set up the forward zone, we will set up the reverse zone, as
    shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.23 – Reverse zone file](img/Figure_9.23_B18607.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.23 – Reverse zone file
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we will start and enable the `named` service that the `bind` package
    installed for running the DNS server:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we will do a lookup to ensure that we are getting the right addresses
    back for the names:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we will install this by using Ansible Automation with the following playbook
    and templates:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'The following are the templates that need to be in place for the correct configuration
    files to be successfully modified during the playbook execution as well. First,
    we have the `named.conf.j2` configuration file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we have the zone files that are needed in order to provide the DNS records.
    First up is the `example.com.zone.j2` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we will add in `192.168.1.zone.j2` for the **Pointer Record** (**PTR**)
    records, also known as the reverse lookup zone file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'After we create the playbook, we run the `ansible-playbook -i /home/emcleroy/playbooks/inventory
    dns.yml -u emcleroy -k --ask-become -v` command, and we can see the successful
    output in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.24 – Successful DNS server deployment via Ansible Automation](img/Figure_9.24_B18607.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.24 – Successful DNS server deployment via Ansible Automation
  prefs: []
  type: TYPE_NORMAL
- en: Managing DHCP
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this section, we will be setting up a DHCP server.
  prefs: []
  type: TYPE_NORMAL
- en: '*Question 1* – For this question, we would like you to set up a DHCP server
    on `rhel1.example.com` that serves the `192.168.1.0`/`24` subnet with an available
    IP range of `192.168.1.100` – `192.168.1.220`. The DNS server is `192.168.1.198`
    or your `rhel1.example.com` IP address. We will want static entries for the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: '*Answer 1* – We will start by installing the `dhcp-server` package as shown
    in the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we will set up the `dhcp` file to accommodate and provide the IP range
    in `/etc/dhcp/dhcpd.conf`, as seen in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.25 – DHCP server configuration file](img/Figure_9.25_B18607.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.25 – DHCP server configuration file
  prefs: []
  type: TYPE_NORMAL
- en: 'Remember there is no need to remember all the lines, as there is an example
    provided after the installation found here: `/usr/share/doc/dhcp-server/dhcpd.conf.example`.
    After we have set up the DHCP configuration file, we will open the firewall rules
    and start and enable `dhcp` services for the server:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let’s set up a DHCP server using Ansible Automation. We will start with
    the following playbook:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'The following code displays the contents of the `dhcpd.conf.j2` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'After we have created the playbook, we can run it using the `ansible-playbook
    -i inventory dhcp.yml -u emcleroy -k --ask-become -v` command to run an Ansible
    playbook successfully, as can be seen in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.26 – Successful DHCP server playbook run](img/Figure_9.26_B18607.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.26 – Successful DHCP server playbook run
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we learned how to set up a DHCP server, including static entries
    in the configuration files. In the next section, we will work with printers that
    are on your network at home or work.
  prefs: []
  type: TYPE_NORMAL
- en: Managing printers
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this section, we will be managing networked printers.
  prefs: []
  type: TYPE_NORMAL
- en: '*Question 1* – For this question, we would like you to set up a network printer
    on `rhel1.example.com`. Please set up a print queue named `myqueue`. If you have
    a network printer, you can test this. If not, you will not be able to test this
    solution/answer.'
  prefs: []
  type: TYPE_NORMAL
- en: '*Answer 1* – We will start by installing `cups` on the system:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'We will then enable and start `cups` print services:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we will allow `mdns` firewall rules to allow access to the printer services:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'We will use the `ippfind` command to find the printers available. In my case,
    I will use `Brother`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we will use the `ipp` address to create the print queue, `myqueue`, and
    add the printer to the queue:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'If you run into the `lpadmin: Unable to connect to "BRW9C305BC2B044.local:631":
    Name or service not known` error, make sure that your DNS can look up that local
    address, and if not, put the host record that directs the use of a shortname or
    URL to an IP address in your `/``etc/hosts` file.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, we will set the default queue destination for printing:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'Next up, we will set up printers with Ansible Automation using the following
    playbook:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'After we have created the playbook, we can run it using the `ansible-playbook
    -i inventory cups.yml -u emcleroy -k --ask-become -v` command to run an Ansible
    playbook successfully, as can be seen in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.27 – Successful cups playbook run](img/Figure_9.27_B18607.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.27 – Successful cups playbook run
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we learned how to connect to a network printer that may be
    available to you to utilize for your everyday work. In the next section, we will
    show you how to set up email services on your servers.
  prefs: []
  type: TYPE_NORMAL
- en: Managing email services
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this section, we will be creating email services on a server.
  prefs: []
  type: TYPE_NORMAL
- en: '*Question 1* – For this question, we would like you to make a null zero client
    on `rhel1.example.com`. We would like any locally delivered mail to be forwarded
    to `rhel2.example.com` for normal delivery to the mail services:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: '*Answer 1* – We will start by installing `postfix`. We will then set the correct
    parameters that are noted in the question and ensure that the mail server does
    not accept external or internal mail:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: Keep in mind that if the exam has you set this for IPv6 as well, make sure to
    set up `inet_protocols` for both IPv4 and IPv6.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we will create an Ansible playbook to complete this same process:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'After we have created the playbook, we will use the `ansible-playbook -i inventory
    email.yml -u emcleroy -k --ask-become -v` command and run an Ansible playbook
    successfully, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.28 – Successful Ansible playbook run for email services](img/Figure_9.28_B18607.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.28 – Successful Ansible playbook run for email services
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we showed you how to modify email services and provided an
    example of setting up a null client configuration. In the next section, we will
    be going over MariaDB configuration and administration.
  prefs: []
  type: TYPE_NORMAL
- en: Managing a MariaDB database server
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this section, we will be installing MariaDB, adding to tables, backing up,
    restoring the content that was previously stored in the columns and tables, and
    searching through the database.
  prefs: []
  type: TYPE_NORMAL
- en: '*Question 1* – For this question, we will install and securely set up MariaDB
    so that `root` can only access locally and the `root` password is `redhat`. We
    will also do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a database named `available_stock`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Create the user `fred` with the password `redhat` with full user rights on database
    inventory
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Create a backup of the database inventory
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Restore the backup of the database inventory
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Answer 1* – We will start by installing the `mariadb` server, starting and
    enabling it, after which we will secure the installation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: We will choose to only allow `root` locally during the secure installation.
    We will choose to remove the test database. We will set a password for `root`
    at this time as well.
  prefs: []
  type: TYPE_NORMAL
- en: 'After we have started MariaDB and secured the installation, we will log in
    and create the database and user:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we are going to take a backup of the database:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'For the Ansible playbook, we are going to modify this, and in a slightly different
    way, we will set up just the database. We will now set up the MariaDB database
    using an Ansible Automation playbook as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'After we have completed creating the playbook, we will run the `ansible-playbook
    -i inventory mariadb.yml -u emcleroy -k --ask-become -v` command and see the successful
    output of the playbook in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.29 – Successful MariaDB playbook run](img/Figure_9.29_B18607.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.29 – Successful MariaDB playbook run
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we learned how to configure MariaDB, including setting up users
    for the database. In the next section, we will be going over setting up web servers.
  prefs: []
  type: TYPE_NORMAL
- en: Managing web access
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this section, we will be setting up web hosts using Apache.
  prefs: []
  type: TYPE_NORMAL
- en: '*Question 1* – For this question, you will need to set up an Apache web host
    that displays `rhel1.example.com` server on the browser via port `80`.'
  prefs: []
  type: TYPE_NORMAL
- en: '*Answer 1* – We will start by installing Apache via the `httpd` package on
    the `rhel1.example.com` server using the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'After `httpd` has been successfully installed, we will create the `index.html`
    file in the default web page location of `/var/www/html/index.html`. Use your
    text editor of choice and create the file with **This server is working on Apache!!!**
    in it. Once we have created the file, we will then start and enable the service
    as displayed in the following commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'After we have started and enabled the service, we will need to open the firewall
    rules to allow connectivity via HTTP using the following commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'Once we have opened the firewall rules, we will then be able to confirm that
    this is working by navigating to the web page via a browser. The following screenshot
    demonstrates a successful deployment of Apache `httpd`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.30 – Successful web host serving the index.html file](img/Figure_9.30_B18607.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.30 – Successful web host serving the index.html file
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we will set up Apache `httpd` via Ansible Automation using the following
    playbook:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: Please ensure that `index.html.j2` is within your playbook directory so that
    it can be copied over successfully.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will use the following command to run the playbook:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: In this section, we set up web server access. In the next section, we will be
    working with NFS file shares.
  prefs: []
  type: TYPE_NORMAL
- en: Managing NFS
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this section, we will be going over NFS.
  prefs: []
  type: TYPE_NORMAL
- en: '*Question 1* – For this question, you will need to make an NFS export on `rhel1.example.com`
    of the `/test` folder with read-only privileges to the `192.168.1.0/24` network
    and no access for the `172.16.1.0/24` network.'
  prefs: []
  type: TYPE_NORMAL
- en: '*Question 2* – For this question, you will need to mount `/test` from `rhel1.example.com`
    on `rhel2.example.com` under `/mnt/test`, and you will need to ensure that it
    mounts on startup.'
  prefs: []
  type: TYPE_NORMAL
- en: '*Answer 1* – We will start by installing `nfs-utils` using the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'After we install `nfs-utils`, we will need to enable and start the service.
    Then, we will ensure that it is running by using the following commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'After that, we will create the `/test` directory using the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'After that, we will add the folder to the `/etc/exports` file in order to export
    it with the proper privileges, allow access from the `192.168.1.0/24` domain,
    and, by default, block it from the rest of the networks, as shown in the following
    screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.31 – exports file for NFS shares](img/Figure_9.31_B18607.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.31 – exports file for NFS shares
  prefs: []
  type: TYPE_NORMAL
- en: 'After we add the folder to the `exports` list, we will use the following commands
    to expose the NFS share:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we will open the firewall rules to allow NFS services out to the world
    using the following commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'For the Ansible solution, we will create the following playbook in order to
    complete the automated version of these manual tasks:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'We will use the following command to run the `ansible-playbook -i inventory
    nfs_server.yml -u emcleroy -k --ask-become -v` playbook and you can see a successful
    run of the Ansible playbook in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.32 – Successful playbook run creating an NFS share](img/Figure_9.32_B18607.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.32 – Successful playbook run creating an NFS share
  prefs: []
  type: TYPE_NORMAL
- en: '*Answer 2* – After we have completed *Question 1*, we can dive into attaching
    the `share` folder to a new machine. On `Rhel2`, we will start by opening the
    firewall to allow NFS connectivity, as shown in the following commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we are going to create the mount point folder in order to add the share
    to `/etc/fstab` and mount it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: 'After that, we are going to add the NFS share to the `/etc/fstab` file in order
    to set it to mount at startup. The file should look something like the following
    screenshot but may differ depending on how you set up your test environment:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.33 – fstab showing the mounts to run at startup](img/Figure_9.33_B18607.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.33 – fstab showing the mounts to run at startup
  prefs: []
  type: TYPE_NORMAL
- en: 'Once this has been added to `fstab`, we will then mount the items in `fstab`
    using the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, to test that this is working, add a file to the `test` directory on `rhel1`
    using the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: 'Once you have done that, navigate to the folder mount point of `/mnt/test`
    and ensure you can view the file from `rhel2` using the following commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see, you are able to view the file. Now, try to add a file to the
    `/mnt/test` folder on `rhel2` and you should receive an error message, such as
    the one shown in the following screenshot, as this is a read-only share:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.34 – Demonstration of being unable to write to any file within the
    share from outside of the server](img/Figure_9.34_B18607.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.34 – Demonstration of being unable to write to any file within the
    share from outside of the server
  prefs: []
  type: TYPE_NORMAL
- en: Now, you have successfully mounted the read-only share, which will persist through
    a reboot as `fstab` mounts the listed mounts at startup.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we will complete these manual tasks using Ansible Automation. We will
    use the following playbook to accomplish the mounting of the share:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: 'After we have created the playbook, we will run it with the `ansible-playbook
    -i inventory nfs_client.yml -u emcleroy -k --ask-become -v` command. The following
    screenshot shows the successful execution of the playbook:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.35 – Successful playbook run to mount NFS share](img/Figure_9.35_B18607.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.35 – Successful playbook run to mount NFS share
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we presented you with mock exam questions that you may be asked
    in some form on the exam itself. We explored what we have learned throughout this
    book through this comprehensive review. New ways of completing tasks were also
    shown in order for you to further enhance your abilities to answer the exam questions
    with ease. In the next chapter, we will look over some exam tips to save you both
    time and stress when taking the exam. We will go over different ways to approach
    the exam to effectively meet the requirements and pass. I look forward to providing
    these tips and tricks, and hope you benefit in some way from them and my own experience
    of taking these exams over the years.
  prefs: []
  type: TYPE_NORMAL
