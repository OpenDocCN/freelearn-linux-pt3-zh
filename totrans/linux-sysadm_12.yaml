- en: '12'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Centralized Authentication
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: User access control is a critically important part of information security.
    On a single machine, keeping track of users and making sure only authorized people
    have access is simple, but as networks become larger, it becomes increasingly
    difficult to keep user accounts in sync on all machines, which is why large networks
    use centralized authentication mechanisms. Historically, UNIX-like systems usually
    used **Network Information Service** (**NIS**), developed by Sun Microsystems
    – a once widespread but now mostly unused protocol. These days, the choice is
    wider and includes standalone LDAP directories, Kerberos realms, or authentication
    solutions that provide a combination of a directory service for storing user information
    and single sign-on protocols, such as FreeIPA and Microsoft Active Directory.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will learn about the following:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
- en: Authentication and user information lookup frameworks in Linux
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The roles of the **Name Service Switch** (**NSS**) framework, **Pluggable Authentication
    Modules** (**PAM**), and the **System Security Services** **Daemon** (**SSSD**)
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to set up a domain controller that’s compatible with Microsoft Active Directory
    and connect a client machine to it
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The AAA framework
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The access control framework is often referred to as *AAA* due to its three
    components: *authentication*, *authorization*, and *accounting*.'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
- en: '**Authentication** is responsible for verifying the user’s identity – usually
    by checking whether the user possesses certain knowledge (such as a password),
    data (such as a cryptographic key or the correct seed for a time-based authentication
    algorithm), a physical item (such as a hardware key storage), or an attribute
    (such as a fingerprint).'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
- en: '**Authorization** is the process of checking whether the user that attempts
    to execute an action has permission to do so. Since in UNIX systems many entities,
    such as hardware devices and sockets, are represented as files, a lot of the time,
    file access permissions are used as an authorization framework.'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
- en: Finally, the **accounting** process ensures that user actions are recorded so
    that it is possible to attribute actions to users, monitor user activity for anomalies,
    and investigate security incidents. Since, for a general-purpose OS, it is impossible
    to give an exhaustive list of user actions, there cannot be a general accounting
    framework. The syslog mechanism is a common way to record log messages, but the
    log message format is different for each application.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
- en: 'Among the user access control components, authentication in Linux is unique
    in that there is a widely used and general framework for it that consists of three
    parts: **NSS**, **PAM**, and, on newer Linux distributions, **SSSD**. The relationship
    between them is somewhat complicated because their functionality is broad and
    partially overlaps, and many tasks can be solved at different levels.'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
- en: The two older parts of that framework, NSS and PAM, originated in the OS named
    Solaris, which was developed by Sun Microsystems (later acquired by Oracle), and
    were soon adopted by almost all UNIX-like systems. However, neither mechanism
    became a part of the POSIX standard and its implementations in different OSs are
    slightly different. SSSD was developed for Linux in the late 2000s and is now
    widely used by Linux distributions, but not by other UNIX-like systems.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
- en: Let’s examine the purpose and functionality of those subsystems in detail.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
- en: Authentication mechanisms in Linux
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Before we learn about centralized authentication mechanisms, we need to learn
    how authentication works in Linux in general. Before a system can check user credentials,
    it needs to fetch user information first – let’s examine how information lookup
    works.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
- en: Information lookup
  id: totrans-17
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Information about users and groups is necessary for authentication, but it has
    many other uses. For example, file ownership information is usually displayed
    in a human-readable fashion, but internally, filesystems store numeric user and
    group identifiers, so even programs that have nothing to do with security, such
    as `ls`, may need to have a way to look up information about users and groups
    to map their identifiers to names.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
- en: The POSIX API standard includes multiple functions for querying information
    about various entities such as users, groups, and hosts. For example, `gethostbyname(name)`
    retrieves network addresses associated with a domain name, and `getgrpnam(name)`
    retrieves information about a user group. For applications, those functions are
    black boxes, and they have neither knowledge nor control of the process – where
    and how the underlying system gets that data is not an application developer’s
    concern. By keeping the process opaque to applications, OS developers can make
    sure that all applications get consistent data from lookup calls.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
- en: In GNU/Linux systems, those functions are implemented by the GNU C library (`glibc`).
    That library, however, does not have a fixed set of supported lookup mechanisms
    and data sources – instead, it uses the **NSS** mechanism as an abstraction layer.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
- en: Name Service Switch
  id: totrans-21
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The NSS subsystem allows an administrator to map *databases* with different
    types of information to *sources*. Let’s inspect its configuration file from a
    Fedora installation to get a sense of what it is capable of:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'NSS is not limited to authentication data lookup and its functionality is much
    broader. The concept of NSS databases and sources is easier to demonstrate on
    a non-authentication example: hostname lookup. The `hosts` database, which is
    responsible for network hostname resolution, is set to use multiple sources, including
    `files` and `dns`.'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
- en: The order of sources determines the order of lookup. In this case, the entry
    for `hosts` tells the system to look up names in local files first, and then turn
    to network sources such as zero-configuration network discovery mechanisms (multicast
    DNS), and finally to the global DNS system. In this particular case, the `files`
    keyword refers to the `/etc/hosts` file, which was discussed in [*Chapter 6*](B18575_06.xhtml#_idTextAnchor109),
    *Basic* *System Settings*.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
- en: 'Sources generally come in order from the fastest and most reliable. Local sources
    are placed first because they are always available even when the network is down
    and reading a local file is a very fast operation. Remote sources come later because
    accessing them always involves at least some latency and they may become inaccessible
    due to network or server faults. Sometimes, like in the case of hostname lookup,
    the order also has security implications: making the system look up names in `/etc/hosts`
    before making a request to a DNS server ensures that traditional names such as
    `localhost` will always point to the localhost (`127.0.0.1` for IPv4 or `::1`
    for IPv6). If DNS were consulted first, a malicious or misconfigured server could
    return a different address and redirect traffic from commands such as `ping localhost`
    to an arbitrary address.'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
- en: The `passwd` database is used to look up user information. Its `files` source
    is the familiar `/etc/passwd` – that is where its name comes from.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
- en: Lookup in different sources is implemented in dynamically loaded libraries (shared
    objects) such as `/usr/lib/libnss_files.so.2` and `/usr/lib/libnss_dns.so.2`.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
- en: It’s certainly possible to implement support for a different authentication
    information database using NSS alone and reuse the oldest login-handling code
    for it – the goal of NSS is to make such client code work with any source so that
    the code will not even know that it now gets user information and password hashes
    from a remote source such as a RADIUS or LDAP server rather than from `/etc/passwd`
    and `/etc/shadow`. That was done in the past and NSS modules for LDAP can still
    be found on the internet.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
- en: However, there are multiple reasons for a more flexible user identity-checking
    framework and an abstraction layer that provides authentication and lookup functionality.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
- en: Pluggable Authentication Modules
  id: totrans-31
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: NSS helps programs retrieve various information, including usernames, group
    membership information, and password hashes. However, the logic for authentication
    still has to exist somewhere. For example, to conduct password-based authentication,
    there must be code that calculates a hash sum from a plain text password that
    the user enters and checks it against the hash stored in an authentication database.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
- en: However, there is more to authentication policies than just having passwords
    and checking that they are correct. Administrators may want to enforce password-strength
    rules or use multi-factor authentication to increase security, for example. Authentication
    using remote databases also presents challenges, such as credential caching to
    ensure that users are not locked out of their machines when the remote database
    becomes temporarily unavailable.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
- en: To allow developers and administrators to create and set up tools for flexible
    authentication policies and add new authentication algorithms, Linux distributions
    use a framework named **PAM**.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
- en: PAM provides an API for applications to authenticate users and for security
    tool developers to implement authentication mechanisms. PAM modules can either
    rely on the NSS layer to look up the information they need to authenticate a user
    or provide their own lookup mechanisms and configuration files.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
- en: On Fedora and Red Hat systems, PAM modules can be found in `/usr/lib64/security/`,
    while on Debian (for x86 machines), they can be found in `/usr/lib/x86_64-linux-gnu/security/`.
    Modules typically come with their own manual pages, so it is possible to get a
    brief description by running `man pam_unix` or `man pam_empty`.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
- en: For example, `pam_empty` is the simplest possible module that always returns
    an authentication failure – it is only useful as a sentinel module to ensure that
    when none of the multiple fallback mechanisms succeed, the user is denied access.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
- en: The `pam_unix` module implements the usual password authentication that normally
    uses the `/etc/passwd` and `/etc/shadow` files unless NSS is configured to use
    anything else.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
- en: Some modules do not implement any authentication mechanisms but rather perform
    auxiliary actions. For example, `pam_motd` shows a message (commonly found in
    `/etc/motd`) after login; `pam_mail` is what’s responsible for checking for local
    email messages and displaying `pam_pwquality` and `pam_pwhistory` help ensure
    that users do not use weak passwords and do not reuse their old passwords.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
- en: PAM configuration
  id: totrans-40
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: While configuring PAM by hand is rarely a good idea and most Linux distributions
    discourage it and provide high-level configuration tools instead, it is still
    important to understand how its configuration files work.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
- en: First of all, PAM is not a program, but a framework and a set of APIs that are
    used by other programs. There is no single login program in Linux, so there is
    no one global authentication configuration file either. Instead, there are multiple
    programs with login capabilities that share most but not all of the configurations.
    These programs include the `/bin/login` executable, which handles local virtual
    console login attempts, but PAM is also independently used by graphical login
    managers (such as GDM or LightDM), screensavers, and network access services (such
    as OpenSSH).
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
- en: Configuration files are stored in `/etc/pam.d/`, but none of them have any special
    meaning by themselves – they are all read and used by different programs. For
    example, the file named `/etc/pam.d/login` is used by `/bin/login` and thus applied
    only to local virtual consoles.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 配置文件存储在 `/etc/pam.d/` 中，但它们本身没有任何特殊意义——它们都由不同的程序读取和使用。例如，名为 `/etc/pam.d/login`
    的文件由 `/bin/login` 使用，因此仅应用于本地虚拟控制台。
- en: The names of those application-specific files are hardcoded in the programs
    that use them, but the shared configuration is stored in separate files whose
    names vary from one distribution to another.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 这些应用程序特定文件的名称是硬编码在使用它们的程序中的，但共享配置存储在独立的文件中，这些文件的名称在不同的发行版之间有所不同。
- en: Let’s compare default configuration files for the OpenSSH daemon’s use of PAM
    on Fedora and Debian. If you don’t have OpenSSH installed, you can check out a
    different file, such as `/etc/pam.d/login`.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们比较 Fedora 和 Debian 中 OpenSSH 守护进程使用 PAM 的默认配置文件。如果你没有安装 OpenSSH，你可以查看其他文件，比如
    `/etc/pam.d/login`。
- en: 'This file is from Fedora:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 这个文件来自 Fedora：
- en: '[PRE1]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'And this one is from a Debian system:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 这个来自 Debian 系统：
- en: '[PRE2]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: As you can see, they are nearly identical in their functionality but organized
    differently. For example, Debian makes extensive use of the `@include` directive,
    which loads all lines from a different file. For example, `@include common-auth`
    instructs PAM to load `/etc/pam.d/common-auth` – all such file references are
    relative to `/etc/pam.d`.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，它们的功能几乎相同，但组织方式不同。例如，Debian 广泛使用 `@include` 指令，它加载来自不同文件的所有行。例如，`@include
    common-auth` 指示 PAM 加载 `/etc/pam.d/common-auth` ——所有此类文件引用都是相对于 `/etc/pam.d` 的。
- en: 'The authors of the Fedora file chose to use a module interface call instead:
    `auth substack system-auth`. In such lines, the last option is either a module
    name or a configuration file reference. If it ends with `.so` (the usual extension
    of shared objects – dynamically loadable library files), then it is a module;
    otherwise, it’s a configuration file in `/etc/pam.d`. So, when you see `substack
    system-auth`, it means loading lines from `/etc/pam.d/system-auth` (the `include`
    and `substack` options work similarly).'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: Fedora 文件的作者选择使用模块接口调用，而不是：`auth substack system-auth`。在这样的行中，最后一个选项要么是模块名称，要么是配置文件引用。如果以
    `.so` 结尾（这是共享对象文件的常见扩展名——动态加载的库文件），那么它就是一个模块；否则，它是 `/etc/pam.d` 中的配置文件。因此，当你看到
    `substack system-auth` 时，它意味着加载来自 `/etc/pam.d/system-auth` 的行（`include` 和 `substack`
    选项的工作方式类似）。
- en: The first part of all such lines is a module interface name. Some modules provide
    only one interface type (for example, `pam_unix` only handles password authentication),
    while others may provide more than one type. The `auth` interface is for performing
    authentication. Other interface types show that *Pluggable Authentication Modules'*
    name is partially a misnomer. The `account` interface handles authorization and
    checks whether the user’s account is allowed to log in – for example, the `pam_time`
    module can allow specific users to access the system only at certain hours or
    on certain days. The `password` interface handles password changing. Finally,
    the `session` interface handles auxiliary tasks unrelated to authentication, such
    as creating home directories for users on their first login or mounting directories
    over the network.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 所有此类行的第一部分是模块接口名称。有些模块仅提供一种接口类型（例如，`pam_unix` 仅处理密码认证），而其他模块可能提供多种类型。`auth`
    接口用于执行身份验证。其他接口类型表明 *可插拔认证模块* 的名称在某些情况下并不准确。`account` 接口处理授权并检查用户账户是否允许登录——例如，`pam_time`
    模块可以让特定用户仅在某些时间段或某些日期访问系统。`password` 接口处理密码更改。最后，`session` 接口处理与认证无关的辅助任务，例如在用户第一次登录时为其创建主目录或通过网络挂载目录。
- en: Limitations of PAM
  id: totrans-53
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: PAM 的局限性
- en: PAM is only concerned with authentication and related activities; so, for example,
    configuring a `pam_ldap` module with the correct LDAP server and options will
    not automatically make user and group information from LDAP available to all applications
    that need to map numeric identifiers to names. In that case, to provide a seamless
    experience to users, an administrator also needs an NSS module. Configuring two
    modules with the same information independently creates a significant maintenance
    burden, and feeding information from remote sources to a simple module such as
    `pam_unix` does not work for single sign-on protocols such as Kerberos that require
    issuance and verification of session tokens rather than simple password hash sum
    checking. Historically, that problem was solved with custom daemons such as `winbind`
    for interaction with Microsoft Active Directory or Samba domains. These days,
    most Linux distributions solve this with a general abstraction layer – the **SSSD**.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: PAM 仅关注认证和相关活动；例如，配置一个正确的 LDAP 服务器和选项的 `pam_ldap` 模块并不会自动使 LDAP 中的用户和组信息对所有需要将数字标识符映射到名称的应用程序可用。在这种情况下，为了提供无缝体验，管理员还需要配置一个
    NSS 模块。独立配置两个模块并提供相同的信息会带来显著的维护负担，而且将信息从远程源传递给像 `pam_unix` 这样的简单模块对于需要发放和验证会话令牌而非简单密码哈希检查的单点登录协议（如
    Kerberos）不起作用。历史上，这个问题通过定制守护进程如 `winbind` 来解决，用于与 Microsoft Active Directory 或
    Samba 域交互。如今，大多数 Linux 发行版通过通用抽象层——**SSSD** 解决了这个问题。
- en: System Security Services Daemon
  id: totrans-55
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 系统安全服务守护进程
- en: The combination of NSS and PAM allows great flexibility but can also make common
    scenarios hard to configure and maintain. The SSSD project strives to simplify
    that process by coordinating the interaction of both PAM and NSS with remote databases.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: NSS 和 PAM 的结合提供了很大的灵活性，但也可能使常见场景的配置和维护变得困难。SSSD 项目努力通过协调 PAM 和 NSS 与远程数据库的交互来简化这一过程。
- en: One source of configuration complexity for single sign-on schemes is that they
    usually involve multiple components and protocols, such as LDAP for storing user
    information and Kerberos for issuing and checking cryptographic authentication
    tickets, plus a way to discover those services, typically via special DNS records.
    SSSD has built-in support for popular SSO schemes such as Microsoft Active Directory
    and FreeIPA, which greatly simplifies the process.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 单点登录方案的配置复杂性之一在于它们通常涉及多个组件和协议，例如用于存储用户信息的 LDAP 和用于发放及检查加密认证票证的 Kerberos，以及发现这些服务的方式，通常通过特殊的
    DNS 记录。SSSD 内置支持流行的单点登录方案，如 Microsoft Active Directory 和 FreeIPA，这大大简化了过程。
- en: For this demonstration, we will set up a Microsoft Active Directory-compatible
    domain controller on Linux using the Samba project and then make a client machine
    join its domain. We will use Fedora Linux on both, but other distributions would
    mostly differ just in package installation commands.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 在本示范中，我们将在 Linux 上使用 Samba 项目设置与 Microsoft Active Directory 兼容的域控制器，并将客户端计算机加入该域。我们将使用
    Fedora Linux，但其他发行版在包安装命令上大多有所不同。
- en: Active Directory authentication with Samba 4
  id: totrans-59
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Samba 4 进行 Active Directory 认证
- en: Samba is an open source implementation of multiple protocols that are required
    for interoperability with Microsoft Windows machines, including the SMB file-sharing
    protocol (which is where the Samba name came from). Apart from file sharing, it
    also implements authentication and user management – initially, it only supported
    Windows NT domains, but since 4.0.0, it has full support for Active Directory
    that’s compatible with Windows Server 2008 and also includes built-in LDAP and
    DNS backends, which makes small installations very simple to deploy.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: Samba 是一个开源实现，支持与 Microsoft Windows 机器互操作所需的多个协议，包括 SMB 文件共享协议（Samba 名字的来源）。除了文件共享外，它还实现了认证和用户管理——最初，它只支持
    Windows NT 域，但自 4.0.0 版本以来，它完全支持与 Windows Server 2008 兼容的 Active Directory，并且还包括内建的
    LDAP 和 DNS 后端，使得小规模安装变得非常简单。
- en: Setting up the domain controller
  id: totrans-61
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 设置域控制器
- en: 'First, you will need to install the Samba domain controller package:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，您需要安装 Samba 域控制器软件包：
- en: '[PRE3]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Then, you may want to remove all configuration files for Samba and the Kerberos
    daemon to ensure a clean state:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，您可能需要删除 Samba 和 Kerberos 守护进程的所有配置文件，以确保清洁状态：
- en: '[PRE4]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Samba includes a command for automatically provisioning domain controllers,
    so there is no need to write configuration files by hand. This command supports
    both interactive and non-interactive modes, and it is also possible to specify
    some parameters through command-line options but enter the rest interactively.
    For example, if you plan to run the client system in a VirtualBox VM, you can
    set the controller to only listen on the VM network interface with `--option="interfaces=vboxnet0"
    --option="bind interfaces only=yes"`. You may also want to include fields for
    UNIX users in the LDAP schema that the controller will use – they are defined
    by RFC2307, so that option is `--use-rfc2307`.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
- en: 'The most important required parameter is the realm name, which must be a domain
    name written in capital letters – this is a requirement of the Kerberos protocol,
    and lowercase realm names will be rejected. We will use `AD.EXAMPLE.COM`, where
    `example.com` is one of the domains reserved for examples and documentation that
    is guaranteed not to belong to any real person or organization. Most modern client
    software uses the realm name primarily or exclusively, but the provision utility
    will also ask for the domain name (in the NetBIOS rather than DNS sense) – a string
    up to 15 characters long. Since Active Directory and its compatible implementations
    rely on DNS SRV records to find controllers and communicate with them, the controller
    will also serve those DNS records, but we will limit it to listen on the VM network
    interface – in this case, `192.168.56.1` (the default address for host-only network
    adapters in VirtualBox). It will also require a domain administrator password
    – you need to remember it to join that domain from client machines:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Note that the provisioning script generates a configuration file for Kerberos
    but does not deploy it – you need to copy it to its target location yourself:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Now, all we need to do is start the Samba service:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: We will also create a user named `testuser` to verify that authentication is
    working as expected. The command to create a new user in our controller is `sudo
    samba-tool user create test-user` (it will ask you to enter a password).
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
- en: 'With `sudo samba-tool user show testuser`, you can see the LDAP fields for
    that user account:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The server is now ready to receive authentication requests.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
- en: Setting up the client
  id: totrans-77
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now that the domain controller is ready, we can set up a client machine to authenticate
    users against it. Since we are using Fedora for the client as well, it most likely
    has both SSSD and `realmd` – a tool for configuring authentication realms – installed
    by default.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
- en: 'We can verify that the controller is working using a `realm discover` command,
    as follows:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'From this output, we can see that this machine has not joined that domain yet
    (`configured: no`). It also shows a list of packages that need to be installed
    to join it – if any are not installed yet, you can install them with a DNF command
    such as `sudo dnf` `install samba-common-tools`.'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
- en: 'Joining the domain is also very simple. Once you run `sudo realm join ad.example.com`,
    it will ask you for the domain administrator password (the one you entered on
    the controller during the provisioning process) and generate configuration files
    for SSSD:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: You will need to restart SSSD with `sudo systemctl restart sssd` to apply the
    changes.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
- en: 'The generated SSSD configuration will look like this:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Since SSSD acts as an NSS provider and the default `nssswitch.conf` value for
    `passwd` is `files sss` in Fedora, we can query information about the `testuser`
    account using the usual `id` command, although in our configuration, we will need
    to specify its fully qualified name with the domain:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: It is also immediately possible to log in to the console by entering `testuser@ad.example.com`
    and the password we set on the controller earlier.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, setting up a domain controller that’s compatible with Microsoft
    Active Directory using Samba is a simple and mostly automated procedure.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-91
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we learned how Linux-based systems implement authentication
    processes and user information lookup using PAM, NSS, and SSSD. We also learned
    about solutions for centralized authentication and demonstrated how to set up
    a domain controller that’s compatible with Microsoft Active Directory using Samba
    software and join that domain from another Linux machine.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will learn about high-availability mechanisms in Linux.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
- en: Further reading
  id: totrans-94
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To learn more about the topics that were covered in this chapter, take a look
    at the following resources:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
- en: 'SSSD documentation: [https://sssd.io/docs/introduction.xhtml](https://sssd.io/docs/introduction.xhtml%0D)'
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Samba project: [https://www.samba.org/](https://www.samba.org/%0D)'
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'FreeIPA project: [https://www.freeipa.org/](https://www.freeipa.org/%0D)'
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Kerberos: [https://en.wikipedia.org/wiki/Kerberos_(protocol)](https://en.wikipedia.org/wiki/Kerberos_(protocol)%0D)'
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'LDAP: [https://en.wikipedia.org/wiki/Lightweight_Directory_Access_Protocol](https://en.wikipedia.org/wiki/Lightweight_Directory_Access_Protocol%0D)'
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Microsoft Active Directory: [https://en.wikipedia.org/wiki/Active_Directory](https://en.wikipedia.org/wiki/Active_Directory)'
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
