- en: '*Chapter 7*: Understanding systemd Timers'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第 7 章*: 理解 systemd 定时器'
- en: 'Busy system administrators like to find ways to make their lives easier. One
    way to do that is to automate as many of their routine tasks as possible by setting
    them up to automatically run on a set schedule. In this chapter, we''ll look at
    how to do this with `systemd` timers. The specific topics that we''ll look at
    include the following:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 繁忙的系统管理员喜欢找到方法简化他们的工作。一个方法是通过设置自动执行的计划来将尽可能多的日常任务自动化。在本章中，我们将学习如何使用 `systemd`
    定时器来做到这一点。我们将探讨的具体主题包括以下内容：
- en: Comparing `systemd` timers with `cron`
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将 `systemd` 定时器与 `cron` 进行比较
- en: Understanding timer options
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解定时器选项
- en: Creating timers
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建定时器
- en: If you're ready, let's get started.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你准备好了，那我们就开始吧。
- en: Technical requirements
  id: totrans-6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: As always, we'll be using an Ubuntu Server 20.04 virtual machine and an Alma
    Linux 8 virtual machine for our demonstrations. It's all hands-on, so feel free
    to follow along with your own virtual machines.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 一如既往，我们将使用 Ubuntu Server 20.04 虚拟机和 Alma Linux 8 虚拟机进行演示。所有内容都是动手操作，因此可以随时在你自己的虚拟机上跟着做。
- en: 'Check out the following link to see the Code in Action video: [https://bit.ly/31pQdfS](https://bit.ly/31pQdfS)'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 查看以下链接以观看“代码实战”视频：[https://bit.ly/31pQdfS](https://bit.ly/31pQdfS)
- en: Comparing systemd timers with cron
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将 `systemd` 定时器与 `cron` 进行比较
- en: The `cron` family of scheduling utilities has been a part of Unix and Unix-like
    operating systems since May 1975\. In the 1980s, as part of Richard Stallman's
    new *free software* movement, several free-as-in-speech versions of `cron` were
    created. Paul Vixie, a member of the *Internet Hall of Fame*, created his own
    free version in 1987\. Vixie's version became the most widely used version in
    the Linux world. (In fact, if you look at the `cron` man page, you'll still see
    Paul Vixie's name in the **Authors** section at the bottom.)
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: '`cron` 调度工具家族自 1975 年 5 月以来便成为了 Unix 和类 Unix 操作系统的一部分。在 1980 年代，作为理查德·斯托曼（Richard
    Stallman）倡导的 *自由软件* 运动的一部分，几种自由软件版本的 `cron` 被创建。互联网名人堂成员**保罗·维克西**（Paul Vixie）于
    1987 年创建了自己版本的 `cron`，该版本在 Linux 世界中成为了最广泛使用的版本。（实际上，如果你查看 `cron` 的手册页，你仍然可以在底部的
    **Authors** 部分看到保罗·维克西的名字。）'
- en: 'A big advantage of `cron` is its sheer simplicity. All it takes to create a
    `cron` job is one simple line of code, which would look something like this:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: '`cron` 的一个大优点是它的极简性。创建一个 `cron` 作业所需要的仅仅是一行简单的代码，通常看起来像这样：'
- en: '![](img/Figure_7.1_B17491.jpg)'
  id: totrans-12
  prefs: []
  type: TYPE_IMG
  zh: '![](img/Figure_7.1_B17491.jpg)'
- en: Figure 7.1 – An example of a cron job
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.1 – 一个 cron 作业示例
- en: In this very simple example, which I took from one of my ancient CentOS 6 virtual
    machines, I'm running a simple task at 25 minutes and 55 minutes past every hour
    of every day. Twice every hour, this `cron` job inserts a message into the system
    log file. Any non-privileged user who needs to can create a `cron` job to perform
    some non-privileged task and anyone with the proper root-level privileges can
    create a system-level job. Jobs can be set up to run on a particular day of the
    week, a particular day of the month, at particular times of the day, or upon rebooting
    the machine. There's a lot of flexibility here, and it's all very simple to set
    up.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个非常简单的示例中，我从我一台古老的 CentOS 6 虚拟机上拿到的，我在每小时的 25 分钟和 55 分钟运行一个简单的任务。每小时两次，这个
    `cron` 作业会将一条消息插入到系统日志文件中。任何非特权用户只要需要，都可以创建 `cron` 作业来执行一些非特权任务，而拥有适当 root 权限的用户则可以创建系统级作业。作业可以设置为在一周中的特定日子、一个月中的特定日子、特定时间或重启机器时运行。这里有很多灵活性，而且一切都非常容易设置。
- en: Another advantage of `cron` is that it's everywhere in the world of Unix and
    Unix-like operating systems, while `systemd` only exists in the world of Linux.
    If you're a system administrator in a large shop with a mix of both Unix and Linux
    servers, you might find it easier to stick with `cron`.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: '`cron` 的另一个优点是它在 Unix 和类 Unix 操作系统的世界中无处不在，而 `systemd` 仅存在于 Linux 世界中。如果你是一个管理着混合
    Unix 和 Linux 服务器的大型系统管理员，你可能会发现继续使用 `cron` 更为方便。'
- en: Setting up `systemd` timers isn't hard, but it does take a bit more time and
    effort. To begin with, you can't directly access a command or a script from a
    `systemd` timer. You first have to create a `systemd` service, then call that
    service from the timer. However, there are quite a few advantages of using `systemd`
    timers, so learning how to use them could be well worth the effort.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 设置 `systemd` 定时器并不难，但确实需要花费更多的时间和精力。首先，你不能直接从 `systemd` 定时器访问命令或脚本。你首先需要创建一个
    `systemd` 服务，然后从定时器中调用该服务。然而，使用 `systemd` 定时器有很多优点，因此学习如何使用它们可能值得付出这些努力。
- en: With `systemd` timers, you have a lot more flexibility and accuracy in the way
    you set up task schedules. The services that you create to go along with your
    timers can take advantage of resource management, security, and all of the other
    goodness that comes with using `systemd`. You can create timers that trigger upon
    some predefined event, or you can specify the calendar and clock time for when
    you want to trigger the timer. As an added bonus, `systemd` will log the completion
    of a timer event in the system log file. With `cron` jobs, you don't have any
    of that.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `systemd` 定时器，你可以在设置任务调度时获得更多的灵活性和准确性。你为定时器创建的服务可以利用资源管理、安全性以及所有使用 `systemd`
    时带来的好处。你可以创建在某个预定义事件发生时触发的定时器，或者可以指定你希望定时器触发的日历和时钟时间。作为额外的好处，`systemd` 会在系统日志文件中记录定时器事件的完成情况。而在使用
    `cron` 任务时，你是没有这些功能的。
- en: So, you're now wondering which of these two task-scheduling systems you should
    use. Well, `cron` does still come installed on modern Linux systems. If you just
    need to quickly create a simple job, there's certainly nothing wrong with using
    `cron`. But, if you need to set up something a bit fancier, then definitely go
    with a `systemd` timer. Even if you do just need something simple, it might still
    be worth your while to set up a timer in order to get familiar with the process.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，你现在可能在想应该使用这两种任务调度系统中的哪一个。实际上，`cron` 仍然会预装在现代 Linux 系统上。如果你只是需要快速创建一个简单的任务，使用
    `cron` 完全没有问题。但如果你需要设置一些更复杂的任务调度，那么一定要使用 `systemd` 定时器。即使你只需要做一些简单的事情，设置一个定时器也可能会让你更熟悉这个过程，值得一试。
- en: Okay, that's probably enough for the introduction. Let's look at how to view
    information about the `systemd` timers on your system.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 好了，这部分介绍大概够了。接下来我们来看看如何查看你系统上 `systemd` 定时器的信息。
- en: Viewing timer information
  id: totrans-20
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 查看定时器信息
- en: 'When you first install a Linux operating system, you''ll see that there are
    already some active timers that take care of certain administrative tasks. You
    can see them by using the `systemctl list-unit-files -t timer` command. On your
    Alma Linux machine, the output should look something like this:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 当你首次安装 Linux 操作系统时，会发现系统上已经有一些活跃的定时器来处理某些管理任务。你可以通过使用 `systemctl list-unit-files
    -t timer` 命令查看它们。在你的 Alma Linux 系统上，输出应该如下所示：
- en: '![](img/Figure_7.2_B17491.jpg)'
  id: totrans-22
  prefs: []
  type: TYPE_IMG
  zh: '![](img/Figure_7.2_B17491.jpg)'
- en: Figure 7.2 – Timers on Alma Linux
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.2 – Alma Linux 上的定时器
- en: We see that 12 timers are installed, but only two are enabled. Two are static,
    which means that they can't be either enabled or disabled, and all the rest are
    disabled.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 我们看到安装了 12 个定时器，但只有两个是启用的。两个是静态的，这意味着它们无法启用或禁用，其他的都被禁用了。
- en: 'On the Ubuntu server machine, we see that quite a few more timers are enabled:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Ubuntu 服务器上，我们看到启用的定时器更多：
- en: '![](img/Figure_7.3_B17491.jpg)'
  id: totrans-26
  prefs: []
  type: TYPE_IMG
  zh: '![](img/Figure_7.3_B17491.jpg)'
- en: Figure 7.3 – Timers on Ubuntu server
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.3 – Ubuntu 服务器上的定时器
- en: 'The `systemctl list-timers` command shows you six fields of information, which
    look like this:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: '`systemctl list-timers` 命令展示了六个信息字段，内容如下：'
- en: '![](img/Figure_7.4_B17491.jpg)'
  id: totrans-29
  prefs: []
  type: TYPE_IMG
  zh: '![](img/Figure_7.4_B17491.jpg)'
- en: Figure 7.4 – systemctl list-timers
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.4 – systemctl list-timers
- en: 'The six fields are as follows:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 这六个字段分别是：
- en: '**NEXT**: This shows the next time that the timer is scheduled to run.'
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**下次运行时间**：这显示定时器下次预定的运行时间。'
- en: '**LEFT**: This shows how much time is left before the timer runs again.'
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**剩余时间**：这显示定时器下次运行前剩余的时间。'
- en: '**LAST**: This shows the time at which the timer last ran.'
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**上次运行时间**：这显示定时器最后一次运行的时间。'
- en: '**PASSED**: This shows how much time has elapsed since the timer last ran.'
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**已过时间**：这显示自定时器最后一次运行以来已经过去的时间。'
- en: '**UNIT**: This is the name of the unit file for the timer.'
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**单元**：这是定时器的单元文件名称。'
- en: '**ACTIVATES**: This is the name of the service that the timer runs. This will
    normally be the same name as the timer, but it doesn''t have to be.'
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**激活服务**：这是定时器运行的服务名称。通常它与定时器的名称相同，但不一定是。'
- en: 'You can view some of this information with `systemctl status`, like this:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过 `systemctl status` 查看一些信息，像这样：
- en: '[PRE0]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Just as you can do with services and targets, you can view the dependency tree
    for a timer, as follows:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 就像你可以使用服务和目标一样，你也可以查看定时器的依赖树，方法如下：
- en: '[PRE1]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: We've seen several ways to view information about the timers on your system.
    Let's move on and look at some of the configuration options.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到几种查看系统上定时器信息的方法。接下来，我们来看一些配置选项。
- en: Understanding timer options
  id: totrans-43
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解定时器选项
- en: The best way to start explaining the timer options is to look at some examples
    of timers that are already on our systems. We'll begin by looking at a timer on
    the Alma Linux machine.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 解释定时器选项的最佳方式是查看一些已经存在于我们系统中的定时器示例。我们将首先查看Alma Linux机器上的一个定时器。
- en: Understanding monotonic timers
  id: totrans-45
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 理解单调定时器
- en: There are two ways to specify the time at which you want a service to automatically
    run. In this section, we'll look at the *monotonic* method. This means that instead
    of configuring the job to run at a specific calendar and clock time, you'll instead
    configure the job to run after some sort of event that serves as a starting point.
    A starting point can be system bootup, timer activation, the time since a timer's
    associated service last ran, or any of several other things (you can see all of
    the monotonic starting points by looking at the `systemd.timer` man page). For
    an example of a monotonic timer, let's look at `dnf-makecache.timer` on the Alma
    Linux machine.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 有两种方法可以指定你希望服务自动运行的时间。在这一部分，我们将介绍*单调*方法。这意味着你不需要配置作业在特定的日历时间和时钟时间运行，而是配置作业在某种作为起始点的事件之后运行。起始点可以是系统启动、定时器激活、定时器关联服务上次运行后的时间，或者其他几种情况（你可以通过查看`systemd.timer`的手册页来查看所有单调起始点）。作为单调定时器的示例，我们来看看Alma
    Linux机器上的`dnf-makecache.timer`。
- en: 'Red Hat-type operating systems, such as Alma Linux, use the `dnf` utility to
    perform update and package management. As with all Linux package management systems,
    `dnf` maintains a local cache of information about what is in the distro''s package
    repositories. Periodically, the cache needs to be refreshed. We could do that
    manually with a `sudo dnf makecache` command, but Red Hat-type systems all come
    with a timer to do it automatically. Here''s what the timer looks like:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 类似Red Hat的操作系统，如Alma Linux，使用`dnf`工具进行更新和包管理。和所有Linux包管理系统一样，`dnf`维护一个关于发行版包仓库中内容的本地缓存。定期需要刷新缓存。我们可以手动执行`sudo
    dnf makecache`命令来实现，但Red Hat类系统都自带一个定时器来自动执行这一操作。以下是该定时器的样子：
- en: '[PRE2]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'In the `[Unit]` section, we see:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 在`[Unit]`部分，我们看到：
- en: '`ConditionKernelCommandLine=!rd.live.image`: This prevents the timer from running
    if the machine is booted from some sort of live media, such as a live DVD.'
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ConditionKernelCommandLine=!rd.live.image`：如果机器是从某种实时媒体（例如实时DVD）启动的，这条指令会阻止定时器运行。'
- en: '`ConditionPathExists=!/run/ostree-booted`: This looks for the `/run/ostree-booted`
    directory, and prevents the timer from running if this directory is found. (According
    to the `ostree` man page, you would use `ostree` to manage different versions
    of filesystem trees. These filesystem trees are mounted as read-only, so trying
    to update the cache on them wouldn''t do much good.)'
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ConditionPathExists=!/run/ostree-booted`：该指令会查找`/run/ostree-booted`目录，如果该目录存在，定时器就不会运行。（根据`ostree`的手册页，你会使用`ostree`来管理不同版本的文件系统树。这些文件系统树是以只读方式挂载的，因此尝试更新它们的缓存效果不大。）'
- en: '`Wants=network-online.target`: This prevents the timer from running until after
    network services are available. (Already, you''re seeing things you can do with
    `systemd` timers that you can''t do with `cron`.)'
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Wants=network-online.target`：这会阻止定时器在网络服务可用之前运行。（你已经看到了一些使用`systemd`定时器可以做的事情，而这些是`cron`做不到的。）'
- en: 'Next, we see the `[Timer]` section, with two examples of monotonic timer settings.
    As I''ve already mentioned, monotonic timers are defined relative to a certain
    starting point, rather than by calendar and clock time:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们看到`[Timer]`部分，其中有两个单调定时器设置的示例。正如我之前提到的，单调定时器是相对于某个起始点来定义的，而不是由日历和时钟时间来决定的：
- en: '`OnBootSec=10min`: As we''ll see in a moment, this timer activates the `dnf-makecache.service`.
    This line causes the service to run 10 minutes after the system has booted up.'
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`OnBootSec=10min`：正如我们稍后会看到的，这个定时器会激活`dnf-makecache.service`。这一行使得该服务在系统启动后10分钟运行。'
- en: '`OnUnitInactiveSec=1h`: This line says that the timer will run the `dnf-makecache.service`
    again one hour after the last time it ran. In other words, this line causes the
    service to run approximately every hour.'
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`OnUnitInactiveSec=1h`：这一行表示定时器会在上次运行后的一个小时再次运行`dnf-makecache.service`。换句话说，这一行使得该服务大约每小时运行一次。'
- en: '`Unit=dnf-makecache.service`: In this case, it''s not necessary to have this
    line. By default, a timer will activate a service that has the same name as the
    timer. The only time you really have to have this line is if the timer activates
    a service with a different name. Still though, some people like to use this parameter
    in any case, and there''s nothing wrong with that.'
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Unit=dnf-makecache.service`：在这种情况下，这一行并不是必需的。默认情况下，定时器会激活与定时器同名的服务。只有在定时器激活一个与其名称不同的服务时，你才需要这行。不过，有些人喜欢在任何情况下都使用这个参数，这也是可以的。'
- en: Note
  id: totrans-57
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注释
- en: You can see the rest of the monotonic timer parameters on the `systemd.timer`
    man page.
  id: totrans-58
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 你可以在`systemd.timer`手册页中查看其余的单调定时器参数。
- en: The `[Install]` section is fairly standard stuff. All we see there is the `WantedBy=timers.target`
    line, which causes this timer to run when the `timers.target` starts.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: '`[Install]`部分是相当标准的内容。我们看到的只是`WantedBy=timers.target`这一行，它使得定时器在`timers.target`启动时运行。'
- en: 'While we''re at it, we might as well look at the `dnf-makecache.service` that
    this timer activates:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 既然提到这个，我们不妨看看这个定时器启动的`dnf-makecache.service`：
- en: '[PRE3]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'In the `[Service]` section, we see a few things that we haven''t seen in service
    files before:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 在`[Service]`部分，我们看到了一些在服务文件中没有见过的内容：
- en: '`Type=oneshot`: Okay, we actually have seen this one before. I just want to
    show here that you need to use the `oneshot` type for services that are called
    by timers. (It really makes sense when you think about it.)'
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Type=oneshot`：好了，实际上我们之前已经见过这个。这里我只是想说明，对于定时器调用的服务，需要使用`oneshot`类型。（当你仔细想想时，实际上是很有道理的。）'
- en: '`Nice=19`: This causes the service to run with a niceness value of `19`, which
    means that the service will run with the lowest possible priority. (Niceness values
    range from `-20` to positive `19`. Although it seems counterintuitive, `-20` denotes
    the highest priority that can be assigned to a process, and positive `19` denotes
    the lowest.) This setting helps prevent this service from bogging down other processes
    that might be more important.'
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Nice=19`：这会使服务以`19`的优先级运行，即以最低的优先级运行。（Nice值的范围从`-20`到正`19`。虽然这看起来有点不符合直觉，但`-20`表示可以分配给进程的最高优先级，而正`19`表示最低优先级。）这个设置有助于防止该服务影响到可能更重要的其他进程。'
- en: '`IOSchedulingClass=2`: This sets the type of input/output scheduler scheme
    that we want to use. A value of `2` means that we want to use the `best-effort`
    type scheduling class. (You can see the other `IOSchedulingClass` types in the
    `systemd.exec` man page.)'
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`IOSchedulingClass=2`：这设置了我们想要使用的输入/输出调度程序方案类型。值为`2`意味着我们希望使用`best-effort`类型的调度类。（你可以在`systemd.exec`手册页中查看其他`IOSchedulingClass`类型。）'
- en: '`IOSchedulingPriority=7`: `IOSchedulingPriority` values range from `0` through
    `7`, with `0` as the highest priority and `7` as the lowest. This is just another
    way to keep this service from bogging down the rest of the system.'
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`IOSchedulingPriority=7`：`IOSchedulingPriority`的值范围从`0`到`7`，其中`0`是最高优先级，`7`是最低优先级。这是另一种避免该服务影响系统其他部分的方式。'
- en: '`ExecStart=/usr/bin/dnf makecache --timer`: The `--timer` option here has nothing
    to do with `systemd` timers. Instead, this is an option that goes along with the
    `dnf` command. According to the `dnf` man page, `--timer` causes `dnf` to be more
    resource-aware, so that it won''t run if the computer is running on battery power.
    It also causes the `dnf makecache` command to immediately abort if it has already
    been run recently.'
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ExecStart=/usr/bin/dnf makecache --timer`：这里的`--timer`选项与`systemd`定时器无关。实际上，这是一个与`dnf`命令一起使用的选项。根据`dnf`手册，`--timer`使`dnf`更加关注资源使用，因此如果计算机正在使用电池电源时，它不会运行。它还会使`dnf
    makecache`命令在最近已经执行过时立即中止。'
- en: The `[Install]` section of this service file is conspicuous by its absence.
    Not having the `[Install]` section makes this a *static* type of service that
    you can't enable. Instead, it will just run whenever the `dnf-makecache.timer`
    activates it.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 这个服务文件的`[Install]`部分因为缺失而显得尤为显眼。没有`[Install]`部分使得这是一个*静态*类型的服务，你不能启用它。相反，它会在`dnf-makecache.timer`激活时自动运行。
- en: Okay, that about does it for this example. Next, we'll look at the other ways
    to specify when to run a job.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，以上就是这个例子的内容。接下来，我们将探讨指定任务运行时间的其他方式。
- en: Understanding real-time timers
  id: totrans-70
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 理解实时定时器
- en: 'You can use a *real-time* timer to run a job on whatever calendar day and at
    whatever clock time you want it to run. For our first simple example, let''s look
    at the `fstrim.timer` on the Alma machine:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用*实时*定时器来在任何日历日期和任何时刻运行任务。对于我们第一个简单的例子，我们来看看Alma机器上的`fstrim.timer`：
- en: '[PRE4]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Here''s the breakdown:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是详细解释：
- en: '`OnCalendar=weekly`: You''ll use the `OnCalendar` parameter to specify the
    time at which you want the job to run. Setting this job up to run weekly means
    that it will run every Monday morning at midnight. (We''ll see in a bit where
    these parameters are defined.)'
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`OnCalendar=weekly`：你将使用`OnCalendar`参数来指定你希望任务运行的时间。将该任务设置为每周运行意味着它将在每周一的午夜运行。（稍后我们会看到这些参数是在哪里定义的。）'
- en: '`AccuracySec=1h`: This defines the amount of time by which the job is allowed
    to be delayed. A one-hour delay means that this job could run at any time from
    midnight to one o''clock on Monday morning. If you leave this line out, the default
    delay will be one minute. If you want the job to run exactly at midnight on Monday,
    you can change the `1h` to `1us`, which gives the greatest accuracy.'
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`AccuracySec=1h`：这定义了任务允许延迟的时间。一小时的延迟意味着这个任务可能在周一凌晨到一点之间的任何时候运行。如果你省略这一行，默认的延迟时间为一分钟。如果你希望任务准确地在周一午夜运行，可以将`1h`改为`1us`，这将提供最高精度。'
- en: '`Persistent=true`: So, what happens if your machine is shut down at midnight
    on Monday morning? Without this line, this job will just be skipped. With this
    line, the job will run the next time you boot up the machine.'
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Persistent=true`：那么，如果你的机器在周一凌晨关机，会发生什么呢？没有这一行的话，这个任务将被跳过。有了这一行，当你下次启动机器时，任务将会运行。'
- en: 'As you can see, there''s no `Unit=` line in this timer, as there was in the
    previous example. So, by default, this `fstrim.timer` will activate the `fstrim.service`,
    which clears out unused blocks on your storage drives. Here''s what the service
    looks like:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，这个计时器中没有`Unit=`行，正如我们在之前的例子中看到的那样。所以，默认情况下，这个`fstrim.timer`将激活`fstrim.service`，它会清理存储驱动器上未使用的块。以下是服务的样子：
- en: '[PRE5]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Okay, so there's nothing new here. It's just a standard static, `oneshot` type
    of service, as we saw in the previous example.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，这里没有什么新内容。它只是一个标准的静态`oneshot`类型服务，就像我们在之前的例子中看到的那样。
- en: 'The `fstrim.timer` is disabled by default on the Alma machine, as we see here:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 在Alma机器上，默认情况下`fstrim.timer`是禁用的，正如我们所看到的那样：
- en: '[PRE6]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The `fstrim.timer` comes in handy if you''re running either a solid-state drive
    or thinly provisioned storage. If you need to enable the timer, just do it the
    same way that you''d enable a service, as shown here:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你正在使用固态硬盘或精简配置的存储，`fstrim.timer`非常有用。如果需要启用该计时器，只需像启用服务一样进行操作，示例如下：
- en: '[PRE7]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'On the Ubuntu machine, you''ll see that the `fstrim.timer` is enabled by default:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 在Ubuntu机器上，你会看到`fstrim.timer`默认是启用的：
- en: '[PRE8]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Next, let's take a closer look at how to define the `OnCalendar` times.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们来仔细看看如何定义`OnCalendar`的时间。
- en: Understanding calendar events for real-time timers
  id: totrans-87
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 理解实时计时器的日历事件
- en: Okay, here's where things can get a bit sticky. I mean, configuring times for
    `cron` jobs is easy and straightforward. Understanding how to set up times for
    a `systemd` timer takes a bit of getting used to. Your best bet is to open the
    `systemd.time` man page, and scroll down to the **CALENDAR EVENTS** section. The
    explanation there isn't as clear as it could be, but you can pretty much figure
    it out by looking at the examples. Let's see if we can make any sense of it.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，事情可能会变得有点复杂。我的意思是，配置`cron`任务的时间是简单直接的。理解如何为`systemd`计时器设置时间则需要一些时间来适应。最好的办法是打开`systemd.time`的手册页面，滚动到**CALENDAR
    EVENTS**部分。那里的解释可能不够清晰，但你基本可以通过查看示例来理解。让我们看看能否弄清楚其中的含义。
- en: 'In the `fstrim.timer` example that we just looked at, we saw the `OnCalendar=weekly`
    line, which causes the job to run at midnight every Monday morning. In the `systemd.time`
    man page, you''ll see the complete list of predefined event times:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们刚刚查看的`fstrim.timer`例子中，我们看到`OnCalendar=weekly`行，这使得任务每周一凌晨运行。在`systemd.time`的手册页面中，你将看到所有预定义事件时间的完整列表：
- en: '[PRE9]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Most of these are easy to figure out. The only ones that might throw you a bit
    are `quarterly` and `semiannually`. A `quarterly` job will run at midnight on
    the first day of January, April, July, and October, as denoted by the `01,04,07,10`
    part. A `semiannually` job will run at midnight on the first day of January and
    July, as denoted by the `01,07` part.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 其中大部分很容易理解。唯一可能让你有些困惑的是`quarterly`和`semiannually`。`quarterly`任务将在每年1月、4月、7月和10月的第一天午夜运行，如`01,04,07,10`部分所示。`semiannually`任务将在每年1月和7月的第一天午夜运行，如`01,07`部分所示。
- en: 'Scroll down the `systemd.time` page a bit more and you''ll see a whole big
    list of examples of how you can set up your job times. Rather than try to show
    you the whole list, I''ll just show you one example, and then break it down for
    you. Here we go:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 向下滚动`systemd.time`页面，你会看到一大堆关于如何设置任务时间的例子。与其尝试展示整个列表，我只会给你一个例子，然后为你逐一解释。来看看：
- en: '[PRE10]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'The left-hand side shows you the date and time as a human would normally write
    it. The right-hand side shows you the value that you''d use as an `OnCalendar=`
    parameter. I chose this example because it uses all of the fields. (And yes, I
    know that 2003 is in the past, but this is what''s in the man page.) To create
    a job that would have run at midnight on March 3, 2003, the `OnCalendar=` line
    would look like this:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 左侧显示的是日期和时间，像人类通常写的那样。右侧显示的是你将用作`OnCalendar=`参数的值。我选择这个例子是因为它用了所有的字段。（是的，我知道2003年已经过去，但这就是man页面里的内容。）要创建一个任务，使其在2003年3月3日的午夜运行，`OnCalendar=`行应如下所示：
- en: '[PRE11]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Since that''s several years in the past, let''s fix this so that it will run
    in the future:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这是几年前的设置，让我们修正它，让任务在未来运行：
- en: '[PRE12]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Ah, yes. *In the year 2525, if man is still alive, and if woman can still survive.
    . .* (Who besides me is old enough to remember that silly song?)
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 啊，是的。*在2525年，如果人类仍然活着，如果女性还能存活……*（除了我，谁还记得那首傻歌？）
- en: 'Seriously though, this isn''t near as hard as it first seems to be. We have
    `Year-Month-Date`, followed by `Hour:Minute:Second` in 24-hour format. So yeah,
    it''s actually quite easy-peasy. Now, let''s say that we want this to run every
    day at 6:15 in the evening. We''ll just replace the `Year-Month-Date` fields with
    the standard wildcard symbol ( `*` ), and change the time:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 说真的，这并不像最初看起来那么难。我们有`Year-Month-Date`，然后是24小时格式的`Hour:Minute:Second`。所以，实际上，这非常简单。现在，假设我们希望任务每天晚上6:15运行。我们只需用标准的通配符符号（
    `*` ）替换`Year-Month-Date`字段，并更改时间：
- en: '[PRE13]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'That''s good, but I''ve changed my mind about running it every single day.
    I think I''ll change it so that it will only run on the fifth day of every month,
    like so:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 这不错，但我改变了主意，不想每天都运行。我想我会改成每月的第五天运行，就像这样：
- en: '[PRE14]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Nah, that''s not often enough. Let''s make it run on the fifth, tenth, and
    fifteenth days of every month:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 不，还是不够频繁。让我们让任务在每月的第五、第十和第十五天运行：
- en: '[PRE15]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'The `Day-of-Week` field is optional. Let''s make the job run on the fifth,
    tenth, and fifteenth days of the month, but only if they happen to fall on either
    a Monday or a Wednesday:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: '`Day-of-Week`字段是可选的。让我们让任务在每月的第五、第十和第十五天运行，但只有在这些日子恰好是周一或周三时才运行：'
- en: '[PRE16]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Better yet, let''s just make it run every Monday and Wednesday:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 更好的是，我们就让它每周一和周三运行：
- en: '[PRE17]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'You can use the tilde ( `~` ) symbol to count a specified number of days back
    from the end of a month. To have the job run on the third from last day of every
    February, just do this:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用波浪号（ `~` ）符号来表示从每个月的最后一天起回溯指定的天数。如果你希望任务在每年二月的倒数第三天运行，只需要这样做：
- en: '[PRE18]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Now, let''s make the job run on the last Monday of every May:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们让任务在每年五月的最后一个周一运行：
- en: '[PRE19]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Finally, let''s get really crazy and make the job run every ten minutes:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，让我们更疯狂一些，让任务每十分钟运行一次：
- en: '[PRE20]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Okay, that should be enough to give you a clue. If you need to see any more
    examples, just look at the `systemd.time` man page.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，这些应该足够给你一个线索。如果你需要查看更多例子，只需查看`systemd.time`的man页面。
- en: Creating timers
  id: totrans-116
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建定时器
- en: Creating your own timer is a two-stage process. You'll first create the service
    that you want to run, and then you'll create and enable the timer.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 创建你自己的定时器是一个两阶段的过程。你首先创建你想要运行的服务，然后创建并启用定时器。
- en: Creating a system-level timer
  id: totrans-118
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建系统级定时器
- en: Let's say that you're a security-conscious soul who suspects that someone might
    try to plant some rootkits on your machines. You want to set up Rootkit Hunter
    so that it will run every day after work hours.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你是一个注重安全的人，怀疑有人可能会试图在你的机器上植入rootkit。你想设置Rootkit Hunter，每天在工作时间结束后运行一次。
- en: Note
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 注：
- en: I wanted to do this with both Ubuntu and Alma Linux. Unfortunately, there's
    a bug in the Rootkit Hunter package for Ubuntu that prevents Rootkit Hunter from
    updating its signature database. That's not too surprising, because Ubuntu quality
    control has always been somewhat less than perfect. So, for this example, we'll
    just go with Alma.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 我想用Ubuntu和Alma Linux都试试。不幸的是，Ubuntu的Rootkit Hunter包存在一个bug，导致Rootkit Hunter无法更新其签名数据库。这也不太令人惊讶，因为Ubuntu的质量控制一直不算完美。所以，在这个例子中，我们就选择Alma来演示。
- en: 'Because there''s a bug in the Rootkit Hunter package in Ubuntu, we''ll just
    do this on the Alma machine. Rootkit Hunter isn''t in the normal Alma repositories,
    so you''ll first need to install the EPEL repository, like so:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 由于Ubuntu中的Rootkit Hunter包存在bug，我们将在Alma机器上执行此操作。Rootkit Hunter不在常规的Alma软件源中，因此你首先需要安装EPEL软件源，方法如下：
- en: '[PRE21]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Create the `rkhunter.service` file by doing:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 通过执行以下命令创建`rkhunter.service`文件：
- en: '[PRE22]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Make the file look like this:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 使文件看起来像这样：
- en: '[PRE23]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Before we do the actual scan, we want to create the `rkhunter.dat` file to
    store file properties and update the database of rootkit signatures. We''ll do
    that with the two `ExecStartPre=` lines. In the `ExecStart=` line, we have three
    options, as follows:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 在实际扫描之前，我们需要创建`rkhunter.dat`文件，用于存储文件属性并更新rootkit签名数据库。我们将通过两个`ExecStartPre=`行来完成。`ExecStart=`行中有三个选项，如下所示：
- en: '`-c`: This is the *check* option, which does the actual scan.'
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-c`：这是*检查*选项，执行实际的扫描。'
- en: '`--cronjob`: Normally, Rootkit Hunter will pause several times during a scan
    and wait for user input. This option causes Rootkit Hunter to complete its run
    without pausing.'
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`--cronjob`：通常，Rootkit Hunter在扫描过程中会暂停几次并等待用户输入。此选项会让Rootkit Hunter在不暂停的情况下完成扫描。'
- en: '`--rwo`: This option causes Rootkit Hunter to only report any problems that
    it finds.'
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`--rwo`：这个选项让Rootkit Hunter只报告它找到的任何问题。'
- en: 'Before creating the timer, it''s a good idea to start the service manually
    to verify that it works. We''ll do that with:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建定时器之前，最好先手动启动服务，以验证它是否正常工作。我们将使用以下命令进行验证：
- en: '[PRE24]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'When it''s finished running, look at the `/var/log/rkhunter/rkhunter.log` file
    to verify that there aren''t any problems. If everything looks good, we''re ready
    to create the timer. Do that with:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 运行完成后，查看`/var/log/rkhunter/rkhunter.log`文件，验证是否存在任何问题。如果一切正常，我们就准备创建定时器。可以使用以下命令：
- en: '[PRE25]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'For demonstration purposes, set the `OnCalendar=` time to just a few minutes
    into the future. That way, you won''t have to wait long for it to run. When you''re
    done, the file should look something like this:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 为了演示，设置`OnCalendar=`时间为未来几分钟。这样，你就不需要等待太久它就能运行。完成后，文件应如下所示：
- en: '[PRE26]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Do a `daemon-reload`, and then enable the timer:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 执行`daemon-reload`，然后启用定时器：
- en: '[PRE27]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Now it's just a matter of waiting for the timer to run to see whether it works.
    After it has finished, you can view the results in the `/var/log/rkhunter/rkhunter.log`
    file.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 现在只需要等待定时器运行，看看它是否能正常工作。运行完成后，你可以在`/var/log/rkhunter/rkhunter.log`文件中查看结果。
- en: Next, let's allow a normal, non-privileged user to create a timer.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们允许一个普通的非特权用户创建一个定时器。
- en: Creating a user-level timer
  id: totrans-142
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建一个用户级别的定时器
- en: You can try this demonstration on either the Ubuntu or the Alma virtual machine.
    I haven't shown much love to the Ubuntu machine for a while, so I'll go with that
    one.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在Ubuntu或Alma虚拟机上尝试此演示。我已经有一段时间没有使用Ubuntu机器了，所以我选择使用它。
- en: Now, let's say that you're just a normal user who wants to back up your home
    directory to one of those handy-dandy portable drives. You'll plug it into the
    USB port of your computer, and the system will automatically mount it under the
    `/media/backup/` directory.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你是一个普通用户，想要将你的主目录备份到便捷的移动硬盘上。你将把它插入电脑的USB端口，系统会自动将其挂载到`/media/backup/`目录下。
- en: Note
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: 'If you don''t have a portable backup drive, you can simulate this by manually
    creating a backup directory, and setting the permissions so that normal users
    can write to it, like this:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你没有便携式备份硬盘，可以通过手动创建备份目录并设置权限，使普通用户能够写入目录，像这样：
- en: '**sudo mkdir /media/backup**'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: '**sudo mkdir /media/backup**'
- en: '**sudo chmod 777 /media/backup**'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: '**sudo chmod 777 /media/backup**'
- en: Now it's just a matter of creating the service and the timer. Any non-privileged
    user can do that by using the `--user` option switch.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，只需创建服务和定时器。任何非特权用户都可以通过使用`--user`选项来完成这一操作。
- en: 'As before, we''ll start by creating the service, like this:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 和之前一样，我们从创建服务开始，像这样：
- en: '[PRE28]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'This will automatically create the necessary files and directories under the
    `/home/donnie/.config/` directory. I''ll use `rsync` to do the backup, so my `backup.service`
    file will look like this:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 这将自动在`/home/donnie/.config/`目录下创建必要的文件和目录。我将使用`rsync`来做备份，所以我的`backup.service`文件将如下所示：
- en: '[PRE29]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'I want to make sure that this works, so I''ll do a `daemon-reload` and then
    try running the service manually before I create the timer:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 我想确保这个可以正常工作，所以我会先执行`daemon-reload`，然后手动运行服务，确保没问题后再创建定时器：
- en: '[PRE30]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'If it runs successfully, I should see a `donnie/` directory under `/media/backup/`:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 如果运行成功，我应该会在`/media/backup/`目录下看到`donnie/`目录：
- en: '[PRE31]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'So far, so good. Let''s see what''s in that `donnie/` directory:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，一切顺利。让我们看看`donnie/`目录里有什么：
- en: '[PRE32]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Nice. The backup service works, and I have achieved coolness. Now, it''s time
    to create the timer:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 很好。备份服务已启动，我也达到了预期效果。现在，是时候创建定时器了：
- en: '[PRE33]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'I''ll just have it run daily at midnight, so I''ll make it look like this:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 我只需要让它每天午夜运行，所以我会这样设置：
- en: '[PRE34]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Of course, if you don't want to wait around until midnight to see whether this
    works, just set the `OnCalendar=` time to whatever you want.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，如果你不想等到午夜再检查是否有效，只需将`OnCalendar=`时间设置为你想要的任何时间。
- en: Note that when we use the `--user` option, we need to have the `default.target`
    in the `WantedBy=` line.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，当我们使用`--user`选项时，需要在`WantedBy=`行中有`default.target`。
- en: 'Next, I''ll do a `daemon-reload` and enable the timer:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我将执行`daemon-reload`并启用定时器：
- en: '[PRE35]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'I can also use the `--user` switch to view information about this timer:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 我还可以使用`--user`选项查看有关该定时器的信息：
- en: '[PRE36]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'As things stand now, this timer will only run while I''m actually logged in
    to the system. To ensure that it runs even when I''m not logged in, I''ll enable
    the `linger` function for myself:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 目前来看，这个定时器只会在我登录到系统时运行。为了确保即使我未登录时它也能运行，我将为自己启用`linger`功能：
- en: '[PRE37]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Okay, I think that does it for this chapter. Let's go ahead and wrap it up.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，我想这一章就到此为止了。我们来总结一下。
- en: Summary
  id: totrans-173
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we've looked at `systemd` timers, and compared them to the
    legacy `cron` system. We looked at different timer options, and at different ways
    to specify when a timer should run. Finally, we looked at how to create timers
    for both system-level and user-level jobs.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一章中，我们探讨了`systemd`定时器，并将其与传统的`cron`系统进行了比较。我们查看了不同的定时器选项以及指定定时器运行时间的不同方式。最后，我们还了解了如何为系统级和用户级任务创建定时器。
- en: In the next chapter, we'll take a brief look at the bootup process under `systemd`.
    I'll see you there.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将简要了解`systemd`下的启动过程。我在那儿见。
- en: Questions
  id: totrans-176
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: How do `cron` and `systemd` timers differ?
  id: totrans-177
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`cron`和`systemd`定时器有什么不同？'
- en: a. It's much easier to set up `systemd` timers.
  id: totrans-178
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: a. 设置`systemd`定时器要简单得多。
- en: b. Non-privileged users can set up their own `cron` jobs, but they can't set
    up their own timers.
  id: totrans-179
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: b. 非特权用户可以设置自己的`cron`任务，但无法设置自己的定时器。
- en: c. A `cron` job can run a command or script directly, but a `systemd` timer
    can only run an associated service.
  id: totrans-180
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: c. `cron`任务可以直接运行命令或脚本，但`systemd`定时器只能运行关联的服务。
- en: d. Non-privileged users can set up their own `systemd` timers, but they can't
    set up their own `cron` jobs.
  id: totrans-181
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: d. 非特权用户可以设置自己的`systemd`定时器，但无法设置自己的`cron`任务。
- en: What are the two ways of specifying when a job will run? (Choose two.)
  id: totrans-182
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 什么时候作业会运行的两种指定方式是什么？（选择两个）
- en: a. monotonic
  id: totrans-183
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: a. 单调时间
- en: b. wallclock
  id: totrans-184
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: b. 实时钟
- en: c. calendartime
  id: totrans-185
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: c. 日历时间
- en: d. realtime
  id: totrans-186
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: d. 实时
- en: Which of the following man pages would tell you how to format times for the
    `OnCalendar=` parameter?
  id: totrans-187
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下哪个man页面会告诉你如何格式化`OnCalendar=`参数的时间？
- en: a. `systemd.time`
  id: totrans-188
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: a. `systemd.time`
- en: b. `systemd.timer`
  id: totrans-189
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: b. `systemd.timer`
- en: c. `systemd.unit`
  id: totrans-190
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: c. `systemd.unit`
- en: d. `systemd.exec`
  id: totrans-191
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: d. `systemd.exec`
- en: Which of the following time configurations equates to the monthly setting?
  id: totrans-192
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下哪种时间配置等同于每月设置？
- en: a. `*-01-01 00:00:00`
  id: totrans-193
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: a. `*-01-01 00:00:00`
- en: b. `*-*-* 00:00:00`
  id: totrans-194
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: b. `*-*-* 00:00:00`
- en: c. `*-*-01 00:00:00`
  id: totrans-195
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: c. `*-*-01 00:00:00`
- en: d. `*-01-01 00:00:00`
  id: totrans-196
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: d. `*-01-01 00:00:00`
- en: Answers
  id: totrans-197
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 答案
- en: c
  id: totrans-198
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: c
- en: a, d
  id: totrans-199
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: a, d
- en: a
  id: totrans-200
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: a
- en: c
  id: totrans-201
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: c
- en: Further reading
  id: totrans-202
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: 'Comparing `systemd` timers with `cron`:'
  id: totrans-203
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 比较`systemd`定时器与`cron`：
- en: '[https://trstringer.com/systemd-timer-vs-cronjob/](https://trstringer.com/systemd-timer-vs-cronjob/)'
  id: totrans-204
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '[https://trstringer.com/systemd-timer-vs-cronjob/](https://trstringer.com/systemd-timer-vs-cronjob/)'
- en: '[https://medium.com/horrible-hacks/using-systemd-as-a-better-cron-a4023eea996d](https://medium.com/horrible-hacks/using-systemd-as-a-better-cron-a4023eea996d)'
  id: totrans-205
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '[https://medium.com/horrible-hacks/using-systemd-as-a-better-cron-a4023eea996d](https://medium.com/horrible-hacks/using-systemd-as-a-better-cron-a4023eea996d)'
- en: 'Using `systemd` timers with Docker:'
  id: totrans-206
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`systemd`定时器与Docker结合：
- en: '[https://matthiasadler.info/blog/running-scheduled-tasks-in-docker-containers-with-systemd/](https://matthiasadler.info/blog/running-scheduled-tasks-in-docker-containers-with-systemd/'
  id: totrans-207
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '[https://matthiasadler.info/blog/running-scheduled-tasks-in-docker-containers-with-systemd/](https://matthiasadler.info/blog/running-scheduled-tasks-in-docker-containers-with-systemd/)'
- en: )
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: )
- en: 'Using `systemd` timers as a `cron` replacement:'
  id: totrans-209
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`systemd`定时器作为`cron`替代：
- en: '[https://www.maketecheasier.com/use-systemd-timers-as-cron-replacement/](https://www.maketecheasier.com/use-systemd-timers-as-cron-replacement/'
  id: totrans-210
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '[https://www.maketecheasier.com/use-systemd-timers-as-cron-replacement/](https://www.maketecheasier.com/use-systemd-timers-as-cron-replacement/)'
- en: )
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: )
