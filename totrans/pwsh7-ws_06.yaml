- en: '6'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: PowerShell and Files – Reading, Writing, and Manipulating Data
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So far, our PowerShell journey has been on the screen. Wouldn’t it be neat to
    be able to write the output of our cmdlets to a file somewhere so that we could
    save it for later or send it to other people? That’s what we’re going to do in
    this chapter. First, we’re going to look at formatting output for the screen so
    that we can just focus on the things we’re interested in or present output in
    a more useful manner. Next, we’re going to look at writing the output to a text
    file using `Out-File`. I do this multiple times a day and it’s an incredibly useful
    technique, but it is very limited, so we’re also going to look at creating **Comma-Separated
    Value** (**CSV**) files for consumption by another program, such as Microsoft
    Excel, and HTML files so that we can display our output as a web page.
  prefs: []
  type: TYPE_NORMAL
- en: Once we’re comfortable with the output, we’re going to dive into a short section
    that will help us understand how PowerShell interacts with filesystems, before
    looking at how we can use PowerShell to read and manipulate data in common file
    types, such as text and CSV files. Finally, we’ll wrap the chapter up with a short
    walkthrough of a fun project and leave you with a challenge.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we are going to cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Understanding formatting
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Writing to a text file
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using `ConvertTo-` and `Export-` cmdlets
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Handling files
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Working with file
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let’s have some fun!
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding formatting
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let’s think about our old friend, `Get-Process`. We know that when we run it,
    it displays a list of the running processes on our machine. For each process,
    it displays some of the properties. We know from running `Get-Process | Get-Member`
    that there are many more that it doesn’t display unless we ask for them explicitly.
    This is the case for pretty much every PowerShell cmdlet; the output we see is
    rarely the complete output of every property the objects in the pipeline possess.
    How does that happen? Welcome to the **default format**.
  prefs: []
  type: TYPE_NORMAL
- en: PowerShell decides on the format for displaying output based on the `TypeName`
    of the object in the pipeline. If the `TypeName` has an associated `PSCustomObject`,
    then the shell will determine whether there is a **default property set** and,
    if so, display that. If there are fewer than five default properties, they will
    be displayed in a table; if there are more than five, then they will be displayed
    as a list. Finally, if the object has neither a default formatting view nor a
    default property set, then all the properties will be displayed.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can see part of the default formatting view for `Get-Process` in the following
    screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.1 – Part of the default formatting view for System.Diagnostics.Process
    objects](img/B17600_06_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6.1 – Part of the default formatting view for System.Diagnostics.Process
    objects
  prefs: []
  type: TYPE_NORMAL
- en: 'It is possible to redefine the properties that are displayed by default, but
    I’ve never found it necessary to do so, so it’s beyond the scope of this book.
    If it’s something you think you might like to do, then have a look at the help
    files for the `FormatData` cmdlets by running the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: We don’t need to do anything as drastic as updating `FormatData` to change the
    way our output is formatted, though. In the rest of this section, we’re going
    to look at three common ways of changing the way our data is displayed using `Format`
    cmdlets. First, let’s look at my favorite, `Format-List`.
  prefs: []
  type: TYPE_NORMAL
- en: Format-List
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Most cmdlets we use will display output as a table with the object name and
    a few well-chosen properties. `Format-List` allows us to display the object properties
    and values as a list. Note that `Format-List` displays the properties in the default
    property set, not the ones in the default format view if a view exists. Have a
    look at the following screenshot to see what we mean:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.2 – The default format and the list format](img/B17600_06_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6.2 – The default format and the list format
  prefs: []
  type: TYPE_NORMAL
- en: 'We can see that running `Get-Process` on its own produces some very different
    information from what we get when we pipe it into `Format-List`. In fact, `Format-List`
    doesn’t look very good at all, there – so why do I use it so much? Try getting
    the information for a single process and using `Format-List` with the wildcard
    operator, (`*`), as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'There! Lots of information. We can also just select certain properties to display
    by passing a comma-separated list to the `-Property` parameter of `Format-List`,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: '`Format-List` has the `fl` alias, so an awful lot of the stuff I ask people
    for when I’m troubleshooting their servers has `|fl *` somewhere near the end.'
  prefs: []
  type: TYPE_NORMAL
- en: Format-Table
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'If we want a subset of data for a number of objects, then the table format
    is convenient. If we want different data to the default format view, then we can
    use `Format-Table`. Try this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: This will get us a subset of properties for each process in a convenient table
    format.
  prefs: []
  type: TYPE_NORMAL
- en: 'Quite often, when we run `Format-Table`, we don’t actually see all the data
    we’ve asked for; instead, the output is truncated with an ellipsis (`…`). Happily,
    there are two other parameters of `Format-Table` that can help us out. Firstly,
    we can use the `-AutoSize` parameter to remove white space between columns and
    set each column to the width of its largest entry. However, if that still doesn’t
    get everything, then we can use the `-Wrap` parameter to display each entry across
    multiple lines. Try this to see the difference:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: That’s quite handy. Let’s look at our last format cmdlet, `Format-Wide`.
  prefs: []
  type: TYPE_NORMAL
- en: Format-Wide
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `Format-Wide` cmdlet allows us to show data in a wide list format, which
    makes it easier to read on a screen. It resembles the standard Linux list output
    (`ls`), but without the coloring rules that make the list command so useful. It
    will only display a single property of each object and defaults to a `Name` property
    unless we specify something else using the `-Property` parameter. It has two parameters
    that allow us to control the display – `-Column`, which specifies a set number
    of columns, and `-AutoSize`, which tries to fit in as many as possible without
    truncating the data. Try this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Personally, I don’t find I use the `Format-Wide` cmdlet anything as much as
    I should. It’s useful for concisely seeing a list of objects and saves scrolling
    up and down looking for an item.
  prefs: []
  type: TYPE_NORMAL
- en: Formatting gotchas
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In [*Chapter 3*](B17600_03.xhtml#_idTextAnchor049), *The PowerShell Pipeline
    – How to String Cmdlets Together*, we discussed a very important rule: `Format-`
    cmdlets produce readable text on the screen, that’s because the formatting data
    objects they produce are processed by the shell. We really can’t use the output
    from a `Format-` cmdlet anywhere else in the pipeline, except to feed it into
    one of the specialized `Out-` cmdlets, such as the `Out-Default | Out-Host` pair
    that is implicit on the end of every PowerShell pipeline.'
  prefs: []
  type: TYPE_NORMAL
- en: There is, however, a very useful `Out-` cmdlet that we haven’t looked at yet,
    and we’ll cover it in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Writing a text file
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We started this chapter by promising to cover writing PowerShell output to a
    file. Let’s do that. We have learned that we can feed the output of the `Format-`
    cmdlets into an `Out-` cmdlet and there is a specific cmdlet for writing data
    to a file; `Out-File`.
  prefs: []
  type: TYPE_NORMAL
- en: '`Out-File` will write the output from any cmdlet to a text file. We can format
    the output first using a `Format-` cmdlet if we want to, but we don’t have to;
    if we don’t, we get the default output of the cmdlet. Let’s try it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: As we can see, the content of the text files looks exactly the same as the screen
    outputs; all we’ve done is redirect the output to a file instead of the screen.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are a few parameters we can use with `Out-File`:'
  prefs: []
  type: TYPE_NORMAL
- en: '`-FilePath` specifies the path and name of the file we want to create. By default,
    `Out-File` will overwrite any pre-existing file with the same name, unless that
    file is read-only.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`-Append` will add the output to an existing file, again, if it is not set
    to read-only.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`-NoClobber` will check whether a file already exists and prevent it from being
    overwritten. We’ll see an error message saying that the file already exists.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`-Force` will allow us to ignore the read-only attribute on existing files.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`-Encoding` can change the default encoding of the file from ASCII to a range
    of other formats; a popular one is UTF-8.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Out-File` also has a couple of aliases that we might see quite often. The
    greater-than symbol (`>`) is an alias for `Out-File -FilePath`, and we just need
    to type a path and file name after it. A double greater-than symbol (`>>`) is
    an alias for `Out-File -Append -FilePath` and again, just needs a path and filename.
    We can’t use any other parameters with these aliases. For example, `Get-Process
    > C:\temp\processes.txt` will take the output of `Get-Process` and save it to
    `C:\temp.txt` – if we then run `Get-Date >> C:\temp\processes.txt`, it will append
    the output of `Get-Date` to the same file.'
  prefs: []
  type: TYPE_NORMAL
- en: '`Out-File` only produces a file. It doesn’t put any object in the pipeline,
    so must be the last cmdlet in a pipeline.'
  prefs: []
  type: TYPE_NORMAL
- en: The first important thing to remember is that what gets written to the file
    is *exactly* what we would see on the screen.
  prefs: []
  type: TYPE_NORMAL
- en: 'The other important thing to remember is that a file we create with `Out-File`
    is a text file. We can call it a CSV file if we want, but it won’t be. The data
    won’t be converted; no commas will be inserted. Let’s demonstrate:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'As expected, the contents of the CSV file created in the last line look horrible.
    Here’s what it looks like if I try to open it in MS Excel, my usual app for manipulating
    CSV files:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.3 – This is not a CSV file](img/B17600_06_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6.3 – This is not a CSV file
  prefs: []
  type: TYPE_NORMAL
- en: We’ll have a look at how we can produce different types of files in the next
    section, using the `ConvertTo-` and `Export-` cmdlets.
  prefs: []
  type: TYPE_NORMAL
- en: Using ConvertTo- and Export- cmdlets
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If we want our PowerShell objects in a format other than text, we’re going to
    need to process them somehow. There are two groups of cmdlets that let us do that.
    The `ConvertTo-` cmdlets convert the objects in our pipeline into data of a particular
    type, such as CSV or HTML data. The `Export-` cmdlets combine the equivalent `ConvertTo-`
    cmdlet with an `Out-File` function to produce a file of the relevant type. In
    this chapter, we’re going to cover three common file types; CSV, XML, and HTML.
  prefs: []
  type: TYPE_NORMAL
- en: CSV
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let’s look at the `ConvertTo-CSV` cmdlet first. With this cmdlet, we can take
    the output of another cmdlet and turn it into a CSV datastream. Try this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'You’ll see something like the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.4 – Nasty](img/B17600_06_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6.4 – Nasty
  prefs: []
  type: TYPE_NORMAL
- en: 'Ugh. Horrible, right? However, we can then pipe that into `Out-File` as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: It will produce a real CSV file of all the processes starting with `w` that
    we can open in an application that reads CSV, such as MS Excel or Google Sheets.
    Not only that but it also ignores the default format information and just dumps
    everything.
  prefs: []
  type: TYPE_NORMAL
- en: 'Even better, there is a cmdlet that will do the whole thing in one operation
    – `Export-Csv`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Let’s take a closer look.
  prefs: []
  type: TYPE_NORMAL
- en: ConvertTo-Csv
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'This cmdlet has a few parameters we will be interested in:'
  prefs: []
  type: TYPE_NORMAL
- en: '`-NoTypeInformation`: A lot of the scripts we might see on the internet will
    include this parameter, but we don’t need it anymore. Prior to PowerShell 6.0,
    by default, the `ConvertTo-Csv` cmdlet included an introductory line that detailed
    the object type that had been converted, so any scripts that were written for
    earlier versions of PowerShell almost always included this parameter to remove
    that line. Since PowerShell 6.0, the default is to *not* include type information.
    Including the parameter won’t cause a problem, but we don’t need it in PowerShell
    7.x.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`-IncludeTypeInformation`: Use this if you *do* want to know the type of the
    object in the first line of the CSV stream.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`-Delimiter`: We usually want our CSV file to use a comma as the field delimiter
    character, but sometimes we might need to produce a `` `t ``, or perhaps use a
    colon or semicolon. We can use this parameter to specify a different delimiter
    character – for example, in the following:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`-UseQuotes`: This parameter controls how the cmdlet applies double-quote characters.
    By default, every value is double-quoted, turning it into a string, but sometimes
    we might want to keep the values as integers or floating point numbers. We can
    use this parameter to control the quoting behavior.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`-QuoteFields`: If we need even finer control over quoting behavior, we can
    specify the fields in which we want the values to be double-quoted. The first
    line of the CSV file is the field names and it may take a bit of experimentation
    to get this right.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Once we’ve converted our objects into a CSV datastream, we can either pipe it
    to `Out-File` or consume it in some other way; for instance, we might want to
    create a number of CSV objects and then aggregate and manipulate them before outputting
    a single file.
  prefs: []
  type: TYPE_NORMAL
- en: Export-Csv
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `Export-Csv` cmdlet combines `ConvertTo-Csv` with `Out-File` in a single
    cmdlet. It has the same interesting parameters that we’ve already discussed for
    those cmdlets. Here are the matching `Out-File` parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '`-Path (instead` `of -FilePath)`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`-``Force`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`-``NoClobber`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`-``Encoding`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`-``Append`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Here are the parameters from `ConvertTo-Csv`:'
  prefs: []
  type: TYPE_NORMAL
- en: '`-``Delimiter`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`-``NoTypeInformation`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`-``IncludeTypeInformation`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`-``QuoteFields`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`-``UseQuotes`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The parameters for `Export-Csv` work the same as the equivalent parameters in
    `ConvertTo-Csv` and `Out-File`. There are no aliases for `Export-Csv`.
  prefs: []
  type: TYPE_NORMAL
- en: XML
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`ConvertTo-Xml` and `Export-Clixml`.'
  prefs: []
  type: TYPE_NORMAL
- en: ConvertTo-Xml
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'This cmdlet only has a handful of parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '`-As`: This parameter allows us to specify the output format; whether it’s
    a single string, an array of strings, or an `XmlDocument` object.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`-Depth`: We can use this to limit the number of levels and sublevels the document
    can contain. By default, this isn’t specified.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`-NoTypeInformation`: This stops the object type information from being written.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Export-Clixml
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '`Export-Clixml` cmdlet is pretty simple. It has one of the `ConvertTo-Xml`
    parameters, `-Depth`, and then the following `Out-File` parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '`-Path (instead` `of -FilePath)`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`-``Force`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`-``NoClobber`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`-``Encoding`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let’s create an XML file we can use later:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Try opening that in an editor such as notepad or VS Code. You should see something
    like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.5 – A date represented in XML](img/B17600_06_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6.5 – A date represented in XML
  prefs: []
  type: TYPE_NORMAL
- en: The important bit is line 3\. That’s the actual data; the rest is formatting
    information and information about the type of object. Keep this file and we’ll
    use it later in the chapter.
  prefs: []
  type: TYPE_NORMAL
- en: HTML
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'It is really useful to be able to convert our PowerShell output into HTML,
    as we can display it in a web browser. This is a popular technique for writing
    reports in system administration. We can use it to produce dashboards and other
    online reports. There are better techniques for creating data that can be consumed
    by web APIs and we’ll be looking at those in the next chapter. There is only one
    cmdlet for creating HTML code; `ConvertTo-Html`. If we want to write it to a file,
    we’ll need to use `Out-File`. Try this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'If you then open `Date.html` in your web browser, you should see something
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.6 – A date as HTML](img/B17600_06_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6.6 – A date as HTML
  prefs: []
  type: TYPE_NORMAL
- en: That’s not particularly inspiring. Let’s take a closer look at the cmdlet to
    see whether we can make it more interesting
  prefs: []
  type: TYPE_NORMAL
- en: ConvertTo-Html
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `ConvertTo-Html` cmdlet has quite a few interesting parameters that we
    can use to format our output:'
  prefs: []
  type: TYPE_NORMAL
- en: '`-As`: This parameter allows us to format the output as a table or as a list.
    By default, we get a table.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`-Body`: This allows us to add text after the opening `<body>` tag. This is
    the main part of any web page. We’re not going to explain how HTML works here
    – if you would like a refresher on HTML, then [https://www.w3schools.com/](https://www.w3schools.com/)
    is an excellent and free online resource.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`-Head`: This allows us to write text in the `<``head>` section.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`-Title`: This allows us to give the page a title. Unlike `-Body` and `-Head`,
    it only takes a single string.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`-PreContent`: This allows us to write text before the table we create.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`-PostContent`: This allows us to add text after the table.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`-Meta`: This allows us to add metatags to the head.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`-Fragment`: This omits the `<head>` and `<body >` tags and just writes the
    HTML to produce the table. This is handy if we are going to concatenate a bunch
    of fragments into one single web page.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`-CssUri`: This allows us to specify a CSS file to provide additional formatting,
    such as different fonts, background colors, and so on. I encourage you to have
    a look at [http://www.csszengarden.com/](http://www.csszengarden.com/) to see
    some of the amazing things we can do with CSS.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let’s have a play. Open a new file in VS Code, select CSS as the language,
    and type the following exactly as written:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Save it as `style.css` in your working directory, `C:\temp\poshbook`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a new PowerShell file in the same directory and try this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'If you select and run your code, you should see the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.7 – A date as fancy HTML](img/B17600_06_07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6.7 – A date as fancy HTML
  prefs: []
  type: TYPE_NORMAL
- en: 'There is a great article on how to write HTML documents in PowerShell here:
    [https://leanpub.com/creatinghtmlreportsinwindowspowershell/read](https://leanpub.com/creatinghtmlreportsinwindowspowershell/read).'
  prefs: []
  type: TYPE_NORMAL
- en: That’s a good start on how to create files. Next, let’s briefly divert to `PSProviders`,
    `PSDrives`, and the `New-Item` cmdlet.
  prefs: []
  type: TYPE_NORMAL
- en: Handling files
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Before we can work with files, we need to be able to find them, and understand
    how PowerShell works with hierarchical data structures such as filesystems.
  prefs: []
  type: TYPE_NORMAL
- en: A brief note about PSProviders and PSDrives
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'PowerShell connects to data structures through software called **providers**.
    These allow PowerShell to present a data structure as a filesystem (including
    the filesystem). On Windows, this allows us to search for and manipulate objects
    in the Registry and the Certificate Store as if they were files. Arguably, it
    is less useful on Linux. Let’s have a look. Run this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'You should see a list of providers and associated drives. We can connect to
    the associated drive with the `Set-Location` cmdlet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Note we have to use the name of the drive, not the name of the provider, and
    we need to follow it with a colon.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once in the data structure, we can use `Get-ChildItem` to search for objects,
    as in the following screenshot, which lists out the environment variables as if
    they were filesystem objects:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.8 – The environment provider](img/B17600_06_08.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6.8 – The environment provider
  prefs: []
  type: TYPE_NORMAL
- en: Providers are dynamic; that is, they don’t need to know what is in the store
    before connecting to it and so they are popular as a way of providing access to
    data structures. While there are only a few included in PowerShell by default,
    you will find that some modules will add new providers, especially in Windows.
    For instance, if we install the `ActiveDirectory` module, then we will have access
    to an `AD:` drive containing the Active Directory data.
  prefs: []
  type: TYPE_NORMAL
- en: 'Note that just installing the provider is not enough. We also need to have
    a drive object before we can browse it. The drive is the thing we work with; the
    provider is the software that lets us access it. Most modules will create the
    required drive as well as install the provider. We can create our own drives quite
    easily. In my home directory on my Ubuntu machine, I have a directory called `MyFiles`.
    I can make this a drive by running the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, I can browse the `MyFiles:` drive, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.9 – Creating a new drive](img/B17600_06_09.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6.9 – Creating a new drive
  prefs: []
  type: TYPE_NORMAL
- en: Item- cmdlets
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We use the `-Item` and `-Childitem` cmdlets to move around the filesystem and
    find items. We’re not going to cover them in detail here, as they are self-explanatory.
    Read the associated help files to understand their simple syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Get-ChildItem` lists the items found in a location:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Move-Item lets us move an item to a different location:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Remove-Item lets us delete an item:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Get-Item has returned the properties of the C:\temp\poshbook folder, whereas
    Get-ChildItem has returned the folder and its contents.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE23]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE24]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`Set-Item`: Again, this is not hugely useful in the filesystem. However, if
    we wanted to change the value of an environment variable or an alias, then we
    would use this cmdlet.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`New-Item`: We can use this to create files and folders, as well as create
    new aliases and variables:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Invoke-Item -Path C:\temp\poshbook\FancyDate.html
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: There are also two cmdlets for moving around in and between drives; `Get-Location`
    and `Set-Location`. Many of these cmdlets have aliases associated with them that
    echo the equivalent bash and Windows commands – for instance, `Get-ChildItem`
    can be called by using `ls` or `dir`. Note, however, that the parameters are still
    those for PowerShell, not for the bash or Windows command. For example, `Dir /p`
    will not produce a paginated directory listing – it will produce an error.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we know how to find our files and move them around, let’s look at what
    is inside them.
  prefs: []
  type: TYPE_NORMAL
- en: Working with files
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Using PowerShell to read the contents of files and manipulate that data is a
    common task. We’re going to look at three cmdlets in this section. First, let’s
    explore the generic `Get-Content` cmdlet.
  prefs: []
  type: TYPE_NORMAL
- en: Get-Content
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `Get-Content` cmdlet can get any type of data in a file and store it as
    an array of strings or bytes (as a bytestream). By default, each line in the file
    will be interpreted as a single string. We will only get meaningful content if
    the file can be interpreted as an array of strings; otherwise, we must fetch it
    as a bytestream. This is useful if we are getting the contents of an executable
    file, for example. It’s got a few parameters. Here are the more interesting ones:'
  prefs: []
  type: TYPE_NORMAL
- en: '`-Path` specifies the item we want. This accepts an array of string values
    so that we can concatenate multiple files into a single array.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`-TotalCount` is the total number of lines to read from the file. The default
    is `-1`, which will read to the last line, but we can check just the first few
    lines of a file to make sure that it is as we expect it to be without loading
    the whole thing.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`-ReadCount` is the number of lines that can be sent through the pipeline at
    a time.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`-AsByteStream` allows us to get the content as bytes rather than as strings.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`-Credential` allows us to supply alternative credentials to open the file.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`-Delimiter` allows us to specify the character that is used to separate strings.
    By default, it is the newline character (`` `n ``), but we can use anything we
    like.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`-Encoding` can be used to specify that the contents are encoded in a different
    format to the default; **UTF-8 with no Byte Order** **Mark** (**utf8NoBOM**).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`-Raw` will return the entire contents as a single string.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`-Tail` is like `-TotalCount`, but works backward and gets lines from the end.
    We can’t use it with `-TotalCount`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Get-Content` is similar in function to the `cat` command in Linux and, unsurprisingly,
    `cat` is an alias for it.'
  prefs: []
  type: TYPE_NORMAL
- en: '`Get-content` is one of the most common ways of bringing data into PowerShell
    so that we can work with it, but it’s not very flexible. For instance, if we try
    to get a CSV file, then it will interpret the file as text, rather than a specially
    formatted file. Let’s have a look at how we can import information in a structured
    way.'
  prefs: []
  type: TYPE_NORMAL
- en: Import- cmdlets
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Like the `Export-` cmdlets, the `Import-` cmdlets perform two operations at
    once. They combine `Get-Content` with a specialist parser that will interpret
    the information and format it correctly for the original file type, allowing us
    to manipulate something that looks like the original objects. Let’s look at `Import-Csv`
    first.
  prefs: []
  type: TYPE_NORMAL
- en: Import-Csv
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `Import-Csv` cmdlet only has a few parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '`-Delimiter`: Just in case the file is using something other than a comma to
    separate values'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`-Path`: To identify the file to be imported'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`-Header`: To specify manual column name information if your CSV file doesn’t
    have it'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`-Encoding`: If your file has come from a system that didn’t output it as `utf8NoBOM`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The cmdlet expects the file to contain string objects and outputs `PSCustomObjects`
    with note properties that match the column headers in the original file. Let’s
    have a play:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'This will output the name values of each object in the array. The next command
    will show us that we haven’t recreated process objects, we’ve created new `PSCustomObjects`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'The following command will retrieve the second element in the array. Because
    there is no default view or default properties list, all properties will be displayed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'You should see something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.10 – Importing a CSV file](img/B17600_06_10.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6.10 – Importing a CSV file
  prefs: []
  type: TYPE_NORMAL
- en: Importing CSVs into PowerShell is great if you have, for instance, a list of
    users and you need to pipe them through a loop to get their home drive size, or
    you want to create a lookup table.
  prefs: []
  type: TYPE_NORMAL
- en: Import-Clixml
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'If you have an XML file that was generated by PowerShell, then you can use
    the `Import-Clixml` cmdlet to recreate something that looks much more like the
    original objects. There aren’t many parameters to this cmdlet. Here are the most
    interesting ones:'
  prefs: []
  type: TYPE_NORMAL
- en: '`-Path` specifies the file to be imported.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`-Skip` allows us to skip a specified number of objects in the file.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`-First` gets only a specified number of objects from the start of the file.
    Clixml files can be huge, so this is handy if we want to check what’s inside.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`-IncludeTotalCount` tells us how many objects are in the file. Interestingly,
    it has an accuracy property that tells us how reliable the estimate is.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let’s have a play with it. Try this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'We can see that what we get back is a date object. Let’s try another one:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'If we then call `$XmlProcs`, we can see that the output displays exactly as
    we’d expect for the `Get-Process` cmdlet:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.11 – Recreating objects with Import-Clixml](img/B17600_06_11.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6.11 – Recreating objects with Import-Clixml
  prefs: []
  type: TYPE_NORMAL
- en: 'However, they’re not quite the objects we exported. Let’s run the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: We can see that they are `Deserialized.System.Diagnostics.Process` objects.
    This tells us that they have been turned into a data object and then retrieved
    from a file, and they are not live objects.
  prefs: []
  type: TYPE_NORMAL
- en: 'One of the most common uses for this is to store credentials securely. Try
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: We’re asked to enter a username and password.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can pipe the credential variable into an XML file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: That file can now be stored on a disk somewhere. It is encrypted by the `Export-Clixml`
    cmdlet.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can then import it back using `Import-Clixml`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'We get a credential object. You can see in the following screenshot what the
    XML file looks like. The password is the encrypted hex string:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.12 – Storing encrypted credentials](img/B17600_06_12.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6.12 – Storing encrypted credentials
  prefs: []
  type: TYPE_NORMAL
- en: Note that the encryption uses our login credentials for the machine we were
    using when we encrypted the file. No other user can decrypt that easily and we
    can’t then decrypt those credentials on another machine.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can’t use just import any XML file with `Import-Clixml`. If we try it with
    something that hasn’t been correctly formatted for the cmdlet, we’ll get an error,
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.13 – We can’t import just anything](img/B17600_06_13.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6.13 – We can’t import just anything
  prefs: []
  type: TYPE_NORMAL
- en: In this case, the schema of the XML file is incorrect for the `Import-Clixml`
    cmdlet; there are important lines missing, as we can see from the error message.
    Don’t try running this code – you may well not have the DISM file referenced in
    the cmdlet.
  prefs: []
  type: TYPE_NORMAL
- en: That’s about it for this chapter. Before we summarize, though, let’s play around
    and consolidate some learning from this chapter and earlier chapters.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s have some fun – measuring the most frequent words in a text file
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'One of my favorite programming books is *Exercises in Programming Style* by
    Cristina Videira Lopes. It is inspired by the 1947 book by Raymond Queneau, *Exercices
    de Style*, in which the author tells the same story in 99 different styles. Lopes’s
    book contains 41 Python programs that accomplish the same task with different
    programming styles. This book is truly mind-expanding and really changed the way
    I saw writing code; it is as much an art as any other form of creative writing.
    The book itself is not cheap, but all the programs are available on GitHub: [https://github.com/crista/exercises-in-programming-style](https://github.com/crista/exercises-in-programming-style).
    I’d encourage you to have a quick look, even if you don’t know any Python.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The problem each program solves is to determine the frequency of the words
    in a text file and sort them in descending order; this is an example of a **term
    frequency** problem, and it is a fairly common exercise given to computer science
    students. Let’s have a go at it:'
  prefs: []
  type: TYPE_NORMAL
- en: First, create a new folder in VS Code, and then create a new PowerShell file
    in your new folder called `wordcountBasic.ps1`
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The file I’m going to use is an English translation of Franz Kafka’s classic,
    *The Trial*, but any large text file will do. I downloaded it from here: [https://www.gutenberg.org/ebooks/7849.txt.utf-8](https://www.gutenberg.org/ebooks/7849.txt.utf-8)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Go ahead and download it and save it in your new folder as `thetrial.txt`.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Now that we have our data, the next thing to do is to putt the contents of
    the file into a variable. That’s easy. We’ll need to get it as a single huge string,
    rather than an array of strings:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, we can use one of the methods available for string objects to split the
    text into an array of single-word strings:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Notice that there’s a space inside the pair of double quotes.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Let’s see how many words we’ve got:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: I get 79,978 words. This code may take a while to run.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Now… the next bit is tricky. We need to count how many times each word appears
    in the text. This is where the power of the shell really shines. Doing the next
    bit in Python would require a few lines of string manipulation, but PowerShell
    comes with a built-in cmdlet, `Group-Object`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The trouble with that line is it will group the objects alphabetically, which
    is not what we want. We want them grouped by frequency, so we need a `Sort-Object`
    cmdlet in the pipeline as well:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We also don’t want to see all the words; we just want the most frequent words.
    Let’s get the most frequent 10\. We can use a formula of `[-1..-10]` to get them
    from the array. We’re using `[-1..-10]` because by default, the sort order is
    ascending and we want it descending. We could run `$GroupedWords[-1..-10]`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'And that’s it! Here’s my whole program and the output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 6.14 – The ten most frequent words in any English book (written by
    a man)](img/B17600_06_14.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6.14 – The ten most frequent words in any English book (written by a
    man)
  prefs: []
  type: TYPE_NORMAL
- en: We’ve achieved something here, although it’s probably not what we wanted to
    achieve. It looks to me like the list of the 10 most frequent words in any book
    in English, written by a man. What can we do about that?
  prefs: []
  type: TYPE_NORMAL
- en: The computer science discipline of **Natural Language Processing** involves
    the concept of **stop words**. These are common words in a language that shouldn’t
    be counted when analyzing the text. There are plenty of lists of stop words available
    on the internet for free. What we need to do is build a loop that compares each
    word in the array to a list of stop words and only adds them to a new array if
    they are *not* in the list.
  prefs: []
  type: TYPE_NORMAL
- en: Activity
  prefs: []
  type: TYPE_NORMAL
- en: Rewrite the program using a loop to compare each word in the `$TrialWords` array
    to the words in a list of stop words. Use the stop words file at [https://raw.githubusercontent.com/stopwords-iso/stopwords-en/master/stopwords-en.txt](https://raw.githubusercontent.com/stopwords-iso/stopwords-en/master/stopwords-en.txt).
  prefs: []
  type: TYPE_NORMAL
- en: 'Hint 1:'
  prefs: []
  type: TYPE_NORMAL
- en: 'You won’t want to use a PowerShell array for this – why? It’s probably best
    to use an array list. Construct it like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '**$Words = [****System.Collections.ArrayList]@()**'
  prefs: []
  type: TYPE_NORMAL
- en: 'Hint 2:'
  prefs: []
  type: TYPE_NORMAL
- en: 'You will need to split the array on more characters than just a space because
    of words that have full stops and other punctuation immediately after them. For
    some characters, you’ll need to use an escape character – the backtick (`` ` ``)
    – for them to be interpreted properly. I found replacing the second line in the
    preceding code with this line to be effective:'
  prefs: []
  type: TYPE_NORMAL
- en: '**$TestWords = $TheTrial.Split(“ “, “`t”, “`n”, “,”,”`””,”.”, [****System.StringSplitOptions]::RemoveEmptyEntries)**'
  prefs: []
  type: TYPE_NORMAL
- en: '`RemoveEmptyEntries` prevents null strings from being counted.'
  prefs: []
  type: TYPE_NORMAL
- en: '`''t` is the tab character.'
  prefs: []
  type: TYPE_NORMAL
- en: '`` `n `` is the newline character.'
  prefs: []
  type: TYPE_NORMAL
- en: '`` `" `` allows us to use a double quote mark as a delimiter.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Hint 3:'
  prefs: []
  type: TYPE_NORMAL
- en: Is `That` the same word as `that`? You will want to make sure that all the characters
    in your words are in the same case.
  prefs: []
  type: TYPE_NORMAL
- en: Have fun! I’ve written one way to do it at the end.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This is quite a long chapter and it is really only an introduction. We will
    cover more ways of ingesting data with PowerShell as we go through the book. We’ve
    come a long way, though.
  prefs: []
  type: TYPE_NORMAL
- en: 'We started out by looking at how we can format output for the screen using
    three common formatting cmdlets: `Format-List`, `Format-Table`, and `Format-Wide`.
    We then looked at how we could output that formatted data to a text file with
    `Out-File`. We took some time to understand the limitations of this approach before
    we explored two families of cmdlets: `ConvertTo-` and `Export-`.'
  prefs: []
  type: TYPE_NORMAL
- en: We took quite a deep look at the cmdlets for handling CSV files, `ConvertTo-Csv`
    and `Export-Csv`, and understood how the `ExportTo-Csv` cmdlet combines the `ConvertTo-Csv`
    and `Out-File` cmdlets. We then looked at `ConvertTo-Xml` and `Export-Clixml`.
    Finally, we looked at `ConvertTo-Html` and experimented with how we can use it
    to produce interestingly formatted documents by referencing a CSS file.
  prefs: []
  type: TYPE_NORMAL
- en: We then briefly discussed `PSProviders` and `PSdrives` and understood that these
    are more useful in a Windows environment, but are still relevant for Linux and
    macOS.
  prefs: []
  type: TYPE_NORMAL
- en: 'We looked at `Get-Content`, the most common way of bringing data into PowerShell,
    and learned that it produces either an array of strings or bytes – to import data
    in a more structured way, we would need to use something else: the `Import-` cmdlets.
    We looked at `Import-Csv` and `Import-Clixml` and saw how they can be used to
    construct PowerShell objects from structured data.'
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we did some programming and looked at how we can analyze text files
    using PowerShell.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will be looking at how we can use PowerShell to interact
    with systems on the internet and the common file formats we will need.
  prefs: []
  type: TYPE_NORMAL
- en: Exercises
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: How would you produce a wide list of the names of all the files in your temp
    directory, with three columns?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What will happen if we run this code?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Add a “`Sooo much"` string to the file from *question 3*.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Write a statement to create a file containing all the items in your working
    directory to a CSV file, but separated with semicolons rather than commas.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How many functions are defined in your PowerShell session?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How would you import the text file from *question 4* using a space as a string
    separator?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How would you import the file you created in *question 5* and what sort of objects
    would you get?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What does the following error tell us?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We really should read all the help files for the cmdlets we’ve used in this
    chapter. We know how to find them, so we’re not going to list them here.
  prefs: []
  type: TYPE_NORMAL
- en: 'To learn about HTML and CSS, go to the W3Schools website: [https://www.w3schools.com/](https://www.w3schools.com/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'To learn more about Serialization, have a look here: [https://docs.microsoft.com/en-us/dotnet/standard/serialization/introducing-xml-serialization](https://docs.microsoft.com/en-us/dotnet/standard/serialization/introducing-xml-serialization)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
