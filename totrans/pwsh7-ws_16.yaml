- en: '16'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '16'
- en: Working with PowerShell and .NET
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 PowerShell 和 .NET
- en: Here we are then, the last chapter. We’re going to look at the product that
    PowerShell 7 is built on, .NET, and how we can use it to expand the range of things
    we can do in PowerShell. Note that this chapter can’t be anything more than a
    whistlestop tour; .NET is a huge subject, and there are many, many more books
    written for it than there are for PowerShell. PowerShell is just one application
    written on .NET, and it only touches a subset of the things that we can do with
    .NET. That being said, let’s have a look at how it works and some of the exciting
    things we can use it for.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们来到了最后一章。我们将探讨 PowerShell 7 所依赖的产品——.NET，以及如何利用它扩展我们在 PowerShell 中能做的事情。需要注意的是，这一章只能提供一个简短的概览；.NET
    是一个庞大的主题，关于它的书籍远远多于关于 PowerShell 的书籍。PowerShell 只是一个基于 .NET 编写的应用程序，它仅触及了我们在 .NET
    中可以做的一部分事情。话虽如此，还是让我们来看看它的工作原理，以及我们可以用它做一些什么令人兴奋的事情。
- en: 'The main topics we will cover in this chapter are as follows:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖的主要内容如下：
- en: Exploring .NET
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 探索 .NET
- en: The components of .NET
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: .NET 的组件
- en: Working with .NET in PowerShell
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 PowerShell 中使用 .NET
- en: Using .NET
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 .NET
- en: Exploring .NET
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 探索 .NET
- en: '**.NET** (**dot-net**) is a software framework. It’s free and open source and
    can be used to write web applications, command-line applications, and applications
    that run in a **Graphical User Interface** (**GUI**). It is based on the proprietary
    coded .NET Framework, which is the software framework that the Windows operating
    system uses. It can be used with a range of programming languages, including C#,
    F#, and Visual Basic .NET. Let’s unpack all that, shall we?'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: '**.NET**（**dot-net**）是一个软件框架。它是免费的、开源的，可以用来编写 Web 应用程序、命令行应用程序和运行在 **图形用户界面**
    (**GUI**) 下的应用程序。它基于专有的 .NET 框架，这个框架是 Windows 操作系统所使用的。它可以与多种编程语言一起使用，包括 C#、F#
    和 Visual Basic .NET。让我们来详细了解一下吧？'
- en: Software frameworks explained
  id: totrans-10
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 软件框架解释
- en: A software framework is a tool for constructing applications. Some frameworks
    are written for specific purposes and specific languages; AngularJS is a framework
    for developing the frontends of web applications in JavaScript. PhaserJS is a
    game development framework, again for JavaScript. While frameworks contain many
    libraries, they differ from libraries in that libraries provide tools for our
    code that we can use in any way we like; with a framework, we need to work within
    the structure. The basics of an application are provided; we need to provide the
    specifics.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 软件框架是构建应用程序的工具。一些框架是为特定目的和特定语言编写的；AngularJS 是一个用于开发 JavaScript Web 应用程序前端的框架。PhaserJS
    是一个游戏开发框架，同样适用于 JavaScript。虽然框架包含了许多类库，但与类库不同，框架需要在其结构内工作。类库为我们的代码提供工具，可以随意使用；而框架则规定了应用程序的基本结构，我们需要在此基础上提供具体的实现。
- en: .NET implements a **Common Language Infrastructure** (**CLI**) that allows different
    high-level languages (such as C#) to be used on multiple operating system platforms,
    without needing to be rewritten for each architecture; this is how PowerShell
    7 can work on Intel and ARM processors. By installing the correct version of .NET,
    our PowerShell code can then run anywhere.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: .NET 实现了 **公共语言基础设施** (**CLI**)，允许不同的高级语言（如 C#）在多个操作系统平台上使用，而无需为每个架构重写代码；这就是
    PowerShell 7 如何能够在 Intel 和 ARM 处理器上运行的原因。通过安装正确版本的 .NET，我们的 PowerShell 代码就能在任何地方运行。
- en: A .NET component called **CoreFX** houses the .NET libraries of classes, interfaces,
    and value types in a **Framework Class Library**. .NET provides more than just
    libraries, though. .NET applications run in a virtual machine called **CoreCLR**,
    in the same way that Java applications run inside the Java Virtual Machine.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 一个名为 **CoreFX** 的 .NET 组件包含了 .NET 类库、接口和值类型，组成了 **框架类库**。不过，.NET 提供的不仅仅是类库。
    .NET 应用程序在一个名为 **CoreCLR** 的虚拟机中运行，就像 Java 应用程序在 Java 虚拟机中运行一样。
- en: Common language infrastructure
  id: totrans-14
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 公共语言基础设施
- en: 'The CLI is an open technical standard developed by Microsoft and is largely
    only found in variations of .NET, although there is an open development platform
    called **Mono** that uses it as well. The CLI specifies five things:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: CLI 是由微软开发的开放技术标准，主要只存在于 .NET 的不同变种中，尽管也有一个叫做 **Mono** 的开放开发平台也使用它。CLI 定义了五个要素：
- en: '**Common Type System (CTS)** – the set of types that can be accessed by programming
    languages using the framework.'
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**公共类型系统（CTS）** – 可由编程语言通过框架访问的类型集合。'
- en: '**Metadata**, which is used to describe the program structure.'
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**元数据**，用于描述程序结构。'
- en: '**Common Language Specification (CLS)** – rules for using the framework.'
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**公共语言规范（CLS）** – 使用框架的规则。'
- en: '**Virtual Execution System (VES)** – this loads and executes applications.
    It uses metadata to run code generated in compliant languages at runtime, compiling
    them into a platform-agnostic **Common Intermediate Language** (**CIL**), which
    is then compiled to a platform-specific machine language in real time. In .NET,
    the VES is implemented in the CoreCLR component.'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**虚拟执行系统（VES）** – 它加载并执行应用程序。它使用元数据在运行时执行用兼容语言生成的代码，并将其编译成平台无关的 **公共中间语言（CIL）**，然后将其即时编译为平台特定的机器语言。在
    .NET 中，VES 是通过 CoreCLR 组件实现的。'
- en: '**Standard libraries**, which provide common functions, such as accessing networks
    and files.'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**标准库**，提供常用功能，如访问网络和文件。'
- en: Let’s look at the CoreCLR component.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看一下 CoreCLR 组件。
- en: Common language runtime – CoreCLR
  id: totrans-22
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 公共语言运行时 – CoreCLR
- en: CoreCLR provides a common language runtime, which is a layer that sits between
    the application and the operating system. It is similar in principle to the PowerShell
    program; .NET applications need .NET to be running on the machine to interpret
    the application code as machine code. This means PowerShell needs .NET to be running,
    as PowerShell is a .NET application.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: CoreCLR 提供了一个公共语言运行时，这是一个位于应用程序和操作系统之间的层。它的原理类似于 PowerShell 程序；.NET 应用程序需要在机器上运行
    .NET 才能将应用程序代码解释为机器代码。这意味着 PowerShell 需要 .NET 运行，因为 PowerShell 本身是一个 .NET 应用程序。
- en: However, CoreCLR doesn’t just provide a runtime. It also includes additional
    services such as memory management (allocating portions of virtual memory to applications),
    garbage collection (recovering unused memory that is no longer needed), and thread
    management. This means that when we use .NET to write applications, we don’t need
    to worry about memory leaks or memory addressing errors, as all that is handled
    for us by CoreCLR.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，CoreCLR 不仅仅提供运行时。它还包括额外的服务，如内存管理（为应用程序分配虚拟内存的一部分）、垃圾回收（回收不再需要的未使用内存）和线程管理。这意味着，当我们使用
    .NET 编写应用程序时，我们无需担心内存泄漏或内存寻址错误，因为这些都由 CoreCLR 为我们处理。
- en: Happily, we don’t need to know much about how CoreCLR works to use .NET with
    PowerShell. Most of what we are interested in is held in the libraries – CoreFX.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，我们不需要知道 CoreCLR 是如何工作的，就能在 PowerShell 中使用 .NET。我们感兴趣的大部分内容都在库中 – CoreFX。
- en: Framework Class Library – CoreFX
  id: totrans-26
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 框架类库 – CoreFX
- en: 'CoreFX contains the class libraries that .NET uses, which include types, functions,
    and classes. All the PowerShell data types, for instance, are a subset of the
    available .NET types. We’ve seen this already; in [*Chapter 4*](B17600_04.xhtml#_idTextAnchor071),
    *PowerShell Variables and Data Structures*, we saw that changing the contents
    of a PowerShell array was resource-intensive because each time we change an array,
    we create a new one and delete the old one. We saw that one of the solutions to
    this was to use a .NET type that is not available natively inside PowerShell,
    `ArrayList`, like this:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: CoreFX 包含了 .NET 使用的类库，其中包括类型、函数和类。例如，所有 PowerShell 数据类型都是可用 .NET 类型的一个子集。我们已经看到这一点；在
    [*第 4 章*](B17600_04.xhtml#_idTextAnchor071)《PowerShell 变量与数据结构》中，我们看到改变 PowerShell
    数组内容是资源密集型的，因为每次改变数组时，我们会创建一个新数组并删除旧数组。我们看到，解决这个问题的方法之一是使用一个在 PowerShell 中原生不可用的
    .NET 类型 `ArrayList`，就像这样：
- en: '[PRE0]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: We use the `[System.Collections.ArrayList]` full .NET type to set the array
    as `ArrayList`. Sometimes, working with .NET really is that easy.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用 `[System.Collections.ArrayList]` 完整的 .NET 类型来将数组设置为 `ArrayList`。有时候，使用
    .NET 确实是这么简单。
- en: .NET history
  id: totrans-30
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: .NET 历史
- en: .NET Framework was first released in 2002 and was intended to create Windows
    applications. It introduced the Microsoft concept of **managed code**, code that
    would only interact with the CLI. Managed code could be more tightly controlled,
    both in terms of resource use and security, and it was also less prone to causing
    system crashes – the dreaded Blue Screen of Death – because it only touched the
    CLR, not the underlying operating system. In time, many of Microsoft’s most popular
    applications, such as Microsoft Exchange Server, were written in managed code
    and required .NET Framework to run. .NET Framework will only run on Windows and
    contains many Windows-specific features.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: .NET Framework首次发布于2002年，旨在创建Windows应用程序。它引入了微软的**托管代码**概念，即只与CLI交互的代码。托管代码可以更严格地控制资源使用和安全性，并且由于只接触CLR而不是底层操作系统，它也不太容易导致系统崩溃（蓝屏），这就是其特点之一。随着时间推移，微软的许多最受欢迎的应用程序，如Microsoft
    Exchange Server，都是用托管代码编写的，需要.NET Framework来运行。.NET Framework仅能在Windows上运行，并包含许多Windows特定的功能。
- en: In 2014, Microsoft released .NET Core, an open source, cross-platform implementation
    of the CLI. This shared many features of .NET Framework but not all of them, and
    similarly, it contained many features that were not implemented in .NET Framework,
    notably the ability to run on different operating systems. In 2022, Microsoft
    released a new version of .NET Core, simply called .NET 5; the intention was that
    .NET would eventually overtake .NET Framework. As happened with PowerShell and
    Windows PowerShell, in practice, both versions now exist side by side. The latest
    release of .NET Framework, at the time of writing, is version 4.8.1 in August
    2022, whereas .NET is released annually, around November; the latest version is
    .NET 8.0, released in November 2023.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 在2014年，微软发布了.NET Core，这是一个开源的、跨平台实现CLI的项目。它与.NET Framework共享许多特性，但并非全部，并且它还包含了许多.NET
    Framework中没有实现的功能，特别是在不同操作系统上运行的能力。2022年，微软发布了一个新版本的.NET Core，简称.NET 5；其意图是最终取代.NET
    Framework。就像PowerShell和Windows PowerShell一样，实际上，两个版本现在并存。截至撰写本文时，最新的.NET Framework版本是2022年8月发布的4.8.1版本，而.NET每年发布一次，大约在11月左右；最新版本是2023年11月发布的.NET
    8.0版本。
- en: So, what can we use .NET for? Let’s take a look.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，我们可以用.NET做什么呢？让我们来看看。
- en: The uses of .NET
  id: totrans-34
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: .NET的用途
- en: .NET Framework was developed to create Windows applications – while we can use
    it for command-line programs, it includes the **Windows Presentation Foundation**
    (**WPF**) framework, ASP.NET (for internet applications), and Windows Forms for
    graphical applications.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: .NET Framework是为创建Windows应用程序而开发的——尽管我们可以将其用于命令行程序，它包括**Windows Presentation
    Foundation**（**WPF**）框架、用于Internet应用程序的ASP.NET以及用于图形应用程序的Windows Forms。
- en: The current iteration of .NET includes libraries for cloud-native applications
    and serverless functions on Azure, cross-platform desktop applications and games,
    mobile apps using .NET **Multi Application User Interface** (**MAUI**), machine
    learning applications with ML.NET, and Internet of Things applications with .NET
    IoT.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 当前的.NET版本包括云原生应用程序和Azure上的无服务器函数的库、跨平台桌面应用程序和游戏、使用.NET **Multi Application User
    Interface**（**MAUI**）的移动应用程序、带有ML.NET的机器学习应用程序以及带有.NET IoT的物联网应用程序。
- en: The most mature libraries, however, are for Windows, and they include libraries
    for Windows Desktop apps with WPF, Windows Forms, and the **Universal Windows
    Platform** (**UWP**) and Windows services libraries that allow us to run applications
    as services.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，最成熟的库是为Windows开发的，它们包括用于WPF、Windows Forms和**Universal Windows Platform**（**UWP**）的Windows桌面应用程序库以及允许我们将应用程序作为服务运行的Windows服务库。
- en: It would be easy to write a whole series of books on .NET, and many people have.
    However, we are mostly interested in how we can use .NET with PowerShell. We are
    going to focus on the .NET libraries and how we can access their contents from
    PowerShell, accessing in turn the APIs we wish to work with. Let’s start by looking
    at the structure of the .NET libraries.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 谈到.NET，可以轻易写一整套的书籍，而且许多人已经这么做了。然而，我们更感兴趣的是如何在PowerShell中使用.NET。我们将重点关注.NET库以及如何从PowerShell访问其内容，进而访问我们希望使用的API。让我们首先看一下.NET库的结构。
- en: The components of .NET
  id: totrans-39
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: .NET的组件
- en: Before we can start using the .NET libraries, we need to understand how they
    are structured. **Members** (properties, methods, etc.) are contained inside **types**,
    which in turn are contained in **namespaces**. This is **logical type containment**.
    There is also **physical type containment**. These logical structures are physically
    held in **assemblies**. We’ve already seen many of these components in PowerShell.
    Let’s start with assemblies.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始使用 .NET 库之前，我们需要理解它们的结构。**成员**（属性、方法等）包含在**类型**中，而类型又包含在**命名空间**中。这就是**逻辑类型封装**。还有**物理类型封装**。这些逻辑结构在物理上由**程序集**保存。我们在
    PowerShell 中已经看到过这些组件。我们先从程序集开始。
- en: Assemblies
  id: totrans-41
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 程序集
- en: 'Assemblies are collections of types and the resources needed to support them.
    They can be either **static**, loaded from a file, or **dynamic**, existing solely
    in memory. PowerShell will load a number of default assemblies at startup, and
    then, as we import modules, that list will expand. We can see the list of assemblies
    we have loaded with the following:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 程序集是类型和支持它们所需资源的集合。它们可以是**静态的**，从文件加载，或者**动态的**，仅存在于内存中。PowerShell 在启动时会加载一组默认程序集，然后随着我们导入模块，这个列表会扩展。我们可以通过以下方式查看加载的程序集列表：
- en: '[PRE1]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'That will output a table like this:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 这将输出如下表格：
- en: '![Figure 16.1 – Enumerating assemblies](img/B17600_16_1.jpg)'
  id: totrans-45
  prefs: []
  type: TYPE_IMG
  zh: '![图 16.1 – 枚举程序集](img/B17600_16_1.jpg)'
- en: Figure 16.1 – Enumerating assemblies
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 图 16.1 – 枚举程序集
- en: We can see the version and the location of the files that these static assemblies
    are stored in. There is another column, `GAC`, which refers to the `False`. We
    can use assemblies that are usually stored in the GAC by installing them with
    NuGet, the .NET package manager; we just can’t access them from the GAC. We can
    also see that the assemblies are `.dll` files, which we talked about when discussing
    binary modules in [*Chapter 11*](B17600_11.xhtml#_idTextAnchor218), *Creating
    Our First Module*, and we also saw that binary modules are a type of .NET assembly.
    We can think of loading .NET assemblies as similar to loading binary modules.
    PowerShell loads a set of default assemblies when it starts, and these assemblies
    define the types that are available to us. To access other types, we need to load
    further assemblies.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以查看这些静态程序集的版本和文件存储位置。还有一列，`GAC`，表示 `False`。我们可以通过使用 .NET 包管理器 NuGet 安装通常存储在
    GAC 中的程序集来使用它们；只不过我们不能从 GAC 访问它们。我们还可以看到这些程序集是 `.dll` 文件，这在我们讨论二进制模块时提到过，[*第 11
    章*](B17600_11.xhtml#_idTextAnchor218)，*创建我们的第一个模块*，我们还看到二进制模块是 .NET 程序集的一种类型。我们可以将加载
    .NET 程序集看作类似于加载二进制模块。PowerShell 在启动时加载一组默认程序集，这些程序集定义了我们可以使用的类型。要访问其他类型，我们需要加载更多程序集。
- en: Types
  id: totrans-48
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 类型
- en: We first encountered types in [*Chapter 4*](B17600_04.xhtml#_idTextAnchor071),
    *PowerShell Variables and Data Structures*. The PowerShell types are a subset
    of the types found in .NET. We used a .NET type earlier in the chapter when we
    created an `ArrayList` object. Types are enclosed in square brackets.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 我们第一次遇到类型是在 [*第 4 章*](B17600_04.xhtml#_idTextAnchor071)，*PowerShell 变量和数据结构*
    中。PowerShell 类型是 .NET 中类型的一个子集。在本章之前，我们在创建 `ArrayList` 对象时使用了一个 .NET 类型。类型用方括号括起来。
- en: Type versus class
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 类型与类
- en: In type theory, a type is an abstract concept, whereas a class is a set of instructions
    to create an object of a given type. An object is of a certain type – for example,
    a string or an imaginary bike. A class is an implementation of the type. An object
    is an instance of the class. For instance, we could have multiple different classes
    of an imaginary bike that would all be of type `Imaginary.Bike`, but they could
    all have different features – for example, ape hanger handlebars or drop handlebars.
    We could then create many instances of each class (i.e., objects) – in this case,
    imaginary bikes.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 在类型理论中，类型是一个抽象概念，而类是一组创建给定类型对象的指令。一个对象属于某种类型——例如，一个字符串或一辆虚构的自行车。类是类型的实现。对象是类的实例。例如，我们可以有多个不同的虚拟自行车类，它们都属于类型
    `Imaginary.Bike`，但它们可能具有不同的特征——例如，猿把手或下拉把手。然后，我们可以为每个类创建多个实例（即对象）——在这种情况下，虚拟自行车。
- en: In practice, classes are user-defined in PowerShell, whereas types are provided
    by .NET – except, of course, where that isn’t true.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 在实践中，PowerShell 中的类是用户定义的，而类型是由 .NET 提供的——当然，除非情况并非如此。
- en: Enumerations
  id: totrans-53
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 枚举类型
- en: 'An enumeration is a list of constant values. While we haven’t discussed them
    before, we have certainly used them. In [*Chapter 10*](B17600_10.xhtml#_idTextAnchor201),
    *Error Handling – Oh No! It’s Gone Wrong!*, we saw the `$ErrorActionPreference`
    automatic variable and how, by changing the value of the variable, we could control
    how PowerShell handles errors temporarily. We can check the type of the `$ErrorActionPreference`
    variable by calling the variable `GetType()` method, and we can see that it is
    a `System.Enum` type in the following screenshot:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 枚举是常量值的列表。虽然我们之前没有讨论过它们，但我们肯定用过它们。在[*第 10 章*](B17600_10.xhtml#_idTextAnchor201)，*错误处理
    – 哎呀！出错了！*中，我们看到自动变量`$ErrorActionPreference`以及通过更改该变量的值，如何临时控制 PowerShell 处理错误的方式。我们可以通过调用变量的`GetType()`方法来检查`$ErrorActionPreference`变量的类型，并且可以在以下截图中看到它是`System.Enum`类型：
- en: '![Figure 16.2 – How can I set thee? Let me count the ways](img/B17600_16_2.jpg)'
  id: totrans-55
  prefs: []
  type: TYPE_IMG
  zh: '![图 16.2 – 如何设置你？让我数一数有哪些方式](img/B17600_16_2.jpg)'
- en: Figure 16.2 – How can I set thee? Let me count the ways
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 图 16.2 – 如何设置你？让我数一数有哪些方式
- en: We can list out the list of possible values with the `GetEnumValues()` method,
    and we can see the familiar list of possible values. `$ErrorActionPreference`
    can only have those values, and we can’t change them.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用`GetEnumValues()`方法列出可能的值，并看到熟悉的可能值列表。`$ErrorActionPreference`只能拥有这些值，且无法更改。
- en: Classes
  id: totrans-58
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 类
- en: A class is a logical definition of an object that defines the properties and
    methods of the object – a recipe. It is an implementation of a type. Back in [*Chapter
    4*](B17600_04.xhtml#_idTextAnchor071), *PowerShell Variables and Data Structures*,
    we created three objects of type `Imaginary.Bike`, by creating the objects and
    their properties and labeling them as `Imaginary.Bike`. We could also have defined
    a class of objects called `Imaginary.Bike` with the same properties and methods,
    using a **constructor** to create actual instances of the class. We use classes
    when we want to be able to create objects easily and repeatably.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 类是对象的逻辑定义，它定义了对象的属性和方法——就像一份食谱。它是某种类型的实现。回到[*第 4 章*](B17600_04.xhtml#_idTextAnchor071)，*PowerShell
    变量与数据结构*，我们通过创建类型为`Imaginary.Bike`的三个对象，定义了这些对象及其属性，并将其标记为`Imaginary.Bike`。我们也可以定义一个名为`Imaginary.Bike`的类，并赋予它相同的属性和方法，使用**构造函数**来创建该类的实际实例。当我们希望能够轻松且可重复地创建对象时，我们使用类。
- en: Namespaces
  id: totrans-60
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 命名空间
- en: 'Namespaces are analogous to folders in a filesystem; we saw namespaces used
    in this context in [*Chapter 13*](B17600_13.xhtml#_idTextAnchor267), *Working
    With PowerShell 7 and Windows*, when we discussed CIM classes. Most PowerShell
    types and functions are found in the `System.Management.Automation` namespace.
    When we interact with the filesystem, we use the `System.IO` namespace. We don’t
    need to write `System` when we refer to a namespace in PowerShell, as the `System`
    namespace is automatically searched; `Management.Automation` is functionally the
    same as `System.Management.Automation`. Unfortunately, we need to specify the
    namespace of any type that isn’t immediately in the `System` namespace, like this:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 命名空间类似于文件系统中的文件夹；我们在[*第 13 章*](B17600_13.xhtml#_idTextAnchor267)，*使用 PowerShell
    7 和 Windows*中讨论 CIM 类时看到了命名空间的使用。大多数 PowerShell 类型和函数都位于`System.Management.Automation`命名空间中。当我们与文件系统交互时，我们使用`System.IO`命名空间。我们在
    PowerShell 中引用命名空间时，不需要写`System`，因为会自动搜索`System`命名空间；`Management.Automation`在功能上与`System.Management.Automation`相同。不幸的是，我们需要为任何不在`System`命名空间中的类型指定命名空间，如下所示：
- en: '![Figure 16.3 – Accessing namespaces](img/B17600_16_3.jpg)'
  id: totrans-62
  prefs: []
  type: TYPE_IMG
  zh: '![图 16.3 – 访问命名空间](img/B17600_16_3.jpg)'
- en: Figure 16.3 – Accessing namespaces
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 图 16.3 – 访问命名空间
- en: The `Path` type defines the file path of an object and is in the `System.IO`
    namespace. If we try to reference it without specifying the namespace in line
    1, we get an error. In line 2, we specify the full namespace, but in line 3, we
    can see that we don’t need to specify the `System` portion of the namespace, as
    it is implied.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: '`Path`类型定义了对象的文件路径，并位于`System.IO`命名空间中。如果我们在第 1 行没有指定命名空间来引用它，就会出现错误。在第 2 行，我们指定了完整的命名空间，但在第
    3 行，我们可以看到无需指定`System`部分的命名空间，因为它是隐式的。'
- en: 'We can also use the `using` keyword to load the namespace, like this:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以使用`using`关键字来加载命名空间，如下所示：
- en: '[PRE2]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'After running this, we can call the `Path` type without specifying the namespace,
    like this:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 运行此操作后，我们可以像这样调用`Path`类型，而无需指定命名空间：
- en: '![Figure 16.4 – The using keyword in action](img/B17600_16_4.jpg)'
  id: totrans-68
  prefs: []
  type: TYPE_IMG
  zh: '![图 16.4 – `using`关键字的作用](img/B17600_16_4.jpg)'
- en: Figure 16.4 – The using keyword in action
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 图 16.4 – `using`关键字的作用
- en: We saw the `using` keyword in [*Chapter 11*](B17600_11.xhtml#_idTextAnchor218),
    *Creating Our First Module*, where we learned it was the recommended way of loading
    modules inside a script. As we can see, we can also use it to load namespaces
    and assemblies. Unfortunately, in the console, only the most recent `using` statement
    is applied, so if we access another namespace with it in the current session,
    we will lose access to the `System.IO` namespace. Scripts allow multiple `using`
    statements, written at the start of the script; they can only be preceded by comments.
    We can load multiple namespaces in the console by using semicolons (`;`) to separate
    the `using` statements.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在[*第11章*](B17600_11.xhtml#_idTextAnchor218)《创建我们的第一个模块》中看到过`using`关键字，我们了解它是脚本中加载模块的推荐方式。正如我们所看到的，我们也可以使用它来加载命名空间和程序集。不幸的是，在控制台中，只有最新的`using`语句会生效，因此如果我们在当前会话中使用它访问另一个命名空间，就会失去对`System.IO`命名空间的访问权限。脚本允许多个`using`语句，通常写在脚本的开头；它们只能被注释符号所前置。我们可以通过使用分号(`;`)分隔`using`语句，在控制台中加载多个命名空间。
- en: Members
  id: totrans-71
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 成员
- en: Types and classes have members; throughout the book, we have used the `Get-Member`
    command to examine the properties and methods available on objects, and we’ve
    seen that objects are instances of a specific type. .NET types have a member we
    have not seen before, the constructor. Constructors provide ways of instantiating
    objects of the given class and take the same name as the class. They don’t appear
    when we run `Get-Member` against the class and can’t be directly called. Constructors
    may have parameters that we can use to populate the data members of the new object,
    or they may not; the object is created with a set of null value properties. Constructors
    may have overloads, where different sets of arguments can be passed when constructing
    the object. Most .NET classes have an automatic constructor called `new()`, which
    is a static method added by PowerShell.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 类型和类有成员；在本书中，我们使用了`Get-Member`命令来检查对象的属性和方法，并且我们已经看到对象是某种特定类型的实例。 .NET 类型有一个我们之前没有见过的成员——构造函数。构造函数提供了实例化给定类对象的方式，并与类同名。当我们对类运行`Get-Member`时，构造函数不会出现，也无法直接调用。构造函数可能有参数，我们可以使用这些参数来填充新对象的数据成员，也可能没有；如果没有参数，则对象会被创建时具有一组空值属性。构造函数可能有重载，可以在构造对象时传递不同的参数集。大多数
    .NET 类都有一个自动构造函数`new()`，这是PowerShell添加的一个静态方法。
- en: 'Let’s look at an example. The `[string]` type is immutable; when we change
    a string, we destroy the old string and create a new one. If we need the string
    to change frequently, this can cause a performance problem, much the same as the
    issue we have seen with arrays. There is a class in .NET that defines mutable
    strings that get around this problem; it’s called the `StringBuilder` class, and
    objects of this class are of type `System.Text.Stringbuilder`. If we create a
    new `StringBuilder` object with the default automatic constructor, we get an object
    with three properties, `Capacity`, `MaxCapacity`, and `Length`, in characters.
    If we call the `new()` method without the brackets, then we can see a list of
    the possible overloads:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一个例子。`[string]`类型是不可变的；当我们修改字符串时，我们会销毁旧字符串并创建一个新字符串。如果我们需要字符串频繁变化，这可能会导致性能问题，这与我们在数组中看到的问题类似。在.NET中有一个定义可变字符串的类，它解决了这个问题；它被称为`StringBuilder`类，该类的对象是`System.Text.StringBuilder`类型。如果我们使用默认的自动构造函数创建一个新的`StringBuilder`对象，我们会得到一个具有三个属性的对象：`Capacity`、`MaxCapacity`和`Length`，这些属性的单位是字符。如果我们不带括号调用`new()`方法，我们就能看到所有可能的重载列表：
- en: '![Figure 16.5 – The overloads of the StringBuilder class](img/B17600_16_5.jpg)'
  id: totrans-74
  prefs: []
  type: TYPE_IMG
  zh: '![图 16.5 – `StringBuilder`类的重载](img/B17600_16_5.jpg)'
- en: Figure 16.5 – The overloads of the StringBuilder class
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 图 16.5 – `StringBuilder`类的重载
- en: 'As we can see, we can pass different combinations of arguments to the `new()`
    method to construct `StringBuilder` objects with different properties. Let’s try
    it. Type the following:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所看到的，我们可以向`new()`方法传递不同的参数组合，从而构造具有不同属性的`StringBuilder`对象。让我们试试看。输入以下内容：
- en: '[PRE3]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Now, if we call `$string1` and `$string2`, we can see that `$string1` is empty
    and has a capacity of 32\. `$string2` has a length of 2 and a capacity of 16\.
    That’s because we called the overload `new(int capacity)` for `$string1` and the
    overload `new(string value)` for `$string2`.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果我们调用`$string1`和`$string2`，我们会看到`$string1`是空的，且其容量为32；`$string2`的长度为2，容量为16。这是因为我们对`$string1`调用了重载`new(int
    capacity)`，对`$string2`调用了重载`new(string value)`。
- en: 'We can use the `ToString()` method to see the contents, like this:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用`ToString()`方法查看内容，如下所示：
- en: '[PRE4]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '`$string1` is empty, and `$string2` contains the `''32''` string. If we use
    the `GetType()` method, we can see that both are `StringBuilder` objects. If we
    pipe them to the `Get-Member` cmdlet, we can also see that the `new()` method
    isn’t listed because it’s a constructor.'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: '`$string1` 是空的，而 `$string2` 包含 `''32''` 字符串。如果我们使用 `GetType()` 方法，我们可以看到两者都是
    `StringBuilder` 对象。如果我们将它们传递给 `Get-Member` cmdlet，我们还可以看到 `new()` 方法没有列出，因为它是一个构造函数。'
- en: Versioning
  id: totrans-82
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 版本管理
- en: An assembly is a `.dll` file that contains metadata called the assembly manifest,
    which lists the contents of the file, as well as the name and the version of the
    file. The concept of strong names was introduced in .NET; a strong name consists
    of the name of the module, the version, and also a cryptographic hash that validates
    the file author. When .NET programs are linked to a strong named assembly, then
    the name, version, and hash of the file must match the linked strong name. If
    we simply replace the `.dll` file with a later version, then the program will
    fail to load it. This leads to different versions of `.dll` that have the same
    version number to prevent introducing breaking changes. Great.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 程序集是一个包含称为程序集清单的元数据的 `.dll` 文件，清单列出了文件的内容以及文件的名称和版本。强名称的概念是在 .NET 中引入的；一个强名称由模块的名称、版本以及用于验证文件作者的加密哈希组成。当
    .NET 程序链接到一个强名称程序集时，文件的名称、版本和哈希必须与链接的强名称匹配。如果我们只是简单地用一个较新的版本替换 `.dll` 文件，那么程序将无法加载它。这导致了具有相同版本号的
    `.dll` 文件的不同版本，以防止引入破坏性更改。太棒了。
- en: There are many other components, but these are the things we most need to be
    aware of when working with .NET and PowerShell. Let’s look now at how PowerShell
    makes use of .NET.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 还有许多其他组件，但这些是我们在使用 .NET 和 PowerShell 时最需要注意的内容。现在，让我们来看看 PowerShell 如何利用 .NET。
- en: Working with .NET in PowerShell
  id: totrans-85
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在 PowerShell 中使用 .NET
- en: In this section, we are going to look at some of the details of how PowerShell
    accesses .NET libraries. We’ll look at the default assemblies, how PowerShell
    finds types, and another way of creating objects.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将查看 PowerShell 如何访问 .NET 库的详细信息。我们将了解默认的程序集、PowerShell 如何查找类型，以及另一种创建对象的方法。
- en: Why bother?
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么要在乎？
- en: PowerShell and C# are part of the .NET family and thus work well together, as
    they are based on the same .NET foundation. They share many features, such as
    classes and libraries. We can call C# inside PowerShell by using `Add-Type`, allowing
    us to compile and run the C# code when we run the PowerShell script. This lets
    us take advantage of the simplicity and ease of PowerShell, but we have C# available
    whenever we need it, without having to write an entire program.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: PowerShell 和 C# 都是 .NET 家族的一部分，因此它们可以很好地协同工作，因为它们基于相同的 .NET 基础。它们共享许多功能，例如类和库。我们可以通过使用
    `Add-Type` 在 PowerShell 中调用 C#，这让我们在运行 PowerShell 脚本时编译并运行 C# 代码。这样我们就能利用 PowerShell
    的简洁和易用性，但当需要时，C# 也能随时调用，而不必编写整个程序。
- en: PowerShell assemblies
  id: totrans-89
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: PowerShell 程序集
- en: 'We saw at the start of the chapter that we could list the loaded assemblies
    with the statement:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在章节开始时看到，可以通过以下语句列出已加载的程序集：
- en: '[PRE5]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '`AppDomain` is a class that encapsulates and isolates the execution environment;
    it’s a bit like `PSSession` but even more secure; each instance of `PSSession`
    shares a set of assemblies, whereas each instance of `AppDomain` loads its own
    assemblies. `CurrentDomain` gets the current execution environment. The double
    colon (`::`) represents the C# namespace alias operator; we need to use it to
    access a member of an aliased namespace, and it goes between two identifiers.
    Let’s run the statement again, like this:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: '`AppDomain` 是一个封装和隔离执行环境的类；它有点像 `PSSession`，但更加安全；每个 `PSSession` 实例共享一组程序集，而每个
    `AppDomain` 实例加载自己的程序集。`CurrentDomain` 获取当前执行环境。双冒号（`::`）是 C# 命名空间别名运算符；我们需要使用它来访问别名命名空间的成员，它位于两个标识符之间。让我们像这样再次运行语句：'
- en: '[PRE6]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Then, we can see a list of the strong names of the assemblies we’ve loaded:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们可以看到已加载程序集的强名称列表：
- en: '![Figure 16.6 – Default assemblies and their strong names](img/B17600_16_6.jpg)'
  id: totrans-95
  prefs: []
  type: TYPE_IMG
  zh: '![图 16.6 – 默认程序集及其强名称](img/B17600_16_6.jpg)'
- en: Figure 16.6 – Default assemblies and their strong names
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 图 16.6 – 默认程序集及其强名称
- en: Note that each strong name contains a short name, a version, a culture identifier,
    and the cryptographic key that identifies the author.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，每个强名称包含一个短名称、一个版本、一个文化标识符和一个加密密钥，该密钥标识作者。
- en: Dynamic assembly loading
  id: totrans-98
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 动态程序集加载
- en: Automatic loading works for compiled programs such as `pwsh.exe`, but it relies
    on the required assembly list in the executable. We can add required assemblies
    to a module manifest as well, in the `RequiredAssemblies` element. If we need
    to load non-default assemblies when writing scripts, we can use the preceding
    `using` keyword, the `Add-Type` cmdlet, or even the `Import-Module` cmdlet if
    the assembly is in a `.``dll` file.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 自动加载适用于像`pwsh.exe`这样的已编译程序，但它依赖于可执行文件中的所需程序集列表。我们也可以将所需的程序集添加到模块清单中的`RequiredAssemblies`元素。如果在编写脚本时需要加载非默认程序集，我们可以使用前面的`using`关键字、`Add-Type`
    cmdlet，甚至使用`Import-Module` cmdlet，如果程序集在一个`.dll`文件中。
- en: 'The `Add-Type` cmdlet has five parameter sets; three of them are for defining
    new types, but we can also use it to import assemblies from a named path, or to
    just import the types we need from the assembly, such as the following:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: '`Add-Type` cmdlet有五个参数集；其中三个用于定义新类型，但我们也可以使用它从指定路径导入程序集，或仅从程序集导入我们需要的类型，例如以下内容：'
- en: '[PRE7]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: This will add the assemblies required to call simple Windows GUI elements from
    within PowerShell.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 这将添加所需的程序集，以便从PowerShell中调用简单的Windows GUI元素。
- en: Once we’ve imported (or created) our new type, we can create instances of types
    with the `New-Object` cmdlet.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们导入（或创建）了新的类型，就可以使用`New-Object` cmdlet来创建该类型的实例。
- en: Creating instances of types
  id: totrans-104
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建类型的实例
- en: 'The `New-Object` cmdlet creates an instance of a type. Either the type must
    exist inside the PowerShell default assemblies, or we must import it first with
    `Add-Type`. `New-Object` is easy to use. All we need to provide is `TypeName`
    and a list of arguments that matches one of the available overloads. For instance,
    one of the overloads on the `StringBuilder` type allows a string to define the
    value of the new object, and an integer to define the initial capacity. Note that
    it takes a string value, (`System.Text.String.Builder`), not a namespace and namespace
    alias qualifier (`[System.Text.StringBuilder]::`), so we can do this:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: '`New-Object` cmdlet创建一个类型的实例。该类型必须存在于PowerShell默认的程序集内，或者我们必须先使用`Add-Type`导入它。`New-Object`很容易使用。我们只需要提供`TypeName`和一个与可用重载匹配的参数列表。例如，`StringBuilder`类型的一个重载允许使用一个字符串来定义新对象的值，另一个整数来定义初始容量。请注意，它接受一个字符串值（`System.Text.String.Builder`），而不是命名空间和命名空间别名限定符（`[System.Text.StringBuilder]::`），所以我们可以这样做：'
- en: '[PRE8]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'That will create a variable called `$loveit` that contains the `"i love PowerShell"`
    string and has an initial capacity of 128 characters:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 这将创建一个名为`$loveit`的变量，它包含`"i love PowerShell"`字符串，并且初始容量为128个字符：
- en: '![Figure 16.7 – Loving it](img/B17600_16_7.jpg)'
  id: totrans-108
  prefs: []
  type: TYPE_IMG
  zh: '![图 16.7 – 喜欢它](img/B17600_16_7.jpg)'
- en: Figure 16.7 – Loving it
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 图 16.7 – 喜欢它
- en: We can see in the preceding screenshot that the initial capacity is 128, whereas
    we would expect it to be 17, the length of the string, if we had just passed a
    string value. Note that we have to understand the required arguments for the overload
    we wish to use as a constructor – in this instance, `"i love powershell"` and
    `128`. For instance, if we supply two strings, we will get an error.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在前面的截图中看到，初始容量是128，而如果我们只传递一个字符串值的话，预计它应该是17，即字符串的长度。请注意，我们需要理解我们希望使用的构造函数的重载所需的参数——在本例中是`"i
    love powershell"`和`128`。例如，如果我们提供两个字符串，则会出错。
- en: An alternative is to use the `-Property` parameter, which accepts a hashtable
    of property names and the required values. We’ll see how to use that in the next
    section, but note that if you misspell a property, PowerShell will simply add
    the misspelled property to the object, rather than tell you that you have it wrong.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种选择是使用`-Property`参数，它接受一个包含属性名称和所需值的哈希表。我们将在下一节中看到如何使用它，但请注意，如果你拼写错误，PowerShell会将拼写错误的属性添加到对象中，而不是告诉你有错误。
- en: Let’s try a couple of examples to get a feel for how we can use .NET with PowerShell.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们尝试几个例子，以便更好地了解如何在PowerShell中使用 .NET。
- en: Using .NET
  id: totrans-113
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 .NET
- en: We’ll try two examples in this section – an alternative way of getting an action
    to fire, such as a script, and how we can call Windows GUI elements from PowerShell.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将尝试两个示例——一种触发操作的替代方法，比如脚本，以及如何从PowerShell中调用Windows GUI元素。
- en: An alternative to the Task Scheduler
  id: totrans-115
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 任务调度程序的替代方案
- en: In this example, we’re going to create a timer object and then use the `Register-Event`
    cmdlet to fire an action at regular intervals.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们将创建一个定时器对象，然后使用`Register-Event` cmdlet在定时的间隔内触发一个操作。
- en: 'First, let’s make a timer:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们创建一个定时器：
- en: '[PRE9]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Now, we need to register the event and define an action:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们需要注册事件并定义一个操作：
- en: '[PRE10]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Now, let’s start the timer going with the following:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们开始计时，操作如下：
- en: '[PRE11]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Then, we should see the `hello` string appear on the screen, every five seconds,
    until we type the following:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们应该看到`hello`字符串每隔五秒钟出现在屏幕上，直到我们输入以下内容：
- en: '[PRE12]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'This is how it looks on my machine:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是它在我机器上的样子：
- en: '![Figure 16.8 – hello](img/B17600_16_8.jpg)'
  id: totrans-126
  prefs: []
  type: TYPE_IMG
  zh: '![图16.8 – hello](img/B17600_16_8.jpg)'
- en: Figure 16.8 – hello
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 图16.8 – hello
- en: We can see the command firing every time the timer reaches 5,000 milliseconds.
    Cool, eh?
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到每当计时器达到5000毫秒时，命令就会被触发。酷吧？
- en: Let’s try creating a GUI message box.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们尝试创建一个GUI消息框。
- en: Creating GUI objects
  id: totrans-130
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建GUI对象
- en: 'This example will create a pop-up message box in Windows with a pair of yes/no
    buttons. The value of the pressed button is recorded in the PowerShell session:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子将在Windows中创建一个弹出消息框，包含一对“是/否”按钮。按下的按钮值将记录在PowerShell会话中：
- en: '[PRE13]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'We could use this in conjunction with the preceding timer object to display
    a message box, allowing people to cancel a long-running script. This is how it
    looks on my machine:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将这个与前面的计时器对象结合使用，显示一个消息框，允许用户取消长时间运行的脚本。这是它在我机器上的样子：
- en: '![Figure 16.9 – Of course you do](img/B17600_16_9.jpg)'
  id: totrans-134
  prefs: []
  type: TYPE_IMG
  zh: '![图16.9 – 当然你会](img/B17600_16_9.jpg)'
- en: Figure 16.9 – Of course you do
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 图16.9 – 当然你会
- en: Note that the default answer is **Yes**. We could also use the response to set
    parameters, add an event, or trigger a conditional statement.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，默认答案是**是**。我们还可以使用响应来设置参数、添加事件或触发条件语句。
- en: Let’s summarize what we’ve seen in this chapter.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们总结一下本章的内容。
- en: Summary
  id: totrans-138
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: We started out by understanding what .NET is – a software framework. We learned
    that it is based on the Common Language Infrastructure and is similar to .NET
    Framework in Windows, but it is not the same. We saw that it includes its own
    runtime, CoreCLR, and a set of libraries, CoreFX. We learned about the relationship
    between .NET and .NET Framework and how they co-exist. We saw that .NET can be
    used for many things, including machine learning and Internet of Things applications,
    but is mostly used for Azure and Windows.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先了解了什么是.NET——一个软件框架。我们了解到它是基于公共语言基础结构（Common Language Infrastructure）并且类似于Windows中的.NET
    Framework，但并不完全相同。我们看到它包含了自己的运行时CoreCLR和一套库CoreFX。我们了解了.NET和.NET Framework之间的关系以及它们如何共存。我们看到.NET可以用于许多领域，包括机器学习和物联网应用，但它主要用于Azure和Windows。
- en: We went through the components of .NET, and we understood how they are related
    to each other and are represented in PowerShell. We saw the constructor member,
    a special type of method for instantiating objects, and understood why versioning
    is frequently confusing.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 我们了解了.NET的各个组件，并理解了它们如何相互关联，并在PowerShell中表示。我们看到了构造函数成员，这是用于实例化对象的一种特殊类型的方法，并理解了为什么版本控制经常让人困惑。
- en: We then looked at the specifics of how we access .NET libraries from PowerShell,
    learned about dynamic loading, and then saw how to use the `New-Object` cmdlet
    to create instances of classes.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们查看了如何从PowerShell访问.NET库的具体方法，学习了动态加载，并看到了如何使用`New-Object` cmdlet来创建类的实例。
- en: Finally, we worked through two examples of things we can do using .NET – creating
    an event timer and a Windows message box.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们通过两个例子演示了可以使用.NET做的事情——创建事件计时器和Windows消息框。
- en: What’s next? Well, it depends. If you want to learn more about PowerShell, then
    there are great books such as *Mastering PowerShell Scripting* by Chris Dent from
    Packt, or the absolute bible, *Windows PowerShell in Action* by Bruce Payette
    et al. Whichever you choose, what you need to do is practice, practice, practice.
    The best way to become confident with a language, any language, is to use it.
    If you are interested in .NET, then PowerShell is a good start, but sooner or
    later, you will want to use a compiled language with it, such as C#. While it’s
    technically possible to write a machine learning application in PowerShell, I
    think it would be a lot easier to do it with C#.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来呢？这取决于你的需求。如果你想了解更多PowerShell的内容，有很多很棒的书籍，比如Packt出版的Chris Dent的《Mastering
    PowerShell Scripting》，或者Bruce Payette等人编写的绝对经典之作《Windows PowerShell in Action》。无论你选择哪本书，你需要做的就是多加练习。任何语言，最好的学习方式就是用它。若你对.NET感兴趣，PowerShell是一个不错的起点，但迟早你会想使用编译型语言，比如C#。虽然在PowerShell中编写机器学习应用程序从技术上来说是可行的，但我认为用C#做会容易得多。
- en: That’s it. That’s the end of the book. Thank you for sticking with it alongside
    me; I hope you enjoyed reading it as much as I enjoyed writing it. I can assure
    you I have learned a lot in the process, and hopefully, so have you. I hope you’ve
    enjoyed my company as much as I’ve enjoyed yours.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 就这样。这本书到此为止。感谢你与我一起坚持读完，希望你读得和我写得一样愉快。我可以向你保证，我在这个过程中学到了很多，希望你也有所收获。希望你像我享受陪伴一样也享受我的陪伴。
- en: Exercises
  id: totrans-145
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 练习
- en: How do you create a new instance of a .NET class in PowerShell?
  id: totrans-146
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如何在 PowerShell 中创建 .NET 类的新实例？
- en: What command in PowerShell is used to add a .NET assembly to the session?
  id: totrans-147
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: PowerShell 中用于将 .NET 程序集添加到会话的命令是什么？
- en: How do you call a static method of a .NET class in PowerShell?
  id: totrans-148
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如何在 PowerShell 中调用 .NET 类的静态方法？
- en: In PowerShell, how can you access a static property of a .NET class?
  id: totrans-149
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 PowerShell 中，如何访问 .NET 类的静态属性？
- en: How can you invoke a .NET constructor with parameters in PowerShell?
  id: totrans-150
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如何在 PowerShell 中调用带参数的 .NET 构造函数？
- en: What is the PowerShell cmdlet to load a .NET assembly from a file?
  id: totrans-151
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 用于从文件加载 .NET 程序集的 PowerShell cmdlet 是什么？
- en: How can you determine the .NET type of an object in PowerShell?
  id: totrans-152
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如何在 PowerShell 中确定对象的 .NET 类型？
- en: In PowerShell, how do you list all the methods of a .NET object?
  id: totrans-153
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 PowerShell 中，如何列出 .NET 对象的所有方法？
- en: What is the syntax to invoke an instance method of a .NET object in PowerShell?
  id: totrans-154
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 PowerShell 中，调用 .NET 对象实例方法的语法是什么？
- en: How do you access an instance property of a .NET object in PowerShell?
  id: totrans-155
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如何在 PowerShell 中访问 .NET 对象的实例属性？
- en: Further reading
  id: totrans-156
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: 'What is .NET?: [https://dotnet.microsoft.com/en-us/learn/dotnet/what-is-dotnet](https://dotnet.microsoft.com/en-us/learn/dotnet/what-is-dotnet)'
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 什么是 .NET？：[https://dotnet.microsoft.com/en-us/learn/dotnet/what-is-dotnet](https://dotnet.microsoft.com/en-us/learn/dotnet/what-is-dotnet)
- en: 'The Microsoft .NET documentation: [https://learn.microsoft.com/en-us/dotnet/core/introduction](https://learn.microsoft.com/en-us/dotnet/core/introduction)'
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 微软 .NET 文档：[https://learn.microsoft.com/en-us/dotnet/core/introduction](https://learn.microsoft.com/en-us/dotnet/core/introduction)
- en: 'The original .NET documentation; surprisingly useful: [https://learn.microsoft.com/en-us/previous-versions/tn-archive/bb496996(v=technet.10)](https://learn.microsoft.com/en-us/previous-versions/tn-archive/bb496996(v=technet.10))'
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 原始的 .NET 文档；出奇的有用：[https://learn.microsoft.com/en-us/previous-versions/tn-archive/bb496996(v=technet.10)](https://learn.microsoft.com/en-us/previous-versions/tn-archive/bb496996(v=technet.10))
- en: 'The `System.Management.Automation` namespace: [https://learn.microsoft.com/en-gb/dotnet/api/system.management.automation](https://learn.microsoft.com/en-gb/dotnet/api/system.management.automation)'
  id: totrans-160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`System.Management.Automation` 命名空间：[https://learn.microsoft.com/en-gb/dotnet/api/system.management.automation](https://learn.microsoft.com/en-gb/dotnet/api/system.management.automation)'
- en: 'Classes: [https://learn.microsoft.com/en-us/powershell/module/microsoft.powershell.core/about/about_classes](https://learn.microsoft.com/en-us/powershell/module/microsoft.powershell.core/about/about_classes)'
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 类：[https://learn.microsoft.com/en-us/powershell/module/microsoft.powershell.core/about/about_classes](https://learn.microsoft.com/en-us/powershell/module/microsoft.powershell.core/about/about_classes)
- en: 'Constructors: [https://learn.microsoft.com/en-us/powershell/module/microsoft.powershell.core/about/about_classes_constructors](https://learn.microsoft.com/en-us/powershell/module/microsoft.powershell.core/about/about_classes_constructors)'
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构造函数：[https://learn.microsoft.com/en-us/powershell/module/microsoft.powershell.core/about/about_classes_constructors](https://learn.microsoft.com/en-us/powershell/module/microsoft.powershell.core/about/about_classes_constructors)
- en: 'The `StringBuilder` class: [https://learn.microsoft.com/en-gb/dotnet/api/system.text.stringbuilder](https://learn.microsoft.com/en-gb/dotnet/api/system.text.stringbuilder)'
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`StringBuilder` 类：[https://learn.microsoft.com/en-gb/dotnet/api/system.text.stringbuilder](https://learn.microsoft.com/en-gb/dotnet/api/system.text.stringbuilder)'
- en: '`Add-Type`: [https://learn.microsoft.com/en-us/powershell/module/microsoft.powershell.utility/add-type](https://learn.microsoft.com/en-us/powershell/module/microsoft.powershell.utility/add-type)'
  id: totrans-164
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Add-Type`：[https://learn.microsoft.com/en-us/powershell/module/microsoft.powershell.utility/add-type](https://learn.microsoft.com/en-us/powershell/module/microsoft.powershell.utility/add-type)'
- en: '`New-Object`: [https://learn.microsoft.com/en-us/powershell/module/microsoft.powershell.utility/new-object](https://learn.microsoft.com/en-us/powershell/module/microsoft.powershell.utility/new-object)'
  id: totrans-165
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`New-Object`：[https://learn.microsoft.com/en-us/powershell/module/microsoft.powershell.utility/new-object](https://learn.microsoft.com/en-us/powershell/module/microsoft.powershell.utility/new-object)'
- en: 'The `Timer` class: [https://learn.microsoft.com/en-us/dotnet/api/system.timers.timer](https://learn.microsoft.com/en-us/dotnet/api/system.timers.timer)'
  id: totrans-166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Timer` 类：[https://learn.microsoft.com/en-us/dotnet/api/system.timers.timer](https://learn.microsoft.com/en-us/dotnet/api/system.timers.timer)'
- en: '`Register-ObjectEvent`: [https://learn.microsoft.com/en-us/powershell/module/microsoft.powershell.utility/register-objectevent](https://learn.microsoft.com/en-us/powershell/module/microsoft.powershell.utility/register-objectevent)'
  id: totrans-167
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'PowerShell Eventing: [https://devblogs.microsoft.com/powershell/powershell-eventing-quickstart/](https://devblogs.microsoft.com/powershell/powershell-eventing-quickstart/)'
  id: totrans-168
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Learn C#: [https://dotnet.microsoft.com/en-us/learn/csharp](https://dotnet.microsoft.com/en-us/learn/csharp)'
  id: totrans-169
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Answers to Activities and Exercises
  id: totrans-170
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '[Chapter 1](B17600_01.xhtml#_idTextAnchor013)'
  id: totrans-171
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Activities
  id: totrans-172
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'You can use `ADD_FILE_CONTEXT_MENU_RUNPOWERSHELL`, like this:'
  id: totrans-173
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-174
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '![Figure A.1 – Some PowerShell processes](img/B17600_Assessments_001.jpg)'
  id: totrans-175
  prefs: []
  type: TYPE_IMG
- en: Figure A.1 – Some PowerShell processes
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s get rid of `4052`:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure A.2 – Fewer PowerShell processes](img/B17600_Assessments_002.jpg)'
  id: totrans-178
  prefs: []
  type: TYPE_IMG
- en: Figure A.2 – Fewer PowerShell processes
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
- en: Exercises
  id: totrans-180
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Input `Get-Random`.
  id: totrans-181
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Input `Get-Random -Minimum 1 -``Maximum 11`.
  id: totrans-182
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Input `Get-ChildItem -``Path <folderpath>`.
  id: totrans-183
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Input `Get-ChildItem -Path <``folderpath> -Recurse`.
  id: totrans-184
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Input `New-Item -Path <folder path> -Name <item` `name> -ItemType`.
  id: totrans-185
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Directory.
  id: totrans-186
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Input `Get-Uptime`.
  id: totrans-187
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Input `Out-File`.
  id: totrans-188
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Store a username and password for use later in the shell or in a script.
  id: totrans-189
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: This cmdlet converts the output of a previous cmdlet or pipeline to HTML, which
    can then be displayed in a web browser. Note that you might need to save it as
    a file using `out-file` as well, or it will just display the HTML code in the
    shell.
  id: totrans-190
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[Chapter 2](B17600_02.xhtml#_idTextAnchor034)'
  id: totrans-191
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Activities
  id: totrans-192
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`New` creates a new object. For instance, `New-Item C:\foo\bar.tx``t` will
    create an empty text file called `bar.txt` in the `C:\foo` directory. Add will
    add things to the existing object, so `Add-Content C:\foo\bar.txt "PowerShell
    rocks my world``"`will add that string to the previously empty text file.'
  id: totrans-193
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Just specify the `-InputObject` parameter like this: `Get-Random -``InputObject
    20`.'
  id: totrans-194
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Use the `-Prefix` parameter. This is particularly useful when using remote sessions.
  id: totrans-195
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Exercises
  id: totrans-196
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`Get-Content` is correct. This is a bit of a trick question, as the *Approved
    Verbs for PowerShell Commands* web page says that `Get` should be reserved for
    getting information *about* an object, not its contents. Nonetheless, `Get-Content`
    is right, as we are getting the contents of a file and reserving it for future
    use *as an object*, as opposed to reading data from a remote resource such as
    a web page. `Read-Host` is an example of a cmdlet that reads things—in this case,
    information from the shell.'
  id: totrans-197
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You should see the words `alive alive` printed on the screen. This is because
    `oh` is an alias for `Out-Host`, which takes an object—in this case, the string
    `alive alive`—and prints it to the default host, usually the screen.
  id: totrans-198
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`Get-ChildItem` has two parameter sets. The parameter that determines which
    set you use is `-LiteralPath`.'
  id: totrans-199
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`*.exe` is being passed to the `-filter` parameter. If you look at the help
    file, you can see that `-filter` is a positional parameter with a position of
    1, so the second value without a specified parameter will be understood as a filter
    argument.'
  id: totrans-200
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: No. the `-Filter` parameter only takes a single argument. If you want this cmdlet
    to run, then `Get-ChildItem c:\foo\* -include *.exe, *.txt` will work.
  id: totrans-201
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`Find-module *aws*` will find lots of official modules for working with AWS,
    provided by Amazon.'
  id: totrans-202
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: At the time of writing, there aren’t any on the PowerShell Gallery, but there
    are some on GitHub. I’m not sure how official they are, though. Be wary.
  id: totrans-203
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Holding the *Ctrl* key and scrolling the mouse wheel is the easiest temporary
    way of doing it. *Ctrl* and *+* (plus) or *Ctrl* and *-* (minus) will also do
    it. To change it permanently, open **Settings**, click on the profile you wish
    to change, and go into the **Appearance** subsection.
  id: totrans-204
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[Chapter 3](B17600_03.xhtml#_idTextAnchor049)'
  id: totrans-205
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Activities
  id: totrans-206
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We can combine `-first`, `-last`, and `-skip` to do this, like so:'
  id: totrans-207
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  id: totrans-208
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '![Figure A.3 – Output when we use first, last, and skip](img/B17600_Assessments_003.jpg)'
  id: totrans-209
  prefs: []
  type: TYPE_IMG
- en: Figure A.3 – Output when we use first, last, and skip
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
- en: This is because `-contains` doesn’t support wildcards. The value must match
    exactly, except that it is not case sensitive.
  id: totrans-211
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`Get-Command -ParameterName filter` will do this for us. If you run it, you
    will see that there are lots of them. Most of them make use of the same `filter`
    block syntax we’ve been looking at in this chapter.'
  id: totrans-212
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Exercises
  id: totrans-213
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`Get-Command` will let us find the `Get-Date` cmdlet. Next, we need to use
    `Get-Member` to see the properties of the object that `Get-Date` produces. Finally,
    we need to use `Select-Object` to just show the `DayOfWeek` property – **Day**
    returns the day of the month.'
  id: totrans-214
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`path` isn’t a property that is displayed when we run `Get-Process`, so we
    will need to use `Get-Member` to find it.'
  id: totrans-215
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Get-Process | select-object name, cpu, path | sort-object** **path -descending**'
  id: totrans-216
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Simple.
  id: totrans-217
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`Where-Object` needs to come early. Remember, *filter left*.'
  id: totrans-218
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'It’s best to make use of the filtering properties of a cmdlet rather than passing
    everything through the pipeline to `Where-Object`, so the following code is the
    most efficient way:'
  id: totrans-219
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  id: totrans-220
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: ForEach-Object interactively.
  id: totrans-221
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE17]'
  id: totrans-222
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '`Get-Content` is the cmdlet you need, and we’ll be covering this in [*Chapter
    6*](B17600_06.xhtml#_idTextAnchor117), *PowerShell and Files – Reading, Writing,
    and Manipulating Data*. You will remember from the work we have done earlier in
    this chapter that the `-Name` parameter for `Get-Process` doesn’t accept objects
    `ByValue`, only `ByProcessName`, so we can’t use `Get-Content` to grab the list
    of names. Instead, we must use parentheses and feed them directly to the `-``Name`
    parameter.'
  id: totrans-223
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'It won’t run like that; although the `-computername` parameter accepts a `system.string`
    object, it does so `ByPropertyName`, not `ByValue`. The correct way to run this
    is as follows:'
  id: totrans-224
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  id: totrans-225
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: '[Chapter 4](B17600_04.xhtml#_idTextAnchor071)'
  id: totrans-226
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Activities
  id: totrans-227
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: It’s all about memory. As we mentioned, the stack has limited space, and value-type
    objects are held in the stack. Therefore, it makes sense to conserve memory as
    much as possible while being transparent to the human writing the code. `[Int64]`
    type objects take up twice as much space on the stack as `[Int32]` type objects.
  id: totrans-228
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`MyString` has been told to take the contents of `MyVariable`, the integer
    `42`, and treat it as a string. We can subsequently put an integer in `MyString`,
    because we didn’t constrain it in any way when we created it.'
  id: totrans-229
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Doing it the other way around, with `[string]$MyOtherString`, constrains `MyOtherString`
    to only be able to contain strings.
  id: totrans-230
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Exercises
  id: totrans-231
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There’s a space in there – spaces aren’t allowed. If we really must use a space
    in the variable name, then we must enclose it in curly braces – `{My Variable}`,
    which is arguably more work than using a variable name that doesn’t include a
    space.
  id: totrans-232
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`System.Management.Automation.PSVariable`, `PSVariable`, or even `Variable`.'
  id: totrans-233
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Use the preference variable `$ErrorView`. By default, it is set to `ConciseView`,
    a shorter, reader-friendly message containing just the error. This was introduced
    in PowerShell 7.0 and replaced a slightly more oblique format. This old format
    can still be seen by setting `$ErrorView` to `NormalView`. Interestingly, the
    PowerShell documentation lists `$ErrorView` as both a preference and an automatic
    variable – I suspect this is wrong; I think it’s a preference variable.
  id: totrans-234
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`$Null` will do this. `$Null` is different from 0 and is still a value; it’s
    just an empty value.'
  id: totrans-235
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'We can use the `CompareTo()` method. This will give us three possible outputs:
    `0` if the integers are the same, `-1` if the first integer is smaller than the
    second, or `1` if it is larger. Try the following:'
  id: totrans-236
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  id: totrans-237
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: This sort of thing will come in handy in the next chapter, [*Chapter 5*](B17600_05.xhtml#_idTextAnchor096),
    *PowerShell Control Flow – Conditionals and Loops*, where we will be looking at
    conditional statements.
  id: totrans-238
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: It’s a `System.Array` object or array.
  id: totrans-239
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`MyString.ToCharArray()` will output each `char` as an element of an array
    on a separate line.PowerShell Variables and Data Structures 34'
  id: totrans-240
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Because we are only using single quote marks, the output will be `My Name is
    $MyName`. If we want the variable to be expanded, we must use double quotes.
  id: totrans-241
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'This is the `TypeName` of an ordered hashtable, and we can create it using
    the `[ordered]` accelerator. Remember, this goes on the right-hand side of the
    statement, not the left, like so:'
  id: totrans-242
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  id: totrans-243
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: '[Chapter 5](B17600_05.xhtml#_idTextAnchor096)'
  id: totrans-244
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Activities
  id: totrans-245
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Because the switch is `7 { Write-Output 'contains 7' }`, which is looking for
    an integer. The line it is searching is a string, and so contains no integers.
    If we replaced the `7` in the `switch` statement with `'*7'`, making it a string,
    then it would work.
  id: totrans-246
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: It’s because we’re executing the increment statement before we write the output.
    Switching the two statements around would demonstrate that the scriptblock doesn’t
    execute when the condition isn’t met.
  id: totrans-247
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Exercises
  id: totrans-248
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: None. The statement only produces output if `$x` is larger than 4\. There is
    no `else` statement here to produce alternative output. This is a true conditional
    statement, rather than a conditional that provides alternate flows.
  id: totrans-249
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`$x = 4 ; IF ($x -gt 4) {Write-Host ''$x is larger than 4''}Else {Write-Host
    ''$x is not larger` `than 4''}`'
  id: totrans-250
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`$x = 4 ; IF ($x -gt 4) {Write-Host ''$x is larger than 4''}elseif ($x -lt
    4) {Write-Host ''$x is smaller than 4''} Else {Write-Host ''$x` `is 4''}`'
  id: totrans-251
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`$x = 4 ; ($x -gt 4) ? (Write-Host ''$x is larger than 4'') : (Write-Host ''$x
    is not larger` `than 4'')`'
  id: totrans-252
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Because `foreach` is after a pipe character, there is only a single statement
    here, and `foreach` is interpreted as an alias of `ForEach-Object`, so the syntax
    is wrong. We can make it right by replacing the pipe character with a semicolon.
    This separates it into two statements, and `foreach` is correctly interpreted:'
  id: totrans-253
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  id: totrans-254
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: '`number = 0 ; Do {$number ++ ; Write-Host "Number is $number"} While (!($number
    -eq 5))` will work. We’ll see that construction using the `not` operator alias
    (`!`) to reverse a statement quite often.'
  id: totrans-255
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 't’s missing the iterator. This will work: `for ($i = 0 ; $i -lt 5 ; $i ++)
    {``Write-Host $i}.`'
  id: totrans-256
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`switch` statements. Using them outside loops and `switch` statements can lead
    to unpredictable outcomes.'
  id: totrans-257
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'There are a few ways to do this; any that work are right, but my solution involves
    substituting a `for` loop instead of the existing `while` loop to implement the
    counter. I’ve also added an extra `elseif` statement to handle a winning condition,
    like this:'
  id: totrans-258
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure A.4 – Guess limited Brucie](img/B17600_Assessments_004.jpg)'
  id: totrans-259
  prefs: []
  type: TYPE_IMG
- en: Figure A.4 – Guess limited Brucie
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
- en: There are lots of ways of writing this on the internet – I’ve chosen this way
    just to use concepts that we’ve covered in this chapter.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
- en: '[Chapter 6](B17600_06.xhtml#_idTextAnchor117)'
  id: totrans-262
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Activity
  id: totrans-263
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'This is just one way of doing it. If you got something different that worked,
    well done. That’s the right way – one of them, anyway. According to *Exercises
    in Programming Style*, there are at least 41 others:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Here it is running:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure A.5 – The ten most frequent words in an English translation of The
    Trial](img/B17600_Assessments_005.jpg)'
  id: totrans-267
  prefs: []
  type: TYPE_IMG
- en: Figure A.5 – The ten most frequent words in an English translation of The Trial
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s step through it quickly:'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
- en: Lines 1 and 2 bring our two files into PowerShell using `Get-Content`, in `Raw`
    format as single strings.
  id: totrans-270
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Line 3 adds some extra delimiters and removes empty strings. I don’t expect
    you to know about the string split options, so I gave you this in the hint.
  id: totrans-271
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Line 5 creates an empty array list to hold interesting words; if we used a PowerShell
    array, this would be painfully slow.
  id: totrans-272
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Line 7 starts a `Foreach` loop to step through each word in `$TrialWords`.
  id: totrans-273
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Line 8 creates a variable and casts each word to lowercase into it each time
    the loop repeats.
  id: totrans-274
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Line 9 starts an `if` statement matching the condition “`$Lword` is not in `$StopWords`.”
    Note we are using the `-Contains` method, which matches substrings in a single
    string, so it is searching the `$StopWords` string for substrings that match `$LWord`.
  id: totrans-275
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Line 10 adds `$Word` to the `$Words` array list if the condition is true.
  id: totrans-276
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Line 13 groups and sorts the words in `$Words`.
  id: totrans-277
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Line 14 returns the 10 most frequent words, in descending order.
  id: totrans-278
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Exercises
  id: totrans-279
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Get-Childitem -Path C:\Temp -File | Format-Wide -****Column 3**'
  id: totrans-280
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Get-Process | Format-Wide -column 5 | Where-Object id -****gt 100**'
  id: totrans-281
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'It will produce no output. Remember, **Format Right**. The correct code should
    be as follows:'
  id: totrans-282
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE23]'
  id: totrans-283
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: '**“I love PowerShell” | Out-File -****Path Q3.txt**'
  id: totrans-284
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**“Sooo much” | Out-File -Path** **Q3.txt -Append**'
  id: totrans-285
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Get-ChildItem | Export-Csv -Path items.csv -****Delimiter “;”**'
  id: totrans-286
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**(****Get-ChildItem Function:).count**'
  id: totrans-287
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Get-Content Q3.txt -Delimiter “ “** Or **(Get-Content** **Q3.txt).Split(“
    “)**'
  id: totrans-288
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`PSCustomObjects`.'
  id: totrans-289
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Import-Clixml: Element ‘Objs’ with namespace name ‘http:// schemas.microsoft.com/powershell/2004/04’
    was** **not found.**'
  id: totrans-290
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The XML file we are trying to import wasn’t formatted correctly for the cmdlet
    or it isn’t a PowerShell object.
  id: totrans-291
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[Chapter 7](B17600_07.xhtml#_idTextAnchor140)'
  id: totrans-292
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Activity
  id: totrans-293
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Here is my solution:'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure A.6 – One solution](img/B17600_Assessments_006.jpg)'
  id: totrans-295
  prefs: []
  type: TYPE_IMG
- en: Figure A.6 – One solution
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
- en: 'Line 2 grabs the data in JSON format from the API and puts it in a variable.
    If we look at the `$astronauts` variable, we can see it has two key-value pairs,
    `message` and `people`. `people` contains an array of JSON objects, which themselves
    have two key-value pairs; `name` and `craft`. We can see this in the following
    figure:'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure A.7 – Getting the JSON data](img/B17600_Assessments_007.jpg)'
  id: totrans-298
  prefs: []
  type: TYPE_IMG
- en: Figure A.7 – Getting the JSON data
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
- en: So, we know the data we need are in the `$astronauts.people.name` key-value
    pair. All we need to do now is display it in a pleasing manner. We covered how
    to use `ConvertTo-Html` in [*Chapter 6*](B17600_06.xhtml#_idTextAnchor117), *PowerShell
    and Files – Reading, Writing, and Manipulating Data*, and this is the way I’ve
    chosen.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
- en: 'On line 5, we set up a `$params` hashtable so we can splat all the parameters
    we need. I’ve chosen to include a CSS stylesheet that displays a lovely image,
    but that’s not necessary. This is my CSS:'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  id: totrans-302
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Finally, the magic happens on line 12\. We feed the values we are interested
    in into `ConvertTo- Html` via the pipeline and then use `Out-File` to write the
    HTML to a file. We can then open this file in the browser of our choosing.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
- en: Hopefully, this has shown you how easy it is to obtain, manipulate, and display
    data using an API.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
- en: Exercises
  id: totrans-305
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Invoke-WebRequest -Uri ‘https://httpbin.org/delete’ -****Method Delete**'
  id: totrans-306
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We use the `-SessionVariable` parameter in the first request (usually a login
    request) to supply a string, and then, in subsequent requests, we supply the session
    variable as a variable using the `-``WebSession` parameter.
  id: totrans-307
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We can use the `-SkipCertificateCheck` parameter, but we should only do this
    if we’re really sure that the site is valid and not malicious.
  id: totrans-308
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The mistake we made is in encoding the token before supplying it via the header.
    Encode the token to supply it as a parameter and keep it in plain text for headers.
    This means that supplying it as a parameter is slightly more secure, but not all
    services will accept it that way.
  id: totrans-309
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: WebSocket APIs are usually stateful. This means information about the requestor
    is persisted through multiple requests; this makes it more complicated to use,
    as we need to persist session information, and susceptible to network conditions.
  id: totrans-310
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'There are lots of ways to do this, but the most straightforward is probably
    this:'
  id: totrans-311
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  id: totrans-312
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: We can either pass it a long string describing the custom schema using the `-Schema`
    parameter, or we can pass it a file location using `-SchemaFile`. You’re right!
    This isn’t in the chapter. You hopefully read the help file to get the answer.
  id: totrans-313
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[Chapter 8](B17600_08.xhtml#_idTextAnchor162)'
  id: totrans-314
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Activities
  id: totrans-315
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The easy way to do this is to create an `$Output` variable in the `Param()`
    block, and pass that as a parameter to the `Out-File` cmdlet in the script, like
    this:'
  id: totrans-316
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  id: totrans-317
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'The trouble with that is if we want to change the filename, we need to type
    both the filename and the path each time. It’s likely that we will want to change
    the filename far more often than we want to change the path. Let’s separate out
    the path and the filename like this:'
  id: totrans-318
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure A.8 – Separating the filename and file path](img/B17600_Assessments_008.jpg)'
  id: totrans-319
  prefs: []
  type: TYPE_IMG
- en: Figure A.8 – Separating the filename and file path
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
- en: Now, we can just pass a different filename when we want to, and a different
    path if we want to, without having to type out the whole thing each time.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
- en: 'From the help file of a cmdlet that has a parameter that takes multiple strings,
    we can see that the attribute contains an empty pair of square brackets, like
    this: `[string[]]`. That part is easy enough. We also need to process each element
    of the array that is then passed to the `-City` parameter. To do that, we’ll need
    a `foreach` loop as well, wrapped around the working part of the script.'
  id: totrans-322
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Finally, we’ll need some way of sending each city’s data to a separate output
    file. I’ve chosen to do that by passing the `$item` variable from the `foreach`
    loop. Here’s my solution. Yours may look different, but if it works, that’s great.
  id: totrans-323
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure A.9 – Processing multiple cities](img/B17600_Assessments_009.jpg)'
  id: totrans-324
  prefs: []
  type: TYPE_IMG
- en: Figure A.9 – Processing multiple cities
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
- en: In line `3`, I’ve added the `[string[]]` attribute to the `-City` parameter
    to allow it to take multiple strings.
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
- en: I’ve opened a `foreach` loop on line `9` and closed it on line `22`. The lines
    in between will now be repeated for each `$item` in the array of strings held
    in the `$City` parameter. I’ve also indented the lines in between to make it easier
    to read.
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
- en: I’ve changed line `17` so that it uses the `$item` variable (the current city)
    rather than the array in `$City` because that would cause an error – the API only
    accepts a single string at a time.
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
- en: Finally, I’ve changed line `11` so that it sends each output to a file that
    includes the name of the city.
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s my example. Yours may differ but, hopefully, you’ve included warnings
    about needing the API key in advance:'
  id: totrans-330
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  id: totrans-331
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Exercises
  id: totrans-332
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This might be because of a few settings, but let’s imagine it is the simplest;
    the execution policy is correct for you, but not for them. This implies that the
    `CurrentUser` policy is restricting them.
  id: totrans-333
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Using the following should do it if the script was written on the local machine,
    or if we have signed it with a code-signing certificate on another machine:'
  id: totrans-334
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE28]'
  id: totrans-335
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: The `-Maximum` parameter. I’m not aware of any *Dungeons and Dragons* dice that
    start at a number other than 1 (except for the d100, but we’ll come to that in
    a question shortly).
  id: totrans-336
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Well, there are a few ways we could do it, but hopefully, you’ve come up with
    something like this:'
  id: totrans-337
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  id: totrans-338
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: You don’t need to have the `CmdletBinding()` attribute in there, but I always
    put it in.
  id: totrans-339
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'It should be an integer, and we’d specify it with the `[``int]` attribute:'
  id: totrans-340
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  id: totrans-341
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'So, if we read the link, we can see that we can assign the `ValidateSet` attribute
    to a parameter and pass it an array of legal values, which looks like this:'
  id: totrans-342
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  id: totrans-343
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'To do this, we’re going to need a loop and to specify the number of times we
    run the loop with a parameter, then add the output of each loop to a running total.
    It might look like this:'
  id: totrans-344
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  id: totrans-345
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'This is because there is no default value assigned for `$Dice`. We could assign
    it a default, but it might be better to make it a mandatory parameter by adding
    `[Parameter(Mandatory)]` like this:'
  id: totrans-346
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  id: totrans-347
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE33]'
- en: We could make both parameters mandatory and include a `HelpMessage` attribute
    that explains what to put for each parameter.
  id: totrans-348
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: So, the first thing to do is to add the value of `100` to the `ValidateSet`
    attribute of the `$``sides` parameter.
  id: totrans-349
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Once that’s done, we need to treat the value of `100` differently, so we can’t
    just add it to the loop. I’ve used an `if` and an `else` statement. Here’s my
    resulting script:'
  id: totrans-350
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure A.10 – My level 15 paladin will crush your chaotic evil cleric](img/B17600_Assessments_010.jpg)'
  id: totrans-351
  prefs: []
  type: TYPE_IMG
- en: Figure A.10 – My level 15 paladin will crush your chaotic evil cleric
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
- en: Remember, there are lots of ways to do this; if your code is completely different
    to mine but it works, that’s fine.
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
- en: '[Chapter 9](B17600_09.xhtml#_idTextAnchor184)'
  id: totrans-354
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Activities
  id: totrans-355
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Nothing, because our parameter is not written to accept pipeline input. As
    we discovered in [*Chapter 8*](B17600_08.xhtml#_idTextAnchor162), *Writing Our
    First Script – Turning Simple Cmdlets into Reusable Code*, to allow a parameter
    to accept pipeline input, we must add a parameter argument, like this:'
  id: totrans-356
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure A.11 –  Accepting values from the pipeline](img/B17600_Assessments_011.jpg)'
  id: totrans-357
  prefs: []
  type: TYPE_IMG
- en: Figure A.11 – Accepting values from the pipeline
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
- en: On line `9`, we’ve added a `ValueFromPipeline` argument to the parameter, which
    allows it to accept values from the pipeline. We’ve also enclosed the function
    in a `process` block, opening on line `12` and closing on line `20`; if we don’t
    have a `process` block, then the function will only act on the last value in the
    pipeline.
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
- en: Because `Get-Random` only accepts one positional parameter, `-Maximum`. If we
    run it as previously, then the maximum will be set as `15`, and the cmdlet has
    no idea what to do with the `20` value. Similarly, `Get-Fifteen20 15 -maximum
    20` won’t work because the `-Maximum` parameter is already filled by the named
    value, `20`, so it doesn’t know what to do with the `15` value. `Get-Fifteen20
    -minimum 15 20` will work, however.
  id: totrans-360
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'There are lots of ways to do this, as always. My method is as follows:'
  id: totrans-361
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  id: totrans-362
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE34]'
- en: I’ve created a function called `Remove-Log` that I can call in my script. I’ve
    created a variable called `$limit` that gets a date seven days less than when
    it is run. I then get all the items in the `C:\temp` directory that start with
    the string `MyLogFile`, using a wildcard. I’ve then filtered the list using `Where-Object`
    to select only the files older than my `$limit` date. Finally, I’ve piped that
    to `Remove-Item` with the `-Force` parameter to suppress any confirmations.
  id: totrans-363
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Exercises
  id: totrans-364
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Avoid Hasty Abstractions – it’s a software engineering principle that encourages
    us to only create an abstraction, such as a function, when we know we will need
    it and we know exactly what we need it to do.
  id: totrans-365
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Because dot sourcing causes whatever it is calling to be run in the local, or
    parent, scope rather than the appropriate child scope.
  id: totrans-366
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Because just calling the variable will produce the code in the scriptblock;
    it won’t run it. We need to use the `invoke()` method, the call operator, or the
    `Invoke-Command` cmdlet. What we shouldn’t do is dot source it without careful
    consideration.
  id: totrans-367
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The `ValidatePattern` validation attribute should do it, but we’d need to use
    a regular expression. Ugh! Hopefully, you looked this up in the help file mentioned
    in the *Further* *reading* section.
  id: totrans-368
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Because filters expect pipeline input, and we haven’t supplied any. However,
    `365 | get-square` would work.
  id: totrans-369
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We’re preventing the `$number` variable from being accessed from another scope.
  id: totrans-370
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A function is named, whereas a scriptblock is anonymous.
  id: totrans-371
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We’re trying to feed a value through the pipeline, but there’s no parameter
    that accepts pipeline input. We need to either make it an advanced function and
    create a parameter that accepts pipeline input, or we need to use `$Args`.
  id: totrans-372
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'We will write the function as follows:'
  id: totrans-373
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  id: totrans-374
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'We can use it like this:'
  id: totrans-375
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure A.12 – Getting a root the easy way](img/B17600_Assessments_012.jpg)'
  id: totrans-376
  prefs: []
  type: TYPE_IMG
- en: Figure A.12 – Getting a root the easy way
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
- en: '[Chapter 10](B17600_10.xhtml#_idTextAnchor201)'
  id: totrans-378
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Activities
  id: totrans-379
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `-ErrorAction` parameter will override the `$ErrorActionPreference` variable,
    and the `nosuchfile` string will cause a terminating error. Because it’s a terminating
    error, the cmdlet will not process `bar.txt`.
  id: totrans-380
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Because if there is an error, then the error object is put into the pipeline,
    replacing the string that caused the error.
  id: totrans-381
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Exercises
  id: totrans-382
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Terminating errors stop the script altogether. Non-terminating errors may stop
    the script from doing the current step, but PowerShell will move the script on
    to the next step.
  id: totrans-383
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Either with the `Get-Error` cmdlet, which displays the most recent error object,
    or with the `$Error` variable. This has an array of all the error objects created
    during a session up to a default maximum of 256.
  id: totrans-384
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The `-ErrorActionPreference` variable allows us to set the default error action
    preference for all cmdlets and scripts running in a specific PowerShell session.
    It determines whether errors should be displayed, ignored, or handled in a specific
    way.
  id: totrans-385
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The `Write-Error` cmdlet allows us to manually generate and display custom non-terminating
    error messages within a script. It is useful when we want to explicitly signal
    an error condition to the user or the calling code.
  id: totrans-386
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: To generate a terminating error that can be handled by a `try`/`catch` statement
    pair.
  id: totrans-387
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: By either using the `-Debug` parameter with a cmdlet or advanced script or by
    setting the `$DebugPreference` variable to `Continue`; the default is `SilentlyContinue`.
  id: totrans-388
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: By using the `Write-Debug` cmdlet in the script. Debug messages are for people
    who write code; error messages are for people who use code. As such, a debug message
    should include detailed information about what is going on in the script at that
    point, possibly including variable values and step counts.
  id: totrans-389
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A breakpoint is a marker set in the script to pause its execution at a specific
    line or condition. It allows us to inspect the state of the script and variables
    at that point. A break point in tennis is quite different.
  id: totrans-390
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: It executes the current line of a script and moves on to the next line but treats
    whole functions as a single line. So, if the next line of code is a function,
    or we are currently in a function, then the whole function call will complete,
    rather than moving on to the next line in the function.
  id: totrans-391
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[Chapter 11](B17600_11.xhtml#_idTextAnchor218)'
  id: totrans-392
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Activity
  id: totrans-393
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Try running `Remove-Module` to get rid of the module we’ve just installed, and
    then running `Get-Square`. What happens? Why does this happen?
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
- en: 'The `Get-Square` cmdlet is still available. This is because we saved the module
    in the module path correctly; this means that PowerShell will autoload the module
    when we call a function in the module. We can see it working in the following
    screenshot:'
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure A.13 – Autoloading with PowerShell](img/B17600_Assessments_013.jpg)'
  id: totrans-396
  prefs: []
  type: TYPE_IMG
- en: Figure A.13 – Autoloading with PowerShell
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
- en: In the first line, I list the loaded modules. Then, I run `Get-Square 7`, which
    autoloads `MyFirstModule`. After that, I confirm that’s what happened by running
    `Get-Module` again. We can see that `Remove-Module` removes the `Get-Square` cmdlet
    by running it with the `-Verbose` switch in the last line.
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
- en: Exercises
  id: totrans-399
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Get-Module**'
  id: totrans-400
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: It imports a module into the global scope. Note that when we import a module
    from the command prompt, it is already imported into the global scope – we use
    this when we’re importing a module from inside another module; a nested module.
  id: totrans-401
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We need to give the full path to the module in the `-Name` parameter of `Import-Module`.
  id: totrans-402
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Either use the `-NoClobber` parameter if they are not functions we want to use
    or use the `-Prefix` parameter if they are.
  id: totrans-403
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Either with the `Export-ModuleMembers` cmdlet in the module file or with a module
    manifest.
  id: totrans-404
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: It provides a link to the online documentation for the module, allowing the
    help to be updated.
  id: totrans-405
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the context of a module, it might be either formatting information for function
    or cmdlet output, or it might be custom type information.
  id: totrans-406
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We’ll get cmdlets; a `.dll` extension signifies a binary module, so the commands
    inside it will be of the `Cmdlet` type. Script modules contain commands of the
    `Function` type.
  id: totrans-407
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Because they are slow. The CDXML gets parsed to a PowerShell script, which then
    has to be interpreted.
  id: totrans-408
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[Chapter 12](B17600_12.xhtml#_idTextAnchor236)'
  id: totrans-409
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Exercises
  id: totrans-410
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`New-PSSession` creates a persistent session, but an ad hoc session can be
    created with `Enter- PSSession`.'
  id: totrans-411
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: By using SSH.
  id: totrans-412
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The `AllSigned` execution policy only allows scripts signed by a trusted publisher
    to run.
  id: totrans-413
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The `-ExecutionPolicy Bypass` switch is used to temporarily bypass an execution
    policy when running a script.
  id: totrans-414
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: PowerShell AMSI.
  id: totrans-415
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The constrained language mode is used to restrict access to dangerous cmdlets
    and scripting features in PowerShell.
  id: totrans-416
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: By using JEA.
  id: totrans-417
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Script block logging records the content of script blocks executed in PowerShell,
    providing visibility into potentially malicious actions. It records the contents
    in the `PowerShellCore` operational event log in Windows and in the systemd log
    in Linux.
  id: totrans-418
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A secure string is a PowerShell object of type `System.Security.SecureString`,
    and an encrypted string is a string object that has been encrypted with a key
    so that it cannot be read in a file.
  id: totrans-419
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[Chapter 13](B17600_13.xhtml#_idTextAnchor267)'
  id: totrans-420
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Activities
  id: totrans-421
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We could write a fairly complicated cmdlet with `Invoke-CimMethod`, but that
    isn’t the best way to do it. Instead, we should use the cmdlet specifically written
    for this purpose, `Stop- Process`, with the `ProcessId` of the `notepad` process:'
  id: totrans-422
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE36]'
  id: totrans-423
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE36]'
- en: '![Figure A.14 – Setting a default printer with CIM commands](img/B17600_Assessments_014.jpg)'
  id: totrans-424
  prefs: []
  type: TYPE_IMG
- en: Figure A.14 – Setting a default printer with CIM commands
  id: totrans-425
  prefs: []
  type: TYPE_NORMAL
- en: In the first command, I put the printer object into a variable, then I used
    that variable as the input object for `Invoke-CimMethod` and invoked the `SetDefaultPrinter`
    method. The return value of `0` indicates success.
  id: totrans-426
  prefs: []
  type: TYPE_NORMAL
- en: 'Note that the `SetDefaultPrinter` method doesn’t appear on the `$printer` variable.
    Unfortunately, we need to read the documentation to discover this method:'
  id: totrans-427
  prefs: []
  type: TYPE_NORMAL
- en: '[https://learn.microsoft.com/en-us/windows/win32/cimwin32prov/win32-printer-methods](https://learn.microsoft.com/en-us/windows/win32/cimwin32prov/win32-printer-methods)'
  id: totrans-428
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://learn.microsoft.com/en-us/windows/win32/cimwin32prov/setdefaultprinter-method-in-class-win32-printer](https://learn.microsoft.com/en-us/windows/win32/cimwin32prov/setdefaultprinter-method-in-class-win32-printer)'
  id: totrans-429
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Exercises
  id: totrans-430
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Manifest modules.
  id: totrans-431
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: It may have been written before PowerShell Core was released, the author may
    not have included compatibility information in the manifest, or it may not be
    a manifest module.
  id: totrans-432
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Windows PowerShell 5.1.
  id: totrans-433
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Deserialized ones.
  id: totrans-434
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Use the `-``UseWindowsPowershell` parameter.
  id: totrans-435
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`__NAMESPACE`'
  id: totrans-436
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: It allows us to specify a different timeout when querying remote machines, as
    the default is 3 minutes per machine.
  id: totrans-437
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Possibly we could use `Set-CimInstance`, but because many properties are not
    writable, we more likely will use `Invoke-CimMethod`.
  id: totrans-438
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We pass them as an i`Dictionary` hash table to the `-``Arguments` parameter.
  id: totrans-439
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[Chapter 14](B17600_14.xhtml#_idTextAnchor280)'
  id: totrans-440
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Activity
  id: totrans-441
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Because PowerShell is very forgiving about file path separators, the only bit
    of code that needs to be different depending on the platform is how we get the
    name of the machine. Everything else is straightforward. Here’s my solution; yours
    could be very different and still achieve the task:'
  id: totrans-442
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  id: totrans-443
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Because we need to use different ways to get the machine name, those two lines
    are within `if` statements. Everything else works the same on Linux and Windows,
    so it’s very straightforward. This is how it looks running on my CentOS box:'
  id: totrans-444
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure A.15 – Running a cross-platform script on CentOS](img/B17600_Assessments_015.jpg)'
  id: totrans-445
  prefs: []
  type: TYPE_IMG
- en: Figure A.15 – Running a cross-platform script on CentOS
  id: totrans-446
  prefs: []
  type: TYPE_NORMAL
- en: As we can see, it works just fine. The script would be better for some error
    checking; for instance, what if both automatic variables are `false`?
  id: totrans-447
  prefs: []
  type: TYPE_NORMAL
- en: Exercises
  id: totrans-448
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The internet. As with most Linux distributions, Kali Linux is not supported
    by Microsoft.
  id: totrans-449
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Trick question. We are actually calling the `ls` Bash command on Linux. When
    we type it on Windows, we are calling `Get-ChildItem` via the `ls` alias.
  id: totrans-450
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Either `\` or `/`. It doesn’t matter, thankfully. This means it’s a lot easier
    to write cross-platform scripts.
  id: totrans-451
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: By calling the `$IsMacOS` variable. If it returns `true`, then we are running
    on macOS.
  id: totrans-452
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: By starting PowerShell with the `sudo pwsh` command. There is no way to elevate
    privilege during a PowerShell session.
  id: totrans-453
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`New-PSSession` with the `-``HostName` parameter.'
  id: totrans-454
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`New-PSSession` and the `-``KeyFilePath` parameter.'
  id: totrans-455
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: It’s a file transfer program that is included in the PowerShell 7 packages.
  id: totrans-456
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Ed25519 is a recent, more secure encryption algorithm for digital signatures
    based on public/private keys.
  id: totrans-457
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[Chapter 15](B17600_15.xhtml#_idTextAnchor302)'
  id: totrans-458
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Answers
  id: totrans-459
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Because the Zero and Pico use an ARMv6 chip architecture, which isn’t compatible
    with .NET since it requires ARMv7 or ARMv8.
  id: totrans-460
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Either `C:\Users\<username>\.sshconfig` or `C:\ProgramData\ssh\ssh_config`.
  id: totrans-461
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Test-NetConnection**'
  id: totrans-462
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**ssh <username>@<hostname>**'
  id: totrans-463
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**sudo** **bash ./install.sh**'
  id: totrans-464
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Because it’s a pain typing `~/powershell/pwsh`.
  id: totrans-465
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**sudo ln -s ~/****powershell/pwsh /usr/bin/pwsh**'
  id: totrans-466
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Use the `-Raw` switch parameter with the `Get-GpioPin` cmdlet.
  id: totrans-467
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Debian Linux, similar to Ubuntu.
  id: totrans-468
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[Chapter 16](B17600_16.xhtml#_idTextAnchor320)'
  id: totrans-469
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Exercises
  id: totrans-470
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**$object = New-Object -****TypeName Namespace.ClassName**'
  id: totrans-471
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Add-Type -****AssemblyName “AssemblyName”**'
  id: totrans-472
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**[****Namespace.ClassName]::MethodName()**'
  id: totrans-473
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**[****Namespace.ClassName]::PropertyName**'
  id: totrans-474
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**$object = New-Object -TypeName Namespace.ClassName -ArgumentList (arg1,**
    **arg2, ...)**'
  id: totrans-475
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Add-Type -****Path “Path\To\Assembly.dll”**'
  id: totrans-476
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Using $object.GetType()**'
  id: totrans-477
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**$object | Get-Member -****MemberType Method**'
  id: totrans-478
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**$****object.MethodName()**'
  id: totrans-479
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**$****object.PropertyName**'
  id: totrans-480
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
