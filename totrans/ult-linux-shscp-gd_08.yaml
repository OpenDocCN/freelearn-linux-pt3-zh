- en: '8'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '8'
- en: Basic Shell Script Construction
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 基本 Shell 脚本构建
- en: Yeah, I know. You’re dying to start creating some shell scripts, but haven’t
    been able to do that yet. So, in this chapter, we’ll look at the basics of shell
    script construction. We’ll then wrap things up by looking at some shell scripts
    that are both practical and useful.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 是的，我知道，你迫不及待想开始编写一些 shell 脚本，但还没有机会做到。所以，在本章中，我们将学习 shell 脚本构建的基础知识。然后，我们将通过一些既实用又有用的
    shell 脚本来总结内容。
- en: Many of the techniques that I’m presenting in this chapter work for any shell,
    but I’ll also present some that might only work on `bash`. So, just to keep things
    simple though, I’ll be sticking with `bash` for now. In *Chapter 22, Using the
    zsh Shell*, I’ll show you techniques that are specific to `zsh`. In *Chapter 19,
    Shell Script Portability*, I’ll show you techniques that will work on a wide variety
    of shells.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中我介绍的许多技巧适用于任何 shell，但我也会介绍一些可能仅适用于`bash`的技巧。所以，为了简化起见，我现在将继续使用`bash`。在*第
    22 章，使用 zsh Shell*中，我会向你展示一些特定于`zsh`的技巧。在*第 19 章，Shell 脚本移植性*中，我会向你展示一些可以在各种 shell
    上工作的技巧。
- en: 'The topics that you’ll see in this chapter include:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中将涉及的主题包括：
- en: Understanding basic shell script construction
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解基本的 shell 脚本构建
- en: Performing tests
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 执行测试
- en: Understanding subshells
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解子 shell
- en: Understanding scripting variables
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解脚本变量
- en: Understanding array variables
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解数组变量
- en: Understanding variable expansion
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解变量扩展
- en: Understanding command substitution
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解命令替换
- en: Understanding decisions and loops
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解决策和循环
- en: Understanding positional parameters
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解位置参数
- en: Understanding exit codes
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解退出码
- en: More information about echo
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 更多关于 echo 的信息
- en: Looking at some real-world examples
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 查看一些真实世界的例子
- en: All right, if you’re ready, let’s jump in.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，如果你准备好了，我们就开始吧。
- en: Technical Requirements
  id: totrans-18
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: Use any Linux distro that has `bash` installed. If you’re a Mac user, you’ll
    want to use one of your Linux virtual machines, because some of the scripts use
    commands that won’t work on macOS. Feel free to follow along on your local machine
    as you go through this chapter, but also be aware that I will provide some actual
    hands-on labs.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 使用任何已安装`bash`的 Linux 发行版。如果你是 Mac 用户，你可能需要使用其中一个 Linux 虚拟机，因为一些脚本使用的命令在 macOS
    上无法运行。你可以在本地机器上跟随本章的内容，但也要知道，我将提供一些实际的动手实验。
- en: I’ve also included one hands-on exercise that uses a FreeBSD virtual machine.
    Create the FreeBSD virtual machine and install both `sudo` and `bash`, as I showed
    you in the book’s *Preface*.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 我还包含了一个使用 FreeBSD 虚拟机的动手练习。创建 FreeBSD 虚拟机并安装`sudo`和`bash`，就像我在本书的*前言*中所展示的那样。
- en: 'Also, as I explained in the *Preface*, you can download the scripts from the
    Github repository by doing:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 另外，正如我在*前言*中所解释的，你可以通过以下方式从 Github 仓库下载脚本：
- en: '[PRE0]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Understanding Basic Shell Script Construction
  id: totrans-23
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解基本的 Shell 脚本构建
- en: The first thing you’ll need to do when creating a shell script is to define
    which shell you want to use to interpret the script.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 创建 shell 脚本时，你首先需要做的就是定义你希望使用的 shell 来解释脚本。
- en: You might have a particular reason for choosing one shell over another. That’s
    something we’ll talk about in *Chapter 19, Shell Script Portability*, and *Chapter
    22, Using the Z Shell*.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能有选择某个 shell 而非另一个的特定原因。这是我们将在*第 19 章，Shell 脚本移植性*和*第 22 章，使用 Z Shell*中讨论的内容。
- en: 'You’ll define the shell to use as the interpreter in the **shebang line**,
    which is the first line of the script. It will look something like this:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 你将在**shebang 行**中定义要作为解释器使用的 shell，它是脚本的第一行。它的形式类似于这样：
- en: '[PRE1]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Normally of course, a line that begins with the `#` sign would indicate a comment
    that would be ignored by the shell. The shebang line--and please don’t ask me
    why it’s called that--is an exception to that rule. In addition to defining a
    specific shell that you want to use, such as `/bin/bash` or `/bin/zsh`, you can
    also define the generic `/bin/sh` shell to make your scripts more portable, so
    that they’ll run on a wider variety of shells and operating systems. Here’s how
    that looks:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 通常情况下，以`#`符号开头的行表示注释，shell 会忽略这些行。而 shebang 行——请不要问我为什么它叫这个名字——是这个规则的例外。除了定义你想使用的特定
    shell，比如`/bin/bash`或`/bin/zsh`，你还可以定义通用的`/bin/sh` shell，使得你的脚本更加便于移植，从而能在更广泛的
    shell 和操作系统上运行。它是这样显示的：
- en: '[PRE2]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'This generic `sh` shell is supposed to make it so that you can run your scripts
    on different systems that might or might not have `bash` installed. But, it’s
    also problematic because the various shells that `sh` represents aren’t fully
    compatible with each other. Here’s the breakdown of how it works:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 这种通用的 `sh` shell 旨在让你可以在不同的系统上运行你的脚本，这些系统可能会或可能不会安装 `bash`。但它也有问题，因为 `sh` 代表的各种
    shell 之间并不完全兼容。下面是它的工作原理：
- en: On FreeBSD and possibly other **Berkeley Software Distribution** (**BSD**)-type
    systems, the `sh` executable is the old-school Bourne shell, which is the ancestor
    of the Bourne Again Shell (`bash`).
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 FreeBSD 和可能的其他 **伯克利软件分发（Berkeley Software Distribution，简称 BSD）** 类型的系统中，`sh`
    可执行文件是旧版 Bourne shell，它是 Bourne Again Shell（`bash`）的前身。
- en: On Red Hat-type systems, `sh` is a symbolic link that points to the `bash` executable.
    Be aware that `bash` can use certain programming features that the other shells
    in this list can’t use. (I’ll explain more about this in *Chapter 19, Shell Script
    Portability*.)
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 Red Hat 类型的系统中，`sh` 是指向 `bash` 可执行文件的符号链接。请注意，`bash` 可以使用其他 shell 无法使用的某些编程功能。（我将在*第
    19 章，Shell 脚本的可移植性*中进一步解释这一点。）
- en: On Debian/Ubuntu-type systems, `sh` is a symbolic link that points to the `dash`
    executable. `dash` stands for **Debian Almquist Shell**, which is a faster, more
    lightweight implementation of `bash`.
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 Debian/Ubuntu 类型的系统中，`sh` 是指向 `dash` 可执行文件的符号链接。`dash` 代表**Debian Almquist
    Shell**，它是 `bash` 的一种更快、更轻量的实现。
- en: On Alpine Linux, `sh` is a symbolic link that points to `ash`, which is a lightweight
    shell that’s part of the `busybox` executable. (On Alpine, `bash` is not installed
    by default.)
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 Alpine Linux 中，`sh` 是指向 `ash` 的符号链接，`ash` 是 `busybox` 可执行文件的一部分，是一个轻量级的 shell。（在
    Alpine 中，`bash` 默认并未安装。）
- en: On OpenIndiana, which is a **Free Open Source Software** fork of Oracle’s Solaris
    operating system, `sh` is a symbolic link that points to the `ksh93` shell. This
    shell, which is also known as the Korn shell, is somewhat, but not completely,
    compatible with `bash`. (It was created by a guy named David Korn, and has nothing
    to do with any vegetable.)
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 OpenIndiana 中，这是 Oracle 的 Solaris 操作系统的**自由开源软件（Free Open Source Software，简称
    FOSS）** 版本，`sh` 是指向 `ksh93` shell 的符号链接。这个 shell，也被称为 Korn shell，与 `bash` 有一定但不完全的兼容性。（它是由名为
    David Korn 的人创建的，与任何蔬菜无关。）
- en: On macOS, `sh` is a symbolic link that points to `bash`. (Curiously, `zsh` is
    the default login shell on macOS, but `bash` is still installed by default and
    is available for use.)
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 macOS 中，`sh` 是指向 `bash` 的符号链接。（有趣的是，`zsh` 是 macOS 默认的登录 shell，但 `bash` 仍然是默认安装的，并且可以使用。）
- en: Be aware that using `#!/bin/sh` in your scripts can be problematic. That’s because
    the various shells on the various operating systems that `#!/bin/sh` represents
    aren’t fully compatible with each other. So, let’s say that you’re creating a
    script on a Red Hat machine, on which `sh` points to `bash`. There’s a real possibility
    that the script won’t run on either a Debian or a FreeBSD machine, on which `sh`
    points to `dash` and Bourne shell, respectively. For that reason, we’ll concentrate
    on `bash` for now, and will just use `#!/bin/bash` as our shebang line. And, as
    I mentioned before, we’ll talk more about this topic in *Chapter 19, Shell Script
    Portability*.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 要注意，使用 `#!/bin/sh` 在你的脚本中可能会有问题。因为不同操作系统上 `#!/bin/sh` 代表的各种 shell 之间并不完全兼容。举个例子，假设你在一个
    Red Hat 机器上创建脚本，在该机器上 `sh` 指向 `bash`。那么，这个脚本在 Debian 或 FreeBSD 机器上可能无法运行，因为在 Debian
    上 `sh` 指向 `dash`，在 FreeBSD 上 `sh` 指向 Bourne shell。由于这个原因，我们现在将专注于 `bash`，并使用 `#!/bin/bash`
    作为我们的 shebang 行。如我之前所提到的，我们将在*第 19 章，Shell 脚本的可移植性*中详细讨论这个话题。
- en: A shell script can be as simple or as complex as your needs dictate. It can
    be just one or more normal Linux/Unix commands put together in a list, to be performed
    sequentially. Or, you can have scripts that can approach the complexity of programs
    written in a higher-level programming language, such as C.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 一个 shell 脚本可以根据你的需求简单或复杂。它可以只是将一个或多个普通的 Linux/Unix 命令按顺序放在列表中执行。或者，你也可以编写接近高级编程语言（如
    C）复杂度的脚本。
- en: Let’s start by taking a look at a very simple, one-command script.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先来看一个非常简单的单命令脚本。
- en: '[PRE3]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'This is a simple one-line script that I used to use to back up my `images`
    directory on one computer to a backup directory on a Debian computer. It uses
    `rsync`, with its appropriate options, to synchronize the two directories via
    a Secure Shell (`ssh`) session. (Although I normally don’t like to allow the root
    user to do `ssh` logins, in this case it’s necessary. Obviously, I would only
    do this on a local network, and would never do it across the Internet.) Appropriately,
    I named the script `rsync_with_debian`. Before I could run the script, I had to
    add the executable permission, like this:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我以前用来将我的 `images` 目录从一台计算机备份到 Debian 计算机的备份目录的一个简单一行脚本。它使用 `rsync`，并带有适当的选项，通过安全
    Shell (`ssh`) 会话同步这两个目录。（虽然我通常不喜欢允许 root 用户进行 `ssh` 登录，但在这种情况下它是必须的。显然，我只会在本地网络中进行此操作，绝不会在互联网上进行。）为了适当起见，我将脚本命名为
    `rsync_with_debian`。在我运行脚本之前，我需要添加可执行权限，方法如下：
- en: '[PRE4]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: On the second line of this `rsync_with_debian` script, right after the shebang
    line, you see the exact same command that I would have typed on the command-line
    if I didn’t have the script. So, you see, I’ve greatly simplified things by creating
    a script.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `rsync_with_debian` 脚本的第二行，也就是 shebang 行之后，你会看到与我如果没有脚本而直接在命令行输入的命令完全相同。可以看出，通过创建脚本，我大大简化了操作。
- en: To make this script available to all users on the system, place it in the `/usr/local/bin/`
    directory, which should be in everyone’s `PATH` setting.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 为了让所有系统用户都能使用这个脚本，需将它放在 `/usr/local/bin/` 目录下，这个目录应该在每个人的 `PATH` 设置中。
- en: Before going further, let’s reinforce what you’ve just learned with a hands-on
    lab.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 在继续之前，让我们通过一个动手实验来巩固你刚刚学到的内容。
- en: Hands-on Lab – Counting Logged-in Users
  id: totrans-46
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实验 – 统计已登录的用户
- en: This lab will help you create a shell script that shows how many users are logged
    in, and then modify it so that only unique users are listed. (This script uses
    some of the text stream filters that you learned about in the previous two chapters.)
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 这个实验将帮助你创建一个 Shell 脚本，显示当前登录的用户数量，然后修改它，使其只列出唯一的用户。（这个脚本使用了你在前两章中学到的一些文本流过滤器。）
- en: 'On one of your Linux virtual machines, create three additional user accounts.
    On your Fedora virtual machine, do it like this, except choose your own user names:'
  id: totrans-48
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在你的某一台 Linux 虚拟机上，创建三个额外的用户账户。在你的 Fedora 虚拟机上，按以下方式操作，只需选择你自己的用户名：
- en: '[PRE5]'
  id: totrans-49
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'On a Debian virtual machine, do it like this:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Debian 虚拟机上，按如下方式操作：
- en: '[PRE6]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'At the local terminal of the virtual machine, obtain its IP address, like this:'
  id: totrans-52
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在虚拟机的本地终端上，获取其 IP 地址，方法如下：
- en: '[PRE7]'
  id: totrans-53
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Open four terminal windows on your host machine. Using the IP address of your
    own virtual machine, log into your own account from one window, and then log into
    each of the other accounts from the other windows. The commands will look something
    like this:'
  id: totrans-54
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在你的主机上打开四个终端窗口。使用你虚拟机的 IP 地址，从一个窗口登录到自己的账户，然后从其他窗口登录到其他账户。命令如下所示：
- en: '[PRE8]'
  id: totrans-55
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'From the terminal window where you’re logged in, view all of the users who
    are currently logged in, like this:'
  id: totrans-56
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从你登录的终端窗口中，查看所有当前登录的用户，方法如下：
- en: '[PRE9]'
  id: totrans-57
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: You should see five users, because your own account will show up once for the
    local terminal log-in, and once for the remote `ssh` log-in.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该能看到五个用户，因为你的账户会显示一次本地终端登录的信息，并且显示一次远程 `ssh` 登录的信息。
- en: 'Create the `logged-in.sh` script, and make it look like this:'
  id: totrans-59
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建 `logged-in.sh` 脚本，并使其如下所示：
- en: '[PRE10]'
  id: totrans-60
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: I’m using the concept of **command substitution** to assign the output of the
    `who | wc -l` command to the value of the `users` scripting variable. (I’ll tell
    you more about command substitution later, so don’t stress out about it just yet.)
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 我使用了 **命令替换** 的概念，将 `who | wc -l` 命令的输出赋值给 `users` 脚本变量。（稍后我会详细讲解命令替换，所以现在不必担心它。）
- en: 'Make the script executable, like this:'
  id: totrans-62
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让脚本具有可执行权限，方法如下：
- en: '[PRE11]'
  id: totrans-63
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Now, run the script, like this:'
  id: totrans-64
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，运行脚本，方法如下：
- en: '[PRE12]'
  id: totrans-65
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'The output should look like this:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 输出应如下所示：
- en: '[PRE13]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The problem here is that there are really only four users, because your own
    username is counted twice. So, let’s fix that.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的问题是，实际上只有四个用户，因为你自己的用户名被计算了两次。所以，让我们来解决这个问题。
- en: 'Modify the `logged-in.sh` script so that it now looks like this:'
  id: totrans-69
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 修改 `logged-in.sh` 脚本，使其现在看起来如下：
- en: '[PRE14]'
  id: totrans-70
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The variable `uniqusers` is created by all of the commands that are piped to
    each other inside the `()`. The `cut` operation is delimited by a blank space
    (`-d" "`) and the first field (`-f1`) is what you will cut from the output of
    `who`. That output is piped to `sort` and then to `uniq`, which will only send
    the names of unique users to the `wc -l` command.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 变量`uniqusers`是通过所有通过管道传递到彼此之间的命令创建的。`cut`操作通过空格（`-d" "`）分隔，并且第一个字段（`-f1`）是从`who`命令输出中切割出来的内容。该输出被传递到`sort`，然后再传递到`uniq`，这将只将唯一用户的名称传递给`wc
    -l`命令。
- en: 'Run the script again, and the output should look like this:'
  id: totrans-72
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 再次运行脚本，输出应该像这样：
- en: '[PRE15]'
  id: totrans-73
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Make one last modification to the script to list the names of the unique users
    who are logged in. The completed script will look like this:'
  id: totrans-74
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对脚本做最后的修改，以列出登录用户的唯一名称。完成的脚本将如下所示：
- en: '[PRE16]'
  id: totrans-75
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Run the script again, and you should get output that looks something like this:'
  id: totrans-76
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 再次运行脚本，你应该会得到类似这样的输出：
- en: '[PRE17]'
  id: totrans-77
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Congratulations! You’ve just created your first shell script. Now, let’s do
    some testing.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 恭喜！你刚刚创建了你的第一个Shell脚本。现在，让我们进行一些测试。
- en: Performing Tests
  id: totrans-79
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 执行测试
- en: 'There will be times when your scripts will need to test for a certain condition
    before making a decision on which action to take. You might need to check for
    the existence of a certain file or directory, whether certain permissions are
    set on a file or directory, or for a myriad of other things. There are three ways
    to perform a test, which are:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 当你的脚本需要在做出行动决定之前测试某个条件时，会有一些情况。你可能需要检查某个文件或目录是否存在，文件或目录上是否设置了特定的权限，或者其他各种情况。有三种执行测试的方法，分别是：
- en: Use the keyword `test` followed by a test condition, with another command joined
    to it with either a `&&` or a `||` construct.
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用关键字`test`，后跟一个测试条件，并用`&&`或`||`结构将另一个命令与其连接。
- en: Enclose the test condition within a set of square brackets.
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将测试条件括在一对方括号中。
- en: Use an if. . .then construct
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`if...then`结构
- en: Let’s start by looking at the `test` keyword.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们首先来看一下`test`关键字。
- en: Using the test Keyword
  id: totrans-85
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用`test`关键字
- en: 'For our first example, let’s test to see whether a certain directory exists,
    and then create it if it doesn’t. Here’s how that works:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 对于第一个例子，让我们测试某个目录是否存在，如果不存在则创建它。操作如下：
- en: '[PRE18]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Now, let’s put that into the `test_graphics.sh` script:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们将其放入`test_graphics.sh`脚本中：
- en: '[PRE19]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Let’s run this script to see what we get:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们运行这个脚本，看看结果如何：
- en: '[PRE20]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: As you may have guessed, the `-d` operator stands for *directory*. The `||`
    construct causes the `mkdir` command to run if the graphics directory doesn’t
    exist. And of course, if the directory already exists, it won’t get created again.
    This is a good safety measure that can prevent you from accidentally overwriting
    any existing files or directories. (I’ll show you a chart with more `test` operators
    in just a moment.)
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你可能已经猜到的，`-d`操作符代表*目录*。`||`结构会在`graphics`目录不存在时执行`mkdir`命令。当然，如果目录已经存在，它将不会被重新创建。这是一个很好的安全措施，可以防止你不小心覆盖现有的文件或目录。（稍后我会给你展示一个包含更多`test`操作符的表格。）
- en: Now, let’s look at the second way to perform a test.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们来看第二种执行测试的方法。
- en: Enclosing a test Condition Within Square Brackets
  id: totrans-94
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将测试条件括在方括号中
- en: 'The second way to perform a test is to enclose the test condition within a
    pair of square brackets, like so:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 执行测试的第二种方法是将测试条件括在一对方括号中，如下所示：
- en: '[PRE21]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'First, note how you must have a blank space after the first bracket and before
    the second one. This tests for the existence of the `graphics` directory, just
    as the `test -d` construct did. Now, let’s put that into the `test_graphics_2.sh`
    script, like so:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，注意在第一个括号后和第二个括号前必须有一个空格。这就像`test -d`结构一样，测试`graphics`目录是否存在。现在，让我们把它放到`test_graphics_2.sh`脚本中，如下所示：
- en: '[PRE22]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Running this script will give you the exact same output as the first script.
    Now, let’s put a twist on things. Modify the `test_graphics_2.sh` script so that
    it looks like this:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 运行这个脚本将产生与第一个脚本完全相同的输出。现在，让我们来点不同的。修改`test_graphics_2.sh`脚本，使其看起来像这样：
- en: '[PRE23]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: The `!` is a negation operator, which makes the affected operator do the opposite
    of what it’s supposed to do. In this case, the `!` causes the `-d` operator to
    check for the *absence* of the `graphics` directory. To make this work properly,
    I also had to change the `||` operator to the `&&` operator. (Also, note that
    there must be a blank space between the `!` and the `-d`.)
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: '`!`是一个否定运算符，它使受影响的运算符做相反的事情。在这种情况下，`!`使`-d`运算符检查`graphics`目录的*不存在*。为了使其正确工作，我还需要将`||`运算符改为`&&`运算符。（另外，请注意`!`和`-d`之间必须有一个空格。）'
- en: 'You can also test for numerical values, like this:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以测试数值，如下所示：
- en: '[PRE24]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'You see that I’m calling up the value of the variable `var`, and testing to
    see if it is equal (`-eq`) to 0\. Instead of using a negation (`!`) here to see
    if the variable is *not* equal to 0, use the `-ne` operator. Let’s see how that
    looks in the `test_var.sh` script:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 你看到我正在调用变量`var`的值，并测试它是否等于（`-eq`）0。与其在这里使用否定（`!`）来判断变量是否*不*等于0，不如使用`-ne`运算符。我们来看一下`test_var.sh`脚本中是如何表现的：
- en: '[PRE25]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Now, let’s run it:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们来运行一下：
- en: '[PRE26]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: The third way to perform a test is to use an `if. . .then` construct, which
    we’ll briefly talk about next.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 执行测试的第三种方式是使用`if...then`结构，我们接下来会简要讲解。
- en: Using an if. . .then Construct
  id: totrans-109
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用`if...then`结构
- en: 'Using an `if. . .then` construct is handy when you have more complex test conditions.
    Here’s the most basic example, in the form of the `test_graphics_3.sh` script:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`if...then`结构在你有更复杂的测试条件时非常有用。这里是一个最基本的例子，以`test_graphics_3.sh`脚本的形式：
- en: '[PRE27]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: This construct begins with the `if` statement, and ends with the `fi` statement.
    (That’s `if` spelled backwards.) Place a semi-colon after the test condition,
    followed by the keyword `then`. After that, specify the action that you want to
    perform, which in this case is `mkdir graphics`. Although indenting the action
    block isn’t necessary in shell scripting, as it is in other languages, it does
    help make the script more readable.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 这个结构以`if`语句开始，以`fi`语句结束。（这就是`if`倒写过来的样子。）在测试条件后加上分号，然后跟上关键字`then`。之后，指定你想执行的操作，在这个例子中是`mkdir
    graphics`。尽管在Shell脚本中不像在其他语言中那样强制缩进操作块，但缩进确实有助于提高脚本的可读性。
- en: Of course, there’s a lot more to `if. . .then` constructs than just this. Not
    to worry though, because I’ll show you more about them in the *Understanding Decisions
    and Loops* section. Before we get there though, I want to show you some more concepts
    that you can use to fancy up your `if. . .then` constructs.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，`if...then`结构不仅仅是这样，还有更多内容。不过不用担心，因为在*理解决策和循环*部分，我会给你展示更多内容。在我们到达那里之前，我想先给你展示一些可以用来美化`if...then`结构的其他概念。
- en: Now, let’s look at the various other types of tests that you can do.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们来看一下你可以进行的其他各种测试。
- en: Using Other Types of Tests
  id: totrans-115
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用其他类型的测试
- en: 'There are a lot more kinds of tests that you can do, including text string
    comparisons, numerical comparisons, whether files or directories exist and what
    permissions are set on them. Here’s a chart of the more popular tests, along with
    their operators:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以进行更多种类的测试，包括文本字符串比较、数值比较、文件或目录是否存在以及它们上面设置了哪些权限。以下是更常用测试及其运算符的图表：
- en: '| **Operator** | **Test** |'
  id: totrans-117
  prefs: []
  type: TYPE_TB
  zh: '| **运算符** | **测试** |'
- en: '| `-b filename` | True if a block device file with the specified filename exists.
    |'
  id: totrans-118
  prefs: []
  type: TYPE_TB
  zh: '| `-b filename` | 如果指定的文件名是块设备文件，则为真。 |'
- en: '| `-c filename` | True if a character device file with the specified filename
    exists. |'
  id: totrans-119
  prefs: []
  type: TYPE_TB
  zh: '| `-c filename` | 如果指定的文件名是字符设备文件，则为真。 |'
- en: '| `-d directory_name` | True if a directory with the specified directory name
    exists. |'
  id: totrans-120
  prefs: []
  type: TYPE_TB
  zh: '| `-d directory_name` | 如果指定的目录名称存在，则为真。 |'
- en: '| `-e filename` | True if any type of file with the specified filename exists.
    |'
  id: totrans-121
  prefs: []
  type: TYPE_TB
  zh: '| `-e filename` | 如果指定的文件名存在任意类型的文件，则为真。 |'
- en: '| `-f filename` | True if a regular file with the specified filename exists.
    |'
  id: totrans-122
  prefs: []
  type: TYPE_TB
  zh: '| `-f filename` | 如果指定的文件名是常规文件，则为真。 |'
- en: '| `-g filename` | True if a file or directory has the SGID permission set.
    |'
  id: totrans-123
  prefs: []
  type: TYPE_TB
  zh: '| `-g filename` | 如果文件或目录具有SGID权限，则为真。 |'
- en: '| `-G filename` | True if a file exists and is owned by the Effective Group
    ID |'
  id: totrans-124
  prefs: []
  type: TYPE_TB
  zh: '| `-G filename` | 如果文件存在且属于有效的组ID，则为真。 |'
- en: '| `-h filename` | True if the file exists and it’s a symbolic link |'
  id: totrans-125
  prefs: []
  type: TYPE_TB
  zh: '| `-h filename` | 如果文件存在且是符号链接，则为真。 |'
- en: '| `-k filename` | True if the file or directory exists and has the sticky bit
    set |'
  id: totrans-126
  prefs: []
  type: TYPE_TB
  zh: '| `-k filename` | 如果文件或目录存在且设置了粘滞位，则为真。 |'
- en: '| `-L filename` | True if the file exists and it’s a symbolic link. (This is
    the same as `-h`.) |'
  id: totrans-127
  prefs: []
  type: TYPE_TB
  zh: '| `-L filename` | 如果文件存在且是符号链接。（这与`-h`相同。） |'
- en: '| `-p filename` | True if the file exists and it’s a named pipe |'
  id: totrans-128
  prefs: []
  type: TYPE_TB
  zh: '| `-p filename` | 如果文件存在并且是一个命名管道，则为真 |'
- en: '| `-O filename` | True if the file exists and it’s owned by the Effective UID
    |'
  id: totrans-129
  prefs: []
  type: TYPE_TB
  zh: '| `-O filename` | 如果文件存在并且属于有效用户 ID，则为真 |'
- en: '| `-r filename` | True if the file exists and it’s readable |'
  id: totrans-130
  prefs: []
  type: TYPE_TB
  zh: '| `-r filename` | 如果文件存在并且是可读的，则为真 |'
- en: '| `-S filename` | True if the file exists and it’s a socket |'
  id: totrans-131
  prefs: []
  type: TYPE_TB
  zh: '| `-S filename` | 如果文件存在并且是一个套接字，则为真 |'
- en: '| `-s filename` | True if the file exists and it’s non-zero bytes in size |'
  id: totrans-132
  prefs: []
  type: TYPE_TB
  zh: '| `-s filename` | 如果文件存在且大小大于零字节，则为真 |'
- en: '| `-u filename` | True if the file exists and it has the SUID bit set |'
  id: totrans-133
  prefs: []
  type: TYPE_TB
  zh: '| `-u filename` | 如果文件存在并且设置了 SUID 位，则为真 |'
- en: '| `-w filename` | True if the file exists and it’s writable |'
  id: totrans-134
  prefs: []
  type: TYPE_TB
  zh: '| `-w filename` | 如果文件存在并且是可写的，则为真 |'
- en: '| `-x filename` | True if the file exists and it’s executable |'
  id: totrans-135
  prefs: []
  type: TYPE_TB
  zh: '| `-x filename` | 如果文件存在并且是可执行文件，则为真 |'
- en: '| `file1 -nt file2` | True if file1 is newer than file2 |'
  id: totrans-136
  prefs: []
  type: TYPE_TB
  zh: '| `file1 -nt file2` | 如果 file1 比 file2 更新，则为真 |'
- en: '| `file1 -ot file2` | True if file1 is older than file2 |'
  id: totrans-137
  prefs: []
  type: TYPE_TB
  zh: '| `file1 -ot file2` | 如果 file1 比 file2 旧，则为真 |'
- en: '| `-z string` | True if the length of the text string is 0 |'
  id: totrans-138
  prefs: []
  type: TYPE_TB
  zh: '| `-z string` | 如果文本字符串的长度为 0，则为真 |'
- en: '| `-n string` | True if the length of the text string is not 0 |'
  id: totrans-139
  prefs: []
  type: TYPE_TB
  zh: '| `-n string` | 如果文本字符串的长度不为 0，则为真 |'
- en: '| `string1 == string2` | True if the two text strings are identical |'
  id: totrans-140
  prefs: []
  type: TYPE_TB
  zh: '| `string1 == string2` | 如果两个文本字符串相同，则为真 |'
- en: '| `string1 != string2` | True if the two text strings are not identical |'
  id: totrans-141
  prefs: []
  type: TYPE_TB
  zh: '| `string1 != string2` | 如果两个文本字符串不相同，则为真 |'
- en: '| `string1 < string2` | True if `string1` comes before `string2` in alphabetical
    order |'
  id: totrans-142
  prefs: []
  type: TYPE_TB
  zh: '| `string1 < string2` | 如果 `string1` 在字母顺序上排在 `string2` 前面，则为真 |'
- en: '| `string1 > string2` | True if `string1` comes after `string2` in alphabetical
    order |'
  id: totrans-143
  prefs: []
  type: TYPE_TB
  zh: '| `string1 > string2` | 如果 `string1` 在字母顺序上排在 `string2` 后面，则为真 |'
- en: '| `integer1 -eq integer2` | True if the two integers are equal |'
  id: totrans-144
  prefs: []
  type: TYPE_TB
  zh: '| `integer1 -eq integer2` | 如果两个整数相等，则为真 |'
- en: '| `integer1 -ne integer2` | True if the two integers are not equal |'
  id: totrans-145
  prefs: []
  type: TYPE_TB
  zh: '| `integer1 -ne integer2` | 如果两个整数不相等，则为真 |'
- en: '| `integer1 -lt integer2` | True if `integer1` is less than `integer2` |'
  id: totrans-146
  prefs: []
  type: TYPE_TB
  zh: '| `integer1 -lt integer2` | 如果 `integer1` 小于 `integer2`，则为真 |'
- en: '| `integer1 -gt integer2` | True if `integer1` is greater than `integer2` |'
  id: totrans-147
  prefs: []
  type: TYPE_TB
  zh: '| `integer1 -gt integer2` | 如果 `integer1` 大于 `integer2`，则为真 |'
- en: '| `integer1 -le integer2` | True if `integer1` is less than or equal to `integer2`
    |'
  id: totrans-148
  prefs: []
  type: TYPE_TB
  zh: '| `integer1 -le integer2` | 如果 `integer1` 小于或等于 `integer2`，则为真 |'
- en: '| `integer1 -ge integer2` | True if `integer1` is greater than or equal to
    `integer2` |'
  id: totrans-149
  prefs: []
  type: TYPE_TB
  zh: '| `integer1 -ge integer2` | 如果 `integer1` 大于或等于 `integer2`，则为真 |'
- en: '| `-o optionname` | True if a shell option is enabled |'
  id: totrans-150
  prefs: []
  type: TYPE_TB
  zh: '| `-o optionname` | 如果启用了某个 shell 选项，则为真 |'
- en: I know, that’s a lot of stuff, isn’t it? But, that’s okay. If you don’t want
    to memorize all of this, just keep this chart handy for ready reference.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 我知道，这信息量挺大的，不是吗？但没关系。如果你不想记住所有这些内容，只需随时参考这张表格即可。
- en: Next up, let’s talk about subshells.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们来谈谈子 Shell。
- en: Understanding Subshells
  id: totrans-153
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解子 Shell
- en: 'When you perform a test using the `[ $var -ne 0 ]` construct, the test will
    invoke a **subshell**. To prevent a test from invoking a subshell, use this construct,
    instead:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 当你使用 `[ $var -ne 0 ]` 构造执行测试时，该测试会调用一个 **子 Shell**。为了防止测试调用子 Shell，使用以下构造：
- en: '[PRE28]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: This can make your script run somewhat more efficiently, which might or might
    not be a huge deal for your particular script.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 这可以使你的脚本运行得更高效，这对你的特定脚本可能是一个大问题，也可能不是。
- en: This `[[. . .]]` type of construct is also necessary when you perform tests
    that require matching a pattern to a regular expression. (Matching regular expressions
    won’t work within a `[. . .]` construct.)
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 这种 `[[. . .]]` 类型的构造在执行需要匹配模式与正则表达式的测试时也非常必要。 (在 `[. . .]` 构造中无法使用正则表达式进行匹配。)
- en: The downside of this `[[. . .]]` construct is that you can’t use it on certain
    non-`bash` shells, such as `dash`, `ash`, or `Bourne`. (You’ll see that in *Chapter
    19, Shell Script Portability*.)
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 这个 `[[. . .]]` 构造的缺点是你不能在某些非 `bash` 的 Shell 中使用它，例如 `dash`、`ash` 或 `Bourne`。
    (你将在 *第 19 章，Shell 脚本的可移植性* 中看到这一点。)
- en: Of course, you don’t know what regular expressions are just yet, and that’s
    okay. I’ll show you all about them in *Chapter 9, Filtering Text with grep, sed,
    and Regular Expressions*.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，你现在可能还不知道什么是正则表达式，但没关系。*第 9 章，使用 grep、sed 和正则表达式过滤文本* 会详细介绍它们。
- en: At any rate, you can always try your scripts with subshells and without subshells,
    to see which works better for you.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 无论如何，你总是可以尝试在使用子 Shell 和不使用子 Shell 的情况下运行你的脚本，看看哪种方式对你更有效。
- en: We’ve now looked at all three methods to perform testing. So, how about a bit
    of practice with a hands-on lab?
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在已经看过了执行测试的三种方法。那么，不妨来做一些实践，进行一次实验室操作？
- en: Hands-on Lab – Testing Conditions
  id: totrans-162
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实验室操作 – 测试条件
- en: 'For this step, download the `tests-test.sh` script from the Github repository.
    (It’s a rather long script that I can’t reproduce here, due to book formatting
    considerations.) Open the script in your text editor, and examine how it’s constructed.
    The first thing you’ll see is that it’s checking for the existence of the `myfile.txt`
    file, like this:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这一步，从Github仓库下载`tests-test.sh`脚本。（由于书籍格式的考虑，这个脚本比较长，我无法在这里重现。）在文本编辑器中打开脚本，并检查它是如何构建的。你首先会看到它在检查`myfile.txt`文件是否存在，如下所示：
- en: '[PRE29]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'After that, you’ll see the command to create the file if it doesn’t exist,
    like this:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，你将看到创建文件的命令（如果文件不存在），如下所示：
- en: '[PRE30]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Next, you’ll see the command to set `400` as the permissions setting, which
    means that the user has permission to read the file, and that nobody has permission
    to write to it. Then, we want to verify that all write permissions have been removed.
    Here’s how that looks:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，你将看到命令将`400`设置为权限设置，这意味着用户有权限读取文件，但没有人有权限写入文件。然后，我们想验证所有写权限是否已被移除。如下所示：
- en: '[PRE31]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'After several more permissions settings manipulations and tests for them, you’ll
    see this stanza that tests for the existence of a directory, and creates it if
    it doesn’t exist:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 在进行了更多权限设置操作并进行了测试后，你将看到这个代码段，它测试一个目录是否存在，如果不存在则创建它：
- en: '[PRE32]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: The final thing you’ll see is the stanza that tests for the `noclobber` option,
    sets it, and then tests for it again.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 最终你将看到一个代码段，测试`noclobber`选项，设置它，然后再次进行测试。
- en: After you’ve finished reviewing the script, run it to see what happens.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 审查完脚本后，运行它看看会发生什么。
- en: For bonus points, retype the script into your own script file. Why? Well, a
    dirty little secret is that if you type code in yourself, it will help you better
    understand the concepts.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 为了额外积分，重新键入脚本到你自己的脚本文件中。为什么？因为一个小秘密是，如果你自己键入代码，它会帮助你更好地理解这些概念。
- en: 'For the next step, create the `tests-test_2.sh` script with the following contents:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 对于下一步，创建`tests-test_2.sh`脚本，内容如下：
- en: '[PRE33]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Make the script file executable and then run it to view the results. Change
    the values of the `string1`, `string2`, `num1`, and `num2` variables and then
    run the script again and view the results.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 使脚本文件可执行，然后运行它查看结果。更改变量`string1`、`string2`、`num1`和`num2`的值，然后再次运行脚本并查看结果。
- en: End of lab.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 实验结束。
- en: Next, let’s take a closer look at variables.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们更详细地了解变量。
- en: Understanding Scripting Variables
  id: totrans-179
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解脚本变量
- en: I’ve already told you a bit about scripting variables, and you’ve already seen
    them in use. But, there’s a bit more to the story.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 我已经跟你简要介绍了脚本变量，并且你已经看到了它们的使用。但这个故事还有一些内容。
- en: Creating and Deleting Variables
  id: totrans-181
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建和删除变量
- en: 'As you’ve already seen, it’s sometimes either necessary or more convenient
    to define variables in your scripts. You can also define, view, and unset variables
    from the command-line. Here’s an example:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你已经看到的，有时在脚本中定义变量是必要的，或者更为方便。你也可以从命令行定义、查看和取消设置变量。以下是一个示例：
- en: '[PRE34]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Here, I’ve defined the variable `car`, and set its value to `Ford`. The first
    `echo` command shows the assigned value. The second `echo` command verifies that
    I’ve successfully cleared the variable with `unset`.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我定义了变量`car`，并将其值设置为`Ford`。第一个`echo`命令显示分配的值。第二个`echo`命令验证我是否成功使用`unset`清除了该变量。
- en: Understanding Variables and Shell Levels
  id: totrans-185
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 理解变量和Shell级别
- en: 'When you place a shebang line, such as `#!/bin/bash` or `#!/bin/sh`, at the
    start of your script, a new non-interactive child shell will be invoked every
    time you run the script. When the script finishes, the child shell terminates.
    The child shell inherits any variables that are exported from the parent shell.
    But, the parent shell won’t inherit any variables from the child shell. To demonstrate,
    let’s set the `car` variable to `Volkswagen` in the parent shell, like so:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 当你在脚本开头放置一个shebang行，如`#!/bin/bash`或`#!/bin/sh`时，每次运行脚本时都会启动一个新的非交互式子shell。脚本结束后，子shell会终止。子shell会继承父shell导出的任何变量，但父shell不会继承子shell的任何变量。为了演示这一点，我们在父shell中将`car`变量设置为`Volkswagen`，如下所示：
- en: '[PRE35]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Next, create the `car_demo.sh` script, like so:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，创建`car_demo.sh`脚本，如下所示：
- en: '[PRE36]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Make the file executable and then run the script. The output should look like
    this:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 使文件可执行，然后运行脚本。输出应该如下所示：
- en: '[PRE37]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Note how the `Volkswagen` value of car was inherited from the parent shell.
    That’s because I used the `export` command to make sure that this value would
    be available to the child shell that the script invokes. Let’s try this again,
    except this time, I won’t export the variable:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 注意`car`的`Volkswagen`值是如何从父shell继承过来的。这是因为我使用了`export`命令，确保这个值对脚本调用的子shell可用。让我们再试一次，不过这次我不会导出变量：
- en: '[PRE38]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: To make this work, I first had to unset the `car` variable. In addition to clearing
    out the value of `car`, it also cleared out the export. When I ran the script
    this time, it couldn’t find the value of `car` that I set in the parent shell.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 为了让这工作，我首先需要取消设置`car`变量。除了清除`car`的值，它还清除了export。当我这次运行脚本时，脚本无法找到我在父shell中设置的`car`的值。
- en: So, why is this important? It’s just that you may, at times, find yourself writing
    scripts that will call another script, which will effectively open another child
    shell. If you want variables to be available to a child shell, you have to export
    them.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，这为什么重要呢？问题在于，有时候你可能会编写调用另一个脚本的脚本，而这将有效地打开另一个子shell。如果你希望变量对子shell可用，你必须导出它们。
- en: Understanding Case Sensitivity
  id: totrans-196
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 理解大小写敏感性
- en: Variable names are case sensitive. So, a variable named `car` is completely
    different from variables named `Car` or `CAR`.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 变量名称是区分大小写的。所以，名为`car`的变量与名为`Car`或`CAR`的变量是完全不同的。
- en: Environmental variables have names with all upper-case letters, and it’s best
    practice for programming variable names to be in either all lower-case letters
    or mixed-case letters. Amazingly, Linux and Unix shells don’t enforce that rule
    for programming variables. But, it is best practice, because it helps prevent
    you from accidentally overwriting the value of an important environmental variable.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 环境变量的名称是全大写字母，而编程变量的名称最好使用全小写字母或混合大小写字母。令人惊讶的是，Linux和Unix的shell并没有强制要求编程变量遵循这个规则。但是，这是最佳实践，因为它有助于防止你不小心覆盖掉重要的环境变量的值。
- en: Sad to say, there are shell scripting tutorials on the web in which the authors
    have you create programming variable names with all upper-case letters. In fact,
    I just came across one such tutorial. For the most part, the author has you create
    variables with names that don’t conflict with any environmental variables. In
    one spot though, the author has you create the `USER` variable and assign a value
    to it. Of course, `USER` is already the name of an environmental variable, so
    assigning a new value to it will overwrite what its value should be. The lesson
    here is that there are a lot of good tutorials on the web, but there are also
    a lot that give out wrong information.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 令人遗憾的是，网上确实有一些shell脚本教程，作者让你创建全大写字母的编程变量名。实际上，我刚刚就看到一个这样的教程。在大多数情况下，作者让你创建的变量名不会与任何环境变量冲突。然而在某个地方，作者让你创建`USER`变量并为其赋值。当然，`USER`已经是一个环境变量的名字，因此将新值赋给它会覆盖它应有的值。这里的教训是，网上有很多优秀的教程，但也有很多提供错误信息的教程。
- en: Understanding Read-Only Variables
  id: totrans-200
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 理解只读变量
- en: 'You’ve just seen that when you declare a variable in the normal way, you can
    either unset it or give it a new value. You can also make a variable read-only,
    which prevents the variable from being either redefined or unset. Here’s how that
    works:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 你刚刚看到，当你以普通方式声明变量时，可以取消设置它或者给它赋予一个新值。你也可以将一个变量设置为只读，这样就无法重新定义或取消设置该变量。下面是它的工作原理：
- en: '[PRE39]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: With the read-only property set, the only way that I can either change or get
    rid of `car` is to close the terminal window.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 设置只读属性后，我改变或删除`car`的唯一方法就是关闭终端窗口。
- en: Well, this is the only way that you can get rid of a read-only variable if you
    don’t have root user privileges. If you do have root user privileges, you can
    use the **GNU bash Debugger** (`gbd`) to get rid of it. But, that’s beyond the
    scope of this chapter. (We’ll look at `gbd` in *Chapter 21, Debugging Shell Scripts*.)
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 好吧，如果你没有root用户权限，这是你唯一能删除只读变量的方法。如果你有root用户权限，你可以使用**GNU bash调试器**(`gbd`)来删除它。但这超出了本章的范围。（我们将在*第21章，调试Shell脚本*中讨论`gbd`。）
- en: Okay, this is all great if all you need is to define some individual variables.
    But, what if you need a whole list of variables? Well, this is where arrays come
    in handy. Let’s look at that next.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，如果你只需要定义一些单独的变量，这一切都很棒。但如果你需要一个完整的变量列表呢？那么，这时候数组就派上用场了。接下来我们来看看数组。
- en: Understanding Array Variables
  id: totrans-206
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解数组变量
- en: 'An array allows you to collect a list into one variable. The easy way to create
    an array variable is to assign a value to one of its indices, like so:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 数组允许你将一个列表收集到一个变量中。创建数组变量的简单方法是为其某个索引分配一个值，如下所示：
- en: '[PRE40]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Here, `name` is the name of the array, and `index` is the position of the item
    in the array. (Note that index must be a number.) `value` is the value that’s
    set for that individual item in the array.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，`name`是数组的名称，`index`是数组中项的位置。（请注意，index必须是数字。）`value`是为该数组项设置的值。
- en: 'The numbering system for arrays begins with 0\. So, `name[0]` would be the
    first item in the array. To create an indexed array, use `declare` with the `-a`
    option, like so:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 数组的编号系统从0开始。所以，`name[0]`就是数组中的第一个项。要创建一个有索引的数组，使用带有`-a`选项的`declare`命令，如下所示：
- en: '[PRE41]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Next, let’s create the list that will be inserted into the array, like so:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们创建将被插入数组中的列表，如下所示：
- en: '[PRE42]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'You can view the value of any individual item in the array, but there’s a special
    way to do it. Here’s what it looks like:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以查看数组中任意单个项的值，但有一种特殊的方式来做到这一点。它的样子如下：
- en: '[PRE43]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: Note how I had to surround the `myarray[x]` construct with a pair of curly braces.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 注意我如何将`myarray[x]`结构用一对大括号包围起来。
- en: 'To view the whole list of array items, use either a `*` or an `@` in place
    of the index number, like so:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看数组项的完整列表，可以用`*`或`@`代替索引数字，如下所示：
- en: '[PRE44]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'To just count the number of array items, insert a `#` in front of the array
    name, like this:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 要仅仅计算数组项的数量，在数组名称前插入一个`#`，像这样：
- en: '[PRE45]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: Okay, that covers the basics of arrays. Let’s do something a bit more practical
    with a hands-on lab.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，这就是数组的基础知识。让我们通过一个实际操作实验来做一些更有实用性的东西。
- en: Hands-on Lab – Using Arrays
  id: totrans-222
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实操实验 – 使用数组
- en: 'To see how arrays are built, create the `ip.sh` script with the following contents:'
  id: totrans-223
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要查看数组是如何构建的，创建一个`ip.sh`脚本，内容如下：
- en: '[PRE46]'
  id: totrans-224
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE46]'
- en: Make the file executable and run it.
  id: totrans-225
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使文件可执行并运行它。
- en: '[PRE47]'
  id: totrans-226
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Create the `/opt/scripts/` directory to store data files that your scripts
    will need to access, like this:'
  id: totrans-227
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建`/opt/scripts/`目录，用于存储你的脚本需要访问的数据文件，像这样：
- en: '[PRE48]'
  id: totrans-228
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'In the `/opt/scripts/` directory, create the `banned.txt` file. (Note that
    in this directory, you’ll need to use `sudo` when opening your text editor.) Add
    to it the following contents:'
  id: totrans-229
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`/opt/scripts/`目录下，创建`banned.txt`文件。（请注意，在该目录下，打开文本编辑器时需要使用`sudo`。）将以下内容添加到文件中：
- en: '[PRE49]'
  id: totrans-230
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'In your own home directory, create the `attackers.sh` script, which will build
    an array of banned IP addresses from a list in a text file. Add the following
    contents:'
  id: totrans-231
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在你自己的主目录下，创建`attackers.sh`脚本，它将根据文本文件中的列表构建一个被禁止的IP地址数组。将以下内容添加到文件中：
- en: '[PRE50]'
  id: totrans-232
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'Set the executable permission and run the script, like so:'
  id: totrans-233
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 设置可执行权限并运行脚本，如下所示：
- en: '[PRE51]'
  id: totrans-234
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE51]'
- en: Modify the script so that the elements 0, 5, and 8 are printed to screen, and
    rerun the script. (You’ve already seen how to do it.)
  id: totrans-235
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 修改脚本，使得索引为0、5和8的元素被打印到屏幕上，然后重新运行脚本。（你已经看过如何做了。）
- en: End of Lab
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 实验结束
- en: 'A few words of explanation about this `attackers.sh` script are in order. First,
    in the second line, I’m using command substitution with the `cat` command to assign
    the contents of the `banned.txt` script to the `badips` variable. (I know, I keep
    showing you examples of command substitution, but I haven’t fully explained it
    yet. Don’t worry though, I’ll do that in a bit.) However, this still isn’t an
    array. I’ve created that separately in the `declare -a` line. In the `attackers=`
    line, I called back the value of the `badips` variable, which I then used to build
    the `attackers` array. Alternatively, I could have skipped using the intermediate
    variable and built the array directly from the `cat` command substitution, as
    I did in this `attackers_2.sh` script:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 关于这个`attackers.sh`脚本，需要做一些解释。首先，在第二行，我使用命令替换与`cat`命令，将`banned.txt`文件的内容赋值给`badips`变量。（我知道，我一直给你展示命令替换的例子，但还没有完全解释清楚。不过不用担心，稍后我会解释的。）然而，这仍然不是一个数组。我在`declare
    -a`那行中单独创建了数组。在`attackers=`这一行，我引用了`badips`变量的值，然后用它构建了`attackers`数组。或者，我也可以跳过使用中间变量，直接从`cat`命令替换中构建数组，就像我在`attackers_2.sh`脚本中做的那样：
- en: '[PRE52]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: Either way works, but this way is a bit more streamlined.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 两种方式都可以，但这种方式稍显简洁。
- en: In a real-life scenario, you could add code that will automatically invoke a
    firewall rule that will block all of the addresses in the `banned.txt` file. But,
    that requires using techniques that I haven’t yet shown you. So, we’ll just have
    to get that later.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 在实际场景中，你可以添加代码，自动调用一个防火墙规则，阻止`banned.txt`文件中的所有地址。但是，这需要使用一些我还没有向你展示的技术。因此，我们稍后再来看这部分内容。
- en: Next, let’s expand some variables.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们扩展一些变量。
- en: Understanding Variable Expansion
  id: totrans-242
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解变量扩展
- en: '**Variable expansion**, which is also called **parameter expansion**, allows
    the shell to test or modify values of a variable to be used in a script, using
    special modifiers enclosed in curly braces and preceded by a `$` (`${variable}`).
    If this variable is not set in `bash` it will be expanded to a null string. The
    best way to begin is to show you a few simple examples.'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: '**变量扩展**，也叫做**参数扩展**，允许shell通过使用被大括号包围并由`$`符号前缀的特殊修饰符（`${variable}`）来测试或修改变量的值，并将这些值用于脚本中。如果在`bash`中这个变量没有被设置，它将扩展为空字符串。最好的方式是先通过几个简单的例子来展示。'
- en: Substituting a Value for an Unset Variable
  id: totrans-244
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 为未设置的变量替换值
- en: 'First, I’ll define the `cat` variable with the name of my 16-year old gray
    kitty. Then, I’ll perform a test to see if `cat` really has a set value, like
    this:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我会定义一个`cat`变量，给它赋值为我16岁灰色小猫的名字。然后，我会进行一个测试，看看`cat`是否真的有一个已设置的值，像这样：
- en: '[PRE53]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'Next, I’ll unset the value of `cat`, and perform the test again. Watch what
    happens:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我会取消设置`cat`的值，并再次进行测试。看看会发生什么：
- en: '[PRE54]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'So, what happened? Well, the `-` between `cat` and `"This cat variable is not
    set."` tests to see whether or not the `cat` variable has an assigned value. If
    the variable has no assigned value, then the text string that comes after the
    `-` is substituted for the variable’s value. However, the substituted value is
    not actually *assigned* to the variable, as you see here:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，发生了什么呢？嗯，`cat`和`"This cat variable is not set."`之间的`-`用来测试`cat`变量是否有一个已设置的值。如果变量没有已设置的值，那么`-`后面的文本字符串就会替代变量的值。然而，替代的值并没有*被赋值*给变量，正如你在这里看到的：
- en: '[PRE55]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'Now, assign a null value to `cat`, and try this again:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，为`cat`赋一个空值，再试一次：
- en: '[PRE56]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'This time, we just get a blank line as output, because the `cat` variable is
    set. It’s just that it’s set to a null value. Let’s try this again, using `:-`
    instead of `-` , like so:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 这次，我们只得到一个空白行作为输出，因为`cat`变量已经设置。只是它的值被设置为一个空值。我们再试一次，使用`:-`代替`-`，像这样：
- en: '[PRE57]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: This works because placing a `:` in front of the `-` causes variables that have
    been set with a null value to be treated as unset variables.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 这样是可行的，因为在`-`前面加上`:`会使那些已设置为空值的变量被视为未设置的变量。
- en: Okay, that does it for unset variables. Sometimes though, we might need to work
    with variables that do have set values, as you’ll see next.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，这就结束了未设置变量的内容。但有时候，我们可能需要处理那些已经设置了值的变量，正如你接下来将看到的。
- en: Substituting a Value for a Set Variable
  id: totrans-257
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 为已设置的变量替换值
- en: 'You can go the opposite way by substituting a value for a variable that *does*
    have an assigned value, like this:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过为一个*有值*的变量替换一个值来反向操作，像这样：
- en: '[PRE58]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'In this case, the `+` construct causes the following text string to be substituted
    for the variable’s assigned value. Note that since there are no special characters
    in this text string that need to be escaped, the quotes are optional. However,
    best practice dictates using quotes anyway, just to be safe. Also note that this
    substitution did not change the actual assigned value of the `car` variable, as
    you see here:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，`+`构造会使以下文本字符串替代变量的已赋值。注意，由于这个文本字符串中没有特殊字符需要转义，引用符号是可选的。不过，最佳实践是仍然使用引号，以确保安全。另外，注意这次替代并没有改变`car`变量的实际赋值，正如你在这里看到的：
- en: '[PRE59]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'As you just saw with the `–` operator, the `+` operator treats variables with
    a null value as being set. If you want to treat variables with null values as
    unset, then use the `:+` operator. If you create a variable and leave it with
    a null value, it will look something like this:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你刚才看到的，`–`操作符和`+`操作符会将具有空值的变量视为已设置。如果你想将空值变量视为未设置，则可以使用`:+`操作符。如果你创建一个变量并让它保持空值，它看起来会像这样：
- en: '[PRE60]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'You see that with a null value, there’s no output from the `echo` command.
    Now, since I just happen to be using a Dell computer, let’s set the value of `computer`
    to `Dell`, as you see here:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 你会看到，使用空值时，`echo`命令没有任何输出。现在，由于我恰好在使用一台戴尔计算机，让我们将`computer`变量的值设置为`Dell`，就像你在这里看到的：
- en: '[PRE61]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: As I’ve already indicated, the operators that we’ve just looked at will substitute
    a value for a variable, depending upon whether the value has an assigned value.
    But, they won’t actually change the value of the variable. But, we might at times
    need to change a variable’s value, as we’ll see next.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我之前所提到的，我们刚刚看到的操作符会根据变量是否已经赋值来替换变量的值。但它们不会真正改变变量的值。不过，我们有时可能需要更改变量的值，接下来我们会看到这一点。
- en: Assigning a Value to a Variable
  id: totrans-267
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 为变量赋值
- en: 'This next trick actually will assign a value to an unset variable, using the
    `=` and `:=` operators. Let’s begin by assigning a value to the `town` variable:'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个小技巧实际上会使用 `=` 和 `:=` 操作符为一个未设置的变量赋值。我们从给 `town` 变量赋值开始：
- en: '[PRE62]'
  id: totrans-269
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'Now, let’s see if we can assign a different value to town:'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看是否能给 `town` 赋一个不同的值：
- en: '[PRE63]'
  id: totrans-271
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'As you’ve seen before, using this operator without a preceding `:` causes a
    variable with a null value to be treated as a set variable. Here’s how that looks:'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 如你之前所见，使用没有前导 `:` 的操作符，会将一个空值变量当作已设置的变量来处理。看看这个例子：
- en: '[PRE64]'
  id: totrans-273
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'To show how using the `:=` operator works, let’s create the `armadillo` variable
    with a null value, and then assign to it a default value, like so:'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 为了展示如何使用 `:=` 操作符，我们首先创建一个值为空的 `armadillo` 变量，然后给它分配一个默认值，如下所示：
- en: '[PRE65]'
  id: totrans-275
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'Artie is the tentative name that I’ve given to the armadillo who’s recently
    begun visiting my back yard at night. But, I don’t yet know if the armadillo is
    a boy or a girl, so I don’t yet know if Artie is an appropriate name. If I find
    out that it’s a girl, I might want to change the name to Annie. So, let’s try
    the preceding exercise again, but with `armadillo` set to `Annie`. Then, we’ll
    see if we can use our variable expansion to change it to `Artie`, like so:'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: Artie 是我给最近开始在晚上来我后院的犰狳取的临时名字。但我还不知道这只犰狳是男是女，所以不确定 Artie 这个名字是否合适。如果我发现它是只母犰狳，我可能想把名字改成
    Annie。所以，我们再试一下前面的练习，不过这次将 `armadillo` 设置为 `Annie`。然后我们看看能否通过变量扩展将它改为 `Artie`，像这样：
- en: '[PRE66]'
  id: totrans-277
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: You see that since the `armadillo` variable already had the `Annie` assigned
    as its value, the `echo ${armadillo:=Artie}` command had no effect, other than
    to show the value that I had already assigned.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 你会看到，由于 `armadillo` 变量已经赋值为 `Annie`，所以 `echo ${armadillo:=Artie}` 命令没有任何效果，除了显示我已经赋予的值。
- en: Now, what if you don’t want to substitute a variable’s value, but just want
    to see an error message? Let’s look at that.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果你不想替换变量的值，而只是想查看一个错误信息，怎么办呢？我们来看看。
- en: Displaying an Error Message
  id: totrans-280
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 显示错误信息
- en: 'You won’t always want to perform either a value substitution or a value assignment
    for an unset variable. Sometimes, you might just want to see an error (`stderror`)
    message if the variable is unset. Do that with the `:?` construct, like this:'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 你并不总是希望为未设置的变量执行值替换或赋值。有时候，你可能只想看到一个错误（`stderr`）信息，如果变量未设置。可以使用 `:?` 构造来实现，如下所示：
- en: '[PRE67]'
  id: totrans-282
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'Let’s try that again with a dog named Rastus, which was the name of an English
    Shepard that my Grandma had when I was a kid. It will look like this:'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们再试一次，使用一个叫 Rastus 的狗，它是我小时候奶奶养的那只英国牧羊犬的名字。它看起来像这样：
- en: '[PRE68]'
  id: totrans-284
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: I know, you’re thinking that this looks just like the first example, where I
    substituted a message for the value of the unset `cat` variable with a `-`. Well,
    you’re kind of right. It’s just that the `-` substitutes a value that shows up
    as `stdout`, while the `:?` substitutes a message that shows up as `stderr`. Another
    difference is that if you use `:?` in a shell script with an unset variable, it
    will cause the script to exit.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 我知道，你现在可能觉得这看起来和第一个例子一样，在那个例子中，我用 `-` 替换了未设置的 `cat` 变量的值。嗯，你说得对。只是 `-` 替换的是一个会显示在
    `stdout` 的值，而 `:?` 替换的是一个会显示在 `stderr` 的信息。另一个区别是，如果在 shell 脚本中使用 `:?` 来处理未设置的变量，它会导致脚本退出。
- en: 'Try that by creating the `ex.sh` script with the following contents:'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 试试这个，创建一个名为 `ex.sh` 的脚本，内容如下：
- en: '[PRE69]'
  id: totrans-287
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'So far, I’ve been showing you how to use `echo` to both perform the variable
    expansion and show the results. This particular construct allows you to just test
    the variable without echoing the results, by using a `:` instead of `echo`. Now
    when I run this script, you’ll see that it exits before the final `echo` command
    can execute, as you see here:'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我一直在展示如何使用 `echo` 来执行变量扩展并显示结果。这个特定的构造允许你只测试变量，而不打印结果，只需要使用 `:` 替代 `echo`。现在，当我运行这个脚本时，你会看到它在最终的
    `echo` 命令执行之前就退出了，如下所示：
- en: '[PRE70]'
  id: totrans-289
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'Wait a minute! Did I just call myself a big dummy? Oh, well. Anyway, let’s
    change the script so that `var` has an assigned value, as you see in this `ex_2.sh`
    script:'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 等等！我刚才是不是称自己是个大傻瓜？哦，算了。不过，让我们修改脚本，让 `var` 有一个已赋值的值，就像在这个 `ex_2.sh` 脚本中一样：
- en: '[PRE71]'
  id: totrans-291
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'The script now runs to completion, as you see here:'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 现在脚本执行完毕，如下所示：
- en: '[PRE72]'
  id: totrans-293
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 'So to reiterate, using the `:` in place of the `echo` prevents the `${var:?"var
    is unset, you big dummy"}` construct from printing out the value of the variable.
    We can change that behavior by changing the `:` back to an `echo`, as you see
    here in `ex_3.sh`:'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 所以为了重申，使用`:`代替`echo`可以防止`${var:?"var is unset, you big dummy"}`结构打印出变量的值。我们可以通过将`:`改回`echo`来改变这一行为，就像在`ex_3.sh`中看到的那样：
- en: '[PRE73]'
  id: totrans-295
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: 'Now, let’s see the results of that change:'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看该更改的结果：
- en: '[PRE74]'
  id: totrans-297
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: This time, the value of `var` does print out.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 这次，`var`的值确实被打印出来。
- en: As you’ve just seen with the `-` and the `+` operators, preceding the `?` with
    a `:` causes the operator to treat a variable that was created with a null value
    as unset. Leaving out the `:` causes the operator to treat variables that were
    created with a null value as set.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你刚刚看到的，使用`-`和`+`操作符时，前面加上`:`会导致操作符将一个空值创建的变量视为未设置。省略`:`会导致操作符将空值创建的变量视为已设置。
- en: Now, let’s change gears by looking at variable offsets.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们换个方式来看变量偏移量。
- en: Using Variable Offsets
  id: totrans-301
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用变量偏移量
- en: The last type of variable expansion that I’ll show you involves the substitution
    of just a subset of a text string. This involves using a **variable offset**,
    and is a bit more difficult to understand unless you can see an example.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 我将向你展示的最后一种变量扩展类型涉及仅替换文本字符串的一个子集。这涉及使用**变量偏移量**，除非你能看到一个例子，否则理解起来有点困难。
- en: 'When you set a variable it will have a set size, or number of characters. The
    `${variable:offset}` construct uses the offset, or number of characters from the
    specified location. So, if the offset is `4` it will omit the first four characters,
    and will only echo all of the characters after the fourth character. The addition
    of a length parameter with the `${variable:offset:length}` construct allows you
    to also determine how many characters that you want to use. To begin, let’s create
    the `text` variable with a value of `MailServer`, like so:'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 当你设置一个变量时，它会有一个固定的大小，或者说是字符数。`${variable:offset}`结构使用偏移量或从指定位置开始的字符数。所以，如果偏移量是`4`，它将省略前四个字符，并且只会回显第四个字符之后的所有字符。通过使用`${variable:offset:length}`结构来添加长度参数，你还可以确定你想要使用的字符数。首先，让我们创建`text`变量，其值为`MailServer`，如下所示：
- en: '[PRE75]'
  id: totrans-304
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: 'Now, let’s say that we only want to see the text that comes after the fourth
    letter. Use an offset, like this:'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，假设我们只想查看第四个字母之后的文本。使用偏移量，如下所示：
- en: '[PRE76]'
  id: totrans-306
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: 'Cool, it works. Now, let’s say that we want to see just the first four letters.
    Use an offset and length, like this:'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 很酷，它有效。现在，假设我们想要查看前四个字母。使用偏移量和长度，如下所示：
- en: '[PRE77]'
  id: totrans-308
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: This means that we’re starting after position `0`, and are viewing only the
    first four letters.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着我们从位置`0`开始，并且只查看前四个字母。
- en: 'You can also extract text from somewhere in the middle of the text string,
    like so:'
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以从文本字符串的中间提取文本，例如这样：
- en: '[PRE78]'
  id: totrans-311
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: Here, I’m starting after the fourth character, and am extracting the next five
    characters.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我从第四个字符之后开始，提取接下来的五个字符。
- en: 'For something a bit more practical, let’s set the `location` variable with
    the name of a US city and state, along with its associated zip code. (That’s *postal
    code* for anyone who isn’t here in the US.) Then, let’s say that we want to extract
    the zip code portion of the text string, like so:'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 对于一些稍微实际点的操作，让我们将`location`变量设置为一个美国城市及其州名，以及相关的邮政编码。（对任何不在美国的人来说，那就是*邮政编码*。）然后，假设我们想提取文本字符串中的邮政编码部分，如下所示：
- en: '[PRE79]'
  id: totrans-314
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: 'Instead of setting the offset by counting from the beginning of the text string,
    I could also have used a negative number to just extract the last part of the
    text string. Since the zip code is five digits long, I could use a `-5`, like
    this:'
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 我可以不通过从文本字符串的开头开始计数来设置偏移量，而是使用负数来提取文本字符串的最后部分。由于邮政编码有五个数字，我可以使用`-5`，像这样：
- en: '[PRE80]'
  id: totrans-316
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: To ensure that this always works properly, be sure to always leave a blank space
    between the `:` and the `-`. Also, since city names will always vary in length,
    this would be a better option if you need to extract zip codes from a whole list
    of locations.
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 为确保这始终正常工作，务必在`:`和`-`之间留一个空格。此外，由于城市名称的长度总是会有所不同，如果你需要从整个地点列表中提取邮政编码，这将是一个更好的选择。
- en: That’s it for offsets. So now, let’s match some patterns.
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 关于偏移量的内容就是这些。现在，让我们匹配一些模式。
- en: Matching Patterns
  id: totrans-319
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 匹配模式
- en: 'The next variable expansion trick involves matching patterns. Let’s start by
    creating the `pathname` variable, like so:'
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个变量扩展技巧涉及匹配模式。让我们从创建`pathname`变量开始，如下所示：
- en: '[PRE81]'
  id: totrans-321
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: 'Now, let’s say that I want to strip the lowest level directory from this path.
    I’ll do that with a `%` and an `*`, like so:'
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，假设我想去掉这个路径中的最低级目录。我会使用 `%` 和 `*` 来做到这一点，如下所示：
- en: '[PRE82]'
  id: totrans-323
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: 'The `%` tells the shell to omit the final part of the string that matches the
    pattern. In this case, the `*` at the end isn’t necessary, because `yum` just
    happens to be at the end of the `pathname`. So, you’ll get the same result without
    it. But, if you want to omit the lowest two levels of `pathname`, you will need
    to use the `*` so that the pattern will match properly. Here’s what I’m talking
    about:'
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: '`%` 告诉 shell 忽略与模式匹配的字符串的最后一部分。在这种情况下，末尾的 `*` 并不是必须的，因为 `yum` 恰好在 `pathname`
    的末尾。所以，去掉它也能得到相同的结果。但是，如果你想省略 `pathname` 的最低两级，你需要使用 `*`，这样模式才会正确匹配。这就是我所说的：'
- en: '[PRE83]'
  id: totrans-325
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: You see that without the `*`, the pattern matching didn’t work. With the ***,
    the matching worked just fine. So, even when the `*` isn’t absolutely necessary,
    it’s best to include it, just to be sure.
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 你看到没有，缺少 `*` 时，模式匹配不起作用。加上 `***` 后，匹配就正常工作了。所以，即使 `*` 并非绝对必要，最好还是加上它，确保万无一失。
- en: 'On the other hand, you might at times just want to extract the names of the
    lower level directories. To do that, just replace the `%` with a `#`, like so:'
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，有时你可能只是想提取低级目录的名称。要做到这一点，只需将 `%` 替换为 `#`，如下所示：
- en: '[PRE84]'
  id: totrans-328
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: 'Let’s wrap this section up with one final trick. This time, I’ll match a pattern
    and then substitute something else. First, I’ll create the string variable, like
    so:'
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们用一个最终的小技巧来结束这一节。这次，我将匹配一个模式，然后替换其他内容。首先，我会创建一个字符串变量，如下所示：
- en: '[PRE85]'
  id: totrans-330
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: 'That’s good, except that I’ve decided that I don’t want blank spaces between
    the words. So, I’ll substitute an `_` character, like so:'
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 这样挺好，除非我决定不想在单词之间留空格。所以，我会用 `_` 字符替换，如下所示：
- en: '[PRE86]'
  id: totrans-332
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: 'That didn’t work out so well, because it only replaced the first blank space.
    To perform a global replacement, I’ll need to add an extra forward slash after
    `string`, like this:'
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 结果不是很好，因为它只替换了第一个空格。为了执行全局替换，我需要在 `string` 后面加一个额外的正斜杠，像这样：
- en: '[PRE87]'
  id: totrans-334
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: This looks much better. But, what’s really going on here? Well, we’re using
    a `/pattern_to_be_replaced/` construct to perform the substitution. Whatever you
    place between the two forward slashes is what you want to replace. You can specify
    an individual character, a character class, or some other pattern that you want
    to replace. At the end, between the last forward slash and the closing curly brace,
    place the character that you want to substitute.
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 这样看起来好多了。但是，这里到底发生了什么呢？嗯，我们使用了 `/pattern_to_be_replaced/` 构造来进行替换。你在两个正斜杠之间放置的是你想要替换的内容。你可以指定一个单独的字符、一个字符类，或者其他你想要替换的模式。最后，在最后一个正斜杠和右大括号之间，放置你想替换的字符。
- en: There’s still a bit more to the variable expansion business, but I’ve shown
    you the most practical examples. If you want to see more, you’ll find a reference
    in the *Further Reading* section.
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 变量展开的内容还有些许更多，但我已经给你展示了最实际的例子。如果你想查看更多内容，可以在 *进一步阅读* 部分找到相关参考。
- en: Okay, now that we’ve substituted some patterns, let’s move on to substituting
    commands.
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，现在我们已经替换了一些模式，接下来让我们尝试替换命令。
- en: Understanding Command Substitution
  id: totrans-338
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解命令替换
- en: In the *Counting Logged-in Users* and *Using Arrays* Hands-on Labs, I’ve shown
    you some examples of **command substitution** in action, but I haven’t yet fully
    explained it. It’s about time that I do.
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 在 *计数登录用户* 和 *使用数组* 实战实验中，我向你展示了 **命令替换** 的一些实例，但我还没有完全解释清楚。现在该是时候讲解了。
- en: 'Command substitution is an extremely handy tool that you will use extensively.
    I mean, really. You can do some very cool stuff with it. It involves taking the
    output from a shell command and either using it in another command, or assigning
    it as the value of some variable. You’ll place the command from which you’ll be
    taking output within a `$( )` construct. Here’s a very simple example:'
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 命令替换是一个非常有用的工具，你会广泛使用它。我是说，真的。你可以用它做一些非常酷的事情。它涉及到获取 shell 命令的输出，然后将其用于另一个命令中，或者将其作为某个变量的值。你将把需要获取输出的命令放在
    `$( )` 构造中。以下是一个非常简单的例子：
- en: '[PRE88]'
  id: totrans-341
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: You see how the output of the `uname -r` command, which shows the version of
    the current running Linux kernel, is substituted for the command substitution
    construct.
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 你看到 `uname -r` 命令的输出吗？它显示了当前正在运行的 Linux 内核版本，已经被替换成了命令替换构造。
- en: 'Now, let’s create the `command_subsitution_1.sh` script, and make it look like
    this:'
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们创建 `command_subsitution_1.sh` 脚本，并让它看起来像这样：
- en: '[PRE89]'
  id: totrans-344
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: 'Here’s the breakdown. In the second line, I’m testing for the absence of the
    `Daily_Reports directory`. If it’s not there, then I’ll create it. In the fourth
    line, I’m using command substitution to create the `datestamp` variable with the
    current date as its assigned value. The current date is returned by the `date
    +%F` command, and will be in the year-month-day format (2023-10-03). In the final
    line, I’m echoing a message that contains today’s date into a file that contains
    today’s date in its filename. Here’s what that looks like:'
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是具体的分析。在第二行，我正在测试`Daily_Reports目录`是否存在。如果它不存在，我将创建它。在第四行，我使用命令替换来创建`datestamp`变量，并将当前日期赋值给它。当前日期由`date
    +%F`命令返回，格式为年-月-日（2023-10-03）。在最后一行，我将包含今天日期的消息输出到一个文件中，该文件名中包含今天的日期。以下是其具体样式：
- en: '[PRE90]'
  id: totrans-346
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: Is that slick, or is that slick? Trust me, you’ll be doing this sort of thing
    a lot if you need to create scripts that will automatically generate reports.
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 这不酷吗？相信我，如果你需要编写能够自动生成报告的脚本，你会经常做这种事的。
- en: Tip
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 提示
- en: There are many different formatting options that you can use with the `date`
    command. To see them all, just view the `date` man page.
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 有许多不同的格式化选项可以与`date`命令一起使用。要查看它们的全部内容，只需查看`date`的手册页面。
- en: But, we’re missing an important element here. What if today’s report has already
    been created? Do you want to overwrite it?
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，我们这里缺少了一个重要的元素。如果今天的报告已经创建了怎么办？你是否想要覆盖它？
- en: 'No, in this case, I don’t. So, let’s create the `command_substitution_2.sh`
    script to test for the absence of today’s report before creating another one.
    It involves adding just a teeny bit of extra code, like this:'
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 不，在这种情况下，我不需要。所以，让我们创建`command_substitution_2.sh`脚本，在创建另一个报告之前，先检查今天的报告是否已经存在。这只需要增加一点额外的代码，如下所示：
- en: '[PRE91]'
  id: totrans-352
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: That last command that looks like three lines is really just one line that wraps
    around on the printed page.
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 那条看起来像三行的命令实际上只是单行命令，它在打印页面上换行了。
- en: 'Now, prepare to be amazed at what happens when I run this new, modified script:'
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，准备好惊叹当我运行这个新的修改版脚本时发生了什么：
- en: '[PRE92]'
  id: totrans-355
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: Just for fun, let’s look at some other cool examples.
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 只是为了好玩，让我们看看一些其他酷炫的示例。
- en: 'Let’s create a script, which we’ll call `am_i_root_1.sh`, which will look like
    this:'
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一个脚本，叫做`am_i_root_1.sh`，它将如下所示：
- en: '[PRE93]'
  id: totrans-358
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: 'The `whoami` command returns the name of the user who’s running the command.
    Here’s what that looks like when I run it first without `sudo`, and then with
    `sudo`:'
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: '`whoami`命令返回运行该命令的用户的用户名。这是我在没有`sudo`的情况下运行命令，再在有`sudo`的情况下运行时的输出：'
- en: '[PRE94]'
  id: totrans-360
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
- en: 'As you see, running `whoami` with `sudo` shows that I’m the root user. The
    first command uses the `!=` operator to test if the user is *not* the root user.
    The second command uses the `==` operator to test if the user *is* the root user.
    Now, let’s run the script to see what happens:'
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，使用`sudo`运行`whoami`命令显示我当前是root用户。第一个命令使用`!=`操作符来测试当前用户*不是*root用户。第二个命令使用`==`操作符来测试当前用户*是*root用户。现在，让我们运行脚本看看会发生什么：
- en: '[PRE95]'
  id: totrans-362
  prefs: []
  type: TYPE_PRE
  zh: '[PRE95]'
- en: 'It works, which means that we have achieved coolness. But, we can be even more
    cool by streamlining things a bit. Modify the script so that it looks like this:'
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: 它有效，这意味着我们已经达到了酷炫的效果。但我们可以通过稍微简化一下流程变得更酷。修改脚本，使其看起来像这样：
- en: '[PRE96]'
  id: totrans-364
  prefs: []
  type: TYPE_PRE
  zh: '[PRE96]'
- en: Instead of two commands in this script, I now have only one. But either way,
    the output is identical.
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，这个脚本中只需要一个命令，而不是两个。但无论如何，输出是相同的。
- en: 'Instead of placing your command within a `$( )` construct, you can also surround
    it with a pair of backticks, like this:'
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: 与其将命令放入`$( )`结构中，你也可以将其用一对反引号包围，如下所示：
- en: '[PRE97]'
  id: totrans-367
  prefs: []
  type: TYPE_PRE
  zh: '[PRE97]'
- en: That works, but it’s a deprecated method that I don’t recommend. The biggest
    problem with it is that if your command contains any special characters that the
    shell might interpret incorrectly, you’ll have to be sure to escape them with
    a backslash. With the newer `$( )` construct, you don’t have to worry so much
    about that. I’m only mentioning this method because you might still see other
    people’s scripts that use it.
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: 这样也行，但它是一个已弃用的方法，我不推荐使用。它最大的问题是，如果你的命令中包含任何可能被Shell错误解析的特殊字符，你必须确保用反斜杠进行转义。而使用更新的`$(
    )`结构，你就不需要太担心这个问题。我提到这个方法只是因为你可能仍然会看到其他人使用它的脚本。
- en: That does it for the command substitution business. Now, we need to make some
    decisions.
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: 这就完成了命令替换的部分。接下来，我们需要做出一些决策。
- en: Understanding Decisions and Loops
  id: totrans-370
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解决策与循环
- en: So far, I’ve been showing you a lot of programming techniques and constructs
    that are specific to shell scripting. In this section, I’ll show you some constructs
    that are common to most all programming languages. I’ll begin by showing you another
    way to make decisions.
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我已经向你展示了很多特定于Shell脚本的编程技巧和结构。在本节中，我将向你展示一些大多数编程语言都通用的结构。我将首先展示另一种决策方法。
- en: The if. .then Construct
  id: totrans-372
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '`if .. then`结构'
- en: 'Although the `&&` and `||` decision constructs work for simple scripts, you
    might want to use `if . . then` constructs for anything more complex, such as
    when you would need to test for multiple conditions at once. For the first example,
    create the `am_i_root_2.sh` script, which will look like this:'
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然`&&`和`||`决策结构适用于简单脚本，但对于更复杂的脚本，你可能需要使用`if .. then`结构，特别是当你需要同时测试多个条件时。对于第一个例子，创建`am_i_root_2.sh`脚本，它应该是这样的：
- en: '[PRE98]'
  id: totrans-374
  prefs: []
  type: TYPE_PRE
  zh: '[PRE98]'
- en: Note that each decision stanza begins with `if` and ends with `fi`. (Yes, that’s
    `if` spelled backwards.) Also note that with `bash` shell scripting, indentation
    isn’t required, as it is in certain other programming languages. But, it does
    make the code much more readable.
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，每个决策语句块都是以`if`开始并以`fi`结束的。（是的，`fi`就是`if`倒过来拼的。）还需要注意的是，在`bash` Shell脚本中，不像某些其他编程语言那样强制要求缩进，但它确实能使代码更具可读性。
- en: Instead of using the `whoami` command this time, I’m using the `id` command,
    which offers more options than `whoami`. (See the man pages for both commands
    for details.) As far as the rest of it goes, rather than trying to explain it
    all in detail, I’ll just let you study this script to see how everything works.
    That will be easier for me, and less boring for you. And besides, I have faith
    in you.
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: 这次我没有使用`whoami`命令，而是使用了`id`命令，后者提供了比`whoami`更多的选项。（详细信息请参见这两个命令的手册页。）至于脚本的其余部分，我不会逐一解释，而是让你自己研究这个脚本，看看它是如何工作的。这样对我来说更容易，对你来说也不那么无聊。而且，我相信你能搞定。
- en: 'Now, let’s see what happens when I run this script:'
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看当我运行这个脚本时会发生什么：
- en: '[PRE99]'
  id: totrans-378
  prefs: []
  type: TYPE_PRE
  zh: '[PRE99]'
- en: 'When you’re testing for more than one condition for the same decision, it would
    be more proper to use one `if .. then .. elif` construct, rather than two `if
    .. then` constructs. This can add a bit more clarity to your code, so that anyone
    who reads it can make a bit more sense of it. Let’s create the `am_i_root_3.sh`
    script to showcase this technique. Make it look like this:'
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: 当你需要为同一个决策测试多个条件时，使用一个`if .. then .. elif`结构会更合适，而不是使用两个`if .. then`结构。这可以使你的代码更加清晰，以便任何阅读它的人都能更容易理解。我们来创建`am_i_root_3.sh`脚本来展示这个技巧。它看起来应该是这样的：
- en: '[PRE100]'
  id: totrans-380
  prefs: []
  type: TYPE_PRE
  zh: '[PRE100]'
- en: The `elif` keyword in this script is short for `else if`. Other than that, everything
    is pretty much the same as it was before in the previous script. When you run
    it, you’ll get the same output as you got for the previous script. Also, note
    that you can test for multiple conditions with more than one `elif` stanza.
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: 这个脚本中的`elif`关键字是`else if`的缩写。除此之外，一切和之前的脚本几乎没有区别。当你运行它时，你将获得与之前脚本相同的输出。此外，请注意，你可以通过多个`elif`语句来测试多个条件。
- en: 'Alternatively, you could also use an `if .. then .. else` construct. Create
    the `am_i_root_4.sh` script, which will look like this:'
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: 另外，你也可以使用`if .. then .. else`结构。创建`am_i_root_4.sh`脚本，它应该是这样的：
- en: '[PRE101]'
  id: totrans-383
  prefs: []
  type: TYPE_PRE
  zh: '[PRE101]'
- en: 'Using `else` can be handy, because it defines a default action to take if the
    conditions in any of the `if` or `elif` stanzas aren’t fulfilled. For example,
    take a look at this script that detects which operating system your machine is
    running:'
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`else`非常方便，因为它定义了当任何`if`或`elif`语句中的条件没有得到满足时应该采取的默认动作。例如，看看这个检测机器运行哪个操作系统的脚本：
- en: '[PRE102]'
  id: totrans-385
  prefs: []
  type: TYPE_PRE
  zh: '[PRE102]'
- en: You see that this script can detect Linux, macOS, or FreeBSD. If the machine
    isn’t running any of those three operating systems, the `else` statement at the
    end displays the default message. Another thing to note is that you’ll need to
    place a semi-colon and a `then` keyword at the end of each `if` or `elif` statement,
    but you don’t need to place them after an `else` statement.
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: 你会看到，这个脚本可以检测Linux、macOS或FreeBSD操作系统。如果机器没有运行这三种操作系统中的任何一种，那么最后的`else`语句会显示默认消息。另一个需要注意的事项是，你需要在每个`if`或`elif`语句的末尾添加分号和`then`关键字，但在`else`语句后则不需要添加它们。
- en: 'Here’s how that looks when I run the script on an OpenIndiana machine:'
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我在OpenIndiana机器上运行脚本时的结果：
- en: '[PRE103]'
  id: totrans-388
  prefs: []
  type: TYPE_PRE
  zh: '[PRE103]'
- en: Of course, if I wanted to, I could insert another `elif` stanza to test for
    SunOS.
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，如果我愿意，我可以插入另一个`elif`语句来测试SunOS。
- en: That about covers it for `if. .then`. Let’s now do something while waiting for
    something else.
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: 这基本上涵盖了`if...then`的内容。现在让我们做一些事情，同时等待其他事情发生。
- en: The do. . while construct
  id: totrans-391
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '`do...while`构造'
- en: 'This construct will continuously execute a set of commands while a certain
    condition is true. Here’s an example:'
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
  zh: 这个构造会在某个条件为真时持续执行一组命令。这里有一个例子：
- en: '[PRE104]'
  id: totrans-393
  prefs: []
  type: TYPE_PRE
  zh: '[PRE104]'
- en: 'This `while_demo.sh` script starts by assigning a value of `10` to the `x`
    variable. As long as the value of `x` remains greater than `0`, it will subtract
    `1` from this value and assign the new value to `x`, using the `expr $x-1` command.
    It then echos the new value. The output looks like this:'
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: 这个`while_demo.sh`脚本从给`x`变量赋值为`10`开始。只要`x`的值大于`0`，它就会从该值中减去`1`，并使用`expr $x-1`命令将新值赋给`x`，然后回显新值。输出如下所示：
- en: '[PRE105]'
  id: totrans-395
  prefs: []
  type: TYPE_PRE
  zh: '[PRE105]'
- en: 'Note that in this `while_demo.sh` script, you can use a bit of shorthand for
    decrementing the value of `x` by 1 for each loop. Just replace the `x=$(expr $x
    - 1)` line with:'
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，在这个`while_demo.sh`脚本中，你可以使用简写的方式在每次循环中将`x`的值减去1。只需将`x=$(expr $x - 1)`这一行替换为：
- en: '[PRE106]'
  id: totrans-397
  prefs: []
  type: TYPE_PRE
  zh: '[PRE106]'
- en: This is the same type of construct that you might be used to seeing in C or
    C++ language programs. However, this construct is not portable, which means that
    it works fine on `bash`, but not on other shells. So, if you need to make your
    script so that it will run on Bourne shell, `dash`, or `ash`, you’ll need to avoid
    this construct and instead stick with the `x=$(expr $x - 1)` construct.
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
  zh: 这与你可能习惯在C或C++语言程序中看到的构造是一样的。然而，这种构造并不具有可移植性，这意味着它在`bash`上能正常工作，但在其他shell上却不行。因此，如果你需要编写一个能够在Bourne
    shell、`dash`或`ash`上运行的脚本，你需要避免使用这种构造，而是坚持使用`x=$(expr $x - 1)`构造。
- en: 'You could also use a `while` loop to read a text file, line-by-line. Here’s
    the very simple `read_file.sh` script that reads the `/etc/passwd` file:'
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以使用`while`循环逐行读取文本文件。这是一个非常简单的`read_file.sh`脚本，用来读取`/etc/passwd`文件：
- en: '[PRE107]'
  id: totrans-400
  prefs: []
  type: TYPE_PRE
  zh: '[PRE107]'
- en: As you see, I start by creating the `file` variable with `/etc/passwd` as its
    assigned value. The `while` line defines the variable line, and the `read -r`
    command assigns values to the line variable. On each pass of the while loop, the
    `read -r` command reads one line of the file, assigns the contents of the line
    to the `line` variable, and then echos the contents of the line to `stdout`. When
    all lines of the file have been read, the loop terminates. At the end, you see
    that I’m using a `stdin` redirector to make the `while` loop read the file. Normally,
    `read` breaks long lines into shorter lines and terminates each part of the long
    line with a backslash. The `-r` option disables that behavior.
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，我首先创建了`file`变量，并将`/etc/passwd`赋值给它。`while`语句定义了`line`变量，`read -r`命令将值赋给`line`变量。在每次`while`循环时，`read
    -r`命令读取文件的一行，将这一行的内容赋给`line`变量，然后将该行内容回显到`stdout`。当文件的所有行都读取完毕时，循环终止。最后，你看到我使用了`stdin`重定向器，使`while`循环读取文件。通常情况下，`read`会将长行拆分成短行，并在每一部分的末尾加上反斜杠。`-r`选项禁用了这种行为。
- en: 'There may be times when you’ll want to create an infinite loop that never stops
    until you tell it to. (There might also be times when you’ll create an infinite
    loop by accident, but that’s a whole different story. For now, let’s assume that
    you want to do it on purpose.) To demonstrate, create the `infinite_loop.sh` script,
    and make it look like this:'
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会有想要创建一个无限循环的情况，直到你手动停止它为止。（也可能会有某些时候你会不小心创建一个无限循环，但那是另外一个故事。现在，假设你是故意这么做的。）为了演示，创建`infinite_loop.sh`脚本，并使其看起来像这样：
- en: '[PRE108]'
  id: totrans-403
  prefs: []
  type: TYPE_PRE
  zh: '[PRE108]'
- en: 'It’s a rather useless script, which does nothing but echo some messages. The
    `sleep 1` command causes a one-second delay between each iteration of the loop.
    Here’s what happens when I run this script:'
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个相当无用的脚本，除了回显一些信息外没有其他作用。`sleep 1`命令在每次循环迭代之间引入了一秒的延迟。这是我运行此脚本时发生的情况：
- en: '[PRE109]'
  id: totrans-405
  prefs: []
  type: TYPE_PRE
  zh: '[PRE109]'
- en: There are still a few other tricks that we can do with `while..do`, but this
    will do it for now. Let’s now look at `for..in`.
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
  zh: 我们仍然可以用`while..do`做一些其他的技巧，但目前就先到这里。现在让我们看看`for..in`。
- en: The for..in Construct
  id: totrans-407
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '`for..in`构造'
- en: 'The `for . . in` construct will process a list, and perform a command for each
    item in the list. In this `car_demo_2.sh` script, the `for` line creates the `cars`
    variable. Here’s what it looks like:'
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
  zh: '`for...in`构造将处理一个列表，并对列表中的每个项目执行一条命令。在这个`car_demo_2.sh`脚本中，`for`语句创建了`cars`变量。它的样子如下：'
- en: '[PRE110]'
  id: totrans-409
  prefs: []
  type: TYPE_PRE
  zh: '[PRE110]'
- en: 'Each time that the loop iterates, the `in` keyword takes a name of a classic
    car from the list, and assigns it to `cars` as its value. The loop ends when it
    reaches the end of the list. Here’s what happens when I run the script:'
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
  zh: 每次循环迭代时，`in` 关键字从列表中获取一个经典汽车的名称，并将其赋值给 `cars`。当循环到达列表末尾时，循环结束。以下是我运行脚本时发生的情况：
- en: '[PRE111]'
  id: totrans-411
  prefs: []
  type: TYPE_PRE
  zh: '[PRE111]'
- en: 'That’s easy enough, so let’s try another one. This time, create the `list_demo.sh`
    script, like this:'
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
  zh: 这很简单，让我们再试试另一个。这次，创建 `list_demo.sh` 脚本，如下所示：
- en: '[PRE112]'
  id: totrans-413
  prefs: []
  type: TYPE_PRE
  zh: '[PRE112]'
- en: 'This loop just does an `ls`-style listing of the files in your current directory.
    I’m using the `*` wildcard to tell `for` to read in all of the filenames, regardless
    of how many files there are. In the `echo` line, I have to surround `$filename`
    with a pair of double quotes in case any filenames contain blank spaces. Here’s
    what happens when I run it:'
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
  zh: 这个循环只是对当前目录中的文件进行 `ls` 样式的列出。我使用 `*` 通配符告诉 `for` 读取所有文件名，无论有多少文件。在 `echo` 行中，我需要用一对双引号将
    `$filename` 括起来，以防文件名中包含空格。以下是我运行时的情况：
- en: '[PRE113]'
  id: totrans-415
  prefs: []
  type: TYPE_PRE
  zh: '[PRE113]'
- en: The reason this works is that if you do `echo *` from the command-line, you’ll
    see a jumbled-up listing of files in the directory. The `for..in` loop causes
    `echo` to list each filename on its own line.
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
  zh: 之所以能这样工作，是因为如果你从命令行执行 `echo *`，你会看到目录中文件的混乱列表。`for..in` 循环会导致 `echo` 将每个文件名列出在单独的一行。
- en: Okay, we’ve just looked at `for..in`. Let’s now look at `for`.
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，我们刚刚看过 `for..in`。现在让我们来看一下 `for`。
- en: The for Construct
  id: totrans-418
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '`for` 结构'
- en: 'This is similar to the `for . . in` construct, except for where it gets its
    list. With `for`, the user will enter the list as arguments when calling the script.
    Let’s create the `car_demo_3.sh` script to demonstrate this:'
  id: totrans-419
  prefs: []
  type: TYPE_NORMAL
  zh: 这与 `for . . in` 结构类似，唯一不同的是它获取列表的方式。使用 `for` 时，用户在调用脚本时会将列表作为参数传入。让我们创建 `car_demo_3.sh`
    脚本来演示这个：
- en: '[PRE114]'
  id: totrans-420
  prefs: []
  type: TYPE_PRE
  zh: '[PRE114]'
- en: 'The `cars` variable gets created in the `for` line, but there’s no list of
    cars. So, where does the list come from? It comes from arguments that the user
    enters on the command-line when he or she invokes the script. Instead of using
    classic car names this time, let’s use a list of modern car names, like so:'
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
  zh: '`cars` 变量在 `for` 行中创建，但没有汽车列表。那么，列表是从哪里来的呢？它来自用户在命令行中调用脚本时输入的参数。这次，我们不用经典的汽车名称，而是使用一组现代汽车名称，如下所示：'
- en: '[PRE115]'
  id: totrans-422
  prefs: []
  type: TYPE_PRE
  zh: '[PRE115]'
- en: Next, let’s look at the `break` command.
  id: totrans-423
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们看看 `break` 命令。
- en: Using break
  id: totrans-424
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 break
- en: 'Use the `break` command to further control how you want `for..in` and `while..do`
    loops to operate. To see how this works, create the `break_demo.sh` script and
    make it look like this:'
  id: totrans-425
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `break` 命令进一步控制 `for..in` 和 `while..do` 循环的操作方式。为了查看其工作原理，创建 `break_demo.sh`
    脚本并使其如下所示：
- en: '[PRE116]'
  id: totrans-426
  prefs: []
  type: TYPE_PRE
  zh: '[PRE116]'
- en: 'The `while` line tells the script to run as long as the value of `j` is less
    than `5`. The `j=$((j + 1))` construct on the sixth line is a mathematical operator,
    with increments the value of `j` by `1` on each iteration of the loop. The `if..then`
    construct that starts on the seventh line defines what should happen when the
    value of `j` is equal to `2`. The `break` command then terminates the loop. Here’s
    how it looks:'
  id: totrans-427
  prefs: []
  type: TYPE_NORMAL
  zh: '`while` 行告诉脚本在 `j` 的值小于 `5` 时运行。第六行的 `j=$((j + 1))` 结构是一个数学运算符，每次循环迭代时会将 `j`
    的值加 `1`。第七行开始的 `if..then` 结构定义了当 `j` 的值等于 `2` 时应该发生的事情。然后 `break` 命令终止循环。以下是其表现：'
- en: '[PRE117]'
  id: totrans-428
  prefs: []
  type: TYPE_PRE
  zh: '[PRE117]'
- en: 'As I’ve indicated for the `while_demo.sh` script, you can replace the `j=$((j
    + 1))` construct with:'
  id: totrans-429
  prefs: []
  type: TYPE_NORMAL
  zh: 如同我在 `while_demo.sh` 脚本中所示，你可以用以下内容替换 `j=$((j + 1))` 结构：
- en: '[PRE118]'
  id: totrans-430
  prefs: []
  type: TYPE_PRE
  zh: '[PRE118]'
- en: However, `((j++))` is `bash`-specific, and might not work on other non-`bash`
    shells.
  id: totrans-431
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，`((j++))` 是特定于 `bash` 的，可能在其他非 `bash` 的 shell 中无法使用。
- en: You can also express this as `j=$(expr j + 1)`, which is also portable, and
    is the form that I showed you in the `while_demo.sh` script.
  id: totrans-432
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以将其表示为 `j=$(expr j + 1)`，这也是便携式的，并且是我在 `while_demo.sh` 脚本中向你展示的形式。
- en: (I’ll show you more about performing math in shell scripts in *Chapter 11, Performing
    Mathematical Operations*.)
  id: totrans-433
  prefs: []
  type: TYPE_NORMAL
  zh: （我将在 *第11章：执行数学运算* 中向你展示更多关于在 shell 脚本中执行数学运算的内容。）
- en: 'Just for fun, delete the `break` command from the script and run it again.
    You should now see this:'
  id: totrans-434
  prefs: []
  type: TYPE_NORMAL
  zh: 只是为了好玩，从脚本中删除 `break` 命令并重新运行。现在你应该看到以下内容：
- en: '[PRE119]'
  id: totrans-435
  prefs: []
  type: TYPE_PRE
  zh: '[PRE119]'
- en: This time, the loop keeps running past the number `2`.
  id: totrans-436
  prefs: []
  type: TYPE_NORMAL
  zh: 这次，循环会继续执行直到数字 `2` 之后。
- en: Now that we’ve taken a break, let’s continue.
  id: totrans-437
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们已经休息一下，接下来让我们继续。
- en: Using continue
  id: totrans-438
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 continue
- en: 'The `continue` command also modifies how `for..in` and `while..do` loops operate.
    This time, create the `for_continue.sh` script, and make it look like this:'
  id: totrans-439
  prefs: []
  type: TYPE_NORMAL
  zh: '`continue` 命令还会修改 `for..in` 和 `while..do` 循环的操作方式。这次，创建 `for_continue.sh` 脚本，并使其如下所示：'
- en: '[PRE120]'
  id: totrans-440
  prefs: []
  type: TYPE_PRE
  zh: '[PRE120]'
- en: 'On each iteration of the `for` loop, a different classic car name gets assigned
    as the value of `cars`. The `if..then` stanza determines if the value of `cars`
    is either `Buick` or `Mercury`. The `continue` command within the `if..then` stanza
    causes the loop to skip over those two car names, so that the `echo` command won’t
    list them. You also see another use for the `||` construct here. When used within
    a test operation, the `||` acts as an `or` operator. Here’s what the output looks
    like:'
  id: totrans-441
  prefs: []
  type: TYPE_NORMAL
  zh: 在`for`循环的每次迭代中，都会将一个不同的经典汽车名称赋值给`cars`。`if..then`部分会判断`cars`的值是否为`Buick`或`Mercury`。`if..then`中的`continue`命令会导致循环跳过这两个汽车名称，以避免`echo`命令列出它们。你还会看到`||`结构的另一个用法。它在测试操作中作为`or`运算符使用。输出效果如下：
- en: '[PRE121]'
  id: totrans-442
  prefs: []
  type: TYPE_PRE
  zh: '[PRE121]'
- en: 'Next, let’s try this with a `while..do` loop. Create the `while_continue.sh`
    script, like this:'
  id: totrans-443
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们尝试使用`while..do`循环。像这样创建`while_continue.sh`脚本：
- en: '[PRE122]'
  id: totrans-444
  prefs: []
  type: TYPE_PRE
  zh: '[PRE122]'
- en: 'This time, we just want to skip over numbers 3 and 6\. Here’s the output:'
  id: totrans-445
  prefs: []
  type: TYPE_NORMAL
  zh: 这次，我们只是想跳过3和6这两个数字。输出如下：
- en: '[PRE123]'
  id: totrans-446
  prefs: []
  type: TYPE_PRE
  zh: '[PRE123]'
- en: Okay, enough of that. Let’s look at the `until` construct.
  id: totrans-447
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，够了。让我们看看`until`结构。
- en: The until Construct
  id: totrans-448
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '`until` 结构'
- en: 'The `until` loop will continue until a certain condition is met. You can use
    it for a variety of things, such as playing a guessing game. See how it works
    by creating the `secret_word.sh` script, like this:'
  id: totrans-449
  prefs: []
  type: TYPE_NORMAL
  zh: '`until`循环会一直执行，直到满足某个条件。你可以用它来做各种事情，比如玩猜谜游戏。通过创建`secret_word.sh`脚本来看看它是如何工作的，像这样：'
- en: '[PRE124]'
  id: totrans-450
  prefs: []
  type: TYPE_PRE
  zh: '[PRE124]'
- en: 'So, I’ve set the `secretword` to `Donnie`. (Hey, that’s me!) I then set `word`
    to a null value. The `until` loop will run until I enter the correct value for
    `secretword`. (In this case, `read` pauses the script until you enter your guess.)
    It works like this:'
  id: totrans-451
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，我将`secretword`设置为`Donnie`。（嘿，那是我！）然后我将`word`设置为空值。`until`循环会一直执行，直到我输入正确的`secretword`值。（在这种情况下，`read`会暂停脚本，直到你输入猜测的内容。）它是这样工作的：
- en: '[PRE125]'
  id: totrans-452
  prefs: []
  type: TYPE_PRE
  zh: '[PRE125]'
- en: Cool, right? I mean, this is yet another trick that you can perform at your
    next party.
  id: totrans-453
  prefs: []
  type: TYPE_NORMAL
  zh: 酷吧？我是说，这又是一个你可以在下次聚会时表演的小技巧。
- en: All right, let’s move on to the next one.
  id: totrans-454
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，接下来让我们继续看看下一个。
- en: The case Construct
  id: totrans-455
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '`case` 结构'
- en: 'The `case` construct provides a way to avoid using an `if..then..else` construct.
    It allows users to enter a text string, then evaluate that string and provide
    the option that the string indicates. Here’s the basic structure of case:'
  id: totrans-456
  prefs: []
  type: TYPE_NORMAL
  zh: '`case` 结构提供了一种避免使用`if..then..else`结构的方法。它允许用户输入一个文本字符串，然后评估该字符串并提供相应的选项。下面是`case`的基本结构：'
- en: '[PRE126]'
  id: totrans-457
  prefs: []
  type: TYPE_PRE
  zh: '[PRE126]'
- en: The `case` statement is matched against a number of values until a match is
    found. When a match is found, the commands are executed until the double semicolons
    (`;;`) are reached. Then, the commands after the `esac` line are executed.
  id: totrans-458
  prefs: []
  type: TYPE_NORMAL
  zh: '`case` 语句会与多个值进行匹配，直到找到匹配项。当找到匹配项时，命令会被执行，直到遇到双分号（`;;`）。然后，`esac`行之后的命令会被执行。'
- en: If there is no match, then the commands between the `*)` and the double semicolons
    are executed. The `*)` acts the same way as the `else` in an `if ...then` construct,
    in that they both provide a default action in case none of the tested conditions
    are met.
  id: totrans-459
  prefs: []
  type: TYPE_NORMAL
  zh: 如果没有匹配项，则执行`*)`和双分号之间的命令。`*)`的作用与`if...then`结构中的`else`相同，都是在没有匹配任何条件时提供默认操作。
- en: 'Just for fun, try this out by creating the `term_color.sh` script, which will
    look like this:'
  id: totrans-460
  prefs: []
  type: TYPE_NORMAL
  zh: 仅为好玩，尝试创建`term_color.sh`脚本，效果如下：
- en: '[PRE127]'
  id: totrans-461
  prefs: []
  type: TYPE_PRE
  zh: '[PRE127]'
- en: 'This script allows you to change the background color of your terminal. (And
    yes, I know that I’ve set the `g` option to `white`. That’s because when you run
    this script and choose the `g` option, the background will look more gray than
    white.) Running the script looks like this:'
  id: totrans-462
  prefs: []
  type: TYPE_NORMAL
  zh: 这个脚本允许你更改终端的背景颜色。（是的，我知道我将`g`选项设置为`white`。这是因为当你运行这个脚本并选择`g`选项时，背景看起来会比白色更灰一些。）运行脚本的效果如下：
- en: '[PRE128]'
  id: totrans-463
  prefs: []
  type: TYPE_PRE
  zh: '[PRE128]'
- en: Run the script in your own terminal, choose the `g` option, and you should see
    the background of the command prompt turn gray. (Or, if your terminal is already
    set up with a white background, choose the `b` option, instead.) To see the background
    for the whole terminal turn gray, just type `clear`.
  id: totrans-464
  prefs: []
  type: TYPE_NORMAL
  zh: 在你自己的终端中运行脚本，选择`g`选项，你应该会看到命令提示符的背景变灰。（或者，如果你的终端已经设置为白色背景，可以选择`b`选项。）要让整个终端背景变灰，只需输入`clear`。
- en: 'For even more fun, edit the script to add another option. First, make the `echo`
    line at the top look like this:'
  id: totrans-465
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更有趣，编辑脚本并添加一个新的选项。首先，将顶部的`echo`行改成这样：
- en: '[PRE129]'
  id: totrans-466
  prefs: []
  type: TYPE_PRE
  zh: '[PRE129]'
- en: 'Then, add the `y` option after the `g` option. This new option will look like
    this:'
  id: totrans-467
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，在`g`选项后添加`y`选项。这个新选项会像这样：
- en: '[PRE130]'
  id: totrans-468
  prefs: []
  type: TYPE_PRE
  zh: '[PRE130]'
- en: 'To see something that’s hideously ugly, run the script again and choose the
    `y` option. (Don’t worry though, because the setting isn’t permanent.) Here’s
    how using the various options will look:'
  id: totrans-469
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看一些非常丑陋的内容，请再次运行脚本并选择`y`选项。（不过别担心，这个设置不是永久性的。）以下是使用各种选项的效果：
- en: '![](img/B21693_08_01.png)'
  id: totrans-470
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B21693_08_01.png)'
- en: 'Figure 8.1: Running the term_color.sh script'
  id: totrans-471
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.1：运行term_color.sh脚本
- en: Okay, you’ve already seen how to use `for` to enter arguments when you invoke
    your scripts. Now, let’s look at another way.
  id: totrans-472
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，你已经看过如何使用`for`在调用脚本时传递参数。现在，让我们看看另一种方式。
- en: Using Positional Parameters
  id: totrans-473
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用位置参数
- en: When you run a shell script, you can also enter command-line parameters that
    will be used within the script. The first parameter that you enter will be designated
    as `$1`, the second will be designated as `$2`, and so on. (`$9` is as high as
    you can go.) The `$0` parameter is reserved for the name of the script.
  id: totrans-474
  prefs: []
  type: TYPE_NORMAL
  zh: 当你运行一个shell脚本时，你还可以输入命令行参数，这些参数将在脚本中使用。你输入的第一个参数将指定为`$1`，第二个参数将指定为`$2`，以此类推。（`$9`是你能达到的最大值。）`$0`参数保留给脚本的名称。
- en: 'To see how this works, create the `position_demo.sh` script, which will look
    like this:'
  id: totrans-475
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看这如何工作，创建`position_demo.sh`脚本，它将如下所示：
- en: '[PRE131]'
  id: totrans-476
  prefs: []
  type: TYPE_PRE
  zh: '[PRE131]'
- en: 'To invoke the script, enter three names after the name of the script, like
    this:'
  id: totrans-477
  prefs: []
  type: TYPE_NORMAL
  zh: 要调用脚本，输入三个名字，格式如下：
- en: '[PRE132]'
  id: totrans-478
  prefs: []
  type: TYPE_PRE
  zh: '[PRE132]'
- en: In the output, the `$1`, `$2`, and `$3` variables will be expanded to the names
    that I entered on the command-line. The `$0` variable will be expanded to the
    full path and name of the script.
  id: totrans-479
  prefs: []
  type: TYPE_NORMAL
  zh: 在输出中，`$1`、`$2`和`$3`变量将被展开为我在命令行中输入的名字。`$0`变量将展开为脚本的完整路径和名称。
- en: 'There are three special positional parameters that you can use to enhance your
    scripts. Here’s the list:'
  id: totrans-480
  prefs: []
  type: TYPE_NORMAL
  zh: 有三个特殊的定位参数，你可以用来增强脚本功能。以下是列表：
- en: '`$#`: This shows the number of parameters that you’ve entered.'
  id: totrans-481
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`$#`：这显示你输入的参数数量。'
- en: '`$@`: This lists all of the parameters that you’ve entered, with each one on
    a separate line.'
  id: totrans-482
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`$@`：这会列出你输入的所有参数，每个参数占一行。'
- en: '`$*`: This lists all of the parameters that you’ve entered on a single line,
    with a blank space between each one.'
  id: totrans-483
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`$*`：这会将你输入的所有参数列在一行上，每个参数之间用空格分隔。'
- en: 'One cool thing that you can do with the `$#` parameter is error-checking. To
    see what I mean, run the `position_demo.sh` script again, but only enter one name
    as an argument. You should see something like this:'
  id: totrans-484
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以用`$#`参数进行错误检查。为了理解我的意思，请重新运行`position_demo.sh`脚本，但只输入一个名字作为参数。你应该会看到如下输出：
- en: '[PRE133]'
  id: totrans-485
  prefs: []
  type: TYPE_PRE
  zh: '[PRE133]'
- en: 'As you see, it gave me no warning about the fact that I didn’t list the correct
    number of names. Let’s modify things a bit to take care of that. Create the `position_demo_2.sh`
    script, and make it look like this:'
  id: totrans-486
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，它并没有警告我没有列出正确数量的名字。让我们稍微修改一下，以处理这个问题。创建`position_demo_2.sh`脚本，让它看起来像这样：
- en: '[PRE134]'
  id: totrans-487
  prefs: []
  type: TYPE_PRE
  zh: '[PRE134]'
- en: 'Run this script with all three names, and you’ll get the same output that you
    got with the first script. Then, run it again with only one name, and you should
    see this:'
  id: totrans-488
  prefs: []
  type: TYPE_NORMAL
  zh: 用三个名字运行这个脚本，你会得到与第一个脚本相同的输出。然后，再用一个名字运行，你应该会看到如下输出：
- en: '[PRE135]'
  id: totrans-489
  prefs: []
  type: TYPE_PRE
  zh: '[PRE135]'
- en: That looks much better.
  id: totrans-490
  prefs: []
  type: TYPE_NORMAL
  zh: 看起来好多了。
- en: 'To introduce our next trick, take a look at the output of the `date` command,
    without specifying any formatting options, like this:'
  id: totrans-491
  prefs: []
  type: TYPE_NORMAL
  zh: 为了介绍我们的下一个技巧，请查看`date`命令的输出，不指定任何格式选项，像这样：
- en: '[PRE136]'
  id: totrans-492
  prefs: []
  type: TYPE_PRE
  zh: '[PRE136]'
- en: 'You see seven fields in the output, which are:'
  id: totrans-493
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以看到输出中有七个字段，分别是：
- en: Day of week
  id: totrans-494
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 星期几
- en: Month
  id: totrans-495
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 月份
- en: Date
  id: totrans-496
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 日期
- en: Time
  id: totrans-497
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 时间
- en: AM or PM
  id: totrans-498
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 上午或下午
- en: Timezone
  id: totrans-499
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 时区
- en: Year
  id: totrans-500
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 年份
- en: 'Now, create the `position_demo_3.sh` script, which will treat each field of
    the date output as a positional parameter. Make it look like this:'
  id: totrans-501
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，创建`position_demo_3.sh`脚本，该脚本将把日期输出的每个字段作为位置参数处理。让它看起来像这样：
- en: '[PRE137]'
  id: totrans-502
  prefs: []
  type: TYPE_PRE
  zh: '[PRE137]'
- en: 'On the second line, you see another use for the `set` command that you haven’t
    yet seen. The first time you saw `set`, it was with the `-o` option to set shell
    options. This time, I’m using it without any options and with `$(date)` as an
    argument. Here’s what the `bash` man page says about using `set` in this manner:'
  id: totrans-503
  prefs: []
  type: TYPE_NORMAL
  zh: 在第二行，你看到了`set`命令的另一种用法，这是你之前没有见过的。你第一次看到`set`时，是使用`-o`选项来设置shell选项。这次，我没有使用任何选项，而是将`$(date)`作为参数传递。以下是`bash`手册页中关于以这种方式使用`set`的说明：
- en: Without options, display the name and value of each shell variable in a format
    that can be reused as input for setting or resetting the currently-set variables.
  id: totrans-504
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 如果没有选项，则以一种可以重复使用的格式显示每个shell变量的名称和值，用于设置或重置当前设置的变量。
- en: In this case, `set` is taking the output of `$(date)` and formatting it in a
    way that allows the individual fields to be used as positional parameters.
  id: totrans-505
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，`set` 获取 `$(date)` 的输出并以一种方式格式化它，使得各个字段可以作为位置参数使用。
- en: 'On the third line, you see where the real magic happens. The `$*` positional
    parameter lists all fields of `$(date)` on a single line. The rest of the `echo`
    commands just output a text string, followed by the value of the specified field
    or fields. Here’s what it looks like:'
  id: totrans-506
  prefs: []
  type: TYPE_NORMAL
  zh: 在第三行，你可以看到真正的魔法发生的地方。`$*` 位置参数将 `$(date)` 的所有字段列在一行上。其余的 `echo` 命令只是输出一个文本字符串，后面跟上指定字段或字段的值。它的样子是这样的：
- en: '[PRE138]'
  id: totrans-507
  prefs: []
  type: TYPE_PRE
  zh: '[PRE138]'
- en: It works as it should, and looks pretty cool. Add this to the list of tricks
    to try at your next party.
  id: totrans-508
  prefs: []
  type: TYPE_NORMAL
  zh: 它按预期工作，看起来相当酷。把这个加入到下次聚会时可以尝试的技巧清单里。
- en: I think that that about covers it for positional parameters. Let’s now look
    at exit codes.
  id: totrans-509
  prefs: []
  type: TYPE_NORMAL
  zh: 我认为关于位置参数的部分已经涵盖了。现在让我们来看看退出码。
- en: Understanding Exit Codes
  id: totrans-510
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解退出码
- en: 'You’ve already seen some examples of using the `exit` command, which can either
    terminate a script normally or cause it to terminate early upon an error condition.
    What I haven’t explained yet, is about **exit codes**. There are two general classes
    of exit codes, which are:'
  id: totrans-511
  prefs: []
  type: TYPE_NORMAL
  zh: 你已经看过一些使用 `exit` 命令的例子，它可以正常终止脚本，或者在发生错误时提前终止。我还没有解释的是关于 **退出码** 的内容。退出码大体分为两类，它们是：
- en: '**Standard shell exit codes**: Each shell has its own defined set of exit codes.
    (To keep things simple, I’ll just talk about `bash` exit codes in this chapter.)'
  id: totrans-512
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**标准 shell 退出码**：每个 shell 都有自己定义的退出码集合。（为了简化起见，本章只讨论 `bash` 退出码。）'
- en: '**User-defined exit codes**: You can also define your own exit codes for different
    purposes.'
  id: totrans-513
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**用户定义的退出码**：你也可以为不同的目的定义自己的退出码。'
- en: Let’s talk about standard exit codes first.
  id: totrans-514
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们首先讨论标准退出码。
- en: Standard Shell Exit Codes
  id: totrans-515
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 标准 Shell 退出码
- en: 'When a program or script runs successfully, it returns an exit code of `0`.
    Otherwise, the exit code will be a non-`0` number from `1` to `255`. To demonstrate,
    use `find` to search through the `/etc/` directory for the `passwd` file, like
    so:'
  id: totrans-516
  prefs: []
  type: TYPE_NORMAL
  zh: 当程序或脚本成功运行时，它会返回 `0` 的退出码。否则，退出码将是一个非 `0` 的数字，范围从 `1` 到 `255`。为了演示，使用 `find`
    搜索 `/etc/` 目录下的 `passwd` 文件，像这样：
- en: '[PRE139]'
  id: totrans-517
  prefs: []
  type: TYPE_PRE
  zh: '[PRE139]'
- en: 'You see that `find` found the file, but we also have a lot of `Permission denied`
    errors due to the fact that there are directories that I can’t enter with my normal
    user privileges. Now, verify the exit code, like this:'
  id: totrans-518
  prefs: []
  type: TYPE_NORMAL
  zh: 你看到 `find` 找到了文件，但我们也有很多 `Permission denied` 错误，因为有些目录我不能用普通用户权限进入。现在，验证退出码，像这样：
- en: '[PRE140]'
  id: totrans-519
  prefs: []
  type: TYPE_PRE
  zh: '[PRE140]'
- en: 'The `?` is a special variable that returns the exit code for the previous command
    that was just run. In this case, the exit code is `1`, which tells me that there
    was some kind of error condition. The specific error was that `find` couldn’t
    enter certain directories to perform its search. So, let’s try this again with
    `sudo`, like so:'
  id: totrans-520
  prefs: []
  type: TYPE_NORMAL
  zh: '`?` 是一个特殊变量，返回上一个执行命令的退出码。在这个例子中，退出码是 `1`，这告诉我发生了某种错误。具体的错误是 `find` 无法进入某些目录进行搜索。所以，我们再试一次，使用
    `sudo`，像这样：'
- en: '[PRE141]'
  id: totrans-521
  prefs: []
  type: TYPE_PRE
  zh: '[PRE141]'
- en: This time I get exit code `0`, which means that there were no error conditions.
  id: totrans-522
  prefs: []
  type: TYPE_NORMAL
  zh: 这次我得到的退出码是 `0`，意味着没有错误发生。
- en: 'Most of the time, you’ll see either `0` or `1` as the exit code. The complete
    list of codes that you might see include the following:'
  id: totrans-523
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数时候，你会看到退出码是 `0` 或 `1`。你可能会看到的完整代码列表包括以下内容：
- en: '`1` General errors'
  id: totrans-524
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`1` 一般错误'
- en: '`2` Misuse of shell builtins'
  id: totrans-525
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`2` 错误使用了 shell 内置命令'
- en: '`126` Cannot invoke requested command'
  id: totrans-526
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`126` 无法调用请求的命令'
- en: '`127` Command not found'
  id: totrans-527
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`127` 找不到命令'
- en: '`128` Invalid argument to `exit`'
  id: totrans-528
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`128` 退出命令的无效参数'
- en: '`128+n` Fatal error signal `n`'
  id: totrans-529
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`128+n` 致命错误信号 `n`'
- en: '`130` Script terminated by *Ctrl-c*'
  id: totrans-530
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`130` 脚本被 *Ctrl-c* 中断'
- en: 'It’s possible to demonstrate some of the other codes. Start by creating the
    `exit.sh` script, like so:'
  id: totrans-531
  prefs: []
  type: TYPE_NORMAL
  zh: 有可能演示其他的退出码。首先创建 `exit.sh` 脚本，像这样：
- en: '[PRE142]'
  id: totrans-532
  prefs: []
  type: TYPE_PRE
  zh: '[PRE142]'
- en: 'Right away, you can see the error. The `exit` command requires a numerical
    argument, and won’t work with an alphabetical argument. But, we’re going to pretend
    that we don’t see the error, and try to run it anyway. Here’s what you’ll get:'
  id: totrans-533
  prefs: []
  type: TYPE_NORMAL
  zh: 立刻，你可以看到错误。`exit` 命令需要一个数值参数，不能使用字母参数。但我们假装看不见这个错误，还是试着运行它。你会看到这样的结果：
- en: '[PRE143]'
  id: totrans-534
  prefs: []
  type: TYPE_PRE
  zh: '[PRE143]'
- en: The `2` exit code indicates that I misused a **shell builtin**.
  id: totrans-535
  prefs: []
  type: TYPE_NORMAL
  zh: '`2` 退出码表示我错误使用了 **shell 内置命令**。'
- en: A **shell builtin** is just a command that doesn’t have its own executable program
    file, because it’s built into the `bash` executable program file. One would think
    that I would get a `128` code, since I provided an invalid argument to `exit`,
    but that’s not how it works. (In fact, I’m really not sure what I would have to
    do to get a `128` code. But, that’s okay.) To see the complete list of shell builtins,
    just view the `builtins` man page.
  id: totrans-536
  prefs: []
  type: TYPE_NORMAL
  zh: '**Shell 内建命令**只是一个没有独立可执行程序文件的命令，因为它是内置在 `bash` 可执行程序文件中的。你可能会认为我会得到 `128`
    代码，因为我为 `exit` 提供了无效的参数，但事实并非如此。（事实上，我真的不确定我需要做什么才能得到 `128` 代码。但没关系。）要查看完整的 shell
    内建命令列表，只需查看 `builtins` 手册页。'
- en: 'A `126` code normally means that you don’t have permission to run a command.
    For example, let’s say that I forgot to set the executable permission on a script,
    as you see here:'
  id: totrans-537
  prefs: []
  type: TYPE_NORMAL
  zh: '`126` 代码通常意味着你没有权限执行某个命令。例如，假设我忘记为脚本设置可执行权限，如你所见：'
- en: '[PRE144]'
  id: totrans-538
  prefs: []
  type: TYPE_PRE
  zh: '[PRE144]'
- en: 'Watch what happens when I try to run this script:'
  id: totrans-539
  prefs: []
  type: TYPE_NORMAL
  zh: 看我尝试运行这个脚本时会发生什么：
- en: '[PRE145]'
  id: totrans-540
  prefs: []
  type: TYPE_PRE
  zh: '[PRE145]'
- en: 'You can generate a `127` code by trying to execute a command that doesn’t exist,
    like this:'
  id: totrans-541
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过尝试执行一个不存在的命令来生成 `127` 代码，比如这样：
- en: '[PRE146]'
  id: totrans-542
  prefs: []
  type: TYPE_PRE
  zh: '[PRE146]'
- en: Obviously, my name is not a command.
  id: totrans-543
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，我的名字不是一个命令。
- en: The `128+n` code means that some sort of fatal error condition occurred. The
    `n` signifies another digit that’s added to `128`. For example, if you start a
    command and *Ctrl-c* out of it before it completes, you’ll get a code of `128+2`,
    which equals `130`. (The `2` in this case indicates the specific fatal condition.)
  id: totrans-544
  prefs: []
  type: TYPE_NORMAL
  zh: '`128+n` 代码表示发生了某种致命错误条件。`n` 是一个额外的数字，它加到 `128` 上。例如，如果你启动一个命令并在它完成之前按 *Ctrl-c*
    停止它，你会得到 `128+2` 的代码，也就是 `130`。（在这种情况下，`2` 表示特定的致命条件。）'
- en: 'You can use standard exit codes within a shell script to make it handle different
    conditions. To see that, create the `netchk.sh` script, as follows:'
  id: totrans-545
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在 shell 脚本中使用标准退出代码来处理不同的条件。要查看这一点，可以创建如下的 `netchk.sh` 脚本：
- en: '[PRE147]'
  id: totrans-546
  prefs: []
  type: TYPE_PRE
  zh: '[PRE147]'
- en: This script expects you to invoke it with a hostname, domain name, or an IP
    address as an argument. In the first `if..then` construct at the top, you see
    that if you don’t enter an argument, the script will default to using `google.com`
    as the argument. \
  id: totrans-547
  prefs: []
  type: TYPE_NORMAL
  zh: '这个脚本期望你传递一个主机名、域名或 IP 地址作为参数。在顶部的第一个 `if..then` 结构中，你会看到，如果你没有输入参数，脚本会默认使用
    `google.com` 作为参数。 '
- en: Otherwise, it will use the argument that you specified. It will then try to
    ping the specified site. If the ping is successful, the exit code will be `0`.
    Otherwise, it will be something other than `0`.
  id: totrans-548
  prefs: []
  type: TYPE_NORMAL
  zh: 否则，它会使用你指定的参数。然后它会尝试 ping 该站点。如果 ping 成功，退出代码将是 `0`。否则，它会是其他非 `0` 的值。
- en: 'In the second `if..then` construct, you see that if the exit code is not `0`,
    it will echo a `Network Failure` message and send an entry to the system log file,
    which on the Fedora machine is `/var/log/messages`. Otherwise, it will echo a
    `Success` message. Here’s how that looks:'
  id: totrans-549
  prefs: []
  type: TYPE_NORMAL
  zh: 在第二个 `if..then` 结构中，你会看到，如果退出代码不是 `0`，它会回显 `Network Failure` 消息，并将一条记录写入系统日志文件，在
    Fedora 机器上该文件是 `/var/log/messages`。否则，它会回显 `Success` 消息。它看起来是这样的：
- en: '[PRE148]'
  id: totrans-550
  prefs: []
  type: TYPE_PRE
  zh: '[PRE148]'
- en: There’s not much else to say about the standard exit codes. So, let’s say a
    few words about user-defined exit codes.
  id: totrans-551
  prefs: []
  type: TYPE_NORMAL
  zh: 关于标准退出代码没有太多要说的了。那么，让我们说几句关于用户自定义退出代码的话。
- en: User-defined Exit Codes
  id: totrans-552
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 用户自定义退出代码
- en: You can specify your own exit codes simply by specifying a numerical argument
    for `exit`. This is handy for whenever you might need to pass some specific exit
    code to an external program. The Nagios network monitoring tool is a great example.
  id: totrans-553
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过为 `exit` 指定一个数字参数来指定你自己的退出代码。这在你需要将某个特定的退出代码传递给外部程序时非常有用。Nagios 网络监控工具就是一个很好的例子。
- en: Nagios is a tool that can monitor pretty much every type of device on your network.
    It can monitor various types of servers, workstations, routers, switches, and
    even printers. What makes it so cool is that it’s modular, which means that it
    works with plug-ins. If you need to monitor a particular device and find that
    there’s no plug-in that will do the job, you can just write your own. You can
    write plug-ins in a variety of programming languages, which includes shell scripting.
  id: totrans-554
  prefs: []
  type: TYPE_NORMAL
  zh: Nagios 是一个可以监控你网络中几乎所有类型设备的工具。它可以监控各种类型的服务器、工作站、路由器、交换机，甚至是打印机。它之所以这么酷，是因为它是模块化的，这意味着它支持插件。如果你需要监控一个特定的设备，并发现没有现成的插件能完成这项工作，你可以自己编写插件。你可以使用多种编程语言来编写插件，其中包括
    shell 脚本。
- en: 'You can install a Nagios monitoring agent on a server or workstation that you
    want to monitor, and create a shell script that generates exit codes that Nagios
    expects to see. To understand how it works, check out this code snippet from a
    larger script:'
  id: totrans-555
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在想要监控的服务器或工作站上安装一个Nagios监控代理，并创建一个生成Nagios期望看到的退出代码的Shell脚本。要了解它是如何工作的，可以查看以下来自更大脚本的代码片段：
- en: '[PRE149]'
  id: totrans-556
  prefs: []
  type: TYPE_PRE
  zh: '[PRE149]'
- en: This script is looking at the `/etc/passwd` file to see if there is more than
    one user with a UID of `0`. That’s important, because UID 0 is what gives a user
    account root user powers. So, on any Linux system, you never want to see more
    than one user account with UID 0\. In the `if..then` construct, you see that if
    the script finds more than one UID 0 account, it will generate an exit code of
    `2`. Otherwise, it will generate an exit code of `1`.
  id: totrans-557
  prefs: []
  type: TYPE_NORMAL
  zh: 这个脚本正在查看`/etc/passwd`文件，看看是否有多个用户的UID为`0`。这很重要，因为UID 0赋予用户根用户权限。所以，在任何Linux系统中，你绝对不想看到有多个用户账户的UID是0。在`if..then`结构中，你可以看到如果脚本发现多个UID
    0账户，它会生成一个退出代码`2`。否则，它会生成一个退出代码`1`。
- en: This exit code and its corresponding `echo` command get passed to the Nagios
    monitoring agent. The monitoring agent will then pass the output from the `echo`
    command to the Nagios server, which will display the message on the Nagios dashboard.
    (You’ll see the entire script in just a few moments, when you get to the *Looking
    at Some Real-World Examples* section.)
  id: totrans-558
  prefs: []
  type: TYPE_NORMAL
  zh: 这个退出代码及其对应的`echo`命令被传递给Nagios监控代理。然后，监控代理将`echo`命令的输出传递给Nagios服务器，Nagios服务器将在仪表板上显示该消息。（你将在稍后的*查看一些实际的例子*部分看到整个脚本。）
- en: That’s about it for exit codes. Let’s now take a closer look at `echo`.
  id: totrans-559
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是退出代码的全部内容。现在，让我们更仔细地看看`echo`。
- en: More Information About echo
  id: totrans-560
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 关于echo的更多信息
- en: You’ve already seen the most simple way to use `echo`, which is to either display
    a message on the screen or send text into a text file. What you haven’t seen yet
    is `echo`'s various formatting options.
  id: totrans-561
  prefs: []
  type: TYPE_NORMAL
  zh: 你已经看到了使用`echo`的最简单方法，即显示一条信息到屏幕上或将文本发送到文本文件中。你还没有看到的是`echo`的各种格式化选项。
- en: 'If you use it with the `-n` switch, you’ll prevent it from creating a new line
    at the end of the text output, like this:'
  id: totrans-562
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你使用`-n`选项，它会阻止在文本输出的末尾创建新的一行，如下所示：
- en: '[PRE150]'
  id: totrans-563
  prefs: []
  type: TYPE_PRE
  zh: '[PRE150]'
- en: 'Use it with the `-e` switch, and you’ll be able to use some backslash options.
    For example, to insert a vertical tab into a line of text, use the `-e` switch
    with the `\v` option, like this:'
  id: totrans-564
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`-e`选项，你将能够使用一些反斜杠选项。例如，要在一行文本中插入垂直制表符，可以使用`-e`选项与`\v`选项，如下所示：
- en: '[PRE151]'
  id: totrans-565
  prefs: []
  type: TYPE_PRE
  zh: '[PRE151]'
- en: 'To insert a horizontal tab, use the `\t` option, like this:'
  id: totrans-566
  prefs: []
  type: TYPE_NORMAL
  zh: 要插入水平制表符，请使用`\t`选项，如下所示：
- en: '[PRE152]'
  id: totrans-567
  prefs: []
  type: TYPE_PRE
  zh: '[PRE152]'
- en: 'If you want to insert a backslash into the text, just use two consecutive backslashes,
    like this:'
  id: totrans-568
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想在文本中插入反斜杠，只需使用两个连续的反斜杠，如下所示：
- en: '[PRE153]'
  id: totrans-569
  prefs: []
  type: TYPE_PRE
  zh: '[PRE153]'
- en: 'You’re not limited to just echoing text messages. You can also use a wildcard
    character to show a list of files that you have in the current directory, like
    this:'
  id: totrans-570
  prefs: []
  type: TYPE_NORMAL
  zh: 你不仅可以回显文本消息。你还可以使用通配符字符显示当前目录中存在的文件列表，如下所示：
- en: '[PRE154]'
  id: totrans-571
  prefs: []
  type: TYPE_PRE
  zh: '[PRE154]'
- en: 'You can also echo a message along with the file list, like so:'
  id: totrans-572
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以在文件列表中回显一条信息，如下所示：
- en: '[PRE155]'
  id: totrans-573
  prefs: []
  type: TYPE_PRE
  zh: '[PRE155]'
- en: With a bit of imagination, you’ll be able to use these `echo` formatting options
    to enhance the appearance of your screen output and text documents.
  id: totrans-574
  prefs: []
  type: TYPE_NORMAL
  zh: 只要稍加想象，你就能利用这些`echo`格式化选项来增强屏幕输出和文本文件的外观。
- en: Sadly, as cool as these formatting options for `echo` are, they don’t work well
    on certain non-`bash` shells, such as `dash`. In *Chapter 19—Shell Script Portability*,
    I’ll show you how to fix that by using `printf` instead of `echo`.
  id: totrans-575
  prefs: []
  type: TYPE_NORMAL
  zh: 可惜，尽管这些`echo`的格式化选项很酷，但它们在某些非`bash`的Shell中效果不佳，例如`dash`。在*第19章——Shell脚本的可移植性*中，我将展示如何通过使用`printf`来替代`echo`解决这个问题。
- en: That’s about it for `echo`. Let’s move on to the real world.
  id: totrans-576
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是`echo`的全部内容。让我们进入现实世界吧。
- en: Looking at Some Real-World Examples
  id: totrans-577
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 查看一些实际的例子
- en: In this section, I’ll show you some practical, real-life things that you can
    do with some of the techniques that we’ve covered so far. Actually, rather than
    just showing you, I’ll let you get your hands dirty with some cool hands-on labs.
  id: totrans-578
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一部分，我将展示一些实际的、现实中的技巧，你可以利用我们到目前为止介绍的一些技术。实际上，我不仅仅是展示，我还将让你亲自动手，参与一些有趣的实操实验。
- en: 'Hands-on Lab: Using if..then'
  id: totrans-579
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 实操实验：使用if..then
- en: This is absolutely a real-life example. Several years ago, I created this script
    as a plug-in for the Nagios network monitoring system. The scenario was that we
    wanted to make sure that malicious hackers haven’t added a rogue `UID 0` account
    to the `/etc/passwd` file on Linux and FreeBSD machines. That’s because any account
    with a UID setting of `0` in the `passwd` file has full root privileges, and we
    don’t want any unauthorized accounts to have root privileges.
  id: totrans-580
  prefs: []
  type: TYPE_NORMAL
  zh: 这完全是一个现实生活中的例子。几年前，我将这个脚本作为插件添加到 Nagios 网络监控系统中。场景是我们希望确保恶意黑客没有在 Linux 和 FreeBSD
    系统的 `/etc/passwd` 文件中添加一个不明的 `UID 0` 账户。因为任何在 `passwd` 文件中设置了 `UID 0` 的账户都拥有完整的
    root 权限，我们不希望任何未经授权的账户拥有 root 权限。
- en: The problem is that on Linux machines there’s only supposed to be one user account
    with `UID 0`, and on FreeBSD there are two accounts with `UID 0`. (One `UID 0`
    account is named `toor`, which has `bash` set as the default shell. The other
    `UID 0` account is `root`, which has `csh` set as the default shell.) So, we needed
    a script that will work on both operating systems. (Note that you’ll be altering
    the `passwd` file for this lab, so you’ll want to do this on a virtual machine,
    and not on a real production machine.)
  id: totrans-581
  prefs: []
  type: TYPE_NORMAL
  zh: 问题在于，Linux 系统上应该只有一个 `UID 0` 用户账户，而在 FreeBSD 上有两个 `UID 0` 的账户。（一个 `UID 0` 的账户名为
    `toor`，其默认 shell 为 `bash`。另一个 `UID 0` 的账户为 `root`，其默认 shell 为 `csh`。）因此，我们需要一个可以在这两个操作系统上都能运行的脚本。（请注意，您将会修改
    `passwd` 文件，所以最好在虚拟机上进行此操作，而不是在生产环境中的真实机器上。）
- en: Note that the `exit 1` and `exit 2` status codes that you’ll see are what Nagios
    expects to see to indicate either `OKAY` or `CRITICAL`. Also note that you can
    add more `elif` stanzas if you want to check other UNIX or UNIX-like operating
    systems. (In fact, you’ll see that I’ve just now added code to check macOS and
    OpenIndiana.) With the introduction out of the way, let’s get to the procedure.
  id: totrans-582
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，您将看到的 `exit 1` 和 `exit 2` 状态代码是 Nagios 用来表示 `正常` 或 `严重` 的预期状态代码。还要注意，如果您想检查其他
    UNIX 或类 UNIX 操作系统，可以添加更多的 `elif` 语句块。（事实上，您会看到我刚刚增加了用于检查 macOS 和 OpenIndiana 的代码。）引言部分讲解完毕，接下来让我们进入操作步骤。
- en: Unfortunately, the script is too long to reproduce in the book. So, go to the
    Github repository and download the `UID-0_check.sh` script. Transfer it to a Linux
    virtual machine. Open the script in your text editor, and examine the code.
  id: totrans-583
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 不幸的是，脚本太长，无法在书中完整显示。所以，请访问 Github 仓库并下载 `UID-0_check.sh` 脚本。将其传输到一个 Linux 虚拟机中，在文本编辑器中打开脚本，查看代码。
- en: 'Run the script to see the results. You should see this message:'
  id: totrans-584
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行脚本查看结果。您应该会看到如下消息：
- en: '[PRE156]'
  id: totrans-585
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE156]'
- en: '**WARNING: Again I say, do this on a virtual machine, not on your production
    workstation.**'
  id: totrans-586
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**警告：再强调一遍，请在虚拟机上进行此操作，而不是在您的生产工作站上。**'
- en: On a Linux virtual machine, create another user account, using the appropriate
    user-creation command for your Linux distro. Open the `/etc/passwd` file in your
    text editor, and change the UID number for the new user to `0`.
  id: totrans-587
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Linux 虚拟机上，使用适合您 Linux 发行版的用户创建命令，创建另一个用户账户。用文本编辑器打开 `/etc/passwd` 文件，将新用户的
    UID 改为 `0`。
- en: 'This UID field is the third field in each line of the passwd file. For example,
    you see here that Vicky’s UID is 1001:'
  id: totrans-588
  prefs: []
  type: TYPE_NORMAL
  zh: 这个 UID 字段是每行 `/etc/passwd` 文件中的第三个字段。例如，您可以看到这里 Vicky 的 UID 是 1001：
- en: '[PRE157]'
  id: totrans-589
  prefs: []
  type: TYPE_PRE
  zh: '[PRE157]'
- en: 'Changing her UID to `0` will make the line look like this:'
  id: totrans-590
  prefs: []
  type: TYPE_NORMAL
  zh: 将她的 UID 改为 `0` 后，行内容将如下所示：
- en: '[PRE158]'
  id: totrans-591
  prefs: []
  type: TYPE_PRE
  zh: '[PRE158]'
- en: 'Save the file and run the script again. You should now see a message that looks
    like this:'
  id: totrans-592
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存文件并再次运行脚本。您应该会看到如下所示的消息：
- en: '[PRE159]'
  id: totrans-593
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE159]'
- en: Delete the new user account.
  id: totrans-594
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 删除新创建的用户账户。
- en: Create a FreeBSD virtual machine and install `sudo` and `bash` as I showed you
    in the *Preface* chapter. Transfer the `UID-0_check.sh` script to it, and repeat
    Steps 3 through 5\. This time, you should see that `2 accounts` are `OKAY`, and
    that `3 accounts` are `CRITICAL`. This will give you a chance to see how the `elif
    [ $os == FreeBSD ]; then` stanza at the bottom of the script can correctly detect
    which operating system you’re running, so that it can run the correct code.
  id: totrans-595
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个 FreeBSD 虚拟机，并按照我在 *前言* 章节中所示安装 `sudo` 和 `bash`。将 `UID-0_check.sh` 脚本传输到虚拟机，并重复步骤
    3 到 5。此时，您应该看到 `2 个账户` 状态为 `正常`，`3 个账户` 状态为 `严重`。这将使您有机会查看脚本底部的 `elif [ $os ==
    FreeBSD ]; then` 语句块，它能正确检测您运行的操作系统，从而执行正确的代码。
- en: End of lab
  id: totrans-596
  prefs: []
  type: TYPE_NORMAL
  zh: 实验结束
- en: Hands-on Lab – Parsing an Apache Access Log
  id: totrans-597
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实验操作 - 解析 Apache 访问日志
- en: In this lab, I’ll show you how much power a one-command shell script can have.
    Building up that one command can be a bit tricky though, so I’ll show you how
    to build it one step at a time, ensuring that each step works properly before
    continuing to the next step. If you’re ready, let’s dig in.
  id: totrans-598
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个实验中，我将向你展示一个单命令 Shell 脚本能有多强大。然而，构建这个单一命令可能有点棘手，所以我会一步一步地教你如何构建它，确保每一步都能正常运行，再继续下一步。如果你准备好了，我们就开始吧。
- en: Set up a Fedora Server virtual machine with Bridged networking. (You’ll need
    Bridged networking so that you can access the machine from other machines on your
    network.)
  id: totrans-599
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 设置一个带有桥接网络的 Fedora Server 虚拟机。（你需要桥接网络，这样才能从你网络中的其他机器访问这台虚拟机。）
- en: 'Install and activate the Apache webserver, like this:'
  id: totrans-600
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 安装并激活 Apache 网络服务器，像这样：
- en: '[PRE160]'
  id: totrans-601
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE160]'
- en: 'Open Port 80 on the virtual machine’s firewall, like this:'
  id: totrans-602
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开虚拟机防火墙上的 80 端口，像这样：
- en: '[PRE161]'
  id: totrans-603
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE161]'
- en: 'From as many other machines on your network as possible, open a web browser
    and navigate to the virtual machine’s IP address. The URL that you enter should
    look something like this:'
  id: totrans-604
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从你网络上的尽可能多的机器上，打开一个 Web 浏览器，并导航到虚拟机的 IP 地址。你输入的 URL 应该像这样：
- en: '[PRE162]'
  id: totrans-605
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE162]'
- en: Note that you can access this from either physical machines or other virtual
    machines that are on the same network. Also, note that there’s no need to set
    up your own web page, because the default *Fedora Webserver Test Page* will work
    fine for your needs.
  id: totrans-606
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，你可以通过物理机或网络上其他虚拟机访问此页面。同时，请注意无需设置你自己的网页，因为默认的*Fedora Webserver Test Page*就能满足需求。
- en: 'View the Apache access log, like this:'
  id: totrans-607
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 查看 Apache 访问日志，像这样：
- en: '[PRE163]'
  id: totrans-608
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE163]'
- en: 'Note how each line begins with the IP address of each machine that accessed
    this website. Here’s an example:'
  id: totrans-609
  prefs: []
  type: TYPE_NORMAL
  zh: 注意每一行都以访问该网站的机器的 IP 地址开头。这里是一个例子：
- en: '[PRE164]'
  id: totrans-610
  prefs: []
  type: TYPE_PRE
  zh: '[PRE164]'
- en: 'You see that the source IP address is in the first field, and that the fields
    are separated by blank spaces. So, one way that we can see just the list of source
    IP addresses is to use `cut`, and to specify a blank space as the delimiter to
    view just the first field. The command and its output would look something like
    this:'
  id: totrans-611
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你会看到源 IP 地址在第一列，并且各个字段通过空格分隔。所以，我们可以使用`cut`命令，通过指定空格作为分隔符来只查看第一列的内容。命令和输出应该像这样：
- en: '[PRE165]'
  id: totrans-612
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE165]'
- en: With only one exception, you see the list of IPv4 addresses of the machines
    that accessed this server. The one exception is the IPv6 address at the top of
    the list, which is the `localhost` address of the Fedora Server machine. (You
    likely won’t see this IPv6 address, unless you access the page from within the
    virtual machine itself.)
  id: totrans-613
  prefs: []
  type: TYPE_NORMAL
  zh: 除了一个例外，你会看到访问该服务器的机器的 IPv4 地址列表。唯一的例外是列表顶部的 IPv6 地址，它是 Fedora Server 机器的`localhost`地址。（除非你从虚拟机内部访问该页面，否则你可能看不到这个
    IPv6 地址。）
- en: 'So far, so good. You’ve successfully isolated the first field. Let’s now add
    the second part, which will sort the output so that the `uniq` filter will work
    properly in the next step. Here’s what that looks like:'
  id: totrans-614
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 到目前为止，一切顺利。你已经成功地隔离了第一列。现在让我们添加第二部分，这将排序输出，以便`uniq`过滤器在下一步能够正常工作。它看起来是这样的：
- en: '[PRE166]'
  id: totrans-615
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE166]'
- en: By using `sort` without the `-n` option, the list doesn’t get sorted in proper
    numerical order. But for this step, that doesn’t matter.
  id: totrans-616
  prefs: []
  type: TYPE_NORMAL
  zh: 通过不使用`-n`选项的`sort`，列表不会按正确的数字顺序排序。但在这一步中，这无关紧要。
- en: 'The next step is to eliminate duplicate IP addresses from the output, and to
    also count how many there are of each in the source file. Here’s how that looks:'
  id: totrans-617
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下一步是从输出中去除重复的 IP 地址，并计算每个 IP 地址在源文件中的出现次数。它看起来是这样的：
- en: '[PRE167]'
  id: totrans-618
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE167]'
- en: 'We’ll now do a reverse numerical sort on the number of times that each IP address
    occurs, like so:'
  id: totrans-619
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们将对每个 IP 地址出现的次数进行反向数字排序，像这样：
- en: '[PRE168]'
  id: totrans-620
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE168]'
- en: 'Now that you know that the command works properly, create the `ipaddress_count.sh`
    script, and make it look like this:'
  id: totrans-621
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在你已经知道命令正常工作了，创建`ipaddress_count.sh`脚本，并使其看起来像这样：
- en: '[PRE169]'
  id: totrans-622
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE169]'
- en: Be aware that you’ll need to use `sudo` to run this script.
  id: totrans-623
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，你需要使用`sudo`来运行这个脚本。
- en: 'Finally, let’s fancy things up a bit. Add some code to save the results to
    a text file with a timestamp in its filename. It should look like this:'
  id: totrans-624
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，让我们给它增添一些亮点。添加一些代码，将结果保存到一个带有时间戳的文本文件中。它应该像这样：
- en: '[PRE170]'
  id: totrans-625
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE170]'
- en: Of course, there are other available programs that do a more comprehensive job
    of parsing your webserver log files. But, this script is handy for a quick analysis
    of who is accessing your server.
  id: totrans-626
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，也有其他可用的程序能够更全面地解析你的 Web 服务器日志文件。但这个脚本对于快速分析谁在访问你的服务器非常方便。
- en: End of lab
  id: totrans-627
  prefs: []
  type: TYPE_NORMAL
  zh: 实验结束
- en: Let’s move on to the final lab.
  id: totrans-628
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们继续到最后一个实验。
- en: Hands-on Lab – Beta Testing a Hard Drive
  id: totrans-629
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 动手实验 – 硬盘Beta测试
- en: The final example involves an experience that I had quite a few years ago. That’s
    when the good folk at Western Digital invited me to participate in a beta test
    of a new model hard drive. All I really had to do was to keep the drive running
    for the whole four-month test period, and then collect log data from the drive’s
    BIOS at the end of the test period. But, I went a bit beyond that by writing a
    shell script that automatically collected drive performance data on a daily basis.
    As before, do this on your Fedora Server virtual machine.
  id: totrans-630
  prefs: []
  type: TYPE_NORMAL
  zh: 最后的示例涉及到我几年前的一个经历。那时，西部数据的好心人邀请我参与一个新型号硬盘的Beta测试。我真正需要做的就是在整个四个月的测试期间保持硬盘运行，然后在测试结束时从硬盘的BIOS中收集日志数据。但我做得更进一步，编写了一个Shell脚本，自动每天收集硬盘性能数据。和之前一样，
    在你的Fedora Server虚拟机上进行操作。
- en: 'To collect drive performance data, you’ll need to install a couple of packages,
    like this:'
  id: totrans-631
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要收集硬盘性能数据，你需要安装几个软件包，方法如下：
- en: '[PRE171]'
  id: totrans-632
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE171]'
- en: 'Start the `sysstat` service and ensure that it’s active, like this:'
  id: totrans-633
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 启动`sysstat`服务并确保它处于活动状态，如下所示：
- en: '[PRE172]'
  id: totrans-634
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE172]'
- en: 'You’ll use the `sar` component of the `sysstat` package to collect your data.
    But, it will be a few minutes before any `sar` data become available. While you’re
    waiting, generate some hard drive activity by doing a system update, like so:'
  id: totrans-635
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你将使用`sysstat`包中的`sar`组件来收集数据。但在几分钟内，`sar`数据才会可用。在等待的过程中，可以通过执行系统更新来生成一些硬盘活动，方法如下：
- en: '[PRE173]'
  id: totrans-636
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE173]'
- en: View the `sar` man page and take note of the different types of data that can
    be collected with the various `sar` option switches. You’ll be seeing several
    of those options in the shell script.
  id: totrans-637
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 查看` sar`的手册页面，并注意不同的` sar`选项开关所能收集的数据类型。你将在Shell脚本中看到其中一些选项。
- en: This is another one of those scripts that’s too large to reproduce in the book.
    So, download the `hard_drive.sh` script from the Github repository. Open it in
    your text editor and study it. I’ve covered all of the concepts that I’ve used
    in this script, so you should be able to figure out what it’s doing.
  id: totrans-638
  prefs: []
  type: TYPE_NORMAL
  zh: 这是另一个在书中无法完全复现的脚本。所以，从Github仓库中下载`hard_drive.sh`脚本。用你的文本编辑器打开并研究它。我已经涵盖了脚本中使用的所有概念，所以你应该能够理解它在做什么。
- en: 'The last command in the script is a `smartctl` command, which requires `sudo`
    privileges. So, you’ll need to use `sudo` to run the script, like so:'
  id: totrans-639
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 脚本中的最后一个命令是`smartctl`命令，需要`sudo`权限。因此，你需要使用`sudo`来运行脚本，方法如下：
- en: '[PRE174]'
  id: totrans-640
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE174]'
- en: Be patient, because this takes a few minutes to run. Also, be aware that the
    virtual drive of your virtual machine isn’t `smartmontools`-aware, which means
    that you’ll see some warning messages in your report.
  id: totrans-641
  prefs: []
  type: TYPE_NORMAL
  zh: 请耐心等待，因为这个过程需要几分钟。同时，请注意，你的虚拟机虚拟硬盘并不支持`smartmontools`，这意味着你在报告中会看到一些警告信息。
- en: When the script has finished running, look at the generated report in the `Drive_Reports`
    directory.
  id: totrans-642
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 脚本运行完成后，请查看`Drive_Reports`目录中生成的报告。
- en: Feel free to run this script on your Linux host machine. It should run on most
    any Linux distro, as long as you have the `sysstat` and `smartmontools` packages
    installed, and the `sysstat` service is running.
  id: totrans-643
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 随时在你的Linux主机上运行此脚本。只要你安装了`sysstat`和`smartmontools`包，并且`sysstat`服务正在运行，几乎所有Linux发行版上都可以运行此脚本。
- en: End of Lab
  id: totrans-644
  prefs: []
  type: TYPE_NORMAL
  zh: 实验结束
- en: All right, that wraps it up for this chapter. Let’s summarize and move on.
  id: totrans-645
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，这一章就到这里。让我们总结一下并继续前进。
- en: Summary
  id: totrans-646
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: We covered an incredible amount of ground in this chapter, and I hope that I
    haven’t overwhelmed you. What I wanted to do was to provide you with a comprehensive
    overview of the concepts and techniques that you would use to build a usable shell
    script. We started with some techniques that are unique to shell scripting, and
    followed up with techniques that are common to most all programming languages.
  id: totrans-647
  prefs: []
  type: TYPE_NORMAL
  zh: 本章我们覆盖了大量内容，我希望没有让你感到不堪重负。我想做的是为你提供一个全面的概述，介绍你在构建可用的Shell脚本时会用到的概念和技术。我们从一些Shell脚本特有的技巧开始，然后跟进一些大多数编程语言通用的技巧。
- en: And really, that’s one of the coolest things about learning shell scripting.
    It’s much easier to learn than higher-level languages such as C, Java, or Rust,
    but it’s still extremely useful. And, as you learn shell scripting, you also learn
    about the constructs and concepts that also apply to the higher-level languages.
    So, if you ever plan to learn another programming language, learning shell scripting
    first can help you prepare for it.
  id: totrans-648
  prefs: []
  type: TYPE_NORMAL
  zh: 而且，学习 shell 脚本的最酷之处之一是，它比 C、Java 或 Rust 等高级语言更容易学习，但它仍然非常有用。当你学习 shell 脚本时，你也会了解适用于高级语言的构造和概念。因此，如果你打算学习另一种编程语言，先学习
    shell 脚本可以帮助你为此做好准备。
- en: But, even with all that we’ve covered, we’re not done yet. In the next chapter,
    I’ll present a few more ways to filter and manipulate text. I’ll see you there.
  id: totrans-649
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，即使我们已经讨论了所有这些内容，我们还没有完成。在下一章中，我会介绍几种更多的文本过滤和操作方法。到时见。
- en: Questions
  id: totrans-650
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: Which of the following snippets represents the *most preferred* way to perform
    command substitution?
  id: totrans-651
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下哪个代码片段代表执行命令替换的*首选*方法？
- en: '`` `command` ``'
  id: totrans-652
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`` `command` ``'
- en: '`%(command)`'
  id: totrans-653
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`%(command)`'
- en: '`"command"`'
  id: totrans-654
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`"command"`'
- en: '`$(command)`'
  id: totrans-655
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`$(command)`'
- en: You need to create an array of names. How would you do that?
  id: totrans-656
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你需要创建一个名字数组。你会怎么做？
- en: '`set array=names`'
  id: totrans-657
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`set array=names`'
- en: '[PRE175]'
  id: totrans-658
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE175]'
- en: '`array=names`'
  id: totrans-659
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`array=names`'
- en: '[PRE176]'
  id: totrans-660
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE176]'
- en: '`array names`'
  id: totrans-661
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`array names`'
- en: '[PRE177]'
  id: totrans-662
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE177]'
- en: '`declare names`'
  id: totrans-663
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`declare names`'
- en: '[PRE178]'
  id: totrans-664
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE178]'
- en: '`declare -a names`'
  id: totrans-665
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`declare -a names`'
- en: '[PRE179]'
  id: totrans-666
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE179]'
- en: How would you view the exit code of a command that you just ran?
  id: totrans-667
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如何查看刚刚运行的命令的退出代码？
- en: '`echo $#`'
  id: totrans-668
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`echo $#`'
- en: '`echo $?`'
  id: totrans-669
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`echo $?`'
- en: '`echo $$`'
  id: totrans-670
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`echo $$`'
- en: '`echo $!`'
  id: totrans-671
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`echo $!`'
- en: You want to create a loop that will read a list of names, and then echo the
    names into another text file. But, you want to skip two of the names. Which of
    the following commands would make your script do that?
  id: totrans-672
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你想创建一个循环，读取一个名字列表，然后将名字回显到另一个文本文件中。但是，你想跳过两个名字。以下哪个命令可以让你的脚本实现这一点？
- en: '`break`'
  id: totrans-673
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`break`'
- en: '`skip`'
  id: totrans-674
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`skip`'
- en: '`continue`'
  id: totrans-675
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`continue`'
- en: '`stop`'
  id: totrans-676
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`stop`'
- en: You want to compare two numerical values to see if they’re equal. which of the
    following operators would you use?
  id: totrans-677
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你想比较两个数值以查看它们是否相等。以下哪个运算符会使用？
- en: '`=`'
  id: totrans-678
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`=`'
- en: '`-eq`'
  id: totrans-679
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`-eq`'
- en: '`==`'
  id: totrans-680
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`==`'
- en: '`-ne`'
  id: totrans-681
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`-ne`'
- en: Further Reading
  id: totrans-682
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: 'What is the Bash Shebang and How to Use It: [https://www.rosehosting.com/blog/what-is-the-bash-shebang/](https://www.rosehosting.com/blog/what-is-the-bash-shebang/)'
  id: totrans-683
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 什么是 Bash Shebang 及其用法：[https://www.rosehosting.com/blog/what-is-the-bash-shebang/](https://www.rosehosting.com/blog/what-is-the-bash-shebang/)
- en: 'An Introduction to Parameter Expansion in bash: [https://opensource.com/article/17/6/bash-parameter-expansion](https://opensource.com/article/17/6/bash-parameter-expansion)'
  id: totrans-684
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: bash 中参数扩展简介：[https://opensource.com/article/17/6/bash-parameter-expansion](https://opensource.com/article/17/6/bash-parameter-expansion)
- en: 'Shell Parameter Expansion (Bash Reference Manual): [https://www.gnu.org/software/bash/manual/html_node/Shell-Parameter-Expansion.html](https://www.gnu.org/software/bash/manual/html_node/Shell-Parameter-Expansion.html)'
  id: totrans-685
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Shell 参数扩展（Bash 参考手册）：[https://www.gnu.org/software/bash/manual/html_node/Shell-Parameter-Expansion.html](https://www.gnu.org/software/bash/manual/html_node/Shell-Parameter-Expansion.html)
- en: 'Introduction to if: [https://tldp.org/LDP/Bash-Beginners-Guide/html/sect_07_01.html](https://tldp.org/LDP/Bash-Beginners-Guide/html/sect_07_01.html)'
  id: totrans-686
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: if 入门：[https://tldp.org/LDP/Bash-Beginners-Guide/html/sect_07_01.html](https://tldp.org/LDP/Bash-Beginners-Guide/html/sect_07_01.html)
- en: 'Bash while Loop: [https://linuxize.com/post/bash-while-loop/](https://linuxize.com/post/bash-while-loop/)'
  id: totrans-687
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Bash while 循环：[https://linuxize.com/post/bash-while-loop/](https://linuxize.com/post/bash-while-loop/)
- en: 'How to Find Most Used Disk Space Directories and Files in Linux: [https://www.tecmint.com/find-top-large-directories-and-files-sizes-in-linux/](https://www.tecmint.com/find-top-large-directories-and-files-sizes-in-linux/)'
  id: totrans-688
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何在 Linux 中查找最常用的磁盘空间目录和文件：[https://www.tecmint.com/find-top-large-directories-and-files-sizes-in-linux/](https://www.tecmint.com/find-top-large-directories-and-files-sizes-in-linux/)
- en: 'Standard Exit Status Codes in Linux: [https://www.baeldung.com/linux/status-codes](https://www.baeldung.com/linux/status-codes)'
  id: totrans-689
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Linux 标准退出状态码：[https://www.baeldung.com/linux/status-codes](https://www.baeldung.com/linux/status-codes)
- en: 'How to Use the sar Command on Linux: [https://www.howtogeek.com/793513/how-to-use-the-sar-command-on-linux/](https://www.howtogeek.com/793513/how-to-use-the-sar-command-on-linux/)'
  id: totrans-690
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何在 Linux 上使用 sar 命令：[https://www.howtogeek.com/793513/how-to-use-the-sar-command-on-linux/](https://www.howtogeek.com/793513/how-to-use-the-sar-command-on-linux/)
- en: Answers
  id: totrans-691
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 答案
- en: d
  id: totrans-692
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: d
- en: e
  id: totrans-693
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: e
- en: b
  id: totrans-694
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: b
- en: c
  id: totrans-695
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: c
- en: b
  id: totrans-696
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: b
- en: Join our community on Discord!
  id: totrans-697
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 加入我们的 Discord 社区！
- en: Read this book alongside other users, Linux experts, and the author himself.
  id: totrans-698
  prefs: []
  type: TYPE_NORMAL
  zh: 与其他用户、Linux 专家和作者一起阅读本书。
- en: Ask questions, provide solutions to other readers, chat with the author via
    Ask Me Anything sessions, and much more. Scan the QR code or visit the link to
    join the community.
  id: totrans-699
  prefs: []
  type: TYPE_NORMAL
  zh: 提出问题，为其他读者提供解决方案，通过“问我任何问题”环节与作者聊天，等等。扫描二维码或访问链接加入社区。
- en: '[https://packt.link/SecNet](https://packt.link/SecNet)'
  id: totrans-700
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://packt.link/SecNet](https://packt.link/SecNet)'
- en: '![](img/QR_Code10596186092701843.png)'
  id: totrans-701
  prefs: []
  type: TYPE_IMG
  zh: '![](img/QR_Code10596186092701843.png)'
