- en: '*Chapter 14*: Dealing with New Applications'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第 14 章*：处理新应用程序'
- en: New applications are often not yet supported through an application-specific
    SELinux policy, as most application projects do not develop the SELinux policies
    themselves, but rely on the community in general (or Linux distributions more
    specifically) to create and maintain them. Some Linux distributions have implemented
    fallbacks to allow these applications to run, even though they might not be isolated
    properly. Administrators might not like the sound of having untrusted new applications
    running without any SELinux enforcements active though.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 新应用程序通常还未通过特定于应用程序的 SELinux 策略进行支持，因为大多数应用程序项目并未自行开发 SELinux 策略，而是依赖于社区（或更具体地说是
    Linux 发行版）来创建和维护这些策略。一些 Linux 发行版已经实施了回退机制，允许这些应用程序运行，即使它们可能未正确隔离。然而，管理员可能不喜欢没有任何
    SELinux 强制执行的情况下，运行不受信任的新应用程序。
- en: Hence, this chapter covers how administrators can run new applications in a
    number of isolated environments, ranging from the (often default) unprotected
    domains, to sandbox systems, and eventually by reusing existing SELinux domains
    without having to develop completely new ones.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，本章将讨论管理员如何在多个隔离环境中运行新应用程序，从（通常是默认的）未保护域，到沙箱系统，最终通过重用现有的 SELinux 域，而无需完全开发新的域。
- en: 'In this chapter, we''re going to cover the following main topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下主要内容：
- en: Running applications without restrictions
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 无限制地运行应用程序
- en: Using sandboxed applications
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用沙箱应用程序
- en: Assigning common policies to new applications
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为新应用程序分配通用策略
- en: Extending generated policies
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 扩展生成的策略
- en: Technical requirements
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'Check out the following video to see the Code in Action: [https://bit.ly/3dGG5Bu](https://bit.ly/3dGG5Bu)'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 查看以下视频，看看代码如何运行：[https://bit.ly/3dGG5Bu](https://bit.ly/3dGG5Bu)
- en: Running applications without restrictions
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 无限制地运行应用程序
- en: 'The default behavior in many Linux distributions is to run new applications
    through unconfined domains. These are specially crafted domains that, while still
    being controlled by SELinux, are designed to have very, very broad permissions
    granted. You can compare such unconfined domains with a firewall that allows any
    possible flow: while the firewall is running, it is hardly doing any enforcement.'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在许多 Linux 发行版中，默认行为是通过未受限制的域来运行新应用程序。这些是精心设计的域，虽然仍然受到 SELinux 的控制，但授予了非常广泛的权限。你可以将这样的未受限制域与允许任何可能流量的防火墙进行比较：尽管防火墙正在运行，但它几乎没有进行任何强制执行。
- en: 'There is, however, another approach possible as well, namely, running an application
    as a permissive domain. Unlike unconfined domains, permissive domains are not
    enforced through SELinux: everything the domain does is allowed, even though SELinux
    might log every violation. We briefly touched upon permissive domains in [*Chapter
    3*](B16276_03_Final_VK.xhtml#_idTextAnchor071), *Understanding SELinux Decisions
    and Logging*.'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，也可以采用另一种方法，即将应用程序作为宽松域运行。与未受限制的域不同，宽松域不会通过 SELinux 强制执行：该域的所有操作都是允许的，即使 SELinux
    可能会记录每一次违规行为。在[*第 3 章*](B16276_03_Final_VK.xhtml#_idTextAnchor071)中，我们简要讨论了宽松域，*理解
    SELinux 决策和日志记录*。
- en: Let's first look at unconfined domains and how administrators can modify system
    configuration to apply unconfined domains to other applications, or remove applications
    from being unconfined.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们首先看看未受限制的域，以及管理员如何修改系统配置，将未受限制的域应用于其他应用程序，或将应用程序移除出未受限制的状态。
- en: Understanding how unconfined domains work
  id: totrans-14
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 理解未受限制的域如何工作
- en: An **unconfined domain** is an SELinux domain that has broad permissions, restricting
    only a very small amount of actions that a domain can do. Unconfined domains are
    not really a concept that SELinux, as technology, supports. Instead, it is used
    by SELinux policy developers who created a set of permissions they consider as
    being unconfined.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: '**未受限制的域**是一个具有广泛权限的 SELinux 域，仅限制域可以执行的极少数操作。未受限制的域实际上并不是 SELinux 作为技术所支持的概念。相反，它是由
    SELinux 策略开发者使用的，他们创建了一组他们认为是未受限制的权限。'
- en: End users on many Linux distributions will have noticed that their own context
    is `unconfined_t`. While this is indeed a reference to being an unconfined domain,
    there are more domains that are unconfined than `unconfined_t`.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 许多 Linux 发行版的最终用户会注意到，他们自己的上下文是 `unconfined_t`。虽然这确实是指一个未受限制的域，但实际上存在比 `unconfined_t`
    更多的未受限制域。
- en: 'SELinux policy developers have aggregated most of the permissions related to
    unconfined domains either in the domains themselves (as is the case for the reference
    policy) or in SELinux attributes, such as `unconfined_domain_type` and `unconfined_user_type`
    (as is the case for CentOS and related Linux distributions). In the case of attributes,
    these attributes are then assigned to one or more domains to effectively make
    them unconfined in nature:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: SELinux 策略开发者将大部分与不受限制域相关的权限聚集在域本身（如参考策略所示）或 SELinux 属性中，如`unconfined_domain_type`和`unconfined_user_type`（如
    CentOS 和相关的 Linux 发行版所示）。对于属性，这些属性然后会分配给一个或多个域，从而有效地使它们本质上不受限制：
- en: '[PRE0]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Once a process is running as an unconfined domain, that does not imply that
    every action of that domain remains unconfined. When an unconfined domain executes
    a process that has a proper SELinux policy assigned, it is possible for this execution
    to still invoke a domain transition, effectively running the executed command
    in a (possibly confined) SELinux domain.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦一个进程在不受限制的域中运行，并不意味着该域的每个操作都保持不受限制。当不受限制的域执行一个有适当 SELinux 策略的进程时，这个执行仍然可能会引发域转换，从而将执行的命令置于一个（可能受限的）SELinux
    域中。
- en: 'As the decision whether a domain transition is allowed or not falls within
    the SELinux policy, it is recommended that administrators query which domain transitions
    are allowed and which ones aren''t. We saw how to analyze domain transitions in
    [*Chapter 13*](B16276_13_Final_VK.xhtml#_idTextAnchor330), *Analyzing Policy Behavior*.
    Given that we are mostly interested in single-step analysis, we can use the `sesearch`
    utility to have a quick overview of supported domain transitions:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 由于是否允许域转换的决定属于 SELinux 策略的一部分，建议管理员查询哪些域转换是被允许的，哪些不是。我们在[*第13章*](B16276_13_Final_VK.xhtml#_idTextAnchor330)中看到了如何分析域转换，*分析策略行为*。考虑到我们主要关心的是单步分析，我们可以使用`sesearch`工具快速概览支持的域转换：
- en: '[PRE1]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'We can see the (many) permissions related to an unconfined domain by either
    checking them for a single domain, or for the attribute that represents unconfined
    domains directly:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过检查单一域的权限或直接检查表示不受限制域的属性，来查看与不受限制域相关的（多个）权限：
- en: '[PRE2]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Using unconfined domains is preferred over making domains permissive, so let's
    see how we can mark a new application to run as an unconfined domain.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 使用不受限制的域比使域宽松更为优先，因此让我们来看一下如何标记一个新的应用程序，以使其在不受限制的域中运行。
- en: Making new applications run as an unconfined domain
  id: totrans-25
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使新的应用程序在不受限制的域中运行
- en: 'When applications are executed, there are a number of checks that need to pass
    before this results in a domain transition:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 当执行应用程序时，有多个检查需要通过，才能导致域转换：
- en: The source SELinux domain must be able to execute the application (implying
    `execute` rights on the SELinux type associated with the application's binary
    or script).
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 源 SELinux 域必须能够执行应用程序（意味着在与应用程序的二进制文件或脚本相关联的 SELinux 类型上拥有`执行`权限）。
- en: The source SELinux domain must be able to transition to the target domain.
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 源 SELinux 域必须能够转换到目标域。
- en: The target domain must have its application binary or script labeled with an
    SELinux type that is marked as an entrypoint for that domain.
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 目标域必须为其应用程序的二进制文件或脚本打上一个 SELinux 类型标签，该标签被标记为该域的入口点。
- en: The target domain must be allowed for the SELinux role that the source domain
    is running with (or a role transition has to be allowed, but that is a corner
    case).
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 目标域必须允许源域所运行的 SELinux 角色（或者必须允许角色转换，但这是一个边缘案例）。
- en: All these checks are related to the SELinux policy and the labels. It comes
    as no surprise then that, in order for us to enable applications to run in an
    unconfined domain, we need to associate the right labels.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些检查都与 SELinux 策略和标签相关。因此，毫不奇怪，为了使应用程序能够在不受限制的域中运行，我们需要关联正确的标签。
- en: Let's consider two examples in the following sections, one being a user-triggered
    application, while the other is a daemonized service.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在接下来的章节中考虑两个示例，一个是用户触发的应用程序，另一个是守护进程服务。
- en: Running applications in an explicit unconfined domain
  id: totrans-33
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 在显式不受限制的域中运行应用程序
- en: For applications that users execute, let's take the example of Jailkit, which
    we introduced in [*Chapter 7*](B16276_07_Final_VK.xhtml#_idTextAnchor216), *Configuring
    Application-Specific SELinux Controls*. By default, this application is not associated
    with any domain, so it runs within the same domain as the parent process. If we
    are logged in to the system through the `unconfined_u` user (in the `unconfined_t`
    SELinux domain), then we have nothing to do. But suppose that our staff user is
    confined, yet we want to have the command run in the `unconfined_t` domain.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 对于用户执行的应用程序，举个例子，我们在[*第7章*](B16276_07_Final_VK.xhtml#_idTextAnchor216)中介绍了Jailkit，*配置特定应用程序的SELinux控制*。默认情况下，该应用程序未与任何域关联，因此它与父进程在同一域中运行。如果我们通过`unconfined_u`用户登录系统（在`unconfined_t`
    SELinux域中），那么我们无需做任何事情。但是，假设我们的staff用户是受限的，但我们希望命令在`unconfined_t`域中运行。
- en: Important note
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 重要说明
- en: This is used as an example that shows how to have applications run in a target
    domain – in our case, an unconfined domain. Allowing confined users to run unconfined
    applications always has a risk associated with it, because they might use this
    to break out of their confinement. Make sure that this is only done for applications
    or users where you have confidence that they will not breach security.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个示例，展示了如何让应用程序在目标域中运行——在我们的案例中，是在一个非约束域中。允许受限用户运行非受限应用程序总是有一定风险的，因为他们可能利用这个机会突破限制。确保只有对那些你有信心不会违反安全的应用程序或用户才执行此操作。
- en: To allow the application to run in the `unconfined_t` domain, we will use `sudo`
    and its SELinux support. While we could also extend the SELinux policy to allow
    it transparently, this is not recommended. Updating the SELinux policy to allow
    confined users to run unconfined commands implies that several principles listed
    in the policy are overturned. You would need to allow the confined user to switch
    to the `unconfined_r` role (which is often not allowed for security reasons) transparently,
    for instance. It would require significant analysis to make sure that it cannot
    be used to break out of the confined role.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 要允许应用程序在`unconfined_t`域中运行，我们将使用`sudo`及其SELinux支持。虽然我们也可以扩展SELinux策略以透明地允许它，但这并不推荐。更新SELinux策略以允许受限用户运行非受限命令意味着要推翻策略中列出的一些原则。例如，你可能需要透明地允许受限用户切换到`unconfined_r`角色（通常出于安全原因不允许这样做）。这将需要进行大量分析，以确保它无法被用来突破受限角色。
- en: Using `sudo` allows us to limit the methods through which such more privileged
    commands are executed. SELinux-wise, the appropriate controls are put on the `staff_sudo_t`
    domain, for instance, which is only assigned when executing the `sudo` command,
    rather than the `staff_t` domain, which is where most of the user's interactions
    are executed.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`sudo`可以限制通过这些更高权限命令执行的方法。例如，SELinux-wise，适当的控制措施会被应用于`staff_sudo_t`域，这个域仅在执行`sudo`命令时才会分配，而不是`staff_t`域，后者是大多数用户交互所在的域。
- en: 'Let''s allow the `lisa` user to run the `jk_init` command as an unconfined
    process:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们允许`lisa`用户作为一个非受限进程运行`jk_init`命令：
- en: 'First, check whether the SELinux user for which we want to execute the command
    is allowed to do anything with the `unconfined_r` SELinux role (and if not, add
    the role to the SELinux user configuration):'
  id: totrans-40
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，检查我们要执行命令的SELinux用户是否被允许使用`unconfined_r` SELinux角色（如果没有，则将该角色添加到SELinux用户配置中）：
- en: '[PRE3]'
  id: totrans-41
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Allowing a role does not imply that the user domain automatically switches role
    when needed though, but rather that it is an allowed role for the user.
  id: totrans-42
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 允许某个角色并不意味着用户域会自动在需要时切换角色，而是意味着该角色是用户的允许角色。
- en: 'Next, update the `/etc/sudoers` file to include a transition when executing
    the following command:'
  id: totrans-43
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，更新`/etc/sudoers`文件，在执行以下命令时添加转换：
- en: '[PRE4]'
  id: totrans-44
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Our user can now run the command, prefixed by `sudo`, to have it execute in
    the right domain and using the right role:'
  id: totrans-45
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们的用户现在可以运行命令，并通过`sudo`前缀使其在正确的域和使用正确的角色下执行：
- en: '[PRE5]'
  id: totrans-46
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Using `sudo` for end user applications is common when the privileges of the
    user also have to switch (from the user privilege to the root privilege). It is
    less common to use it when staying within the Linux user context though.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 对于最终用户应用程序，使用`sudo`很常见，当用户的权限也需要切换时（从用户权限切换到root权限）。但在保持在Linux用户上下文中时，使用它则不太常见。
- en: Running daemons in an explicit unconfined domain
  id: totrans-48
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 在显式非受限域中运行守护进程
- en: The second use case, and perhaps a more common one than for end user applications,
    is to run daemonized services in an unconfined domain. Most Linux distributions
    that use unconfined domains (such as CentOS) will by default have newly installed
    software run as an unconfined domain as well. For instance, any service that is
    enabled and activated through systemd (which runs as the `init_t` SELinux domain)
    and that does not have an explicit labeling set (meaning the executable commands
    are labeled as `bin_t`) will run in the `unconfined_service_t` domain.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 第二种使用场景，或许比最终用户应用程序更常见，是将守护进程服务在非受限域中运行。大多数使用非受限域的Linux发行版（如CentOS）默认会让新安装的软件也以非受限域运行。例如，任何通过systemd启用和激活的服务（它以`init_t`
    SELinux域运行）且没有显式标签设置（即可执行命令被标记为`bin_t`）将运行在`unconfined_service_t`域中。
- en: But what if we have a confined application that we want to run in an unconfined
    domain? Let's take PostgreSQL as an example. Suppose this is an isolated database
    that has certain extensions active that are incompatible with the existing PostgreSQL
    SELinux domain (`postgresql_t`). Administrators might not have the time to extend
    the current SELinux policy using methods such as `audit2allow`, as seen in [*Chapter
    12*](B16276_12_Final_VK.xhtml#_idTextAnchor312), *Tuning SELinux Policies*.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 但如果我们有一个受限应用程序，想要在非受限域中运行呢？以PostgreSQL为例。假设这是一个隔离的数据库，启用了某些与现有PostgreSQL SELinux域（`postgresql_t`）不兼容的扩展。管理员可能没有时间使用`audit2allow`等方法扩展现有的SELinux策略，正如在[*第12章*](B16276_12_Final_VK.xhtml#_idTextAnchor312)《调整SELinux策略》中所看到的那样。
- en: 'Luckily, we can easily move PostgreSQL to work and run in an unconfined domain.
    There are two ways to approach this:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，我们可以轻松地将PostgreSQL移至非受限域并运行。有两种方法可以实现这一点：
- en: We can remove the existing labels on its executable files (`postgresql_exec_t`)
    and set it to `bin_t` instead. This will then trigger the default transition when
    starting the PostgreSQL binary to the `unconfined_service_t` domain.
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以移除其可执行文件上的现有标签（`postgresql_exec_t`），并将其设置为`bin_t`。这将触发启动PostgreSQL二进制文件时的默认转换，转换到`unconfined_service_t`域。
- en: We can update the SELinux policy for `postgresql_t` to become an unconfined
    domain itself.
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以更新SELinux策略，使`postgresql_t`成为一个非受限域。
- en: 'Switching the labels is easy, but is the least recommended method. It is, however,
    a quick and dirty way to see whether running the service in the `unconfined_service_t`
    domain is sufficient to resolve the issue immediately:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 切换标签很容易，但这不是最推荐的方法。然而，这是一种快速且简单的方式，可以立即查看在`unconfined_service_t`域中运行服务是否足以解决问题：
- en: '[PRE6]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'If agreeable, make sure that the label change remains, even after a relabel
    operation occurs:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 如果可以接受，确保标签更改在重新标签操作后仍然保持：
- en: '[PRE7]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Updating the SELinux policy for the PostgreSQL daemon is recommended though,
    as it retains the existing support within the policy (including the file transitions
    and other integrations that the `postgresql_t` domain has with other domains and
    resources). It also allows administrators to update the policy as needed later
    on, when there is more time available.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 推荐更新PostgreSQL守护进程的SELinux策略，因为它保留了策略中现有的支持（包括文件转换和`postgresql_t`域与其他域及资源的集成）。它还允许管理员在以后有更多时间时，根据需要更新策略。
- en: 'To make the `postgresql_t` domain unconfined, we need to assign the `unconfined_domain_type`
    attribute to the `postgresql_t` domain. This can be accomplished by loading in
    the following CIL-based SELinux policy:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使`postgresql_t`域变为非受限域，我们需要将`unconfined_domain_type`属性分配给`postgresql_t`域。这可以通过加载以下基于CIL的SELinux策略来完成：
- en: '[PRE8]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Save this in a file and load it using `semodule -i`, and from that point onward
    the `postgresql_t` domain will be augmented with the privileges associated with
    the `unconfined_domain_type` attribute.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 将此内容保存到文件中，并使用`semodule -i`加载，从此以后，`postgresql_t`域将扩展为与`unconfined_domain_type`属性相关的权限。
- en: Extending unconfined domains
  id: totrans-62
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 扩展非受限域
- en: As unconfined domains are still enforced, it might be possible that SELinux
    is still preventing some actions from occurring. We can adjust the SELinux policy
    to extend unconfined domains with more privileges though. While the default `unconfined_service_t`
    domain has almost all possible permissions set, more specifically, identified
    domains might not be as expansive.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 由于非受限域仍然受到强制执行，可能仍然有一些操作被SELinux阻止。我们可以调整SELinux策略，以扩展非受限域并授予更多权限。尽管默认的`unconfined_service_t`域几乎设置了所有可能的权限，但更具体地说，某些已识别的域可能没有那么广泛。
- en: 'The trick to adding more privileges to the domains is to assign the appropriate
    attribute to them. The method is the same as seen in *Running daemons in an explicit
    unconfined domain*, adding more attributes as needed. The list of attributes that
    we can add is very significant (as you can see from `seinfo -a`), but the most
    important ones, especially for the CentOS-based SELinux policy, are the following:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 向域添加更多权限的技巧是为其分配适当的属性。这个方法与在*运行守护进程于明确的非限制性域*中看到的方法相同，根据需要添加更多属性。我们可以添加的属性列表非常重要（如从`seinfo
    -a`中看到的那样），但最重要的几个属性，尤其是对于基于CentOS的SELinux策略，主要包括以下几个：
- en: '`files_unconfined_type` allows the domain to manage any possible file- or filesystem-based
    resource.'
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`files_unconfined_type` 允许该域管理任何可能的文件或基于文件系统的资源。'
- en: '`devices_unconfined_type` allows the domain to interact and manage any device
    resource.'
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`devices_unconfined_type` 允许该域与任何设备资源进行交互和管理。'
- en: '`filesystem_unconfined_type` allows the domain to interact and manage all filesystems.'
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`filesystem_unconfined_type` 允许该域与所有文件系统进行交互和管理。'
- en: '`selinux_unconfined_type` allows the domain to interact with and manage the
    SELinux subsystem and configuration.'
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`selinux_unconfined_type` 允许该域与SELinux子系统及其配置进行交互和管理。'
- en: '`storage_unconfined_type` allows the domain to interact with storage systems
    and removable devices.'
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`storage_unconfined_type` 允许该域与存储系统和可移动设备进行交互。'
- en: '`dbusd_unconfined` allows the domain to interact with all possible D-Bus services.'
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`dbusd_unconfined` 允许该域与所有可能的D-Bus服务进行交互。'
- en: '`xserver_unconfined_type` allows the domain to interact with and manage all
    X server resources.'
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`xserver_unconfined_type` 允许该域与并管理所有X服务器资源。'
- en: Furthermore, there are several `can_*` attributes that fine-tune very specific,
    security-sensitive actions. The names of these attributes nicely explain what
    they allow. For instance, `can_write_shadow_passwords` allows the domain to write
    to `/etc/shadow`, whereas `can_change_object_identity` means that the domain can
    change the SELinux user of an object.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，还有若干个`can_*`属性，它们精细调整了非常具体的、安全敏感的操作。这些属性的名称很好地解释了它们的用途。例如，`can_write_shadow_passwords`
    允许该域写入`/etc/shadow`，而`can_change_object_identity` 表示该域可以更改对象的SELinux用户。
- en: 'Not all attributes have their privileges reflected in regular `allow` rules
    or transitions that can be queried using `sesearch`. For instance, `can_change_object_identity`
    is used in SELinux constraints instead:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 并非所有属性的权限都能通过常规的`allow`规则或过渡来反映，这些规则或过渡可以通过`sesearch`查询。例如，`can_change_object_identity`
    是在SELinux约束中使用的：
- en: '[PRE9]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Querying the constraints is an often forgotten method to see what or why a certain
    privilege is or isn't assigned to a domain.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 查询约束是一个常常被忽视的方法，可以查看某个特定权限是否被分配到域，或者为什么没有被分配。
- en: Suppose now that an application still fails to run correctly within an unconfined
    domain, then we can use permissive domains to allow this application to run unprotected,
    while having the rest of the system remain in enforcing mode.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 假设现在一个应用程序在非限制性域内仍然无法正确运行，那么我们可以使用宽容域来允许该应用程序在没有保护的情况下运行，同时保持系统的其余部分处于强制模式。
- en: Marking domains as permissive
  id: totrans-77
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将域标记为宽容
- en: 'As we saw in [*Chapter 2*](B16276_02_Final_VK.xhtml#_idTextAnchor045), *Understanding
    SELinux Decisions and Logging*, we can mark a domain as permissive using `semanage
    permissive`:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在[*第二章*](B16276_02_Final_VK.xhtml#_idTextAnchor045)中看到的，*理解SELinux决策和日志记录*，我们可以使用`semanage
    permissive`将一个域标记为宽容：
- en: '[PRE10]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'The same command can be used to query (`-l`) or remove (`-d`) permissive states.
    However, administrators should take special care before marking domains as permissive:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 同样的命令可以用来查询（`-l`）或移除（`-d`）宽容状态。然而，管理员在将域标记为宽容时应特别小心：
- en: First of all, if you mark a domain as permissive, then all processes running
    with that SELinux domain will run without any active SELinux enforcements. As
    an administrator, you really want to limit the number of processes that are running
    through permissive domains, so do not mark broadly used SELinux domains as permissive.
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 首先，如果你将一个域标记为宽容，那么该SELinux域下运行的所有进程都将没有任何活动的SELinux强制执行。作为管理员，你确实希望限制通过宽容域运行的进程数量，因此不要将广泛使用的SELinux域标记为宽容。
- en: A daemon that runs in an unconfined domain, yet still has problems, should not
    result in the unconfined domain being marked as permissive. Instead, have the
    daemon run as a different domain, and mark that domain as permissive.
  id: totrans-82
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在一个非限制性域内运行的守护进程，如果仍然存在问题，不应导致该非限制性域被标记为宽容。相反，应该让该守护进程以不同的域运行，并将该域标记为宽容。
- en: Secondly, permissive domains will still trigger SELinux behavior by the SELinux
    subsystem. Transition rules, including process transitions and file transitions,
    are still executed. This is of course by design, as permissive domains are meant
    to be short-lived, allowing administrators and developers to capture information
    and adapt the policy as needed before they can remove the permissive flag again.
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 其次，宽松的域仍然会触发 SELinux 子系统的 SELinux 行为。过渡规则，包括进程过渡和文件过渡，仍然会执行。这当然是设计上的考虑，因为宽松域旨在短期使用，允许管理员和开发人员捕获信息并根据需要调整策略，然后才能再次移除宽松标志。
- en: This also implies that, if the domain does not have proper transition rules
    set, it might result in files being created on the system that have the wrong
    SELinux types set. Because of this, using permissive domains should not be considered
    for applications or daemons that have a wide impact on the system, but rather
    for more isolated situations where you, as an administrator, feel confident that
    you can easily fine-tune the policy if needed.
  id: totrans-84
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这也意味着，如果域没有设置适当的过渡规则，可能会导致系统上创建具有错误 SELinux 类型的文件。因此，对于对系统影响较大的应用程序或守护进程，不应考虑使用宽松的域，而应使用更为隔离的情况，在这些情况下，作为管理员的你确信在需要时可以轻松地微调策略。
- en: Consider the situation where we deploy pgpool-II, a load balancer for PostgreSQL
    databases, and find that the application does not run properly in an unconfined
    domain, even though it already runs in the `unconfined_service_t` SELinux domain.
    While we can put this domain in permissive mode, this would also apply to various
    other services running inside the `unconfined_service_t` domain.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们部署 pgpool-II，这是一个 PostgreSQL 数据库的负载均衡器，并发现该应用程序在非受限域中无法正常运行，尽管它已经在 `unconfined_service_t`
    SELinux 域中运行。虽然我们可以将此域设置为宽松模式，但这也会影响在 `unconfined_service_t` 域中运行的其他各种服务。
- en: What we can do is relabel its resources (executables mostly) so that the application
    is run through a different SELinux domain, and then mark that domain as permissive.
    We can either reuse an existing, unused domain or generate one, as we will see
    in the *Generating policies with sepolicy generate* section.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以做的是重新标记其资源（主要是可执行文件），使得该应用程序通过另一个 SELinux 域运行，然后将该域标记为宽松模式。我们可以重用一个现有的、未使用的域，或者生成一个新域，正如我们将在
    *使用 sepolicy generate 生成策略* 章节中看到的那样。
- en: When we want to run an application in a (strictly) confined manner though, we
    need to take a completely different route and seek out how to put such applications
    in sandbox-like domains.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，当我们希望以（严格）受限的方式运行应用程序时，我们需要采取完全不同的方法，并寻求将此类应用程序放入类似沙盒的域中。
- en: Using sandboxed applications
  id: totrans-88
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用沙盒化的应用程序
- en: New applications that should only have very limited privileges, and that are
    untrusted by nature, should be confined completely. While we could look at custom
    SELinux policies for these applications, this is hardly possible for each and
    every application out there.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 应该仅具有非常有限权限且天生不可信的新应用程序应完全受限。虽然我们可以为这些应用程序查看自定义的 SELinux 策略，但对于每个应用程序来说，这几乎是不可能的。
- en: Instead, we can consider sandboxing the applications, isolating their access
    from the system. With the help of some other Linux primitives such as namespace
    support, a utility has been created called the SELinux sandbox, which launches
    applications in a tightly confined domain. This is mostly meant for end user applications.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，我们可以考虑将应用程序沙盒化，将其与系统的访问隔离开来。借助其他 Linux 原语，如命名空间支持，已经创建了一个名为 SELinux 沙盒的工具，它将在一个严格受限的域中启动应用程序。这主要适用于终端用户应用程序。
- en: Important note
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: The SELinux sandbox, its SELinux policy, and the command associated with it,
    is specific to Linux distributions that use or follow Red Hat packages, such as
    CentOS. It might not be available for your Linux distribution.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: SELinux 沙盒、其 SELinux 策略以及与其相关的命令，特定于使用或遵循 Red Hat 包的 Linux 发行版，如 CentOS。这可能不适用于你的
    Linux 发行版。
- en: For service-oriented domains, using the container runtime and protection measures
    are more suited. For more information about using container protections, see [*Chapter
    11*](B16276_11_Final_VK.xhtml#_idTextAnchor293), *Enhancing the Security of Containerized
    Workloads*.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 对于面向服务的域，使用容器运行时和保护措施更为合适。有关使用容器保护的更多信息，请参见 [*第11章*](B16276_11_Final_VK.xhtml#_idTextAnchor293)，*增强容器化工作负载的安全性*。
- en: Understanding the SELinux sandbox
  id: totrans-94
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 理解 SELinux 沙盒
- en: The **SELinux sandbox** is a combination of a number of technologies and protection
    measures. While the SELinux policy plays an important part, other isolation measures
    are taken as well to really create a sandbox experience for applications and users.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: '**SELinux沙箱**是多种技术和保护措施的结合体。虽然SELinux策略在其中起着重要作用，但也采取了其他隔离措施，真正为应用程序和用户创建了沙箱体验。'
- en: The purpose of the sandbox is to create a low-privilege environment that blocks
    anything that could jeopardize the security of the system or the user's data.
    This also means that network interaction is blocked by default (no data exfiltration),
    and many system resources are hidden away from the sandboxed process.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 沙箱的目的是创建一个低权限环境，阻止任何可能危及系统或用户数据安全的操作。这也意味着网络交互默认是被阻止的（没有数据外泄），并且许多系统资源对沙箱进程是隐藏的。
- en: Many of the access controls themselves are handled by the SELinux policy. The
    sandbox SELinux domains, `sandbox_t`, and derivatives such as `sandbox_xserver_t`,
    do not have many privileges for other resources. The sandbox utility will also
    apply sVirt-like categories to differentiate one sandboxed process from another.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 许多访问控制本身是由SELinux策略处理的。沙箱SELinux域` sandbox_t`及其衍生域（如`sandbox_xserver_t`）没有太多对其他资源的权限。沙箱实用程序还将应用类似sVirt的类别，以区分不同的沙箱进程。
- en: The isolation, however, is done using different means. `seunshare` application
    is responsible for doing these isolation tasks.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，隔离是通过不同的手段实现的。`seunshare`应用程序负责执行这些隔离任务。
- en: Let's see how the SELinux sandbox works in practice.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看SELinux沙箱在实践中是如何工作的。
- en: Using the sandbox command
  id: totrans-100
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用沙箱命令
- en: 'The SELinux sandbox uses the `sandbox` command. Now, before we can use it,
    we need to make sure that our SELinux user has multiple categories set as, otherwise,
    the SELinux sandbox cannot randomly allocate two categories for isolation:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: SELinux沙箱使用` sandbox`命令。现在，在我们使用它之前，需要确保我们的SELinux用户已经设置了多个类别，否则SELinux沙箱无法随机分配两个类别进行隔离：
- en: '[PRE11]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Once assigned, we can prepare for running an untrusted application in a sandbox.
    For instance, we can download one of the International Obfuscated C Code Contest
    applications from [https://www.ioccc.org](https://www.ioccc.org), compile it,
    and then only run it in a sandbox mode just in case the code behaves maliciously:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦分配了类别，我们就可以准备在沙箱中运行不可信的应用程序。例如，我们可以从[https://www.ioccc.org](https://www.ioccc.org)下载国际混淆C代码竞赛的一个应用程序，编译它，然后仅在沙箱模式下运行它，以防代码表现出恶意行为：
- en: 'Assuming we use the 2019 entry from `adamovsky`, we should have the `prog`
    binary and the `advent.unl` file ready to use. Create a location in which to store
    these files, and copy them over:'
  id: totrans-104
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 假设我们使用的是` adamovsky`的2019年条目，我们应该已经准备好了` prog`二进制文件和` advent.unl`文件。创建一个存储这些文件的位置，并将它们复制过来：
- en: '[PRE12]'
  id: totrans-105
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Next, run the `prog` command from within the sandbox:'
  id: totrans-106
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，从沙箱中运行` prog`命令：
- en: '[PRE13]'
  id: totrans-107
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'While the application runs, we can check its current context with `ps`:'
  id: totrans-108
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在应用程序运行时，我们可以通过` ps`查看其当前上下文：
- en: '[PRE14]'
  id: totrans-109
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'If we exit the application, we can see that the sandbox location has been labeled
    with an sVirt-like MCS pair:'
  id: totrans-110
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果退出应用程序，我们可以看到沙箱位置已被标记为一个类似sVirt的MCS对：
- en: '[PRE15]'
  id: totrans-111
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The method we used here was to explicitly tell the sandbox to create an isolated
    home directory based upon the `sandbox/` folder and run the `prog` binary from
    within this location (and with `advent.unl` as an argument to the `prog` command).
    However, this is not the sole approach.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里使用的方法是明确告诉沙箱基于` sandbox/`文件夹创建一个隔离的主目录，并从该位置运行` prog`二进制文件（并且将` advent.unl`作为`
    prog`命令的参数）。然而，这并不是唯一的方法。
- en: 'If no explicit home directory is provided, then the sandbox will create a temporary
    one (and clean it up afterward). However, in that case, we cannot execute commands
    that are not already installed on the system, unless we allow the sandbox domain
    to execute `user_home_t`-labeled resources:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 如果没有明确提供主目录，则沙箱将创建一个临时目录（并在之后清理）。但是，在这种情况下，除非我们允许沙箱域执行标有` user_home_t`标签的资源，否则我们无法执行系统中未安装的命令：
- en: '[PRE16]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'With this policy loaded, we can use the sandbox with the least number of options.
    For instance, with the Burton contest submission (also from IOCCC''s 2019 contest),
    we have the following:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 加载此策略后，我们可以使用最少选项来使用沙箱。例如，使用Burton竞赛提交（也来自IOCCC 2019年竞赛），我们有以下内容：
- en: '[PRE17]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: The use of a more known location, however, allows more flexibility, as well
    as allowing the sandbox to keep data across multiple sessions (as the directory
    pointed toward will not be cleaned up).
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，使用一个更常见的位置可以提供更多的灵活性，同时还允许沙箱在多个会话之间保持数据（因为指向的目录不会被清理）。
- en: The SELinux sandbox also supports running graphical applications in the sandbox.
    To accomplish this, add the `-X` option to the `sandbox` command. The resulting
    process will run in the `sandbox_xserver_t` domain rather than the `sandbox_t`
    domain, as more privileges are needed to allow graphical applications to run.
    Keep in mind though that the sandbox domain has very few privileges; connecting
    to networked resources is not allowed, so it is not possible to use the sandbox
    (without additional modifications and SELinux policy adjustments) to run a sandboxed
    browser to interact with unsafe websites.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: SELinux沙箱还支持在沙箱中运行图形应用程序。要实现这一点，可以在`sandbox`命令中添加`-X`选项。由此启动的进程将运行在`sandbox_xserver_t`域中，而不是`sandbox_t`域，因为运行图形应用程序需要更多的权限。不过需要注意的是，沙箱域的权限非常有限；不允许连接到网络资源，因此，在没有额外修改和SELinux策略调整的情况下，无法使用沙箱（无法与不安全网站交互的沙箱浏览器）。
- en: Assigning common policies to new applications
  id: totrans-119
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将通用策略分配给新应用程序
- en: In between the strong isolation of an SELinux sandbox and the broad permissions
    of unconfined domains (or even permissive domains) sits the sufficiently privileged
    application domain. For most administrators, having a proper SELinux domain for
    applications is the best way forward, as it allows all the common behaviors and
    restricts unwanted ones.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 在SELinux沙箱的强隔离与未受限制域（或甚至宽松域）的广泛权限之间，存在着具有足够特权的应用程序域。对于大多数管理员来说，拥有一个适当的SELinux域来管理应用程序是最好的方法，因为它可以允许所有常见的行为，并限制不希望出现的行为。
- en: When we start looking at application domains, however, we notice that there
    is differentiation in complexity, and as an administrator, we need to understand
    what the complexity is about before we can make the right choice.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，当我们开始查看应用程序域时，我们会注意到复杂性存在差异，作为管理员，我们需要理解这种复杂性到底是什么，然后才能做出正确的选择。
- en: Understanding domain complexity
  id: totrans-122
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 了解域复杂性
- en: 'SELinux is able to provide full system confinement: each and every application
    runs in its own restricted environment that it cannot break out of. But that requires
    fine-grained policies that are developed as quickly as the new releases of all
    the applications they confine.'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: SELinux能够提供完整的系统限制：每个应用程序都在自己无法突破的受限环境中运行。但这需要细粒度的策略，这些策略必须随着所有应用程序的新版本快速开发。
- en: 'Developing fine-grained policies at this speed is not possible, so a balance
    has to be struck between the maintainability of a policy and the security of the
    domain. This balance is the policy design complexity or domain complexity, which
    can be roughly categorized as follows:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 以这样的速度制定细粒度的策略是不可能的，因此必须在策略的可维护性和域的安全性之间找到平衡。这个平衡就是策略设计的复杂性或域复杂性，可以大致分为以下几类：
- en: '**Fine-grained policies** have separate, individual domains for each sub component
    of an application or service. Such policies have the advantage that they really
    attempt to restrict applications as much as possible. Through fine-grained policies,
    roles developed with users and administrators in mind become fine-grained as well,
    for instance, by differentiating sub-roles in the application.'
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**细粒度策略**为应用程序或服务的每个子组件设置独立的、单独的域。这种策略的优点在于它们尽可能地限制应用程序。通过细粒度策略，针对用户和管理员开发的角色也会变得更精细，例如通过区分应用程序中的子角色。'
- en: The disadvantage of such policies is that they are hard to maintain, requiring
    frequent updates as the application itself evolves. The policies also need to
    take into account the impact of the various configuration options that the application
    supports.
  id: totrans-126
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这种策略的缺点是它们很难维护，需要随着应用程序本身的演变频繁更新。策略还需要考虑应用程序所支持的各种配置选项的影响。
- en: Such fine-grained policies are not frequently found. An example is the policy
    set provided for the Postfix mail infrastructure. Each sub-service of the Postfix
    infrastructure has its own SELinux domain.
  id: totrans-127
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这样的细粒度策略并不常见。一个例子是为Postfix邮件基础设施提供的策略集。Postfix基础设施的每个子服务都有自己的SELinux域。
- en: '**Application-level policies** use a single domain for an application, regardless
    of its sub-components. This balances the requirement for application confinement
    versus the maintainability of the application and its SELinux policy.'
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**应用程序级别的策略**为应用程序使用单一域，无论其子组件如何。这在应用程序的限制性需求与应用程序及其 SELinux 策略的可维护性之间达到了平衡。'
- en: Such application-level policies are the most common in SELinux policies. They
    do still suffer from regular maintenance as applications expand their functionality,
    but the complexity of this is limited and SELinux policy developers should not
    have too many problems maintaining these policies.
  id: totrans-129
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这种应用程序级别的策略是 SELinux 策略中最常见的策略。尽管随着应用程序功能的扩展，它们确实面临常规维护问题，但其复杂性是有限的，SELinux
    策略开发人员应该不会在维护这些策略时遇到太多问题。
- en: '**Category-wide policies** use a single domain definition for a set of applications
    that implement the same functionality. This is popular for services that act very
    similarly and whose user-role definitions can be described without really considering
    the application-specific nature.'
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**类别广泛的策略**为一组实现相同功能的应用程序使用单一的域定义。这种策略适用于那些行为非常相似的服务，它们的用户角色定义可以在不考虑特定应用性质的情况下描述。'
- en: A good example of a category-wide policy is the policy for web servers. While
    this policy was initially written for the Apache HTTP daemon, the policy has become
    reusable for a number of web servers, such as the Cherokee, Hiawatha, Nginx, and
    Lighttpd projects.
  id: totrans-131
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 类别广泛策略的一个好例子是针对 web 服务器的策略。虽然这个策略最初是为 Apache HTTP 守护进程编写的，但它已经变得可以重用，适用于多个 web
    服务器，例如 Cherokee、Hiawatha、Nginx 和 Lighttpd 项目。
- en: While such policies are easier to maintain, the downside of category-wide policies
    is that they often have more broad privileges than really needed. As more applications
    are joined in the category-wide policy, additional rules and privileges are added
    to support those specific functions.
  id: totrans-132
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 虽然此类策略更易于维护，但类别广泛策略的缺点是，它们往往拥有比实际需要更广泛的权限。随着更多应用加入类别广泛策略，为了支持这些特定功能，会增加更多的规则和权限。
- en: '**Coarse-grained policies** are used for applications or services whose behavior
    is hard to define. End user domains are examples of coarse-grained policies, as
    are unconfined domains.'
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**粗粒度策略**用于那些难以定义行为的应用程序或服务。最终用户域是粗粒度策略的一个例子，未受限的域也是如此。'
- en: When we are dealing with a new application, and we want to quickly assign a
    decent-enough policy, the most common method is to see whether a category-wide
    policy exists that we can reuse for the application.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们处理一个新的应用程序，并希望快速分配一个足够合适的策略时，最常见的方法是查看是否存在可以为该应用程序重用的类别广泛策略。
- en: Running applications in a specific policy
  id: totrans-135
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在特定策略中运行应用程序
- en: Let's consider the situation for the pgpool-II application. When we install
    it without any additional changes, it will run with the `unconfined_service_t`
    domain, as mentioned in the *Marking domains as permissive* section. But perhaps
    we can find a suitable policy to run the pgpool-II application with, through which
    it is more confined.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们考虑一下 pgpool-II 应用程序的情况。当我们在没有任何额外更改的情况下安装它时，按照 *标记域为宽松* 部分所述，它将以 `unconfined_service_t`
    域运行。但也许我们可以找到一个合适的策略，使得 pgpool-II 应用程序能够在更受限制的环境中运行。
- en: 'As the pgpool-II solution is a load balance-like application for PostgreSQL
    databases, it is likely we can run it in the PostgreSQL domain. If there are no
    PostgreSQL databases running on the same system, then lending this domain for
    the pgpool-II application might not do much harm. Let''s see how well this goes:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 pgpool-II 解决方案是一个类似负载均衡的 PostgreSQL 数据库应用程序，因此我们可能可以将其运行在 PostgreSQL 域中。如果系统上没有运行
    PostgreSQL 数据库，那么将这个域分配给 pgpool-II 应用程序可能不会造成太大损害。让我们看看效果如何：
- en: 'The PostgreSQL policy uses the `postgresql_exec_t` SELinux type for its executables,
    so let''s assign that one to the `pgpool` binary:'
  id: totrans-138
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: PostgreSQL 策略使用 `postgresql_exec_t` SELinux 类型来处理其可执行文件，因此我们将其分配给 `pgpool` 二进制文件：
- en: '[PRE18]'
  id: totrans-139
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'If we try to start the `pgpool` system service, we might get one or more failures:'
  id: totrans-140
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果我们尝试启动 `pgpool` 系统服务，可能会遇到一个或多个失败：
- en: '[PRE19]'
  id: totrans-141
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'One of the failures mentioned is that the daemon cannot access its logs (in
    `/var/log/pgpool`) while another complains about the process ID file (in `/var/run/pgpool`)
    being unreachable. As these were previously created by an unconfined domain, it
    is indeed likely that their context is wrong as well. Let''s apply the PostgreSQL-specific
    types to these locations:'
  id: totrans-142
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 提到的一个故障是守护进程无法访问其日志（位于`/var/log/pgpool`），另一个则抱怨进程ID文件（位于`/var/run/pgpool`）无法访问。由于这些文件之前是由一个不受限的域创建的，确实有可能它们的上下文也不正确。让我们将PostgreSQL特定的类型应用到这些位置：
- en: '[PRE20]'
  id: totrans-143
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'After restarting `pgpool`, we notice it has a new failure:'
  id: totrans-144
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在重新启动`pgpool`后，我们发现它出现了一个新的故障：
- en: '[PRE21]'
  id: totrans-145
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Let''s create a small policy enhancement to allow `postgresql_t` to bind to
    this port:'
  id: totrans-146
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们创建一个小的策略增强，允许`postgresql_t`绑定到这个端口：
- en: '[PRE22]'
  id: totrans-147
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Load this policy and restart `pgpool`. With this in place, `pgpool` starts up
    fine.
  id: totrans-148
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 加载这个策略并重启`pgpool`。这样一来，`pgpool`就可以正常启动了。
- en: Of course, having the daemon launch without problems does not mean that it will
    work without problems, so it is recommended to continue testing, using the service
    as intended.
  id: totrans-149
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 当然，守护进程能够启动而不出错并不意味着它能正常工作，因此建议继续进行测试，按照预期使用该服务。
- en: Finding out which policy can be reused for a process requires a bit of practice
    and searching. For instance, you can query the policy for which domains are able
    to bind to the port that the daemon needs. Or you can search for a domain that
    has a behavior very similar to the application involved. In our example, we only
    had to allow the domain to bind to port `9999`. We could also use this information
    point to seek a different policy—one that is allowed to bind to this port (such
    as the `httpd_t` domain) and see whether that one fits better.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 找出哪个策略可以重用给一个进程需要一点实践和搜索。例如，你可以查询哪个域能够绑定到守护进程需要的端口，或者你可以搜索一个行为非常类似于应用程序的域。在我们的例子中，我们只需要允许该域绑定到`9999`端口。我们也可以使用这一信息点来寻找一个不同的策略——一个允许绑定到该端口的策略（例如`httpd_t`域），然后看看它是否更合适。
- en: While this approach is trial and error, it could allow running the service in
    a more confined domain than the unconfined domain would. A much better approach,
    however, is to generate a new, custom policy and work from there.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这种方法是试错法，但它可能会使服务在比不受限域更受限的域中运行。然而，更好的方法是生成一个新的自定义策略，并从那里开始工作。
- en: Extending generated policies
  id: totrans-152
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 扩展生成的策略
- en: When we assign a different policy to a new application, we are reusing and possibly
    extending existing policies. We can go a step further and generate new policies,
    after which we can further extend those policies, effectively moving into the
    realm of developing new policies ourselves.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们为一个新的应用程序分配一个不同的策略时，我们实际上是在重用并可能扩展现有的策略。我们可以进一步生成新的策略，然后进一步扩展这些策略，实际上进入了自己开发新策略的领域。
- en: In [*Chapter 15*](B16276_15_Final_VK.xhtml#_idTextAnchor373), *Using the Reference
    Policy*, and [*Chapter 16*](B16276_16_Final_VK.xhtml#_idTextAnchor391), *Developing
    Policies with SELinux CIL*, we will expand further into the policy development
    aspects for more fine-grained control. By using policy generation tools, however,
    we can quickly create a first-draft policy and adapt as needed.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 在[*第15章*](B16276_15_Final_VK.xhtml#_idTextAnchor373)，《使用参考策略》，以及[*第16章*](B16276_16_Final_VK.xhtml#_idTextAnchor391)，《使用SELinux
    CIL开发策略》中，我们将进一步扩展策略开发的相关内容，以实现更细粒度的控制。通过使用策略生成工具，我们可以快速创建一个初稿策略，并根据需要进行调整。
- en: An important caveat is that policy generation tools often limit themselves to
    a single-policy format, either being reference policy style or CIL style. Administrators
    and organizations should try to focus on a single style and stick with that so
    that the learning curve for new developers and administrators isn't too high.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 一个重要的警告是，策略生成工具通常只限于单一策略格式，要么是参考策略风格，要么是CIL风格。管理员和组织应该尝试专注于一种风格并坚持使用，这样新开发人员和管理员的学习曲线就不会太陡峭。
- en: Understanding the limitations of generated policies
  id: totrans-156
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 理解生成的策略的局限性
- en: Policy generators, such as the `udica` tool we saw in [*Chapter 11*](B16276_11_Final_VK.xhtml#_idTextAnchor293),
    *Enhancing the Security of Containerized Workloads*, often have a very specific
    purpose. For instance, the `udica` tool focuses on generating new container SELinux
    domains and is only useful for those containers. Generators will always have a
    specific target in mind for what their policies should look like.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 策略生成器，例如我们在 [*第11章*](B16276_11_Final_VK.xhtml#_idTextAnchor293) 中看到的 `udica`
    工具，*增强容器化工作负载的安全性*，通常有一个非常特定的目的。例如，`udica` 工具专注于生成新的容器 SELinux 域，仅对这些容器有用。生成器通常有一个明确的目标，来定义它们的策略应该是什么样的。
- en: The generated policies are often application-level policies. Creating fine-grained
    policies with generators is hard, and defining category-wide policies requires
    multiple steps and occurrences, whereas generators often use single-step generations.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 生成的策略通常是应用层的策略。通过生成器创建精细粒度的策略是困难的，而定义跨类别的策略需要多个步骤和多次操作，而生成器通常采用单步生成。
- en: 'Furthermore, most generated policies only generally support role-based access
    controls within SELinux: either a user is allowed the target SELinux domain and
    interacting with it, or the user isn''t allowed. Differentiating roles (such as
    application administrator versus application user) are not often included in generated
    policies.'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，大多数生成的策略仅一般支持基于角色的 SELinux 访问控制：用户要么被允许访问目标 SELinux 域并与其交互，要么不允许访问。生成的策略中通常不包含角色区分（例如应用管理员与应用用户）。
- en: Administrators should be aware that generators also have to make assumptions
    about how applications work. While this allows generators to be used for the majority
    of simple services and applications, they are definitely not ready yet to substitute
    a knowledgeable team of SELinux policy developers.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 管理员应当意识到，生成器也必须假设应用程序的工作方式。虽然这使得生成器适用于大多数简单的服务和应用程序，但它们显然还不能替代一支有经验的 SELinux
    策略开发团队。
- en: Introducing sepolicy generate
  id: totrans-161
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 引入 sepolicy generate
- en: The `sepolicy` command is able to generate initial SELinux policy modules, which
    administrators and developers can then fine-tune further. This generator will
    use some resources on the system (such as the package database of the distribution)
    to better understand which resources to include, and generates a number of SELinux
    policy files.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: '`sepolicy` 命令能够生成初始的 SELinux 策略模块，管理员和开发者可以进一步调整。这些生成器会利用系统上的一些资源（例如发行版的包数据库），更好地了解应包含哪些资源，并生成一系列
    SELinux 策略文件。'
- en: 'As there are different types of applications around, the `sepolicy generate`
    command also requires the user to inform it about the application type. The following
    types are currently supported:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 由于应用程序种类繁多，`sepolicy generate` 命令还需要用户提供应用程序类型。目前支持以下类型：
- en: User applications are identified with the `--application` option. Such applications
    are meant for end users to launch and interact with.
  id: totrans-164
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用户应用程序通过 `--application` 选项进行识别。这类应用程序是供最终用户启动并与之交互的。
- en: System service applications are identified with the `--init` option. Applications
    that run in daemon mode or with their own user are most often system service applications.
  id: totrans-165
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 系统服务应用程序通过 `--init` 选项进行识别。以守护进程模式运行或拥有自己用户的应用程序通常是系统服务应用程序。
- en: D-Bus system service applications are identified with the `--dbus` option. This
    type of service is invoked by D-Bus.
  id: totrans-166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: D-Bus 系统服务应用程序通过 `--dbus` 选项进行识别。这类服务由 D-Bus 调用。
- en: '`--cgi` option. Using CGI-specific domains allows having CGI applications run
    in their own domain, rather than extending the privileges of the web server domain
    itself.'
  id: totrans-167
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`--cgi` 选项。使用 CGI 特定域可以让 CGI 应用程序在自己的域中运行，而不是扩展 Web 服务器域本身的权限。'
- en: '`--inetd` option.'
  id: totrans-168
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`--inetd` 选项。'
- en: Sandbox applications are like user applications but much more confined, and
    are supported through the `--sandbox` option.
  id: totrans-169
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 沙箱应用程序类似于用户应用程序，但更为封闭，并通过 `--sandbox` 选项提供支持。
- en: 'Next to application-level policy generation, `sepolicy generate` also supports
    generating user domains and roles:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 除了应用层策略生成，`sepolicy generate` 还支持生成用户域和角色：
- en: Standard users with support for the graphical desktop can be generated using
    the `--desktop_user` option. This is a common, non-administration-oriented user
    role.
  id: totrans-171
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 支持图形桌面的标准用户可以通过 `--desktop_user` 选项生成。这是一种常见的非管理型用户角色。
- en: A more lightweight, minimal user role that still supports the graphical desktop
    can be generated using the `--x_user` option. This domain focuses on minimal permissions
    and thus requires further extensions before they can be better put to use.
  id: totrans-172
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`--x_user`选项可以生成一个更轻量、最小的用户角色，仍然支持图形桌面。此域专注于最小权限，因此需要进一步扩展，才能更好地发挥作用。
- en: If no graphical user interface needs to be supported, then you can use the `--term_user`
    option. This generates a confined user domain without desktop support.
  id: totrans-173
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果不需要支持图形用户界面，则可以使用`--term_user`选项。这将生成一个没有桌面支持的受限用户域。
- en: Administration-oriented user domains can be generated using the `--admin_user`
    option. This is meant for broad administrative privileges.
  id: totrans-174
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可以使用`--admin_user`选项生成面向管理的用户域。此选项适用于具有广泛管理权限的用户。
- en: More confined administration domains can be generated using the `--confined_admin`
    option. This allows you to generate user domains that have administrative roles
    for a limited number of application domains, not to the system as a whole.
  id: totrans-175
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可以使用`--confined_admin`选项生成更多受限的管理域。这使您能够生成仅对少数应用程序域具有管理角色的用户域，而不是对整个系统进行管理。
- en: The generator also supports customizing existing domains further (using `--customize`)
    or generating specific types (using `--newtype`).
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 生成器还支持进一步自定义现有域（使用`--customize`）或生成特定类型（使用`--newtype`）。
- en: Let's use `sepolicy generate` to generate a policy for the pgpool-II application.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用`sepolicy generate`为pgpool-II应用程序生成策略。
- en: Generating policies with sepolicy generate
  id: totrans-178
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用sepolicy generate生成策略
- en: The `sepolicy generate` command will create a skeleton SELinux policy, using
    the reference policy code style. This policy can then be gradually extended with
    the privileges the application needs.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: '`sepolicy generate`命令将创建一个骨架SELinux策略，采用参考策略代码样式。然后可以逐步扩展此策略，以满足应用程序所需的权限。'
- en: 'Let''s create and adapt the policy for `pgool`:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们为`pgpool`创建并调整策略：
- en: 'First, we tell `sepolicy` to generate a new policy, named `pgpool`, which is
    intended for the `/usr/bin/pgpool` binary:'
  id: totrans-181
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们告诉`sepolicy`生成一个名为`pgpool`的新策略，适用于`/usr/bin/pgpool`二进制文件：
- en: '[PRE23]'
  id: totrans-182
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Next, build the generated SELinux policy:'
  id: totrans-183
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，构建生成的SELinux策略：
- en: '[PRE24]'
  id: totrans-184
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Load the policy in memory:'
  id: totrans-185
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将策略加载到内存中：
- en: '[PRE25]'
  id: totrans-186
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Relabel the filesystem, or at least the locations mentioned in the generated
    `pgpool.fc` file:'
  id: totrans-187
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 重新标记文件系统，或者至少是`pgpool.fc`文件中提到的位置：
- en: '[PRE26]'
  id: totrans-188
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Start the `pgpool` service:'
  id: totrans-189
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 启动`pgpool`服务：
- en: '[PRE27]'
  id: totrans-190
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Now, you might have the impression that this was too easy. Yes, it was. The
    default SELinux policy that `sepolicy generate` provides is permissive, as you
    can see from within the `pgpool.te` file:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，您可能会觉得这太简单了。是的，的确如此。`sepolicy generate`提供的默认SELinux策略是宽容的，正如您可以在`pgpool.te`文件中看到的那样：
- en: '[PRE28]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'If we remove this statement, rebuild, and reload the policy, then we will notice
    the failures coming up again, such as the process not being allowed to bind to
    the selected ports. We can now use `audit2allow`, for instance, to help us extend
    the policy as needed:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们删除此语句，重新构建并重新加载策略，那么我们会注意到失败再次出现，例如进程无法绑定到所选端口。我们现在可以使用`audit2allow`，例如，帮助我们根据需要扩展策略：
- en: '[PRE29]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Gradually extend, rebuild, and reload the policy until the application works
    without problems.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 逐步扩展、重建并重新加载策略，直到应用程序无故障运行。
- en: Summary
  id: totrans-196
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: Linux administrators can use SELinux controls to prevent or confine access to
    applications, but this is not always the requirement at hand. Being able to run
    the application with the *right* set of permissions is, and what the right set
    is depends on the user's intentions and the environment.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: Linux管理员可以使用SELinux控制来防止或限制对应用程序的访问，但这并不总是当前的需求。能够以*正确*的权限集运行应用程序才是关键，而正确的权限集取决于用户的意图和环境。
- en: Within this chapter, we've learned how to apply the appropriate confinement
    to application domains, ranging from very isolated container environments over
    regular application domains, category-wide permission sets, and up to unconfined
    domains and even permissive domains. We learned that this is done by first finding
    the appropriate domain, understanding which labels the domain uses, and then assigning
    the right labels to the files so that the application is executed in the right
    domain.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们学习了如何对应用程序域应用适当的限制，从高度隔离的容器环境，到常规应用程序域、类别范围的权限集，再到无限制域甚至宽容域。我们了解到，这是通过首先找到适当的域，理解该域使用的标签，然后为文件分配正确的标签，从而确保应用程序在正确的域中执行。
- en: We also learned how to generate new policies (using `sepolicy generate`) ourselves
    without immediately having to dive into a full SELinux policy development approach,
    which is what we will consider in the final two chapters.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还学习了如何自己生成新的策略（使用`sepolicy generate`），而不需要立即深入全面的SELinux策略开发方法，这将在最后两章中讨论。
- en: Questions
  id: totrans-200
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: What is the difference between an unconfined domain and a permissive domain?
  id: totrans-201
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 非受限域和宽容域有什么区别？
- en: How can we run applications in a very restricted domain?
  id: totrans-202
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们如何在一个非常受限的域中运行应用程序？
- en: How can we easily switch the domain in which a service will run?
  id: totrans-203
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们如何轻松切换服务运行的域？
- en: Why do policies generated by `sepolicy` seemingly run without problems?
  id: totrans-204
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为什么由`sepolicy`生成的策略似乎可以顺利运行？
