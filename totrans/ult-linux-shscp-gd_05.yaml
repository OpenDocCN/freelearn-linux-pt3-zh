- en: '5'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Customizing the Environment
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we’ll look at the various configuration files for the `bash`
    shell environment. We’ll look at how to customize these configuration files, and
    how to set certain environmental options from the command-line.
  prefs: []
  type: TYPE_NORMAL
- en: 'Topics in this chapter include:'
  prefs: []
  type: TYPE_NORMAL
- en: Reviewing the environmental variables
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding the configuration files
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Setting shell options from the command line
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: I’m sticking with `bash` for now, but in *Chapter 22, Understanding the Z Shell*,
    I’ll explain how `zsh` is set up.
  prefs: []
  type: TYPE_NORMAL
- en: If you’re raring and ready, let’s get going.
  prefs: []
  type: TYPE_NORMAL
- en: Technical Requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For this chapter, you’ll need one Fedora virtual machine and one Debian virtual
    machine. I won’t be providing a Hands-On Lab in this chapter. Instead, I’ll just
    invite you to follow along on your virtual machines as you read through the chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Reviewing the Environmental Variables
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In *Chapter 3, Understanding Variables and Pipelines*, I introduced the concept
    of environmental variables. In this chapter, I’d like to expand on that topic.
  prefs: []
  type: TYPE_NORMAL
- en: 'We’ve already seen that environmental variables can be used to help customize
    and control your shell environment. Here’s a table of some of the more common
    environmental variables:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Environmental Variable** | **Purpose** |'
  prefs: []
  type: TYPE_TB
- en: '| `USER` | The username of the person who is currently logged into the system.
    |'
  prefs: []
  type: TYPE_TB
- en: '| `UID` | The User ID number of the logged-in user. |'
  prefs: []
  type: TYPE_TB
- en: '| `EUID` | The Effective User ID number of the user who’s running a certain
    process. |'
  prefs: []
  type: TYPE_TB
- en: '| `MAIL` | This defines the path to the mail spool of the logged in user. |'
  prefs: []
  type: TYPE_TB
- en: '| `SHELL` | The path to the shell that is currently in use. |'
  prefs: []
  type: TYPE_TB
- en: '| `PWD` | The current working directory. (PWD stands for “Print Working Directory”.)
    |'
  prefs: []
  type: TYPE_TB
- en: '| `OLDPWD` | The previous working directory. |'
  prefs: []
  type: TYPE_TB
- en: '| `HOSTNAME` | The hostname of the computer. |'
  prefs: []
  type: TYPE_TB
- en: '| `PATH` | A colon-delimited list of directories in which the system looks
    when you type an executable program name. This variable gets built in several
    configuration files, such as `/etc/profile` and the `.bashrc` file that resides
    in the user’s home directory. |'
  prefs: []
  type: TYPE_TB
- en: '| `HOME` | This holds the path for the current user’s home directory. Some
    programs will use this variable to determine where to find configuration files
    or determine the default location to store files. |'
  prefs: []
  type: TYPE_TB
- en: '| `PS1` | The primary shell prompt. |'
  prefs: []
  type: TYPE_TB
- en: '| `PS2` | The secondary shell prompt. |'
  prefs: []
  type: TYPE_TB
- en: '| `TERM` | This specifies the current terminal type. You’ll probably see it
    set as either `xterm` or some form of `xterm` for non-login sessions and login
    sessions from a remote GUI terminal emulator, and just `Linux` for login sessions
    at the local console. (I’ll explain the types of sessions in the next section.)
    The system needs to know which terminal type is in use so that it will know how
    to move the cursor and display text effects in text-mode programs. |'
  prefs: []
  type: TYPE_TB
- en: '| `DISPLAY` | This variable allows you to have multiple displays running from
    the same computer. If you’re only running one display, you’ll see a returned value
    of `:0`. (That means, the first display on the current computer.) |'
  prefs: []
  type: TYPE_TB
- en: '| `EDITOR` | This sets the default text editor that you want to use for system
    administrative functions such as `systemctl edit` and `crontab -e`. Your best
    choices are generally either `nano` or `vim`. |'
  prefs: []
  type: TYPE_TB
- en: 'Table 5.1: The more common environmental variables'
  prefs: []
  type: TYPE_NORMAL
- en: The slightly tricky part about this is that environmental variables aren’t always
    exactly the same across all Linux distros. For example, the `EDITOR` variable
    is defined here on my Fedora workstation, but it’s not used at all on any Debian
    or Ubuntu distros. Instead, Debian and Ubuntu use another mechanism for setting
    the default editor, which we’ll look at in a bit.
  prefs: []
  type: TYPE_NORMAL
- en: Now, before I can fully explain the `bash` configuration files, I need to explain
    the different types of shell sessions.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding Shell Sessions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Any time you initiate interaction with a shell, you’re creating a **shell session**.
    Shell sessions can be classified in the following ways:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Interactive shells**: When you sit down at a computer and enter commands
    on the command-line, you’re working with an interactive shell.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Non-interactive shells**: When a shell session is invoked from within a shell
    script, you’re working with a non-interactive shell.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Login shells:** If you log into a Linux machine that’s running in text mode,
    without a graphical interface, you’re working with a login shell. You can also
    work with a login shell on a desktop machine by invoking a *Ctrl-Alt-Function_Key*
    sequence to switch away from the desktop interface to a text mode terminal. (You
    can use function keys F1 through F6 for this.) Or, you can invoke the `bash -l`
    command in the normal terminal emulator to open a child `bash` session in login
    mode. The final way to initiate a login shell session is to log into a machine
    remotely via Secure Shell. Regardless of whether the remote machine is of a text-mode
    or GUI-mode variety, your remote session will be of the login shell type.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Non-login shells**: Any time you open a terminal emulator on a desktop Linux
    machine, you’re working with a non-login shell.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: So, what does all this mean? Well, the difference between interactive and non-interactive
    shells is fairly obvious, so I won’t talk more about that. But, I would like to
    point out two different ways to know whether you’re working with a login shell
    or a non-login shell.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first way is to use the `shopt` command, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'The `shopt` command can be used to set various configuration options for a
    `bash` session. Here though, I’m using it without any option switches to just
    view the `login_shell` setting. You see here that the `login_shell` setting is
    `off`, which means that I’m in a non-login shell here on my Fedora workstation.
    On my text mode Fedora Server virtual machine, the `shopt` output looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: As you see, the `login_shell` parameter is `on`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The second way to tell if you’re in a login shell is to use the `echo $0` command,
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: The `$0` argument is what’s known as a **positional parameter**. I’ll provide
    in-depth coverage of positional parameters in *Chapter 8, Basic Shell Script Construction*,
    so don’t stress out about them just yet. All you need to know for now is that
    the `echo $0` command shows the name of the script or executable that’s currently
    in use.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this case, we’re in a `bash` session, which means that the `bash` executable
    is in use. But, how do we know whether or not we’re using a login shell? Well,
    it’s just that the `bash` output is not preceded by a dash, which means that we’re
    not in a login shell. To show the difference, here’s what you’ll see on the text-mode
    Fedora Server virtual machine:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: The `-bash` output indicates that I’m in a login shell.
  prefs: []
  type: TYPE_NORMAL
- en: Even from afar, I can read your mind. (Yes, I know that that’s creepy.) I know
    that you’re wondering why you need to know about these different types of shell
    sessions. Well, it’s just that there are several different `bash` configuration
    files. The type of shell session you’re using determines which configuration files
    the session accesses. So, now that you know about the different types of shell
    sessions, we can look at these configuration files.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the Configuration Files
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As we’ve already seen, you can set environmental variables from the command-line.
    But, any variables you set in this manner will only last for the duration of the
    command-line session. When you log out of the system or close the terminal emulator
    window, any environmental changes that you’ve made from the command-line will
    be lost.
  prefs: []
  type: TYPE_NORMAL
- en: What if we want to make these changes permanent? There are several configuration
    files that we can edit to save our changes. Some are global and will affect all
    users, while others will only affect an individual user. The slightly tricky part
    is that the files differ from one Linux distro to the next. Let’s start by looking
    at the `bash` configuration files on Fedora. After that, we’ll move on to Debian.
  prefs: []
  type: TYPE_NORMAL
- en: bash Global Configuration Files on Fedora
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'As we’ve already seen, there are global configuration files in the `/etc/`
    directory, and users’ configuration files in each user’s own home directory. For
    the global configuration, we have these two files:'
  prefs: []
  type: TYPE_NORMAL
- en: '`/etc/profile`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`/etc/bashrc`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The `/etc/profile` file sets up the environment for anyone who opens a `bash`
    login shell session, and is executed as soon as a user logs in. Go ahead and open
    it and look through it. What you’ll see is a somewhat complex shell script that
    performs the following functions:'
  prefs: []
  type: TYPE_NORMAL
- en: It defines the default `PATH` setting for both the root user and every non-root
    user who’s using a login shell.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It defines the various environmental variables that are associated with each
    logged-in user. These include the `UID`, `EUID`, `USER`, `LOGNAME`, and `MAIL`
    variables.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It sets the machine’s `HOSTNAME`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It sets the `HISTSIZE` variable, which defines how many past commands will be
    held in each user’s command history.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: After having done all of the above, it reads in the various configuration scripts
    in the `/etc/profile.d/` directory. Most of these scripts define system-wide behaviors
    for certain system utilities. There’s also a script that sets the default `EDITOR`
    for system utilities that automatically open a text editor.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Of course, at this point I don’t expect you to completely understand what’s
    going on in this profile file. However, what you see in this file is the kind
    of stuff that we’ll be covering throughout the remainder of this book. Once you’ve
    gone through all of that, you’ll be able to come back and have a better understanding
    of exactly what this file is doing.
  prefs: []
  type: TYPE_NORMAL
- en: The other global configuration file is the `/etc/bashrc` file, which affects
    non-login shell sessions. It does a few different things for us, but for our present
    purposes just know that this is where the `PS1` variable is defined for interactive
    sessions, and that it defines the `PATH` setting for users who are using a non-login
    shell.
  prefs: []
  type: TYPE_NORMAL
- en: 'In addition to these two main files, there are also supplementary configuration
    files in the `/etc/profile.d/` directory, as you see here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Each of these files contains supplementary configuration information for the
    shell environment. In general, each file does either one of these two things for
    us:'
  prefs: []
  type: TYPE_NORMAL
- en: Creating aliases for certain other commands. (We’ll cover aliases in just a
    bit.)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Defining environmental variables that aren’t already defined in the `/etc/profile`
    or `/etc/bashrc` files.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'For a simple example of the second function, let’s look at the definition for
    the `EDITOR` variable. On the server version of Fedora it will be in the `/etc/profile.d/vim-default-editor.sh`
    file, and on the workstation version of Fedora it will be in the `/etc/profile.d/nano-default-editor.sh`
    file. Here’s what the server version looks like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Again, I don’t expect you to fully understand what’s going on with this just
    yet. So for now, the simple explanation is that if the `EDITOR` environmental
    variable hasn’t yet been set, then it will be set it to `/usr/bin/vim`. (On the
    workstation edition of Fedora, `EDITOR` will be set to `/usr/bin/nano`.)
  prefs: []
  type: TYPE_NORMAL
- en: 'There may be times when an administrator needs to alter the default environmental
    settings that have been defined in either `/etc/profile` or `/etc/bashrc`. You
    could do that by editing the `/etc/profile` or the `/etc/bashrc` file, but that’s
    not recommended. Instead, just place the new settings in the `/etc/profile.d/sh.local`
    file. Currently, there’s nothing in that file except for an explanatory comment,
    as we see here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Okay, that about does it for the global configuration files on Fedora. Let’s
    now look at the users’ own configuration files.
  prefs: []
  type: TYPE_NORMAL
- en: Users’ Configuration Files on Fedora
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Shell configuration files in the users’ home directories are considered as
    hidden files, because their filenames begin with a dot. To see them, you’ll need
    to use the `-a` option with `ls`, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Only three of these files are of concern to us, which are:'
  prefs: []
  type: TYPE_NORMAL
- en: '`.bash_logout`: This file is currently empty, except for an explanatory comment.
    Any commands that you place in this file will be executed either upon logging
    out of an interactive login shell session, or when the `exit` function is invoked
    at the end of a shell script. Among other things, you could use this to automatically
    clean up temporary files or to perform an automatic backup of files in a user’s
    home directory when the user exits the shell session.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`.bash_profile`: This file is only used for login shell sessions. So, if you
    open a terminal emulator on your desktop machine, anything that’s in this file
    will have no effect. If you look at the contents of this file, you’ll see that
    the only thing it does by default is to cause the `.bashrc` file to be read in.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`.bashrc`: This is the main bash configuration file for the user level, which
    directly affects non-login shell sessions. Since the `.bash_profile` file causes
    the `.bashrc` file to be read in for login shell sessions, anything you place
    into `.bashrc` affects both login and non-login sessions.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'So, how does this work in practice? Well, let’s say that you need to add the
    `/opt/` directory to your working `PATH`. Currently, the `PATH` looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'To add the `/opt/` directory, open the `.bashrc` file in your text editor,
    and look for this stanza:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Change it so that it looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Log out and then log back in. Your `PATH` setting should now look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: You can now place executable scripts or binary executable files in the `/opt/`
    directory, and run them without having to specify the entire path.
  prefs: []
  type: TYPE_NORMAL
- en: 'To make a permanent change to your command prompt setting so that it will also
    show the current date and time, place this line at the end of the `.bashrc` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Log out and log back in. Your command prompt should now look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: So, that’s all pretty cool, right? For even more coolness, let’s move on to
    the Debian configuration files.
  prefs: []
  type: TYPE_NORMAL
- en: bash Global Configuration Files on Debian
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: On Debian, things are somewhat different. The `/etc/profile` file is still there,
    but it’s radically different from the one on Fedora. Go ahead and look at it on
    your own virtual machine. You’ll see that all it does is define the `PATH` and
    `PS1` variables and read in any supplementary files that are in the `/etc/profile.d/`
    directory. If the session is an actual `bash` session instead of an `sh` session,
    then it will also read in the `/etc/bash.bashrc` file. Also, you’ll see that Debian
    uses a method for defining `PATH` that’s radically different from the method that’s
    used on Fedora.
  prefs: []
  type: TYPE_NORMAL
- en: 'Instead of the `/etc/bashrc` file that Fedora uses, Debian uses the `/etc/bash.bashrc`
    file. This file does the following things for us:'
  prefs: []
  type: TYPE_NORMAL
- en: It checks the size of the window in which the `bash` session is running, so
    that the correct number of lines and columns can be displayed after the user enters
    a command.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It defines the `PS1` variable.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If a user enters a command that `bash` can’t find, it invokes the `command_not_found_handle`
    function if the `command-not-found` software package isn’t installed.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: At the top of the `bash.bashrc` file, you’ll see that it’s invoked for interactive
    shell sessions, and that it will also get invoked for login shell sessions if
    the `profile` file sources it. We’ve already seen that the `profile` file does
    source it, so we know that `bash.bashrc` does run for both login and non-login
    interactive sessions.
  prefs: []
  type: TYPE_NORMAL
- en: When a configuration file reads in information from another configuration file,
    we say that the first file is **sourcing** the second file.
  prefs: []
  type: TYPE_NORMAL
- en: Unlike on Fedora, the `/etc/profile.d/` directory doesn’t do much for us by
    default. The only thing you’ll see there is the `bash_completion.sh` script. As
    you’ll see in a moment, the aliases that are defined in the `/etc/profile.d/`
    directory on Fedora are defined in the users’ configuration files on Debian.
  prefs: []
  type: TYPE_NORMAL
- en: Users’ Configuration Files on Debian
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In each user’s home directory on a Debian system, we have these bash configuration
    files:'
  prefs: []
  type: TYPE_NORMAL
- en: '`.bash_logout`: This is the same as the `.bash_logout` file on Fedora, except
    that it contains a command that will clear the screen upon logout from a login
    session.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`.profile`: This replaces the `.bash_profile` that’s on Fedora, and serves
    the same purpose.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`.bashrc`: It does the same things as the `.bashrc` file on Fedora, and more
    besides. It also defines some of the environmental variables that are defined
    globally on Fedora, and it also defines some of the aliases that are defined in
    the `/etc/profile.d/` directory on Fedora.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As I’ve already told you, I don’t expect you to read through any of these configuration
    files and completely understand what they’re doing. That’s why I’ve only shown
    you a few small snippets of these files instead of trying to explain each one
    in detail. After you’ve completely gone through this book, you’ll have gained
    a better understanding of them.
  prefs: []
  type: TYPE_NORMAL
- en: I should also point out that every family of Linux distros has its `bash` configuration
    files set up differently. I can’t cover all of them, but you can probably figure
    out what’s going on with them from what I’ve told you here.
  prefs: []
  type: TYPE_NORMAL
- en: Setting the Default Editor on Debian
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Oh, dear, I almost forgot to show you how to change the default editor for Debian,
    since we can’t do it by setting an environmental variable. So, let’s look at that
    now.
  prefs: []
  type: TYPE_NORMAL
- en: 'On a Debian system, the default editor is defined by a pair of symbolic links,
    as you see here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'The `editor` symbolic link in the `/usr/bin/` directory points to the `editor`
    symbolic link in the `/etc/alternatives/` directory, which in turn points to the
    `nano` executable that’s in the `/bin/` directory. This tells us that `nano` is
    set as the default editor. To change the default editor on a Debian machine, you’ll
    first need to ensure that the editor that you want to use is installed. Then,
    use the `update-alternatives` utility, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'I’ve chosen the number `2` option to set `vim` as the default editor. Let’s
    see how that changed the symbolic link in the `/etc/alternatives/` directory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Very cool. This allows me to use my favorite editor.
  prefs: []
  type: TYPE_NORMAL
- en: Okay, now that we’ve seen the configuration files, let’s look at another way
    to customize a shell session.
  prefs: []
  type: TYPE_NORMAL
- en: Setting Shell Options from the Command-line
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In addition to using environmental variables to modify your shell session, you
    can also use **shell options**. You would use the `set` command to set shell options
    from either the command-line or from within your shell scripts. You can also use
    it from the command-line to just view the options that are set.
  prefs: []
  type: TYPE_NORMAL
- en: You can use either the Fedora or the Debian virtual machine for this section.
    With only one minor exception that concerns a man page, everything will be the
    same on both of them.
  prefs: []
  type: TYPE_NORMAL
- en: 'To begin, let’s invoke the `set` command without any options or arguments,
    like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: What you’ll see is a complete list of environmental variables and **shell functions**
    that are active for this shell session. (I’ll tell you more about shell functions
    in *Chapter 10, Understanding Functions*.)
  prefs: []
  type: TYPE_NORMAL
- en: 'Use the `set -o` command to just see the list of shell options that are active,
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: I won’t go over what each and every one of these options does, but I will tell
    you how to find out what they do. The only catch is that there’s a bit of a trick
    to it. That is, there’s no man page that’s specifically for the `set` command.
    When you do `man set` on your Fedora machine, you’ll actually pull up the `bash`
    man page. On Debian, you’ll have to do `man bash`, because `man set` won’t work
    at all. The reason for this is that the `set` command is built into the `bash`
    executable, and doesn’t have its own executable. Once you have the `bash` man
    page up, you’ll need to search through it to find the explanation of the `set`
    command and all of its options. For now, let’s look at a couple of the more useful
    options and how to set them.
  prefs: []
  type: TYPE_NORMAL
- en: 'In *Chapter 4, Understanding Input/Output Redirection*, I told you how the
    `noclobber` option can help prevent you from accidentally overwriting an important
    file. By default, `noclobber` is off, as you see here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'The way you turn options on and off is completely counterintuitive. You’ll
    use the `set -o` command to turn an option on and the `set +o` command to turn
    an option off, which is the exact opposite of what you’d think it would be. (I
    have no idea why someone decided to do things this way. But, whatever, right?)
    So, let’s say that we want to turn the `noclobber` option on. Here’s what that
    looks like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let’s turn it back off:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'For some options, such as `noclobber`, you can use a shorthand notation. So,
    to minimize keystrokes while turning `noclobber` on or off just do this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: In this example, the `-C` replaces `-o noclobber`, and `+C` replaces `+o noclobber`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another option that you might find useful is the `allexport` option. To see
    how you might use it, let’s set a programming variable from the command-line,
    and then try to use it in a child shell. Here’s what that looks like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'As you see, once I opened a child shell with the `bash` command, the value
    of `car` is no longer available to me. One way to fix that is to precede the variable
    definition with `export`, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'This time, the value of `car` is available to me in the child shell. The problem
    with this method is that I would have to remember to precede each variable definition
    I create with `export`. It would be easier just to set the `allexport` option
    so that every variable I create will be exported automatically. Here’s how that
    works:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'This time, the `car` variable got exported automatically so that its value
    is available in the child shell. When you’re done with `allexport`, you can turn
    it off, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'The `-a` shorthand notation is also available for `allexport`, which looks
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: And now, my shell option settings are back to their default values.
  prefs: []
  type: TYPE_NORMAL
- en: Keep in mind that any options that you set will return to normal when you exit
    from the shell session.
  prefs: []
  type: TYPE_NORMAL
- en: Okay, that does it for shell options, at least for now. In *Chapter 21, Debugging
    Shell Scripts*, I’ll show you a couple of more cool tricks that you can do with
    them. With all this out of the way, let’s move on to the final section of this
    chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding Aliases
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If you ever watch any crime dramas on television, you might see some criminal
    who uses more than one name. Of course, only one of those names is the criminal’s
    real name. All of the other names are fake names, or aliases, that the criminal
    uses to prevent being found by the police. In the world of operating system shells,
    **aliases** are quite useful and have nothing to do with criminal activity. In
    fact, you’re already using them without realizing it.
  prefs: []
  type: TYPE_NORMAL
- en: Think of an alias as a command that you can use in place of another command.
    For example, let’s say that you’re one of those poor souls who’s stuck using Windows
    most of the time, and who only occasionally gets the chance to work with Linux.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let’s say that every time you get on a Linux machine, you instinctively
    always type in Windows commands, as you’re doing here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Yeah, that `cls` command that you always use on Windows doesn’t work so well
    on Linux, does it? There’s an easy fix to that, though. Just create an alias that
    points to the `clear` command, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Once you do this, you’ll be able to clear the screen with either the `cls`
    command or the `clear` command. Note that in this case, I didn’t have to surround
    the alias definition with quotes because it doesn’t contain any blank spaces or
    special symbols. Creating an alias that has blank spaces or special characters
    in its definition would look something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![B21693_05_03](img/B21693_05_01.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 5.1: Using my new lla alias on Fedora'
  prefs: []
  type: TYPE_NORMAL
- en: Coolness, it works.
  prefs: []
  type: TYPE_NORMAL
- en: 'To see the list of all active aliases, just use the `alias` command without
    any options or arguments, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'As you see, they’re listed in alphabetical order. On Fedora, several aliases
    have already been globally-defined in a set of scripts in the `/etc/profile.d/`
    directory. For an example, let’s look in the `/etc/profile.d/colorls.sh` script.
    Most of the script is rather complex, consisting of commands that define the color
    scheme that will be used with the `ls` aliases. At the bottom, you’ll find the
    actual aliases, which look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we see that:'
  prefs: []
  type: TYPE_NORMAL
- en: The `ll` alias replaces the `ls -l --color=auto` command
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `l.` alias replaces the `ls -d .* --color=auto` command
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `ls` alias replaces the `ls --color=auto` command.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'To see how these aliases work, create a few files and directories in the home
    directory of your Fedora virtual machine, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'When you do a plain `ls` command, you’ll see that the plain text file shows
    up in either black or white letters, depending upon whether you’re using a black
    or a white background for your terminal. The directory shows up in blue letters,
    the graphic file shows up in magenta letters, and the executable script shows
    up in green letters. The `ll` alias performs the same function as the `ls -l`
    command, again with color coding, as you see here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B21693_05_02.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 5.2: Using the ll alias on Fedora'
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, the `l.` alias shows you the files and directories whose names begin
    with a dot, again with color coding. It looks something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![B21693_05_02](img/B21693_05_03.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 5.3: Using the l. alias on Fedora'
  prefs: []
  type: TYPE_NORMAL
- en: The Debian developers have done things differently. Instead of defining aliases
    at the global level, the Debian folk just define them at the user level. You’ll
    find the list of defined aliases in the `.bashrc` file that’s in every user’s
    home directory. Only one is enabled by default, but you can easily enable any
    or all of the others by removing the `#` symbol from in front of them.
  prefs: []
  type: TYPE_NORMAL
- en: 'On the Fedora machine, there’s a `which` alias that replaces the `which` command.
    This alias shows you not only where the executable file for a command is, it also
    shows you if there’s an alias for that command. Here’s what that looks like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'There’s no `which` alias on Debian, so you can’t use `which` to see if there
    are any aliases for other commands. Here’s what the Debian output looks like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'It’s important to note that if you have an alias that has the same name as
    the actual underlying command, the alias always takes precedence. There are two
    ways to override that so that you can directly invoke the executable file for
    a command. The first way is to just specify the entire path to that executable,
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'The second way is to precede the command with a backslash, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'You’ll now see the `ls` output without any color-coding. Let’s try it again
    with `which`, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'This time, `which` only shows the location of the executable file, and ignores
    the alias. If you need to disable an alias, use the `unalias` command, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: In this case, the alias is only disabled temporarily, until you close the shell
    session. If you use `unalias` for any aliases that you’ve created from the command-line,
    that alias will be disabled permanently.
  prefs: []
  type: TYPE_NORMAL
- en: The last thing I’ll say about aliases is that any alias you set at the command-line
    will disappear when you exit the shell session. To make them permanent on either
    Debian or Fedora, just place them in the `.bashrc` file that’s in your home directory.
  prefs: []
  type: TYPE_NORMAL
- en: All right, that pretty much wraps things up for this chapter. Let’s summarize
    and move on.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we’ve completed laying the groundwork for the chapters to come.
    We explained the different types of shell sessions, and then looked at the configuration
    files that affect the shell environment at both the global and user levels. Then,
    we looked at how to set shell options and how to create and use aliases.
  prefs: []
  type: TYPE_NORMAL
- en: Now that you know the basics of how a shell operates, you’re ready to tackle
    some meatier issues, like how to use text-stream filters. We’ll start with that
    in the next chapter. I’ll see you there.
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Which two of the following commands turn on the `noclobber` option? (Choose
    two.)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`set +o noclobber`'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '`set -o noclobber`'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '`set -C`'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '`set +C`'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: On a Fedora machine, which of the following user-level configuration files will
    only affect a login shell session?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`profile`'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '`.bash_profile`'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '`.bash.bashrc`'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: You’ve just opened a terminal emulator on your desktop Linux machine. What type
    of shell session are you using? (Choose two.)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: non-interactive
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: login
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: interactive
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: non-login
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Further Reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'How to List Environmental Variables on Linux: [https://www.howtogeek.com/842780/linux-list-environment-variables/](https://www.howtogeek.com/842780/linux-list-environment-variables/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Types of Linux Shell Sessions: [https://www.automationdojos.com/types-of-linux-shell-sessions/](https://www.automationdojos.com/types-of-linux-shell-sessions/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Linux set Command & How to Use it (9 examples): [https://phoenixnap.com/kb/linux-set](https://phoenixnap.com/kb/linux-set)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Answers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: b and c
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: c
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: c and d
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Join our community on Discord!
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Read this book alongside other users, Linux experts, and the author himself.
  prefs: []
  type: TYPE_NORMAL
- en: Ask questions, provide solutions to other readers, chat with the author via
    Ask Me Anything sessions, and much more. Scan the QR code or visit the link to
    join the community.
  prefs: []
  type: TYPE_NORMAL
- en: '[https://packt.link/SecNet](https://packt.link/SecNet)'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/QR_Code10596186092701843.png)'
  prefs: []
  type: TYPE_IMG
