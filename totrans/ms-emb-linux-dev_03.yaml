- en: '2'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Learning about Toolchains
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The toolchain is the first element of embedded Linux and the starting point
    of your project. You will use it to compile all the code that will run on your
    device. The choices you make at this early stage will have a profound impact on
    the final outcome.
  prefs: []
  type: TYPE_NORMAL
- en: Your toolchain should be capable of making effective use of your hardware by
    using the optimum instruction set for your processor. It should support the languages
    that you require and have a solid implementation of the **Portable Operating System
    Interface** (**POSIX**) and other system interfaces.
  prefs: []
  type: TYPE_NORMAL
- en: Your toolchain should remain constant throughout the project. In other words,
    once you have chosen your toolchain, it is important to stick with it. Changing
    compilers and development libraries inconsistently during a project will lead
    to subtle bugs. That being said, it is still best to update your toolchain when
    security flaws or bugs are found.
  prefs: []
  type: TYPE_NORMAL
- en: Obtaining a toolchain can be as simple as downloading and installing a TAR file
    or it can be as complex as building the whole thing from source code. In this
    chapter, we take the first approach. Later on, in [*Chapter 6*](Chapter_04.xhtml#_idTextAnchor110),we
    will switch to using the toolchain generated by the build system. This is the
    more usual means of obtaining a toolchain.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Introducing toolchains
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Finding a toolchain
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Anatomy of a toolchain
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Linking with libraries ‒ static and dynamic linking
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Art of cross-compiling
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: I recommend using Ubuntu 24.04 or a later LTS release since the exercises in
    this chapter were all tested against that Linux distro at the time of writing.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is the command to install all the packages required for this chapter on
    Ubuntu 24.04 LTS:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'The code used in this chapter can be found in the chapter folder in this book’s
    GitHub repository: [https://github.com/PacktPublishing/Mastering-Embedded-Linux-Development/tree/main/Chapter02](https://github.com/PacktPublishing/Mastering-Embedded-Linux-Development/tree/main/Chapter02).'
  prefs: []
  type: TYPE_NORMAL
- en: Introducing toolchains
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A toolchain is a set of tools that compiles source code into executables that
    can run on your target device. It includes a compiler, a linker, and runtime libraries.
    You need a toolchain to build the other three elements of an embedded Linux system:'
  prefs: []
  type: TYPE_NORMAL
- en: Bootloader
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Kernel
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Root filesystem
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It has to be able to compile code written in C, C++, and an assembly language
    since these are the languages used in the base open source packages.
  prefs: []
  type: TYPE_NORMAL
- en: Usually, toolchains for Linux are based on components from the GNU project and
    that is still true at the time of writing. However, over the past few years, the
    **Clang** compiler and the associated **Low-Level Virtual Machine** (**LLVM**)
    project have progressed to the point that LLVM is now a viable alternative to
    a GNU toolchain. One major distinction between LLVM and GNU-based toolchains is
    the licensing; LLVM has the Apache License v2.0 with LLVM Exceptions while GNU
    has the GPL.
  prefs: []
  type: TYPE_NORMAL
- en: There are some technical advantages to Clang as well, such as faster compilation,
    better diagnostics, and more support for the latest C and C++ standards. But **GCC**
    (**GNU C Compiler**) has the advantage of compatibility with the existing code
    base and support for a wider range of architectures and **Operating** **Systems**
    (**OS**). While it took some years to get there, Clang can now compile all the
    components needed for embedded Linux and is a viable alternative to GCC. To learn
    more, see [https://docs.kernel.org/kbuild/llvm.html](https://docs.kernel.org/kbuild/llvm.html).
  prefs: []
  type: TYPE_NORMAL
- en: There is a good description of how to use Clang for cross-compilation at [https://clang.llvm.org/docs/CrossCompilation.html](https://clang.llvm.org/docs/CrossCompilation.html).
    If you would like to use it as part of an embedded Linux build system, various
    people are working on using Clang with Buildroot and The Yocto Project. I will
    cover embedded build systems in [*Chapter 6*](Chapter_04.xhtml#_idTextAnchor110).
    Meanwhile, this chapter focuses on the GNU toolchain as it is still the most popular
    and mature toolchain for Linux.
  prefs: []
  type: TYPE_NORMAL
- en: 'A standard GNU toolchain consists of three main components:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Binutils**: A set of binary utilities including the assembler and the linker.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**GCC**: Compilers for C and other languages, which include C++, Objective-C,
    Objective-C++, Java, Fortran, Ada, Go, and D. They all use a common backend that
    produces assembler code that is fed to the GNU assembler.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**C library**: A standardized **Application Program Interface** (**API**) based
    on the POSIX specification, which is the main interface to the OS kernel for applications.
    There are several C libraries to consider, as we shall see later in this chapter.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Along with these, you will also need a copy of the Linux kernel headers. The
    kernel headers contain definitions and constants that are needed when accessing
    the kernel directly. You need the kernel headers to compile the C library, programs,
    and libraries. This **user space** code interacts indirectly with Linux devices,
    for example, to display graphics via the Linux frame buffer driver. This is in
    stark contrast to kernel modules/drivers inside **kernel space** with direct access
    to peripheral hardware.
  prefs: []
  type: TYPE_NORMAL
- en: This is not simply a question of making a copy of the header files in the include
    directory of your kernel source code. Those headers are intended for use in the
    kernel only and contain definitions that will cause conflicts if used in their
    raw state to compile regular Linux applications. Instead, you will need to generate
    a set of sanitized kernel headers, which I have illustrated in [*Chapter 5*](Chapter_05.xhtml#_idTextAnchor138).
  prefs: []
  type: TYPE_NORMAL
- en: When compiling for user space, the kernel headers do not need to be generated
    from the exact version of Linux you are going to be running on. Since the kernel
    interfaces are always backward compatible, it is only necessary that the headers
    are from a kernel that is the same as or older than the one you are using on the
    target.
  prefs: []
  type: TYPE_NORMAL
- en: Most people consider the **GNU Debugger** (**GDB**) to be part of the toolchain
    as well since it is also normally built at this point. When building a cross compiler,
    you also need to build a corresponding cross debugger to debug code on the target
    remotely from your host machine. I will talk about GDB in [*Chapter 19*](Chapter_19.xhtml#_idTextAnchor611).
  prefs: []
  type: TYPE_NORMAL
- en: Now that we’ve talked about kernel headers and seen what the components of a
    toolchain are, let’s look at the different types of toolchains.
  prefs: []
  type: TYPE_NORMAL
- en: Types of toolchains
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'For our purposes, there are two types of toolchains:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Native**: A toolchain that runs on the same type of system (or even the actual
    system) as the programs it generates. This is usually the case for desktops and
    servers, and it is becoming popular on certain classes of embedded devices. For
    example, the Raspberry Pi 4 running Debian for ARM has self-hosted native compilers.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Cross**: A toolchain that runs on a different type of system than the target
    allowing development to be done on a fast desktop PC and then loaded onto the
    embedded target for execution.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Almost all embedded Linux development is done using a cross-development toolchain.
    This is partly because most embedded devices are not well suited for development
    since they lack computing power, memory, and storage, but also because it keeps
    the host and target environments separate. The latter point is especially important
    when the host and the target are using the same architecture, x86_64, for example.
    In this case, it is tempting to compile natively on the host and simply copy the
    binaries to the target.
  prefs: []
  type: TYPE_NORMAL
- en: This works up to a point. However, it is likely that the host distribution will
    receive updates more often than the target or that different engineers building
    code for the target will have slightly different versions of the host development
    libraries. Over time, the development and target systems will diverge. You can
    upgrade the toolchain if you ensure that the host and the target build environments
    are in lockstep with each other. However, a much better approach is to keep the
    host and the target separate, and a cross toolchain is the way to do that.
  prefs: []
  type: TYPE_NORMAL
- en: There is a counterargument in favor of native development. Cross-development
    creates the burden of having to cross-compile all the libraries and tools that
    you need for your target. We will see later, in the section titled *Art of cross-compiling*,
    that cross-development is not always simple because many open source packages
    are not designed to be built in this way.
  prefs: []
  type: TYPE_NORMAL
- en: Integrated build tools like Buildroot and The Yocto Project help by encapsulating
    the rules for cross-compiling a range of packages needed by most embedded systems.
    But if you want to compile lots of additional packages, then it is better to compile
    them natively. For example, building a Debian distribution for the Raspberry Pi
    4 or BeaglePlay using a cross compiler is very hard. Instead, they are natively
    compiled.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a native build environment from scratch is not easy. You still need
    a cross compiler at first to create the native build environment on the target,
    which you then use to build the packages. Then, to perform the native build in
    a reasonable amount of time, you need a build farm of well-provisioned target
    boards or **Quick Emulator** (**QEMU**) to emulate the target.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will focus on a pre-built cross-compiler environment that
    is relatively easy to set up and administer. We will start by looking at what
    distinguishes one target CPU architecture from another.
  prefs: []
  type: TYPE_NORMAL
- en: CPU architectures
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The toolchain must be built according to the capabilities of the target CPU,
    which includes:'
  prefs: []
  type: TYPE_NORMAL
- en: '**CPU architecture**: ARM, RISC-V, PowerPC, **Microprocessor without Interlocked
    Pipelined Stages** (**MIPS**), or x86_64.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Big- or little-endian operation**: Some CPUs can operate in both modes, but
    the machine code is different for each.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Floating point support**: Not all versions of embedded processors implement
    a hardware floating point unit. In these cases, the toolchain must be configured
    to call a software floating point library instead.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Application Binary Interface (ABI)**: The calling convention used for passing
    parameters between function calls.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'With many architectures, the ABI is constant across the family of processors.
    One notable exception is ARM. The ARM architecture transitioned to the **Extended
    Application Binary Interface** (**EABI**) in the late 2000s resulting in the previous
    ABI being named the **Old Application Binary Interface** (**OABI**). While the
    OABI is now obsolete, you continue to see references to EABI. Since then, the
    EABI has split into three based on the way floating point parameters are passed:
    softfloat, softfp, and hardfp.'
  prefs: []
  type: TYPE_NORMAL
- en: The original EABI uses software emulation (softfloat) or general-purpose integer
    registers (softfp), while the newer **Extended Application Binary Interface Hard-Float**
    (**EABIHF**) uses floating point registers (hardfp). The original EABI’s softfloat
    and softfp modes are ABI-compatible. In **softfloat** mode, the compiler does
    not generate **Floating Point Unit** (**FPU**) instructions. All floating point
    operations are done in software, resulting in suboptimal performance. In **softfp**
    mode, float values are passed via the stack or integer registers for better performance.
    EABIHF is significantly faster at floating point operations since **hardfp** mode
    removes the need for copying between integer and floating point registers.
  prefs: []
  type: TYPE_NORMAL
- en: The downside of EABIHF is that hardfp mode is incompatible with CPUs that do
    not have a floating point unit. The choice then is between two incompatible ABIs.
    You cannot mix and match the two, so you must decide at this stage.
  prefs: []
  type: TYPE_NORMAL
- en: 'GNU adds a prefix to the name of each tool in the toolchain that identifies
    the various combinations that can be generated. This prefix consists of a tuple
    of three or four components separated by dashes, as described here:'
  prefs: []
  type: TYPE_NORMAL
- en: '**CPU**: The CPU architecture such as ARM, RISC-V, PowerPC, MIPS, or x86_64\.
    If the CPU has both endian modes, they may be differentiated by adding `el` for
    little-endian or `eb` for big-endian. Good examples are little-endian MIPS (`mipsel`)
    and big-endian ARM (`armeb`).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Vendor**: Identifies the provider of the toolchain. Examples include `buildroot`,
    `poky`, and just `unknown`. Sometimes, it is left out altogether.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**OS**: For our purposes, it is always `linux`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**User space**: A name for the user space component, which might be `gnu` or
    `musl`. The ABI may be appended here as well. So, for ARM toolchains, you may
    see `gnueabi`, `gnueabihf`, `musleabi`, or `musleabihf`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'You can find the tuple used when building the toolchain by using the `-dumpmachine`
    option of `gcc`. For example, you may see the following on the host computer:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: This tuple indicates a CPU of `x86_64`, a kernel of `linux`, and a user space
    of `gnu`.
  prefs: []
  type: TYPE_NORMAL
- en: '**IMPORTANT NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: When a native compiler is installed on a machine it is normal to create links
    to each of the tools in the toolchain with no prefixes so that you can call the
    C compiler with the `gcc` command.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is an example using a cross compiler:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: This tuple indicates a CPU of little-endian MIPS, an `unknown` vendor, a kernel
    of `linux`, and a user space of `gnu`. Your choice of user space (`gnu` or `musl`)
    determines which C library (glibc or musl) your programs are linked with.
  prefs: []
  type: TYPE_NORMAL
- en: Choosing the C library
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The programming interface to the Unix OS is defined in the C language in adherence
    to POSIX standards. The **C library** is the implementation of that interface.
    It is the gateway to the kernel for Linux programs. Even if you are writing programs
    in another language like Go or Python, the respective runtime support libraries
    will eventually have to call the C library, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.1 – C library](img/B18466_02_01.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2.1 – C library
  prefs: []
  type: TYPE_NORMAL
- en: Whenever the C library needs the services of the kernel, it will use the kernel
    system call interface to transition between user space and kernel space. It is
    possible to bypass the C library by making the kernel system calls directly but
    that is a lot of trouble and almost never necessary.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are several C libraries to choose from. The main options are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**glibc**: This is the standard GNU C library available at [https://gnu.org/software/libc/](https://gnu.org/software/libc/).
    It is big and, until recently, not very configurable, but it is the most complete
    implementation of the POSIX API. The license is LGPL 2.1.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**musl libc**: This is comparatively new but has been gaining a lot of attention
    as a small and standards-compliant alternative to glibc. It is a good choice for
    systems with a limited amount of RAM and storage. It has an MIT license and is
    available at [https://musl.libc.org](https://musl.libc.org).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**uClibc-ng**: *u* is really the Greek *mu* character, indicating that this
    is the microcontroller C library. uClibc-ng is available at [https://uclibc-ng.org](https://uclibc-ng.org).
    It was first developed to work with uClinux (Linux for microcontrollers without
    a memory management unit) but has since been adapted to be used with full Linux.
    The uClibc-ng library is a fork of the original uClibc project, which has fallen
    into disrepair. Both are licensed with LGPL 2.1.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'So, which to choose? My advice is to use uClibc-ng only if you are using uClinux.
    If you have a very limited amount of storage or RAM, then musl libc is a good
    choice. Otherwise, use glibc, as shown in this flow chart:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.2 – Choosing a C library](img/B18466_02_02.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2.2 – Choosing a C library
  prefs: []
  type: TYPE_NORMAL
- en: Your choice of C library could limit your choice of toolchain since not all
    pre-built toolchains support all C libraries. Once you know what you need in a
    toolchain, where do you find one?
  prefs: []
  type: TYPE_NORMAL
- en: Finding a toolchain
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'You have three choices for your cross-development toolchain: you may find a
    ready-built toolchain that matches your needs, you can use the one generated by
    an embedded build tool (which is covered in [*Chapter 6*](Chapter_04.xhtml#_idTextAnchor110)),
    or you can create one yourself.'
  prefs: []
  type: TYPE_NORMAL
- en: 'A pre-built cross toolchain is an attractive option in that you only have to
    download and install it. But you are limited to the configuration of that particular
    toolchain, and you are dependent on the person or organization you got it from.
    Most likely, it will be one of these:'
  prefs: []
  type: TYPE_NORMAL
- en: An SoC or board vendor. Most vendors offer a Linux toolchain.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A consortium dedicated to providing system-level support for a given architecture.
    For example, Linaro ([https://www.linaro.org](https://www.linaro.org)) has pre-built
    toolchains for the ARM architecture.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A third-party Linux tool vendor such as Siemens, Timesys, or Wind River.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The cross-tool packages for your desktop Linux distribution. For example, Debian-based
    distributions have packages for cross-compiling for ARM, PowerPC, and MIPS targets.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A binary SDK produced by one of the integrated embedded build tools. The Yocto
    Project has some available for download at [https://downloads.yoctoproject.org/releases/yocto/yocto-<version>/toolchain/](https://downloads.yoctoproject.org/releases/yocto/yocto-version/toolchain/).
    (replace `<version>` with a valid Yocto Project version such as `5.0` in the preceding
    URL).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A link from a forum that you can’t find anymore.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**IMPORTANT NOTE**'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: In all these cases, you must decide whether the pre-built toolchain on offer
    meets your requirements. Does it use the C library you prefer? Will the provider
    give you updates for security fixes and bugs? Bear in mind my comments on support
    and updates from [*Chapter 1*](Chapter_01.xhtml#_idTextAnchor016). If your answer
    is no to any of these, then you should consider creating your own.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Unfortunately, building a toolchain is no easy task. If you truly want to do
    the whole thing yourself, take a look at Cross Linux From Scratch ([https://trac.clfs.org](https://trac.clfs.org)).
    There, you will find step-by-step instructions on how to create each component.
  prefs: []
  type: TYPE_NORMAL
- en: A simpler alternative is to use crosstool-NG, which encapsulates the process
    into a set of scripts and has a menu-driven frontend. You still need a fair degree
    of knowledge though just to make the right choices.
  prefs: []
  type: TYPE_NORMAL
- en: It is simpler still to use a build system such as Buildroot or The Yocto Project
    since they generate a toolchain as part of the build process. This is my preferred
    solution, as we shall see in [*Chapter 6*](Chapter_04.xhtml#_idTextAnchor110).
  prefs: []
  type: TYPE_NORMAL
- en: You will need a working cross toolchain to complete the exercises in the next
    section. We will employ a pre-built toolchain from Bootlin. Bootlin’s toolchains
    are built using Buildroot.
  prefs: []
  type: TYPE_NORMAL
- en: 'To download the pre-built cross toolchain needed for *Chapters 2* through *5*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: To download the latest version of this toolchain, visit [https://toolchains.bootlin.com](https://toolchains.bootlin.com).
    Select *aarch64* for architecture and *glibc* for libc. Once these choices have
    been made, download the stable version of the toolchain.
  prefs: []
  type: TYPE_NORMAL
- en: 'Install the pre-built toolchain on your Linux host machine by extracting and
    decompressing it to your home directory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: You will use this toolchain for the remainder of this chapter. Let’s start by
    looking at its internals.
  prefs: []
  type: TYPE_NORMAL
- en: Anatomy of a toolchain
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To get an idea of what is in a typical toolchain, let’s examine the toolchain
    you downloaded from Bootlin. The examples use the aarch64 toolchain, which has
    the prefix `aarch64-buildroot-linux-gnu`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The aarch64 toolchain is in the directory `~/aarch64--glibc--stable-2024.02-1/bin`.
    In there, you will find the cross compiler `aarch64-buildroot-linux-gnu-gcc`.
    To make use of it, you need to add the directory to your path using the following
    command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: If you downloaded a different version, make sure to replace `2024.02-1` with
    the actual version of the stable toolchain.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now you can take a simple `helloworld` program, which, in the C language, looks
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'And compile it like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Confirm that it has been cross-compiled by using the `file` command to print
    the type of the file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Now that you’ve verified that your cross compiler works, let’s take a closer
    look at it.
  prefs: []
  type: TYPE_NORMAL
- en: Finding out about your cross compiler
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Imagine that you have just received a toolchain and that you would like to
    know more about how it was configured. You can find out a lot by querying `gcc`.
    For example, to find the version, you use `--version`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'To find how it was configured, use `-v`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'There is a lot of output there but the interesting things to note are:'
  prefs: []
  type: TYPE_NORMAL
- en: '`--with-sysroot`=`/builds/buildroot.org/toolchains-builder/build/aarch64--glibc--stable-2024.02-1/aarch64-buildroot-linux-gnu/sysroot`:
    The location of the `sysroot` directory at build time. See the following section
    for an explanation.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`--enable-languages=c,c++,fortran`: Both the C and C++ languages are enabled.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`--with-cpu=cortex-a53`: Generates code for an ARM Cortex-A53 core.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`--enable-threads`: Enables POSIX threads.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'These are the default settings for the compiler. You can override most of them
    on the `gcc` command line. For example, if you want to compile for a different
    CPU, you can override the configured setting `--with-cpu` by adding `-mcpu=cortex-a72`
    to the command line, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'You can print out the range of architecture-specific options available using
    `--target-help`, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: You may be wondering if it matters that you get the configuration exactly right
    at this point since you can always change it. The answer depends on the way you
    anticipate using it. If you plan to create a new toolchain for each target, then
    it makes sense to set everything up at the beginning because it will reduce the
    risks of getting it wrong later.
  prefs: []
  type: TYPE_NORMAL
- en: I call this the Buildroot philosophy, which we will revisit in [*Chapter 6*](Chapter_04.xhtml#_idTextAnchor110).
    If, on the other hand, you want to build a toolchain that is generic, and you
    are prepared to provide the correct settings when you build for a particular target,
    then you should make the base toolchain generic, which is the way The Yocto Project
    handles things.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we’ve seen the location of the `sysroot` directory at build time, let’s
    look inside the default `sysroot` directory installed on your host machine.
  prefs: []
  type: TYPE_NORMAL
- en: sysroot, library, and header files
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The toolchain `sysroot` directory contains subdirectories for libraries, header
    files, and other configuration files. It can be set when the toolchain is configured
    through `--with-sysroot=` or it can be set on the command line using `--sysroot=`.
    You can see the location of the default `sysroot` by using `-print-sysroot`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'You will find the following subdirectories in `sysroot`:'
  prefs: []
  type: TYPE_NORMAL
- en: '`lib`: Contains the shared objects for the C library and the dynamic linker/loader
    `ld-linux`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`usr/lib`: Contains the static library archive files for the C library and
    any other libraries that may be subsequently installed'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`usr/include`: Contains the headers for all the libraries'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`usr/bin`: Contains the utility programs that run on the target such as the
    `ldd` command'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`usr/share`: Used for localization and internationalization'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`sbin`: Provides the `ldconfig` utility that is used to optimize library loading
    paths'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Some of these are needed on the development host to compile programs and others,
    like the shared libraries and `ld-linux`, are needed on the target at runtime.
  prefs: []
  type: TYPE_NORMAL
- en: Other tools in the toolchain
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Below is a list of commands to invoke the various other components of a GNU
    toolchain. Like `aarch64-buildroot-linux-gnu-gcc`, these tools are all located
    inside the `~/aarch64--glibc--stable-2024.02-1/bin/` directory that you added
    to your `PATH`. Here are brief descriptions of these tools:'
  prefs: []
  type: TYPE_NORMAL
- en: '`addr2line`: Converts program addresses into source code filenames and line
    numbers by reading the debug symbol tables in an executable file. It is very useful
    when decoding addresses printed out in a system crash report.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ar`: An archive utility used to create static libraries.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`as`: GNU assembler.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`c++filt`: Demangles C++ and Java symbols.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`cpp`: C preprocessor used to expand `#define`, `#include`, and other similar
    directives. You seldom need to use this by itself.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`elfedit`: Updates the ELF header of the ELF files.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`g++`: GNU C++ frontend, which assumes that source files contain C++ code.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`gcc`: GNU C frontend, which assumes that source files contain C code.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`gcov`: Code coverage tool.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`gdb`: GNU debugger.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`gprof`: Program profiling tool.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ld`: GNU linker.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`nm`: Lists symbols from object files.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`objcopy`: Copies and translates object files.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`objdump`: Displays information from object files.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ranlib`: Creates or modifies an index in a static library making the linking
    stage faster.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`readelf`: Displays information about files in ELF object format.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`size`: Lists section sizes and the total size.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`strings`: Displays strings of printable characters in files.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`strip`: Strips an object file of debug symbol tables, making it smaller. Typically,
    you would strip all the executable code that is put onto the target.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We will now switch gears from command-line tools and return to the topic of
    the C library.
  prefs: []
  type: TYPE_NORMAL
- en: Looking at the components of the C library
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The C library is not a single library file. It is composed of four main parts
    that together implement the POSIX API:'
  prefs: []
  type: TYPE_NORMAL
- en: '`libc`: The main C library that contains the well-known POSIX functions such
    as `printf`, `open`, `close`, `read`, `write`, and so on'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`libm`: Contains math functions such as `cos`, `exp`, and `log`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`libpthread`: Contains all the POSIX thread functions with names beginning
    with `pthread_`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`librt`: Has real-time extensions to POSIX including shared memory and asynchronous
    I/O'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The first one, `libc`, is always linked in but the others must be explicitly
    linked with the `-l` option. The parameter to `-l` is the library name with `lib`
    stripped off. For example, a program that calculates a sine function by calling
    `sin()` would be linked with `libm` using `-lm`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'You can verify which libraries have been linked in this or any other program
    by using the `readelf` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Shared libraries need a runtime linker, which you can expose using:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'This is so useful that I have a script file named `list-libs`, which you will
    find in the book code archive in `MELD/list-libs`. It contains the following commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: There are other library files we can link to other than the four components
    of the C library. We will look at how to do that in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Linking with libraries – static and dynamic linking
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Any application you write for Linux, whether it be in C or C++, will be linked
    with the C library `libc`. This is so fundamental that you don’t even have to
    tell `gcc` or `g++` to do it because it always links `libc`. Other libraries that
    you may want to link with have to be explicitly named through the `-l` option.
  prefs: []
  type: TYPE_NORMAL
- en: 'Library code can be linked in two different ways:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Statically**: This means that all the library functions your application
    calls and their dependencies are pulled from the library archive and bound into
    your executable.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Dynamically**: This means that references to the library files and functions
    in those files are generated in the code but the actual linking is done dynamically
    at load time.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You will find the code for the examples that follow in the book code archive
    in `MELD/Chapter02/library`.
  prefs: []
  type: TYPE_NORMAL
- en: Static libraries
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Static linking is useful in a few circumstances. For example, if you are building
    a small system that consists of only BusyBox and some script files, it is simpler
    to link BusyBox statically and avoid having to copy the runtime library files
    and linker. The footprint will also be smaller because you only link in the code
    that your application uses rather than supplying the entire C library. Static
    linking is also useful if you need to run a program before the filesystem that
    holds the runtime libraries is available.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can link all the libraries statically by adding `-static` to the command
    line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'You will note that the size of the binary increases dramatically:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Static linking pulls code from a library archive usually named lib<name>.a.
    In the preceding case, it is libc.a, which is in <sysroot>/usr/lib:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Note that the syntax `export SYSROOT=$(aarch64-buildroot-linux-gnu-gcc -print-sysroot)`
    places the path to the `sysroot` in the shell variable `SYSROOT`, which makes
    the example a little clearer.
  prefs: []
  type: TYPE_NORMAL
- en: 'Creating a static library is as simple as creating an archive of object files
    using the `ar` command. If I have two source files named `test1.c` and `test2.c`
    (this exercise has no Git examples – you are expected to generate your own `test1.c`
    and `test2.c` files) and I want to create a static library named `libtest.a`,
    then I would do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'The book’s Git repository contains source and makefiles to assist with the
    linking exercises that follow:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Compile the static `libtest.a` library:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Compile `hello-arm.c` and link it with `libtest.a` to produce a hello-arm-static
    executable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Now let’s rebuild the same program using dynamic linking.
  prefs: []
  type: TYPE_NORMAL
- en: Shared libraries
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A more common way to deploy libraries is as shared objects that are linked at
    runtime, which makes more efficient use of storage and system memory since only
    one copy of the code needs to be loaded. It also makes it easy to update the library
    files without having to relink all the programs that use them.
  prefs: []
  type: TYPE_NORMAL
- en: 'The object code for a shared library must be position independent so that the
    runtime linker is free to locate it in memory at the next free address. To do
    this, add the `-fPIC` parameter to `gcc` and then link it using the `-shared`
    option:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: This creates the shared library `libtest.so`. To link an application with this
    library, you add `-ltest` just like you did for the static case, but this time,
    the code is not included in the executable. Instead, there is a reference to the
    library that the runtime linker will have to resolve.
  prefs: []
  type: TYPE_NORMAL
- en: 'Compile the shared `libtest.so` library:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Compile `hello-arm.c` and link it with `libtest.so` to produce a `hello-arm-shared`
    executable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'The runtime linker for this program is `/lib/ld-linux-aarch64.so.1`, which
    must be present in the target’s filesystem. The linker will look for `libtest.so`
    in the default search path: `/lib` and `/usr/lib`. If you want it to look for
    libraries in other directories as well, you can place a colon-separated list of
    paths in the shell variable `LD_LIBRARY_PATH`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: Because shared libraries are separate from executables, you need to ensure the
    correct versions of shared libraries are installed on the target so that you don’t
    encounter runtime errors.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding shared library version numbers
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'One of the benefits of shared libraries is that they can be updated independently
    of the programs that use them. Library updates are of two types:'
  prefs: []
  type: TYPE_NORMAL
- en: Those that fix bugs or add new functions in a backward-compatible way
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Those that break compatibility with existing applications
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: GNU/Linux has a versioning scheme to handle both these cases.
  prefs: []
  type: TYPE_NORMAL
- en: Each library has a release version and an interface number. The release version
    is simply a string that is appended to the library name. For example, the JPEG
    image library `libjpeg` is currently at release 8.2.2 and so the library is named
    `libjpeg.so.8.2.2`. There is a symbolic link named `libjpeg.so` to `libjpeg.so.8.2.2`
    so that when you compile a program with `-ljpeg`, you link with the current version.
    If you install version 8.2.3, the link is updated, and you will link with that
    one instead.
  prefs: []
  type: TYPE_NORMAL
- en: Now suppose that version 9.0.0 comes along and that breaks the backward compatibility.
    The link from `libjpeg.so` now points to `libjpeg.so.9.0.0` so that any new programs
    are linked with the new version. When the interface to `libjpeg` changes, the
    result is compilation errors that a developer can fix.
  prefs: []
  type: TYPE_NORMAL
- en: 'Any programs on the target that are not recompiled are going to fail in some
    way because they are still using the old interface. This is where an object known
    as the **soname** helps. The soname encodes the interface number from when the
    library was built and is used by the runtime linker when it loads the library.
    It is formatted as `<library name>.so.<interface number>`. For `libjpeg.so.8.2.2`,
    the soname is `libjpeg.so.8` because the interface number when that `libjpeg`
    shared library was built is 8:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: Any program compiled with it will request `libjpeg.so.8` at runtime, which will
    be a symbolic link on the target to `libjpeg.so.8.2.2`. When version 9.0.0 of
    `libjpeg` is installed, it will have a soname of `libjpeg.so.9` and so it is possible
    to have two incompatible versions of the same library installed on the same system.
    Programs that were linked with `libjpeg.so.8.*.*` will load `libjpeg.so.8` and
    those linked with `libjpeg.so.9.*.*` will load `libjpeg.so.9`.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is why, when you look at the directory listing of `/usr/lib/x86_64-linux-gnu/libjpeg*`,
    you find these four files:'
  prefs: []
  type: TYPE_NORMAL
- en: '`libjpeg.a`: The library archive used for static linking'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`libjpeg.so -> libjpeg.so.8.2.2`: A symbolic link used for dynamic linking'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`libjpeg.so.8 -> libjpeg.so.8.2.2`: A symbolic link used when loading the library
    at runtime'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`libjpeg.so.8.2.2`: The actual shared library used at both compile time and
    runtime'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The first two are only needed on the host computer for building and the last
    two are needed on the target at runtime.
  prefs: []
  type: TYPE_NORMAL
- en: While you can invoke the various GNU cross-compilation tools directly from the
    command line, this technique does not scale beyond toy examples like `helloworld`.
    To really be effective at cross-compiling, we need to combine a cross toolchain
    with a build system.
  prefs: []
  type: TYPE_NORMAL
- en: Art of cross-compiling
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Having a working cross toolchain is the starting point of a journey not the
    end of it. At some point, you will want to begin cross-compiling the various tools,
    applications, and libraries that you need for your target. Many of them will be
    open source packages, each of which has its own method of compiling and its own
    peculiarities.
  prefs: []
  type: TYPE_NORMAL
- en: 'Some common build systems include:'
  prefs: []
  type: TYPE_NORMAL
- en: Pure makefiles where the toolchain is usually controlled by the `make` variable
    `CROSS_COMPILE`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: GNU **Autotools** build system
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**CMake**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Both Autotools and makefiles are needed to build even a basic embedded Linux
    system. CMake is cross-platform and has seen increased adoption over the years,
    especially among the C++ community. In this section, we will cover all three build
    tools.
  prefs: []
  type: TYPE_NORMAL
- en: Simple makefiles
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Some important packages are very simple to cross-compile, including the Linux
    kernel, the U-Boot bootloader, and BusyBox. For each of these, you only need to
    put the toolchain prefix in the make variable `CROSS_COMPILE`, for example, `aarch64-buildroot-linux-gnu-`.
    Note the trailing hyphen.
  prefs: []
  type: TYPE_NORMAL
- en: 'To compile BusyBox, you type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'Or you can set it as a shell variable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: In the case of U-Boot and Linux, you also need to set the `make` variable `ARCH`
    to one of the machine architectures they support, which I will cover in *Chapters
    3* and *4*.
  prefs: []
  type: TYPE_NORMAL
- en: Both Autotools and CMake can generate makefiles. Autotools only generates makefiles,
    whereas CMake supports other ways of building projects depending on which platform(s)
    you are targeting (strictly Linux in our case). Let’s look at cross-compiling
    with Autotools first.
  prefs: []
  type: TYPE_NORMAL
- en: Autotools
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The name Autotools refers to a group of tools that are used as the build system
    in many open source projects. The components, together with the appropriate project
    pages, are:'
  prefs: []
  type: TYPE_NORMAL
- en: GNU autoconf ([https://www.gnu.org/software/autoconf/](https://www.gnu.org/software/autoconf/)
    )
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: GNU automake (https://www.gnu.org/software/automake/)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: GNU libtool ([https://www.gnu.org/software/libtool/)](https://www.gnu.org/software/libtool/))
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: gnulib ([https://www.gnu.org/software/gnulib/)](https://www.gnu.org/software/gnulib/))
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The role of Autotools is to smooth over the differences between the different
    types of systems that the package may be compiled for, accounting for different
    versions of compilers, different versions of libraries, different locations of
    header files, and dependencies with other packages.
  prefs: []
  type: TYPE_NORMAL
- en: Packages that use Autotools come with a script named `configure` that checks
    dependencies and generates makefiles according to what it finds. The `configure`
    script may also give you the opportunity to enable or disable certain features.
    You can find the options on offer by running `./configure --help`.
  prefs: []
  type: TYPE_NORMAL
- en: 'To configure, build, and install a package for the native OS, you would typically
    run the following three commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'Autotools can handle cross-development as well. You can influence the behavior
    of the configured script by setting these shell variables:'
  prefs: []
  type: TYPE_NORMAL
- en: '`CC`: C compiler command'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`CFLAGS`: Additional C compiler flags'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`CXX`: C++ compiler command'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`CXXFLAGS`: Additional C++ compiler flags'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`LDFLAGS`: Additional linker flags; for example, if you have libraries in a
    non-standard directory, `<lib dir>`, you would add it to the library search path
    by adding `-L<lib dir>`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`LIBS`: A list of additional libraries to pass to the linker; for instance,
    `-lm` for the math library'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`CPPFLAGS`: C/C++ preprocessor flags; for example, you would add `-I<include
    dir>` to search for headers in a non-standard directory, `<include dir>`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`CPP`: C preprocessor to use'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Sometimes, it is sufficient to set only the `CC` variable, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'Other times, that will result in an error like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: The reason for the failure is that `configure` often tries to discover the capabilities
    of the toolchain by compiling snippets of code and running them to see what happens,
    which cannot work if the program has been cross-compiled.
  prefs: []
  type: TYPE_NORMAL
- en: '**IMPORTANT NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: Pass `--host=<host>` to `configure` when you are cross-compiling so that `configure`
    searches your system for the cross-compiling toolchain targeting the specified
    `<host>` platform. That way, `configure` does not try to run snippets of non-native
    code as part of the configuration step.
  prefs: []
  type: TYPE_NORMAL
- en: 'Autotools understands three different types of machines that may be involved
    when compiling a package:'
  prefs: []
  type: TYPE_NORMAL
- en: '**build**: The computer that builds the package, which defaults to the current
    machine.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**host**: The computer the program will run on. For a native compile, this
    is left blank and defaults to the same computer as build. When you are cross-compiling,
    set it to be the tuple of your toolchain.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**target**: The computer the program will generate code for. You would set
    this when building a cross compiler.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'To cross-compile, you just need to override the host as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: One final thing to note is that the default install directory is `<sysroot>/usr/local`.
    You would usually install it in `<sysroot>/usr` so that the header files and libraries
    would be picked up from their default locations.
  prefs: []
  type: TYPE_NORMAL
- en: 'The complete command to configure a typical Autotools package is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: Let’s dive deeper into Autotools and use it to cross-compile a popular library.
  prefs: []
  type: TYPE_NORMAL
- en: 'An example: SQLite'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The SQLite library implements a simple relational database and is quite popular
    on embedded devices.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, begin by getting a copy of SQLite:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: Version 3.44.0 of SQLite may no longer be available. If so, then download a
    more up-to-date version of the source code from the SQLite Download page at [https://www.sqlite.org/download.html.](https://www.sqlite.org/download.html.)
    Modify the preceding `tar` and `cd` commands to match the filename of the new
    tarball.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, run the `configure` script:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'That seems to work! If it had failed, there would have been error messages
    printed to the terminal and recorded in `config.log`. Note that several makefiles
    have been created so now you can build it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, you install it into the toolchain directory by setting the make variable,
    `DESTDIR`. If you don’t, it will try to install it into the host computer’s `/usr`
    directory, which is not what you want:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: You may find that the final command fails with a file permissions error because
    the toolchain is installed in a system directory such as `/opt` or `/usr/local`.
    In that case, you will need root permissions when running the installation.
  prefs: []
  type: TYPE_NORMAL
- en: 'After installing, you should find that various files have been added to your
    toolchain:'
  prefs: []
  type: TYPE_NORMAL
- en: '`<sysroot>/usr/bin`: `sqlite3`: A command-line interface for SQLite that you
    can install and run on the target'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`<sysroot>/usr/lib`: `libsqlite3.so.0.8.6`, `libsqlite3.so.0`, `libsqlite3.so`,
    `libsqlite3.la`, `libsqlite3.a`: The shared and static libraries'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`<sysroot>/usr/lib/pkgconfig`: `sqlite3.pc`: The package configuration file,
    as described in the following section'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`<sysroot>/usr/include`: `sqlite3.h`, `sqlite3ext.h`: The header files'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`<sysroot>/usr/share/man/man1`: `sqlite3.1`: The manual page'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Now you can compile programs that use sqlite3 by adding `-lsqlite3` at the
    link stage:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: Here, `sqlite-test.c` is a hypothetical program that calls SQLite functions.
    Since `sqlite3` has been installed into the `sysroot`, the compiler will find
    the header and library files without any problem. If they had been installed elsewhere,
    you would have had to add `-L<lib dir>` and `-I<include dir>`.
  prefs: []
  type: TYPE_NORMAL
- en: Naturally, there will be runtime dependencies as well and you will have to install
    the appropriate files into the target directory, as described in [*Chapter 5*](Chapter_05.xhtml#_idTextAnchor138).
  prefs: []
  type: TYPE_NORMAL
- en: To cross-compile a library or package, you first need to cross-compile its dependencies.
    Autotools relies on a utility called `pkg-config` to gather vital information
    about packages cross-compiled by Autotools.
  prefs: []
  type: TYPE_NORMAL
- en: Package configuration
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Tracking package dependencies is quite complex. The package configuration utility
    `pkg-config` helps track which packages are installed and which compile flags
    each package needs by keeping a database of Autotools packages in `<sysroot>/usr/lib/pkgconfig`.
    For instance, the one for SQLite3 is named `sqlite3.pc` and contains essential
    information needed by other packages that depend on it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'You can use `pkg-config` to extract information in a form that you can feed
    straight to `gcc`. In the case of a library like `libsqlite3`, you want to know
    the library name (`--libs`) and any special C flags `(--cflags`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'Oops! That failed because it was looking in the host’s `sysroot`, and the development
    package for `libsqlite3` has not been installed on the host. You need to point
    it at the `sysroot` of the target toolchain by setting the shell variable `PKG_CONFIG_LIBDIR`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'Now the output is `-lsqlite3`. In this case, you knew that already, but generally,
    you wouldn’t, so this is a valuable technique. The final commands to compile are:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: Many `configure` scripts read the information generated by `pkg-config`. This
    can lead to errors when cross-compiling, as we shall see next.
  prefs: []
  type: TYPE_NORMAL
- en: Problems with cross-compiling
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`sqlite3` is a well-behaved package that cross-compiles nicely, but not all
    packages are the same. Typical pain points include:'
  prefs: []
  type: TYPE_NORMAL
- en: Home-grown build systems for libraries like `zlib` that have a `configure` script
    that does not behave like the Autotools `configure` described in the previous
    section
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`configure` scripts that read `pkg-config` information, headers, and other
    files from the host disregarding the `--host` override'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Scripts that insist on trying to run cross-compiled code
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Each case requires careful analysis of the error. We can either pass additional
    parameters to the `configure` script to provide the correct information or apply
    patches to the code to avoid the problem altogether. Bear in mind that a single
    package can have many dependencies. This is especially true for programs that
    have a graphical interface or that handle multimedia content. As an example, MPlayer
    has dependencies on over 100 libraries. It would take weeks of effort to build
    them all.
  prefs: []
  type: TYPE_NORMAL
- en: Therefore, I would not recommend manually cross-compiling components for the
    target in this way, except when there is no alternative or the number of packages
    to build is small.
  prefs: []
  type: TYPE_NORMAL
- en: A much better approach is to use a build tool such as Buildroot or The Yocto
    Project or avoid the problem altogether by setting up a native build environment
    for your target architecture. Now you can see why distributions like Debian are
    always compiled natively.
  prefs: []
  type: TYPE_NORMAL
- en: CMake
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: CMake is more of a meta build system in the sense that it relies on an underlying
    platform’s native tools to build software. On Windows, CMake can generate project
    files for Microsoft Visual Studio, and on macOS, it can generate project files
    for Xcode. Integrating with the principal IDEs for each of the major platforms
    is no simple task and explains the success of CMake as the leading cross-platform
    build system solution. CMake also runs on Linux where it can be used in conjunction
    with a cross-compiling toolchain of your choice.
  prefs: []
  type: TYPE_NORMAL
- en: 'To configure, build, and install a package for a native Linux OS, run the following
    commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: On Linux, the native build tool is GNU `make` so CMake generates makefiles by
    default for us to build with. Often, we want to perform out-of-source builds so
    that object files and other build artifacts remain separate from source files.
  prefs: []
  type: TYPE_NORMAL
- en: 'To configure an out-of-source build in a subdirectory named `build`, run the
    following commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: This will generate the makefiles inside a `build` subdirectory within the project
    directory where the `CMakeLists.txt` is located. The `CMakeLists.txt` file is
    the CMake equivalent of the `configure` script for Autotools-based projects.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can then build the project out of source from inside the `build` directory
    and install the package just as before:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: CMake uses absolute paths so the `build` subdirectory cannot be copied or moved
    once the makefiles have been generated or any subsequent `make` step will likely
    fail. Note that CMake defaults to installing packages into system directories
    like `/usr/bin`, even for out-of-source builds.
  prefs: []
  type: TYPE_NORMAL
- en: 'To generate the makefiles so that CMake installs the package in the `build`
    subdirectory, replace the previous `cmake` command with the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: We no longer need to preface `make install` with `sudo` because we do not need
    elevated permissions to copy the package files into the `build` directory.
  prefs: []
  type: TYPE_NORMAL
- en: 'Similarly, we can use another CMake command-line option to generate makefiles
    for cross-compilation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: But the best practice for cross-compiling with CMake is to create a toolchain
    file that sets `CMAKE_C_COMPILER` and `CMAKE_CXX_COMPILER` in addition to other
    relevant variables for targeting embedded Linux.
  prefs: []
  type: TYPE_NORMAL
- en: CMake works best when we design our software in a modular way by enforcing well-defined
    API boundaries between libraries and components.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are some key terms that come up time and time again in CMake:'
  prefs: []
  type: TYPE_NORMAL
- en: '`target`: A software component such as a library or executable.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`properties`: The source files, compiler options, and linked libraries needed
    to build a target.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`package`: A CMake file that configures an external target for building just
    as if it was defined within your `CMakeLists.txt` itself.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'For example, if we had a CMake-based executable named `dummy` that needed to
    take a dependency on SQLite, we could define the following `CMakeLists.txt`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: The `find_package` command searches for a package (SQLite3, in this case) and
    imports it so that the external target can be added as a dependency to the `dummy`
    executable’s list of `target_link_libraries` for linking.
  prefs: []
  type: TYPE_NORMAL
- en: CMake comes with numerous finders for popular C and C++ packages, including
    OpenSSL, Boost, and protobuf, making native development much more productive than
    if we were to use just pure makefiles.
  prefs: []
  type: TYPE_NORMAL
- en: The `PRIVATE` qualifier prevents details like headers and flags from leaking
    outside of the `dummy` target. Using `PRIVATE` makes more sense when the target
    being built is a library instead of an executable. Think of targets as modules
    and attempt to minimize their exposed surface areas when using CMake to define
    your own targets. Only employ the `PUBLIC` qualifier when absolutely necessary
    and utilize the `INTERFACE` qualifier for header-only libraries.
  prefs: []
  type: TYPE_NORMAL
- en: Model your application as a dependency graph with edges between targets. This
    graph should not only include the libraries that your application links to directly
    but any transitive dependencies as well. For best results, remove any cycles or
    other unnecessary independencies seen in the graph. It is often best to perform
    this exercise before you start coding. A little planning can make the difference
    between a clean, easily maintainable `CMakeLists.txt` and an inscrutable mess
    that nobody wants to touch.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The toolchain is always your starting point. Everything that follows from that
    is dependent on having a working, reliable toolchain.
  prefs: []
  type: TYPE_NORMAL
- en: You may start with nothing but a toolchain downloaded from Bootlin or Linaro
    and use it to compile all the packages that you need on your target. Or you may
    obtain the toolchain as part of a distribution generated from source code using
    a build system such as Buildroot or The Yocto Project.
  prefs: []
  type: TYPE_NORMAL
- en: Beware of toolchains or distributions that are offered to you for free as part
    of a hardware package. They are often poorly configured and not maintained.
  prefs: []
  type: TYPE_NORMAL
- en: Once you have a toolchain, you can use it to build the other components of your
    embedded Linux system. In the next chapter, you will learn about the bootloader,
    which brings your device to life and begins the boot process. We will use the
    toolchain we built in this chapter to build a working bootloader for the BeaglePlay.
  prefs: []
  type: TYPE_NORMAL
- en: Further study
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '*Toolchain Options in 2023: What’s new in compilers and libcs?* by Bernhard
    “Bero” Rosenkränzer – [https://www.youtube.com/watch?v=Vgm3GJ2ItDA](https://www.youtube.com/watch?v=Vgm3GJ2ItDA)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Modern CMake for modular design*, by Mathieu Ropert – [https://www.youtube.com/watch?v=eC9-iRN2b04](https://www.youtube.com/watch?v=eC9-iRN2b04)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
