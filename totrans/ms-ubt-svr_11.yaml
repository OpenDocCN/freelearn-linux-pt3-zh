- en: '11'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Setting Up Network Services
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In *Chapter 10*, *Connecting to Networks*, we went over some important foundational
    topics related to networking. We saw how to set the hostname, manage network interfaces,
    configure connections, and more. In this chapter, we’ll revisit networking, specifically
    to set up the resources that will serve as the foundation of our network. The
    majority of this chapter will focus on setting up the DHCP and DNS servers, which
    are very important components of any network. In addition, we’ll even take a look
    at setting up a server to act as an internet gateway for the rest of our network.
  prefs: []
  type: TYPE_NORMAL
- en: 'Along the way, we’ll cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Planning your IP address scheme
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Serving IP addresses with `isc-dhcp-server`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Setting up DNS with `bind`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Setting up an internet gateway
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As a Linux administrator, you may or may not be tasked with designing the entire
    network layout of your organization; often there will be an already-existing network
    to manage. In the next section, we’ll discuss creating such a layout, even if
    only to understand what goes into such a plan.
  prefs: []
  type: TYPE_NORMAL
- en: Planning your IP address scheme
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Designing the overall layout of your network is an incredibly important process
    that sets the stage for success or failure later on. This design must take into
    consideration the needs of the organization, the need for efficient methods of
    communication, and the segregation of network services to ensure that your servers
    can only communicate with the resources that they are supposed to. As a Linux
    administrator that manages a fleet of Ubuntu servers, it’s not always the case
    that you’ll even have a say in the network layout at all. It’s quite common that
    you “inherit” a network designed by a previous administrator, or your job is siloed
    such that you only manage the servers and someone else is responsible for the
    network.
  prefs: []
  type: TYPE_NORMAL
- en: Since this is primarily a book that focuses on teaching you how to manage Ubuntu
    servers, we aren’t going to cover all of the things that a network administrator
    would need to know, but there’s a bit of overlap between the two roles. As a Linux
    administrator, you may or may not be tasked with the designing of your network,
    but at a minimum, you do need to understand the overall layout and how your servers
    will fit within it.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we’ll discuss the most important part of a network layout—the
    IP address scheme. Planning the IP scheme is an important task that sets the foundation
    for many other things. Even if it’s not up to you to design this layout, knowing
    the finer details of an existing layout can help you better understand how servers
    you maintain might communicate with other devices. Planning your IP layout involves
    estimating how many devices will need to connect to your network and being able
    to support them. In addition, a good plan will account for potential growth and
    allow expansion as well. The main thing that factors into this is the size of
    your user base. Perhaps you are working in a small office with only a handful
    of people, or a large corporation with thousands of users and hundreds of virtual
    machines. Even if your organization is only a small office, I always recommend
    making the assumption that your company will explode in popularity someday and
    designing your network to have the growth potential to accommodate that.
  prefs: []
  type: TYPE_NORMAL
- en: Typically, most off-the-shelf routers and network equipment come with an integrated
    **Dynamic Host Control Protocol** (**DHCP**) server, with a default class C (`/24`)
    network. Essentially, this means that if you do not perform any configuration
    at all, you’re limited to 254 addresses. For a small office, this may seem like
    plenty. After all, if you don’t even have 254 employees at your company, that
    number may seem like overkill. As I mentioned before, potential growth is always
    something to keep in mind. But even if we remove that from the equation, IP addresses
    are used up quicker than you’d think nowadays—even when it comes to internal addressing.
    Average users may consume three IP addresses each, and sometimes more.
  prefs: []
  type: TYPE_NORMAL
- en: For example, perhaps a user not only has a laptop (which itself can have both
    a wired and wireless interface, both consuming an IP address), but perhaps they
    also have a mobile phone (which likely features Wi-Fi), and a **Voice over IP**
    (**VoIP**) phone (there goes another address). If that user somehow manages to
    convince their supervisor that they also need a desktop computer as well as their
    laptop, there will be a total of five IP addresses for that one user. Suddenly,
    254 addresses don’t seem like all that many.
  prefs: []
  type: TYPE_NORMAL
- en: Perhaps a really good real-world example of the number of available IP addresses
    potentially being a problem is a small restaurant in a busy city that offers free
    Wi-Fi to its customers. The person designing the guest network for their customers
    may assume that a `/24` network is more than enough if they only have one hundred
    customers or so each day. While that logic may seem sound, consider that if the
    restaurant is next to a busy street, people that have Wi-Fi enabled on their phone
    may snag an address as they pass by, and if the DHCP addresses are configured
    to expire in 24 hours, then there will often be no available IP addresses for
    actual customers most of the time. If you’ve ever attempted to connect to a restaurant
    Wi-Fi network and found yourself unable to access the internet after connecting,
    this could be a real-world example of a pain point of not designing a network
    layout effectively.
  prefs: []
  type: TYPE_NORMAL
- en: The obvious answer to this problem is splitting up your network into **subnets**.
    Although I won’t go into the details of how to subnet your network (which would
    be beyond the scope of this book), I mention it here because it’s definitely something
    you should take into consideration. In the next section, I’ll explain how to set
    up your own DHCP server with a single network. However, if you need to expand
    your address space, you can easily do so by updating your DHCP configuration.
    When coming up with an IP address layout, always assume the worst and plan ahead.
    While it may be a simple task to expand your DHCP server, planning a new IP scheme
    rollout is very time-consuming, and to be honest, annoying.
  prefs: []
  type: TYPE_NORMAL
- en: 'When I set up a new network, I like to divide the address space into several
    categories. First, I’ll usually set aside a group of IP addresses specifically
    for DHCP. These addresses will get assigned to clients as they connect, and I’ll
    usually have them expire and need to be renewed in about one day. Then, I’ll set
    aside a block of IP addresses for network appliances, another block for servers,
    and so on. In the case of a typical `/24`, I might decide on a scheme such as
    the following (assuming it’s a small office with no growth planned):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Since I mentioned it’s a good idea to plan for future growth, the `/24` would
    be potentially constrained and wouldn’t accommodate much growth. I chose that
    scheme to keep everything in this chapter simple for the sake of easy explanation.
    But in a real company network, you may want to consider a larger number of IP
    addresses than what the above would give you.
  prefs: []
  type: TYPE_NORMAL
- en: How do you get more IP addresses? Take a look at the number after the network
    address, which is `/24` on the first line. With that number, we’re configuring
    how large the IP address space is, which essentially correlates to how many IP
    addresses we have available. That number is known as a **CIDR** notation, which
    stands for **Classless Inter-Domain Routing**. Similar to a subnet mask, changing
    that number results in a different number of IP addresses. For example, if you
    change the `/24` portion of the network to `/22`, you instantly have 1,022 possible
    addresses to work with, rather than 254\. If you lower it again to `/20`, the
    number jumps to 4,094\. For now, don’t worry too much about this. You can focus
    on remembering that the higher the number, the fewer IP addresses you have. It
    can go up to `/32`, which only gives you one IP address. If you’d like to experiment
    further with subnetting, we’ve provided a subnet calculator in the *Further reading*
    section.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is a list of common CIDR values and their impact on the number
    of available IP addresses:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **CIDR** | **Total Usable IP Addresses** |'
  prefs: []
  type: TYPE_TB
- en: '| `/32` | `1` |'
  prefs: []
  type: TYPE_TB
- en: '| `/24` | `254` |'
  prefs: []
  type: TYPE_TB
- en: '| `/16` | `65,534` |'
  prefs: []
  type: TYPE_TB
- en: '| `/8` | `16,777,214` |'
  prefs: []
  type: TYPE_TB
- en: Of course, no single IP address scheme is right for everyone. The scheme I provided
    earlier is simply a hypothetical example, so you shouldn’t copy mine and use it
    on your network unless it matches your needs. I’ll use this scheme for the remainder
    of this chapter, since it works fine as an example. To explain my sample rollout,
    we start off with a 24-bit network, `192.168.1.0/24`. The address `192.168.1.0`
    refers to the network itself, and that IP address is not assignable to clients.
    The first usable IP address in this subnet will be `192.168.1.1`. The last IP
    address in this block (`192.168.1.255`) is not assignable either, since that is
    known as the **broadcast address**. Anything that’s sent to the broadcast address
    is effectively sent to every IP in the block, so we can’t really use it for anything
    but broadcasts. In summary, keep in mind that an IP address ending in `.0` can’t
    be used, and neither can an IP address that ends in `.255`.
  prefs: []
  type: TYPE_NORMAL
- en: Technically, you *can* assign IP addresses ending in `.0` or `.255`, depending
    on the CIDR value. However, since those ending values are most often used to refer
    to the network itself and the broadcast address respectively, some applications
    and pieces of hardware may not accept these values so for all intents and purposes,
    you should consider those ending values as unassignable.
  prefs: []
  type: TYPE_NORMAL
- en: Going back to the example IP layout mentioned earlier in this section, I set
    aside a group of IP addresses starting with `192.168.1.1` through `192.168.1.10`
    for use by network appliances. Typical devices that would fit into this category
    would be managed switches, routers, wireless access points, and so on. These devices
    typically have an integrated web console for remote management, so it would be
    best to have a static IP address assignment. That way, I’ll have an IP address
    available that I can use to access these devices. I like to set up network appliances
    as the first devices so that they all get the lowest numbers when it comes to
    the last number of each IP address. This is just personal preference.
  prefs: []
  type: TYPE_NORMAL
- en: Next in the example layout, we define IP addresses `192.168.1.11` through `192.168.1.99`
    for servers. This may seem like quite a few addresses for servers, and it is.
    However, with the rise of virtualization and how simple it has become to spin
    up a server, this block could get used up faster than you’d think. Feel free to
    adjust accordingly.
  prefs: []
  type: TYPE_NORMAL
- en: Now we have our DHCP pool, which consists of addresses `192.168.1.101` through
    `192.168.1.240`. These IP addresses are assignable to any devices that connect
    to our network. Typically, I like to have these assignments expire in one day
    to prevent one-off devices from claiming and holding onto an IP address for too
    long, which can lead to devices fighting over a DHCP lease. In this situation,
    you’d have to clear your DHCP leases to reset everything, and I find that to be
    too much of a hassle. When we get to the section on setting up a DHCP server,
    I’ll show you how to set the expiration time.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we have addresses `192.168.1.241` through `192.168.1.254` for the purposes
    of DHCP reservations. I generally refer to reserved DHCP addresses as *static
    leases*, but both terms mean the same thing. These addresses will be assigned
    by DHCP, but each device with a static lease will be given the same IP address
    each time. You don’t have to separate these into their own pool, since DHCP will
    not assign the same address twice. It may still be a good idea to separate them
    though, if only to be able to tell from looking at an IP address that it’s a static
    lease, due to it being within a particular hypothetical block. Static leases are
    good for devices that aren’t necessarily a server but still need a predictable
    IP address.
  prefs: []
  type: TYPE_NORMAL
- en: An example of this may be an administrator’s desktop PC. Perhaps they want to
    be able to connect to the office via VPN and be able to easily find their computer
    on the network and connect to it. If the IP was dynamically assigned instead of
    statically assigned, it would be harder for them to find it.
  prefs: []
  type: TYPE_NORMAL
- en: After you carve up your IP addresses, the next thing is to make sure that they’re
    accurately documented. If you don’t focus on documentation now while designing
    services, you will definitely regret it later. You can consider setting up a private
    wiki server, for example.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another method is creating a spreadsheet to keep track of your static IP assignments.
    This is acceptable if you don’t have a better solution; it doesn’t have to be
    anything fancy. Among the usual components, such as the device info and IP address,
    I also include the MAC address of each device on the spreadsheet, which will come
    in handy when we set up our DHCP server in the next section:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Table  Description automatically generated](img/B18425_11_01.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 11.1: An example IP address layout spreadsheet'
  prefs: []
  type: TYPE_NORMAL
- en: As you can see from my example layout, our number of available addresses is
    rather limited with a 24-bit network. However, this layout will serve as an example
    we can follow that’s good enough for the remainder of the chapter. At this point,
    just think about the factors that are important to your organization, and ensure
    that any networks you create are scalable and accommodate your needs.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have an IP layout (if we didn’t have one already), we can take a
    look at setting up a DHCP server, which will be the service that will ultimately
    be assigning these IPs.
  prefs: []
  type: TYPE_NORMAL
- en: Setting up a DHCP server for serving IP addresses
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Most network appliances you purchase nowadays often come with their own DHCP
    server and allow you to configure it via a web console. Often, this is totally
    fine and meets your needs. In my experience though, network appliances you purchase
    can be very hit and miss. Some of them are great, while others are not so impressive.
    One of the main problems is that manufacturers will often stop supporting the
    hardware prematurely, exposing your network to unpatched vulnerabilities. It’s
    important to always purchase network hardware that’s as future-proof as possible.
    Or, you can set up your own router with the features that you need. Although the
    burden of management is placed on you, this gives you ultimate flexibility. Ubuntu
    servers make great DHCP servers, and rolling your own server is actually easier
    than it sounds. And that’s exactly what we’re going to work through in this section.
  prefs: []
  type: TYPE_NORMAL
- en: First, the server that serves DHCP will definitely need a static IP address.
    This means you’ll need to configure Netplan with a static IP assignment. A static
    lease won’t work here, since the DHCP server can’t assign an IP address to itself.
  prefs: []
  type: TYPE_NORMAL
- en: Also, the IP address that you designate for your server’s static IP must be
    in the same network as the addresses that you plan to serve. Otherwise, the service
    will fail to start even after we configure it.
  prefs: []
  type: TYPE_NORMAL
- en: If you have yet to set a static IP address, *Chapter 10*, *Connecting to Networks*,
    has a section that will walk you through the process.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once you assign a static IP address, the next step is to install the `isc-dhcp-server`
    package:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Check the status of the daemon after installing the `isc-dhcp-server` package,
    using the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'You’ll likely notice that it failed:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B18425_11_02.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 11.2: isc-dhcp-server failing by default'
  prefs: []
  type: TYPE_NORMAL
- en: If it did fail to start, there’s no need to be concerned. Ubuntu, by default,
    starts most of the services that are installed via packages. Sometimes, a service
    needs to be configured before it can run. In the case of the `isc-dhcp-server`,
    it needs a valid configuration in order to start, but we have yet to configure
    anything. We need to configure the `isc-dhcp-server` service for it to be useful,
    so let’s stop the service for now.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can start it as soon as we’ve finished adding our configuration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Configuring an IPv6 network isn’t something we’ll be getting into, but the
    DHCP server package we’ve just installed also comes with an IPv6 equivalent. Let’s
    stop and disable this service, since we won’t be using it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that you’ve installed the `isc-dhcp-server` package, you’ll have a default
    configuration file for it at `/etc/dhcp/dhcpd.conf`. This file will contain some
    default configuration, with some example settings that are commented out. Feel
    free to take a look at this file to get an idea of some of the settings you can
    configure. We’ll create our own `dhcpd.conf` file from scratch. So when you’re
    done looking at it, move the existing file with a new name so we can refer to
    it later if we ever need to:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we’re ready to create our own `dhcpd.conf` file. Open `/etc/dhcp/dhcpd.conf`
    in your preferred text editor. Since the file no longer exists (we moved it),
    we should start with an empty file. Here’s an example `dhcpd.conf` file that I
    will explain so that you understand how it works:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: As always, change the values I’ve used to those that match your network. I’ll
    explain each line so that you’ll understand how it affects the configuration of
    your DHCP server.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: When a device connects to your network and requests an IP address, the expiration
    of the lease will be set to the number of seconds in `default-lease-time` if the
    device doesn’t explicitly ask for a longer lease time. Here, I’m setting that
    to `43200` seconds, which is equivalent to half a day. This basically means that
    the device will need to renew its IP address every `43200` seconds unless it asks
    for a longer duration.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: While the previous setting dictated the default lease time for devices that
    don’t ask for a specific lease time, `max-lease-time` is the most that the device
    is allowed to have. In this case, I set this to one day (`86400` seconds). Therefore,
    no device that receives an IP address from this DHCP server is allowed to hold
    onto its lease for longer than this without first renewing it.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: With this setting, we’re informing clients that their subnet mask should be
    set to `255.255.255.0`, which is for a default 24-bit network. If you plan to
    subnet your network, you’ll put in a different value here. `255.255.255.0` is
    fine if all you need is a 24-bit network.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: With this setting, we’re telling the client to use `192.168.1.255` as the broadcast
    address, which is the last address in the subnet and cannot be assigned to a host.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Here, we’re setting the domain names of all hosts that connect to the server
    to include `local.lan`. The domain name is added to the end of the hostname. For
    example, if a workstation with a hostname of `muffin` receives an IP address from
    our DHCP server, it will be referred to as `muffin.local.lan`. Feel free to change
    this to the domain name of your organization, or you can leave it as is if you
    don’t have one.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: With the `authoritative` setting (the opposite is `not authoritative`), we’re
    declaring our DHCP server as authoritative to our network. Unless you are planning
    to have multiple DHCP servers, the `authoritative;` option should be included
    in your `config` file. We won’t use the `not authoritative;` option as it’s beyond
    the scope of this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we get to the most important part of our configuration file for DHCP.
    The following block details the specific information that will be provided to
    clients:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: This block is probably self-explanatory, but we’re basically declaring our pool
    of addresses for the `192.168.1.0` network. We’re declaring a range of IPs from
    `192.168.1.100` through `192.168.1.240` to be available for clients. Now when
    our DHCP server provides an address to clients, it will choose one from this pool.
    For the address pool (`range`), feel free to expand it or shrink it accordingly.
    For example, you might need more addresses than the 140 that are allowed in my
    sample range, so you may change it to something like `192.168.1.50` through `192.168.1.250`.
    Feel free to experiment.
  prefs: []
  type: TYPE_NORMAL
- en: We’re also providing a default gateway (`option routers`) and DNS server (`option
    domain-name-servers`) of `192.168.1.1`. This is assuming that your router and
    local DNS server are both listed at that address, so make sure that you change
    it accordingly. Otherwise, anyone who receives a DHCP lease from your server will
    not be able to connect to anything.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we have our configuration file in place, but the DHCP server will likely
    still not start until we declare an interface for it to listen for requests on.
    You can do that by editing the `/etc/default/isc-dhcp-server` file, where you’ll
    see a line toward the bottom similar to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Simply type the name of the interface within the quotes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: In case you forgot, the command to list the details of the interfaces on your
    server is `ip addr show`, or the shortened version, `ip a`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have our DHCP server configured, we should be able to start it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, double-check that there were no errors by running the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'The daemon should report that it’s `active (running)`, similar to what’s shown
    in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B18425_11_03.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 11.3: Checking the status of the isc-dhcp-server process after a successful
    start'
  prefs: []
  type: TYPE_NORMAL
- en: 'Assuming all went well, your DHCP server should be running. When an IP lease
    is assigned to a client, it will be recorded in the `/var/lib/dhcp/dhcpd.leases`
    file. While your DHCP server runs, it will also record information to your server’s
    system log, located at `/var/log/syslog`. To see your DHCP server function in
    all its glory, you can follow the log as it gets written to with the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: We’ve discussed the `-f` flag of the `tail` command earlier in the book. This
    option is indispensable, and it’s something you’ll likely use quite often as a
    server administrator. With the `-f` option, you’ll watch the log as it gets written
    to, rather than needing to refresh it manually. You can press *Ctrl + c* to break
    out of the file.
  prefs: []
  type: TYPE_NORMAL
- en: 'While your DHCP server runs, you’ll see notices appear within the `syslog`
    file whenever a DHCP request was received and when a lease is offered to a client.
    A typical DHCP request will appear in the log similar to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Active and previous DHCP leases are stored in the `/var/lib/dhcp/dhcpd.leases`
    file, and a typical lease entry in that file would look similar to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: When a new device is added to your network and receives an IP address from your
    new DHCP server, you should see the lease information populate that file. This
    file can be incredibly helpful, because whenever you connect a new device, you
    won’t have to interrogate the device itself to find out what its IP address is.
    You can just check the `/var/lib/dhcp/dhcpd.leases` file. If the device advertises
    its hostname, you’ll see it within its lease entry. A good example of how this
    can be useful is connecting a Raspberry Pi to your network. Once you plug it in
    and turn it on, you’ll see its IP address in the `dhcpcd.leases` file, and then
    you can connect to it via SSH with the IP without having to plug a monitor into
    it to find out which IP it was given. Similarly, you can view the temporary IP
    address of a new network appliance that you plug in so that you can connect to
    it and configure it.
  prefs: []
  type: TYPE_NORMAL
- en: If you have any trouble setting up the `isc-dhcp-server` daemon, double-check
    that you have set all the correct and matching values within your static IP assignment,
    as well as within your `/etc/dhcp/dhcpd.conf` file. For example, your server must
    be within the same network as the IPs you’re assigning to clients. As long as
    everything matches, you should be fine and it should start properly.
  prefs: []
  type: TYPE_NORMAL
- en: Next, let’s take a look at another important service within a network—DNS.
  prefs: []
  type: TYPE_NORMAL
- en: Adding a DNS server
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: I’m sure most of you are familiar with the purpose of a **Domain Name System**
    (**DNS**) server. Its simplest definition is that it’s a service that’s responsible
    for matching an IP address to a domain or hostname. When you’re connected to the
    internet, name-to-IP matching happens constantly as you browse. After all, it’s
    much easier to connect to [https://www.google.com/](https://www.google.com/) using
    its domain name than it is to remember its IP address.
  prefs: []
  type: TYPE_NORMAL
- en: When you connect to the internet, your workstation or server will connect to
    an external DNS server in order to figure out the IP addresses for the websites
    you attempt to visit.
  prefs: []
  type: TYPE_NORMAL
- en: It’s also very common to run a local DNS server internally in your organization.
    The benefit is that you’ll be able to resolve your local hostnames as well, something
    that an external DNS server would know nothing about. For example, if you have
    an intranet site that you intend to make available to your co-workers, it would
    be easier to give everyone a local domain that they can access than it would be
    to make everyone memorize its IP address. With a local DNS server, you would create
    what is known as a **zone file**, which would contain information regarding the
    hosts and IP addresses in use within your network so that local devices would
    be able to resolve them. In the event that your local DNS server is unable to
    fulfill your request (such as a request for an external website), the server would
    pass the request along to an external DNS server, which would then carry out the
    request.
  prefs: []
  type: TYPE_NORMAL
- en: While DNS is an extensive topic that can take a while to master, a basic understanding
    is really all you need in order to make use of a custom DNS server within your
    network. In this section, I’ll show you how to set up your very own DNS server
    to allow your devices to resolve local hostnames, which should greatly enhance
    your network.
  prefs: []
  type: TYPE_NORMAL
- en: Setting up external DNS with bind
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To set up your very own DNS server, we’ll first need to install the **Berkeley
    Internet Name Daemon** (**BIND**) package on our server:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Now, we should have the `bind9` service running on our server, though it’s not
    actually configured to do much at this point. The most basic function of `bind`
    is to act as what’s called a **Caching Name Server**, which means that the server
    doesn’t actually match any names itself. Instead, it caches responses from an
    external server – which can actually increase the performance of your network
    in some cases. We’ll configure `bind` with actual hosts later, but setting up
    a caching name server is a good way to get started.
  prefs: []
  type: TYPE_NORMAL
- en: To do so, open the `/etc/bind/named.conf.options` file in your favorite text
    editor.
  prefs: []
  type: TYPE_NORMAL
- en: 'Within the file, you should see a block of text that looks similar to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Uncomment these lines. The *forward slashes* are comment marks as far as this
    configuration file is concerned, so remove them. Then, we can add a few external
    DNS server IP addresses. For these, you can use the IP addresses for your **Internet
    Service Provider** (**ISP**)’s DNS servers, or you could simply use Google’s DNS
    servers (`8.8.8.8` and `8.8.4.4`) instead:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'After you save the file, restart the `bind9` service:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'To be sure that everything is running smoothly, check the status of the service:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'It should report that it’s `active (running)`. As long as you’ve entered everything
    correctly, you should now have a working DNS server. Of course, we haven’t added
    any DNS names for it to resolve, but we’ll get to that. Now, all you should need
    to do is configure other devices on your network to use your new DNS server. The
    easiest way to do this is to reconfigure the `isc-dhcp-server` service we set
    up in the previous section. Remember the section that designates a pool of addresses
    from the server to the clients? It also contained a section to declare the DNS
    server your clients will use as well. Here’s that section again, with the relevant
    line in bold:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: To configure the devices on your network to use your new DNS server, all you
    should need to do is change the configuration `option domain-name-servers 192.168.1.1;`
    to point to the IP address of the new DNS server that we’re in the process of
    setting up. When clients request a DHCP lease (or attempt to renew an existing
    lease), they will be configured with the new DNS server automatically.
  prefs: []
  type: TYPE_NORMAL
- en: With the caching name server we just set up, hosts that utilize it will check
    it first for any hostnames they attempt to look up. If they look up a website
    or host that is not within your local network, their requests will be forwarded
    to the forwarding addresses you configured for `bind`.
  prefs: []
  type: TYPE_NORMAL
- en: In my example, I used Google’s DNS servers, so if you used my configuration,
    your hosts will first check your local server and then check Google’s servers
    when resolving external names. Depending on your network hardware and configuration,
    you might even see a slight performance boost. This is because the DNS server
    you just set up is caching any lookups done against it. For example, if a client
    looks up [https://www.packtpub.com](https://www.packtpub.com) in a web browser,
    your DNS server will forward the request along since that site doesn’t exist locally
    and it will also remember the result. The next time a client within your network
    looks up that site, the response will be much quicker because your DNS server
    cached it.
  prefs: []
  type: TYPE_NORMAL
- en: 'To see this yourself, execute the following command twice on a node (device)
    that is utilizing your new DNS server:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'If `dig` isn’t available in your installation, you can install it as part of
    the `dnsutils` package:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'In the response, look for a line toward the end that gives you your query time.
    It will look similar to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'When you run it again, the query time should be much lower:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: This is your caching name server in action! Even though we haven’t even set
    up any zone files to resolve your internal servers, your DNS server is already
    adding value to your network. You just laid the groundwork we’ll use for the rest
    of our configuration.
  prefs: []
  type: TYPE_NORMAL
- en: Setting up internal DNS and adding hosts
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now, let’s add some hosts to our DNS server so we can start fully utilizing
    it. The configuration file for `bind` is located at `/etc/bind/named.conf`. In
    addition to some commented lines, it will have the following three lines of configuration
    within it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see, the default `bind` configuration is split among several configuration
    files. Here, it includes three others: `named.conf.options`, `named.conf.local`,
    and `named.conf.default-zones` (the first of which we already took care of editing).
    In order to resolve local names, we need to create a **zone file**, which is essentially
    a text file that includes some configuration, a list of hosts, and their IP addresses.
    In order to do this, we need to tell `bind` where to find the zone file we’re
    about to create. Within `/etc/bind/named.conf.local`, we need to add a block of
    code like the following to the end of the file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'Notice that the zone is named `local.lan`, which is the same name I gave our
    domain in our DHCP server configuration. It’s best to keep everything consistent
    when we can. If you use a different domain name than the one I used in my example,
    make sure that it matches here as well. Within the block, we’re creating a `master`
    zone file and informing `bind` that it can find a file named `net.local.lan`,
    stored in the `/etc/bind` directory. This should be the only change we’ll need
    to make to the `named.conf.local` file; we’ll only create a single zone file (for
    the purpose of this section). Once you save this file, you’ll need to create the
    `/etc/bind/net.local.lan` file. So, go ahead and open that file in a text editor.
    Since we haven’t created it yet, it should be blank. Here’s an example of this
    zone file, completely filled out with some sample configuration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'Feel free to edit this file to match your configuration. You can edit the list
    of hosts at the end of the file to match your hosts within your network, as the
    ones I included are merely examples. You should also ensure that the file matches
    the IP scheme for your network. Next, I’ll go over each line in order to give
    you a deeper understanding of what each line of this configuration file is responsible
    for:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: The **Time to Live** (**TTL**) determines how long a record may be cached within
    a DNS server. If you recall from earlier, where we practiced with the `dig` command,
    you saw that the second time you queried a domain with `dig`, the query time was
    less than the first time you ran the command. This is because your DNS server
    cached the result, but it won’t hold onto it forever. At some point, the lookup
    will expire. The next time you look up that same domain after the cached result
    has expired, your server will go out and fetch the result from the DNS server
    again. In my examples, I used Google’s DNS servers. That means at some point,
    your server will query those servers again once the record times out.
  prefs: []
  type: TYPE_NORMAL
- en: 'With the **Start of Authority** (**SOA**) line, we’re establishing that our
    DNS server is authoritative over the `local.lan` domain:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: We also set `hostmaster@local.lan` as the email address of the responsible party
    for this server, but we enter it here in a different format for `bind` (`hostmaster.local.lan`).
    This is obviously a fake address, but for the purposes of an internal DNS server,
    its validity is of no concern.
  prefs: []
  type: TYPE_NORMAL
- en: 'Of all the lines of configuration within a zone file, `serial` is by far the
    one that will frustrate us the most:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: This is because it’s not enough to simply update the zone file any time we make
    a change to it (change an IP address, add or remove a host, and so on); we also
    need to remember to increase the serial number by at least one. If we don’t, `bind`
    won’t be aware that we’ve made any changes, as it will look at the serial number
    before the rest of the file.
  prefs: []
  type: TYPE_NORMAL
- en: The problem with this is that you and I are both human, and we’re prone to forgetting
    things. I’ve forgotten to update `serial` many times and have become frustrated
    when the DNS server refused to resolve new hosts that were recently added. Once
    I remembered that I didn’t increment the serial number, the issue was resolved
    after I did. Therefore, it’s very important for you to remember that any time
    you make a change to any zone file, you’ll need to also increment the serial number.
  prefs: []
  type: TYPE_NORMAL
- en: The format doesn’t really matter; I used `202208161`, which is simply the year,
    two-digit month, two-digit day, and an extra number to cover us if we make more
    than one change in a day (which can sometimes happen). As long as you increment
    the serial number by one every time you modify your zone file, you’ll be in good
    shape—regardless of what format you use. However, the sample format I gave here
    is actually quite common in the field.
  prefs: []
  type: TYPE_NORMAL
- en: 'These values control how often secondary DNS servers will be instructed to
    check in for updates:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'With the example refresh value, we’re instructing any secondary DNS servers
    to check in every eight hours to see whether or not the zone records were updated.
    The `retry` field dictates how long the secondary will wait to check in, in case
    there was an error doing so the last time. The last two options in this section,
    `expire` and `minimum`, set the minimum and maximum age of the zone file, respectively.
    As I mentioned though, a full discussion of DNS with `bind` could constitute an
    entire book on its own. For now, I would just use these values until you have
    a reason to need to experiment. Here, we identify the name server itself:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: In my case, the server is called `hermes` and it’s located at `192.168.1.1`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, in our file, we’ll have several host entries to allow our resources to
    be resolved on our network by name:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'In that example, I have three hosts: `fileserv`, `mailserv`, and `web01`. In
    the example, these are all address records, which means that any time our server
    is asked to resolve one of these names, it will respond with the corresponding
    IP address. If our DNS server is set as a machine’s primary DNS server, it will
    respond with `192.168.1.3` when asked for `fileserv` and `192.168.1.7` when asked
    for `web01`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The entry for `mail` is special as it is not an address record, but instead
    a **Canonical Name** (**CNAME**) record. In this case, it just points back to
    `mailserv`. Essentially, that’s what a CNAME record does: it creates a pointer
    to another resource. In this case, if someone tries to access a server named `mail`,
    we redirect them to the actual server `mailserv`. Notice that on the CNAME record,
    we’re not inputting an IP address, but instead the hostname of the resource it’s
    linked to.'
  prefs: []
  type: TYPE_NORMAL
- en: In addition, you should also notice that I added the DNS server itself (`hermes`)
    to the file as well. You can see it on the second line above. I’ve found that
    if you don’t do this, the DNS server may complain and refuse to load the file.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have a zone file in place, we should be able to start using it.
    First, we’ll need to restart the `bind9` service:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'After the command finishes, check to see if there are any errors:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'You should see that the service state is `active (running)`, and in addition,
    you should see a line telling you that the serial number for your zone file was
    loaded. If you see that the service is not running and/or your zone file was not
    loaded, you should see specific information in the output while checking the status
    that should point you in the right direction. If not, you can also check the system
    log for clues regarding `bind` as well:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: The most common mistakes I’ve seen typically result from not being consistent
    within the file. For example, if you’re using a different IP scheme (such as `10.10.10.0/24`),
    you’ll want to make sure you didn’t forget to replace any of my example IP addresses
    with the proper scheme. Assuming that everything went smoothly, you should be
    able to point devices on your network to use this new DNS server. Make sure you
    test not only pinging devices local to your network but outside resources as well,
    such as websites. If the DNS server is working properly, it should resolve your
    local names, and then forward your requests to your external DNS servers (the
    two we set as forwarders) if it doesn’t find what you’re looking for locally.
    In addition, you’ll also want to make sure that port `53` (UDP) is open in your
    network’s firewall, which is the port that DNS uses. It’s extremely rare that
    this would be an issue, but I have seen it happen.
  prefs: []
  type: TYPE_NORMAL
- en: 'To further test our DNS server, we can use the `dig` command, as we did before
    while we were experimenting with caching. Try `dig` against a local server on
    your LAN, as well as a DNS address that’s not located on your LAN (change the
    first domain to an actual domain on your LAN):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'You should see a response similar to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'What you’re looking for here is for both local resources and external websites
    to be resolvable now. You’ll probably notice that the DNS server used in the output
    will most likely show up as a localhost address, as it did in my output, and not
    the address of the DNS server we just set up. Actually, you can ignore this. Most
    distributions of Linux nowadays use local resolvers, which essentially cache DNS
    lookup results on your local computer. Your computer is still using the DNS server
    we set up, but there’s just an additional layer in between your computer and the
    DNS server. You can verify this with the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: The output will show you the IP address of the actual server that’s responding
    to your DNS lookups.
  prefs: []
  type: TYPE_NORMAL
- en: Next, let’s take a look at the process of setting up an internet gateway, which
    is an option to consider if you don’t already have a router or firewall on your
    network that acts as a device between your internet connection and your internal
    network.
  prefs: []
  type: TYPE_NORMAL
- en: Setting up an internet gateway
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As long as we’re setting up network services, we may as well go all the way
    and set up a router to act as a **gateway** for our network. A gateway within
    a network is the device you go through to route from one network to another. In
    this context, the **internet gateway** will be the device that sits between your
    local network and the device that provides your internet connection (such as a
    cable modem). The gateway in a typical network is usually a commercial router
    or firewall, which often also provides DNS, DHCP, and routing services as well.
  prefs: []
  type: TYPE_NORMAL
- en: If you already have such a device on your network providing these services,
    then there’s nothing for you to do. You can skip this section. But if you’d like
    to set up your own router, then feel free to proceed.
  prefs: []
  type: TYPE_NORMAL
- en: If you’d like to proceed and set up a router, then the first order of business
    is to decide which device on your network will serve that purpose. Often, administrators
    will build DNS, DHCP, and routing services all into the same server, so you can
    even use the same device you’ve used earlier to work through the DNS and DHCP
    examples for our purposes in this section. In order for a device to function as
    a gateway, it should have at least two network interfaces, one to your ISP device
    (such as a cable modem) and another interface connected to a network switch that
    your other servers will connect to. The interface connected to your ISP device
    should use DHCP, so it will obtain an IP address directly from your ISP. This
    interface may need a static IP with details provided from the ISP, if relevant.
  prefs: []
  type: TYPE_NORMAL
- en: Depending on what kind of internet connection you have, Linux itself can likely
    replace whatever device your internet modem connects to. A good example of this
    is a cable modem that your office or home router may utilize. In this case, the
    modem provides your internet connection, and then your router allows other devices
    on your network to access it. In some cases, your modem and router may even be
    the same device. Therefore, depending on the hardware you have, this method of
    setting up your networking may or may not be efficient. But if you do have the
    hardware available, you’ll be able to manage the entire networking stack with
    Ubuntu Server quite easily.
  prefs: []
  type: TYPE_NORMAL
- en: Why might you want to create your own internet gateway? One potential reason
    is that it’s often the case that security patches aren’t provided for commercial
    routers and firewall devices. New vulnerabilities are discovered all the time,
    and if your router or firewall is no longer supported by the manufacturer, it
    may allow outside threats into your network. By setting up an internet gateway
    with Ubuntu, you’ll benefit from the regular updates that Canonical provides.
    As long as you’re using a version of Ubuntu that’s still supported (such as an
    LTS release, as is the case with Ubuntu 22.04), you’ll benefit from a more secure
    platform. If nothing else, a physical server that we can install Ubuntu on will
    usually have a more powerful CPU than a commercial device would have, which would
    mean that CPU bottlenecks slowing down network performance would be less likely
    to happen.
  prefs: []
  type: TYPE_NORMAL
- en: Thankfully, setting up an internet gateway is easy. In fact, we’ll only need
    to execute a single command to set up routing between interfaces, which is technically
    all that’s required in order to set up an internet gateway. But before we get
    into that, it’s also important to keep in mind that if you do set up an internet
    gateway, you’ll need to pay special attention to security. The device that sits
    between your network and your modem will be a constant attack target, just like
    any other gateway device would be. When it comes to commercial routers, they’re
    also attacked constantly.
  prefs: []
  type: TYPE_NORMAL
- en: However, in most cases, they’ll have some sort of default security or firewall
    built in. In all honesty, the security features built into common routing equipment
    are extremely poor and most of them are easy to hack when someone wants to badly
    enough. The point is that these devices have some sort of security to begin with
    (regardless of how good or bad), whereas a custom internet gateway of your own
    won’t have any security at all until you add it.
  prefs: []
  type: TYPE_NORMAL
- en: When you set up an internet gateway, you’ll want to pay special attention to
    setting up the firewall, restricting access to SSH, using very strong passwords,
    keeping up to date on security patches, and installing an authentication monitor
    such as `fail2ban`. We’ll get into those topics in *Chapter 21*, *Securing Your
    Server*. The reason I bring this up now, though, is that if you do set up an internet
    gateway, you’ll probably want to take a detour and read that chapter right away,
    just to make sure that you secure it properly.
  prefs: []
  type: TYPE_NORMAL
- en: 'Anyway, let’s move on. A proper internet gateway, as I’ve mentioned, will have
    two Ethernet ports. On the first, you’ll plug in your cable modem or internet
    device, and you’ll connect a switch to the second. By default though, routing
    between these interfaces will be disabled, so traffic won’t be able to move from
    one Ethernet port to the other. To rectify this, use the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'That’s actually it. With that single command, you’ve just made your server
    into a router. However, that change will not survive a reboot. To make it permanent,
    open the `/etc/sysctl.conf` file in your editor:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'Look for the following line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: Uncomment the line by removing the hash symbol in front of it, and save the
    file. With that change made, your server will allow routing between interfaces
    even after a reboot. Of all the topics we’ve covered in this chapter, that one
    was probably the simplest. However, I must remind you again to definitely secure
    your server if it’s your frontend device to the internet, as computer security
    students always enjoy practicing on a real-life Linux server. With good security
    practices, you’ll help ensure that they’ll leave you alone, or at least have a
    harder time breaking in.
  prefs: []
  type: TYPE_NORMAL
- en: From here, all you should need to do is attach a network switch to your other
    network interface, and then you can attach your other wired Ethernet devices and
    wireless access point to the switch. Now, Ubuntu Server is managing your entire
    network!
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we explored additional networking topics. We started off with
    some notes on planning an IP address scheme for your network so that you could
    create groups for the different types of nodes, such as servers and network equipment,
    and plan a pool of addresses for DHCP. We also worked through the process of setting
    up a DHCP and DNS server, which gives us additional flexibility when configuring
    the services we run on our network, such as when defining a custom IP scheme for
    DHCP, as well as giving us the ability to resolve the hostnames of devices on
    our network by name. We closed off this chapter with a discussion on setting up
    an internet gateway to serve as our internet-facing router.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we’ll take a look at sharing and transferring files over
    the network. This will include covering NFS and Samba shares, as well as using
    `scp`, `rsync`, and `sshfs`. Stay tuned!
  prefs: []
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '8 Steps to Understanding IP Subnetting: [https://learnlinux.link/8-ip-sub](https://learnlinux.link/8-ip-sub)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'IP Subnet Calculator: [https://learnlinux.link/s-calc](https://learnlinux.link/s-calc)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Join our community on Discord
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Join our community’s Discord space for discussions with the author and other
    readers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://packt.link/LWaZ0](https://packt.link/LWaZ0)'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/QR_Code50046724-1955875156.png)'
  prefs: []
  type: TYPE_IMG
