- en: '11'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Creating Our First Module
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Most programming languages include the concept of a library – an object that
    contains code, documentation, programming objects such as classes, message templates,
    and a host of other things. These libraries extend what we can do with that language
    by helping us to use other people’s code and reuse our own. In this chapter, we’re
    going to explore PowerShell modules – a convenient way of distributing PowerShell
    code.
  prefs: []
  type: TYPE_NORMAL
- en: We’ll start by briefly recapping how to work with modules and the cmdlets we
    use to do that. Then, we’ll look at the components of a module. We’ll learn how
    to write a module manually, before wrapping up with a brief look at using a module
    scaffolding application called **Plaster**.
  prefs: []
  type: TYPE_NORMAL
- en: 'The main topics we will cover in this chapter are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Working with modules
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Writing a simple module
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Module manifests
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using scaffolding tools such as Plaster
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Working with modules
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Back in [*Chapter 2*](B17600_02.xhtml#_idTextAnchor034), *Exploring PowerShell
    Cmdlets and Syntax*, we spent some time exploring how we can use modules to find
    new cmdlets. In this chapter, we’ll be writing modules, but first, let’s recap
    what we learned previously and place it in some sort of context.
  prefs: []
  type: TYPE_NORMAL
- en: Modules allow us to reuse and distribute code so that it can be easily automated
    by including the cmdlets that manipulate modules in our scripts. So, if we need
    a cmdlet from the PowerShell math module in our script, then we can programmatically
    import that module (or just the required cmdlet) and use it. We can do this in
    a predictable and controllable fashion, without user intervention.
  prefs: []
  type: TYPE_NORMAL
- en: 'Modules fulfill three basic functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Configuring the environment**: They provide a repeatable custom work environment
    – for example, the PowerShell module for Exchange, as well as Exchange-specific
    cmdlets – configuring the PowerShell environment to work in a particular way with
    Exchange'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Code reuse**: They provide libraries of functions that we or other people
    can use, such as the math module'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Solution engineering**: Because modules can be nested inside other modules,
    whole groups of modules may be distributed to create an application for redistribution
    – this is common in Windows administration environments'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We can find modules on the internet, in places such as GitHub, where they’ve
    been distributed with software, in a public repository such as the PowerShell
    Gallery or internal repositories in our workplace or school, or via friends and
    colleagues.
  prefs: []
  type: TYPE_NORMAL
- en: By installing the modules in standard locations, we can control access to them
    on a given machine, or we can add to the default list of places that PowerShell
    will search for modules. Let’s start by looking at the common locations for modules
    on our client device.
  prefs: []
  type: TYPE_NORMAL
- en: Module locations
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'There are three default locations for modules. These are shown in the following
    table:'
  prefs: []
  type: TYPE_NORMAL
- en: '|  | **Windows** | **Linux** |'
  prefs: []
  type: TYPE_TB
- en: '| **System** | None for PowerShell 7, but Windows PowerShell uses `C:\WINDOWS\system32\WindowsPowerShell\v1.0\Modules\`
    | `/``opt/Microsoft/PowerShell/7/Modules` |'
  prefs: []
  type: TYPE_TB
- en: '| **AllUsers** |'
  prefs: []
  type: TYPE_TB
- en: '`C:\Program Files\PowerShell\Modules`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`C:\Program Files\PowerShell\7\Modules`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '| `/``usr/local/share/PowerShell/Modules` |'
  prefs: []
  type: TYPE_TB
- en: '| **User** | `C:\Users\<user name>\Documents\PowerShell\Modules` | `/``home/<username>/.local/share/PowerShell/Modules`
    |'
  prefs: []
  type: TYPE_TB
- en: Table 11.1 – Default module locations in Windows and Linux
  prefs: []
  type: TYPE_NORMAL
- en: The System location is reserved for Microsoft modules. The User location does
    not exist by default in Windows and will need to be created before it can be used.
    The AllUsers location was introduced in PowerShell v4 to provide a location for
    non-Microsoft modules that need to run under the system account. This also gives
    us a place to install modules for any user on the client to use. Modules downloaded
    from the PowerShell Gallery are placed here by default.
  prefs: []
  type: TYPE_NORMAL
- en: 'As we saw in [*Chapter 2*](B17600_02.xhtml#_idTextAnchor034), *Exploring PowerShell
    Cmdlets and Syntax*, we can add locations where we may install modules by manipulating
    the `$ENV:PSModulePath` variable. Locations should be separated by a semicolon
    (`;`) in Windows and a colon (`:`) in Linux, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.1 – The $env:PSModulePath variable in Linux](img/B17600_11_001.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 11.1 – The $env:PSModulePath variable in Linux
  prefs: []
  type: TYPE_NORMAL
- en: We can make this listing tidier by calling the `$env:PSModulePath -Split ":"`
    variable, which will output each location on a separate line. Obviously, on a
    Windows client, the separator should be a semicolon (`;`). Paths often get added
    to this variable when installing applications.
  prefs: []
  type: TYPE_NORMAL
- en: Module autoloading
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We can load modules automatically under certain circumstances. Modules in correctly
    named folders in the module paths defined in `$env:PSModulePath` are automatically
    discovered by PowerShell. We can do this by doing the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Running a cmdlet from the module
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using `Get-Command` for a cmdlet in the module
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using `Get-Help` for a cmdlet in the module
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Module autoloading is great for when we’re working interactively in the shell,
    but we shouldn’t rely on it in a script. The recommended way to load modules inside
    a script is with the `using` keyword, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Here’s an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Note that some caveats on this are covered in the *Nested* *modules* section.
  prefs: []
  type: TYPE_NORMAL
- en: Importing modules
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Autoloading modules is convenient, but it’s not particularly controlled. For
    instance, it loads everything in the module, some of which we might not need,
    and we cannot control the version of the module that is loaded. It can also consume
    a lot of memory. Therefore, we might choose to manually import modules into a
    session using the `Import-Module` cmdlet, which gives us several options to control
    how and what we import:'
  prefs: []
  type: TYPE_NORMAL
- en: '`-Name`: Use this to specify the name of the module to import. We can also
    include a path here if the module is not in the module path specified in `$ENV:PSModulePath`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`-Cmdlet`: This allows us to import a selection of cmdlets from an array of
    strings. Similar parameters, such as `-Alias`, `-Function`, and `-Variable`, have
    the expected effect.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`-Force`: This forces a module to reload completely. By default, if a module
    is already loaded, then `Import-Module` does not reimport it. This is useful if
    we are developing a module and need to test it repeatedly.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`-RequiredVersion`: Use this to specify the version of the module to be imported.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`-Prefix`: This parameter adds a prefix to the nouns in cmdlets that are imported
    from the module, to prevent confusion with cmdlets that already exist in the session.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`-NoClobber`: This prevents cmdlets from being imported if they have the same
    name as cmdlets that already exist in the session.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There are several other parameters, but we won’t consider them here.
  prefs: []
  type: TYPE_NORMAL
- en: We can unload a module using the `Remove-Module` cmdlet. Why might we want to
    do that? Well, when we first import a module, we import all the nested modules
    that it requires as well. However, if we then use `Import-Module -Force` to reload
    the module, it only reloads the named module, not the nested modules. `Remove-Module`
    also removes the nested modules. In practice, of course, just starting a new session
    is often quicker and cleaner.
  prefs: []
  type: TYPE_NORMAL
- en: Very often, we’ll see scripts on the internet using the `Import-Module` cmdlet
    to make module contents available inside a script. I do this too, despite it not
    being the recommended way of doing it; it just feels more readable to me. Microsoft
    recommends we do this with the `using` keyword, though. My doctor recommends I
    eat less salt; I tend to ignore that advice as well.
  prefs: []
  type: TYPE_NORMAL
- en: PowerShellGet
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Microsoft has a module called `PowerShellGet` that includes a lot of resources
    for working with repositories and modules. This module is included in PowerShell
    7\. It allows us to work easily with the PowerShell Gallery so that we can find,
    register, and unregister other repositories, which allows us to find, install,
    and uninstall modules and scripts in repositories, as well as manipulate those
    modules and scripts. We covered the basic uses of `PowerShellGet` at some length
    in [*Chapter 2*](B17600_02.xhtml#_idTextAnchor034),*Exploring PowerShell Cmdlets*
    *and Syntax*.
  prefs: []
  type: TYPE_NORMAL
- en: From PowerShell 7.4 onwards, the PowerShellGet v2.2.5 module will be accompanied
    by version 3\. The version 3 module is called `Microsoft.Powershell.PSResourceGet`
    and replaces the `Install-Module` and `Install-Script` cmdlets with the single
    `Install-PSResource` cmdlet, among many other changes. In PowerShell 7.4, the
    two modules will ship side by side, allowing any current resources that use `PowerShellGet`
    to continue working. However, no compatibility layer will be included, so scripts
    written for v2.2.5 and earlier won’t work with version 3 unless we use the separate
    `CompatPowerShellGet` module that will be included in PowerShell 7.5.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we’ll learn how to create a module, but first, a word of caution. There
    is a PowerShell cmdlet called `New-Module`. This creates a very specific type
    of module – a `New-Module`, either.
  prefs: []
  type: TYPE_NORMAL
- en: Writing a simple module
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A module, at its most basic, is a script file containing functions, saved with
    a `.psm1` extension. That’s it. That’s the simplest possible module. Try it –
    save the following lines as a `.psm1` file, in a folder with the same name as
    the file, inside your `\users\<username>\documents\powershell\modules` folder
    (or the `home/<user>/.local/share/powershell/Modules` folder in Linux):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'It doesn’t matter what you call the file, so long as the file and folder name
    are the same, and the folder is in the module path so that PowerShell can find
    it, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.2 – Saving a module in the module path correctly](img/B17600_11_002.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 11.2 – Saving a module in the module path correctly
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, if we start a PowerShell session, we can type the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'PowerShell will load it. Once it is loaded, we can use the functions inside,
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.3 – Using our first module](img/B17600_11_003.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 11.3 – Using our first module
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, the `Import-Module` cmdlet produces no output, but the function
    inside the module is available. If we run `Remove-Module`, the function disappears
    as well. Or does it?
  prefs: []
  type: TYPE_NORMAL
- en: Activity 1
  prefs: []
  type: TYPE_NORMAL
- en: Try running `Remove-Module` to get rid of the module we’ve just installed, and
    then running `Get-Square`. What happens? Why does this happen?
  prefs: []
  type: TYPE_NORMAL
- en: Before we look at ways to create modules, let’s talk about the earliest method
    of building libraries in PowerShell – dot-sourcing.
  prefs: []
  type: TYPE_NORMAL
- en: A word of caution – dot-sourcing
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In the very first version of PowerShell, there was only one way to include
    the functions in one script inside another: `Dot-Source.ps1` in a suitable folder
    – I’m using `c:\temp\poshbook\ch11`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'It should be obvious that if we run this, it isn’t going to work. There is
    no cmdlet called `Write-Message`, and the script doesn’t define one. Let’s create
    a `Write-Message` function in another script, and save it as `Write-Message.ps1`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let’s go back to `Dot-Source.ps1` and add this line at the start:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Change the path to reflect the location where you saved `Write-Message.ps1`.
    Now, when we run `Dot-Source.ps1`, our message should be displayed, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.4 – Using dot-sourcing in a script](img/B17600_11_004.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 11.4 – Using dot-sourcing in a script
  prefs: []
  type: TYPE_NORMAL
- en: 'We can do this interactively as well, in a PowerShell session, just by dot-sourcing
    the script, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.5 – Interactive dot-sourcing](img/B17600_11_005.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 11.5 – Interactive dot-sourcing
  prefs: []
  type: TYPE_NORMAL
- en: So, if dot-sourcing is so straightforward, why should we bother with modules
    at all? The reason is the management problems that dot-sourcing introduces. When
    we dot-source a script, we bring the members of that script, as well as the variables
    and functions, into the parent scope. We can see this in the preceding screenshot;
    if we call the `$text` variable, then we get the `default message` string. Remember,
    the concept of scope was introduced to protect us from ambiguously written code;
    by dot-sourcing code, we remove that protection. When we interactively dot-sourced
    `Write-Message.ps1`, we brought a function into the global scope that we now have
    no easy way of removing. Any variables in that script outside the function would
    be brought in as well. If those variables are poorly named, they may conflict
    with important existing variables, leading to, as they say, hilarious consequences.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we are unsure where a function has come from, we can use the `File` property
    on the object to check, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'This will give us the path of the file that contains that function. We can
    also remove it from a session with the `Remove-Item` cmdlet, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.6 – Finding the source of functions and removing them](img/B17600_11_006.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 11.6 – Finding the source of functions and removing them
  prefs: []
  type: TYPE_NORMAL
- en: Modules allow us to control what functions and variables are exported from our
    code, and to control those as a group. Let’s see how we can turn an existing script
    into a module.
  prefs: []
  type: TYPE_NORMAL
- en: Turning a script into a module
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As we saw at the start of this section, the basic process for turning a script
    into a module is to change the file extension from `.ps1` to `.psm1`. Let’s do
    that now with the `Write-Message.ps1` script we wrote previously, and save a copy
    of it as `Write-Message.psm1`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we can open a new session and import our module into the session with
    the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Let’s take a look at this module in detail:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.7 – Details of the Write-Message module](img/B17600_11_007.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 11.7 – Details of the Write-Message module
  prefs: []
  type: TYPE_NORMAL
- en: 'In the first line, we imported the module. We used the full path because we
    haven’t saved it in a location included in the module path. This is to prevent
    PowerShell from autoloading it. Now, let’s run the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'We’ll see a script module, its location, and the exported command – that is,
    `Write-Module`. Now, let’s run the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: We will see that only the function is exported, not the variable.
  prefs: []
  type: TYPE_NORMAL
- en: We can check the details of the `Write-Message` function with `Get-Command`
    and see that the source is the `Write-Message` module.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s try some other things with this module. Open the module file and add
    the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Import the module again, using the `-Force` parameter to reload it. Now, we
    have two functions in our module. If we run `Get-Module` again, we’ll see that
    they are both visible:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.8 – Multiple exports](img/B17600_11_008.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 11.8 – Multiple exports
  prefs: []
  type: TYPE_NORMAL
- en: 'As you can see, the `setMessage` cmdlet is available for us to use. What happens
    if we don’t want that? The name we’ve used doesn’t conform with cmdlet naming
    conventions and is generally one we’d use to signify a private function; something
    that we need to be available to the other functions within the module, but not
    something we want available for use outside those functions. We can control access
    using the `Export-ModuleMember` cmdlet. Add the following line to the bottom of
    `Write-Message.psm1`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, import the module again with the `-Force` parameter. The results are
    shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.9 – Controlling exported functions](img/B17600_11_009.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 11.9 – Controlling exported functions
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, only the `Write-Message` function is exported, and when we try and run
    `setMessage`, this time, we get an error. We can also use `Export-ModuleMember`
    to export variables and aliases from the module, which aren’t exported by default,
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: If we don’t explicitly use `Export-ModuleMember`, all the functions in a module
    will be exported, but nothing other than functions.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the introduction to this chapter, we mentioned one of the use cases for
    modules: building applications and solutions. To do this, we will often call a
    module from within another module – this is called nesting modules, and that’s
    what we’re going to look at next.'
  prefs: []
  type: TYPE_NORMAL
- en: Nested modules
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In [*Chapter 9*](B17600_09.xhtml#_idTextAnchor184), *Don’t Repeat Yourself
    – Functions and Scriptblocks*, we looked at some functions for writing output
    to log files. It would be useful to write those functions in a module so that
    we could just call them when we needed them, rather than having to write them
    in every script we create. These are great examples of functions we would want
    to keep private, rather than export them for general use. Let’s do this. Copy
    the `Write-Log.ps1` script we wrote previously to a module file called `Write-Log.psm1`
    in a suitable location. We’ll need to edit the `.psm1` file to remove the following
    line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'This is how my module file looks:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.10 – The Write-Log.psm1 module](img/B17600_11_010.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 11.10 – The Write-Log.psm1 module
  prefs: []
  type: TYPE_NORMAL
- en: As we can see, I’ve remarked line 11, rather than deleting it. We are left with
    two functions and a variable – that is, `Write-Log`, `Remove-Log`, and `$LogFile`.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can now add a couple of lines to our `Write-Message.psm1` module so that
    we can call the `Write-Log` module and run one of the functions in it. Edit your
    `Write-Message` function, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'I’ve added the first line to import the `Write-Log` module and the fifth line
    to call the `Write-Log` function from it. I’ve also removed the `Export-ModuleMember`
    line. Now, let’s see what happens when we import the `Write-Message` module:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.11 – Nested modules](img/B17600_11_011.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 11.11 – Nested modules
  prefs: []
  type: TYPE_NORMAL
- en: As we can see, the module is imported as before and works as we expect. We can
    see from the output of `Get-Module` that there are four exported functions – two
    from `Write-Message` and two from `Write-Log` – and we can see that the `Write-Log`
    module is nested. When we attempt to access it with `Get-Command`, however, we
    don’t see any loaded functions, and `Get-Module Write-Log` returns nothing. However,
    if we check the log file that was created, we’ll see a message stating `nested
    module test`, so it is working.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is because nested modules are only visible to the calling module, so we
    can’t access `Write-Log` directly. However, because we removed the `Export-ModuleMember`
    line, all functions are exported, including the functions from nested modules;
    they appear as functions of the calling module. We’ll be able to see the `Write-Log`
    module if we use `Get-Module -All`, though, and we can find the real location
    of the `Write-Log` function as before – that is, by calling the `File` property:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.12 – Finding nested modules](img/B17600_11_012.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 11.12 – Finding nested modules
  prefs: []
  type: TYPE_NORMAL
- en: As we can see, the `Write-Log` function is defined in the `write-log.psm1` file.
  prefs: []
  type: TYPE_NORMAL
- en: 'Sometimes, we may not want nested modules to be hidden like this; if that’s
    the case, then we can use the `-Global` parameter of `Import-Module`, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: The `Write-Log` module will be imported at the same top level as the `Write-Message`
    module.
  prefs: []
  type: TYPE_NORMAL
- en: Now, let’s look at some other types of modules, including binary and manifest
    modules.
  prefs: []
  type: TYPE_NORMAL
- en: More modules
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'You may have noticed that when we create a function in a module, we use it
    like a cmdlet, but it’s still called a function. It will behave as a cmdlet, with
    parameters, help, members, and so on, but it’s not a cmdlet. Consider the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.13 – Functions and cmdlets](img/B17600_11_013.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 11.13 – Functions and cmdlets
  prefs: []
  type: TYPE_NORMAL
- en: As we can see, `Write-Message` is of the `Function` type, whereas the Microsoft
    `Get-Service` command is of the `Cmdlet` type.
  prefs: []
  type: TYPE_NORMAL
- en: To write custom cmdlets, we need to write a binary module. Remember that PowerShell
    is based on .NET and is an interpreted language, written in a compiled language,
    usually C#, in the same way that Python is an interpreted language written in
    C.
  prefs: []
  type: TYPE_NORMAL
- en: We’re not going to cover writing modules in C# here, but we will discuss how
    they work and how they are used.
  prefs: []
  type: TYPE_NORMAL
- en: 'A binary module does not have a `.psm1` extension – it is a .NET assembly compiled
    from code such as C# and has a `.dll` extension. We can create it by writing our
    C# code within a `Here-String` declaration, a block of multi-line text inside
    the `@" "@` construct, and then use the `Add-Type -OutputAssembly` cmdlet to compile
    it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Other than that, we can import it in the same way as a script module with `Import-Module`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: If we were to run `Get-Module` on our fictional `MyBinaryModule`, we would see
    that `ModuleType` is `Binary` and that it has exported cmdlets, rather than exported
    functions.
  prefs: []
  type: TYPE_NORMAL
- en: The main difference between binary modules and script modules is that once they’re
    loaded into a session, they can’t be unloaded. If we need to make a change to
    a binary module we are writing, we will need to close PowerShell first.
  prefs: []
  type: TYPE_NORMAL
- en: We may also see PowerShell modules written in CDXML, an XML wrapper for Common
    Information Model commands. This used to be quite common for Windows administration
    modules, but it is largely deprecated now since modules written this way are slower
    to load and run than script modules due to the extra effort required to parse
    the XML into PowerShell, which then itself needs parsing. In the words of the
    official documentation, “*Avoid CDXML.*” Similarly, we may see references to PowerShell
    SnapIns. These are deprecated forms of Windows PowerShell that aren’t supported
    in PowerShell 7, so we don’t need to worry about them.
  prefs: []
  type: TYPE_NORMAL
- en: There’s one more type of module for us to consider – the manifest module. A
    manifest module is a script or binary module that includes a module manifest.
    That’s what we’re going to look at in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Module manifests
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The script modules we’ve been playing with so far are monolithic single files,
    either standalone or nested. That’s fine for hobbyist use, but it’s not great
    in a production environment, where we might want to split our functions into separate
    files and include version information and a whole bunch of other metadata and
    resources, such as XML formatting files or binaries. To organize a more complex
    module, we need a document that explains how it is to be loaded and implemented;
    this document is called a module manifest, and it is a hash table saved with a
    `.psd1` extension. Let’s have a look at an example. if we browse to the PowerShellGet
    module in `C:\Program Files\PowerShell\7\Modules` (or `/opt/microsoft/PowerShell/7/Modules`
    in Linux), we will see the following files and folders:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.14 – The PowerShellGet module](img/B17600_11_014.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 11.14 – The PowerShellGet module
  prefs: []
  type: TYPE_NORMAL
- en: As we can see, there are four files and three folders. These folders contain
    several `.psm1` and `.psd1` files that define functions and manifests for nested
    modules. The main code for the module is in `PSModule.psm1`. `PSGet.Format.ps1xml`
    contains formatting information for displaying the output of functions. `PowerShellGet.psd1`
    is the module manifest. `PSGet.Resource.psd1` is a set of output strings for the
    module to use; we won’t worry about it here. If we open the `PSModule.psm1` file,
    we will see it is written in PowerShell, not C#, so it is a script module. It’s
    a big file, with a lot of functions defined in it. Let’s take a look at the `PowerShellGet.psd1`
    file.
  prefs: []
  type: TYPE_NORMAL
- en: The first thing to note is that it is given the same name as the folder it’s
    housed in. This is deliberate; if there is a manifest present in a module folder,
    it must have the same name as the folder; otherwise, the module won’t load. Giving
    the same name to the `.psm1` file, in the absence of a manifest, allows PowerShell
    to easily find it for autoloading, but otherwise, this doesn’t matter. It’s different
    for manifests.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s open it up and look inside:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.15 – The PowerShellGet manifest](img/B17600_11_015.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 11.15 – The PowerShellGet manifest
  prefs: []
  type: TYPE_NORMAL
- en: On line 1, we can see that this is a hash table from `@{`, and that everything
    after that takes the format of a key-value pair. As we can see, this is a long
    file with a lot of information in it; over 200 lines, although much of this is
    a big blob of text with the `ReleaseNotes` key.
  prefs: []
  type: TYPE_NORMAL
- en: A manifest consists of up to 37 different key-value pairs that may contain strings
    or arrays. We can add additional code to a manifest, including comparison and
    arithmetic operators, basic data types, and the `if` statement, but we’re not
    going to cover that here; I’ve never needed to do it. Let’s create a new manifest
    for ourselves and see what’s in it.
  prefs: []
  type: TYPE_NORMAL
- en: 'In a suitable directory, create a folder called `ManifestModule`. Now, open
    a PowerShell session and type the following cmdlet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'At the prompt, supply the path and the name of the new manifest file, like
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'That’s it – this creates a new manifest file for a module called `ManifestModule`.
    Let’s open it up in VS Code:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.16 – A basic module manifest](img/B17600_11_016.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 11.16 – A basic module manifest
  prefs: []
  type: TYPE_NORMAL
- en: The first thing to notice is that some of the values have been generated for
    you. `ModuleVersion` is `0.0.1`, there is an autogenerated `GUID` to ensure that
    this module can be differentiated from any other modules with the same name, and
    the `Author`, `CompanyName`, and `Copyright` keys are populated. Other than that,
    everything is empty and generally remarked out.
  prefs: []
  type: TYPE_NORMAL
- en: 'The keys in a manifest fall into three groups that cover the following aspects:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Production data**: Who wrote it, when, who for, and what sort of systems
    it will run on.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`RootModule` defines the main module file that calls everything else – the
    main `.``psm1` file.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Module content**: These are lists of all the modules, files, and other assets
    that are included in the module. These keys are optional, but generally, they
    should be populated accurately.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We can populate the keys when we call the `New-ModuleManifest` cmdlet, by adding
    the key name as a parameter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'The alternative is to edit the manifest file directly in a text editor or VS
    Code. If we edit it directly, there is always the possibility of mistyping something
    and breaking the file, so it’s a good idea to test our edited manifest, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'We can see the results in the following figure:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.17 – Testing a module manifest file](img/B17600_11_017.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 11.17 – Testing a module manifest file
  prefs: []
  type: TYPE_NORMAL
- en: If the module’s information is returned, then the file has been formatted correctly.
  prefs: []
  type: TYPE_NORMAL
- en: As we’ve seen, module construction can get complicated pretty quickly. Let’s
    finish this chapter by taking a look at a tool that can make it very much easier
    – Plaster.
  prefs: []
  type: TYPE_NORMAL
- en: Using scaffolding tools such as Plaster
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If we are working long-term on a module, or collaborating with other people,
    then it’s a really good idea to use a framework that splits everything up into
    separate files and assets. This is where a scaffolding tool comes in. My choice
    of tool is Plaster, a module that was originally produced by Microsoft but is
    now maintained by PowerShell.Org, one of the most prolific online PowerShell communities.
  prefs: []
  type: TYPE_NORMAL
- en: 'Plaster uses a template file that consists of a manifest (similar to the module
    manifest) and a set of content files and directories. The template is written
    in XML and is highly customizable. The manifest has three sections:'
  prefs: []
  type: TYPE_NORMAL
- en: Metadata, which contains information about the template, such as its name, version,
    and author
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Parameters, which defines choices that the user can make about their module
    structure – what files and folders to create and include
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Content, which specifies the actions that Plaster will perform – copying files,
    modifying files, and checking that required modules are installed.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let’s start by installing the module from the PowerShell gallery. Type the
    following to download the module:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'We may need to acknowledge that the PowerShell gallery is an untrusted repository.
    Now, let’s import the module:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'And that’s it – we’re ready to go. Let’s see what we’ve got:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.18 – Examining the Plaster module](img/B17600_11_018.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 11.18 – Examining the Plaster module
  prefs: []
  type: TYPE_NORMAL
- en: 'As we can see, we’ve installed version 1.1.4 of the module, and we’ve got four
    new commands to play with:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Get-PlasterTemplate`: This lists the existing templates available for us to
    use. We can write or download templates as XML files. Only two are included, and
    the one we need is `NewPowerShellScriptModule`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Invoke-Plaster`: This runs the Plaster scaffolding tool.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`New-PlasterManifest`: This command creates a new manifest.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Test-PlasterManifest`: This command tests that the manifest is formatted correctly.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let’s run it and see what we get:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, copy the path for `NewPowerShellScriptModule`. Now, type the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: You’ll be asked for the path to the default template and then a destination
    path; this needs to be a folder, not a file.
  prefs: []
  type: TYPE_NORMAL
- en: 'You’ll also be asked to provide the module’s name and version, as well as whether
    you want to set VS Code as the default editor. Here’s how it looked for me:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.19 – Invoking Plaster](img/B17600_11_019.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 11.19 – Invoking Plaster
  prefs: []
  type: TYPE_NORMAL
- en: As we can see, one of the required modules, Pester, is missing from my sandbox
    machine. Pester is a module that makes it a breeze to do unit testing and test-driven
    development, but it’s a bit beyond the scope of this book.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s see what has been created in the destination path:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.20 – A module created with the default Plaster template](img/B17600_11_020.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 11.20 – A module created with the default Plaster template
  prefs: []
  type: TYPE_NORMAL
- en: As we can see, Plaster has created two files – a script module file and a module
    manifest file – a folder for test scripts, and a folder for VS Code settings.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `NewPlasterModule.psm1` file looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.21 – A basic module file generated by Plaster](img/B17600_11_021.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 11.21 – A basic module file generated by Plaster
  prefs: []
  type: TYPE_NORMAL
- en: As we can see, it’s very simple, but it includes a great trick – if the functions
    in the file are named with standard cmdlet naming conventions, such as `Verb-Noun`,
    then they will be exported. If they are not, like the `setMessage` function we
    wrote earlier in this chapter, then they will not be exported. Neat.
  prefs: []
  type: TYPE_NORMAL
- en: The beauty of Plaster is how extensible it is; it’s easy to write templates
    to create folder structures for public and private functions and classes, and
    it can all be done in a repeatable way. To get some idea of how versatile Plaster
    is, have a look at Kevin Marquette’s blog at [https://powershellexplained.com/2017-05-12-Powershell-Plaster-adventures-in/](https://powershellexplained.com/2017-05-12-Powershell-Plaster-adventures-in/)
    and his GitHub page at [https://github.com/KevinMarquette/PlasterTemplates](https://github.com/KevinMarquette/PlasterTemplates).
    Have a play with his example templates.
  prefs: []
  type: TYPE_NORMAL
- en: That is as much as we’re going to cover regarding Plaster – there are several
    other scaffolding modules available, so if you don’t like Plaster, take a look
    at some of the others. That also wraps up this chapter; let’s recap what we’ve
    done.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We started this chapter by reminding ourselves of what we learned in earlier
    chapters regarding modules and placing that into a more formal context. We looked
    at the standard module locations and how we can add locations by editing the `$ENV:PSModulePath`
    variable. We saw how PowerShell uses these locations to facilitate autoloading,
    and we saw how sometimes, we might not want that to happen. Then, we looked at
    how we can manually import modules and finished up our review by looking at the
    `PowerShellGet` module.
  prefs: []
  type: TYPE_NORMAL
- en: After, we started to write our own modules. We began by looking at the earliest
    method for importing code, known as dot-sourcing, and saw why that could be a
    bad idea. Then, we created our first module by writing a script and converting
    it. Next, we looked at how we can build applications by nesting modules, before
    discussing some other types of modules, such as binary modules.
  prefs: []
  type: TYPE_NORMAL
- en: Then, we looked at the most common complex module type – the manifest module.
    We saw how the manifest file controls what is loaded and exported, and how to
    write and test a manifest file. Finally, we looked at a tool that can make writing
    modules much simpler – Plaster.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we are going to look at the security aspects of PowerShell,
    and how we can best go about making ourselves and our colleagues and users safe
    with such a powerful tool.
  prefs: []
  type: TYPE_NORMAL
- en: Exercises
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Here are the exercises for this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: How can you list all imported modules in the current PowerShell session?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is the purpose of the `-Global` parameter when importing a module?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How do we import a module that isn’t in a path specified in the `$``ENV:PSModulePath`
    variable?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We want to import a module that contains functions that have the same name as
    cmdlets that already exist in our session. What are two ways we can get around
    this?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: By default, all the functions of a module are exported. What are two ways we
    can control what functions are exported?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is the purpose of the `HelpInfoURI` key in a module manifest?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What might be in a file with the`.ps1xml` extension?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If we load a module with the `.dll` extension, what sort of commands will we
    get?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Why don’t we write CDXML modules?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To learn more about the topics that were covered in this chapter, take a look
    at the following resources:'
  prefs: []
  type: TYPE_NORMAL
- en: '`PowerShellGet` and its replacement:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://devblogs.microsoft.com/powershell/powershellget-in-powershell-7-4-updates/](https://devblogs.microsoft.com/powershell/powershellget-in-powershell-7-4-updates/)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://learn.microsoft.com/en-us/powershell/module/microsoft.powershell.psresourceget/?view=powershellget-3.x](https://learn.microsoft.com/en-us/powershell/module/microsoft.powershell.psresourceget/?view=powershellget-3.x)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://learn.microsoft.com/en-us/powershell/module/powershellget/?view=powershellget-2.x](https://learn.microsoft.com/en-us/powershell/module/powershellget/?view=powershellget-2.x)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Writing module manifests: [https://learn.microsoft.com/en-us/powershell/scripting/developer/module/how-to-write-a-powershell-module-manifest](https://learn.microsoft.com/en-us/powershell/scripting/developer/module/how-to-write-a-powershell-module-manifest)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Plaster: [https://powershellexplained.com/2017-05-12-Powershell-Plaster-adventures-in/#template-folder-and-file-structure](https://powershellexplained.com/2017-05-12-Powershell-Plaster-adventures-in/#template-folder-and-file-structure)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
