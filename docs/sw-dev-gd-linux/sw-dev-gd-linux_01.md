# 1

# 命令行是如何工作的

在深入学习实际的 Linux 命令之前，你需要对命令行的工作原理有一个基本的理解。本章将为你提供这样的理解。

对于新手开发者，我们将探讨你开始使用 Linux 命令行所需的基本技能。对于有一些经验的人来说，仍然有一些细微的差别需要了解，比如“shell”和“命令行”之间的区别。了解这些差异很有价值！ 

在本章中，我们将涵盖以下主题：

+   命令行界面（CLI）的基本概念

+   命令的格式

+   命令参数是如何工作的，当你输入命令以及查阅文档时，它们是什么样子的。

+   介绍“shell”及其与“命令行”的区别

+   shell 用来查找命令的核心规则

首先，我们将从命令行界面的基本概念开始。我们将快速掌握 CLI 的工作原理，并通过一个简单的例子来加以演练。

# 一开始……是 REPL

什么是 **命令行界面**（**CLI**）？它是一个基于文本的计算机交互环境：

1.  从你那里读取一些输入，

1.  评估（或处理）输入，

1.  响应并打印一些输出到屏幕，然后

1.  循环回到开始，重复该过程。

让我们实际看看每一步发生了什么，以 `ls`（列出目录内容）命令为例，稍后你会在几页后看到它。现在，了解 `ls` 命令列出目录内容就足够了。

| **步骤** | **含义** |
| --- | --- |
| 1\. 读取输入 | 你输入 `ls` 命令并按 *Enter* 键。 |
| 2\. 评估命令 | shell 查找 `ls` 二进制文件，找到它后指示机器执行该命令。 |
| 3\. 打印输出 | `ls` 命令会输出一些文本——它找到的所有文件和目录的名称——然后 shell 会将这些输出打印到你的终端窗口。 |
| 4\. 循环回到第 1 步（重复该过程） | 当命令调用的程序退出后，通过接受更多的用户输入来重复该过程。 |

如果你再次阅读步骤 1-4，你会注意到每个步骤的第一个字母拼出了“REPL”，这是在那些发明并完善了这种工作流的语言（如 Lisp）中，常用来指代这种读取-评估-打印循环的方式。

用编程术语来说，你可以将上面的 REPL 指令翻译成代码：

```
while (true) { // the loop
  print(eval(read()))
} 
```

实际上，你可以使用大多数编程语言的几行代码创建一个能够进行基本计算的 REPL。以下是用 Perl 编写的单行“shell”程序：

```
perl -e 'while (<>){print eval, "\n"}'
1+2
3 
```

在这里，我们将代码写作一个参数，只要有输入可以读取，就会打印出评估后的输出。最后，我们添加一个新行并退出。

这个程序很小，但足够在命令行环境中实现一个交互式读评打印循环——一个**shell**。你在 Linux 和 Unix 中使用的 shell 比这个 Perl 小 shell 要复杂得多，但原理是相同的。

重点很简单：作为开发者，你可能已经在不自觉中使用 REPL，因为几乎所有现代脚本语言都会带有一个。实际上，Linux（或者 macOS、或其他 Unix 系统）命令行就像解释型语言提供的“交互式 shell”一样。所以即使你不熟悉 Lisp REPL，前面的 Perl 代码片段也应该会让你想起一个非常基础的 Ruby 或 Python shell。

现在你已经理解了将要在 Linux 中使用的命令行接口的基本机制，你准备好尝试你的第一个命令了。为此，你需要了解正确的命令行语法。

# 命令行语法（阅读）

所有的 REPL 都是通过读取一些输入来开始的。在 Linux 命令行中，shell 读取的命令需要具有正确的语法。命令的基本格式如下：

```
commandname options 
```

在编程术语中，你可以把命令名看作函数名，把选项看作传递给该函数的任意数量的参数。这一点很重要，因为并没有统一的语法来处理所有选项——每个命令都定义了它将接受哪些参数。正因如此，shell 对命令的正确性验证非常有限，除了检查命令是否映射到一个可执行文件。

**注意**

在本章中，“程序”和“命令”这两个术语可以互换使用。它们之间有一个非常细微的差别，因为一些 shell 内建命令是定义在 shell 代码中的，因此从技术上讲，它们并不是独立的程序，但你不需要担心这个区别——把这点留给 Unix 老手们去琢磨吧。

让我们深入探讨这个“命令 [选项]”语法的更复杂变体，你将会经常看到：

```
command [-flags,] [--example=foobar] [even_more_options ...] 
```

这是你在大多数 Linux 环境中看到的帮助文档中的常见格式，例如程序手册页（manpages），它相当简单：

+   `command` 是你正在运行的程序

+   方括号中的项是可选的，带省略号的方括号（`[xyz ...]`）表示你可以在此传递零个或多个参数

+   `-flags` 表示该程序的任何有效选项（在 Unix 中称为“标志”），例如 `-debug 或 -foobar`

有些程序还会接受参数的短版本和长版本，通常通过单短划线和双短划线来区分：例如 `-l` 和 `--long` 可能会执行相同的操作。然而，这种行为在命令之间并不一致；这种行为要求命令的创建者实现了短版本和长版本的参数，以设置相同的参数。

不是所有命令都会在调用时实现所有这些配置传递方式，但这些是你最常见的几种形式。

默认情况下，空格表示参数的结束，所以像大多数编程语言一样，包含空格的参数字符串必须使用单引号或双引号。你将在*第十二章*《使用 Shell 脚本自动化任务》中阅读更多相关内容。

在接下来的内容中，我们将跟随这一过程，了解 shell 如何解释你使用这种语法输入的命令，但首先，我们需要清楚地定义一下本章中我们使用的两个有时可以互换的术语：“命令行”和“shell”。

# 命令行与 shell

在本书中，我们提到的“命令行环境”是指任何作为 REPL 一种形式的文本环境，专门用于与操作系统、编程语言解释器、数据库等进行交互。“命令行”环境或界面描述了你与系统交互的一般方式。

但这里有一个更具体的术语，我们将在这里使用：shell。

shell 是一个特定的程序，它实现了这个命令行环境，并让你可以输入文本命令。技术上讲，有很多不同的 shell 提供相同类型的基于 REPL 的命令行环境，通常用于截然不同的目的：

+   Bash 是一个常见的 shell 环境，用于与 Linux 和 Unix 操作系统交互。

+   流行的数据库，如 Postgres、MySQL 和 Redis，都提供了 shell 供开发者与之交互并执行命令。

+   大多数解释型语言都提供 shell 环境，以加快开发速度。在这些环境中，有效的命令只是编程语言的语句。比如 Ruby 的 `irb`，Python 的交互式 shell 等。

+   Zsh（Z shell）是另一种操作系统 shell（类似 Bash），你可能会在一些开发者的笔记本上看到它，尤其是当他们自定义了环境设置时。

当我们在本书中提到 *shell* 时，我们指的是 Unix shell（通常是 Bash），它是一个专门设计用来让你与底层 Linux 或 Unix 操作系统进行交互的命令行界面。

## Shell 如何知道该运行什么？（评估）

在*读取*命令后，shell 需要对其进行*评估*，通过执行程序、获取一些信息或做其他对你实际有用的事情。

**注意**

这样详细描述 shell 工作原理可能一开始会显得冗长，但我们保证，当你需要解决因缺少或权限不正确的程序而产生的问题时，这些知识将派上用场。

当你在像 Bash 这样的 shell 中输入类似 `foobar -option1 test.txt` 的命令并按下 *Enter* 键时，以下几件事会发生：

1.  如果命令中指定了路径，它将被使用。路径可以有多种形式：

    +   一个完整的路径，比如命令 `/usr/bin/foobar -option1 test.txt` 中的 `/usr/bin/foobar`。

    +   相对路径，例如在命令`./foobar-option1 test.txt`中的当前工作目录（`.`表示当前目录，我们将在*绝对路径与相对路径*部分中讨论；此命令基本上表示“请执行我的当前目录中的“foobar”文件”）。

    +   路径可能基于变量和符号，也可能是：

        +   Shell 的环境（env vars）如`$HOME/foobar`，或者

        +   由 shell 提供，例如`~/foobar`（`~`字符表示“这个用户的主目录”）

1.  如果没有，shell 将检查是否知道`foobar`的含义：

    +   它可能是一个内置的 shell 命令。

    +   它可能是一个*别名*，用于设置命令的宏或快捷方式。

1.  如果没有，shell 通常会查看`$PATH`环境变量，该变量包含几个不同的位置用于检查命令：`/bin`、`/usr/bin`、`/sbin`等。用户可以向`$PATH`列表添加位置，各种软件将修改您的`$PATH`：脚本语言的版本管理器、Python 的虚拟环境以及许多其他程序大量使用这种机制。Shell 会按照`$PATH`变量中找到的顺序尝试这些指定的位置，以查看是否有包含名为`foobar`的可执行文件。

如果 shell 仍然找不到任何内容，它将返回一个错误，例如`bash: foobar: command not found:`。

另一方面，如果在任何时候 shell 确实找到名为`foobar`的可执行文件，它将执行该文件并将`-option1`和`test.txt`（按照顺序）作为参数传递。

此时，shell 知道要使用什么程序来评估命令，并执行。在评估命令时，将任何输出打印给用户，完成 REPL 过程的第三步。现在唯一剩下的就是回到开始并重新启动过程，接受用户的另一个命令作为输入。

Shell 尽最大努力猜测用户想要运行的程序，使用我们上面概述的一般过程来解决歧义。然而，歧义可能是一个坏事，会导致误解或错误。在故障排除过程中，您经常会想要找出实际运行的命令。为此，您可以使用命令`which <command>`，它将打印完整路径（或正在运行的别名或脚本），并告诉您该命令是否是 shell 内置的。在某些系统上，可能无法使用`which`命令。在这些情况下，您可以改用`command –v`。这是 POSIX 的等效命令，我们将在下面学习它：

```
bash-3.2$ which ls
/bin/ls
bash-3.2$ command -v ls
/bin/ls 
```

## POSIX 的简单定义

维基百科告诉我们，“**可移植操作系统接口**（**POSIX**）是 IEEE 计算机学会指定的一系列标准，用于在操作系统之间保持兼容性。”从实际角度来看，它试图在 Unix 系统之间定义一些共同的标准，否则这些系统可能具有完全不同的基本命令集。

POSIX 基本上是这样说的：“每个符合 POSIX 的操作系统应该有一个叫做 `ls` 的列表命令”；在这个例子中，“每个符合 POSIX 的操作系统应该有一种方法来检查是否存在与给定命令名匹配的可执行文件。”

如果你的脚本需要在不同的 Unix 操作系统间移植，限制自己只使用 POSIX 命令是一个好方法。然而，这仍然不能完全保证成功——许多非常流行的 Linux 发行版在多个方面偏离了 POSIX 大多数情况下，直到遇到问题时你才会意识到这些差异。

理解 POSIX 是你开始进行命令行实际操作之前需要打下的最后一块基石。到目前为止，我们已经覆盖了很多内容：

+   你已经了解了 REPL（读取-求值-输出循环），并看到这一基本过程如何映射到所有现代 shell 的工作方式。

+   我们探讨了你在使用 Linux 时将会用到的基本命令语法。

你了解了 shell 如何决定如何正确处理你的命令输入并“评估”它。你学到了许多重要的术语，你会经常遇到这些术语：shell、命令行界面、POSIX，以及一些如果现在学习了将会带来好处的术语。有了这些知识，你已经准备好从理论进入实践。在接下来的部分，我们将讨论你在执行命令时所处的 Linux 特定环境。你将学习 Linux 文件系统的基本知识，以及不同类型路径的工作方式。之后，本章的其余部分将专注于运行 Linux 命令！

# 基本命令行技能

要高效使用 Linux，你需要知道一些最基本的知识：系统的结构、如何在系统中查找和移动、以及如何读取和编辑文件。在本节中，我们将涵盖这些内容，并帮助你熟悉 Linux 系统的基本导航。

在本书的其余部分，我们将深入探讨每一个主题和命令，但我们希望确保你在本章结束时掌握一套最基本、能正常运作的技能。

## Unix 文件系统基础

在图形用户界面中，**目录**（在 macOS 中称为 *文件夹*）通过图标表示。也许你习惯了在你的主目录中看到这些小小整齐排列的图标——桌面、文档、视频等等。双击目录图标会打开一个新窗口，显示该目录内部的内容。

当我们使用“文件系统”这个术语时，我们指的正是这样——一个由目录和文件组成的集合，用来组织系统上的所有数据。在命令行环境中，底层的概念是完全相同的，只是它看起来有所不同。

你不会看到许多窗口和图标，一切都以文本的形式呈现，目录的内容只有在你请求时才会显示。然而，文件和目录依旧像你习惯的那样工作。

在你浏览文件系统时，刚开始时似乎很难记住它，但一旦你习惯了，这通常是处理计算机的更高效方式。经过几天的工作后，大多数人都能毫不费力地在工作时保持文件系统的详细视图，并且只偶尔验证这个视图。

## 绝对路径 vs. 相对路径

当初学者使用 Linux 时，他们常常被**绝对路径**和**相对路径**的区别所困扰。这个简单的误解导致了浪费大量时间盯着这样的错误：

```
No such file or directory 
```

由于你需要理解路径，作为你运行几乎每个 Linux 命令的前提条件，我们将首先讲解路径。

绝对路径是指从根目录开始，到文件系统中任何文件的完整路径。你可以通过它以`/`开始来识别这个路径，`/`引用了根目录（文件系统的最顶部或开头，包含所有其他文件和目录）。

下面是一些绝对路径的例子：

+   `/home/dave/Desktop`

+   `/var/lib/floobkit/`

+   `/usr/bin/sudo`

这些**绝对路径**就像一整套驾车路线，从已知的起点（比如你的公寓，或者在 Unix 系统中是根目录）给出逐步指引。

你可以通过它以“`/`”字符开始立即识别出绝对路径。无论你在文件系统中的哪个位置，绝对路径都会起作用，因为它们是完整的、唯一的文件对象地址。

**相对路径**是部分路径，默认假设它是从*当前目录*开始的，而不是从根目录开始的。你可以通过以下特点识别绝对路径：它*不*以`/`字符开始。

相对路径就像是使用当前位置作为起点的驾车路线。如果你迷路了，想要新的路线，你希望得到的是从*当前位置*出发的路线，而不是从你的家庭地址开始的路线。相对路径正是提供了这一点。

结果是，相对路径通常更方便输入：如果你已经在`/home/Desktop`目录下，引用文件时用`mydocument.txt`比用`/home/Desktop/mydocument.txt`要更简单（即使两种方式都是有效的，取决于你在文件系统中的位置）。真正的区别出现在你切换目录时。当你从`/home/Desktop`上移到`/home`时，绝对路径仍然引用相同的文件，而相对路径则不再引用（此时输入`mydocument.txt`会引用`/home/mydocument.txt`）。

想象一下这样的部分目录结构——在我们的例子中，我们假设这是`/home/dave/Desktop`的目录树列表：

```
Desktop
├── anotherfile
├── documents
│   └── contract.txt
├── somefile.txt
└── stuff
    ├── nothing
    └── important 
```

你现在坐在这个桌面目录中；换句话说，你的当前目录（你可以通过运行`pwd`命令看到）是`/home/dave/Desktop`。

这里有一些相对路径示例，指向该桌面目录中的文件：

+   `anotherfile`

+   `documents/contract.txt`

+   `stuff/important`

以下是这些相同文件的绝对路径：

+   `/home/dave/Desktop/anotherfile`

+   `/home/dave/Desktop/documents/contract.txt`

+   `/home/dave/Desktop/stuff/important`

你会注意到，相对路径实际上只是一个绝对路径，去掉当前工作目录的路径部分。

### 绝对路径与相对路径复习

回想我们的示例：

```
Desktop
├── anotherfile
├── documents
│   └── contract.txt
├── somefile.txt
└── stuff
    ├── nothing
    └── important 
```

现在假设你在一个 shell 环境中，当前工作目录是 `Desktop` 目录。你想列出 `contract.txt` 文件。你该如何引用该文件？你有两个选项：

1.  `ls /home/dave/Desktop/documents/contract.txt`：这是绝对路径，可以在任何地方使用。

1.  `ls documents/contract.txt`：这是相对于当前目录的该文件的路径。

### 打开终端

在 Ubuntu Linux 和 macOS 上，你可以通过打开“Terminal”应用程序进入命令行提示符。

## 环顾四周 – 命令行导航

作为初学者，当你打开一个 shell 时，你首先要做的就是浏览一下系统。在本节中，我们将介绍最重要的命令，用于在 shell 窗口中浏览和查看 Linux 环境。

话虽如此，让我们深入了解一些基本的 Linux 命令吧！

### pwd - 打印当前工作目录

`pwd` 代表“打印工作目录”，当你在终端中输入它时，shell 会打印出你当前所在的目录。Unix 文件系统通常被比作一棵树，但现在你可以把它当作一个凌乱的桌面，里面有很多目录。如果每个目录都像一个房间，`pwd` 让你看到当前命令行环境所在的房间。

新的 shell 会话通常从你的主目录开始。如果你在 Linux 上操作，它看起来可能是这样的：

```
![](img/Tab-01-01.png)  ~ pwd
    /home/dave 
```

如果你正在运行其他版本的 Unix，它可能会稍有不同。以下是在 macOS 上你会看到的内容：

```
![](img/Tab-01-01.png)  ~ pwd
    /Users/dave 
```

无论你在文件系统中的位置如何，你仍然可以引用所有目录中的文件（请参阅本章中的 *绝对路径与相对路径* 部分），但有时四处移动会更容易些。我们将在后面的章节中详细介绍文件系统结构。

### ls - 列出

`ls` 让你“列出”目录中的文件。如果你不带任何参数运行此命令，它将列出当前目录中的文件和目录。如果你传入一个目录的路径作为参数，它会尝试查看该目录中的内容并列出来：

```
ls /var/log 
```

List 也可以接受参数（“标志”）。有很多标志，但两个常用的标志是 `-l`（“长格式”）和 `-h`（“人类可读格式”）。

```
ls -l -h
# same thing; you can combine flags
ls -lh
# List a specific directory
ls -lh /usr/local/ 
```

长列表将产生以下输出格式：

```
-rw-r--r--  1 dcohen  wheel   0 Jul  5 09:27 foobar.txt 
```

让我们逐列查看：

+   `-rw-r--r--`：文件类型（第一个字符）和权限（三个三位数，分别表示拥有用户、拥有组和系统中其他所有用户的权限）。

+   `1`：对该文件的引用次数（硬链接数量）。

+   `dcohen`：拥有此文件的用户。

+   `wheel`：拥有此文件的组。

+   `0`：文件所占用的磁盘空间（此文件为空）。`-h` 标志将默认的字节数输出改为“人类可读”的形式，即在适当情况下显示为兆字节或吉字节。

+   `Jul 5 09:27`：文件的修改时间。

+   `foobar.txt`：文件名。

这会显示需要一些我们尚未涵盖的知识（用户、组和权限）的输出。没关系——我们会在*第七章*，“用户和组”中讲解。

## 移动位置

现在你已经学习了最基本的 Linux 命令来帮助你定位自己，接下来我们来聊聊如何在命令行环境中导航到你想去的地方。

### cd – 改变目录

`cd` 让你可以“改变目录”，前往文件系统中的任何地方。借用之前的房间隐喻，这就相当于从当前房间传送到另一个房间。

成功改变目录后，`pwd` 命令将显示你新的（更新后的）位置：

```
bash-3.2$ cd /etc/ssl
bash-3.2$ pwd
/etc/ssl
bash-3.2$ ls
README  cert.pem  certs  misc  openssl.cnf private
bash-3.2$ cd certs
bash-3.2$ pwd
/etc/ssl/certs 
```

### find – 查找文件

`find` 允许你搜索文件。它是少数几个不遵循长选项（例如`--name`）约定的命令之一。相反，它的标志是通过单个短划线指定的。以下是一个示例：

```
bash-3.2$ find / -type d -name home
/home
... 
```

上述命令会在 `/`（整个系统）中搜索一个名为 `home` 的目录（`-type d`）。请记住，当你不是以拥有超级权限的 root（管理员）身份执行此操作时，`find` 可能没有权限列出许多目录的内容，因此你将收到类似 `find: '/root': Permission denied` 的输出，除此之外还会列出找到的内容。

另一个常见的用例是根据 `find` 输出执行命令：

```
bash-3.2$  find . -exec echo {} \;
.
./foobar 
```

这将运行 `echo` 命令，并将找到的文件替换为 `{}`。结果输出将类似于运行 `ls` 命令。

如果我们希望将每个找到的文件作为参数传递给`echo`，而不是为每个文件运行`echo`，可以用`+`代替`\`。

```
bash-3.2$  find . -exec echo {} +;
. ./foobar 
```

`find` 还有许多其他标志。具体哪些标志可用，取决于你的操作系统所提供的 `find` 版本。

下面是一些典型的使用案例：

+   `find -iname foobar`：搜索 `foobar`，忽略大小写

+   `find -name "foobar*"`：搜索以 `foobar` 开头的文件

+   `find -name "*foobar"`：搜索以 `foobar` 结尾的文件

## 阅读文件

现在你已经学会了如何找到你要的文件，接下来我们来看看如何在命令行中实际阅读文件内容。

### less – 翻阅文件

`less` 允许你一次阅读文件的一“页”（基于你的终端窗口大小）。

```
less somefile.txt 
```

运行 `less` 会打开文件，并允许你逐行（上下箭头键）或逐页（空格键）滚动查看。

要在文件内搜索，输入 `/`，然后输入你的搜索字符串，按 *Enter* 键。用 `n`（下一个）和 `SHIFT-n`（上一个）来导航匹配项。

要退出，输入 `q`。

## 修改操作

现在你可以查找和读取文件，接下来我们来看看如何修改文件或创建新文件。

### touch – 创建一个空文件，或者更新现有文件的修改时间

`touch` 创建一个文件，因此需要一个文件路径作为参数。如果你提供的路径还不存在（并且假设你有权限），将在该路径下创建一个空文件。

如果指定路径下的文件已经存在，它的访问时间和修改时间将更新为当前时间。如果你只想更新访问时间或修改时间，可以分别使用 `-a` 或 `-m` 标志。

### mkdir – 创建目录

`mkdir` 需要一个文件路径参数，并利用它来创建（“制作”）目录：

```
bash-3.2$ mkdir foobar
bash-3.2$ ls
foobar 
```

可选地，如果你想创建多个目录，可以提供额外的参数：

```
bash-3.2$ mkdir foo bar baz
bash-3.2$ ls
foo
bar
baz 
```

如果你想创建多个嵌套的目录（或者你只是想确保它们都存在），可以使用 `-p` 标志：

```
bash-3.2$ mkdir -p /var/log/myapp/error
bash-3.2$ ls /var/log/myapp
error 
```

即使 `/var/log/myapp` 之前不存在，使用 `mkdir` 和 `-p` 标志也会确保创建 `/var/log/myapp`，然后再在其中创建 `/var/log/myapp/error`。另一方面，如果你给 `mkdir -p` 的路径中的某个目录已经存在，`-p` 不会对它造成任何影响，所以可以安全地多次运行（“幂等”）。这使得 `-p` 标志成为脚本使用中的标准。

### rmdir – 删除空目录

`rmdir` 删除空目录。为了使此命令生效，目录必须为空，这意味着它是一个相对安全的命令。大多数 Linux 用户最终还是使用 `rm`，因为它可以完成相同的任务。

### rm – 删除文件和目录

要删除一个文件，请使用 `rm` 命令：

```
rm filename 
```

在实践中，大多数人也使用 `rm` 来删除目录，因为与 `rmdir` 不同，它可以删除*非*空的目录。你需要使用 `-r` 标志来*递归*地应用命令（对你正在删除的目录包含的所有目录），并使用 `-f` 标志来“强制”删除，而不需要每次确认每个文件和目录：

```
rm –rf /path/to/directory 
```

**注意**

在使用 `rm -rf` 时要非常小心，因为 Linux 允许你删除对系统操作至关重要的目录。例如，`rm -rf /` 告诉 `rm` 你希望删除根目录，根目录包含系统上的所有内容。

一些 Linux 发行版和 Unix 操作系统通过创新的方式解决了这个问题（Ubuntu 提供了一个带有`--no-preserve-root`选项的`rm`命令，作为一种询问“你*确定*要这样做吗？”的方式，而 Solaris 故意对`rm`的功能做了宽松解释，以避免删除根目录）。实际上，这些保护措施很容易绕过。在使用`rm`时要小心，并且在将命令从互联网上粘贴到你的 shell 中时要特别注意！

### mv – 移动或重命名文件和目录

`mv`是一个聪明的命令，因为它可以使用相同的语法做两种不同的事情。它可以将文件从一个目录“移动”到另一个目录，或者——另外——它可以重命名一个文件，并将其保留在同一目录下。

首先，我们将使用`touch`命令创建一个文件：

```
bash-3.2$ touch foobar.txt
bash-3.2$ ls
foobar.txt 
```

然后，我们将在原地重命名文件：

```
bash-3.2$ mv foobar.txt foobarbaz.txt
bash-3.2$ ls
foobarbaz.txt 
```

请注意，上述命令会覆盖任何已存在的名为`foobarbaz.txt`的文件，如果存在的话，所以在重命名时要小心。

要将文件移动到新目录，我们将创建一个新目录，然后将文件移到那里：

```
bash-3.2$ mkdir targetdir
bash-3.2$ mv foobarbaz.txt targetdir/
bash-3.2$ ls targetdir/
foobarbaz.txt 
```

你还可以将这些操作结合起来。如果你想将文件移动到另一个目录*同时*重命名它，可以这样做：

```
bash-3.2$ mv foobarbaz.txt targetdir/renamed.txt
bash-3.2$ ls targetdir/
renamed.txt 
```

# 获取帮助

除了最基本的环境之外，大多数环境都会提供手册页（manpages），它们是你可以用来学习（或记住）如何使用你可用的命令行程序的文档。

使用`man $COMMANDNAME`来获取命令的信息。例如，`man ls`将打印出类似以下内容：

```
LS(1)                                                    General Commands Manual                                                   LS(1)
NAME
     ls – list directory contents
SYNOPSIS
     ls [-@ABCFGHILOPRSTUWabcdefghiklmnopqrstuvwxy1%,] [--color=when] [-D format] [file ...]
DESCRIPTION
     For each operand that names a file of a type other than directory, ls displays its name as well as any requested, associated
     information.  For each operand that names a file of type directory, ls displays the names of files contained within that directory,
     as well as any requested, associated information.
     If no operands are given, the contents of the current directory are displayed.  If more than one operand is given, non-directory
     operands are displayed first; directory and non-directory operands are sorted separately and in lexicographical order.
     The following options are available:
     -@      Display extended attribute keys and sizes in long (-l) output.
     -A      Include directory entries whose names begin with a dot ('.') except for . and ...  Automatically set for the super-user
             unless -I is specified. 
```

由于手册页面会自动打开在一个分页程序中，滚动、搜索和退出都可以使用你习惯的`less`命令中的快捷键。

请记住，`man`是一个古老的工具，它尽力模仿一本实际的书籍，分为不同的章节，涵盖不同的主题。在上面的示例中，`ls(1)`中的`(1)`表示我们正在查看的手册章节。

有时，具有相同名称的手册页可能会存在于不同的章节中。要指定某个章节，可以在命令名称前添加数字。例如，要查看与上述相同的手册，你可以运行`man 1 ls`。

大多数类 Unix 操作系统的手册章节如下：

1.  常用命令，这些是你通常在命令行中运行的命令

1.  系统调用

1.  库函数，涵盖 C 标准库

1.  特殊文件（通常是设备文件，位于`/dev`目录下）和驱动程序

1.  文件格式和约定。这包括配置文件

1.  游戏和屏幕保护程序

1.  杂项

1.  系统管理命令和守护进程

所以，如果你想深入了解本书中涉及的某个主题，你很可能会从查看手册页的第 1、5 和 8 章开始。

如果你不确定要查找的手册页面名称是什么，可以使用`apropos <keyword>`或`man -k <keyword>`来查找。它会打印出所有包含指定关键词的手册页面列表。

# Shell 自动补全

如果你在一个交互式 Shell 会话中（即，不是从脚本执行或创建 Dockerfile），你可以使用**Shell 自动补全**，也称为**Tab 补全**，通过更少的按键和更低的拼写错误概率来构建命令。

要使用 Shell 自动补全，开始输入一个文件或目录名称并按*Tab*键。Shell 将逐步缩小你的选择范围，显示你输入行下方的可能匹配项。当根据你输入的内容，只剩下一个选项时，Shell 会自动完成该命令或参数，你可以按*Enter*键执行。让我们看一个示例。

如果你在 Linux 桌面系统的主目录下，界面可能看起来像这样：

```
![](img/Tab-01-01.png)  ~ pwd
/home/dave
![](img/Tab-01-01.png)  ~ ls
Desktop
Documents
Downloads
Library
Movies
Music
Pictures
Public
code
go 
```

如果你想进入`Documents`目录，你可以使用`cd`（切换目录）命令来实现：

```
![](img/Tab-01-01.png)  ~ cd Documents 
```

首先，输入`cd D`并按*Tab*键：

```
![](img/Tab-01-01.png)  ~ cd D
Desktop/    Documents/  Downloads/ 
```

你会看到，Shell 已将十个可能的选项缩小为三个。再输入一个字母并按*Tab*键，你将看到只有两个匹配项：

```
![](img/Tab-01-01.png)  ~ cd Do
Documents/  Downloads/ 
```

输入另一个字母`c`，这将把选择范围缩小到只有一个选项，再按一次*Tab*键即可自动完成目录名称：

```
![](img/Tab-01-01.png)  ~ cd Documents/ 
```

一旦你完成了目录名称的自动补全，你可以像平常一样按*Enter*键执行命令，或者继续在该目录内进行自动补全。例如，在这里按一次*Tab*键将重新开始在`Documents`目录内的自动补全过程，保留`Documents/`前缀，并自动完成斜杠右侧的有效项。直到你有一个有效路径并按下*Enter*键，Shell 的当前工作目录才会改变。

这个小技巧将为你节省大量的输入时间。越早开始使用它越好！

# 结论

在这一章中，你学习了在命令行上高效工作之前需要了解的所有基本理论。你看到了命令行语法的实际示例，并学习了大多数命令如何接受参数的基础知识。

我们还介绍了 Shell 的概念，并演示了在你输入命令并按下*Enter*键后，如何查找可执行文件。令人惊讶的是，许多高级用户并不完全理解这两个概念，这会影响他们快速高效地使用命令行环境。

最后，你已经学会了在命令行系统中移动的最重要基本命令。你几乎每次操作 Linux 系统时都会使用这些命令——它们代表了任何人在进一步深入学习之前都必须掌握的绝对基础。你甚至学会了第一个省时技巧——Shell 自动补全。

如果你正在跟随并尝试在一个真实的 Linux 系统上操作（你*应该*这么做！），确保在进入下一章之前练习几分钟你所学到的内容。我们将在本书的其余部分建立在这些知识之上。

# 在 Discord 上了解更多

要加入本书的 Discord 社区 —— 在这里你可以分享反馈、向作者提问，并了解新版本发布 —— 请扫描下面的二维码：

[`packt.link/SecNet`](https://packt.link/SecNet)

![](img/QR_Code17684224202100941871.png)
