- en: '15'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Using awk – Part 2
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we’ll continue the discussion about `awk`, but from a different
    perspective. In the previous chapter, I showed you the basics of creating one-line
    `awk` commands that you can use in your normal shell scripts. In this chapter,
    I’ll show you a bit about how to write `awk` scripts in the `awk` language. Topics
    in this chapter include:'
  prefs: []
  type: TYPE_NORMAL
- en: Basic `awk` script construction
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using conditional statements
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using a `while` construct and setting variables
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using for loops and arrays
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using floating point math and `printf`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Working with multi-line records
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If you’re ready, let’s dig in.
  prefs: []
  type: TYPE_NORMAL
- en: Technical Requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'You can use either a Fedora or Debian virtual machine for this. And, as always,
    you can grab the scripts by doing:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Basic awk Script Construction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let’s begin with the simplest `awk` script that you can imagine, which we’ll
    call `awk_kernel1.awk`. It looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: As you’ve likely guessed, this script will look through a specified file to
    search for all lines that contain the text string `kernel`. You already know that
    `{print $0}` is the default action if no action is specified. So, this script
    will print out every line that contains the specified text string.
  prefs: []
  type: TYPE_NORMAL
- en: 'In actual `awk` scripts, there’s no need to preface every command with `awk`,
    and there’s no need to surround the commands with pairs of single quotes, as you
    have to do when embedding `awk` commands in normal shell scripts. I didn’t put
    a shebang line into this script, so there’s no need to set the executable permission.
    Instead, just invoke the script like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Sure, that works. But, wouldn’t you really rather have a stand-alone, executable
    script? That’s easy enough to do. Just add the shebang line, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Then, make the script executable, the same as you would do with normal `bash`
    scripts.
  prefs: []
  type: TYPE_NORMAL
- en: There are two things that I want you to notice about this shebang line. First,
    is that I’m using `/usr/bin/` instead of `/bin/` as the path to the `awk` executable.
    That’s because I want to make this script portable, so that it will run on Linux,
    Unix, and Unix-like systems such as FreeBSD and macOS.
  prefs: []
  type: TYPE_NORMAL
- en: The `/bin/` path that you’re used to seeing in shebang lines is an artifact
    that’s been carried over from older Linux systems. On current Linux systems, `/bin/`
    is a symbolic link that points to `/usr/bin/`. On older Linux systems, `/bin/`
    and `/usr/bin/` used to be two separate directories, which each contained two
    separate sets of program files. That’s no longer the case. Nowadays, you’ll find
    the `awk` executable in `/usr/bin/` on all Linux systems.
  prefs: []
  type: TYPE_NORMAL
- en: FreeBSD still uses separate `/bin/` and `/usr/bin/` directories with different
    sets of program files. But, `awk` is in `/usr/bin/`, and there’s no symbolic link
    for it in `/bin/`. So, just use `#!/usr/bin/awk`, and you’ll be good-to-go for
    most operating systems.
  prefs: []
  type: TYPE_NORMAL
- en: The second thing to notice is that I still have to invoke `awk` with the `-f`
    option, which causes `awk` to read the program file. If you leave out the `-f`,
    the script won’t work.
  prefs: []
  type: TYPE_NORMAL
- en: Now that you’ve seen the basic structure of an `awk` script, let’s look at some
    `awk` programming constructs.
  prefs: []
  type: TYPE_NORMAL
- en: Using Conditional Statements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'You’ve already been using `if` constructs without even knowing it. That’s because
    you don’t have to explicitly declare them as such. The simple `/kernel/` command
    that you just saw in the `awk_kernel1.awk` script means that if the *kernel* string
    is found on a line, then print that line. However, `awk` also offers the whole
    array of programming constructs that you would expect to see in other languages.
    For example, let’s create the `awk_kernel2.awk` script, which will look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: This is somewhat different from what you’re used to seeing in `bash` scripts,
    because in `awk` there’s no need to use `then` or `fi` statements. This is because
    `awk` uses C language syntax for its programming constructs. So, if you’re used
    to programming in C, rejoice!
  prefs: []
  type: TYPE_NORMAL
- en: 'Also, note how you need to surround the pattern with a pair of parentheses,
    and how you have to surround the entire multi-line script with a pair of curly
    braces. At any rate, just specify the name and location of your log file when
    running the script, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, you’re probably wondering why anyone would want to do the extra typing
    to create a full-blown `if` construct when just typing `/kernel/` will do the
    job. Well, it’s so that you can create full-blown `if. .else` constructs, like
    this one in the `awk_kernel3.awk` script:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let’s see how many times each type of message shows up in the log file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Cool, it works.
  prefs: []
  type: TYPE_NORMAL
- en: 'For our final `if` trick, let’s create the `awk_kernel4.awk` script, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'The Number of Records (`NR`) built-in variable causes the line numbers to print
    out along with the messages. There will be lots of output, so you might want to
    pipe it into `less`, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Here’s a sample of the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Okay, I think you get the idea. Other than the different syntax, it’s really
    no different from using `if` in normal `bash` scripts. So, let’s move on for a
    while.
  prefs: []
  type: TYPE_NORMAL
- en: Using a while Construct and Setting Variables
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, I’ll show you two new concepts at once. You’ll see how to use
    a `while` loop, and how to use `awk` programming variables. Let’s begin with something
    simple.
  prefs: []
  type: TYPE_NORMAL
- en: Summing Numbers in a Line
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this scenario, we have a file with several lines of numbers. We want to
    add the numbers on each line and show the sum for each line. First, create the
    input file and make it look something like this `numbers_fields.txt` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'This looks like quite a challenging task because each line has a different
    number of fields. But, it’s actually quite easy. Here’s the `add_fields.awk` script
    that does the job:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: The first thing I’ve done is to initialize the `addend` and `sum` variables.
    The `addend` variable represents the field numbers. By initializing it to a value
    of `1`, the script will always begin at the first field of every line. The `sum`
    variable is initialized to `0`, for obvious reasons. The `while (addend <= NF)`
    line causes the `while` loop to execute until it reaches the last field in a line.
    (The built-in `NF` variable holds the number of fields in a given line.) In the
    next line, using `$addend` is the same as listing a field number, such as `$1`
    or `$2`. So, as you might expect, `$addend` returns the value that’s contained
    in a given field. By using a variable in place of a hard-coded field number, we
    can use the `addend++` command in the next line to advance to the next field in
    a line. (This `variable++` construct increments the value of the variable by 1,
    the same as it does in C.)
  prefs: []
  type: TYPE_NORMAL
- en: If you’re a bit confused by this, allow me to clarify.
  prefs: []
  type: TYPE_NORMAL
- en: Unlike in normal shell scripting, in `awk`, you don’t preface the name of a
    variable with a `$` to call back its value. In `awk`, the `$` is instead used
    to reference the number of a field. So, prefacing a variable name with a `$` in
    `awk` just means that you’re referencing the field number that’s been assigned
    to that variable.
  prefs: []
  type: TYPE_NORMAL
- en: 'After the `while` loop finishes, the script prints out its message, with the
    sum of all the numbers on a line. Then, it returns to the beginning of the script
    and keeps going until all lines in the file have been processed. Here’s what the
    output looks like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'It works, so everything is cool. Now, let’s fancy things up a bit. Let’s add
    a line that will produce the average of the numbers on each line and format the
    output. Name the file `average_fields.awk`, and make it look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'What’s so cool about this is that I can use the `NF` built-in variable in math
    operations. In this case, I’m just dividing the sum of each line by the number
    of fields in each line. The output looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: If you’re used to C programming, understand that there’s a difference between
    how `awk` and C use variables. Unlike in C, it’s not necessary to declare `awk`
    variables before you use them. But, it is sometimes necessary to initialize them
    to a certain value before you use them. Also, unlike in C, there’s only one variable
    type in `awk`. All `awk` variables are of the string type, and all `awk` math
    operators automatically recognize numerical values that these variables might
    represent.
  prefs: []
  type: TYPE_NORMAL
- en: Next, let’s look at something a bit more complex.
  prefs: []
  type: TYPE_NORMAL
- en: Finding the CPU Generation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let’s consider another scenario. You have an old server that’s powered by an
    AMD Opteron CPU. You just tried to install Red Hat Enterprise Linux 9 (RHEL 9)
    on it, and you can’t get it to work. What could be the problem?
  prefs: []
  type: TYPE_NORMAL
- en: 'Well, it’s just that your trusty Opteron CPU is too old, which means that it
    lacks certain capabilities that newer CPUs have. Ever since AMD created the first
    64-bit x86 CPUs in 2003, both AMD and Intel have kept adding new capabilities
    to their newer models. In 2020, representatives from Intel, AMD, Red Hat, and
    SUSE got together and defined the four generations of x86_64\. Each successive
    generation has capabilities that aren’t in the previous generations. Here’s a
    list of when each generation was introduced:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Generation 1: 2003'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Generation 2: 2009'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Generation 3: 2013 for Intel, 2015 for AMD'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Generation 4: 2017 for Intel, 2022 for AMD'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Software that was created for a first generation x86_64 CPU will also run fine
    on the three newer generations. But, if you have a newer CPU, you can make things
    run faster by using software that was optimized for it. Of course, that means
    that it won’t run on the older CPUs. So, if you’re still running a first generation
    x86_64 CPU, you won’t be able to run either RHEL 9 or any of its clones. (Rumor
    has it that RHEL 10, which should be out sometime in 2025, will require at least
    a third generation x86_64 CPU. You’ll find a link to the rumor in the *Further
    Reading* section.) That’s actually okay, because Red Hat’s target customers are
    the large enterprises that upgrade their gear on a regular basis.
  prefs: []
  type: TYPE_NORMAL
- en: This makes it very unlikely that any of them still run any of these first generation
    machines. This doesn’t really affect normal home users of desktop Linux, because
    very few home users use either RHEL or a RHEL clone for that purpose, and most
    non-RHEL distros still support the old machines. So, how do you know which generation
    your CPU is? That’s easy. Just write a script.
  prefs: []
  type: TYPE_NORMAL
- en: 'To get an idea of how this works, look in the `/proc/cpuinfo` file, and scroll
    down to the `flags` section. What you’ll see depends upon which generation of
    x86_64 CPU is in your machine. Here on my 2012-model Dell workstation with an
    Intel Xeon CPU that’s of the second generation x86_64 variety, the `flags` section
    looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'On my vintage 2009-model Hewlett-Packard machine with a pair of first generation
    Opteron CPUs, the `flags` section looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'You see here that the second generation CPU in my Dell has newer capabilities,
    such as `sse4_1`, `sse4_2`, and a few others that aren’t in the old Opterons.
    On a Linux system, you can create either a `bash` script or an `awk` script that
    will automatically parse the `/proc/cpuinfo` file to determine the generation
    to which your CPU belongs. Here’s the `x86_64_check.awk` script, which I borrowed
    from a post on the StackExchange site:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: The first thing to note is that the whole script needs to be part of a `BEGIN`
    block. That’s because we need to process the whole `cpuinfo` file at once, instead
    of just one line at a time as `awk` would normally do. The `BEGIN` block helps
    us out with that.
  prefs: []
  type: TYPE_NORMAL
- en: Then, note that this script uses a different style for the `if` constructs.
    Instead of formatting them in the C language style as I showed you before, the
    author instead placed each `if` construct on its own line. Each style works equally
    well, and I’ll leave it to you to decide which one you like better. Anyway, here’s
    the breakdown of how it all works.
  prefs: []
  type: TYPE_NORMAL
- en: At the end of each of the first four `if` statements, the `level` variable is
    set to a new value.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The first `if` statement looks for capabilities that are in the first generation,
    and then assigns `1` as the value of `level`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The second `if` statement verifies that the CPU contains level 1 capabilities,
    looks for another set of capabilities that are in second generation CPUs, and
    then assigns `2` as the value of `level`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The process repeats for the third and fourth `if` statements, in order to detect
    either third or fourth generation CPUs.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Finally, the fifth `if` statement verifies that the value of `level` is greater
    than `0`, prints out the message, and then exits the script with an exit code
    that’s the value of `level` plus 1.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `exit 1` line at the end causes the script to exit with exit code `1` if
    the script fails to run correctly for whatever reason. (The `level + 1` command
    at the end of the fourth `if` statement prevents a successful run of the program
    from returning a `1` for the exit code. Remember, `1` is normally an exit code
    for a program that doesn’t run correctly.)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'An interesting thing about `awk` variables is that all of them are string variables,
    which greatly simplifies the coding process. If you assign the value of `1` to
    the `level` variable, the value is stored as a string instead of as an integer.
    But, when you use variables to perform math operations in `awk`, everything works
    correctly because `awk` automatically recognizes when a string is really a number.
    Also, unlike `bash`, `awk` can natively perform floating point math operations.
    So, you can perform math operations much easier and faster in `awk` than you can
    in either `bash` scripting or a normal programming language. To demonstrate this,
    let’s run this script on my both of the workstations that I currently have running.
    Here’s what it looks like on my old Opteron-powered Hewlett-Packard:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'As expected, the script shows that this is a first generation x86_64 machine.
    The `echo $?` command shows the exit code, which was created by the `level + 1`
    command in the script. Now, here’s how it looks on my Xeon-powered Dell:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: So yeah, everything works fine.
  prefs: []
  type: TYPE_NORMAL
- en: Ah, but wait. We’re not done yet, because I haven’t yet explained the `while`
    construct. It’s a bit tricky, so I saved it for last.
  prefs: []
  type: TYPE_NORMAL
- en: 'I’ve already shown you that in the `/proc/cpuinfo` file, the strings that you
    seek are in the stanza with the text string `flags` in the first field. But, the
    `while (!/flags/)` statement makes it appear that we’re *not* looking for the
    `flags` stanza. (Remember that the `!` is a negation operator.) To understand
    what’s really going on, view the entire `cpuinfo` file by entering `cat /proc/cpuinfo`.
    You’ll see that the same set of information prints out once for every CPU core
    in your system. For example, my Dell workstation is running with an octo-core
    Xeon. Hyperthreading is enabled, which means that I have a total of 16 virtual
    CPU cores. So, running `cat /proc/cpuinfo` causes the same CPU information to
    print 16 times. You’ll also see that several more stanzas of information print
    out after the `flags` stanza. To understand how this `while` loop works, run the
    following one-line `awk` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: The `flags` stanza is actually just a single long line that wraps around on
    both your terminal and on the printed page. So, `awk` treats the `flags` line
    as a single record. The `while (!/flags/)` statement in this command causes `getline`
    to read the `cpuinfo` file until it encounters the first `flags` string. This
    means that the CPU information for only the first CPU core will show up, and any
    information that comes after the first `flags` line will not show up. (Yeah, it
    looks a bit confusing, but it makes total sense when you think about it.)
  prefs: []
  type: TYPE_NORMAL
- en: In the original script, the `if (getline < "/proc/cpuinfo" != 1) exit 1` that’s
    within the `while` loop does two things for us. First, it uses the `!=1` parameter
    to check for the existence of the `cpuinfo` file. If `!=1`, which is the same
    as saying *not true*, evaluates to *true,* then the script will exit with exit
    code `1`.
  prefs: []
  type: TYPE_NORMAL
- en: If the `!=1` parameter evaluates to *false*, which would mean that the file
    exists, then `getline`, a built-in `awk` function, will read in the `cpuinfo`
    file. This way, if you run this script on an operating system that doesn’t have
    a `/proc/cpuinfo` file, such as FreeBSD, it will gracefully exit.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, some of you might prefer using C-style syntax to make the script a bit
    more readable. Fortunately, that’s easy to do. Changing the style makes the script
    too long to show here in its entirety, but I can show you a snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: If you want to see the converted script in its entirety, just download the `x86-64-level_check2.awk`
    file from GitHub.
  prefs: []
  type: TYPE_NORMAL
- en: I believe that we’re done with this script. Let’s see what we can do with a
    `for` loop and an array.
  prefs: []
  type: TYPE_NORMAL
- en: Using for loops and Arrays
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Certain languages, such as Spanish and French, have the concept of masculine
    and feminine nouns. For this demo, we’ll work with a list of English nouns, their
    Spanish equivalents, and the gender designations for the Spanish nouns.
  prefs: []
  type: TYPE_NORMAL
- en: Why is someone with a French last name creating a list of Spanish words? Well,
    it’s just that despite my French ancestry, I chose to learn Spanish instead of
    French in high school. So, I do know some Spanish, but I don’t know French. (I
    know, I’m weird.) Also, I realize that the Spanish word *camiόn* has an accent
    over the last syllable. Alas, inserting accents with an English-language keyboard
    isn’t easily done in a plain-text file, at least not without messing up how the
    `awk` script works.
  prefs: []
  type: TYPE_NORMAL
- en: 'To begin, create the `spanish_words.txt` file, and make it look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: As you see, we’re using colons as field separators, and using either M or F
    to designate if a word is masculine or feminine. The first line is a header, so
    we’ll need to take that into account when we process the file.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, create the `masc-fem.awk` script, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'In the `BEGIN` section, we’re setting the `:` as the field separator. The `NR
    == 1 {next}` line means to ignore line 1 and move on to the next line. The next
    two lines build the `masc` and `fem` arrays. Any line that has an `M` in field
    3 goes into the `masc` array, and any line that has an `F` in field 3 goes into
    the `fem` array. The `END` section contains code that will run after the code
    in the main body has finished building the arrays. The two `for` loops work the
    same as you saw with the normal shell scripting `for` loops, except that we’re
    now using C language syntax. The first loop prints out the list of masculine nouns
    and uses the `count` variable to add up the total of masculine nouns. The second
    loop does the same for the feminine nouns, except that it uses the `count2` variable
    to total the number of feminine nouns. Running the script looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: And, that’s all there is to it. Easy, right?
  prefs: []
  type: TYPE_NORMAL
- en: For our next trick, let’s do some floating-point math.
  prefs: []
  type: TYPE_NORMAL
- en: Using Floating Point Math and printf
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'For some strange reason, you’ve found yourself working a job that requires
    you to keep track of weather-related statistics. Your boss has just sent you a
    text file that contains a list of temperatures. Some of the temperatures are Celsius
    temperatures, and some are Fahrenheit temperatures. Your assigned task is to convert
    the Fahrenheit temperatures to Celsius temperatures. You can do that the hard
    way by using a calculator to manually convert each Fahrenheit temperature, or
    you can write a script that will automate the process. You’ve decided that it
    would be easier to write a script. The list of temperatures is in the `temps.txt`
    file, which looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: The first three temperatures are checks to verify that the script works correctly.
    We know that 32 degrees F equals 0 degrees C, that 212 degrees F equals 100 degrees
    C, and finally that -40 degrees F equals -40 degrees C. If the script converts
    those three temperatures correctly, we can be reasonably sure that the rest of
    the temperatures are getting converted correctly.
  prefs: []
  type: TYPE_NORMAL
- en: Be sure that you haven’t inserted a blank line after the last temperature line,
    or else the script will insert non-sense information after the last actual line
    of output data.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two ways to express the conversion formula. Here’s one way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Here’s the other way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: The `$1` represents the field that holds the original Fahrenheit temperature.
    So, we begin by subtracting 32 from the Fahrenheit value.
  prefs: []
  type: TYPE_NORMAL
- en: 'Either formula works equally well, so it really doesn’t matter which one we
    use. Just for fun, I’ll use the first method in the `fahrenheit_to_celsius.awk`
    script, which looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'As you see, it’s just a simple one-liner. The `NR==1` causes the header to
    print out, and the `NR>1` ensures that the conversions are performed only on the
    lines that contain actual data. The combination of the `?` and the `:` in the
    `print` action is known as a **ternary operator**. If the first term (`$2=="F"`)
    evaluates to true, then the original value of field 1 will be replaced by the
    value that’s between the `?` and the `:`. In this case, the new value is derived
    from performing the conversion calculation. After the new temperature value on
    each line, we want to print out a pair of tabs, followed by the word Celsius.
    Here’s what happens when I run the script:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: That doesn’t look so good, because some of the Celsius values are longer than
    the others, which causes the second column of those lines to not line up correctly.
    We’ll fix this by using `printf` instead of `print`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `printf` command allows you to customize the output in ways that you can’t
    do with `print`. It works pretty much the same way in `awk` as it does in C, so
    once again you C programmers can rejoice. Here’s how the solution works in the
    `fahrenheit_to_celsius2.awk` script:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'The `%` signs in the `printf` command represent formatting directives. Let’s
    take the `%-11s` directive, which formats the first field in each line. The `-`
    tells `printf` to left-justify the output. (By default, the output is right-justified.)
    The `11s` tells `printf` to allocate 11 spaces for the first field of output.
    If the string in any given line is less than 11 characters long, then `printf`
    will pad the output with enough blank spaces to make up the difference. Finally,
    `%s\n` causes `printf` to print out the designated text string as the second field,
    followed by a newline. (Unlike `print`, `printf` doesn’t automatically add a newline
    at the end of a line.) Anyway, here’s the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'Yes, that looks much better. But, what if you don’t need to see all of those
    decimal places? Easy, just use a different formatting directive for the first
    field, as you see here in the `fahrenheit_to_celsius3.awk` script:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, I’m using `%.2f` to format the output as a floating point number with
    only two digits after the decimal point. Here’s how the output looks:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: The only slight catch is that now the second column doesn’t line up correctly.
    You can’t use two directives together for a single field, so we’ll just have to
    live with it like this. That’s okay though, because if you decide to redirect
    this output into a file, you’ll still be able to import it into a spreadsheet
    program.
  prefs: []
  type: TYPE_NORMAL
- en: 'With a slight change in the formula, you can also change Celsius temperatures
    to Fahrenheit. Here’s the `celsius_to_fahrenheit2.awk` script that does that:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'And, here’s the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, let’s say that we don’t care about seeing the list of temperatures, and
    only want to see the average. Well, here’s the `average_temp.awk` script which
    does that:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'This time, I decided to use the alternate formula for converting from Fahrenheit
    to Celsius. In both of the `$2==` lines, I’m using the `+=` operator to sum the
    temperatures in the first field and to increment the `total_records` variable.
    Here’s the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: To verify that it’s giving you accurate averages, play around with different
    temperature values in the `temps.txt` file to see what happens.
  prefs: []
  type: TYPE_NORMAL
- en: The final thing I’ll say on this topic is that `awk` offers the full range of
    math operators, as well as a good selection of math functions. You can find out
    more by following the links in the *Further Reading* section.
  prefs: []
  type: TYPE_NORMAL
- en: Next, let’s see what we can do with multi-line records.
  prefs: []
  type: TYPE_NORMAL
- en: Working with Multi-Line Records
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'So far, we’ve been using `awk` to parse text files in which each line is its
    own distinct record. Sometimes though, you might have to work with files that
    have each record spread across several lines. For example, look at this `inventory.txt`
    file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'The first and third records each consist of three lines, and the second record
    consists of four lines. Each record is separated by a blank space. Now, let’s
    say that we need to import this information into a spreadsheet. That won’t work
    well with multi-line records, so we’ll need to find an easy way to convert it
    into a spreadsheet-friendly format. Once again, `awk` to the rescue! Here’s the
    `inventory.awk` script that helps us out:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: The `BEGIN` block defines the newline (`\n`) as the field separator, which means
    that each line in a record is its own field. The record separator (`RS`) and the
    output record separator (`ORS`) are each defined as a null value (`""`). The `RS`
    variable interprets the null value as a blank line, but the `ORS` variable doesn’t.
    In this case, having `ORS` defined as a null value just prevents the `print` command
    in the `while` loop from adding a newline at the end of each field.
  prefs: []
  type: TYPE_NORMAL
- en: 'There’s not much in the `while` loop that you haven’t seen before. It just
    uses the `count` variable to hold the number of the field that’s being processed.
    The value of this `count` variable gets incremented by 1 after each iteration
    of the `while` loop. You might think it strange that the loop parameter is defined
    as `count<NF` instead of `count<=NF`. I mean, wouldn’t we want to process the
    last field in every record? Well, we do process that last field with the `print
    $NF "\n"` command that comes after the `while` loop. As I said, defining the `OFS`
    as `""` prevents the `print` command from adding a newline character at the end
    of each field. So, in order to have each record on a separate line, we have to
    have a separate `print` command for the final field, and specify that it will
    add a newline at the end of the line. At any rate, here’s how things look when
    I use the script to parse the `inventory.txt` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'Of course, you can redirect the output into a `.tsv` file that you can open
    in your favorite spreadsheet program. If you’d rather use a `.csv` file, just
    replace the print `$count "\t"` line in the `while` loop with print `$count ","`.
    The output will then look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: The beauty of this script is that it doesn’t matter how many fields you have
    in each record. The `NF` built-in variable keeps track of how many fields there
    are, and the `while` loop processes each record accordingly.
  prefs: []
  type: TYPE_NORMAL
- en: Okay, I think that this will pretty much wrap up our introduction to `awk` scripting.
    So, let’s summarize and move on.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `awk` scripting language is exceedingly useful for anyone who needs to extract
    meaningful data from plain-text files. I began this chapter by showing you the
    basic construction of an `awk` script. Then, I showed you how to use `if` and
    `if..else` to create conditional commands, how to use `while` loops, and how to
    parse text files with multi-line records. For the demos, I showed you various
    `awk` scripts that do the types of jobs that you might encounter in real life.
  prefs: []
  type: TYPE_NORMAL
- en: Unfortunately, there’s no way that I can do complete justice with this presentation
    of `awk`. It’s another of those topics about which entire books have been written,
    so the best I can do here is to just whet your appetite.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we’ll get back to the main topic of shell scripting, by
    looking at a couple of utilities that allow you to create user interfaces for
    your scripts. I’ll see you there.
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For the best portability, which of the following shebang lines should you place
    in your `awk` scripts?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`#!/bin/awk`'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '`#!/usr/bin/awk -f`'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '`#!/bin/awk -f`'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '`#!/usr/bin/awk`'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Which of the following statements is true?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: All `awk` programming variables must be declared before you use them.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: There are various types of `awk` variables, such as integer, floating-point,
    and string.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: All `awk` programming variables are string-type variables.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: You must convert string-type variables to either integer or floating-point variables
    before using them in math operations.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Within an `awk` script, how would you define the comma as the field separator?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`-F=,`'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '`-F=","`'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '`FS=,`'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: . `FS=","`
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: You have a text file with several lines of numbers, with blank spaces between
    the numbers. Each line has a different number of numbers. You want to sum the
    numbers on each line. When you write an `awk` script to create these sums, how
    would you account for the fact that each line has a different number of fields?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a variable array to hold the number of fields in each line, and use a
    `for` loop to build the array.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Use the `NF` built-in variable.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Use the `NR` built-in variable.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: You can only do this when each line has the same number of fields.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Which of the following `printf` directives would you use to ensure that a floating-point
    number always displays with four digits after the decimal point?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`%.4f`'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '`%4`'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '`#4.f`'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '`#4`'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Further Reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'How do I check if my CPU supports x86_v2?: [https://unix.stackexchange.com/questions/631217/how-do-i-check-if-my-cpu-supports-x86-64-v2](https://unix.stackexchange.com/questions/631217/how-do-i-check-if-my-cpu-supports-x86-64-v2)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Exploring x86-64-v3 for Red Hat Enterprise Linux 10: [https://developers.redhat.com/articles/2024/01/02/exploring-x86-64-v3-red-hat-enterprise-linux-10](https://developers.redhat.com/articles/2024/01/02/exploring-x86-64-v3-red-hat-enterprise-linux-10)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'x86_64 Levels: [https://medium.com/@BetterIsHeather/x86-64-levels-944e92cd6d83](mailto:https://medium.com/@BetterIsHeather/x86-64-levels-944e92cd6d83)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'How the awk Command Made Me a 10x Engineer: [https://youtu.be/FbSpuZVb164?si=ri9cnjBh1sxM_STz](https://youtu.be/FbSpuZVb164?si=ri9cnjBh1sxM_STz)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Ternary Operators: [https://www.tutorialspoint.com/awk/awk_ternary_operators.htm](https://www.tutorialspoint.com/awk/awk_ternary_operators.htm)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'printf Examples: [https://www.gnu.org/software/gawk/manual/html_node/Printf-Examples.html](https://www.gnu.org/software/gawk/manual/html_node/Printf-Examples.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Doing math with awk: [https://www.networkworld.com/article/942538/doing-math-with-awk.html](https://www.networkworld.com/article/942538/doing-math-with-awk.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Numeric functions in awk: [https://www.gnu.org/software/gawk/manual/html_node/Numeric-Functions.html](https://www.gnu.org/software/gawk/manual/html_node/Numeric-Functions.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Answers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: b
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: c
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: d
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: b
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: a
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Join our community on Discord!
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Read this book alongside other users, Linux experts, and the author himself.
  prefs: []
  type: TYPE_NORMAL
- en: Ask questions, provide solutions to other readers, chat with the author via
    Ask Me Anything sessions, and much more. Scan the QR code or visit the link to
    join the community.
  prefs: []
  type: TYPE_NORMAL
- en: '[https://packt.link/SecNet](https://packt.link/SecNet)'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/QR_Code10596186092701843.png)'
  prefs: []
  type: TYPE_IMG
