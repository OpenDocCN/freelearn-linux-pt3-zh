- en: '2'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Working with Processes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As a developer, you are already intuitively familiar with processes. They are
    the fruits of your labor: after writing and debugging code, your program finally
    executes, transforming into a beautiful operating system process!'
  prefs: []
  type: TYPE_NORMAL
- en: A process on Linux can be a long-running application, a quick shell command
    like `ls`, or anything that the kernel spawns to do some work on the system. If
    something is getting done in Linux, a process is doing it. Your web browser, text
    editor, vulnerability scanner, and even things like reading files and the commands
    you’ve learned so far all spawn a process.
  prefs: []
  type: TYPE_NORMAL
- en: 'Linux’s process model is important to understand because the abstraction it
    gives you – the Linux process – is what all the commands and tools you’ll use
    to manage processes depend on. Gone are the details you’re used to seeing from
    a developer’s perspective: variables, functions, and threads have all been encapsulated
    as “a process.” You’re left with a different, external set of knobs to manipulate
    and gauges to check: process ID, status, resource usage, and all the other process
    attributes we’ll be covering in this chapter.'
  prefs: []
  type: TYPE_NORMAL
- en: First, we’ll take a close look at the process abstraction itself, and then we’ll
    dive into useful, practical things you can do with Linux processes. While we’re
    covering the practical aspects, we’ll pause to add detail to a few aspects that
    are a common source of problems, like permissions, and give you some heuristics
    for troubleshooting processes.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, you’ll learn about the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: What a Linux process is, and how to see the processes currently running on your
    system
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The attributes a process has, so you know what information you can gather while
    troubleshooting
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Common commands for viewing and finding processes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'More advanced topics that can come in handy for a developer actually writing
    programs that execute as Linux processes: Signals and inter-process communication,
    the `/proc` virtual filesystem, seeing open file handles with the `lsof` command,
    and how processes are created in Linux'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You’ll also get a practical review of everything you’ve learned in an example
    troubleshooting session that uses the theory and commands we cover in this chapter.
    Now, let’s dive into what exactly a Linux process is.
  prefs: []
  type: TYPE_NORMAL
- en: Process basics
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'When we refer to a “process” in Linux, we’re referring to the operating system’s
    internal model of what exactly a running program *is*. Linux needs a general abstraction
    that works for *all* programs, which can encapsulate the things the operating
    system cares about. A process is that abstraction, and it enables the OS to track
    some of the important context around programs that are executing; namely:'
  prefs: []
  type: TYPE_NORMAL
- en: Memory usage
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Processor time used
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Other system resource usage (disk access, network usage)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Communication between processes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Related processes that a program starts, for example, firing off a shell command
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'You can get a listing of all system processes (at least the ones your user
    is allowed to see) by running the `ps` program with the `aux` flags:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B19251_02_01.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2.1: List of system processes'
  prefs: []
  type: TYPE_NORMAL
- en: We’ll cover the attributes most relevant to your work as a developer in this
    chapter.
  prefs: []
  type: TYPE_NORMAL
- en: What is a Linux process made of?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'From the perspective of the operating system, a “process” is simply a data
    structure that makes it easy to access information like:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Process ID** (**PID** in the `ps` output above). PID 1 is the init system
    – the original parent of all other processes, which bootstraps the system. The
    kernel starts this as one of the first things it does after starting to execute.
    When a process is created, it gets the next available process ID, in sequential
    order. Because it is so important to the normal functioning of the operating system,
    init cannot be killed, even by the root user. Different Unix operating systems
    use different init systems – for example, most Linux distributions use `systemd`,
    while macOS uses `launchd`, and many other Unixes use SysV. Regardless of the
    specific implementation, we’ll refer to this process by the name of the role it
    fills: “init.”'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Note**'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: In containers, processes are namespaced – in the “real” environment, all container
    processes might be PID 3210, while that single PID maps to lots of processes (`1..n`,
    where `n` is the number of running processes in the container). You can see this
    from outside but not inside the container.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**Parent Process PID** (**PPID**). Each process is spawned by a parent. If
    the parent process dies while the child is alive, the child becomes an “orphan.”
    Orphaned processes are re-parented to init (PID 1).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Status** (**STAT** in the `ps` output above). `man ps` will show you an overview:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: D – uninterruptible sleep (usually IO)
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: I – idle kernel thread
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: R – running or runnable (on run queue)
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: S – interruptible sleep (waiting for an event to complete)
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: T – stopped by job control signal
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: t – stopped by debugger during tracing
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: X – dead (should never be seen)
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Z – defunct (“zombie”) process, terminated but not reaped by its parent
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Priority** status (“niceness” – does this process allow other processes to
    take priority over it?).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A process **Owner** (USER in the `ps` output above); the effective user ID.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Effective **Group ID** (EGID), which is used.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An **address map** of the process’s memory space.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Resource usage – open files, network ports, and other resources the process
    is using (**VSZ** and **RSS** for memory usage in the `ps` output above).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '(Citation: from the *Unix and Linux System Administration Handbook*, *5th edition*,
    p.91.)'
  prefs: []
  type: TYPE_NORMAL
- en: Let’s take a closer look at a few of the process attributes that are most important
    for developers and occasional troubleshooters to understand.
  prefs: []
  type: TYPE_NORMAL
- en: Process ID (PID)
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Each process is uniquely identifiable by its process ID, which is just a unique
    integer that is assigned to a process when it starts. Much like a relational database
    with IDs that uniquely identify each row of data, the Linux operating system keeps
    track of each process by its PID.
  prefs: []
  type: TYPE_NORMAL
- en: A PID is by far the most useful label for you to use when interacting with processes.
  prefs: []
  type: TYPE_NORMAL
- en: Effective User ID (EUID) and Effective Group ID (EGID)
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: These determine which system user and group your process is running as. Together,
    user and group permissions determine what a process is allowed to do on the system.
  prefs: []
  type: TYPE_NORMAL
- en: As you’ll see in *Chapter 5*, *Introducing Files*, files have user and group
    ownership set on them, which determines who their permissions apply to. If a file’s
    ownership and permissions are essentially a lock, then a process with the right
    user/group permissions is like a key that opens the lock and allows access to
    the file. We’ll dive deeper into this later, when we talk about permissions.
  prefs: []
  type: TYPE_NORMAL
- en: Environment variables
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You’ve probably used environment variables in your applications – they’re a
    way for the operating system environment that launches your process to pass in
    data that the process needs. This commonly includes things like configuration
    directives (`LOG_DEBUG=1`) and secret keys (`AWS_SECRET_KEY`), and every programming
    language has some way to read them out from the context of the program.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, this Python script gets the user’s home directory from the `HOME`
    environment variable, and then prints it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'In my case, running this program in the `python3` REPL on a Linux machine results
    in the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Working directory
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A process has a “current working directory,” just like your shell (which is
    just a process, anyway). Typing `pwd` in your shell prints its current working
    directory, and every process has a working directory. The working directory for
    a process can change, so don’t rely on it too much.
  prefs: []
  type: TYPE_NORMAL
- en: This concludes our overview of the process attributes that you should know about.
    In the next section, we’ll step away from theory and look at some commands you
    can use to start working with processes right away.
  prefs: []
  type: TYPE_NORMAL
- en: Practical commands for working with Linux processes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Here are some of the commands you’ll use most often:'
  prefs: []
  type: TYPE_NORMAL
- en: '`ps` – Shows processes on the system; you saw an example of this command earlier
    in the chapter. Flags modify which process attributes are displayed as columns.
    This command is usually used with filters to control how much output you get,
    for example, (`ps aux | head –n 10`) to cut your output down to just the top 10
    lines. A few more useful tricks:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ps –eLf` shows thread information for processes'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ps -ejH` is useful for seeing the relationships between parent and child processes
    visually (children are indented under their parents)![](img/B19251_02_02.png)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Figure 2.2: Examples of outputs of the ps command with flags'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`pgrep` – Find process IDs by name. Can use regular expressions.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![](img/B19251_02_03.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2.3: Examples of outputs of the pgrep command with flags'
  prefs: []
  type: TYPE_NORMAL
- en: '`top` – An interactive program that polls all processes (once a second, by
    default) and outputs a sorted list of resource usage (you can configure what it
    sorts by). Also displays total system resource usage. Press *Q* or use *Ctrl*
    + *C* to quit. You’ll see an example of this command’s output later in this chapter.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`iotop` – Like `top`, but for disk IO. Extremely useful for finding IO-hungry
    processes. Not installed on all systems by default, but available via most package
    managers.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![](img/B19251_02_04.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2.4: Example of output of the iotop command'
  prefs: []
  type: TYPE_NORMAL
- en: '`nethogs` – Like `top`, but for network IO. Groups network usage by process,
    which is incredibly convenient. Available via most package managers.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![](img/B19251_02_05.png)Figure 2.5: Example of output of the nethogs command'
  prefs: []
  type: TYPE_NORMAL
- en: '`kill` – Allows users to send signals to processes, usually to stop them or
    make them re-read their configuration files. We’ll explain signals and `kill`
    command usage later in this chapter.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Advanced process concepts and tools
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This marks the beginning of the “advanced” section of this chapter. While you
    don’t need to master all the concepts in this section to work effectively with
    Linux processes, they can be extremely helpful. If you have a few extra minutes,
    we recommend at least familiarizing yourself with each one.
  prefs: []
  type: TYPE_NORMAL
- en: Signals
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: How does `systemctl` tell your web server to re-read its configuration files?
    How can you politely ask a process to shut down cleanly? And how can you kill
    a malfunctioning process immediately, because it’s bringing your production application
    to its knees?
  prefs: []
  type: TYPE_NORMAL
- en: In Unix and Linux, all of this is done with signals. Signals are numerical messages
    that can be sent between programs. They’re a way for processes to communicate
    with each other and with the operating system, allowing processes to send and
    receive specific messages.
  prefs: []
  type: TYPE_NORMAL
- en: These messages can be used to communicate a variety of things to a process,
    for example, indicating that a particular event has happened or that a specific
    action or response is required.
  prefs: []
  type: TYPE_NORMAL
- en: Practical uses of signals
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Let’s look at a few examples of the practical value that the signal mechanism
    enables. Signals can be used to implement inter-process communication; for example,
    one process can send a signal to another process indicating that it’s finished
    with a particular task and that the other process can now start working. This
    allows processes to coordinate their actions and work together in a smooth and
    efficient manner, much like execution threads in programming languages (but without
    the associated memory sharing).
  prefs: []
  type: TYPE_NORMAL
- en: Another common application of process signals is to handle program errors. For
    example, a process can be designed to catch the `SIGSEGV` signal, which indicates
    a segmentation fault. When a process receives this signal, it can trap that signal
    and then take action to log the error, dump core for debugging purposes, or clean
    up any resources that were being used before shutting down gracefully.
  prefs: []
  type: TYPE_NORMAL
- en: Process signals can also be used to implement graceful shutdowns. For example,
    when a system is shutting down, a signal can be sent to all processes to give
    them a chance to save their state and clean up any resources they were using,
    via “trapping” signals.
  prefs: []
  type: TYPE_NORMAL
- en: Trapping
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Many of the signals can be “trapped” by the processes that receive them: this
    is essentially the same idea as catching and handling an error in a programming
    language.'
  prefs: []
  type: TYPE_NORMAL
- en: If the receiving process has a handler function for the signal that’s being
    sent, then that handler function is run. That’s how programs re-read their configuration
    without restarting, and finish their database writes and close their file handles
    after receiving the shutdown signal.
  prefs: []
  type: TYPE_NORMAL
- en: The kill command
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'However, it’s not just processes that communicate via signals: the frighteningly
    named (and, technically speaking, incorrectly named) `kill` is a program that
    allows users to send signals to processes, too.'
  prefs: []
  type: TYPE_NORMAL
- en: One of the most common uses of user-sent processes via the `kill` command is
    to interrupt a process that is no longer responding. For example, if a process
    is stuck in an infinite loop, a “kill” signal can be sent to force it to stop.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `kill` command allows you to send a signal to a process by specifying its
    PID. If the process you’d like to terminate has PID `2600`, you’d run:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: This command would send signal 15 (`SIGTERM`, or “terminate”) to the process,
    which would then have a chance to trap the signal and shut down cleanly.
  prefs: []
  type: TYPE_NORMAL
- en: '**Note**'
  prefs: []
  type: TYPE_NORMAL
- en: As you can see from the included table of standard signal numbers, the default
    signal that `kill` sends is “terminate” (signal 15), not “kill” (`SIGKILL` is
    9). The `kill` program is not just for killing processes but also for sending
    any kind of signal. It’s really confusingly named and I’m sorry about that – it’s
    just one of those idiosyncrasies of Unix and Linux that you’ll get used to.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you don’t want to send the default signal 15, you can specify the signal
    you’d like to send with a dash; to send a `SIGHUP` to the same process, you’d
    run:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Running `man` `signal` will give you a list of signals that you can send:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B19251_02_06.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2.6: Example of output of the man signal command'
  prefs: []
  type: TYPE_NORMAL
- en: 'It pays – sometimes quite literally, in engineering interviews – to be familiar
    with a few of these:'
  prefs: []
  type: TYPE_NORMAL
- en: '`SIGHUP` (1) – “hangup”: interpreted by many applications – for example, nginx
    – as “re-read your configuration because I’ve made changes to it.”'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`SIGINT` (2) – “interrupt”: often interpreted the same as `SIGTERM` - “please
    shut down cleanly.”'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`SIGTERM` (15) – “terminate”: nicely asks a process to shut down.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`SIGUSR1` (30) and `SIGUSR2` (31) are sometimes used for application-defined
    messaging For example, SIGUSR1 asks nginx to re-open the log files it’s writing
    to, which is useful if you’ve just rotated them.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`SIGKILL` (9) – `SIGKILL` cannot be trapped and handled by processes. If this
    signal is sent to a program, the operating system will kill that program immediately.
    Any cleanup code, like flushing writes or safe shutdown, is not performed, so
    this is generally a last resort, since it could lead to data corruption.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If you want to explore Linux a bit deeper, feel free to poke around the `/proc`
    directory. That’s definitely beyond the basics, but it’s a directory that contains
    a filesystem subtree for every process, where live information about the processes
    is looked up as you read those files.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: In practice, this knowledge can come in handy during troubleshooting when you’ve
    identified a misbehaving (or mysterious) process and want to know exactly what
    it’s doing in real time.
  prefs: []
  type: TYPE_NORMAL
- en: You can learn a lot about a process by poking around in its `/proc` subdirectory
    and casually googling.
  prefs: []
  type: TYPE_NORMAL
- en: Many of the tools we show you in this chapter actually use `/proc` to gather
    process information, and only show you a subset of what’s there. If you want to
    see *everything* and do the filtering yourself, `/proc` is the place to look.
  prefs: []
  type: TYPE_NORMAL
- en: lsof – show file handles that a process has open
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `lsof` command shows all files that a process has opened for reading and
    writing. This is useful because it only takes one small bug for a program to leak
    file handles (internal references to files that it has requested access to). This
    can lead to resource usage issues, file corruption, and a long list of strange
    behavior.
  prefs: []
  type: TYPE_NORMAL
- en: 'Thankfully, getting a list of files that a process has open is easy. Just run
    `lsof` and pass the `–p` flag with a PID (you’ll usually have to run this as root).
    This will return the list of files that the process (in this case, with PID 1589)
    has open:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: '![](img/B19251_02_07.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2.7: Example of list of files opened by the 1589 process using the lsof
    -p 1589 command'
  prefs: []
  type: TYPE_NORMAL
- en: 'The above is the output for an nginx web server process. The first line shows
    you the current working directory for the process: in this case, the root directory
    (`/`). You can also see that it has file handles open on its own binary (`/usr/sbin/nginx`)
    and various libraries in `/usr/lib/`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Further down, you might notice a few more interesting filepaths:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B19251_02_08.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2.8: Further opened files of the 1589 process'
  prefs: []
  type: TYPE_NORMAL
- en: This listing includes the log files nginx is writing to, and socket files (Unix,
    IPv4, and IPv6) that it’s reading and writing to. In Unix and Linux, network sockets
    are just a special kind of file, which makes it easy to use the same core toolset
    across a wide variety of use cases – tools that work with files are extremely
    powerful in an environment where almost everything is represented as a file.
  prefs: []
  type: TYPE_NORMAL
- en: Inheritance
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Except for the very first process, `init` (`PID 1`), all processes are created
    by a parent process, which essentially makes a copy of itself and then “forks”
    (splits) that copy off. When a process is forked, it typically inherits its parent’s
    permissions, environment variables, and other attributes.
  prefs: []
  type: TYPE_NORMAL
- en: 'Although this default behavior can be prevented and changed, it’s a bit of
    a security risk: software that you run manually receives the permissions of your
    current user (or even root privileges, if you use `sudo`). All child processes
    that might be created by that process – for example, during installation, compilation,
    and so on – inherit those permissions.'
  prefs: []
  type: TYPE_NORMAL
- en: Imagine a web server process that was started with root privileges (so it could
    bind to a network port) and environment variables containing cloud authentication
    keys (so it could grab data from the cloud). When this main process forks off
    a child process that needs neither root privileges nor sensitive environment variables,
    it’s an unnecessary security risk to pass those along to the child. As a result,
    dropping privileges and clearing environment variables is a common pattern in
    services spawning child processes.
  prefs: []
  type: TYPE_NORMAL
- en: From a security perspective, it is important to keep this in mind to prevent
    situations where information such as passwords or access to sensitive files could
    be leaked. While it is outside the scope of this book to go into details of how
    to avoid this, it’s important to be aware of this if you’re writing software that’s
    going to run on Linux systems.
  prefs: []
  type: TYPE_NORMAL
- en: Review – example troubleshooting session
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let’s look at an example troubleshooting session. All we know is that one specific
    Linux server is running extremely slowly.
  prefs: []
  type: TYPE_NORMAL
- en: To begin with, we want to see what’s happening on the system. You just learned
    that you can see a live view of processes running on a system by running the interactive
    `top` command. Let’s try that now.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B19251_02_09.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2.9: Example of output of the top command'
  prefs: []
  type: TYPE_NORMAL
- en: By default, the `top` command sorts processes by CPU usage, so we can simply
    look at the first listed process to find the offending one. Indeed, the top process
    is using 94% of one CPU’s available processing time.
  prefs: []
  type: TYPE_NORMAL
- en: 'As a result of running `top`, we’ve gotten a few useful pieces of information:'
  prefs: []
  type: TYPE_NORMAL
- en: The problem is CPU usage, as opposed to some other kind of resource contention.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The offending process is PID 1763, and the command being run (listed in the
    **COMMAND** column) is `bzip2`, which is a compression program.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We determine that this `bzip2` process doesn’t need to be running here, and
    we decide to stop it. Using the `kill` command, we ask the process to terminate:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'After waiting a few seconds, we check to see if this (or any other) `bzip2`
    process is running:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Unfortunately, we see that the same PID is still running. It’s time to get
    serious:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'This orders the operating system to kill the process without allowing the process
    to trap (and potentially ignore) the signal. A `SIGKILL` (signal #9) simply kills
    the process where it stands.'
  prefs: []
  type: TYPE_NORMAL
- en: Now that you’ve killed the offending process, the server is running smoothly
    again and you can start tracking down the developer who thought it was a good
    idea to compress large source directories on this machine.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this example, we followed the most common systems troubleshooting pattern
    in existence:'
  prefs: []
  type: TYPE_NORMAL
- en: We looked at resource usage (via `top` in this example). This can be any of
    the other tools we discussed, depending on which resource is the one being exhausted.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We found a PID to investigate.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We acted on that process. In this example, no further investigation was necessary
    and we sent a signal, asking it to shut down (15, `SIGTERM`).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Conclusion
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we took a close look at the process abstraction that Linux
    wraps around executing programs. You’ve seen the common components that all processes
    have and learned the basic commands you need to find and inspect running processes.
    With these tools, you’ll be able to identify when a process is misbehaving, and
    more importantly, *which* process is misbehaving.
  prefs: []
  type: TYPE_NORMAL
- en: Learn more on Discord
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To join the Discord community for this book – where you can share feedback,
    ask questions to the author, and learn about new releases – follow the QR code
    below:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://packt.link/SecNet](https://packt.link/SecNet)'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/QR_Code1768422420210094187.png)'
  prefs: []
  type: TYPE_IMG
