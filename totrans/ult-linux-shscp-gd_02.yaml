- en: '2'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '2'
- en: Interpreting Commands
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 解读命令
- en: To fulfill its job as the interface between the user and the operating system
    kernel, a shell has to perform five different functions. These functions include
    interpreting commands, setting variables, enabling input/output redirection, enabling
    pipelines, and allowing customization of a user’s working environment. In this
    chapter, we’ll look at how `bash` and `zsh` interpret commands. As an added bonus,
    much of what we’ll cover in the next few chapters will also help you prepare for
    certain Linux certification exams, such as the Linux Professional Institute or
    CompTIA Linux+ exams.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 为了履行其作为用户与操作系统内核之间接口的职责，Shell必须执行五个不同的功能。这些功能包括解读命令、设置变量、启用输入/输出重定向、启用管道以及允许定制用户的工作环境。在本章中，我们将探讨`bash`和`zsh`是如何解读命令的。作为额外的收获，我们将在接下来的几章中讲解的内容也会帮助你准备一些Linux认证考试，比如Linux专业人员协会（LPI）或CompTIA
    Linux+考试。
- en: 'Topics in this chapter include:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章内容包括：
- en: Understanding the structure of a command
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解命令的结构
- en: Executing multiple commands at once
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一次执行多个命令
- en: Running commands recursively
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 递归运行命令
- en: Understanding the command history
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解命令历史
- en: Escaping and quoting
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 转义和引用
- en: To follow along, you can use pretty much any Linux distro that you desire, as
    long as it’s running with either `bash` or `zsh`. Your best bet is to use a virtual
    machine instead of your production workstation, in case you accidentally delete
    or change something that you shouldn’t.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 为了跟着学习，你可以使用任何你喜欢的Linux发行版，只要它运行的是`bash`或`zsh`。你最好的选择是使用虚拟机，而不是生产工作站，以防不小心删除或更改一些不该更改的内容。
- en: Understanding the Structure of a Command
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解命令结构
- en: 'A handy thing to know for both real-life and any certification exams that you
    may take, is the structure of a command. Commands can consist of up to three parts,
    and there’s a certain order for the parts. Here are the parts and the order in
    which you’ll normally place them:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 对于现实生活和你可能参加的任何认证考试来说，了解命令的结构非常重要。命令可以由最多三个部分组成，并且这些部分有一定的顺序。以下是这些部分以及通常排列的顺序：
- en: The command itself
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 命令本身
- en: Command options
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 命令选项
- en: Command arguments
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 命令参数
- en: If you plan to take a Linux certification exam, you’ll definitely want to remember
    this ordering rule. Later on though, we’ll see that some commands don’t always
    follow this rule.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你计划参加Linux认证考试，你肯定要记住这个排序规则。不过，稍后我们会看到一些命令并不总是遵循这个规则。
- en: Using Command Options
  id: totrans-16
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用命令选项
- en: 'There are two general types of **option switches**:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 有两种常见的**选项开关**：
- en: '**Single-letter options**: For most commands, a single-letter option is preceded
    by a single dash. Most of the time, two or more single-letter options can be combined
    with a single dash.'
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**单字母选项**：对于大多数命令，单字母选项前面会有一个短横线。大多数情况下，两个或更多单字母选项可以与一个短横线结合使用。'
- en: '**Whole-word options**: For *most* commands, a whole word option is preceded
    by two dashes. Two or more whole-word options must be listed separately, because
    they can’t be combined with a single pair of dashes.'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**全字选项**：对于*大多数*命令，整个单词选项前面会有两个短横线。两个或更多的全字选项必须单独列出，因为它们不能与一对短横线结合使用。'
- en: To show you what we mean, check out this hands-on lab.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 为了向你展示我们的意思，请查看这个实践实验。
- en: Hands-on Lab – Practice With Command Options
  id: totrans-21
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 实践实验 – 使用命令选项的练习
- en: In this lab, we’ll be working with the humble `ls` utility. Options and arguments
    are optional for this utility, so we’ll get to see the different configurations
    for the command in this hands-on practice.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 在本实验中，我们将使用简单的`ls`工具。对于这个工具，选项和参数是可选的，因此我们将在实际操作中看到该命令的不同配置。
- en: Let’s issue the naked `ls` command in order to see the files and directories
    that are in our current directory.
  id: totrans-23
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们执行裸`ls`命令，以查看当前目录中的文件和目录。
- en: '[PRE0]'
  id: totrans-24
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Now, let’s add a single-letter option. We’ll use the `-l` option to show the
    files and directories with some of their characteristics.
  id: totrans-25
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们添加一个单字母选项。我们将使用`-l`选项来显示文件和目录及其一些特征。
- en: '[PRE1]'
  id: totrans-26
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Use the `ls` command with the `-a` option to see any hidden files or directories.
    (Hidden files or directories have names that begin with a period.)
  id: totrans-27
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`ls`命令配合`-a`选项，可以查看任何隐藏的文件或目录。（隐藏文件或目录的名字以一个句点开始。）
- en: '[PRE2]'
  id: totrans-28
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Next, let’s combine the two options, so that we can see the characteristics
    of both the hidden and unhidden files and directories:'
  id: totrans-29
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，让我们结合这两个选项，以便我们可以看到隐藏文件和未隐藏文件以及目录的特点：
- en: '[PRE3]'
  id: totrans-30
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'In the preceding examples, the `donnie donnie` part indicates that the files
    and directories belong to user `donnie` and are associated with the `donnie` group.
    In this example, we’re using a whole-word option, `--author`, preceded by two
    dashes, to view some extra information. Let’s use this `--author` switch and the
    `-l` switch together to see who authored these files:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，`donnie donnie`部分表示这些文件和目录属于用户`donnie`，并与`donnie`组关联。在这个例子中，我们使用一个完整的选项`--author`，前面有两个破折号，来查看一些额外的信息。让我们将`--author`开关和`-l`开关一起使用，来查看这些文件的作者：
- en: '[PRE4]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: So, it appears that that Donnie character also created the files in the first
    place. (Oh, that’s me, isn’t it?)
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，看起来那个 Donnie 角色也正是最初创建这些文件的人。（哦，那是我，不是吗？）
- en: Using Command Arguments
  id: totrans-34
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用命令参数
- en: 'An argument is an object upon which a command will operate. For the `ls` command,
    an argument would be the name of a file or directory. For example, let’s say that
    we want to see the details of just a certain file. We can do something like this:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 参数是命令操作的对象。对于`ls`命令，参数将是文件或目录的名称。例如，假设我们只想查看某个文件的详细信息。我们可以这样做：
- en: '[PRE5]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'We can use the `*` **wildcard** to see details of all files of a certain type,
    like so:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用`*` **通配符**查看某一类型的所有文件的详细信息，如下所示：
- en: '[PRE6]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: If you’re not familiar with the concept of wildcards, think of them as a way
    to perform pattern-matching. In the above example, the `*` wildcard is used to
    match one or more characters. For this reason, the `ls -l *.sh` command allows
    us to see all files with the .sh filename extension. You can also use this wildcard
    in other ways. For example, to see all filenames and directory names that begin
    with the letter w, just do this
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你不熟悉通配符的概念，可以把它们看作是执行模式匹配的一种方式。在上面的例子中，`*`通配符用于匹配一个或多个字符。正因如此，`ls -l *.sh`命令让我们能看到所有以.sh为文件扩展名的文件。你还可以以其他方式使用这个通配符。例如，要查看所有以字母
    w 开头的文件名和目录名，只需执行：
- en: '[PRE7]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '`F`or more information about wildcards, check out the reference in the *Further
    Reading* section.'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解有关通配符的更多信息，请查阅*进一步阅读*部分中的参考资料。
- en: In this case, we’re looking at all files whose names end in `.sh`.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们查看的是所有以`.sh`结尾的文件。
- en: 'You’re not always limited to specifying just one argument. In this example,
    we’re looking at three different files:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 你并不总是仅限于指定一个参数。在这个例子中，我们正在查看三个不同的文件：
- en: '[PRE8]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Use the `-ld` option to view the characteristics of a directory without viewing
    the contents of the directory, like so:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`-ld`选项查看目录的特征，而不查看目录的内容，如下所示：
- en: '[PRE9]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Although you can actually change the order in which options and arguments appear
    in many commands, it’s bad practice to do so. To avoid confusion and to prepare
    yourself for any Linux certifications exams that you might take, just follow the
    ordering rule that I’ve presented here. That is, the command itself, command options,
    and lastly, the command arguments.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管你实际上可以改变选项和参数在许多命令中出现的顺序，但这样做并不是好习惯。为了避免混淆，并为你可能参加的任何 Linux 认证考试做好准备，还是遵循我在这里提供的顺序规则。也就是说，首先是命令本身，其次是命令选项，最后是命令参数。
- en: That about does it for the command structure part. Let’s move on to see how
    to execute multiple commands at once.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 命令结构部分就到这里。接下来，我们来看一下如何一次性执行多个命令。
- en: Executing Multiple Commands at Once
  id: totrans-49
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 一次性执行多个命令
- en: 'From either the command-line or from within shell scripts, it’s handy to know
    how to combine multiple commands into one single command. In this section, I’ll
    demonstrate three ways to do that which are:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 无论是在命令行中还是在 shell 脚本中，了解如何将多个命令合并成一个单一命令都非常方便。在本节中，我将演示三种方法：
- en: Running commands interactively
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 交互式运行命令
- en: Using command sequences
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用命令序列
- en: Using the `find` utility
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`find`工具
- en: Running Commands Interactively
  id: totrans-54
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 交互式运行命令
- en: This is a form of shell-script programming, except that you’re just executing
    all commands from the command-line, instead of actually writing, saving, and executing
    a script. Here, you are creating a **for loop** – with each command of the loop
    on its own separate line – to perform a directory listing three times.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一种 shell 脚本编程方式，只不过你只是从命令行执行所有命令，而不是实际编写、保存和执行脚本。在这里，你正在创建一个**for 循环**——循环中的每个命令都在各自的单独行上——来执行三次目录列出操作。
- en: '[PRE10]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'At the end of each line, you’ll hit the *Enter* key. But, nothing will happen
    until you type the `done` command on the final line. The `for` loop will then
    run three times, once for each of the three listed arguments. Each time that it
    runs, the value of an argument gets assigned to the `var` variable, and the `echo`
    command prints the currently-assigned value. The output will look something like
    this:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 在每一行的末尾，你需要按下*Enter*键。但在你输入`done`命令之后，什么也不会发生。`for`循环将会执行三次，每次使用列出的三个参数之一。每次执行时，参数的值都会被赋值给`var`变量，而`echo`命令将打印当前赋值的内容。输出看起来会像这样：
- en: '[PRE11]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Next, hit the up arrow key on your keyboard, and you’ll see the `for` loop
    that you just executed If you try this with `bash`, you’ll see that the individual
    commands are separated by semi-colons, like so:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，按下键盘上的上箭头键，你会看到刚刚执行的`for`循环。如果你在`bash`中尝试这一操作，你会发现各个命令用分号分隔，如下所示：
- en: '[PRE12]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'On `zsh`, pressing the up arrow key will cause the command components to appear
    on their own separate lines, as you see here:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 在`zsh`中，按下上箭头键会使命令的各个部分出现在单独的行上，正如你在这里看到的那样：
- en: '[PRE13]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Either way, the `for` loop will run again when you hit the *Enter* key.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 无论哪种方式，当你按下*Enter*键时，`for`循环将再次执行。
- en: If you’re still a bit unclear about how `for` loops work, have no fear. We’ll
    look at them in greater detail once we start actually creating shell scripts.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你对`for`循环的工作方式还有点不清楚，别担心。一旦我们开始实际创建shell脚本，我们将更详细地讲解它们。
- en: Using Command Sequences
  id: totrans-65
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用命令序列
- en: Command sequences are another type of programming structure that you’ll find
    very useful. Here, I’m demonstrating how to use them from the command-line so
    that you can grasp the basic concepts. In the upcoming chapters, I’ll show you
    examples of how to use them in shell scripts.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 命令序列是另一种你会发现非常有用的编程结构。在这里，我演示了如何从命令行使用它们，以便你能掌握基本概念。在接下来的章节中，我会向你展示如何在shell脚本中使用它们的例子。
- en: Chaining Commands with a Semi-Colon
  id: totrans-67
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用分号链式执行命令
- en: 'You can also use the semi-colon to separate stand-alone commands that you want
    to execute from the same command entry. If you wanted to `cd` to a certain directory
    and then look at its contents, you could enter each command on its own line. Or,
    you could enter them both on the same line. This process is called **command chaining**,
    which looks like this:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以使用分号来分隔你想在同一命令行中执行的独立命令。如果你想先`cd`到某个目录，再查看它的内容，你可以把每个命令写在单独的行中，或者把它们写在同一行。这种过程被称为**命令链式执行**，它的样子如下：
- en: '[PRE14]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The first command failed because I tried to `cd` into a non-existent directory.
    But, the second command still executed, which listed the files in my home directory.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个命令失败了，因为我尝试进入一个不存在的目录。但是，第二个命令仍然执行成功，它列出了我家目录中的文件。
- en: Conditional Command Execution with Double Ampersands
  id: totrans-71
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用双与符号进行条件命令执行
- en: 'You can also instruct `bash` or `zsh` to only execute the second command if
    the first command successfully completes. Just separate the commands with `&&`
    instead of with a semi-colon, like this:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以指示`bash`或`zsh`，仅在第一个命令成功完成时才执行第二个命令。只需用`&&`而不是分号来分隔命令，如下所示：
- en: '[PRE15]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'What if the first command doesn’t run successfully? Note here that the second
    command doesn’t execute:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 如果第一个命令没有成功执行呢？请注意，第二个命令并不会执行：
- en: '[PRE16]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Conditional Command Execution with Double Pipes
  id: totrans-76
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用双管道符进行条件命令执行
- en: If you want `bash` or `zsh` to execute the second command only if the first
    command *doesn’t* run successfully, just separate the commands with `||`. (This
    is a pair of pipe characters, which you’ll find on the same key as the backslash.)
    To illustrate, let’s again make a slight typo while trying to change directories.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你希望`bash`或`zsh`仅在第一个命令*未*成功执行时才执行第二个命令，只需用`||`分隔命令。（这是两个管道符号，你可以在和反斜杠同一个键上找到它们。）举个例子，我们再次尝试输入一个小错误的命令来切换目录。
- en: '[PRE17]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: For a more practical example, try changing to a directory, creating it if it
    doesn’t exist, and then changing to it after it’s been successfully created.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 作为一个更实际的例子，试着切换到一个目录，如果该目录不存在则创建它，然后在目录成功创建后切换到它。
- en: '[PRE18]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: You’ll still get an error message saying that the directory you tried to access
    doesn’t exist. But, look at the command prompt, and you’ll see that the directory
    has been created, and that you’re now in it.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 你仍然会看到一个错误信息，提示你尝试访问的目录不存在。但请看看命令提示符，你会看到目录已经被创建，并且你已经进入了该目录。
- en: Using the find Utility
  id: totrans-82
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用`find`工具
- en: We’ll now take a short intermission from our discussion of running multiple
    commands in order to introduce the `find` utility, which is truly the Cool-Mac
    Daddy of all search utilities. After this introduction, I’ll use `find` to show
    you more ways to run multiple commands at once.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在暂时从多命令执行的讨论中休息一下，来介绍一下 `find` 工具，它真的是所有搜索工具中的酷炫大哥。介绍完之后，我会使用 `find` 展示更多同时运行多个命令的方法。
- en: Also, it would behoove us to mention that `find` isn’t just good for command-line
    searches. It’s also excellent for use within shell scripts, as you’ll see much
    later.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 另外，我们有必要提到，`find` 不仅适用于命令行搜索。它在 Shell 脚本中也非常优秀，稍后你会看到。
- en: If you’re as old as I am, you might remember the Windows XP search pooch, which
    pranced around on your screen every time you did a file search from the Windows
    XP graphical search utility. It was cute, but it didn’t add to your search power.
    With the Linux `find` utility, you can perform powerful searches on just about
    any criterion you can think of, and then--from the same command-line entry--invoke
    another utility to do whatever you need to do with the search results. I won’t
    try to discuss every option there is for `find`, since there are so many. Rather,
    I’ll give you an overview of what you can do with `find`, and let you read its
    man page for the rest. (Just enter `man find` at the command-line to read about
    all of its options.)
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你和我一样年纪大，你可能还记得 Windows XP 搜索助手，每次从 Windows XP 图形搜索工具进行文件搜索时，它会在屏幕上跳跃。它看起来挺可爱，但并没有增强你的搜索能力。而在
    Linux 的 `find` 工具中，你可以根据你能想到的任何标准执行强大的搜索，然后——通过同一个命令行输入——调用另一个工具来处理搜索结果。我不会尝试讨论
    `find` 的所有选项，因为它们太多了。我将简要介绍你可以用 `find` 做什么，然后让你通过查看其手册页面了解更多选项。（只需在命令行输入 `man
    find`，即可查看所有选项。）
- en: 'In order to perform the most basic of searches, you’ll need to specify two
    things:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 要执行最基本的搜索，你需要指定两个要素：
- en: '**The search path**: You can perform a search in either a specific path, or
    the entire filesystem. Since `find` is inherently recursive, the search will automatically
    extend to all of the subdirectories that are beneath of the directory that you
    specify. (Of course, you can also add command switches that limit the depth of
    the search.)'
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**搜索路径**：你可以在指定的路径中，或者整个文件系统中进行搜索。由于 `find` 本身是递归的，搜索会自动扩展到你指定目录下的所有子目录。（当然，你也可以添加命令开关来限制搜索的深度。）'
- en: '**What you’re searching for**: There are a lot of ways that you can specify
    this. You can search for files of a specific name, and decide whether to make
    the search case-sensitive. You can also use wildcards, or search for files with
    certain characteristics or that are of a certain age. Or, you can combine multiple
    criteria for even more specific searches. The main thing that limits you is your
    own imagination.'
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**你要搜索的内容**：有很多方法可以指定搜索内容。你可以按特定的文件名进行搜索，并决定是否区分大小写。你还可以使用通配符，或者搜索具有特定特征或特定年龄的文件。或者，你可以结合多个标准进行更为具体的搜索。限制你的唯一因素就是你的想象力。'
- en: So now, let’s say that you want to search the entire filesystem for all files
    whose names end in `.conf`. You’ll want to use either the `-name` or the `-iname`
    switch in front of the file description that you want to search for. Otherwise,
    you’ll get a jumbled up mess of every directory listing that you’ve searched,
    with the information you’re looking for mixed in. For case-sensitive searches,
    use `-name`, and for case-insensitive searches, use `-iname`. In this case, we’ll
    use `-iname`, since we want to make the search case-insensitive.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你现在想要在整个文件系统中搜索所有以 `.conf` 结尾的文件。你需要在要搜索的文件描述前使用 `-name` 或 `-iname` 选项。否则，你会得到一个杂乱无章的目录列表，其中包含你搜索的每个目录，且你要找的信息混杂其中。对于区分大小写的搜索，使用
    `-name`，对于不区分大小写的搜索，使用 `-iname`。在这种情况下，我们使用 `-iname`，因为我们希望搜索不区分大小写。
- en: I know, I’ve told you previously that most whole-word option switches are preceded
    by a pair of dashes. The `find` utility is an exception to the rule, because its
    whole-word option switches are preceded by only a single dash.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 我知道，我之前告诉过你，大多数整字选项开关前面都有一对破折号。`find` 工具是这个规则的例外，因为它的整字选项开关前面只有一个破折号。
- en: Also, be aware that searching through an entire filesystem on a production server
    with very large drives can take a long time. It’s sometimes necessary to do that,
    but it’s best to confine your searches to specific directories whenever possible.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 同时需要注意，在生产服务器上对整个文件系统进行搜索，尤其是当硬盘非常大的时候，可能会花费很长时间。有时候确实需要这么做，但尽可能最好将搜索限制在特定目录内。
- en: 'If you include a wildcard character with a search criterion, you’ll need to
    enclose that search criterion in quotes. That will keep the shell from interpreting
    the wildcard character as an ambiguous file reference. For example, to perform
    a case-insensitive search through the current working directory and all of its
    subdirectories for all files with names ending with a `.conf` filename extension,
    I would do this:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在搜索条件中包含通配符字符，您需要将该搜索条件用引号括起来。这样可以防止 shell 将通配符字符解释为模糊的文件引用。例如，若要在当前工作目录及其所有子目录中执行不区分大小写的搜索，查找所有以
    `.conf` 结尾的文件，我会这样操作：
- en: '[PRE19]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: By using the `-iname` option, I was able to find files with names that ended
    in either `.conf` or `.CONF`. If I had used the `-name` option instead, I would
    only have found files with names that end in `.conf`.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用 `-iname` 选项，我能够找到以 `.conf` 或 `.CONF` 结尾的文件。如果我使用的是 `-name` 选项，那么只会找到以 `.conf`
    结尾的文件。
- en: 'Normally, you would specify the search path as the first component of the `find`
    command. In the GNU implementation of `find` that’s included on Linux-based operating
    systems, omitting the search path will cause `find` to search through the current
    working directory, as we’ve just seen. Unfortunately, that trick doesn’t work
    for Unix/Unix-like operating systems, such as FreeBSD, macOS, or OpenIndiana.
    For those operating systems, you’ll always need to specify a search path. To make
    `find` search through the current working directory, just use a dot to specify
    the search path. So, on my FreeBSD virtual machine, the command looks like this:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，您会将搜索路径指定为 `find` 命令的第一个组件。在 Linux 操作系统中包含的 GNU 实现的 `find` 中，如果省略搜索路径，`find`
    将会默认搜索当前工作目录，就像我们刚才看到的那样。不幸的是，这个技巧对于 Unix/Unix-like 操作系统（如 FreeBSD、macOS 或 OpenIndiana）不适用。在这些操作系统中，您始终需要指定搜索路径。要使
    `find` 搜索当前工作目录，只需使用点号来指定搜索路径。因此，在我的 FreeBSD 虚拟机上，命令如下所示：
- en: '[PRE20]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Okay, I know. You’re wondering why I’m mentioning FreeBSD, macOS, and OpenIndiana
    in what’s supposed to be a Linux book. Well, it’s because sometimes, we’ll want
    to create shell scripts that work on multiple operating systems, rather than just
    on Linux. If you include the dot in this command, it will still work on your Linux
    machines, and will also work on your Unix/Unix-like machines.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 好吧，我知道了。你可能会问，为什么我在这本本该是 Linux 书籍的内容里提到 FreeBSD、macOS 和 OpenIndiana。其实，是因为有时我们希望创建可以在多个操作系统上运行的
    shell 脚本，而不仅仅是 Linux。如果您在这个命令中包含点号，它仍然能在 Linux 机器上运行，同时也能在您的 Unix/Unix-like 机器上运行。
- en: 'You can also specify search paths that aren’t your current working directory.
    For example, you can remain within your own home directory and search through
    the entire filesystem like this:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以指定不是当前工作目录的搜索路径。例如，您可以停留在自己的主目录，并像这样在整个文件系统中进行搜索：
- en: '[PRE21]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Of course, this will take much longer than it does to just search through one
    directory. Also, you’ll encounter errors because your normal user account won’t
    have permission to go into every directory. To search through all directories
    on the filesystem, just preface the command with `sudo`, like this:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，这将比仅搜索一个目录花费更多的时间。而且，您会遇到错误，因为您的普通用户账户没有权限进入所有目录。要搜索整个文件系统中的所有目录，只需在命令前加上
    `sudo`，如以下所示：
- en: '[PRE22]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'You can perform searches with more than one search criterion. If you separate
    the criteria with a space, it will be the same as placing an `and` operator between
    them. Here, we’ll use the `-mtime -7` switch to find all of the `.conf` files
    that were modified within the last seven days, and the `-ls` switch at the end
    to show detailed information about the files:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用多个搜索条件进行搜索。如果使用空格分隔条件，它就相当于在它们之间放置了一个 `and` 运算符。在这里，我们将使用 `-mtime -7` 选项来查找过去七天内修改过的
    `.conf` 文件，并在最后使用 `-ls` 选项显示文件的详细信息：
- en: '[PRE23]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'To search for `.conf` files that were modified more than seven days ago, replace
    the `-7` with `+7`, like this:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 要查找修改时间超过七天的 `.conf` 文件，请将 `-7` 替换为 `+7`，如下所示：
- en: '[PRE24]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: It’s also possible to create more advanced searches by creating compound expressions.
    It works like Algebra, in that expressions are evaluated from left to right unless
    you group some of the terms with parentheses. But, with that, there are a couple
    of minor catches.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以通过创建复合表达式来执行更复杂的搜索。它的工作原理像代数一样，表达式是从左到右评估的，除非你使用括号将某些项分组。但这样做时，有几个小陷阱。
- en: Since the parenthesis symbols have a special meaning in `bash` and `zsh`, you’ll
    want to precede them with a backslash so that `bash` and `zsh` won’t interpret
    them the wrong way. You’ll also need to leave a space between the parenthesis
    symbols and the terms that they’re enclosing.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 由于括号符号在`bash`和`zsh`中有特殊含义，你需要在它们前面加上反斜杠，这样`bash`和`zsh`就不会误解它们的含义。你还需要在括号符号和它们所包含的内容之间留一个空格。
- en: Let’s say that we now want to look for all of the `.conf` files in the `/etc/`
    directory that were either modified within the last seven days, or that were accessed
    more than 30 days ago. We’ll use the `-atime` switch to set the access time criterion.
    The `or` operator is represented by `-o`.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们现在要查找`/etc/`目录下所有`.conf`文件，这些文件要么在过去七天内被修改，要么在30天前就被访问过。我们将使用`-atime`开关来设置访问时间条件。`or`运算符由`-o`表示。
- en: '[PRE25]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: There are several subdirectories in `/etc/` that require root privileges to
    enter, so I used `sudo` again, as I did before. Adding the `-ls` option at the
    end of the command would show the timestamps on the files, which would tell me
    which of the two search criteria applies to each specific file.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: '`/etc/`目录中有几个子目录需要root权限才能进入，所以我又使用了`sudo`，就像之前那样。在命令末尾添加`-ls`选项可以显示文件的时间戳，这可以告诉我每个具体文件满足哪一个搜索条件。'
- en: 'If you want to find files that belong to only a certain user, you can do that
    with the `-user` switch. Add a second criterion to find only files of a certain
    type that belong to a certain user. Here, I’m searching through the whole filesystem
    for all `.png` graphics files that belong to me:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想查找只属于某个特定用户的文件，可以使用`-user`开关。添加第二个条件来查找只属于某个特定用户的特定类型的文件。在这里，我正在搜索整个文件系统，寻找所有属于我的`.png`图形文件：
- en: '[PRE26]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Even with full `sudo` privileges, there are still a couple of directories where
    I’m not allowed to access. But, that’s okay.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 即使拥有完全的`sudo`权限，仍然有一些目录我无法访问。但这没关系。
- en: You can use the `-group` switch to find files that belong to a certain group.
    Here, I’m looking through my own home directory for either files or directories
    that are associated with the `nobody` group.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用`-group`开关来查找属于某个特定组的文件。在这里，我正在查看我自己主目录下，属于`nobody`组的文件或目录。
- en: '[PRE27]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Note that I’m still using `sudo` here, because even in my own home directory
    there are some directories that `find` won’t access without it. (These are the
    directories that contain information about Docker containers.)
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我在这里仍然使用`sudo`，因为即使在我自己的主目录中，也有一些目录在没有它的情况下`find`是无法访问的。（这些目录包含有关Docker容器的信息。）
- en: Conversely, you can use the `-nogroup` switch to find files that don’t belong
    to any group that’s listed in the `/etc/group` file.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，你可以使用`-nogroup`开关来查找不属于`/etc/group`文件中列出的任何组的文件。
- en: '[PRE28]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'In the Linux/Unix world, everything on the system is represented by a file.
    Normal users of a system will usually just encounter regular files and directories,
    but there are many other types of files that will be of interest to a system administrator.
    The various file types include:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 在Linux/Unix世界中，系统上的一切都表示为文件。系统的普通用户通常只会遇到常规文件和目录，但对于系统管理员来说，还有许多其他类型的文件会很重要。各种文件类型包括：
- en: '**Regular files:** These are the types of files that a normal user would routinely
    access. Graphics files, video files, database files, spreadsheet files, text files,
    and executable files are all examples of regular files.'
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**常规文件：** 这些是普通用户通常会访问的文件类型。图形文件、视频文件、数据库文件、电子表格文件、文本文件和可执行文件都是常规文件的例子。'
- en: '**Directories**: It seems strange that a directory is a type of file, but that’s
    just how it is in the Linux and Unix worlds.'
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**目录：** 目录作为一种文件类型可能会让人觉得奇怪，但在Linux和Unix的世界里，事情就是如此。'
- en: '**Character devices**: A character device either accepts or supplies a serial
    stream of data. A sound card or a terminal would be represented by a character
    device file. You’ll find these files in the `/dev/` directory.'
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**字符设备：** 字符设备要么接受，要么提供一个串行数据流。声卡或终端会由字符设备文件表示。你会在`/dev/`目录中找到这些文件。'
- en: '**Block devices**: A block device file represents devices that can be accessed
    in a random manner. Examples include hard drives, solid-state drives, and drive
    partitions. You’ll also find these files in the `/dev/` directory.'
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**块设备**：块设备文件代表可以随机访问的设备。示例包括硬盘、固态硬盘和驱动器分区。你还可以在`/dev/`目录中找到这些文件。'
- en: '**Named pipes**: These devices take the output from one system process and
    supply it as the input to another system process, thus enabling inter-process
    communication.'
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**命名管道**：这些设备接收一个系统进程的输出，并将其作为输入提供给另一个系统进程，从而实现进程间通信。'
- en: '**Sockets**: These are the same as named pipes, except that they can send and
    receive file descriptors as part of the communications stream. Also, unlike named
    pipes, sockets can allow two-way data exchange between two processes.'
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**套接字**：这些与命名管道相同，只是它们可以在通信流中发送和接收文件描述符。此外，与命名管道不同，套接字允许两个进程之间进行双向数据交换。'
- en: '**Symbolic links**: This type of file simply points to either a regular file
    or directory. This allows users to either access files and directories from multiple
    places in the filesystem, or to access them by different names.'
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**符号链接**：这种类型的文件只是指向一个普通文件或目录。这允许用户从文件系统的多个位置访问文件和目录，或者通过不同的名称访问它们。'
- en: 'You can tell what type a file is by doing an `ls -l` command. The first character
    in the output for each file is known as the **file mode string**. This file mode
    string designates the file type. For example, let’s look at what’s in my home
    directory:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过执行`ls -l`命令来判断文件的类型。每个文件输出的第一个字符被称为**文件模式字符串**。这个文件模式字符串表示文件类型。例如，让我们看看我家目录中的内容：
- en: '[PRE29]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Lines that begin with a `-` represent a regular file, and lines that begin
    with a `d` represent a directory. The various file types are represented as follows:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 以`-`开头的行表示普通文件，而以`d`开头的行表示目录。各种文件类型表示如下：
- en: '| **File mode string** | **File type** |'
  id: totrans-130
  prefs: []
  type: TYPE_TB
  zh: '| **文件模式字符串** | **文件类型** |'
- en: '| `-` | Regular file |'
  id: totrans-131
  prefs: []
  type: TYPE_TB
  zh: '| `-` | 普通文件 |'
- en: '| `d` | Directory |'
  id: totrans-132
  prefs: []
  type: TYPE_TB
  zh: '| `d` | 目录 |'
- en: '| `c` | Character device |'
  id: totrans-133
  prefs: []
  type: TYPE_TB
  zh: '| `c` | 字符设备 |'
- en: '| `b` | Block device |'
  id: totrans-134
  prefs: []
  type: TYPE_TB
  zh: '| `b` | 块设备 |'
- en: '| `p` | Named pipe |'
  id: totrans-135
  prefs: []
  type: TYPE_TB
  zh: '| `p` | 命名管道 |'
- en: '| `s` | Socket |'
  id: totrans-136
  prefs: []
  type: TYPE_TB
  zh: '| `s` | 套接字 |'
- en: '| `l` | Symbolic link |'
  id: totrans-137
  prefs: []
  type: TYPE_TB
  zh: '| `l` | 符号链接 |'
- en: 'Table 2.1: File type designators'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 表2.1：文件类型标识符
- en: 'There may be times when you’ll need to locate all files of a certain type.
    You can do that with the `-type` option, like so:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 有时你可能需要定位所有某一类型的文件。你可以通过使用`-type`选项来做到这一点，像这样：
- en: '[PRE30]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: As you see, I’m using the `-type p` option to search for all named pipe files.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，我使用`-type p`选项来搜索所有命名管道文件。
- en: 'Now, let’s consider the previous example in which we searched for all files
    that end with a `.conf` filename extension:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们考虑之前的例子，在这个例子中我们搜索了所有以`.conf`文件扩展名结尾的文件：
- en: '[PRE31]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'This command only found regular files because they’re the only types of files
    on the system that have the `.conf` filename extension. But, let’s now say that
    we want to search through the `/etc/` directory to find all subdirectories with
    the `conf` text string in their names. If we don’t specify a file type, we’ll
    see regular files, symbolic links, and directories:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 这个命令只找到了普通文件，因为它们是系统中唯一拥有`.conf`文件扩展名的文件类型。但是，现在假设我们想在`/etc/`目录中搜索所有包含`conf`文本字符串的子目录。如果我们没有指定文件类型，我们将看到普通文件、符号链接和目录：
- en: '[PRE32]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'We’ll use the `-type d` option to narrow things down:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用`-type d`选项来进一步缩小范围：
- en: '[PRE33]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Cool. We now only see the directories, which is exactly what we want.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 很棒。现在我们只看到目录，这正是我们想要的。
- en: As I said before, there are a lot of options that you can use with the `find`
    utility. (Enter `man find` to see them all.)
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 如我之前所说，`find`工具有很多选项可以使用。（输入`man find`可以查看所有选项。）
- en: Now, with the introduction to `find` out of the way, let’s look at how to use
    `find` to perform multiple actions with one command.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在介绍了`find`之后，让我们来看一下如何使用`find`通过一个命令执行多个操作。
- en: Performing Multiple Actions with find
  id: totrans-151
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用`find`执行多个操作
- en: Our next trick contains a bit of a twist. We’ll use `find`'s `-exec` and `-ok`
    option switches to make `find` perform some sort of action on each file that it
    finds. First, `find` finds the files. Then, it causes another command to run that
    will take some sort of action on the files. Here’s how it works.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 我们接下来的技巧有点复杂。我们将使用`find`的`-exec`和`-ok`选项来使`find`对每个找到的文件执行某种操作。首先，`find`找到文件。然后，它会触发另一个命令来对文件执行某种操作。它是这样工作的：
- en: The `-exec` and `-ok` switches tell the shell to perform a second command only
    if the first command produces valid output. It then uses the output of the first
    command (`find`) as arguments for the second. The difference between the two switches
    is that `-exec` causes the desired action to automatically execute on each file
    without prompting the user. The `-ok` switch will cause the action to stop after
    each file that `find` finds, asking the user whether or not to proceed with the
    action for that file. Here, we’re searching the entire filesystem for all `.zip`
    files that are more than 30 days old, and copying them to the `/home/donnie/`
    directory. (Note that I’m still using `sudo` so that I can access all directories.)
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: '`-exec` 和 `-ok` 开关告诉 shell 仅当第一个命令产生有效输出时，才执行第二个命令。然后，它将第一个命令（`find`）的输出作为第二个命令的参数。这两个开关之间的区别在于，`-exec`
    会在不提示用户的情况下自动对每个文件执行所需操作。而 `-ok` 开关会在 `find` 找到每个文件后暂停，询问用户是否继续对该文件执行操作。在这里，我们正在搜索整个文件系统中所有超过
    30 天的 `.zip` 文件，并将它们复制到 `/home/donnie/` 目录。（注意，我仍然使用 `sudo` 以便能够访问所有目录。）'
- en: '[PRE34]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: The `{}` after the `cp` command tells `bash` or `zsh`, “Take the results from
    the `find` command, and put them here as the arguments”. Note that this command
    sequence has to end with a semi-colon. But, since the semi-colon has special meaning
    for `bash` and `zsh`, you must precede it with a backslash so that `bash` and
    `zsh` will interpret it correctly.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: '`cp` 命令后的 `{}` 告诉 `bash` 或 `zsh`，“获取 `find` 命令的结果，并将其作为参数放到这里”。注意，这个命令序列必须以分号结尾。但是，由于分号对
    `bash` 和 `zsh` 有特殊含义，你必须在它前面加上反斜杠，以便 `bash` 和 `zsh` 能正确解释它。'
- en: Also, note that you must have a blank space after the first parenthesis, and
    another blank space before the backslash that precedes the last parenthesis.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 另外，注意你必须在第一个括号后留一个空格，并在反斜杠前的括号之前再留一个空格。
- en: Now, suppose that you only want to copy over some of the files that you find.
    Just replace the `-exec` switch with the `-ok` switch. It works the same as `-exec`,
    but it will ask permission before performing an operation on a file. You’ll have
    to enter either *y* or *n* before continuing to the next file.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，假设你只想复制找到的一部分文件。只需将 `-exec` 开关替换为 `-ok` 开关。它的工作方式与 `-exec` 相同，但在对文件执行操作之前会询问权限。你必须输入
    *y* 或 *n*，然后才能继续执行下一个文件。
- en: The same principle also works for removing files.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 同样的原理也适用于删除文件。
- en: '[PRE35]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Let’s now suppose that Vicky, Cleopatra, Frank, and Goldie are all creating
    graphics for some sort of project. They’re supposed to place the graphics files
    into the `graphics` subdirectory that each of them have in their own home directory.
    Sometimes they forget though, and place the files into their top-level home directories,
    as we see in the following diagram:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 假设现在 Vicky、Cleopatra、Frank 和 Goldie 都在为某个项目创建图形文件。它们应该将图形文件放入各自主目录下的 `graphics`
    子目录。有时他们会忘记，将文件放入各自的顶级主目录，如下图所示：
- en: '![](img/B21693_02_01.png)'
  id: totrans-161
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B21693_02_01.png)'
- en: 'Figure 2.1: Some of these graphics files are in the wrong place.'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.1：这些图形文件中的一些文件放错了位置。
- en: Now, let’s get a bit of hands-on practice with this.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们动手实践一下这个操作。
- en: Hands-on Lab – Using find to Perform Other Commands
  id: totrans-164
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 实践实验 – 使用 find 执行其他命令
- en: For this lab, use a Fedora, Debian, or Ubuntu virtual machine. (I’ll provide
    instructions for all of them.)
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个实验，使用 Fedora、Debian 或 Ubuntu 虚拟机。（我会提供它们的操作说明。）
- en: Let’s say that we want to copy everyone’s graphics files into a common backup
    directory.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们想将每个人的图形文件复制到一个公共的备份目录。
- en: 'First, create the `/backup` directory, like this:'
  id: totrans-167
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，像这样创建 `/backup` 目录：
- en: '[PRE36]'
  id: totrans-168
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE36]'
- en: For our present purposes, just leave ownership and permissions settings as they
    are.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 就我们目前的目的而言，暂时保持文件的所有权和权限设置不变。
- en: 'Next, create user accounts for Vicky, Cleopatra, Frank, and Goldie, and assign
    a password to each account. On Fedora, the commands would look like this:'
  id: totrans-170
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，创建 Vicky、Cleopatra、Frank 和 Goldie 的用户账户，并为每个账户分配密码。在 Fedora 上，命令如下所示：
- en: '[PRE37]'
  id: totrans-171
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'On either Debian or Ubuntu, use the interactive `adduser` command, which both
    creates the user account and sets the password. It looks like this:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Debian 或 Ubuntu 上，使用交互式的 `adduser` 命令，该命令会同时创建用户账户并设置密码。命令如下：
- en: '[PRE38]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Log into each user’s account, create a `graphics` directory in each user’s
    home directory, and then create some fake graphics files. Here are the commands
    to do that:'
  id: totrans-174
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 登录到每个用户的账户，在每个用户的主目录中创建一个 `graphics` 目录，然后创建一些假的图形文件。以下是执行这些操作的命令：
- en: '[PRE39]'
  id: totrans-175
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'The `touch` command is actually meant to be used by programmers for purposes
    that I won’t go into here. But, it’s also handy for situations like this, when
    you just need to create some fake files for testing purposes. By enclosing a comma-separated
    list of filenames within a pair of curly braces, you can create multiple files
    with just one single command. To verify that, let’s peek into the `graphics` directory:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: '`touch`命令实际上是为程序员设计的，用于一些我这里不打算深入讲解的用途。但它在这种情况下也很有用，尤其是当你只需要创建一些假文件进行测试时。通过将用逗号分隔的文件名列表放入一对大括号中，你可以通过一个命令创建多个文件。为了验证这一点，让我们看一下`graphics`目录：'
- en: '[PRE40]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'For this step, you’ll need to log back into your own user account. You want
    to be sure to get all of the graphics files, even if they’re in the users’ top-level
    home directories, and copy them into the `/backup/` directory. Your command and
    results would look like this:'
  id: totrans-178
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在这一步，你需要重新登录到你的用户帐户。你要确保获取所有的图形文件，即使它们在用户的顶级主目录中，也要将它们复制到`/backup/`目录中。你的命令和结果应该像这样：
- en: '[PRE41]'
  id: totrans-179
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE41]'
- en: What I’ve shown you here just barely scratches the surface of what you can do
    with `find`. To see the complete list of search criteria that you can specify,
    open the `find` man page and scroll down to the **TESTS** section.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 我在这里给你展示的内容只是`find`命令能做的事情的冰山一角。要查看你可以指定的所有搜索条件，请打开`find`的手册页面并滚动到**TESTS**部分。
- en: We’ll look at some more `find` examples a bit later. For now though, let’s look
    at how to create recursive commands.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 稍后我们将再看一些`find`的示例。现在，我们来看看如何创建递归命令。
- en: Running Commands Recursively
  id: totrans-182
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 递归运行命令
- en: We’ve already shown you that the `find` utility is inherently recursive. That
    is, it will automatically search through the subdirectories of your specified
    search path without you having to tell it to. Most Linux commands aren’t that
    way, however. If you want them to work recursively, you’ll have to tell them to.
    For the most part, this is done with either the `-R` switch or the `-r` switch.
    (Some commands use `–R`, and some use `–r`. Something that you’ll eventually see
    for yourself is that there’s not a lot of consistency in how the different commands
    work with option switches.) Let’s see how it all works with a hands-on lab.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经展示过`find`工具是递归的。也就是说，它会自动搜索你指定的搜索路径下的子目录，而无需你额外告诉它。 然而，大多数Linux命令并不是这样。如果你希望它们递归工作，你必须告诉它们。大多数情况下，这是通过`-R`或`-r`选项来完成的。（有些命令使用`–R`，有些使用`–r`。你最终会发现，不同命令在选项开关的使用上并没有很大的统一性。）让我们通过一个实操实验来看看它是如何工作的。
- en: The examples in this section involve using the numeric method to set file and
    directory permissions. For anyone who’s not familiar with how to do that, I’ve
    provided a reference in the *Further Reading* section.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 本节中的示例涉及使用数字方式设置文件和目录权限。对于那些不熟悉如何操作的人，我在*进一步阅读*部分提供了参考。
- en: Hands-on Lab – Using Commands with Recursion
  id: totrans-185
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实操实验 – 使用带递归的命令
- en: In this lab, you’ll be using the recursive option for the `ls` and `chmod` utilities.
    Let’s dig in.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个实验中，你将使用`ls`和`chmod`工具的递归选项。让我们深入了解一下。
- en: 'First, let’s create a new directory with a set of nested subdirectories, like
    this:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们创建一个带有嵌套子目录的新目录，像这样：
- en: '[PRE42]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Next, we want to look at the permissions settings for the entire nest of directories.
    So, let’s do this:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们要查看整个目录嵌套的权限设置。所以，让我们这样做：
- en: '[PRE43]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: Well now, that doesn’t help, does it? All we can see is just the first level
    subdirectory.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 哦，这并没有什么帮助，是吧？我们只能看到第一层子目录。
- en: 'Let’s try adding the `-R` option to see if that helps:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们尝试添加`-R`选项，看看是否有帮助：
- en: '[PRE44]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: This is much better, because we now see the permissions settings for all four
    of the nested subdirectories. But, we see that the permissions settings aren’t
    what we want. With the `755` permission setting that we currently have, we’re
    allowing the user to have read/write/execute access, while the group and others
    have read/execute access. What we really want is for the user and the group to
    both have read/write/execute access, and for others to have no access at all.
    We’ll do that by using `chmod` to change the permissions settings to `770`. The
    `-R` switch will allow us to change the settings for the top-level directory,
    as well as all four of the nested subdirectories.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 这已经好多了，因为我们现在可以看到所有四个嵌套子目录的权限设置。但是，我们发现权限设置并不是我们想要的。根据当前的`755`权限设置，我们允许用户拥有读/写/执行权限，而组和其他用户只有读/执行权限。我们真正想要的是让用户和组都拥有读/写/执行权限，而其他人则完全没有访问权限。我们将通过使用`chmod`命令将权限设置更改为`770`来实现。`-R`选项将允许我们更改顶级目录以及所有四个嵌套子目录的设置。
- en: 'Recursively set the correnct permissions setting with this command:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 使用以下命令递归地设置正确的权限：
- en: '[PRE45]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Now that you’ve removed access for others, you’ll need to use `sudo` to view
    the permissions settings:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 既然你已经为其他用户移除了访问权限，你将需要使用`sudo`来查看权限设置：
- en: '[PRE46]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: You see that the permissions setting is now `770` for the entire nest, which
    means that we have achieved extreme coolness.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 你会看到权限设置现在是`770`，表示我们已经实现了极致的酷炫。
- en: '**Tip**'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: '**提示**'
- en: You might, at some point, be called upon to create a shell script that will
    automatically compile and install a program. The ability to create nested directories
    and recursively change permissions settings on them will come in quite handy when
    writing those kinds of scripts.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会在某个时刻被要求创建一个自动编译和安装程序的 shell 脚本。在编写这种脚本时，创建嵌套目录并递归地更改它们的权限设置将非常有用。
- en: There are several other utilities that also have the recursive feature. (You’ll
    encounter some of them as you go through this book.) The slight catch is that
    for some of them the recursive option switch is `-r`, and for other it’s `-R`.
    But, that’s okay. When in doubt, just consult the man page for the utility that
    you need to use.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 还有其他一些实用工具也具有递归功能。（在本书的学习过程中，你会遇到其中的一些。）小小的区别是，对于某些工具，递归选项是`-r`，而对于其他工具则是`-R`。不过，这没关系。如果不确定，可以查阅你需要使用的工具的手册页。
- en: Now that we’ve covered recursion, let’s have a `history` lesson.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经了解了递归，接下来让我们来上一节`history`课程。
- en: Understanding the Command History
  id: totrans-204
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解命令历史
- en: Whenever you work with the command-line, there will be times when you’ll have
    to enter some commands more than once. If you’ve just entered a command that’s
    long and complex, you may not exactly be thrilled at the prospect of having to
    type it in all over again. Not to worry, though. For this, `bash` and `zsh` give
    you the ability to recall and/or edit commands that you’ve previously entered.
    There are a few ways to do this.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 每当你使用命令行时，会有一些时候你需要输入某些命令不止一次。如果你刚刚输入了一个既长又复杂的命令，你可能不会太高兴再次输入它。不过不用担心。对于这一点，`bash`和`zsh`提供了回忆和/或编辑你之前输入的命令的功能。实现这一点有几种方法。
- en: 'Whenever you enter a command, it gets stored in memory until you exit the shell
    session. The command will then get added to a file that’s specified by the `HISTFILE`
    variable. Usually, this is the `.bash_history` file on `bash`, and the `.histfile`
    file on `zsh`. You’ll find these stored in each user’s home directory. To verify
    that, you can use the `echo` command, like this:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 每当你输入命令时，它会存储在内存中，直到你退出 shell 会话。该命令会被添加到由`HISTFILE`变量指定的文件中。通常，这在`bash`中是`.bash_history`文件，在`zsh`中是`.histfile`文件。你可以在每个用户的主目录中找到这些文件。要验证这一点，你可以使用`echo`命令，像这样：
- en: '[PRE47]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'On `zsh`, you’ll see this:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 在`zsh`中，你会看到以下内容：
- en: '[PRE48]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'The number of commands that get saved to either the `.bash_history` file or
    the `.histfile` is set by the `HISTSIZE` variable in the `/etc/profile` file.
    (Both `bash` and `zsh` reference the same file.) You can use `grep` to search
    for that line without having to open the file, like so:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 保存在`.bash_history`文件或`.histfile`文件中的命令数量是由`/etc/profile`文件中的`HISTSIZE`变量设置的。（`bash`和`zsh`都参考了这个文件。）你可以使用`grep`来搜索该行，而无需打开文件，像这样：
- en: '[PRE49]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'You can also use `echo` to see the setting:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以使用`echo`来查看这个设置：
- en: '[PRE50]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: Either way, we see that the system is set up to store the last 1,000 user commands
    in the `.bash_history` file.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 无论如何，我们可以看到系统被设置为将最后 1,000 条用户命令保存在`.bash_history`文件中。
- en: More often than not, you’ll probably use the up and down arrow keys on your
    keyboard to call up previously entered commands. If you keep pressing the up arrow
    key, you’ll scroll through the list of previous commands, starting with the last
    one entered. If you go past the command that you want, you can use the down arrow
    key to get back to it. When you finally do get to the command that you want to
    repeat, you can either press the *Enter* key to enter it as is, or edit it and
    then press *Enter*.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数情况下，你可能会使用键盘上的上下箭头键来调用先前输入的命令。如果你不断按上箭头键，你将滚动浏览以前的命令列表，从最后输入的命令开始。如果你越过了你想要的命令，可以使用下箭头键返回到它。当你最终找到想要重复的命令时，你可以按*Enter*键直接输入，或者先编辑再按*Enter*键。
- en: 'You can also use the `!` in various ways to recall past commands. For example,
    entering `!!` will execute the last command that you entered, as you see here:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以用各种方式使用`!`来回顾过去的命令。例如，输入`!!`将执行你输入的最后一个命令，就像你看到的这样：
- en: '[PRE51]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'Use the `!` followed by a text string to execute the last executed command
    that begins with that string. Let’s say that I want to repeat the last `grep`
    command that I did, like this:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`!`后跟一个文本字符串，来执行最后执行过的以该字符串开头的命令。假设我想重复我做过的最后一个`grep`命令，像这样：
- en: '[PRE52]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'Use `!?` followed by a string to execute the last executed command that contains
    that string, like this:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`!?`后跟一个字符串来执行最后执行过的包含该字符串的命令，像这样：
- en: '[PRE53]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'Now, for the coolest part of all. First, let’s view the history list, like
    so:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，最酷的部分来了。首先，我们查看历史列表，像这样：
- en: '[PRE54]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'To execute a command from this list, enter `!` followed by the command number.
    For example, to perform the `echo` command again, enter `!478`, like so:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 要执行此列表中的命令，请输入`!`后跟命令编号。例如，要再次执行`echo`命令，请输入`!478`，像这样：
- en: '[PRE55]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'Of all of the `history` tricks that I’ve shown you, this last one is the most
    useful one for me. But wait, here’s yet one more trick that you might find useful.
    That is, you can display the command history along with timestamps that show when
    each command has been executed. On `bash`, just do this:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 在我展示的所有`history`技巧中，最后这个对我来说是最有用的。但等一下，这里还有一个你可能会觉得有用的技巧。也就是说，你可以显示命令历史记录，并带有显示每个命令执行时间戳的功能。在`bash`中，只需这样做：
- en: '[PRE56]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'The output will look something like this:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 输出将类似于这样：
- en: '[PRE57]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: What’s happening here is that we’re configuring the `HISTTIMEFORMAT` environmental
    variable to display the timestamp in our desired format, and then running the
    `history` command.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 这里发生的情况是，我们正在配置`HISTTIMEFORMAT`环境变量，以显示我们期望的时间戳格式，然后运行`history`命令。
- en: 'This is somewhat easier on `zsh`, because `zsh` allows us to use `history`
    with the `-f` option switch, like so:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 在`zsh`中，这稍微容易一些，因为`zsh`允许我们使用带有`-f`选项开关的`history`，像这样：
- en: '[PRE58]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'Note that running `history -f` on `bash` will give you an error message, like
    this one:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，在`bash`上运行`history -f`会给出错误信息，如下所示：
- en: '[PRE59]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: All right, let’s move on to the next topic.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，我们继续下一个话题。
- en: Escaping and Quoting
  id: totrans-236
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 转义和引用
- en: Whenever you type anything on the command-line or into a shell script, you’ll
    be using a mix of normal alphanumeric text and non-alphanumeric characters. Some
    of these characters have special meanings within the shell, and will cause the
    shell to perform in some special way. Sometimes, you’ll want the shell to interpret
    these special characters as normal text, instead of as something with a magical
    power. To do that, you can either **escape** or **quote** the special characters.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 每当你在命令行中输入任何内容或在 Shell 脚本中输入时，你将使用普通的字母数字文本和非字母数字字符的混合。某些字符在 Shell 中具有特殊含义，会导致
    Shell 以某种特殊方式执行。有时，你可能希望 Shell 将这些特殊字符视为普通文本，而不是具有魔法般的功能。为了实现这一点，你可以选择**转义**或**引用**这些特殊字符。
- en: 'There are two general classes of characters that can be interpreted by the
    shell from within a shell command. These are:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Shell 命令中，Shell 可以解释的字符通常分为两类。这些是：
- en: '**Normal characters**: `bash` and `zsh` interpret these characters literally.
    In other words, they have no special meaning to the shell.'
  id: totrans-239
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**普通字符**：`bash`和`zsh`会字面解释这些字符。换句话说，它们对 Shell 没有特殊含义。'
- en: '**Metacharacters**: These characters have special meanings for `bash` and `zsh`.
    You could say that a metacharacter provides some sort of special instruction to
    these shells.'
  id: totrans-240
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**元字符**：这些字符对`bash`和`zsh`有特殊的含义。可以说，元字符为这些 Shell 提供了某种特殊的指令。'
- en: 'Here’s a space-separated list of metacharacters that can be used in either
    shell scripts or shell commands:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个由空格分隔的元字符列表，可以在 Shell 脚本或 Shell 命令中使用：
- en: '[PRE60]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: I’d rather not try to explain what each one does right now, because many of
    them can perform multiple functions, depending upon the context of the command.
    But, we’ve already seen some of them in action, and we’ll see the rest of them
    in action as we progress through this book.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 我现在不想解释每个元字符的功能，因为其中许多可以根据命令的上下文执行多个功能。不过，我们已经在前面的示例中看到了一些元字符的使用，接下来我们会在本书的后续内容中看到其余元字符的应用。
- en: Escaping Metacharacters
  id: totrans-244
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 转义元字符
- en: 'We’ve already seen some of these metacharacters in action in the previous examples.
    To further demonstrate, let’s look at the humble `*` metacharacter, which can
    be used as a wildcard. Let’s first do a directory listing of all of the `.conf`
    files in the `/etc/` directory, like so:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例中，我们已经看到一些元字符的应用。为了进一步演示，让我们看看不起眼的`*`元字符，它可以用作通配符。我们先列出`/etc/`目录下所有的`.conf`文件，像这样：
- en: '[PRE61]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'You see that I’ve just listed all files with filenames that end with a `.conf`
    filename extension. Now, let’s place a `\` in front of the `*`, like this:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 你看到我刚刚列出了所有文件名以`.conf`扩展名结尾的文件。现在，让我们在`*`前面加上一个`\`，像这样：
- en: '[PRE62]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: Placing the `\` in front of the `*` caused the shell to interpret the `*` literally,
    instead of as a metacharacter. Instead of looking for all files with `.conf` at
    the end of their filenames, we’re now looking for just one specific file with
    the filename, `*.conf`. No such file exists, so `ls` returned an error message.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 在`*`前面加上`\`导致Shell按字面意义解释`*`，而不是将其视为元字符。现在，我们不是在查找所有以`.conf`结尾的文件，而是在查找名为`*.conf`的特定文件。由于没有这样的文件，`ls`返回了一个错误信息。
- en: 'In our `find` example where we performed a compound search, we had to place
    a `\` in front of each parenthesis character so that the shell would interpret
    them correctly. Here’s what that looked like:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们之前的`find`示例中，当我们执行复合搜索时，我们必须在每个括号前加上`\`，以便Shell能正确解释它们。这就是当时的情况：
- en: '[PRE63]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'Now, let’s try it without the \ characters:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们试试不加`\`字符的情况：
- en: '[PRE64]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: This time, I get an error message, because `bash` doesn’t understand what I’m
    trying to do.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 这次，我收到一个错误信息，因为`bash`不理解我正在尝试做什么。
- en: 'Now, just for fun, try this pair of commands on your own machine and note the
    difference in output:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，出于好玩，试试在你自己的机器上执行这对命令，并注意输出的差异：
- en: '[PRE65]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: I guess that I should mention that when you place a `\` in front of a metacharacter
    so that the shell will interpret the metacharacter literally, it’s called **escaping**
    the metacharacter. This is something that you’ll use extensively for either normal
    shell commands or shell scripting.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 我想我应该提到，当你在元字符前加上`\`，使得Shell按字面意思解释元字符时，这叫做**转义**元字符。这是你在执行普通Shell命令或编写Shell脚本时会广泛使用的技术。
- en: Okay, let’s look at another way to make the shell interpret metacharacters literally.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，让我们看另一种让Shell按字面意义解释元字符的方法。
- en: Quoting
  id: totrans-259
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 引号
- en: 'You sometimes might have to quote a text string when performing a shell command
    or writing a shell script. This simply involves surrounding the text string with
    either a pair of double quotes (`"`) or a pair of single quotes (`''`). If you
    surround a text string with a pair of single quotes, the shell will interpret
    any metacharacters that are within the quotes as normal, literal characters. If
    you surround a text string with a pair of double quotes, the shell will interpret
    most, but not all, metacharacters as normal, literal characters. To show how that
    works, let’s create a programming variable that we’ll call `name`, and assign
    to it the value `charlie`, like so:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 在执行Shell命令或编写Shell脚本时，你有时可能需要引用文本字符串。这只需要将文本字符串用一对双引号（`"`)或一对单引号（`'`）括起来。如果你用一对单引号将文本字符串括起来，Shell会将引号内的任何元字符解释为正常的字面字符。如果你用一对双引号将文本字符串括起来，Shell会将大部分元字符（但不是全部）解释为正常的字面字符。为了展示这一点，让我们创建一个名为`name`的编程变量，并将其赋值为`charlie`，如下所示：
- en: '[PRE66]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'Next, we’ll try to echo back the value of `name`, using a pair of single quotes:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将尝试回显`name`的值，使用一对单引号：
- en: '[PRE67]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'You see that the single quotes cause the shell to interpret the `$` as a literal
    character. Now, let’s see what happen if we use a pair of double quotes:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 你看到单引号使得Shell将`$`解释为字面字符。现在，让我们看看如果我们使用一对双引号会发生什么：
- en: '[PRE68]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: This time, we see the variable’s actual value, because the `$` is one of the
    metacharacters that the double quotes won’t treat as a literal character.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 这一次，我们看到了变量的实际值，因为`$`是一个元字符，双引号不会将其视为字面字符。
- en: We’ll cover the topic of programming variables more in depth later. So for now,
    don’t stress out if you don’t fully understand the concept.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 我们稍后会更深入地讲解编程变量的主题。所以目前，如果你还不完全理解这个概念，也不要太担心。
- en: 'For reference, here’s the complete list of metacharacters that won’t get interpreted
    as literal characters by surrounding them with double quotes:'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 作为参考，以下是不会被解释为字面字符的元字符完整列表，方法是将它们用双引号括起来：
- en: '`"`'
  id: totrans-269
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`"`'
- en: '`\`'
  id: totrans-270
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`\`'
- en: '`` ` ``'
  id: totrans-271
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`` ` ``'
- en: '`$`'
  id: totrans-272
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`$`'
- en: To clarify, the list consists of the double quote character, the backslash,
    the back-tick, and the dollar sign. (For now, don’t worry about what all of these
    metacharacters do. We’ll cover them all in due time.)
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 为了澄清，列表包括双引号字符、反斜杠、反引号和美元符号。（目前，别担心这些元字符的作用。我们会在适当的时候讲解它们。）
- en: 'For all other metacharacters, it doesn’t matter whether you use double quotes
    or single quotes. Let’s look at this example that uses a wildcard character:'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 对于所有其他元字符，是否使用双引号或单引号并不重要。我们来看这个使用通配符字符的例子：
- en: '[PRE69]'
  id: totrans-275
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'Either way, the result is the same. Both times, the `*` gets treated as a literal
    character. To use the `*` as an actual metacharacter, just omit the quotes, like
    so:'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 无论哪种方式，结果是相同的。每次，`*`都会被当作字面字符处理。要将`*`作为实际的元字符使用，只需省略引号，如下所示：
- en: '[PRE70]'
  id: totrans-277
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: Okay, that pretty much does it for escaping and quoting, as well as for the
    whole chapter. Let’s summarize and move on.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，转义和引用部分差不多就到此为止，这一章也讲完了。让我们总结一下并继续。
- en: Summary
  id: totrans-279
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: We’ve covered some important basics in this chapter. We started by describing
    the structure and the components of a shell command, and how to perform multiple
    actions with just one single command. Then, we looked at the `find` utility, and
    the cool things that you can do with it. We then looked at how to run commands
    recursively, and wrapped up with a discussion about escaping and quoting.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们已经覆盖了一些重要的基础知识。我们首先描述了shell命令的结构和组成部分，以及如何通过一个命令执行多个操作。接着，我们看了`find`工具以及你可以用它做的有趣事情。然后，我们讨论了如何递归执行命令，最后总结了转义和引用的内容。
- en: In the next chapter, we’ll talk about variables and pipelines. I’ll see you
    there.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将讨论变量和管道。我们在那里见。
- en: Questions
  id: totrans-282
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: Which of the following sets of metacharacters would cause the second command
    to run only if the first command runs successfully?
  id: totrans-283
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下哪个元字符集会使第二个命令仅在第一个命令成功执行后运行？
- en: '`||`'
  id: totrans-284
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`||`'
- en: '`&&`'
  id: totrans-285
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`&&`'
- en: '`|`'
  id: totrans-286
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`|`'
- en: '`&`'
  id: totrans-287
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`&`'
- en: You want to run a command that contains the `$` metacharacter, but you want
    the shell to interpret the metacharacter literally. How would you do that? (Choose
    two.)
  id: totrans-288
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你想运行一个包含`$`元字符的命令，但你希望shell将该元字符按字面意思解释。你该怎么做？（选择两项）
- en: Precede the metacharacter with a `/`.
  id: totrans-289
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在元字符前加上`/`。
- en: Surround the text string that contains the metacharacter with a pair of single
    quotes.
  id: totrans-290
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将包含元字符的文本字符串用一对单引号括起来。
- en: Precede the metacharacter with a `\`.
  id: totrans-291
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在元字符前加上`\`。
- en: Surround the text string that contains the metacharacter with a pair of double
    quotes.
  id: totrans-292
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将包含元字符的文本字符串用一对双引号括起来。
- en: It’s not possible.
  id: totrans-293
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这是不可能的。
- en: You’re using `find` to search for files on a FreeBSD system. To search through
    the current working directory, what must you do on FreeBSD that you don’t have
    to do on Linux?
  id: totrans-294
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你正在使用`find`在FreeBSD系统上搜索文件。要在当前工作目录中搜索，在FreeBSD上必须做什么，而在Linux上不需要做的？
- en: Use a dot to designate the search path.
  id: totrans-295
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用点符号指定搜索路径。
- en: Nothing. The commands are performed the same way on both systems.
  id: totrans-296
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 没有区别。这两个系统上的命令执行方式是相同的。
- en: This isn’t possible on a FreeBSD system.
  id: totrans-297
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在FreeBSD系统上无法实现这一点。
- en: Use `sudo`.
  id: totrans-298
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`sudo`。
- en: You want to create a nested directory structure with one single `mkdir` command.
    How would you do that?
  id: totrans-299
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你想用一个`mkdir`命令创建一个嵌套的目录结构。你该如何操作？
- en: Use the `-r` option to make `mkdir` run recursively.
  id: totrans-300
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`-r`选项使`mkdir`递归运行。
- en: Use the `-R` option to make `mkdir` run recursively.
  id: totrans-301
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`-R`选项使`mkdir`递归运行。
- en: Use the `-P` option.
  id: totrans-302
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`-P`选项。
- en: Use the `-p` option.
  id: totrans-303
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`-p`选项。
- en: You want to automatically perform an action on every file that `find` finds,
    without being prompted. Which `find` option would you use to do that?
  id: totrans-304
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你希望自动对`find`找到的每个文件执行某个操作，而不需要提示。你会使用哪个`find`选项来实现？
- en: '`-ok`'
  id: totrans-305
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`-ok`'
- en: '`-exec`'
  id: totrans-306
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`-exec`'
- en: '`--exec`'
  id: totrans-307
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`--exec`'
- en: '`--ok`'
  id: totrans-308
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`--ok`'
- en: Further Reading
  id: totrans-309
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: 'Linux File Permissions Explained: [https://www.redhat.com/sysadmin/linux-file-permissions-explained](https://www.redhat.com/sysadmin/linux-file-permissions-explained)'
  id: totrans-310
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Linux 文件权限解释：[https://www.redhat.com/sysadmin/linux-file-permissions-explained](https://www.redhat.com/sysadmin/linux-file-permissions-explained)
- en: 'How to Use Bash Wildcards for Globbing?: [https://www.shell-tips.com/bash/wildcards-globbing/#gsc.tab=0](https://www.shell-tips.com/bash/wildcards-globbing/#gsc.tab=0)'
  id: totrans-311
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何使用 Bash 通配符进行全局匹配？：[https://www.shell-tips.com/bash/wildcards-globbing/#gsc.tab=0](https://www.shell-tips.com/bash/wildcards-globbing/#gsc.tab=0)
- en: 'How to Recursively Search Directory Names in Linux: [https://www.howtogeek.com/devops/how-to-recursively-search-directory-names-in-linux/](https://www.howtogeek.com/devops/how-to-recursively-search-directory-names-in-linux/)'
  id: totrans-312
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何在 Linux 中递归搜索目录名称：[https://www.howtogeek.com/devops/how-to-recursively-search-directory-names-in-linux/](https://www.howtogeek.com/devops/how-to-recursively-search-directory-names-in-linux/)
- en: 'Find Command in Linux: [https://linuxize.com/post/how-to-find-files-in-linux-using-the-command-line/](https://linuxize.com/post/how-to-find-files-in-linux-using-the-command-line/)'
  id: totrans-313
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Linux 中的 Find 命令：[https://linuxize.com/post/how-to-find-files-in-linux-using-the-command-line/](https://linuxize.com/post/how-to-find-files-in-linux-using-the-command-line/)
- en: '10 Ways to Use the Linux find Command: [https://www.redhat.com/sysadmin/linux-find-command](https://www.redhat.com/sysadmin/linux-find-command)'
  id: totrans-314
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Linux find 命令的 10 种方法：[https://www.redhat.com/sysadmin/linux-find-command](https://www.redhat.com/sysadmin/linux-find-command)
- en: 'What are Linux Metacharacters? Everything You Need to Know: [https://www.makeuseof.com/what-are-linux-metacharacters/](https://www.makeuseof.com/what-are-linux-metacharacters/)'
  id: totrans-315
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 什么是 Linux 元字符？你需要知道的一切：[https://www.makeuseof.com/what-are-linux-metacharacters/](https://www.makeuseof.com/what-are-linux-metacharacters/)
- en: '6 Linux metacharacters I love to use on the command line: [https://opensource.com/article/22/2/metacharacters-linux](https://opensource.com/article/22/2/metacharacters-linux)'
  id: totrans-316
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我喜欢在命令行上使用的 6 个 Linux 元字符：[https://opensource.com/article/22/2/metacharacters-linux](https://opensource.com/article/22/2/metacharacters-linux)
- en: 'How to Use Your Bash Historyin the Linux or MacOS Terminal: [https://www.howtogeek.com/44997/how-to-use-bash-history-to-improve-your-command-line-productivity/](https://www.howtogeek.com/44997/how-to-use-bash-history-to-improve-your-command-line-productivity/)'
  id: totrans-317
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何在 Linux 或 MacOS 终端中使用 Bash 历史记录：[https://www.howtogeek.com/44997/how-to-use-bash-history-to-improve-your-command-line-productivity/](https://www.howtogeek.com/44997/how-to-use-bash-history-to-improve-your-command-line-productivity/)
- en: 'Navigating Bash History Ctrl+r: [https://lornajane.net/posts/2011/navigating-bash-history-with-ctrlr](https://lornajane.net/posts/2011/navigating-bash-history-with-ctrlr)'
  id: totrans-318
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Bash 历史记录 Ctrl+r：[https://lornajane.net/posts/2011/navigating-bash-history-with-ctrlr](https://lornajane.net/posts/2011/navigating-bash-history-with-ctrlr)
- en: 'How to Find When a Command is Executed in Linux: [https://ostechnix.com/find-when-a-command-is-executed-in-linux/](https://ostechnix.com/find-when-a-command-is-executed-in-linux/)'
  id: totrans-319
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何查找 Linux 中何时执行命令：[https://ostechnix.com/find-when-a-command-is-executed-in-linux/](https://ostechnix.com/find-when-a-command-is-executed-in-linux/)
- en: 'Escape Quotes in Bash: [https://linuxsimply.com/bash-scripting-tutorial/quotes/escape-quotes/](https://linuxsimply.com/bash-scripting-tutorial/quotes/escape-quotes/)'
  id: totrans-320
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 Bash 中转义引号：[https://linuxsimply.com/bash-scripting-tutorial/quotes/escape-quotes/](https://linuxsimply.com/bash-scripting-tutorial/quotes/escape-quotes/)
- en: Answers
  id: totrans-321
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 答案
- en: b
  id: totrans-322
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: b
- en: b and c
  id: totrans-323
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: b 和 c
- en: a
  id: totrans-324
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: a
- en: d
  id: totrans-325
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: d
- en: b
  id: totrans-326
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: b
- en: Join our community on Discord!
  id: totrans-327
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 加入我们的 Discord 社区！
- en: Read this book alongside other users, Linux experts, and the author himself.
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 与其他用户、Linux 专家以及作者本人一起阅读本书。
- en: Ask questions, provide solutions to other readers, chat with the author via
    Ask Me Anything sessions, and much more. Scan the QR code or visit the link to
    join the community.
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 提问、为其他读者提供解决方案、通过“问我任何问题”环节与作者交流，还有更多。扫描二维码或访问链接加入社区。
- en: '[https://packt.link/SecNet](https://packt.link/SecNet)'
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://packt.link/SecNet](https://packt.link/SecNet)'
- en: '![](img/QR_Code10596186092701843.png)'
  id: totrans-331
  prefs: []
  type: TYPE_IMG
  zh: '![](img/QR_Code10596186092701843.png)'
