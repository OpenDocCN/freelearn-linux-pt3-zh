<html><head></head><body><div id="sbo-rt-content" class="calibre1"><div id="_idContainer023" class="calibre2">
			<h1 id="_idParaDest-172" class="calibre5"><em class="italic"><a id="_idTextAnchor174" class="pcalibre calibre6 pcalibre1"/>Chapter 6</em>: Configuring SELinux through Infrastructure-as-Code Orchestration</h1>
			<p class="calibre3">With the advent of large distributed application platforms, cloud services, and the high adoption of virtualized infrastructure, system administrators are actively managing their systems through <strong class="bold">Infrastructure-as-Code</strong> frameworks: orchestration and configuration tooling that uses source code-like information to manage the systems.</p>
			<p class="calibre3">In this chapter, administrators will learn how to distribute and load custom SELinux policy modules, set file context definitions and apply those to the systems, set the permissive state of the system or SELinux domains, configure the SELinux settings on the systems, and how to customize SELinux actions if they are not supported by the tooling. We will apply this with four popular automation frameworks: Ansible, Chef, Puppet, and SaltStack.</p>
			<p class="calibre3">We will cover the following topics in this chapter:</p>
			<ul class="calibre8">
				<li class="calibre9">Introducing the target settings and policies</li>
				<li class="calibre9">Using Ansible for SELinux system administration</li>
				<li class="calibre9">Utilizing SaltStack to configure SELinux</li>
				<li class="calibre9">Automating system management with Puppet</li>
				<li class="calibre9">Wielding Chef for system automation</li>
			</ul>
			<h1 id="_idParaDest-173" class="calibre5"><a id="_idTextAnchor175" class="pcalibre calibre6 pcalibre1"/>Technical requirements</h1>
			<p class="calibre3">The code files for this chapter can be found in our Git repository at <a href="https://github.com/PacktPublishing/SELinux-System-Administration-Third-Edition" class="pcalibre calibre6 pcalibre1">https://github.com/PacktPublishing/SELinux-System-Administration-Third-Edition</a>.</p>
			<p class="calibre3">Check out the following video to see the Code in Action: <a href="https://bit.ly/2T4Fksv" class="pcalibre calibre6 pcalibre1">https://bit.ly/2T4Fksv</a></p>
			<h1 id="_idParaDest-174" class="calibre5"><a id="_idTextAnchor176" class="pcalibre calibre6 pcalibre1"/>Introducing the target settings and policies</h1>
			<p class="calibre3">Before we <a id="_idIndexMarker422" class="pcalibre calibre6 pcalibre1"/>embark on the journey of using these four automation frameworks, we need to clarify what we want to accomplish. After all, to truly compare automation frameworks, we need to test each framework with the same tests each time.</p>
			<h2 id="_idParaDest-175" class="calibre10"><a id="_idTextAnchor177" class="pcalibre calibre6 pcalibre1"/>The idempotency of actions</h2>
			<p class="calibre3">Whenever <a id="_idIndexMarker423" class="pcalibre calibre6 pcalibre1"/>we create a remote management environment with a central repository, we need to consider the impact of running remote management activities on the system. A very common best practice, strongly adopted by all these frameworks, is idempotency.</p>
			<p class="calibre3">An <strong class="bold">idempotent</strong> task is a <a id="_idIndexMarker424" class="pcalibre calibre6 pcalibre1"/><a id="_idIndexMarker425" class="pcalibre calibre6 pcalibre1"/>task that will not modify a system if the system's state is already how it should be. Or, differently put, repeatedly executing a task does not affect the system or the processes that run on it if nothing needs to be changed. As an example, consider loading an SELinux module: if the module is already loaded, then the module should not be reloaded. If it isn't loaded yet, then we will load the proper module.</p>
			<p class="calibre3">While most actions supported by the automation frameworks are idempotent, we will need to create custom actions ourselves if the framework does not support what we want. For instance, if the framework does not support loading SELinux modules, then we need to write our own code to do so.</p>
			<p class="calibre3">Most orchestration frameworks will envelope non-idempotent tasks in a definition that is more idempotent. For instance, if a change in a configuration file requires a system reboot, then the enveloped definition would be something like <em class="italic">reboot after file change</em>. The engine can check the state of the file (when it changed) and the system (when it rebooted) and deduce whether a reboot is needed or not, even though a system reboot as a task is a non-idempotent task.</p>
			<h2 id="_idParaDest-176" class="calibre10"><a id="_idTextAnchor178" class="pcalibre calibre6 pcalibre1"/>Policy and state management</h2>
			<p class="calibre3">The first <a id="_idIndexMarker426" class="pcalibre calibre6 pcalibre1"/>set of scenarios that we want to support through the automation frameworks is to ensure that SELinux is active (enforcing) and that the right SELinux policy is loaded, a task usually performed by the machine's package management system. While allowing the package management system to handle this is convenient, it only offers the ability to use distribution-specific default policies. Sysadmins of systems with different security requirements will be restrained when using default policies and will need to create custom policies and policy handling routines. So, we will examine how to distribute and load custom policies.</p>
			<p class="calibre3">The custom policy we will use in the examples is a CIL policy, which is very new and often not directly supported by the automation frameworks. However, it gives us a nice reoccurring situation to create custom rules within the automation framework. We store the policy itself in a file called <strong class="source-inline">test.cil</strong> that has the following content:</p>
			<p class="source-code">(auditallow staff_sudo_t sysadm_t (process (transition)))</p>
			<p class="calibre3">This simple policy will enable logging any transition from the <strong class="source-inline">staff_sudo_t</strong> domain to the <strong class="source-inline">sysadm_t</strong> domain and is easy to test out with <strong class="source-inline">sudo</strong>. In our example, it serves no other purpose than <a id="_idIndexMarker427" class="pcalibre calibre6 pcalibre1"/>to quickly allow us to verify that the policy has been correctly loaded.</p>
			<p class="calibre3">State-wise, we will ensure that the system is in enforcing mode, but have the <strong class="source-inline">zoneminder_t</strong> SELinux domain marked as permissive.</p>
			<h2 id="_idParaDest-177" class="calibre10"><a id="_idTextAnchor179" class="pcalibre calibre6 pcalibre1"/>SELinux configuration settings</h2>
			<p class="calibre3">The second <a id="_idIndexMarker428" class="pcalibre calibre6 pcalibre1"/>group of actions we want to take up is to configure the system with the various SELinux settings we've discussed in different chapters before. Most of these we've seen through the <strong class="source-inline">semanage</strong> commands, and we will learn how the various automation frameworks support these entries, and to what extent.</p>
			<p class="calibre3">We will not go through every setting, but rather focus on the supported configuration sets within each automation framework. If a framework does not support a particular configuration (such as the <strong class="source-inline">semanage ibpkey</strong> one, which is fairly new), we will need to create custom actions for this. In that case, we will show how to approach this once, as it is a recurring and similar approach for the others as well.</p>
			<h2 id="_idParaDest-178" class="calibre10"><a id="_idTextAnchor180" class="pcalibre calibre6 pcalibre1"/>Setting file contexts</h2>
			<p class="calibre3">The third <a id="_idIndexMarker429" class="pcalibre calibre6 pcalibre1"/>and final group of actions we want to see is how the automation frameworks support applying file contexts to resources. This can be applying an <strong class="source-inline">semanage fcontext</strong> configuration, after which a restore operation is done (such as with <strong class="source-inline">restorecon</strong>), but also validating whether the framework supports applying contexts directly.</p>
			<p class="calibre3">Directly applying the context allows administrators to use the frameworks directly without having to twiddle with creating and reapplying file context definitions (which can have some performance overhead). However, this should only be considered if the automation framework is the sole method through which system changes can be made. In any other case, having missing file context definitions might lead to administrators resetting contexts to an incorrect state.</p>
			<h2 id="_idParaDest-179" class="calibre10"><a id="_idTextAnchor181" class="pcalibre calibre6 pcalibre1"/>Recovering from mistakes</h2>
			<p class="calibre3">In this <a id="_idIndexMarker430" class="pcalibre calibre6 pcalibre1"/>chapter, we're diving into the various frameworks that allow managing SELinux across a multitude of systems. It is not the intention of this chapter to explain the frameworks themselves in detail, nor the secure configuration of the frameworks themselves. We don't recommend immediately applying this to production systems without testing first, and make sure to have backups!</p>
			<p class="calibre3">That being said, many settings applied in this chapter are easily corrected if things fail. We refer to <a href="B16276_02_Final_VK.xhtml#_idTextAnchor045" class="pcalibre calibre6 pcalibre1"><em class="italic">Chapter 2</em></a>, <em class="italic">Understanding SELinux Decisions and Logging</em>, to selectively put SELinux in permissive mode if needed.</p>
			<p class="calibre3">Furthermore, each <a id="_idIndexMarker431" class="pcalibre calibre6 pcalibre1"/>framework can easily be suspended, allowing administrators to correct issues without being affected by the framework overwriting the changes immediately after.</p>
			<h2 id="_idParaDest-180" class="calibre10"><a id="_idTextAnchor182" class="pcalibre calibre6 pcalibre1"/>Comparing frameworks</h2>
			<p class="calibre3">Every framework <a id="_idIndexMarker432" class="pcalibre calibre6 pcalibre1"/>we discuss further has its own approach to infrastructure automation and configuration. It is not the intention of this book to dwell on the details of each framework, but rather to focus on its core support and how it deals with SELinux. We will also abstract away how to handle different Linux distributions and have all examples based on CentOS.</p>
			<p class="calibre3">Furthermore, these frameworks are continuously improving and evolving. When we consider these frameworks in this chapter, we only explore how they are commonly used, and not how they can specialize in specific deployments. For instance, if a framework uses an agent-based architecture by default but also supports SSH-based connections, we will only consider the agent-based one in this book, as that is the default setup for these frameworks and we want to focus on the SELinux configuration support features.</p>
			<p class="calibre3">But don't let this stop you from experimenting with the frameworks further and adapting them to your own liking! That said, let's dive into our first engine, Ansible.</p>
			<h1 id="_idParaDest-181" class="calibre5"><a id="_idTextAnchor183" class="pcalibre calibre6 pcalibre1"/>Using Ansible for SELinux system administration</h1>
			<p class="calibre3">The <a id="_idIndexMarker433" class="pcalibre calibre6 pcalibre1"/>first orchestration and automation <a id="_idIndexMarker434" class="pcalibre calibre6 pcalibre1"/>tooling we'll consider is Ansible, a very popular open source solution for the remote management of systems. Ansible has commercial backing through Red Hat but does not limit its support to Red Hat or even Linux systems. Other environments such as Windows environments or even network setups have significant Ansible-based support.</p>
			<h2 id="_idParaDest-182" class="calibre10"><a id="_idTextAnchor184" class="pcalibre calibre6 pcalibre1"/>How Ansible works</h2>
			<p class="calibre3"><strong class="bold">Ansible</strong> generally <a id="_idIndexMarker435" class="pcalibre calibre6 pcalibre1"/>uses a central server that hosts the configuration and <a id="_idIndexMarker436" class="pcalibre calibre6 pcalibre1"/>interprets the settings. The Ansible runtime then connects to the remote systems over SSH, sending the necessary data to a temporary location, and then executes the steps locally.</p>
			<p class="calibre3">The use of SSH as its main connection approach has significant advantages: administrators know how this protocol works and how to configure and control it. Furthermore, Ansible does not require any additional deployments on the target machines, except for Python and libselinux's Python bindings (which are often installed on SELinux-enabled machines by default).</p>
			<p class="calibre3">Ansible knows how to address the various resources through its modules. <strong class="bold">Ansible modules</strong> contain <a id="_idIndexMarker437" class="pcalibre calibre6 pcalibre1"/>the logic that Ansible uses to execute tasks correctly. The module code is distributed to the target machines and is executed on the remote systems.</p>
			<p class="calibre3">The definitions that administrators configure systems with are stored in Ansible playbooks. <strong class="bold">Playbooks</strong> define <a id="_idIndexMarker438" class="pcalibre calibre6 pcalibre1"/>how a system should be configured, and Ansible will read and interpret playbooks to see what it must execute on each system.</p>
			<p class="calibre3">To facilitate the management of Ansible playbooks in larger environments, Ansible uses <strong class="bold">Ansible roles</strong> to bundle <a id="_idIndexMarker439" class="pcalibre calibre6 pcalibre1"/>coherent definitions. Administrators can then, in their playbooks, assign roles to systems to automatically uplift the state of those systems accordingly. For instance, a role can be created to create a properly configured web server, a database, and so on.</p>
			<p class="calibre3">In this <a id="_idIndexMarker440" class="pcalibre calibre6 pcalibre1"/>chapter, we will create a role called <strong class="source-inline">packt_selinux</strong> and apply it to a remote system. Within that role, we will show how to configure and execute the various SELinux tasks using Ansible.</p>
			<h2 id="_idParaDest-183" class="calibre10"><a id="_idTextAnchor185" class="pcalibre calibre6 pcalibre1"/>Installing and configuring Ansible</h2>
			<p class="calibre3">To install <a id="_idIndexMarker441" class="pcalibre calibre6 pcalibre1"/>and set up Ansible, most Linux distributions offer out-of-the-box <a id="_idIndexMarker442" class="pcalibre calibre6 pcalibre1"/>support for the framework. On CentOS, the following steps can be taken. Users of other distributions can easily deduce the steps for their platform:</p>
			<ol class="calibre18">
				<li class="calibre9">You <a id="_idIndexMarker443" class="pcalibre calibre6 pcalibre1"/>need to enable <strong class="bold">Extra Packages for Enterprise Linux</strong> (<strong class="bold">EPEL</strong>), after which you can install Ansible easily. Execute this on the master node (from which you want to manage the other systems):<p class="source-code"><strong class="bold"># yum install epel-release</strong></p><p class="source-code"><strong class="bold"># yum install ansible</strong></p></li>
				<li class="calibre9">Once installed, create an SSH key pair to use between the master system and the target systems that we will be managing with Ansible. Use the <strong class="source-inline">ssh-keygen</strong> command to create a key pair on the master system, and then copy the public key (<strong class="source-inline">~/.ssh/id_rsa.pub</strong>) to the remote systems, saving it as <strong class="source-inline">~/.ssh/authorized_keys</strong>:<p class="source-code"><strong class="bold"># ssh-keygen</strong></p><p class="source-code"><strong class="bold"># scp ~/.ssh/id_rsa.pub rem1:/root/.ssh/authorized_keys</strong></p></li>
				<li class="calibre9">Test to see whether the remote connection works properly, for instance, by executing the <strong class="source-inline">id</strong> command remotely:<p class="source-code"><strong class="bold"># ssh rem1 id</strong></p></li>
				<li class="calibre9">If the <a id="_idIndexMarker444" class="pcalibre calibre6 pcalibre1"/>test is successful, we can configure Ansible to see this remote system as one of the nodes it will be managing. To accomplish this, edit <strong class="source-inline">/etc/ansible/hosts</strong> and add the hostname to the list:<p class="source-code"><strong class="bold"># cat /etc/ansible/hosts</strong></p><p class="source-code"><strong class="bold">rem1</strong></p></li>
				<li class="calibre9">To see <a id="_idIndexMarker445" class="pcalibre calibre6 pcalibre1"/>whether Ansible can correctly manage the remote system, we can ask it to gather all the facts about the remote system. Facts in Ansible represent the discovered settings of the remote system and can be used to fine-tune playbooks and roles later. For instance, the Ansible facts discovered of the distribution can be used to select which package name an installation uses:<p class="source-code"><strong class="bold"># ansible all -m setup</strong></p><p class="calibre3">This instruction asks all managed hosts (<strong class="source-inline">all</strong>, reflecting all entries in <strong class="source-inline">/etc/ansible/hosts</strong>) to execute the tasks in the <strong class="source-inline">setup</strong> module. </p></li>
			</ol>
			<p class="calibre3">The output of the last task is a large set of discovered facts, showing us that the connection succeeded and that Ansible is ready to manage the remote system.</p>
			<h2 id="_idParaDest-184" class="calibre10"><a id="_idTextAnchor186" class="pcalibre calibre6 pcalibre1"/>Creating and testing the Ansible role</h2>
			<p class="calibre3">To allow <a id="_idIndexMarker446" class="pcalibre calibre6 pcalibre1"/>reusable configurations across multiple systems, Ansible <a id="_idIndexMarker447" class="pcalibre calibre6 pcalibre1"/>recommends the use of its Ansible roles. We will create a role called <strong class="source-inline">packt_selinux</strong>, have it create a custom directory, and then assign this role to the remote system:</p>
			<ol class="calibre18">
				<li value="1" class="calibre9">Use <strong class="source-inline">ansible-galaxy</strong> to create an empty yet ready-to-use role:<p class="source-code"><strong class="bold"># cd /etc/ansible/roles</strong></p><p class="source-code"><strong class="bold"># ansible-galaxy init packt_selinux --offline</strong></p><p class="source-code"><strong class="bold">- Role packt_selinux was created successfully</strong></p><p class="calibre3">This command will create the necessary files and directories that constitute a role. The file we will use is <strong class="source-inline">packt_selinux/tasks/main.yml</strong>, which will host all the settings and definitions we want to apply when we assign the <strong class="source-inline">packt_selinux</strong> role to a system. The other directories are, for our brief introduction to Ansible, less relevant, but play an important role in making sufficiently modular roles.</p></li>
				<li class="calibre9">Edit <a id="_idIndexMarker448" class="pcalibre calibre6 pcalibre1"/>the <strong class="source-inline">main.yml</strong> file and have it create a custom directory. The <a id="_idIndexMarker449" class="pcalibre calibre6 pcalibre1"/>content of the file should look like this:<p class="source-code">---</p><p class="source-code">- name: Create /usr/share/selinux/custom directory</p><p class="source-code">   file:</p><p class="source-code">        path: /usr/share/selinux/custom</p><p class="source-code">        owner: root</p><p class="source-code">        group: root</p><p class="source-code">        mode: '0755'</p><p class="source-code">        state: directory</p><p class="calibre3">In later steps, this file will be extended with more and more blocks. Each block will start with a name that identifies the block, and then the state definition. In the current block, we used Ansible's <strong class="source-inline">file</strong> module to assert that a file or directory is available with the parameters given.</p></li>
				<li class="calibre9">Assign the role to the remote system and apply the playbook. We accomplish this by first creating an <strong class="source-inline">/etc/ansible/site.yml</strong> file with the following content:<p class="source-code">---</p><p class="source-code">- hosts: all </p><p class="source-code">  roles:</p><p class="source-code">        - packt_selinux</p></li>
				<li class="calibre9">Run this playbook to apply the setting defined in our role to the remote systems:<p class="source-code"><strong class="bold"># ansible-playbook /etc/ansible/site.yml</strong></p><p class="calibre3">Ansible will display its progress, as well as for which tasks it has executed a change. In our case, a change would mean that the directory has been created.</p></li>
			</ol>
			<p class="calibre3">Now that we have tested our role and assigned the role to the remote system, all we need to do is update the role gradually until it contains all the logic we need. No other configuration is needed, and after each change, we can rerun the <strong class="source-inline">ansible-playbook</strong> command from the main server.</p>
			<h2 id="_idParaDest-185" class="calibre10"><a id="_idTextAnchor187" class="pcalibre calibre6 pcalibre1"/>Assigning SELinux contexts to filesystem resources with Ansible</h2>
			<p class="calibre3">In the <a id="_idIndexMarker450" class="pcalibre calibre6 pcalibre1"/>current role, we create a custom directory inside <strong class="source-inline">/usr/share/selinux</strong>. This parent directory has the <strong class="source-inline">usr_t</strong> SELinux type set, so the newly created subdirectory has it as well. The SELinux user of this directory, however, will be different, as Ansible has created the directory after remotely logging in to the system. In a default CentOS configuration, this means that the target directory's context will have <strong class="source-inline">unconfined_u</strong> as its SELinux user component.</p>
			<p class="calibre3">Let's update the definition in <strong class="source-inline">main.yml</strong> and explicitly set the SELinux user and type:</p>
			<p class="source-code">---</p>
			<p class="source-code">- name: Create /usr/share/selinux/custom directory</p>
			<p class="source-code">  file:</p>
			<p class="source-code">        path: /usr/share/selinux/custom</p>
			<p class="source-code">        owner: root</p>
			<p class="source-code">        gr<a id="_idTextAnchor188" class="pcalibre calibre6 pcalibre1"/>oup: root</p>
			<p class="source-code">        mode: '0755'</p>
			<p class="source-code">        state: directory</p>
			<p class="source-code">        setype: 'usr_t'</p>
			<p class="source-code">        seuser: 'system_u'</p>
			<p class="calibre3">After applying the change (using <strong class="source-inline">ansible-playbook</strong>), the updated definition results in a correctly set SELinux user and SELinux type for this directory.</p>
			<p class="calibre3">In this case, we added two parameters to the file definition: <strong class="source-inline">setype</strong> and <strong class="source-inline">seuser</strong>. The Ansible file module supports the following SELinux-related parameters:</p>
			<ul class="calibre8">
				<li class="calibre9"><strong class="source-inline">seuser</strong> is the SELinux user of the resource. Set this to <strong class="source-inline">system_u</strong> for system resources, as used in the example.</li>
				<li class="calibre9"><strong class="source-inline">serole</strong> is the SELinux role of the resource. This is generally not used, as role inheritance on the system will generally result in the resource being labeled with the <strong class="source-inline">object_r</strong> role, which is correct most of the time.</li>
				<li class="calibre9"><strong class="source-inline">setype</strong> is the SELinux type of the resource and is the most commonly used SELinux parameter in file modules.</li>
				<li class="calibre9"><strong class="source-inline">selevel</strong> is the SELinux sensitivity level for the resource. By default, it is set to <strong class="source-inline">s0</strong>.</li>
			</ul>
			<p class="calibre3">As we've learned from the example already, you do not need to declare the type if the inherited context is correct.</p>
			<h2 id="_idParaDest-186" class="calibre10"><a id="_idTextAnchor189" class="pcalibre calibre6 pcalibre1"/>Loading custom SELinux policies with Ansible</h2>
			<p class="calibre3">Ansible's <a id="_idIndexMarker451" class="pcalibre calibre6 pcalibre1"/>current release has no support for loading custom SELinux modules. While custom modules are found on Ansible galaxy (the ecosystem where contributors can add more modules), let's see how we would handle distributing a custom policy to the systems under Ansible control and loading the module, but only if it is not loaded yet.</p>
			<p class="calibre3">While we could start creating custom modules ourselves, let's use a combination of tasks in the existing role to accomplish this. We will try to accomplish the following tasks in sequence:</p>
			<ol class="calibre18">
				<li value="1" class="calibre9">Upload a custom policy called <strong class="source-inline">test.cil</strong> to the remote system.</li>
				<li class="calibre9">Check whether this custom policy is already loaded.</li>
				<li class="calibre9">Load the custom policy, but only if the previous check failed.</li>
			</ol>
			<p class="calibre3">These three tasks are handled through three modules: the <strong class="source-inline">copy</strong> module, the <strong class="source-inline">shell</strong> module, and the <strong class="source-inline">command</strong> module. We will use each of these modules in separate steps:</p>
			<ol class="calibre18">
				<li value="1" class="calibre9">Create the custom policy mentioned earlier in this chapter by placing the <strong class="source-inline">test.cil</strong> file in the <strong class="source-inline">files/</strong> folder of the <strong class="source-inline">packt_selinux</strong> role.</li>
				<li class="calibre9">Create a new code block in the <strong class="source-inline">main.yml</strong> file of the role, with the following content:<p class="source-code">- name: Upload test.cil file to /usr/share/selinux/custom</p><p class="source-code">  copy:</p><p class="source-code">        src: test.cil</p><p class="source-code">        dest: /usr/share/selinux/custom/test.cil</p><p class="source-code">        owner: root</p><p class="source-code">        group: root</p><p class="source-code">        mode: '0644'</p><p class="calibre3">This will ensure that the <strong class="source-inline">test.cil</strong> file, currently on the master machine, is distributed to the target nodes in the directory we've previously created.</p></li>
				<li class="calibre9">Next, we check whether the policy is already loaded. For this, we use the <strong class="source-inline">shell</strong> module and use the fail or success state later. Hence, we store the return in the <strong class="source-inline">test_is_loaded</strong> variable, and explicitly tell Ansible to ignore a failure as we use this as a check rather than a state definition:<p class="source-code">- name: Check if test SELinux module is loaded</p><p class="source-code">  shell: /usr/sbin/semodule -l | grep -q ^test$</p><p class="source-code">  register: test_is_loaded</p><p class="source-code">  ignore_errors: True</p></li>
				<li class="calibre9">The <strong class="source-inline">command</strong> module loads the policy file, and only if the previous task failed:<p class="source-code">- name: Load test.cil if not loaded yet</p><p class="source-code">  command: /usr/sbin/semodule -i /usr/share/selinux/custom/test.cil</p><p class="source-code">  when: test_is_loaded is failed</p></li>
			</ol>
			<p class="calibre3">This <a id="_idIndexMarker452" class="pcalibre calibre6 pcalibre1"/>approach shows how we can use our knowledge of SELinux to define and set states. This method can be used for other SELinux settings as well, for instance, by validating the output of listings (for example, with <strong class="source-inline">semanage</strong>) before defining or adjusting settings.</p>
			<h2 id="_idParaDest-187" class="calibre10"><a id="_idTextAnchor190" class="pcalibre calibre6 pcalibre1"/>Using Ansible's out-of-the-box SELinux support</h2>
			<p class="calibre3">Ansible has <a id="_idIndexMarker453" class="pcalibre calibre6 pcalibre1"/>quite a few modules available to provide native support for several SELinux-related settings, which we briefly cover here:</p>
			<ul class="calibre8">
				<li class="calibre9">The <strong class="source-inline">selinux</strong> module can be used to set or change the SELinux state (enforcing or permissive) as well as to select the appropriate SELinux policy type (such as targeted):<p class="source-code">- name: Set SELinux to enforcing mode</p><p class="source-code">  selinux:</p><p class="source-code">          policy: targeted</p><p class="source-code">          state: enforcing</p></li>
				<li class="calibre9">With the <strong class="source-inline">seboolean</strong> module, the SELinux booleans can be adjusted at will:<p class="source-code">- name: Set httpd_builtin_scripting to true</p><p class="source-code">  seboolean:</p><p class="source-code">          name: httpd_builtin_scripting</p><p class="source-code">          state: yes</p></li>
				<li class="calibre9">The <strong class="source-inline">sefcontext</strong> module allows us to change SELinux file context definitions:<p class="source-code">- name: Set the context for /srv/web</p><p class="source-code">  sefcontext:</p><p class="source-code">          target: '/srv/web(/.*)?'</p><p class="source-code">          setype: httpd_sys_content_t</p><p class="source-code">          state: present</p></li>
				<li class="calibre9">With <strong class="source-inline">selinux_permissive</strong>, we can selectively mark certain SELinux policy domains as permissive:<p class="source-code">- name: Set zoneminder_t as permissive domain</p><p class="source-code">  selinux_permissive:</p><p class="source-code">          name: zoneminder_t</p><p class="source-code">          permissive: true</p></li>
				<li class="calibre9">The <strong class="source-inline">selogin</strong> module can be used to map a login to an SELinux user, as with <strong class="source-inline">semanage login</strong>:<p class="source-code">- name: Map taylor's login to the unconfined_u user</p><p class="source-code">  selogin:</p><p class="source-code">          login: taylor</p><p class="source-code">          seuser: unconfined_u</p><p class="source-code">          state: present</p></li>
				<li class="calibre9"><strong class="source-inline">seport</strong> can be used to create an SELinux port mapping:<p class="source-code">- name: Set port 10122 to ssh_port_t</p><p class="source-code">  seport:</p><p class="source-code">          ports: 10122</p><p class="source-code">          proto: tcp</p><p class="source-code">          setype: ssh_port_t</p><p class="source-code">          state: present</p></li>
			</ul>
			<p class="calibre3">Other <a id="_idIndexMarker454" class="pcalibre calibre6 pcalibre1"/>SELinux settings might be supported through custom modules, but with the method presented earlier, administrators can already start configuring SELinux across all systems in their environment.</p>
			<h1 id="_idParaDest-188" class="calibre5"><a id="_idTextAnchor191" class="pcalibre calibre6 pcalibre1"/>Utilizing SaltStack to configure SELinux</h1>
			<p class="calibre3">The second <a id="_idIndexMarker455" class="pcalibre calibre6 pcalibre1"/>orchestration and automation framework <a id="_idIndexMarker456" class="pcalibre calibre6 pcalibre1"/>we'll consider is SaltStack, which has commercial backing by the SaltStack company. SaltStack uses a declarative language similar to Ansible and is also written in Python. In this chapter, we will use the open source SaltStack framework, but an enterprise version of SaltStack is available as well, which adds more features on top of the open source one.</p>
			<h2 id="_idParaDest-189" class="calibre10"><a id="_idTextAnchor192" class="pcalibre calibre6 pcalibre1"/>How SaltStack works</h2>
			<p class="calibre3"><strong class="bold">SaltStack</strong>, often <a id="_idIndexMarker457" class="pcalibre calibre6 pcalibre1"/>also described as just Salt, is an automation framework <a id="_idIndexMarker458" class="pcalibre calibre6 pcalibre1"/>that uses an agent/server model for its integrations. Unlike Ansible, SaltStack generally requires agent installations on the target nodes (called <strong class="bold">minions</strong>) and <a id="_idIndexMarker459" class="pcalibre calibre6 pcalibre1"/>activation of the minion daemons to enable communications to the master. This communication is encrypted, and the minion authentication uses public-key validation, which needs to be approved on the master to ensure no rogue minions participate in a SaltStack environment.</p>
			<p class="calibre3">While agent-less installations are possible with SaltStack as well, we will focus on  agent-based deployments. In such a configuration, the minions regularly check with the master to see whether <a id="_idIndexMarker460" class="pcalibre calibre6 pcalibre1"/>any updates need to be applied. But administrators do not need to wait until the minion pulls the latest updates: you can also trigger updates from the master, effectively pushing changes to the nodes.</p>
			<p class="calibre3">The target state that a <a id="_idIndexMarker461" class="pcalibre calibre6 pcalibre1"/>minion should be in is written down in a <strong class="bold">Salt State file</strong>, which uses the <strong class="source-inline">.sls</strong> suffix. These Salt State files can refer to other state files, to allow a modular design and reusability across multiple machines.</p>
			<p class="calibre3">If we need <a id="_idIndexMarker462" class="pcalibre calibre6 pcalibre1"/>more elaborate coding, SaltStack supports the creation and distribution of modules, called <strong class="bold">Salt execution modules</strong>. However, unlike Ansible's Galaxy, no community repositories currently exist to find more execution modules.</p>
			<h2 id="_idParaDest-190" class="calibre10"><a id="_idTextAnchor193" class="pcalibre calibre6 pcalibre1"/>Installing and configuring SaltStack</h2>
			<p class="calibre3">The installation <a id="_idIndexMarker463" class="pcalibre calibre6 pcalibre1"/>of SaltStack is similar across the different Linux distributions. Let's <a id="_idIndexMarker464" class="pcalibre calibre6 pcalibre1"/>see how the installation is done on a CentOS machine:</p>
			<ol class="calibre18">
				<li value="1" class="calibre9">We first need to enable the SaltStack repository that contains its software. The project maintains the repository definitions through RPM files that can be installed immediately:<p class="source-code"><strong class="bold"># yum install https://repo.saltstack.com/py3/redhat/salt-py3-repo-latest.el8.noarch.rpm</strong></p></li>
				<li class="calibre9">Once we have enabled the repository on all systems, install <strong class="source-inline">salt-master</strong> on the master, and <strong class="source-inline">salt-minion</strong> on the remote systems:<p class="source-code"><strong class="bold">master ~# yum install salt-master</strong></p><p class="source-code"><strong class="bold">remote ~# yum install salt-minion</strong></p></li>
				<li class="calibre9">Before we start the daemons on the systems, we first update the minion configuration to point to the master. By default, the minions will attempt to connect to a host with the hostname <strong class="source-inline">salt</strong>, but this can be easily changed by editing <strong class="source-inline">/etc/salt/minion</strong> and setting the right hostname:<p class="source-code"><strong class="bold">remote ~# vim /etc/salt/minion</strong></p><p class="source-code"><strong class="bold">master: ppubssa3ed</strong></p></li>
				<li class="calibre9">With the minion configured, we can now launch the SaltStack master (<strong class="source-inline">salt-master</strong>) and minion (<strong class="source-inline">salt-minion</strong>) daemons:<p class="source-code"><strong class="bold">master ~# systemctl start salt-master</strong></p><p class="source-code"><strong class="bold">remote ~# systemctl start salt-minion</strong></p></li>
				<li class="calibre9">The minion <a id="_idIndexMarker465" class="pcalibre calibre6 pcalibre1"/>will connect to the master and present its public key. To list the agents currently connected, use <strong class="source-inline">salt-key -L</strong>:<p class="source-code"><strong class="bold">master ~# salt-key -L</strong></p><p class="source-code"><strong class="bold">Accepted Keys:</strong></p><p class="source-code"><strong class="bold">Denied Keys:</strong></p><p class="source-code"><strong class="bold">Unaccepted Keys:</strong></p><p class="source-code"><strong class="bold">rem1.internal.genfic.local</strong></p><p class="source-code"><strong class="bold">Rejected Keys:</strong></p><p class="calibre3">We need <a id="_idIndexMarker466" class="pcalibre calibre6 pcalibre1"/>to accept the keys for the remote machines:</p><p class="source-code"><strong class="bold">master ~# salt-key -a rem1.internal.genfic.local</strong></p><p class="source-code"><strong class="bold">The following keys are going to be accepted:</strong></p><p class="source-code"><strong class="bold">Unaccepted Keys:</strong></p><p class="source-code"><strong class="bold">rem1.internal.genfic.local</strong></p><p class="source-code"><strong class="bold">Proceed? [n/Y] y</strong></p><p class="source-code"><strong class="bold">Key for minion rem1.internal.genfic.local accepted.</strong></p></li>
				<li class="calibre9">Once we have accepted the key, the master will know and control the minion. Let's see whether we can properly interact with the remote system:<p class="source-code"><strong class="bold">master ~# salt '*' service.get_all</strong></p><p class="calibre3">This command will list all system services on the minion.</p></li>
			</ol>
			<p class="calibre3">The <strong class="source-inline">salt</strong> command is the main command used to query and interact with the remote minions from the master. If the last command is successfully returning all system services, then SaltStack is correctly configured and ready to manage the remote systems.</p>
			<h2 id="_idParaDest-191" class="calibre10"><a id="_idTextAnchor194" class="pcalibre calibre6 pcalibre1"/>Creating and testing our SELinux state with SaltStack</h2>
			<p class="calibre3">Let's <a id="_idIndexMarker467" class="pcalibre calibre6 pcalibre1"/>create our SELinux state called <strong class="source-inline">packt_selinux</strong>, and <a id="_idIndexMarker468" class="pcalibre calibre6 pcalibre1"/>have it applied to the remote minion: </p>
			<ol class="calibre18">
				<li value="1" class="calibre9">We first need to create the top file. This file is the master file for SaltStack, from which the entire environment is configured:<p class="source-code"><strong class="bold">master ~# mkdir /srv/salt</strong></p><p class="source-code"><strong class="bold">master ~# vim /srv/salt/top.sls</strong></p><p class="source-code"><strong class="bold">base:</strong></p><p class="source-code"><strong class="bold">  '*':</strong></p><p class="source-code"><strong class="bold">    - packt_selinux</strong></p></li>
				<li class="calibre9">Next, we create the state definition for <strong class="source-inline">packt_selinux</strong>:<p class="source-code"><strong class="bold">master ~# mkdir /srv/salt/packt_selinux</strong></p><p class="source-code"><strong class="bold">master ~# vim /srv/salt/packt_selinux/init.sls</strong></p><p class="source-code"><strong class="bold">/usr/share/selinux/custom/test.cil:</strong></p><p class="source-code"><strong class="bold">  file.managed:</strong></p><p class="source-code"><strong class="bold">    - source: salt://packt_selinux/test.cil</strong></p><p class="source-code"><strong class="bold">    - mode: 644</strong></p><p class="source-code"><strong class="bold">    - user: root</strong></p><p class="source-code"><strong class="bold">    - group: root</strong></p><p class="source-code"><strong class="bold">    - makedirs: True</strong></p><p class="calibre3">The <strong class="source-inline">init.sls</strong> file is the main state file for this <strong class="source-inline">packt_selinux</strong> state. So, when SaltStack reads the <strong class="source-inline">top.sls</strong> file, it sees a reference to the <strong class="source-inline">packt_selinux</strong> state and then searches for the <strong class="source-inline">init.sls</strong> file inside this state.</p></li>
				<li class="calibre9">Place <a id="_idIndexMarker469" class="pcalibre calibre6 pcalibre1"/>the SELinux <strong class="source-inline">test.cil</strong> module, as defined <a id="_idIndexMarker470" class="pcalibre calibre6 pcalibre1"/>earlier on in this chapter, inside <strong class="source-inline">/srv/salt/packt_selinux</strong> as we refer to it in the state definition. Once placed, we can apply this state to the environment:<p class="source-code"><strong class="bold">master ~# salt '*' state.apply</strong></p></li>
			</ol>
			<p class="calibre3">The <strong class="source-inline">state.apply</strong> subcommand of the <strong class="source-inline">salt</strong> command is used to apply the state across the environment. Each time we modify our state definition, this command can be used to force an update to the minions. Without this, the minions will (by default) update their state every 60 minutes. These scheduled state updates are called mine updates and are configured on the agents inside <strong class="source-inline">/etc/salt/minion</strong>.</p>
			<h2 id="_idParaDest-192" class="calibre10"><a id="_idTextAnchor195" class="pcalibre calibre6 pcalibre1"/>Assigning SELinux contexts to filesystem resources with SaltStack</h2>
			<p class="calibre3">At <a id="_idIndexMarker471" class="pcalibre calibre6 pcalibre1"/>the time of writing, support for addressing SELinux types in resources has not yet reached the stable versions of SaltStack. SaltStack, however, supports running commands but only if a certain test has succeeded (or failed).</p>
			<p class="calibre3">Update the <strong class="source-inline">init.sls</strong> file and add the following code to it:</p>
			<p class="source-code">{%- set path = '/usr/share/selinux/custom/test.cil' %}</p>
			<p class="source-code">{%- set context = 'system_u:object_r:usr_t:s0' %}</p>
			<p class="source-code">set {{ path }} context:</p>
			<p class="source-code">  cmd.run:</p>
			<p class="source-code">    - name: chcon {{ context}} {{ path }}</p>
			<p class="source-code">    - unless: test $(stat -c %C {{ path }}) == {{ context }}</p>
			<p class="calibre3">In this code snippet, we declare two variables (<strong class="source-inline">path</strong> and <strong class="source-inline">context</strong>) so that we do not need to iterate <a id="_idIndexMarker472" class="pcalibre calibre6 pcalibre1"/>the path and context multiple times, and then use these variables in a <strong class="source-inline">cmd.run</strong> call.</p>
			<p class="calibre3">The <strong class="source-inline">cmd.run</strong> approach allows us to easily create custom SELinux support using the commands we've seen earlier on in this book. The <strong class="source-inline">unless</strong> check contains the test to see whether we need to execute the command or not, allowing us to create idempotent state definitions.</p>
			<h2 id="_idParaDest-193" class="calibre10"><a id="_idTextAnchor196" class="pcalibre calibre6 pcalibre1"/>Loading custom SELinux policies with SaltStack</h2>
			<p class="calibre3">Let's <a id="_idIndexMarker473" class="pcalibre calibre6 pcalibre1"/>load our custom SELinux module on the remote systems. SaltStack has support for loading SELinux modules through the <strong class="source-inline">selinux.module</strong> state:</p>
			<p class="source-code">load test.cil:</p>
			<p class="source-code">  selinux.module:</p>
			<p class="source-code">    - name: test</p>
			<p class="source-code">    - source: /usr/share/selinux/custom/test.cil</p>
			<p class="source-code">    - install: True</p>
			<p class="source-code">    - unless: "semodule -l | grep -q ^test$"</p>
			<p class="calibre3">As in the previous section, we need to add an <strong class="source-inline">unless</strong> statement, as otherwise, SaltStack will attempt to load the SELinux module repeatedly every time the state is applied.</p>
			<h2 id="_idParaDest-194" class="calibre10"><a id="_idTextAnchor197" class="pcalibre calibre6 pcalibre1"/>Using SaltStack's out-of-the-box SELinux support</h2>
			<p class="calibre3">SaltStack's <a id="_idIndexMarker474" class="pcalibre calibre6 pcalibre1"/>native SELinux support is gradually expanding but still has much room for improvement:</p>
			<ul class="calibre8">
				<li class="calibre9">With <strong class="source-inline">selinux.boolean</strong>, the SELinux boolean values can be set on the target machines:<p class="source-code">httpd_builtin_scription:</p><p class="source-code">  selinux.boolean:</p><p class="source-code">    - value: True</p></li>
				<li class="calibre9">The file contexts, as managed with <strong class="source-inline">semanage fcontext</strong>, can be defined using the <strong class="source-inline">selinux.fcontext_policy_present</strong> state:<p class="source-code">"/srv/web(/.*)?":</p><p class="source-code">  selinux.fcontext_policy_present:</p><p class="source-code">    - sel_type: httpd_sys_content_t</p></li>
				<li class="calibre9">To remove the definition, use the <strong class="source-inline">selinux.fcontext_policy_absent</strong> definition. </li>
				<li class="calibre9">With <strong class="source-inline">selinux.mode</strong>, we can put the system in enforcing or permissive mode:<p class="source-code">enforcing:</p><p class="source-code">  selinux.mode</p></li>
				<li class="calibre9">Port <a id="_idIndexMarker475" class="pcalibre calibre6 pcalibre1"/>mappings are handled using the <strong class="source-inline">selinux.port_policy_present</strong> state:<p class="source-code">tcp/10122:</p><p class="source-code">  selinux.port_policy_present:</p><p class="source-code">    - sel_type: ssh_port_t</p></li>
			</ul>
			<p class="calibre3">With the <strong class="source-inline">cmd.run</strong> approach mentioned earlier, we can apply SELinux configuration updates to systems in a repeatable fashion for unsupported settings.</p>
			<h1 id="_idParaDest-195" class="calibre5"><a id="_idTextAnchor198" class="pcalibre calibre6 pcalibre1"/>Automating system management with Puppet</h1>
			<p class="calibre3">Puppet is <a id="_idIndexMarker476" class="pcalibre calibre6 pcalibre1"/>the third automation framework <a id="_idIndexMarker477" class="pcalibre calibre6 pcalibre1"/>that we will check out. It is the oldest one in our list, with its first release in 2005, and is commonly seen as the baseline against which other automation frameworks are compared. It has commercial backing through the Puppet company, also often referred to as Puppet Labs.</p>
			<h2 id="_idParaDest-196" class="calibre10"><a id="_idTextAnchor199" class="pcalibre calibre6 pcalibre1"/>How Puppet works</h2>
			<p class="calibre3">Like SaltStack, <strong class="bold">Puppet</strong> uses <a id="_idIndexMarker478" class="pcalibre calibre6 pcalibre1"/>an agent/server-based model with public-key <a id="_idIndexMarker479" class="pcalibre calibre6 pcalibre1"/>authentication of the agents to ensure no rogue agents are active within the environment.</p>
			<p class="calibre3">The <strong class="bold">Puppet master</strong> has <a id="_idIndexMarker480" class="pcalibre calibre6 pcalibre1"/>access to the <strong class="bold">Puppet manifests</strong>, which is the declaration <a id="_idIndexMarker481" class="pcalibre calibre6 pcalibre1"/>of the state that Puppet wants to achieve. These manifests use a specific language inspired by Ruby and can refer to classes provided by modules to ensure reusability across the environment.</p>
			<p class="calibre3"><strong class="bold">Puppet modules</strong>, hence, are <a id="_idIndexMarker482" class="pcalibre calibre6 pcalibre1"/>the workhorse within Puppet, and Puppet has a <a id="_idIndexMarker483" class="pcalibre calibre6 pcalibre1"/>significant community called Puppet Forge that allows you to download and install modules created by the community to more easily manage your environment.</p>
			<p class="calibre3">Puppet agents will regularly connect to the master, informing the master of the current details of the remote machine. These <a id="_idIndexMarker484" class="pcalibre calibre6 pcalibre1"/>current details are called <strong class="bold">facts</strong> and can be used by Puppet to dynamically handle changes in the environment. The master then compiles the <a id="_idIndexMarker485" class="pcalibre calibre6 pcalibre1"/>target state in what it calls a <strong class="bold">catalog</strong> and sends that catalog over to the agent. The agent then applies this catalog and reports the results back.</p>
			<h2 id="_idParaDest-197" class="calibre10"><a id="_idTextAnchor200" class="pcalibre calibre6 pcalibre1"/>Installing and configuring Puppet</h2>
			<p class="calibre3">The Puppet <a id="_idIndexMarker486" class="pcalibre calibre6 pcalibre1"/>company offers integrated packages for several Linux distributions. The <a id="_idIndexMarker487" class="pcalibre calibre6 pcalibre1"/>following instructions focus on RPM-compatible distributions, but other platforms have very similar instructions:</p>
			<ol class="calibre18">
				<li value="1" class="calibre9">The Puppet company provides repository definitions through RPM files. After the repositories are established, you can install <strong class="source-inline">puppetserver</strong> and <strong class="source-inline">pdk</strong> (on the master) and <strong class="source-inline">puppet-agent</strong> (on the remote systems) so that the software is readily available to use:<p class="source-code"><strong class="bold"># yum install https://yum.puppet.com/puppet6-release-el-8.noarch.rpm</strong></p><p class="source-code"><strong class="bold">master ~# yum install puppetserver pdk</strong></p><p class="source-code"><strong class="bold">remote ~# yum install puppet-agent</strong></p></li>
				<li class="calibre9">Configure the master to have its certificate properly named. Edit the <strong class="source-inline">puppet.conf</strong> file inside <strong class="source-inline">/etc/puppetlabs/puppet</strong> and, within the <strong class="source-inline">[master]</strong> section, update or add the following settings:<p class="source-code"><strong class="bold">master ~# vim /etc/puppetlabs/puppet/puppet.conf</strong></p><p class="source-code"><strong class="bold">certname = ppubssa3ed.internal.genfic.local</strong></p><p class="source-code"><strong class="bold">server = ppubssa3ed.internal.genfic.local</strong></p><p class="source-code"><strong class="bold">environment = production</strong></p></li>
				<li class="calibre9">Start the Puppet server so that the clients can start connecting to it:<p class="source-code"><strong class="bold">master ~# systemctl start puppetserver</strong></p></li>
				<li class="calibre9">On the remote systems, edit the same configuration file, and update or add the following settings in the <strong class="source-inline">[main]</strong> section:<p class="source-code"><strong class="bold">remote ~# vim /etc/puppetlabs/puppet/puppet.conf</strong></p><p class="source-code"><strong class="bold">[main]</strong></p><p class="source-code"><strong class="bold">certname = rem1.internal.genfic.local</strong></p><p class="source-code"><strong class="bold">server = ppubssa3ed.internal.genfic.local</strong></p><p class="source-code"><strong class="bold">environment = production</strong></p><p class="source-code"><strong class="bold">runinterval = 1h</strong></p></li>
				<li class="calibre9">Next, start the Puppet agent:<p class="source-code"><strong class="bold">remote ~# systemctl start puppet</strong></p></li>
				<li class="calibre9">On the <a id="_idIndexMarker488" class="pcalibre calibre6 pcalibre1"/>master node, we can now query the pending certificate requests. It should display the requests from the agents we recently started:<p class="source-code"><strong class="bold">master ~# /opt/puppetlabs/bin/puppetserver ca list</strong></p><p class="source-code"><strong class="bold">Requested Certificates:</strong></p><p class="source-code"><strong class="bold">  rem1.internal.genfic.local   (SHA256) ...</strong></p></li>
				<li class="calibre9">We can <a id="_idIndexMarker489" class="pcalibre calibre6 pcalibre1"/>accept this request (sign the certificate) as follows:<p class="source-code"><strong class="bold">master ~# /opt/puppetlabs/bin/puppetserver ca sign --certname rem1.internal.genfic.local</strong></p><p class="source-code"><strong class="bold">Successfully signed certificate request for rem1.</strong><strong class="bold">internal.genfic.local</strong></p></li>
				<li class="calibre9">To validate whether the connection works, log in on the remote machine and trigger the agent to apply the (currently empty) catalog:<p class="source-code"><strong class="bold">remote ~# /opt/puppetlabs/bin/puppet agent --test</strong></p></li>
			</ol>
			<p class="calibre3">Unlike SaltStack, where we can push a change to the agents, Puppet relies on the agents to frequently poll the server. In the configuration we made earlier, we configured the agent to check every hour. With the <strong class="source-inline">puppet agent --test</strong> command, we can signal the agent to run the state check immediately.</p>
			<h2 id="_idParaDest-198" class="calibre10"><a id="_idTextAnchor201" class="pcalibre calibre6 pcalibre1"/>Creating and testing the SELinux class with Puppet</h2>
			<p class="calibre3">Let's <a id="_idIndexMarker490" class="pcalibre calibre6 pcalibre1"/>create our <strong class="source-inline">packt_selinux</strong> class, through which <a id="_idIndexMarker491" class="pcalibre calibre6 pcalibre1"/>we will configure our remote machine's SELinux settings: </p>
			<ol class="calibre18">
				<li value="1" class="calibre9">Call <a id="_idIndexMarker492" class="pcalibre calibre6 pcalibre1"/>the <strong class="bold">Puppet Development Kit</strong> (<strong class="bold">PDK</strong>) on the master node inside the <strong class="source-inline">/etc/puppetlabs/code/modules</strong> directory:<p class="source-code"><strong class="bold">master ~# cd /etc/puppetlabs/code/modules</strong></p><p class="source-code"><strong class="bold">master ~# pdk new module packt_selinux --skip-interview</strong></p><p class="calibre3">The result is an empty module with lots of default files and directories. We will be mostly working with the module's manifest file.</p></li>
				<li class="calibre9">Inside the <strong class="source-inline">packt_selinux/manifests</strong> directory, create a new file named <strong class="source-inline">init.pp</strong> with the following content:<p class="source-code">class packt_selinux {</p><p class="source-code">  file { "/usr/share/selinux/custom":</p><p class="source-code">    ensure =&gt; directory,</p><p class="source-code">    mode =&gt; "0755",</p><p class="source-code">  }</p><p class="source-code">}</p></li>
				<li class="calibre9">Next, inside <a id="_idIndexMarker493" class="pcalibre calibre6 pcalibre1"/>the <strong class="source-inline">/etc/puppetlabs/code/environments/production/manifests</strong> location, create a file called <strong class="source-inline">site.pp</strong> with the following content:<p class="source-code">node 'rem1.internal.genfic.local' {</p><p class="source-code">  include packt_selinux</p><p class="source-code">}</p><p class="calibre3">The <strong class="source-inline">site.pp</strong> file provides the top-level hierarchy for Puppet to associate its environment <a id="_idIndexMarker494" class="pcalibre calibre6 pcalibre1"/>with the appropriate definitions. In this example, the node with the hostname <strong class="source-inline">rem1.internal.genfic.local</strong> is configured through a reference to <strong class="source-inline">packt_selinux</strong>, the module we created previously.</p><p class="calibre3">Inside the <strong class="source-inline">packt_selinux</strong> module, we've created the <strong class="source-inline">packt_selinux</strong> class, which currently is composed of a single directive to create <strong class="source-inline">/usr/share/selinux/custom</strong>.</p></li>
				<li class="calibre9">With these definitions in place, have the remote agent update its state:<p class="source-code"><strong class="bold">remote ~# puppet agent -t</strong></p><p class="calibre3">In product environments, it is common to have this command either scheduled regularly or to run the Puppet agent continuously as a daemon.</p></li>
			</ol>
			<p class="calibre3">With the class properly assigned to the node, we can expand our configuration with more SELinux details.</p>
			<h2 id="_idParaDest-199" class="calibre10"><a id="_idTextAnchor202" class="pcalibre calibre6 pcalibre1"/>Assigning SELinux contexts to filesystem resources with Puppet</h2>
			<p class="calibre3">Let's <a id="_idIndexMarker495" class="pcalibre calibre6 pcalibre1"/>augment our current class definition with the following snippet:</p>
			<p class="source-code">file { 'selinux_custom_module_test':</p>
			<p class="source-code">  path =&gt; "/usr/share/selinux/custom/test.cil",</p>
			<p class="source-code">  ensure =&gt; file,</p>
			<p class="source-code">  owner =&gt; "root",</p>
			<p class="source-code">  group =&gt; "root",</p>
			<p class="source-code">  source =&gt; "puppet:///modules/packt_selinux/test.cil",</p>
			<p class="source-code">  require =&gt; File["/usr/share/selinux/custom"],</p>
			<p class="source-code">  seltype =&gt; "usr_t",</p>
			<p class="source-code">}</p>
			<p class="calibre3">For this block to work properly, we need to place the <strong class="source-inline">test.cil</strong> SELinux module in the <strong class="source-inline">files/</strong> folder inside the <strong class="source-inline">packt_selinux</strong> module location. This block will have Puppet upload the file to the directory, with the dependency set that the directory must exist. The <strong class="source-inline">require</strong> statement refers to the previously defined block.</p>
			<p class="calibre3">We also see that Puppet has out-of-the-box support for SELinux type definitions. The file class has several SELinux-supported parameters that can be used:</p>
			<ul class="calibre8">
				<li class="calibre9"><strong class="source-inline">seluser</strong> defines the SELinux user for the resource.</li>
				<li class="calibre9"><strong class="source-inline">selrole</strong> defines the SELinux role for the resource.</li>
				<li class="calibre9"><strong class="source-inline">seltype</strong> defines the SELinux type for the resource.</li>
				<li class="calibre9"><strong class="source-inline">selrange</strong> defines the SELinux sensitivity range for the resource.</li>
				<li class="calibre9"><strong class="source-inline">selinux_ignore_defaults</strong> tells Puppet to ignore the default SELinux context (as queried from the SELinux policy).</li>
			</ul>
			<p class="calibre3">Our previous example is thus actually superfluous because Puppet will actively query the SELinux policy to discover what the right resource context is and apply this. With <strong class="source-inline">selinux_ignore_defaults</strong> set to <strong class="source-inline">true</strong>, Puppet will not query and adjust the context accordingly, which can be useful when testing out new setups that do not have proper context definitions set.</p>
			<h2 id="_idParaDest-200" class="calibre10"><a id="_idTextAnchor203" class="pcalibre calibre6 pcalibre1"/>Loading custom SELinux policies with Puppet</h2>
			<p class="calibre3">Puppet <a id="_idIndexMarker496" class="pcalibre calibre6 pcalibre1"/>does have support for loading and managing SELinux modules. However, its support is currently restricted to the more traditional SELinux policy modules, and not the CIL powered ones.</p>
			<p class="calibre3">So, let's create another block in our module definition that loads the <strong class="source-inline">test.cil</strong> file, but only if no test SELinux module is already loaded:</p>
			<p class="source-code">exec { '/usr/sbin/semodule -i /usr/share/selinux/custom/test.cil':</p>
			<p class="source-code">  require =&gt; File['selinux_custom_module_test'],</p>
			<p class="source-code">  unless =&gt; '/usr/sbin/semodule -l | grep -q ^test$',</p>
			<p class="source-code">}</p>
			<p class="calibre3">This <a id="_idIndexMarker497" class="pcalibre calibre6 pcalibre1"/>approach allows us to create custom SELinux configuration adjustments if the native Puppet support does not suffice.</p>
			<h2 id="_idParaDest-201" class="calibre10"><a id="_idTextAnchor204" class="pcalibre calibre6 pcalibre1"/>Using Puppet's out-of-the-box SELinux support</h2>
			<p class="calibre3">Puppet <a id="_idIndexMarker498" class="pcalibre calibre6 pcalibre1"/>has a few SELinux-related classes supported out of the box but has more support through Puppet Forge, an ecosystem of community-contributed modules. One of the modules that we can recommend is the <strong class="source-inline">puppet-selinux</strong> module, which Puppet (the company) maintains on Puppet Forge (and thus has a higher chance of remaining supported in later versions of Puppet).</p>
			<p class="calibre3">Installing new modules is quite easy, using the <strong class="source-inline">puppet module</strong> command:</p>
			<p class="source-code">master ~# /opt/puppetlabs/bin/puppet module install puppet-selinux</p>
			<p class="calibre3">We can then refer to the <strong class="source-inline">selinux</strong> class (provided through this module) within our manifest:</p>
			<ul class="calibre8">
				<li class="calibre9">The <strong class="source-inline">selinux</strong> class can be directly used to set the enforcing (or permissive) state of the system:<p class="source-code">class { selinux:</p><p class="source-code">  mode =&gt; 'enforcing',</p><p class="source-code">  type =&gt; 'targeted',</p><p class="source-code">}</p></li>
				<li class="calibre9">The (native) <strong class="source-inline">selboolean</strong> class can be used to set SELinux booleans:<p class="source-code">selboolean { 'httpd_builtin_scripting':</p><p class="source-code">  value =&gt; off,</p><p class="source-code">}</p></li>
				<li class="calibre9">SELinux file contexts can be defined using the <strong class="source-inline">selinux::fcontext</strong> class:<p class="source-code">selinux::fcontext { '/srv/web(/.*)?':</p><p class="source-code">  seltype =&gt; 'httpd_sys_content_t',</p><p class="source-code">}</p></li>
				<li class="calibre9">Equivalence definitions for the file context are handled by <strong class="source-inline">selinux::fcontext::equivalence</strong>, like so:<p class="source-code">selinux::fcontext::equivalence { '/srv/www':</p><p class="source-code">  ensure =&gt; 'present',</p><p class="source-code">  target =&gt; '/srv/web',</p><p class="source-code">}</p></li>
				<li class="calibre9">Custom port mappings are handled by <strong class="source-inline">selinux::port</strong>:<p class="source-code">selinux::port { 'set_ssh_custom_port':</p><p class="source-code">  ensure =&gt; 'present',</p><p class="source-code">  seltype =&gt; 'ssh_port_t',</p><p class="source-code">  protocol =&gt; 'tcp',</p><p class="source-code">  port =&gt; 10122,</p><p class="source-code">}</p></li>
				<li class="calibre9">Individual <a id="_idIndexMarker499" class="pcalibre calibre6 pcalibre1"/>SELinux domains can be made permissive using <strong class="source-inline">selinux::permissive</strong>:<p class="source-code">selinux::permissive { 'zoneminder_t':</p><p class="source-code">  ensure =&gt; 'present',</p><p class="source-code">}</p></li>
				<li class="calibre9">If standard SELinux modules are present, the use of <strong class="source-inline">selmodule</strong> allows loading it up. In this case, it will search for the SELinux module named after the block, inside the directory referred to by <strong class="source-inline">selmoduledir</strong>:<p class="source-code">selmodule { 'vlock':</p><p class="source-code">  ensure =&gt; 'present',</p><p class="source-code">  selmoduledir =&gt; '/usr/share/selinux/custom',</p><p class="source-code">}</p></li>
			</ul>
			<p class="calibre3">While other SELinux-supporting modules might be available on Puppet Forge, be sure to validate whether these modules are mature and sufficiently stable. If their support is uncertain, you might want to pursue the <strong class="source-inline">exec</strong> route, as used earlier on, in <em class="italic">Loading custom SELinux policies with Puppet</em>.</p>
			<h1 id="_idParaDest-202" class="calibre5"><a id="_idTextAnchor205" class="pcalibre calibre6 pcalibre1"/>Wielding Chef for system automation</h1>
			<p class="calibre3">The last <a id="_idIndexMarker500" class="pcalibre calibre6 pcalibre1"/>automation framework we will explore is Chef. Chef is a <a id="_idIndexMarker501" class="pcalibre calibre6 pcalibre1"/>slightly more hands-on and development-oriented automation framework than the previous ones, but powerful nonetheless. It has commercial backing by the similarly named company Chef.</p>
			<h2 id="_idParaDest-203" class="calibre10"><a id="_idTextAnchor206" class="pcalibre calibre6 pcalibre1"/>How Chef works</h2>
			<p class="calibre3">Chef has a <a id="_idIndexMarker502" class="pcalibre calibre6 pcalibre1"/>slightly more extensive approach to automation and requires slightly more work to get up and running. Once set up, however, it offers a very flexible and programmable environment wherein infrastructure automation can be worked out.</p>
			<p class="calibre3">There are three types of systems in the Chef architecture:</p>
			<ul class="calibre8">
				<li class="calibre9">The <strong class="bold">Chef server</strong> acts <a id="_idIndexMarker503" class="pcalibre calibre6 pcalibre1"/>as the central hub on which <a id="_idIndexMarker504" class="pcalibre calibre6 pcalibre1"/>the automation code is maintained, and which interacts with the remote systems to apply the changes.</li>
				<li class="calibre9">The <strong class="bold">Chef workstation</strong> is an <a id="_idIndexMarker505" class="pcalibre calibre6 pcalibre1"/>endpoint on which <a id="_idIndexMarker506" class="pcalibre calibre6 pcalibre1"/>administrators and engineers develop Chef recipes (code) and cookbooks and interact with the Chef server. There can be multiple Chef workstations per Chef environment.</li>
				<li class="calibre9">The <strong class="bold">Chef client</strong> is an <a id="_idIndexMarker507" class="pcalibre calibre6 pcalibre1"/>agent running on the remote <a id="_idIndexMarker508" class="pcalibre calibre6 pcalibre1"/>systems (nodes) managed by the Chef environment. </li>
			</ul>
			<p class="calibre3">Developers create <a id="_idIndexMarker509" class="pcalibre calibre6 pcalibre1"/>automation code in <strong class="bold">recipes</strong>, which are like tasks. Multiple recipes <a id="_idIndexMarker510" class="pcalibre calibre6 pcalibre1"/>are bundled in a <strong class="bold">cookbook</strong> and uploaded to the Chef server before the recipes can be applied to one or more nodes. Cookbooks can be compared with modules in the previous automation frameworks.</p>
			<p class="calibre3">The Chef clients and server use public key-based authentication and encryption for their interactions. It is the client that takes the initiative, connecting to the server to download the latest cookbooks and other resources, after which it calculates and applies the latest changes, sending feedback on these changes back to the server.</p>
			<h2 id="_idParaDest-204" class="calibre10"><a id="_idTextAnchor207" class="pcalibre calibre6 pcalibre1"/>Installing and configuring Chef</h2>
			<p class="calibre3">A full <a id="_idIndexMarker511" class="pcalibre calibre6 pcalibre1"/>Chef installation requires a few components to be installed. The Chef workstation <a id="_idIndexMarker512" class="pcalibre calibre6 pcalibre1"/>and the Chef server need to be installed by the administrator, whereas the Chef agents will be installed by Chef later.</p>
			<h3 class="calibre12">Installing the Chef workstation</h3>
			<p class="calibre3">To install <a id="_idIndexMarker513" class="pcalibre calibre6 pcalibre1"/>and use Chef, first download the Chef workstation. All Chef software can be downloaded from <a href="https://downloads.chef.io" class="pcalibre calibre6 pcalibre1">https://downloads.chef.io</a>. For CentOS, the Chef workstation is available as an RPM, which can be installed using <strong class="source-inline">yum</strong>. </p>
			<p class="calibre3">However, unlike common packaged software, the Chef workstation dependencies are not explicitly listed as RPM dependencies, causing the software to be installed without its necessary libraries. At the end of the installation, the RPM file will execute a post-installation script that checks the dependencies and reports on the missing libraries:</p>
			<p class="source-code">master ~# yum install chef-workstation-0.17.5-1.el7.x86_64.rpm</p>
			<p class="calibre3">The dependencies, currently, require the following CentOS packages to be installed:</p>
			<p class="source-code">master ~# yum install libX11-xcb libXcomposite libXcursor libXdamage nss gdk-pixbuf2 gtk3 libXScrnSaver alsa-lib git</p>
			<p class="calibre3">After <a id="_idIndexMarker514" class="pcalibre calibre6 pcalibre1"/>the installation, run <strong class="source-inline">chef -v</strong> (as a regular, non-root user) to verify whether all dependencies are met:</p>
			<p class="source-code">master ~$ chef -v</p>
			<p class="calibre3">The command should output the versions of the included Chef components.</p>
			<h3 class="calibre12">Installing and configuring the Chef server core</h3>
			<p class="calibre3">The second <a id="_idIndexMarker515" class="pcalibre calibre6 pcalibre1"/>installation is the Chef server core. This software <a id="_idIndexMarker516" class="pcalibre calibre6 pcalibre1"/>is again made available as RPM:</p>
			<ol class="calibre18">
				<li value="1" class="calibre9">Install the Chef server core using <strong class="source-inline">yum</strong>:<p class="source-code"><strong class="bold">master ~# yum install chef-server-core-13.2.0-1.el7.x86_64.rpm</strong></p><p class="calibre3">After the installation finishes, we need to configure it for our environment.</p></li>
				<li class="calibre9">Create a directory named <strong class="source-inline">/var/opt/chef</strong>. We will use this directory to store the cryptographic keys to authenticate against the Chef server:<p class="source-code"><strong class="bold">master ~# mkdir /var/opt/chef</strong></p></li>
				<li class="calibre9">Next, configure the Chef server using <strong class="source-inline">chef-server-ctl</strong>:<p class="source-code"><strong class="bold">master ~# chef-server-ctl reconfigure</strong></p><p class="calibre3">This will set up the Chef server on the current system. This setup can take a while to complete, but once finished, we can continue with creating a user account inside of Chef. </p></li>
				<li class="calibre9">Let's create an account called <strong class="source-inline">chefadmin</strong> for the user <strong class="source-inline">lisa</strong> on this system and give it a custom password:<p class="source-code"><strong class="bold">master ~# chef-server-ctl user-create chefadmin Lisa McCarthy lisa@ppubssa3ed.internal.genfic.local pw4chef --filename /var/opt/chef/chefadmin.pem</strong></p></li>
				<li class="calibre9">Create <a id="_idIndexMarker517" class="pcalibre calibre6 pcalibre1"/>an organization unit inside the Chef configuration, which <a id="_idIndexMarker518" class="pcalibre calibre6 pcalibre1"/>we associate with the newly created user:<p class="source-code"><strong class="bold">master ~# chef-server-ctl org-create ppubssa3ed "Packt Pub SSA 3rd Edition" --association_user chefadmin --filename /var/opt/chef/ppubssa3ed-validator.pem</strong></p></li>
			</ol>
			<p class="calibre3">With this done, the server administration itself is all done, and we can start creating our development environment.</p>
			<h3 class="calibre12">Preparing the development environment</h3>
			<p class="calibre3">As mentioned <a id="_idIndexMarker519" class="pcalibre calibre6 pcalibre1"/>earlier on, Chef is somewhat more development-oriented than the previous automation frameworks. The user that will interact with Chef (using the Chef workstation) needs to establish a development environment first:</p>
			<ol class="calibre18">
				<li value="1" class="calibre9">We previously created an account called <strong class="source-inline">chefadmin</strong> for the user <strong class="source-inline">lisa</strong>. Now, log in as the user <strong class="source-inline">lisa</strong> and create a development environment in the user's home directory:<p class="source-code"><strong class="bold">master ~$ mkdir chef</strong></p><p class="source-code"><strong class="bold">master ~$ cd chef</strong></p><p class="source-code"><strong class="bold">master ~$ git init</strong></p></li>
				<li class="calibre9">We create a Git-enabled environment as the Chef utilities require it. If you have no active Git configuration yet, you might need to add your email and name:<p class="source-code"><strong class="bold">master ~$ git config --global user.email "lisa@ppubssa3ed.internal.genfic.local"</strong></p><p class="source-code"><strong class="bold">master ~$ git config --global user.name "Lisa McCarthy"</strong></p></li>
				<li class="calibre9">Next, create the Chef knife configuration as <strong class="source-inline">.chef/knife.rb</strong> within this environment (so <strong class="source-inline">~/chef/.chef/knife.rb</strong> in our example):<p class="source-code"><strong class="bold">master ~$ mkdir .chef</strong></p><p class="source-code"><strong class="bold">master ~$ vim .chef/knife.rb</strong></p><p class="source-code"><strong class="bold">current_dir = File.dirname(__FILE__)</strong></p><p class="source-code"><strong class="bold">log_level		:info</strong></p><p class="source-code"><strong class="bold">log_location	STDOUT</strong></p><p class="source-code"><strong class="bold">node_name		"chefadmin"</strong></p><p class="source-code"><strong class="bold">client_key		"/var/opt/chef/chefadmin.pem"</strong></p><p class="source-code"><strong class="bold">chef_server_url	"https://ppubssa3ed/organizations/ppubssa3ed"</strong></p><p class="source-code"><strong class="bold">cookbook_path	["#{current_dir}/../cookbooks"]</strong></p><p class="calibre3">This configuration references the key used previously as well as the organization we created. If the Chef workstation is a different system than the Chef server, don't forget to copy over the key (<strong class="source-inline">chefadmin.pem</strong> in our example) and adjust the configuration accordingly.</p></li>
				<li class="calibre9">Download <a id="_idIndexMarker520" class="pcalibre calibre6 pcalibre1"/>the certificates that the Chef server uses (these certificates are self-signed certificates) and then check the SSL connection:<p class="source-code"><strong class="bold">master ~$ knife ssl fetch</strong></p><p class="source-code"><strong class="bold">master ~$ knife ssl check</strong></p></li>
				<li class="calibre9">If the checks are successful, we can commit the changes:<p class="source-code"><strong class="bold">master ~$ git add -A</strong></p><p class="source-code"><strong class="bold">master ~$ git commit -m 'Chef configuration baseline'</strong></p></li>
			</ol>
			<p class="calibre3">We are now ready to start our recipe and cookbook development.</p>
			<h2 id="_idParaDest-205" class="calibre10"><a id="_idTextAnchor208" class="pcalibre calibre6 pcalibre1"/>Creating the SELinux cookbook</h2>
			<p class="calibre3">The cookbook <a id="_idIndexMarker521" class="pcalibre calibre6 pcalibre1"/>we are going to develop will contain the various SELinux configuration entries, which are then assigned to the remote node:</p>
			<ol class="calibre18">
				<li value="1" class="calibre9">Let's start by creating a cookbook called <strong class="source-inline">packt_selinux</strong>:<p class="source-code"><strong class="bold">master ~$ mkdir cookbooks</strong></p><p class="source-code"><strong class="bold">master ~$ cd cookbooks</strong></p><p class="source-code"><strong class="bold">master ~$ chef generate cookbook packt_selinux</strong></p><p class="source-code"><strong class="bold">master ~$ cd packt_selinux</strong></p><p class="calibre3">This command creates the default files for the cookbook, of which we will handle <strong class="source-inline">metadata.rb</strong> and <strong class="source-inline">recipes/default.rb</strong>. The <strong class="source-inline">metadata.rb</strong> file contains information about the cookbook and, while it is not necessary for our example, it is sensible to edit and update this file immediately. Later, we will adjust this file to include dependency information toward other cookbooks.</p></li>
				<li class="calibre9">The <strong class="source-inline">recipes/default.rb</strong> file contains the actual logic we want to apply to the remote systems. Let's create a definition for the <strong class="source-inline">/usr/share/selinux/custom</strong> directory:<p class="source-code"><strong class="bold">master ~$ vim recipes/default.rb</strong></p><p class="source-code"><strong class="bold">directory '/usr/share/selinux/custom' do</strong></p><p class="source-code"><strong class="bold">  owner 'root'</strong></p><p class="source-code"><strong class="bold">  group 'root'</strong></p><p class="source-code"><strong class="bold">  mode '0755'</strong></p><p class="source-code"><strong class="bold">  action :create</strong></p><p class="source-code"><strong class="bold">end</strong></p></li>
				<li class="calibre9">Now upload the cookbook to the Chef server:<p class="source-code"><strong class="bold">master ~$ knife cookbook upload packt_selinux</strong></p></li>
				<li class="calibre9">We can <a id="_idIndexMarker522" class="pcalibre calibre6 pcalibre1"/>query the available cookbooks on the Chef server with the <strong class="source-inline">list</strong> subcommand:<p class="source-code"><strong class="bold">master ~$ knife cookbook list</strong></p><p class="source-code"><strong class="bold">packt_selinux   0.1.0</strong></p></li>
				<li class="calibre9">With the cookbook available, let's bootstrap the target node. Bootstrapping only needs to occur once, but must be triggered from a Chef authenticated user:<p class="source-code"><strong class="bold">master ~$ knife bootstrap rem1 --ssh-user root --node-name rem1</strong></p></li>
				<li class="calibre9">This ensures the Chef server knows the remote system. We can query the nodes using <strong class="source-inline">knife node list</strong> and get more details about a node with the <strong class="source-inline">show</strong> subcommand:<p class="source-code"><strong class="bold">master ~$ knife node show rem1</strong></p></li>
				<li class="calibre9">Assign the <strong class="source-inline">packt_selinux</strong> recipe to the node using the <strong class="source-inline">run_list add</strong> subcommand:<p class="source-code"><strong class="bold">master ~$ knife node run_list add rem1 'recipe[packt_selinux]'</strong></p><p class="calibre3">Adding the recipe to the node list does not automatically trigger the requested update. For this, the remote node's administrator needs to ensure that the <strong class="source-inline">chef-client</strong> binary executes either regularly (through a cron job or similar) or starts as a daemon.</p></li>
				<li class="calibre9">For our purposes, we will trigger the <strong class="source-inline">chef-client</strong> command on the remote system to download and apply the latest changes:<p class="source-code"><strong class="bold">remote ~# chef-client</strong></p><p class="calibre3">The output of <strong class="source-inline">chef-client</strong> should show how it found and applied the changes listed in the recipe.</p></li>
			</ol>
			<p class="calibre3">If this <a id="_idIndexMarker523" class="pcalibre calibre6 pcalibre1"/>command returns successfully, then Chef is ready to manage the remote system using the cookbook we've developed.</p>
			<h2 id="_idParaDest-206" class="calibre10"><a id="_idTextAnchor209" class="pcalibre calibre6 pcalibre1"/>Assigning SELinux contexts to filesystem resources with Chef</h2>
			<p class="calibre3">Chef has <a id="_idIndexMarker524" class="pcalibre calibre6 pcalibre1"/>limited native support for SELinux contexts. When instructed to create or modify files on nodes, it will relabel those files according to the present file context definitions on the nodes. We can, however, subscribe to events defined in the recipe, and trigger appropriate actions when they occur. For instance, to explicitly set the context of a directory, we can create something like this:</p>
			<p class="source-code">execute 'set_selinux_custom_context' do</p>
			<p class="source-code">  command '/usr/bin/chcon -t usr_t /usr/share/selinux/custom'</p>
			<p class="source-code">  action :nothing</p>
			<p class="source-code">  subscribes :run, 'directory[/usr/share/selinux/custom]', :immediately</p>
			<p class="source-code">end</p>
			<p class="calibre3">After adding this to the <strong class="source-inline">recipes/default.rb</strong> file, we first need to upload the updated cookbook to the server:</p>
			<p class="source-code">master ~$ knife cookbook upload packt_selinux</p>
			<p class="calibre3">Afterward, we can rerun <strong class="source-inline">chef-client</strong> on the remote node to apply this updated recipe. If the directory was previously already created, the recipe will not change anything as the subscription will not be triggered.</p>
			<h2 id="_idParaDest-207" class="calibre10"><a id="_idTextAnchor210" class="pcalibre calibre6 pcalibre1"/>Loading custom SELinux policies with Chef</h2>
			<p class="calibre3">Let's <a id="_idIndexMarker525" class="pcalibre calibre6 pcalibre1"/>update our recipe to include the logic to load a custom policy. We will use two blocks in our recipe, one to upload the <strong class="source-inline">test.cil</strong> file to the node, and another one to load it, but only if it was not loaded previously:</p>
			<p class="source-code">cookbook_file '/usr/share/selinux/custom/test.cil' do</p>
			<p class="source-code">  source 'test.cil'</p>
			<p class="source-code">  owner 'root'</p>
			<p class="source-code">  group 'root'</p>
			<p class="source-code">  mode '0755'</p>
			<p class="source-code">  action :create</p>
			<p class="source-code">end</p>
			<p class="source-code">bash 'load_test_cil' do</p>
			<p class="source-code">  code '/usr/sbin/semodule -i /usr/share/selinux/custom/test.cil'</p>
			<p class="source-code">  not_if '/usr/sbin/semodule -l | grep -q ^test$'</p>
			<p class="source-code">  only_if { ::File.exists?('/usr/share/selinux/custom/test.cil') }</p>
			<p class="source-code">end</p>
			<p class="calibre3">Put <a id="_idIndexMarker526" class="pcalibre calibre6 pcalibre1"/>the <strong class="source-inline">test.cil</strong> file in a folder called <strong class="source-inline">files</strong> inside the <strong class="source-inline">packt_selinux</strong> cookbook directory, before uploading the updated cookbook and reapplying the changes using <strong class="source-inline">chef-client</strong>.</p>
			<h2 id="_idParaDest-208" class="calibre10"><a id="_idTextAnchor211" class="pcalibre calibre6 pcalibre1"/>Using Chef's out-of-the-box SELinux support</h2>
			<p class="calibre3">While Chef <a id="_idIndexMarker527" class="pcalibre calibre6 pcalibre1"/>itself has limited out-of-the-box SELinux support, cookbooks are available online on Chef Supermarket (where the Chef community manages and distributes their custom cookbooks). Chef (the company) maintains the <strong class="source-inline">selinux</strong> cookbook itself, which allows managing the SELinux state of a system, whereas the <strong class="source-inline">selinux_policy</strong> cookbook addresses a few other SELinux settings.</p>
			<p class="calibre3">Let's download and install the <strong class="source-inline">selinux</strong> and <strong class="source-inline">selinux_policy</strong> cookbooks:</p>
			<p class="source-code">master ~$ knife supermarket install selinux_policy</p>
			<p class="source-code">master ~$ knife supermarket install selinux</p>
			<p class="source-code">master ~$ knife cookbook upload selinux_policy</p>
			<p class="source-code">master ~$ knife cookbook upload selinux</p>
			<p class="calibre3">Next, adjust the <strong class="source-inline">metadata.rb</strong> file of our own cookbook to include the dependency to this newly added cookbook:</p>
			<p class="source-code">depends 'selinux_policy'</p>
			<p class="source-code">depends 'selinux'</p>
			<p class="calibre3">We can now use some of the predefined recipes to handle SELinux configuration settings:</p>
			<ul class="calibre8">
				<li class="calibre9">With <strong class="source-inline">selinux_state</strong>, we can place the system in an enforcing or permissive state:<p class="source-code">selinux_state "SELinux enforcing" do</p><p class="source-code">  action :enforcing</p><p class="source-code">end</p></li>
				<li class="calibre9">The <strong class="source-inline">selinux_policy_boolean</strong> recipe can configure an SELinux boolean value:<p class="source-code">selinux_policy_boolean 'httpd_builtin_scripting' do</p><p class="source-code">  value false</p><p class="source-code">end</p></li>
				<li class="calibre9">With <strong class="source-inline">selinux_policy_port</strong>, a custom SELinux port mapping can be defined:<p class="source-code">selinux_policy_port '10122' do</p><p class="source-code">  protocol 'tcp'</p><p class="source-code">  secontext 'ssh_port_t'</p><p class="source-code">end</p></li>
				<li class="calibre9">A file context definition can be set using <strong class="source-inline">selinux_policy_fcontext</strong>:<p class="source-code">selinux_policy_fcontext '/srv/web(/.*)?' do</p><p class="source-code">  secontext 'httpd_sys_content_t'</p><p class="source-code">end</p></li>
				<li class="calibre9">An <a id="_idIndexMarker528" class="pcalibre calibre6 pcalibre1"/>SELinux domain can be put in permissive mode using the <strong class="source-inline">selinux_policy_permissive</strong> recipe:<p class="source-code">selinux_policy_permissive 'zoneminder_t' do</p><p class="source-code">end</p></li>
			</ul>
			<p class="calibre3">Don't forget to upload the changed cookbook before calling <strong class="source-inline">chef-client</strong> on the remote systems.</p>
			<h1 id="_idParaDest-209" class="calibre5"><a id="_idTextAnchor212" class="pcalibre calibre6 pcalibre1"/>Summary</h1>
			<p class="calibre3">Automation frameworks such as Ansible, SaltStack, Puppet, and Chef can be easily used to manage SELinux settings on a multitude of systems. While not all frameworks can deal with SELinux settings natively, this is easily mitigated by either using community-provided modules or by creating custom rules that check and update the settings accordingly. In this chapter, we've seen how to accomplish this by installing a custom, CIL-based SELinux policy.</p>
			<p class="calibre3">We learned that these frameworks all have their specific approaches. Ansible, for instance, does not use any software installations on remote systems and communicates with the target systems using SSH. The other frameworks all use an agent/server model but have their own views on configuring settings (the syntax between Puppet and SaltStack is noticeably different) or design (Chef uses a workstation where developers have their development environment). All these frameworks are easily put in place and configured and can handle most SELinux settings without any problems. All tools have a way of modularizing the definitions so they can be applied easily against a larger number of systems.</p>
			<p class="calibre3">Now that we know how to apply SELinux settings consistently, let's see what other SELinux controls exist, but now through userspace application-specific support.</p>
			<h1 id="_idParaDest-210" class="calibre5"><a id="_idTextAnchor213" class="pcalibre calibre6 pcalibre1"/>Questions</h1>
			<ol class="calibre18">
				<li value="1" class="calibre9">Which of the four tools have native support for setting SELinux contexts on resources?</li>
				<li class="calibre9">How do these orchestration tools allow reusable customization beyond native support?</li>
				<li class="calibre9">What are some obvious differences between the listed orchestration tools?</li>
			</ol>
		</div>
	</div></body></html>