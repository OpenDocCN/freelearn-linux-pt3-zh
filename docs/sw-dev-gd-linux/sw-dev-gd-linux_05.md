

# 文件简介

在 Linux 中，一切都是——或者可以表示为——一个文件。文件被组织成一个文件系统，文件系统其实就是一个由文件和目录（目录只是特殊类型的文件）组成的层级结构。作为开发人员，你在 Linux 系统上几乎做的每一件事都需要了解文件：编写和复制源代码、构建 Docker 镜像、应用日志、配置依赖关系等。

在这一章中，我们将详细介绍 Linux 中的文件。你将了解纯文本文件和二进制文件之间的区别，这两种文件内容类型是你最常接触的。我们会向你展示这些文件如何在 Linux 中组织成一个文件系统“树”，然后再深入介绍你需要用到的命令，帮助你创建、修改、移动和编辑文件。接着，我们将通过介绍最常用的命令行文本编辑器，完成文件编辑的基本知识讲解。

然而，在本章中，我们不仅仅停留在基础知识上。Linux 文件是一个值得深入了解的主题，掌握一些高级知识有时会带来实际的好处（有时甚至是直接的经济回报）。毕竟，“处理文件”是你在 Linux 上作为开发人员最常做的事情之一：编写和读取源代码和配置文件、查找特定的文件内容、复制和移动日志文件等等。你在这些基础操作上越高效，作为一个全面的开发人员，你就越能避免不断在 Google 上查找基本的 Linux 命令，或者在和同事的故障排除 Zoom 通话中尴尬地卡在命令行文本编辑器里。

首先，我们将讨论如何在文件系统树中搜索文件，并在单个文件中查找特定内容或模式。接下来，我们将讨论你可能会遇到的特殊文件和替代文件系统，以及你需要了解的有效工作方法。

到最后，你将了解：

+   你可能遇到的各种文件类型，以及它们的用途

+   你需要处理的最重要的文件数据类型

+   Linux 文件系统和你将使用的相关命令

+   文件编辑基础

+   一些常见问题及如何避免它们

本章内容丰富，是你学习 Linux 其他技能的基础之一。确保你在继续之前理解每一部分——你不必在第一次阅读时就记住所有内容，但尽量在自己的 Linux 环境中尽可能多地获得实践经验。掌握这些知识，对于你在解决现实问题或面试时将有实际的回报。

# Linux 中的文件：绝对基础

为了更好地讲解 Linux 中文件的更大主题，让我们先讲一些你可能已经有直觉的绝对基础：纯文本文件和二进制文件。我们还将讨论在将 Windows 文件移动到 Unix 系统，或反之时，可能会遇到的一个实际错误。

## 纯文本文件

你会遇到的最简单的文本文件形式之一就是强大的纯文本文件。虽然它们在历史上是 ASCII 文件，但现在通常是 UTF-8 编码的。你可能会遇到其他文件编码，但这种情况很少见，因为它们通常被认为是过时的。

## 什么是二进制文件？

Unix 不像许多其他操作系统那样区分二进制文件和文本文件。所有文件都可以通过管道流传输、编辑和附加。文件就是文件。当文件被设置为可执行时，Unix 会尽力执行它，要么成功（如**ELF**格式文件，可能是今天最广泛使用的可执行格式），要么失败——例如，尝试执行一个图像或音频文件时。

这个简单的机制开辟了一些令人惊讶的可能性。例如，执行文件可以通过压缩工具，然后通过网络隧道（如 SSH）传输，最后解压并写回到文件中——这一切都在一个命令中完成，而无需任何临时文件。

然而，这也意味着，你应该小心避免创建一个情况，例如，网站用户上传或修改的随机文件（包括日志文件！）有任何可能被执行的机会。这可能导致严重的安全问题。

## 行结束符

虽然 Unix 文件，尤其是文本文件，和其他操作系统上的文件功能相似，但值得一提的是，Windows（和 DOS）等系统使用不同的行结束符字符，这可能在许多使用这些文本文件的程序中导致错误。虽然这种情况只会发生在将一种系统上创建的文件复制到另一种系统时（例如，从 Linux 迁移到 DOS），但值得了解。

不同的行结束符的原因是历史性的，许多工具（例如 Git 和各种文本编辑器）会自动为你处理这种差异。然而，在极少数情况下，你可能需要手动转换文件。有一些著名的命令，如`dos2unix`，可以做到这一点，但这些命令通常需要手动安装在大多数类 Unix 操作系统上。

然而，仍然有一些方法可以使用更传统的工具来转换它们。

+   使用`sed`：`sed 's/^M$//' original_dos_file > unix_file`

+   使用`tr`：`tr -d '\r' < original_dos_file > unix_file`

+   使用`perl`就地替换：`perl -pi -e 's/\r\n/\n/g' original_file`

现在我们已经讨论了理解类 Unix 系统中文件所需的基本概念，让我们来谈谈这些文件实际上存在的上下文：Linux 文件系统。

# 文件系统树

**文件系统层次结构标准**（**FHS**）描述了类 Unix 系统的常规目录布局。Linux 遵循这一标准，实际上使其成为“Linux 的官方文件夹结构”。FHS 是一个标准化的树形结构，其中每个文件和目录都源自根目录（一个名为“`/`”的目录）。这个层次结构至关重要：虽然有一个位置供最终用户自由创建自己的目录结构，但`/`（根目录）中的每个子目录都有其特定的用途。

这个文件系统层次结构的基本布局并不难学习，通过现在投入几分钟，你会对文件的位置产生直觉——无论它们是应用程序二进制文件、日志、数据文件，还是你的代码需要访问的外部设备。换句话说，它既有助于开发，也有助于故障排除：当你知道文件“应该”在哪里时，你就能减少在事故发生时迷茫和不确定该在哪里寻找的时间。此外，这些知识对于编写自己的脚本和进行高级开发者预期的轻量级系统管理任务是必需的。

这里列出的是你经常会看到或需要自己使用的一些重要文件系统位置：

+   `/etc`：系统和软件配置文件存放在这里，按多个子目录进行组织。

+   `/bin` 和 `/sbin`：系统二进制文件存放在这里。不要随意更改这些文件。

+   `/usr/bin` 和 `/usr/local/bin`：你的已安装软件和你自己的二进制文件存放在这里，系统中的任何人都可以看到并执行它们。

+   `/var/log` 和 `/var/lib`：`/var`包含可变数据，这些数据在系统运行时容易发生变化，例如应用日志（`/var/log`）和动态库（`/var/lib`）、文件及其他运行中的应用状态。

+   `/var/lib/systemd`：文件系统中包含`systemd`配置的多个位置之一。

+   `/etc/systemd/system`：这是放置自定义系统单元文件的好地方，如果你正在创建服务的话。

+   `/dev`：用于表示硬件设备的特殊文件系统。

+   `/proc`：一个特殊的文件系统，用于查询或更改系统状态。

# 基本的文件系统操作

现在是时候深入了解你作为开发者每天都会用到的基础 Unix 命令了。这些命令将使你能够完成任何系统中需要执行的一系列基本命令行任务。一旦你学会并练习了本章中的命令，你将能够做一些事情，比如：

+   实时查看你的应用日志。

+   修复一个损坏的配置文件，让你的应用正常运行。

+   在本地 macOS 开发机器上的 Git 仓库中从一个目录切换到另一个目录。

让我们从列出一个目录开始。确保你已登录到一个 Linux 或 Unix 系统（Ubuntu 或 macOS 均可），并打开终端应用程序，准备跟随操作。

## ls

列出文件或目录。此命令类似于图形用户界面中的“打开文件夹”。它列出所给目录的内容。默认情况下，它使用你当前的目录：

```
/home/steve# ls
my_document.txt 
```

在这个例子中，我的 shell 当前的位置是`/home/steve`目录，它包含一个文件（`my_document.txt`）。

你可以通过传递目录路径作为参数，要求`ls`列出系统上的任何目录：

```
/home/steve# ls /var/log/
alternatives.log  apt  bootstrap.log  btmp  dpkg.log  faillog  lastlog  wtmp 
```

为了获得更整齐的输出，你可能想添加`-l`选项。这将给你一个“长列表”，意味着每行显示一个文件或目录，并附带额外的信息。

```
# ls -l /var/log/
total 296
-rw-r--r-- 1 root root   4686 Jun 24 02:31 alternatives.log
drwxr-xr-x 2 root root   4096 Jun 24 02:31 apt
-rw-r--r-- 1 root root  64547 Jun 24 02:06 bootstrap.log
-rw-rw---- 1 root utmp      0 Jun 24 02:06 btmp
-rw-r--r-- 1 root root 177139 Jun 24 02:31 dpkg.log
-rw-r--r-- 1 root root  32032 Oct 28 14:26 faillog
-rw-rw-r-- 1 root utmp 296296 Oct 28 14:26 lastlog
-rw-rw-r-- 1 root utmp      0 Jun 24 02:06 wtmp 
```

简而言之，`ls`命令就是你在 Unix 文件系统上“查看周围”的方式。

## pwd

“打印工作目录”的缩写。这显示了你在文件系统中的“位置”，是你当前 shell 会话的上下文。如果我作为`steve`用户登录到 Linux 系统，并且在我的主目录下，我可以期待`pwd`打印出类似这样的内容：

```
pwd
/home/steve 
```

## cd

更改当前工作目录。使用此命令后，你运行的命令将从新更改的文件系统位置的角度执行。

这是一个示例目录：

```
Desktop
├── anotherfile
├── documents
│   └── contract.txt
├── somefile.txt
└── stuff
    ├── nothing
    └── important 
```

如果你坐在`Desktop`目录下，但然后用`cd documents`切换到`documents`目录，你使用`ls`命令时，会从新的位置看到不同的列表。让我们看看实际操作：

```
/home/steve/Desktop# ls
anotherfile  documents  somefile.txt  stuff
/home/steve/Desktop# cd documents/
/home/steve/Desktop/documents# ls
contract.txt 
```

现在我们可以查看我们的周围环境（`ls`）、在文件系统中移动（`cd`），并且知道我们在哪个位置（`pwd`），让我们开始通过创建和修改文件来实际影响文件系统。

## touch

这个操作写作`touch filepath`。

根据你提供的文件路径是否已存在，`touch`命令将执行以下两种操作之一：

1.  如果路径下的文件尚不存在，`touch`将创建它：

    ```
    →  /tmp touch filepath
    →  /tmp ls -l filepath
    -rw-r--r--  1 dcohen  wheel  0 Aug  7 16:02 filepath 
    ```

1.  如果路径下的文件*确实*存在，`touch`将更新该文件的访问和修改时间：

    ```
    →  /tmp touch filepath
    →  /tmp ls -l filepath
    -rw-r--r--  1 dcohen  wheel  0 Aug  7 16:03 filepath 
    ```

注意，唯一改变的是在长列表显示中的修改时间。

## less

`less`是一个被称为“分页器”的程序——它允许你一次查看文件内容的一个屏幕（页面）：

```
less /etc/hosts 
```

它是交互式的——一旦你开始用它查看文件，你可以：

+   使用鼠标滚轮或箭头键逐行向上或向下滚动。

+   使用**SPACE**键滚动整页。

+   使用*/*（输入搜索模式）*RETURN*进行搜索。

+   转到下一个匹配项：**n**。

+   使用**q**退出程序。

练习使用它一两分钟，你就能掌握。

## tail

`tail`用于查看文件的最后几行。

```
tail /some/file 
```

`-f`（跟随）选项对于实时流式传输日志到终端非常有用：

```
tail -f /var/log/some.log 
```

使用**q**退出 tail。

## mv

`mv`（移动）用于移动和重命名文件。

### 移动

假设你有一个名为`somefile.txt`的文件：

```
→  Desktop ls -alh somefile.txt
-rw-r--r--  1 dcohen  wheel     0B Aug  7 11:02 somefile.txt 
```

只要你和文件处于同一个目录，以下是如何将它移动到`/var/log`目录，而不重命名它：

```
mv somefile.txt /var/log/ 
```

### 重命名

现在你想把那个文件重命名为`foobar`：

```
mv /var/log/somefile /var/log/foobar 
```

就是这样！

## cp

要复制文件和目录，请使用`cp`命令：

`cp file destination` 将名为`file`的文件复制到目标文件路径`destination`。最常用的选项是`-r`，或者`–recursive`；如果你复制的是一个目录，它将复制其中的所有内容。

```
cp -r /home/dave /storage/userbackups/ 
```

## mkdir

使用以下命令创建一个新的空目录，命名为`directoryname`：

```
mkdir directoryname 
```

一个有用的选项是`-p`，它允许你在一个命令中创建嵌套目录。例如，如果你想创建一个包含名为`school`的目录的`Documents`目录，而`school`目录中又包含一个名为`reports`的目录，你可以运行以下命令：

```
mkdir -p Documents/school/reports 
```

## rm

`rm` 删除（删除）文件和目录：

+   `rm filename` 删除名为`filename`的文件。

+   `rm -r directoryname` 将删除名为`directoryname`的目录，以及其中的所有文件和目录，递归地。

删除空目录有一个单独的命令，名为`rmdir`，但它通常只在脚本中使用，开发人员小心地限制不小心删除的范围。

# 编辑文件

无论是更新配置文件、创建新的 Linux 服务，还是在故障排除期间做笔记，你在 Linux 上的工作偶尔会要求你在命令行上编辑文件。我们将在*第六章*《命令行编辑文件》中详细介绍命令行文件编辑，但在这里我们会给你一个非常简短的概述。

如果你只能使用命令行环境，可能会使用一些 CLI 文本编辑器：

+   **nano**：几乎总是已安装或可用；易于使用

+   **vi**：几乎到处都已安装；需要一点时间适应

+   **vim**：在所有地方都容易安装；比`vi`功能更全面

如果这些编辑器没有安装，你可以通过你的包管理器安装它们。例如，如果你使用的是 Ubuntu Linux，可以使用类似`sudo apt-get install nano`的命令（或将`nano`替换为`vim`）。我们将在*第九章*《管理已安装的软件》中深入探讨包管理命令。不管你选择哪个编辑器，你只需在命令行中输入`[$EDITOR filename]`来编辑文件；例如：

```
vi filename
vim /some/file
nano /another/file 
```

+   如果文件存在，你将能够在编辑器中编辑它。

+   如果不存在，但目录存在，你将在编辑器中第一次保存时，在该路径下创建一个新文件。

+   如果目录不存在，你可能仍然能够编辑该文件，但编辑器在没有一些额外步骤的情况下无法将其写入文件系统。

在下一章，*第六章*《命令行编辑文件》中，我们将深入探讨在 Linux 命令行上编辑文件的实际技能。如果你在完成本章之前绝对需要编辑文件，只需输入`nano /path/to/the/file`并按照屏幕上的备忘单保存并退出。与此同时，让我们了解一下你作为 Linux 开发者会遇到的各种文件类型。

# 文件类型

我们已经讨论了“常规”文件，比如纯文本文件或图像文件中的二进制数据以及可执行程序。但是，在 Linux 中，还有几种其他类型的文件，你需要知道如何识别并与之操作。无论你是在寻找你刚刚插入计算机的 USB 闪存盘或键盘，创建指向文件的链接，还是检查一个 Web 进程打开的网络套接字，你都需要了解这些 *所有* 文件类型。

下面是所有 Linux 文件类型及其用途：

+   **常规文件**：这是最常见的文件类型，包含文本或二进制数据。作为软件工程师，你会在几乎每个编程任务中遇到常规文件，无论是编写代码、编辑配置文件还是执行程序。在长列表中，你可能会看到的典型示例是像这样的源代码文件：

    ```
    -rw-r--r-- 1 dave dave 210 Jan 04 09:30 main.c 
    ```

+   **目录**：目录是用于组织其他文件和目录的特殊文件。如果你曾经使用过 Windows 或 macOS（在这些系统中，它们被称为“文件夹”），那么你已经熟悉了目录；它们包含其他文件和目录。在长列表中，像 `/etc` 这样的目录将显示为：

    ```
    drwxr-xr-x 5 root root 4096 Jan 04 09:21 /etc 
    ```

+   **块特殊文件**：这种特殊文件类型提供缓冲访问硬件设备，这使得它们特别适用于像硬盘这样的设备，因为数据是以大块、固定大小的块进行访问的。除非是在挂载文件系统时，你很少会直接使用这些文件。一个示例可能是一个硬盘分区，显示为：

    ```
    brw-rw---- 1 root disk 8, 2 Jan 19 11:00 sda2 
    ```

    这表示一个块设备，具有所有者和组的读写权限。

+   **字符特殊文件**：与块文件类似，字符文件提供无缓冲的、原始的硬件设备访问，但它们是为数据不是以块方式组织的设备设计的，比如键盘或鼠标。你通常不需要关心这些文件，尽管在工作中你可能偶尔会用到它们（例如，`/dev/urandom`、`/dev/null` 或 `/dev/zero`）。像终端这样的字符设备在长列表中可能会显示为：

    ```
    crw-rw-rw- 1 root tty 5, 1 Jan 19 22:00 /dev/tty1 
    ```

+   **FIFO 特殊文件（“命名管道”）**：命名管道，不要与 shell 中经常使用的匿名管道混淆，用于进程间通信。你几乎不需要处理这些文件，尽管在 *第十一章*《管道和重定向》中，你将使用它们的匿名版本来成为 Unix 大师。你很少会遇到这些文件，但有一个示例是命名管道文件，它可能看起来像这样：

    ```
    prw-r--r-- 1 user user 0 Jan 21 10:00 mynamedpipe 
    ```

+   **链接**：链接是一种指向其他文件的快捷方式。链接有两种类型——硬链接和符号链接（软链接）。你几乎不需要处理硬链接，但你可能会使用符号链接来创建指向常用文件的方便路径，或者确保多个路径指向同一个文件。我们将在下面详细介绍这些内容。符号链接可能显示为：

    ```
    lrwxrwxrwx 1 user user 7 Jan 21 10:30 versions/latest -> bin/app-3.1 
    ```

    这个示例表示一个名为 `latest` 的链接，它指向名为 `app-3.1` 的文件。

+   **套接字**：Unix 套接字用于进程间通信（IPC），类似于管道文件。在故障排除需要相互通信的服务时，你可能会遇到套接字文件（“为什么 nginx 无法访问我的应用服务器？”）。例如，一个用于 nginx 和`php-fpm`之间通信的套接字文件，以便 WordPress 应用程序能够运行，可能如下所示：

    ```
    srwxrwx--- 1 root socket 0 Jan 23 11:31 /run/wordpress.sock 
    ```

这个列表涵盖了你可能遇到的额外的特殊文件类型，并且给你提供了一些关于你为何以及如何在实际使用中遇到这些文件类型的直觉。为了帮助你建立实用的技能，我们应该特别深入探讨几种类型。让我们从体验最常见的这些特殊文件类型——链接开始。

## 符号链接

符号链接，通常称为 symlink 或软链接，是一种文件类型，用作指向另一个文件或目录的引用。与硬链接不同，符号链接可以跨不同的文件系统指向一个文件或目录，并且它维护与所引用的文件或目录不同的 inode。

你可以使用以下基本语法创建符号链接：

```
ln -s document.txt /path/to/create/link 
```

`ln`（小写字母 l）是“链接”命令。

例如，如果你在当前目录中有一个名为`file1.txt`的文件，并且你想创建一个指向它的符号链接，命名为`link1`，你可以使用以下命令：

```
ln -s file1.txt link1 
```

现在，如果你使用`ls -l`列出目录的详细信息，你会看到`link1`作为指向`file1.txt`的链接列出：

```
ls -l
total 0
-rw-r--r-- 1 root root 0 Oct 28 16:08 file1.txt
lrwxrwxrwx 1 root root 9 Oct 29 17:20 link1 -> file1.txt 
```

例如，当你通过使用`cat link1`查看`link1`的内容时，系统会自动取消引用该链接并显示`file1.txt`的内容。如果`file1.txt`被移动、删除或重命名，符号链接不会自动更新，并且会指向一个不存在的文件（即断开的链接）。

符号链接特别适用于创建快捷方式、组织文件和目录，并维护灵活和逻辑的文件系统结构。

## 硬链接

硬链接是同一文件系统上现有文件的额外名称，实际上充当了别名。原始文件和硬链接共享相同的 inode，这意味着对一个的更改会反映到另一个上。与符号链接不同，硬链接不能跨文件系统边界或链接到目录。如果原始文件被删除，硬链接仍然会保持数据。要创建名为`link1`的硬链接，指向名为`file1.txt`的文件，你可以使用以下命令：

```
ln file1.txt link1. 
```

## `file`命令

`file`命令是一个工具，可以让你检查文件的类型。`file`命令的基本用法很简单：输入`file`后跟文件名。例如：

```
file mysecret.txt 
```

可能输出`mysecret.txt: ASCII text`，表示`mysecret.txt`是一个纯文本文件。

如果你有一个二进制文件，比如一个名为`mybinary`的已编译程序，运行`file mybinary`可能会输出类似`mybinary: ELF 64-bit LSB executable`的内容，表示`program`是一个二进制可执行文件。

对于目录，例如`/home/user`，运行`file /home/user`通常会返回`/home/user: directory`，表示`/home/user`是一个目录。

`file`命令是一个强大的工具，可以快速了解你正在处理的文件类型，尤其是在处理未知或不熟悉的文件时。

如果你想探索，可以使用`file`命令检查以下文件：

+   `file /bin/sh`

+   `file /dev/zero`

+   `file /dev/urandom`

+   `file /dev/sda1`

+   `file ~/.bashrc`

+   `file /bin/ls`

+   `file /home`

+   `file /proc/1/cwd`

# 高级文件操作

当你在类 Unix 操作系统中处理文件时，你通常希望对它们或它们的内容执行某些操作，但不直接在编辑器中修改它们。例如，你可能想要：

+   搜索文件，看看它是否包含你正在寻找的内容。

+   识别在特定时间被修改的一批文件。

+   安全地将文件移动到另一个系统，而不是仅仅在本地机器上使用`mv`进行复制。

你甚至可能想将这三者结合成一个单一的操作！这种类型的知识在故障排除（在日志中搜索特定的请求 ID 或错误代码）、开发（查找最近修改的源代码文件）或测试（将更新的应用程序源代码复制到测试系统）时非常有用。

这里快速介绍这些文件操作，帮助你了解将用于完成这些操作的工具和命令。

## 使用 grep 搜索文件内容

文本匹配传统上使用`grep`完成。在个人或工作笔记本上，你可能希望安装`ag`或`rg`，它们是更适合程序员的、更快速的版本（例如，`sudo apt-get install silversearcher-ag`），但在生产系统上，你将始终使用`grep`。

在文件`path/to/file`中搜索模式`search_pattern`：

```
grep "search_pattern" path/to/file 
```

当然，你可以像这样搜索字符串字面量，但`grep`之所以强大，是因为它允许你使用正则表达式（regex）来搜索模式。以下命令将返回以`startswith`开头的行：

```
grep ^startswith /some/file 
```

这个命令将返回以`endswith`结尾的行：

```
grep endswith$ /some/file 
```

正则表达式非常有用，每个开发者和 Linux 用户都应该熟悉其基础知识。

你还可以使用`grep`递归地搜索一个目录——也就是说，搜索它包含的所有文件中的所有目录：

```
root@c7f1417df8d2:/tmp# grep -r -i "hello world" /tmp
/tmp/secret/dontlook.key:hello world
/tmp/hi.txt:hello world
/tmp/hi.txt:HeLlO WoRlD! You found me! 
```

但如果你不想查找文件*内部*的字符串——如果你想找到特定的文件本身呢？

## 使用 find 查找文件

`find`可以帮助你根据名称、修改时间或其他属性查找文件和目录。它本质上是文件系统树的广度优先搜索，非常适用于以下任务：

+   查找在过去一天内创建或修改的所有应用程序日志文件。

+   识别所有以`_test.go`结尾的源代码测试文件。

+   定位所有被实习生程序员遗留下来的`php.ini`文件，以便删除它们。

在以下示例中，`/search/path`是你想要搜索的文件系统部分。如果你想要搜索当前目录及其所有子目录，可以使用点号字符（`.`），例如，`find . -name 'file.txt'`：

+   按扩展名查找文件：

    ```
    find /search/path -name '*.ext' 
    ```

+   查找匹配多个路径/名称模式的文件：

    ```
    find /search/path -path '**/path/**/*.ext' -or -name '*pattern*' 
    ```

+   查找匹配给定名称的目录，不区分大小写：

    ```
    find /search/path -type d -iname '*lib*' 
    ```

+   查找匹配给定模式的文件，排除特定路径：

    ```
    find /search/path -name '*.py' -not -path '*/site-packages/*' 
    ```

+   查找匹配给定大小范围的文件：

    ```
    find /search/path -size +500k -size –10M 
    ```

### 使用 rsync 在本地和远程主机之间复制文件

`rsync`是一个非常有用的工具，用于在主机之间复制文件和目录。它的工作方式和`cp`命令一样，不同之处在于它可以在一个或两个主机是远程主机时工作。

`rsync`本质上是`cp`（用于复制数据）和`ssh`（用于安全加密传输）的结合体。如果你不熟悉`ssh`，你需要先了解它的工作原理（并设置自己的 SSH 密钥和访问权限），然后再尝试使用`rsync`命令。

这里有一些示例调用，感谢`tldr`项目：

+   将文件从本地主机传输到远程主机：

    ```
    rsync path/to/local_file remote_host:path/to/remote_directory 
    ```

+   将文件从远程主机传输到本地主机：

    ```
    rsync remote_host:path/to/remote_file path/to/local_directory 
    ```

+   使用[`a`]归档模式（保留属性）和压缩（[`z`]压缩）模式，带[`v`]详细信息和[`h`]人类可读的[`P`]进度：

    ```
    rsync -azvhP path/to/local_directory remote_host:path/to/remote_directory 
    ```

最后的这个例子是我用过一百次的命令，用于快速、自动化备份。

### 结合使用 find、grep 和 rsync

我们将在*第十一章*，*管道和重定向*中详细了解如何使用`|`字符来组合命令，但这里给你一个快速预览。

举个例子，如果你想将刚才看到的例子结合起来，例如，备份上周内修改的所有`/tmp`目录中的文件，那只需要一个巧妙的命令：

```
find /tmp -type f -mtime -7 -exec grep -l "hello world" {} \; | xargs -I _ backupscript.sh _ backup@backupserver.local:/backups_ 
```

首先，我们运行`find`命令，查找修改时间在 7 天之内的文件。我们使用 find 的`-exec`标志来执行一个带有`-l`标志的`grep`命令，该命令只会返回匹配文件的文件名。然后，我们将这些文件名传递给`xargs`命令，`xargs`会对从前一个命令接收到的每一行输入执行一个动作。在这个例子中，动作是对每个匹配文件运行一个虚拟的备份脚本，并指定一个虚拟的目标路径，这个路径是用户可能希望将文件备份到的位置。

如果我们有与上面`grep`部分相同的文件，这个看起来有些复杂的命令会为你执行两个命令：

```
backupscript.sh /tmp/secret/dontlook.key backup@backupserver.local:/backups/tmp/secret/dontlook.key
backupscript.sh /tmp/hi.txt backup@backupserver.local:/backups/tmp/hi.txt 
```

它正在做我们想要的事情：仅对包含我们关心的“hello world”内容*且*在过去 7 天内修改过的两个文件运行备份脚本。

虽然像这样的命令可能需要几分钟时间（以及一些谷歌搜索）来编写，但从长远来看，它可能为你节省数小时的工作。这就是命令行环境的强大之处，结合了小巧且专注的 Unix 工具，你可以根据需要将它们组合起来。

你将在*第十一章*，*管道和重定向*中进一步了解 Unix 管道和`xargs`，但我们在这里给你举这个例子，是因为你需要提前了解如何将这些简单的命令组合在一起，以便在学习过程中使用。

# 真实世界中的高级文件系统知识

你现在已经了解了各种 Linux 文件类型，并且有了一些与最常见文件类型打交道的经验。现在，让我们来看看一些不太常见的文件系统知识，它们在你使用 Linux 系统时会派上用场。

当你在以下场景中会遇到这些内容：

+   排查你的第一个 Docker 应用程序，该应用程序已经挂载了存储卷。

+   开发与工业控制器、摄像头或其他外部硬件通信的应用程序。

+   编写需要访问随机数的应用程序代码，用于安全地生成密码或 API 令牌。你将会遇到的特殊文件类型之一是**块设备**，它们是类似磁盘的设备，数据以块的形式被提取和读取。

经典的磁盘设备是块设备，你通常会在以下位置找到它们附加到你的文件系统上：

+   `/dev/hdX`

+   `/dev/sdX`

+   `/dev/nvmeN`

其中`X`和`N`是各自磁盘的字母或数字索引，比如`/dev/sda`或`/dev/nvme0`。**分区**看起来就像磁盘，但在后面会附加一个额外的数字或字符，比如`/dev/sda0`，表示第一个磁盘上的第一个分区。

注意，即使操作系统检测到新的硬盘并将其（以及任何检测到的分区）附加到这些位置，你仍然需要手动“挂载”驱动器上的文件系统，使用`mount`命令。这对于开发者来说并不是特别常见的操作，因此我们就不展开了。

还有一些特殊的“**软件设备**”。这些包括`/dev/null`，你可能看到过将输出通过管道传递到它那里，如`somecommand > /dev/null`，以及`/dev/random`和`/dev/urandom`，它们为你提供随机字节。这也是你选择的编程语言可能会从中获取其加密安全的随机数的地方。

另一个目录是`/proc`，这是一个由 Plan 9 操作系统推广的文件系统，但在 Unix 早期就有了它的构想。顾名思义，它是用来将进程表示为文件的。`/proc`包含以进程 ID 命名的目录，目录下有可以用来读取进程状态的文件。尤其在 Linux 中，它扩展了各种接口，包括配置内核驱动程序、读取硬件信息和传感器输出，甚至与 BIOS 和 UEFI 交互。

## FUSE：与 Unix 文件系统更有趣的互动

正如你刚刚看到的，Unix 中许多东西都可以被解释为文件。其理念是常见的编辑文件，因此能够与文件交互的命令和编程语言提供了一个被广泛理解的接口。**FUSE**，即**用户空间文件系统**，是一个允许任何人实现新的 Unix 文件系统的 API，而不必成为内核程序员。换句话说，因为许多东西可以与文件对话，所以能够“伪造”Unix 文件 API，对于那些不是你期望的普通本地存储数据的东西，是非常有用的。如果这听起来有点疯狂，请看看人们使用 FUSE 写的一些东西。FUSE 已被用来实现许多经典的文件系统驱动程序，例如 NTFS，因此你可以在 Linux 机器上读取你的旧 Windows 文件系统。然而，由于 FUSE 的灵活性和易用性，也有一些非常疯狂的文件系统是这样实现的：

+   例如，`sshfs` 允许你在通过 SSH 访问的另一台机器上本地挂载一个目录。

+   其他 FUSE 文件系统允许你将远程云存储（如亚马逊的 S3）挂载为本地目录。

+   一些更加不为人知的文件系统允许你将 Wikipedia 挂载为文件目录，或者将诸如 IRC 和像天气 API 这样的服务表示为文件系统。

FUSE 如此有用，以至于它已经进入了除 Linux 之外的许多类 Unix 操作系统，并且现在甚至在 Windows 上也可用。了解它是值得的，不仅因为它是 Unix 文件抽象的一种新颖应用，而且在处理存储在某处没有经典 API 的信息时，它可以非常有用。你可能会使用的任何编程语言都有一个标准库，让你能够在 Unix 文件系统上操作文件，而 FUSE 则是为几乎任何类型的信息创建这种接口的一种方式。

# 结论

这一章节是对 Linux 上文件和文件系统基础及一些高级内容的密集探讨。你了解了纯文本文件和二进制文件的区别，探索了 Linux 文件系统树的布局，并学习了所有处理文件所需的基本命令。如果你做得对，你也在自己的 Linux 环境中花了一些时间，练习了我们在这里展示的重要的命令行文件编辑技能。

在介绍了基础知识之后，我们进入了你将需要的最关键的中级和高级主题。你学会了如何查找文件并在其中搜索内容，我们还让你尝试了特殊文件和文件系统。

所有这些加在一起，让你具备了解决实际问题所需的最重要的技能和知识。希望你在这场风风火火的旅程中玩得开心！

# 在 Discord 上了解更多

要加入本书的 Discord 社区——在这里你可以分享反馈、向作者提问并了解新版本的发布——请扫描下方的二维码：

[`packt.link/SecNet`](https://packt.link/SecNet)

![](img/QR_Code1768422420210094187.png)
