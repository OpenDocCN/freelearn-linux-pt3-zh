<html><head></head><body>
<div id="sbo-rt-content"><div id="_idContainer030">
<h1 class="chapter-number" id="_idParaDest-66"><a id="_idTextAnchor081"/>5</h1>
<h1 id="_idParaDest-67"><a id="_idTextAnchor082"/>Hardware Discovery</h1>
<p><a id="_idTextAnchor083"/>Knowing how to find out what hardware an operating system runs on and what peripherals are attached is a necessary skill for all systems administrators – at the very least, every administrator needs to know how many CPU cores they have and how much memory there is to allocate resources to applications. In this chapter, we’ll learn how to retrieve and interpret information about CPUs, USB peripherals, and storage devices, using both the raw kernel interfaces and utilities to work with them. We will also cover tools specific to x86 machines with a <span class="No-Break">SMBIOS/DMI interface.</span></p>
<p>In this chapter, we will cover the <span class="No-Break">following topics:</span></p>
<ul>
<li>How to discover the number of CPUs, their model names, <span class="No-Break">and features</span></li>
<li>How to discover PCI, USB, and <span class="No-Break">SCSI peripherals</span></li>
<li>How to use platform-specific tools to retrieve detailed hardware information from <span class="No-Break">system firmware</span></li>
</ul>
<h1 id="_idParaDest-68"><a id="_idTextAnchor084"/>Discovering CPU model and features</h1>
<p>The central processor <a id="_idIndexMarker235"/>is certainly one of the most important hardware components, and there are many reasons to find out detailed information about it. The CPU model name or number and frequency are the first things you would look at to find out the age and overall performance of a machine. However, there are more details that are often useful in practice. For example, the number of CPU cores is important to know if you run applications that support multiple worker threads or processes (such as <strong class="source-inline">make -j2</strong>). Trying to run more processes than there are CPUs may slow the application down because some of those processes end up waiting for an available CPU, so you may want to run fewer worker processes to avoid overloading <span class="No-Break">the machine.</span></p>
<p>It’s also important to know whether your CPU supports specific acceleration technologies such as AES-NI or Intel QuickAssist. If they are available, some applications can perform much better if you enable support for those <span class="No-Break">acceleration features.</span><a id="_idTextAnchor085"/></p>
<h2 id="_idParaDest-69"><a id="_idTextAnchor086"/>Feature discovery on different platforms</h2>
<p>One thing you should<a id="_idIndexMarker236"/> remember about CPU information discovery is that it’s largely a feature of the CPU itself rather than a feature of Linux. If a CPU has no way to report certain information, it may be difficult or even impossible to figure it out from <span class="No-Break">the software.</span></p>
<p>Many ARM and MIPS CPUs do not report their exact model names, so the only way to find them may be to just open the case and look at <span class="No-Break">the chip.</span></p>
<p>For example, the popular Raspberry Pi 4 single-board computer uses an ARM Cortex A72 CPU, but it doesn’t tell <span class="No-Break">you that.</span></p>
<pre class="source-code">
pi@raspberrypi4   :~ $ cat /proc/cpuinfo
processor         : 0
model name        : ARMv7 Processor rev 3 (v7l)
BogoMIPS          : 108.00
Features          : half thumb fastmult vfp edsp neon vfpv3 tls vfpv4 idiva idivt vfpd32 lpae evtstrm crc32
CPU implementer   : 0x41
CPU architecture  : 7
CPU variant       : 0x0
CPU part          : 0xd08
CPU revision      : 3</pre>
<p>We will focus on x86 CPUs made by AMD and Intel because they are still the most common CPUs outside of embedded system markets, and they have the most extensive <span class="No-Break">feature-reporting functionality<a id="_idTextAnchor087"/>.</span></p>
<h2 id="_idParaDest-70"><a id="_idTextAnchor088"/>The /proc/cpuinfo file</h2>
<p>We discussed the <strong class="source-inline">/proc</strong> filesystem<a id="_idIndexMarker237"/> when we talked about process<a id="_idIndexMarker238"/> control in <a href="B18575_04.xhtml#_idTextAnchor059"><span class="No-Break"><em class="italic">Chapter 4</em></span></a>, <em class="italic">Processes and Process Control</em>. That filesystem is virtual – files under <strong class="source-inline">/proc</strong> aren’t present on any disk, and the kernel simply presents that information as if it were stored in files, according to the <em class="italic">everything is a file</em> principle of the <span class="No-Break">Unix philosophy.</span></p>
<p>Apart from information about running processes, the kernel also uses <strong class="source-inline">/proc</strong> for information about CPUs and memory. The file with CPU information is named <strong class="source-inline">/proc/cpuinfo</strong>, as we <span class="No-Break">saw earlier.</span></p>
<p>Now, let’s<a id="_idIndexMarker239"/> look <a id="_idIndexMarker240"/>at that file on an <span class="No-Break">Intel machine:</span></p>
<pre class="source-code">
$ cat /proc/cpuinfo
processor         : 0
vendor_id         : GenuineIntel
cpu family        : 6
model             : 44
model name        : Intel(R) Xeon(R) CPU            L5630  @ 2.13GHz
stepping          : 2
microcode         : 0x1a
cpu MHz           : 2128.000
cache size        : 12288 KB
physical id       : 0
siblings          : 1
core id           : 0
cpu cores         : 1
apicid            : 0
initial apicid    : 0
fpu               : yes
fpu_exception     : yes
cpuid level       : 11
wp                : yes
flags             : fpu vme de pse tsc msr pae mce cx8 apic sep mtrr pge mca cmov pat pse36 clflush dts mmx fxsr sse sse2 syscall nx rdtscp lm constant_tsc arch_perfmon pebs bts nopl xtopology tsc_reliable nonstop_tsc cpuid aperfmperf pni pclmulqdq ssse3 cx16 sse4_1 sse4_2 x2apic popcnt tsc_deadline_timer aes hypervisor lahf_lm pti tsc_adjust dtherm ida arat
bugs              : cpu_meltdown spectre_v1 spectre_v2 spec_store_bypass l1tf mds swapgs itlb_multihit
bogomips          : 4256.00
clflush size      : 64
cache_alignment   : 64
address sizes     : 42 bits physical, 48 bits virtual
power management  :
processor         : 1
vendor_id         : GenuineIntel
cpu family        : 6
model             : 44
model name        : Intel(R) Xeon(R) CPU            L5630  @ 2.13GHz
stepping          : 2
microcode         : 0x1a
cpu MHz           : 2128.000
cache size        : 12288 KB
physical id       : 2
siblings          : 1
core id           : 0
cpu cores         : 1
apicid            : 2
initial apicid    : 2
fpu               : yes
fpu_exception     : yes
cpuid level       : 11
wp                : yes
flags             : fpu vme de pse tsc msr pae mce cx8 apic sep mtrr pge mca cmov pat pse36 clflush dts mmx fxsr sse sse2 syscall nx rdtscp lm constant_tsc arch_perfmon pebs bts nopl xtopology tsc_reliable nonstop_tsc cpuid aperfmperf pni pclmulqdq ssse3 cx16 sse4_1 sse4_2 x2apic popcnt tsc_deadline_timer aes hypervisor lahf_lm pti tsc_adjust dtherm ida arat
bugs              : cpu_meltdown spectre_v1 spectre_v2 spec_store_bypass l1tf mds swapgs itlb_multihit
bogomips          : 4256.00
clflush size      : 64
cache_alignment   : 64
address sizes     : 42 bits physical, 48 bits virtual
power management  :</pre>
<p>Some information is obvious and needs no interpretation. The model is Intel Xeon L5630, its frequency is 2.13 GHz, and it has 12 kilobytes of cache. The reason why CPU vendor names are written in seemingly strange ways such as <strong class="source-inline">GenuineIntel</strong> and <strong class="source-inline">AuthenticAMD</strong> is that, internally, the vendor string is stored as three 32-bit values, which gives 12 bytes. Note how both <strong class="source-inline">GenuineIntel</strong> and <strong class="source-inline">AuthenticAMD</strong> are 12 characters long – they were chosen to fill all 12 bytes with printable ASCII characters to avoid issues with different interpretations of null bytes on <span class="No-Break">different systems.</span></p>
<p>One field of note is <strong class="source-inline">bogomips</strong>. Its name <a id="_idIndexMarker241"/>hints at the <strong class="bold">Million Instructions per Second</strong> (<strong class="bold">MIPS</strong>) performance metric, but that value isn’t a useful indicator of overall performance. The Linux kernel uses it for internal calibration purposes, and you shouldn’t use it to compare the performance of <span class="No-Break">different CPUs.</span></p>
<p>The <strong class="source-inline">flags</strong> field has the highest information density and is the most difficult to interpret. A flag is simply a bit in the Flags register, and the meanings of those bits vary widely. Some of them aren’t even set in the hardware CPU, such as the hypervisor flag, which indicates that the system runs on a virtual machine (but its absence doesn’t mean anything, since not all hypervisors <span class="No-Break">set it).</span></p>
<p>Many flags indicate whether a certain feature is present, although interpreting their nature and importance requires familiarity with the vendor’s terminology. For example, the Neon feature from the <a id="_idIndexMarker242"/>Raspberry<a id="_idIndexMarker243"/> Pi output is a <a id="_idIndexMarker244"/>set of <strong class="bold">Single Instruction, Multiple Data</strong> (<strong class="bold">SIMD</strong>) instructions for ARM CPUs, comparable with Intel’s SSE, which is often used in multimedia and scientific applications. When in doubt, consult the CPU <span class="No-Break">vendor docum<a id="_idTextAnchor089"/>entation.</span></p>
<h2 id="_idParaDest-71"><a id="_idTextAnchor090"/>Multi-processor systems</h2>
<p>Most CPUs on the <a id="_idIndexMarker245"/>market today include multiple CPU cores, and<a id="_idIndexMarker246"/> server mainboards often have multiple sockets. The <strong class="source-inline">cpuinfo</strong> file includes all information necessary to figure out the CPU socket and core layout, but there <span class="No-Break">are caveats.</span></p>
<p>The field you should look at to determine the number of CPU sockets is <strong class="source-inline">physical id</strong>. Note that <strong class="source-inline">physical id</strong> values aren’t always consecutive, so you can’t just look at the maximum value and should consider all the values present. You can find unique IDs by piping the <strong class="source-inline">cpuinfo</strong> file through the <strong class="source-inline">sort</strong> and <span class="No-Break"><strong class="source-inline">uniq</strong></span><span class="No-Break"> commands:</span></p>
<pre class="source-code">
$ cat /proc/cpuinfo | grep "physical id" | sort | uniq
physical id    : 0
physical id    : 2</pre>
<p>In virtual machines running on x86 hardware, all CPUs that the hypervisor presents to them will show up as if they were in different physical sockets. For example, if you have a hypervisor host with a single quad-core CPU and create a virtual machine with two virtual CPUs, it will look like two single-core CPUs in <span class="No-Break">different sockets.</span></p>
<p>On many non-x86 architectures, such as ARM, all CPUs will look as if they are different physical CPUs, whether they are different chips or cores on the <span class="No-Break">same chips.</span></p>
<p>On bare-metal x86 machines, you<a id="_idIndexMarker247"/> can find two <strong class="source-inline">cpuinfo</strong> entries with different physical IDs and examine them further to find out the number of cores in <span class="No-Break">each socket.</span></p>
<p>Consider this <strong class="source-inline">cpuinfo</strong> entry from a Linux system running on <span class="No-Break">a laptop:</span></p>
<pre class="source-code">
processor         : 7
vendor_id         : GenuineIntel
cpu family        : 6
model             : 140
model name        : 11th Gen Intel(R) Core(TM) i5-1135G7 @ 2.40GHz
stepping          : 1
microcode         : 0xa4
cpu MHz           : 1029.707
cache size        : 8192 KB
physical id       : 0
siblings          : 8
core id           : 3
cpu cores         : 4
apicid            : 7
initial apicid    : 7
fpu               : yes
fpu_exception     : yes
cpuid level       : 27
wp                : yes
flags             : fpu vme de pse tsc msr pae mce cx8 apic sep mtrr pge mca cmov pat pse36 clflush dts acpi mmx fxsr sse sse2 ss ht tm pbe syscall nx pdpe1gb rdtscp lm constant_tsc art arch_perfmon pebs bts rep_good nopl xtopology nonstop_tsc cpuid aperfmperf tsc_known_freq pni pclmulqdq dtes64 monitor ds_cpl vmx est tm2 ssse3 sdbg fma cx16 xtpr pdcm pcid sse4_1 sse4_2 x2apic movbe popcnt tsc_deadline_timer aes xsave avx f16c rdrand lahf_lm abm 3dnowprefetch cpuid_fault epb cat_l2 invpcid_single cdp_l2 ssbd ibrs ibpb stibp ibrs_enhanced tpr_shadow vnmi flexpriority ept vpid ept_ad fsgsbase tsc_adjust bmi1 avx2 smep bmi2 erms invpcid rdt_a avx512f avx512dq rdseed adx smap avx512ifma clflushopt clwb intel_pt avx512cd sha_ni avx512bw avx512vl xsaveopt xsavec xgetbv1 xsaves split_lock_detect dtherm ida arat pln pts hwp hwp_notify hwp_act_window hwp_epp hwp_pkg_req avx512vbmi umip pku ospke avx512_vbmi2 gfni vaes vpclmulqdq avx512_vnni avx512_bitalg avx512_vpopcntdq rdpid movdiri movdir64b fsrm avx512_vp2intersect md_clear ibt flush_l1d arch_capabilities
vmx flags    : vnmi preemption_timer posted_intr invvpid ept_x_only ept_ad ept_1gb flexpriority apicv tsc_offset vtpr mtf vapic ept vpid unrestricted_guest vapic_reg vid ple pml ept_mode_based_exec tsc_scaling
bugs              : spectre_v1 spectre_v2 spec_store_bypass swapgs eibrs_pbrsb
bogomips          : 4838.40
clflush size      : 64
cache_alignment   : 64
address sizes     : 39 bits physical, 48 bits virtual
power management  :</pre>
<p>From the <strong class="source-inline">cpu cores</strong> field, you<a id="_idIndexMarker248"/> can see that it’s a <span class="No-Break">quad-core CPU.</span></p>
<p>Now, note that the entry has <strong class="source-inline">processor: 7</strong> in it, and the <strong class="source-inline">siblings</strong> field is set to <strong class="source-inline">8</strong>. It appears that the system has eight CPUs, even though it clearly has a single physical CPU chip (all entries have <strong class="source-inline">physical id: 0</strong>), and the reported number of cores in each entry <span class="No-Break">is </span><span class="No-Break"><strong class="source-inline">4</strong></span><span class="No-Break">.</span></p>
<p>This is caused by <em class="italic">simultaneous multithreading</em> technologies such as AMD SMT and Intel Hyper-Threading. Those technologies allow a single CPU core to maintain the state of more than one execution thread, which can speed up certain applications. If every core supports two threads at once, to the operating system it looks as if the machine has twice as many CPU cores than it really does. For this reason, you can’t determine the number of physical cores just by looking at the highest <strong class="source-inline">/proc/cpuinfo</strong> entry number, so you need to examine it <span class="No-Break">more closely.</span></p>
<p>There is a utility named <strong class="source-inline">nproc</strong> in the GNU <strong class="source-inline">coreutils</strong> package whose purpose is to output the number of CPU cores in the system, and it can simplify your job if you need the number of CPUs – for example, to determine how many worker processes or threads of an application to spawn. However, it does not take simultaneous multithreading into account and prints the number of virtual cores if an SMT technology is enabled. If your application requires the number of physical cores, you should not rely on the output of <strong class="source-inline">nproc</strong> for that purpose. This is what the output of <strong class="source-inline">nproc</strong> would<a id="_idIndexMarker249"/> look <a id="_idIndexMarker250"/>like on <span class="No-Break">that mac<a id="_idTextAnchor091"/>hine:</span></p>
<pre class="source-code">
$ nproc
8</pre>
<h2 id="_idParaDest-72"><a id="_idTextAnchor092"/>High-level CPU discovery utilities</h2>
<p>As you can see, reading<a id="_idIndexMarker251"/> the <strong class="source-inline">/proc/cpuinfo</strong> file can be a tedious and tricky task. For this reason, people created utilities that aim to simplify it. The most popular tool in this category is <strong class="source-inline">lscpu</strong> from the <span class="No-Break"><strong class="source-inline">util-linux</strong></span><span class="No-Break"> package.</span></p>
<p>If offers an <span class="No-Break">easier-to-read output:</span></p>
<pre class="source-code">
$ lscpu
Architecture         : x86_64
CPU op-mode(s)       : 32-bit, 64-bit
Byte Order           : Little Endian
Address sizes        : 42 bits physical, 48 bits virtual
CPU(s)               : 2
On-line CPU(s) list  : 0,1
Thread(s) per core   : 1
Core(s) per socket   : 1
Socket(s)            : 2
NUMA node(s)         : 1
Vendor ID            : GenuineIntel
CPU family           : 6
Model                : 44
Model name           : Intel(R) Xeon(R) CPU            L5630  @ 2.13GHz
Stepping             : 2
CPU MHz              : 2128.000
BogoMIPS             : 4256.00
Hypervisor vendor    : VMware
Virtualization type  : full
L1d cache            : 32K
L1i cache            : 32K
L2 cache             : 256K
L3 cache             : 12288K
NUMA node0 CPU(s)    : 0,1
Flags                : fpu vme de pse tsc msr pae mce cx8 apic sep mtrr pge mca cmov pat pse36 clflush dts mmx fxsr sse sse2 syscall nx rdtscp lm constant_tsc arch_perfmon pebs bts nopl xtopology tsc_reliable nonstop_tsc cpuid aperfmperf pni pclmulqdq ssse3 cx16 sse4_1 sse4_2 x2apic popcnt tsc_deadline_timer aes hypervisor lahf_lm pti tsc_adjust dtherm ida arat</pre>
<p>Another advantage is<a id="_idIndexMarker252"/> that you can get a machine-readable JSON output by running <strong class="source-inline">lscpu --json</strong> and analyzing it <span class="No-Break">with scripts.</span></p>
<p>Note, however, that <strong class="source-inline">lscpu</strong> doesn’t take the simultaneous multithreading issue into account (at least as of version 2.38) and will report twice as many CPUs if AMD SMT or Intel Hyper-Threading <span class="No-Break">is enabled.</span></p>
<p>As you can see, there is a lot of information about the CPUs that you can get either directly from the <strong class="source-inline">/proc</strong> filesystem or by using high-level utilities to simplify the process. However, you should always remember the nuances of interpretation, such as the issue of core numbers being inflated by simultaneous<a id="_idIndexMarker253"/> <span class="No-Break">multithreading technologies.</span></p>
<h1 id="_idParaDest-73"><a id="_idTextAnchor093"/>Memory discovery</h1>
<p>Discovering the <a id="_idIndexMarker254"/>amount of memory is often even more practically important than discovering CPU features. It is required to plan application deployment, choose the size of a swap partition, and estimate whether you need to install more <span class="No-Break">memory already.</span></p>
<p>However, the kernel interfaces for memory discovery are not as rich as those for discovering CPU features. For example, it is impossible to find out how many memory slots a system has, how many of them are used, and what the sizes of memory sticks installed in those slots using the kernel interface are alone. At least on some architectures, it is possible to obtain that information, but from the firmware rather than from the kernel, as we will see later in the <span class="No-Break"><em class="italic">dmidecode</em></span><span class="No-Break"> section.</span></p>
<p>Moreover, information from the kernel can be misleading for beginners who are unfamiliar with Linux kernel conventions. First, let us look at that information and then discuss how to <span class="No-Break">interpret it.</span></p>
<p>First, we will look at the output of the <strong class="source-inline">free</strong> utility that comes from the <strong class="source-inline">procps-ng</strong> package. That utility has the <strong class="source-inline">-m</strong> option to show memory amounts in megabytes rather than in kibibytes, which is much easier <span class="No-Break">to read.</span></p>
<div>
<div class="IMG---Figure" id="_idContainer029">
<img alt="Figure 5.1 – the free –m output" height="67" src="image/B18575_05_01.jpg" width="750"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 5.1 – the free –m output</p>
<p>On the surface, its output seems self-descriptive. The total amount of memory here is about 16 gigabytes. Of that amount, <strong class="source-inline">13849</strong> megabytes are used. However, the question of how the kernel uses memory is not trivial. Not all memory that is declared as used is used by user applications – the kernel also uses memory to cache data from disk to speed up input-output operations. The more memory the system has that is not currently used by any processes, the more memory will be used by Linux for caching. Whenever there is not enough completely unused memory to allocate to a process that requests it, the kernel will evict some cached data to free up space. For this reason, the amount of memory in the <strong class="source-inline">used</strong> column can be very high, even on a system that runs very few applications, which may create an impression that the system is running out of memory when, in fact, there is lots of memory available to applications. The amount of memory used for disk caching is in the <strong class="source-inline">buff/cache</strong> column, and the amount of memory available to applications is in the <span class="No-Break"><strong class="source-inline">available</strong></span><span class="No-Break"> column.</span></p>
<p>Raw information <a id="_idIndexMarker255"/>about memory consumption is found in the <strong class="source-inline">/proc/meminfo</strong> file. The output of the <strong class="source-inline">free</strong> utility is a summary of informat<a id="_idTextAnchor094"/>ion from <span class="No-Break">that file.</span></p>
<h1 id="_idParaDest-74"><a id="_idTextAnchor095"/>Discovering PCI devices</h1>
<p>Many peripherals <a id="_idIndexMarker256"/>are attached to a PCI bus. These days, this usually <a id="_idIndexMarker257"/>means <strong class="bold">PCI Express</strong> (<strong class="bold">PCI-e</strong>) rather than older PCI or PCI-x buses, but from a software point of view, they are all PCI devices, whichever variant of that bus they are <span class="No-Break">attached to.</span></p>
<p>The kernel exposes information about them in the <strong class="source-inline">/sys/class/pci_bus</strong> hierarchy, but reading those files by hand would be a very time-consuming task, unlike in <strong class="source-inline">/proc/cpuinfo</strong>, so in practice, people always use utilities for it. The most popular one is <strong class="source-inline">lspci</strong> from the <span class="No-Break"><strong class="source-inline">pciutils</strong></span><span class="No-Break"> package.</span></p>
<p>Here is a <span class="No-Break">sample output:</span></p>
<pre class="source-code">
$ sudo lspci
00:00.0 Host bridge: Intel Corporation 11th Gen Core Processor Host Bridge/DRAM Registers (rev 01)
00:02.0 VGA compatible controller: Intel Corporation TigerLake-LP GT2 [Iris Xe Graphics] (rev 01)
00:04.0 Signal processing controller: Intel Corporation TigerLake-LP Dynamic Tuning Processor Participant (rev 01)
00:06.0 PCI bridge: Intel Corporation 11th Gen Core Processor PCIe Controller (rev 01)
00:0a.0 Signal processing controller: Intel Corporation Tigerlake Telemetry Aggregator Driver (rev 01)
00:14.0 USB controller: Intel Corporation Tiger Lake-LP USB 3.2 Gen 2x1 xHCI Host Controller (rev 20)
00:14.2 RAM memory: Intel Corporation Tiger Lake-LP Shared SRAM (rev 20)
00:14.3 Network controller: Intel Corporation Wi-Fi 6 AX201 (rev 20)
00:15.0 Serial bus controller: Intel Corporation Tiger Lake-LP Serial IO I2C Controller #0 (rev 20)
00:15.1 Serial bus controller: Intel Corporation Tiger Lake-LP Serial IO I2C Controller #1 (rev 20)
00:16.0 Communication controller: Intel Corporation Tiger Lake-LP Management Engine Interface (rev 20)
00:17.0 SATA controller: Intel Corporation Tiger Lake-LP SATA Controller (rev 20)
00:1c.0 PCI bridge: Intel Corporation Device a0bc (rev 20)
00:1d.0 PCI bridge: Intel Corporation Tiger Lake-LP PCI Express Root Port #9 (rev 20)
00:1f.0 ISA bridge: Intel Corporation Tiger Lake-LP LPC Controller (rev 20)
00:1f.4 SMBus: Intel Corporation Tiger Lake-LP SMBus Controller (rev 20)
00:1f.5 Serial bus controller: Intel Corporation Tiger Lake-LP SPI Controller (rev 20)
01:00.0 3D controller: NVIDIA Corporation GP108M [GeForce MX330] (rev a1)
02:00.0 Non-Volatile memory controller: Samsung Electronics Co Ltd NVMe SSD Controller 980
03:00.0 Ethernet controller: Realtek Semiconductor Co., Ltd. RTL8111/8168/8411 PCI Express Gigabit Ethernet Controller (rev 15)</pre>
<p>Full access to the PCI bus information is only available to the <strong class="source-inline">root</strong> user, so you should run <strong class="source-inline">lspci</strong> with <strong class="source-inline">sudo</strong>. PCI device classes are standardized, so that utility will not only tell you about device vendors and models but also their functions, such as an Ethernet controller or a <span class="No-Break">SATA controller.</span></p>
<p>Some of those names <a id="_idIndexMarker258"/>may be slightly misleading – for example, a VGA-compatible controller may not have an actual VGA port; these days, it’s almost invariably DVI, HDMI, <span class="No-Break">or Th<a id="_idTextAnchor096"/>underbolt/DisplayPort.</span></p>
<h1 id="_idParaDest-75"><a id="_idTextAnchor097"/>Discovering USB devices</h1>
<p>To discover USB <a id="_idIndexMarker259"/>devices, there’s the <strong class="source-inline">lsusb</strong> utility from the <strong class="source-inline">usbutils</strong> package. That command does not require <strong class="source-inline">root</strong> privileges. Here’s what its output may <span class="No-Break">look like:</span></p>
<pre class="source-code">
$ lsusb
Bus 002 Device 001: ID 1d6b:0003 Linux Foundation 3.0 root hub
Bus 001 Device 005: ID 1bcf:2b98 Sunplus Innovation Technology Inc. Integrated_Webcam_HD
Bus 001 Device 036: ID 0b0e:0300 GN Netcom Jabra EVOLVE 20 MS
Bus 001 Device 035: ID 05ac:12a8 Apple, Inc. iPhone 5/5C/5S/6/SE
Bus 001 Device 006: ID 8087:0aaa Intel Corp. Bluetooth 9460/9560 Jefferson Peak (JfP)
Bus 001 Device 002: ID 047d:1020 Kensington Expert Mouse Trackball
Bus 001 Device 001: ID 1d6b:0002 Linux Foundation 2.0 root hub</pre>
<p>Even though the USB bus specification also includes standardized device classes, <strong class="source-inline">lsusb</strong> does not show them by default. One reason for that behavior is that a single USB device may implement multiple functions. A smartphone, for example, can present itself as a mass storage device (similar to a USB stick) for generic <a id="_idIndexMarker260"/>file transfer and as a digital camera to retrieve pictures from it using <strong class="bold">Picture Transfer </strong><span class="No-Break"><strong class="bold">Protocol</strong></span><span class="No-Break"> (</span><span class="No-Break"><strong class="bold">PTP</strong></span><span class="No-Break">).</span></p>
<p>You can get detailed information about a device by running <strong class="source-inline">lsusb</strong> with additional options. In the previous example, running <strong class="source-inline">lsusb -s 2 -v</strong> would show you information about device <strong class="source-inline">002</strong> – a <span class="No-Break">Kensington trackball.</span></p>
<p>Note that if a device is shown in the output of <strong class="source-inline">lsusb</strong>, it doesn’t always mean that it’s attached to a USB port. Onboard devices may also be connected to the USB bus. In the previous example, the Bluetooth controller is an intern<a id="_idTextAnchor098"/>al device in <span class="No-Break">the laptop.</span></p>
<h1 id="_idParaDest-76"><a id="_idTextAnchor099"/>Discovering storage devices</h1>
<p>Storage devices can<a id="_idIndexMarker261"/> be attached to different buses, so discovering them may be complicated. One useful command to discover everything that looks like a storage device is <strong class="source-inline">lsblk</strong> from the <strong class="source-inline">util-linux</strong> package (its name stands for list <span class="No-Break">block devices):</span></p>
<pre class="source-code">
$ lsblk
NAME   MAJ:MIN RM  SIZE RO TYPE MOUNTPOINTS
zram0  251:0     0  959M  0 disk [SWAP]
vda    252:0     0   25G  0 disk
├─vda1 252:1     0    1M  0 part
├─vda2 252:2     0  500M  0 part /boot
├─vda3 252:3     0  100M  0 part /boot/efi
├─vda4 252:4     0    4M  0 part
└─vda5 252:5     0 24.4G  0 part /home
                                 /</pre>
<p>One caveat is that it will show virtual devices as well as physical ones. For example, if you mount an ISO image using a virtual loop device, it will show up as a storage device – because from the user’s point of view, it<a id="_idIndexMarker262"/> is indeed a <span class="No-Break">storage device:</span></p>
<pre class="source-code">
$ sudo mount -t iso9660 -o ro,loop /tmp/some_image.iso /mnt/iso/
$ lsblk
NAME                                           MAJ:MIN RM   SIZE RO TYPE  MOUNTPOINTS
loop0                                            7:0     0   1.7G  1 loop  /mnt/tmp
├─loop0p1                                      259:4     0     30K  1 part
└─loop0p2                                      259:5     0   4.3M  1 part</pre>
<p>If you try to discover physical devices, you may want to try the <strong class="source-inline">lsscsi</strong> command from the package that is also usually <span class="No-Break">called </span><span class="No-Break"><strong class="source-inline">lsscsi</strong></span><span class="No-Break">:</span></p>
<pre class="source-code">
$ lsscsi
[N:0:5:1]     disk     PM991a NVMe Samsung 512GB__1           /dev/nvme0n1</pre>
<p>A confusing part is that the <em class="italic">protocol</em> of the original parallel SCSI bus found many new applications and remains widely used, even though its original hardware implementation was replaced by newer buses. There are many devices that will show up in the output of that utility, including SATA, <strong class="bold">Serial-Attached SCSI</strong> (<strong class="bold">SAS</strong>), and NVMe <a id="_idIndexMarker263"/>drives, as well as USB mass <span class="No-Break">storage devices.</span></p>
<p>Conversely, paravirtual devices such as VirtIO drives in KVM and Xen virtual machines will not be included in the <strong class="source-inline">lsscsi</strong> output. All in all, you may need to rely on a combination of <strong class="source-inline">lsusb</strong>, <strong class="source-inline">lsscsi</strong>, and <strong class="source-inline">lsblk</strong> to get the full picture. A good thing is that none of those commands require <strong class="source-inline">root</strong> privileges. Another<a id="_idIndexMarker264"/> good thing about <strong class="source-inline">lsblk</strong> specifically is that you can run <strong class="source-inline">lsblk --json</strong> to get machine-readable out<a id="_idTextAnchor100"/>put and load it in <span class="No-Break">a script.</span></p>
<h1 id="_idParaDest-77"><a id="_idTextAnchor101"/>High-level discovery tools</h1>
<p>As well as these tools, which are specific to a certain bus or device type, there are also tools that can help you discover all h<a id="_idTextAnchor102"/>ardware present in <span class="No-Break">a system.</span></p>
<h2 id="_idParaDest-78"><a id="_idTextAnchor103"/>dmidecode</h2>
<p>On x86 systems, you<a id="_idIndexMarker265"/> can use a program named <strong class="source-inline">dmidecode</strong> to retrieve and view information from the firmware (BIOS/UEFI) via the Desktop Management Interface (hence its name). That interface is also known as SMBIOS. Since it’s specific to the x86 PC firmware standards, it will not work on machines with other architectures such as ARM or MIPS, but on x86 laptops, workstations, and servers, it can help you discover information that cannot be obtained in any other way, such as the number of <span class="No-Break">RAM slots.</span></p>
<p>One disadvantage is that you need <strong class="source-inline">root</strong> privileges to run it. Another thing to take note of is that it produces a lot of output. There is no way to reproduce a complete output in the book because it would take many pages, but for reference, here’s what the beginning of its output may look like (in this case, in a VMware <span class="No-Break">virtual machine):</span></p>
<pre class="source-code">
$ sudo dmidecode
# dmidecode 3.2
Getting SMBIOS data from sysfs.
SMBIOS 2.4 present.
556 structures occupying 27938 bytes.
Table at 0x000E0010.
Handle 0x0000, DMI type 0, 24 bytes
BIOS Information
    Vendor: Phoenix Technologies LTD
    Version: 6.00
    Release Date: 09/21/2015
    Address: 0xE99E0
    Runtime Size: 91680 bytes
    ROM Size: 64 kB
    Characteristics:
         ISA is supported
         PCI is supported
         PC Card (PCMCIA) is supported
         PNP is supported
         APM is supported
         BIOS is upgradeable
         BIOS shadowing is allowed
         ESCD support is available
         Boot from CD is supported
         Selectable boot is supported
         EDD is supported
         Print screen service is supported (int 5h)
         8042 keyboard services are supported (int 9h)
         Serial services are supported (int 14h)
         Printer services are supported (int 17h)
         CGA/mono video services are supported (int 10h)
         ACPI is supported
         Smart battery is supported
         BIOS boot specification is supported
         Function key-initiated network boot is supported
         Targeted content distribution is supported
    BIOS Revision: 4.6
    Firmware Revision: 0.0
Handle 0x0001, DMI type 1, 27 bytes
System Information
    Manufacturer: VMware, Inc.
    Product Name: VMware Virtual Platform
    Version: None
    Serial Number: VMware-56 4d 47 fd 6f 6f 20 30-f8 85 d6 08 bf 09 fe b5
    UUID: 564d47fd-6f6f-2030-f885-d608bf09feb5
    Wake-up Type: Power Switch
    SKU Number: Not Specified
    Family: Not Specified
Handle 0x0002, DMI type 2, 15 bytes
Base Board Information
    Manufacturer: Intel Corporation
    Product Name: 440BX Desktop Reference Platform
    Version: None
    Serial Number: None
    Asset Tag: Not Specified
    Features: None
    Location In Chassis: Not Specified
    Chassis Handle: 0x0000
    Type: Unknown
    Contained Object Handles: 0</pre>
<p>As you can see in this output, there<a id="_idIndexMarker266"/> are exact model names for the chassis and the mainboard. Unlike, for example, a USB, where the protocol itself includes features that allow devices themselves to report their names and capabilities to the host, there is no cross-platform way to query the<a id="_idIndexMarker267"/> mainboard name, but at least on most x86 machines, that information is avail<a id="_idTextAnchor104"/>able through the <span class="No-Break">DMI interface.</span></p>
<h2 id="_idParaDest-79"><a id="_idTextAnchor105"/>lshw</h2>
<p>Another tool that provides <a id="_idIndexMarker268"/>comprehensive hardware reporting is <strong class="source-inline">lshw</strong> (LiSt HardWare). Like <strong class="source-inline">dmidecode</strong>, it can use the DMI interface as its information source, but it tries to support more hardware platforms and their platform-specific hardware <span class="No-Break">discovery interfaces.</span></p>
<p>One disadvantage is that none of the popular distributions install it by default, so you’ll always need to install it from the repositories by hand. It also requires <strong class="source-inline">root</strong> privileges to run, since it relies on the privileged <span class="No-Break">access DMI.</span></p>
<p>Here is a sample output from a virtual machine running in KVM on the DigitalOcean cloud platform. Its output is also very large, so we only include <span class="No-Break">its beginning:</span></p>
<pre class="source-code">
$ sudo lshw
my-host
     description: Computer
     product: Droplet
     vendor: DigitalOcean
     version: 20171212
     serial: 293265963
     width: 64 bits
     capabilities: smbios-2.4 dmi-2.4 vsyscall32
     configuration: boot=normal family=DigitalOcean_Droplet uuid=AE220510-4AD6-4B66-B49F-9D103C60BA5A
  *-core
        description: Motherboard
        physical id: 0
      *-firmware
           description: BIOS
           vendor: DigitalOcean
           physical id: 0
           version: 20171212
           date: 12/12/2017
           size: 96KiB
      *-cpu
           description: CPU
           product: DO-Regular
           vendor: Intel Corp.
           physical id: 401
           bus info: cpu@0
           slot: CPU 1
           size: 2GHz
           capacity: 2GHz
           width: 64 bits
           capabilities: fpu fpu_exception wp vme de pse tsc msr pae mce cx8 apic sep mtrr pge mca cmov pat pse36 clflush mmx fxsr sse sse2 ss syscall nx rdtscp x86-64 constant_tsc arch_perfmon rep_good nopl cpuid tsc_known_freq pni pclmulqdq vmx ssse3 fma cx16 pcid sse4_1 sse4_2 x2apic movbe popcnt tsc_deadline_timer aes xsave avx f16c rdrand hypervisor lahf_lm abm cpuid_fault invpcid_single pti ssbd ibrs ibpb tpr_shadow vnmi flexpriority ept vpid ept_ad fsgsbase tsc_adjust bmi1 avx2 smep bmi2 erms invpcid xsaveopt md_clear
      *-memory
           description: System Memory
           physical id: 1000
           size: 1GiB
           capacity: 1GiB
           capabilities: ecc
           configuration: errordetection=multi-bit-ecc
         *-bank
              description: DIMM RAM
              physical id: 0
              slot: DIMM 0
              size: 1GiB
              width: 64 bits
      *-pci
           description: Host bridge
           product: 440FX - 82441FX PMC [Natoma]
           vendor: Intel Corporation
           physical id: 100
           bus info: pci@0000:00:00.0
           version: 02
           width: 32 bits
           clock: 33MHz
         *-isa
              description: ISA bridge
              product: 82371SB PIIX3 ISA [Natoma/Triton II]
              vendor: Intel Corporation
              physical id: 1
              bus info: pci@0000:00:01.0
              version: 00
              width: 32 bits
              clock: 33MHz
              capabilities: isa
              configuration: latency=0
         *-ide
              description: IDE interface
              product: 82371SB PIIX3 IDE [Natoma/Triton II]
              vendor: Intel Corporation
              physical id: 1.1
              bus info: pci@0000:00:01.1
              version: 00
              width: 32 bits
              clock: 33MHz
              capabilities: ide isa_compat_mode bus_master
              configuration: driver=ata_piix latency=0
              resources: irq:0 ioport:1f0(size=8) ioport:3f6 ioport:170(size=8) ioport:376 ioport:c160(size=16)
         *-usb
              description: USB controller
              product: 82371SB PIIX3 USB [Natoma/Triton II]
              vendor: Intel Corporation
              physical id: 1.2
              bus info: pci@0000:00:01.2
              version: 01
              width: 32 bits
              clock: 33MHz
              capabilities: uhci bus_master
              configuration: driver=uhci_hcd latency=0
              resources: irq:11 ioport:c0c0(size=32)
            *-usbhost
                 product: UHCI Host Controller
                 vendor: Linux 5.16.18-200.fc35.x86_64 uhci_hcd
                 physical id: 1
                 bus info: usb@1
                 logical name: usb1
                 version: 5.16
                 capabilities: usb-1.10
                 configuration: driver=hub slots=2 speed=12Mbit/s</pre>
<p>As you can see, the output<a id="_idIndexMarker269"/> includes information that can only be retrieved from DMI (such as the mainboard model), together with information that we have seen in the outputs of <strong class="source-inline">lsusb</strong> and other utilities. In this sense, <strong class="source-inline">lshw</strong> can replace them if you want a detailed and complete ov<a id="_idTextAnchor106"/>erview <a id="_idIndexMarker270"/>of all <span class="No-Break">installed hardware.</span></p>
<h1 id="_idParaDest-80"><a id="_idTextAnchor107"/>Summary</h1>
<p>In this chapter, we learned that the Linux kernel can gather a lot of information about the system hardware and provide it to the user. In an emergency situation, it’s possible to retrieve all that information directly from the kernel, using the <strong class="source-inline">/proc</strong> and <strong class="source-inline">/sys</strong> filesystems and reading files such <span class="No-Break">as </span><span class="No-Break"><strong class="source-inline">/proc/cpuinfo</strong></span><span class="No-Break">.</span></p>
<p>However, high-level utilities such as <strong class="source-inline">lscpu</strong>, <strong class="source-inline">lsscsi</strong>, and <strong class="source-inline">lsusb</strong> can make it much easier to retrieve information and <span class="No-Break">analyze it.</span></p>
<p>There are also platform-specific utilities, such as <strong class="source-inline">dmidecode</strong> for x86 PCs, that can help you retrieve even more detailed information that cannot be retrieved otherwise, such as the number of <span class="No-Break">memory slots.</span></p>
<p>In the next chapter, we will learn about configuring basic <span class="No-Break">system settings.</span></p>
</div>
</div>

<div id="sbo-rt-content"><div class="Content" id="_idContainer031">
<h1 id="_idParaDest-81" lang="en-US" xml:lang="en-US"><a id="_idTextAnchor108"/>Part 2: Configuring and Modifying Linux Systems</h1>
<p>The second part of the book is dedicated to managing individual Linux systems. Once you are comfortable interacting with the system, the next step is to learn how to configure it. In this part, you will learn how to configure basic settings such as the system hostname, how to create and manage users and groups, how to install additional software from package files or remote repositories, and how to set up and debug network connections and <span class="No-Break">storage devices.</span></p>
<p>This part has the <span class="No-Break">following chapters:</span></p>
<ul>
<li><a href="B18575_06.xhtml#_idTextAnchor109"><em class="italic">Chapter 6</em></a>, <em class="italic">Basic System Settings</em></li>
<li><a href="B18575_07.xhtml#_idTextAnchor118"><em class="italic">Chapter 7</em></a>, <em class="italic">User and Group Management</em></li>
<li><a href="B18575_08.xhtml#_idTextAnchor134"><em class="italic">Chapter 8</em></a>, <em class="italic">Software Installation and Package Repositories</em></li>
<li><a href="B18575_09.xhtml#_idTextAnchor152"><em class="italic">Chapter 9</em></a>, <em class="italic">Network Configuration and Troubleshooting</em></li>
<li><a href="B18575_10.xhtml#_idTextAnchor175"><em class="italic">Chapter 10</em></a>,<em class="italic"> Storage Management</em></li>
</ul>
</div>
<div>
<div id="_idContainer032">
</div>
</div>
</div></body></html>