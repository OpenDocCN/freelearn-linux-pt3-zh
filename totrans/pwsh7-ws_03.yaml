- en: '3'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The PowerShell Pipeline – How to String Cmdlets Together
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Almost all **operating systems** (**OSs**) have the concept of a **pipeline**,
    allowing the output of one process to be fed into the input of the next. This
    concept is credited to Douglas McIlroy in 1973 when he was working on version
    3 of Unix at Bell Labs. This initial implementation envisaged the output of every
    command as a file-like structure, on which the next command could operate.
  prefs: []
  type: TYPE_NORMAL
- en: This chapter will explain how PowerShell adheres to this vision and differs
    from it. We’ll start by exploring the pipeline concept, then look at some basic
    ways of manipulating the contents of the pipeline before taking a medium-depth
    dive into how the pipeline works in PowerShell, and how we can troubleshoot it
    when it doesn’t.
  prefs: []
  type: TYPE_NORMAL
- en: By the end of this chapter, we’ll understand how information passes from one
    cmdlet to the next, how to manipulate that information so that we only work with
    the stuff we need, and how to work out what’s going wrong when we get an error
    message.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we’re going to cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: How to bring cmdlets together – the pipeline
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Selecting and sorting objects
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Filtering objects
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Enumerating objects
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Formatting objects
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How the pipeline works – parameter binding
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Troubleshooting the pipeline – pipeline tracing
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to bring cmdlets together – the pipeline
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Since Unix and the C programming language in the 1970s, operating systems have
    abstracted computer input and output into `Read-Host` cmdlet. The stdout stream
    is the successful output of the cmdlet. The stderr stream contains any error messages
    produced by the program and is sent to a separate stream so as not to interfere
    with any successful output.
  prefs: []
  type: TYPE_NORMAL
- en: 'PowerShell expands on these streams a bit and has six output streams instead
    of two. Each of these streams can be captured either with an explicit PowerShell
    cmdlet or by specifying one of the common parameters when running a cmdlet, as
    shown in the following table:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Stream #** | **Description** | **Cmdlet** | **Common Parameters** |'
  prefs: []
  type: TYPE_TB
- en: '| 1 | Success | `Write-Output` | None – this is the default output |'
  prefs: []
  type: TYPE_TB
- en: '| 2 | Error | `Write-Error` | `-ErrorAction` and `-ErrorVariable` |'
  prefs: []
  type: TYPE_TB
- en: '| 3 | Warning | `Write-Warning` | `-WarningAction` and `-WarningVariable` |'
  prefs: []
  type: TYPE_TB
- en: '| 4 | Verbose | `Write-Verbose` | `-``Verbose` |'
  prefs: []
  type: TYPE_TB
- en: '| 5 | Debug | `Write-Debug` | `-``Debug` |'
  prefs: []
  type: TYPE_TB
- en: '| 6 | Information | `Write-Information` | `-``InformationAction` and`-``InformationVariable`
    |'
  prefs: []
  type: TYPE_TB
- en: Table 3.1 – PowerShell streams
  prefs: []
  type: TYPE_NORMAL
- en: Stream 1 is the equivalent of stdout, while stream 2 is the equivalent of stderr.
    The PowerShell pipeline passes the contents of stream 1, success, from one cmdlet
    to the next in the pipeline. When we see red error messages on the screen, they
    are not output in stream 1 – they are output in stream 2\. This is because we
    don’t want error messages (or verbose messages or anything other than an output
    object) being passed into the next cmdlet and causing another error. After all,
    the second cmdlet has no way of interpreting that information.
  prefs: []
  type: TYPE_NORMAL
- en: 'The pipeline may consist of one or more PowerShell cmdlets, separated by a
    pipe character (`|`). Every PowerShell cmdlet is part of a pipeline, even if it’s
    just one cmdlet. There is an implicit pair of cmdlets, `Out-Default | Out-Host`,
    at the end of every pipeline so that the output in stream 1 of the cmdlet gets
    formatted and written to the screen. Some cmdlets have no stream 1 output, so
    we see nothing on the screen after running them. For example, in [*Chapter 2*](B17600_02.xhtml#_idTextAnchor034),
    *Exploring PowerShell Cmdlets and Syntax*, we ran the following cmdlet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Once the cmdlet finished running, we were returned to the prompt. If we look
    at the help file for `Set-Alias`, we will see that it has no output by default,
    so we see nothing on the screen when it runs successfully. `Set-Alias` is still
    a pipeline, though; `Out-Default` still runs, it just receives no output.
  prefs: []
  type: TYPE_NORMAL
- en: 'Cmdlets execute from left to right, with the output object of the cmdlet on
    the left being passed to the next cmdlet in the pipeline on the right. For ease
    of reading (and typing), the pipe symbol can be used as a line break when working
    interactively. Try pressing *return* or *Enter* after the pipe symbol:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'You should see a continuation prompt (`>>`) after pressing *return*/*Enter*
    after the pipe symbol, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.1 – Using the pipe symbol as a line break](img/B17600_03_001.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.1 – Using the pipe symbol as a line break
  prefs: []
  type: TYPE_NORMAL
- en: We keep referring to objects – it would be useful to describe exactly what we
    mean. This is what we’ll do in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: What is an object?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When we run commands in Linux and the Windows console, the commands output a
    byte stream to stdout; this is interpreted as a text file, held in memory. When
    we want to manipulate the contents of this output, we must use the same tools
    that we would use to search and manipulate text; this may be Perl, sed, AWK, or
    a host of others.
  prefs: []
  type: TYPE_NORMAL
- en: 'This means that we become adept at text manipulation; I’ve got about seven
    volumes of Perl books on my desk, dating back to the mid-nineties. PowerShell
    cmdlets don’t produce a text-like byte stream; instead, they produce objects and
    collections of objects, which are table structures held in memory, that are produced
    when we run `Get-Process`, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.2 – The Get-Process collection of objects](img/B17600_03_002.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.2 – The Get-Process collection of objects
  prefs: []
  type: TYPE_NORMAL
- en: 'Each line in the table is an object. Each column is a property of the objects
    in the table. The whole table is a collection of objects. From *Figure 3**.1*,
    we know that each object is of the `System.Diagnostics.Process` type and has the
    list of properties and methods associated with that object type. With the pipeline,
    we can send this collection to another cmdlet to extract further information,
    or just call the specific property we are interested in. If we want to know the
    value of a property that isn’t displayed by default, such as how much privileged
    processor time had been consumed in the lifetime of a particular process, we could
    type the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Where did that `4514` come from? It’s the `Id` property of one of the `pwsh`
    processes in *Figure 3**.2*. From this, I can see that my `pwsh` process has 11.75
    seconds in privileged mode. I know – we probably don’t want to know that for a
    process as trivial as `pwsh`, but we might be interested in the value for other
    processes if we were investigating a storage performance issue on a database server.
    Run the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Here, we will get the privileged process time for all the processes currently
    running on our client, using the alias we have set for `Get-Process`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Not all cmdlets produce a single type of object. Some cmdlets may produce more
    than one, and we need to be careful how we process these and pass their output
    in the pipeline. For instance, consider the `Get-ChildItem` cmdlet. It gets the
    contents of a directory or folder. A directory may contain two basic types of
    items – that is, files and sub-directories. These two types will have different
    properties – for instance, we can’t nest a sub-directory inside a file. A pipeline
    that has been set up to manipulate file objects may fail if it is also passed
    directory objects. Let’s have a look; type the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we can see that the `C:\scratch` directory on my Windows machine contains
    both directories and files, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.3 – Checking the types of objects in a directory](img/B17600_03_003.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.3 – Checking the types of objects in a directory
  prefs: []
  type: TYPE_NORMAL
- en: What are we doing there? This looks a bit complicated. Well, we’re taking the
    output of the `Get-ChildItem C:\scratch` cmdlet and passing it to `Get-Member`.
    We’re only interested in the `TypeName` property, so we put the pipeline in parentheses
    so that we can easily access just the property we need. Once we’ve got the collection
    of all `TypeName` instances, we pass it in a second pipeline to `Select-Object`,
    which we tell to only return unique values by using the `-unique` parameter. Clever,
    eh?
  prefs: []
  type: TYPE_NORMAL
- en: We’re going to look at basic ways of manipulating these objects in the next
    few sections. Let’s start with selecting and sorting objects.
  prefs: []
  type: TYPE_NORMAL
- en: Selecting and sorting objects
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Many of the cmdlets we might run will produce a large amount of output, and,
    likely, much of it will not be interesting. Therefore, it’s useful to be able
    to select just the bits we need and sort them into a meaningful order. There are
    two cmdlets for doing this: `Select-Object` and `Sort-Object`. We will often see
    these referred to by their aliases – `select` and `sort`.'
  prefs: []
  type: TYPE_NORMAL
- en: Using Select-Object
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We used `Select-Object` in the *What is an object?* section to select the unique
    properties of objects in a collection. However, we can use it to do so much more.
    Look at the help file for `Select-Object` by running the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we can see that there are four parameter sets, all of which work in one
    of two ways – we can either use the cmdlet to work with one or more properties
    of a collection, or we can use it to select a subset of objects in a collection.
    Let’s try the first one by typing the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we’ll see a collection of objects with two properties – `Name` and `Id`.
    Now, let’s run that in `Get-Member`, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we can see that we’ve taken that collection of `System.Diagnostics.Process`
    objects and changed them into `Selected.System.Diagnostics.Process` objects –
    these objects only have two properties – the `Name` and `Id` properties we used
    in the `Select-Object` cmdlet:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.4 – The properties of our new objects](img/B17600_03_004.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.4 – The properties of our new objects
  prefs: []
  type: TYPE_NORMAL
- en: We’ve still got the same number of objects, but now, they only have the properties
    we’re interested in. This has two benefits; first, PowerShell will run much quicker
    while working on these smaller objects, but also PowerShell will require less
    memory. The downside is that we no longer have access to the properties we *didn’t*
    select from the original objects in the pipeline.
  prefs: []
  type: TYPE_NORMAL
- en: 'The second way we can use `Select-Object` is to select a subset of objects
    from a collection. The parameters for doing that are in the first parameter set;
    `-first`, `-last`, and `-skip`. Each of these parameters requires an integer as
    an argument. `-first 5` will select the first five objects in the pipeline, whereas
    `-last 2` will select the last two objects in the pipeline, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.5 – Selecting a subset of objects](img/B17600_03_005.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.5 – Selecting a subset of objects
  prefs: []
  type: TYPE_NORMAL
- en: 'We can use the `-skip` parameter to miss out values at the start or end, like
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: This will return the integers `2` and `3` which are the first two if we skip
    the first one.
  prefs: []
  type: TYPE_NORMAL
- en: Activity 1
  prefs: []
  type: TYPE_NORMAL
- en: How might we return `2`, `3`, `4`, `7`, and `8` from that array?
  prefs: []
  type: TYPE_NORMAL
- en: The problem with running `Select-Object` in this way is that unless we can control
    the order of the objects in the collection, we’re just grabbing random objects.
    This brings us to our next cmdlet, `Sort-Object`.
  prefs: []
  type: TYPE_NORMAL
- en: Ordering objects with Sort-Object
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When we run `Get-Process`, the processes are returned in alphabetical order,
    by process name. This is determined in the PowerShell source code. We can, however,
    change the order in which the objects are presented (and by implication, re-order
    them in the pipeline) using the `Sort-Object` cmdlet.
  prefs: []
  type: TYPE_NORMAL
- en: '`Sort-Object` can sort a collection of objects on one or more properties. We
    don’t need to run it with any parameters; if we don’t specify a property to sort
    on, it will sort the collection based on the default sort property of the first
    object in the pipeline, which is defined deep within the PowerShell source code
    and is not easy to find.'
  prefs: []
  type: TYPE_NORMAL
- en: 'What does this mean? Remember that `Get-ChildItem` produces two types of output.
    By default, when you run `Get-ChildItem`, you get a list of all the first type
    of object (`System.IO.DirectoryInfo`, or directories), and then a list of all
    the second type of object (`System.IO.FileInfo`, or files), as shown in the first
    example in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.6 – The effect of running Select-Object with no parameters](img/B17600_03_006.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.6 – The effect of running Select-Object with no parameters
  prefs: []
  type: TYPE_NORMAL
- en: In the second example, `Get-ChildItem -Path C:\Scratch\ | Sort-Object`, we have
    a list of all the objects arranged alphabetically and mixed; it ignores the object
    type.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can add a property name to sort our collection on that property. For instance,
    we could run `Get-Process` and sort on the working set size, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'This is nice. However, it’s sorted them in the default order, ascending, so
    the processes we are most likely to be interested in – those with the highest
    memory consumption – are at the bottom of the table. We can fix that with another
    parameter, `-Descending`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'This produces a much more useful output, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.7 – Using Sort-Object to sort in descending order](img/B17600_03_007.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.7 – Using Sort-Object to sort in descending order
  prefs: []
  type: TYPE_NORMAL
- en: 'We can even sort on multiple properties at once. For instance, we could try
    doing the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: This orders our list by **Session ID** (**SI**), and then by **Working** **Set**
    (**WS**).
  prefs: []
  type: TYPE_NORMAL
- en: Let’s take a look at the help file. Here, we can see that `Sort-Object` has
    three parameter sets that all work in much the same fashion; the only difference
    is the `-top`, `-bottom`, and `-stable` parameters. The `-top` and `-bottom` parameters
    are fairly self-explanatory, but `-stable` is less so. When we run `Sort-Object`,
    it will output objects of equal value in an order according to its internal logic,
    not necessarily in the order that they are received. The `-stable` parameter (as
    well as `-top` and `-bottom`) will preserve the order that `Sort-Object` received
    the objects in if the sorted properties are equal.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can now see how we can combine these two cmdlets, `Sort-Object` and `Select-Object`,
    to produce meaningful collections of interesting information. For instance, we
    could type the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'This will get us the five most CPU-intensive running processes, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.8 – Combining Sort-Object and Select-Object](img/B17600_03_008.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.8 – Combining Sort-Object and Select-Object
  prefs: []
  type: TYPE_NORMAL
- en: What if we don’t want the top five, though? What if we want all the processes
    that are using *a lot* of CPU? That’s where filtering comes in.
  prefs: []
  type: TYPE_NORMAL
- en: Filtering objects
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We can filter objects in a more sophisticated way using the `Where-Object`
    cmdlet. `Where-Object` also looks at the properties of the objects in the pipeline,
    but it can also make decisions about which objects to output and which to discard.
    Try this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'This will return a list of processes where the CPU property has a value greater
    than 1\. In practice, we very rarely see people include the `-Property` and `-Value`
    names for the parameters, as they are positional. It is far more likely that you
    will see this written as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Wait, though. What’s that `-gt`? The `-gt` parameter is a **comparison operator**,
    an important concept in coding.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding comparison operators
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Comparison operators are expressed as switch parameters when using the `Where-Object`
    cmdlet, resulting in the help file being a long and complex document, with many
    parameter sets, as only one comparison operator can be used at a time. The basic
    comparison operators are shown in the following table:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Comparison** | **Operator** | **Case-Sensitive Operator** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| Equality | `-``eq` | `-``ceq` |'
  prefs: []
  type: TYPE_TB
- en: '| Inequality | `-``ne` | `-``cne` |'
  prefs: []
  type: TYPE_TB
- en: '| Greater than | `-``gt` | `-``cgt` |'
  prefs: []
  type: TYPE_TB
- en: '| Less than | `-``lt` | `-``clt` |'
  prefs: []
  type: TYPE_TB
- en: '| Greater than or equal to | `-``ge` | `-``cge` |'
  prefs: []
  type: TYPE_TB
- en: '| Less than or equal to | `-``le` | `-``cle` |'
  prefs: []
  type: TYPE_TB
- en: '| Wildcard equality | `-``like` | `-``clike` |'
  prefs: []
  type: TYPE_TB
- en: Table 3.2 – Basic comparison operators
  prefs: []
  type: TYPE_NORMAL
- en: 'By default, the operators are not case-sensitive, so `-eq top` is functionally
    the same as `-eq TOP`. There are also several NOT operators to obtain the opposite,
    such as `-NotLike`. Additionally, we have more advanced comparison operators,
    such as the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '`-match` to get values based on regular expressions.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`-in` to get objects where the property has a value in a specified array. We’ll
    discuss arrays in [*Chapter 4*](B17600_04.xhtml#_idTextAnchor071), *PowerShell
    Variables and* *Data Structures*.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`-contains` to get objects where the specified value might be in a property
    that contains an array, rather than a single value.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let’s explore how some of these might work. Try running the following commands
    to get a list of your running PowerShell processes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: The last one works because we have given `Where-Object` a two-item array of
    values, `"pwsh"` and `"bash"`, and asked it to return any objects with a `ProcessName`
    property value in that array. In practice, the array probably wouldn’t be a list
    of strings like that but something much more complicated, derived by running another
    cmdlet.
  prefs: []
  type: TYPE_NORMAL
- en: Activity 2
  prefs: []
  type: TYPE_NORMAL
- en: Why doesn’t `Get-Process | Where-Object ProcessName -contains *wsh` produce
    any output?
  prefs: []
  type: TYPE_NORMAL
- en: That’s all very interesting, but what happens if we want to find something more
    complicated, such as a filter on two properties, or find values within a range?
  prefs: []
  type: TYPE_NORMAL
- en: Understanding Where-Object advanced syntax
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: So far, we’ve been using `Where-Object` with what is known as the `-FilterScript`
    parameter. This parameter allows us to pass a short script object to the cmdlet,
    which then runs on each item in the pipeline.
  prefs: []
  type: TYPE_NORMAL
- en: 'Filter scripts are `-and`, `-or`, and `-not`. Let’s see how one of our previous
    examples might work using advanced syntax. Earlier in this section, we typed the
    following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: This gave us a list of all our running `pwsh` processes when using the basic
    syntax.
  prefs: []
  type: TYPE_NORMAL
- en: 'Writing the same command using the advanced syntax would look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'The filter script is the bit enclosed in curly brackets – that is, `$PSItem.ProcessName
    -eq ''pwsh''`. Let’s break this down. `-eq ''pwsh''` is familiar to us, as we
    used it earlier, but what about `$PSItem.ProcessName`? This is a construction
    that allows us to access the `ProcessName` property of the object currently being
    processed. `$PSItem` is a `$PSItem` outside of textbooks; the variable is almost
    always written as `$_` (*dollar underscore*); for example, `$_.ProcessName -eq
    ''pwsh''`. In the basic syntax, we didn’t need quotes around `pwsh`, but in the
    advanced syntax, we do so that the script knows that we are passing it a string
    value, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.9 – Three ways of filtering with Where-Object, one of which is wrong](img/B17600_03_009.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.9 – Three ways of filtering with Where-Object, one of which is wrong
  prefs: []
  type: TYPE_NORMAL
- en: Without the quotes, the cmdlet will interpret `pwsh` as the next cmdlet. If
    you look closely at the error, you will see that it doesn’t get as far as that,
    though, because `-eq` is missing a value. It doesn’t matter much if you use single
    or double quotes here, but the best practice is to use single quotes unless you
    need some of the special powers of double quotes, which we will talk about in
    [*Chapter 4*](B17600_04.xhtml#_idTextAnchor071), *PowerShell Variables and* *Data
    Structures*.
  prefs: []
  type: TYPE_NORMAL
- en: Multiple filters in the advanced syntax
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now that we understand the syntax, we can start using it to combine filters
    to produce more complex results. Try this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'This should give you a list of your `pwsh` processes where the `CPU` value
    is greater than 1\. Now, if you change the `CPU` value to something higher, you
    should see the output change:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.10 – Combining filters with Where-Object advanced syntax](img/B17600_03_010.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.10 – Combining filters with Where-Object advanced syntax
  prefs: []
  type: TYPE_NORMAL
- en: 'Be aware that the script block syntax is unforgiving. Unless we type it carefully
    and exactly right, we will not get the result we are hoping for. For instance,
    let’s say we type the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we will get an error saying `You must provide a value expression following
    the ''-and'' operator`. Because we can see the error, we can fix it by replacing
    `CPU` with `$PSItem.CPU`. However, let’s say we only want processes named `pwsh`
    or `bash`, and we type this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we *don’t* get an error, we just get the wrong result, as shown in the
    following screenshot. The correct syntax is shown in the second example in the
    following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.11 – Careful with that syntax, Eugene](img/B17600_03_011.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.11 – Careful with that syntax, Eugene
  prefs: []
  type: TYPE_NORMAL
- en: 'We can also use the advanced syntax to access properties of properties. Let’s
    run the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we can see that the `ProcessName` property is a string, so it has the
    properties of a string object. This means we can run something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Here, we are looking for all the processes running on the machine with a `ProcessName`
    that’s fewer than `5` characters. We’re also using the more common `$_` in place
    of `$PSItem`. You must get used to this.
  prefs: []
  type: TYPE_NORMAL
- en: Filter optimization
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Consider the following two cmdlets:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'They produce the same results (at least, they do on my machine). However, on
    my client, the first one takes 29 milliseconds, while the second one only takes
    20 milliseconds. Try it yourself with the `Measure-Command` cmdlet, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Now and then, because they’re both very short pipelines, you may get a surprising
    result, but if you run them 10 times in a row, the second cmdlet will be quicker
    than the first in some way almost every time. This variation is caused by the
    other things running on your client, competing with PowerShell for resources.
  prefs: []
  type: TYPE_NORMAL
- en: 'Earlier in this chapter, we talked about reducing the amount of processing
    and memory PowerShell requires to produce a result. Filter optimization is a great
    way to do this. We should filter objects as early as possible in the pipeline
    to reduce the number of objects PowerShell has to work on. There’s a basic rule:
    **filter left**.'
  prefs: []
  type: TYPE_NORMAL
- en: We don’t just have the `Where-Object` cmdlet for filtering. Many cmdlets also
    have filtering parameters that are either explicit, where the parameter name is
    `-Filter`, or parameters that will perform common filtering tasks. For instance,
    the `Get-ChildItem` cmdlet has `-File` and `-Directory` parameters to limit its
    output to just those object types. Where possible, use the built-in parameters
    of the cmdlet to filter objects before passing them into the pipeline for further
    processing.
  prefs: []
  type: TYPE_NORMAL
- en: Activity 3
  prefs: []
  type: TYPE_NORMAL
- en: How can we find a list of cmdlets that have a `-``Filter` parameter?
  prefs: []
  type: TYPE_NORMAL
- en: We’ve now got a pretty good grasp of how to limit the objects in the pipeline
    to just the ones we’re interested in. Next, we’ll look at how we can perform operations
    on those objects.
  prefs: []
  type: TYPE_NORMAL
- en: Enumerating objects
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Often, we will want to perform an operation on the objects that we’re working
    with. Most of the time, there will be a cmdlet to do this, but sometimes, there
    won’t. For instance, say we want to output the filename and path of some items
    in a folder. There is no convenient property that will produce just the filename
    and path; there are properties such as `pspath`, which will get us what we want
    and a bit extra, but nothing that gets exactly what we want. There is, however,
    a method on the objects that are produced by `Get-ChildItem` that will: `tostring()`.
    We can execute this method on each item by enumerating them, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'This will produce exactly the output I want, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.12 – Basic enumeration](img/B17600_03_012.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.12 – Basic enumeration
  prefs: []
  type: TYPE_NORMAL
- en: 'This is a pretty simple example. Like `Where-Object`, `Foreach-Object` has
    basic and advanced syntax, and the advanced syntax looks very similar to what
    we saw in the previous section. You must provide a script block to the `-Process`
    parameter of `ForEach-Object`. To run the last cmdlet with the advanced syntax,
    we would type the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'As shown in the following screenshot, the output is the same. Note that when
    using a script block, the method name, `tostring`, must be followed by an open
    and close bracket pair:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.13 – Advanced enumeration](img/B17600_03_013.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.13 – Advanced enumeration
  prefs: []
  type: TYPE_NORMAL
- en: 'If the method takes arguments, then we would put them in parentheses as a comma-separated
    list, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'This will correct the spelling by inserting the `''S''` string at position
    5 in the original string. We don’t see interactive enumeration as much as we used
    to, since usually, cmdlets are written to perform most of the things we might
    have wanted to enumerate interactively. However, this is an important concept
    in scripting, as we will see in [*Chapter 5*](B17600_05.xhtml#_idTextAnchor096),
    *PowerShell Control Flow – Conditionals and Loops*. There is one useful technique
    we can use it for, though – repeating a process a set number of times. Try this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: So, in the first part of the pipeline, we are using a range operator (`..`)
    to create an array of 10 integers from 1 to 10\. We’re not using the `$PSItem`
    pipeline variable in the second cmdlet, though – we’re just instructing it to
    run once for each item in the pipeline. As you can see, we’re not limited to just
    putting object methods into the script block; we can put cmdlets and scripts in
    there too.
  prefs: []
  type: TYPE_NORMAL
- en: Parallel enumeration
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'One of the problems with enumeration is that it can take a very long time if
    there are a lot of objects, or if the process is complicated. With PowerShell
    7, we gained the ability to run `ForEach-Object` processes in parallel. Try running
    the following code, which will print out the numbers 1 to 10:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'As you press *Enter* after each line, you should see a continuation prompt
    until you close the curly brackets. Slow, eh? 10 seconds to print out 10 numbers.
    Now, let’s try it with parallel processing:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: Now, you should see the numbers being printed out in groups of five. We can
    alter the number of parallel processes with the `-``ThrottleLimit` parameter.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we’ve explored some useful cmdlets for manipulating the pipeline and
    had our first taste of scripting (yes, that’s what you did just now), we will
    have a look at how the pipeline works.
  prefs: []
  type: TYPE_NORMAL
- en: How the pipeline works – parameter binding
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The main difference between the output of PowerShell cmdlets and more generic
    shells is that instead of being file-like, the output is an **object**, with a
    type, properties, and methods. So, how does an object produced by one cmdlet get
    passed to another cmdlet?
  prefs: []
  type: TYPE_NORMAL
- en: 'Cmdlets can only accept input via their parameters. There is no other way,
    so it follows that the output objects of one cmdlet must be fed to a parameter
    of the next cmdlet in the pipeline. Consider the following cmdlet pipeline:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: We can only see one parameter here, `-property`, and it’s being given an argument
    of `CPU`. So, what’s going on? `Sort-Object` is being given two parameters, but
    we can’t see one of them. This is called **pipeline** **parameter binding**.
  prefs: []
  type: TYPE_NORMAL
- en: PowerShell takes the output of the first cmdlet, `Get-Process`, and must do
    something with it, so it looks for a parameter on the second cmdlet that can accept
    the object that PowerShell is holding. There are two ways this can happen; `ByValue`
    and `ByPropertyName`. Let’s look at them in detail.
  prefs: []
  type: TYPE_NORMAL
- en: '`ByValue` is the default method, and PowerShell will always try that first,
    so let’s start with that.'
  prefs: []
  type: TYPE_NORMAL
- en: Understanding ByValue parameter binding
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let’s have a look at the help file for `Sort-Object` by typing the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'Have a look through the parameters. You will see that only one parameter can
    accept objects from the pipeline: `-InputObject`. The help file has this to say
    about it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we can see that it only accepts input `ByValue`, and it only accepts
    `PSObject` type input. `PSObject` is pretty broad; it means anything that is an
    object in PowerShell. So, we can use it to sort an array of numbers because they
    are objects of the `System.Int32` type, as shown in the following screenshot.
    Notice that, as described in the help file, we can’t successfully pass an array
    directly to the `-InputObject` parameter; it must go through the pipeline. If
    we try to explicitly feed it an array via the parameter, it sees a single array
    object and returns the array unsorted. We need it to pass through the pipeline
    one item at a time:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.14 – Correct and incorrect use of the -InputObject parameter](img/B17600_03_014.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.14 – Correct and incorrect use of the -InputObject parameter
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s have a look at another. We can see from the help file for `Get-ChildItem`
    that it has a parameter, `-path`, that accepts pipeline input `ByValue`, and accepts
    string objects. This means we can do something like this, where we put the `myfiles`
    string into the pipeline:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: Here, we will get a meaningful output – a list of all the items in the `myfiles`
    directory. If we had a cmdlet pipeline that outputs paths as strings, we could
    feed this into `Get-ChildItem` to get the contents. The important thing to remember
    when using `ByValue` is that the type of object you are passing into the pipeline
    must match the type of object that is specified by the parameter of the next cmdlet
    that accepts pipeline input.
  prefs: []
  type: TYPE_NORMAL
- en: '`Get-ChildItem` is interesting because the parameter that accepts pipeline
    input is not the `-InputObject` parameter – it’s `-path`. What happens if you
    try to pipe a string to `Get-ChildItem`, but you also explicitly specify the `-path`
    parameter? You will get an error, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.15 – Pipeline sabotage](img/B17600_03_015.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.15 – Pipeline sabotage
  prefs: []
  type: TYPE_NORMAL
- en: The preceding error says that there is no parameter to accept pipeline input,
    even though we know there is. This is because we bound a value to `Get-ChildItem`
    before we started processing the objects in the pipeline, effectively removing
    that parameter from those available. If we see this error, it’s always worth checking
    that we haven’t already used the parameter before we throw our laptops at the
    wall in frustration.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s have a look at the other method of binding pipeline content to a parameter:
    `ByPropertyName`.'
  prefs: []
  type: TYPE_NORMAL
- en: ByPropertyName parameter binding
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: PowerShell will always try to bind to a parameter `ByValue` first. It will only
    try to shoehorn the pipeline objects using `ByPropertyName` if `ByValue` is not
    available. What happens if your first cmdlet produces objects of the wrong sort
    for the `pipeline-accepting` parameter of the next cmdlet? Well, PowerShell will
    look and see if there is a parameter in the second cmdlet that accepts pipeline
    input where there is a matching property name – usually, `-Id` or `-Name`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Unsurprisingly, `Stop-Process` is a cmdlet that stops processes. If we look
    at the help file, we will see that three parameters accept pipeline input:`-InputObject`,
    which accepts objects `ByValue`, and `-Id` and `-Name`, which accept `ByPropertyName`.
    Now, let’s type the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we will get an error – the same one shown in *Figure 3**.15*. We know
    that `Stop-Process` has three parameters that take pipeline input, so it’s not
    the first reason. We haven’t explicitly bound anything to any parameters either,
    so it must be because the type of object we have in the pipeline is the wrong
    sort of object. If we use `Get-Member` to determine the type of objects `Get-Random`
    produces, and then refer to the help file for `Stop-Process`, we will see that
    `Get-Random` produces `System.Int32` objects, but `Stop-Process` requires `System.Diagnostics.Process`
    objects. So, if we’ve not got the right sort of objects in our pipeline, why didn’t
    PowerShell try to do anything `ByPropertyName`? Well, it did, but none of the
    properties of the object that were output by `Get-Random` have a property name
    that matches the `-Id` or `-Name` parameters in `Stop-Process`. Let’s have some
    fun. Type the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'What are we doing there? We’re using the `New-Object` cmdlet to create a generic
    PowerShell object (`-TypeName PSObject`) with a single property, `Id`, which we
    populate by running the `Get-Random` cmdlet to produce a random number. We will
    be able to see it in the output if we pipe the cmdlet into `Get-Member`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.16 – Creating custom objects](img/B17600_03_016.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.16 – Creating custom objects
  prefs: []
  type: TYPE_NORMAL
- en: Once we’ve created this new custom object, we can pipe it into `Stop-Process`.
    The object type is not right, so it can’t bind to `-InputObject`, but the object
    has a property name that matches the `-Id` parameter, so it binds there. Finally,
    because we don’t want to have too much fun, we’re using the `-WhatIf` parameter,
    just in case `Get-Random` provides us with a legitimate process ID. `-WhatIf`
    is one of the common parameters available in most PowerShell cmdlets, and it tells
    us what would happen if we ran the cmdlet without actually changing anything.
  prefs: []
  type: TYPE_NORMAL
- en: Parenthetical commands
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A few times now, we have run cmdlets in parentheses, as we did previously. Parentheses
    are a way of overriding the order in which PowerShell runs. The same as in mathematics,
    parentheses are an instruction to do something *first*. When we use them in PowerShell,
    the content inside the parentheses must be completed before anything else in that
    segment of the pipeline is processed. This gives us another way to pass input
    directly to a parameter.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the preceding example, we tried to run the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'This didn’t work. While the object type (`System.Int32`) was correct for the
    `-Id` parameter, the `PropertyName` value was incorrect. With parentheses, we
    can explicitly pass that content to the `-Id` parameter, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: First, PowerShell will produce a random number, and then pass it to the `-Id`
    parameter for us. We will see many more useful examples of parentheses as we go
    through this book.
  prefs: []
  type: TYPE_NORMAL
- en: Troubleshooting the pipeline – pipeline tracing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We’ve done a lot of work in this chapter, so now it’s time to kick back and
    have some fun with `Trace-Command`. At least, I think it’s fun; other opinions
    are available. This cmdlet does, however, really let us get into the nuts and
    bolts of how PowerShell works so that we get to see it in action.
  prefs: []
  type: TYPE_NORMAL
- en: 'Run the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: Here, we’re running `Trace-Command` and asking it to record `ParameterBinding`
    events. We’re giving it the cmdlet we ran previously as an expression in a script
    block, and then with `-PSHost`, we’re telling it to output to the screen, rather
    than its default, which is the debug stream that we saw right at the start of
    this chapter when we were talking about streams.
  prefs: []
  type: TYPE_NORMAL
- en: 'We’ve now got a screen full of yellow writing, which is messy; we’re going
    to need to have a dig around in there. These are the questions we’re interested
    in:'
  prefs: []
  type: TYPE_NORMAL
- en: Where did the custom object bind?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How did the custom object bind?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Here’s my output, tidied up, with comments below each line:'
  prefs: []
  type: TYPE_NORMAL
- en: '`DEBUG: BIND PIPELINE object to` `parameters: [Stop-Process]`'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In this line, we’re starting by binding to the parameters of `Stop-Process`.
  prefs: []
  type: TYPE_NORMAL
- en: '`DEBUG: PIPELINE object TYPE = [``System.Management.Automation.PSCustomObject]`'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: This tells us what sort of object we have in the pipeline.
  prefs: []
  type: TYPE_NORMAL
- en: '`DEBUG: Parameter [InputObject] PIPELINE INPUT ValueFromPipeline` `NO COERCION`'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: This tells us that `-InputObject` only takes the `ByValue objects`.
  prefs: []
  type: TYPE_NORMAL
- en: '`DEBUG: BIND arg [@{Id=1241688337}] to` `parameter [InputObject]`'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`arg [1241688337]` is the random number that was generated.'
  prefs: []
  type: TYPE_NORMAL
- en: '`DEBUG: Binding collection parameter InputObject: argument type [PSObject],
    parameter type [System.Diagnostics.Process[]], collection type Array, element
    type [System.Diagnostics.Process],` `no coerceElementType`'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: This shows us that the object types don’t match.
  prefs: []
  type: TYPE_NORMAL
- en: '`DEBUG: BIND arg [@{Id=1241688337}] to param [``InputObject] SKIPPED`'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Here, we’re skipping binding to `-InputObject`.
  prefs: []
  type: TYPE_NORMAL
- en: '`DEBUG: Parameter [Id] PIPELINE INPUT ValueFromPipelineByPropertyName` `NO
    COERCION`'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: This line shows that the `-Id` parameter accepts `ByPropertyName` `as` `input`.
  prefs: []
  type: TYPE_NORMAL
- en: '`DEBUG: BIND arg [1241688337] to` `parameter [Id]`'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`DEBUG: Binding collection parameter Id: argument type [Int32], parameter type
    [System.Int32[]], collection type Array, element type [System.Int32],` `no coerceElementType`'
  prefs: []
  type: TYPE_NORMAL
- en: This shows us that the object types match.
  prefs: []
  type: TYPE_NORMAL
- en: '`DEBUG: BIND arg [System.Int32[]] to param [``Id] SUCCESSFUL`'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Here, we are told we have successfully bound to the `–``Id` parameter.
  prefs: []
  type: TYPE_NORMAL
- en: So, we have the answers to our questions – the object in the pipeline bound
    to the `-Id` parameter, `ByPropertyName`.
  prefs: []
  type: TYPE_NORMAL
- en: That was a whirlwind introduction to `Trace-Command`. If your pipeline is failing,
    and you are sure that your object types match, or that you have matching property
    names, and you haven’t bound something explicitly to the only parameter that accepts
    pipeline input, then this cmdlet is your best hope of understanding what’s happening.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We covered some really interesting and quite technical topics in this chapter.
    We started by describing what the pipeline does, and then looked at techniques
    for selecting and sorting objects. We then looked at filtering objects and talked
    about the importance of using filtering to allow PowerShell to work as efficiently
    as possible.
  prefs: []
  type: TYPE_NORMAL
- en: 'From there, we introduced a topic that will be important later, enumeration,
    and looked at one of the newer features of PowerShell 7, parallel enumeration.
    In the last part of this chapter, we took a deeper dive into how the pipeline
    accomplishes its magic and examined the two methods of parameter binding: `ByValue`
    and `ByPropertyName`. Finally, we played with a cmdlet that allows us to get under
    the hood of how the pipeline is working: `Trace-Command`.'
  prefs: []
  type: TYPE_NORMAL
- en: Most of the time, the pipeline *just works*. However, for cases when it doesn’t,
    this chapter has given us the essential knowledge we need to understand what it
    is doing and, hopefully, how to fix it. Sometimes, cmdlet authors do not provide
    a way for their cmdlets to accept pipeline input. This chapter has shown us how
    to spot that and given us one technique for working around it.
  prefs: []
  type: TYPE_NORMAL
- en: This chapter concludes the introductory part of this book on PowerShell mechanics.
    In the next chapter, we’re going to start doing some coding by looking at variables
    and data structures. Hold tight.
  prefs: []
  type: TYPE_NORMAL
- en: Exercises
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The following are some exercises to help you solidify your knowledge of this
    chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: How can we use PowerShell to display just the day of the week it is today?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We need to get a list of CPU usage and the locations of all our running processes,
    and we don’t want a lot of unnecessary information. How do we do that?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now that we’ve got our list, how can we get the path names in reverse alphabetical
    order?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: There’s a lot of stuff here. How do we ensure it only lists the processes that
    have a CPU usage of greater than 5?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is the most efficient way to get a list of read-only files from our home
    drive?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We need to get the size of all the files in our home directory. We just want
    the name and the size in bytes.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We have a file that contains a list of process names, called `processes.txt`.
    we need to use it to discover information about the processes on our local machine,
    so we will need to find a cmdlet that can get content from the file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Without *actually running the cmdlet*, what will happen if we run this without
    `-WhatIf` on a Windows host?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: If it’s not right, what would the right cmdlet be?
  prefs: []
  type: TYPE_NORMAL
- en: 'What would happen if we ran it on a Linux host? Tip: think about this. Don’t
    try it. Especially don’t try it without `-WhatIf`.'
  prefs: []
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As I get older, I find the history of computing more and more fascinating;
    concepts and devices that were bleeding edge when I was in my twenties are now
    dusty old relics. However, these old relics go some way to explaining why we are
    where we are. The Unix Oral History Project has a great section on the concept
    of pipes: [https://dspinellis.github.io/oral-history-of-unix/frs122/unixhist/finalhis.htm](https://dspinellis.github.io/oral-history-of-unix/frs122/unixhist/finalhis.htm).'
  prefs: []
  type: TYPE_NORMAL
