<html><head></head><body><div id="sbo-rt-content"><div id="_idContainer123">
			<h1 id="_idParaDest-76"><em class="italic"><a id="_idTextAnchor077"/>Chapter 4</em>: Using Shell to Configure and Troubleshoot a Network</h1>
			<p>Managing processes is an important job of a Linux system administrator. That can be for a variety of reasons – maybe some processes got stuck and we need to finish them, or we want to put some process(es) to work in the background, or even to be started periodically or at a later date. Whatever the scenario is, it's important to know how to administer processes and make them do the work that needs to be done efficiently and with regards to other processes running on the system.</p>
			<p>In this chapter, we are going to learn about the following recipes:</p>
			<ul>
				<li>Using <strong class="source-inline">nmcli</strong> and <strong class="source-inline">netplan</strong></li>
				<li>Using <strong class="source-inline">firewall-cmd</strong> and <strong class="source-inline">ufw</strong></li>
				<li>Working with open ports and connections</li>
				<li>Configuring <strong class="source-inline">/etc/hosts</strong> and DNS resolving</li>
				<li>Using network diagnostic tools</li>
			</ul>
			<h1 id="_idParaDest-77"><a id="_idTextAnchor078"/>Technical requirements </h1>
			<p>For these recipes, we're going to use two Linux machines. We can use the client1 virtual machine from our previous recipes. We'll also use another two virtual machines running <strong class="bold">CentOS 8 2105</strong> to cover CentOS-based scenarios (<strong class="source-inline">nmcli</strong> and <strong class="source-inline">firewall-cmd</strong>). Let's call them <strong class="source-inline">server1</strong> and client2. All in all, we need the following:</p>
			<ul>
				<li>A virtual machine running Ubuntu 20.10</li>
				<li>Two virtual machines with CentOS 8 2105 </li>
			</ul>
			<p>So, let's start our virtual machines and let's get cracking!</p>
			<h1 id="_idParaDest-78"><a id="_idTextAnchor079"/>Using nmcli and netplan</h1>
			<p>Network configuration has changed significantly in the past couple of releases – for all Linux distributions. It doesn't really matter<a id="_idIndexMarker155"/> whether we are discussing Red Hat and its clones or Debian<a id="_idIndexMarker156"/> and its clones – these changes happened across all of them. For example, Red Hat and its clones went from a network service to a mixture of network and NetworkManager services to a fully NetworkManager-based configuration. Ubuntu was using a networking service until recently when it switched to netplan. Let's explain all of these concepts so that we can have a full overview of these configuration methods and cover any situations you might end up in. We will also cover a scenario in which someone might want to turn off netplan and go back to using the networking service on Ubuntu.</p>
			<h2 id="_idParaDest-79"><a id="_idTextAnchor080"/>Getting ready</h2>
			<p>We just need one Ubuntu and one CentOS machine for this recipe. Let's say we are going to use <strong class="source-inline">server1</strong> and client1 to master <strong class="source-inline">nmcli</strong> and <strong class="source-inline">netplan</strong>. Furthermore, on CentOS, we need to deploy the <strong class="source-inline">net-tools</strong> package to get access to some of the commands used in this recipe (for example, the <strong class="source-inline">ifconfig</strong> command). Let's do that by using the following command:</p>
			<p class="source-code"><strong class="source-inline">dnf install net-tools</strong></p>
			<p>After that, we're ready to go.</p>
			<h2 id="_idParaDest-80"><a id="_idTextAnchor081"/>How to do it</h2>
			<p>Let's first work with the two most common CentOS scenarios – implementing network configuration<a id="_idIndexMarker157"/> via <strong class="source-inline">nmcli</strong> for both <strong class="bold">static IP address</strong> and <strong class="bold">Dynamic Host Configuration Protocol</strong> (<strong class="bold">DHCP</strong>) scenarios. Let's just say that we are going to use network<a id="_idIndexMarker158"/> interface <strong class="source-inline">ens39</strong> to create a network connection called <strong class="source-inline">static</strong> (for the static IP address, for example, <strong class="source-inline">192.168.2.2/24</strong> with gateway <strong class="source-inline">192.168.2.254</strong> and DNS servers <strong class="source-inline">8.8.8.8</strong> and <strong class="source-inline">8.8.4.4</strong>) and, later on, a network connection called <strong class="source-inline">dynamic</strong> (for DHCP configuration). We just need to run a few commands as root per scenario for that:</p>
			<p class="source-code"><strong class="source-inline">nmcli connection add con-name static ifname ens39 type ethernet ipv4.address 192.168.2.2/24 ipv4.gateway 192.168.2.254 ipv4.dns 8.8.8.8,8.8.4.4</strong></p>
			<p class="source-code"><strong class="source-inline">nmcli connection reload</strong></p>
			<p class="source-code"><strong class="source-inline">systemctl restart NetworkManager</strong></p>
			<p>The expected result should look like this:</p>
			<div>
				<div id="_idContainer069" class="IMG---Figure">
					<img src="Images/Figure_4.1_B16269.jpg" alt="Figure 4.1 – Adding a static IP configuration via nmcli&#13;&#10;" width="1449" height="443"/>
				</div>
			</div>
			<p class="figure-caption">Figure 4.1 – Adding a static IP configuration via nmcli</p>
			<p>Let's now remove that connection<a id="_idIndexMarker159"/> and define a DHCP-based configuration. For that, we need to have a DHCP server<a id="_idIndexMarker160"/> available on our network, so that it can assign the necessary network configuration information to client2 (IP address, netmask, gateway, DNS server addresses, and so on). We need to type in the following commands:</p>
			<p class="source-code"><strong class="source-inline">nmcli connection delete static</strong></p>
			<p class="source-code"><strong class="source-inline">nmcli connection add con-name dynamic ifname ens39 type ethernet</strong></p>
			<p class="source-code"><strong class="source-inline">nmcli connection reload</strong></p>
			<p class="source-code"><strong class="source-inline">systemctl restart NetworkManager</strong></p>
			<p><strong class="source-inline"> </strong>This is our expected result:</p>
			<div>
				<div id="_idContainer070" class="IMG---Figure">
					<img src="Images/Figure_4.2_B16269.jpg" alt="Figure 4.2 – Adding a DHCP configuration via nmcli&#13;&#10;" width="1194" height="615"/>
				</div>
			</div>
			<p class="figure-caption">Figure 4.2 – Adding a DHCP configuration via nmcli</p>
			<p>If everything is configured correctly on our network, we should've gotten an IP address and other networking information and have internet access.</p>
			<p>In terms of <strong class="source-inline">netplan</strong> on Ubuntu, this configuration method is more in line with the currently popular <em class="italic">infrastructure as code</em> paradigm, so it's all about configuration files. So, we will again implement<a id="_idIndexMarker161"/> two of the most common scenarios – a static IP address and DHCP, but we will also<a id="_idIndexMarker162"/> cover a scenario with multiple network interfaces so that we can see what the syntax looks like. </p>
			<p>First, let's start with the <strong class="source-inline">netplan</strong> static networking configuration. Let's say that we need to assign IP address <strong class="source-inline">192.168.1.1/24</strong> to network interface <strong class="source-inline">ens33</strong>, with the default gateway being <strong class="source-inline">192.168.1.254</strong> and DNS servers <strong class="source-inline">8.8.8.8</strong>, and <strong class="source-inline">8.8.4.4</strong>. We can just change the existing YAML configuration file that's already there, called <strong class="source-inline">00-installer-config.yaml</strong>:</p>
			<div>
				<div id="_idContainer071" class="IMG---Figure">
					<img src="Images/Figure_4.3_B16269.jpg" alt="Figure 4.3 – Adding a static configuration via netplan&#13;&#10;" width="808" height="359"/>
				</div>
			</div>
			<p class="figure-caption">Figure 4.3 – Adding a static configuration via netplan</p>
			<p>That covers our static IP address<a id="_idIndexMarker163"/> scenario. It's relatively obvious what we need<a id="_idIndexMarker164"/> to do in terms of a <strong class="source-inline">netplan</strong> DHCP scenario, so the configuration file needs to look like this for that specific scenario:</p>
			<div>
				<div id="_idContainer072" class="IMG---Figure">
					<img src="Images/Figure_4.4_B16269.jpg" alt="Figure 4.4 – Adding a dynamic configuration via netplan&#13;&#10;" width="810" height="212"/>
				</div>
			</div>
			<p class="figure-caption">Figure 4.4 – Adding a dynamic configuration via netplan</p>
			<p>The last part of our recipe, as we mentioned, is about having multiple network interfaces and configuring them properly. Let's say that we have a network interface called <strong class="source-inline">ens33</strong> that needs to be DHCP-configured, and an interface called <strong class="source-inline">ens38</strong> that needs to be assigned an IP address, <strong class="source-inline">192.168.1.1/24</strong>, with the same config data for gateway and DNS servers as before. The configuration file would look like this:</p>
			<div>
				<div id="_idContainer073" class="IMG---Figure">
					<img src="Images/Figure_4.5_B16269.jpg" alt="Figure 4.5 – Configuring multiple network interfaces via netplan&#13;&#10;" width="812" height="417"/>
				</div>
			</div>
			<p class="figure-caption">Figure 4.5 – Configuring multiple network interfaces via netplan</p>
			<p>For some of the latest versions of Ubuntu, this <strong class="source-inline">yes</strong>/<strong class="source-inline">no</strong> configuration<a id="_idIndexMarker165"/> will be changed to <strong class="source-inline">true</strong>/<strong class="source-inline">false</strong>, so if you<a id="_idIndexMarker166"/> get an error here, you just need to make that change. Basically, it looks like a merge of the previous two files, with a couple of lines stripped so that we don't have unnecessary repetitions.</p>
			<p>Let's now see how these two concepts work. It's simple enough, but still, it requires a bit of background knowledge, so let's dive in.</p>
			<h2 id="_idParaDest-81"><a id="_idTextAnchor082"/>How it works</h2>
			<p>Now that we've done a brief primer on how processes and signals work, let's continue our quest for knowledge about processes by learning about the management of background processes. As we've already explained the basics of background processes, that shouldn't be a difficult task.</p>
			<p>In terms of NetworkManager and its command-line configuration interface (<strong class="source-inline">nmcli</strong>), NetworkManager does its configuration via configuration files in the <strong class="source-inline">/etc/sysconfig/network-scripts</strong> directory. Let's show an example from our previous CentOS session – where we created an interface called <strong class="source-inline">dynamic</strong>. In that directory, there's a file called <strong class="source-inline">ifcfg-dynamic</strong>, with the following content:</p>
			<div>
				<div id="_idContainer074" class="IMG---Figure">
					<img src="Images/Figure_4.6_B16269.jpg" alt="Figure 4.6 – Regular NetworkManager configuration file&#13;&#10;" width="714" height="467"/>
				</div>
			</div>
			<p class="figure-caption">Figure 4.6 – Regular NetworkManager configuration file</p>
			<p>That's quite a big configuration<a id="_idIndexMarker167"/> file for a simple configuration. Actually, if we were to polish<a id="_idIndexMarker168"/> this file a bit, we could make it at least two thirds shorter, and it would still work, for example, like this:</p>
			<div>
				<div id="_idContainer075" class="IMG---Figure">
					<img src="Images/Figure_4.7_B16269.jpg" alt="Figure 4.7 – Shortened configuration file&#13;&#10;" width="959" height="152"/>
				</div>
			</div>
			<p class="figure-caption">Figure 4.7 – Shortened configuration file</p>
			<p>These configuration options aren't all that difficult to understand, as well as some other configuration options that are needed for static IP configuration (<strong class="source-inline">IPADDR</strong>, <strong class="source-inline">PREFIX</strong> or <strong class="source-inline">NETMASK</strong>, <strong class="source-inline">GATEWAY</strong> – these are all pretty self-explanatory). But the fact remains that – at least in part – NetworkManager still uses this bulky syntax as a history leftover, as we've been using this <strong class="source-inline">/etc/sysconfig/network-scripts</strong> directory and files in that directory to configure network interfaces for years and years now. </p>
			<p>When comparing that to netplan, we can clearly see that netplan<a id="_idIndexMarker169"/> puts much more importance on declarative syntax<a id="_idIndexMarker170"/> with all of the structured code and indentation that it needs to have, which is what YAML is known for. It will frustrate you at the beginning, at least until you learn how to use the vim editor for editing YAML files, as it then becomes much easier. Check out the link in the <em class="italic">There's more</em> section to learn how to set up vim to help you with YAML syntax. </p>
			<p>Both of these services – when the system gets booted up – read the aforementioned configuration files and set the network interfaces in accordance to the settings in them. A pretty straightforward process, as long as we understand the syntax. But we'd still recommend using <strong class="source-inline">nmcli</strong> for NetworkManager configuration as its syntax gets under your fingers quickly.</p>
			<p>The next stop is firewalling, by using <strong class="source-inline">firewalld</strong> and <strong class="source-inline">ufw</strong>.</p>
			<h2 id="_idParaDest-82"><a id="_idTextAnchor083"/>There's more</h2>
			<p>If you need more information<a id="_idIndexMarker171"/> about networking in CentOS and Ubuntu, make sure that you check the following:</p>
			<ul>
				<li>Configuring and managing<a id="_idIndexMarker172"/> networking: <a href="https://access.redhat.com/documentation/en-us/red_hat_enterprise_linux/8/html-single/configuring_and_managing_networking/index%0D">https://access.redhat.com/documentation/en-us/red_hat_enterprise_linux/8/html-single/configuring_and_managing_networking/index</a></li>
				<li>Netplan<a id="_idIndexMarker173"/> reference: <a href="https://netplan.io/reference/%0D">https://netplan.io/reference/</a></li>
				<li><strong class="source-inline">nmcli</strong>: <a href="https://developer-old.gnome.org/NetworkManager/stable/nmcli.html%0D">https://developer-old.gnome.org/NetworkManager/stable/nmcli.html</a></li>
				<li>Setting up vim<a id="_idIndexMarker174"/> for YAML editing: <a href="https://www.arthurkoziel.com/setting-up-vim-for-yaml/%0D">https://www.arthurkoziel.com/setting-up-vim-for-yaml/</a></li>
			</ul>
			<h1 id="_idParaDest-83"><a id="_idTextAnchor084"/>Using firewall-cmd and ufw</h1>
			<p>Using built-in firewalls<a id="_idIndexMarker175"/> has been a de facto standard in Linux for more than two decades<a id="_idIndexMarker176"/> now. Ever since the <em class="italic">invention</em> of <strong class="source-inline">ipfwadm</strong> (kernel v2.0), Linux kernel developers have been piling up functionality and a firewall has been one of those things. <strong class="source-inline">ipfwadm</strong> was followed by <strong class="source-inline">ipchains</strong> (kernel v2.2), <strong class="source-inline">iptables</strong> (kernel v2.4), and today it's all about <strong class="source-inline">firewalld</strong> (CentOS) and <strong class="source-inline">ufw</strong> (Ubuntu). Let's go through both of these concepts so that we can use them when we need them regardless of the Linux distribution we're working on. </p>
			<h2 id="_idParaDest-84"><a id="_idTextAnchor085"/>Getting ready</h2>
			<p>As a part of this recipe, we are going to go through a list of dozens of different scenarios covering <strong class="source-inline">firewalld</strong> and <strong class="source-inline">ufw</strong>. In other words, we are going to introduce the necessary commands to do configuration changes for some of the most commonly used scenarios. First, let's install the necessary packages for CentOS (on our client2 machine) and Ubuntu (client1 machine). So, for CentOS, we need to type the following command:</p>
			<p class="source-code">yum -y install firewalld</p>
			<p>Also, use this command for Ubuntu:</p>
			<p class="source-code">apt-get -y install ufw</p>
			<p>In terms of services, for CentOS, we have these – just in case we used <strong class="source-inline">iptables</strong> previously, as <strong class="source-inline">iptables</strong> firewall is supported in CentOS 8:</p>
			<p class="source-code">systemctl stop iptables</p>
			<p class="source-code">systemctl disable iptables</p>
			<p class="source-code">systemctl mask iptables</p>
			<p class="source-code">systemctl enable firewalld</p>
			<p class="source-code">systemctl start firewalld</p>
			<p>For Ubuntu, it's the same idea:</p>
			<p class="source-code">systemctl stop iptables</p>
			<p class="source-code">systemctl disable iptables</p>
			<p class="source-code">systemctl mask iptables</p>
			<p class="source-code">systemctl enable ufw</p>
			<p class="source-code">systemctl start ufw</p>
			<p class="source-code">ufw enable</p>
			<p>Now that the services are configured, let's start!</p>
			<h2 id="_idParaDest-85"><a id="_idTextAnchor086"/>How to do it</h2>
			<p>For <strong class="source-inline">firewalld</strong>, we are going to use its default command, which is <strong class="source-inline">firewall-cmd</strong>. For <strong class="source-inline">ufw</strong>, the command<a id="_idIndexMarker177"/> has the same name – <strong class="source-inline">ufw</strong>. First, let's take care<a id="_idIndexMarker178"/> of some basic commands. Let's first list all the rules:</p>
			<p class="source-code">firewall-cmd --list-all</p>
			<p>Depending on how many rules we added previously, we should get an output similar to this:</p>
			<div>
				<div id="_idContainer076" class="IMG---Figure">
					<img src="Images/Figure_4.8_B16269.jpg" alt="Figure 4.8 – firewall-cmd --list-all output&#13;&#10;" width="597" height="404"/>
				</div>
			</div>
			<p class="figure-caption">Figure 4.8 – firewall-cmd --list-all output</p>
			<p>Let's now add<a id="_idIndexMarker179"/> and delete a couple<a id="_idIndexMarker180"/> of rules. This is what we are going to do:</p>
			<ul>
				<li>Add a rule that allows <strong class="source-inline">192.168.2.254/24</strong> to access everything on our <strong class="source-inline">client2</strong> machine.</li>
				<li>Add a rule that allows network subnet <strong class="source-inline">192.168.1.0/24</strong> to access the <strong class="source-inline">SSH</strong> service on our <strong class="source-inline">client2</strong> machine.</li>
				<li>Block the <strong class="source-inline">192.168.3.0/24</strong> network from accessing HTTP/HTTPS services.</li>
				<li>Allow the same subnet to access the DNS service.</li>
				<li>Forward port <strong class="source-inline">900</strong> to port <strong class="source-inline">9090</strong>.</li>
				<li>Configure <strong class="source-inline">masquerade</strong> so that <strong class="source-inline">client1</strong> can be used as a router/gateway.</li>
			</ul>
			<p>As the last step, we are going to delete every single one of these rules, one by one.</p>
			<p>Now that we're clear on what we are trying to do, let's punch in all of the necessary commands to make this happen. First, let's start by using the default configuration and default zone, which means that we need to check which zone it is. We can see in the previous screenshot that the public zone is active, so – for the time being – we are going to add all of the rules to that zone and explain zones and rich rules a bit later:</p>
			<p class="source-code">firewall-cmd --permanent --zone=public --add-source=192.168.2.254/32</p>
			<p class="source-code">firewall-cmd --permanent --zone=public --add-rich-rule='rule family="ipv4" source address="192.168.1.0/24" port protocol="tcp" port="22" accept'</p>
			<p class="source-code">firewall-cmd --permanent --zone=public --add-rich-rule='rule family="ipv4" source address="192.168.3.0/24" port protocol="tcp" port="80" reject' </p>
			<p class="source-code">firewall-cmd --permanent --zone=public --add-rich-rule='rule family="ipv4" source address="192.168.3.0/24" port protocol="tcp" port="443" reject'</p>
			<p class="source-code">firewall-cmd --permanent --zone=public --add-rich-rule='rule family="ipv4" source address="192.168.3.0/24" port protocol="udp" port="53" accept' </p>
			<p class="source-code">firewall-cmd --permanent --zone=public --add-forward-port=port=900:proto=tcp:toport=9090</p>
			<p class="source-code">firewall-cmd --permanent --zone=public --add-masquerade</p>
			<p class="source-code">echo "1" &gt; /proc/sys/net/ipv4/ip_forward</p>
			<p class="source-code">echo "net.ipv4.ip_forward = 1" &gt; /etc/sysctl.d/50-forward.conf</p>
			<p class="source-code">firewall-cmd --reload</p>
			<p>Echo commands<a id="_idIndexMarker181"/> are used to enable IP forwarding<a id="_idIndexMarker182"/> right now (first echo), and to enable it permanently (second echo), by using a <strong class="source-inline">sysctl</strong> configuration file that's going to be loaded as our system boots up. The last command is to apply these settings to the current running state of <strong class="source-inline">firewalld</strong>. When we now type in the <strong class="source-inline">firewall-cmd --list-all</strong> command, we should get output like this:</p>
			<div>
				<div id="_idContainer077" class="IMG---Figure">
					<img src="Images/Figure_4.9_B16269.jpg" alt="Figure 4.9 – End result of our configuration in firewalld&#13;&#10;" width="1349" height="535"/>
				</div>
			</div>
			<p class="figure-caption">Figure 4.9 – End result of our configuration in firewalld</p>
			<p>It's very important to learn how to remove these rules, as well. So, let's now remove these rules, one by one, going in the opposite direction:</p>
			<p class="source-code">firewall-cmd --permanent --zone=public --remove-masquerade</p>
			<p class="source-code">firewall-cmd --permanent --zone=public --remove-forward-port=port=900:proto=tcp:toport=9090</p>
			<p class="source-code">firewall-cmd --permanent --zone=public --remove-rich-rule='rule family="ipv4" source address="192.168.1.0/24" port protocol="tcp" port="22" accept'</p>
			<p class="source-code">firewall-cmd --permanent --zone=public --remove-rich-rule='rule family="ipv4" source address="192.168.3.0/24" port protocol="udp" port="53" accept' </p>
			<p class="source-code">firewall-cmd --permanent --zone=public --remove-rich-rule='rule family="ipv4" source address="192.168.3.0/24" port protocol="tcp" port="443" reject'</p>
			<p class="source-code">firewall-cmd --permanent --zone=public --add-rich-rule='rule family="ipv4" source address="192.168.3.0/24" port protocol="tcp" port="80" reject'</p>
			<p class="source-code">firewall-cmd --permanent --zone=public --remove-source=192.168.2.254/24</p>
			<p class="source-code">firewall-cmd --reload</p>
			<p>That should remove<a id="_idIndexMarker183"/> all of the rules and apply the starting state<a id="_idIndexMarker184"/> as the current state. Let's check:</p>
			<div>
				<div id="_idContainer078" class="IMG---Figure">
					<img src="Images/Figure_4.10_B16269.jpg" alt="Figure 4.10 – The firewalld rule set after rule removal&#13;&#10;" width="597" height="403"/>
				</div>
			</div>
			<p class="figure-caption">Figure 4.10 – The firewalld rule set after rule removal</p>
			<p>Everything is back to its original<a id="_idIndexMarker185"/> state, so we can call this a success. Let's now apply the same ruleset<a id="_idIndexMarker186"/> to the Ubuntu virtual machine called client1 by using <strong class="source-inline">ufw</strong>. Let's first check the status by using the <strong class="source-inline">ufw status verbose</strong> command. We should get a result like this:</p>
			<div>
				<div id="_idContainer079" class="IMG---Figure">
					<img src="Images/Figure_4.11_B16269.jpg" alt="Figure 4.11 – ufw configuration starting point&#13;&#10;" width="905" height="152"/>
				</div>
			</div>
			<p class="figure-caption">Figure 4.11 – ufw configuration starting point</p>
			<p>Let's now add the same set of rules that we added in <strong class="source-inline">firewalld</strong>, to see how it's done via <strong class="source-inline">ufw</strong> and to be able to check the syntax differences:</p>
			<p class="source-code">ufw allow from 192.168.2.254/32</p>
			<p class="source-code">ufw allow from 192.168.1.0/24 proto tcp to any port 22</p>
			<p class="source-code">ufw deny from 192.168.3.0/24 proto tcp to any port 80</p>
			<p class="source-code">ufw deny from 192.168.3.0/24 proto tcp to any port 443</p>
			<p class="source-code">ufw allow from 192.168.3.0/24 proto udp to any port 53</p>
			<p>For port forwarding, we need<a id="_idIndexMarker187"/> to edit the <strong class="source-inline">/etc/ufw/before.rules</strong> file and add<a id="_idIndexMarker188"/> the following configuration options before the <strong class="source-inline">*filter</strong> section:</p>
			<p class="source-code">*nat</p>
			<p class="source-code">:PREROUTING ACCEPT [0:0]</p>
			<p class="source-code">-A PREROUTING -p tcp --dport 900 -j REDIRECT --to-port 9090</p>
			<p class="source-code">COMMIT</p>
			<p>We can now check the status of our work by using the <strong class="source-inline">ufw</strong> and <strong class="source-inline">iptables</strong> commands:</p>
			<div>
				<div id="_idContainer080" class="IMG---Figure">
					<img src="Images/Figure_4.12_B16269.jpg" alt="Figure 4.12 – ufw status verbose after all the added rules&#13;&#10;" width="1318" height="905"/>
				</div>
			</div>
			<p class="figure-caption">Figure 4.12 – ufw status verbose after all the added rules</p>
			<p>We need to add two configuration<a id="_idIndexMarker189"/> options to <strong class="source-inline">ufw</strong> configuration for masquerading<a id="_idIndexMarker190"/> to work. First, we need to change the default policy for forwarding in the <strong class="source-inline">/etc/default/ufw</strong> file. It's set to <strong class="source-inline">DROP</strong> by default. We just need to change it to <strong class="source-inline">ACCEPT</strong>. It's at the beginning of this file, so the end result should look like this:</p>
			<p class="source-code">DEFAULT_FORWARD_POLICY="ACCEPT"</p>
			<p>This is rather than looking like this:</p>
			<p class="source-code">DEFAULT_FORWARD_POLICY="DROP"</p>
			<p>The next configuration option is actually in the same file that we previously edited, <strong class="source-inline">/etc/ufw/before.rules</strong>. We need to add one additional part to the <strong class="source-inline">*nat</strong> section called the <strong class="source-inline">POSTROUTING</strong> subsection, to the same place that we used before. So, similar to the previous example, we need to add the following configuration options, again before the <strong class="source-inline">*filter</strong> section:</p>
			<p class="source-code">*nat</p>
			<p class="source-code">:POSTROUTING ACCEPT [0:0]</p>
			<p class="source-code">-A POSTROUTING -o ens33 -j MASQUERADE</p>
			<p class="source-code">COMMIT</p>
			<p>The last part of the <strong class="source-inline">ufw</strong> configuration<a id="_idIndexMarker191"/> is making sure that the kernel<a id="_idIndexMarker192"/> knows that it needs to turn on <strong class="source-inline">ip</strong> forwarding. For that to happen, we need to edit a file called <strong class="source-inline">/etc/ufw/sysctl.conf</strong> and uncomment the following configuration option by removing the comment mark (<strong class="source-inline">#</strong>) before it:</p>
			<p class="source-code">net/ipv4/ip_forward=1</p>
			<p>This changes a value in the <strong class="source-inline">/proc</strong> filesystem, in a file called <strong class="source-inline">/proc/sys/net/ipv4/ip_forward</strong>. If we want to make sure that it works even without rebooting the machine, we need to issue the following command, as well:</p>
			<p class="source-code">echo "1" &gt; /proc/sys/net/ipv4/ip_forward</p>
			<p>That will enable IP forwarding on the kernel level and enable us to use masquerading in <strong class="source-inline">ufw</strong>. Let's now check the end result:</p>
			<div>
				<div id="_idContainer081" class="IMG---Figure">
					<img src="Images/Figure_4.13_B16269.jpg" alt="Figure 4.13 – ufw ruleset after configuring masquerading&#13;&#10;" width="1314" height="935"/>
				</div>
			</div>
			<p class="figure-caption">Figure 4.13 – ufw ruleset after configuring masquerading</p>
			<p>If we need to remove<a id="_idIndexMarker193"/> any of these configuration options, it's going to be done<a id="_idIndexMarker194"/> in two parts:</p>
			<ul>
				<li>Configuration options that we added to files directly via the editor will need to be removed via the editor.</li>
				<li>Configuration options that we added by using the <strong class="source-inline">ufw</strong> command can be easily reversed by using ufw's rule indexing.</li>
			</ul>
			<p>Let's type in the command <strong class="source-inline">ufw status numbered</strong>. This is the expected result:</p>
			<div>
				<div id="_idContainer082" class="IMG---Figure">
					<img src="Images/Figure_4.14_B16269.jpg" alt="Figure 4.14 – ufw ruleset indexed by number&#13;&#10;" width="882" height="422"/>
				</div>
			</div>
			<p class="figure-caption">Figure 4.14 – ufw ruleset indexed by number</p>
			<p>We can see that every rule that we punched<a id="_idIndexMarker195"/> in has a number attached to it. Rules 8 and 9 are rules<a id="_idIndexMarker196"/> for ports <strong class="source-inline">900</strong> and <strong class="source-inline">9090</strong> that were automatically added for the IPv4 and IPv6 stack. We can remove all of these rules easily by using the numbers attached to them. The thing is, <strong class="source-inline">ufw</strong> doesn't have a mechanism for deleting multiple rules one by one, so we would need to delete them one by one, something like this:</p>
			<p class="source-code">ufw delete 9 </p>
			<p class="source-code">&lt;confirm by pressing y&gt;</p>
			<p class="source-code">ufw delete 8 </p>
			<p class="source-code">&lt;confirm by pressing y&gt;</p>
			<p class="source-code">....</p>
			<p class="source-code">ufw delete 1</p>
			<p class="source-code">&lt;confirm by pressing y&gt;</p>
			<p>Yes, we could've simplified this with a <strong class="source-inline">for</strong> loop, something like this:</p>
			<p class="source-code">for i in {9..1};do yes|ufw delete $i;done</p>
			<p>But shell scripting and using loops is yet to come in this book so... let's treat this as an <em class="italic">example in advance</em>.</p>
			<p>Let's now explain<a id="_idIndexMarker197"/> how all of this works – firewalld<a id="_idIndexMarker198"/> zones, rich rules, <strong class="source-inline">ufw</strong> syntax – so that we can get an understanding of the background services and capabilities making it happen.</p>
			<p class="callout-heading">Note</p>
			<p class="callout"><strong class="source-inline">Firewalld</strong> is available on Ubuntu, as well. It just needs to be installed, enabled, started, and configured, and the opposite needs to be done to <strong class="source-inline">ufw</strong>. If you're more prone to using <strong class="source-inline">firewalld</strong>, we suggest that you try doing that as it's easy and won't take much of your time.</p>
			<h2 id="_idParaDest-86"><a id="_idTextAnchor087"/>How it works</h2>
			<p>There's a fundamental difference between <strong class="source-inline">ufw</strong> and <strong class="source-inline">firewalld</strong>, with <strong class="source-inline">ufw</strong> basically being just a frontend to <strong class="source-inline">iptables</strong>, while <strong class="source-inline">firewalld</strong> is much more dynamic, having the capability to work with zones to which we can assign various trust levels. The syntax is also different, <strong class="source-inline">ufw</strong> being a bit more namespace-based while <strong class="source-inline">firewalld</strong> requires a bit more effort in terms of rule typing. But, at the same time, <strong class="source-inline">firewalld</strong> has a D-Bus interface, which makes configuration easier in terms of applications, services, and users making configuration changes, on top of the fact that we don't have to restart the firewall for every change to take effect. It also interacts well with NetworkManager and <strong class="source-inline">nmcli</strong>, <strong class="source-inline">libvirt</strong>, Docker, and Podman, and other utilities such as fail2ban (although fail2ban works with <strong class="source-inline">iptables</strong> just as well). Sometimes it's a matter of preference; sometimes it's habits. Generally speaking, if you're more of an Ubuntu/Debian user, you're probably going to be more inclined to use <strong class="source-inline">ufw</strong>. By the same token, if you're more of a CentOS/Red Hat/Fedora/*SuSe user, you'll definitely be more inclined to use <strong class="source-inline">firewalld</strong>.</p>
			<p>Firewalld's concept of using zones, to which we can assign network interfaces or IP addresses, is certainly useful, as it gives us much more freedom in terms of configuration. If we type in the <strong class="source-inline">firewall-cmd --get-zones command</strong>, we'll see the list of available zones at that point in time:</p>
			<div>
				<div id="_idContainer083" class="IMG---Figure">
					<img src="Images/Figure_4.15_B16269.jpg" alt="Figure 4.15 – Default firewalld zones&#13;&#10;" width="1089" height="63"/>
				</div>
			</div>
			<p class="figure-caption">Figure 4.15 – Default firewalld zones</p>
			<p>By default, <strong class="source-inline">firewalld</strong> is configured in the <em class="italic">deny everything, add exceptions</em> manner, again, for ease of use. We can use<a id="_idIndexMarker199"/> it to allow or deny connections<a id="_idIndexMarker200"/> based on ports, IP addresses, subnets, and services, which enables us to do everything we need to do, in terms of host-based firewall functionality. It also has a concept called rich rules (as shown in our examples in this recipe), that enables us to create complex rules with intricate levels of granularity. These rules can be based on source address, destination address, ports, protocols, services, port forwarding, and masquerade per subnet. They can be used for rate limiting, which allows us to set the number of accepted SSH connections to 5 or 10 per minute to make it much harder to do SSH brute force attacks on our Linux servers. All in all, it's a very well-thought-out and feature-rich firewall that's free for us to use. We just need to configure it.</p>
			<p><strong class="source-inline">ufw</strong>, being just a frontend of <strong class="source-inline">iptables</strong> – or, as people usually describe it, a command-line interface for <strong class="source-inline">iptables</strong> – is less feature-packed, but is definitely easier to configure, at least for the most commonly used scenarios. Its command-line interface is more human-readable (less complex) and easier to learn. Seeing that it's just a frontend for <strong class="source-inline">iptables</strong>, it's basically a user-space utility that manages Linux kernel filtering rules provided by the netfilter module stack.</p>
			<p>Now that we have discussed some key concepts in Linux firewalling, it's time to move on to our next recipe, which is about checking open ports and connections. Let's see what that's all about.</p>
			<h2 id="_idParaDest-87"><a id="_idTextAnchor088"/>There's more</h2>
			<p>If you need<a id="_idIndexMarker201"/> to learn more about <strong class="source-inline">firewalld</strong> and <strong class="source-inline">ufw</strong>, we recommend<a id="_idIndexMarker202"/> the following links:</p>
			<ul>
				<li><strong class="source-inline">firewall-cmd</strong>: <a href="https://firewalld.org/documentation/man-pages/firewall-cmd.html%0D">https://firewalld.org/documentation/man-pages/firewall-cmd.html</a></li>
				<li>A beginner's guide<a id="_idIndexMarker203"/> to <strong class="source-inline">firewalld</strong> in Linux: <a href="https://www.redhat.com/sysadmin/beginners-guide-firewalld%0D">https://www.redhat.com/sysadmin/beginners-guide-firewalld</a></li>
				<li><strong class="source-inline">firewalld</strong> rich<a id="_idIndexMarker204"/> language: <a href="https://firewalld.org/documentation/man-pages/firewalld.richlanguage.html%0D">https://firewalld.org/documentation/man-pages/firewalld.richlanguage.html</a></li>
				<li><strong class="source-inline">ufw</strong>: <a href="https://help.ubuntu.com/community/UFW%0D">https://help.ubuntu.com/community/UFW</a></li>
			</ul>
			<h1 id="_idParaDest-88"><a id="_idTextAnchor089"/>Working with open ports and connections</h1>
			<p>Checking open ports<a id="_idIndexMarker205"/> on our local and/or remote machine is often part of security<a id="_idIndexMarker206"/> and configuration auditing processes. It's something that we use to check if we can connect to some remote ports to verify that a service works, whether a firewall is configured properly, or whether routing works – just regular, everyday tasks. Of course, it can also be a part of some hacking processes, which often start by using <strong class="source-inline">nmap</strong> and similar utilities to check for open ports and OS fingerprints. But, let's check how we can use utilities such as <strong class="source-inline">netstat</strong>, <strong class="source-inline">lsof</strong>, <strong class="source-inline">ss</strong>, and <strong class="source-inline">nmap</strong> to do good for our network and security.</p>
			<h2 id="_idParaDest-89"><a id="_idTextAnchor090"/>Getting ready</h2>
			<p>Keep the client1 virtual machine powered on and let's continue using our shell. Generally speaking, if we're doing this on Ubuntu, we need to install some packages such as <strong class="source-inline">traceroute</strong> and <strong class="source-inline">nmap</strong> using <strong class="source-inline">apt-get</strong>:</p>
			<p class="source-code">apt-get -y install traceroute nmap</p>
			<p>If, however, we are using CentOS, we need to use <strong class="source-inline">yum</strong> or <strong class="source-inline">dnf</strong>:</p>
			<p class="source-code">yum -y install traceroute nmap</p>
			<p>After that, we are ready for our recipe.</p>
			<h2 id="_idParaDest-90"><a id="_idTextAnchor091"/>How to do it</h2>
			<p>Let's first learn the usual ways of checking which ports and sockets are opened on our local Linux machine, starting with the <strong class="source-inline">netstat</strong> command. Yes, it's a common thing to check the routing table with <strong class="source-inline">netstat</strong> (the <strong class="source-inline">netstat -rn</strong> command), but we can also learn many more interesting details about our local Linux machine by using it in a different way. First, let's check all opened connections and ports by using the <strong class="source-inline">netstat -a</strong> command:</p>
			<div>
				<div id="_idContainer084" class="IMG---Figure">
					<img src="Images/Figure_4.16_B16269.jpg" alt="Figure 4.16 – A part of the netstat -a output – the result is much longer so we stripped it a bit for formatting reasons&#13;&#10;" width="1362" height="656"/>
				</div>
			</div>
			<p class="figure-caption">Figure 4.16 – A part of the netstat -a output – the result is much longer so we stripped it a bit for formatting reasons</p>
			<p>A lot of details are here. Let's see if we can<a id="_idIndexMarker207"/> format that a bit better. First, let's show<a id="_idIndexMarker208"/> all opened TCP ports by using the <strong class="source-inline">netstat -atp</strong> command:</p>
			<div>
				<div id="_idContainer085" class="IMG---Figure">
					<img src="Images/Figure_4.17_B16269.jpg" alt="Figure 4.17 – netstat with the TCP port list&#13;&#10;" width="1380" height="163"/>
				</div>
			</div>
			<p class="figure-caption">Figure 4.17 – netstat with the TCP port list</p>
			<p>Then, let's show the same thing, but for opened UDP ports, by using the <strong class="source-inline">netstat -aup</strong> command:</p>
			<div>
				<div id="_idContainer086" class="IMG---Figure">
					<img src="Images/Figure_4.18_B16269.jpg" alt="Figure 4.18 – netstat with the UDP port list&#13;&#10;" width="1374" height="119"/>
				</div>
			</div>
			<p class="figure-caption">Figure 4.18 – netstat with the UDP port list</p>
			<p>We can also show a subset of the information above in terms of listening ports (a port that an application or process is listening on). That's what<a id="_idIndexMarker209"/> the <strong class="source-inline">netstat -l</strong> command<a id="_idIndexMarker210"/> is all about:</p>
			<div>
				<div id="_idContainer087" class="IMG---Figure">
					<img src="Images/Figure_4.19_B16269.jpg" alt="Figure 4.19 – Checking listening ports via netstat&#13;&#10;" width="1357" height="950"/>
				</div>
			</div>
			<p class="figure-caption">Figure 4.19 – Checking listening ports via netstat</p>
			<p>We can do similar things with <strong class="source-inline">ss</strong> and <strong class="source-inline">lsof</strong>. Let's first use <strong class="source-inline">ss</strong>:</p>
			<div>
				<div id="_idContainer088" class="IMG---Figure">
					<img src="Images/Figure_4.20_B16269.jpg" alt="Figure 4.20 – Checking active connections via ss&#13;&#10;" width="1386" height="326"/>
				</div>
			</div>
			<p class="figure-caption">Figure 4.20 – Checking active connections via ss</p>
			<p>Next on our list is <strong class="source-inline">lsof</strong>, a command that can be used to determine which files are being opened by their corresponding processes:</p>
			<div>
				<div id="_idContainer089" class="IMG---Figure">
					<img src="Images/Figure_4.21_B16269.jpg" alt="Figure 4.21 – The same idea as ss, but with more details about actual commands/services using ports&#13;&#10;" width="1254" height="154"/>
				</div>
			</div>
			<p class="figure-caption">Figure 4.21 – The same idea as ss, but with more details about actual commands/services using ports</p>
			<p>The options<a id="_idIndexMarker211"/> that we used are<a id="_idIndexMarker212"/> as follows:</p>
			<ul>
				<li><strong class="source-inline">-n</strong> for using port numbers, not port names</li>
				<li><strong class="source-inline">-P</strong> for using numerical addresses, without DNS resolving</li>
				<li><strong class="source-inline">-iTCP</strong> <strong class="source-inline">-sTCP:LISTEN</strong> to show only files that have an opened port in the TCP state <strong class="source-inline">LISTEN</strong></li>
			</ul>
			<p>Then, if we wanted to narrow that down to a specific TCP port – for example, port <strong class="source-inline">22</strong> – we could use a command such as <strong class="source-inline">lsof -nP -iTCP:22 -sTCP:LISTEN</strong>:</p>
			<div>
				<div id="_idContainer090" class="IMG---Figure">
					<img src="Images/Figure_4.22_B16269.jpg" alt="Figure 4.22 – Narrowing the lsof output to TCP port 22 only&#13;&#10;" width="936" height="123"/>
				</div>
			</div>
			<p class="figure-caption">Figure 4.22 – Narrowing the lsof output to TCP port 22 only</p>
			<p>If we need to check opened ports specified by port range, <strong class="source-inline">lsof</strong> allows that, by using the <strong class="source-inline">lsof -i</strong> option. For example, let's use that on port range <strong class="source-inline">22</strong> to <strong class="source-inline">1000</strong>:</p>
			<div>
				<div id="_idContainer091" class="IMG---Figure">
					<img src="Images/Figure_4.23_B16269.jpg" alt="Figure 4.23 – lsof by port range&#13;&#10;" width="1304" height="183"/>
				</div>
			</div>
			<p class="figure-caption">Figure 4.23 – lsof by port range</p>
			<p>Now that we've used some commands on our local machine, let's turn our attention to remote machines and discuss how to find open ports on them, as well as other information<a id="_idIndexMarker213"/> that might be necessary. For that, we are going<a id="_idIndexMarker214"/> to use the <strong class="source-inline">nmap</strong> command. Let's first use client1 (IP address <strong class="source-inline">192.168.1.1</strong>) to scan <strong class="source-inline">server1</strong> (IP address <strong class="source-inline">192.168.1.254</strong>). <strong class="source-inline">server1</strong> is just a vanilla CentOS 8 installation, as explained in the last recipe of this chapter. </p>
			<p>First, let's do a general scan, by using the <strong class="source-inline">nmap 192.168.1.254</strong> command:</p>
			<div>
				<div id="_idContainer092" class="IMG---Figure">
					<img src="Images/Figure_4.24_B16269.jpg" alt="Figure 4.24 – Using nmap on a single IP address&#13;&#10;" width="1013" height="325"/>
				</div>
			</div>
			<p class="figure-caption">Figure 4.24 – Using nmap on a single IP address</p>
			<p>If we wanted a bit more verbosity, we could've added the <strong class="source-inline">-v</strong> option before or after the IP address, as well. Still, we can see that the remote IP address has a couple of open TCP ports. Let's try to find some more information, by initiating <strong class="source-inline">nmap</strong> with the <strong class="source-inline">-A</strong> option (OS information scan):</p>
			<div>
				<div id="_idContainer093" class="IMG---Figure">
					<img src="Images/Figure_4.25_B16269.jpg" alt="Figure 4.25 – More detailed version of the previous nmap session&#13;&#10;" width="1369" height="713"/>
				</div>
			</div>
			<p class="figure-caption">Figure 4.25 – More detailed version of the previous nmap session</p>
			<p>We can see even<a id="_idIndexMarker215"/> more details on this<a id="_idIndexMarker216"/> output. If we just wanted to do OS fingerprinting, we could've used the <strong class="source-inline">-O</strong> option:</p>
			<div>
				<div id="_idContainer094" class="IMG---Figure">
					<img src="Images/Figure_4.26_B16269.jpg" alt="Figure 4.26 – nmap OS fingerprinting&#13;&#10;" width="1311" height="497"/>
				</div>
			</div>
			<p class="figure-caption">Figure 4.26 – nmap OS fingerprinting</p>
			<p>We could also scan<a id="_idIndexMarker217"/> for various other things, such <a id="_idIndexMarker218"/>as the following:</p>
			<ul>
				<li>Specific TCP ports – <strong class="source-inline">nmap -p T:9090,22 192.168.1.254</strong></li>
				<li>Specific UDP ports – <strong class="source-inline">nmap -sU 53 192.168.1.254</strong></li>
				<li>Scan port range – <strong class="source-inline">nmap -p 22-2000 192.168.1.254</strong></li>
				<li>Find remote host service versions – <strong class="source-inline">nmap -sV 192.168.1.254</strong></li>
				<li>Scan a subnet – <strong class="source-inline">nmap 192.168.1.*</strong></li>
				<li>Scan multiple hosts – <strong class="source-inline">nmap 192.168.1.252,253,254</strong></li>
				<li>Scan a complete IP range – <strong class="source-inline">nmap 192.168.1.1-254</strong></li>
			</ul>
			<p>Let's now discuss how these four utilities work and wrap this recipe up.</p>
			<h2 id="_idParaDest-91"><a id="_idTextAnchor092"/>How it works</h2>
			<p><strong class="source-inline">netstat</strong>, <strong class="source-inline">ss</strong>, and <strong class="source-inline">lsof</strong> are kind of similar, yet have their differences. The usual way in which people use <strong class="source-inline">netstat</strong> is just to check their routing table. But, having said that, by default, <strong class="source-inline">netstat</strong> is a tool that gives us a list of opened TCP sockets/UDP connections on the network layer. <strong class="source-inline">lsof</strong>, on the other hand, lists open files (kernel-level functionality), but it's also capable of determining which processes are using those opened files. Keep in mind that, in Unix operating systems, almost everything is a file, which also includes objects such as network sockets. As such, <strong class="source-inline">lsof</strong> is often used when dealing with security aspects of our Linux systems, as it obviously gives many more technical details when compared to <strong class="source-inline">netstat</strong>.</p>
			<p><strong class="source-inline">ss</strong>, as an alternative to <strong class="source-inline">netstat</strong>, can be used to work with network information and statistics, which makes it kind of similar to <strong class="source-inline">netstat</strong>. It can be used to get details about network connections, sockets, statistical data, TCP state filtering, connections to and from specific IP addresses, and so on. And, not to be forgotten, <strong class="source-inline">ss</strong> is quite a bit simpler to use, and when you compare man page sizes of <strong class="source-inline">netstat</strong> and <strong class="source-inline">ss</strong>, you'll see the difference there as well. </p>
			<p><strong class="source-inline">nmap</strong>, on the other hand, is completely different from all of these commands. It's a tool that's aimed much more broadly in terms of functionality – it can scan both local and remote hosts, domains, IP ranges, and ports. It's a regular network scanner, with all the good and the bad that comes with it, as people both love and dislike it – love using it, dislike being the target of it. It works by establishing connections to remote IP addresses and ports, sending<a id="_idIndexMarker219"/> them information and gathering output from them<a id="_idIndexMarker220"/> to get information. Therefore, it's a perfect tool to do security scanning and auditing as it's able to find open ports and report the fact that there are open ports. It's also heavily used to search for certain security issues. </p>
			<h2 id="_idParaDest-92"><a id="_idTextAnchor093"/>There's more</h2>
			<p>If you need to learn<a id="_idIndexMarker221"/> more about <strong class="source-inline">netstat</strong>, <strong class="source-inline">lsof</strong>, <strong class="source-inline">ss</strong>, and <strong class="source-inline">nmap</strong>, make sure that you check the following links:</p>
			<ul>
				<li><strong class="source-inline">nmap</strong> documentation: <a href="https://nmap.org/docs.html%0D">https://nmap.org/docs.html</a></li>
				<li><strong class="source-inline">netstat</strong> man<a id="_idIndexMarker222"/> page: <a href="https://man7.org/linux/man-pages/man8/netstat.8.html%0D">https://man7.org/linux/man-pages/man8/netstat.8.html</a></li>
				<li><strong class="source-inline">lsof</strong> man<a id="_idIndexMarker223"/> page: <a href="https://man7.org/linux/man-pages/man8/lsof.8.html%0D">https://man7.org/linux/man-pages/man8/lsof.8.html</a></li>
				<li><strong class="source-inline">ss</strong> man<a id="_idIndexMarker224"/> page: <a href="https://man7.org/linux/man-pages/man8/ss.8.html%0D">https://man7.org/linux/man-pages/man8/ss.8.html</a></li>
			</ul>
			<h1 id="_idParaDest-93"><a id="_idTextAnchor094"/>Configuring /etc/hosts and DNS resolving</h1>
			<p>Name resolution<a id="_idIndexMarker225"/> is an essential part of any operating system, specifically its networking<a id="_idIndexMarker226"/> stack. Generally speaking, operating systems have multiple different ways of making DNS queries – usually, it involves some kind of <strong class="source-inline">hosts</strong> file, caches, and – of course – network interface configuration. Let's go through the configuration capabilities of <strong class="source-inline">/etc/hosts</strong> and see how that fits in the grand scheme of name resolution.</p>
			<h2 id="_idParaDest-94"><a id="_idTextAnchor095"/>Getting ready</h2>
			<p>Keep the CLI1 virtual machine powered on and let's discuss how to work with name resolution in general, using <strong class="source-inline">/etc/hosts</strong> (a file that we can fill with hostnames and IP addresses for local resolving) and <strong class="source-inline">/etc/resolv.conf</strong> (a file that determines which DNS servers are being used for network resolving, and which domain is the Linux server a part of) as integral parts of that process. When editing <strong class="source-inline">/etc/hosts</strong> or <strong class="source-inline">/etc/resolv.conf</strong>, we have to be logged in as root or use <strong class="source-inline">sudo</strong>, as this is a system-wide operation that's only allowed<a id="_idIndexMarker227"/> to administrative users. The way in which the name resolution process<a id="_idIndexMarker228"/> works changed years ago as <strong class="source-inline">systemd</strong> took over from <strong class="source-inline">init</strong> and <strong class="source-inline">upstart</strong>, and introduced a service called <strong class="source-inline">systemd-resolved</strong>. On top of this, the configuration is different on Ubuntu when compared to CentOS. So, let's dig into all of that and explain what's going on.</p>
			<h2 id="_idParaDest-95"><a id="_idTextAnchor096"/>How to do it</h2>
			<p>Let's first take care of Ubuntu, then we'll switch to CentOS. This is the default <strong class="source-inline">/etc/resolv.conf</strong> file from our Ubuntu CLI1 machine:</p>
			<div>
				<div id="_idContainer095" class="IMG---Figure">
					<img src="Images/Figure_4.27_B16269.jpg" alt="Figure 4.27 – Default /etc/resolv.conf file&#13;&#10;" width="1163" height="528"/>
				</div>
			</div>
			<p class="figure-caption">Figure 4.27 – Default /etc/resolv.conf file</p>
			<p>As we can see, this file is mostly commented out (the <strong class="source-inline">#</strong> sign in config files equals a Unix shell-style comment, so these lines are omitted in terms of configuration). We only have two configuration lines, which are a by-product of running the systemd-resolved service (a local service that provides resolving capabilities for DNS, DNS over TLS, DNSSEC, mDNS, and so on), as well as using the netplan service by default:</p>
			<p class="source-code">nameserver 127.0.0.53</p>
			<p class="source-code">options edns0 trust-ad</p>
			<p>There are two approaches to <strong class="source-inline">resolv.conf</strong> configuration:</p>
			<ul>
				<li>We say that we want to stick with systemd-resolved and configure our system that way (and <strong class="source-inline">127.0.0.53</strong> is actually the loopback IP address that systemd-resolved binds to).</li>
				<li>We say that we don't want systemd-resolved and we want to go back to the <em class="italic">old way</em> of configuring our system, which means installing a package called <strong class="source-inline">resolvconf</strong>. That will give us the capability to configure <strong class="source-inline">/etc/resolv.conf</strong> and <strong class="source-inline">/etc/hosts</strong> as they were always configured and not rely on systemd-resolved making changes to <strong class="source-inline">/etc/resolv.conf</strong> on the fly (most of us usually don't want this).</li>
			</ul>
			<p>Let's start with the first approach<a id="_idIndexMarker229"/> and then move to the second approach as a lot of us Linux administrators<a id="_idIndexMarker230"/> are more prone to using our old-school ways and we find it easier for things to be configured the way they have always been configured since the dawn of Unix time. </p>
			<p>If we are using systemd-resolved, we need to mention a couple of files. The first file that we need to mention is <strong class="source-inline">/run/systemd/resolve/stub-resolv.conf</strong> – this is a file that's actually linked to <strong class="source-inline">/etc/resolv.conf</strong> when systemd-resolved is being used. This file is used for maintaining compatibility with old Linux programs that were exclusively using the old way (<strong class="source-inline">/etc/resolv.conf</strong>, <strong class="source-inline">/etc/hosts</strong>) to get access to name resolution information. If we want to permanently set DNS servers to be used, we need to do it via <strong class="source-inline">systemd</strong>. So, let's go to the second file that we need to discuss. It's located in the <strong class="source-inline">/etc/systemd</strong> directory, and it's called <strong class="source-inline">resolved.conf</strong>. At the beginning of this file, there's a <strong class="source-inline">[Resolve]</strong> section that's completely commented out. Let's change it to this:</p>
			<p class="source-code">[Resolve]</p>
			<p class="source-code">DNS = 8.8.8.8 8.8.4.4</p>
			<p class="source-code">FallBackDNS = 1.1.1.1</p>
			<p class="source-code">Domains =domain.local</p>
			<p>The first and second lines set the main and fallback DNS addresses, while the third line sets the default domain that we're querying.</p>
			<p>After we do this change, we need to restart the <strong class="source-inline">systemd-resolved</strong> service, which we can do with the following command:</p>
			<p class="source-code">systemctl restart systemd-resolved</p>
			<p>We can check if our changes<a id="_idIndexMarker231"/> have been applied by using <strong class="source-inline">systemd-resolve --status</strong>, which should, in accordance with<a id="_idIndexMarker232"/> our changes, give us output similar to this one:</p>
			<div>
				<div id="_idContainer096" class="IMG---Figure">
					<img src="Images/Figure_4.28_B16269.jpg" alt="Figure 4.28 – Checking the systemd-resolved status&#13;&#10;" width="684" height="874"/>
				</div>
			</div>
			<p class="figure-caption">Figure 4.28 – Checking the systemd-resolved status</p>
			<p>Let's now check how the DNS<a id="_idIndexMarker233"/> cache works – for example, we type in the following<a id="_idIndexMarker234"/> commands:</p>
			<p class="source-code">nslookup index.hr</p>
			<p class="source-code">nslookup planetf1.com</p>
			<p>We did this so that we can check the DNS cache, as the DNS cache first needs to be filled with some data at least. If we want to check the state of the <strong class="source-inline">systemd-resolved</strong> cache, we can do it with two commands:</p>
			<p class="source-code">killall -USR1 systemd-resolved</p>
			<p class="source-code">journalctl -u systemd-resolved &gt; cache.txt</p>
			<p>The first command doesn't kill <strong class="source-inline">systemd-resolved</strong> but tells it to write available entries in the DNS cache. The second command exports entries to a file called <strong class="source-inline">cache.txt</strong> (it can be called whatever we want). When we check the content of that file for the string <strong class="source-inline">CACHE</strong>, we're going to see entries similar to this:</p>
			<div>
				<div id="_idContainer097" class="IMG---Figure">
					<img src="Images/Figure_4.29_B16269.jpg" alt="Figure 4.29 – Checking the DNS cache&#13;&#10;" width="1383" height="416"/>
				</div>
			</div>
			<p class="figure-caption">Figure 4.29 – Checking the DNS cache</p>
			<p>This is correct – on our testing system, those are two entries that we searched for by using <strong class="source-inline">nslookup</strong>. If we want to flush the DNS cache, we can use the following command:</p>
			<p class="source-code">resolvectl flush-caches</p>
			<p>If you notice errors with DNS violations in the file, there was a problem during the system installation or upgrade – one that didn't set a symbolic link to <strong class="source-inline">resolv.conf</strong> properly. As a result of that problem, the symbolic link was created to the wrong file (<strong class="source-inline">stub-resolv.conf</strong>) instead of the actual file <strong class="source-inline">(/run/systemd/resolve/resolv.conf</strong>). We can mitigate that issue by using the following commands:</p>
			<p class="source-code">mv /etc/resolv.conf /etc/resolv.conf.old</p>
			<p class="source-code">ln -s /run/systemd/resolve/resolv.conf /etc/resolv.conf</p>
			<p class="source-code">systemctl restart systemd-resolved</p>
			<p>Now, let's try the second<a id="_idIndexMarker235"/> approach, which is quite a bit more simple. So, if we wanted<a id="_idIndexMarker236"/> to get rid of all of this <strong class="source-inline">systemd-resolved</strong> configuration and just use a good old administration process via <strong class="source-inline">resolv.conf</strong> without all of this additional hassle, we could do that easily. So, let's first install the necessary package: </p>
			<p class="source-code">apt-get -y install resolvconf</p>
			<p class="source-code">systemctl stop systemd-resolved</p>
			<p class="source-code">systemctl disable systemd-resolved</p>
			<p class="source-code">systemctl mask systemd-resolved</p>
			<p>Next, let's do a bit of configuration. Let's open the <strong class="source-inline">/etc/resolv.conf</strong> file and make it look like this (the commented part is not important, start with the <strong class="source-inline">nameserver</strong> part):</p>
			<div>
				<div id="_idContainer098" class="IMG---Figure">
					<img src="Images/Figure_4.30_B16269.jpg" alt="Figure 4.30 – The resolv.conf configuration&#13;&#10;" width="1377" height="320"/>
				</div>
			</div>
			<p class="figure-caption">Figure 4.30 – The resolv.conf configuration</p>
			<p>Let's check if this configuration works:</p>
			<div>
				<div id="_idContainer099" class="IMG---Figure">
					<img src="Images/Figure_4.31_B16269.jpg" alt="Figure 4.31 – Checking if DNS resolution works&#13;&#10;" width="626" height="621"/>
				</div>
			</div>
			<p class="figure-caption">Figure 4.31 – Checking if DNS resolution works</p>
			<p>No problem whatsoever, right? Of course, we used <strong class="source-inline">8.8.8.8</strong>, <strong class="source-inline">8.8.4.4</strong>, and <strong class="source-inline">1.1.1.1</strong> as examples for DNS<a id="_idIndexMarker237"/> servers here – this needs to be configured so that it's valid<a id="_idIndexMarker238"/> for the environment where our Linux server is actually running.</p>
			<p>Working with the DNS cache requires a bit of extra effort. First, we need to deploy two additional packages – <strong class="source-inline">nscd</strong> (the service that does the caching), and <strong class="source-inline">binutils</strong> (this package contains a command called <strong class="source-inline">strings</strong>, which we'll use to check string content in a binary file):</p>
			<p class="source-code">apt-get -y install nscd binutils</p>
			<p class="source-code">strings /var/cache/nscd/hosts</p>
			<p>The output of the second command should look similar to this:</p>
			<div>
				<div id="_idContainer100" class="IMG---Figure">
					<img src="Images/Figure_4.32_B16269.jpg" alt="Figure 4.32 – Checking the nscd cache&#13;&#10;" width="777" height="473"/>
				</div>
			</div>
			<p class="figure-caption">Figure 4.32 – Checking the nscd cache</p>
			<p>If we need to clear the <strong class="source-inline">nscd</strong> <strong class="source-inline">hosts</strong> cache, we can use the following commands:</p>
			<p class="source-code">nscd -i hosts</p>
			<p>or</p>
			<p class="source-code">systemctl restart nscd</p>
			<p>The first one just clears<a id="_idIndexMarker239"/> the hosts table, while the second one restarts the <strong class="source-inline">nscd</strong> service and, as a part<a id="_idIndexMarker240"/> of the process, clears the <strong class="source-inline">hosts</strong> table.</p>
			<p>And that brings us to the hosts table, and – luckily – it works the same on all Linux distributions. If we're in a situation where we just need to add some resolving capabilities without actually building up a DNS server via <strong class="source-inline">BIND</strong>, <strong class="source-inline">dnsmasq</strong>, or anything similar to that, using the <strong class="source-inline">hosts</strong> table seems like a reasonably simple thing to do. Let's say that we need to use temporary resolution for the following two hosts:</p>
			<p><strong class="source-inline">server1.domain.local </strong></p>
			<p><strong class="source-inline">server2.domain.local</strong></p>
			<p>Let's assume<a id="_idIndexMarker241"/> that these two servers' IP addresses are <strong class="source-inline">192.168.0.101</strong> and <strong class="source-inline">192.168.0.102</strong>. We'd add these entries<a id="_idIndexMarker242"/> to the <strong class="source-inline">/etc/hosts</strong> file by editing it and adding these entries to the bottom of the file:</p>
			<p><strong class="source-inline">192.168.0.101 server1.domain.local</strong></p>
			<p><strong class="source-inline">192.168.0.102 server2.domain.local</strong></p>
			<p>So, our <strong class="source-inline">/etc/hosts</strong> file should look like this:</p>
			<div>
				<div id="_idContainer101" class="IMG---Figure">
					<img src="Images/Figure_4.33_B16269.jpg" alt="Figure 4.33 – /etc/hosts file with additions&#13;&#10;" width="1085" height="440"/>
				</div>
			</div>
			<p class="figure-caption">Figure 4.33 – /etc/hosts file with additions</p>
			<p>If we now use a command such as <strong class="source-inline">ping</strong> to check if these hosts are alive, we will get the following result:</p>
			<div>
				<div id="_idContainer102" class="IMG---Figure">
					<img src="Images/Figure_4.34_B16269.jpg" alt="Figure 4.34 – ping not working&#13;&#10;" width="1197" height="406"/>
				</div>
			</div>
			<p class="figure-caption">Figure 4.34 – ping not working</p>
			<p>The <strong class="source-inline">^C</strong> character visible in this output is due to the fact that we used <em class="italic">Ctrl</em> + <em class="italic">C</em> to stop the ping process as these hosts don't actually exist on our network. But that's beside the point – the point of this was to test whether the name resolution works. In other words, does <strong class="source-inline">server1</strong> and <strong class="source-inline">server2.domain.local</strong> resolution work? And it does – we can clearly see that the <strong class="source-inline">ping</strong> command is trying to ping their IP addresses.</p>
			<p>We need to briefly discuss the way in which CentOS<a id="_idIndexMarker243"/> does these things, as it's a bit different from what Ubuntu<a id="_idIndexMarker244"/> does. By default, the latest couple of generations of CentOS use NetworkManager as the default service to configure a network. As a result, <strong class="source-inline">/etc/resolv.conf</strong> gets configured by NetworkManager by default, which is very important to note, especially in the most common use case – when our CentOS machine gets its IP address from the DHCP server. What happens if we need to configure custom DNS servers and we don't want to use the DNS servers that we got from our DHCP server?</p>
			<p>There are two basic ways to make sure that everything's configured correctly in CentOS:</p>
			<ul>
				<li>To configure everything via interface files</li>
				<li>To configure everything after the fact, by using the <strong class="source-inline">nmcli</strong> command</li>
			</ul>
			<p>Using configuration files is a hassle here, so let's just do the second thing – configure our DNS entries by using the <strong class="source-inline">nmcli</strong> command. Let's say that we want to assign <strong class="source-inline">8.8.8.8</strong>, <strong class="source-inline">8.8.4.4</strong>, and <strong class="source-inline">1.1.1.1</strong> as DNS servers for our CentOS server. Let's check our network interface name first:</p>
			<p class="source-code">nmcli con show</p>
			<p>Our system tells us that it's using the <strong class="source-inline">ens33</strong> network interface. Let's modify its settings by typing in the following commands:</p>
			<p class="source-code">nmcli con mod ens33 ipv4.ignore-auto-dns yes</p>
			<p class="source-code">nmcli con mod ens33 ipv4.dns "8.8.8.8 8.8.4.4 1.1.1.1"</p>
			<p class="source-code">systemctl restart NetworkManager</p>
			<p>The key aspect of this configuration is the first line – we're basically telling NetworkManager<a id="_idIndexMarker245"/> to quit automatically using the DNS server that it gets from the DHCP<a id="_idIndexMarker246"/> server. If we didn't want that, we could've just omitted that specific line.</p>
			<p>If we check the contents of our <strong class="source-inline">/etc/resolv.conf</strong> file, it should now look like this:</p>
			<div>
				<div id="_idContainer103" class="IMG---Figure">
					<img src="Images/Figure_4.35_B16269.jpg" alt="Figure 4.35 – /etc/resolv.conf configured correctly&#13;&#10;" width="554" height="144"/>
				</div>
			</div>
			<p class="figure-caption">Figure 4.35 – /etc/resolv.conf configured correctly</p>
			<p>And that's a wrap in terms of configuration – using both Ubuntu and CentOS. Let's now focus on how all of this works <em class="italic">under the hood</em>.</p>
			<h2 id="_idParaDest-96"><a id="_idTextAnchor097"/>How it works</h2>
			<p>There are two concepts that we need to dig into and explain. We need to understand how <strong class="source-inline">systemd-resolved</strong> works, and, of course, the opposite – how everything works when we remove <strong class="source-inline">systemd-resolved</strong> from the administrative equation, if you will. Having in mind that there was Linux before systemd and name resolution before <strong class="source-inline">systemd-resolved</strong>, let's start by explaining how the <em class="italic">old method</em> (pre-systemd-resolved) worked.</p>
			<p>The core concept was called the <strong class="bold">Name Service Switch</strong> (<strong class="bold">NSS</strong>). The basic idea behind NSS was to connect<a id="_idIndexMarker247"/> to various mechanisms – databases, files, services – to provide various services. Services such as authentication (<strong class="source-inline">/etc/passwd</strong>, <strong class="source-inline">/etc/shadow</strong>, and <strong class="source-inline">/etc/group</strong>), network configuration, and, of course, services such as name resolution (<strong class="source-inline">/etc/hosts</strong> and so on). Our focus will be solely on name resolution, which is why we need to discuss a configuration file, <strong class="source-inline">/etc/nsswitch.conf</strong>. Specifically, we will ignore all of the configuration options in that file and focus on one configuration line, which is usually similar to this:</p>
			<p class="source-code">hosts:      files dns</p>
			<p>This configuration line tells our name resolution system <em class="italic">how</em> to do its job. The <strong class="source-inline">files</strong> option means <em class="italic">check file /etc/hosts</em>, while the <strong class="source-inline">dns</strong> option means just that – use other network name resolution methods. But the important thing about this line is the <em class="italic">order</em>, which clearly states <em class="italic">files first, dns second</em>. This is the reason why – by default – Linux first checks the contents of the <strong class="source-inline">/etc/hosts</strong> file, and then starts issuing network name resolution calls (for example, <strong class="source-inline">nslookup</strong>) to get to the IP address of some server that we're trying to communicate<a id="_idIndexMarker248"/> with. We also have capabilities to store these entries<a id="_idIndexMarker249"/> in a database, and we can force NSS to access it to read the necessary data. For example, 20 years ago, when Active Directory and other LDAP-based directories weren't used so often, we used to use NIS/NIS+ a lot – to store user and similar data. We were also able to store host data in NIS/NIS+ databases (<strong class="source-inline">hosts.byname</strong> and <strong class="source-inline">hosts.byaddr</strong>). These maps were basically forward and reverse DNS tables, stored within an external service. That's why we can use the configuration option <strong class="source-inline">db</strong> in <strong class="source-inline">nsswitch.conf</strong>, although pretty much nobody uses that nowadays. </p>
			<p>When systemd took over name resolution (<strong class="source-inline">systemd-resolved</strong>), things changed, as we described in our last recipe. The whole point of <strong class="source-inline">systemd-resolved</strong> is to be able to better integrate with systemd and to offer support for some use cases that were – realistically – complicated without it. Stuff such as VPN connections, especially corporate ones, were a constant source of problems when using the old-style configuration. <strong class="source-inline">systemd-resolved</strong> tries to get around that stack of problems (and others) by introducing the capability to do split DNS, which is implemented by using DNS routing domains as a way of determining which DNS requests we're actually making. Please don't mistake this for IP-based ideas of subnet routing, VLAN routing, or anything of the sort – those are completely different concepts, based on completely different ideas. We're specifically talking about the DNS routing domain, which is nothing more than a term saying <em class="italic">let's determine which DNS server should be contacted for correct information about your DNS query</em>. This has nothing to do with the IP aspect of it, which is handled by using standard routing methods.</p>
			<p>Having split DNS is nothing new – it's something that a lot of us have been using for a decade or two. In short, split DNS means having some DNS servers assigned to internal connections and other DNS servers assigned to external connections. From an enterprise standpoint, if we connect via VPN connection to our workplace, a part of our DNS queries is aimed at internal infrastructure, while the other part should be headed to the external DNS servers hosted on the internet. Being able to implement this scenario in Linux also isn't something new – we could've easily done this with <strong class="source-inline">BIND</strong> more than a decade ago. But a way to do this as tightly integrated and as automatically as possible, especially on the client side – which is what <strong class="source-inline">systemd-resolved</strong> does – is actually something new. </p>
			<p>Let's imagine for a second that we have a Linux VPN server<a id="_idIndexMarker250"/> that we're connecting to by using a Linux machine<a id="_idIndexMarker251"/> as a VPN client. Let's say that these two systems both have multiple network interfaces in different subnets (a couple of physical network cards and a wireless network adapter for the VPN client). When we connect from our VPN client to the VPN server, how is the VPN client going to determine where to send DNS queries? Yes, it's going to use <strong class="source-inline">resolv.conf</strong>, but still, <strong class="source-inline">resolv.conf</strong> and <strong class="source-inline">systemd-resolved</strong> need to be configured correctly so that a name resolution request gets sent to the correct DNS server. If we have multiple subnets, and multiple domains (a larger enterprise, for example), things can get messy very quickly. This situation gets taken care of via NetworkManager/netplan's interaction with <strong class="source-inline">systemd-resolved</strong>. By using this interaction, we can have different DNS servers assigned to different network interfaces, that are assigned to multiple different domains. And that's a pretty smart way of dealing with potential VPN client problems. </p>
			<h2 id="_idParaDest-97"><a id="_idTextAnchor098"/>There's more</h2>
			<p>If we need to learn more about<a id="_idIndexMarker252"/> network name resolution, we can check the following links:</p>
			<ul>
				<li>What is DNS?: <a href="https://www.cloudflare.com/learning/dns/what-is-dns/%0D">https://www.cloudflare.com/learning/dns/what-is-dns/</a></li>
				<li>What is DNS?: <a href="https://aws.amazon.com/route53/what-is-dns/%0D">https://aws.amazon.com/route53/what-is-dns/</a></li>
				<li>NSCD man<a id="_idIndexMarker253"/> page, chapter 8: <a href="https://linux.die.net/man/8/nscd%0D">https://linux.die.net/man/8/nscd</a></li>
				<li><strong class="source-inline">systemd-resolved</strong><a id="_idIndexMarker254"/> man page: <a href="http://manpages.ubuntu.com/manpages/bionic/man8/systemd-resolved.service.8.html%0D">http://manpages.ubuntu.com/manpages/bionic/man8/systemd-resolved.service.8.html</a></li>
				<li><strong class="source-inline">resolved.conf</strong> man<a id="_idIndexMarker255"/> page: <a href="https://www.freedesktop.org/software/systemd/man/resolved.conf.html%0D">https://www.freedesktop.org/software/systemd/man/resolved.conf.html</a></li>
			</ul>
			<h1 id="_idParaDest-98"><a id="_idTextAnchor099"/>Using network diagnostic tools</h1>
			<p>Diagnosing problems<a id="_idIndexMarker256"/> with network connections is an everyday job for a seasoned system engineer. It doesn't necessarily happen because we have problems in our own network, it can be other factors. For example, sometimes our local network works, while the internet connection doesn't. Or, even worse, customers report that some of them are able to access the internet, while some others can't. How do we approach these situations and which tools should we use? That's what we will talk about in this recipe. So, get ready to talk about <strong class="source-inline">ping</strong>, <strong class="source-inline">route</strong>, <strong class="source-inline">netstat</strong>, <strong class="source-inline">tracepath</strong>, and similar commands – that's what they're there for!</p>
			<h2 id="_idParaDest-99"><a id="_idTextAnchor100"/>Getting ready</h2>
			<p>Let's install a CentOS virtual machine called <strong class="source-inline">server1</strong> and use our existing clients (an Ubuntu virtual machine called client1 and a CentOS virtual machine called client2) to work on this recipe. We are going to use client1 to simulate a situation where the server on our local network wants to access internal resources and/or the internet by using <strong class="source-inline">server1</strong> as a default gateway. We are going to use client2 to simulate a situation where our local client<a id="_idIndexMarker257"/> or wireless client wants to access internal resources and/or the internet by using <strong class="source-inline">server1</strong> as a default gateway. In order for us to be able to do that, we'll temporarily add another network interface to client2, so that we can have two network interfaces in two different subnets to simulate problems in our scenario. The <strong class="source-inline">server1</strong> virtual machine is just going to be a standard CentOS installation, but with four network interfaces. In our scenario, <strong class="source-inline">server1</strong>'s <strong class="source-inline">ens33</strong> network interface is going to be an external network interface, while network interfaces <strong class="source-inline">ens37</strong>, <strong class="source-inline">ens38</strong>, and <strong class="source-inline">ens39</strong> are going to be internal network interfaces.</p>
			<h2 id="_idParaDest-100"><a id="_idTextAnchor101"/>How to do it</h2>
			<p>Let's create a scenario here so that we can go through the whole process. For example, our colleagues from the company that we work for are reporting that they have problems accessing both internal resources (the company network) and external resources (the internet). The company that we're discussing has multiple network subnets:</p>
			<ul>
				<li><strong class="source-inline">192.168.1.0/24</strong> – This one is used for all of the server machines; we'll call this connection profile <strong class="source-inline">network1</strong> when we configure it via <strong class="source-inline">nmcli</strong>.</li>
				<li><strong class="source-inline">192.168.2.0/24</strong> – This one is used for all of the client machines; we'll call this connection profile <strong class="source-inline">network2</strong> when we configure it via <strong class="source-inline">nmcli</strong>.</li>
				<li><strong class="source-inline">192.168.3.0/24</strong> – This one is used for company wireless; we'll call this connection profile <strong class="source-inline">network3</strong> when we configure it via <strong class="source-inline">nmcli</strong>.</li>
			</ul>
			<p>The fourth network interface of our machine is going to act as our internet connection. As we mentioned in our second recipe in this chapter (<em class="italic">Using firewalld and ufw</em>), let's configure that virtual machine so that it allows connectivity for all three of these subnets to the internet and work from there.</p>
			<p>The first step will obviously be to allow internet access for these three subnets. Let's do that in the simplest<a id="_idIndexMarker258"/> fashion, by using <strong class="source-inline">firewalld</strong>. Specifically, we'll do that by adding these interfaces to the public zone. So, we need a couple of standard commands and configuration steps on <strong class="source-inline">server1</strong>:</p>
			<p class="source-code">echo "1" &gt; /proc/sys/net/ipv4/ip_forward</p>
			<p class="source-code">nmcli connection add con-name network1 ifname ens37 type ethernet ip4 192.168.1.254/24</p>
			<p class="source-code">nmcli connection add con-name network2 ifname ens38 type ethernet ip4 192.168.2.254/24</p>
			<p class="source-code">nmcli connection add con-name network3 ifname ens39 type ethernet ip4 192.168.3.254/24 </p>
			<p>If our configuration is correct, when we type in the <strong class="source-inline">nmcli con show</strong> command, we should have something like this (depending on how we configured our external network on <strong class="source-inline">ens33</strong> – and in our virtual machine, it's using the <strong class="source-inline">192.168.159.0/24</strong> network):</p>
			<div>
				<div id="_idContainer104" class="IMG---Figure">
					<img src="Images/Figure_4.36_B16269.jpg" alt="Figure 4.36 – Checking our NM connection setup&#13;&#10;" width="938" height="187"/>
				</div>
			</div>
			<p class="figure-caption">Figure 4.36 – Checking our NM connection setup</p>
			<p>Also, if we check routing information by using the <strong class="source-inline">ip route</strong> command, we should get something similar to this:</p>
			<div>
				<div id="_idContainer105" class="IMG---Figure">
					<img src="Images/Figure_4.37_B16269.jpg" alt="Figure 4.37 – Checking our routes&#13;&#10;" width="1175" height="178"/>
				</div>
			</div>
			<p class="figure-caption">Figure 4.37 – Checking our routes</p>
			<p>So, we have our three subnets, the routes are configured accordingly, now we need to configure<a id="_idIndexMarker259"/> <strong class="source-inline">server1</strong> to act as a router. Let's type in the following commands to set our interfaces to specific zones:</p>
			<p class="source-code">nmcli connection modify ens33 connection.zone public</p>
			<p class="source-code">nmcli connection modify network1 connection.zone public</p>
			<p class="source-code">nmcli connection modify network2 connection.zone public</p>
			<p class="source-code">nmcli connection modify network3 connection.zone public</p>
			<p class="source-code">firewall-cmd --zone=public --add-masquerade --permanent</p>
			<p class="source-code">firewall-cmd --reload</p>
			<p class="source-code">firewall-cmd --list-all</p>
			<p>When we type in the last command, we should get output similar to this:</p>
			<div>
				<div id="_idContainer106" class="IMG---Figure">
					<img src="Images/Figure_4.38_B16269.jpg" alt="Figure 4.38 – The firewall-cmd --list-all output&#13;&#10;" width="602" height="410"/>
				</div>
			</div>
			<p class="figure-caption">Figure 4.38 – The firewall-cmd --list-all output</p>
			<p>On client1, we need to do a bit of reconfiguration as well, as it was initially set up to use DHCP to get the IP address. First, let's install the <strong class="source-inline">traceroute</strong> package by typing in the following command:</p>
			<p class="source-code">apt-get -y install traceroute</p>
			<p>After that, let's configure this Linux virtual machine<a id="_idIndexMarker260"/> so that its IP address is <strong class="source-inline">192.168.1.1/24</strong> and apply that configuration. First, we need to edit netplan's configuration file. For simplicity reasons, let's just use the default configuration file, <strong class="source-inline">/etc/netplan/00-installer-config.yaml</strong>. It needs to have the following content applied via the <strong class="source-inline">netplan apply</strong> command:</p>
			<p class="figure-caption">``</p>
			<div>
				<div id="_idContainer107" class="IMG---Figure">
					<img src="Images/Figure_4.39_B16269.jpg" alt="Figure 4.39 – The netplan configuration file&#13;&#10;" width="823" height="442"/>
				</div>
			</div>
			<p class="figure-caption">Figure 4.39 – The netplan configuration file</p>
			<p>Let's now test if internet access from this machine works. As noted on the screenshot shown previously, we're using <strong class="source-inline">server1</strong> as the default gateway (<strong class="source-inline">192.168.1.254</strong>):</p>
			<div>
				<div id="_idContainer108" class="IMG---Figure">
					<img src="Images/Figure_4.40_B16269.jpg" alt="Figure 4.40 – Checking the configuration works&#13;&#10;" width="1087" height="360"/>
				</div>
			</div>
			<p class="figure-caption">Figure 4.40 – Checking the configuration works</p>
			<p>So, connectivity works. Let's now configure client2. Our CentOS virtual machine called <strong class="source-inline">client2</strong> has a network interface<a id="_idIndexMarker261"/> called <strong class="source-inline">ens39</strong>. Let's set it up so that it's a part of the <strong class="source-inline">network2</strong> subnet (we defined that subnet on <strong class="source-inline">server1</strong>). Let's say client2 is going to temporarily use <strong class="source-inline">192.168.2.2/24</strong> as its IP address:</p>
			<p class="source-code">nmcli connection add con-name network2 ifname ens39 type ethernet ipv4.address 192.168.2.2/24 gateway 192.168.2.254 ipv4.dns 8.8.8.8,8.8.4.4</p>
			<p class="source-code">nmcli con reload network2</p>
			<p>We previously configured <strong class="source-inline">server1</strong> to act as a default gateway, and, as a result, <strong class="source-inline">client1</strong> and <strong class="source-inline">client2</strong> can happily use it as a default gateway and access the external network. We can easily test that by using <strong class="source-inline">ping</strong>. Let's use <strong class="source-inline">client2</strong> as an example:</p>
			<div>
				<div id="_idContainer109" class="IMG---Figure">
					<img src="Images/Figure_4.41_B16269.jpg" alt="Figure 4.41 – Checking the configuration works after configuration changes&#13;&#10;" width="1082" height="240"/>
				</div>
			</div>
			<p class="figure-caption">Figure 4.41 – Checking the configuration works after configuration changes</p>
			<p>Now that we have verified that everything is configured correctly, let's now check a few different scenarios that might require<a id="_idIndexMarker262"/> additional network troubleshooting:</p>
			<ul>
				<li><strong class="source-inline">ping</strong> to an external host is not working, but external network access works.</li>
				<li>External network access is not working.</li>
				<li>Can't route between two subnets.</li>
				<li>Name resolution not working properly. </li>
			</ul>
			<p>Let's start with the first scenario. Usually, this is a firewall configuration setting (we're not calling it a problem on purpose). Let's first ping a site that we want to access:</p>
			<div>
				<div id="_idContainer110" class="IMG---Figure">
					<img src="Images/Figure_4.42_B16269.jpg" alt="Figure 4.42 – Scenario start – ping doesn't work&#13;&#10;" width="1095" height="263"/>
				</div>
			</div>
			<p class="figure-caption">Figure 4.42 – Scenario start – ping doesn't work</p>
			<p>At the same time, if we try to browse <strong class="source-inline">packtpub.com</strong> from our web browser, that works without any problems:</p>
			<div>
				<div id="_idContainer111" class="IMG---Figure">
					<img src="Images/Figure_4.43_B16269.jpg" alt="Figure 4.43 – It works in the browser&#13;&#10;" width="1350" height="981"/>
				</div>
			</div>
			<p class="figure-caption">Figure 4.43 – It works in the browser</p>
			<p>This type of problem<a id="_idIndexMarker263"/> is common – and from the output of <strong class="source-inline">ping</strong>, we can see that the firewall that we're passing on the way from our client2 to <strong class="source-inline">packtpub.com</strong> is filtering <strong class="source-inline">ping</strong> (<strong class="bold">ICMP</strong>, or <strong class="bold">Internet Control Message Protocol</strong>) traffic. This is nothing to be worried about, although it might be confusing. We need to keep in mind that ping/ICMP traffic has nothing to do with HTTP(S)/TCP traffic and that these protocols can be filtered separately. This is exactly what was done here – ping/ICMP traffic was filtered, while HTTP(S)/TCP traffic wasn't. </p>
			<p>Let's pile up additional complexity now and go through a scenario where external network access isn't available. Let's try pinging<a id="_idIndexMarker264"/> one of Google's DNSes from client2 and <strong class="source-inline">server1</strong>, just to see the symptoms: </p>
			<div>
				<div id="_idContainer112" class="IMG---Figure">
					<img src="Images/Figure_4.44_B16269.jpg" alt="Figure 4.44 – External network access doesn't work&#13;&#10;" width="1112" height="450"/>
				</div>
			</div>
			<p class="figure-caption">Figure 4.44 – External network access doesn't work</p>
			<p>It's one thing if the network client (client2) can't get to the external network. It's a completely different thing if the default gateway (in our case, <strong class="source-inline">server1</strong>) can't get to the external network. That points to a bigger problem, and if we didn't touch the firewall configuration and other network devices, it's probably some kind of a problem either with connectivity to the <strong class="bold">Internet Service Provider</strong> (<strong class="bold">ISP</strong>), or something on the ISP's end.</p>
			<p>We could do a bit more detective work by using additional tools, such as <strong class="bold">traceroute</strong> or <strong class="bold">tracepath</strong>:</p>
			<div>
				<div id="_idContainer113" class="IMG---Figure">
					<img src="Images/Figure_4.45_B16269.jpg" alt="Figure 4.45 – Further verification that external network access doesn't work&#13;&#10;" width="991" height="507"/>
				</div>
			</div>
			<p class="figure-caption">Figure 4.45 – Further verification that external network access doesn't work</p>
			<p>If we are using external DNS<a id="_idIndexMarker265"/> servers, we could even use the <strong class="source-inline">nslookup</strong>, <strong class="source-inline">host</strong>, or <strong class="source-inline">dig</strong> commands to almost conclusively determine that the problem lies with internet access, not our client or server:</p>
			<div>
				<div id="_idContainer114" class="IMG---Figure">
					<img src="Images/Figure_4.46_B16269.jpg" alt="Figure 4.46 – resolv.conf is configured correctly; DNS name resolution doesn't work&#13;&#10;" width="762" height="187"/>
				</div>
			</div>
			<p class="figure-caption">Figure 4.46 – resolv.conf is configured correctly; DNS name resolution doesn't work</p>
			<p>Let's say that the problem was that a cable connecting from our <strong class="source-inline">server1</strong> to the ISP router broke down. When we change that cable, <strong class="source-inline">ping</strong> should work perfectly, as shown here:</p>
			<div>
				<div id="_idContainer115" class="IMG---Figure">
					<img src="Images/Figure_4.47_B16269.jpg" alt="Figure 4.47 – The connection works again&#13;&#10;" width="906" height="305"/>
				</div>
			</div>
			<p class="figure-caption">Figure 4.47 – The connection works again</p>
			<p>Let's now check a scenario<a id="_idIndexMarker266"/> where we can't go from one subnet to another subnet. We're going to use network1 and network2 as an example – so, we're going to use client2 (<strong class="source-inline">192.168.2.2/24</strong>) to try to access client1 (<strong class="source-inline">192.168.1.1/24</strong>). As these two hosts are <em class="italic">not</em> a part of the same Layer 2 network, we have to have some kind of mechanism to <em class="italic">route</em> traffic between them. Let's check if that routing configuration works properly:</p>
			<div>
				<div id="_idContainer116" class="IMG---Figure">
					<img src="Images/Figure_4.48_B16269.jpg" alt="Figure 4.48 – Routing across subnets working&#13;&#10;" width="1055" height="105"/>
				</div>
			</div>
			<p class="figure-caption">Figure 4.48 – Routing across subnets working</p>
			<p>As previously configured, we allowed the forwarding of traffic between all of the networks on <strong class="source-inline">server1</strong>. We achieved that by allowing masquerading and putting all interfaces in the public <strong class="source-inline">firewalld</strong> zone. Sometimes when we configure our routing devices, we make mistakes. The results of our mistakes might be that two networks can't communicate with each other anymore (usually two VLANs, as we are discussing an internal networking scenario here). Let's see the symptoms:</p>
			<div>
				<div id="_idContainer117" class="IMG---Figure">
					<img src="Images/Figure_4.49_B16269.jpg" alt="Figure 4.49 – Routing doesn't work anymore&#13;&#10;" width="1043" height="615"/>
				</div>
			</div>
			<p class="figure-caption">Figure 4.49 – Routing doesn't work anymore</p>
			<p>If we check our<a id="_idIndexMarker267"/> routing table by using the <strong class="source-inline">netstat -rn</strong> command, we can see the following information:</p>
			<div>
				<div id="_idContainer118" class="IMG---Figure">
					<img src="Images/Figure_4.50_B16269.jpg" alt="Figure 4.50 – Checking that routing on our Linux machine is set up properly, which it is&#13;&#10;" width="1146" height="355"/>
				</div>
			</div>
			<p class="figure-caption">Figure 4.50 – Checking that routing on our Linux machine is set up properly, which it is</p>
			<p>So, our gateway works (we can ping it), but it doesn't forward us correctly to the <strong class="source-inline">192.168.1.0/24</strong> network. Seeing that we configured the <strong class="source-inline">192.168.1.0/24</strong> network to be a local network for <strong class="source-inline">server1</strong>, it's clear that we have some kind of routing problem here. It could be a <strong class="source-inline">firewalld</strong> misconfiguration, stopping <strong class="source-inline">firewalld</strong> as a service, a routing table misconfiguration, or maybe someone played with the <strong class="source-inline">/proc</strong> filesystem and set the <strong class="source-inline">ip_forward</strong> flag back to <strong class="source-inline">0</strong>. Whatever the case may be, the source of our problem is our default gateway. In larger enterprises, we usually have a networking team taking care of these things, so showing them output from <strong class="source-inline">ping</strong>, <strong class="source-inline">traceroute</strong>, and <strong class="source-inline">netstat</strong> should tell them where the problem is (in their own backyard). We'd usually tell them that they have a VLAN routing problem between VLAN X (subnet 1) and VLAN Y (subnet 2), send them outputs of these previously mentioned commands, and let them work from there.</p>
			<p>Let's finish this recipe<a id="_idIndexMarker268"/> by talking about a few name resolution issues. These issues can happen because of a service misconfiguration (<strong class="source-inline">systemd-resolved</strong>, for example), a wrong <strong class="source-inline">/etc/resolv.conf</strong> configuration, and even an <strong class="source-inline">/etc/hosts</strong> configuration that we did ourselves. Let's go through a couple of common problems.</p>
			<p>First, we are going to edit <strong class="source-inline">/etc/resolv.conf</strong> on client1 and put some custom DNS servers there. Then, we are going to reboot our client1 Linux virtual machine and see what happens when we check the content of <strong class="source-inline">/etc/resolv.conf</strong>. This screenshot is pre-reboot (we added two name servers, <strong class="source-inline">8.8.8.8</strong> and <strong class="source-inline">8.8.4.4</strong>):</p>
			<div>
				<div id="_idContainer119" class="IMG---Figure">
					<img src="Images/Figure_4.51_B16269.jpg" alt="Figure 4.51 – Editing /etc/resolv.conf manually&#13;&#10;" width="560" height="136"/>
				</div>
			</div>
			<p class="figure-caption">Figure 4.51 – Editing /etc/resolv.conf manually</p>
			<p>This next screenshot was taken post-reboot. We can clearly see that the content of this file has been changed:</p>
			<div>
				<div id="_idContainer120" class="IMG---Figure">
					<img src="Images/Figure_4.52_B16269.jpg" alt="Figure 4.52 – /etc/resolv.conf after reboot&#13;&#10;" width="564" height="68"/>
				</div>
			</div>
			<p class="figure-caption">Figure 4.52 – /etc/resolv.conf after reboot</p>
			<p>This was to be expected – as we described in our previous recipe, changing <strong class="source-inline">/etc/resolv.conf</strong> on a Linux machine that's running <strong class="source-inline">systemd-resolved</strong> is always going to end like this. If we want to change DNS settings, we need to do it properly. That means using <strong class="source-inline">nmcli</strong> in CentOS and, in this case, using netplan configuration on Ubuntu. This might only be a <em class="italic">local</em> issue, but it can still have a big impact in various scenarios where <strong class="source-inline">split-dns</strong> is involved.</p>
			<p>The next problem<a id="_idIndexMarker269"/> is going to be about the opposite – let's say that we installed the <strong class="source-inline">resolvconf</strong> package on our Ubuntu machine, disabled <strong class="source-inline">systemd-resolved</strong>, and configured <strong class="source-inline">/etc/resolv.conf</strong> like this:</p>
			<div>
				<div id="_idContainer121" class="IMG---Figure">
					<img src="Images/Figure_4.53_B16269.jpg" alt="Figure 4.53 – Putting a wrong config option in /etc/resolv.conf&#13;&#10;" width="574" height="43"/>
				</div>
			</div>
			<p class="figure-caption">Figure 4.53 – Putting a wrong config option in /etc/resolv.conf</p>
			<p>And when we try to resolve something by using the <strong class="source-inline">nslookup</strong>, <strong class="source-inline">host</strong>, or <strong class="source-inline">dig</strong> commands, it ends up nowhere, although our internet connection works, as shown with ou<a id="_idTextAnchor102"/>r manual DNS server configuration in <strong class="source-inline">nslookup</strong>:</p>
			<div>
				<div id="_idContainer122" class="IMG---Figure">
					<img src="Images/Figure_4.54_B16269.jpg" alt="Figure 4.54 – The network obviously works, but DNS name resolution doesn't, &#13;&#10;which points us in the right direction&#13;&#10;" width="834" height="731"/>
				</div>
			</div>
			<p class="figure-caption">Figure 4.54 – The network obviously works, but DNS name resolution doesn't, which points us in the right direction</p>
			<p>This clearly points to a wrong DNS server<a id="_idIndexMarker270"/> configuration as the internet access works, but we can't resolve a host. It's obvious that the option that we used (<strong class="source-inline">namserver</strong>) is wrong – it has to be <strong class="source-inline">nameserver</strong>. This brings us to the point: we always have to make sure that the syntax of our configuration files – in this case, <strong class="source-inline">resolv.conf</strong> – is correct. Mistakes are easily made if we are making changes by using a text editor, especially when we, for example, ignore red, highlighted fields in vi. If we were using commands to configure this and made an error in the syntax (<strong class="source-inline">nmcli</strong> or <strong class="source-inline">netplan</strong>), we would have an error somewhere, which would be easy to debug.</p>
			<p>The last scenario that we are going to work on is a common one for those of us dealing with a public website migration from one provider to another, thus changing the public IP address. When we are configuring these scenarios, oftentimes we need to have the old website running while we test the new website. We could have two IP address entries in our public DNS servers pointing to two different web servers, but that's not what we're after, ever. It would confuse our website visitors and us as well. So, we want to have a quick way of testing the new website until it's fully debugged while offering the general public access to the old one.</p>
			<p>Obviously, the simplest thing to do would be to add an entry to <strong class="source-inline">/etc/hosts</strong>, so that it points to the new website. Then, on the same machine where we made that change, we can debug our new website as much as we need – the public DNS entry still points to the old website, while our local machine goes to the new one.</p>
			<p>After the debugging process is done, we need to do a switchover – we need to change the public DNS entries and remove the <strong class="source-inline">/etc/hosts</strong> entry on our debugging machine. That's an ideal scenario where we can make some mistakes. So, we go to our public DNS provider, change the IP address of our website so that it points to the new IP, and save the configuration. Then, we go to our local debugging machine and remove the <strong class="source-inline">/etc/hosts</strong> entry pointing to the new website, start a web browser, point it to our website URL, and – lo and behold – we are still being presented with the old website. What is going on here?</p>
			<p>The simple fact is public DNS records need a bit of time to become active. It could be a minute, 15 minutes, an hour, a day – depending on how it's configured, but still, it needs time. Also, from various parts of the world – if our website is for an international audience – it could take different amounts of time to synchronize, which is why we have to be armed with patience when dealing with scenarios like these as we are probably going to get some emails about this scenario. We just need to do these types of configuration changes over the weekend when the amount of website visitors is at its lowest, and then sit and wait it out for all of the DNS entries to sync. From the time when we changed the DNS entry until everything is working, it's out of our hands. It's just the way it works.</p>
			<p>As you can clearly see from these examples, there are quite a few different scenarios that might come into play as you're administering your Linux servers, clients, and networks. </p>
			<h2 id="_idParaDest-101"><a id="_idTextAnchor103"/>How it works</h2>
			<p>All of the commands<a id="_idIndexMarker271"/> that we covered in this recipe work on the same idea – we have a networking stack that is either configured correctly or not. If it is, we mostly don't need them, but if something is misconfigured and/or not working properly, which can happen for a variety of external reasons as well, then we need to know how these commands work.</p>
			<p>If we are discussing networking generally, there are a few well-known concepts: the configured IP address, netmask, gateway, DNS server(s), and a fully qualified domain name of any given Linux server. Keeping in mind that networks are isolated into multiple subnets and that DNS is a hierarchical structure, if any of these concepts aren't configured correctly, we will have issues with network communication. That's why most of us system engineers take extra care to configure all of these settings correctly, as it's a basis for us to not get permanent headaches, if you will.</p>
			<p>When we do <strong class="source-inline">ping</strong>, <strong class="source-inline">traceroute</strong>, and <strong class="source-inline">tracepath</strong>, all of the traffic that we generate by using those utilities either goes to our local network or to non-local networks, which requires routing. On top of routing, firewalls might get in the way – sometimes people configure firewalls with ICMP traffic denied. </p>
			<p>Then, even if all of that works as it should, there's the DNS, sitting on top of it like a Jedi master trying to balance the Force. And sometimes, it just seems a bit evil and as if it's bugging us for no reason whatsoever. That's where utilities such as <strong class="source-inline">nslookup</strong>, <strong class="source-inline">host</strong>, and <strong class="source-inline">dig</strong> come in handy – so that we can find out if it's something <em class="italic">lower</em> in the networking stack, or if it's the DNS. As we discussed in our previous recipe, using <strong class="source-inline">systemd-resolved</strong> changed quite a few things in terms of DNS configuration. We must be extra careful to configure things properly when we're using it – so, using <strong class="source-inline">nmcli</strong> and netplan's config files. We shouldn't just go and start editing files more often than not. That's just going to make more problems.</p>
			<p>That being said, when we configure everything correctly and some other device on the network (our network or an external network) is at fault, things can get complicated very quickly. If a device doing network routing (a switch, router, Linux server, firewall, or whatever it might be) isn't configured correctly, we won't be able to communicate between multiple subnets. Imagine trying to go from Paris to Barcelona without knowing the way. There are so many possible ways of going from Paris to Barcelona (which we can equate to routing) that we wouldn't know which way to go. Usually, we start our debugging process by pinging some addresses on our networks (to check that the local network is working properly), then the default gateway, and checking if DNS is available as a service. On a more personal note, over the years, I have seen students and course attendees becoming painfully aware of just how complex DNS is as a system, especially at scale. We have a saying here at our college that students repeat over and over again – <em class="italic">It's always DNS</em>. So, we need to make sure that we have strong foundations in terms of DNS<a id="_idIndexMarker272"/> knowledge and understanding of how routing works. Then everything becomes much, much easier, as combining these two concepts can get insanely complicated. Especially when there are dynamic routing protocols such as BGP, EIGRP, and OSPF involved with split DNS and multiple locations. </p>
			<p>And that's a wrap for this chapter. The next chapter is going to be all about using the shell to manage software packages on our Linux systems. We are going to discuss how to use <strong class="source-inline">apt</strong> and <strong class="source-inline">apt-get</strong>, <strong class="source-inline">yum</strong>, and <strong class="source-inline">dnf</strong>, software repositories, and other subjects related to software management. Until then, we bid you adieu!</p>
			<h2 id="_idParaDest-102"><a id="_idTextAnchor104"/>There's more</h2>
			<p>If you need to learn more about network debugging, you can check the following links:</p>
			<ul>
				<li>A beginner's guide to<a id="_idIndexMarker273"/> network troubleshooting in Linux: <a href="https://www.redhat.com/sysadmin/beginners-guide-network-troubleshooting-linux%0D">https://www.redhat.com/sysadmin/beginners-guide-network-troubleshooting-linux</a></li>
				<li>Five Linux network troubleshooting<a id="_idIndexMarker274"/> commands: <a href="https://www.redhat.com/sysadmin/five-network-commands%0D">https://www.redhat.com/sysadmin/five-network-commands</a></li>
			</ul>
		</div>
	</div></body></html>