- en: '3'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Linux Filesystem
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Files and filesystems are the topics of discussion in this chapter. The Unix
    ethos of *everything is a file* carries on in Linux, and while that’s not true
    100% of the time, most resources in Linux are actually files.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will first define several relevant concepts. Then we will
    investigate Linux’s implementation of the *everything is a file* concept. We will
    then cover the specialized filesystems the kernel makes use of to report data
    about running processes or attached hardware. We will then move on to normal files
    and filesystems, things you would typically associate with documents, data, and
    applications. Finally, we will explore standard filesystem operations and provide
    comparisons with other available alternatives. It is very important to know what
    limitations has each filesystem type in order for you to take the best decisions.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: The types of filesystems available and the differences between them
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The directory trees and standard directories
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to mount/unmount filesystems
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What is a filesystem?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A filesystem (or sometimes *file system*) governs the storage and retrieval
    of data in computers. Without a filesystem, all the data saved on a computer’s
    hard drive would be jumbled together, making it impossible to find certain files.
    Instead, with a filesystem, data is easily isolated and identified by breaking
    it up into pieces and giving each piece a name. Each collection of data is referred
    to as a *file*, a name that originally came from information systems that use
    paper storage. A *filesystem* is a name for the organizational framework and logical
    principles used to handle the names and groups of bits of data.
  prefs: []
  type: TYPE_NORMAL
- en: In fact, there are a variety of filesystems available for Linux; if you’re unsure
    which one to use, we’ll present a thorough list of the filesystems that Linux
    supports.
  prefs: []
  type: TYPE_NORMAL
- en: '*What types of Linux filesystems* *are there?*'
  prefs: []
  type: TYPE_NORMAL
- en: 'Linux has a variety of filesystems to choose from, including the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '**ext**: The first filesystem constructed expressly for Linux was called *ext*,
    which is an acronym for *extended filesystem*, and was released in 1992\. The
    primary objective of ext’s developers was to increase the maximum size of editable
    files, which at the time was limited to 64 MB. The maximum file size grew to 2
    GB as a result of the new metadata structure that was created. The maximum length
    of filenames was also increased at the same time to 255 bytes.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**ext2**: This is also known as the *second expanded system*. ext2 was developed
    by Remy Card, just like the first one, and was intended to replace Linux’s original
    extension system. It introduced innovations in fields such as storage capacity
    and overall performance. The maximum file size was notably increased to 2 TB,
    as opposed to the previous version’s 2 GB. Still, filenames remained limited to
    255 bytes long.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**ext3**: ext3 is an upgraded version of ext2 and was first developed in 2001\.
    The 2-TB maximum file size did not change, but ext3 was superior to ext2 in that
    it is a journaling filesystem. The 2-TB maximum file size does not change. This
    means that if the computer, hard drive(s), or both crash for any reason or encounter
    some type of power outage, the files can be repaired and restored upon rebooting
    using a separate log that contains the changes performed before the crash.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'ext3 supports three levels of journaling:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Journal**: In the event of a power outage, the filesystem ensures effective
    filesystem recovery by writing both user data and metadata to the journal. Of
    the three ext3 journaling modes, this is the slowest. This journaling mode reduces
    the likelihood that any changes to any file in an ext3 filesystem will be lost.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`data=writeback` mode, only metadata updates are logged in the journal. Data
    updates, on the other hand, are written directly to their respective locations
    on the disk without being logged in the journal first. This approach can provide
    better performance for write-intensive workloads because it reduces the overhead
    of journaling data.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Pros**:'
  prefs: []
  type: TYPE_NORMAL
- en: Improved performance for write-heavy workloads since data is written directly
    to disk without the extra overhead of journaling
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Lower write latency as data doesn’t need to be written twice (to the journal
    and then to the filesystem)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Cons**:'
  prefs: []
  type: TYPE_NORMAL
- en: Reduced data consistency during a system crash or power failure. Since data
    updates are not journaled, there’s a possibility of data loss or inconsistency
    in case of a crash.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In scenarios where data integrity is critical (for example, databases), the
    `writeback` mode may not be the best choice because it prioritizes performance
    over data consistency.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Ordered**: This mode does not update related filesystem metadata; instead,
    it flushes changes from file data to disk before updating the associated filesystem
    metadata. This is ext3’s default journaling mode. Only the files that were in
    the process of being written to the disk *disappear* in the event of a power outage.
    The architecture of the filesystem is undamaged.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**ext4**: The *fourth extended system*, often known as ext4, was launched in
    2008\. This filesystem is commonly used as the default filesystem for the majority
    of Linux distributions since it overcomes a number of shortcomings that the third
    extended system had. Ext4 supports significantly larger filesystems and individual
    file sizes compared to Ext3\. It can handle filesystems up to 1 exabyte (1 EB)
    and individual files up to 16 terabytes (16 TB). Additionally, a directory in
    ext4 can have up to 64,000 subdirectories (as opposed to 32,000 in ext3).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Extents have replaced fixed blocks as the primary method of data allocation
    in ext4\. An extent’s beginning and end locations on the hard disk serve as a
    description of it. The number of pointers needed to represent the location of
    all the data in larger files can be greatly reduced because of the ability to
    express extremely long, physically contiguous files in a single inode pointer
    entry.
  prefs: []
  type: TYPE_NORMAL
- en: '**JFS**: JFS stands for *Journaled File System*. It is a 64-bit filesystem
    developed by IBM. In 1990, the first version of JFS (also known as *JFS1*) was
    introduced for use with IBM’s AIX operating system.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Data recovery after a power outage is simple and reliable. Additionally, compared
    to other filesystems, JFS requires less CPU power.
  prefs: []
  type: TYPE_NORMAL
- en: '**XFS**: SGI began working on XFS in the early 1990s with the intention of
    using it as the filesystem for their IRIX operating system. To tackle the most
    difficult computing challenges, XFS was designed as a high-performance 64-bit
    journaling filesystem. Large file manipulation and high-end hardware performance
    are strengths of XFS. In SUSE Linux Enterprise Server, XFS is the default filesystem
    for data partitions.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Btrfs**: Chris Mason created the **copy-on-write** (**COW**) filesystem known
    as Btrfs. It is based on Ohad Rodeh’s COW-friendly B-trees. Btrfs is a logging-style
    filesystem that links the change after writing the block modifications in a new
    area as opposed to journaling them. New changes are not committed until the last
    write.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Swap**: When the amount of memory available to the computer begins to run
    low, the system will use a file known as a swap file to generate temporary storage
    space on a solid-state drive or hard disk. The file replaces a section of memory
    in the RAM storage of a paused program with a new part, making memory available
    for use by other processes.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The computer is able to utilize more RAM than is physically installed by using
    a swap file. In other words, it is capable of running more programs than it would
    be able to execute if it relied solely on the limited resources provided by the
    RAM that was physically installed.
  prefs: []
  type: TYPE_NORMAL
- en: Because swap files are not kept in the computer’s actual RAM, we can consider
    them to be a form of virtual memory. When a computer uses a swap file, its operating
    system essentially tricks itself into thinking that it has more RAM than it actually
    does.
  prefs: []
  type: TYPE_NORMAL
- en: Linux is compatible with a wide variety of filesystems, including the FAT and
    NTFS filesystems that are standard to other operating systems such as Windows.
    It’s possible that embedded developers will support those, although in most cases,
    a Linux filesystem such as ext4, XFS, or Btrfs will be used for storage partitions.
    A better understanding of the benefits of the available alternatives will help
    you to choose the appropriate filesystem for a certain application.
  prefs: []
  type: TYPE_NORMAL
- en: High scalability
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: By leveraging allocation groups, XFS provides excellent scalability.
  prefs: []
  type: TYPE_NORMAL
- en: The block device that supports the XFS filesystem is split into eight or more
    linear regions that are all the same size at the moment the filesystem is created.
    They are referred to as allocation groups. Each allocation group controls its
    own free disk space and inodes. The kernel can address multiple allocation groups
    at once since they are relatively independent of one another. The high scalability
    of XFS is made possible by this feature. These autonomous allocation groups naturally
    meet the requirements of multiprocessor systems.
  prefs: []
  type: TYPE_NORMAL
- en: High performance
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: XFS provides high performance by effectively managing disk space.
  prefs: []
  type: TYPE_NORMAL
- en: Within the allocation groups, B+ trees manage free space and inodes. The effectiveness
    and scalability of XFS are considerably enhanced by the usage of B+ trees. XFS
    manages allocation in a delayed manner by dividing the allocation procedure into
    two steps. Pending transactions are kept in the RAM and the necessary amount of
    space is set aside. The precise location (in filesystem blocks) of the data’s
    storage is still left up to XFS. This choice is postponed until the very last
    second. If it is outdated when XFS selects where to save it, certain short-lived
    temporary data may never reach the disk. XFS improves write performance and lessens
    filesystem fragmentation in this way. Data loss after a crash during a write operation
    is likely to be more severe in a delayed-allocation filesystem than in other filesystems.
  prefs: []
  type: TYPE_NORMAL
- en: What filesystem does my system use?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If you aren’t sure which filesystem your distribution ships with, or if you
    just want to know which one you have installed, you can use some clever commands
    at the Terminal to find out.
  prefs: []
  type: TYPE_NORMAL
- en: There are other ways to accomplish this, but we’ll demonstrate the simplest
    one here using the `df -``T` command.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.1 – A command used to determine what type of filesystem is in use](img/Figure_3.1_B18575.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.1 – A command used to determine what type of filesystem is in use
  prefs: []
  type: TYPE_NORMAL
- en: In the second column, labeled `Type`, you can see the descriptions of the filesystem
    formats. At this point, you should be able to tell which filesystem is mounted
    on your Linux installation.
  prefs: []
  type: TYPE_NORMAL
- en: FUSE filesystem
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As a user, you shouldn’t have to worry too much about the underlying implementation
    when interacting with files and directories in user space. It is common practice
    for processes to make use of system calls to the kernel in order to read or write
    to a mounted filesystem. However, you do have access to data from the filesystem
    that doesn’t seem to belong in the user’s domain. The `stat()` system call in
    particular returns inode numbers and link counts.
  prefs: []
  type: TYPE_NORMAL
- en: Do you have to worry about inode numbers, link counts, and other implementation
    details even when you’re not maintaining a filesystem? No (in most cases). This
    information is made available to user-mode programs for the primary purpose of
    maintaining backward compatibility. In addition, these filesystem internals aren’t
    present in every Linux filesystem because they’re not standardized. The VFS interface
    layer is responsible for ensuring that system calls always return inode numbers
    and link counts; however, the values of these numbers may or may not indicate
    anything.
  prefs: []
  type: TYPE_NORMAL
- en: On non-traditional filesystems, it’s possible that you won’t be able to carry
    out operations that are typical of the Unix filesystem. For instance, you cannot
    use the `ln` command to create a hard link on a mounted VFAT filesystem because
    that filesystem’s directory entry structure does not support the concept of hard
    links. Because of the high level of abstraction provided by the system calls available
    in user space, working with files on Linux systems does not require any prior
    knowledge of the underlying implementation. Additionally, the format of filenames
    is flexible, and the use of mixed-case filenames is supported; both of these features
    make it simple to support other hierarchical-style filesystems.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: Keep in mind that the support for a particular filesystem does not necessarily
    need to be included in the kernel. To give one illustration, the role of the kernel
    in user-space filesystems is limited to that of a conduit for system calls.
  prefs: []
  type: TYPE_NORMAL
- en: The directory tree and standard directories
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To see the main structure of the root folder, just use the following command:
    `tree -``L 1`.'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.2 – The command to see a directory structure tree](img/Figure_3.2_B18575.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.2 – The command to see a directory structure tree
  prefs: []
  type: TYPE_NORMAL
- en: 'To better grasp how the Linux filesystem functions in general, let’s examine
    what each folder’s purpose is with reference to the Linux filesystem diagram shown
    in *Figure 3**.2*. Not all of the folders mentioned here nor in the preceding
    examples will be found in every Linux distribution, but the vast majority of them
    will:'
  prefs: []
  type: TYPE_NORMAL
- en: '`/bin`: The majority of your binary files are kept in this location, which
    is pronounced *bin,* and is often used by Linux Terminal commands and essential
    utilities such as `cd` (change directory), `pwd` (print working directory), `mv`
    (move), and others.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`/boot`: All of the boot files for Linux can be found in this folder. The majority
    of people, including myself, save this directory on a separate partition of their
    hard drive, especially if they plan to use dual-booting. Remember that even if
    `/boot` is physically located on a different partition, Linux still believes it
    to be at `/boot`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`/dev`: Your physical devices, such as hard drives, USB drives, and optical
    media, are mounted here. Additionally, your drive may have different partitions,
    in which case you’ll see `/dev/sda1`, `/dev/sda2`, and so forth.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`/etc`: This directory stores configuration files. Users can keep configuration
    files in their own `/home` folder, which affects only the given user, whereas
    configurations placed in `/etc` usually affect all users on the system.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`/home`: Because this directory contains all of your personal information,
    you’ll spend most of your time here. The `/home/username` directory contains the
    `Desktop`, `Documents`, `Downloads`, `Photos`, and `Videos` directories.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`/lib`: Here is where you’ll find all the library buildings. There are always
    extra libraries that start with lib-something that get downloaded when you install
    a Linux distribution. The operation of your Linux program depends on these files.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`/media`: This is where external devices such as USB drives and CD-ROMs are
    mounted. This varies between Linux distributions.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`/mnt`: This directory basically serves as a mounting point for other folders
    or drives. This can be used for anything, although it is typically used for network
    locations.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`/opt`: This directory contains supplementary software for your computer that
    is not already managed by the package management tool that comes with your distribution.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`/proc`: The *processes* folder contains a variety of files holding system
    data (remember, everything is a file). In essence, it gives the Linux kernel—the
    heart of the operating system—a mechanism to communicate with the numerous processes
    that are active within the Linux environment.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`/root`: This is the equivalent of the `/home` folder for the root user, commonly
    known as the superuser. You should only touch anything in this directory if you
    are really sure you know what you’re doing.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`/sbin`: This is comparable to the `/bin` directory, with the exception that
    it contains instructions that can only be executed by the *root* user, sometimes
    known as the *superuser*.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`/tmp`: Temporary files are kept here and are often erased when the computer
    shuts down, so you don’t have to manually remove them as you would in Windows.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`/usr`: This directory contains files and utilities that are shared between
    users.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`/var`: The files used by the system to store information as it runs are often
    located in the `/var` subfolder of the root directory in Linux and other Unix-like
    operating systems.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We’ve now covered the root directory, but many of the subdirectories also lead
    to additional files and folders. You can get a general concept of what the basic
    filesystem tree looks like from the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.3 – Basic filesystem structure (Source: https://en.wikipedia.org/wiki/Unix_filesystem)](img/Figure_3.3_B18575.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 3.3 – Basic filesystem structure (Source: [https://en.wikipedia.org/wiki/Unix_filesystem](https://en.wikipedia.org/wiki/Unix_filesystem))'
  prefs: []
  type: TYPE_NORMAL
- en: Having an understanding of the root directory structure will make your life
    much easier in the Linux world.
  prefs: []
  type: TYPE_NORMAL
- en: Links (hard and symbolic)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'There are two alternative ways to refer to a file on the hard drive: hard links
    and symbolic links. The filesystem, which organizes which file belongs where and
    how, includes several approaches such as symbolic link and hard link. A hard link
    basically refers to the inode of a file and is a synchronized carbon copy of that
    file. On the other hand, symbolic links point directly to the file, which in turn
    points to the inode, a shortcut. We need to next discuss inodes in order to comprehend
    how symbolic and hard links function.'
  prefs: []
  type: TYPE_NORMAL
- en: What is an inode?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A Unix-style filesystem uses a data structure called an inode to describe filesystem
    objects such as files and directories. The properties and disk block locations
    of an object’s data are stored in each inode. Attributes of filesystem objects
    can include metadata, owner information, and permission information.
  prefs: []
  type: TYPE_NORMAL
- en: Inodes are essentially a whole address’s numerical equivalent. The operating
    system can obtain details about a file, including permission privileges and the
    precise location of the data on the hard drive, using an inode.
  prefs: []
  type: TYPE_NORMAL
- en: What is a hard link?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: On a computer system, a hard link is a special kind of link that points directly
    to a specific file by its name. A hard link will continue to point to the original
    file even if the file’s name is changed, unlike a soft link.
  prefs: []
  type: TYPE_NORMAL
- en: When comparing the two methods of linking a directory entry or file to the same
    memory region, hard links are more reliable. As opposed to symbolic links, hard
    links prevent files from being deleted or moved. The *alias effect*, in which
    a file has numerous identifiers, can occur when multiple hard links point to the
    same file. Experts agree that all links, whether hard or soft, are pointers; nonetheless,
    hard links are distinguished as being more permanent than soft connections.
  prefs: []
  type: TYPE_NORMAL
- en: What are symbolic links?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Symbolic links are essentially shortcuts that refer to a file rather than the
    inode value of the file they point to. This method can be applied to directories
    and can be used to make references to data that is located on a variety of hard
    discs and volumes. A symbolic link will be broken or leave a dangling link if
    the original file is moved to a different folder. This is due to the fact that
    symbolic links refer to the original file and not the inode value of the file.
  prefs: []
  type: TYPE_NORMAL
- en: Because a symbolic link points to the original file, any changes you make to
    the symbolic link should result in corresponding changes being made to the actual
    file.
  prefs: []
  type: TYPE_NORMAL
- en: Mounting and unmounting filesystems
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In order for the computer to access files, the filesystem must be mounted. The
    `mount` command will show you what is mounted (usable) on your system at the moment.
  prefs: []
  type: TYPE_NORMAL
- en: 'I created my own `/data` folder and mounted a new HDD into it:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.4 – A command showing what filesystem is mounted on /data](img/Figure_3.4_B18575.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.4 – A command showing what filesystem is mounted on /data
  prefs: []
  type: TYPE_NORMAL
- en: 'To mount your filesystem with a command, just run the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: In order to have it automatically mounted on reboot, you have to define this
    entry in `/etc/fstab`.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you want to mount a CD-ROM, just run the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: For more detailed information, consult the `mount` man page or run `mount` with
    the `-h` flag to get assistance.
  prefs: []
  type: TYPE_NORMAL
- en: The `cd` command can be used to traverse the newly accessible filesystem through
    the mount point you just created after mounting.
  prefs: []
  type: TYPE_NORMAL
- en: How to unmount the filesystem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Using the `umount` command and specifying the mount point or device, you can
    unmount (detach) the filesystem from your computer.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following command, for instance, would unmount a CD-ROM:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Pseudo-filesystems
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A process information pseudo-filesystem is another name for the `proc` filesystem.
    It contains runtime system information rather than *actual* files (for example,
    system memory, devices mounted, hardware configuration, and so on). It can therefore
    be viewed as the kernel’s command and information hub. This directory (`/proc`)
    is accessed by many system utilities. The `lsmod` command lists the modules loaded
    by the kernel, and the `lspci` command displays the devices attached to the PCI
    bus. Both of these commands are functionally equivalent to `cat /proc/modules`
    and `cat /proc/pci`, respectively. Common examples of pseudo filesystems in Unix-like
    operating systems (for example, Linux) include the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Processes, the most prominent use
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Kernel information and parameters
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: System metrics, such as CPU usage
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Processes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'All the information about each running process can be found in the `/proc/pid`
    file. Here’s an illustration of a few PIDs in action right now:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.5 – A command to see running processes](img/Figure_3.5_B18575.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.5 – A command to see running processes
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s take, for example, PID `1031` and see what is inside:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.6 – A command to see what is inside of the process with PID 1031](img/Figure_3.6_B18575.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.6 – A command to see what is inside of the process with PID 1031
  prefs: []
  type: TYPE_NORMAL
- en: Finally, a synthetic filesystem is a filesystem that provides a tree-like interface
    to non-file objects, making them look like regular files in a disk-based or long-term
    storage filesystem. This type of filesystem is also known as a faux filesystem.
  prefs: []
  type: TYPE_NORMAL
- en: Kernel and system information
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Numerous folders under `/proc` contain a wealth of knowledge about the kernel
    and the operating system. There are too many of them to include here, but we will
    cover a few along with a brief description of what they contain:'
  prefs: []
  type: TYPE_NORMAL
- en: '`/proc/cpuinfo`: Information about the CPU'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`/proc/meminfo`: Information about the physical memory'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`/proc/vmstats`: Information about the virtual memory'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`/proc/mounts`: Information about the mounts'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`/proc/filesystems`: Information about filesystems that have been compiled
    into the kernel and whose kernel modules are currently loaded'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`/proc/uptime`: This shows the current system uptime'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`/proc/cmdline`: The kernel command line'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: CPU usage
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When evaluating a system’s overall performance, it is crucial to have a firm
    grasp of how much CPU time is being used. Knowing how to monitor CPU utilization
    in Linux via the command line is essential knowledge for everyone working with
    Linux, from enthusiasts to system administrators.
  prefs: []
  type: TYPE_NORMAL
- en: 'One of the most common commands used for this purpose is `top`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.7 – Output of top command](img/Figure_3.7_B18575.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.7 – Output of top command
  prefs: []
  type: TYPE_NORMAL
- en: The system’s response should be a comprehensive rundown of all active tasks
    where users, processes, CPU usage, and memory consumption can all be viewed.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we explored files and filesystems in Linux. Filesystems are
    a powerful and versatile approach to organize access to information in a hierarchical
    fashion. In Linux, filesystems are the focus of numerous technologies and ongoing
    efforts. Some are open source, but there is also a spectrum of commercial options.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will talk about processes and process control.
  prefs: []
  type: TYPE_NORMAL
