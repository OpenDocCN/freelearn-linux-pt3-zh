- en: '18'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '18'
- en: Shell Scripting for Security Professionals
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 安全专业人士的Shell脚本编写
- en: In this chapter, we’ll do things a bit differently. Instead of showing you new
    scripting concepts, I’ll show you how to use the concepts that you’ve already
    learned to perform chores that a security professional might need to do.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将做一些不同的事情。与其向你展示新的脚本概念，不如教你如何利用你已经学到的概念来执行一些安全专业可能需要做的工作。
- en: Of course, you could do many of these chores with a more complex program, such
    as `nmap`. But, there may be times when these tools won’t be available to you.
    In this chapter, I’ll show you some simple scripts that can do some of these jobs.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，你也可以用更复杂的程序如`nmap`来完成许多这些任务。但是，有时这些工具可能对你不可用。在本章中，我将向你展示一些简单的脚本，可以完成一些这样的工作。
- en: 'Topics in this chapter include:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的主题包括：
- en: Simple scripts for auditing
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 简单的审计脚本
- en: Creating simple firewall scripts
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建简单的防火墙脚本
- en: Searching for existing security-related scripts
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 搜索现有的与安全相关的脚本
- en: Okay, I know that you’re anxious to get started. So, let’s go.
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 好了，我知道你迫不及待地想要开始了。所以，让我们开始吧。
- en: Technical Requirements
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: For the Linux demos in this chapter, I’ll use a Fedora Server virtual machine.
    That’s because these demos will use features and utilities that are unique to
    Red Hat-type distros, such as Fedora. However, you can easily adapt them to other
    Linux distros, such as Ubuntu or Debian, if you desire.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 对于本章中的Linux演示，我将使用一个Fedora Server虚拟机。这是因为这些演示将使用红帽类型的独特功能和实用程序，如Fedora。但是，如果你愿意，你也可以很容易地将它们适配到其他Linux发行版，如Ubuntu或Debian。
- en: I’ll also be showing you some things on OpenIndiana and FreeBSD. On your FreeBSD
    virtual machine, I’m assuming that you’ve already installed `bash`, and set up
    a normal user account with full `sudo` privileges, as I’ve shown you in *Chapter
    12, Automating Scripts with here Documents and expect*.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 我还将在OpenIndiana和FreeBSD上向你展示一些东西。在你的FreeBSD虚拟机上，我假设你已经安装了`bash`，并设置了一个具有完整`sudo`权限的普通用户帐户，就像我在*第12章，使用here文档和expect自动化脚本*中展示的那样。
- en: 'Also, as always, you can grab the scripts from Github by running:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 正如以往一样，你可以通过运行以下命令从Github获取这些脚本：
- en: '[PRE0]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Simple Scripts for Auditing
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简单的审计脚本
- en: If you’re used to using `nmap`, you already know how awesome it is. You can
    use it for many types of auditing and network security chores, such as scanning
    ports or identifying operating systems on remote machines. But, if you ever find
    yourself in a situation where `nmap` isn’t available to you, know that you can
    do some of your `nmap` chores with some simple shell scripts. Let’s begin with
    something simple.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你习惯使用`nmap`，你肯定知道它有多棒。你可以用它来进行许多类型的审计和网络安全任务，如扫描端口或识别远程机器上的操作系统。但是，如果你发现自己处于`nmap`不可用的情况下，你也可以通过一些简单的Shell脚本完成部分`nmap`的工作。让我们从简单的事情开始。
- en: Identifying an Operating System
  id: totrans-16
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 识别操作系统
- en: 'You can get a rough idea of what operating system is running on another machine
    by pinging it, and looking at the **Time-to-Live** (**TTL**) figure in the response.
    Here’s how it works:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过ping另一台机器并查看响应中的**Time-to-Live**（**TTL**）字段来大致了解它运行的操作系统。这是它的工作原理：
- en: '`64`: If the TTL of a ping response is 64, then the operating system of the
    target machine is Linux, some sort of BSD, or macOS.'
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`64`：如果ping响应的TTL为64，则目标机器的操作系统是Linux、某种BSD或macOS。'
- en: '`128`: A 128 TTL indicates that the target machine is running Windows.'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`128`：128的TTL表示目标机器正在运行Windows。'
- en: '`255`: This indicates that the target machine is running either Solaris or
    a Solaris clone, such as OpenIndiana.'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`255`：这表示目标机器正在运行Solaris或Solaris克隆，如OpenIndiana。'
- en: 'Here’s the output of a normal ping command. (Note that I’m using the `-c1`
    option, which means that I’m only sending one ping packet.) This shows the TTL
    field:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 这是普通ping命令的输出。（请注意，我使用了`-c1`选项，这意味着我只发送一个ping数据包。）这显示了TTL字段：
- en: '[PRE1]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'In the second line of output, you see `ttl=128`, which indicates that I’ve
    just pinged a Windows machine. Now, here’s the `os-detect.sh` script, which automatically
    interprets the TTL field:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 在输出的第二行中，你看到`ttl=128`，这表明我刚刚ping了一台Windows机器。现在，这是`os-detect.sh`脚本，它可以自动解释TTL字段：
- en: '[PRE2]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: In the second line, I’m using the `$1` positional parameter to represent the
    IP address of the target machine. I’m also piping the `ping` output into `head`
    and then `tail` in order to isolate the second line of output, which contains
    the TTL field. I then pipe this second line into `cut`, using the `=` as the field
    delimiter to isolate the third field, which in this example with Windows is `128
    time`. Finally, I pipe the value of this third field into `cut`, in order to isolate
    just the TTL number. This TTL number will be the value of the `ttl` variable.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 在第二行中，我使用`$1`位置参数来表示目标机器的IP地址。我还将`ping`输出通过管道传送到`head`，然后是`tail`，以便隔离出第二行输出，其中包含TTL字段。接着，我将第二行传递给`cut`，使用`=`作为字段分隔符来隔离出第三个字段，在这个例子中，Windows的第三个字段是`128
    time`。最后，我将这个第三个字段的值传递给`cut`，以便仅提取TTL数字。这个TTL数字将作为`ttl`变量的值。
- en: 'Finally, we have the `if. .elif. .else` construct to identify the target machine’s
    operating system. Now, here’s the script in operation:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们有`if. .elif. .else`结构来识别目标机器的操作系统。现在，看看这个脚本的运行效果：
- en: '[PRE3]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: For the record, the first machine is running Windows 10, the second one is running
    FreeBSD, and the third one is running OpenIndiana. So, that’s easy, right? Hang
    on though, because I do need to point out a couple of caveats.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 记录一下，第一台机器运行的是Windows 10，第二台机器运行的是FreeBSD，第三台机器运行的是OpenIndiana。这样很简单，对吧？不过，稍等一下，我确实需要指出几个注意事项。
- en: First, is the obvious fact that this script can’t provide much detail about
    the operating systems on the target machines. In fact, it can’t even differentiate
    between Linux, BSD, or macOS operating systems. The second caveat is that you
    can only use this script to scan machines that are on your local network, because
    sending ping packets across a network boundary changes the TTL value. Thirdly,
    you can run this script from either a Linux or a BSD machine, but you can’t run
    it from a Solaris/OpenIndiana machine. That’s because Solaris and OpenIndiana
    use a different implementation of the `ping` utility that doesn’t show anything
    other than the fact that the target machine is up. And lastly, if the target machines
    have firewalls that are configured to block ping packets, then this script won’t
    work at all.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，显而易见的是，这个脚本无法提供目标机器操作系统的详细信息。事实上，它甚至无法区分Linux、BSD或macOS操作系统。第二个注意事项是，你只能使用这个脚本扫描本地网络中的机器，因为跨网络边界发送ping数据包会改变TTL值。第三，你可以在Linux或BSD机器上运行这个脚本，但不能在Solaris/OpenIndiana机器上运行。因为Solaris和OpenIndiana使用不同实现的`ping`工具，这些工具除了显示目标机器是否在线外不会显示任何其他信息。最后，如果目标机器有防火墙配置来阻止ping数据包，那么这个脚本根本无法工作。
- en: 'So, even though this script could be a handy tool for a quick analysis of machines
    on your local network, you’ll need to use `nmap` or some other equivalent tool
    to get more detailed information, to scan machines on another network, or to scan
    machines with firewalls that block ping packets. For example, using `nmap` with
    the `-A` option allows `nmap` to somewhat accurately detect the operating system
    of the target machine. Here’s how it looks when I scan a FreeBSD 14 machine:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，即使这个脚本可能是一个快速分析你本地网络中机器的有用工具，你仍然需要使用`nmap`或其他等效工具来获取更详细的信息，扫描另一个网络上的机器，或者扫描那些阻止ping数据包的防火墙机器。例如，使用`nmap`的`-A`选项可以使`nmap`相对准确地检测目标机器的操作系统。下面是当我扫描一台FreeBSD
    14机器时的结果：
- en: '[PRE4]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Okay, you see what I meant when I said that `nmap`'s operating system detection
    is *somewhat* accurate. The scan results show that I’m scanning a FreeBSD 12 or
    FreeBSD 13 machine, even though it’s really a FreeBSD 14 machine. But, FreeBSD
    14 is still quite new, so it’s probable that the fingerprint for it hasn’t yet
    been added to the `nmap` database. On the positive side, at least this accurately
    tells us that it’s some sort of FreeBSD machine, instead of just telling us that
    it could be FreeBSD, Linux, or macOS.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 好吧，你看到了我说的`nmap`的操作系统检测是*有些*准确的意思。扫描结果显示我正在扫描的是FreeBSD 12或FreeBSD 13机器，尽管它实际上是FreeBSD
    14机器。但是，FreeBSD 14还很新，因此很可能它的指纹尚未添加到`nmap`数据库中。好的一面是，至少它准确地告诉我们这是某种FreeBSD机器，而不是仅仅告诉我们它可能是FreeBSD、Linux或macOS。
- en: 'On the other hand, you might find times when our simple script works better.
    For example, look at what happens when I do an `nmap -A` scan on an OpenIndiana
    machine:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，你可能会发现我们的简单脚本在某些情况下效果更好。例如，看看当我在OpenIndiana机器上执行`nmap -A`扫描时发生了什么：
- en: '[PRE5]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: As you saw earlier, our script correctly identified this machine as either a
    Solaris or OpenIndiana machine. But, `nmap` can’t identify it at all.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你之前看到的，我们的脚本正确地将这台机器识别为Solaris或OpenIndiana机器。但是，`nmap`完全无法识别它。
- en: A Simple Port-scanning Script
  id: totrans-36
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 一个简单的端口扫描脚本
- en: 'This is a cool little script that you can use to scan either local or remote
    machines for open network ports. If you’re new to network scanning, a network
    port can be in any one of three states. Here are the relevant definitions of those
    states:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个很酷的小脚本，你可以用它扫描本地或远程机器上的开放网络端口。如果你是网络扫描的新手，网络端口可以处于三种状态中的任何一种。以下是这些状态的相关定义：
- en: '`open`: An open port is one that has an associated network service running,
    and that is not blocked by a firewall. For example, you would expect to find Port
    22 open on a server that has its Secure Shell service running, and Port 443 open
    on a webserver that’s using an encrypted connection. By observing which ports
    on a remote machine are open, you can tell which network services are running
    on that machine.'
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`open`：开放端口是指有一个关联的网络服务正在运行，并且没有被防火墙阻止的端口。例如，你会期待在运行安全外壳（SSH）服务的服务器上找到22端口是开放的，在使用加密连接的Web服务器上找到443端口是开放的。通过观察远程机器上哪些端口开放，你可以知道该机器上正在运行哪些网络服务。'
- en: '`closed`: A closed port is one that does not have an associated service running,
    and that is not blocked by a firewall.'
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`closed`：关闭端口是指没有关联服务在运行，并且没有被防火墙阻止的端口。'
- en: '`filtered`: A filtered port has been blocked by a firewall.'
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`filtered`：过滤端口是指该端口已被防火墙阻止。'
- en: 'This script works by using the network capability that’s built into the GNU
    implementation of `bash` that comes on Linux and newer versions of macOS. It works
    by using either the `/dev/tcp` or the `/dev/udp` device on your Linux system.
    What’s crazy though, is that you won’t find either of these device files in the
    `/dev/` directory. That’s because they’re hard-coded into the `bash` executable.
    You can use the `strings` utility to verify that, as you see here:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 这个脚本通过使用GNU版`bash`内建的网络功能来工作，这些功能存在于Linux和较新版本的macOS上。它通过使用Linux系统上的`/dev/tcp`或`/dev/udp`设备来工作。奇怪的是，你不会在`/dev/`目录下找到这些设备文件，因为它们是硬编码在`bash`可执行文件中的。你可以使用`strings`工具来验证这一点，正如你在这里看到的：
- en: '[PRE6]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: In case you’re wondering, `strings` allows you to view text strings that are
    embedded into binary executable files. Also, be aware that this networking capability
    is only built into the GNU implementation of `bash`, which means that you can
    run these commands on either Linux or a newer version of macOS, but not on other
    Unix/Unix-like distros such as FreeBSD or OpenIndiana.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在想，`strings` 允许你查看嵌入到二进制可执行文件中的文本字符串。另外，要注意，这种网络功能仅在GNU版的`bash`中内建，这意味着你可以在Linux或较新版本的macOS上运行这些命令，但不能在其他Unix/类Unix发行版（如FreeBSD或OpenIndiana）上运行。
- en: 'The simplest way to illustrate this is to manually query a port that will provide
    feedback. Here, I’m querying Port 13 on a remote network time server:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 最简单的说明方式是手动查询一个会提供反馈的端口。在这里，我查询了一个远程网络时间服务器的13端口：
- en: '[PRE7]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'You’ll also get feedback from Port 22, the SSH port, as you see here:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 你还会收到来自22端口（SSH端口）的反馈，正如你在这里看到的：
- en: '[PRE8]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: This one takes a bit longer to complete, because it takes a while for the authentication
    timer on the target machine to time out.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 这个过程完成起来稍微需要一些时间，因为目标机器上的身份验证计时器需要一段时间才能超时。
- en: In both of these examples, note how I’m using the input redirector (`<`) to
    obtain input from the `/dev/tcp` device. Then, after the `/dev/tcp/` part, I place
    the IP address of the target machine, and finally the port that I want to scan.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 在这两个示例中，请注意我如何使用输入重定向符号（`<`）从`/dev/tcp`设备获取输入。然后，在`/dev/tcp/`部分之后，我放入目标机器的IP地址，最后是我想要扫描的端口。
- en: 'Most ports won’t provide you with any kind of feedback. But, you can still
    tell if a port is open by how quickly the command executes. For example, if you
    query Port 53 on a DNS server, you should see that the command completes execution
    immediately, as you see here with the Google DNS server:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数端口不会向你提供任何反馈。但你仍然可以通过命令执行的速度判断端口是否开放。例如，如果你查询DNS服务器上的53端口，你应该看到命令立即完成执行，就像你在这里看到的Google
    DNS服务器一样：
- en: '[PRE9]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'So, I know that Port 53 is open. But, if I query a port that isn’t open, such
    as Port 54 in this case, it will be a very long time before the command-prompt
    returns with an error message, as you see here:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，我知道53端口是开放的。但是，如果我查询一个未开放的端口，比如在这个例子中的54端口，命令提示符返回错误信息会非常迟，正如你在这里看到的：
- en: '[PRE10]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Now, let’s leverage this knowledge by creating the `bash-portscan1.sh` script,
    like this:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们利用这些知识，通过创建`bash-portscan1.sh`脚本来实现，像这样：
- en: '[PRE11]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'It’s rather long, so I’ll break it down into sections. Here’s the top part:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 这个脚本比较长，我会分成几个部分。这里是上半部分：
- en: '[PRE12]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'To run this script, you’ll need to specify either the hostname or the IP address
    of the target machine, along with the range of ports that you want to scan. Easy
    enough so far, right? Next, we want to verify that the target machine is actually
    up, and create a variable assignment that we can use in the next step. Here’s
    how that looks:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 要运行这个脚本，你需要指定目标机器的主机名或IP地址，以及你想要扫描的端口范围。到目前为止，这很简单，对吧？接下来，我们要验证目标机器是否真的在线，并创建一个变量赋值，方便我们在下一步使用。它看起来是这样的：
- en: '[PRE13]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The value of the `ping` variable will be greater than 1, most likely 2, if
    the target machine is up and accessible. If the target machine isn’t accessible,
    the value will just be 1\. To see how this works, run this from the command-line,
    leaving off the `wc -l` part, like so:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 如果目标机器在线并且可访问，`ping`变量的值将大于1，通常为2。如果目标机器无法访问，则值将为1。要查看这如何工作，可以在命令行中运行此命令，去掉`wc
    -l`部分，如下所示：
- en: '[PRE14]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: I first pinged a machine that’s up, and got two lines of output. I then pinged
    a fictitious machine, and only received one line of output. The `wc -l` command
    will count those lines and assign the appropriate value to the `ping` variable.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 我首先对一个在线的机器进行了ping操作，并得到了两行输出。然后，我对一个虚拟机器进行了ping操作，只收到了一个输出行。`wc -l`命令将计算这些行并将适当的值赋给`ping`变量。
- en: 'Next, we have the `if. .else` block that causes the script to exit if the target
    machine isn’t up. Here’s how that looks:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们有一个`if...else`块，它会在目标机器不可用时使脚本退出。它看起来是这样的：
- en: '[PRE15]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Note how I had to surround `$ping` with a pair of double quotes. That’s because
    the value of `ping` will contain blank spaces, non-alphanumeric characters, and
    might consist of more than one line. Without the double quotes, `bash` won’t interpret
    the value of `ping` correctly.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 注意我必须用一对双引号将`$ping`括起来。这是因为`ping`的值可能包含空格、非字母数字字符，并且可能包含多行内容。如果没有双引号，`bash`将无法正确解析`ping`的值。
- en: 'Finally, we have the `for` loop that does the actual port scan. Here’s how
    it looks:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们有了执行实际端口扫描的`for`循环。它看起来是这样的：
- en: '[PRE16]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: This starts by assigning the value of the `startport` variable to the `counter`
    variable. The loop will continue as long as the value of `counter` is less than
    or equal to the value of `stopport`.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 这从将`startport`变量的值赋给`counter`变量开始。只要`counter`的值小于或等于`stopport`的值，循环就会继续。
- en: 'Now, here’s how it looks when I run the script:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，这是我运行脚本时的效果：
- en: '[PRE17]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: In the first instance, I scanned a range of ports, beginning with Port 20 and
    ending with Port 22\. Then, I scanned only Port 53 on the Google DNS server.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一次扫描中，我扫描了一个端口范围，从端口20开始，到端口22结束。然后，我只扫描了Google DNS服务器上的端口53。
- en: So you see, this works fine with either local or remote targets.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 所以你看到，这对于本地或远程目标都能正常工作。
- en: 'So far, we’ve only scanned TCP ports. But, you can also scan UDP ports by making
    one simple modification, as I’ve done in the `bash-portscan2.sh` script. In the
    `for` loop, just change `tcp` to `udp`, so that it will look like this:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们只扫描了TCP端口。但是，你也可以通过简单的修改来扫描UDP端口，就像我在`bash-portscan2.sh`脚本中所做的那样。在`for`循环中，只需将`tcp`改为`udp`，它看起来就像这样：
- en: '[PRE18]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Of course, you can fancy things up a bit more if you like. For example, you
    could combine the TCP and the UDP scan functions together into one script, and
    have some sort of menu that allows you to choose the one you want to do. Heck,
    for that matter, you could even add a `yad`, `dialog`, or `xdialog` interface.
    (I’ve shown you the techniques for all this in *Chapter 16, Creating User Interfaces
    with yad, dialog, and xdialog*.)
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，如果你喜欢的话，你可以让事情看起来更加复杂。例如，你可以将TCP和UDP扫描功能合并到一个脚本中，并添加一个菜单，允许你选择要执行的操作。甚至，你还可以加上`yad`、`dialog`或`xdialog`界面。（所有这些技巧，我在*第16章，使用yad、dialog和xdialog创建用户界面*中已经向你展示过了。）
- en: 'Now, you can get more detailed information about your target by using `nmap`
    to perform the scan, which would look something like this:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你可以使用`nmap`进行扫描，从而获取目标的更详细信息，类似这样：
- en: '[PRE19]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'This `-sS` type of scan, which is known as a SYN packet scan, requires `sudo`
    privileges. However, you can also do a `-sT` type of scan, which doesn’t require
    `sudo` privileges. Scanning open ports with our homemade script runs almost instantaneously.
    But scanning closed or filtered ports can be, but not always, faster with `nmap`.
    Still though, there is one possible advantage for using our script. It’s just
    that certain types of `nmap` scans can be blocked by adding a few rules to the
    target machine’s firewall. So, if you try to run an `nmap` scan against a machine
    and get no results, you might try using the script, instead. On the other hand,
    scanning open ports with the script can be a bit less stealthy, because it will
    leave tell-tale messages in the target machine’s system log files. For example,
    here’s the set of messages that resulted from using the script to scan Port 22
    on an AlmaLinux 9 machine:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 这种`-sS`类型的扫描，称为 SYN 包扫描，需要`sudo`权限。然而，你也可以进行`-sT`类型的扫描，这种扫描不需要`sudo`权限。使用我们自制的脚本扫描开放端口几乎是瞬间完成的。但扫描关闭或被过滤的端口，使用`nmap`可能会更快（但并不总是如此）。不过，使用我们脚本的一个潜在优势是，某些类型的`nmap`扫描可以通过向目标机器的防火墙添加几条规则来阻止。因此，如果你尝试对某台机器运行`nmap`扫描却没有结果，你可以尝试改用脚本。不过，使用脚本扫描开放端口的隐蔽性稍差，因为它会在目标机器的系统日志文件中留下明显的痕迹。例如，下面是使用脚本扫描
    AlmaLinux 9 机器上的端口 22 时产生的消息：
- en: '[PRE20]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Using the script to scan other open ports will create similar messages, while
    scanning closed ports won’t create any messages at all. If you use the script
    to scan an open webserver port, such as Port 80 or Port 443, you’ll instead see
    messages like this one in the webserver’s `access_log` file:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 使用脚本扫描其他开放端口时，会生成类似的消息，而扫描关闭端口则不会生成任何消息。如果你使用脚本扫描一个开放的 web 服务器端口，如端口 80 或端口
    443，你将在 web 服务器的`access_log`文件中看到类似这样的消息：
- en: '[PRE21]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: But, `nmap` won’t create any messages like these unless the target machine’s
    firewall is configured to log packets that come from `nmap` scans. So, there are
    advantages and disadvantages for both approaches.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，`nmap`不会生成这些消息，除非目标机器的防火墙配置为记录来自`nmap`扫描的包。因此，两种方法各有优缺点。
- en: On Red Hat-type machines, such as AlmaLinux, Rocky Linux, and RHEL, these messages
    will show up in the `/var/log/secure` file. On other distros, these messages might
    show up in either the `/var/log/messages` file or the `/var/log/syslog` file.
    Some Linux distros, such as Debian, no longer create any of these files by default.
    For them, you’ll need to either use the `sudo journalctl` command to view the
    messages, or install the `rsyslog` package from the normal distro repository so
    that you can have the normal text-mode log files..
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Red Hat 系列的机器上，如 AlmaLinux、Rocky Linux 和 RHEL，这些消息将出现在`/var/log/secure`文件中。在其他发行版中，这些消息可能会出现在`/var/log/messages`文件或`/var/log/syslog`文件中。一些
    Linux 发行版（如 Debian）默认不再创建这些文件。对于这些系统，你需要使用`sudo journalctl`命令来查看消息，或者从正常的发行版仓库安装`rsyslog`包，以便你能拥有正常的文本模式日志文件。
- en: Now, let’s do something a bit more complex.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们做一些更复杂的操作。
- en: Auditing the root User Account
  id: totrans-85
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 审计 root 用户账户
- en: Since I’m a security geek, I always advocate setting up Linux and Unix systems
    with the root user account disabled. That’s easy to do on many modern Linux systems,
    because you can configure things properly in the system installer. In fact, the
    Ubuntu installer won’t even let you enable the root user account, and will just
    automatically add the account that you created for yourself to the `sudo` group.
    (You can enable the root user account after you’ve installed the operating system,
    even though that’s not recommended practice.) For other Linux distros, such as
    Debian, Fedora, or members of the RHEL family, enabling the root user account
    during installation is optional. On most Unix-like systems such as FreeBSD and
    OpenIndiana, the installer will assign a password to the root user account. On
    FreeBSD, after installation has been completed, you’ll have to manually install
    `sudo`, set up a normal user account to use it, and then disable the root user
    account. On OpenIndiana, the normal user you create when you install the operating
    system will already be configured to have full `sudo` privileges, and the root
    account will also be enabled.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我是一名安全极客，我一直倡导在设置 Linux 和 Unix 系统时禁用 root 用户账户。在许多现代 Linux 系统上，这很容易做到，因为你可以在系统安装程序中正确配置。事实上，Ubuntu
    安装程序甚至不会让你启用 root 用户账户，而是会自动将你创建的账户添加到`sudo`组中。（你可以在安装操作系统后启用 root 用户账户，尽管这不是推荐的做法。）对于其他
    Linux 发行版，如 Debian、Fedora 或 RHEL 家族的成员，在安装过程中启用 root 用户账户是可选的。在大多数类 Unix 系统（如
    FreeBSD 和 OpenIndiana）上，安装程序会为 root 用户账户分配一个密码。在 FreeBSD 上，安装完成后，你需要手动安装`sudo`，设置一个普通用户账户来使用它，然后禁用
    root 用户账户。在 OpenIndiana 上，你在安装操作系统时创建的普通用户将自动配置为具有完全的`sudo`权限，且 root 账户也会被启用。
- en: So now, you want an easy way to audit your systems to see if the root user on
    them is enabled. Let’s begin by setting up a script that works equally well on
    either Linux or OpenIndiana systems.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你想要一种简单的方法来审计你的系统，看看它们的 root 用户是否已启用。我们从设置一个在 Linux 或 OpenIndiana 系统上都能很好工作的脚本开始。
- en: Creating the root Account Auditing Script for Linux and OpenIndiana
  id: totrans-88
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 为 Linux 和 OpenIndiana 创建 root 账户审计脚本
- en: We’ll begin with the `rootlock_1.sh` script, which you can download from the
    Github repository. This is another one of those scripts that’s too long to show
    here in its entirety. That’s okay though, because it’s easier to explain if I
    break it down into sections.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从`rootlock_1.sh`脚本开始，你可以从 Github 仓库下载该脚本。这是另一个太长无法在这里完整展示的脚本。没关系，因为如果我将其分解成几个部分来解释，会更容易理解。
- en: 'The first thing I want to do is to initialize a couple of variables, like so:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 我首先要做的是初始化一些变量，如下所示：
- en: '[PRE22]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: OpenIndiana and most Linux systems come with `bash` installed by default, and
    both use the same shadow file system. So, the same exact script works for either
    one. Eventually though, I might want to modify it so that it will run on some
    of the BSD-type operating systems, which are set up differently. To prepare for
    that, I’ll use the output of the `uname` command as the value for the `os` variable,
    so that I can ensure that the correct code will always run on each operating system.
    I also want to know how many user accounts there are that have an assigned UID
    value of 0, so I’ll create the `quantity` variable to keep track of that. To obtain
    that value, I need to use the `cut -f3 -d:` command to look at the third field
    of each `passwd` file entry, and then pipe that into the `grep -w 0` command to
    only find the lines that contain nothing but a 0 in that field. Finally, I use
    the `wc -l` command to count the number of lines that match this criterion.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: OpenIndiana 和大多数 Linux 系统默认都安装了`bash`，并且两者使用相同的影子文件系统。因此，完全相同的脚本适用于这两者。不过，最终我可能会想对其进行修改，使其可以在一些
    BSD 类型的操作系统上运行，因为这些系统的设置方式不同。为此，我将使用`uname`命令的输出作为`os`变量的值，以确保每个操作系统上总是运行正确的代码。我还想知道有多少个用户账户的
    UID 值为 0，因此我将创建`quantity`变量来追踪这一点。为了获取该值，我需要使用`cut -f3 -d:`命令查看每个`passwd`文件条目的第三字段，然后将其通过管道传输给`grep
    -w 0`命令，只查找该字段中仅包含 0 的行。最后，我使用`wc -l`命令来计算匹配此标准的行数。
- en: Remember that the UID value of 0 is what gives user accounts full root user
    privileges. On most operating systems, you should never see more than one UID
    0 user account. On some BSD-type systems, you’ll see either two or three UID 0
    accounts. One will be the root account, which might have either `csh` or `sh`
    assigned as the default shell. A second one will be the toor account, which will
    have `sh` assigned as the default shell. DragonflyBSD has a third UID 0 account
    which is called, installer. So, if you want to write one script that will cover
    all of these different operating systems, you’ll need to write code that will
    account for each one having a different number of UID 0 accounts. (We’ll look
    at all that later in this section.)
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，UID 为 0 的值赋予用户账户完全的根用户权限。在大多数操作系统中，你不应该看到多个 UID 为 0 的用户账户。在某些 BSD 类型的系统中，你会看到两个或三个
    UID 0 的账户。其中一个是 root 账户，可能将 `csh` 或 `sh` 设置为默认 shell。第二个是 toor 账户，默认 shell 为 `sh`。DragonflyBSD
    有一个第三个 UID 0 账户，名为 installer。因此，如果你想编写一个适用于所有这些不同操作系统的脚本，你需要编写能够处理每个系统拥有不同数量 UID
    0 账户的代码。（稍后我们会在本节中详细讨论这些内容。）
- en: 'Next, I’ve created the `linux_sunos` function, which contains the bulk of the
    working code. Here’s how it looks:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我创建了 `linux_sunos` 函数，它包含了大部分工作代码。它是这样的：
- en: '[PRE23]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: The top part is easy. It’s just an `if. .then. .else` construct that alerts
    you if there are more than one UID 0 accounts in the `/etc/passwd` file.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 顶部部分很简单。它只是一个 `if...then...else` 结构，如果 `/etc/passwd` 文件中有多个 UID 0 账户，则会提醒你。
- en: Next, I use an `awk` command, with its output piped into `cut -c1`, to find
    the root user account line in the `/etc/shadow` file, and to isolate the value
    of the first character of the second field of that line. That value will be assigned
    to the `rootlock` variable. So, what is so significant about that character? Well,
    here’s the deal.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我使用 `awk` 命令，将其输出通过管道传输到 `cut -c1`，以查找 `/etc/shadow` 文件中根用户账户的行，并隔离该行第二个字段的第一个字符的值。这个值将被分配给
    `rootlock` 变量。那么，这个字符有什么重要性呢？好吧，事情是这样的。
- en: 'On Linux, Unix, and Unix-like systems, a list of user accounts is kept in the
    `/etc/passwd` file. This file must always be world-readable, so that users can
    access their user account information when they log in. Many years ago, when I
    was young and still had a full head of hair, user passwords were also kept in
    this `passwd` file. Eventually, someone figured out that keeping passwords in
    a world-readable file is a security problem, and invented the **shadow file system**.
    Now, the hashed values of all users’ passwords are in the `/etc/shadow` file on
    Linux and Solaris/OpenIndiana systems, which requires root privileges to read.
    (It’s a bit different on BSD-type systems, as I’ll show you in just a bit.) For
    example, here’s the entry for my own user account on my Fedora Server virtual
    machine:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Linux、Unix 及类 Unix 系统中，用户账户的列表保存在 `/etc/passwd` 文件中。该文件必须始终对所有用户可读，以便用户在登录时可以访问他们的账户信息。许多年前，当我年轻时，仍然满头黑发，用户密码也保存在这个
    `passwd` 文件中。最终，有人意识到将密码保存在一个全局可读的文件中是一个安全问题，并发明了 **shadow 文件系统**。现在，所有用户密码的哈希值都保存在
    Linux 和 Solaris/OpenIndiana 系统的 `/etc/shadow` 文件中，读取该文件需要根用户权限。（在 BSD 类型的系统中有些不同，稍后我会向你展示。）例如，以下是我自己在
    Fedora Server 虚拟机上的用户账户条目：
- en: '[PRE24]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: (Note that this is one long line that wraps around on the printed page. Also
    note that I changed a couple of characters, to prevent revealing the real hash
    value.)
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: （请注意，这是一行很长的内容，在打印页面上会换行。同时注意，我改变了几个字符，以防泄露真实的哈希值。）
- en: What I want you to note is the prefix of this hashed value, which is `$y$`.
    The leading `$` indicates that this account is enabled, and the whole `$y$` thing
    indicates that the password was hashed by the **yescrypt** hashing algorithm.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 我希望你注意到这个哈希值的前缀，即 `$y$`。前导的 `$` 表示该账户已启用，而整个 `$y$` 表示密码是通过 **yescrypt** 哈希算法加密的。
- en: Since Fedora is a cutting-edge, somewhat experimental Linux distro, you can
    expect it to use new technologies that aren’t yet widely used by the rest of the
    Linux ecosystem. Such is the case here with Fedora’s use of yescrypt. On most
    modern Linux distros, you’ll see a `$6$` prefix on the password hash, which indicates
    that they’re using the SHA512 hashing algorithm. Although SHA512 hashes are very
    difficult to crack, yescrypt hashes are supposed to be even more difficult, which
    enhances password security.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 Fedora 是一个前沿的、稍微实验性的 Linux 发行版，你可以期待它使用一些还未广泛应用于其他 Linux 生态系统中的新技术。这里就是 Fedora
    使用 yescrypt 的例子。在大多数现代 Linux 发行版中，你会在密码哈希的前面看到`$6$`，这表示它们使用的是 SHA512 哈希算法。虽然 SHA512
    哈希很难破解，但 yescrypt 哈希据说更难破解，从而增强了密码安全性。
- en: 'For our present purposes, it doesn’t matter which hashing algorithm is in use.
    All we care about is that leading `$`, because that’s what tells us that the account
    is enabled. If anything other than a `$` is in that first position, then the account
    is disabled. For best security, you want to see something like any of these three
    lines in the `/etc/shadow` file:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们当前的目的，使用什么哈希算法并不重要。我们关心的只是前导的 `$`，因为它告诉我们该账户已启用。如果该位置的字符不是 `$`，则账户已禁用。为了获得最佳安全性，你希望在
    `/etc/shadow` 文件中看到类似以下三行的内容：
- en: '[PRE25]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Now, here’s the sort of thing that you don’t want to see:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，以下是你不想看到的情况：
- en: '[PRE26]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'On this virtual machine, the root account is enabled, as indicated by the leading
    `$`. And, this takes us back to the `linux_sunos` function in our script. Let’s
    take another look at the line that creates the `rootlock` variable:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 在这台虚拟机上，根账户已启用，如前导符号 `$` 所示。这将我们带回到脚本中的 `linux_sunos` 函数。让我们再看看创建 `rootlock`
    变量的那一行：
- en: '[PRE27]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: As I pointed out before, this `awk` command isolates the second field of the
    root user’s entry, which is the password field. Piping the `awk` output into the
    `cut -c1` command isolates the first character of that field. The value of that
    character is then assigned as the value of the `rootlock` variable.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 如我之前所指出的，这个 `awk` 命令提取了根用户条目的第二个字段，即密码字段。将 `awk` 输出通过管道传输到 `cut -c1` 命令，会提取该字段的第一个字符。该字符的值随后被赋值给
    `rootlock` 变量。
- en: 'Next up is the code that determines whether or not the root user account is
    locked:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来是决定根用户账户是否被锁定的代码：
- en: '[PRE28]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: This says that if the first character of the second field of the root user’s
    entry is a `$`, then the account is not locked. If that first character is anything
    other than a `$`, then the account is locked, and all is good.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 这表示，如果根用户条目的第二个字段的第一个字符是`$`，那么该账户未被锁定。如果第一个字符是其他任何字符，则该账户被锁定，一切正常。
- en: Note that in this `if. .then. .else` construct I had to surround `$rootlock`
    with a pair of double quotes. That’s because on some Linux distros, such as Ubuntu,
    you might see an `*` in the password field of the root user’s `shadow` file entry.
    Without the double quotes, the shell will interpret the `*` as a wildcard, and
    will cause `$rootlock` to return the list of files in the current working directory.
    Using the double quotes allows the `$` to do its job, while forcing the shell
    to interpret the `*` in a literal manner.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，在这个 `if...then...else` 结构中，我必须用一对双引号将 `$rootlock` 包围起来。这是因为在某些 Linux 发行版中，如
    Ubuntu，你可能会在根用户的 `shadow` 文件条目的密码字段中看到一个 `*`。如果没有双引号，Shell 会将 `*` 解释为通配符，这会导致
    `$rootlock` 返回当前工作目录中的文件列表。使用双引号可以确保 `$` 正常工作，同时强制 Shell 以字面意义解释 `*`。
- en: For good measure, I also surrounded the `$` with a pair of single quotes, to
    ensure that that the shell would interpret it correctly. (It actually worked fine
    when I tested it without the single quotes, but it’s better to be safe.)
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 为了确保准确，我还用一对单引号将 `$` 包围，以确保 Shell 能正确解释它。（实际上，在我测试时，即使没有单引号也能正常工作，但为了安全起见，最好加上。）
- en: 'Now, at the very end of the script, after the function, you see this:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在脚本的最后部分，在函数之后，你会看到以下内容：
- en: '[PRE29]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: The value of the `os` variable should be `Linux` on a Linux system, and `SunOS`
    on an OpenIndiana system. Either way, the `linux_sunos` function will run. If
    the value of `os` is anything else, the user will see an error message.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: '`os` 变量的值应该在 Linux 系统上为 `Linux`，在 OpenIndiana 系统上为 `SunOS`。无论哪种情况，`linux_sunos`
    函数都会运行。如果 `os` 的值为其他任何值，用户将看到错误消息。'
- en: 'Finally, let’s test this script to see what happens. Here’s what it looks like
    on the Fedora workstation that I’m using to write this:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，让我们测试一下这个脚本，看看会发生什么。以下是在我用来编写本文的 Fedora 工作站上的显示效果：
- en: '[PRE30]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Very cool, it all looks good.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 非常酷，一切看起来不错。
- en: 'To see how it looks when the root account is enabled, I pulled up my Fedora
    Server virtual machine, which has never had the root account enabled. I enabled
    the root account like this:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 为了查看启用 root 账户后的样子，我启动了我的 Fedora Server 虚拟机，该虚拟机从未启用过 root 账户。我像这样启用了 root 账户：
- en: '[PRE31]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Easy, right? All I had to do was to assign a password to the root user account.
    Now, let’s run the script:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 很简单，对吧？我只需要为 root 用户账户分配一个密码。现在，让我们运行脚本：
- en: '[PRE32]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Now, let’s add the option to disable the root account, as you see in the `rootlock_2.sh`
    script. We’ll do that by embedding another `if. .then. .else` construct within
    the one that’s already there. Here’s how it looks:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们在 `rootlock_2.sh` 脚本中添加禁用 root 账户的选项。我们将通过在已经存在的 `if...then...else` 结构中嵌入另一个结构来做到这一点。它的样子是这样的：
- en: '[PRE33]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Here’s how running the modified script looks:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 运行修改后的脚本是这样的：
- en: '[PRE34]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'To disable an account, the `passwd -l` command places a pair of exclamation
    points in front of the password hash, like this:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 要禁用一个账户，`passwd -l` 命令会在密码哈希前加上一对感叹号，像这样：
- en: '[PRE35]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'The password hash is still there, but the operating system can no longer read
    it. This will allow you to unlock the account by running:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 密码哈希仍然存在，但操作系统无法再读取它。这将允许你通过运行以下命令解锁账户：
- en: '[PRE36]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'To both delete the password and disable the account, place a `passwd -d root`
    command on the line before the `passwd -l root` command, so that the construct
    will now look like this:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 要删除密码并禁用账户，将 `passwd -d root` 命令放在 `passwd -l root` 命令之前，这样构造将变成这样：
- en: '[PRE37]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Note that you can’t use both the `-l` and `-d` options for `passwd` in a single
    command. To use both options, you’ll need to run two separate commands. Also note
    that if you just use the `-d` option, you’ll delete the password hash but the
    account is still considered as enabled. Running `passwd -l` after running `passwd
    -d` will both delete the password hash and disable the account.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，你不能在一个命令中同时使用 `-l` 和 `-d` 选项。要使用这两个选项，你需要分别运行两个命令。还需要注意的是，如果你只使用 `-d` 选项，虽然会删除密码哈希，但账户仍然被视为启用状态。在运行
    `passwd -d` 后，如果再运行 `passwd -l`，将既删除密码哈希，又禁用账户。
- en: And, although you probably already know this, I’ll tell you anyway. Before you
    disable the root user account, be darned sure that you’re logged in as a normal
    user with full `sudo` privileges, instead of as the root user. That way, there
    will be no chance of accidentally disabling the root account on a machine for
    which nobody else has any admin privileges.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然你可能已经知道这一点，但我还是告诉你。在禁用 root 用户账户之前，一定要确保你是以具有完整 `sudo` 权限的普通用户身份登录，而不是以 root
    用户身份登录。这样，才不会意外地禁用没有其他管理员权限的机器上的 root 账户。
- en: The only way to re-enable root’s account now is to create a new password, as
    you’ve already seen.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 现在重新启用 root 账户的唯一方法就是创建一个新密码，正如你已经看到的那样。
- en: That covers it for Linux and OpenIndiana. Let’s see if we can make this work
    on FreeBSD.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 这涵盖了 Linux 和 OpenIndiana。现在让我们看看能否在 FreeBSD 上使其工作。
- en: Modifying the root Account Auditing Script for Use on FreeBSD
  id: totrans-139
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 修改 root 账户审计脚本以在 FreeBSD 上使用
- en: On BSD-type operating systems, such as FreeBSD, the `/etc/master.passwd` file
    is used instead of the `/etc/shadow` file. In addition to the UID 0 root user
    account in the `/etc/passwd` file, there’s the toor user account, which is also
    a UID 0 account. So, we’ll need to add a `freebsd` function to work with these
    differences.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 在 BSD 类型操作系统（如 FreeBSD）中，使用的是 `/etc/master.passwd` 文件，而不是 `/etc/shadow` 文件。除了
    `/etc/passwd` 文件中的 UID 0 的 root 用户账户外，还有一个 UID 0 的 toor 用户账户。因此，我们需要添加一个 `freebsd`
    功能来处理这些差异。
- en: Up through FreeBSD 13, the root user account has `csh` assigned as its default
    shell, and the toor account has `sh` assigned as the default shell. Now, on FreeBSD
    14, both of these UID 0 accounts have `sh` as the default shell.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 在 FreeBSD 13 之前，root 用户账户的默认 shell 是 `csh`，而 toor 账户的默认 shell 是 `sh`。但在 FreeBSD
    14 中，这两个 UID 0 的账户默认 shell 都是 `sh`。
- en: 'The simplest way to do this is to add a new function, which I’ll call `freebsd`.
    (Really, what else would I call it?) You’ll find this new function in the `rootlock_3.sh`
    script that’s in the Github repository. Let’s break this new function into sections
    to see what we have. Here’s the top part:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 最简单的做法是添加一个新功能，我将其命名为 `freebsd`。（实际上，还能叫什么呢？）你可以在 Github 仓库中的 `rootlock_3.sh`
    脚本中找到这个新功能。让我们将这个新功能分解成几个部分来看它包含了什么。这里是顶部部分：
- en: '[PRE38]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'This is the same as the `linux_sunos` function that we just looked at, except
    that it now checks for more than two UID 0 accounts in the `passwd` file. Here’s
    the next part:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 这与我们刚刚查看的`linux_sunos`函数相同，只是现在它检查`passwd`文件中超过两个UID 0账户。这里是接下来的部分：
- en: '[PRE39]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'I had to modify the `awk` command so that it will only find “root” in the first
    field of a line, as you see here with the `$1 ~ /root/` part:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 我不得不修改`awk`命令，以便它只在一行的第一个字段中找到“root”，就像你在这里看到的那样，使用了`$1 ~ /root/`部分：
- en: '[PRE40]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'That’s because, unlike the Linux and OpenIndiana `shadow` files, the FreeBSD
    `master.passwd` file lists users’ default home directories. As you see here, the
    default home directories for the first three users are set to the `/root/` directory:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 这是因为，与Linux和OpenIndiana的`shadow`文件不同，FreeBSD的`master.passwd`文件列出了用户的默认主目录。正如你在这里看到的，前三个用户的默认主目录设置为`/root/`目录：
- en: '[PRE41]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: Having `/root/` instead of `$1 ~ /root/` in the `awk` command causes the script
    to read all three of these lines, instead of just the first one that’s for the
    root user. This prevents the script from properly detecting if the root user account
    is enabled. That’s because if the script sees a `$` in field 2 of the root line,
    and then sees an `*` in field 2 of the toor and daemon lines, it will assign the
    `*` as the final value of `rootlock`. Because of that, the script will always
    show that the root account is locked, even when it isn’t.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 在`awk`命令中使用`/root/`而不是`$1 ~ /root/`导致脚本读取了所有这三行，而不仅仅是用于root用户的第一行。这会阻止脚本正确检测root用户帐户是否已启用。因为如果脚本在root行的字段2中看到`$`，然后在toor和daemon行的字段2中看到`*`，它将把`*`作为`rootlock`的最终值。因此，即使root帐户没有被锁定，脚本也会始终显示root帐户被锁定。
- en: 'I also had to change the commands that lock the root and toor accounts, because
    the FreeBSD version of `passwd` doesn’t have the proper option switches to do
    that. So, I replaced the two `passwd` commands with:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 我还不得不更改锁定root和toor帐户的命令，因为FreeBSD版本的`passwd`没有适当的选项开关来执行此操作。因此，我用以下两个`passwd`命令替换了它们：
- en: '[PRE42]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: This handy command both removes the password and locks the account at the same
    time.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 这个方便的命令同时删除密码并锁定帐户。
- en: 'Since FreeBSD also has the toor account with UID 0, I’ve added another section
    to check for that:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 由于FreeBSD还有UID 0的toor帐户，我添加了另一部分来检查它：
- en: '[PRE43]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: Only one line in the `master.passwd` file contains the word “toor”, so I didn’t
    need to tell `awk` to look for the `/toor/` pattern in only the first field. Other
    than that, it’s the same as what I’ve just shown you for the root user. (Of course,
    since this is the end of the function, I’ve included the closing curly brace at
    the end.)
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 在`master.passwd`文件中只有一行包含单词“toor”，所以我不需要告诉`awk`只在第一个字段中查找`/toor/`模式。除此之外，它与我刚刚为root用户展示的内容相同。（当然，因为这是函数的结尾，我在末尾包含了闭合的大括号。）
- en: 'Finally, I’ve modified the final part of the script so that it will automatically
    choose which function to run:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我修改了脚本的最后部分，以便它将自动选择要运行的功能：
- en: '[PRE44]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: You’ve seen this sort of thing before in previous chapters, so you likely already
    know what’s going on with this.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 你在之前的章节中已经见过这种情况，所以你可能已经知道这里正在发生什么。
- en: Once again, I’m reading your mind. You’re thinking about how cool this script
    is, and how much you’d like to use it on an entire fleet of mixed Linux, Unix,
    and Unix-like servers. The problem though, is that this script is written for
    `bash` and uses some of the `bash` advanced features that don’t work on many of
    the legacy `sh` shells. That’s great if you can install `bash` on all of your
    Unix and Unix-like servers, but that might not be an option. Also, if you’re working
    with Internet of Things devices that run lightweight versions of Linux, you might
    not be able to install `bash` on them either. So, what do you do? Well, hang on,
    because I’ll explain all of that in *Chapter 19, Shell Script Portability*.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 再次阅读你的思维。你正在考虑这个脚本有多酷，以及你想在一个混合的Linux、Unix和类Unix服务器群上使用它。然而问题在于，这个脚本是为`bash`编写的，并使用了一些`bash`的高级特性，这些特性在许多传统的`sh`
    shell上不起作用。如果你能在所有的Unix和类Unix服务器上安装`bash`，那就太好了，但这可能不是一个选择。另外，如果你在使用运行轻量级Linux的物联网设备，可能也无法在它们上安装`bash`。那么，你该怎么办？好吧，稍等，因为我将在*第19章，Shell脚本可移植性*中解释这一切。
- en: I think that this about covers it for the `rootlock` scripts. Let’s look at
    one more auditing script before wrapping up this section.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 我认为这差不多涵盖了`rootlock`脚本。在结束本节之前，让我们再看一个审计脚本。
- en: Creating a User Activity Monitoring Script
  id: totrans-162
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建一个用户活动监控脚本
- en: 'In this scenario, you want to see a record of when other users have logged
    into the system, and what they’re doing with their `sudo` privileges. To do that,
    let’s create the `user_activity_1.sh script`. Here’s the top section:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，你希望查看其他用户何时登录到系统，以及他们如何使用自己的`sudo`权限。为此，让我们创建`user_activity_1.sh`脚本。以下是脚本的顶部部分：
- en: '[PRE45]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'This tells you that you have to supply a user name when invoking this script.
    If you don’t specify a user name, you’ll see this message, and the script will
    exit. Here’s the next part:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 这告诉你，在调用此脚本时必须提供用户名。如果没有指定用户名，你将看到此消息，并且脚本会退出。接下来是这部分内容：
- en: '[PRE46]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: Most Linux and some Unix/Unix-like distros store user authentication messages
    in either the `/var/log/secure` file or the `/var/log/auth.log` file. SUSE and
    openSUSE are notable exceptions to this rule, because they store this information
    in the `/var/log/messages` file.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数Linux和一些Unix/类Unix发行版会将用户认证消息存储在`/var/log/secure`文件或`/var/log/auth.log`文件中。SUSE和openSUSE是这一规则的显著例外，因为它们将这些信息存储在`/var/log/messages`文件中。
- en: I’m assuming here that you’re working with a distro that has either `rsyslog`
    or `syslog` installed. This script won’t work if all you have is `journald`.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 我假设你正在使用一个安装了`rsyslog`或`syslog`的发行版。如果你只有`journald`，那么这个脚本是无法工作的。
- en: Finally, here’s the part that does the actual work.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，这部分才是实际执行工作的部分。
- en: '[PRE47]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: Okay, it’s easy. It’s just creating a report file with the user’s name and a
    timestamp in the filename. The `last` command creates the record of the user’s
    logins, and the `grep` command searches through the designated file for all lines
    that contain the *sudo* text string. Then, it pipes that output into `grep` to
    search for all lines that contain the designated user name.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 好吧，很简单。它只是创建一个包含用户名和时间戳的报告文件，文件名中带有时间戳。`last`命令会生成用户登录的记录，`grep`命令会在指定的文件中搜索所有包含*sudo*字符串的行。然后，它将这些输出通过管道传输给`grep`，继续搜索包含指定用户名的所有行。
- en: 'Now, let’s run the script to see what that Donnie character has been doing:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们运行脚本，看看Donnie这个角色在做什么：
- en: '[PRE48]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'Very cool. You see that the script has created a report file with my username
    and the current date and time in the filename. Here’s a snippet of what you’ll
    see in that report file:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 非常酷。你看到脚本创建了一个报告文件，文件名中包含了我的用户名和当前的日期与时间。这是你在报告文件中会看到的一部分内容：
- en: '[PRE49]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: I’ve tested this script on Fedora Server, Ubuntu Server, openSUSE, FreeBSD,
    and OpenBSD. (Note that I installed `bash` on both of the BSD distros.)
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 我已经在Fedora Server、Ubuntu Server、openSUSE、FreeBSD和OpenBSD上测试了这个脚本。（请注意，我在这两个BSD发行版上都安装了`bash`。）
- en: Okay, I think that that’s about it for the auditing scripts. Let’s see what
    we can do with a firewall script.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，我想审计脚本差不多就是这样了。让我们看看可以用防火墙脚本做些什么。
- en: Creating Simple Firewall Scripts
  id: totrans-178
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建简单的防火墙脚本
- en: In this scenario, you need to create a text file with a list of IP addresses
    that you want to block. You then need to create a shell script that will read
    that list of IP addresses, and then create firewall rules that will block them.
    There are two ways that you can do this. First, there’s the hard way. And then,
    there’s the easy way.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，你需要创建一个文本文件，列出你想要封锁的IP地址。然后，你需要创建一个shell脚本，读取这些IP地址，并创建封锁它们的防火墙规则。你可以通过两种方式来实现这一点。首先是较难的方式，然后是简单的方式。
- en: The hard way consists of reading the list of addresses into a variable array,
    and then creating a `for` loop that will create a blocking rule for each IP address
    that’s in the array. Okay, it’s not that hard, but it is a bit harder than we
    would like. (I’ll show you the easy way after I show you the hard way. That way,
    you’ll be more appreciative of the easy way.)
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 难的方法是将IP地址列表读入一个变量数组，然后创建一个`for`循环，为数组中的每个IP地址创建一个封锁规则。好吧，这并不是非常困难，但比我们希望的稍微难一点。（在我展示了难的方法后，我会给你展示简单的方法。这样，你会更加感激简单的方法。）
- en: Creating an IP Address Blocking Script for Red Hat Distros
  id: totrans-181
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 为Red Hat发行版创建IP地址封锁脚本
- en: Red Hat-type distros, such as Fedora, AlmaLinux, Rocky Linux, Oracle Linux,
    and of course Red Hat Enterprise Linux, use `firewalld` as their firewall management
    utility, and `nftables` as the actual firewall engine. To my knowledge, the only
    non-Red Hat Linux distros that come with this setup installed by default are SUSE
    and openSUSE.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: Red Hat类型的发行版，如Fedora、AlmaLinux、Rocky Linux、Oracle Linux，以及当然还有Red Hat Enterprise
    Linux，使用`firewalld`作为其防火墙管理工具，并且使用`nftables`作为实际的防火墙引擎。根据我所知，唯一默认安装这个设置的非Red Hat
    Linux发行版是SUSE和openSUSE。
- en: The `firewall-cmd` utility is the main way to manage `firewalld` rules, policies
    and configuration. To see how this works, let’s do a couple of hands-on labs.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: '`firewall-cmd` 工具是管理 `firewalld` 规则、策略和配置的主要方式。为了了解它是如何工作的，让我们做几个动手实验。'
- en: 'Hands-on Lab: Create the Script with an Array and a for loop'
  id: totrans-184
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 动手实验：使用数组和 for 循环创建脚本
- en: In this lab, you’ll create a script that builds a variable array by reading
    the list of IP addresses from the `ip-address_blacklist.txt` file. You’ll then
    use a `for` loop to create a firewall rule for each IP address in the list.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个实验中，你将创建一个脚本，通过读取 `ip-address_blacklist.txt` 文件中的 IP 地址列表来构建一个变量数组。然后，你将使用
    `for` 循环为列表中的每个 IP 地址创建一个防火墙规则。
- en: '1\. On the Fedora Server virtual machine, create the `ip-address_blacklist.txt`
    file, with one IP address on each line. Make it look something like this:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 1\. 在 Fedora Server 虚拟机上，创建 `ip-address_blacklist.txt` 文件，每行一个 IP 地址。它应该像这样：
- en: '[PRE50]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: '2\. Now, create the `firewall-blacklist_array.sh` script, which uses a variable
    array and a `for` loop. Make it look like this:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 2\. 现在，创建 `firewall-blacklist_array.sh` 脚本，使用一个变量数组和一个 `for` 循环。它应该像这样：
- en: '[PRE51]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: The first thing we’re doing here is to declare and build the `badips` array,
    as I showed you in *Chapter 8, Basic Shell Script Construction*. This array obtains
    its values from the `ip-address_blacklist.txt` file that we’ve just created. Within
    the `for` loop, you see the `firewall-cmd` command that creates a firewall rule
    for each IP address that we loaded into the `badips` array. Whenever you use the
    `--permanent` option the `firewall-cmd` command will write the new rules to the
    proper configuration file. But, it won’t load the new rules into the running firewall.
    The final `firewall-cmd --reload` command loads the new rules so that they will
    take effect.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里做的第一件事是声明并构建 `badips` 数组，就像我在 *第8章 基本 Shell 脚本构建* 中展示的那样。这个数组从我们刚刚创建的 `ip-address_blacklist.txt`
    文件中获取其值。在 `for` 循环中，你会看到 `firewall-cmd` 命令，它为每个我们加载到 `badips` 数组中的 IP 地址创建一个防火墙规则。每当你使用
    `--permanent` 选项时，`firewall-cmd` 命令会将新规则写入相应的配置文件。但它不会将新规则加载到正在运行的防火墙中。最后的 `firewall-cmd
    --reload` 命令会加载新规则，使其生效。
- en: '3\. Run this script on your Fedora virtual machine. You should receive one
    success message for each IP address, and a final success message after the reload
    command. Here’s how it looks:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 3\. 在你的 Fedora 虚拟机上运行此脚本。你应该会收到每个 IP 地址的一个成功消息，并在重载命令后收到一个最终的成功消息。它看起来是这样的：
- en: '[PRE52]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: '4\. To verify that the rules have taken effect, use the `nft list ruleset`
    command, and then scroll back to where you’ll see the new rules. Here’s how that
    looks:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 4\. 要验证规则是否生效，使用 `nft list ruleset` 命令，然后向上滚动查看新规则。它看起来是这样的：
- en: '[PRE53]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: '5\. To see if the rules have been added permanently, look at the proper configuration
    file in the `/etc/firewalld/zones/` directory, like this:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 5\. 要查看规则是否已永久添加，请查看 `/etc/firewalld/zones/` 目录中的相应配置文件，像这样：
- en: '[PRE54]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: Note that the name of this configuration file will be different on other distros,
    such as AlmaLinux, Rocky Linux, Red Hat Enterprise Linux, or SUSE/openSUSE.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，这个配置文件的名称在其他发行版中会有所不同，比如 AlmaLinux、Rocky Linux、Red Hat Enterprise Linux
    或 SUSE/openSUSE。
- en: Also, be aware that different Linux distros come with different firewall management
    utilities. For example, Ubuntu comes with the **Uncomplicated Firewall** (`ufw`)
    firewall manager, and other distros might just have you use plain `nftables` without
    a management utility. Once you know the proper firewall management commands for
    your particular distro, it’s a simple matter to modify this script to work with
    it. (If you need to learn more about Linux firewalls, you might like to check
    out one of my other books, *Mastering Linux Security and Hardening*, which is
    available from both Amazon and directly from Packt Publishing.)
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 另外，请注意，不同的 Linux 发行版可能配有不同的防火墙管理工具。例如，Ubuntu 配备 **简单防火墙** (`ufw`) 防火墙管理工具，其他发行版可能仅让你使用简单的
    `nftables`，而没有管理工具。一旦你知道适用于你特定发行版的防火墙管理命令，修改这个脚本以使其适应就非常简单了。（如果你需要更多了解 Linux 防火墙的内容，可能会想看看我的另一本书，《精通
    Linux 安全与加固》，这本书可以在亚马逊以及 Packt 出版社直接购买。）
- en: End of lab.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 实验结束。
- en: Okay, that wasn’t too difficult, was it? Hang on, though. Let’s make this even
    easier with `xargs`.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 好了，这还不算太难，对吧？不过，稍等一下。让我们用 `xargs` 让这个变得更简单。
- en: 'Hands-on Lab: Creating the Script with xargs'
  id: totrans-201
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 动手实验：使用 xargs 创建脚本
- en: Back in *Chapter 7, Text Stream Filters–Part 2*, I introduced you to the `xargs`
    utility. I showed you a few examples of how to use it in the context of text stream
    filters, and I also promised that I would show you more examples of how to use
    it later. You can vastly simplify this type of script by using `xargs` instead
    of variable arrays and `for` loops. As before, I’ll show you how it’s done with
    the Red Hat family.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 在*第7章，文本流过滤器–第二部分*中，我介绍了`xargs`工具。我向你展示了在文本流过滤器的上下文中如何使用它的一些例子，并且我还承诺稍后会向你展示更多的使用例子。通过使用`xargs`而不是变量数组和`for`循环，你可以大大简化这种类型的脚本。像之前一样，我会向你展示如何在Red
    Hat家族系统中进行操作。
- en: '1\. Create the `firewall-blacklist_xargs.sh` script, like this:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 1\. 创建`firewall-blacklist_xargs.sh`脚本，像这样：
- en: '[PRE55]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: (Note that the `xargs` line is a long line that wraps around on the printed
    page.)
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: （注意，`xargs`这一行是很长的，可能会在打印页面上换行。）
- en: As before, the first command is just a normal `firewall-cmd` command that creates
    the blocking rules. In this case, we’re preceding the command with `xargs -i`
    so that it will read the list of IP addresses from the `ip-address_blacklist.txt`
    file, one at a time. In a normal `firewall-cmd` command, you would place either
    an IP address or a range of IP addresses after the `source address=` part. This
    time though, we’ve placed a pair of curly braces there. The `xargs` utility will
    cause the `firewall-cmd` command to run once for each IP address that it finds
    in the `ip-address_blacklist.txt` file. Each time that the command runs, the next
    IP address in the list will be placed within the pair of curly braces. The `--permanent`
    option in this `firewall-cmd` command is what saves the new rules to the proper
    rules file. Using this `--permanent` option requires you to run the `firewall-cmd
    --reload` command in order to make the new rules take effect.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 和之前一样，第一个命令是一个普通的`firewall-cmd`命令，用于创建阻止规则。在这个例子中，我们在命令前加上了`xargs -i`，这样它就会从`ip-address_blacklist.txt`文件中逐个读取IP地址。在普通的`firewall-cmd`命令中，你会在`source
    address=`后面放入一个IP地址或IP地址范围。但这次我们放置了一对大括号。`xargs`工具会使得`firewall-cmd`命令针对`ip-address_blacklist.txt`文件中找到的每个IP地址执行一次。每次执行时，列表中的下一个IP地址将被放入大括号内。`firewall-cmd`命令中的`--permanent`选项会将新的规则保存到正确的规则文件中。使用`--permanent`选项时，需要运行`firewall-cmd
    --reload`命令才能使新规则生效。
- en: '2\. Edit the `ip-address_blacklist.txt` file to add a few more IP addresses.
    Then, run the script. The output should now look something like this:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 2\. 编辑`ip-address_blacklist.txt`文件，添加一些更多的IP地址。然后运行脚本。输出应该类似于这样：
- en: '[PRE56]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: '3\. Verify that the new rules have taken effect:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 3\. 验证新规则是否生效：
- en: '[PRE57]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: Note how with the last rule, I opted to block an entire IP address subnet. This
    capability could come in handy if you ever need to block an entire country from
    accessing your server, for example.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，在最后一条规则中，我选择阻止整个IP地址子网。这个功能如果你需要阻止一个国家访问你的服务器时可能会派上用场。
- en: 'If you ever do need to block an entire country, you can find lists of IP address
    ranges for various countries here:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你确实需要阻止一个整个国家的IP地址，可以在这里找到各种国家的IP地址范围列表：
- en: '[https://lite.ip2location.com/ip-address-ranges-by-country](https://lite.ip2location.com/ip-address-ranges-by-country)'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://lite.ip2location.com/ip-address-ranges-by-country](https://lite.ip2location.com/ip-address-ranges-by-country)'
- en: 4\. Open the `/etc/firewalld/zones/FedoraServer.xml` file in your text editor,
    and remove the rules that you’ve just created.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 4\. 打开`/etc/firewalld/zones/FedoraServer.xml`文件，在文本编辑器中删除你刚才创建的规则。
- en: '5\. Finally, clear the rules out of the running firewall by doing:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 5\. 最后，通过以下操作清除正在运行的防火墙中的规则：
- en: '[PRE58]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: End of lab.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 实验结束。
- en: Now, is that slick, or is that slick? I mean, by using `xargs` instead of variable
    arrays and `for` loops, you’ve vastly simplified this script. Also, using `xargs`
    makes your scripts more portable. That’s because you can use `xargs` on pretty
    much any type of Linux, Unix, or Unix-like shell. On the other hand, you can use
    variable arrays with `bash`, but not with certain variations of `sh`. (I’ll talk
    more about portability in *Chapter 19, Shell Script Portability*.) So really,
    having `xargs` in our toolbox is what I call a win-win!
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，这是不是很酷？我的意思是，通过使用`xargs`而不是变量数组和`for`循环，你大大简化了这个脚本。而且，使用`xargs`让你的脚本更加便于移植。因为你几乎可以在任何类型的Linux、Unix或类Unix的shell中使用`xargs`。另一方面，虽然你可以在`bash`中使用变量数组，但在某些`sh`变体中却不能使用。（关于移植性，我会在*第19章，Shell脚本的移植性*中详细讲解。）所以，真的，把`xargs`放入我们的工具箱中，算得上是双赢！
- en: Next, let’s see if we can save ourselves a bit of work.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们看看是否能节省一些工作。
- en: Searching for Existing Security-related Scripts
  id: totrans-220
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 搜索现有的与安全相关的脚本
- en: A basic tenet of computer programming is to reuse code as much as possible.
    Otherwise, every programmer in the world would waste huge amounts of time trying
    to always reinvent the proverbial wheel. So, if you find yourself in need of a
    script and don’t know how to write it yourself, you can search for one either
    by using your favorite search engine or by searching on Github.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 计算机编程的一个基本原则是尽可能重用代码。否则，世界上每个程序员都会浪费大量时间试图重新发明那个“轮子”。因此，如果你需要一个脚本而又不知道如何编写，你可以通过使用你最喜欢的搜索引擎或在Github上搜索来找到它。
- en: 'The only catch with using search engines is that you might have to try several
    different search terms to find what you need. For example, I tried the following
    search terms on DuckDuckGo:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 使用搜索引擎的唯一问题是，你可能需要尝试几个不同的搜索词才能找到你需要的东西。例如，我在DuckDuckGo上尝试了以下搜索词：
- en: bash scripts for security audit
  id: totrans-223
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用于安全审计的bash脚本
- en: bash scripting for pentesters
  id: totrans-224
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用于渗透测试员的bash脚本
- en: bash scripts for security administrators
  id: totrans-225
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用于安全管理员的bash脚本
- en: bash scripting for cybersecurity
  id: totrans-226
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用于网络安全的bash脚本
- en: As a matter of full disclosure, I have to say that most of these search results
    were for courses and books for which you’ll have to pay. If that’s what you need
    or want, then great. But, mixed in with all that you might find some gems that
    will either help you with your immediate problem or that will give you some good
    ideas for your own scripts.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 需要完全披露的是，大多数这些搜索结果都是针对需要付费的课程和书籍。如果那正是你需要或想要的，那很好。但是，在这些结果中，你也许能找到一些对你当前问题有帮助的“宝藏”，或者为你自己的脚本提供一些不错的想法。
- en: 'For more concise and useful search results, you might consider searching for
    scripts on Github. Here, for example, I searched for the term, *bash security
    scripts*:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 为了获得更简洁和有用的搜索结果，你可以考虑在Github上搜索脚本。例如，我搜索了*bash安全脚本*：
- en: '![B21693_18_1](img/B21693_18_01.png)'
  id: totrans-229
  prefs: []
  type: TYPE_IMG
  zh: '![B21693_18_1](img/B21693_18_01.png)'
- en: 'Figure 18.1: Searching for bash security scripts on Github'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 图18.1：在Github上搜索bash安全脚本
- en: You’ll find lots of repositories from many different authors like this. Most,
    if not all, of these scripts are released under a free-as-in-freedom software
    license, so you can download them and use them as you wish. Of course, you’ll
    want to review and test the scripts before you put them into production use. Some
    of them will work on your systems without modification, and some won’t. So, just
    because you’re able to find scripts that someone else has already written doesn’t
    mean that you can just skate by without any knowledge of shell scripting.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 你会找到很多来自不同作者的代码库。大多数，甚至是所有这些脚本，都发布在“自由软件许可”下，因此你可以下载并按照自己的需要使用。当然，在将它们投入生产使用之前，你需要先审查和测试这些脚本。它们中的一些在你的系统上可以直接使用，而有些则不行。所以，仅仅因为你能找到别人已经编写的脚本，并不意味着你可以在不具备任何shell脚本知识的情况下轻松应对。
- en: All right, I think that about covers it. Let’s summarize and then move on to
    the next chapter.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，我想这大致涵盖了内容。让我们总结一下，然后进入下一章。
- en: Summary
  id: totrans-233
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, I didn’t introduce a lot of new scripting concepts as I normally
    do. Instead, I showed you how to use the concepts that you already know to create
    scripts that might be useful to a security-conscious administrator. You’ve seen
    how to create shell scripts that can do simple port scans or operating system
    identification. Then, you saw how to create auditing scripts that can show if
    the root user account is enabled, when a normal user is logging into the system,
    and what a normal user is doing with his or her `sudo` privileges. After that,
    I showed you a script that can read a list of IP addresses, and automatically
    create firewall rules to block those addresses. Finally, I showed you some tips
    about how to find and use scripts that other people have already created.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我没有像通常那样介绍很多新的脚本概念。相反，我向你展示了如何利用你已经掌握的概念来创建可能对注重安全的管理员有用的脚本。你已经看到了如何创建可以执行简单端口扫描或操作系统识别的shell脚本。然后，你看到了如何创建审计脚本，这些脚本可以显示root用户账户是否启用，普通用户何时登录系统，以及普通用户在使用`sudo`权限时做了什么。之后，我展示了一个脚本，它可以读取IP地址列表，并自动创建防火墙规则来阻止这些地址。最后，我向你展示了一些如何查找和使用别人已经创建的脚本的技巧。
- en: In the next chapter, we’ll talk a bit about shell script portability. I’ll see
    you there.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将讨论一些关于shell脚本可移植性的内容。我在下一章见。
- en: Questions
  id: totrans-236
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: When you do a port scan of a remote machine and find ports that are in a closed
    state, what does that mean?
  id: totrans-237
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当你对远程机器进行端口扫描并发现某些端口处于关闭状态时，这意味着什么？
- en: That the ports are blocked by a firewall.
  id: totrans-238
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 端口被防火墙阻止。
- en: That the ports are not blocked by a firewall, and that the associated services
    for those ports are not running.
  id: totrans-239
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 端口未被防火墙阻止，并且与这些端口相关的服务未运行。
- en: That the ports are not blocked by a firewall, and that the associated services
    for those ports are running.
  id: totrans-240
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 端口未被防火墙阻止，并且与这些端口相关的服务正在运行。
- en: That the remote machine can’t be reached by your port scanner.
  id: totrans-241
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 远程机器无法通过您的端口扫描器访问。
- en: You’re looking for the `/etc/shadow` file on a FreeBSD system, but can’t find
    it. What could be the problem?
  id: totrans-242
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您在FreeBSD系统上寻找`/etc/shadow`文件，但找不到它。可能是什么问题？
- en: FreeBSD keeps its account passwords in the `/etc/passwd` file.
  id: totrans-243
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: FreeBSD将其账户密码保存在`/etc/passwd`文件中。
- en: FreeBSD keeps its account passwords in the `/var/lib/` directory.
  id: totrans-244
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: FreeBSD将其账户密码保存在`/var/lib/`目录中。
- en: FreeBSD uses the `/etc/master.passwd` file instead of the `/etc/shadow` file.
  id: totrans-245
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: FreeBSD使用`/etc/master.passwd`文件，而不是`/etc/shadow`文件。
- en: FreeBSD doesn’t require passwords.
  id: totrans-246
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: FreeBSD不需要密码。
- en: Which of the following statements is true?
  id: totrans-247
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下哪项陈述是正确的？
- en: There is no advantage to using `xargs` in your scripts.
  id: totrans-248
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在您的脚本中使用`xargs`没有任何优势。
- en: Using `xargs` can make your scripts easier to create, easier to read, and can
    enhance script portability.
  id: totrans-249
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`xargs`可以让您的脚本更易创建、更易阅读，并能提高脚本的可移植性。
- en: Using `xarg`s makes your scripts more complex and harder to understand.
  id: totrans-250
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`xarg`使您的脚本更加复杂，且更难理解。
- en: Further Reading
  id: totrans-251
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 深入阅读
- en: 'Introduction to Bash for Cybersecurity: [https://medium.com/@aardvarkinfinity/introduction-to-bash-for-cybersecurity-56792984bcc0](mailto:https://medium.com/@aardvarkinfinity/introduction-to-bash-for-cybersecurity-56792984bcc0)'
  id: totrans-252
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 网络安全入门-Bash使用简介：[https://medium.com/@aardvarkinfinity/introduction-to-bash-for-cybersecurity-56792984bcc0](mailto:https://medium.com/@aardvarkinfinity/introduction-to-bash-for-cybersecurity-56792984bcc0)
- en: 'Shell Scripting and Security: [https://www.linuxjournal.com/content/shell-scripting-and-security](https://www.linuxjournal.com/content/shell-scripting-and-security)'
  id: totrans-253
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Shell脚本与安全：[https://www.linuxjournal.com/content/shell-scripting-and-security](https://www.linuxjournal.com/content/shell-scripting-and-security)
- en: 'HackSploit Blog-Bash Scripting: [https://hackersploit.org/bash-scripting/](https://hackersploit.org/bash-scripting/)'
  id: totrans-254
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: HackSploit博客-Bash脚本：[https://hackersploit.org/bash-scripting/](https://hackersploit.org/bash-scripting/)
- en: 'Is Bash the Secret Weapon of Cybersecurity Experts?: [https://cyberinsight.co/is-bash-used-in-cyber-security/](https://cyberinsight.co/is-bash-used-in-cyber-security/)'
  id: totrans-255
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Bash是网络安全专家的秘密武器吗？：[https://cyberinsight.co/is-bash-used-in-cyber-security/](https://cyberinsight.co/is-bash-used-in-cyber-security/)
- en: 'Secure Scripting: A Step-by-Step Guide to Password Automation in Linux with
    Bash: [https://medium.com/@GeorgeBaidooJr/secure-scripting-a-step-by-step-guide-to-password-automation-in-linux-with-bash-12aa6b980acf](mailto:https://medium.com/@GeorgeBaidooJr/secure-scripting-a-step-by-step-guide-to-password-automation-in-linux-with-bash-12aa6b980acf)'
  id: totrans-256
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 安全脚本：在Linux上使用Bash进行密码自动化的分步指南：[https://medium.com/@GeorgeBaidooJr/secure-scripting-a-step-by-step-guide-to-password-automation-in-linux-with-bash-12aa6b980acf](mailto:https://medium.com/@GeorgeBaidooJr/secure-scripting-a-step-by-step-guide-to-password-automation-in-linux-with-bash-12aa6b980acf)
- en: Answers
  id: totrans-257
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 答案
- en: b
  id: totrans-258
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: b
- en: c
  id: totrans-259
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: c
- en: b
  id: totrans-260
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: b
- en: Join our community on Discord!
  id: totrans-261
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 加入我们的Discord社区！
- en: Read this book alongside other users, Linux experts, and the author himself.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 与其他用户、Linux专家以及作者本人一起阅读本书。
- en: Ask questions, provide solutions to other readers, chat with the author via
    Ask Me Anything sessions, and much more. Scan the QR code or visit the link to
    join the community.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 提问、为其他读者提供解决方案、通过“问我任何问题”环节与作者互动，等等。扫描二维码或访问链接加入社区。
- en: '[https://packt.link/SecNet](https://packt.link/SecNet)'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://packt.link/SecNet](https://packt.link/SecNet)'
- en: '![](img/QR_Code10596186092701843.png)'
  id: totrans-265
  prefs: []
  type: TYPE_IMG
  zh: '![](img/QR_Code10596186092701843.png)'
- en: Leave a Review!
  id: totrans-266
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 留下您的评论！
- en: Thank you for purchasing this book from Packt Publishing—we hope you enjoy it!
    Your feedback is invaluable and helps us improve and grow. Once you've completed
    reading it, please take a moment to leave an Amazon review; it will only take
    a minute, but it makes a big difference for readers like you.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 感谢您从Packt出版社购买本书——我们希望您喜欢它！您的反馈对我们非常宝贵，帮助我们不断改进和成长。阅读完本书后，请花一点时间在亚马逊上留下评价；这只需要一分钟，但对像您这样的读者来说，意义重大。
- en: Scan the QR code below to receive a free ebook of your choice.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 扫描下面的二维码以接收您选择的免费电子书。
- en: '[https://packt.link/NzOWQ](https://packt.link/NzOWQ)'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://packt.link/NzOWQ](https://packt.link/NzOWQ)'
- en: '![](img/review.png)'
  id: totrans-270
  prefs: []
  type: TYPE_IMG
  zh: '![](img/review.png)'
