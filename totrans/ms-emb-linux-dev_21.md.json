["```\n#include <stdio.h>\n#include <stdlib.h>\n#include <unistd.h>\n#include <sys/types.h>\n#include <sys/wait.h>\nint main(void)\n{\n    int pid;\n    int status;\n    pid = fork();\n    if (pid == 0) {\n        printf(\"I am the child, PID %d\\n\", getpid());\n        sleep(10);\n        exit(42);\n    } else if (pid > 0) {\n        printf(\"I am the parent, PID %d\\n\", getpid());\n        wait(&status);\n        printf(\"Child terminated, status %d\\n\", WEXITSTATUS(status));\n    } else {\n        perror(\"fork:\");\n    }\n    return 0;\n} \n```", "```\nI am the parent, PID 13851\nI am the child, PID 13852\nChild terminated with status 42 \n```", "```\nint execl(const char *path, const char *arg, ...);\nint execlp(const char *file, const char *arg, ...);\nint execle(const char *path, const char *arg, ..., char * const envp[]);\nint execv(const char *path, char *const argv[]);\nint execvp(const char *file, char *const argv[]);\nint execvpe(const char *file, char *const argv[], ..., char *const envp[]); \n```", "```\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <unistd.h>\n#include <sys/types.h>\n#include <sys/wait.h>\nint main(int argc, char *argv[])\n{\n    char command_str[128];\n    int pid;\n    int child_status;\n    int wait_for = 1;\n    while (1) {\n        printf(\"sh> \");\n        scanf(\"%s\", command_str);\n        pid = fork();\n        if (pid == 0) {\n            /* child */\n            printf(\"cmd '%s'\\n\", command_str);\n            execl(command_str, command_str, (char *)NULL);\n            /* We should not return from execl, so only get\n              to this line if it failed */\n            perror(\"exec\");\n            exit(1);\n        }\n        if (wait_for) {\n            waitpid(pid, &child_status, 0);\n            printf(\"Done, status %d\\n\", child_status);\n        }\n     }\n     return 0;\n} \n```", "```\n# ./exec-demo\nsh> /bin/ls\ncmd '/bin/ls'\nbin etc lost+found proc sys var\nboot home media run tmp\ndev lib mnt sbin usr\nDone, status 0\nsh> \n```", "```\n#define SHM_SEGMENT_NAME \"/demo-shm\" \n```", "```\nint shm_fd;\nstruct shared_data *shm_p;\n/* Attempt to create the shared memory segment */\nshm_fd = shm_open(SHM_SEGMENT_NAME, O_CREAT | O_EXCL | O_RDWR, 0666);\nif (shm_fd > 0) {\n    /* succeeded: expand it to the desired size (Note: dont't\n       do this every time because ftruncate fills it with zeros) */\n    printf(\"Creating shared memory and setting size=%d\\n\",\n    SHM_SEGMENT_SIZE);\n    if (ftruncate(shm_fd, SHM_SEGMENT_SIZE) < 0) {\n        perror(\"ftruncate\");\n        exit(1);\n    }\n    <…>\n} else if (shm_fd == -1 && errno == EEXIST) {\n    /* Already exists: open again without O_CREAT */\n    Shm_fd = shm_open(SHM_SEGMENT_NAME, O_RDWR, 0);\n    <…>\n} \n```", "```\n/* Map the shared memory */\nshm_p = mmap(NULL, SHM_SEGMENT_SIZE, PROT_READ | PROT_WRITE, MAP_SHARED, shm_fd, 0); \n```", "```\nstatic sem_t *demo_sem;\n<…>\nint main(int argc, char *argv[])\n{\n    char *shm_p;\n    printf(\"%s PID=%d\\n\", argv[0], getpid());\n    shm_p = get_shared_memory();\n    while (1) {\n        printf(\"Press enter to see the current contents of shm\\n\");\n        getchar();\n        sem_wait(demo_sem);\n        printf(\"%s\\n\", shm_p);\n        /* Write our signature to the shared memory */\n        sprintf(shm_p, \"Hello from process %d\\n\", getpid());\n        sem_post(demo_sem);\n    }\n    return 0;\n} \n```", "```\n# ./shared-mem-demo\n./shared-mem-demo PID=271\nCreating shared memory and setting size=65536\nPress enter to see the current contents of shm\nPress enter to see the current contents of shm\nHello from process 271 \n```", "```\n# ./shared-mem-demo\n./shared-mem-demo PID=279\nPress enter to see the current contents of shm\nHello from process 271\nPress enter to see the current contents of shm\nHello from process 279 \n```", "```\n$ aarch64-buildroot-linux-gnu-gcc shared-mem-demo.c -lrt -pthread -o shared-mem-demo \n```", "```\nint pthread_create(pthread_t *restrict thread, const pthread_attr_t *restrict attr, typeof(void *(void *)) *start_routine, void *restrict arg); \n```", "```\nUID PID PPID LWP C NLWP STIME TTY TIME CMD\n<...>\nchris 6072 5648 6072 0 3 21:18 pts/0 00:00:00 ./thread-demo\nchris 6072 5648 6073 0 3 21:18 pts/0 00:00:00 ./thread-demo \n```", "```\n#include <stdio.h>\n#include <unistd.h>\n#include <pthread.h>\n#include <sys/syscall.h>\nstatic void *thread_fn(void *arg)\n{\n    printf(\"New thread started, PID %d TID %d\\n\",\n        getpid(), (pid_t)syscall(SYS_gettid));\n    sleep(10);\n    printf(\"New thread terminating\\n\");\n    return NULL;\n}\nint main(int argc, char *argv[])\n{\n    pthread_t t;\n    printf(\"Main thread, PID %d TID %d\\n\",\n        getpid(), (pid_t)syscall(SYS_gettid));\n    pthread_create(&t, NULL, thread_fn, NULL);\n    pthread_join(t, NULL);\n    return 0;\n} \n```", "```\n#include <stdio.h>\n#include <stdlib.h>\n#include <pthread.h>\n#include <unistd.h>\n#include <string.h>\nchar g_data[128];\npthread_cond_t cv = PTHREAD_COND_INITIALIZER;\npthread_mutex_t mutx = PTHREAD_MUTEX_INITIALIZER;\nvoid *consumer(void *arg)\n{\n    while (1) {\n        pthread_mutex_lock(&mutx);\n        while (strlen(g_data) == 0)\n            pthread_cond_wait(&cv, &mutx);\n        /* Got data */\n        printf(\"%s\\n\", g_data);\n        /* Truncate to null string again */\n        g_data[0] = 0;\n        pthread_mutex_unlock(&mutx);\n    }\n    return NULL;\n}\nvoid *producer(void *arg)\n{\n    int i = 0;\n    while (1) {\n        sleep(1);\n        pthread_mutex_lock(&mutx);\n        sprintf(g_data, \"Data item %d\", i);\n        pthread_mutex_unlock(&mutx);\n        pthread_cond_signal(&cv);\n        i++;\n    }\n    return NULL;\n} \n```", "```\n    (base) $ cd MELD/Chapter17/zeromq \n    ```", "```\n    (base) $ conda create --name zeromq python=3.12 pyzmq \n    ```", "```\n    (base) $ conda activate zeromq \n    ```", "```\n    (zeromq) $ python –-version \n    ```", "```\n    (zeromq) $ conda list \n    ```", "```\nimport time\nimport zmq\ncontext = zmq.Context()\nsocket = context.socket(zmq.REP)\nsocket.bind(\"tcp://*:5555\")\nwhile True:\n    # Wait for next request from client\n    message = socket.recv_pyobj()\n    print(f\"Received request: {message}\")\n    # Do some 'work'\n    time.sleep(1)\n    # Send reply back to client\n    socket.send_pyobj(f\"Hello {message}\") \n```", "```\nimport zmq\ndef main(who):\n    context = zmq.Context()\n    # Socket to talk to server\n    print(\"Connecting to echo server...\")\n    socket = context.socket(zmq.REQ)\n    socket.connect(\"tcp://localhost:5555\")\n    # Do 5 requests, waiting each time for a response\n    for request in range(5):\n        print(f\"Sending request {request} ...\")\n        socket.send_pyobj(who)\n        # Get the reply.\n        message = socket.recv_pyobj()\n        print(f\"Received reply {request} [ {message} ]\")\nif __name__ == '__main__':\n    import sys\n    if len(sys.argv) != 2:\n        print(\"usage: client.py <username>\")\n        raise SystemExit\n    main(sys.argv[1]) \n```", "```\n(zeromq) $ ./planets.sh \n```", "```\nimport asyncio\nimport time\nimport zmq\nfrom zmq.asyncio import Context, Poller\nurl = 'inproc://#1'\nctx = Context.instance()\nasync def ping() -> None:\n    \"\"\"print dots to indicate idleness\"\"\"\n    while True:\n        await asyncio.sleep(0.5)\n        print('.')\nasync def receiver() -> None:\n    \"\"\"receive messages with polling\"\"\"\n    pull = ctx.socket(zmq.PAIR)\n    pull.connect(url)\n    poller = Poller()\n    poller.register(pull, zmq.POLLIN)\n    while True:\n        events = await poller.poll()\n        if pull in dict(events):\n            print(\"recving\", events)\n            msg = await pull.recv_multipart()\n            print('recvd', msg)\nasync def sender() -> None:\n    \"\"\"send a message every second\"\"\"\n    tic = time.time()\n    push = ctx.socket(zmq.PAIR)\n    push.bind(url)\n    while True:\n        print(\"sending\")\n        await push.send_multipart([str(time.time() - tic).encode('ascii')])\n        await asyncio.sleep(1)\nasync def main() -> None:\n    tasks = [asyncio.create_task(coroutine()) for coroutine in [ping, receiver, sender]]\n    await asyncio.wait(tasks)\nif __name__ == \"__main__\":\n    asyncio.run(main()) \n```", "```\n(zeromq) $ python coroutines.py \n```", "```\nstruct sched_param {\n    <…>\n    int sched_priority;\n    <…>\n};\nint sched_setscheduler(pid_t pid, int policy,\n    const struct sched_param *param);\nint sched_getscheduler(pid_t pid); \n```", "```\nint pthread_setschedparam(pthread_t thread, int policy,\n    const struct sched_param *param);\nint pthread_getschedparam(pthread_t thread, int *policy,\n    struct sched_param *param); \n```"]