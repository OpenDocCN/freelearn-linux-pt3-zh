- en: '*Chapter 3*: Using Commands and Services for Process Management'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第3章*：使用命令和服务进行进程管理'
- en: Managing processes is an important job of a Linux system administrator. That
    can be for a variety of reasons – maybe some processes got stuck and we need to
    finish them, or we want to set some process(es) to work in the background or even
    to be started periodically or at a later date. Whatever the scenario is, it's
    important to know how to administer processes and make them do the work that needs
    to be done efficiently and with regard to other processes running on the system.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 管理进程是 Linux 系统管理员的一项重要工作。原因有很多——也许某些进程卡住了，我们需要结束它们，或者我们希望将某些进程设置为后台运行，甚至是定期或在稍后的日期启动。不管是什么情况，了解如何管理进程并使它们有效地完成需要做的工作，同时考虑到系统上其他进程的运行，都是非常重要的。
- en: 'In this chapter, we are going to learn about the following recipes:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将学习以下内容：
- en: Process management tools
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 进程管理工具
- en: Managing background jobs
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 管理后台任务
- en: Managing process priorities
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 管理进程优先级
- en: Configuring `crond`
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 配置 `crond`
- en: Technical requirements
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'For these recipes, we''re going to use a Linux machine – we can use any virtual
    machine from our previous recipes. Again, we can just continue using the `cli1`
    machine that we used in the previous chapter. So, to sum this up, we need the
    following:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这些操作，我们将使用一台 Linux 机器——我们可以使用之前教程中任何虚拟机。再次提醒，我们可以继续使用前一章中使用的`cli1`机器。那么，总结来说，我们需要以下内容：
- en: A virtual machine with Linux installed, any distribution (in our case, it's
    going to be Ubuntu 20.10)
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一台安装了 Linux 的虚拟机，任何发行版（在我们的例子中，将使用 Ubuntu 20.10）
- en: So, start your virtual machine and let's get cracking!
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，启动你的虚拟机，开始吧！
- en: Process management tools
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进程管理工具
- en: Managing processes means learning about the ways in which processes work and
    the specific text-mode tools that we can use to manage them. We are going to start
    by introducing some simple concepts – explain what processes are and which states
    they can be in – and then we're going to move on to commands and how to use them
    to manage processes from an administrative standpoint. That means that we are
    going to learn 10+ new commands/concepts that are necessary to understand how
    all of this works.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 管理进程意味着了解进程的工作方式以及我们可以用来管理它们的特定文本模式工具。我们将从介绍一些简单的概念开始——解释什么是进程以及它们可能处于哪些状态——然后我们将继续讲解命令以及如何从管理的角度使用这些命令来管理进程。这意味着我们将学习10个以上的新命令/概念，这些是理解这一切如何运作所必需的。
- en: Getting ready
  id: totrans-13
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'The vast majority of commands and utilities that we are going to use in this
    recipe come pre-installed with our Linux distribution. That being said, there
    are a couple of cool additional tools we can use to further drive the point of
    managing processes and system resources home. So, let''s install one more utility
    as it''s capable of being used as a tool to monitor system resources along with
    low-level stuff, such as working with processes. It''s called `glances`; let''s
    install it by typing the following:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在本教程中，我们将使用的大多数命令和工具都预先安装在我们的 Linux 发行版中。话虽如此，还有一些很棒的额外工具，我们可以用来进一步加深对进程管理和系统资源管理的理解。所以，让我们安装另一个工具，它能够作为监控系统资源的工具，并且能够处理低级任务，例如处理进程。它叫做
    `glances`；我们可以通过输入以下命令来安装它：
- en: '[PRE0]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: That should cover everything that we need in this recipe, so let's get cracking!
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 这些应该覆盖了我们在本教程中需要的所有内容，现在开始吧！
- en: How to do it…
  id: totrans-17
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作…
- en: The first two commands that we must cover are `ps` and `top`. These are commands
    that Linux system administrators use dozens of times on a daily basis if they're
    managing a Linux server. Both of these commands are very valuable, as we can get
    a lot of information about our system if we know how to use them properly, especially
    `ps`.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 我们必须先讲解的前两个命令是 `ps` 和 `top`。这些命令是 Linux 系统管理员每天都会使用几十次的命令，尤其是在管理 Linux 服务器时。这两个命令都非常有价值，因为如果我们知道如何正确使用它们，我们可以获得大量关于系统的信息，特别是
    `ps` 命令。
- en: 'So, let''s first use `ps` as a command without any additional options (of which
    there are many):'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，首先我们使用没有任何附加选项的 `ps` 命令（选项有很多）：
- en: '![Figure 3.1 – Default ps command output'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 3.1 – 默认 ps 命令输出'
- en: '](img/Figure_3.1_B16269.jpg)'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_3.1_B16269.jpg)'
- en: Figure 3.1 – Default ps command output
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.1 – 默认 ps 命令输出
- en: By default, `ps` gives us a report about currently running processes. By starting
    it in a shell without any additional options, we can get a list of processes running
    in our current shell. We can already see some interesting information in this
    output. For starters, we can see five processes and their IDs (the `PID` field
    on the left side). Then, we can see where they're running, which is what the `TTY`
    field is all about. The `TIME` field tells us how much accumulated CPU time the
    process has used so far. Furthest to the right, we can see the `CMD` field, which
    tells us the name of an actual process that was started.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，`ps`会给我们当前正在运行的进程报告。我们可以在没有任何附加选项的情况下启动它，从而获取当前 shell 中正在运行的进程列表。在这个输出中，我们已经可以看到一些有趣的信息。首先，我们可以看到五个进程及其
    ID（左侧的`PID`字段）。接着，我们可以看到它们的运行位置，这就是`TTY`字段的含义。`TIME`字段告诉我们进程到目前为止使用了多少累计的 CPU
    时间。最右侧是`CMD`字段，显示了启动的实际进程名称。
- en: 'To fully appreciate the power of the `ps` command, we really need to look to
    its man page. There''s a really nice `EXAMPLES` section in it. Here''s an excerpt
    from that section:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 要充分理解`ps`命令的强大功能，我们需要查看它的手册页面。里面有一个非常好的`EXAMPLES`部分。以下是该部分的摘录：
- en: '![Figure 3.2 – Example for using the ps command'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 3.2 – 使用 ps 命令的示例'
- en: '](img/Figure_3.2_B16269.jpg)'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_3.2_B16269.jpg)'
- en: Figure 3.2 – Example for using the ps command
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.2 – 使用 ps 命令的示例
- en: 'Let''s use an extreme derivative of one of these examples. Let''s type the
    following command:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用这些示例中的一个极端派生。我们来输入以下命令：
- en: '[PRE1]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'We used the `| less` part of this command to output just the first page of
    the `ps` command output. The output should look something like this:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用了`| less`部分来仅输出`ps`命令输出的第一页。输出应该类似于这样：
- en: '![Figure 3.3 – ps auwwx command output (much more verbose)'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 3.3 – ps auwwx 命令输出（更加冗长）'
- en: '](img/Figure_3.3_B16269.jpg)'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_3.3_B16269.jpg)'
- en: Figure 3.3 – ps auwwx command output (much more verbose)
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.3 – ps auwwx 命令输出（更加冗长）
- en: 'As we can clearly see, there''s a lot more detail in this output sorted by
    `PID`. Some of the newly added fields include the following:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们清楚看到的，这个输出比之前按`PID`排序的输出包含了更多的细节。一些新增的字段包括：
- en: '`USER`: This field tells us the name of the user who started the process.'
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`USER`：此字段告诉我们启动进程的用户的名字。'
- en: '`%CPU`: This field tells us how much CPU time the process uses.'
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`%CPU`：此字段告诉我们进程使用了多少 CPU 时间。'
- en: '`%MEM`: This field tells us how much memory the process uses.'
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`%MEM`：此字段告诉我们进程使用了多少内存。'
- en: '`VSZ`: This field tells us how much virtual memory the process uses.'
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`VSZ`：此字段告诉我们进程使用了多少虚拟内存。'
- en: '`RSS`: Resident Set Size, the amount of non-swapped memory used by the process.'
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`RSS`：常驻集大小，进程使用的非交换内存量。'
- en: '`STAT`: Process status code.'
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`STAT`：进程状态代码。'
- en: '`START`: Time when the process was started.'
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`START`：进程启动的时间。'
- en: Just as an example, a lot of system administrators use the `%CPU` and `%MEM`
    fields to find processes that are using too much CPU or memory.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 作为一个示例，许多系统管理员使用`%CPU`和`%MEM`字段来查找使用过多 CPU 或内存的进程。
- en: 'Let''s say that we need to find a process by name. There are multiple ways
    of doing this, the most common two being using either the `ps` command or the
    `pgrep` command. Let''s see how that would work:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们需要通过进程名称来查找一个进程。有多种方法可以实现这一点，其中最常见的两种方法是使用`ps`命令或`pgrep`命令。让我们看看它们是如何工作的：
- en: '![Figure 3.4 – Using pgrep or ps to find a process by name'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 3.4 – 使用 pgrep 或 ps 按名称查找进程'
- en: '](img/Figure_3.4_B16269.jpg)'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_3.4_B16269.jpg)'
- en: Figure 3.4 – Using pgrep or ps to find a process by name
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.4 – 使用 pgrep 或 ps 按名称查找进程
- en: 'As a command, we tend to use `grep` to create a filter that will find a text
    sample by going through text output. We can see that both commands gave us the
    result that we needed – it''s just formatted differently and with a different
    level of detail. We can also use the `pidof` command to find a PID for any given
    process, similar to `pgrep`:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 作为一种命令，我们通常使用`grep`来创建一个过滤器，查找文本输出中的特定文本。我们可以看到这两个命令都给出了我们需要的结果——它们只是以不同的格式和不同的详细程度显示结果。我们还可以使用`pidof`命令来查找任何给定进程的
    PID，类似于`pgrep`：
- en: '![Figure 3.5 – Using the pidof command'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 3.5 – 使用 pidof 命令'
- en: '](img/Figure_3.5_B16269.jpg)'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_3.5_B16269.jpg)'
- en: Figure 3.5 – Using the pidof command
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.5 – 使用 pidof 命令
- en: 'Let''s now explain the idea of the `top` command. After we start the `top`
    command, we should get something similar to this:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们来解释一下`top`命令的概念。在启动`top`命令后，我们应该会看到类似这样的内容：
- en: '![Figure 3.6 – Using the top command'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 3.6 – 使用 top 命令'
- en: '](img/Figure_3.6_B16269.jpg)'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_3.6_B16269.jpg)'
- en: Figure 3.6 – Using the top command
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.6 – 使用 `top` 命令
- en: 'There are multiple things happening in this interactive output at the same
    time:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个交互式输出中，多个操作正在同时发生：
- en: The `top` line is actually output from the `uptime` command. If we add the next
    four lines (beginning with `Tasks`, `%Cpu(s)`, `Mib Mem`, and `MiB Swap`), that
    is what we call the top *summary area*.
  id: totrans-56
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`top` 行实际上是来自 `uptime` 命令的输出。如果我们添加接下来的四行（从 `Tasks`、`%Cpu(s)`、`Mib Mem` 和 `MiB
    Swap` 开始），这就是我们所说的顶部 *摘要区域*。'
- en: After that, we can clearly see that `top` acts as a frontend to the `ps` command
    but is implemented in an interactive sense.
  id: totrans-57
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 之后，我们可以清楚地看到，`top` 作为 `ps` 命令的前端，但以交互方式实现。
- en: The interactive part of the `top` command stems from the fact that it actually
    refreshes regularly – by default, every 3 seconds. We can change that default
    refresh interval by pressing the *S* key, which will make `top` ask us to change
    the delay from `3.0` to any number. If we want to change the refresh interval
    to `1` second, we just press `1` and *Enter*.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: '`top` 命令的交互式部分源于它定期刷新——默认情况下是每 3 秒刷新一次。我们可以通过按 *S* 键来更改默认刷新间隔，这时 `top` 会提示我们将延迟从
    `3.0` 更改为任何数字。如果我们想将刷新间隔更改为 `1` 秒，只需按下 `1` 并按 *Enter*。'
- en: We can ask `top` to show us processes by a single user (by pressing *U* and
    typing in the user's login name) and to kill processes (by pressing *K* and typing
    in the PID and the signal we want to send to that PID). We can also manipulate
    process priority, which we will cover in our *third* recipe of this chapter. All
    in all, `top` is a very useful and often-used command to do process management.
    It acts as a frontend to many different commands, such as `nice`, `renice`, and
    `kill`.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以让 `top` 显示某个特定用户的进程（按 *U* 键并输入该用户的登录名），并终止进程（按 *K* 键并输入 PID 和要发送的信号）。我们还可以调整进程优先级，这将在本章的
    *第三个* 配方中讲解。总的来说，`top` 是一个非常有用且常用的进程管理命令。它作为许多不同命令的前端，例如 `nice`、`renice` 和 `kill`。
- en: 'The next set of commands that we need to learn about is `kill` and `killall`.
    We shouldn''t use the literal translation of these utilities to try to instinctively
    understand what they do as we''ll be surprised that that translation doesn''t
    apply. Specifically, the `kill` command is used when we want to kill a process
    by its corresponding PID. `killall`, in contrast, is used to kill processes by
    name. There are – of course – viable use cases for both. To show an example for
    both of these commands, we are going to use the following `top` output:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来我们需要学习的命令是 `kill` 和 `killall`。我们不应该通过字面翻译来试图直观理解这些工具的作用，因为我们会发现这种翻译并不适用。具体来说，`kill`
    命令是用于通过进程对应的 PID 来终止一个进程。相比之下，`killall` 用于通过进程名称来终止进程。当然，这两者都有各自的有效使用场景。为了展示这两个命令的例子，我们将使用以下的
    `top` 输出：
- en: '![Figure 3.7 – top output – notice the top command being started twice by the
    student user'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 3.7 – 顶部输出 – 注意到学生用户启动了两次 `top` 命令'
- en: '](img/Figure_3.7_B16269.jpg)'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_3.7_B16269.jpg)'
- en: Figure 3.7 – top output – notice the top command being started twice by the
    student user
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.7 – 顶部输出 – 注意到学生用户启动了两次 `top` 命令
- en: 'Let''s kill both of these `top` processes in a separate shell. If we want to
    kill the first one by using the `kill` command, we need to type the following:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在另一个 shell 中终止这两个 `top` 进程。如果我们想通过 `kill` 命令终止第一个进程，我们需要输入以下内容：
- en: '[PRE2]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'If we want to kill all of the started `top` commands by name, we can type the
    following:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想通过进程名称终止所有已启动的 `top` 命令，可以输入以下内容：
- en: '[PRE3]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'When using the `kill` command, we''re killing a single PID. When using the
    `killall` command, we are killing all the started `top` processes. Of course,
    in order for us to be able to kill a process by using either of these commands,
    we have to log in as either root or `student`. Only the user that started the
    process and root can kill a user process. We need to remember that the default
    signal of both of these commands is the `SIGTERM` signal (signal number `15`).
    If we want to kill a process by using a custom signal, we can achieve that by
    adding that number to any of these two commands preceded by a minus sign. Here''s
    an example:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用 `kill` 命令时，我们是在终止一个特定的 PID。当使用 `killall` 命令时，我们是在终止所有启动的 `top` 进程。当然，为了能够使用这两个命令中的任意一个来终止进程，我们必须以
    root 用户或 `student` 用户身份登录。只有启动了进程的用户和 root 用户才能终止用户进程。我们需要记住，这两个命令的默认信号是 `SIGTERM`
    信号（信号编号 `15`）。如果我们想通过自定义信号来终止进程，可以通过在这两个命令中添加信号编号，并在前面加上减号来实现。下面是一个例子：
- en: '[PRE4]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: This will send the `SIGKILL` signal to the process. Both of these signals are
    explained in the *How it works…* section of this recipe.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 这将向进程发送 `SIGKILL` 信号。这两个信号在本食谱的 *它是如何工作的…* 部分有解释。
- en: 'It''s also good to note the fact that sometimes we need to find the PID of
    a currently running shell or a parent PID of a shell. We can do that by using
    the following two commands:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 另外需要注意的是，有时我们需要找到当前正在运行的 shell 的 PID 或父进程 PID。我们可以通过以下两个命令来实现：
- en: '![Figure 3.8 – PID of our current shell process, the parent process'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 3.8 – 当前 shell 进程的 PID，父进程的 PID'
- en: '](img/Figure_3.8_B16269.jpg)'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_3.8_B16269.jpg)'
- en: Figure 3.8 – PID of our current shell process, the parent process
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.8 – 当前 shell 进程的 PID，父进程的 PID
- en: 'Let''s now check how `glances` can help us check what''s happening with our
    system. If we just start the command, we''re going to get the following output:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们检查一下 `glances` 如何帮助我们查看系统中发生了什么。如果我们只启动命令，系统会输出以下内容：
- en: '![Figure 3.9 – glances default output'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 3.9 – glances 默认输出'
- en: '](img/Figure_3.9_B16269.jpg)'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_3.9_B16269.jpg)'
- en: Figure 3.9 – glances default output
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.9 – glances 默认输出
- en: 'It''s easy to see the level of detail, as well as the different formats, that
    `glances` uses. Furthermore, we really appreciate the fact that it uses color
    output as default, which makes the information a bit easier to read. We can go
    into different methods of displaying data. For example, we can type `1` to switch
    between per-CPU core versus aggregated statistics. We can also use it in server
    mode (by starting it with the `-s` switch) so that we can monitor remote hosts.
    So, from the server perspective, we would start it with the following:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 很容易看到 `glances` 使用的详细信息级别，以及不同的格式。此外，我们也很欣赏它默认使用颜色输出，这使得信息稍微容易阅读。我们可以使用不同的方法来显示数据。例如，我们可以输入
    `1` 来在每个 CPU 核心的统计数据与汇总统计数据之间切换。我们还可以以服务器模式使用它（通过添加 `-s` 参数启动），这样就可以监控远程主机。因此，从服务器的角度来看，我们会用以下命令启动：
- en: '[PRE5]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'From the client perspective, we would start `glances` with the following:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 从客户端的角度，我们将使用以下命令启动 `glances`：
- en: '[PRE6]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '`glances` is cross-platform (it''s Python-based), as it supports Linux, OS
    X, Windows, and FreeBSD. It also has a built-in web UI that can be used via a
    web browser if we''re more into using the GUI than the CLI. But one of the most
    convenient features that it has is the ability to export data in various different
    formats – CSV, Elasticsearch, RabbitMQ, Cassandra, and others.'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: '`glances` 是跨平台的（它基于 Python），支持 Linux、OS X、Windows 和 FreeBSD。它还内置了一个 Web UI，可以通过
    Web 浏览器使用，如果我们更喜欢使用图形界面而不是命令行界面。但它最方便的功能之一是能够以各种不同的格式导出数据——CSV、Elasticsearch、RabbitMQ、Cassandra
    等等。'
- en: How it works…
  id: totrans-84
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: A process is a unit of command execution that an operating system initializes
    so that it can be managed both from the operating system standpoint and from our
    standpoint as system administrators. That means that a process acts like an instance
    of any given program, and it has some common properties (state, PID, and many
    others that we will describe in this chapter), as well as some tasks that it needs
    to do. For example, after we start a command (`process`), that command can open
    and read from the file, user input, or other programs, do something with that
    input, and then terminate after the work is done.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 进程是操作系统初始化的命令执行单元，操作系统和系统管理员都可以管理它。这意味着进程就像是任何给定程序的一个实例，并且它具有一些共同的属性（状态、PID
    等，以及我们将在本章中描述的许多其他属性），同时也需要执行一些任务。例如，在我们启动一个命令（`进程`）之后，命令可以打开并读取文件、用户输入或其他程序的数据，处理这些输入，然后在工作完成后终止。
- en: It is important to note that processes aren't *paused* if we reboot a machine
    – they get stopped and then start as our Linux machine boots or we start it manually
    after the reboot. So, *there's no process persistence across reboots*. Most of
    the time (except for most of the processes that are a part of the operating system
    startup procedure), they don't even keep the same PID across a reboot.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 需要注意的是，如果我们重启计算机，进程不会被*暂停*——它们会被停止，然后在 Linux 机器启动时重新启动，或者我们在重启后手动启动它们。因此，*重启后进程不会保持持续性*。大多数情况下（除去操作系统启动过程中涉及的进程），它们甚至不会在重启后保持相同的
    PID。
- en: 'In terms of process types, we have five different types:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 在进程类型方面，我们有五种不同的类型：
- en: '**Parent and child processes**: In simple terms, a parent process is a process
    that creates additional processes that we call child processes. Child processes
    exit when the parent process exits. A parent process doesn''t exit if a child
    process exits.'
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**父进程与子进程**：简单来说，父进程是创建其他进程的进程，这些被创建的进程我们称为子进程。子进程会在父进程退出时退出，而父进程在子进程退出时并不会退出。'
- en: '**Zombie and orphan processes**: There are situations where the parent process
    gets killed before the child process exits. The remaining child process is called
    an orphan process. On the other hand, a zombie process is a situation where a
    process is killed but still exists in the process table.'
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**僵尸进程与孤儿进程**：有时父进程在子进程退出之前被杀死，剩余的子进程称为孤儿进程。另一方面，僵尸进程指的是一个已经被终止，但仍然存在于进程表中的进程。'
- en: '**Daemons**: Daemons are usually related to some system tasks that usually
    involve working with other processes and servicing them. They also don''t use
    a terminal as they run in the background.'
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**守护进程**：守护进程通常与一些系统任务相关，这些任务通常涉及与其他进程的交互并为其提供服务。守护进程也不会使用终端，因为它们在后台运行。'
- en: 'In terms of states, we have these:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 从状态的角度来看，我们有以下几种：
- en: '**Running/runnable**: Running state refers to a state where a process is being
    executed by a CPU. Runnable state, on the other hand, means that a process is
    ready to be executed but is currently not consuming CPU or queued to be executed
    by a CPU.'
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**运行/可运行**：运行状态是指进程正在被 CPU 执行的状态。而可运行状态则意味着进程已经准备好被执行，但当前并未消耗 CPU，或者正在等待 CPU
    执行。'
- en: '**Interruptible/uninterruptible sleep**: In an interruptible sleep state, a
    process can be awakened and it can accept **signals** aimed at it. In an uninterruptible
    sleep state, that doesn''t happen, and the process remains asleep. This scenario
    often includes a **system call** – a process can''t do a system call and can''t
    be paused or killed until it finishes its job.'
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**可中断/不可中断睡眠**：在可中断睡眠状态下，进程可以被唤醒，并且可以接受针对它的**信号**。在不可中断睡眠状态下，进程不会被唤醒，且会保持睡眠状态。这个情况通常涉及到一个**系统调用**——进程在完成任务之前无法执行系统调用，也不能被暂停或终止。'
- en: '**Stopped**: A process is often stopped when it receives a signal and when
    we''re debugging a process.'
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**停止**：当进程收到信号或者我们正在调试一个进程时，进程通常会被停止。'
- en: '**Zombie**: A dead process that''s been halted but still exists in the process
    table is in a zombie state.'
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**僵尸进程**：一个已经终止但仍然存在于进程表中的进程处于僵尸状态。'
- en: From the operating system perspective, processes are units of execution – for
    a program or service. Processes get scheduled by the operating system and that
    means assigning them resources so that they can run from a programmatic perspective
    (context), and some basic attributes so that they can be managed from the system
    administrative perspective. That includes creating an entry in a process table
    with a PID (number of the process) and other types of attribute data. We are going
    to explain these attributes and how to notice process states a bit later in this
    chapter, when we start discussing practical aspects of working with commands such
    as `top` and `ps`.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 从操作系统的角度来看，进程是程序或服务的执行单元。进程由操作系统调度，这意味着为它们分配资源，使它们能够从程序的角度（上下文）运行，并且分配一些基本的属性，便于从系统管理的角度进行管理。这包括在进程表中创建一个条目，并分配
    PID（进程号）以及其他属性数据。我们将在本章稍后的部分解释这些属性，并讨论如何通过使用像 `top` 和 `ps` 这样的命令来观察进程的状态。
- en: 'We mentioned the concept of a signal. When we''re dealing with different ways
    of establishing communication between a kernel and userspace program, there are
    two ways of achieving that – via either a system call or a signal. Usually, we
    use commands such as `kill` or `killall` if we want to send a signal to a process
    by assigning a signal number or name along with the command. Let''s take a look
    at an excerpt from the signal list:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 我们提到了信号的概念。在讨论内核与用户空间程序之间建立通信的不同方式时，通常有两种方式——通过系统调用或信号。通常，如果我们想要通过命令发送一个信号给进程，可以使用
    `kill` 或 `killall` 命令，并通过信号号或名称来指定信号。让我们来看一下信号列表的一个摘录：
- en: '![Figure 3.10 – Excerpt from the signal man page'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 3.10 – 来自 signal 手册页的摘录'
- en: '](img/Figure_3.10_B16269.jpg)'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_3.10_B16269.jpg)'
- en: Figure 3.10 – Excerpt from the signal man page
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.10 – 来自 signal 手册页的摘录
- en: 'As we can see, there are many of them, and approximately 30 of these signals
    have been implemented by the Linux kernel. Also, there are two types of signals
    from the process perspective:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所见，信号有很多，约有 30 个信号已经由 Linux 内核实现。此外，从进程的角度来看，信号有两种类型：
- en: '`SIGHUP` signal (number 1)'
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SIGHUP` 信号（编号 1）'
- en: '`SIGKILL` signal (number 9)'
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SIGKILL` 信号（编号 9）'
- en: The word *handled* is used in a programmatic sense here – handling something
    means using some kind of *handler* to write a piece of code that's going to intercept
    the signal message and redirect it to something, such as a function or subroutine.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 这里使用的“*handled*”一词是以编程意义上的方式出现的——处理某个信号意味着使用某种*处理程序*编写代码，该代码将拦截信号消息并将其重定向到某个地方，例如函数或子程序。
- en: 'There are major differences between these two types. Let''s use an example
    of a daemon process such as an *Apache web server*. If a daemon process receives
    the `SIGHUP` signal and it supports it (it has a routine in its source code handling
    the `SIGHUP` signal, like Apache does), the most common thing that it will do
    after receiving `SIGHUP` is to refresh its state by re-reading its configuration.
    To quote the Apache manual:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 这两种类型之间有很大的区别。我们以守护进程为例，例如 *Apache 网络服务器*。如果守护进程接收到 `SIGHUP` 信号并且支持该信号（即它的源代码中有处理
    `SIGHUP` 信号的例程，像 Apache 一样），它在接收到 `SIGHUP` 后最常做的事情就是通过重新读取配置来刷新其状态。引用 Apache 手册：
- en: '*Sending the HUP or restart signal to the parent causes it to kill off its
    children like in TERM, but the parent doesn''t exit. It re-reads its configuration
    files, and re-opens any log files. Then it spawns a new set of children and continues
    serving hits*.'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: '*向父进程发送 HUP 或重启信号会导致它像 TERM 信号一样杀死其子进程，但父进程本身不会退出。它会重新读取配置文件，并重新打开日志文件。然后，它会生成一组新的子进程，并继续提供服务*。'
- en: Unlike this scenario, when you send the `SIGKILL` signal to Apache, it will
    be terminated without giving any regard to refreshing its configuration, content,
    or anything of the sort. We can't write a handle to redirect this signal to anything
    other than the process being killed. We can think of it as a *kernel sucking the
    life out of a process* type of scenario, as the process can't get access to resources
    to run and is effectively eradicated by the system (kernel).
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 与此场景不同，当你向 Apache 发送 `SIGKILL` 信号时，它会被终止，而不会考虑刷新其配置、内容或类似操作。我们无法为此信号编写处理程序，将其重定向到除被终止进程之外的任何地方。我们可以把它理解为一种*内核吸取进程生命*的情境，因为进程无法访问运行所需的资源，并且被系统（内核）有效地消除。
- en: The third commonly used signal is `SIGTERM` (number 15). It's also used to terminate
    the process (such as `SIGKILL`), but it does it in a graceful way. We can think
    of it as a *Hello, Mr. Process, would you please be so kind as to terminate yourself
    gracefully? Thank you very much!* message from the kernel. Then the process does
    what it needs to do and shuts itself down.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 第三种常用信号是 `SIGTERM`（编号 15）。它也用于终止进程（如 `SIGKILL`），但它的方式是优雅的。我们可以把它理解为来自内核的*你好，进程先生，请优雅地终止自己，好吗？非常感谢！*的消息。然后进程会做它需要做的事情并自己关闭。
- en: Now that we've had a brief primer on how processes and signals work, let's continue
    our quest for knowledge about processes by learning about the management of background
    processes. As we already explained the basics of background processes, that shouldn't
    be a difficult task.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们简要了解了进程和信号的工作原理，让我们继续探索有关进程管理的知识，学习后台进程的管理。既然我们已经解释了后台进程的基础，应该不会是难事。
- en: See also
  id: totrans-110
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另见：
- en: 'If you need more information about processes, signals, and similar concepts,
    make sure that you check out the following:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你需要更多关于进程、信号以及类似概念的信息，确保查看以下内容：
- en: '**Basics of Linux processes**: [http://www.science.unitn.it/~fiorella/guidelinux/tlk/node45.html](http://www.science.unitn.it/~fiorella/guidelinux/tlk/node45.html%0D)'
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Linux 进程基础**：[http://www.science.unitn.it/~fiorella/guidelinux/tlk/node45.html](http://www.science.unitn.it/~fiorella/guidelinux/tlk/node45.html%0D)'
- en: '**Linux command basics** – Seven commands for process management: [https://www.redhat.com/sysadmin/linux-command-basics-7-commands-process-management](https://www.redhat.com/sysadmin/linux-command-basics-7-commands-process-management%0D)'
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Linux 命令基础**——七个进程管理命令：[https://www.redhat.com/sysadmin/linux-command-basics-7-commands-process-management](https://www.redhat.com/sysadmin/linux-command-basics-7-commands-process-management%0D)'
- en: '**Signal man page**: [https://man7.org/linux/man-pages/man7/signal.7.html](https://man7.org/linux/man-pages/man7/signal.7.html%0D)'
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**信号手册页**：[https://man7.org/linux/man-pages/man7/signal.7.html](https://man7.org/linux/man-pages/man7/signal.7.html%0D)'
- en: '**Basics of glances**: [https://www.tecmint.com/glances-an-advanced-real-time-system-monitoring-tool-for-linux/](https://www.tecmint.com/glances-an-advanced-real-time-system-monitoring-tool-for-linux/%0D)'
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Glances 基础**：[https://www.tecmint.com/glances-an-advanced-real-time-system-monitoring-tool-for-linux/](https://www.tecmint.com/glances-an-advanced-real-time-system-monitoring-tool-for-linux/%0D)'
- en: '**TLDP Chapter 4: Processes**: [https://tldp.org/LDP/tlk/kernel/processes.html](https://tldp.org/LDP/tlk/kernel/processes.html%0D)'
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**TLDP 第 4 章：进程**：[https://tldp.org/LDP/tlk/kernel/processes.html](https://tldp.org/LDP/tlk/kernel/processes.html%0D)'
- en: Managing background jobs
  id: totrans-117
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 管理后台任务
- en: There are various types of situations where we would like to start a process
    and run it in the background. For example, let's say that we want to start a process,
    log off, and then come back tomorrow and check the result of that process. Let's
    learn how this works by using an example.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 有多种情况我们希望启动一个进程并将其放到后台运行。例如，假设我们希望启动一个进程，退出登录，然后等到第二天再检查该进程的结果。让我们通过一个例子来学习它是如何工作的。
- en: Getting ready
  id: totrans-119
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备就绪
- en: Keep the `cli1` virtual machine powered on and let's use the shell to explain
    how the idea of a background process works, as opposed to a foreground process.
    We will make sure that we also explain the concept in the *How it works…* section.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 保持`cli1`虚拟机开机，让我们使用 shell 来解释后台进程是如何工作的，与前台进程的不同之处。我们还会确保在*它是如何工作的…*这一部分中进行解释。
- en: How to do it…
  id: totrans-121
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点……
- en: Let's imagine a scenario in which we want to download a large file by using
    shell tools. The *usual suspect* that we'd use for this kind of task in Linux
    is a program called `wget`. We want to start a `wget` session (`wget` is a `shell`
    command that enables us to download files from the `http` and `ftp` URIs) to download
    a large ISO file, but we want to log off (or do something else) while the download
    is taking place. This is achieved by putting the `wget` process in the background.
    This is just one common example of using a background process to our advantage.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们想通过使用 shell 工具下载一个大文件。在 Linux 中，*常见工具*是一个叫做`wget`的程序。我们想要启动一个`wget`会话（`wget`是一个`shell`命令，可以让我们从`http`和`ftp`的
    URI 下载文件）来下载一个大 ISO 文件，但我们希望在下载进行的同时退出（或做其他事情）。这可以通过将`wget`进程放到后台来实现。这只是利用后台进程的一种常见例子。
- en: 'First, we need to install `wget`. Let''s do that by using the following command:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要安装`wget`。我们可以通过以下命令来安装：
- en: '[PRE7]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '`wget` is a common utility, and it''s mostly installed by default. But either
    way, by using this command, we''ll make sure that it''s installed.'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: '`wget`是一个常用的工具，通常默认安装。无论如何，通过使用这个命令，我们可以确保它已安装。'
- en: Let's use the `Ubuntu 20.04 ISO` file as the file that we want to download by
    using two examples. The first one is going to be running `wget` as a *foreground*
    process, and the second one is going to be running `wget` as a *background* process.
    The second example can actually be done in two different ways as `wget` has a
    built-in option that can be used to put it in the background. Of course, as we're
    trying to explain the *system-wide* concept, not a specific utility, let's make
    sure that we do both.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用`Ubuntu 20.04 ISO`文件作为我们想要下载的文件，使用两个例子来展示。第一个例子是将`wget`作为*前台*进程运行，第二个例子是将`wget`作为*后台*进程运行。第二个例子实际上可以通过两种不同的方式完成，因为`wget`有一个内置选项可以将其放到后台。当然，既然我们要解释的是*系统级*的概念，而非某个特定工具，那么我们一定会确保两种方式都进行讲解。
- en: 'At the time of writing, the `Ubuntu 20.04 ISO` file can be found here:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 在撰写时，`Ubuntu 20.04 ISO` 文件可以在这里找到：
- en: '[https://releases.ubuntu.com/20.04/ubuntu-20.04.3-live-server-amd64.iso](https://releases.ubuntu.com/20.04/ubuntu-20.04.3-live-server-amd64.iso%0D)'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://releases.ubuntu.com/20.04/ubuntu-20.04.3-live-server-amd64.iso](https://releases.ubuntu.com/20.04/ubuntu-20.04.3-live-server-amd64.iso%0D)'
- en: 'Let''s use `wget` to download it as a foreground process, by typing in the
    following command:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过输入以下命令，使用`wget`以前台进程的方式下载文件：
- en: '[PRE8]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'The result should look something like this:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 结果应该类似于这样：
- en: '![Figure 3.11 – Foreground process – exclusively locks the shell access'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 3.11 – 前台进程 – 独占锁定 shell 访问](img/Figure_3.11_B16269.jpg)'
- en: '](img/Figure_3.11_B16269.jpg)'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_3.11_B16269.jpg)'
- en: Figure 3.11 – Foreground process – exclusively locks the shell access
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.11 – 前台进程 – 独占锁定 shell 访问
- en: 'As we can clearly see, the download is working, but the problem is the fact
    that for the next 12+ minutes, we can''t do anything in this shell, as the underlying
    shell session is being exclusively used by `wget`. We can''t write commands, get
    command results – nothing. The only thing that we could do to prevent that would
    be to use a *Ctrl* + *C* sequence to quit the download and be thrown into the
    shell. But that''s not what we want to do. What we want to do is the following:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们清楚看到的，下载正在进行，但问题是，在接下来的 12 分钟以上，我们无法在这个 shell 中做任何事，因为底层的 shell 会话完全被 `wget`
    占用。我们无法输入命令，也无法获取命令结果——什么都做不了。唯一能做的事是使用 *Ctrl* + *C* 组合键退出下载并返回到 shell。但这不是我们想做的。我们想做的是：
- en: Start the download.
  id: totrans-136
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 启动下载。
- en: Be thrown back into the shell with the download still working.
  id: totrans-137
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 被抛回到 shell 中，并且下载仍在进行。
- en: 'This is a situation in which running a process as a background task can be
    very helpful. So, let''s add one additional parameter to the previous command:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个运行后台任务非常有帮助的情况。那么，让我们在之前的命令中添加一个额外的参数：
- en: '[PRE9]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'The `&` sign at the end of this command tells the kernel to put this process
    in the background. Let''s see what the end result is:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 这条命令末尾的 `&` 符号告诉内核将该进程放入后台。让我们看看最终结果：
- en: '![Figure 3.12 – Starting the process in the background'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 3.12 – 在后台启动进程'
- en: '](img/Figure_3.12_B16269.jpg)'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_3.12_B16269.jpg)'
- en: Figure 3.12 – Starting the process in the background
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.12 – 在后台启动进程
- en: We can clearly see that we've been thrown back into the shell (`root@cli1` prompt)
    and that we can keep writing additional commands. We can also see that a `wget`
    process was started with PID `43787`, which we could use to issue a `kill` command
    if we so choose.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以清楚地看到，我们已经被抛回到 shell（`root@cli1` 提示符），并且我们可以继续输入其他命令。我们还可以看到一个 `wget` 进程已启动，PID
    为 `43787`，如果我们愿意，可以使用 `kill` 命令终止它。
- en: Obviously, we can issue multiple commands with `&` at the end, and then we'd
    have multiple processes running in the background. This is where the `[1]` part
    of the previous output comes in handy. This number represents an index number
    assigned to the background process. In other words, the `wget` that we started
    with PID `43787` is the first background process. If we were to start multiple
    background processes, each new background process would get the next number –
    `2`, `3`, and so on.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，我们可以在命令末尾使用 `&` 来发出多个命令，然后我们就会有多个进程在后台运行。这时，之前输出中的 `[1]` 部分就派上用场了。这个数字表示分配给后台进程的索引号。换句话说，我们开始的
    `wget` 进程，PID 为 `43787`，是第一个后台进程。如果我们启动多个后台进程，每个新的后台进程将会得到下一个数字——`2`、`3`，依此类推。
- en: 'Obviously, we need to learn how to manage multiple background jobs. This is
    what the `jobs` command is all about. Let''s see how that works. First, we are
    going to start multiple background jobs:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，我们需要学习如何管理多个后台任务。这正是 `jobs` 命令的作用。让我们看看它是如何工作的。首先，我们将启动多个后台任务：
- en: '![Figure 3.13 – Starting multiple background processes'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 3.13 – 启动多个后台进程'
- en: '](img/Figure_3.13_B16269.jpg)'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_3.13_B16269.jpg)'
- en: Figure 3.13 – Starting multiple background processes
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.13 – 启动多个后台进程
- en: 'Then, let''s use the `jobs` and `kill` commands to work out which background
    jobs we have and kill them by index (not by using their PID). This is the way
    to do it:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，使用 `jobs` 和 `kill` 命令来查找我们有哪些后台任务，并通过索引（而不是通过 PID）来终止它们。操作方法如下：
- en: '![Figure 3.14 – Checking and killing multiple background processes'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 3.14 – 检查并终止多个后台进程'
- en: '](img/Figure_3.14_B16269.jpg)'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_3.14_B16269.jpg)'
- en: Figure 3.14 – Checking and killing multiple background processes
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.14 – 检查并终止多个后台进程
- en: 'By using the `kill %index_number` syntax, we were able to kill background jobs
    by their index number, instead of their PIDs. This syntax is shorter and shouldn''t
    be discounted in everyday life as it makes a lot of things easier – as long as
    we don''t log off. If we log off, the whole idea changes a bit as we can''t access
    these processes by using their index numbers, but we can definitely manage them
    by using PIDs. So, let''s imagine for a second that we started two `wget` sessions
    as background processes, and then logged off and logged back on. Let''s try to
    list these processes as background processes, then as just regular, general processes,
    and kill them by PID. This is what happens after that:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用`kill %index_number`语法，我们能够通过索引号终止后台作业，而不是通过它们的PID。这个语法更简洁，在日常生活中不应忽视，因为它让许多事情变得更简单——只要我们不登出。如果我们登出，情况就有所变化，因为我们无法通过索引号访问这些进程，但我们仍然可以通过PID来管理它们。所以，假设我们启动了两个`wget`会话作为后台进程，然后登出并重新登录。让我们试着将这些进程列为后台进程，然后作为普通的、一般的进程，并通过PID终止它们。这是接下来发生的事情：
- en: '![Figure 3.15 – jobs provides no output, but the ps command does'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: '![图3.15 – jobs没有输出，但ps命令有输出'
- en: '](img/Figure_3.15_B16269.jpg)'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_3.15_B16269.jpg)'
- en: Figure 3.15 – jobs provides no output, but the ps command does
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.15 – jobs没有输出，但ps命令有输出
- en: We can clearly see that the `jobs` command provides no output (can't find index
    numbers of background jobs), but our processes are still running. Why? Well, background
    processes that we started were created in the shell that's no longer active. After
    we logged off, we started a new shell, and, because of the way in which the `jobs`
    command works, we can't see those background jobs anymore. But we can definitely
    see them as processes running on the system, and, if we want to do so, we can
    kill them successfully by using their PIDs, as we did with the `kill` command.
    We used the `ps` command here and filtered its output by using `grep` – a command
    that is able to search specific pieces of text from a text-based output (in our
    case, we were searching through the whole table of processes by using `ps` `auwwx`,
    created a serial pipeline by using the pipe sign ( `|` ), and then threw the output
    from the `ps` command in the `grep` command.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 我们清楚地看到，`jobs`命令没有任何输出（找不到后台作业的索引号），但我们的进程仍然在运行。为什么？好吧，我们启动的后台进程是在一个已经不再活跃的shell中创建的。在我们登出后，我们启动了一个新的shell，并且由于`jobs`命令的工作方式，我们无法再看到这些后台作业了。但我们绝对可以将它们视为在系统上运行的进程，并且，如果需要，我们可以通过PID成功终止它们，正如我们使用`kill`命令所做的那样。我们在这里使用了`ps`命令，并通过使用`grep`过滤了它的输出——`grep`是一个可以从基于文本的输出中搜索特定文本的命令（在我们的案例中，我们通过使用`ps
    auwwx`命令搜索整个进程表，创建了一个管道并使用管道符号（`|`），然后将`ps`命令的输出传递给`grep`命令）。
- en: 'We mentioned that the `wget` command has the capability to start itself in
    the background by using a command-line option (`-b`). This is not all that common,
    but it''s definitely useful. So, say we were to use the following command:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 我们提到过，`wget`命令有能力通过使用命令行选项（`-b`）在后台启动自身。这并不常见，但绝对有用。所以，假设我们使用以下命令：
- en: '[PRE10]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'This should be the end result:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 这应该是最终结果：
- en: '![Figure 3.16 – wget can be started in the background by using the -b switch'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: '![图3.16 – 可以通过使用`-b`开关在后台启动wget'
- en: '](img/Figure_3.16_B16269.jpg)'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_3.16_B16269.jpg)'
- en: Figure 3.16 – wget can be started in the background by using the -b switch
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.16 – 可以通过使用`-b`开关在后台启动wget
- en: 'What''s really interesting about this procedure is the following:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 这个过程真正有趣的地方在于：
- en: '`wget` clearly states that it''s starting itself in the background, but it
    doesn''t give us an index number.'
  id: totrans-166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`wget`清楚地表明它会在后台启动，但它没有给我们一个索引编号。'
- en: If we use the `jobs` command, we can't see it as a background process.
  id: totrans-167
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果我们使用`jobs`命令，我们无法看到它作为后台进程的状态。
- en: We can kill it by using regular means, a `kill` command.
  id: totrans-168
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以通过常规方式使用`kill`命令来终止它。
- en: 'This is a bit of a different concept, as `wget` effectively achieves this `jobs`
    *command invisibility* by creating a `wget` child process and terminating the
    parent process. Since the parent process is no longer there, it''s no longer associated
    with a specific shell, and therefore not indexed. The result is that it''s not
    visible in the jobs table for the current shell. We can achieve something similar
    by using the `disown` command. Let''s start a process in the current shell, and
    then do the thing that `wget` basically does:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个稍微不同的概念，因为`wget`通过创建一个`wget`子进程并终止父进程，实际上实现了这种`jobs` *命令隐形*的效果。由于父进程不再存在，它不再与特定的
    Shell 关联，因此不再被索引。结果是它在当前 Shell 的作业表中不可见。我们可以通过使用`disown`命令实现类似的效果。让我们在当前 Shell
    中启动一个进程，然后做`wget`基本上做的事情：
- en: '![Figure 3.17 – Disowning a background process'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 3.17 – 解除后台进程的关联'
- en: '](img/Figure_3.17_B16269.jpg)'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_3.17_B16269.jpg)'
- en: Figure 3.17 – Disowning a background process
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.17 – 解除后台进程的关联
- en: There are other ways of making sure that a process goes to the background. The
    most common scenario is we want to start a process in the background, we forget
    to put the `&` sign at the end of our command, and we're stuck with the foreground
    process. What to do then?
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 还有其他方法可以确保进程进入后台。最常见的情况是我们希望将进程放入后台，但忘记在命令末尾加上`&`符号，结果进程被困在前台。那么该怎么办呢？
- en: 'The answer is simple – we press *Ctrl* + *Z* (to put the process in the suspended
    state), and then type in the `bg` command. It''s going to put the process in the
    background, as if we started it with the `&` sign from the start. Combining all
    of that with `jobs`, `disown` and `kill` would look like this:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 答案很简单 – 我们按下*Ctrl* + *Z*（将进程置于挂起状态），然后输入`bg`命令。这样会将进程放入后台，就像我们一开始用`&`符号启动它一样。将这些与`jobs`、`disown`和`kill`结合起来，会是这样的：
- en: '![Figure 3.18 – Using Ctrl + Z and bg to put a process in the background'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 3.18 – 使用 Ctrl + Z 和 bg 将进程放入后台'
- en: '](img/Figure_3.18_B16269.jpg)'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_3.18_B16269.jpg)'
- en: Figure 3.18 – Using Ctrl + Z and bg to put a process in the background
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.18 – 使用 Ctrl + Z 和 bg 将进程放入后台
- en: We started `wget` in the foreground and put it in a suspended state by typing
    *Ctrl* + *Z*. Then, we moved that process to the background by using the `bg`
    command. Since it's job number `1` in our shell, we disowned it, used `ps` to
    find its PID, and killed it.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在前台启动了`wget`，然后通过按*Ctrl* + *Z*将其置于挂起状态。接着，我们使用`bg`命令将该进程移至后台。由于它在我们的 Shell
    中是作业号`1`，我们解除它的关联，使用`ps`查找其 PID，并将其终止。
- en: 'If, for some reason, we wanted to go from the background to the foreground
    with a process (providing that it has an index number and was started in the current
    shell), we can do that by using the `fg` command. So, if we use the previous procedure
    as an example, it would look like this:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 如果由于某种原因，我们想要将一个进程从后台恢复到前台（前提是该进程有索引号并且是在当前 Shell 中启动的），我们可以使用`fg`命令来实现。因此，如果我们使用之前的操作步骤作为示例，它将是这样的：
- en: '![Figure 3.19 – Using Ctrl + Z, bg, and fg to move a process to the background
    and back to the foreground'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 3.19 – 使用 Ctrl + Z、bg 和 fg 将一个进程从后台移动到前台再返回后台'
- en: '](img/Figure_3.19_B16269.jpg)'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_3.19_B16269.jpg)'
- en: Figure 3.19 – Using Ctrl + Z, bg, and fg to move a process to the background
    and back to the foreground
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.19 – 使用 Ctrl + Z、bg 和 fg 将一个进程从后台移动到前台再返回后台
- en: We can clearly see that the `wget` process went to the background (*Ctrl* +
    *Z* and `bg` commands), then went to the foreground (the `fg` command), and was
    terminated at the end by using *Ctrl* + *C*. If we have multiple background processes
    in our current shell, we can also use indexing with the `fg` command (`fg index_number`).
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以清楚地看到，`wget`进程先是进入了后台（*Ctrl* + *Z* 和 `bg` 命令），然后又回到了前台（`fg` 命令），最后通过使用*Ctrl*
    + *C*将其终止。如果我们当前的 Shell 中有多个后台进程，我们还可以使用索引来操作前台命令（`fg 索引号`）。
- en: How it works…
  id: totrans-184
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的……
- en: 'Processes can run in two different ways:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 进程可以以两种不同的方式运行：
- en: '**Foreground**: If we start a process from the shell, that process is going
    to occupy our current shell and will not allow us to type in additional commands.
    A kind of exception to that rule is a scenario in which the started process requires
    additional user input, but that input needs to be baked into the core of the process
    that we''re executing (a part of the programming code). In this scenario, the
    shell is exclusively used by the started process until either the process finishes,
    we put it in the background, or it gets killed by other external factors (such
    as other processes or the kernel, or if it crashes for some reason).'
  id: totrans-186
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**前台**：如果我们从 shell 启动一个进程，该进程将占用当前的 shell，并且不允许我们输入其他命令。对此规则的一个例外情况是，启动的进程需要额外的用户输入，但这些输入需要嵌入到我们正在执行的进程核心中（程序代码的一部分）。在这种情况下，shell
    完全被启动的进程占用，直到进程完成、我们将其置于后台，或者它被其他外部因素（如其他进程或内核，或因某种原因崩溃）终止。'
- en: '**Background**: If we start a process in the background, it runs and frees
    up our shell so that we can continue using it to type other commands.'
  id: totrans-187
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**后台**：如果我们在后台启动一个进程，它会运行并释放我们的 shell，这样我们可以继续用它输入其他命令。'
- en: When a process goes to the background in the current shell, it gets an index
    number so that we have the capability to manage it by using its index number.
    We can use `fg`, `kill`, and similar commands by using this index number (for
    example, `kill %1` would kill the first job in the job index table).
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个进程在当前 shell 中转入后台时，它会获得一个索引号，这样我们就可以通过该索引号来管理它。我们可以使用 `fg`、`kill` 等命令来操作这个索引号（例如，`kill
    %1` 会终止作业索引表中的第一个作业）。
- en: As we saw in our practical demonstration, there are multiple ways of making
    sure that processes are started in the background – either when they are started
    or after they are started. What makes this concept plausible is the fact that
    we can easily put processes in the background, to be handled by the operating
    system, while we're away from it, which sometimes means freeing our precious time.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在实际演示中看到的，有多种方法可以确保进程在后台启动——无论是启动时还是启动后。这一概念之所以成立，是因为我们可以轻松地将进程放入后台，由操作系统处理，当我们不在时，这有时意味着节省我们的宝贵时间。
- en: There's more…
  id: totrans-190
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多内容……
- en: 'If we need to learn more about foreground and background processes, we can
    check the following links:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们需要了解更多关于前台和后台进程的内容，可以查看以下链接：
- en: '`jobs`, `bg`, and `fg`: [https://www.redhat.com/sysadmin/jobs-bg-fg](https://www.redhat.com/sysadmin/jobs-bg-fg%0D)'
  id: totrans-192
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`jobs`、`bg` 和 `fg`：[https://www.redhat.com/sysadmin/jobs-bg-fg](https://www.redhat.com/sysadmin/jobs-bg-fg%0D)'
- en: '**Linux command basics** – seven commands for process management: [https://www.redhat.com/sysadmin/linux-command-basics-7-commands-process-management](https://www.redhat.com/sysadmin/linux-command-basics-7-commands-process-management)'
  id: totrans-193
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Linux 命令基础** – 管理进程的七个命令：[https://www.redhat.com/sysadmin/linux-command-basics-7-commands-process-management](https://www.redhat.com/sysadmin/linux-command-basics-7-commands-process-management)'
- en: Managing process priorities
  id: totrans-194
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 管理进程优先级
- en: 'When we were explaining how to work with the `top` command, we intentionally
    omitted some details to give them their own time and place to discuss them later
    on in this chapter. We''ll discuss one of these details here: the difference between
    the `PR` and `NI` fields in the `top` output. Let''s do that now.'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们解释如何使用 `top` 命令时，我们有意省略了一些细节，留待在本章稍后讨论。我们将在这里讨论其中一个细节：`top` 输出中 `PR` 和 `NI`
    字段的区别。现在我们来讨论这个。
- en: Getting ready
  id: totrans-196
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: Keep the `cli1` virtual machine powered on and let's continue using our shell.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 保持 `cli1` 虚拟机开启，让我们继续使用我们的 shell。
- en: How to do it…
  id: totrans-198
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作……
- en: 'We are going to learn how to use the `top`, `nice`, and `renice` commands to
    manage process scheduling in accordance with our wishes. First, let''s use the
    `top` command. Let''s `renice` a running process to a more negative value and
    a more positive value. Let''s use the following `top` output for that:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将学习如何使用 `top`、`nice` 和 `renice` 命令，根据我们的需求来管理进程调度。首先，我们来使用 `top` 命令。我们将 `renice`
    一个正在运行的进程，使其优先级变为更负的值和更正的值。我们将使用以下 `top` 输出进行演示：
- en: '![Figure 3.20 – Starting point – processes started by the student user'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 3.20 – 起点 – 学生用户启动的进程]'
- en: '](img/Figure_3.20_B16269.jpg)'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_3.20_B16269.jpg)'
- en: Figure 3.20 – Starting point – processes started by the student user
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.20 – 起点 – 学生用户启动的进程
- en: 'Let''s now change the priority of the process with PID `47160` (`top`). Press
    the *R* key and the `top` output will change this output to something such as
    the following:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们改变 PID 为 `47160`（`top`）的进程的优先级。按下 *R* 键，`top` 输出将会变化为如下所示：
- en: '![Figure 3.21 – Let''s renice a PID'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 3.21 – 让我们重新调整一个 PID 的优先级'
- en: '](img/Figure_3.21_B16269.jpg)'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_3.21_B16269.jpg)'
- en: Figure 3.21 – Let's renice a PID
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.21 – 让我们重新调整一个 PID 的优先级
- en: 'Then, again, type in the number `47160` and press *Enter*, followed by the
    niceness level – let''s say, `-10`. We should get something like this as a result:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，再次输入数字 `47160`，按 *Enter* 键，并输入 nice 值——假设为 `-10`。我们应该会看到类似如下的结果：
- en: '![Figure 3.22 – End result – more negative niceness level, higher priority'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 3.22 – 结果 – 更负的 nice 值，更高的优先级'
- en: '](img/Figure_3.22_B16269.jpg)'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_3.22_B16269.jpg)'
- en: Figure 3.22 – End result – more negative niceness level, higher priority
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.22 – 结果 – 更负的 nice 值，更高的优先级
- en: We can clearly see that the `NI` field of our PID changed from `0` to `-10`.
    Since we gave it a more negative niceness level, that means higher priority.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以清楚地看到，我们的 PID 的 `NI` 字段从 `0` 改变为 `-10`。由于我们赋予了更负的 nice 值，这意味着更高的优先级。
- en: 'This example explains how to `renice` an already running process. But clearly,
    we can''t use that to set the niceness level before we start the process. That''s
    why we have the `nice` command. Here''s an example of using the `nice` command:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 这个示例解释了如何 `renice` 一个已经在运行的进程。但显然，我们不能用它在启动进程之前设置 nice 值。这就是为什么我们有 `nice` 命令的原因。下面是使用
    `nice` 命令的一个示例：
- en: '[PRE11]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'If we start this command as root and check the output, after we give it a bit
    of time, we should see something like this:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们以 root 用户身份启动该命令并查看输出，给它一点时间后，我们应该会看到类似这样的内容：
- en: '![Figure 3.23 – Using nice to pre-assign priority to a process at process start'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 3.23 – 使用 nice 在进程启动时预设优先级'
- en: '](img/Figure_3.23_B16269.jpg)'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_3.23_B16269.jpg)'
- en: Figure 3.23 – Using nice to pre-assign priority to a process at process start
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.23 – 使用 nice 在进程启动时预设优先级
- en: Obviously, there's a caveat here – if we tried to start this command as a regular
    user, that wouldn't work. Regular users don't have a right to use the `nice` command
    – imagine how many different possibilities of abusing the system and/or crashing
    it would be given to any user if they did have that right. There are ways around
    this if we want to give the right to use the `nice` command to some users – we
    can do it via PAM modules or the `sudo` system. But for the time being, let's
    agree that this is not something that needs to be *urbi et orbi*, just as an exception.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，这里有一个警告——如果我们尝试以普通用户身份启动这个命令，是无法成功的。普通用户没有使用 `nice` 命令的权限——想象一下，如果普通用户拥有这个权限，他们可能会有多少种滥用系统或崩溃系统的方式。若我们希望授予某些用户使用
    `nice` 命令的权限，可以通过 PAM 模块或 `sudo` 系统来实现。但目前为止，我们可以一致认为这只是一个例外，不需要像 *urbi et orbi*
    那样普遍适用。
- en: Let's now explain how these concepts work.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们解释一下这些概念是如何工作的。
- en: How it works…
  id: totrans-220
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的……
- en: 'Let''s start by executing the `top` command and checking the important part
    of its output:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 我们先执行 `top` 命令并查看其输出中的重要部分：
- en: '![Figure 3.24 – top output related to process priority'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 3.24 – top 输出与进程优先级相关'
- en: '](img/Figure_3.24_B16269.jpg)'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_3.24_B16269.jpg)'
- en: Figure 3.24 – top output related to process priority
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.24 – top 输出与进程优先级相关
- en: 'Let''s briefly explain the difference between these two fields:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 简要解释一下这两个领域的区别：
- en: '`PR` (priority field): Real, kernel-scheduled priority at the moment of looking,
    assigned by the kernel. The `rt` mark means real time; it ranges between `0` and
    `139`, although it can have negative static values for real-time processes.'
  id: totrans-226
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`PR`（优先级字段）：当前查看时的实际内核调度优先级，由内核分配。`rt` 标记表示实时；其值范围在 `0` 到 `139` 之间，尽管对于实时进程，它可以有负的静态值。'
- en: '`NI` (niceness field): The process priority that it should have, assigned in
    user space (not kernel space) by default or by additional commands (`nice` and
    `renice`). The lower the number, the higher the priority, on a scale from `-20`
    to `+19`.'
  id: totrans-227
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`NI`（nice 值字段）：进程应该具有的优先级，默认情况下由用户空间（而非内核空间）分配，或者通过额外的命令（`nice` 和 `renice`）进行调整。数字越低，优先级越高，范围从
    `-20` 到 `+19`。'
- en: Obviously, there's a big difference between these two numbers, seeing that one
    of them is *the real deal* (`PR`) and the other one is like *advice* (`NI`). Explaining
    process priorities is relatively easy in theory, but it becomes a bit more challenging
    to put into practice because of some architectural reasons. So, we'll try to explain
    this with an example that used to be possible but is not anymore as the speed
    of modern CPUs and memory is many times over what it used to be 10 years ago.
    So, let's first discuss the theoretical concept and then use an example.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，这两个数字之间有很大的差异，因为其中一个是*真实的*（`PR`），另一个则像是*建议*（`NI`）。理论上解释进程优先级相对容易，但由于一些架构原因，将其应用到实际中会变得更具挑战性。因此，我们将尝试用一个曾经可以实现但现在不再适用的例子来解释这一点，因为现代
    CPU 和内存的速度已经远远超过了 10 年前的水平。所以，先讨论理论概念，然后再用一个例子来说明。
- en: Theoretically speaking, when we use the `nice` and `renice` commands, what we're
    doing is assigning a specific amount of CPU context to a process – a running one
    (`renice`) or a soon-to-be-running one (`nice`). We use the word *context* here
    in a programmatic sense from a CPU perspective. Translation – if we want to run
    a process, the kernel needs to assign it some CPU. If we have a running process
    and we `renice` it to a more negative value, that is going to tell the kernel
    and its scheduler to pay more attention to that specific process, therefore giving
    it more access to the CPU. If we `renice` it to a more positive value, that's
    going to tell the kernel to pay less attention to giving CPU resources to that
    process. By assigning more CPU to a process, there's a chance that that process
    is going to work faster and do its job faster as a result.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 从理论上讲，当我们使用`nice`和`renice`命令时，我们所做的是为进程分配一定的 CPU 上下文——一个正在运行的进程（`renice`）或一个即将运行的进程（`nice`）。我们在这里使用“上下文”一词，是从
    CPU 的角度在编程中使用的。翻译过来——如果我们想运行一个进程，内核需要为它分配一些 CPU 资源。如果我们有一个正在运行的进程，并且将其`renice`为一个更负的值，这将告诉内核及其调度器更多地关注这个特定的进程，从而给它更多的
    CPU 访问权限。如果我们将其`renice`为一个更正的值，这将告诉内核减少分配 CPU 资源给该进程。通过给进程分配更多的 CPU，进程可能会变得更快并更快地完成工作。
- en: Obviously, this is a bit of a simplification as there are other factors at play
    here. For example, every process needs some memory to work, and the busier the
    memory is with other processes, the less speed the process has to access memory
    content, therefore lowering the memory bandwidth and increasing the latency of
    memory access. So, assigning a more negative value to niceness doesn't always
    directly translate to more performance out of a process. Also, what if the process
    doesn't need more CPU as it's currently idling and not doing anything of significance?
    There can be many more factors here – **Non-Unified Memory Access** (**NUMA**)
    operating system/application compatibility, effective usage of multiple threads/cores,
    locking mechanisms, and others. So, this is more of a general, academic discussion
    that can have exceptions that can happen for a variety of reasons, the state of
    the system being one of the most common ones.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，这有点过于简化，因为这里涉及到其他因素。例如，每个进程都需要一些内存来运行，而内存越是被其他进程占用，进程访问内存内容的速度就越慢，从而降低了内存带宽并增加了内存访问的延迟。因此，给进程分配一个更负的优先级值并不总是能直接提高进程的性能。此外，如果进程当前处于空闲状态，什么也不做，且不需要更多的
    CPU 呢？这里可能还有很多其他因素——**非统一内存访问**（**NUMA**）操作系统/应用程序兼容性、多线程/核心的有效使用、锁机制等。因此，这更多的是一种通用的学术讨论，可能会有各种原因导致的例外，系统状态是其中最常见的原因之一。
- en: Now that we've taken care of the theoretical background, let's use an example
    that used to be very easy to demonstrate as a lot of people had these sorts of
    experiences in the past, when CPU and memory were much, much less capable than
    they are today.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经处理了理论背景，来看看一个以前很容易展示的例子，因为很多人过去都有类似的经历，当时的 CPU 和内存远远不如今天这么强大。
- en: 10 years ago, if we were to use an average computer of the day to display a
    high-resolution Flash video from YouTube, we had a problem. CPUs were kind of
    strong enough to do that, but only just. So, in order for us to be able to watch
    them in Linux by using a web browser (for example, Firefox), we had to tune the
    system to do it. So, we started the web browser, found a video that we wanted
    to watch, and pressed the *play* button, and it would work for a couple of seconds
    and then stutter. Then, it would work again, then stutter again. This was a frustrating
    experience. In those days, we didn't have GPU acceleration for Flash, so the CPU
    was the only device that could be of any assistance in these scenarios.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 10 年前，如果我们使用当时的一台普通电脑观看来自 YouTube 的高分辨率 Flash 视频，就会遇到一个问题。CPU 的性能大致够用，但勉强够。所以，为了能通过
    Linux 使用网页浏览器（例如 Firefox）观看这些视频，我们不得不对系统进行调优。于是我们打开了网页浏览器，找到了想看的视频，点击了 *播放* 按钮，视频会播放几秒钟，然后卡顿。接着，它又会播放一段时间，再次卡顿。这是一个令人沮丧的体验。那时候，我们还没有
    Flash 的 GPU 加速功能，所以 CPU 是唯一能在这种情况下提供帮助的设备。
- en: But if we knew how to set process priority, we could've solved that problem
    in most cases, depending on the CPU speed. We could go to the shell, find the
    PID of the Firefox process, and `renice` it to a much more negative value. All
    of a sudden, the kernel would instruct its scheduler to pay more attention to
    Firefox as a process, and lo and behold – our video would stop stuttering. Why?
    Because the kernel – by virtue of us using the `renice` command – realized that
    we wanted to give that process more priority and therefore ordered the CPU scheduler
    to make it happen.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 但如果我们知道如何设置进程优先级，在大多数情况下，我们可以通过这种方式解决问题，这取决于 CPU 的速度。我们可以进入命令行，找到 Firefox 进程的
    PID，并将其 `renice` 为一个更负的值。突然间，内核会指示其调度器更加关注 Firefox 这个进程，结果就会发生——视频不再卡顿。为什么？因为通过我们使用
    `renice` 命令，内核意识到我们希望赋予这个进程更高的优先级，因此命令 CPU 调度器去执行这一操作。
- en: There are many more aspects of tuning CPU performance. Modern Linux distributions
    have many options for this as the kernel gets more and more programmatic in terms
    of its approach to CPU scheduling. That's why various Linux distributions introduced
    concepts such as **tuned**, a profile-driven system that's able to tune our system
    performance based on pre-assigned or manually created profiles, and **tuna**,
    a utility that enables deep application-specific tuning. We always need to have
    the capability to go deep with tuning so that our system can have optimized performance
    for any specific use case.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 调优 CPU 性能还有许多其他方面。随着 Linux 内核在处理 CPU 调度时变得越来越程序化，现代 Linux 发行版提供了很多相关选项。因此，各个
    Linux 发行版引入了像 **tuned** 这样的概念，这是一个基于预设或手动创建的配置文件来调节系统性能的系统，另外还有 **tuna**，这是一款能够进行深度应用特定调优的工具。我们始终需要具备深入调优的能力，以便让系统能够针对特定的使用场景获得最佳性能。
- en: There's more…
  id: totrans-235
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多…
- en: 'If we need to learn more about these concepts, we can check the following links:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们需要了解更多关于这些概念的信息，可以查看以下链接：
- en: '**A guide to the Linux top command**: [https://www.booleanworld.com/guide-linux-top-command/](https://www.booleanworld.com/guide-linux-top-command/)'
  id: totrans-237
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Linux top 命令指南**: [https://www.booleanworld.com/guide-linux-top-command/](https://www.booleanworld.com/guide-linux-top-command/)'
- en: '**CPU scheduling**: [https://access.redhat.com/documentation/en-us/red_hat_enterprise_linux/6/html/performance_tuning_guide/s-cpu-scheduler](https://access.redhat.com/documentation/en-us/red_hat_enterprise_linux/6/html/performance_tuning_guide/s-cpu-scheduler)'
  id: totrans-238
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**CPU 调度**: [https://access.redhat.com/documentation/en-us/red_hat_enterprise_linux/6/html/performance_tuning_guide/s-cpu-scheduler](https://access.redhat.com/documentation/en-us/red_hat_enterprise_linux/6/html/performance_tuning_guide/s-cpu-scheduler)'
- en: '**top man page**: [https://man7.org/linux/man-pages/man1/top.1.html](https://man7.org/linux/man-pages/man1/top.1.html)'
  id: totrans-239
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**top 手册页**: [https://man7.org/linux/man-pages/man1/top.1.html](https://man7.org/linux/man-pages/man1/top.1.html)'
- en: '**nice man page**: [https://man7.org/linux/man-pages/man1/nice.1.html](https://man7.org/linux/man-pages/man1/nice.1.html)'
  id: totrans-240
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**nice 手册页**: [https://man7.org/linux/man-pages/man1/nice.1.html](https://man7.org/linux/man-pages/man1/nice.1.html)'
- en: '**renice man page**: [https://man7.org/linux/man-pages/man1/renice.1.html](https://man7.org/linux/man-pages/man1/renice.1.html)'
  id: totrans-241
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**renice 手册页**: [https://man7.org/linux/man-pages/man1/renice.1.html](https://man7.org/linux/man-pages/man1/renice.1.html)'
- en: '**Getting started with tuned**: [https://access.redhat.com/documentation/en-us/red_hat_enterprise_linux/8/html/monitoring_and_managing_system_status_and_performance/getting-started-with-tuned_monitoring-and-managing-system-status-and-performance](https://access.redhat.com/documentation/en-us/red_hat_enterprise_linux/8/html/monitoring_and_managing_system_status_and_performance/getting-started-with-tuned_monitoring-and-managing-system-status-and-performance)'
  id: totrans-242
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**开始使用 tuned**：[https://access.redhat.com/documentation/en-us/red_hat_enterprise_linux/8/html/monitoring_and_managing_system_status_and_performance/getting-started-with-tuned_monitoring-and-managing-system-status-and-performance](https://access.redhat.com/documentation/en-us/red_hat_enterprise_linux/8/html/monitoring_and_managing_system_status_and_performance/getting-started-with-tuned_monitoring-and-managing-system-status-and-performance)'
- en: '**Reviewing a system using the tuna interface**: [https://access.redhat.com/documentation/en-us/red_hat_enterprise_linux/8/html/monitoring_and_managing_system_status_and_performance/reviewing-a-system-using-tuna-interface_monitoring-and-managing-system-status-and-performance](https://access.redhat.com/documentation/en-us/red_hat_enterprise_linux/8/html/monitoring_and_managing_system_status_and_performance/reviewing-a-system-using-tuna-interface_monitoring-and-managing-system-status-and-performance)'
  id: totrans-243
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**使用 tuna 界面审查系统**：[https://access.redhat.com/documentation/en-us/red_hat_enterprise_linux/8/html/monitoring_and_managing_system_status_and_performance/reviewing-a-system-using-tuna-interface_monitoring-and-managing-system-status-and-performance](https://access.redhat.com/documentation/en-us/red_hat_enterprise_linux/8/html/monitoring_and_managing_system_status_and_performance/reviewing-a-system-using-tuna-interface_monitoring-and-managing-system-status-and-performance)'
- en: Configuring crond
  id: totrans-244
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 配置 crond
- en: Having the capability to run jobs on a schedule is very important for everyday
    system administration. We schedule backups, run cleanup procedures, send reports,
    do antivirus checks, and do other tasks that business procedures need. Scheduling
    them means a certain level of automation and getting rid of the manual approach
    to things, which in turn again gives us more time to focus on more important tasks.
    Generally speaking, we use either commands or scripts as a way to do these scheduled
    tasks, and to execute them, we use `cron daemon` (`crond`). Let's learn how to
    use `crond` to schedule jobs in accordance with our needs.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 拥有按计划运行任务的能力对于日常系统管理非常重要。我们安排备份、执行清理操作、发送报告、做杀毒检查以及其他业务流程需要的任务。通过调度这些任务，我们实现了一定程度的自动化，摆脱了手动操作，这样我们就可以有更多时间专注于更重要的任务。一般来说，我们使用命令或脚本来执行这些计划任务，而要执行它们，我们使用
    `cron daemon`（`crond`）。让我们学习如何使用 `crond` 根据我们的需求调度任务。
- en: Getting ready
  id: totrans-246
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备开始
- en: Keep the `cli1` virtual machine powered on and let's create some scheduled jobs
    via `crond`.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 保持 `cli1` 虚拟机开机，让我们通过 `crond` 创建一些计划任务。
- en: How to do it…
  id: totrans-248
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作…
- en: 'Let''s start by using root to create a cron job. We are going to achieve that
    by typing in the following command as root:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从使用 root 创建一个 cron 任务开始。我们将通过以 root 身份输入以下命令来实现：
- en: '[PRE12]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'In Ubuntu, we are going to be asked to select which editor we want to use.
    For continuity reasons, let''s say that we choose the vi editor (`vi.basic`).
    Let''s add the following entry to the end of the file that we''re editing in vi:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Ubuntu 中，我们将被要求选择想要使用的编辑器。为了保持一致性，假设我们选择了 vi 编辑器（`vi.basic`）。让我们在我们正在编辑的 vi
    文件末尾添加以下内容：
- en: '[PRE13]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'If we save the file as is, we just created the first root cron job – the one
    that''s going to execute every minute. The `*` signs are actually *frequency fields*
    in these crontab files. Look at the following:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们按原样保存文件，我们就创建了第一个根 cron 任务——它将在每分钟执行一次。`*` 符号实际上是这些 crontab 文件中的 *频率字段*。请看下面的例子：
- en: '[PRE14]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Now scroll a bit lower on the man page; we''re going to find the following
    examples:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 现在稍微向下滚动一下 man 页面，我们将找到以下示例：
- en: '![Figure 3.25 – Excerpt from man 5 crontab page'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 3.25 – man 5 crontab 页面摘录](img/Figure_3.25_B16269.jpg)'
- en: '](img/Figure_3.25_B16269.jpg)'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_3.25_B16269.jpg)'
- en: Figure 3.25 – Excerpt from man 5 crontab page
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.25 – man 5 crontab 页面摘录
- en: The first part explains the fields, as there are six of them. The first five
    are related to the frequency of executing the six fields. We can use space or
    *Tab* as delimiters between these fields.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 第一部分解释了这些字段，因为总共有六个。前五个字段与执行频率有关。我们可以使用空格或 *Tab* 作为这些字段之间的分隔符。
- en: 'The first five fields are as follows:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 前五个字段如下：
- en: 'The `minute` field: At which minute the job should be executed'
  id: totrans-261
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`minute` 字段：任务应在哪一分钟执行'
- en: 'The `hour` field: At which hour the job should be executed'
  id: totrans-262
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`hour` 字段：任务应在哪一小时执行'
- en: 'The `day of month` field: On which day of the month the job should be executed'
  id: totrans-263
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`day of month` 字段：任务应在每月的哪一天执行'
- en: 'The `month` field: On which month the job should be executed'
  id: totrans-264
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`month` 字段：任务应在哪个月执行'
- en: 'The `day of week` field: On which day of the week the job should be executed'
  id: totrans-265
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`day of week` 字段：指定任务应该在一周中的哪一天执行'
- en: 'All of these fields support various types of syntax:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些字段都支持各种类型的语法：
- en: '`75` in the `minute` field, that doesn''t make any sense as single numbers
    in the `minute` field go from `0` to `59`.'
  id: totrans-267
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`75` 在 `minute` 字段中没有意义，因为 `minute` 字段中的单个数字范围是 `0` 到 `59`。'
- en: '`3-47` in the `hour` field, that won''t work as the number range for hours
    is `0-23`.'
  id: totrans-268
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`3-47` 在 `hour` 字段中是无效的，因为小时的范围是 `0-23`。'
- en: '`0-10/2` in the first field, which `cron` translates to *from the 0th to 10th
    minute, every second minute*.'
  id: totrans-269
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第一个字段中的 `0-10/2`，`cron` 会将其解释为*从第 0 分钟到第 10 分钟，每隔第二分钟*。
- en: '`0`,`2`,`4`,`6`,`8`,`10`.'
  id: totrans-270
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`0`,`2`,`4`,`6`,`8`,`10`。'
- en: '**Combination thereof**: Any combination of previously mentioned syntaxes.'
  id: totrans-271
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**组合**：任何之前提到的语法组合。'
- en: All of these syntaxes give us many different options to configure which jobs
    we want to execute and when, down to the minute. We also need to remember that
    `cron` doesn't allow frequency smaller than a minute. If we need to do something
    like that, we need to work *around* that fact (using the `sleep` function, the
    `at` command, and others).
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些语法给我们提供了许多不同的选项来配置我们希望执行哪些任务以及何时执行，甚至可以精确到分钟级别。我们还需要记住，`cron` 不允许小于一分钟的频率。如果我们需要做类似的事情，我们需要*绕过*这个限制（使用
    `sleep` 函数、`at` 命令等）。
- en: 'If we are logged in as root, that gives us the capability to manage a user''s
    cron jobs as well. For example, say we type in the following command:'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们以 root 用户登录，这也让我们能够管理用户的 cron 任务。例如，假设我们输入以下命令：
- en: '[PRE15]'
  id: totrans-274
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: We are going to be editing `crontab` for the `student` user.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将要编辑 `student` 用户的 `crontab`。
- en: 'Furthermore, if we want to remove `student`''s cron jobs, we can do it like
    this:'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，如果我们想删除 `student` 用户的 cron 任务，可以这样做：
- en: '[PRE16]'
  id: totrans-277
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'If we just need to list cron jobs from the `student` user, we can use the following
    command:'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们只需要列出 `student` 用户的 cron 任务，可以使用以下命令：
- en: '[PRE17]'
  id: totrans-279
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Let''s go back to system cron jobs, the second most common type of cron jobs.
    These are configured in system folders under the `/etc` directory, such as `/etc/cron.daily`
    and `/etc/cron.hourly`. The keyword that follows `cron.` in the directory name
    tells us the frequency for all of the jobs configured in that folder. For example,
    let''s take a look at the `cron.daily` folder:'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回到系统 cron 任务，这是第二常见的 cron 任务类型。这些任务在 `/etc` 目录下的系统文件夹中配置，如 `/etc/cron.daily`
    和 `/etc/cron.hourly`。目录名中的 `cron.` 关键字后跟的内容告诉我们该文件夹中所有任务的执行频率。例如，来看一下 `cron.daily`
    文件夹：
- en: '![Figure 3.26 – Daily system cron jobs'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 3.26 – 系统的日常 cron 任务'
- en: '](img/Figure_3.26_B16269.jpg)'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_3.26_B16269.jpg)'
- en: Figure 3.26 – Daily system cron jobs
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.26 – 系统的日常 cron 任务
- en: 'Some of these filenames probably sound familiar. `logrotate` does log rotation,
    the `mlocate` job updates the file/folder database used by the `updatedb` command,
    and so on. At any given moment, there can be dozens of these system-wide cron
    jobs in those directories, depending on which packages we installed on our Linux
    server and how many additional system jobs we created ourselves. Let''s use the
    `logrotate` file as an example:'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 其中一些文件名可能听起来很熟悉。`logrotate` 用于日志轮转，`mlocate` 任务更新 `updatedb` 命令使用的文件/文件夹数据库，等等。在任何给定时刻，这些系统范围的
    cron 任务可能在这些目录中有数十个，具体取决于我们在 Linux 服务器上安装了哪些软件包，以及我们自己创建了多少额外的系统任务。让我们以 `logrotate`
    文件为例：
- en: '![Figure 3.27 – logrotate cron.daily job, which actually executes a simple
    shell script'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 3.27 – logrotate cron.daily 任务，它实际上执行一个简单的 shell 脚本'
- en: '](img/Figure_3.27_B16269.jpg)'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_3.27_B16269.jpg)'
- en: Figure 3.27 – logrotate cron.daily job, which actually executes a simple shell
    script
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.27 – logrotate cron.daily 任务，它实际上执行一个简单的 shell 脚本
- en: As we can see, this cron job actually executes a shell script, and its configuration
    is the polar opposite of what we saw in user cron jobs where `crontab` files have
    a very strict syntax. Here, we have much more freedom and the fact that we can
    just write outright shell script code in these files makes our job easier. We
    have a lot of additional content about shell scripting coming up later in this
    book, from [*Chapter 9*](B16269_09_Final_PD_ePub.xhtml#_idTextAnchor206), *An
    Introduction to Shell Scripting*, all the way to the end of the book. So, let's
    table that discussion for a later time when we introduce all the necessary concepts
    – variables, loops, functions, arrays, and so on. It is going to be a lot of fun
    indeed.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，这个 cron 任务实际上执行的是一个 shell 脚本，而且其配置与我们在用户 cron 任务中看到的截然不同，后者的 `crontab`
    文件具有严格的语法要求。而这里，我们拥有更多的自由，能够在这些文件中直接写 shell 脚本代码，这让我们的工作更加轻松。关于 shell 脚本的更多内容将在本书后面详细介绍，从
    [*第9章*](B16269_09_Final_PD_ePub.xhtml#_idTextAnchor206)，*Shell 脚本入门*，一直到本书的结尾。所以，关于这些内容的讨论可以稍后再进行，等到我们介绍完所有必要的概念——变量、循环、函数、数组等。到时一定会非常有趣。
- en: How it works…
  id: totrans-289
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: '`crond` is a spooling type of service – it creates queues of tasks that it
    needs to do and then executes them in accordance with specified criteria. In larger
    enterprises, we might consider `crond` criteria to be a part of a bigger picture
    that we usually call policy. Businesses rely on IT-related policies to implement
    standards and levels of service, and in that sense, IT policies are nothing more
    than objects describing a certain need. A need to do scheduled, daily backups,
    a need to run regular security checks by using an `crond`, it''s one of those
    essential tools to deliver those policies.'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: '`crond` 是一种排队类型的服务——它会创建任务队列，然后根据指定的标准执行这些任务。在大型企业中，我们可能会将 `crond` 的标准视为更大图景的一部分，这通常被称为策略。企业依赖于与
    IT 相关的策略来实施标准和服务水平，从这个角度看，IT 策略不过是描述某种需求的对象。比如，需要进行定期的每日备份，需要通过 `crond` 执行定期的安全检查，它就是实现这些策略的关键工具之一。'
- en: '`crond` takes care of different types of scheduled jobs:'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: '`crond` 负责处理不同类型的计划任务：'
- en: '**System-related scheduled jobs**: Daily, hourly, weekly, and other jobs that
    are executed in order for the system to work properly.'
  id: totrans-292
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**与系统相关的计划任务**：每日、每小时、每周及其他任务，这些任务的执行是为了确保系统正常工作。'
- en: '`crond` to make sure to execute them later if we install the `anacron` package,
    which takes care of scenarios such as constant server shutdowns that would lead
    to periodic tasks not being executed regularly.'
  id: totrans-293
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`crond` 用于确保如果我们安装了 `anacron` 包，它能在稍后的时间执行任务，`anacron` 处理一些情境，如持续的服务器关机，这会导致周期性任务无法定期执行。'
- en: '**User-based crond jobs**: These are per-user jobs that regular system users
    can create so that they can execute a job at a given moment.'
  id: totrans-294
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**基于用户的 crond 任务**：这些是每个用户可以创建的任务，普通系统用户可以根据需要在特定时间执行任务。'
- en: First and foremost, we need to learn how user-based cron jobs work, as these
    are the most common jobs on multi-user servers.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要了解基于用户的 cron 任务如何工作，因为这些任务是多用户服务器上最常见的任务。
- en: 'When we use the `crontab -e` command for any given user, a `crontab` file gets
    created in one of the `crond` directories. These files are nothing special in
    terms of complexity – there''s obviously a bit of syntax involved, but they''re
    really well documented even when starting from scratch so that most users won''t
    have problems with figuring this out. In Ubuntu, `crontab` files are created in
    the `/var/spool/cron/crontabs` directory, where all user cron jobs get saved as
    a text file per user. If a file in that directory is named as root, that means
    that the root user has a cron job. If there''s a file named `student`, that means
    that the user called `student` has a cron job scheduled. This makes it easier
    to debug if it ever comes to that. Also, we need to take note of the fact that
    there are people who prefer to edit those files rather than using the `crontab`
    command. At the end of the day, whichever way we solve the IT problem that we
    need to solve is good, as long as it works properly. Let''s take a look at one
    of those files – in this case, it''s going to be an excerpt from the root user''s
    `crontab` file:'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们使用 `crontab -e` 命令为某个用户设置定时任务时，系统会在某个 `crond` 目录下创建一个 `crontab` 文件。这些文件在复杂性上并不特别——虽然其中涉及一些语法，但即使从零开始，文档也非常完善，绝大多数用户不会遇到理解上的问题。在
    Ubuntu 中，`crontab` 文件会被创建在 `/var/spool/cron/crontabs` 目录下，在这里，每个用户的 cron 任务都会作为一个文本文件保存在系统中。如果该目录中的某个文件名为
    root，说明 root 用户有一个定时任务。如果有一个名为 `student` 的文件，说明名为 `student` 的用户有一个定时任务。这使得调试过程变得更简单。如果遇到问题，我们还需要注意，某些人可能更喜欢直接编辑这些文件，而不是使用
    `crontab` 命令。归根结底，无论我们使用什么方式来解决 IT 问题，只要能正常工作，就都没有问题。接下来让我们看一下其中一个文件——这里我们将展示
    root 用户的 `crontab` 文件的一段内容：
- en: '![Figure 3.28 – Root''s crontab file'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 3.28 – Root 的 crontab 文件'
- en: '](img/Figure_3.28_B16269.jpg)'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_3.28_B16269.jpg)'
- en: Figure 3.28 – Root's crontab file
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.28 – Root 的 crontab 文件
- en: We can clearly see that root scheduled a job to be executed every minute here.
    That job lists the content of the `/root` directory and saves it to a file in
    the `/tmp` directory called `root.txt`. It's simple enough, but it clearly shows
    the way in which `crontab` configuration files are created.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以清楚地看到，root 用户在这里安排了一个每分钟执行的任务。该任务列出了 `/root` 目录的内容，并将其保存到 `/tmp` 目录下名为 `root.txt`
    的文件中。这个例子虽然简单，但清晰地展示了 `crontab` 配置文件的创建方式。
- en: '`crond` regularly checks these files and executes configuration stored in them
    at the scheduled time. This is the reason why it''s very important to be careful
    what we put in these files. We really shouldn''t put plain-text passwords, login
    information, or anything similar to these concepts in `crontab` files. By using
    the first five fields in the user''s `crontab` file, `crond` determines the frequency
    for any given scheduled job. It parses these files line by line, which means that
    we can easily schedule multiple cron jobs as users, without any problems.'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: '`crond` 会定期检查这些文件，并在预定时间执行文件中存储的配置。这也是我们需要小心处理这些文件内容的重要原因。我们真的不应该在 `crontab`
    文件中存储明文密码、登录信息或类似的敏感内容。通过使用用户 `crontab` 文件中的前五个字段，`crond` 会确定任何给定定时任务的执行频率。它逐行解析这些文件，这意味着我们可以轻松地为每个用户安排多个
    cron 任务，而不会遇到任何问题。'
- en: 'If we run into problems with users scheduling too many cron jobs eating away
    at the performance of our server, we can always ban them from using `crontab`.
    For example, if we want to deny the `student` user the capability of creating
    user cron jobs, we just need to edit the `/etc/cron.deny` file and add a user
    name per line, like this:'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们遇到用户安排过多 cron 任务导致服务器性能下降的问题，我们可以随时禁止他们使用 `crontab`。例如，如果我们想禁止 `student`
    用户创建定时任务，只需编辑 `/etc/cron.deny` 文件，并逐行添加用户名，如下所示：
- en: '[PRE18]'
  id: totrans-303
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'If we do that, and the user called `student` tries to create a cron job by
    using `crontab -e`, this is the expected result:'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们这样做，并且名为 `student` 的用户尝试使用 `crontab -e` 创建一个定时任务，预期的结果是：
- en: '![Figure 3.29 – Using cron.deny to disable a user''s right to use crontab'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 3.29 – 使用 cron.deny 禁用用户使用 crontab 的权限'
- en: '](img/Figure_3.29_B16269.jpg)'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_3.29_B16269.jpg)'
- en: Figure 3.29 – Using cron.deny to disable a user's right to use crontab
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.29 – 使用 cron.deny 禁用用户使用 crontab 的权限
- en: That's a wrap for this chapter. The next chapter is going to be all about using
    the shell to configure network settings, which includes both network interfaces
    and firewalls. Stay tuned!
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 本章就到此为止。下一章将讲解如何使用 shell 配置网络设置，包括网络接口和防火墙。敬请期待！
- en: There's more…
  id: totrans-309
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多内容……
- en: 'If we need to learn more about these concepts, we can check the following links:'
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们需要了解更多这些概念，我们可以查看以下链接：
- en: '**Automating system tasks**: [https://access.redhat.com/documentation/en-us/red_hat_enterprise_linux/7/html/system_administrators_guide/ch-automating_system_tasks](https://access.redhat.com/documentation/en-us/red_hat_enterprise_linux/7/html/system_administrators_guide/ch-automating_system_tasks)'
  id: totrans-311
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**自动化系统任务**：[https://access.redhat.com/documentation/en-us/red_hat_enterprise_linux/7/html/system_administrators_guide/ch-automating_system_tasks](https://access.redhat.com/documentation/en-us/red_hat_enterprise_linux/7/html/system_administrators_guide/ch-automating_system_tasks)'
- en: '**Crontab man page, chapter 5**: [https://man7.org/linux/man-pages/man5/crontab.5.html](https://man7.org/linux/man-pages/man5/crontab.5.html)'
  id: totrans-312
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Crontab 手册页，第 5 章**：[https://man7.org/linux/man-pages/man5/crontab.5.html](https://man7.org/linux/man-pages/man5/crontab.5.html)'
- en: '**How I use cron in Linux**: [https://opensource.com/article/17/11/how-use-cron-linux](https://opensource.com/article/17/11/how-use-cron-linux)'
  id: totrans-313
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**我在 Linux 中使用 cron 的方式**：[https://opensource.com/article/17/11/how-use-cron-linux](https://opensource.com/article/17/11/how-use-cron-linux)'
- en: '**Use anacron for a better crontab**: [https://opensource.com/article/21/2/linux-automation](https://opensource.com/article/21/2/linux-automation)'
  id: totrans-314
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**使用 anacron 以优化 crontab**：[https://opensource.com/article/21/2/linux-automation](https://opensource.com/article/21/2/linux-automation)'
