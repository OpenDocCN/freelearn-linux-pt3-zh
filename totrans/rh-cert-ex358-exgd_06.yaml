- en: '6'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Printer and Email – Setting Up Printers and Email Services on Linux Servers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we are going to set up printer and email services. These services
    are vital to any company, big or small. The ability to print documentation is
    a necessity for many things. This can include documentation and handouts. Along
    with printing, we will be setting up email services for servers. This will allow
    mail servers to send out emails of the reports we create based on the type of
    reports we set up or programs that utilize email to complete tasks, such as alerting
    the user or providing configuration compliance reports. Through the use of email
    services, we will be able to ensure that nothing is overlooked when it comes to
    our systems.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we’re going to cover the following main topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Learning about printer services and setting them up manually
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Setting up printer services via Ansible Automation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Learning about email services and setting them up manually
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Setting up email services via Ansible Automation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You need to have applied the configuration from [*Chapter 1*](B18607_01.xhtml#_idTextAnchor016),
    *Block Storage – Learning How to Provision Block Storage on Red Hat Enterprise
    Linux*, in order to do the hands-on portion of this chapter. The relevant example
    files and playbooks can be found on the GitHub repository at [https://github.com/PacktPublishing/Red-Hat-Certified-Specialist-in-Services-Management-and-Automation-EX358-Exam-Guide/tree/main/Chapter06](https://github.com/PacktPublishing/Red-Hat-Certified-Specialist-in-Services-Management-and-Automation-EX358-Exam-Guide/tree/main/Chapter06).
  prefs: []
  type: TYPE_NORMAL
- en: Setting up GitHub access
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Please refer to the instructions found in [*Chapter 1*](B18607_01.xhtml#_idTextAnchor016),
    *Block Storage – Learning How to Provision Block Storage on Red Hat Enterprise
    Linux*, to gain access to GitHub. You can find the Ansible automation playbooks
    for this chapter at [https://github.com/PacktPublishing/Red-Hat-Certified-Specialist-in-Services-Management-and-Automation-EX358-/tree/main/ch6](https://github.com/PacktPublishing/Red-Hat-Certified-Specialist-in-Services-Management-and-Automation-EX358-/tree/main/ch6).
    Remember, these are only suggested playbooks, they do not represent the only way
    these solutions can be written.
  prefs: []
  type: TYPE_NORMAL
- en: You can always change them using raw, shell, or cmd to achieve the same results,
    but we seek to demonstrate the best way to accomplish our goals. Also keep in
    mind that we are not using the FCQN required in future versions of Ansible, as
    that will not be supported in the exam, which tests against Ansible 2.9.
  prefs: []
  type: TYPE_NORMAL
- en: Learning about printer services and setting them up manually
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Systems need the ability to print in many cases. This could be in order to output
    some data that you need to deliver at a presentation, or due to the need to print
    material for later referencing. Through the use of printer services, we can set
    up and configure a print queue that will allow us to do just that. We will be
    able to control how and when the printer prints as well as which printer is set
    as the default. With this knowledge, you can set up printers on both RHEL desktops
    and servers. For the hands-on portion of the exercise, you will need a network
    printer on the same network as your servers.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s get started. First, we are going to install the `cups` package to provide
    the dependencies that we need to aggregate. We will do this with the commands
    in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.1 – Install cups package](img/Figure_6.01_B18607.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6.1 – Install cups package
  prefs: []
  type: TYPE_NORMAL
- en: 'By installing the `cups` package, we install all the packages needed to create
    print queues and query printers directly attached to other servers or print servers.
    We will need to enable and start the service, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.2 – Start and enable cups for printer setup](img/Figure_6.02_B18607.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6.2 – Start and enable cups for printer setup
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we are going to enable firewall rules to allow `631/tcp`, which is the
    typical port that printers serve from. We also enable mDNS, which allows dynamic
    discovery through the **Internet Printing Protocol** (**IPP**). The commands needed
    are in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.3 – Add the required firewall rules to discover printers and printing](img/Figure_6.03_B18607.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6.3 – Add the required firewall rules to discover printers and printing
  prefs: []
  type: TYPE_NORMAL
- en: 'The next step for setting up printing on your system is to look up network
    printers. We will use the `ippfind` tool to do that with the command shown in
    the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.4 – Use the ippfind tool to look up network printers](img/Figure_6.04_B18607.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6.4 – Use the ippfind tool to look up network printers
  prefs: []
  type: TYPE_NORMAL
- en: 'After we have located our printers, we will take the one we would like to target
    and create a print queue for it. This will allow us to queue up print jobs to
    send to the printer. This provides the ability to enable and disable the printer’s
    printing functionality, while maintaining the print queue when the printer is
    offline or disabled (unless you intervene manually or through Ansible Automation).
    We can see the print queue created with the `lpadmin` command. (Note that is an
    *L* at the start of `lpadmin`.) We will utilize the following flags: `-p`, `-v`,
    `-m`, and `-E`. These mean the following: `-p queue` name, `-v device` url, while
    `-m everywhere` is the IPP definition, and `-E` is for immediate enabling of the
    printer queue. Please first ensure that the DNS name is routable for the printer
    or add it to `/etc/hosts` in order to ensure reachability. The full command utilized
    can be seen in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.5 – Configure the print queue](img/Figure_6.05_B18607.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6.5 – Configure the print queue
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we are going to set the default printer so that when you create a print
    job it is sent to the right printer. This is normally used when you have multiple
    printers and need to ensure you print to the right one, perhaps at a specific
    location in a building or due to needing to utilize a certain type of printer.
    The command to set the default printer can be seen in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.6 – Set the default printer](img/Figure_6.06_B18607.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6.6 – Set the default printer
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we are going to create a simple text file to print and test that our
    print queue is set up correctly. In my case, my file looks like the following
    screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.7 – Create a test document to print](img/Figure_6.07_B18607.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6.7 – Create a test document to print
  prefs: []
  type: TYPE_NORMAL
- en: 'After we have created the text file to print, we are going to go and actually
    print it. This is done with the command found in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.8 – Print test document](img/Figure_6.08_B18607.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6.8 – Print test document
  prefs: []
  type: TYPE_NORMAL
- en: If the printer successfully printed your page, then you are able to create and
    control printer jobs on `rhel1.example.com`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, let’s see how to disable and enable the print queue. When you disable
    the printer, it will queue the print jobs instead of sending them to the printer.
    This can be seen in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.9 – Disable printer and then attempt to print](img/Figure_6.09_B18607.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6.9 – Disable printer and then attempt to print
  prefs: []
  type: TYPE_NORMAL
- en: 'We are then going to check the current print queue and how it is not moving
    forward as the printer is disabled. After that, we will cancel the print jobs
    so that they do not print when we re-enable the printer. Going to the home directory
    and using the commands found in the following screenshot will show the print queue
    and cancel the print jobs:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.10 – Print queue shows stalled jobs due to the printer being disabled](img/Figure_6.10_B18607.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6.10 – Print queue shows stalled jobs due to the printer being disabled
  prefs: []
  type: TYPE_NORMAL
- en: 'To ensure that we will still be able to print, next we are going to re-enable
    the print queue. This will allow any print jobs to be sent to our default printer.
    This is accomplished by the command in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.11 – Re-enable the print queue after clearing the print queue](img/Figure_6.11_B18607.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6.11 – Re-enable the print queue after clearing the print queue
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we set up a print queue to allow a Linux device to print to
    a network printer. This information is crucial when you need to be able to create
    physical documentation. This could be for handouts at a company event or for an
    internal meeting. The ability to print is necessary and knowing how to set up
    a print queue enables that ability. Next, we are going to set up a print queue
    using Ansible Automation.
  prefs: []
  type: TYPE_NORMAL
- en: Setting up printer services via Ansible Automation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We are going to start this section off by creating a playbook for enabling print
    services using `cups`. We will then create playbooks to enable and disable the
    print queues and also to drain any queued print jobs that might be in line to
    print. This will allow us to control setting up printers over many devices via
    automation, which will shorten the time to completion considerably.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we will start with a playbook directory, inside of which we will have
    an inventory file with a list of the servers we want to set up services on. In
    our case, we are going to set up a print queue on `rhel1.example.com` and `rhel2.example.com`.
    This will allow us to showcase using Ansible Automation in more than just a single
    playbook. We are going to create a `cups_playbook` directory, inside of which
    we are going to first create the inventory file shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.12 – Inventory file for playbook](img/Figure_6.12_B18607.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6.12 – Inventory file for playbook
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we are going to start the playbook as we always have by creating the
    top level of the playbook. The following shows the format that is required for
    the beginning of all playbooks when using Ansible Automation. The start of the
    playbook can be seen in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, let’s move on to the tasks. These include installing `cups`, configuring
    firewall rules, and setting up the printer queue. For this, you will need to know
    the URL of the printer ahead of time, so you might need to gather that information
    from the server using the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: In my case, I will be using the Brother printer that is at the bottom of the
    printer-finding command output in the preceding snippet.
  prefs: []
  type: TYPE_NORMAL
- en: 'With that information, we can write out the command that we learned earlier
    to set up the print queue. You can see the tasks for installing `cups`, firewall
    configuration, and print queue setup in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'We will run the playbook with the following command, including the `-v` flag
    for verbose output such as when the print queue is shown enabled:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'The output from this successful playbook run is truncated but you can see where
    the print queue was enabled in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.13 – Successful playbook run for the cups create playbook](img/Figure_6.13_B18607.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6.13 – Successful playbook run for the cups create playbook
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we are going to write a playbook to disable the print queue and then
    another to enable it. Here you can see the playbook code to disable the print
    queue:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'The output of this playbook run for disabling the print queue can be seen in
    the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.14 – Successful playbook run for the cups disable playbook](img/Figure_6.14_B18607.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6.14 – Successful playbook run for the cups disable playbook
  prefs: []
  type: TYPE_NORMAL
- en: 'The playbook shown in the following code enables the print queue:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'The output for enabling the print queue can be seen in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.15 – Successful playbook run for the cups enable playbook](img/Figure_6.15_B18607.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6.15 – Successful playbook run for the cups enable playbook
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we learned how to set up print queues through Ansible Automation.
    This can be extremely useful in an enterprise environment where you might be setting
    up many servers that need to print to the same printer. By setting up Ansible
    Automation playbooks to do the work for you, you free up your time for other more
    meaningful work.
  prefs: []
  type: TYPE_NORMAL
- en: Learning about email services and setting them up manually
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Email services are an essential part of any infrastructure. The ability to send
    email reports or alerts to a dedicated email list is one of the reasons that email
    is so useful. Using the `postfix` package, you are able to set up full email relays
    or null clients that forward emails to other relays. This allows you to control
    how your email is routed in your network. In this section, we will see how to
    set up a null client for these purposes. We will install `postfix` to control
    email from the server, set up firewall rules, and finally set up the null client
    settings both manually and through Ansible Automation.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first thing we have to do is install `postfix`. Running the command to
    install `postfix` can be seen in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.16 – Install postfix](img/Figure_6.16_B18607.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6.16 – Install postfix
  prefs: []
  type: TYPE_NORMAL
- en: 'We are then going to view the configuration file for `postfix`. This is not
    the best way to set up `postfix` as the `postconf` command is normally used to
    change the required settings. The configuration file can be seen truncated in
    the following screenshot and is located at `/etc/postfix/main.cf`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.17 – Postfix main.cf truncated](img/Figure_6.17_B18607.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6.17 – Postfix main.cf truncated
  prefs: []
  type: TYPE_NORMAL
- en: 'Using the `postconf` command, you can see the same configuration without the
    comments, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: "![Figure 6.18 – Output from \uFEFFthe postconf command truncated](img/Figure_6.18_B18607.jpg)"
  prefs: []
  type: TYPE_IMG
- en: Figure 6.18 – Output from the postconf command truncated
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we are going to make the required changes to the system to set up what
    is needed for `postfix` to work as a null client, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.19 – Using the postconf command to change configuration values](img/Figure_6.19_B18607.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6.19 – Using the postconf command to change configuration values
  prefs: []
  type: TYPE_NORMAL
- en: This allows you to make changes to your `postfix` configuration based on the
    requirements set by Red Hat during your exam.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s look at an example of what you may need to set for a null client setup.
    A null client is just a server that passes emails on to another server and does
    not accept any email itself.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first setting to change is `inet_interfaces`, making it `loopback-only`,
    as shown in the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Then we are going to set the `myorigin` parameter to use the domain name, in
    our case, `example.com`, as seen in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we are going to set `inet_protocols` to `ipv4` purely for simplicity,
    as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'The next setting we are going to change is the `mydestination` parameter, as
    `postfix` is allowed to deliver mail if this value is populated. To ensure that
    nothing is delivered to this server locally, we will remove all settings. We are
    going to change the `mydestination` setting to blank, per the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, let’s alter the `mynetworks` parameter in order to submit messages to
    the mail relay for any network hosts. We will set this to our loopback IP in order
    for it to take effect, as seen in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'The next thing we are going to set is an error message for local delivery.
    This helps us confirm that local delivery is disabled. This is accomplished in
    the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we are going to point to an active mail relay that can deliver email
    locally and to the company’s mail servers. This is done with the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'We have now set up the `postfix` mail service. Now, let’s open the firewall,
    start the service, and enable it. These commands can be seen in the following
    screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.20 – Enable and start the service, add firewall rules, and reload
    the firewall](img/Figure_6.20_B18607.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6.20 – Enable and start the service, add firewall rules, and reload the
    firewall
  prefs: []
  type: TYPE_NORMAL
- en: 'If you start and enable the `postfix` service before configuring, you need
    to make sure to reload the service again to ensure that the changes have been
    accepted and check the status, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.21 – Check the status of postfix](img/Figure_6.21_B18607.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6.21 – Check the status of postfix
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we learned how to set up a null client email server. This is
    useful for setting up email notifications to be sent from a server to send reports
    or alerts. We learned how to manipulate `postfix` with the `postconf` command
    and which variables need to be changed to create a null client.
  prefs: []
  type: TYPE_NORMAL
- en: Setting up email services via Ansible Automation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We are going to set up `postfix` with Ansible Automation using a set of variables
    and a loop. This will allow us to create the same setup that we got when doing
    things manually, but done here in an iterative manner using a loop. First, we
    will set up our playbook directory and then our inventory file. The inventory
    file can be seen in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.22 – Inventory for email playbook](img/Figure_6.22_B18607.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6.22 – Inventory for email playbook
  prefs: []
  type: TYPE_NORMAL
- en: 'We are going to start our playbook with the normal starting format, as seen
    in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'After we have set up the beginning of the playbook, let’s create the tasks
    required to get the playbook to successfully configure a null client. We will
    use a loop and loop over the variables we provide to the playbook. We can see
    the playbook in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'With that done, let’s run the playbook with the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'The truncated output of this playbook when successfully run can be seen in
    the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.23 – Successful email setup playbook run](img/Figure_6.23_B18607.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6.23 – Successful email setup playbook run
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, let’s check and confirm our configuration of `mynetworks` to ensure
    that it is only using `127.0.0.0/8`, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.24 – Confirming the settings changed in the postfix configuration](img/Figure_6.24_B18607.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6.24 – Confirming the settings changed in the postfix configuration
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we learned how to set up a `postfix` null client using Ansible
    Automation. This is a great way to set up your mail servers easily using predetermined
    values that can span multiple hosts. This allows you to quickly set up these servers
    without having to install and then type in the configuration commands on each
    and every server.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we went over how to print from a server and how to set up email
    hosts to correctly forward emails to a relay using a null server. This allows
    you to set up subordinate systems to other masters. With this knowledge, you can
    successfully print from your servers or Linux clients along with sending and receiving
    mail transmissions. In the next chapter, we are going to work with MariaDB and
    the MySQL commands that are available for it. A database is a powerful tool that
    allows you to create backends for web servers and for programs that need a database
    to run. This will allow you to control your data points with ease. We will do
    this both manually and via Ansible Automation to make your life easier when setting
    up multiple databases throughout the course of your career.
  prefs: []
  type: TYPE_NORMAL
