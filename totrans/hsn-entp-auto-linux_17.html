<html><head></head><body>
        <section>

                            <header>
                    <h1 class="header-title">Using CIS Benchmarks</h1>
                </header>
            
            <article>
                
<p>When implementing Linux in the Enterprise, security is paramount. There is no one step that can be taken to achieve the nirvana of a truly <em>secure</em> environment—rather, the approach is an amalgamation of disparate steps that come together to build an environment that is as safe and secure as it can be. Indeed, this statement brings us to another important point—security is a moving target. As just one example, SSLv2 was considered to be secure and was used to secure websites across the internet for many years. Then came the DROWN attack in 2016, which rendered it insecure. Thus, a server secured for internet traffic (perhaps a frontend web server) in 2015 would have, at the time, been considered secure. However, in 2017, it would have been considered highly vulnerable.</p>
<p>Linux itself has always been considered a secure operating system, though its high and increasing levels of adoption has seen attacks on the rise. Throughout this book, we have advocated, at a high level, good security practices in the design of your Linux estate, for example, not installing unnecessary services on your base operating system image. Nonetheless, there is much more we can do to make our Linux environment more secure and, in this chapter, we will explore the ways in which standards have been developed to ensure the security of Linux environments. Specifically, we will consider the use of the CIS Benchmarks, along with some practical examples of how to apply them.</p>
<p>Specifically, the following topics will be covered in this chapter:</p>
<ul>
<li><span>Understanding CIS Benchmarks</span></li>
<li>Applying security policy wisely</li>
<li>Scripted deployment of server hardening</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Technical requirements</h1>
                </header>
            
            <article>
                
<p>This chapter includes examples based on the following technologies:</p>
<ul>
<li class="mce-root">CentOS 7.6</li>
<li class="mce-root">Ansible 2.8</li>
</ul>
<p>To run through these examples, you will need access to two servers or virtual machines running the operating system listed previously, along with Ansible. Note that the examples given in this chapter may be destructive in nature (for example, they delete files and make changes to server configuration) and, if run as shown, are only intended to be run in an isolated test environment.</p>
<p class="mce-root">Once you are satisfied that you have a safe environment to operate in, let's get started with routine system maintenance with Ansible.</p>
<p><span>All example code discussed in this chapter is available from GitHub at the following URL:</span><span> <a href="https://github.com/PacktPublishing/Hands-On-Enterprise-Automation-on-Linux/tree/master/chapter13">https://github.com/PacktPublishing/Hands-On-Enterprise-Automation-on-Linux/tree/master/chapter13</a></span>.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Understanding CIS Benchmarks</h1>
                </header>
            
            <article>
                
<p>Before we delve into what a CIS Benchmark actually consists of, let's take a look at why they exist and, conceptually, what they are.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">What is a CIS Benchmark?</h1>
                </header>
            
            <article>
                
<p>Securing servers, regardless of their operating system, is a big task. It requires being constantly up to date with new attack vectors and vulnerabilities as they are discovered (see the mention of the DROWN attack and SSLv2 in the introduction to this chapter). Some things are well-known and considered <em>normal</em>. For example, on Linux, it is generally frowned upon to ever log in as root—instead, it is almost universally recognized that each individual user should have their own user account and should perform all commands requiring elevated permissions using the <kbd>sudo</kbd> command. Thus, some Linux distributions such as Ubuntu come with remote root access disabled by default. Others, such as CentOS, do not. Even between these two key distributions commonly found in the enterprise, you know that, for one, you need to actively turn off remote root SSH access and, for the other, you just need to check that it is turned off.</p>
<p>Of course, defining a security policy goes far deeper than whether root access is allowed over SSH. Over the years, individuals build up a wealth of knowledge about what works and, perhaps by learning the hard way, what doesn't. However, the security of your environment should not be defined by how experienced your system administrators are. Rather, there should be some defined standard for how to best secure a server to prevent most of the common attacks, and also to ensure that a suitable level of information is logged in the case that an audit is ever required to find the root cause of an event.</p>
<p>This is where the concept of the CIS Benchmark comes in. Many people are familiar with the concept of a benchmark as a performance test (that is, speed). However, whether your server is secure or not is something that can be tested by looking for certain criteria, and thus the CIS Benchmark exists. Quoting directly from the <strong>Community for Internet Security</strong> (<strong>CIS</strong> for short) website:</p>
<div class="packt_quote"><span>"CIS Benchmarks are developed through a unique consensus-based process comprised of cybersecurity professionals and subject matter experts around the world."</span></div>
<p>Thus, these benchmarks can be considered an amalgamation of best practices from industry professionals. Further, they are regularly updated and so can be used by engineers and administrators to keep abreast of best practices when it comes to securing a server.</p>
<p>It should, of course, be noted that there are other security standards out there that go to even greater depths than the CIS Benchmark, for example, FedRAMP and NSA security requirements. It would be impossible to go into detail of all the different profiles available within this book, and so we will focus on the CIS Benchmark, which is freely available (in exchange for some personal information) and is also well regarded.</p>
<div class="packt_infobox">That this book focuses on the CIS Benchmarks should not be taken as an implicit statement that you should implement these on your server estate in order for it to be secure. It is the duty of each and every reader to ensure they understand their own security requirements and to implement the correct ones accordingly. In this chapter, we work through the use of CIS Benchmarks as a worked example of server hardening to a given standard.</div>
<p>Also of note is that the CIS Benchmarks are divided by technology. For example, there is a CIS Benchmark for both Red Hat Enterprise Linux 7 and Ubuntu Server, which you can apply to your Enterprise Linux estate. However, these focus on securing the base operating system, and if you install an application layer on top of it, then you must apply the appropriate security policy for that as well.</p>
<p>There are CIS Benchmarks for more than 140 technologies, including common Linux services such as nginx, Apache, and PostgreSQL. Thus, if you are building an internet-facing web server, it would make sense to apply both the operating system benchmark and then the appropriate one for the chosen web server.</p>
<p>If you have a bespoke application layer, or indeed are simply using a technology not listed on the CIS website, do not despair—secure the underlying operating system using the appropriate benchmark and then apply security practices in the best way you can. Often, there is good advice on the internet, but figuring this out is beyond the scope of this book.</p>
<p>A full list of the technologies for which there are CIS Benchmarks can be found here: <a href="https://www.cisecurity.org/cis-benchmarks/">https://www.cisecurity.org/cis-benchmarks/</a><span>.</span></p>
<p>Once you have obtained the security benchmark for your chosen operating system, it is time to consider the application of it. Before we get this far, though, in the next section of this chapter, we will explore in greater detail the contents of a CIS Benchmark for the Linux operating system.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Exploring CIS Benchmarks in detail</h1>
                </header>
            
            <article>
                
<p>Let's take a practical example to explore CIS Benchmarks in greater detail by looking at the one for RHEL 7. At the time of writing, this is on release version 2.2.0 and consists of 386 pages! Thus, immediately we can see that implementing this benchmark is unlikely to be a trivial activity.</p>
<p>As you explore the document, you will find that the section of most interest to us—the <em>Recommendations</em> section—is divided into subsections. Each of these focuses on a specific area of security within the operating system. At the time of writing, <em>section 1</em> is all about the initial setup of the operating system; parameters and configuration likely to be applied at build time. S<em>ection 2</em> is all about securing common services that might be installed by default on a RHEL 7 server. <em>Section 3</em> deals with network configuration, while s<em>ection 4</em> goes into detail on your logging and audit logging setup to ensure you are capturing the requisite amount of data during daily use. This is to ensure you can audit your servers and find out what happened if you are unfortunate enough to suffer a breach or an outage. <em>Section 5</em> considers access to your server and authentication (this is where you will find SSH server security mentioned—in fact, you will see that our example of disabling remote root logins is benchmark 5.2.8 in version 2.2.0 of the document). Finally, <em>section 6</em> is entitled <em>System Maintenance</em> and is intended to be run not once, but regularly, to ensure the integrity of the system.</p>
<p>Of course, we have discussed previously in this book that it is possible for anyone with root privileges to change core system configuration, and thus it is recommended that all of the benchmarks be run (or at least checked) on a regular basis to ensure compliance with the original policy.</p>
<p>We will explore this across the next two chapters of this book; however, for now, let's return to furthering our understanding of the CIS Benchmark itself. As you look into each recommendation, you will notice that each has a level associated with it and is either <em>Scored</em> or <em>Not Scored</em> (this is stated in the title of each benchmark).</p>
<p>Each of these benchmarks are intended to contribute to a final report or scoring of a system as part of a compliance check—and recommendations that are scored quite literally contribute to the final score. Thus, if your system meets the check, then the final score is increased—however, if it is not met, the final score is decreased. Those marked as <em>Not Scored</em> have no bearing on the final score at all. In other words, you are not marked down for failing to implement them.</p>
<p>This, of course, does not mean they are any less important to consider. By way of example, let's consider benchmark 3.7 of the version 2.2.0 RHEL 7 benchmark, which is entitled <em>Ensure wireless interfaces are disabled</em>. The rationale between each benchmark is given in the details of the benchmark, and this one states the following:</p>
<div class="packt_quote">
<div class="page">
<div class="layoutArea">
<div class="column"><span>"If wireless is not to be used, wireless devices can be disabled to reduce the potential attack surface."</span></div>
</div>
</div>
</div>
<p class="mce-root">This is a logical approach—we know that if your device has a wireless interface, it should be disabled unless it is in use. In addition, wireless security protocols have been historically broken, just as SSLv2 was, and thus, in the long term, wireless network communication might not be considered to be truly secure. Nonetheless, on a corporate laptop running RHEL 7, you cannot guarantee that it will be connected to a wired network connection. Wireless networking might be the only option and, in this instance, you would need to leave it turned on.</p>
<p>Of course, the CIS Benchmark cannot make this decision for you—only you can know whether your system needs to have its wireless network adapters enabled (if present), and so it is reasonable that this is a non-scorable item. </p>
<p>By contrast, our old friend benchmark 5.2.8 (disabling remote root SSH access) is scored as there should be no rational reason for enabling this in an enterprise environment. Thus, we would expect our system to be scored down if this benchmark could not be met.</p>
<p>Each benchmark has details on how to test for the presence of the condition or configuration mentioned, along with the details on how to apply the desired configuration.</p>
<p>In addition to these details, you will also note that each benchmark has a level associated with it that can be either 1 or 2. In each case, for RHEL 7, you will see that these levels are applied to two different scenarios—the use of RHEL 7 as a server and as a workstation. Again, this makes sense when we delve into the meaning of these levels.</p>
<p>Level 1 is intended to be a sensible security baseline for you to apply to your environment to reduce the attack surface. It is not intended to have an extensive impact on the day-to-day business usage of your Linux environment, and so level 1 benchmarks are the less intrusive ones to implement.</p>
<p>By contrast, level 2 benchmarks are offered to provide a much more rigorous level of security, and are highly likely to have an impact on the day-to-day usage of your environment.</p>
<p>If we look again at benchmark 3.7, we will see that it is categorized as level 1 for servers and level 2 for workstations. This makes sense—a server is unlikely to have a wireless network adapter, and even less likely to be using it, even if present, thus disabling it has little or no impact on the day-to-day usage of the server. However, a RHEL 7 laptop would become a lot less portable if benchmark 3.7 was implemented on it, and so the level 2 categorization warns us of this. Imagine having a laptop and not being able to use it on a wireless network—this is a concept that, to many, is unfeasible in this day and age!</p>
<p>Benchmark 5.2.8 is considered level 1 for both server and workstation because it is already considered good practice not to use the root account for day-to-day operations—thus, disabling access to it over SSH should not have any impact on a day-to-day basis.</p>
<p>In an ideal world, you should read and understand all benchmarks before you apply them in case they have an impact on your way of doing things—for example, I still come across systems that make use of the root account over SSH for scripted operations, and while my first task is normally to rectify this, if I were to blindly apply the CIS Benchmark to these systems, I would break an otherwise working setup.</p>
<p>However, accepting that anyone who manages an Enterprise Linux environment is incredibly busy, you could be forgiven for thinking that you could just apply the scored level 1 benchmarks to your systems. Indeed, this would give you a reasonable security baseline while incurring a relatively low risk—yet there is no substitute for being thorough. In the next section of this chapter, we will look in greater detail at how to wisely select benchmarks without causing issues in your environment!</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Applying security policy wisely</h1>
                </header>
            
            <article>
                
<p>As we had begun to explore in the previous section, each CIS Benchmark has a level and scoring associated with it. The level is of particular concern to us as, while we wish to secure our systems as effectively as possible, we would not wish to break any running systems. For this reason, it is highly advisable to apply the benchmarks in an isolated test environment and test your applications before deploying them to a production environment. Indeed, if the application of a benchmark breaks a given system, the following process should be executed in the enterprise to resolve it:</p>
<ol>
<li>Establish which benchmark caused the issue.</li>
<li>Determine which internal systems were affected by the benchmark.</li>
<li>Decide whether the internal systems can be changed to work with the benchmarks (for example, use an unprivileged account over SSH rather than root).</li>
<li>Implement the changes to the internal systems and apply the benchmark universally or (only if there is a good reason to) make an exception for that benchmark and record it.</li>
</ol>
<div class="packt_infobox">The CIS Benchmarks could even break your Ansible automation—the simplest example being that you are using the root account to perform your automation tasks over, and you disable this as part of your CIS Benchmark deployment. In this instance, you would find Ansible locked out of all of your systems and, in the worst case, you would have to manually modify each server to reinstate Ansible access.</div>
<p class="mce-root">Although we can't go through the benchmarks one by one in this chapter, in the following subsections, we will explore some of the relevant examples to look out for. It is hoped this will give you enough information to review the benchmark for your chosen version of Linux, and then make informed decisions on what security policies are in the best interests of your environment.</p>
<p class="mce-root">We will continue with our example of using the RHEL 7 benchmark version 2.2.0. However, most of what we describe here will be applicable to other Linux platforms too. Configuration file paths and even log file paths might vary, but these will be detailed in the relevant CIS Benchmark for your operating system, so be sure to download the benchmark that is most relevant to you.</p>
<p>Now that we have considered the overall principles of security policy application, we will dive into some specific examples, starting with the SELinux policy in the next section.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Applying the SELinux security policy</h1>
                </header>
            
            <article>
                
<p>Section 1.6.1 of the RHEL 7 benchmark concerns the implementation of SELinux and consists of checks to ensure SELinux is in enforcing mode rather than disabled at some level. You will note that these checks are all level 2 benchmarks, meaning they could break existing systems.</p>
<p>Enabling and applying SELinux is a very good idea on operating systems that support it, yet even at the time of writing there are many Linux applications that do not work with it and whose installation instructions state that SELinux must be disabled for the application to function. This, of course, is not ideal and instead you should create an SELinux policy that allows your application stack to work without the need to disable it. </p>
<p>Not all enterprises will h<span>ave the skill set of time to allow this to be completed, though, and so some careful consideration needs to be given to this set of benchmarks—in short, it should be applied if at all possible, but exceptions may be required.</span></p>
<p>If you are working with Ubuntu, the same logic should be applied to AppArmor, which is enabled by default on Ubuntu Server.</p>
<p><span><span>In the next section of this chapter, we will take a look at how the CIS Benchmarks affect the way filesystems are mounted on Linux</span></span>.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Mounting of filesystems</h1>
                </header>
            
            <article>
                
<p>All filesystems in Linux must be mounted before they can be used—this is quite simply the mapping of block devices such as a partition on a disk to a path. To most users, this is transparent and happens at boot time, but to those responsible for configuring systems, it needs some attention. For example, the <kbd>/tmp</kbd> filesystem is usually writable to all users, and so it is desirable to not let people execute files from this directory as they could put any arbitrary binary in there to be run by themselves or someone else. Thus, this filesystem is often mounted with the <kbd>noexec</kbd> flag to achieve exactly this.</p>
<div class="packt_tip">Changing mount options for partitions (and indeed partition structure) can be problematic on machines that have already been deployed. In addition, many cloud platforms feature a flat filesystem structure and, as such, the preceding example of <kbd>/tmp</kbd> may not be achievable as it cannot be mounted separately from the <kbd>root</kbd> partition. As a result, I recommend that you factor this part of the CIS Benchmark into your server (or image) build process and create exclusions for public cloud platforms where required.</div>
<p>The benchmarks in <em>section 1.1 </em>of the CIS Benchmark (entitled <em>Filesystem Configuration</em>) concern exactly these kinds of details and, again, these will need to be tailored to your environment. For example, benchmark 1.1.1.8 recommends disabling the ability to mount FAT filesystems, and <em>section 1.1.5</em> recommends disabling binary execution on <kbd>/tmp</kbd>, as discussed previously. These are both scored benchmarks and, at the time of writing, there should be little need to use or mount FAT volumes or execute files from <kbd>/tmp</kbd>. However, in some legacy environments, this could still be required and so this should be applied with some care.</p>
<p>Similarly, there are many recommendations around having separate filesystems for important paths such as <kbd>/tmp</kbd> and <kbd>/var</kbd>, and also special mount options. All of these will work in a large number of cases but, again, it would be too bold to state that this will work for everyone, especially in preexisting environments, and so these should be applied but with an understanding of the environmental requirements.</p>
<p><span><span>Having looked at the </span></span>implications of the CIS Benchmarks on how filesystems are mounted, we will proceed to look at the recommendations around intrusion detection using file checksumming.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Installing Advanced Intrusion Detection Environment (AIDE)</h1>
                </header>
            
            <article>
                
<p>Benchmark 1.3.1 concerns the installation of <strong>Advanced Intrusion Detection Environment</strong> (<strong>AIDE</strong>)—a modern replacement for the venerable <strong>Tripwire</strong> utility that can scan the filesystem and checksum all the files, thus providing a reliable way of detecting modifications to the filesystem.</p>
<p>On the face of it, installing and using AIDE is a very good idea—however, if you have an environment with 100 machines in it and you update all of them, you will get 100 reports, each containing details of a large number of file changes. There are other solutions to this problem, including the open source OSSEC project (<a href="https://www.ossec.net/">https://www.ossec.net/</a>), but this is not checked for as part of the CIS Benchmark and so it is left for you to decide what the right solution is for your enterprise.</p>
<p>This, of course, is not to say that AIDE should not be used—far from it. Rather, it is to say that, if you choose to use AIDE, make sure you have processes in place to process and understand the reports, and to ensure that you can distinguish false positives (for example, a change in the checksum of a binary due to a package update) from genuinely malicious and unexpected modifications (for example, <kbd>/bin/ls</kbd> changes even though no package update has been performed).</p>
<p>Having looked at whether AIDE is a viable tool to install on your Linux infrastructure, we will proceed to look at how the CIS Benchmarks impact the default configuration of services at boot time.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Understanding CIS Service benchmarks</h1>
                </header>
            
            <article>
                
<p>Section 2.2 of the benchmark details a number of scored level 1 benchmarks around services that are to be disabled. Again, the rationale behind this is that the attack surface should be minimized, and so, for example, <kbd>httpd</kbd> should not be running unless a server is intended to be a web server.</p>
<p>While logical in itself, a review of this section turns up a large number of services that could be vital for your environment, including <kbd>squid</kbd>, <kbd>httpd</kbd>, and <kbd>snmpd</kbd>. For all of these benchmarks, they should only be applied if it makes sense to do so. You would not turn off Apache on a web server, and neither would you disable <kbd>squid</kbd> on a proxy server.</p>
<p>However, good guidance is given with regard to these benchmarks about when they should be applied and, in the case of <kbd>snmpd</kbd>, there is even guidance on securing the service if your environment relies on this for monitoring purposes.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">X Windows</h1>
                </header>
            
            <article>
                
<p>Benchmark 2.2.2 goes as far as ensuring that the X Windows server is actually uninstalled from your systems. Most servers are headless and it would be possible to do this—however, you would not do this for a workstation or for a system that performs remote desktop functions. </p>
<p>Be sure to apply this benchmark to your servers, but only when you know it is safe to apply it.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Allowing hosts by network</h1>
                </header>
            
            <article>
                
<p>Benchmarks 3.4.2 and 3.4.3 ensure that <kbd>/etc/hosts.allow</kbd> and <kbd>/etc/hosts.deny</kbd> are configured—this means that, for all services that process these two files, only connections from networks that are allowed are actually processed. </p>
<p>This is generally a good idea—however, many organizations have good firewalls and some actually have policies of not allowing local firewalls on their servers because it complicates the process of debugging. If a connection is denied, the more firewalls you have, the more you have to check to find out where it was denied.</p>
<p>Thus, it is recommended you apply these two benchmarks in accordance with your corporate security policy.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Local firewalls</h1>
                </header>
            
            <article>
                
<p>The same applies for the benchmarks in <em>section 3.6</em> that concern the installation and configuration of iptables. Although this local firewall increases your level of server security, it is in contrast to many corporate security policies of having fewer, more centralized, firewalls rather than many localized ones. Apply these benchmarks in accordance with corporate policy.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Overall guidance on scoring</h1>
                </header>
            
            <article>
                
<p>You will note that many of the benchmarks I have advised you to exercise caution over applying are actually scored. This brings us to a wider point regarding scoring—the aim of applying CIS Benchmarks is not to achieve a 100% score. Rather, it is to achieve the highest possible score that is right for your environment and enables your enterprise to function correctly.</p>
<p>Scoring should instead be used to establish your own baseline—once you have worked through all benchmarks in the manner discussed in this chapter, you will know which are right for your enterprise and, hence, what your target score is.</p>
<p>Through a process of auditing the results of repeated applications of the benchmark, repeated scoring exercises can be performed to track overall environment compliance and drift over time. For example, if repeated audits show an ever-decreasing score, then you know you have a problem with regards to compliance, for the root cause must be established—whether that is users making unauthorized changes to systems, or even rolling out new servers that have not been correctly secured.</p>
<p>Either way, your CIS Benchmark score will become a useful tool in monitoring the compliance of your Linux estate with your security policy. In the next section of this chapter, we will explore scripted approaches to CIS Benchmark application and compliance.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Scripted deployment of server hardening</h1>
                </header>
            
            <article>
                
<p>We have spent some time exploring the CIS Benchmarks and how they are intended to be worked with. Now, let us turn our attention to more practical matters—how to audit them and how to implement them. In this book, we have focused on Ansible as our chosen tool for automating such tasks, and indeed Ansible is an excellent solution for this purpose. With that said, of course, you will have noticed that the examples in the CIS Benchmark document itself are often shell commands or, in some cases, are simply statements regarding configuration lines that should exist (or not exist) in a given file.</p>
<p>In order to clearly explain the auditing and implementation of the CIS Benchmark on a Linux system, I have split the examples into two. In this part of this chapter, we will develop traditional shell scripts for checking for CIS Benchmark compliance, and then for implementing the recommendations if required. This will look very similar to the CIS Benchmark document itself and thus will help with generating an understanding of how to implement them. Then, in the next chapter, we will develop these shell script-based examples into Ansible roles so that we can use our favorite automation tool to manage our CIS Benchmark compliance.</p>
<p>Let's work through some examples to demonstrate how to develop such scripts, starting with our root login over SSH example.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Ensuring SSH root login is disabled</h1>
                </header>
            
            <article>
                
<p>CIS recommendation 5.2.8 in version 2.2.0 of the RHEL 7 benchmark is that we should disable remote root logins. We have visited this example already in other guises, and here we will look specifically at the recommendations in the CIS Benchmark document to help us understand how this should be implemented. </p>
<p>The document states that, to audit for this requirement (and thus score this item), the following test result should be observed:</p>
<pre># grep "^PermitRootLogin" /etc/ssh/sshd_config <br/>PermitRootLogin no</pre>
<p>Note that the command is intended for a human being to interpret the output of it—this command will return the <kbd>PermitRootLogin</kbd> line from this file, regardless of whether it is enabled or disabled. The text shows the desired output, but assumes that the person running the test will read the output and check whether it is enabled or not—workable on a small scale, but not viable for automation purposes. The remediation suggested is to edit <kbd>/etc/ssh/sshd_config</kbd> to set the following parameter:</p>
<pre>PermitRootLogin no</pre>
<p>So far, so good—the CIS Benchmark document is quite descriptive, and even gives us a head start with our coding. However, as stated previously, these snippets don't really help us to either check or implement this recommendation in an automated manner. </p>
<p>Suppose we want to audit for this condition using a shell script. In this instance, we would want to run the <kbd>grep</kbd> command mentioned in the benchmark document, but use a more precise pattern to ensure we only match the <kbd>PermitRootLogin</kbd> line when it is set to <kbd>no</kbd>. We would then check for the desired output and <kbd>echo</kbd> a suitable message to the console, depending on the result of the check. This script might look like this (noting that there are multiple ways to achieve the same end result in shell scripting!):</p>
<pre>#!/bin/sh<br/>#<br/># This file implements CIS Red Hat Enterprise Linux 7 Benchmark<br/># Recommendation 5.2.8 from version 2.2.0<br/>echo -n "Ensure root logins are disabled on SSH... "<br/>OUTPUT=$(grep "^PermitRootLogin no" /etc/ssh/sshd_config)<br/>if [ "x$OUTPUT" == "x" ]; then<br/>  echo FAILED!<br/>else<br/>  echo OK<br/>fi</pre>
<p>The script is fairly straightforward for anyone familiar with shell scripts, but in brief, here are the steps:</p>
<ol>
<li>We put some useful documentation in the comments at the top of the file so that we know which recommendation we are testing for. Note that recommendation numbers might change between document versions and so it is important to record both.</li>
<li>We <kbd>echo</kbd> a line of informative text about the test we are running.</li>
<li>Then, the suggested audit command from the CIS Benchmark is run, only this time we are checking for the presence of the <kbd>PermitRootLogin no</kbd> line. The output is captured in an <kbd>OUTPUT</kbd> variable.</li>
</ol>
<ol start="4">
<li>If the contents of <kbd>OUTPUT</kbd> are blank, then we know the line we are checking for does not exist in the file and the test is assumed to have failed. We can safely assume this because root logins are enabled by default in the OpenSSH server, and so if this line is absent from the configuration file, then provided there were no issues with our <kbd>grep</kbd> pattern, root logins are enabled. We <kbd>echo</kbd> this to the Terminal so that the user knows to take action.</li>
<li>The only condition under which the <kbd>OUTPUT</kbd> variable should contain text is when the <kbd>grep</kbd> command finds the desired pattern. If this condition is achieved, then we echo a different message for the user so that they know that this test has passed and no further action is required.</li>
</ol>
<p>Let's see this script in action, along with an attempt to fix the problem by hand:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/9a53551f-7c99-4e7d-9fdd-0969f7a0caa2.png" style="width:44.67em;height:20.83em;"/></p>
<p>Here, we can see a prime example of the manual process, which many system administrators and engineers will be familiar with when managing their estates. We ran the check script defined previously and it yielded the response <kbd>FAILED!</kbd>. Thus, our first step was to take a look at the config file to see why the test failed. There were one of two possibilities that would have caused this result—either the line containing <kbd>PermitRootLogin</kbd> was not present at all, or it was commented out. In this case, the former proved to be true.</p>
<p>If the line had been present, but commented out, we could have used <kbd>sed</kbd> (or another inline editing tool) to uncomment the line and set the parameter to <kbd>no</kbd>. However, as the line was not present, we needed to append the line to the file, which we have done in the previous screenshot using the <kbd>tee -a</kbd> command. Note that this was needed in conjunction with <kbd>sudo</kbd> because only <kbd>root</kbd> can write to this file. We then run the test a second time and it passes. Of course, you will note that it would have been entirely possible to simply open this file with <kbd>vim</kbd> (or your favorite editor) and correct the issue manually; however, the previous example could lend itself to a scripted solution.</p>
<p>As shown from the preceding example, this is an incredibly slow and manual process. This would be bad enough to perform on a single server (for example, the template image), but imagine scaling this up across an entire estate of Linux servers, and then to all the recommendations in the CIS Benchmark document. The task would be a full-time (and very tedious) job for someone.</p>
<p>It's better to automate the process and you will note that, in the CIS Benchmark document, there is not only a test case for auditing the recommendation on a server, but also a recommended alteration. In most cases, this is simply a statement of the line(s) that should be present in the given configuration file(s). In this case, we want to assert the following:</p>
<pre>PermitRootLogin no</pre>
<p>If we were to try and remedy this issue by developing our shell script further, we would need to perform the following steps when the test results are in a <kbd>FAILED!</kbd> state (on an <kbd>OK</kbd> result, no further action is necessary):</p>
<ol>
<li>As we have failed to match the desired pattern in the file, we know that the line is either present, but has the wrong setting, or is not present at all (either absent or commented out). We can ignore the difference between the last two possibilities as it will do no harm to leave the commented out line in place and add the correct line in. Thus, our first task is to test for the presence of the <kbd>PermitRootLogin</kbd> line, regardless of its setting:</li>
</ol>
<pre style="padding-left: 60px">  OPTPRESENT=$(grep -e "^PermitRootLogin.*" /etc/ssh/sshd_config)<br/>  if [ "x$OPTPRESENT" == "x" ]; then<br/>  ...<br/>  else<br/>  ...<br/>  fi</pre>
<ol start="2">
<li>In the previous screenshot, we are looking for any line in the configuration file that begins with <kbd>PermitRootLogin</kbd>. If we get nothing back (our positive test case), then we know we must add the line to the file by adding the following directly under the <kbd>if</kbd> statement:</li>
</ol>
<pre style="padding-left: 60px">    echo "Configuration not present - attempting to add"<br/>    echo "PermitRootLogin no" | sudo tee -a /etc/ssh/sshd_config 1&gt;/dev/null</pre>
<ol start="3">
<li>So far, so good. However, if our <kbd>grep</kbd> command did return some output, we know the line is present and the value is incorrect, and so we can use a tool such as <kbd>sed</kbd> to modify the line in place:</li>
</ol>
<pre style="padding-left: 60px">    echo "Configuration present - attempting to modify"<br/>    sudo sed -i 's/^PermitRootLogin.*/PermitRootLogin no/g' /etc/ssh/sshd_config</pre>
<ol start="4">
<li>When we have modified the file (regardless of the route taken), we know we must restart <kbd>sshd</kbd> for the changes to be picked up. Thus, under the closing <kbd>fi</kbd> statement of the inner <kbd>if</kbd> construct, we add the following:</li>
</ol>
<pre style="padding-left: 60px">  sudo systemctl restart sshd</pre>
<ol start="5"/>
<ol start="5">
<li>When we run this with an SSH configuration where this setting is not present, we see the following behavior—note that a second run of the script shows that the modifications were successful:</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img src="assets/151d712f-2ab1-46e3-86d0-cc03e393c074.png" style="width:43.17em;height:8.75em;"/></p>
<ol start="6">
<li>Similarly, if we run it and the line is present and not correct according to the CIS Benchmark, we see the following:</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img src="assets/d988510e-b2a2-4b9a-ba37-3a5e11fe7783.png" style="width:42.92em;height:8.67em;"/></p>
<p>This is excellent—we have just used shell scripts to automate one of the recommendations in the CIS Benchmark document. However, you will note that the shell script we developed contains a lot of repetition and would not be easy to pick up by someone else.</p>
<p>Further, this recommendation is one of the more simple ones—there is only one line to modify in one file in this case. What if the recommendation is more in depth? Let's take a look at that in the next section.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Ensuring packet redirect sending is disabled</h1>
                </header>
            
            <article>
                
<p>Recommendation 3.1.2 of the version 2.2.0 RHEL benchmark is somewhat more detailed—this is a scored level 1 benchmark that ensures that your servers do not send routing information to other hosts. Unless they have been configured as a router, there should be no good reason for them to do this.</p>
<p>From the documentation itself, we can see that the recommended audit commands (and results) are as follows:</p>
<pre><strong>$ sysctl net.ipv4.conf.all.send_redirects </strong><br/><strong>net.ipv4.conf.all.send_redirects = 0</strong><br/><strong>$ sysctl net.ipv4.conf.default.send_redirects </strong><br/><strong>net.ipv4.conf.default.send_redirects = 0</strong><br/><strong>$ grep "net\.ipv4\.conf\.all\.send_redirects" /etc/sysctl.conf /etc/sysctl.d/*</strong><br/><strong>net.ipv4.conf.all.send_redirects = 0</strong><br/><strong>$ grep "net\.ipv4\.conf\.default\.send_redirects" /etc/sysctl.conf /etc/sysctl.d/*</strong><br/><strong>net.ipv4.conf.default.send_redirects= 0</strong></pre>
<p>The commands to be run begin with the <kbd><span><span>$</span></span></kbd> character, while the desired results are shown on the following line. We can already see that developing this into a shell script is going to take some work—we need to validate the output of the two <kbd>sysctl</kbd> commands, and then also check the configuration files to ensure that the parameters will persist across reboots and kernel parameter reloads.</p>
<p>We can check for the current kernel parameter setting quite easily using some shell code such as this:</p>
<pre>echo -n "Ensure net.ipv4.conf.all.send_redirects = 0... "<br/>OUTPUT=$(sysctl net.ipv4.conf.all.send_redirects | grep "net.ipv4.conf.all.send_redirects = 0" 2&gt; /dev/null)<br/>if [ "x$OUTPUT" == "x" ]; then<br/>    echo FAILED!<br/>  else<br/>    echo OK<br/>fi</pre>
<p>You will note that the code structure is almost identical to that which we used to check the <kbd>PermitRootLogin</kbd> parameter for SSH—hence, although the code to automate our auditing process is getting easier, it is also getting highly repetitious and inefficient. A similar block of code would then be used to check the value of the <kbd>net.ipv4.conf.default.send_redirects</kbd> parameter.</p>
<p>We can also check the persistent configuration of these parameters, again, by building the audit commands from the CIS Benchmark document into a conditional structure similar to what we did previously:</p>
<pre>echo -n "Ensure net.ipv4.conf.all.send_redirects = 0 in persistent configuration..."<br/>OUTPUT=$(grep -e "^net\.ipv4\.conf\.all\.send_redirects = 0" /etc/sysctl.conf /etc/sysctl.d/*)<br/>if [ "x$OUTPUT" == "x" ]; then<br/>    echo FAILED!<br/>  else<br/>    echo OK<br/>fi</pre>
<p>Once again, we would replicate this block for the <kbd>net.ipv4.conf.default.send_redirects</kbd> parameter. Thus, once again, we have successfully built up a script to audit this benchmark—running it on our system looks something like this:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/3f2098e0-5ec0-4253-837d-66769c2d0ffd.png" style="width:41.58em;height:10.75em;"/></p>
<p>That's 35 lines of shell script (albeit with a few comments at the top of the file), much of it repetitious, and all just to know that we have completely failed to meet this requirement! Once again, if we are to expand this example to resolve the issues, we need to expand our script.</p>
<p>Setting the active kernel parameters is quite easy—we just need to add a series of commands such as the following into the <kbd>FAILED!</kbd> branch of our first two <kbd>if</kbd> constructs:</p>
<pre>    echo "Attempting to modify active kernel parameters"<br/>    sudo sysctl -w net.ipv4.conf.all.send_redirects=0<br/>    sudo sysctl -w net.ipv4.route.flush=1</pre>
<p>We could add something similar for <kbd>net.ipv4.conf.default.send_redirects</kbd> in the appropriate place.</p>
<p>For our persistent parameters, however, things are a bit more tricky—we need to deal with the two possible configuration file scenarios as with the <kbd>PermitRootLogin</kbd> example, but now we have a configuration that is built up of a series of files and we must choose which file to modify if the parameter isn't present.</p>
<p>Thus, once again, we must build up a block of code to handle these two differing scenarios:</p>
<pre>    OPTPRESENT=$(grep -e "^net\.ipv4\.conf\.all\.send_redirects" /etc/sysctl.conf /etc/sysctl.d/*)<br/>    if [ "x$OPTPRESENT" == "x" ] ; then<br/>      echo "Line not present - attempting to append configuration"<br/>      echo "net.ipv4.conf.all.send_redirects = 0" | sudo tee -a /etc/sysctl.conf 1&gt;/dev/null<br/>    else<br/>      echo "Line present - attempting to modify"<br/>      sudo sed -i -r 's/^net\.ipv4\.conf\.all\.send_redirects.*/net.ipv4.conf.all.send_redirects = 0/g' /etc/sysctl.conf /etc/sysctl.d/*<br/>    fi</pre>
<p>That's a pretty ugly and difficult-to-read piece of code. What it does is as follows:</p>
<ol>
<li>It runs a second <kbd>grep</kbd> against the known configuration files to see whether the parameter is in there, regardless of its value.</li>
<li>If the parameter is not set, then we choose to append it to <kbd>/etc/sysctl.conf</kbd>.</li>
<li>If the parameter is set, we instead use <kbd>sed</kbd> to modify the parameter, forcing it to our desired value of <kbd>0</kbd>.</li>
</ol>
<p class="mce-root"/>
<p>Now when we run this script as before, we get the following:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/615e1ba1-da69-44f4-8663-071f9342850e.png" style="width:56.67em;height:33.50em;"/></p>
<p>As we can see, this works nicely; however, we are now up to 57 lines of shell code and much of it starting to get quite unreadable. All of this is for setting just two kernel parameters, and although we have now built up a fairly solid code base for taking the CIS Benchmarks (along with their recommended audit and remediation steps), it is not scaling at all well.</p>
<p>Further, these scripts are all being run locally in the preceding example—what if we wanted to run them from a central place? In the next section, we will take a look at exactly that.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Running CIS Benchmark scripts from a remote location</h1>
                </header>
            
            <article>
                
<p>The challenge with shell scripting is that, while it is easy to run on the machine where the scripts exist, it is a little more difficult to do on a remote machine. </p>
<p>The scripts we developed previously are designed to be run from an unprivileged account—thus, we have used <kbd>sudo</kbd> on the steps that specifically require root access to be run. This is fine when you have passwordless sudo access set up, but when a password is required for elevated access using <kbd>sudo</kbd>, this further complicates the task of running the scripts remotely.</p>
<p>Of course, the entire script could be run as root and, depending on your use case and security requirements, this may or may not be desirable. Let's take a look at the task of running our send redirect example on a remote system called <kbd>centos-testhost</kbd>. To achieve this, we need to do the following:</p>
<ol>
<li>SSH into the remote system and authenticate—this could be with a password or SSH keys that were set up previously.</li>
<li>Invoke the shell required to run the script we have developed—in our examples, this is <kbd>/bin/bash</kbd>.</li>
<li>We add the <kbd>-s</kbd> flag to the <kbd>bash</kbd> command—this causes the shell to read its command from the standard input (that is, the commands can be piped to it).</li>
<li>Finally, we pipe our script across to <kbd>bash</kbd>.</li>
</ol>
<p class="mce-root">There is one further caveat to this approach—in our script, we have boldly assumed that the commands we rely on (such as <kbd>sysctl</kbd>) exist within one of the directories defined in the PATH variable. It could be argued that this is flawed—however, it can also make script development easier, especially when building up scripts that might be used in a cross-platform environment.</p>
<p>For example, although we have been exclusively working with the RHEL 7 CIS Benchmark in this chapter, it is fair to assume that Ubuntu Server would also want to have SSH root logins disabled, and not send packet redirect information unless it is explicitly configured as a router. Hence, we might reasonably expect the scripts we have developed so far to work on both systems and save us some development effort.</p>
<p>However, on RHEL 7 (and CentOS 7), the <kbd>sysctl</kbd> command is found in <kbd>/usr/sbin/sysctl</kbd>, whereas on Ubuntu it is in <kbd>/sbin/sysctl</kbd>. This difference in itself could be handled by defining the path to <kbd>sysctl</kbd> in a variable at the top of the script, and then calling it via this—however, even so, it would mean modifying many scripts related to CIS hardening, like so:</p>
<pre># RHEL 7 systems<br/>SYSCTL=/usr/sbin/sysctl<br/>$SYSCTL -w net.ipv4.conf.all.send_redirects=0<br/><br/># Ubuntu systems<br/>SYSCTL=/sbin/sysctl<br/>$SYSCTL -w net.ipv4.conf.all.send_redirects=0</pre>
<p>In short, this is better than our original approach, but still highly manual and messy. Returning to the task of running our existing script remotely, putting all our requirements together, we might run it using the following command:</p>
<pre><strong>$ ssh centos-testhost 'PATH=$PATH:/usr/sbin /bin/bash -s' &lt; cis_v2.2.0_recommendation_3.1.2.sh</strong></pre>
<p>The preceding command assumes we are running the script as the current user on the local system—we could explicitly set the user by adding it before the hostname:</p>
<pre><strong>$ ssh james@centos-testhost 'PATH=$PATH:/usr/sbin /bin/bash -s' &lt; cis_v2.2.0_recommendation_3.1.2.sh</strong></pre>
<p>Running this against our remote system (including a second run to ensure the modifications took place effectively) will look something like this:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/987f3c66-8e88-4810-ae4e-d6cbd4dbe130.png" style="width:66.00em;height:42.50em;"/></p>
<p>We can see that this has been effective against our remote system and that no modification to our original script was required. All of this, while very effective, is somewhat inefficient and cumbersome, especially when compared to our experience with Ansible. In fact, it is fair to say that these examples demonstrate the value that Ansible brings to automating fundamental system administration tasks. To develop this, in the next chapter, we will look at how to build upon our foundation in CIS Benchmarks by developing Ansible playbooks to carry out the tasks required.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Summary</h1>
                </header>
            
            <article>
                
<p>In today's highly connected world, system security is paramount, and while Linux has long been regarded as a secure operating system, there is much that can be done to enhance its security. CIS Benchmarks provided one such standardized approach by bringing together a consensus on security best practices from across the technology industry. CIS Benchmarks, however, are extensive and, if applied by hand, would take many hours for an engineer to implement on a single system. Thus, automating their deployment is of vital importance.</p>
<p>In this chapter, you have learned about <span>CIS Benchmarks, what they are for, and the benefits they bring. You then learned about the </span><span>balance between security and application support, and how to make </span><span>informed decisions when applying a server hardening policy. You also learned how to m</span><span>ake use of shell scripts to apply some example security policies on a Linux server.</span></p>
<p>In the next chapter, we will develop this concept further by demonstrating effective methods for automating the deployment of CIS Benchmark recommendations using Ansible.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Questions</h1>
                </header>
            
            <article>
                
<ol>
<li>Why are CIS Benchmarks relevant to securing Linux servers?</li>
<li>If you secure Ubuntu Server with the appropriate benchmark and then install nginx on that server, does that also need hardening?</li>
<li>What is the difference between a level 1 and a level 2 benchmark?</li>
<li>Why are some benchmarks scored and others not?</li>
<li>How can you check using a shell script that a given audit requirement has been met?</li>
</ol>
<ol start="6">
<li>State three possible issues relating to automated modification of configuration files using a shell script.</li>
<li>Why do shell scripts not scale well for the automated rollout of CIS Benchmarks?</li>
<li>How can you run a CIS Benchmark shell script on a remote server using SSH?</li>
<li>Why would you want to make use of a variable to specify the path to a binary used to implement a CIS recommendation?</li>
<li>Why might you use sudo for individual commands within a script rather than needing the whole script to run as root?</li>
</ol>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Further reading</h1>
                </header>
            
            <article>
                
<ul>
<li>To review common questions about the CIS Benchmarks, please refer to <a href="https://www.cisecurity.org/cis-benchmarks/cis-benchmarks-faq/">https://www.cisecurity.org/cis-benchmarks/cis-benchmarks-faq/</a><span>.</span></li>
<li>A full list of CIS Benchmarks is available at <a href="https://www.cisecurity.org/cis-benchmarks/">https://www.cisecurity.org/cis-benchmarks/</a><span>.</span></li>
<li>For a greater understanding of Linux shell scripting, please refer to <em>Mastering Linux Shell Scripting, Second Edition, Andrew Mallett</em> and <em>Mokhtar Ebrahim</em> (<a href="https://www.packtpub.com/gb/virtualization-and-cloud/mastering-linux-shell-scripting-second-edition">https://www.packtpub.com/gb/virtualization-and-cloud/mastering-linux-shell-scripting-second-edition</a>).</li>
<li>To understand more about SELinux and how to create your own policies, please refer to <em>SELinux System Administration, Second Edition, Sven Vermeulen</em> (<a href="https://www.packtpub.com/gb/networking-and-servers/selinux-system-administration-second-edition">https://www.packtpub.com/gb/networking-and-servers/selinux-system-administration-second-edition</a>).</li>
</ul>


            </article>

            
        </section>
    </body></html>