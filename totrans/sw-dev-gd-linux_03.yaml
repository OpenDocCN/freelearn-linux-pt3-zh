- en: '3'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Service Management with systemd
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In the previous chapter, you learned about how processes work in Linux. Now
    it’s time to look at how these processes are wrapped in an additional layer of
    abstraction: the *systemd service*.'
  prefs: []
  type: TYPE_NORMAL
- en: The commands you’ve seen so far – `ls`, `mv`, `rm`, `ps`, and others – run in
    the foreground, attached to your shell session. You run them, the programs do
    their job, and then they exit. However, not all programs run like this.
  prefs: []
  type: TYPE_NORMAL
- en: Services, also frequently called daemons, are long-running processes that run
    in the background. These can be things like databases and web servers, but also
    regular system services like your network manager, your desktop environment, and
    so on. These long-running background services are typically started and controlled
    via an **init** system such as **systemd**.
  prefs: []
  type: TYPE_NORMAL
- en: '**init** here refers to the first process your operating system kernel starts,
    and it is the job of this process to take care of starting any other processes.'
  prefs: []
  type: TYPE_NORMAL
- en: '**systemd** services are controlled using a command line utility called `systemctl`.
    It will be used for starting and stopping services, for example, to restart a
    service that’s misbehaving or to reload one whose configuration has changed.'
  prefs: []
  type: TYPE_NORMAL
- en: If you’re bouncing around the book and haven’t read the previous chapter yet,
    you can still get value out of this one. For now, just think of a process as any
    running command, application, or service. When you’re ready to learn about how
    processes work in more detail, you can read *Chapter 2*, *Working with Processes*.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, you’ll learn all about:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The command you’ll use to interact with `systemd` services: `systemctl`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A slightly deeper dive into what an init system does, and how `systemd` specifically
    fills this role
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Managing services with `systemctl`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A few tips for working in container environments (like Docker containers), which
    usually don’t have the kind of robust service management layer we describe in
    this chapter
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Note**'
  prefs: []
  type: TYPE_NORMAL
- en: This chapter applies to Linux only – macOS and Windows (and even other Unixes)
    manage processes using different tools. In fact, different Linux distributions
    use different tools, however, `systemd` is the most widely used one. While the
    concepts are similar, knowing how modern Linux environments manage services is
    most useful for developers.
  prefs: []
  type: TYPE_NORMAL
- en: The basics
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Linux services are background processes that run on a Linux system to perform
    specific tasks. They are similar to Windows services or daemons on macOS.
  prefs: []
  type: TYPE_NORMAL
- en: 'Most non-containerized Linux environments use `systemd` to manage services.
    The two tools you’ll use to interact with `systemd` are:'
  prefs: []
  type: TYPE_NORMAL
- en: '`systemctl`: Controls services (called ‘units’ in `systemd` nomenclature)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`journalctl`: Lets you work with system logs'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We’ll cover `systemctl` in this chapter, and `journalctl` in *Chapter 16*, *Monitoring
    Application Logs*, later in the book.
  prefs: []
  type: TYPE_NORMAL
- en: '`systemd` is a system and service manager for Linux that provides a standard
    way to manage services. It is now widely used as the default init system for most
    Linux distributions. Many Linux distributions previously made use of the SysV
    init systems, which come from Unix and are still used by many modern Unix operating
    systems. Others, such as Alpine and Gentoo Linux, use OpenRC as their init systems.
    There are many more init systems out there, however, the overwhelming majority
    of Linux distributions now use `systemd`. With `systemd`, services can be started,
    stopped, restarted, enabled (set to start at boot), and disabled, and their status
    can be checked. Services are defined by a *unit file*, which specifies exactly
    how the service should be managed by systemd.'
  prefs: []
  type: TYPE_NORMAL
- en: 'To manage services with `systemd`, you can use the following basic commands
    (we’ll dive into each one later in this chapter):'
  prefs: []
  type: TYPE_NORMAL
- en: '`systemctl start <service>`: starts a service.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`systemctl stop <service>`: stops a service.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`systemctl restart <service>`: restarts a service.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`systemctl status <service>`: displays the current status of a service.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Remember that only users with root privileges (e.g., using `sudo`) can manage
    system services with `systemd`.
  prefs: []
  type: TYPE_NORMAL
- en: init
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let’s take a quick detour to define a common term that you’ll see used often.
    In Linux, `init` – short for ‘initialization’ – is the first process that is started
    when the system boots up. Unsurprisingly, you can find it at PID 1\. init is responsible
    for managing the boot process and starting all other processes and services that
    have been configured to run on the system. It also re-parents orphaned processes
    (processes whose original parent process has died) and keeps them as its own children,
    to ensure they still behave normally.
  prefs: []
  type: TYPE_NORMAL
- en: Like almost everything in the Linux world, there are several different, mutually
    exclusive programs that can fill this role. They are all referred to as *init
    systems*, which is the general name for any software that can fill this important
    bootstrapping, initializing, and coordinating role. As mentioned previously, there
    are several init systems available for Linux, including **System V init** (**SysV**),
    OpenRC, and `systemd`. Most modern Linux systems have switched to systemd, which
    is why that’s the one we’re covering here.
  prefs: []
  type: TYPE_NORMAL
- en: Which init system you’re using will determine how services are defined and managed,
    so keep in mind that everything you see here applies only to systemd.
  prefs: []
  type: TYPE_NORMAL
- en: Processes and services
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let’s talk about the subtle difference between processes and services. You can
    think of a service as some packaging around a piece of software that makes it
    easier to manage as a running process.
  prefs: []
  type: TYPE_NORMAL
- en: A service adds convenient features to how a program (and the resulting process
    spawned by that program) is handled by the system. For example, it lets you define
    dependencies between different processes, control startup order, add environment
    variables for the process to start with, limit resource usage, control permissions,
    and many other useful things. To tie a bow around the whole package, a service
    provides a simple name to reference your program. We’ll show you how to create
    your own service in the later *Chapter 10*, *Configuring Software*.
  prefs: []
  type: TYPE_NORMAL
- en: In the rest of this chapter, we’ll stick to managing existing services.
  prefs: []
  type: TYPE_NORMAL
- en: systemctl commands
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`systemctl` is the tool you’ll use to manage the services that have been defined
    on your system. These examples will use the `foobar` service, which doesn’t really
    exist, as a stand-in for whatever service you might be managing.'
  prefs: []
  type: TYPE_NORMAL
- en: Checking the status of a service
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`systemctl status <service>` checks the status of the service. You’ll get an
    assortment of data that’s useful for all kinds of troubleshooting tasks. This
    is what the output for the nginx web server’s service looks like:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B19251_03_01.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 3.1: nginx web server service output'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s dissect the information that’s displayed in the dense output that this
    command produces, line by line:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Service name**: The name of the service as defined in its unit file.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Load state**: Whether the service unit file has been successfully loaded
    and is ready to be started.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Active state**: The current state of the service – whether it is running,
    inactive, or failed – and how long it’s been that way.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Docs**: The main page where you can find relevant documentation if it’s been
    installed.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Main PID and child processes:** The **process ID** (**PID**) of the main
    process associated with the service, with additional entries for any child processes
    that have been launched.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Resource usage**: RAM (memory) and CPU time.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**CGroup**: Details about the control group to which this process belongs.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Log preview**: A few loglines from the service’s output, to give you an idea
    of what’s happening.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This information provides a detailed overview of the service and its status
    and can be useful for debugging issues or checking the health of the service.
  prefs: []
  type: TYPE_NORMAL
- en: If the service has failed, the output will usually provide details on why it
    failed, such as the exit code or a description of the error.
  prefs: []
  type: TYPE_NORMAL
- en: Starting a service
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: This starts the service. If the service was already running, this command would
    have no effect.
  prefs: []
  type: TYPE_NORMAL
- en: Stopping a service
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: This stops the service. If the service wasn’t running, then it should have no
    effect.
  prefs: []
  type: TYPE_NORMAL
- en: Restarting a service
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'This stops and then starts a service. It is equivalent to running:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: '**Note**'
  prefs: []
  type: TYPE_NORMAL
- en: 'Be careful with this command: if a service’s configuration file has changed
    on disk since it was started, and that config file has a bug that prevents the
    program from successfully starting, then `restart` will happily stop your running
    service and then fail to start it again.'
  prefs: []
  type: TYPE_NORMAL
- en: This logical but potentially undesirable behavior has bitten many developers
    over the years, so take care to ensure that your service’s configuration is still
    valid before restarting.
  prefs: []
  type: TYPE_NORMAL
- en: 'Many popular programs have built-in configuration validation, e.g., for `nginx`,
    you can run:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: to test the configuration on disk.
  prefs: []
  type: TYPE_NORMAL
- en: Reloading a service
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Not all services support this subcommand – it’s up to the person creating the
    service configuration to implement it. If a service does have a `reload` option,
    it is generally safer than `restart`.
  prefs: []
  type: TYPE_NORMAL
- en: '`U`sually, a `reload`:'
  prefs: []
  type: TYPE_NORMAL
- en: re-checks the configuration on disk to ensure that it’s valid
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: re-reads the configuration into memory without interrupting the running process,
    if possible
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: restarts the process only after validating the config and making sure the process
    will start successfully after being stopped
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Like so many things in Linux, this is a convention rather than a strictly enforced
    requirement, so you may run into software that:'
  prefs: []
  type: TYPE_NORMAL
- en: doesn’t implement a `reload` subcommand
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: doesn’t implement some of the safety features discussed above (config validation,
    etc.)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: does something else with a `reload`, because the developer or packager thought
    it was a good idea
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In general, when updating the configuration file for an application, especially
    in production environments, you should prefer `reload` over `restart`.
  prefs: []
  type: TYPE_NORMAL
- en: Enable and disable
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`systemctl enable foobar` – configures `foobar` to start automatically on boot.
    `systemctl disable foobar` – if `foobar` is configured to start automatically,
    gets rid of that configuration and turns foobar into a manually managed service.'
  prefs: []
  type: TYPE_NORMAL
- en: The key difference here is that while `start` and `stop` have an immediate effect
    – they ensure that a service is running (or stopped) *right now*; `enable` and
    `disable` are about future system startups. However, they have no effect on that
    service’s ‘running’ status at the time you run the command.
  prefs: []
  type: TYPE_NORMAL
- en: 'One common mistake that developers make is to assume that `enable` will start
    a service. It won’t. If you want to start an `nginx` web server now and ensure
    that it automatically starts every time the VM is rebooted, you need to run two
    commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Because of this, `enable` and `disable` come with an optional flag that also
    starts (or stops, in the case of `disable`) the service. This command is equivalent
    to the two commands above:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: A note on Docker
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: While `systemctl` is a common tool for managing services on traditional Linux
    systems, it is generally not used in Docker containers due to containers’ isolated
    and self-contained nature.
  prefs: []
  type: TYPE_NORMAL
- en: Docker containers ideally run a single process and therefore don’t require a
    complex boot phase or process management. The container, in essence, *is* the
    process and doesn’t have access to the host system’s init system (including `systemd`).
  prefs: []
  type: TYPE_NORMAL
- en: Although it’s possible to have access to these commands in a Docker container,
    it’s usually undesirable to use any kind of service-management system inside of
    them.
  prefs: []
  type: TYPE_NORMAL
- en: Docker containers ideally contain a single application and launch a single process
    when they start. For this, no service management is needed – the running container
    is your service package, and your Docker container essentially *is* your process.
  prefs: []
  type: TYPE_NORMAL
- en: 'We don’t recommend a Docker setup that includes multiple processes or significant
    internal service management, so we won’t get into it here: much like families,
    all happy Docker images are alike in the same way, while each unhappy Docker configuration
    is unhappy in its own way.'
  prefs: []
  type: TYPE_NORMAL
- en: Conclusion
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, you learned how services are managed in Linux, and we introduced
    the practical commands you’ll use to control them. We gave you the theory you’ll
    need to make sense of all the terminology you’ll come across on a live system:
    what init is, what systemd does on Linux systems, and which commands you need
    to interact with it.'
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we’ll show you some useful tricks for interacting with
    your shell and your command history, so you can save time and look like a Unix
    wizard from your favorite movie (it will also make you faster and more efficient
    at your day job, but putting it that way just doesn’t make it sound as fun).
  prefs: []
  type: TYPE_NORMAL
- en: Learn more on Discord
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To join the Discord community for this book – where you can share feedback,
    ask questions to the author, and learn about new releases – follow the QR code
    below:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://packt.link/SecNet](https://packt.link/SecNet)'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/QR_Code1768422420210094187.png)'
  prefs: []
  type: TYPE_IMG
