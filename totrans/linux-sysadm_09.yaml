- en: '9'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Network Configuration and Debugging
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: All modern systems are networked, so network configuration and troubleshooting
    are fundamental skills for every systems administrator. In this chapter, we will
    learn how the Linux network stack works and how to use the tools for working on
    it—both universal and distribution-specific.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Linux network stack
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Network interfaces and addresses in Linux
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Routes and neighbor tables
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: NetworkManager
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Distribution-specific configuration methods
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Network troubleshooting
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Linux network stack
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To end users who only interact with the network through applications and only
    configure network access through a graphical user interface, the network stack
    of their operating system looks like a single abstraction. However, for administrators,
    it is important to understand its structure because different parts of the stack
    are implemented by different software and administered by different tools.
  prefs: []
  type: TYPE_NORMAL
- en: This contrasts Linux distributions with many proprietary operating systems where
    most network functions are built-in and cannot be replaced individually. In a
    Linux distribution, performance-critical functionality is implemented by the Linux
    kernel itself, but many other functions, such as the dynamic configuration of
    IP addresses and routes through **Dynamic Host Configuration Protocol** (**DHCP**),
    are done by third-party tools, and there can be multiple competing implementations.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are also different tools for managing the network functionality of the
    Linux kernel. The kernel allows userspace processes to retrieve and change its
    network configuration via *Netlink* protocol sockets and, technically, anyone
    can write a tool for managing IP addresses and routes. In practice, there are
    two suites of network administration tools: the legacy tools (`ifconfig`, `vconfig`,
    `route`, `brctl`, and so on), which are only kept for compatibility and do not
    support many new features of the kernel network stack, and the modern `iproute2`
    toolkit, which provides access to all kernel functionality via `ip` and `tc` utilities.'
  prefs: []
  type: TYPE_NORMAL
- en: Sometimes, more than one implementation of the same or similar functionality
    may exist in the kernel as well. One prominent example is the Netfilter firewall
    subsystem, which currently includes the older `iptables` framework and the newer
    `nftables` implementation.
  prefs: []
  type: TYPE_NORMAL
- en: Different implementations of userspace tools may also be either legacy implementations
    that are being gradually replaced with newer alternatives, or there can also be
    multiple alternative implementations with different design goals. For example,
    in 2022, the ISC DHCP server was declared unsupported by its maintainers who went
    on to work on the newer Kea project. However, Kea is not the only alternative
    to the ISC DHCP server. Some people may want to switch to other projects instead.
    For example, small networks can benefit from `dnsmasq`, which combines a DHCP
    server with DNS forwarding and other functions, which is especially useful for
    running it on small office routers with limited hardware resources.
  prefs: []
  type: TYPE_NORMAL
- en: 'Some of the most commonly used Linux network functionality backends and management
    tools are summarized in the following table:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Component** | **Implementation(s)** | **Tools** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| Ethernet | Linux kernel | Network card settings tweaking: `ethtool`MAC address
    settings, VLANs: `iproute2` (modern); `vconfig` (legacy) |'
  prefs: []
  type: TYPE_TB
- en: '| Wi-Fi (framing and forwarding) | Linux kernel | `iw` |'
  prefs: []
  type: TYPE_TB
- en: '| Wi-Fi (authentication and access point functionality) | `hostapd` |'
  prefs: []
  type: TYPE_TB
- en: '| IPv4 and IPv6 routing | Linux kernel | `iproute2` (modern)`ifconfig`, `route`,
    etc. (legacy) |'
  prefs: []
  type: TYPE_TB
- en: '| Bridging (software switch) | Linux kernel | `iproute2` (modern);`brctl` (legacy)
    |'
  prefs: []
  type: TYPE_TB
- en: '| QoS and traffic shaping | Linux kernel | `tc` (part of `iproute2`) |'
  prefs: []
  type: TYPE_TB
- en: '| IPsec (packet encryption and checksum calculation) | Linux kernel | `iproute2`
    |'
  prefs: []
  type: TYPE_TB
- en: '| IPsec (IKE session management) | strongSwan, Openswan, Raccoon (legacy)...
    |'
  prefs: []
  type: TYPE_TB
- en: '| DHCP client | ISC DHCP, `dhcpcd` |'
  prefs: []
  type: TYPE_TB
- en: '| DHCP server | ISC DHCP, ISC Kea, `dnsmasq` |'
  prefs: []
  type: TYPE_TB
- en: Table 9.1 – Linux network stack components
  prefs: []
  type: TYPE_NORMAL
- en: Finally, there are high-level management tools such as NetworkManager that tie
    multiple tools and components under a single user interface. Let’s learn about
    the kernel parts of the network stack and how to manage them with `iproute2` first.
    Then, we will see how to simplify and automate that with high-level tools in different
    distributions.
  prefs: []
  type: TYPE_NORMAL
- en: Network interfaces and addresses in Linux
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '*Network interface* is a generic term for physical and virtual network links
    that can carry addresses. The correspondence between physical network cards and
    network interfaces as the kernel sees them is not one-to-one. A network card with
    four ports is a single PCI device, but every one of its ports is seen as a separate
    link by the kernel.'
  prefs: []
  type: TYPE_NORMAL
- en: There are also virtual links. Some virtual links are tied to physical network
    ports, but other types are fully independent. For example, MACVLAN links allow
    administrators to send traffic from certain IP addresses using a different MAC
    address. Since an Ethernet interface by definition cannot have multiple MAC addresses,
    Linux solves that problem by creating virtual interfaces on top of a physical
    Ethernet port and assigning different MAC and IP addresses to it. Multiplexing
    Ethernet traffic using 802.1Q VLAN or 802.3ad QinQ (nested VLAN) is also done
    by creating a virtual link that is bound to a specific underlying link.
  prefs: []
  type: TYPE_NORMAL
- en: 'However, interfaces for tunneling protocols such as IPIP and GRE are not tied
    to any underlying links. They require tunnel endpoint addresses, but those addresses
    can belong to any interface. There are also dummy interfaces that are used either
    for local process communication or for assigning addresses that must be reachable
    through any physical interface:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Link type** | **Relationship with** **physical devices** |'
  prefs: []
  type: TYPE_TB
- en: '| Ethernet, Wi-Fi | Associated with physical cards or ports on those cards
    |'
  prefs: []
  type: TYPE_TB
- en: '| 802.1Q VLAN, 802.3ad QinQ, MACVLAN | Tied to a single physical link |'
  prefs: []
  type: TYPE_TB
- en: '| IPIP, GRE, dummy | Purely virtual |'
  prefs: []
  type: TYPE_TB
- en: Table 9.2 – Network link types and their relationships with physical devices
  prefs: []
  type: TYPE_NORMAL
- en: In the following sections, we will learn how to retrieve information about network
    interfaces and configure them.
  prefs: []
  type: TYPE_NORMAL
- en: Discovering physical network devices
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Discovering all physical network devices in a Linux system can be a challenging
    task. They can be connected to different buses, including PCI and USB, and those
    buses use different device class identifiers.
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider the following PCI device listing from a laptop:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Network devices are easy to identify visually here. There is a Wi-Fi controller
    (00:14.3) and an Ethernet card (03:00.0). Automatically filtering out everything
    but network devices from that listing is a bit trickier. We can use the fact that
    the PCI class for network devices is `02xx`, and there is a way to include device
    class numbers in the output with `lspci -nn`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Given that, to see all network devices you will need to look in both PCI and
    USB device listings, it is better to use high-level third-party tools such as
    `lshw`. With the `lshw -class` command you can view all available network devices
    in one step: both wired and wireless, connected to any buses. It also shows a
    lot of additional information about devices:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, the `lshw` output also includes logical interface names rather
    than just bus addresses. Every network interface in Linux has a unique name, but
    their names are not completely determined by their hardware type and bus port.
    Let us examine the issue of interface naming in more detail.
  prefs: []
  type: TYPE_NORMAL
- en: Network interface names
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The Linux kernel does not ascribe any special significance to network interface
    names. In some operating systems, interface names are completely determined by
    the kernel so that the first Ethernet device might always be named Ethernet0,
    and there is no way for an administrator to change that. In Linux, that is not
    the case, and names can be arbitrary. In fact, most distributions include a userspace
    helper for renaming network interfaces at boot time according to a default policy
    or custom configuration. Formerly, the most common helper was `udev`. Now, it
    is usually `systemd-udevd`.
  prefs: []
  type: TYPE_NORMAL
- en: Historically, Ethernet devices were named `ethX` by default, as per the kernel’s
    built-in naming scheme. By the 2020s, most distributions switched to systemd for
    service management and adopted its **predictable network interface names** scheme
    as their default option.
  prefs: []
  type: TYPE_NORMAL
- en: The issue with the original naming scheme is that the kernel’s device probing
    is not deterministic, so in some situations, especially when new network cards
    were added or old cards were removed, old names could be assigned to different
    physical devices (for example, a card formerly named `eth2` would become `eth1`).
    On the other hand, if a machine had a single network interface, it was guaranteed
    to be named `eth0`.
  prefs: []
  type: TYPE_NORMAL
- en: The naming scheme of systemd is predictable in the sense that network interface
    names are guaranteed to stay the same across reboot and hardware changes. The
    price for that is that users and scriptwriters cannot make any assumptions about
    names. Even if a machine only has a single network card, it can be named, for
    example, `eno1` (Ethernet network, onboard, number 1) or `enp3s0` (Ethernet network,
    PCI, slot 3:0).
  prefs: []
  type: TYPE_NORMAL
- en: 'It is possible to switch to the original naming scheme, either by adding `net.ifnames=0`
    to the kernel command line in the GRUB configuration, or by executing the following
    command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: It is also possible to permanently assign custom names to certain network interfaces
    by creating systemd link files.
  prefs: []
  type: TYPE_NORMAL
- en: Using the ip command
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In modern Linux distributions, all network discovery and setup are done either
    with utilities from the `iproute2` package or with high-level tools such as NetworkManager.
    We will omit the legacy tools such as `ifconfig` and focus on the `ip` utility
    from `iproute2`.
  prefs: []
  type: TYPE_NORMAL
- en: Even though that utility is named `ip`, its functionality is much broader, and
    it provides an interface to all features of the kernel network stack that are
    related to network interfaces, addresses, and routing.
  prefs: []
  type: TYPE_NORMAL
- en: One thing to note is that in some distributions such as Fedora, that utility
    may be installed in `/sbin` or `/usr/sbin—d`irectories meant for administrative
    tools and often absent from the `$PATH` environment variable in shell configurations
    for unprivileged users. Thus, attempts to execute it from an unprivileged shell
    will result in a command not found error even though `iproute2` is installed.
    In that case, you may want to either add `/sbin` to your `$PATH` or always run
    `sudo ip` instead. Commands that change network settings indeed require administrative
    privileges but commands for viewing them usually do not.
  prefs: []
  type: TYPE_NORMAL
- en: Note that changes you make with `ip` only remain active until the next reboot
    and permanent changes must be made in distribution-specific configuration files
    instead or added to a script executed at boot time. If you are experimenting on
    a desktop or a laptop computer with NetworkManager running, then it may also override
    your changes on, for example, Wi-Fi reconnects.
  prefs: []
  type: TYPE_NORMAL
- en: Discovering and inspecting logical links
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To view all network interfaces, both physical and virtual, you can run `ip
    link list` or simply `ip link`. Note that `ip` allows abbreviating subcommands
    and options, so you can also write `ip li li`, but we will use full forms throughout
    the chapter for better readability:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: In this output from a VM, we see the loopback device (`lo`) and a single Ethernet
    card named according to the systemd predictable network interface naming convention
    (`ens192`).
  prefs: []
  type: TYPE_NORMAL
- en: 'The loopback device is present in every Linux system. Its role is to enable
    communication between local processes over IP and it carries addresses designated
    for that use: `127.0.0.1/8` for IPv4 and `::1/128` for IPv6.'
  prefs: []
  type: TYPE_NORMAL
- en: The output for the `ens192` Ethernet device has more data. In the `link/ether`
    field, you can see its MAC address (`00:50:56:91:a2:b6`).
  prefs: []
  type: TYPE_NORMAL
- en: 'You may also notice seemingly redundant `<...UP,LOWER_UP>` and `state UP` bits
    in the output. They refer to different facts about that network interface: `UP`
    inside the angle brackets tells us that the link is not intentionally disabled
    by the administrator, while `state UP` refers to the actual state (whether it
    is connected to any other network device or not—with a physical cable or a virtual
    link, in the case of VMs).'
  prefs: []
  type: TYPE_NORMAL
- en: 'To illustrate the distinction, let us examine a physical network on another
    machine that is not connected to anything. To view information about a single
    link, you can use `ip link` `show <name>`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, in the angle brackets its state is `UP`, but `state DOWN` tells
    us that it is not active, and `NO-CARRIER` explains why—it is disconnected (an
    Ethernet link can also be down despite being connected to something, for example,
    due to a settings mismatch with the other side).
  prefs: []
  type: TYPE_NORMAL
- en: 'Now let’s disable a link to see what an intentionally disabled link looks like.
    You can do it with `sudo ip link set dev <``name> down`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: You can see that when the link was taken down, the `UP` token disappeared from
    the part inside the angle brackets, and also its `state` field changed to `DOWN`.
  prefs: []
  type: TYPE_NORMAL
- en: Viewing and changing Ethernet link MAC addresses
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Every Ethernet and Wi-Fi card has a globally unique, burnt-in MAC address. To
    make sure that no two network devices will ever conflict if they are connected
    to the same network, manufacturers request blocks of MAC addresses and keep track
    of every MAC address they assign to their hardware products so that no address
    is ever assigned twice.
  prefs: []
  type: TYPE_NORMAL
- en: 'However, end users may have reasons to assign their own MAC address to a network
    interface. For example, many internet service providers register the first MAC
    address of the subscriber’s router port and then require all future connection
    attempts to use the same address. If the user replaces or upgrades the router
    (or a network card in it), it is often easier to just assign the original port’s
    MAC address than ask the ISP support to update their records. You can change the
    MAC address (until the next reboot) with `ip link set dev <name>` `address <MAC>`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Note that `ip link show` displays the new, manually assigned MAC address now
    (`de:ad:be:ef:ca:fe`).
  prefs: []
  type: TYPE_NORMAL
- en: 'While `ip` only shows the MAC address that the kernel uses for sending Ethernet
    frames, it’s possible to retrieve the default, burnt-in address with `ethtool`
    instead. You can use either `ethtool --show-permaddr` or its short version, `ethtool
    -P`, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: It is useful to know how to change MAC addresses even though it is not a very
    common task. Next, we will learn how to manage IP addresses.
  prefs: []
  type: TYPE_NORMAL
- en: Viewing and changing IP addresses
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Commands for viewing and changing IP addresses are similar to those for links
    and MAC addresses but use the `address` command family instead of `link`. To view
    addresses on all links, you can run `ip address show`, just `ip address`, or an
    abbreviated version—i`p a`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: You can also limit the output to just one interface, such as in `ip address`
    `show lo`.
  prefs: []
  type: TYPE_NORMAL
- en: The output of `ip address show` includes MAC addresses for Ethernet and other
    data link layer interfaces, so often, you can use that command instead of `ip
    link list`, unless you specifically want to exclude IP addresses from the output.
  prefs: []
  type: TYPE_NORMAL
- en: 'It is possible to show only IPv4 or only IPv6 addresses with the `-4` and `-6`
    options. We can demonstrate it on the loopback interface (`lo`) since it is guaranteed
    to have both IPv4 and IPv6 addresses (unless IPv6 is disabled explicitly):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Now let’s see how to add and remove addresses. For safe experiments that knowingly
    will not affect any network interface used for real traffic, we will create a
    dummy interface. Dummy interfaces are conceptually similar to the loopback interface.
    However, there can be multiple dummy interfaces in the same system, while there
    can only be one loopback (this situation is unique to Linux; many other operating
    systems allow multiple loopback interfaces instead of using a different interface
    type):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: All virtual interfaces are created in the `DOWN` state in Linux, so we brought
    the `dummy1` link up by hand. Now it is ready for experiments with addresses.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can assign an address with `ip address add <addr> dev <name>`. Just as
    with MAC addresses, such changes will not survive reboots, so this method is only
    good for experiments and troubleshooting sessions. We will use addresses from
    `192.0.2.0/24—a` network reserved for examples and documentation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Note that executing `ip address add` for the second time with a different address
    will not replace the old address but rather add a second address. There is no
    limit on the number of addresses on a single network interface in Linux; you can
    assign as many as you want. If you want to replace an address, you can add the
    new one first and then remove the old one. Let’s see how we can replace `192.0.2.1`
    with `192.0.2.2`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: It is also possible to remove all addresses from a network interface at once
    using `sudo ip address flush` `dev <name>`.
  prefs: []
  type: TYPE_NORMAL
- en: Most of the time, you will configure IP addresses using high-level configuration
    tools that we will discuss later in this chapter. However, knowing those commands
    can help you verify address configuration and change network interface addresses
    temporarily during troubleshooting sessions or emergency configuration changes.
  prefs: []
  type: TYPE_NORMAL
- en: Routes and neighbor tables
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To be able to communicate with other hosts over the network, it’s not enough
    for a host to have an address. It also needs to know how to reach other hosts.
    Modern networks use layered protocol stacks, and the Linux kernel is responsible
    for the **Data Link** and **Network** layers according to the OSI model.
  prefs: []
  type: TYPE_NORMAL
- en: At the data link layer, there are protocols such as Ethernet and Wi-Fi — both
    are multiple-access broadcast networks and require dynamic discovery of neighbors
    in the same network segment. At the data link layer, hosts are identified by their
    MAC addresses. Direct communication at the data link layer is only possible within
    the same segment. If a network layer protocol packet encapsulated in a data link
    layer protocol frame must travel further, it’s extracted from the original frame
    and encapsulated in a new one.
  prefs: []
  type: TYPE_NORMAL
- en: Above the data link layer are network layer protocols—IPv4 and IPv6\. IP packets
    can be sent either to hosts in the same data link layer segment or routed to other
    networks and may traverse many data link layer connections on their way to their
    destination.
  prefs: []
  type: TYPE_NORMAL
- en: However, to be able to send an IP packet to another host or a router, the kernel
    needs to build an association between the IP addresses of those machines and their
    MAC addresses and maintain tables of such associations.
  prefs: []
  type: TYPE_NORMAL
- en: ARP and NDP neighbor tables
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: IPv4 and IPv6 protocols share many similarities but use different neighbor discovery
    mechanisms. The older IPv4 protocol uses **Address Resolution Protocol** (**ARP**)
    to determine the MAC addresses of hosts with given IP addresses. ARP was not designed
    to be extensible, and the switch from 32-bit addresses in IPv4 to 128-bit ones
    in IPv6 required the development of a new protocol, so its designers used it as
    a chance to revise many old assumptions and add many new features. The result
    was named **Neighbor Discovery Protocol** (**NDP**), and, unlike ARP, it allows
    hosts to discover routers and dynamically configure public addresses, and detect
    address conflicts.
  prefs: []
  type: TYPE_NORMAL
- en: 'To view the ARP table, you can run `ip -4 neighbor show`. You can also shorten
    it to just `ip -4 neighbor` or `ip -4 neigh`. Note that those commands also support
    the British spelling (`neighbour`) if you prefer to use it. If you omit `-4` or
    `-6`, that command will show entries for both protocols, so if your system does
    not have IPv6 configured or if you do not want to filter, you can omit `-4`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: It is also possible to filter the output and only show entries for one network
    interface, for example, with `ip -4 neighbor show` `dev eth1`.
  prefs: []
  type: TYPE_NORMAL
- en: The field for MAC addresses is called the **Link-Layer Address** (**lladdr**).
    The reason is that the neighbor table output format is the same for multiple data
    link layer protocols that may not name their link-layer addresses MAC addresses.
    There are also situations when the link-layer address for an IPv4 host is itself
    an IPv4 address—that’s how multipoint GRE tunnels work, for example (it’s part
    of the dynamic multipoint VPN technology that also includes IPsec for encryption
    and the next-hop resolution protocol for neighbor discovery).
  prefs: []
  type: TYPE_NORMAL
- en: 'Every association is a triple rather than a pair: MAC address, IPv4 address,
    and network interface. Every Ethernet interface belongs to its own data link layer
    segment, so to send an IP packet correctly, the system needs to know which network
    card to send it from. MAC addresses must only be unique within the same segment.'
  prefs: []
  type: TYPE_NORMAL
- en: 'It is possible to only show entries with a specific state. For example, this
    is how to view only address associations that have been recently discovered or
    confirmed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Stale entries eventually disappear from the table. When an IP address is moved
    to a machine with a different MAC address, the kernel will also eventually discover
    it. But if waiting is not an option and an IP address must be moved with minimum
    downtime, you can manually remove an entry and force a new ARP request as soon
    as traffic to that IP address is seen. The command to remove an entry for a specific
    IP address is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'There is also a command that removes all entries for a specific network interface:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Even though the inner workings of the ARP and NDP protocols are different, all
    commands we discussed are applicable to both IPv4 and IPv6 neighbor tables.
  prefs: []
  type: TYPE_NORMAL
- en: Routes and route tables
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'IPv4 and IPv6 are routed protocols, which allows them to be used in large-scale
    networks that consist of multiple independent segments, such as the internet.
    An Ethernet network segment is flat and there are no mechanisms for grouping MAC
    addresses: if there are a hundred hosts in a network, the switch must maintain
    a MAC address table of hundred entries, and every host needs to keep the MAC address
    of every host it needs to communicate with in its table. That approach puts obvious
    limits on the maximum network size. It also makes it impossible to have multiple
    paths to the same part of the network, since all hosts in a data link layer segment
    must communicate directly.'
  prefs: []
  type: TYPE_NORMAL
- en: By contrast, IP networks are broken into subnets that are connected to one another
    through routers—devices dedicated to forwarding packets between hosts (many routers,
    both home/small office and enterprise/service provider ones, are running Linux
    these days). The most important property of the IP addressing architecture is
    that subnets can be aggregated. For example, if a network internally consists
    of two consecutive subnets that contain 32 hosts each, say `192.0.2.0/27` and
    `192.0.2.32/27`, then other networks can refer to it as a single network of 64
    hosts—1`92.0.2.0/26`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Hosts and routers that are only connected to a single upstream router (typically,
    an internet service provider) thus can store only one route to the entire IP range:
    `0.0.0.0/0` for IPv4 or `::/0` for IPv6\. Such a route is called a **default route**.'
  prefs: []
  type: TYPE_NORMAL
- en: Viewing routing tables and routes
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Let us inspect the routing table of a Linux host connected to a single router.
    You can view IPv4 routes with `ip route show`, or just `ip route`. Unlike `ip
    neigh`, which displays both IPv4 and IPv6 neighbors unless filtered with `-4`
    or `-6`, this command defaults to IPv4 and requires the `-6` option to show IPv6
    routes instead:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: The first entry is the default route—a route to the `0.0.0.0/0` network that
    covers every possible IPv4 address. The gateway is `172.20.10.1`. The outgoing
    interface is `eth0`. From `proto dhcp`, we can infer that it was received from
    a DHCP server. The protocol field is purely informational, and the kernel does
    not use it for route selection. Internally, it is a number from `0` to `255`,
    and some of those numbers are mapped to protocol names in the `/etc/iproute2/rt_protos`
    configuration file.
  prefs: []
  type: TYPE_NORMAL
- en: 'The second route to the `172.20.10.0/28` network is a connected route that
    simply tells the system that it can communicate with hosts from a certain subnet
    directly by sending packets from a certain network interface. Notice that it lacks
    a gateway and only has an interface field (`dev`). If we examine the IPv4 addresses
    on that machine, we will see that its address is `172.20.10.2/28`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Whenever an IP address is added to a network interface, the kernel calculates
    its subnet address and adds a route to that subnet. Since the `172.20.10.0/28`
    subnet is smaller than `0.0.0.0/0`, that route will be used for communication
    with hosts from that subnet rather than the default route. This is known as **the
    longest** **match rule**.
  prefs: []
  type: TYPE_NORMAL
- en: 'The kernel protocol number is reserved for marking such auxiliary routes that
    are created without a direct request from an administrator. It is possible to
    view routes only for a specific protocol by running the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'The kernel can also tell you which route it would use for accessing a certain
    host or network. For example, if you want to know how it would reach a host with
    a `192.0.2.1` address, run the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Since this machine only has a single default route, the answer for every host
    is its default gateway — `172.20.10.1`. However, on routers with multiple connections
    to multiple networks, the `ip route get` command can be helpful.
  prefs: []
  type: TYPE_NORMAL
- en: Configuring routes
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Many host systems just get their default route from DHCP, but routing functionality
    in the Linux kernel is much more advanced.
  prefs: []
  type: TYPE_NORMAL
- en: One problem with configuring routes through the `ip` utility is that, as with
    everything configured that way, such routes only survive until the next reboot,
    in perfect conditions. The other problem is that if a network interface goes down
    (due to a disconnected cable in the case of physical network cards or protocol
    reset in the case of virtual links), all routes associated with that interface
    are permanently deleted and need to be restored by a userspace program. On enterprise
    and service provider routers, the userspace program is usually a routing protocol
    stack service such as Free Range Routing or BIRD. Those routing stack services
    implement dynamic routing protocols but also help manage static routes and keep
    them active across network interface state changes. On host systems, it can be
    NetworkManager or another network configuration frontend. However, it is still
    good to know how to create routes by hand when you need to experiment or make
    an emergency fix on a running machine.
  prefs: []
  type: TYPE_NORMAL
- en: 'To create a static route with a specific gateway address, you can use this
    command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Let us demonstrate it on a dummy interface. First, we will create a dummy interface
    and assign the `192.0.2.1/24` address to it to force the kernel to create a connected
    route to `192.0.2.0/24` and give us space for imaginary gateways. We will use
    `203.0.113.0/24` for our experiments—it is another network reserved for examples
    and documentation that is guaranteed not to appear on the public internet, so
    we can be sure that we do not disturb any real traffic:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we can add a route, verify that it exists, and try to take `dummy1` down
    to see what happens:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'You can see that the newly added route automatically had the right network
    interface in its entry: `203.0.113.0/24 via 192.0.2.10 dev dummy1`. The kernel
    checked the route to `192.0.2.10—t`he address we set as a gateway—and found that
    it is reachable through `dummy1` (nominally, at least).'
  prefs: []
  type: TYPE_NORMAL
- en: 'When we took `dummy1` down, the kernel also removed the connected route to
    `192.0.2.0/24` associated with it. That made the `192.0.2.10` gateway unreachable,
    so the kernel also removed every route whose gateway became unreachable because
    of that change. The kernel also does not normally allow the user to create a route
    whose gateway is not reachable and can detect recursive routes (that is, routes
    whose gateway is not reachable directly via a connected route). However, it is
    possible to disable that reachability check by adding a special `onlink` flag
    to the command, for example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: If you are connected to an Ethernet switch or some other kind of a multiple
    access network, you must specify the gateway in your routes because simply sending
    packets from an Ethernet device is impossible—there must be a destination address
    in the packet since there may be multiple hosts in the same segment. However,
    some network interfaces are point-to-point and have only one system on the other
    side. Physical point-to-point connections, such as serial WAN links, are mostly
    extinct now, but virtual point-to-point links are common. If you are connected
    to the internet via PPPoE, you can create a default route with just `sudo ip route
    add 0.0.0.0/0 dev ppp0` or similar—no gateway address is needed.
  prefs: []
  type: TYPE_NORMAL
- en: If you have only one route to a certain network and want to delete it, you can
    do it with just `sudo ip route del <network>`, and if you have multiple routes
    to the same network, you will need to specify the gateway or the interface to
    delete exactly the route you want, as in `sudo ip route del 203.0.113.0/24` `via
    192.0.2.10`.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two situations when there may be more than one route to the same
    destination. First, it is possible to create a backup route by setting a `metric`
    command for it. For example, if we create a route with a `100` metric, it will
    stay in the table but will not be used while routes with lower metric values still
    exist. If a route disappears, the kernel will automatically start using the backup
    route. Let us demonstrate is with the following commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Second, the kernel can use more than one route to the same destination in parallel
    for load balancing and redundancy. If different paths have different bandwidths,
    you can specify different weights for each gateway as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: Note that this method of load balancing is only applicable in networks that
    have direct routed connectivity throughout because packets that belong to the
    same connection will be sent over both paths and the return path of replies to
    those packets is also unpredictable. Systems that are connected to multiple ISPs
    but use NAT to share a public IPv4 address between all internal network hosts
    need more complex load-balancing configurations that ensure that entire connections
    are balanced and use the same outgoing path for every packet, but that is out
    of the scope of this book.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are also special-purpose routes that ensure that the destination network
    is made unreachable. There are two types of those routes: `blackhole` and `unreachable/prohibit/throw`.
    Both make the kernel discard all packets sent to certain networks, but the `blackhole`
    route tells it to discard packets silently, while the other type also makes it
    send an ICMP error to the originator.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The `blackhole` route is commonly used as a crude but highly efficient filter
    for outgoing traffic. These routes can be used to stop hosts inside the network
    from communicating with a known bad destination, such as a botnet command and
    control node. In case of an incoming DDoS attack, they can also be used to stop
    its traffic at the router and keep it from reaching its target so that you can
    reconfigure the target host for better performance or at least avoid overloading
    it until the attack is over. You can create a `blackhole` route with `sudo ip
    route add` `blackhole <network>`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: If a network is blackholed, you will not be able to connect to any host in it
    from the local machine. For hosts that use that machine as a router, it will look
    like their packets receive no replies.
  prefs: []
  type: TYPE_NORMAL
- en: The other three types of routes (`unreachable,` `discard`, and `throw`) cannot
    be used for DDoS protection because when the packet destination matches such a
    route, the kernel will not only discard the packet but also generate an ICMP packet
    to notify the sender that their packets are not reaching their destination, which
    will only make the situation worse by generating more traffic. They are best used
    inside corporate networks for enforcing policies in a way that will be easy to
    debug. If you do not want your hosts to send any traffic to a hypothetical `203.0.113.113`
    host, you can run `sudo ip route add prohibit 203.0.113.113/32`, and everyone
    who tries to connect to it will receive a message saying that the host is administratively
    prohibited (while with a `blackhole` route clients could not easily tell whether
    it is a policy or a network problem).
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, the `ip` command provides rich functionality for both configuring
    and viewing routing and neighbor tables. Configuring routes by hand is not a common
    task but it is still important to know how to do it, and information retrieval
    commands for route and neighbor tables are very useful in day-to-day diagnostic
    and debugging work.
  prefs: []
  type: TYPE_NORMAL
- en: NetworkManager
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Servers and embedded devices usually have fixed, statically assigned IP addresses,
    but desktop and especially laptop computers may need to dynamically connect to
    multiple networks of different types. A systems administrator with a laptop may
    need to connect to a wired Ethernet network in their server closet, to Wi-Fi networks
    in their office, home, and public spaces such as cafes, and also use a VPN tunnel
    to connect to the corporate network from home. Since many laptops no longer have
    an onboard wired network card, there may be a need to use a USB Ethernet adapter
    instead, so the system must handle not just on-demand network connections, but
    also hot-plug network devices.
  prefs: []
  type: TYPE_NORMAL
- en: Managing such configurations by hand through configuration files and commands
    would be tedious, so people created software projects to automate it. Those projects
    rely on the usual tools such as the `ip` utility and third-party projects such
    as strongSwan or `xl2tpd` for VPN connections but tie them under a unified user
    interface and include an event handling mechanism to deal with hot-plug hardware
    changes and users' requests to connect to different networks.
  prefs: []
  type: TYPE_NORMAL
- en: The most popular solution is the NetworkManager project, which was started by
    Red Hat in 2004\. These days, most Linux distributions include it at least in
    desktop installations.
  prefs: []
  type: TYPE_NORMAL
- en: '`dnf search NetworkManager` (on Fedora or RHEL) or `apt-cache search NetworkManager`
    (on Debian-based distros), you will see packages with various plugins for connection
    types that range from well-known and widely used such as `NetworkManager-wifi`
    or `NetworkManager-openvpn` to obscure and experimental such as `NetworkManager-iodine—a`
    solution for bypassing firewalls by transmitting data inside DNS packets.'
  prefs: []
  type: TYPE_NORMAL
- en: 'There are also multiple user interfaces for it. The network applet you can
    see in the tray area of desktop environment panels is a NetworkManager user interface.
    In MATE Desktop and many other desktop environments, you can verify that if you
    right-click on the network icon and choose the **About** menu point. You will
    see the following screen:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.1 – NetworkManager applet version information dialog](img/B18575_09_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.1 – NetworkManager applet version information dialog
  prefs: []
  type: TYPE_NORMAL
- en: 'In the **Edit Connections** section in the right-click menu, you can create
    new connections or edit existing ones:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.2 – NetworkManager connection editing dialog](img/B18575_09_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.2 – NetworkManager connection editing dialog
  prefs: []
  type: TYPE_NORMAL
- en: 'Recent versions of NetworkManager save connection configuration files to a
    dedicated directory, while old versions would use distribution-specific formats.
    If you save a connection, you can find its file under `/etc/NetworkManager/system-connections`.
    Note that those files are not readable for unprivileged users. You can view the
    connection file for the Office Wi-Fi connection as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: There is also a text-mode interface for NetworkManager that can provide a GUI-like
    experience on headless machines. It’s usually not installed by default, but on
    Fedora, it can be installed from the `NetworkManager-tui` package.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.3 – nmtui, a text-based interface for NetworkManager](img/B18575_09_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.3 – nmtui, a text-based interface for NetworkManager
  prefs: []
  type: TYPE_NORMAL
- en: Finally, the `nmcli` tool allows managing NetworkManager connections from the
    command line. If you've already created a connection, you can bring it up with
    `nmcli connection up <name>` (similar to `nmcli connection up "Office Wi-Fi"`)
    or bring it down with `nmcli connection down <name>`. It also provides interactive
    connection editing functionality that you can use if neither `nmtui` nor a graphical
    desktop environment is available.
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, NetworkManager makes it easy to manage typical network configurations,
    especially on desktop machines. Next, we will learn about distribution-specific
    configuration methods that do not use NetworkManager.
  prefs: []
  type: TYPE_NORMAL
- en: Distribution-specific configuration methods
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: NetworkManager is used by many distributions on desktop systems, but many Linux
    distributions have also used custom network configuration files and scripts. Some
    still use them, while other systems migrated to NetworkManager but maintain old
    methods as an alternative or in legacy long-term support releases.
  prefs: []
  type: TYPE_NORMAL
- en: Debian
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In Debian, the configuration file for network interfaces is `/etc/network/interfaces`.
    Unlike NetworkManager’s native format, this allows keeping configurations for
    all interfaces in a single file. To make the configuration more modular and easier
    to read, it is possible to store files for individual interfaces in the `/``etc/network/interfaces.d/`
    directory.
  prefs: []
  type: TYPE_NORMAL
- en: 'Interface configurations are also identified by link names rather than arbitrary
    descriptions and UUIDs. This is how to set an onboard Ethernet device, `eno1`,
    to use static addresses for both IPv4 and IPv6, for example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'You can also execute custom commands when interfaces are brought up and down,
    using the `pre-up`, `up`, `down`, and `post-down` options. For example, to automatically
    add a route when `eno1` goes up, run the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: The tools for bringing interfaces up and down are named `ifup` and `ifdown`,
    respectively. They are only available to privileged users, so you need to run
    them with `sudo`, as in `sudo ifup eno1` or `sudo` `ifdown eno1`.
  prefs: []
  type: TYPE_NORMAL
- en: Old Red Hat-based distributions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Fedora and RHEL version 8 and above (as well as its derivatives such as Rocky
    Linux) use NetworkManager as their network configuration system. Up to RHEL7,
    however, it used a different system. Its configuration file directory was `/etc/sysconfig/network-scripts`,
    and each interface used its own file. For example, this is how you could statically
    assign the `203.0.113.113/24` address to an onboard Ethernet interface, `eno1`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: A Red Hat-specific way to reread and apply all old-style network configurations
    is by using the `service network` `restart` command.
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, distribution-specific methods are conceptually similar, although
    configuration syntax and names for options with the same meaning can vary wildly.
    If in doubt, you should always consult the documentation. Now that we've covered
    the most common network configuration methods, we should also learn how to verify
    whether the configuration works as expected.
  prefs: []
  type: TYPE_NORMAL
- en: Network troubleshooting
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Network troubleshooting is a vast subject. However, most of the time, experts
    use the same tools that are available to every novice and those tools are not
    hard to learn to use at a basic level. The main difference between a novice and
    an expert is how well they can interpret their outputs and choose the correct
    options.
  prefs: []
  type: TYPE_NORMAL
- en: Using ping
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The name of the `ping` utility comes from the sound of sonar—a device that uses
    sound pulses to discover objects underwater. That command metaphorically probes
    a remote host by sending an ICMP packet and listening for a reply. The sonar metaphor
    is a bit of a stretch because sound pulses are passively reflected, while the
    exchange of ICMP packets requires cooperation from a remote host.
  prefs: []
  type: TYPE_NORMAL
- en: Still, a host that runs a correctly implemented network stack should reply with
    an ICMP echo reply packet if it receives an echo request. At the most basic level,
    pinging a host tells you whether the host is online and whether there is a working
    network path to it.
  prefs: []
  type: TYPE_NORMAL
- en: 'By default, the Linux version of `ping` will keep sending echo requests indefinitely.
    This is in contrast with some other versions, such as that of Windows, that terminate
    after a finite number of packets by default. If you want the Linux `ping` to behave
    that way, you can specify the number of requests with `-c`, such as `-c5`, to
    send five requests as shown:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: If ICMP echo requests successfully reach their target and the target replies,
    then replies to those packets will come from the target address.
  prefs: []
  type: TYPE_NORMAL
- en: 'If packets do not reach the target host because there is no route to it, you
    will get replies from the last router on the path of those packets that fail to
    send them further because it could not find a route. For example, consider this
    output from pinging a host in a private network:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: In this case, the last router that received our ICMP echo request packets and
    failed to forward them further has a `10.217.41.49` address, so if we wanted to
    check why that host was inaccessible, that router would be our starting point.
  prefs: []
  type: TYPE_NORMAL
- en: Using traceroute
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A ping can tell you whether a host is accessible and if not, then where exactly
    in the network the path of ICMP echo packets ends. However, it cannot tell you
    what the network path is.
  prefs: []
  type: TYPE_NORMAL
- en: To discover paths of packets through the network, you can use the `traceroute`
    utility instead. In short, that utility sends packets with an intentionally small
    TTL (for IPv4) or hop count (for IPv6) and records to force those routers to discard
    the test packet and record ICMP error messages from them to record the packet
    path.
  prefs: []
  type: TYPE_NORMAL
- en: Every IP packet has a field that shows how many times it was already forwarded
    between routers. In IPv4, that field is named `0`, the packet is discarded. Whenever
    a router discards a packet for that reason, it notifies the sender with an ICMP
    TTL exceeded message.
  prefs: []
  type: TYPE_NORMAL
- en: Thus, if you intentionally set the TTL of a packet to `1`, it is guaranteed
    to be discarded by the very first router on its path. From the ICMP response about
    a discarded packet, you can learn the address of that router. By repeating the
    procedure with increasing TTL values, you can learn about every router on the
    path—or at least every router that cooperates and sends ICMP TTL-exceeded replies.
  prefs: []
  type: TYPE_NORMAL
- en: In the public internet and other large-scale networks, there are lots of subtleties
    in interpreting `traceroute` outputs. Some routers may not generate ICMP TTL exceeded
    messages at all or only generate them if their load is low, so the path may appear
    to have gaps (you will see `* * *` symbols in place of path entries where the
    router never generates those responses—t`raceroute` retries its probes three times
    before giving up). The path shown by `traceroute` may not be the real path due
    to network segments that use **Multi-Protocol Label Switching** (**MPLS**) instead
    of IP routing. However, it is still a useful tool, and inside private networks,
    its output is usually the real path.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is what its output may look like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: By default, `traceroute` tries to resolve IP addresses to domain names by looking
    up their PTR records. It may slow it down or you may want to see raw addresses
    instead. If you prefer to see raw addresses, you can disable name resolution with
    the `-``n` option.
  prefs: []
  type: TYPE_NORMAL
- en: There are many more network diagnostic tools. For example, network scanners
    such as *nmap* can tell you which services are running on a remote machine and
    gather information about its operating system and network stack. Packet capture
    and analysis tools such as *tcpdump* and *Wireshark* can help you get a detailed
    picture of network traffic. However, even with just `ping` and `traceroute`, you
    can verify that your network setup is working or gather debugging information
    to share with colleagues or support technicians.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we learned about the components of the Linux network stack,
    the tools for managing it, and different types of physical and virtual network
    interfaces. We learned how to assign and view addresses, view and create routes,
    configure network settings using NetworkManager and distribution-specific methods,
    and perform basic troubleshooting procedures.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will learn about managing storage devices.
  prefs: []
  type: TYPE_NORMAL
