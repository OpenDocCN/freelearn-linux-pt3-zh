# *第九章*：备份与灾难恢复方法

我在本书中已经说过，并且无论多少次，都要重申：作为系统管理员，保持良好的备份是我们工作中最重要的事情。它是我们的首要任务。重要到许多组织都会维护一个独立的系统管理团队，专门负责备份工作，以确保能够持续关注这一任务。

备份并不吸引眼球，也很少让人兴奋。这不仅仅是因为它们对我们技术人员来说是一个挑战，当我们本可以花时间实施新的自动化或者做其他更令人兴奋的事情时，我们却要花时间思考备份问题，还因为这意味着管理层往往不会优先考虑预算或将备份作为优先事项。这为系统管理员带来了潜在的风险，如果我们过于关注像备份这样的关键功能，而不是做那些炫目、高调的项目以维持管理层的兴趣，往往会面临被惩罚的高风险——如果那些他们未曾优先考虑的备份在需要时无法完美运行。

然而，备份越来越多地出现在我们的意识前沿，因为它们已经不再仅仅是保护免受灾难性硬件故障的手段，而是处于安全问题的前沿。近年来，备份发生了演变，现如今它们不仅提供了在我们组织中政治上发光发热的机会，也为技术上的新兴趣带来了重新点燃的机会。上世纪 90 年代和 2000 年代那个枯燥的备份与恢复的局面，简直可以说已经成为过去式。今天，我们有了那么多的备份方法、选项和产品，以至于我们必须把备份视为一个比以往更广泛的问题来处理。

在这一章中，我们将涵盖备份的许多不同方面。我们将从备份的广泛概述以及备份系统中存在的组件开始。接着，我们将讨论一些常与备份一起使用、但有时可能会与备份混淆的相似技术。然后，我们将深入探讨本书中提到的概念——现代*以 DevOps 为中心的备份方法*，并对这一方法进行详尽的讨论。接着，我们将探讨代理以及备份中数据崩溃一致性的问题。最后，我们将讨论分类以及灾难发生后如何改进恢复。

言归正传，让我们开始本书中无疑是最重要的一章。我想，任何一本书都是如此。

在这一章中，我们将学习以下内容：

+   代理和崩溃一致性

+   备份策略与机制

+   快照、档案、备份与灾难恢复

+   DevOps 世界中的备份

+   分类概念

# 代理和崩溃一致性

在下一部分，我们将探讨备份机制。在此之前，我想先讨论为什么备份本身这么难做好。为了做到这一点，我将通过两个示例来解释。一个是我们使用最爱的文本编辑器创建的文本文件。我假设你是个普通人，和我一样热爱使用 vi 编辑器。另一个则是企业数据库系统中的数据文件。

当我们谈论备份时，我们是在谈论将存储在物理介质上的数据复制到一个与原始系统分开的地方，以便在许多情况下原始系统失败时，备份仍然能够存活下来。这是备份目标的一个高层次概述，它满足我们的需求。因此，为了执行备份，我们必须能够获取系统中的数据，读取它，移动它并将其写入。

在这些步骤中，看起来将数据移动到另一个位置或将数据写入某个地方可能是最大的挑战。这个想法是错误的。能够读取数据实际上才是问题的根源。主要是因为我们需要读取的数据并不总是明确的。

计算机是如何在磁盘上存储数据的呢？并不是每个计算机系统的工作方式都相同，但存在一些我们知道没有替代方法的基本原理。在处理数据时，计算机会将数据保存在随机存取内存中。在内存中，它是完全易失的，但速度非常快。当计算机处理完一个文件时，它会将内存中的数据写入存储设备，假设是硬盘或 SSD。

如果我们尝试在数据仍保存在计算机内存中并尚未写入磁盘时进行备份，我们的备份将不包含任何相关数据。听起来可能有些荒谬，但这是必须记住的。无论是技术人员还是管理人员，都常常假设数据总是被存储在某个地方，即使它只是进入了内存，还没有时间被存储到任何地方。

一旦数据被写入磁盘并进行备份，磁盘上的数据应当被复制到备份位置。世界一切正常。

这一切听起来不错，但计算机处理的情况要比仅仅接收文件并保存到磁盘复杂得多。在现实世界中，计算机几乎总是在从存储机制中读取现有文件，将其保存在内存中并进行数据操作，然后将修改后的数据保存回磁盘。这就是事情开始变得棘手的地方。

现在我们应该开始使用我们的示例。首先是`vi`中编辑文本文件的情况（如果你坚持的话，你也可以使用 Atom 或其他编辑器。）我们还假设我们不是创建一个新文件，而是在编辑已经存在于磁盘上的配置文件。一个很好的例子是`hosts`文件（位于`/etc/hosts`）。

如果我们在文件编辑过程中进行备份，我们将获得编辑前的旧数据副本，因为任何正在进行的编辑仅存在于内存中，而不是磁盘上。文件在打开时并不意味着数据正在写入磁盘。旧数据仍然保存在磁盘上，而新数据则存在于内存中。

当文件被保存时，数据会被写入磁盘。写入完成后，我们可以进行复制。当然，在数据写入过程中，可能会有一个短暂的时刻，磁盘上的内容既不是原始版本，也不是新版本，而是处于两者之间的某个状态，因为数据尚未完全写入。

我们可以尝试锁定文件，但即使文件被锁定，情况依然复杂。无论备份机制是什么，它必须决定是跳过锁定的文件、等待锁释放，还是忽略锁定直接进行备份。没有一种情况是理想的。我们要么无法在任何特定的备份过程中备份所有文件，要么面临长时间等待某个可能*永远*不会发生的事件，或者我们面临备份过时文件，甚至更糟，备份损坏的文件。没有完全简单的解决方案。

## Linux 中的锁机制

当进程在 Linux 上使用文件时，实际上在任何操作系统上，我们通常会看到三种基本策略。第一种，也是最明显的，就是不做任何操作。是的，没错。在许多情况下，根本没有执行任何锁定操作。文件内容被读取，而文件本身并未被标记为已打开。它只是被读取。这种方法的优点是任何其他进程都可以以任意方式继续使用该文件，但它也无法提供任何关于文件是否即将以某种方式更新的信息。

Linux 上的主要替代机制称为建议锁（advisory lock）。通过建议锁，操作系统会标记一个文件是否已被进程打开。这些锁被称为建议锁，因为操作系统通知其他进程该文件正在使用。其他进程可以选择忽略该锁，继续读取，甚至覆盖被锁定的文件。这种方式的好处是我们可以锁定文件而不必担心完全阻止其他人访问它。风险在于我们的锁可能不会被遵守，导致竞态条件发生，数据可能被更改顺序错误，或者本以为已保存的数据被覆盖。忽略建议锁以查看文件并检查一些旧数据是相对安全的。忽略建议锁以在没有原进程知情的情况下覆盖文件并进行更改则是危险的。完全支持并遵守建议锁的进程称为合作进程（cooperative processes）。

第三个选项是强制锁（mandatory lock）。顾名思义，进程别无选择，必须遵守强制锁。强制锁由 Linux 内核管理，只有在文件系统特意以这种锁定方式挂载时才会存在。然而，Linux 上的强制锁存在实现问题，使得它们不可靠，并且容易受到一些罕见的竞态条件的影响，这些竞态条件实际上使得锁的目的无法实现。因此，强制锁在 Linux 系统中几乎总是被忽视。

锁定在概念上是困难的。它带来了风险和系统开销。对被锁定文件的最佳响应方式并不总是显而易见，并且可能因操作系统无法预见的各种不同用例而有所不同。由于操作系统并不知晓文件最初为何被访问，它几乎没有有效的手段来强制执行二次访问的限制。几乎总是有理由我们可能想要读取一个被锁定的文件，甚至有时有充分理由对一个被锁定的文件进行写操作。信任我们只会运行那些在我们使用场景下能够按需执行的进程，是我们在几乎所有情况下的最佳行动方案。当需要更复杂的访问时，比如大多数数据库文件的情况，就需要转向单一进程访问，由该进程处理来自应用程序栈上层的额外数据访问，因为那里的进程对文件的预期用途有更多的了解。

除了锁定，另一个我们必须理解的重要概念是静默（quiescence）。静默简单来说是指存储达到一种休眠状态，即没有波动。当我们说存储已经达到静默状态时，我们的意思是所有当前*正在传输*的数据，无论是正在被应用程序使用，还是仅仅被存储在多个缓存层中的某一层，已经被写入磁盘。从某种程度上讲，我们可以将锁定视为一种机制，用来警告我们（或一个进程）系统目前未处于静默状态。

不幸的是，Linux 上没有通用机制来强制执行或甚至确保系统的静默状态，Windows 上也没有，尽管许多关于 VSS（卷影副本服务）能做到这一点的说法是错误的。VSS 是 Windows 上的标准逻辑卷管理器（LVM），因此常用于许多存储操作。常有人说 VSS 保证所有文件都处于静默状态，但这不准确。VSS 与许多常见的应用程序（主要是 Microsoft 的应用）有特殊的挂钩，例如 SQL Server、Exchange 和 Active Directory，以便它们能够有效地与存储层通信，了解自身静默状态。这是一个令人惊叹的功能，并且自动与操作系统集成非常方便。然而，它并未解决第三方应用程序的问题，这些应用程序很少有 VSS 集成，导致它们处于危险的非静默状态，而许多 Windows 管理员认为 VSS 神奇地管理了所有应用层的数据刷新，但事实并非如此，它无法做到这一点。

在操作系统层面，我们作为系统管理员通常需要使用的静默工具是来自逻辑卷管理器的快照（例如 LVM 或 ZFS 提供的快照），或者冻结文件系统本身，如 XFS 所能实现的那样。我们越接近栈的上层（“上层”意味着更靠近应用程序本身），我们冻结系统的范围就越大，系统中仍在传输并未写入磁盘的数据的可能性就越小。然而，最终，无论操作系统如何，除非应用程序本身保证它已经将所有数据刷新到磁盘并且没有留下任何缓存或正在处理的数据，否则我们所能希望的最多也就是尽力而为。这是一个普遍存在的挑战。计算机本身就是非常复杂的东西。

在大多数情况下，事实上几乎所有情况下，一种或多种静默方法都能很好地将数据安全地写入磁盘。实际上，大多数备份和企业通常很少依赖如此多的保护，通常依赖尽力而为的文件锁和多重备份来提供系统中足够数量文件的有效副本。大多数工作负载写入磁盘的频率较低，使得很少发生高风险场景。但我们不能忽视的是，这些方法中的任何一种都无法真正确保系统完全静默，并且我们始终面临某些程度的风险，关键数据可能以某种形式仍在传输中。如果我们讨论的是仅提供静态网站的 Web 服务器，风险可能低到可以忽略不计。如果我们讨论的是用于财务和会计数据的关键企业数据库，风险可能极大，这是无论如何都不能承担的风险。因此，如果我们想要在系统层面进行备份，我们需要考虑我们的工作负载、它们的静默状态以及由此带来的风险。

当我们使用其中一种不与应用工作负载端到端协调以确保物理媒体上的数据完整和静默的机制进行备份时，我们称我们的备份为*崩溃一致*。这是一个重要的术语，经常使用。崩溃一致性并不意味着系统实际上已经崩溃，而是指计算机系统突然崩溃或断电后存储的状态。

崩溃一致性是一个非常关键的概念，我们需要真正理解我们所说的意思。对于一些人来说，它被说成是一个即将到来的灾难的可怕警告。其他人则用它来暗示一个可靠的系统状态。那么，它真正意味着什么呢？

当任何计算机完全崩溃时，意味着在事件发生后没有恢复或保护能力，例如当硬件发生灾难性故障或电源突然无法提供给系统时，绝对没有机制可以确保磁盘上的数据准确或完整。正如任何计算机用户所知，计算机突然断电通常不是问题，除非文件的任何未保存更改或我们在视频游戏中的最新进展等都将丢失。这似乎是显而易见的，我们通常不会认为这是系统设计的一个重大问题。偶尔，我们会发现一个程序或数据集已经损坏。当系统从崩溃中恢复时，我们都害怕这种情况，但实际上很少是一个问题 - 至少对于最终用户而言。

实际崩溃后系统的状态与没有任何静默期备份的系统状态基本相同。任何当前正在修改的数据都将丢失。偶尔会发生我们认为已保存到磁盘的数据损坏的情况。总体而言，一切都在那里。这就是为什么我们称这种状态下的备份或任何拷贝为崩溃一致，即与物理机器上的灾难性崩溃一致性相同。

当谈论到桌面时，更容易说明这一点。服务器上存在相同的风险，但程度严重得多。在桌面上，我们往往只有一个用户，对当前可能正在传输的所有数据有很好的了解，并且存储比较直接。在服务器环境中，不仅可能存在大量的存储复杂性，每一个转折点都可能存在不同的可能且可能有风险的机制，而且我们很可能在整个堆栈中有更大更多的缓存情况，并且一个或多个多用户工作负载会在崩溃时很少与用户有意义地交互。

考虑一个典型的 Web 服务器示例，数据存储在数据库中。用户与网页进行一些交互，可能是输入销售信息、上传表单、处理银行交易或下订单。用户认为交易已完成，因为他们收到了反馈，显示提交已完成。用户很可能不会刷新页面或返回，因为对他们来说，交易已经完全完成。但真的是这样吗？

Web 服务器可能将交易排队在内存中，稍后几秒钟再处理，或者将部分数据保存在缓存中。或者，它可能已将交易写入数据库，而该数据库可能仍然将数据保留在缓存中。也许数据库已将数据写入文件，但文件系统仍然将数据保存在缓存中。也许文件系统已提交数据，但逻辑卷管理器还在缓存中持有数据。如果你有硬件 RAID，那里可能会有缓存，在数据写入物理磁盘之前，它会停留在那个缓存中。物理磁盘本身也可能有缓存，虽然在这种情况下应该禁用它，但它可能没有被禁用，并且可能是另一个数据在驱动头将数据实际写入磁盘之前可能被缓存的地方。

当然，可能存在许多机制来防止这些故障。磁盘缓存应该禁用，RAID 缓存通常通过使用非易失性内存或电池保护，以便即使系统发生断电，它们也能将数据刷新到物理磁盘，数据库通常会在进行最终写入之前记录事务，因此如果无法向前滚动，它们就有能力回滚，应用程序通常不会在至少确保某种程度的事务已记录的情况下向最终用户报告一切正常。我们希望这些情况都能存在，但没有什么能够保证它们，除非在端到端的应用程序和系统设计的结合下。即使是设计最好的应用程序，也可能会被虚拟机监控程序欺骗，它将易失性内存表现得像硬盘一样，并报告系统已空闲，但实际上没有写入任何存储数据。因此，需要信任。

数据在传输过程中丢失只是一个问题，另一个问题是数据损坏。沿途的许多层可能会因写入操作不完整而发生损坏。单个文件通常是我们看到损坏发生的地方，这是最常见的地方。二十五年前，我们也经常看到文件系统损坏。今天这不再是一个常见问题，但它仍然存在风险。不同的文件系统在这种情况下的风险程度不同。理论上，逻辑卷管理层可能会存在某些损坏风险。显然，RAID 或 RAIN 存储层可能会发生损坏，并且有时，如奇偶校验 RAID，在损坏事件发生时有可能导致数据完全丢失。

所有这些步骤都不太可能发生，但都有可能发生。正常崩溃时通常不会发生丢失或损坏数据。灾难发生的可能性取决于许多因素。我们不应该把崩溃一致性级别的解决方案看作毫无用处或等待发生的完全损失，但我们也不应假装它们没有忽略没有任何系统确保一致性的基本风险。在所有情况下，我们只是在掷骰子并希望得到最好的结果。我见过许多小企业丢失了他们认为完全可靠的备份数据，因为他们依赖于崩溃一致性，而供应商却假装数据损坏不是一个问题。由于崩溃一致性机制便宜且简单，因此它们受到供应商的广泛关注。

替代方法称为**应用一致性**。我们之所以这么称呼，是因为它指的是当工作负载应用程序能够确认已将所有数据刷新到磁盘，并且当前没有数据在传输中时，系统可能的状态。应用程序可以通过确认它们当前处于静默状态来简单实现这一点，或者它们可能有机制强制发生这种状态。无论哪种方式，它们通过从应用程序堆栈的最上层应用智能来避免崩溃一致性的问题，并验证数据已经准备好进行备份。

这种方法要求应用程序支持提供这种静默状态，如果我们想将此操作与任何类型的备份机制协调，我们必须有一种方式让备份机制调用应用程序请求静默，或者让应用程序调用备份机制。在 Windows 环境中，正如我们之前讨论的，VSS 提供了一个标准接口，任何应用程序都可以选择支持。如果它们愿意的话。当前 Linux 没有类似的标准。

因为所有这些机制都复杂且非标准化，所以在处理任何超出有限范围的流行服务时，都会遇到重大挑战，这些服务通常是广为人知且得到支持的。实际上，Windows 也同样有限，但在那里使用一小部分非常标准的服务更为常见。

许多应用程序选择通过集成自己的备份服务来解决这个问题，而不是尝试依赖其他机制。有些可能会构建一个非常强大的备份机制，直接支持多种不同的选项，例如内置的调度、多级备份以及直接存储到多种不同类型的介质。这种情况并不常见，但确实存在。

从最简单的应用程序到企业数据库，最常用的选项就是直接从应用程序写一个备份文件到本地文件系统。这是非常常见且有效的方法。它会生成一个简单的文件或一组文件，可以指定为备份，并防止它们被用于除另一个备份机制之外的其他用途，后者会使用这些文件来复制或发送到其他位置。

这个非常常见的例子是 MySQL 和 MariaDB 数据库。数据库是我们最难以安全备份的应用程序类型，因此几乎所有的数据库系统都会采用某种方式来安全地保护数据，而不必采取如关闭数据库、复制文件并在完成后重新启动等极端的暴力步骤。

## 使用 mysqldump 工具的 MySQL 示例

几乎可以肯定，Linux 生态系统中最著名的应用级备份工具是随 MySQL 和 MariaDB 提供的`mysqldump`。这个简单的命令行工具连接到一个正在运行的 MySQL 或 MariaDB 数据库服务器，锁定它并将所有数据静默到内存中（它不需要刷新到磁盘），然后将这份数据的副本保存到磁盘。它是任何工具中最简单易用的，同时也是极其强大的。它对正在运行的系统几乎没有影响，而且由于它不需要在将应用程序一致性的副本保存到磁盘之前进行任何复杂的刷新操作，所以不需要停止数据库的读取操作，只需要短暂暂停写操作。

在这里，我将展示一个简单的单一命令，用于轻松备份由单个 MySQL 或 MariaDB 实例管理的所有数据库：

```
mysqldump --all-databases > mysqlbackup-`date +%H%M`.sql
```

这个例子几乎是最基础的，你几乎无法简化得更多了，但它非常有效。你可以随时运行它，并且因为它在过程中记录当前时间，所以它不会覆盖任何其他备份文件，即使是比它早一分钟创建的文件。你可以将备份写入磁盘上的任何位置。你可以在备份文件写入时或稍后使用标准工具轻松地压缩生成的备份文件。请记住，这只是一个备份文件，是用来进行备份的文件，但到此时它还不是一个实际的备份。

一旦这个文件存储到磁盘，它就变得安全，任何备份工具现在都可以在不担心应用程序正在使用或修改它的情况下获取这个文件，并将其放置在任何合理的位置。完全灵活，且应用程序的一致性简单易懂。

目前，我认为我们理解了一致性、锁定和静止状态的作用，以及在尝试备份甚至单个文件或应用程序时可能面临的所有问题（请记住，并非所有备份都涉及存储在任何地方的文件格式数据），更不用说尝试备份整个文件系统或系统了。理解这一挑战是关键，因此我们关心不同类型的备份工具的不同方面，下面我们将一起进行探讨。

# 备份策略与机制

实际上，备份比大多数人想象的要复杂得多。在处理备份时，我们经常只是被告知“进行备份”，好像这是一个简单的活动，几乎没有变数。然而，在现实世界中，我们确实有一些常规方法，可以满足大多数需求，即使只是最低限度地满足。然而，在某些情况下，要有效地进行备份需要更多的思考，并且需要深入理解我们的工作负载和基础设施，以便能够正确地进行操作。

在过去的好日子里，就像上世纪 80 年代和 90 年代那样，备份几乎总是相同的。它们涉及某种简单的代理程序，例如标准的 Linux `tar`命令，该命令会按计划运行（我们可能需要手动设置类似于`cron`的计划任务），它会将一个目录中的所有文件，或更可能是整个系统，打包成一个单一文件，并将该单个大文件放置在磁带设备上。然后需要人为移除磁带并将其运输到安全地点。

多年来，新技术不断涌现，备份逐渐变得更加强大和复杂。磁带逐渐不受欢迎，而其他备份目标，从可交换的硬盘到始终在线的存储，也应运而生。随着备份介质的发展，备份机制有机会从离散的“每次备份一磁带”的计划转变为更灵活或更复杂的设计。伴随而来的是复杂的备份应用程序，备份领域由简单和基础的状态转变为相当复杂的情况。

由于今天涉及的变量如此之多，简单地进行备份已不再是一个简单的概念。每个人对备份的理解和需求各不相同，基于他们的期望和经验。这种多样性甚至可能导致我们产生视角狭窄的危险，认为所有人都以类似的方式看待备份，而实际上，现实世界中处理备份需求的方式有很多种。

## 备份类型

首先，我们将讨论可能使用的实际备份机制。这些通常分为两类：基于代理的和无代理的（我真的讨厌这两个术语），但人们通常会将其视为三类，其中第三类是临时脚本。关于它们身份的所有这些想法当然都是完全错误的，正如许多人常说的那样。这些术语已经得到了广泛使用，尽管它们不准确，你仍然需要使用它们。

### 系统级备份

系统级备份就是所谓的基于代理的备份。这些备份之所以得名，是因为通常会在操作系统上安装一个运行的软件代理，并且该代理是可见的。你可以在系统上的某个地方看到它出现在已安装的软件列表中。然后，代理会运行并从操作系统上下文的*内部*抓取文件，并将其发送到其他地方进行存储。通常会有额外的处理步骤，如打包、压缩、去重和加密，但这些技术上都是可选的。

### 一切都是代理

当我们说有一个基于代理的备份解决方案时，脑海中会浮现出必须购买、下载并安装到我们计算机上的软件。毫无疑问，这是人们常做的事情。

然而，代理的概念要广泛得多。备份代理可能是操作系统中内置的复杂备份工具，而不是单独获得的。在 Linux 世界中，这种情况几乎是常见的，因为许多强大的备份选项已经包含在典型企业级发行版的仓库生态系统中。

代理的范围甚至更广。像`tar`和`rsync`这样的经典工具，就是，或者至少可以成为，备份代理。它们是已安装的软件组件，可以用于在操作系统内部执行备份。

我们可以继续下去。如果你编写自己的脚本来移动块或文件，那也是一个代理。代理的概念非常广泛，从逻辑上讲，总是需要某个组件来执行备份任务，而这个组件永远是代理。

通过在操作系统内部工作，位于此处的代理可以利用明显的访问方法来访问我们想要备份的数据。它可以通过使用像`dd`这样的工具在块级别与存储设备进行通信，或者使用像 LVM 这样的稍高层次的逻辑卷工具来提供强大的块级处理；或者它可以使用文件系统层逐一请求文件；或者它可以使用 API 与正在运行的应用程序进行交互，从而提供某种类型的高级数据访问。通过这些方式中的一种或多种，代理可以访问备份所需的数据。

所有这一切都意味着，代理程序的任务是与操作系统进行交互，尝试从存储子系统中触发某种程度的静默，以增加获得一致性备份的机会。有些代理程序会与许多应用程序进行广泛的交互，而有些则根本不与任何应用程序交互。

代理程序完成所有工作，并提供多种方式与我们的数据进行交互。但它们有一个局限性，那就是它们只能访问操作系统能够访问的内容，并且只有在操作系统启动并运行时才能使用。最后这一点意味着，操作系统本身正在使用的任何资源，在代理程序需要访问它们时也会处于使用状态。这就给系统范围内的一致性带来了真正的挑战。然而，我们很少真正关心整个系统范围内的一致性。当然，我们会更喜欢一致性，但大多数系统文件的影响较小，如果丢失或损坏，也能轻松恢复。通常，只有关键的应用程序数据或安装的应用程序本身才是主要关注点，其他的文件只是为了在需要快速恢复时提供帮助。

通常，但不是普遍的，对于系统级备份，进行恢复操作时，必须先安装一个空的操作系统，然后安装恢复代理，并允许代理对存储的备份进行操作，将文件恢复到操作系统中。这通常意味着系统级备份在备份单个文件并能够恢复单个文件方面表现优秀，但在恢复整个丢失的系统时却更加困难。

曾经一度，几乎所有备份都是这么做的，普遍的假设是，几乎所有恢复操作都是为了检索单个丢失的文件，而不是为了恢复整个失败的系统。

### 人们已经不再像以前那样丢失文件了。

在写这章时，我被过去三十年中计算体验的巨大根本变化所打动。在我年轻时的整个行业生涯中，甚至在我只是一个计算机用户之前，我们最大的担忧一直是丢失、删除或使某个文件以某种方式损坏。我们所有人都把备份的概念看作是将许多单独的文件复制到某个地方，我们设想任何恢复过程就是把那些文件复制回来，一旦有了存放它们的地方，而往往这种恢复操作的发生是没有任何故障的情况下进行的。

最后这一点是我最感兴趣的。几十年来，人们一直认为他们会经常意外覆盖或删除自己需要的关键文件，而这确实发生过。需要追踪并恢复一个终端用户删除的单个文件是一个完全常见的任务，这项工作如此频繁，以至于大多数大公司都有专门的团队来专职处理这类事务。

计算已经发生了改变，今天这种情况很少见，重要文件自行丢失的想法似乎不可能，但肯定是不太可能的。我假设用户在文件管理方面变得更加有教养和更加勤奋，当然，过去作为个别文件完成的大部分工作已经转移到某种数据库或者数据存储在应用程序前端背后的地方，这保护了最终用户免受自己的伤害（这可能从 Google Docs 到 Flickr，但即使是最终用户自己管理文件的工作也显著减少）。大多数操作系统，甚至一些应用程序本身，现在都实施了*回收站*功能，这些功能将删除的文件保留，直到它们被明确处理，以便最终用户有足够的时间改变主意或找回意外删除的内容。最后，像操作系统自带的自助文件恢复功能或者简单的附加应用程序都可以让文件从其他媒体恢复回来，而无需引入传统的备份或者备份团队，因为数据仍然本地存储（更不用说可以被最终用户使用的在线备份系统了）。

简单来说，值得注意的是，曾经成为一个常见问题，甚至推动整个行业发展的问题，如今在今天已经基本消失了。计算机被视为文件管理和操作设备的时代已经过去，现在已经变成了在线数据消费设备，大多数用户甚至不再关注文件。今天的许多年轻用户甚至可能对文件和存储管理的概念感到困惑。

### 平台级备份

另一种方法是从平台级别进行备份，即从操作系统下层进行备份。在实际操作中，这意味着虚拟化层，通常是指虚拟化监控程序，但在某些情况下可能仅限于操作系统外部的存储虚拟化，例如，如果使用 SAN 设备，这种情况尤其常见。

随着虚拟化的到来，这种方法迅速流行起来。新的备份厂商推出了新技术，旨在使操作系统外的备份更简单、更快速。此层级的备份当然无法访问文件系统或应用程序 API，无法与这些组件进行通信或了解数据布局。因此，进行此层级的备份必须直接与块设备或虚拟化层的存储抽象层进行交互，而这些抽象层本质上是块设备本身，这让我们通常无法知晓正在备份的数据到底是什么。在这个层级，我们可能知道，或者说可能知道，操作系统呈现给我们的物理设备分离。但我们无法看见文件系统或更深层次的内容。因此，我们在进行系统级备份时所关心的一切一致性问题，可能会在此层级被放大多倍。我们不仅无法知道一个特定的应用工作负载是否已经静默，而且我们甚至无法告诉系统管理的文件系统、文件锁或逻辑卷管理器，我们正在尝试读取块设备。所以，如果我们仅在这个层级进行备份，我们实际上是完全盲目的，仅仅从虚拟磁盘中读取块数据，而没有理由相信这些数据处于一致状态，而且没有任何信息告诉操作系统有任何事情发生。如果我们仅仅这样做，操作系统根本无法知道事情正在发生。

不需要多想就能意识到，没有代理的平台级备份几乎是不可能实现的。我们当然可以关闭虚拟机，并在其关闭时对存储层进行备份。操作系统的完全关闭过程实际上是确保完整静止和一致性的最佳方式。我们如何在不直接拔掉虚拟插头并让自己进入崩溃一致性状态的情况下，从平台级别关闭虚拟机呢？出奇的是，使用了代理。

这就是平台级（即*无代理*）备份的最大秘密：它们使用了代理！必须使用代理。在现实世界中，直接从任何低层服务进行备份是完全不可靠的。但我听到你在低声说*我做过这种事，每个人都做过，而且我们不安装任何代理*。

在虚拟化环境中，使备份代理难以识别的原因是因为我们自动和普遍地安装它们，以至于我们不会去思考它。在某些情况下，这些代理程序直接构建到操作系统中。根据您使用的平台不同，它们有不同的名称。最著名的是 VMware Tools，因为 VMware 使用它，并且安装过程众所周知。KVM，Linux 世界中的主要虚拟化管理程序，不仅将客户机代理内置到大多数基于 Linux 的操作系统中，而且实际上直接内置到 Linux 内核中！因此，您实际上永远不需要看到代理，尽管它几乎总是存在的。许多 Linux 发行版也采用了 Hyper-V 的等效代理称为 Linux 集成服务，虽然它们没有内置到内核中，但通常会自动包含在操作系统中。

在这些情况下，我用作示例的虚拟化管理程序供应商的代理程序并不严格是备份代理程序，它们是用于协调虚拟化管理程序和操作系统之间活动的通用代理程序，但实际上，这只是一个更高级的代理功能，没有其他更多内容。从各种可能意义上来看，它们都是代理软件，必须安装到操作系统中才能工作，就像更传统的备份代理程序一样，有时它们包含在操作系统中，有时是第三方附加包。

这些代理通常是一组高性能驱动程序的一部分，用于使完整虚拟机高效运行，因此很少被忽略。它们提供了一个关键通道，允许底层平台层与操作系统层甚至更高层通信。这种通信通道用于向虚拟机发出优雅关闭命令，以及通知其需要使文件系统静默或对卷进行快照。理论上，这种代理甚至可以钩入特定应用程序，尽管在 Linux 世界中这主要是理论性的。

进行平台级备份有重要的优势。如果我们考虑这些备份系统的工作原理，我们很容易看到预期将是对整个文件系统容器或块设备进行块级镜像拍摄。这样做的真正优势在于其完整性。如果我们进行镜像级备份，而不是文件备份，我们有机会获得整个设备，而不仅仅是其部分内容，这将使我们能够完全恢复系统，而不必部分重建然后再恢复。

### 磁盘镜像

当我们谈论文件级备份的基本机制时，最终讨论的是某种形式的文件复制。文件 X 存在于我们想要保护的文件系统中，为了保护该文件中的数据，我们将该文件复制到另一个位置，以便数据可以同时存在于多个地方。简单明了。

在平台级别进行完整块设备复制时，我们称结果复制为镜像或磁盘镜像。理论上，我们可以从一个物理块设备复制到另一个物理块设备，或者至少从一个虚拟块设备复制到物理块设备。在几乎所有实际情况下，特别是涉及备份的情况，我们实际上是将块设备复制到一个文件中。该文件称为磁盘镜像，有时奇怪地被称为 ISO 文件。

我们之所以称之为镜像，是因为它本质上是任何给定时刻整个磁盘的图像。我们还使用“快照”一词来指代同一操作。在常规英语中，快照就是镜像。这些术语几乎可以互换使用。在计算中也是如此。有时一个术语被用来暗示与另一个不同的含义，但没有被接受的定义使它们不完全重叠。

在日常使用中，“镜像”通常指存储为常规文件的镜像，例如 ISO 文件，并包含原始文件系统的完整副本。而“快照”通常指几乎相同的情景，但逻辑卷管理器创建的部分镜像文件与原始文件以某种方式连接，并且可能仅包含两者之间的差异。但该文件通常用于创建一个独立的镜像文件，否则与镜像文件无异，但仍被称为快照。这导致了一个不恰当的情况，即两个相同的文件可能基于不可追踪和不可知的历史有不同的命名。显然，关于这些文件的常见误解导致了对相同事物不同名称的使用。尽管如此，镜像和快照是重叠的概念。

因为磁盘镜像包含块设备的全部内容，所以可以直接用于恢复整个块设备，甚至在没有任何了解该块设备应包含什么的硬件上也可以。如果备份了 Linux 服务器并进行了恢复，整个系统都将恢复，即使它被加密。镜像不会绕过加密，但加密也不会改变镜像过程。

大多数虚拟化平台，即使使用外部存储设备如 SAN 设备，也会将属于虚拟机的磁盘存储为一个或多个磁盘镜像文件（通常不是原始 ISO 文件而是一种高级格式）。这表明镜像文件是一个完整的块设备（虚拟），因此可以在任何其他块设备使用的地方使用。这在我们想要谈论恢复数据时非常重要。如果我们有一个完整的镜像文件，在我们能够访问的地方就不需要恢复。我们可以根据需要直接挂载它。

镜像备份在性能方面可以更接近硬件，因此具有一些重要优势。但也存在一些显著的劣势，所以并非一切都很完美。

允许系统在仍然处于活动使用状态时冻结某一时刻并与之一起工作的先进快照技术对于允许主要备份活动系统具有重大意义。获取完整系统镜像是处理备份的最简单过程，因为我们不必考虑备份的内容，只需获取所有内容。我们不仅可以获取整个操作系统，还可以获取单个虚拟化层上存在的每个操作系统的所有内容。我们甚至可以对关闭电源的虚拟机以及正在运行的虚拟机进行备份。系统级别的备份必须针对每个系统进行，只能在系统运行时完成，并且只有在非常有限的情况下才能有效地进行完整备份，甚至更少的情况下才能找到一种方法以提供可以在相同方式中恢复的完整块级重新创建系统。

平台级别的备份现在已经流行了十多年，原因充分。它们高效，可以防止选择正确要备份的数据失败，如果必要，可以由不同的团队处理，而不是标准的系统管理员，而且可以在大规模上实施，基本上不需要进行其他工作（除了需要的代理部署和备份软件部署到虚拟化层）。平台级别的备份完全符合大多数组织希望工作的方式，并且对支持供应商来说，作为服务提供是非常容易的，无需进行任何尽职调查。

平台级别的备份也有很多注意事项，因此我们需要意识到为什么大部分时间我们可能不希望专注于它们。由于其盲目性，通常需要最大的存储容量来存储备份，因为它们往往包含许多不必要的数据，比如系统文件。这种膨胀还意味着，不论是出于存档目的还是为了将文件移到恢复所需的位置，移动生成的镜像都可能比通常所需的时间长。仍然需要部署代理。系统几乎普遍被误解，因此很容易犯错，就像许多对于普通用户来说过于复杂而被视为万灵药而不是考虑的另一种工具。

平台级别备份对于平静状态确实是一个真正的挑战。即使所有代理都正确放置，这些代理的性质是它们暴露的选项较少，并且在应用层面的钩子较少，这意味着从该层面获取的备份有较高的风险，可能只是崩溃一致的。操作系统文件将受到保护，因为几乎总是通过代理与操作系统本身进行适当的通信，但几乎没有应用工作负载会受到保护。

平台级备份很引人注目且酷炫。它是供应商通过做最少的工作来利用备份恐惧的简单方式；它是一条容易获得大幅利润的捷径，而任何实际的风险都被推给了那些很少做功课的客户。它让客户感觉安全，因为这些风险太复杂，甚至更多的 IT 从业人员都无法理解，它让他们可以告诉自己，他们得到了保护。无知让人晚上睡得安稳。

平台级备份是一项强大的工具，是现代的奇迹，但它仍然只是一个机制，一种方法，当然也不是每次都适用的。

这只是关于两种非常简单的备份机制的许多信息。我们需要有这个扎实的理解，以便能够继续讨论备份和恢复领域中许多存在的概念。

# 快照、归档、备份和灾难恢复

有许多技术要么被误解为备份，要么可能是备份的组成部分。在这一部分中，我想拆解这些基础知识，确保我们理解它们是什么、为什么重要、如何使用它们，以及何时我们自己应该利用它们。

## 快照

在上一部分中，我们讨论了如何拍摄块设备镜像，镜像和快照实际上是一样的，使用快照这个术语时人们通常意味着什么，而不是使用镜像这个术语。现在，我们将真正深入探讨快照。

快照，正如人们通常使用的术语，是在存储中做一些非凡事情的惊人工具。快照通常用于抓取块存储设备状态的瞬时镜像。在这种情况下，术语“快照”非常形象。

对于大多数快照系统来说，正如大多数使用该术语的人所理解的那样，拍摄的快照会与原始数据一起保存在本地存储中，并且两者是内在联系的。假设是快照只包含与原始数据之间的变化或差异。实现这一点的方法有多种，但本质上，最终结果是相同的：一个比原始数据小得多、创建速度快、但能够完美地重现拍摄快照时块设备状态的文件，或者说是*快照*。

这种过程的显而易见风险是，快照假定*仅仅*包含了拍摄时与原始数据之间的差异。因此，这里并没有对系统故障提供保护。如果原始文件损坏或丢失，快照将无效。快照可能是一个有效的保护机制，可以防止误删文件、恶意软件或勒索软件，因为它允许系统轻松、快速地恢复到未受损害的状态。这是一个重要的价值，早期的快照机制通常专门用于防止文件删除和覆盖错误。但由于它们与原始数据紧密耦合，真正的备份所能提供的最重要的保护在这里完全缺失。

这种风险导致了“*快照不是备份！*”的口号。你到处都会听到这个。确实，它们单独并不是备份。不过，快照是备份的重要组成部分。过度强调这一口号导致许多人错误地认为，使用快照作为来源创建的备份不是真正的备份。

### 快照类型

快照是一个通用的概念，可以通过多种方式实现。写时复制和重定向写入是两种常见的快照机制。几乎你遇到的任何生产系统都会利用这两种机制之一。理解这两者有助于深入了解快照的思维方式和设计，并解释它们为何如此强大。

首先，写时复制（有时称为 COW 快照）。当启动写时复制快照时，一个块设备本质上被冻结在某个时间点。通常这是理论上的，因为实际上什么也不会发生，直到尝试对存储进行更改时，才会有任何操作发生。

当有人尝试向块设备写入新数据时，存储系统会将即将写入的任何块复制到新位置，然后用新数据覆盖原始块。当然，在所有这些复制操作进行时会有性能损耗，并且随着更改的积累，复制数据的大小将不断增加。因此，虽然我们第一次启动快照时它的大小为零，但只要我们继续写入块设备，它将不断增长。

写时复制快照很受欢迎，因为它们被销毁时几乎没有任何代价。删除快照所需做的只是删除额外的数据。在这个过程中，工作块存储不受影响。即使有一个进程在监控原始块设备，它也永远不会知道在某个地方存在快照，因为与快照相关的所有内容都与原始块设备外部有关。所以，当快照不再需要时，清理它基本上没有任何代价。

另一种替代方法——重定向写入——通过操作指针来实现，稍微有些不同。这些指针指向存储设备的所有数据块位置。当数据块通过写入新数据进行修改时，系统不会修改原始数据块，而是将新数据写入新位置，并仅仅将该数据块的指针指向新位置。这样，写操作对数据块的任何影响基本上可以忽略不计。影响不是零，但极低，尤其是相比于写时复制，后者在正常操作中需要移动和重写现有数据。

使用重定向写入，我们可以获得一些非常有用的功能，比如能够维护存储设备几乎无限的版本。事实上，有些存储设备会将所有操作都视作重定向写入，并不将变化视为快照，而是将整个存储系统看作一个永恒的快照机制，以便存储的任何部分都可以回滚到任意时间点。

重定向写入（Redirect on write）看起来一开始非常完美，但它的警告是，你会随着时间的推移积累越来越多的数据，如果你保存数据的中间版本，而不是仅仅保存一个时间点的版本，数据的增长可能会变得非常惊人。如果你需要清理这些数据，清理指针系统的过程可能会变得相当复杂，并且会带来性能损失。

写时复制（Copy on write）通常是处理短期快照时的最佳选择，例如在执行重大系统更新之前创建快照，并且需要在更新之前的时刻进行回滚，或者在备份操作中为了将数据发送到外部而创建快照。在这些任务完成时，快照将被销毁并忘记。写时复制的核心在于快速创建和销毁整个快照，而不是保留它，因为写时复制的代价只会存在很短时间，而且销毁过程没有痛苦。

当我们打算长时间保留快照并希望多个快照相互叠加时，重定向写入非常强大。因为在使用过程中几乎没有代价，只有在销毁快照时才会产生真正的代价，它的作用恰好与写时复制相反。

所以：重定向写入可能是将快照用作持续数据保护的最佳选择，而写时复制通常用于像备份软件这样的系统中，用来生成数据集。

即使我们没有任何特殊的备份软件，我们也可以使用存储系统拍摄的快照，并将其作为有意义的手动备份的构建块。这比听起来要简单得多。在最简单的示例中，假设我们有类似于挂载的磁带驱动器可以在同一系统上写入数据，我们只需利用存储系统将快照挂载为不可变版本的块设备，然后将其复制到磁带上。

当我们这么做时，源快照文件可能非常小，理论上甚至为零字节，但发送到磁带（或任何其他存储介质）的却是整个块存储设备的完整副本，且其状态与拍摄快照时的状态一致。这就是快照技术的奇迹。在使用极少的、通常是微不足道的额外存储空间的情况下，自动且通常完全透明地重新创建或恢复原始块设备的状态。

当我们这么做时，我们面临着一个语义上的挑战：我们该如何称呼那个不再位于原始媒体上的副本？当然，它是一个镜像，但通常我们仍然称之为快照，因为它在各方面都与快照相同，并且代表着在某个时间点的块设备快照。所以，当我们这么做时，“快照不是备份”这一说法就变得不成立了，因为我们可以拥有一个既是真正的备份又是快照的副本。正确的说法应该是快照通常不是备份。然而，快照确实经常作为备份使用，甚至更常作为备份的基础。

由于快照提供了在某个时刻（或多个时刻）冻结块设备的能力，并且提供了一种利用该冻结时刻的方法，而无需中断块设备进行未来操作，因此它非常适合作为创建备份源的手段，同时允许正在运行的系统继续运行。然而，必须注意的是，传统的快照操作都是基于同一个底层物理块设备进行的。因此，虽然我们不需要停止存储设备来执行快照操作，但我们确实会使用原始设备的 IOPS（每秒输入/输出操作次数）。我们的操作并不是零开销的神奇过程，但它们的开销远低于其他备份机制。

由于这一切，快照成为了一个流行的工具，被广泛用于幕后和底层，使得许多现代备份成为可能。实际上，每个虚拟机监控器或存储设备级别的备份（平台备份）都是由快照提供支持的。在许多情况下，即使是系统级备份（即操作系统内的代理式备份）今天也使用快照，无论是 Linux 系统还是其他操作系统。

## 存档

与备份密切相关，但又有重要区别的是档案。这两个概念经常被混淆，甚至在企业圈子中也不例外。理论上，只要提到这两个名称，问别人，任何人，描述他们对备份和档案的看法，就足以让他们自己认识到这两者并不相同。但将*我能定义它*转化为*我能清晰地表达并内化这两者的不同*并不是自动的。

备份，稍后我们将进一步定义，至少是一个副本。这一点应该很清楚。我们在英语中使用这个术语就是指这一点。我们称之为我们的*备份副本*。如果你表达得清楚，大家都会同意，如果它不是副本，那么它就不是备份。

档案是不同的。归档某个东西并不意味着没有副本，我们有时甚至会说*档案副本*，但在档案的定义中并未暗示需要有副本。档案指的是长期存储，通常假定其成本较低，访问更困难，或其他方式*归档*。长期存储，但不一定是随时可以获取的。

档案存储可以简单地理解为一个第二硬盘，数据不会发生变化。也许它是离线磁带，也许是冷存储云。档案存储并不一定意味着存储的性能或可访问性比常规存储差，但通常情况下，它们的性能确实会更低。

大多数组织使用档案存储作为一种低成本手段，以维持对那些不再需要经常访问的数据的紧急或偶尔访问。这种情况很容易举例说明。旧数据可能是去年的财务记录、旧收据的副本、已经处理过的材料的视频片段、旧发票、旧会议记录、已完成项目的蓝图、旧项目文物，你可以想象到。这些企业会产生大量的数据，虽然他们从未预料到需要再次使用这些数据，但也不能完全删除。

假设是，如果档案中包含任何重要数据，它也需要像任何其他存储一样进行备份。经验法则是，任何值得存储的东西都值得备份。如果你觉得备份的成本或努力太大，那么你应该仔细重新评估是否继续存储这些数据。为什么还要为它的存储付费呢？

在正确规划的存储基础设施中，这正是发生的事情，而存档与备份结合起来时，存档是数据保留和保护的强大机制。由于存档一词意味着数据不会更改，这意味着数据不应该被锁定，并且备份可以尽可能简单。处理存档时不存在备份过程面临的复杂性。通常也不需要定期进行备份；如果存档是静态的，可能只需要一个备份就足够了。或者如果存档很少更改，也许每月或每年进行一次备份可能就足够了。

### 将备份转换为存档

一个常见的情况是备份变成存档。这种情况比你想象的要频繁得多，发生的原因大多数人都能理解。我曾经看到最大的组织中发生过这种情况，而且没有政策来避免这种情况。

在正常情况下，所有想要存储的数据都是实时的，并位于其适当位置以供使用和正常使用。对这些数据进行备份，以防发生灾难，系统可以恢复。在发生灾难之前，所有数据都存在于原始位置以及一个（或多个）备份位置中。这种位置的冗余性是使副本成为备份的原因。从技术上讲，如果原始存储位置失败，主要备份（可能是唯一的备份）将停止成为备份，并且暂时成为数据的主要来源位置。我们从不这样说，因为我们都知道“从备份中恢复”的含义，但是在原始存储消失的那段时间内，第一个备份现在是该数据的主数据，而不再是备份。它可能有自己的备份，通常我们会这样做，但是只有当有非备份数据时，备份才能成为备份的备份！很难解释，但这是一个关键的概念。

这很重要的原因是一旦对数据进行了备份，就很容易感觉我们的备份可以保护我们，因此我们可以删除原始数据。因为已经有了备份，我们觉得我们可以这样做。这里的问题是，如果我们删除了原始数据，备份（或至少是第一个备份）就不再是备份，而是存档！在大多数情况下，如果假定的主源位置不再存在，可能没有机制来进一步备份这些存档数据。甚至可能没有任何手段来定位它。

我亲眼见过这种情况发生在现实世界中。每天的备份任务都会运行，而终端用户却默认认为他们不需要存储任何他们需要的数据，即使法律要求保留并备份数据在主系统上，因此他们会在创建后立即删除数据，假设他们的数据受到备份系统的保护。然而，这种计划存在一些关键缺陷。

首先，通过删除原始数据，任何现有的备份都会成为源位置而不是备份，并且仅仅是基于磁带的归档。考虑到数据有法律要求需要保留和备份，这违反了法律的保留要求。

第二，备份机制是分阶段的，有些备份保留数年，有些保留数月，有些保留数周。因此，如果数据碰巧存在于保留数年的运行中，那么包含相关文件的那一盘磁带很可能可以读取以检索数据，但如果数据仅存在于每周作业的备份运行中，即使是归档版本也会在几周后磁带被覆盖时被删除。

第三点，与档案情况无关，经常是数据在每日备份作业运行之前就已删除，这意味着数据在没有任何备份或档案的情况下立即丢失了。结果是从未存在过备份，偶尔某些文件可能会幸运地保留几年，但大多数文件要么根本没有被归档，要么只是短暂地被归档，并在几周后的磁带重用时被删除。

考虑到需要保留七年的要求，再加上对该保留的备份，很容易看出流程有多大偏差，因为最终用户认为他们可以有意删除原始文件，因为他们认为魔术备份过程某种方式在保护他们。备份团队认为所有数据都会保持七年，并且如果有任何文件丢失或损坏，最终用户会立即通知备份团队进行恢复。他们从未考虑到最终用户会自行销毁数据并且从未通知备份团队数据已被销毁，因为为什么会这样呢？

很容易看出我们可以通过许多情况下最终用户的行为，无意中将我们的备份位置转换为档案位置，并且由于我们不理解备份过程的复杂性，可能会丢失数据。如果数据不会在主要位置永久保留，那么通常需要非常复杂的过程来确保删除的安全工作流程。

档案是降低成本并保持我们主线存储瘦身的强大机制。也许我们仅使用档案来降低成本。在许多情况下，通过将多余的数据远离我们顶级存储层，可以让我们投资于更快速但更小型的系统，用于我们日常使用的数据。

档案也可以应用于文件的部分。当然，有时甚至数据库也使用混合存储位置，以便能够将经常访问的表或表的部分存储在最快的存储上，而很少接触的表或表的部分可以存储在成本更低的较慢存储上。这可能在数据库引擎内部自动进行，或者应用程序可能使用多个数据库系统，并在应用程序层面在它们之间移动数据，例如。

档案是一个有用的工具，但绝不能替代备份。

## 备份

很难相信在没有实际深入探讨我们说“备份”时确切含义的情况下，我们已经走了这么远。与许多事物一样，有时候直接进入定义是很困难的，因为我们需要考虑的事情实在是太多了。

在最基本的层面上，备份是原始数据集的副本。我们在上面已经讨论过这一点。如果数据没有变得冗余，那么它就不能算是备份。这是难题中最明显的部分。

接下来，数据必须存储两次。这意味着硬件必须存在不止一次。

在许多情况下，我们可以将其与纸张或其他物理形式的数据存储进行比较。如果我们有一张重要代码的纸张，我们会感到有必要将这些数据复制到其他地方 - 进行备份。我们知道纸张容易被弄脏、烧毁、丢失或者洗涤机洗过。

或许备份要求中最令人困惑的部分是它必须与原始材料强烈解耦。强烈解耦是一个涉及一些观点的术语，这使得确定适当的解耦水平有些困难。对于一个组织来说足够解耦的程度，对另一个组织来说可能还不够。

当我们使用术语紧密耦合时，我们指的是原始数据和数据副本之间存在连接的情况。在最紧密耦合的情况下，类似快照的概念，任何发生在原始文件上的事情也会影响到快照。这是完全耦合的情况。稍微松散耦合的情况可能是将副本存储在同一物理设备上。副本与原始数据之间的距离越远，它们的耦合性就越低。

耦合可以涉及到更多的内容。它还可以包括诸如存储在共享凭据（如用户名和密码）系统上的概念。耦合可以很复杂，并且没有单一、明确的描述方法。但是，当我们谈论保持备份高度解耦时，通常意味着一些事情，例如：完全不同的硬件和媒体、物理上分离的位置以及断开的身份验证。

每增加一步解耦的背后想法，是让任何可能发生在原始数据上的事件，几乎没有可能同时发生在备份数据上。这可能是文件意外删除、存储设备故障、勒索病毒攻击、洪水或火灾。丢失原始数据或无法访问它的方式有很多种。我们必须尽可能广泛地考虑这些可能性，并评估多少解耦，以及什么类型的解耦是合理的。没有任何两个系统能做到完全解耦，但我们可以很容易地将解耦做到一个实际的水平。

第一步很简单，很少有组织犯错误尝试将备份文件放在与原始数据相同的媒体上。然而，这种情况确实发生过。使用同一硬盘的情况非常罕见，但尝试在同一设备内使用第二个硬盘却悲哀地相对常见。当然，正如你所想象的那样，许多会导致计算机中一块硬盘丢失数据的事件，可能也会导致另一块硬盘上的数据丢失。机箱内的火灾、极端震动、洪水、断电、盗窃、由于各种事件导致的数据损坏或恶意攻击，都很可能同时摧毁备份数据与原始数据。这几乎完全否定了备份的意义。

如果用物理世界来做类比，我们可以比作纸张。你有一张存储关键数据的纸。你把这张纸放在文件柜里。你担心保护这张纸免受不好的事情的发生。你可以使用一张纸，将信息写两遍。你可以在同一个文件夹内同一个文件柜里放第二张包含数据的纸。你也可以把副本放在第二个文件柜里的独立纸张上，文件柜与第一个文件柜相邻。或者，你可以把纸张的副本放在另一个建筑物的独立文件柜里。

在这些例子中，很容易看出从紧密耦合到高度解耦的演变。当共享一张纸或两张放在同一个文件柜里的纸时，风险是显而易见的。几乎任何损坏第一份副本的情况都会同时影响第二份副本。将纸放在第二个文件柜中，至少提供了一定的保护，因为两个柜子可能有不同的钥匙，一个柜子掉入水中*可能*不会影响另一个柜子，一个文件损坏*可能*不会影响另一个文件，等等，但很容易看出它们的风险仍然是耦合的，只是没有那么紧密。

通过将文件柜放置在完全不同的建筑物中，可能是在不同的楼层，甚至是不同的城市，那么发生洪水、火灾或盗窃，能够同时摧毁原始数据和备份的可能性极低。也有可能发生火山事件、核战争或陨石撞击，即便备份和原数据分别存放在几英里之外，它们仍然可能被摧毁。这就是为什么我们说强解耦，但绝不完全解耦。

在备份中，我们必须考虑我们的数据解耦的程度，以及进一步解耦所需的成本。我们还必须考虑解耦的有效性以及它对我们业务的影响。这是一个复杂的问题。然而，对于大多数企业来说，我们希望备份具有物理距离、各种介质、身份验证的分离和多个副本。备份包含的内容以及它们如何使用在这一过程中起着重要作用。

这里没有简单的最佳实践，甚至常见的经验法则在基本的极限之外也很少适用。最佳实践要求：

最佳实践：如果数据值得存储，它就值得备份。

最佳实践：备份需要与原始数据高度解耦。

备份的可能性范围如此广泛，以至于我们必须全面评估每个企业的需求，在许多情况下，还需要考虑个人工作负载。在某些情况下，像整个操作系统的备份，我们的主要关注点可能是硬件故障时的快速恢复，而备份的实际内容可能并不重要。在另一些情况下，备份可能包含大量高度专有的数据，确保这些备份的安全性，确保它们不会落入错误的手中，成为优先考虑的事项。

### 为什么磁带仍然重要

在谈到备份时，磁带介质的问题不可避免地浮现出来。通常你会听到两种回应：磁带太棒了，我总是使用它；或者磁带已经死了。意见极为分歧。

曾几何时，磁带几乎是唯一的备份介质选择。固态硬盘还不存在，而硬盘的每兆字节价格极为昂贵，且其使用寿命和抗震能力都非常差。磁带是唯一既实惠又耐用的介质选择，尽管当时它也并不好。

在过去的几十年里，一切都发生了变化，正如它经常发生的那样。硬盘、固态硬盘以及为你托管这些服务的公司都已经变得非常标准化。驱使我们使用磁带的主要因素已经消失，我们有很多可行的选择。这使得许多人专注于这些新选择，而没有跟上磁带技术的进步，但和其他所有技术一样，磁带技术也已经取得了相当显著的进展。

磁带几乎是专为备份而设计的介质。它可以以极高的速率移动线性数据，存储每兆字节的成本非常低，并且具有出色的保管耐久性和抗震能力。磁带自然地，除非你将磁带留在驱动器中，否则只需从驱动器中弹出磁带，它就会与原始系统解耦。你甚至可以拥有一个远程磁带系统，通过自动磁带弹出使技术和物理解耦完全自动化！

磁带的优势在于允许每个磁带至少部分地与其他磁带解耦。磁带可以存储在不同的位置，并且可以使用多个磁带来存储数据的多个副本。在某些情况下，磁带组可能会存放在一个盒子里，实际上*重新耦合*了磁带。如果磁带分开存储，则不仅源数据与备份之间可能实现显著的解耦，备份内部的数据之间也能实现解耦！

磁带并不完美。它需要物理装载磁带才能恢复，并且在查找备份中深埋的单个文件时表现很差。磁带在备份或恢复大量连续数据时表现出色，但一旦开始搜索特定数据，性能就会迅速下降。一些公司通过使用机器人和磁带库来解决磁带管理中的人工问题，但这实际上将磁带重新“上线”，并可能将其与原始数据重新耦合，至少部分耦合，削弱了其保护层。没有机器人或磁带库的直磁带有一个好处，那就是需要“黑客”攻击一个人，除非攻击计算机，才能同时摧毁原始数据和备份。

磁带足够有用，甚至一些在线云备份提供商也将磁带作为其存储解决方案的一个组成部分。磁带在现代世界中占有重要地位，在可预见的未来也将如此。

当然，备份可能不是针对某一工作负载的单一解决方案。一个工作负载或系统可能需要多个备份。一个可以本地存储、耦合适度的备份，用于发生意外或硬盘故障时快速恢复。远程备份到磁带或不可变云存储，用于长期、高度解耦的数据保留，以应对勒索软件攻击或整个站点丧失的情况。

解耦对备份的功能性或有用性至关重要，以至于我们必须将其纳入备份定义中，即使我们不能完全清楚地定义什么构成足够重要的解耦。这是因为对一个组织或情况来说足够的标准，可能对另一个组织或情况来说并不适用。对我来说，这意味着我们的解耦定义必须是主观的。利益相关者需要定义备份应防护的内容，并根据此定义必要的解耦程度。

不能忽视的是，现代勒索软件已经成为推动组织开始分析传统备份耦合水平的一个驱动力，因为突然之间，备份具有任何实际耦合级别的影响和威胁变得非常剧烈。到目前为止，勒索软件技术积极采用策略，尽可能勒索备份本身，并使用隐藏其活动的技术，阻止备份在系统加密时提供保护。备份仍然是防御此类威胁的最佳手段，但确保极高的解耦级别通常需要像不可变存储和将备份物理断开连接等技术，以便没有计算机能够在没有人工干预的情况下访问它们。

### 如果你无法恢复，那就不是备份。

我听过很多次这句话，我仍然很喜欢。简单来说，如果在灾难发生时你的备份无法恢复，那它真的算是备份吗？在某种程度上，这种说法有些夸张。备份可以失败，这种失败可能与原始工作负载的失败时刻重合。但这种情况应该在统计上非常不可能，如果发生了这种情况，应该有一个极为明显的巧合。

许多人想表达的是备份测试的必要性。备份非常复杂，了解使用可用机制的速度、过程和效果是任何备份过程中的一个非常关键的环节。如果你从未测试过你的系统，你必须假设它们不会起作用。即使你已经测试过它们，最好还是最近进行过测试。有些备份系统甚至会每次自动进行恢复测试，以展示备份的有效性。

备份测试可能会产生误导。像许多其他数据保护机制一样，如 RAID、冗余电源供应或故障切换 SAN 控制器，我们通常在一个可预测、完美的环境中测试备份，但这种测试通常并不能反映在紧急情况下恢复所需的真实情境。备份测试通常是在系统空闲或比平时慢的情况下进行的，且通常会反映出最佳的情况，从而导致几乎总是通过测试，即使是在现实世界中几乎总会失败的系统上。考虑一下不利的条件，比如正在故障的系统（而不是完全失败的系统）、高负荷操作或不一致的数据状态（崩溃一致性），这些情况在测试场景中是无法反映的。

备份可能看起来是一件简单的事情，每个备份供应商都会将他们的产品呈现为消除了你对数据理解的需求。供应商希望你对他们的盲目信任，认为他们能够做不可能的事，并让你打开钱包、单纯地期待一切顺利。作为系统管理员，我们的任务是理解我们的数据，了解我们的备份机制如何工作，确定我们组织和工作负载的一致性与耦合需求，并组建一个符合或超越这些需求的备份解决方案。

## 灾难恢复

最终，任何备份机制的目的都是为了实现灾难恢复。灾难恢复是我们都希望永远不必面对的事情，但它却是我们职业生涯中最为重要的时刻。灾难情境是我们比任何时候都更能展现价值的时刻。在灾难来临时，你能够冷静从容地应对，掌握如何将工作负载恢复上线的知识，并能够适应任何变化或突发的挑战，这一点至关重要。灾难中的表现可能意味着数百个百分点的薪资差异。

随着我们深入了解了各种备份类型和方法，现在自然地出现了许多恢复方式。在灾难恢复的规划过程中，我们必须将所有这些因素考虑在内，因为我们的规划过程会因此发生巨大的变化。

如果我们使用基于镜像的备份方法，那么假设是我们将通过一次性恢复整个块设备镜像（或多个镜像）来进行恢复。这在灾难恢复中有一些显著的优势，因为我们只有一个步骤：恢复整个系统。在某些情况下，我们的恢复机制将会一次性自动恢复所有系统，而不仅仅是单个系统！这是一个非常诱人的前景。这个方法的警告是恢复通常较慢，并且一般只是在崩溃一致性方面达到要求。以最快的速度恢复并确保可靠性是此方法面临的最大挑战。

使用基于文件的备份时，我们几乎总是需要首先恢复一个空白的操作系统，通常是模板或原始构建，然后再将单个文件恢复到最初的位置。理论上，这种方法比镜像基础的完整恢复更快，但在实践中很少如此，因为从传统方法构建基础操作系统所需的时间。虽然从现代方法理论上可以构建基础系统，但这通常并不会发生，因为如果这样做，你就自然会转向 DevOps 风格的备份。然而，这两者在概念上开始重叠，你可以将基于文件的备份机制与传统的文件恢复相结合。当然，变化在于，文件备份将专注于有意义的系统数据，而不是盲目地备份任何东西。

最后是完整的 DevOps 风格恢复。这更为复杂，因为没有明确的单一定义。这里的假设是，由于任何数量的自动化构建机制，基础操作系统的重建几乎是瞬时完成的。而且数据恢复将被大幅度最小化，以便也能以极快的速度进行恢复。

当然，所有这些操作将与我们稍后讨论的优先处理操作同时进行。规划和时间安排这些操作，使其广为人知，流程经过测试，并且在不同场景下恢复时间可预测，为灾难情景中的决策提供了宝贵的信息。

灾难恢复规划不应仅仅是对单个工作负载的孤立测试，也不应仅仅测试数据丢失。不同的组织面临不同的风险，测试多种类型的场景非常重要。我们在考虑灾难恢复时，通常会想到数据恢复，但这可能并不是我们面临的挑战。如果我们的工作负载分布在多个位置，我们可能需要考虑如何在较慢的连接或不理想的数据中心位置下工作。灾难恢复测试可能涉及测试在备份系统上启动工作负载、故障切换集群，或从备用数据中心运行的能力。

灾难恢复的最佳实践是始终测试你的场景，并定期进行测试。永远不要盲目相信我们的备份、规划、网络或数据中心会正常工作。我们不仅需要测试计划背后的技术，还需要测试这些计划的操作流程。

现在我们已经讨论了备份相关的机制和术语，是时候真正探讨现代的 DevOps 世界如何重新定义我们的备份操作了。

# DevOps 世界中的备份

在本书的早期部分，我们讨论了像 DevOps 和基础设施即代码等现代概念对系统管理领域的影响。你可能会想，这些现代概念是否对备份和灾难恢复领域有潜在影响。好问题！如果章节标题没有透露答案，我现在来给你提示：是的，它们确实有影响！

传统上，我们认为恢复数据要么是非常老式的方式——只恢复单个文件，要么是较现代的方式（过去二十年内的做法）——恢复整个系统，包括操作系统及所有相关文件。我们已经习惯了这种方式，以至于常常很难从其他角度来思考恢复系统的问题。

在超现代的 DevOps 风格世界中，系统通过自动化构建，并在代码或配置文件中定义，我们必须开始以全新的视角看待几乎所有事物。当系统可以通过标准的非灾难性流程自动、轻松且快速地构建时，恢复这些系统的需求就完全消失了。试想，如果你可以用更少的钱、更少的时间、更可靠地将一辆全新的、完全相同的汽车送到你的门前，而不是在事故后修理旧车——你就永远不会浪费时间去恢复一个损坏的东西，而是直接选择拥有一个全新的完美副本。

## 版本控制系统

在谈论备份时，特别是与 DevOps 相关时，我们还应该谈论版本（或修订）控制系统。版本控制系统，如 GIT、Mercurial 或 Subversion，虽然本身不是备份系统，但它们作为一种机制，用于将系统上一些最重要的数据同步到另一个位置，备份通常会发生在这个位置。

在备份的上下文中谈论版本控制时，可能会有些困惑，因为在某些情况下，我们可能把操作系统视为主位置，而版本控制系统可以用于将配置文件复制到另一个位置，从那里它们可以通过任何常见的备份机制轻松地进行备份。

因为版本控制系统不仅存储当前数据，还存储文件的历史版本和变更，它们实际上变得不可变，因此在备份样式的情境中非常有用，因为备份机制不需要处理随着时间推移的版本问题。版本控制系统保存了文件历史中的所有版本和更改。因此，对整个版本控制系统的备份自动包含了所有文件的更改。因为这一点，终端用户意外删除文件、文件的错误更改、对数据的勒索攻击等问题变得无关紧要，因为能够恢复到坏更改发生之前的状态是内建的功能。

版本控制系统通常不仅可以用于在一个端点和版本控制服务器之间复制文件（及其版本历史），还可以复制到多个额外的端点。例如，一个系统管理工作站或跳板机（我们将在下一章中描述）可能包含公司中每个 Linux 系统的配置文件的完整副本，且该副本与任何服务器或备份系统分开。即使由于巨大的灾难丧失了所有官方数据副本，单个工作站也可能能够重建整个文档集。

这些类型的系统已经在非备份相关的场景中广泛使用，并且在 DevOps 领域被视为*必备*工具。我们可能已经在一些系统管理任务中使用它们。即便是在没有 DevOps 流程的系统中，考虑到数据保护的需求，这些工具也可能被用作版本控制。

即使是最传统的（意味着尽可能远离 DevOps）Linux 系统，也能从其配置文件使用版本控制中受益。如果组织认为不必要，甚至无需为版本控制建立自己的基础设施。像 Gitlab 和微软通过 GitHub 提供的企业托管版本控制系统，具有丰富的功能和访问控制系统，且免费提供。

一家拥有传统遗留系统的小公司，想要引入版本控制保护的话，在一个假设的例子中，简单地进入 `/etc` 文件系统并将其添加到远程 GIT 仓库，然后进行推送。瞧，所有的数据都得到了保护，快速而轻松。设置一个 `cron` 作业，每隔几个小时推送任何额外的更改，您就能自动化一个强大的备份系统，几乎不需要任何努力，且肯定是零成本。

版本控制系统是开发世界中那些不为人知的秘密之一，它们已渗透并被许多其他行业所接受。任何大量使用文本文件的系统，都应该尽快加入版本控制的行列。版本控制是提升数据保护水平的最简单方式之一。尽管这个简单的例子可能没能体现出其所有优势，但恢复一个系统也存在一定的风险，可能会恢复到已损坏的系统，甚至更糟的是，恢复了感染或 rootkit。干净的重启可以消除这些风险，确保您从头开始时拥有安心。很可能是最快的路径，能够以最可重复和可预测的方式进行操作，并且风险最小。此方法也是最容易测试的。每次构建新服务器时，无论是生产、测试、预发布等环境，您都会自然地测试至少部分内容。

当我们构建基础操作系统、安装应用程序，并通过 DevOps 风格的自动化部署配置时，我们只需恢复来自备份系统的系统特定数据，而且这种恢复通常仅在部分情况下需要。如果你考虑一个典型的多层应用程序，唯一的、不能从初始构建过程中获取的数据通常仅限于数据库文件或有限的文件存储。在一个运行于多个操作系统实例上的应用程序中，我们通常期望这些数据只存在于那些节点的某一层，通常是数据库。如果该节点是复制的，我们通常只需要从集群中的单个节点备份数据（因为我们通常会在所有节点之间复制所有数据）。通过这个过程，我们减少了备份的多个节点、减少了备份类型，并仅识别出可能存在风险的实际数据。

每个环境都不同，在某些环境中，我们可能发现需要特别保护的数据仅占所有数据的百分之一，而在另一些环境中，可能占到百分之九十九。我们无法确定现实世界中你将会面临什么，因为每个组织和工作负载的情况差异很大。普遍来说，能够限制备份的规模，进而限制恢复的规模，是有优势的。备份越小，备份过程越快速且对系统的影响越小。备份越小，存储它的成本也越低。较小的备份意味着验证数据是否损坏的工作量更少。减少备份时间的同样较小的大小，也同样能够减少恢复时间。

在我们这个多层的例子中，我们可能需要重建三个节点才能使应用程序重新启动。顶层的负载均衡和代理层假定没有独特数据，可以通过已经测试过的构建过程恢复，这个过程最初就是用来构建它的。应用层同样不应该有独特数据，并能够使用已经测试过的构建过程自动恢复。

我们最后一层标准层，数据库，应该同样通过完整的构建过程来部署所有配置和应用程序。此时，应用程序的所有层级和配置都已经恢复，备份和恢复机制甚至还没有发挥作用。此时唯一缺失的部分是数据库中最新数据的恢复。数据库已就位，但其中的数据尚未恢复。此时，我们的恢复过程启动，将数据恢复到正确的位置。这可能只是一个简单的文件从远程位置复制到数据库位置，并在文件到位后重启数据库。或者可能需要对数据执行特定于数据库的恢复操作以重新加载数据。无论如何，恢复的数据量非常小，类型也非常有限。

这种方法改变了我们传统上对备份的所有认知。它改变了备份操作的速度和影响力，改变了我们需要使用的工具，并可能将它们完全淘汰，它使得恢复变得更快，甚至可能实现完全自动化！

如果我们回到之前的示例，假设我们使用的是流行的 MySQL 应用程序作为我们的数据库平台，且所有必要的数据都存储在这个位置——对于许多常见的工作负载设计来说，这是一个合理的假设，那么我们可能不再需要使用特别的备份工具。我们也不需要依赖像快照这样的复杂或风险较高的机制。我们可以使用数据库平台的内置工具，可靠地从工作负载层（我们不愿意称之为应用层，因为那是一个软件工程术语，和系统层面的术语有所不同）获取完整的数据集，且我们知道，工作负载在备份操作期间，凭借其所有必要的智能，能够稳定并锁定数据，从而确保我们的备份是安全的*应用* *一致性*。

当我们退后一步，开始忽略常规，停止单纯地*购买解决方案*，而是戴上 IT 的帽子，确定如何最好地保护我们的环境时，我们常常能找到既能保护我们的组织又能节省开支的方法。

## IT 提供解决方案，供应商销售组件

超越备份，甚至超越系统管理，了解解决方案的来源是我们在 IT 领域做得好的一项基本任务。核心是，生产解决方案的责任属于 IT，而不是其他人。在很多情况下，我们需要依赖供应商提供某一或多个解决方案的组件。IT 不可能自己制造 CPU、组装服务器部件，或者编写操作系统，因此供应商（在这个上下文中，供应商包括那些不收费但提供像开源软件（例如 Linux 操作系统）这样的东西的供应商）是解决方案过程中的必要部分。

供应商不是解决方案提供者（尽管很多供应商会以此作为营销名号，自称为解决方案提供者，当然），他们更像是销售组织。他们的角色是提供工具的访问权限，希望这些工具能在我们追求解决方案的过程中带来帮助。真正决定使用哪些工具的，是 IT 部门，IT 部门负责选择合适的工具，并用它们来组装最终的解决方案，以满足业务需求。IT 是提供解决方案的部门，这不仅仅是我们购买的东西，而是我们所做的事。我们不能仅仅依赖供应商来卖给我们一个能保护我们的产品；事情并非如此简单。我们需要理解业务需求、工作负载、备份产品、方法，并将所有这些信息整合起来，做出一个适合我们的统一解决方案。每个企业都是独特的，每个解决方案也应该是独特的。

没有任何供应商提供的工具能够考虑到我们今天所有独特的备份需求，更不用说能够适应未来可能的变化了。如果你能想象的话，许多公司对供应商购买流程上瘾，以至于他们试图将自己的工作负载和内部流程（以及需求）调整到适应供应商想要销售的产品需求！这就像是为了让你的船销售员解释他推销给你的船，而不是能让你轻松上下班的车，你非得搬到一个不理想的房子里。

DevOps 和类似的基础设施确实揭示了传统的*只是购买销售员想让你购买的东西*流程，如何迫使企业适应采购，而不是选择对企业更有意义的产品。在以前的技术时代，选项要少得多，差异也要小得多，所以很容易忽视或忽略这些低效之处。今天，已经不可能再这样做了。

增强的备份和恢复流程实际上是考虑投资 DevOps 和基础设施即代码工程的最佳理由之一。通常情况下，我们可以找到许多理由让 DevOps 更具吸引力，但更好的备份显然是最有价值的好处。

现在我们已经了解了如何在真正现代化的基础设施上进行备份，接下来我们要讨论的最后一个话题是：分类。是时候从备份的操作转向如何使用备份了！

# 分类概念

规划很重要，它帮助你为许多可能的情况做好准备。然而，当灾难真正来临时，大部分的规划都会被抛到窗外。你对备份可靠性的所有信心并不会让你放松，最终用户会陷入恐慌，管理层会忘记你需要解决问题，反而会把你拉进会议，压力巨大，所有情况都和你原本的规划完全不同。

分类之所以困难，是因为每个工作负载、每个时间点、每个当前情形都包含了许多动态的因素。我们必须准备好随时做出调整，并尽可能快速地让我们的系统恢复正常。

灾难发生的瞬间，才是最关键的时候，这也是系统管理员真正展现能力的时刻。准备好应对灾难相对简单，但保持冷静、理性，实时评估局势，并管理周围的人，都会变成不可预测且非常情绪化的挑战。

没有简单的分类指南，并非每个人都擅长这一点。我们越是事先做好准备，越是了解整个环境，越是了解我们所处的商业环境，我们就越能适应变化。

分类是一项最适合由 Myers-Briggs 性格类型中的知觉型（Perceiver）来处理的技能。因此，在这里，管理工作，相对于工程设计，确实能展现出其最极端的优势。

分析停机时，我们的第一步是评估情况并确定灾难的范围。是只有某些服务不可用吗？还是所有服务都中断了？是否有数据丢失？停机的当前、正在发生和未来可能带来的影响是什么？如果我们手头没有这些数据，应该让人员忙于为我们收集这些信息。

紧急处理尤其需要帮助业务了解在停机期间能做些什么。许多企业会陷入恐慌，或者根本没有计划（即使有计划，也无法正确执行）。但业务行为需要与技术恢复工作协调一致。在我们开始恢复的过程中，我们还需要努力帮助业务尽可能地继续运作。当然，我们希望公司管理层根据 IT 对影响的评估以及恢复可能的样貌，来指导运营，以提高效率。IT 往往也需要准备好提供指导。

在任何紧急操作中，我们都必须确定工作负载的关键性及恢复的可能性。最关键的工作负载，如果恢复需要几周时间，而许多基本服务能在短时间内恢复运行，那么它也将排在后面。在决定如何进行灾难恢复时，我们需要考虑生产力损失、客户信任丧失、合同无法履行以及类似的顾虑。

恢复计划，即使是在紧急时刻，也需要与业务部门协调。业务部门可以做些什么来帮助恢复，技术方面又能做些什么来实现这一目标？通过良好的合作，不同的业务可能会发现多种途径来最大限度地减少停机带来的损失。

企业可以采取一些简单的措施，比如让员工回家休息，避开工作现场，这样 IT 部门可以有更多的自由进行恢复。一个享受了突然假期的员工，回到办公室时可能会精神焕发，甚至尝试弥补部分失去的工作时间。与其让团队因无法工作而感到沮丧，为什么不奖励他们的辛勤工作呢？

将通信转移到未停机的系统上同样非常重要。如果电子邮件停了，员工能否转而使用电话？如果电话停了，能否用电子邮件？即时通讯呢？或者通过其他平台进行语音聊天？也许这时候是去拜访客户的好时机！

没有办法列举出企业利用停机的无数方法。我们需要的是创造力和与业务合作的自由，帮助他们看到如何尽最大努力继续工作，并引导我们以最适合他们的方式进行恢复。

思考分类操作凸显了我们已经讨论过的概念的重要性，如自恢复系统、最小化的恢复大小和周密的规划。它还强调了让运营和其他部门参与进来、了解可用计划并准备好协助和协调在问题发生时的重要性。良好的规划能让分类操作更有效，但你无法为你的分类操作做出完全的规划。变量太多，无法真正预见所有的突发情况。

我希望分类处理和灾难恢复监督是我们可以具体教授的内容。那是一个令人恐惧的情况，我们所能做的就是确保具备分类处理和洞察力思维的正确人员在关键时刻能够及时行动，拥有良好的备份、良好的恢复流程，并尽可能做好规划，同时确保整个组织能够作为一个协同团队共同努力以尽量减少影响。

# 总结

没有什么比备份更重要。我觉得这至少是我在本书中写下的第五次，显然这还不够。如今，备份比以往任何时候都重要。我们面临的灾难场景和更为复杂的数据丢失情况比我们行业以往的任何时候都要多。备份一直是且可能永远是我们防止完全失败的最强防线。

近年来，备份发生了很大的变化。即使是十年前我们备份的假设，今天也不再适用了，然而许多组织仍在使用传统应用程序、传统设计，仍然需要使用传统的备份。所以，我们的工作是复杂的，我们对现代备份的需求可能推动我们朝着更加现代化的应用设计发展，从而使我们能够以更好的方式保护它们。

但现在我们已经理解了不同备份方法背后的机制，为什么我们要考虑以不同的方式进行备份，以及如何将我们的备份实践推进到未来。备份可能是你与众不同的最佳机会；没有什么比备份更重要的了，而且很少有什么像备份那样被忽视。

在下一章，我们将探讨用户在 Linux 系统中的存在与互动，以及我们如何处理身份验证、远程访问和安全性问题。
