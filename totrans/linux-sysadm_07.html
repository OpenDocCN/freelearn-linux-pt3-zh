<html><head></head><body>
<div id="sbo-rt-content"><div id="_idContainer044">
<h1 class="chapter-number" id="_idParaDest-91"><a id="_idTextAnchor118"/>7</h1>
<h1 id="_idParaDest-92"><a id="_idTextAnchor119"/>User and Group Management</h1>
<p>If you administer Linux servers, the users of such servers can be both your greatest asset and your greatest headache. Throughout the course of your career, you will be responsible for the addition of a large number of new users, the management of their passwords, the deletion of their accounts when they leave the organization, and the provision and revocation of access to resources located across the network. Even on servers where you are the sole user, you will still be responsible for managing user accounts. This is because even system processes run under the guise of a user. If you want to be effective at managing Linux servers, you will also need to know how to manage rights, implement password policies, and limit the number of people who can execute administrative commands on the computer. In this chapter, we’ll go over these topics in detail so that you have a solid understanding of how to manage users and the resources <span class="No-Break">they consume.</span></p>
<p>In this chapter, we’re going to learn how to do <span class="No-Break">the following:</span></p>
<ul>
<li>Create users <span class="No-Break">and groups</span></li>
<li>Modify users <span class="No-Break">and groups</span></li>
<li>Delete users <span class="No-Break">and groups</span></li>
<li>List <span class="No-Break">all users</span></li>
<li>Add a user to <span class="No-Break">a group</span></li>
<li>Remove a user from <span class="No-Break">a group</span></li>
</ul>
<h1 id="_idParaDest-93"><a id="_idTextAnchor120"/>Overview of managing accounts/groups</h1>
<p>As a <a id="_idIndexMarker318"/>multi-user operating system, Linux<a id="_idIndexMarker319"/> allows for multiple users to be logged in and work simultaneously on a single machine. Be aware that it is never a good idea to let users share login information for the same account. It is preferable to have as many accounts as users who require <span class="No-Break">machine access.</span></p>
<p>Access to specific system resources, such as directories and files, may need to be shared by two or more users. We can achieve both goals using Linux’s user and group <span class="No-Break">administration features.</span></p>
<p>General/normal users and root/superusers are the two categories of users in <span class="No-Break">Linux systems.</span></p>
<p>One of the <a id="_idIndexMarker320"/>fundamental components of the Linux operating system is the management of user and group accounts. The custom rights of user and<a id="_idIndexMarker321"/> group accounts are maintained by each user logging in to the operating system using a different set of credentials. Adding new users requires specific permissions (superuser); the same holds true for other user or group administration operations, including account deletion, account update, and group addition <span class="No-Break">and deletion.</span></p>
<p>These operations are performed using the <span class="No-Break">following commands:</span></p>
<ul>
<li><strong class="source-inline">adduser</strong>: Add a user to <span class="No-Break">the system</span></li>
<li><strong class="source-inline">userdel</strong>: Delete a user account and <span class="No-Break">related files</span></li>
<li><strong class="source-inline">addgroup</strong>: Add a group to <span class="No-Break">the system</span></li>
<li><strong class="source-inline">delgroup</strong>: Remove a group from <span class="No-Break">the system</span></li>
<li><strong class="source-inline">usermod</strong>: Modify a <span class="No-Break">user account</span></li>
<li><strong class="source-inline">chage</strong>: This command is used to change the password expiration time and see user password <span class="No-Break">expiry information</span></li>
<li><strong class="source-inline">passwd</strong>: This command is used to create or change a user <span class="No-Break">account’s password</span></li>
<li><strong class="source-inline">sudo</strong>: Run one or more commands as another user (typically with superuser permissions by running the <strong class="source-inline">sudo su &lt;</strong><span class="No-Break"><strong class="source-inline">username&gt;</strong></span><span class="No-Break"> command)</span></li>
</ul>
<p>Files relevant to these operations include <strong class="source-inline">/etc/passwd</strong> (user information), <strong class="source-inline">/etc/shadow</strong> (encrypted passwords), <strong class="source-inline">/etc/group</strong> (group information), and <strong class="source-inline">/etc/sudoers</strong> (configuration <span class="No-Break">for </span><span class="No-Break"><strong class="source-inline">sudo</strong></span><span class="No-Break">).</span></p>
<p>Superuser access is granted by using either the <strong class="source-inline">su</strong> command to become the root user or the <strong class="source-inline">sudo su</strong> command to get <span class="No-Break">root privileges.</span></p>
<p>These are the default locations for user <span class="No-Break">account information:</span></p>
<ul>
<li>User account <span class="No-Break">properties: </span><span class="No-Break"><strong class="source-inline">/etc/passwd</strong></span></li>
<li>User password <span class="No-Break">properties: </span><span class="No-Break"><strong class="source-inline">/etc/shadow</strong></span></li>
</ul>
<p>A group with<a id="_idIndexMarker322"/> the same username is also created when a <a id="_idIndexMarker323"/>user is created. Every user has a home directory; for the root user, it is placed in <strong class="source-inline">/root</strong>; for all other users, it is <span class="No-Break">in </span><span class="No-Break"><strong class="source-inline">/home/</strong></span><span class="No-Break">.</span></p>
<p>The <strong class="source-inline">/etc/passwd</strong> file contains all of the account details. This file has the following structure and includes a record for each system user account (fields are delimited <span class="No-Break">by colons):</span></p>
<pre class="source-code">
&lt;username&gt;:&lt;x&gt;:&lt;UID&gt;:&lt;GID&gt;:&lt;Comment&gt;:&lt;Home directory&gt;:&lt;Default shell&gt;</pre>
<p>Let’s carefully examine the <span class="No-Break">preceding code:</span></p>
<ul>
<li>The <strong class="source-inline">&lt;username&gt;</strong> and <strong class="source-inline">&lt;Comment&gt;</strong> fields <span class="No-Break">are self-explanatory</span></li>
<li>The shadowed password (in <strong class="source-inline">/etc/shadow</strong>), which is required to log on as <strong class="source-inline">&lt;username&gt;</strong>, is indicated by the <strong class="source-inline">x</strong> in the <span class="No-Break">second field</span></li>
<li>The <strong class="source-inline">&lt;UID&gt;</strong> and <strong class="source-inline">&lt;GID&gt;</strong> entries include integers that, respectively, reflect the <strong class="source-inline">&lt;usernameprimary&gt;</strong> Group ID and <span class="No-Break">User ID</span></li>
<li><strong class="source-inline">&lt;Home directory&gt;</strong> displays the full path to the home directory of the <span class="No-Break">current user</span></li>
<li>When a user logs in to the system, <strong class="source-inline">&lt;Default shell&gt;</strong> is the shell that is made available <span class="No-Break">to them</span></li>
</ul>
<p>Now that we have an overview of the commands used to manage accounts/groups, let’s start to play <span class="No-Break">with them.</span></p>
<h1 id="_idParaDest-94"><a id="_idTextAnchor121"/>How to add a new account</h1>
<p>There are <a id="_idIndexMarker324"/>two commands, <strong class="source-inline">adduser</strong> and <strong class="source-inline">useradd</strong>, that can be utilized in Linux for the purpose of generating new users. The fact that these two commands achieve the same thing (albeit in different ways) and have names that are extremely similar to one another can make this a bit difficult to understand at first. I’ll begin by walking you through the <strong class="source-inline">useradd</strong> command, and<a id="_idIndexMarker325"/> then I’ll describe how <strong class="source-inline">adduser</strong> works differently. It’s possible that you will prefer the latter option, but we’ll discuss that in <span class="No-Break">a moment.</span></p>
<h2 id="_idParaDest-95"><a id="_idTextAnchor122"/>Using useradd</h2>
<p>You <a id="_idIndexMarker326"/>need <strong class="source-inline">sudo</strong> capabilities in order to add an account if you don’t have root access. This must be defined <span class="No-Break">in </span><span class="No-Break"><strong class="source-inline">/etc/sudoers</strong></span><span class="No-Break">.</span></p>
<p>To begin, here is a working example of the <strong class="source-inline">useradd</strong> command that you can put <span class="No-Break">to use:</span></p>
<pre class="source-code">
sudo  useradd -d /home/packt -m packt</pre>
<p>I set up a new user with the name <strong class="source-inline">packt</strong> by using this command. I am confirming that I want a home directory to be established for this user by using the <strong class="source-inline">-d</strong> option, and after that, I specified <strong class="source-inline">/home/packt</strong> as the user’s home directory in the following command. If I hadn’t used the <strong class="source-inline">-m</strong> parameter, the system would not have known that I wanted my home directory to be created while the process was running; in that case, I would have had to manually create the directory. At the end, I announced the username that will be used for my new user (in this case, <strong class="source-inline">packt</strong>). As we progress through this book, we will come across commands that, in order to be executed, need root privileges. This was demonstrated in the preceding command. I’ll prefix commands that need certain permissions with <strong class="source-inline">sudo</strong>, as that is the standard way to accomplish it. When you see this, it simply indicates that the command can only be executed with the root user’s rights. You can also execute these commands by logging in as root (if root access is enabled) or switching to root mode. Both of these options are available to you. However, rather than logging in with the root account, it is strongly recommended that you use <strong class="source-inline">sudo</strong> instead. I explained <span class="No-Break">this earlier.</span></p>
<p>The following command can be used to set a password for the newly created <span class="No-Break"><strong class="source-inline">packt</strong></span><span class="No-Break"> account:</span></p>
<pre class="source-code">
~ $sudo passwd packt
Changing password for user packt.
New password:
Retype new password:
passwd: all authentication tokens updated successfully.</pre>
<p>Another <a id="_idIndexMarker327"/>command is <strong class="source-inline">adduser</strong>, which will create everything automatically for you, including the home directory and group, and will ask you to set <span class="No-Break">the password.</span></p>
<h2 id="_idParaDest-96"><a id="_idTextAnchor123"/>Using adduser</h2>
<p>The <strong class="source-inline">adduser</strong> command is<a id="_idIndexMarker328"/> yet another option for establishing a user account, as mentioned earlier. When you first use this command, the difference it makes (as well as the convenience it provides) should become instantly evident. Execute the <strong class="source-inline">adduser</strong> command while providing the username of the new user you want to create. Go ahead and give it <span class="No-Break">a shot:</span></p>
<pre class="source-code">
~ $sudo adduser packt2
Adding user `packt2' ...
Adding new group `packt2' (1004) ...
Adding new user `packt2' (1003) with group `packt2' ...
The home directory `/home/packt2' already exists.  Not copying from `/etc/skel'.
New password:
Retype new password:
passwd: password updated successfully
Changing the user information for packt2
Enter the new value, or press ENTER for the default
        Full Name []:
        Room Number []:
        Work Phone []:
        Home Phone []:
        Other []:
Is the information correct? [Y/n]</pre>
<p>It is clear from the results that the <strong class="source-inline">adduser</strong> command did a significant amount of work for us. The command copied files from <strong class="source-inline">/etc/skel</strong> into our new user’s home directory and set<a id="_idIndexMarker329"/> the user’s home directory to <strong class="source-inline">/home/packt2</strong> by default. The user account was also assigned the next available <strong class="bold">User ID</strong> (<strong class="bold">UID</strong>) and <strong class="bold">Group ID</strong> (<strong class="bold">GID</strong>) of <strong class="source-inline">1004</strong>. In point<a id="_idIndexMarker330"/> of fact, the <strong class="source-inline">adduser</strong> and <strong class="source-inline">useradd</strong> commands<a id="_idIndexMarker331"/> both copy files from the <strong class="source-inline">/etc/skel</strong> directory; however, the <strong class="source-inline">adduser</strong> command is somewhat more detailed in the tasks that <span class="No-Break">it executes.</span></p>
<h1 id="_idParaDest-97"><a id="_idTextAnchor124"/>How to delete an account</h1>
<p>When a<a id="_idIndexMarker332"/> user no longer needs access to a system, it is highly necessary to remove or disable their account because unmanaged accounts frequently become a security concern. This can be done by logging in to the system’s administration panel and selecting the <strong class="bold">Accounts</strong> tab. We will make use of the <strong class="source-inline">userdel</strong> command in order to delete a user account. However, before you go and delete an account, there is one crucial question that you should consult with yourself about. Do you (or someone else) anticipate needing access to the user’s files in some capacity? The vast majority of businesses have retention policies that outline what ought to take place with regard to a user’s data in the event that they depart the organization. These files are occasionally duplicated and saved in an archive for long-term preservation. It’s not uncommon for a manager, a coworker, or a new employee to require access to a previous user’s files, possibly so that they can pick up where the previous user left off on a project. Before beginning to manage users, it is critical to have a solid understanding of this policy. If you do not already have a policy that describes the retention requirements for files when users depart the company, it is highly recommended that you collaborate with the management team to develop such a policy. The user’s home directory’s contents are not deleted when the <strong class="source-inline">userdel</strong> command is used since this behavior is not the default. In this section, we will delete <strong class="source-inline">packt2</strong> from the system by executing the <span class="No-Break">following command:</span></p>
<pre class="source-code">
sudo userdel packt2</pre>
<p>In this case, the home folder of the <strong class="source-inline">packt2</strong> <span class="No-Break">user remains.</span></p>
<p>If we want to remove the home folder once with the account, we need to use the <strong class="source-inline">–</strong><span class="No-Break"><strong class="source-inline">r</strong></span><span class="No-Break"> parameter:</span></p>
<pre class="source-code">
sudo userdel –r packt2</pre>
<p>Before <a id="_idIndexMarker333"/>deleting users’ accounts, remember to check whether the files in their home folders are needed. Once deleted, they cannot be recovered if there is <span class="No-Break">no backup:</span></p>
<pre class="source-code">
su - packt2
su: user packt2 does not exist</pre>
<p>In conclusion, deleting a user account in Linux involves backing up data, terminating processes, removing the user from groups, deleting the home directory, updating system files, and performing a final cleanup. By following these steps, you can securely delete an account while managing the associated files and <span class="No-Break">permissions effectively.</span></p>
<h1 id="_idParaDest-98"><a id="_idTextAnchor125"/>Understanding the/etc/sudoers file</h1>
<p>In this <a id="_idIndexMarker334"/>section, let’s see how to use the ordinary user account we created earlier to carry out user <span class="No-Break">administration operations.</span></p>
<p>We must make a special permissions entry for <strong class="source-inline">packt</strong> in <strong class="source-inline">/etc/sudoers</strong> in order to allow it <span class="No-Break">special access:</span></p>
<pre class="source-code">
packt ALL=(ALL) ALL</pre>
<p>Let’s break down this <span class="No-Break">line’s syntax:</span></p>
<ul>
<li>First, we state to which user this rule <span class="No-Break">applies (</span><span class="No-Break"><strong class="source-inline">packt</strong></span><span class="No-Break">).</span></li>
<li>All hosts that use the same <strong class="source-inline">/etc/sudoers</strong> file are covered by the rule if the first <strong class="source-inline">ALL</strong> is present. Since the same file is no longer shared among different machines, this term now refers to the <span class="No-Break">current host.</span></li>
<li>Next, <strong class="source-inline">(ALL) ALL</strong> informs us that any user may execute any command as the <strong class="source-inline">packt</strong> user. In terms of functionality, this is similar to <strong class="source-inline">(</strong><span class="No-Break"><strong class="source-inline">root) ALL</strong></span><span class="No-Break">.</span></li>
</ul>
<p>It is important to manage permissions using groups as it makes life much easier. Imagine how simple it would be to just remove a user from a <strong class="source-inline">sudo</strong> group rather than removing the user from 100 <span class="No-Break">different places.</span></p>
<h1 id="_idParaDest-99"><a id="_idTextAnchor126"/>Switching users</h1>
<p>We are <a id="_idIndexMarker335"/>now prepared to begin using the <strong class="source-inline">packt</strong> account to carry out user administration duties. Use the <strong class="source-inline">su</strong> command to switch to that account to accomplish this. Notably, if you’re using CentOS or a comparable operating system, you don’t need to use the root account <span class="No-Break">moving forward:</span></p>
<pre class="source-code">
su -l packt</pre>
<p>We are able to check the permissions for our newly formed <strong class="source-inline">packt</strong> account by using the <strong class="source-inline">sudo</strong> command. Let’s create another account called <strong class="source-inline">packtdemo</strong>, <span class="No-Break">shall we?</span></p>
<pre class="source-code">
~ $sudo adduser packtdemo
Adding user `packtdemo' ...
Adding new group `packtdemo' (1005) ...
Adding new user `packtdemo' (1004) with group `packtdemo' ...
The home directory `/home/packtdemo' already exists.  Not copying from `/etc/skel'.
New password:
Retype new password:
passwd: password updated successfully
Changing the user information for packtdemo
Enter the new value, or press ENTER for the default
Full Name []:
Room Number []:
Work Phone []:
Home Phone []:
Other []:
Is the information correct? [Y/n]</pre>
<p>Changes to the user’s home folder, default shell, and the ability to add a description to the user account can all be made with the <span class="No-Break"><strong class="source-inline">usermod</strong></span><span class="No-Break"> command.</span></p>
<p>Initially, the <strong class="source-inline">/etc/passwd</strong> file looks <span class="No-Break">like this:</span></p>
<pre class="source-code">
~ $grep packtdemo /etc/passwd
packtdemo:x:1004:1005:,,,:/home/packtdemo:/bin/bash</pre>
<p>Let’s try to add a description and change <span class="No-Break">the shell:</span></p>
<pre class="source-code">
~ $sudo usermod --comment "Demo account for packt" --shell /bin/sh packtdemo
~ $grep packtdemo /etc/passwd
packtdemo:x:1004:1005:Demo account for packt:/home/packtdemo:/bin/sh</pre>
<p>Changing to <a id="_idIndexMarker336"/>an alternate user account is frequently quite beneficial when working with support (especially while troubleshooting permissions). Take, for instance, the scenario in which a user complains to you that they are unable to access the files contained in a particular directory or that they are unable to execute a certain command. In such a scenario, you can try to duplicate the issue by logging in to the server, switching to the user account of the person having the issue, and then attempting to access the given files. In this way, you will not only be able to view their issue for yourself; you will also be able to test whether your solution resolves their problem before you report back <span class="No-Break">to them.</span></p>
<p>You can switch to root user by running the <strong class="source-inline">sudo su</strong> or <strong class="source-inline">su –</strong> command, or just <span class="No-Break">simply </span><span class="No-Break"><strong class="source-inline">su</strong></span><span class="No-Break">.</span></p>
<p><strong class="source-inline">su</strong> alone switches to another user while maintaining the current environment, while <strong class="source-inline">su –</strong> simulates a complete login environment for the target user, including setting up their home directory and environment variables and starting a new login shell. The choice between the two commands depends on the specific requirements or tasks you need to accomplish as the user <span class="No-Break">switched to.</span></p>
<h1 id="_idParaDest-100"><a id="_idTextAnchor127"/>Managing account passwords</h1>
<p>If you <a id="_idIndexMarker337"/>remember correctly, the <strong class="source-inline">passwd</strong> command enables us to alter the password for the user who is now logged in to the system. In addition, we are able to change the password for any user account on our system by running the <strong class="source-inline">passwd</strong> command while logged in as root and providing the username. However, that is only one of the capabilities of <span class="No-Break">this command.</span></p>
<h2 id="_idParaDest-101"><a id="_idTextAnchor128"/>Locking/unlocking user accounts</h2>
<p>The ability to<a id="_idIndexMarker338"/> lock and unlock a user <a id="_idIndexMarker339"/>account is one feature of the <strong class="source-inline">passwd</strong> command that we have not yet discussed. You can use this command to do either of these things. There are lots of different use cases where you need to accomplish something like this. For example, if a person is going to be gone for a lengthy period of time, you might want to lock their account so that it is inaccessible to other users during <span class="No-Break">that time.</span></p>
<p>Use the <strong class="source-inline">-l</strong> option when you want to lock an account. For example, to lock the account for the <strong class="source-inline">packt</strong> user, we use the <span class="No-Break">following command:</span></p>
<pre class="source-code">
sudo passwd -l packt</pre>
<p>Unlock it <span class="No-Break">as follows:</span></p>
<pre class="source-code">
sudo passwd –u packt</pre>
<h2 id="_idParaDest-102"><a id="_idTextAnchor129"/>Setting password expiration</h2>
<p>Next, we <a id="_idIndexMarker340"/>will discuss the process of actually carrying out the steps to set up <span class="No-Break">password expiration.</span></p>
<p>To be more specific, the <strong class="source-inline">chage</strong> command is what enables us to do this. We may use <strong class="source-inline">chage</strong> to change the length of time for which a user’s password is valid, and it also provides a more user-friendly alternative to reading the <strong class="source-inline">/etc/shadow</strong> file in order to view the current password expiration information. By giving a username and using the <strong class="source-inline">-l</strong> option of the <strong class="source-inline">chage</strong> command, we are able to view the <span class="No-Break">pertinent information:</span></p>
<pre class="source-code">
sudo chage -l packt</pre>
<p>It is not necessary to run <strong class="source-inline">chage</strong> as <strong class="source-inline">root</strong> or with the <strong class="source-inline">sudo</strong> command. There is no need to raise your permission level to be able to view the expiration information for your own login. To access information using <strong class="source-inline">chage</strong> for any user account other than your own, however, you will need to <span class="No-Break">utilize </span><span class="No-Break"><strong class="source-inline">sudo</strong></span><span class="No-Break">:</span></p>
<pre class="source-code">
~ $sudo chage -l packt</pre>
<div>
<div class="IMG---Figure" id="_idContainer039">
<img alt="Figure 7.1 – Display the password-related information and aging policies for a user account" height="264" src="image/Figure_7.1_B18575.jpg" width="993"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 7.1 – Display the password-related information and aging policies for a user account</p>
<p>In the <a id="_idIndexMarker341"/>output, we are able to view values such as the date that the password will expire, the maximum number of days that can pass before it needs to be changed, and so on. It’s basically the same information that’s saved in <strong class="source-inline">/etc/shadow</strong>, but it’s formatted in a way that makes it much simpler to understand. If you would like to make any modifications to this information, the <strong class="source-inline">chage</strong> tool is once again your best option. The first illustration that I’ll give you is a fairly typical one. You should absolutely require new users to reset their passwords the first time they log in after creating their user accounts for them. Unfortunately, not everyone will be interested in doing what has to be done. Using the <strong class="source-inline">chage</strong> command, you can require a user to change their password upon their first successful login to the system. This is done by changing their total number of days before password expiration to <strong class="source-inline">0</strong> in the <span class="No-Break">following manner:</span></p>
<pre class="source-code">
sudo chage –d 0 packt</pre>
<p>And the results compared with the previous output look <span class="No-Break">like this:</span></p>
<pre class="source-code">
~ $sudo chage -l packt</pre>
<div>
<div class="IMG---Figure" id="_idContainer040">
<img alt="Figure 7.2 – Display the password-related information and aging policies for a user account" height="269" src="image/Figure_7.2_B18575.jpg" width="1003"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 7.2 – Display the password-related information and aging policies for a user account</p>
<p>The following instructions allow you to configure a user account so that it will demand a new password after a particular number of days <span class="No-Break">have passed:</span></p>
<pre class="source-code">
sudo chage -M 90 &lt;username&gt;</pre>
<p>In the preceding code, I am <a id="_idIndexMarker342"/>configuring the user account to become invalid after 90 days and to demand a new password at that time. When the user logs in, they will be presented with a warning notice seven days before the password has to be changed. This is the message that will appear seven days before the <span class="No-Break">password expires:</span></p>
<div>
<div class="IMG---Figure" id="_idContainer041">
<img alt="Figure 7.3 – Display the password-related information and aging policies for a user account" height="269" src="image/Figure_7.3_B18575.jpg" width="1000"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 7.3 – Display the password-related information and aging policies for a user account</p>
<p>It is a good practice to set a password expiration policy for <span class="No-Break">security reasons.</span></p>
<h1 id="_idParaDest-103"><a id="_idTextAnchor130"/>Group management</h1>
<p>Now that we <a id="_idIndexMarker343"/>know how to make new user accounts, manage existing user accounts, and switch between user accounts, we need to learn how to manage groups. Linux’s implementation of the concept of groups is not all that dissimilar to that of other operating systems, and it essentially performs the same function. Controlling a user’s access to the resources on your server can be done more effectively with the help of groups. You can grant access to users or deny access to users by simply adding them to or removing them from a group that has been assigned to a resource (such as a file or directory). This is made possible by assigning a group to the resource in question. The way that this is handled in Linux is such that each and every file and directory has both a user and a group that claims ownership of it. When using Linux, ownership is assigned on a one-to-one basis, meaning that each file or directory has just one user and just one group associated with it. You can verify this for yourself on a Linux system by listing the items included within a directory, <span class="No-Break">as follows:</span></p>
<pre class="source-code">
ls –l</pre>
<div>
<div class="IMG---Figure" id="_idContainer042">
<img alt="Figure 7.4 – Listing the contents of a folder" height="373" src="image/Figure_7.4_B18575.jpg" width="828"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 7.4 – Listing the contents of a folder</p>
<p>You only<a id="_idIndexMarker344"/> need to use the <strong class="source-inline">cat</strong> command to read the contents of the <strong class="source-inline">/etc/group</strong> file if you are interested in discovering which groups are currently active on your server. The <strong class="source-inline">/etc/group</strong> file, much like the <strong class="source-inline">/etc/passwd</strong> file that we went over before, stores information regarding the groups that have been created on your system. Feel free to take a look at this file, which is located on <span class="No-Break">your system:</span></p>
<p>To create a group, use the <strong class="source-inline">sudo addgroup &lt;</strong><span class="No-Break"><strong class="source-inline">groupname&gt;</strong></span><span class="No-Break"> command:</span></p>
<pre class="source-code">
sudo addgroup packtgroup
Adding group `packtgroup' (GID 1006) ...
Done.</pre>
<p>To view the content of the file, run the <span class="No-Break">following command:</span></p>
<pre class="source-code">
cat /etc/group
packtgroup:x:1006:
packt:x:1007:
packtdemo:x:1005:
packt2:x:1004:</pre>
<p>The structure of each line is <span class="No-Break">as follows:</span></p>
<pre class="source-code">
&lt;Group name&gt;:&lt;Group password&gt;:&lt;GID&gt;:&lt;Group members&gt;</pre>
<p>Examining the previous syntax, we can see <span class="No-Break">the following:</span></p>
<ul>
<li>The name of the group is <strong class="source-inline">&lt;</strong><span class="No-Break"><strong class="source-inline">Group name&gt;</strong></span></li>
<li>Group passwords are not used if there is an <strong class="source-inline">x</strong> next to <strong class="source-inline">&lt;</strong><span class="No-Break"><strong class="source-inline">Group password&gt;</strong></span></li>
<li><strong class="source-inline">&lt;Group members&gt;</strong> is a list, separated by commas, of users who are members of <strong class="source-inline">&lt;</strong><span class="No-Break"><strong class="source-inline">Group name&gt;</strong></span></li>
</ul>
<p>Use the <strong class="source-inline">sudo delgroup &lt;groupname&gt;</strong> command to remove <span class="No-Break">a group.</span></p>
<p>Each line<a id="_idIndexMarker345"/> in the <strong class="source-inline">/etc/group</strong> file containing group information contains the group name and the user accounts connected <span class="No-Break">to it:</span></p>
<pre class="source-code">
packt:x:1007:
packtdemo:x:1005:
packt2:x:1004:</pre>
<p>Now, we’ll have a look at the <strong class="source-inline">usermod</strong> command, which is what actually allows you to associate users with groups and is the next topic on our agenda. The <strong class="source-inline">usermod</strong> command can be used for a variety of purposes and has a wide range of applications (adding a user to a group is just one of its abilities). In the event that we want to include a user (<strong class="source-inline">packt</strong>) in our <strong class="source-inline">packtgroup</strong> group, we would issue the <span class="No-Break">following command:</span></p>
<pre class="source-code">
sudo usermod –aG packtgroup packt</pre>
<p>The <strong class="source-inline">-aG</strong> option is used to add a user to a specific group. The <strong class="source-inline">-a</strong> flag means <em class="italic">append</em>, which means that the user will be added to the group without removing them from any other groups they may already be a member of. The <strong class="source-inline">G</strong> flag specifies the <span class="No-Break">group name.</span></p>
<p>If you wanted to modify the primary group that a user belonged to, you would use the <strong class="source-inline">-g</strong> option instead (note that it is written with a lowercase <strong class="source-inline">g</strong> rather than an uppercase <strong class="source-inline">G</strong>, as we <span class="No-Break">did earlier):</span></p>
<pre class="source-code">
sudo usermod –g &lt;groupname&gt; &lt;username&gt;</pre>
<p>Groups are the easiest way to manage security permissions. Imagine removing one user from a group assigned to 100 resources rather than removing the user <span class="No-Break">100 times.</span></p>
<h1 id="_idParaDest-104"><a id="_idTextAnchor131"/>Permissions</h1>
<p>In Linux, each file, directory, and <a id="_idIndexMarker346"/>other system object has a designated owner and group. This is the most fundamental aspect of system security that safeguards users from one another. Different sorts of access to read from, write to, or execute<a id="_idIndexMarker347"/> files can be given to owners, group members, and everyone else. In Linux, these are commonly referred to as <span class="No-Break">file permissions.</span></p>
<p>The following commands are used to manage ownership and <span class="No-Break">set permissions:</span></p>
<ul>
<li>Change file permissions <span class="No-Break">with </span><span class="No-Break"><strong class="source-inline">chmod</strong></span></li>
<li>Change the file owner <span class="No-Break">with </span><span class="No-Break"><strong class="source-inline">chown</strong></span></li>
<li>Change group ownership <span class="No-Break">with </span><span class="No-Break"><strong class="source-inline">chgrp</strong></span></li>
<li>Print the user and group IDs <span class="No-Break">with </span><span class="No-Break"><strong class="source-inline">id</strong></span></li>
</ul>
<p>Typically, the user who created a file is its owner, and the group attached to that owner is its primary group (at least initially). Let’s create a <strong class="source-inline">testfile</strong> file in the <strong class="source-inline">/tmp</strong> directory as <span class="No-Break">an example:</span></p>
<pre class="source-code">
$echo "This is a test file" &gt;  testfile
$ls -l testfile
-rw-rw-r-- 1 packt packt 20 Feb  6 16:37 testfile</pre>
<p>The first character of the output shows that <strong class="source-inline">testfile</strong> is a normal file (that is, not a directory or other type of system object). The next nine characters (split into three sets of three characters each) show the read (<strong class="source-inline">r</strong>), write (<strong class="source-inline">w</strong>), and execute (<strong class="source-inline">x</strong>) permissions for the system’s owner, group owner, and <span class="No-Break">other users.</span></p>
<p>The first three characters (<strong class="source-inline">rw-</strong>) show that the file’s owner (user <strong class="source-inline">packt</strong>) can read and write to it. The next three characters show the same thing concerning the group owner. The last set of characters (<strong class="source-inline">r—</strong>) mean that other users can only read that file; they can’t write to it or <span class="No-Break">run it.</span></p>
<p>We’ll use <strong class="source-inline">chmod</strong> to modify a file’s permissions. A symbolic representation indicating to whom the new permissions will applied must come after <span class="No-Break">this command:</span></p>
<ul>
<li><strong class="source-inline">u</strong> <span class="No-Break">means user</span></li>
<li><strong class="source-inline">g</strong> <span class="No-Break">means group</span></li>
<li><strong class="source-inline">o</strong> means all <span class="No-Break">other users</span></li>
<li><strong class="source-inline">a</strong> means <span class="No-Break">all users</span></li>
</ul>
<p>The types of <a id="_idIndexMarker348"/>permission are <span class="No-Break">as follows:</span></p>
<ul>
<li><strong class="source-inline">+r</strong> adds <span class="No-Break">read permission</span></li>
<li><strong class="source-inline">-r</strong> removes <span class="No-Break">read permission</span></li>
<li><strong class="source-inline">+w</strong> adds <span class="No-Break">write permission</span></li>
<li><strong class="source-inline">-w</strong> removes <span class="No-Break">write permission</span></li>
<li><strong class="source-inline">+x</strong> adds <span class="No-Break">execute permission</span></li>
<li><strong class="source-inline">-x</strong> removes <span class="No-Break">execute permission</span></li>
<li><strong class="source-inline">+rw</strong> adds read and <span class="No-Break">write permissions</span></li>
<li><strong class="source-inline">+rwx</strong> adds read, write, and <span class="No-Break">execute permissions</span></li>
</ul>
<p>All of these permissions can be expressed numerically <span class="No-Break">as follows:</span></p>
<p>Read – <strong class="source-inline">4</strong> : Write – <strong class="source-inline">2</strong> : Execute – <strong class="source-inline">1</strong></p>
<p>For example, <strong class="source-inline">chmod 754 testfile</strong> will be translated as <strong class="source-inline">rwx</strong> permissions on <strong class="source-inline">testfile</strong> for the owner, <strong class="source-inline">rx</strong> for the group, and only <strong class="source-inline">r</strong> for <span class="No-Break">everyone else:</span></p>
<pre class="source-code">
ls -la testfile
-rwxr-xr--  1 voxsteel voxsteel  0 26 Jun 14:27 testfile</pre>
<p>To sum up, giving correct permissions is critical for security reasons and to avoid causing any unwanted damage. Following is an example of viewing <span class="No-Break">the permissions:</span></p>
<div>
<div class="IMG---Figure" id="_idContainer043">
<img alt="Figure 7.5 – Listing the contents of a folder and their permissions" height="322" src="image/Figure_7.5_B18575.jpg" width="876"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 7.5 – Listing the contents of a folder and their permissions</p>
<p>To sum up, giving <a id="_idIndexMarker349"/>correct permissions is critical for security reasons to prevent any unwanted activity on <span class="No-Break">your system.</span></p>
<h1 id="_idParaDest-105"><a id="_idTextAnchor132"/>Changing groups</h1>
<p>The <strong class="source-inline">chgrp</strong> command <a id="_idIndexMarker350"/>will be discussed now in the context of making <strong class="source-inline">packtgroup</strong> the new owner of <strong class="source-inline">testfile</strong>. After the command, we specify the name of the group and the name of the file whose ownership is to be changed (in this <span class="No-Break">case, </span><span class="No-Break"><strong class="source-inline">testfile</strong></span><span class="No-Break">):</span></p>
<pre class="source-code">
sudo chgrp packtgroup testfile</pre>
<p>Let’s check the ability of user <strong class="source-inline">packtdemo</strong> to write to this file now. A permission refused error should appear for the user. We can set the relevant permissions for the group to allow <strong class="source-inline">packtdemo</strong> to write to <span class="No-Break">the file:</span></p>
<pre class="source-code">
sudo chmod g+w testfile</pre>
<p>Then use <strong class="source-inline">usermod</strong> once more to add the account to <strong class="source-inline">packtgroup</strong>, this time using the <strong class="source-inline">-aG</strong> combined option <span class="No-Break">as follows:</span></p>
<pre class="source-code">
sudo usermod -aG packtgroup packtdemo</pre>
<p>The abbreviation for <em class="italic">append to group</em> <span class="No-Break">is </span><span class="No-Break"><strong class="source-inline">-aG</strong></span><span class="No-Break">.</span></p>
<p>Currently, <strong class="source-inline">packtgroup</strong> is referred to as a subsidiary or auxiliary group for user <strong class="source-inline">packtdemo</strong>. When <strong class="source-inline">packtdemo</strong> next logs in, the updated access permissions will <span class="No-Break">be active.</span></p>
<p>We can use <strong class="source-inline">chown</strong> followed by the usernames and filenames, in that order, to make <strong class="source-inline">packtdemo</strong> the owner of <strong class="source-inline">testfile</strong> rather than just adding the user to the <span class="No-Break"><strong class="source-inline">packtgroup</strong></span><span class="No-Break"> group:</span></p>
<pre class="source-code">
sudo chown packtdemo testfile</pre>
<p>Keep in <a id="_idIndexMarker351"/>mind that the aforementioned command will prevent the <strong class="source-inline">packt</strong> user from accessing <strong class="source-inline">testfile</strong> because such an account is no longer the file’s owner or a member of the <span class="No-Break"><strong class="source-inline">packtgroup</strong></span><span class="No-Break"> group.</span></p>
<p>Along with the typical <strong class="source-inline">rwx</strong> file permissions, <strong class="source-inline">setuid</strong>, <strong class="source-inline">setgid</strong>, and the sticky bit are three additional permissions that merit addressing. Let’s look at them one <span class="No-Break">by one.</span></p>
<p>Any user may run an executable file if the <strong class="source-inline">setuid</strong> bit is set on the file, utilizing the <span class="No-Break">owner’s permissions.</span></p>
<p>Any user may run an executable file when the <strong class="source-inline">setgid</strong> bit is set on the file, using the <span class="No-Break">group’s rights.</span></p>
<p>When misused, these specific rights present a security risk. For instance, if any user is permitted to run a command with superuser capabilities, that user will be able to access files that belong to root as well as to other users. It is simple to understand how this might quickly wreak havoc on a system: crucial files may be deleted, individual directories could be completely erased, and even hardware could end up acting erratically. All of this can be brought about by a single wicked or careless person. The <strong class="source-inline">setuid</strong> and <strong class="source-inline">setgid</strong> bits must therefore be used with <span class="No-Break">extreme caution.</span></p>
<p>In <strong class="source-inline">/usr/bin/passwd</strong>, the <strong class="source-inline">setuid</strong> bit is required and is an acceptable use case. Although root owns this file, any user can change their own password by using it (but not that of <span class="No-Break">other users).</span></p>
<p> When the sticky bit is set on a directory, no one other than the owner, the directory’s owner, or root can delete files from that directory. This is commonly used to prevent a user from erasing the files of other users in a <span class="No-Break">shared directory.</span></p>
<p>The <strong class="source-inline">setuid</strong> bit is set for <strong class="source-inline">testfile</strong> <span class="No-Break">as follows:</span></p>
<pre class="source-code">
sudo chmod u+s testfile</pre>
<p>The <strong class="source-inline">setgid</strong> bit is set for <strong class="source-inline">testfile</strong> <span class="No-Break">as follows:</span></p>
<pre class="source-code">
sudo chmod g+s testfile</pre>
<p>To create a directory named <strong class="source-inline">packtdir</strong> and set the sticky bit on it, use the <span class="No-Break">following command:</span></p>
<pre class="source-code">
sudo mkdir packtdir
sudo chmod +t packtdir</pre>
<p>Going back to <strong class="source-inline">/etc/sudoers</strong>, we can also grant superuser access to every user in a group by using the <strong class="source-inline">/etc/sudoers</strong> file. For instance, the following command specifies that users who belong to <strong class="source-inline">packtgroup</strong> are permitted to run <strong class="source-inline">updatedb</strong> (or more <span class="No-Break">specifically, </span><span class="No-Break"><strong class="source-inline">/usr/bin/updatedb</strong></span><span class="No-Break">):</span></p>
<pre class="source-code">
/usr/bin/updatedb %packtgroup ALL=(ALL)</pre>
<p>The group<a id="_idIndexMarker352"/> name must be preceded by the <strong class="source-inline">%</strong> sign, which is the only distinction between group members and individual users. In this situation, command aliases are <span class="No-Break">also applicable.</span></p>
<p>Simply type <strong class="source-inline">sudo -l</strong> in the command line and hit <em class="italic">Enter</em> to display the calling user’s permitted commands <span class="No-Break">in </span><span class="No-Break"><strong class="source-inline">/etc/sudoers</strong></span><span class="No-Break">.</span></p>
<p>Using groups can save a lot of time. Imagine assigning one group permissions to run some commands, rather than 100 users one <span class="No-Break">by one.</span></p>
<h1 id="_idParaDest-106"><a id="_idTextAnchor133"/>Summary</h1>
<p>Managing users and permissions is something that will be required of you very frequently in sectors related to Linux administration, such as system administration and network security. This is something that will become embedded in your mental toolkit as new users join your organization while others depart. However, even if you are the only person who uses your servers, you will still need to manage permissions. This is due to the fact that processes are unable to run properly if they are denied access to the resources that they require in order to do <span class="No-Break">their tasks.</span></p>
<p>In this chapter, we dove deep into the process of managing users, groups, and permissions and covered a lot of ground. We proceeded through the process of creating new users, removing existing users, assigning rights, and managing administrative access with the <strong class="source-inline">sudo</strong> command. Put these ideas into practice on your <span class="No-Break">own server.</span></p>
<p>In the next chapter, we will talk about software installation and <span class="No-Break">package repositories.</span></p>
</div>
</div></body></html>