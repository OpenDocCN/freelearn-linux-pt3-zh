<html><head></head><body>
		<div id="_idContainer046">
			<h1 id="_idParaDest-35" class="chapter-number"><a id="_idTextAnchor034"/>2</h1>
			<h1 id="_idParaDest-36"><a id="_idTextAnchor035"/>Exploring PowerShell Cmdlets and Syntax</h1>
			<p>Now we’ve got PowerShell installed, it’s time to get down to using it. The power of PowerShell lies in the huge number of cmdlets available for it. In this chapter, we’re going to learn about these. First, we’ll see how the naming conventions work, then we will learn how to control what they do <span class="No-Break">with parameters.</span></p>
			<p>We’ll take quite a deep dive into the syntax so that we understand exactly which parameters are available to a cmdlet and what information those parameters need to work. We’ll then look at how to get more cmdlets to work with, both from our local machine and from <span class="No-Break">external sources.</span></p>
			<p>Finally, we’ll talk about working interactively with PowerShell and will install an exciting new application for Windows that will help us do just that. By the end of the chapter, you will be able to confidently find and use unfamiliar cmdlets and be able to use the versatile Windows <span class="No-Break">Terminal application.</span></p>
			<p>In this chapter, we’re going to cover the following <span class="No-Break">main topics:</span></p>
			<ul>
				<li>What <span class="No-Break">are cmdlets?</span></li>
				<li>Understanding <span class="No-Break">cmdlet syntax</span></li>
				<li>How to find <span class="No-Break">more cmdlets</span></li>
				<li>Working interactively <span class="No-Break">with PowerShell</span></li>
			</ul>
			<h1 id="_idParaDest-37"><a id="_idTextAnchor036"/>Technical requirements</h1>
			<p>This chapter assumes you have a client machine, an internet connection, and have installed the latest stable version of PowerShell 7. The last two sections of this chapter— <em class="italic">Windows Terminal – an alternative terminal emulator</em> and <em class="italic">Installing Windows Terminal from the Windows Store</em>—are specifically for Windows users. Those of us on Linux and macOS can feel happy that we don’t need to do these parts, as those operating systems already contain <span class="No-Break">multi-tabbed terminals.</span></p>
			<h1 id="_idParaDest-38"><a id="_idTextAnchor037"/>What are cmdlets?</h1>
			<p><strong class="bold">Cmdlets</strong> (pronounced <em class="italic">command-lets</em>) are the commands we use in PowerShell. They can either <a id="_idIndexMarker085"/>be entered via a terminal application or through a script. They may be <strong class="bold">script-based</strong> and constructed from other cmdlets, or they may be <strong class="bold">binary</strong> cmdlets written in <strong class="bold">C#</strong>. The cmdlets that install by default with PowerShell are binaries. Usually, cmdlets that we write ourselves or download from the internet will be script-based. Cmdlets take an <strong class="bold">input object</strong> from the pipeline, perform an action on it, and generally return an object for further processing. We will describe this in detail in <a href="B17600_03.xhtml#_idTextAnchor049"><span class="No-Break"><em class="italic">Chapter 3</em></span></a>, <em class="italic">The PowerShell Pipeline – How to String </em><span class="No-Break"><em class="italic">Cmdlets Together</em></span><span class="No-Break">.</span></p>
			<h2 id="_idParaDest-39"><a id="_idTextAnchor038"/>Exploring cmdlet structure</h2>
			<p>We’ve already <a id="_idIndexMarker086"/>used a few cmdlets, and you may have noticed that they have a common structure: <strong class="source-inline">Get-Help</strong>, <strong class="source-inline">Get-Command</strong>, <strong class="source-inline">Get-Member</strong>. This is a <strong class="bold">verb-noun</strong> structure, and it’s intended to help us understand what a cmdlet does. The <strong class="bold">verb</strong> at the start tells us that in each case, these cmdlets are going to <em class="italic">get</em> something: help, a list of commands, or a list of members. There is a list of approved verbs <span class="No-Break">here: </span><a href="https://docs.microsoft.com/en-us/powershell/scripting/developer/cmdlet/approved-verbs-for-windows-powershell-commands?view=powershell-7.2"><span class="No-Break">https://docs.microsoft.com/en-us/powershell/scripting/developer/cmdlet/approved-verbs-for-windows-powershell-commands?view=powershell-7.2</span></a><span class="No-Break">.</span></p>
			<p>Why do we need a list of approved verbs? For the sake of clarity; one of the primary purposes of PowerShell is to be easily understood. By limiting the number of verbs and clearly defining what each one means and when it should be used, we can tell immediately what a cmdlet will do. For instance, a cmdlet named <strong class="source-inline">Delete-Item</strong> might be just as obvious as <strong class="source-inline">Remove-Item</strong>, but how about <strong class="source-inline">Eliminate-Item</strong>? It’s possible this is going to do something unpleasant and terminal. Most well-written cmdlets will conform to this list; hopefully, anything we write will <span class="No-Break">as well.</span></p>
			<p>Notice that not all the verbs in that list are actual verbs in English. <strong class="source-inline">New</strong> is not a verb, but for the purposes of cmdlets, we’re going to use it <span class="No-Break">as one.</span></p>
			<p class="callout-heading">Activity 1</p>
			<p class="callout">When should we use <strong class="source-inline">New</strong>, and when should we use <strong class="source-inline">Add</strong>? Check out the preceding link to <span class="No-Break">find out.</span></p>
			<p>The second part of the cmdlet is the <strong class="bold">noun</strong>. These are not so tightly defined; the first rule is that they are always singular: <strong class="source-inline">Get-Process</strong>, never <strong class="source-inline">Get-Processes</strong>. The second rule <a id="_idIndexMarker087"/>is that they should be descriptive; that is, they should be immediately understandable. This can lead to some long cmdlet names, such as <strong class="source-inline">Get-NetAdapterAdvancedProperty</strong>. This is a bit of a mouthful, but it’s easily understood. Autocomplete, which we have already looked at in <a href="B17600_01.xhtml#_idTextAnchor013"><span class="No-Break"><em class="italic">Chapter 1</em></span></a>, <em class="italic">Introduction to PowerShell 7 – What It Is and How to Get It</em>, makes typing long cmdlets much easier. Type the first part of the noun, hit <em class="italic">Tab</em>, type the next part, hit <em class="italic">Tab</em> again, and so on until the cmdlet is complete. Try it with <strong class="source-inline">Get-NetAdapterAdvancedProperty</strong>. We only need to type <strong class="source-inline">Get-NetA</strong>, then press <em class="italic">Tab</em> twice to arrive at the right cmdlet. Repeatedly pressing <em class="italic">Tab</em> will cycle through the appropriate cmdlets on a Windows machine, or present you with a list of options on Linux <span class="No-Break">and macOS.</span></p>
			<p>There are also some standards around capitalization; <strong class="bold">CamelCase</strong> is preferred, whereby each word in the noun is capitalized. This not only makes it easier for us to read from the screen, but it also means that accessibility tools such as screen readers can handle <span class="No-Break">them correctly.</span></p>
			<h2 id="_idParaDest-40"><a id="_idTextAnchor039"/>The correct use of aliases</h2>
			<p>There is a way <a id="_idIndexMarker088"/>around cumbersome cmdlet names: <strong class="bold">aliases</strong>. Type <strong class="source-inline">Get-Alias</strong> into the command line. You should see a fairly long list of aliases for common cmdlets. For example, you should see that <strong class="source-inline">man</strong> is an alias for <strong class="source-inline">Get-Help</strong>. Try it; type in the following code and see <span class="No-Break">what happens:</span></p>
			<pre class="console">
man Get-Command</pre>			<p>There are two types of aliases, which exist for different reasons. Let’s have a closer look at <span class="No-Break">them here:</span></p>
			<ul>
				<li><strong class="bold">Abbreviations</strong>, such as <strong class="source-inline">gci</strong> for <strong class="source-inline">Get-ChildItem</strong>. These often require you to already <a id="_idIndexMarker089"/>know what the correct cmdlet is and can be quite cryptic. They are for people who know PowerShell and want to <span class="No-Break">save time.</span></li>
				<li><strong class="bold">Synonyms</strong>—We’ve just used one in the preceding code snippet. <strong class="source-inline">man</strong> is a Unix command <a id="_idIndexMarker090"/>that calls the <strong class="bold">manual</strong>. Similarly, <strong class="source-inline">ls</strong> and <strong class="source-inline">dir</strong> are both aliases for <strong class="source-inline">Get-ChildItem</strong> and produce output that looks like the output you might expect if you are familiar with the <strong class="source-inline">ls</strong> Unix command or the <strong class="source-inline">dir</strong> Windows command. These are for old people like me so that years of muscle memory don’t have to <span class="No-Break">be relearned.</span></li>
			</ul>
			<p class="callout-heading">Note</p>
			<p class="callout">While we can type <strong class="source-inline">dir</strong> in PowerShell and get relevant output, we are not getting output from the <strong class="source-inline">dir</strong> command. The command switches we may be familiar with in <strong class="source-inline">dir</strong> won’t work in PowerShell. We are calling a cmdlet with <span class="No-Break">similar functionality.</span></p>
			<p>We can <a id="_idIndexMarker091"/>also define our own aliases for cmdlets we use regularly using the <strong class="source-inline">Set-Alias</strong> cmdlet. We can do it <span class="No-Break">like this:</span></p>
			<pre class="console">
Set-Alias -Name adapters -Value Get-NetAdapter</pre>			<p>Try it. Type in the preceding cmdlet, and then type in <strong class="source-inline">adapters</strong>. You should see something <span class="No-Break">like this:</span></p>
			<div>
				<div id="_idContainer025" class="IMG---Figure">
					<img src="image/B17600_02_001.jpg" alt="Figure 2.1 – Setting an alias"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 2.1 – Setting an alias</p>
			<p>The drawback to doing this is that the alias you set is only available in the current PowerShell session. When you close the window, all your custom aliases are lost. You can save <a id="_idIndexMarker092"/>them in your PowerShell profile, but they’ll still only be available locally. I avoid using custom aliases and rely on autocomplete instead. It’s also poor practice to use them in a script, as this can <span class="No-Break">hinder readability.</span></p>
			<p>Now we have an understanding of what a cmdlet is, let’s take a look at the syntax we need to use <span class="No-Break">with them.</span></p>
			<h1 id="_idParaDest-41"><a id="_idTextAnchor040"/>Understanding cmdlet syntax</h1>
			<p>We’ve already <a id="_idIndexMarker093"/>seen that you can pass information to cmdlets for input, or to modify the output. For instance, in the previous section, we typed <span class="No-Break">the following:</span></p>
			<pre class="console">
Set-Alias -Name adapters -Value Get-NetAdapter</pre>			<p>The cmdlet is called <strong class="source-inline">Set-Alias</strong>, but there are two bits of information after that: <strong class="source-inline">-Name</strong> and <strong class="source-inline">-Value</strong>. These <a id="_idIndexMarker094"/>are called <strong class="bold">parameters</strong>. They are denoted by the dash character (<strong class="source-inline">-</strong>), which tells PowerShell that the following characters up to the next <em class="italic">space</em> character represent an instruction, rather than a value. In each of the preceding parameters we’ve passed a string—we’ve told <strong class="source-inline">Set-Alias</strong> that the value of <strong class="source-inline">-Name</strong> is <strong class="source-inline">adapters</strong>, and <strong class="source-inline">-Value</strong> is <strong class="source-inline">Get-NetAdapter</strong>. Now, when we type <strong class="source-inline">adapters</strong> at Command Prompt, PowerShell knows to substitute it <span class="No-Break">with </span><span class="No-Break"><strong class="source-inline">Get-NetAdapter</strong></span><span class="No-Break">.</span></p>
			<p>That’s great, but how do we know which parameters a cmdlet will take? Well, we’re going to go back to our friend <strong class="source-inline">Get-Help</strong> from <a href="B17600_01.xhtml#_idTextAnchor013"><span class="No-Break"><em class="italic">Chapter 1</em></span></a>, <em class="italic">Introduction to PowerShell 7 – What It Is and How to Get It</em>. Open a PowerShell prompt and type <span class="No-Break">the following:</span></p>
			<pre class="console">
Get-Help Get-Random</pre>			<p>This will call up the <strong class="source-inline">Get-Random</strong> help file. We are interested in the <strong class="source-inline">SYNTAX</strong> section, <span class="No-Break">shown next:</span></p>
			<div>
				<div id="_idContainer026" class="IMG---Figure">
					<img src="image/B17600_02_002.jpg" alt="Figure 2.2 – Get-Random syntax"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 2.2 – Get-Random syntax</p>
			<p>Well, that’s great, but what does it all mean? The help file tells us that <strong class="source-inline">Get-Random</strong> can operate <a id="_idIndexMarker095"/>in three different ways; there is a set of parameters for each. Let’s concentrate on the first set. Remember, parameters always start with a dash (<strong class="source-inline">-</strong>), so we can see there are four parameters in that first set: <strong class="source-inline">-Maximum</strong>, <strong class="source-inline">-Minimum</strong>, <strong class="source-inline">-Count</strong>, and <strong class="source-inline">-SetSeed</strong>. As it says in the <strong class="source-inline">DESCRIPTION</strong> section: <strong class="source-inline">You can use the parameters of Get-Random to specify the minimum and maximum values, the number of objects returned from a collection, or a seed number</strong>. Hopefully, you completed the <em class="italic">Exercises</em> section in <a href="B17600_01.xhtml#_idTextAnchor013"><span class="No-Break"><em class="italic">Chapter 1</em></span></a>, <em class="italic">Introduction to PowerShell 7 – What It Is and How to Get It</em>, so you’ve seen this before. Let’s look at the second parameter set. There are three parameters there: <strong class="source-inline">-InputObject</strong>, <strong class="source-inline">-Count</strong>, and <strong class="source-inline">-SetSeed</strong>. Using these parameters makes <strong class="source-inline">Get-Random</strong> do something different. Instead of returning a random number, now it will return a random object from a list you give it in the first parameter. Let’s try it. In a PowerShell prompt, type <span class="No-Break">the following:</span></p>
			<pre class="console">
Get-Random -InputObject "apples", "pears", "bananas"</pre>			<p>Hopefully, <strong class="source-inline">Get-Random</strong> will return a random piece of fruit from that list. The comma character tells PowerShell that there are more items to come in <span class="No-Break">the list.</span></p>
			<p>The following screenshot shows some of the ways you can get <span class="No-Break">this wrong:</span></p>
			<div>
				<div id="_idContainer027" class="IMG---Figure">
					<img src="image/B17600_02_003.jpg" alt="Figure 2.3 – Passing a list of items the wrong way"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 2.3 – Passing a list of items the wrong way</p>
			<p>In the first example, I’ve only passed a single item with a lot of <span class="No-Break">double quotes.</span></p>
			<p>In the second one, I’ve passed a single item to the <strong class="source-inline">-InputObject</strong> parameter, and PowerShell is interpreting the second string, <strong class="source-inline">pears</strong>, as input for another parameter and <span class="No-Break">getting confused.</span></p>
			<p>In the third example, PowerShell is waiting for the next item in the list, shown by the <strong class="source-inline">&gt;&gt;</strong> symbol. If you find yourself with this and you don’t know what to type next, press <em class="italic">Ctrl</em> + <em class="italic">C</em> to <span class="No-Break">break out.</span></p>
			<p>But the <strong class="source-inline">SYNTAX</strong> section tells us a lot more than just the names and sets of the parameters. It also <a id="_idIndexMarker096"/>tells us which parameters are mandatory, which ones accept more than one item, which ones need to be explicitly named, and which types of values each parameter will accept. Hold tight—this is going to get a bit complicated. Let’s look at the <strong class="source-inline">SYNTAX</strong> section of the help file for <strong class="source-inline">Get-Random</strong> again, in the following screenshot. Keep your eyes on the <span class="No-Break">square brackets:</span></p>
			<div>
				<div id="_idContainer028" class="IMG---Figure">
					<img src="image/B17600_02_004.jpg" alt="Figure 2.4 – Get-Random syntax"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 2.4 – Get-Random syntax</p>
			<p>Our first parameter set starts with <strong class="source-inline">[[-Maximum] &lt;System.Object&gt;]</strong>. <strong class="source-inline">-Maximum</strong> is the parameter name, and <strong class="source-inline">&lt;System.Object&gt;</strong> is the parameter <strong class="bold">argument</strong>; that is, the <strong class="bold">type</strong> of object that the <strong class="source-inline">-Maximum</strong> parameter will take <span class="No-Break">as input.</span></p>
			<p>If you type <strong class="source-inline">Get-Help Get-Random -Full</strong>, then you will see that it only accepts integers, floating-point numbers, or objects that can be interpreted as integers, such as the string <strong class="source-inline">two</strong>, as shown in <span class="No-Break"><em class="italic">Figure 2</em></span><em class="italic">.5</em>. The outer set of square brackets tells us that the <strong class="source-inline">-Maximum</strong> parameter is optional; we don’t need to include it to get a random number. The inner set of square brackets around the parameter name, <strong class="source-inline">[-Maximum]</strong>, tells us that we don’t need to include the parameter name to pass a maximum value to the cmdlet. In the following screenshot, we can see that the parameter has a position value of <strong class="source-inline">0</strong>—this means that the first unnamed argument will be interpreted as belonging to the <strong class="source-inline">-</strong><span class="No-Break"><strong class="source-inline">Maximum</strong></span><span class="No-Break"> parameter:</span></p>
			<div>
				<div id="_idContainer029" class="IMG---Figure">
					<img src="image/B17600_02_005.jpg" alt="Figure 2.5 – Detailed information about the -Maximum and -Minimum parameters"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 2.5 – Detailed information about the -Maximum and -Minimum parameters</p>
			<p>We can see that for the <strong class="source-inline">[-Minimum &lt;System.Object&gt;]</strong> parameter, there is no inner set <a id="_idIndexMarker097"/>of square brackets; this means the <strong class="source-inline">-Minimum</strong> parameter must always be named if we’re going to use it; we actually have to type <strong class="source-inline">-Minimum</strong>. For both the <strong class="source-inline">-Minimum</strong> and <strong class="source-inline">-Maximum</strong> parameters, there are no square brackets around <strong class="source-inline">&lt;System.Object&gt;</strong>. This means that if we use these parameters, we must pass an argument to them of the type <strong class="source-inline">System.Object</strong> (specifically in this case an integer, floating-point number, or string that can be interpreted as <span class="No-Break">a number).</span></p>
			<p>Let’s look at the second set of parameters. It starts with <strong class="source-inline">[-InputObject] &lt;System.Object[]&gt;</strong>; this means if we want to use the second set, we must provide some input. The square brackets around <strong class="source-inline">[-Input.Object]</strong> tell us the name of the parameter is optional, however; PowerShell will interpret the first argument it receives as the input. How is this different from the first set? Look closely at the <strong class="source-inline">&lt;System.Object[]&gt;</strong> argument—it contains a set of square brackets at the end. This shows that it can contain multiple values, separated by a comma. Try this. Type <span class="No-Break">the following:</span></p>
			<pre class="console">
Get-Random 10, 20, 30</pre>			<p>Hopefully, you should get one of those values back. PowerShell knows it has received multiple values and knows not to interpret that collection as an argument for <strong class="source-inline">-Maximum</strong>, because <strong class="source-inline">-Maximum</strong> can only contain a <span class="No-Break">single value.</span></p>
			<p class="callout-heading">Activity 2</p>
			<p class="callout">How might you provide a single numeric value to the <strong class="source-inline">-</strong><span class="No-Break"><strong class="source-inline">InputObject</strong></span><span class="No-Break"> parameter?</span></p>
			<p>Let’s look now at the third set of parameters. At first glance, they look the same as the second set. They both start the same way, but notice at the end is this parameter: <strong class="source-inline">-Shuffle</strong>. It’s got no square brackets and no argument. This is a <strong class="source-inline">switch</strong> parameter. If we use it, we are automatically using the third parameter set; this means the <strong class="source-inline">-Count</strong> parameter is <a id="_idIndexMarker098"/>not available to us, as it’s not in the third set. It doesn’t take any argument because it tells PowerShell to return the entire list in <span class="No-Break">random order.</span></p>
			<p>Each parameter set finishes with <strong class="source-inline">[&lt;CommonParameters&gt;]</strong>. This is a set of parameters that are available for any PowerShell cmdlet. You can read the <strong class="source-inline">about_CommonParameters</strong> help file for more information. They include variables to control the action PowerShell will take in the event of an error, or to produce more output from a cmdlet to help with troubleshooting. More on this in <a href="B17600_10.xhtml#_idTextAnchor201"><span class="No-Break"><em class="italic">Chapter 10</em></span></a>, <em class="italic">Error Handling – Oh No! It’s </em><span class="No-Break"><em class="italic">Gone Wrong!</em></span><span class="No-Break">.</span></p>
			<p>Let’s summarize cmdlet syntax. There are six types of parameters, <span class="No-Break">listed next:</span></p>
			<ul>
				<li><strong class="bold">Mandatory parameters</strong>: The parameter name and argument have no square brackets. Both <a id="_idIndexMarker099"/>the name and an argument must be supplied. For example, <strong class="source-inline">Start-Service</strong> has a mandatory <span class="No-Break">parameter: </span><span class="No-Break"><strong class="source-inline">-DisplayName</strong></span><span class="No-Break">.</span></li>
				<li><strong class="bold">Mandatory positional parameters</strong>: The parameter name is enclosed in square <a id="_idIndexMarker100"/>brackets, but the argument is not. The <strong class="source-inline">Get-Random</strong> parameter <strong class="source-inline">-InputObject</strong> is an example <span class="No-Break">of this.</span></li>
				<li><strong class="bold">Optional parameters</strong>: The <a id="_idIndexMarker101"/>parameter name and argument are enclosed in square brackets, but there is no second set of brackets enclosing just the parameter name. The <strong class="source-inline">Get-Random</strong> parameter <strong class="source-inline">-Count</strong> is an example <span class="No-Break">of this.</span></li>
				<li><strong class="bold">Optional positional parameters</strong>: <strong class="source-inline">-Maximum</strong> is an example of this in the <strong class="source-inline">Get-Random</strong> cmdlet. The whole parameter is enclosed in square brackets, then <a id="_idIndexMarker102"/>there is a second set enclosing just the <span class="No-Break">parameter name.</span></li>
				<li><strong class="bold">Switch parameters</strong>: These parameters take no argument, a bit like my mother. They <a id="_idIndexMarker103"/>may be mandatory or optional, but they are never positional. <strong class="source-inline">-Shuffle</strong> is a good example of a mandatory <span class="No-Break">switch parameter.</span></li>
				<li><strong class="bold">Common parameters</strong>: These <a id="_idIndexMarker104"/>are parameters that are available to all PowerShell cmdlets, and allow you to direct output or control <span class="No-Break">error behavior.</span></li>
			</ul>
			<p>Parameters <a id="_idIndexMarker105"/>are organized into <strong class="bold">parameter sets</strong> for each cmdlet; which parameters you specify when you type the cmdlet determine which parameter set you use, and this <a id="_idIndexMarker106"/>radically alters the behavior of the cmdlet. For example, <strong class="source-inline">Get-Random</strong> can return a random number, a random item from a list, or the whole list in <span class="No-Break">random order.</span></p>
			<p>Now we understand what cmdlets and parameters are, you’re probably wondering where we get them. There are lots included when we download PowerShell, but it’s not going to be anything like enough. We’ll explore how to get more <span class="No-Break">cmdlets next.</span></p>
			<h1 id="_idParaDest-42"><a id="_idTextAnchor041"/>How to find more cmdlets</h1>
			<p>Cmdlets are <a id="_idIndexMarker107"/>usually bundled together into packages called modules. We’ll cover module structure in detail in <a href="B17600_11.xhtml#_idTextAnchor218"><span class="No-Break"><em class="italic">Chapter 11</em></span></a>, <em class="italic">Creating Our First Module</em>, but for now, it is enough to know that a module is a collection of cmdlets with a common theme, such as interacting with a particular application or performing a set of similar functions. Once a module is installed and imported, the cmdlets become available in the shell or to <span class="No-Break">a script.</span></p>
			<h2 id="_idParaDest-43"><a id="_idTextAnchor042"/>Finding modules and cmdlets on your machine</h2>
			<p>We already <a id="_idIndexMarker108"/>have a number of modules available to us. Try this; type <strong class="source-inline">Get-Module</strong> into your shell. Depending on how long PowerShell has been installed, how long the session has been open, and the platform we are working on, we should see a relatively short list—something <span class="No-Break">like this:</span></p>
			<div>
				<div id="_idContainer030" class="IMG---Figure">
					<img src="image/B17600_02_006.jpg" alt="Figure 2.6 – List of imported modules"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 2.6 – List of imported modules</p>
			<p>That’s a list of modules that have been imported into the current session. But that’s not all the modules that we can use right now. Try running the cmdlet again, <span class="No-Break">like this:</span></p>
			<pre class="console">
Get-Module -ListAvailable</pre>			<p>You should see a few more; if you’re running on Windows, you’ll see a <span class="No-Break">lot more.</span></p>
			<p>The output of the cmdlet will be split according to the directory the modules are in, as shown in the <span class="No-Break">following screenshot:</span></p>
			<div>
				<div id="_idContainer031" class="IMG---Figure">
					<img src="image/B17600_02_007.jpg" alt="Figure 2.7 – Modules and their directories"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 2.7 – Modules and their directories</p>
			<p>As you can see, on my machine, that cmdlet has found modules from PowerShell 7 Preview and modules from Windows PowerShell, as well as many others. PowerShell uses the <strong class="source-inline">PSModulePath</strong> environment variable to know where to look for modules in your environment. We can check which locations are in that variable by typing <span class="No-Break">the following:</span></p>
			<pre class="console">
 $env:PSModulePath -split ";"</pre>			<p>You’ll need to use a colon if you’re working on a Linux or <span class="No-Break">macOS device.</span></p>
			<p>Locations <a id="_idIndexMarker109"/>are put in that variable each time PowerShell is started, but they can also be added by applications, or even manually. You can see the results from my machine in the following screenshot. Notice the last entry is for <strong class="source-inline">Microsoft Message Analyzer</strong>; this was added when I installed <span class="No-Break">that application:</span></p>
			<div>
				<div id="_idContainer032" class="IMG---Figure">
					<img src="image/B17600_02_008.jpg" alt="Figure 2.8 – The PSModulePath variable"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 2.8 – The PSModulePath variable</p>
			<p>While we can add paths manually, for most purposes it is better to make sure we install modules to the default paths. There’s lots more about the <strong class="source-inline">PSModulePath</strong> variable in the <strong class="source-inline">about_PSModulePath</strong> <span class="No-Break">help file.</span></p>
			<p>Now we know where to find modules on our machine, how do we know which cmdlets are in them? Notice in <span class="No-Break"><em class="italic">Figure 2</em></span><em class="italic">.7</em> that there are properties in the <strong class="source-inline">ExportedCommands</strong> table; these are the cmdlets that will be available when we import the module. There may be cmdlets that aren’t exported and can only be used internally within the module; we won’t be able to type these in and use them. We can see just the exported cmdlets by running <strong class="source-inline">Get-Command –Module</strong>, followed by the name of <span class="No-Break">the module.</span></p>
			<p>Let’s try something. In <a href="B17600_01.xhtml#_idTextAnchor013"><span class="No-Break"><em class="italic">Chapter 1</em></span></a>, <em class="italic">Introduction to PowerShell 7 – What It Is and How to Get It</em>, we used the <strong class="source-inline">Get-Command</strong> cmdlet to find cmdlets. That cmdlet searches all the available modules for cmdlets, or we can tell it to just search imported ones. Let’s say we’re interested in cmdlets for manipulating modules. We might type the following to get a list of cmdlets that include the word <strong class="source-inline">module</strong> in <span class="No-Break">the name:</span></p>
			<pre class="console">
Get-Command *module*</pre>			<p>However, if we type the following, then we will only get cmdlets from modules that we have already <a id="_idIndexMarker110"/>imported into the <span class="No-Break">current session:</span></p>
			<pre class="console">
 Get-Command *module* -ListImported</pre>			<p>This shows how those two cmdlets look on <span class="No-Break">my machine:</span></p>
			<div>
				<div id="_idContainer033" class="IMG---Figure">
					<img src="image/B17600_02_009.jpg" alt="Figure 2.9 – Imported and installed cmdlets"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 2.9 – Imported and installed cmdlets</p>
			<p>How do we use cmdlets from modules that haven’t been imported? In two ways, <span class="No-Break">as follows:</span></p>
			<ul>
				<li>Firstly, we can use the <strong class="source-inline">Import-Module</strong> cmdlet to bring the module into the session, and then use the cmdlet <span class="No-Break">we need.</span></li>
				<li>Or, we can just use it anyway and allow PowerShell to implicitly <span class="No-Break">import it.</span></li>
			</ul>
			<p>Try it. In <span class="No-Break"><em class="italic">Figure 2</em></span><em class="italic">.6</em>, there is a list of imported modules for my current session. It doesn’t contain the <strong class="source-inline">PowerShellGet</strong> module. It’s probable that your current session hasn’t imported that module either, so let’s do that now. Type <span class="No-Break">the following:</span></p>
			<pre class="console">
 Get-InstalledModule</pre>			<p>You’ll notice <a id="_idIndexMarker111"/>a little bit of a pause as PowerShell imports the <strong class="source-inline">PowerShellGet</strong> module, and then you’ll see a list of installed modules if any have been installed. That’s great, but the clever bit is this: type <strong class="source-inline">Get-Module</strong> again, to get a list of imported modules. You should see <strong class="source-inline">PowerShellGet</strong> has been imported in the background, <span class="No-Break">as follows:</span></p>
			<div>
				<div id="_idContainer034" class="IMG---Figure">
					<img src="image/B17600_02_010.jpg" alt="Figure 2.10 – As if by magic… the module appears"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 2.10 – As if by magic… the module appears</p>
			<p>That leads to two questions. The first one is this: Why bother with importing and installing? Why not make all the cmdlets available every time, right from the start? The short answer is <strong class="bold">space</strong>. Each imported module requires a memory space; if we import hundreds of modules and thousands of cmdlets, then every time we start PowerShell, it will get incredibly unwieldy and slow, so we just import the modules and cmdlets we need, as we <span class="No-Break">need them.</span></p>
			<p>The other question is this: Why do we need an <strong class="source-inline">Import-Module</strong> cmdlet if we can get cmdlets implicitly? We need <strong class="source-inline">Import-Module</strong> for two reasons; firstly, you might not install a module into one of the default paths in <strong class="source-inline">PSModulePath</strong>, so implicit importing won’t be available. Secondly, you might want to control how the module is imported. For instance, you might not want to import cmdlets from a module that has the same name as cmdlets you have already imported, in which case you would use <strong class="source-inline">Import-Module</strong> with the <strong class="source-inline">-NoClobber</strong> parameter, rather than <span class="No-Break">import implicitly.</span></p>
			<p class="callout-heading">Activity 3</p>
			<p class="callout">How might we import cmdlets, but change their names so that we know which module they <span class="No-Break">are from?</span></p>
			<h2 id="_idParaDest-44"><a id="_idTextAnchor043"/>Finding new modules and cmdlets</h2>
			<p>So far, we’ve <a id="_idIndexMarker112"/>looked at modules that are already on our system, but we have just now imported <strong class="source-inline">PowerShellGet</strong>, and it’s really useful because it can help us find modules that are held remotely, in a <strong class="bold">repository</strong>. Repositories are storage locations for software packages; usually, it has a table of contents, contains metadata about the packages, and has some form of version control, allowing us to select a particular version of the software it contains. Many applications <a id="_idIndexMarker113"/>and operating systems have official repositories; Python has the <strong class="bold">Python Package Index</strong> (<strong class="bold">PyPI</strong>), Docker has Docker Hub, Ubuntu has four repositories, and PowerShell is no different. The official, Microsoft-maintained repository for PowerShell is the PowerShell Gallery, and this is the repository that <strong class="source-inline">PowerShellGet</strong> connects to <span class="No-Break">by default.</span></p>
			<h3>The PowerShell Gallery</h3>
			<p>Let’s start by looking at how we might find modules in the gallery that we are interested in. Try running <span class="No-Break">the following:</span></p>
			<pre class="console">
Get-Command -Module PowerShellGet</pre>			<p>This will <a id="_idIndexMarker114"/>give us a list of the cmdlets that are available in the module. We can see they fall into two categories—cmdlets for finding and <a id="_idIndexMarker115"/>installing resources such as modules and scripts, and cmdlets for managing repositories. Let’s have a look for a module. Try running <span class="No-Break">the following:</span></p>
			<pre class="console">
Find-Module -name *math*</pre>			<p>My results are <span class="No-Break">shown here:</span></p>
			<div>
				<div id="_idContainer035" class="IMG---Figure">
					<img src="image/B17600_02_011.jpg" alt="Figure 2.11 – Math-related modules in the PowerShell Gallery"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 2.11 – Math-related modules in the PowerShell Gallery</p>
			<p>Some of those look more or less useful—I’m not sure that I need <strong class="source-inline">PokerMath</strong>, but you may. How do we know which cmdlets are in those modules? We can’t use <strong class="source-inline">Get-Command</strong>, as the modules are not present on our local machine, but <strong class="source-inline">PowerShellGet</strong> includes the <strong class="source-inline">Find-Command</strong> cmdlet. If we pass <strong class="source-inline">Find-Command</strong> the name of a particular module, then it will list out the cmdlets in that module, <span class="No-Break">like this:</span></p>
			<pre class="console">
Find-Command -ModuleName psmath</pre>			<p>If we run that, we can see that <strong class="source-inline">psmath</strong> contains a whole range of mathematical functions, from the fairly obvious—such as <strong class="source-inline">Get-Math.sqrt</strong>—to some more esoteric ones for <strong class="bold">artificial intelligence</strong> (<strong class="bold">AI</strong>) and statistics. To know how to use the functions, we will need to install the module and examine the help file. We can do this by typing <span class="No-Break">the following:</span></p>
			<pre class="console">
Install-Module psmath</pre>			<p>You may <a id="_idIndexMarker116"/>see a warning that the repository is untrusted, as in the following <a id="_idIndexMarker117"/>screenshot. This is expected, as by default, no repositories are trusted. We need to explicitly trust them with the <span class="No-Break"><strong class="source-inline">Set-PSrepository</strong></span><span class="No-Break"> cmdlet:</span></p>
			<div>
				<div id="_idContainer036" class="IMG---Figure">
					<img src="image/B17600_02_012.jpg" alt="Figure 2.12 – Do you trust this repository?"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 2.12 – Do you trust this repository?</p>
			<p>Type <strong class="source-inline">Y</strong> for yes. After a few seconds of a progress bar, the Command Prompt will reappear. The module is now installed, but not imported. Although we’ve used <strong class="source-inline">PowerShellGet</strong> to install the module, it’s been installed into a location that isn’t in the correct path for implicitly importing it by using one of the cmdlets, but we can explicitly import it using the <strong class="source-inline">Import-Module</strong> cmdlet, <span class="No-Break">like so:</span></p>
			<pre class="console">
Import-Module psmath</pre>			<p>If we now type the following, we will see one of the disadvantages of <span class="No-Break">community-provided modules:</span></p>
			<pre class="console">
Get-Help Get-Math.Sqrt</pre>			<p>A lot of authors are more excited by writing their software than documenting it, and the help is pretty sparse. However, we can see that <strong class="source-inline">Get-Math.Sqrt</strong> takes two parameters: either values or an input object. The <strong class="source-inline">-Values</strong> parameter is positional. Interestingly, it also takes a list of values, not only a single one. You can use the input object to supply the output of another cmdlet or a variable. <span class="No-Break">Try this:</span></p>
			<pre class="console">
Get-Math.Sqrt -InputObject (Get-Random)</pre>			<p>This will generate a random number, and then calculate the square root <span class="No-Break">of it.</span></p>
			<p>Why doesn’t <strong class="source-inline">PowerShellGet</strong> install modules in the right place? This is to do with scope. By default, <strong class="source-inline">PowerShellGet</strong> will install modules for the current user only, into a path in your <strong class="source-inline">Documents</strong> folder if you are on Windows, or into your home drive on Linux. We can <a id="_idIndexMarker118"/>change this by including the <strong class="source-inline">-Scope</strong> parameter with the <strong class="source-inline">AllUsers</strong> argument, but we would need to be running <a id="_idIndexMarker119"/>with administrator rights to do so. In the following screenshot, you can see the error message that comes up in this case. The alternative is to add the location to the <strong class="source-inline">PATH</strong> <span class="No-Break">environment variable:</span></p>
			<div>
				<div id="_idContainer037" class="IMG---Figure">
					<img src="image/B17600_02_013.jpg" alt="Figure 2.13 – I’m afraid I can’t do that, Dave"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 2.13 – I’m afraid I can’t do that, Dave</p>
			<p>We can <a id="_idIndexMarker120"/>also view the PowerShell Gallery online at <a href="https://www.powershellgallery.com/">https://www.powershellgallery.com/</a>. Searching the website for <strong class="source-inline">math</strong> gives a lot more results, as it will not only search the module name but also any associated tags. We can get similar results by using the <strong class="source-inline">-Filter</strong> parameter <span class="No-Break">with </span><span class="No-Break"><strong class="source-inline">Find-Module</strong></span><span class="No-Break">.</span></p>
			<h3>The PowerShell Gallery is not the only repository</h3>
			<p>While the <a id="_idIndexMarker121"/>PowerShell Gallery is great, there are other repositories. You may have an internal repository where you work, or you may decide to build one for yourself later. The advantages of a repository are the version control and the automation it allows. The disadvantages are the maintenance and the potential for exploitation. If you need to use repositories other than the PowerShell Gallery, then <strong class="source-inline">PowerShellGet</strong> includes cmdlets for working with them, such as <strong class="source-inline">Get-</strong><strong class="source-inline">PSRepository</strong>, <strong class="source-inline">Set-PSRepository</strong>, <span class="No-Break">and </span><span class="No-Break"><strong class="source-inline">Register-PSRepository</strong></span><span class="No-Break">.</span></p>
			<h3>Other sources</h3>
			<p>The main alternative to the PowerShell Gallery is GitHub, at <a href="https://github.com">https://github.com</a>, and similar online <a id="_idIndexMarker122"/>source code management tools such as GitLab. These platforms are not specific to PowerShell and contain code written in many other languages. The vast majority of the code is open source in one form or another. The GitHub platform is owned by Microsoft but not moderated by Microsoft, and contains everything ranging from the fully official PowerShell repository, with Microsoft’s own code, to unmaintained incomplete bits of scripts and malware. Unless you absolutely trust the repository owner always, <em class="italic">ALWAYS</em> read the code and understand what it does before <span class="No-Break">downloading it.</span></p>
			<p>We can search GitHub for PowerShell modules by entering our search term on the GitHub website and adding <strong class="source-inline">language:PowerShell</strong>, as seen in the <span class="No-Break">following screenshot:</span></p>
			<div>
				<div id="_idContainer038" class="IMG---Figure">
					<img src="image/B17600_02_014.jpg" alt="Figure 2.14 – 49 repositories on the GitHub website, some of which may be useful"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 2.14 – 49 repositories on the GitHub website, some of which may be useful</p>
			<p>We can also find plenty of PowerShell scripts on the internet; it’s less likely we’ll find full modules, but many useful websites publish perfectly usable scripts outside of source-controlled platforms. The caveat still stands, however, only more so. Even if you trust the author, read the code, and understand what it does before using it. Never just blindly run something and hope it’s OK. PowerShell is extremely powerful, and you should always run it securely. There’ll be plenty more on this in <a href="B17600_12.xhtml#_idTextAnchor236"><span class="No-Break"><em class="italic">Chapter 12</em></span></a>, <span class="No-Break"><em class="italic">Securing PowerShell</em></span></p>
			<p>The final <a id="_idIndexMarker123"/>way to get cmdlets, modules, and scripts is to write them yourself. This is easier than you might think, and we’ll cover it in the second section of the book, starting in <a href="B17600_08.xhtml#_idTextAnchor162"><span class="No-Break"><em class="italic">Chapter 8</em></span></a>, <em class="italic">Writing Our First Script – Turning Simple Cmdlets into </em><span class="No-Break"><em class="italic">Reusable Code</em></span><span class="No-Break">.</span></p>
			<p>We should now have a good idea of the many places where we can find PowerShell resources, and understand their relative value. In the next section, we’ll discuss the most basic way to work with PowerShell, and Windows users can have <span class="No-Break">some fun.</span></p>
			<h1 id="_idParaDest-45"><a id="_idTextAnchor044"/>Working interactively with PowerShell</h1>
			<p>PowerShell is, in my experience, unusual for a programming language, in that the huge number of <a id="_idIndexMarker124"/>cmdlets available make it particularly suitable for interactive use; open a terminal, type a line of code, and see something exciting happen. It is pretty difficult to do this in other interpreted languages, such as Python, because Python doesn’t come with many bundled commands, and it is difficult to import libraries into interactive sessions. Because of this, Python users very quickly move on to writing scripts. In the 10 years I have worked with PowerShell, I’ve found many of my colleagues never really progress from interactive PowerShell, and that’s fine. In the rest of this chapter, we’re going to recap how we’ve been using PowerShell, and Windows users can get to install a really useful utility called Windows Terminal, which will give them the same multi-tabbed terminal experience that Linux and macOS users can get <span class="No-Break">by default.</span></p>
			<p>Each time we’ve entered a line of code, we’ve called a cmdlet. Each cmdlet is a mini-script or program. This is similar to shell scripting; batch scripts in Windows or Bash scripts in Linux, where each line of code we enter calls a <span class="No-Break">defined program.</span></p>
			<p>Most scripts in PowerShell are written in the same way—the script can be run as if it were a cmdlet, with parameters to modify the behavior and actions. This means we can use them interactively as well, allowing us to share our efforts with our less technically inclined colleagues and friends. Before we start writing scripts, however, it would be good to set up a way to easily use PowerShell interactively. The provided shell is much improved with PowerShell 7, including highlighting to make it easier to see what we are typing and improved copy and paste. However, I prefer another <span class="No-Break">tool—Windows Terminal.</span></p>
			<h2 id="_idParaDest-46"><a id="_idTextAnchor045"/>Windows Terminal – an alternative terminal emulator</h2>
			<p>If you use Linux or macOS, you don’t need to do this part, as you already have multi-tabbed <a id="_idIndexMarker125"/>terminals, you lucky people. For Windows users, we had to open multiple applications; in the past, I might have had Windows Console (Command Prompt), Windows PowerShell, PowerShell 7, Azure Cloud Shell, PuTTY, Git Bash, and Python all open at once, running as separate applications. Since 2020, however, there is a much better choice—Windows Terminal. It can run multiple instances <a id="_idIndexMarker126"/>of any command-line program in separate tabs, which is enough to convince me on its own, but it also has support for emojis and glyphs, a split-pane function, and an allegedly fun new font called Cascadia Code, plus it’s open source. There are lots of details in this blog post if you want to know <span class="No-Break">more: </span><a href="https://devblogs.microsoft.com/commandline/introducing-windows-terminal/"><span class="No-Break">https://devblogs.microsoft.com/commandline/introducing-windows-terminal/</span></a><span class="No-Break">.</span></p>
			<p>Windows Terminal is hosted on GitHub at <a href="https://github.com/Microsoft/Terminal">https://github.com/Microsoft/Terminal</a>, and you can download and install the <strong class="source-inline">.msixbundle</strong> file from there. You can also install it using Winget if you installed that earlier, or if you are on Windows 11. The preferred way, however, is to install it from Microsoft Store. This allows the application to be automatically updated—as it is open source, software updates are frequent and often necessary, as they include bug fixes as well <span class="No-Break">as improvements.</span></p>
			<h2 id="_idParaDest-47"><a id="_idTextAnchor046"/>Installing Windows Terminal from Microsoft Store</h2>
			<p>Installing <a id="_idIndexMarker127"/>from the Windows Store <a id="_idIndexMarker128"/>is a breeze. Here’s how to <span class="No-Break">do it:</span></p>
			<ol>
				<li>Type <strong class="source-inline">store</strong> into your search bar in Windows and launch the Microsoft <span class="No-Break">Store app.</span></li>
				<li>Type <strong class="source-inline">Windows Terminal</strong> into the search bar in the <span class="No-Break">Store app.</span></li>
				<li>Click <strong class="bold">Get</strong>, as shown in the <span class="No-Break">following screenshot:</span></li>
			</ol>
			<div>
				<div id="_idContainer039" class="IMG---Figure">
					<img src="image/B17600_02_015.jpg" alt="Figure 2.15 – Getting Windows Terminal: not suitable for toddlers"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 2.15 – Getting Windows Terminal: not suitable for toddlers</p>
			<ol>
				<li value="4">After a few minutes, Terminal will be available in your <span class="No-Break"><strong class="bold">Start</strong></span><span class="No-Break"> menu.</span></li>
			</ol>
			<p>And that’s it. Windows Terminal will now be updated automatically. Let’s start configuring it for our purposes. Because we’ve already installed PowerShell 7, Terminal will default <a id="_idIndexMarker129"/>to that when you open it; if we hadn’t, it would default to Windows PowerShell instead. Depending on which <a id="_idIndexMarker130"/>other applications you have installed on your client, it may automatically pick them up and make them available. Click the <em class="italic">down</em> icon in the toolbar to see what is already available and select an application other than the default, as illustrated in the <span class="No-Break">following screenshot:</span></p>
			<div>
				<div id="_idContainer040" class="IMG---Figure">
					<img src="image/B17600_02_016.jpg" alt="Figure 2.16 – The basic applications available in Windows Terminal"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 2.16 – The basic applications available in Windows Terminal</p>
			<p>That’s great, but it doesn’t begin to cover the number of command-line applications you might have. Let’s see how we can do that. I’ve got Python on my machine because I often <a id="_idIndexMarker131"/>enjoy a change of perspective. If you want to follow along and you don’t have Python installed, you can download <a id="_idIndexMarker132"/>it from <span class="No-Break">here: </span><a href="https://www.python.org/downloads"><span class="No-Break">https://www.python.org/downloads</span></a><span class="No-Break">/.</span></p>
			<p>Python by default installs to <strong class="source-inline">C:\Users\&lt;yourname&gt;\AppData\Local\Programs\Python\&lt;version number&gt;</strong>, as in the following screenshot. You’ll need to make a note of the path, and enable viewing hidden files in <span class="No-Break"><strong class="bold">File Explorer</strong></span><span class="No-Break">:</span></p>
			<div>
				<div id="_idContainer041" class="IMG---Figure">
					<img src="image/B17600_02_017.jpg" alt="Figure 2.17 – Where Python is"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 2.17 – Where Python is</p>
			<p>To configure Windows Terminal to access Python, you’ll need to set up a new profile. Here’s how you can <span class="No-Break">do this:</span></p>
			<ol>
				<li>Start <span class="No-Break">Windows Terminal.</span></li>
				<li>Click the <em class="italic">down</em> button on the toolbar, and <span class="No-Break">select </span><span class="No-Break"><strong class="bold">Settings</strong></span><span class="No-Break">.</span></li>
				<li>Select <strong class="bold">Add a new profile</strong> in the left-hand pane, and click on <strong class="bold">New empty profile</strong>, as shown in the <span class="No-Break">following screenshot:</span></li>
			</ol>
			<div>
				<div id="_idContainer042" class="IMG---Figure">
					<img src="image/B17600_02_018.jpg" alt="Figure 2.18 – Creating a new profile"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 2.18 – Creating a new profile</p>
			<ol>
				<li value="4">Fill in <a id="_idIndexMarker133"/>the name—in my case, I’m using <strong class="source-inline">Python 3.10</strong>, so I know which version of Python it <span class="No-Break">will launch.</span></li>
				<li>Fill in <a id="_idIndexMarker134"/>the path to the <strong class="source-inline">python.exe</strong> <span class="No-Break">executable file.</span></li>
				<li>Select a starting directory, if you like. I like to put all my rubbish in <span class="No-Break">one place.</span></li>
				<li>I like to use icons. You can find Python icons <span class="No-Break">here: </span><span class="No-Break"><strong class="source-inline">C:\Users\&lt;username&gt;\AppData\Local\Programs\Python\Python310\Lib\test\imghdrdata</strong></span><span class="No-Break">.</span></li>
				<li><span class="No-Break">Click </span><span class="No-Break"><strong class="bold">Save</strong></span><span class="No-Break">.</span></li>
			</ol>
			<p>You can see an overview of this in the <span class="No-Break">following screenshot:</span></p>
			<div>
				<div id="_idContainer043" class="IMG---Figure">
					<img src="image/B17600_02_019.jpg" alt="Figure 2.19 – Creating a new profile, completed"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 2.19 – Creating a new profile, completed</p>
			<p>And we’re done. Now, when you click on the <em class="italic">down</em> button in the toolbar, you’ll see <strong class="bold">Python 3.10</strong> as an option. Why have I used Python as an example here? Why didn’t I use the PowerShell 7 Preview version? Because Windows Terminal is pretty clever. If you install <a id="_idIndexMarker135"/>PowerShell 7 Preview <a id="_idIndexMarker136"/>after installing Windows Terminal, just restart Windows Terminal, and voilà! PowerShell 7 Preview will be an option. <span class="No-Break">Cool, eh?</span></p>
			<p>Here, you can see Python running in <span class="No-Break">Windows Terminal:</span></p>
			<div>
				<div id="_idContainer044" class="IMG---Figure">
					<img src="image/B17600_02_020.jpg" alt="Figure 2.20 – Running Python in Windows Terminal"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 2.20 – Running Python in Windows Terminal</p>
			<p>There’s another thing we must do. We’ve discussed the importance of being able to start PowerShell as an administrator; we need to do that for Windows Terminal as well. The easiest <a id="_idIndexMarker137"/>way to do that is to pin <a id="_idIndexMarker138"/>the Terminal app to the taskbar. If you right-click the icon on the taskbar, we can then right-click the <strong class="bold">Terminal</strong> icon in the pop-up menu and select <strong class="bold">Run as administrator</strong>, <span class="No-Break">as follows:</span></p>
			<div>
				<div id="_idContainer045" class="IMG---Figure">
					<img src="image/B17600_02_021.jpg" alt="Figure 2.21 – Running Windows Terminal as an administrator"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 2.21 – Running Windows Terminal as an administrator</p>
			<p>If you <a id="_idIndexMarker139"/>open the settings for a profile in Windows Terminal, then you can set just that profile to run as an administrator. There are lots of other things you can do with Windows Terminal. The settings are available through the <strong class="bold">user interface</strong> (<strong class="bold">UI</strong>), or there is a convenient settings file in <strong class="bold">JavaScript Object Notation</strong> (<strong class="bold">JSON</strong>) that you can <span class="No-Break">edit directly.</span></p>
			<h1 id="_idParaDest-48"><a id="_idTextAnchor047"/>Summary</h1>
			<p>In this chapter, we have explored cmdlets quite thoroughly. By now, we should understand the naming conventions, the syntax that cmdlets use, how to find out the parameters a cmdlet takes, and what to put in them. We then looked at some ways of discovering new cmdlets and modules, both on our local machine and with the PowerShell Gallery. Finally, we discussed working interactively with PowerShell and looked at an exciting new application for Windows users; <span class="No-Break">Windows Terminal.</span></p>
			<p>In the next chapter, we’re going to take a long hard look at the pipeline; how it works, how to string cmdlets together, how to understand what’s gone wrong, and what to do about it. We’ll also look at another great application for working with PowerShell, and this time everyone can install it, not just <span class="No-Break">Windows users.</span></p>
			<h1 id="_idParaDest-49"><a id="_idTextAnchor048"/>Exercises</h1>
			<ol>
				<li>Which of these is the correct cmdlet to obtain the contents of a file in PowerShell: <strong class="source-inline">Get-Content</strong> <span class="No-Break">or </span><span class="No-Break"><strong class="source-inline">Read-Content</strong></span><span class="No-Break">?</span></li>
				<li>What happens if you type <strong class="source-inline">"alive alive" | oh</strong> into the shell, <span class="No-Break">and why?</span></li>
				<li>How many parameter sets does the <strong class="source-inline">Get-ChildItem</strong> cmdlet have? Which parameter determines which set we <span class="No-Break">will use?</span></li>
				<li>If you see the <strong class="source-inline">Get-ChildItem c:\foo *.exe</strong> cmdlet, you can tell that <strong class="source-inline">c:\foo</strong> is an argument being passed to the <strong class="source-inline">-Path</strong> parameter. Which parameter is <strong class="source-inline">*.exe</strong> being <span class="No-Break">passed to?</span></li>
				<li>Without actually trying it, will the <strong class="source-inline">Get-ChildItem c:\foo -Filter *.exe, *.txt</strong> cmdlet run? If not, <span class="No-Break">why not?</span></li>
				<li>How might you find cmdlets to work with <strong class="bold">Amazon Web </strong><span class="No-Break"><strong class="bold">Services</strong></span><span class="No-Break"> (</span><span class="No-Break"><strong class="bold">AWS</strong></span><span class="No-Break">)?</span></li>
				<li>How might you find cmdlets to work <span class="No-Break">with AliCloud?</span></li>
				<li>How could you change the text size in <span class="No-Break">Windows Terminal?</span></li>
			</ol>
		</div>
		<div>
			<div id="_idContainer047" class="Content">
			</div>
		</div>
	</body></html>