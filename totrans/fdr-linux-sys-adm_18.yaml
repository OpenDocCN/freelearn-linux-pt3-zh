- en: '12'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Untangling Security with SELinux
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '*Security*, *Hardening*, *Compliance*, and *Policy*: these are the four horsemen
    of the SysAdmin apocalypse. One of the big battles is maintaining the security
    of the systems. Besides the daily tasks, the security of the systems is part of
    the job, even those systems where the third-party provider asks us to deactivate
    the *enhanced security*. In most of these cases, an analysis is enough to find
    the right troubleshooting method or a workaround.'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
- en: '**Security-Enhanced Linux** (**SELinux**) is a code that runs in the user space,
    leveraging kernel code (**Linux Security Modules**) to provide **mandatory access
    control** (**MAC**) over system resources. The access to system objects and features
    takes place on a per-domain basis following the principle of *least privilege*.'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we are going to learn how to take advantage of the benefits
    of SELinux to secure managed systems, covering the following main topics:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
- en: Learning about mandatory access control
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Labeling and type enforcement
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to troubleshoot SELinux issues
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For the development of the topics in this chapter, it is necessary to install
    the packages indicated in each section. In each section, you will find the instructions
    for the different types of installation of each package as required.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
- en: Learning about mandatory access control
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Linux file permissions control which users or groups of users access specific
    files. But a user with read or write access to a specific file could use that
    file in any way desired, even if that use is not what the file should be used
    for.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
- en: Linux *standard file permissions* succeed when files get used by a single owner
    and a single designated group of people.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
- en: File permissions fail to prevent some forms of unwanted access. They were not
    designed to control how a file gets used, but only who to allow to read, write,
    or run a file.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
- en: Linux standard file permissions are ownership-based, also known as **discretionary
    access** **control** (**DAC**).
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
- en: The MAC rules are *policy* based, not by ownership.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two types of MAC:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
- en: '**Multi-level security systems**: The original and simplest form of MAC consists
    of a vertical structure of protection and security levels. Information only flows
    within this area. A level of protection is also assigned to users, who can thus
    only access the same or lower levels.'
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Multi-lateral security systems**: These systems are more complex and assign
    access based on segments. Those segments form associations, which in turn consist
    of protection levels and code words. This results in a horizontal security system
    that also includes vertical levels of protection.'
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: SELinux is an example of a MAC application on Linux.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
- en: SELinux offers a special security architecture based on the principles of MAC.
    SELinux *minimizes access* to operating system processes and files through strict
    access control methods and corresponding security measures. The module aims to
    ensure data confidentiality and integrity. Furthermore, with SELinux, the operating
    system and user programs remain delimited.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
- en: 'SELinux also relies on two other implementations: **type enforcement** (**TE**)
    and **role-based access control** (**RBAC**). With RBAC, access rights map according
    to a defined role model. The defined user roles abstract the work processes of
    an organization. On a MAC model, TE is the notion that access gets governed through
    clearance based on a *subject-access-object set* *of rules*.'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
- en: SELinux defines security measures and sets extra attributes that state under
    what conditions and in what situations a rights holder could access certain operating
    system processes or files. If these conditions or relationships (i.e., attributes)
    are not met, access is denied.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
- en: SELinux consists of sets of policies that declare exactly what *actions and
    accesses* are allowed for each object used by an application. It is also known
    as a *targeted policy* since the policy covers the activities of a single application.
    Policies declare predefined labels that apply to individual programs, files, and
    network ports.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
- en: SELinux enforces a set of access rules that prevent a security flaw in one application
    from affecting other applications or the system itself. SELinux provides an extra
    layer of security, but it also adds a level of complexity that might seem confusing
    to those unfamiliar with it.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
- en: To better understand how it works, let’s walk through the basic concepts that
    SELinux works with.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
- en: Labeling and type enforcement
  id: totrans-26
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: SELinux is a *labeling system*, which tells us that each file, directory, or
    object in the system has a corresponding label. Each file, process, directory,
    and port has a *special security label* called an SELinux context. A **context**
    is a tag name used by the SELinux policy to determine whether a process can access
    a file, directory, or port. Policies control the interaction between these elements.
    By default, the policy does not allow any interaction unless an explicit rule
    grants access. If no permission rule exists, access is not allowed. The Linux
    kernel enforces these rules.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
- en: 'SELinux contexts have different labels in their format, separated by colons:
    *user*, *role*, *type*, and *sensitivity level*. They are formed as follows:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Note
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
- en: The *sensitivity level* is the part that is optional.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
- en: 'The targeted policy bases its rules on the third context component: the *type*
    context. Type context names usually end with `_t`.'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s look at the following example:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 12.1 – SELinux label example](img/12.1.jpg)'
  id: totrans-34
  prefs: []
  type: TYPE_IMG
- en: Figure 12.1 – SELinux label example
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
- en: 'In the preceding example, the `/var/www/html/file` file has the following context
    components: `unconfined_u` is the SELinux user, the role is `object_r`, the type
    is `httpd_sys_content_t`, and the sensitivity level is `s0`. So, the context on
    which the access of this file depends is `httpd_sys_content_t`.'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
- en: Let’s use a demo example with this file to learn how the SELinux policy works.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
- en: How SELinux works
  id: totrans-38
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Before analyzing the operation of SELinux, let’s determine how SELinux is running
    on the system.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
- en: 'SELinux runs in three modes:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
- en: '**Enforcing**: SELinux enforces access control rules. This is the Fedora Linux
    default enabled mode.'
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Permissive**: SELinux is active but instead of enforcing access control rules,
    it *logs warnings* of rules violated. This mode gets used for testing and troubleshooting.'
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Disabled**: SELinux is completely *disabled*; no SELinux violations are denied
    or even logged. *This is not recommended under* *any circumstances*.'
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'To find out how SELinux is running, use the `sestatus` command:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The SELinux running mode gets configured in the `/``etc/selinux/config` file:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 12.2 – SELinux config file](img/12.2.jpg)'
  id: totrans-47
  prefs: []
  type: TYPE_IMG
- en: Figure 12.2 – SELinux config file
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
- en: 'During execution, for testing, the SELinux mode could change. But upon *rebooting*
    the system, it will again take the mode configured in the configuration file to
    set it. Use the `getenforce` command to find out the mode SELinux is running in
    and the `setenforce` command to change the mode, as the `root` user:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 12.3 – Changing the SELinux run mode](img/12.3.jpg)'
  id: totrans-50
  prefs: []
  type: TYPE_IMG
- en: Figure 12.3 – Changing the SELinux run mode
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
- en: Now, let us see how SELinux works.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
- en: So, how does SELinux work?
  id: totrans-53
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Linux was born in the early days of the operating system’s usefulness. It’s
    used as the main operating system running a web server.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
- en: The Apache web server (`httpd`) is not insecure, but its *access range* is very
    wide so it is very important to secure it.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
- en: 'So, let’s start with this example to understand how SELinux works. Follow the
    subsequent steps:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
- en: 'Verify that the **httpd** service is installed and active on the system:'
  id: totrans-57
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 12.4 – Status of the httpd service](img/12.4.jpg)'
  id: totrans-58
  prefs: []
  type: TYPE_IMG
- en: Figure 12.4 – Status of the httpd service
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
- en: 'If not, use the **dnf** and **systemctl** commands to perform this:'
  id: totrans-60
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-61
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The Linux kernel integrates an option, in most commands, to know the SELinux
    context type. Use the **ls** command with the **-Z** (or **–context**) option
    to identify the SELinux context type of the binary file:'
  id: totrans-62
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-63
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The configuration files for the **httpd** service are found in **/etc/httpd**.
    Let’s see what context type they have:'
  id: totrans-64
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-65
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The logs of the **httpd** service are found in **/var/log/httpd**. Find their
    context type using the following:'
  id: totrans-66
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-67
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The content type directory of the **httpd** service is found in **/var/www/html**.
    Find their context using the following:'
  id: totrans-68
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-69
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The unit file for the **httpd** service startup is found in **/usr/lib/systemd/system/**.
    Find its context type using the following:'
  id: totrans-70
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-71
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Use the **ps** command to find the context type of the **httpd** service daemon
    while it is running:'
  id: totrans-72
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-73
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '![Figure 12.5 – Finding the context of the httpd daemon](img/12.5.jpg)'
  id: totrans-74
  prefs: []
  type: TYPE_IMG
- en: Figure 12.5 – Finding the context of the httpd daemon
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
- en: The context type of the service daemon is `httpd_t`.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
- en: 'Use the **netstat** command to find the context type of the **httpd** service
    port while it is running:'
  id: totrans-77
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-78
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '![Figure 12.6 – Finding the context of the httpd port](img/12.6.jpg)'
  id: totrans-79
  prefs: []
  type: TYPE_IMG
- en: Figure 12.6 – Finding the context of the httpd port
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
- en: The context type of the service port is `httpd_t`.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
- en: 'The preceding example can be summarized in the following table:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
- en: '| **Type** | **Context type** |'
  id: totrans-83
  prefs: []
  type: TYPE_TB
- en: '| Binary file | `httpd_exec_t` |'
  id: totrans-84
  prefs: []
  type: TYPE_TB
- en: '| Config files | `httpd_config_t` |'
  id: totrans-85
  prefs: []
  type: TYPE_TB
- en: '| Logs | `httpd_log_t` |'
  id: totrans-86
  prefs: []
  type: TYPE_TB
- en: '| Content directory | `httpd_sys_content_t` |'
  id: totrans-87
  prefs: []
  type: TYPE_TB
- en: '| Unit file | `httpd_unit_file_t` |'
  id: totrans-88
  prefs: []
  type: TYPE_TB
- en: '| Process | `httpd_t` |'
  id: totrans-89
  prefs: []
  type: TYPE_TB
- en: '| Port | `httpd_t` `or http_port_t` |'
  id: totrans-90
  prefs: []
  type: TYPE_TB
- en: Table 12.1 – The httpd service contexts
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
- en: Note the relation of contexts; all belong to the `httpd_t` domain.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
- en: Thus, type enforcement is the concept under which it makes sense for a process
    running in the `httpd_t` context to interact with a file labeled as `httpd_sys_content_t`.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s see what context the `/etc/shadow` file has, where user passwords are
    stored:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: touch myfile
  id: totrans-96
  prefs:
  - PREF_IND
  - PREF_H1
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-97
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: mv myfile /var/www/html/
  id: totrans-98
  prefs:
  - PREF_IND
  - PREF_H1
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-99
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: curl http://localhost/myfile
  id: totrans-100
  prefs:
  - PREF_IND
  - PREF_H1
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-101
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: grep myfile /var/log/audit/audit.log
  id: totrans-102
  prefs:
  - PREF_IND
  - PREF_H1
  type: TYPE_NORMAL
- en: '...'
  id: totrans-103
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'type=AVC msg=audit(1689045662.823:264): avc:  denied  { getattr } for  pid=1035
    comm="httpd" path="/var/www/html/myfile" dev="vda3" ino=769948 scontext=system_u:system_r:httpd_t:s0
    tcontext=unconfined_u:object_r:admin_home_t:s0 tclass=file permissive=0'
  id: totrans-104
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-105
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: date -d @1689045662.823
  id: totrans-106
  prefs:
  - PREF_IND
  - PREF_H1
  type: TYPE_NORMAL
- en: Mon Jul 10 09:21:02 PM CST 2023
  id: totrans-107
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE15]'
  id: totrans-108
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: semanage command applies the httpd_sys_content_t label to the entire contents
    of the /srv/myweb directory and inherits it to the new files created in it. This
    means the (/.*)? characters appear at the end of the command.
  id: totrans-109
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE16]'
  id: totrans-110
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: -e option of the semanage command, assign the label with reference to another
    known file with the correct label.
  id: totrans-111
  prefs:
  - PREF_IND
  - PREF_H1
  type: TYPE_NORMAL
- en: '[PRE17]'
  id: totrans-112
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: restorecon -vR /srv/myweb
  id: totrans-113
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '[PRE18]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: chcon -t httpd_system_content_t /var/www/html/myfile
  id: totrans-115
  prefs:
  - PREF_IND
  - PREF_H1
  type: TYPE_NORMAL
- en: '[PRE19]'
  id: totrans-116
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: chcon --reference /var/www/html/ /var/www/html/myfile
  id: totrans-117
  prefs:
  - PREF_IND
  - PREF_H1
  type: TYPE_NORMAL
- en: '[PRE20]'
  id: totrans-118
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: chcon command. This is the easiest way to fix it.
  id: totrans-119
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If there is a custom path, it is necessary to inform SELinux that an alternate
    directory to the policy is going to be used. To change the policy, use the `semanage`
    command.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
- en: To save context changes in the policy, use the `restorecon` command.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
- en: When there is a customization that modifies the policy, this falls into the
    second case of SELinux failures. If the standard usage of a task changes, then
    SELinux must be informed.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
- en: Let’s look at these cases.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
- en: SELinux needs to know
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
- en: 'Following the web server configuration, in the case of using a port other than
    the standard port (`80`) – for example, `8585` – let’s start by finding out the
    *port label*. Use the `semanage` command to ask the policy about the configured
    label:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: semanage port -a -t http_port_t -p tcp 8585
  id: totrans-127
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '[PRE22]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: -P option, the Boolean change persists on system restart.
  id: totrans-129
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To see all Booleans, use the `getsebool` command with the `-``a` option:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: '![Figure 12.8 – SELinux Booleans](img/12.8.jpg)'
  id: totrans-132
  prefs: []
  type: TYPE_IMG
- en: Figure 12.8 – SELinux Booleans
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
- en: 'To review the Boolean description, use the `semanage boolean` command with
    the `-``l` option:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: '![Figure 12.9 – Reviewing the Boolean description](img/12.9.jpg)'
  id: totrans-136
  prefs: []
  type: TYPE_IMG
- en: Figure 12.9 – Reviewing the Boolean description
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
- en: These two cases, incorrect labeling and custom configuration, are the most common
    causes of errors with SELinux.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
- en: There are two other cases that, although not as common, could happen.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
- en: Let’s look at the first one.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
- en: Policy bugs
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
- en: 'In some events, the policy might not work when the behavior fails to meet expectations,
    as in the following cases:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
- en: Configurations
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Redirection of stdout
  id: totrans-144
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Filtered file descriptors
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Executable memory
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Libraries built wrongly
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Unusual paths in the code
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There is a high likelihood that the policy or application has bugs. These bugs
    or behavioral flaws should be reported to the developers to get them fixed.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
- en: This is an unusual situation as developers pay close attention to SELinux policies
    , but do not rule out the possibility of it happening.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
- en: A less common situation is that the system might be *compromised*, and the behavior
    of the policies changes to grant the escape of information or an intrusion.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
- en: Let’s look at this last case of failure with SELinux.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
- en: Hack attack
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
- en: 'There is a risk of a hack attack if the current tools *don’t do a good job*
    of differentiating contexts, or if you detect the case where *confined domains*
    attempt to do the following:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
- en: Load kernel modules
  id: totrans-155
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Turn off SELinux enforcing mode
  id: totrans-156
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Write to **etc_t**/**shadow_t**
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Change firewall rules
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If this happens, then be careful, because the system could become compromised
    and your information could be in danger.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
- en: Hacker attacks are not that common, but rest assured that hackers know how to
    use SELinux. Don’t trust, and follow your instinct. If you notice *unexpected
    behavior* and it is not related to the other SELinux failures, there is a possibility
    that your system might be hacked.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
- en: Take it *seriously*, and *thoroughly* inspect your system.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
- en: You never know when you might be a target for security attacks.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we gave an overview of the use of SELinux and differentiated
    the types of access control: *discretionary* and *mandatory*. SELinux, as a mandatory
    access control could help us to harden the security of our systems.'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
- en: The use of SELinux is considered very complex, but we gave several examples
    that simplify how it works. SELinux is a *labeling system*.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
- en: We learned how to read the error logs with SELinux and found that there are
    only *four* scenarios where SELinux could fail, as looked at their solutions.
    The most common failures are with labels or when using custom configurations for
    services.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
- en: Also, policies could have errors and they should be reported to their developers.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
- en: In a less common case, we analyzed that the change of behavior of the policies
    could be due to an *attack* on our system.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 在一个较为罕见的案例中，我们分析了策略行为的变化可能是由于对我们系统的*攻击*。
- en: In the next chapter, we will take an in-depth look at how to virtualize complete
    systems or take them to their smallest expression using containers.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将深入探讨如何虚拟化完整系统，或通过容器将它们缩小到最小的表达形式。
- en: Further reading
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: 'To learn more about the topics covered in this chapter, you can visit the following
    links:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解本章涉及的更多内容，您可以访问以下链接：
- en: '*A sysadmin’s guide to SELinux: 42 answers to the big* *questions*: [https://opensource.com/article/18/7/sysadmin-guide-selinux](https://opensource.com/article/18/7/sysadmin-guide-selinux)'
  id: totrans-172
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*系统管理员指南：42个关于SELinux的重大* *问题的答案*：[https://opensource.com/article/18/7/sysadmin-guide-selinux](https://opensource.com/article/18/7/sysadmin-guide-selinux)'
- en: '*A sysadmin’s handy cheat sheet for* *SELinux*: [https://opensource.com/article/18/8/cheat-sheet-selinux](https://opensource.com/article/18/8/cheat-sheet-selinux)'
  id: totrans-173
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*系统管理员的实用备忘单* *关于SELinux*：[https://opensource.com/article/18/8/cheat-sheet-selinux](https://opensource.com/article/18/8/cheat-sheet-selinux)'
- en: '*SELinux troubleshooting and* *pitfalls*: [https://www.redhat.com/sysadmin/selinux-troubleshooting](https://www.redhat.com/sysadmin/selinux-troubleshooting)'
  id: totrans-174
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*SELinux故障排除与* *常见陷阱*：[https://www.redhat.com/sysadmin/selinux-troubleshooting](https://www.redhat.com/sysadmin/selinux-troubleshooting)'
- en: '[PRE25]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: '[PRE26]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
