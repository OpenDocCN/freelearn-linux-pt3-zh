- en: '4'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Format and Disk Space Commands
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As we progress in our comprehensive series on frequently used commands for system
    administrators, the **command-line interface** (**CLI**) is an essential tool
    for getting many tasks done. The CLI offers a streamlined and efficient way to
    perform various tasks, from managing files and directories to monitoring system
    performance and troubleshooting issues. In this section, we will delve into frequently
    used commands and explore their usefulness, execution, and best practices for
    effective system administration. By mastering these commands, system administrators
    can work more efficiently and effectively, making the most of their computing
    resources.
  prefs: []
  type: TYPE_NORMAL
- en: As a system administrator, managing storage and filesystems is an essential
    part of ensuring the smooth operation of a system. The ability to format, partition,
    and manage disk space is critical for managing files, backing up important data,
    and maintaining system stability. In this chapter, we will explore the various
    commands used for formatting and disk space management, including `fdisk`, `lsblk`,
    `df`, `du`, and more.
  prefs: []
  type: TYPE_NORMAL
- en: We will begin by discussing the history and evolution of disk formatting and
    partitioning, from the early days of magnetic tapes to modern `mkfs`, `mke2fs`,
    `fdformat`, and others. By the end of this chapter, you will have a comprehensive
    understanding of formatting and disk space commands, enabling you to effectively
    manage storage and filesystems. It’s important to note that formatting a disk
    results in deleting all data on that disk, so you should exercise caution when
    using these commands.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we are going to cover the following main topics:'
  prefs: []
  type: TYPE_NORMAL
- en: The history and evolution of disk formatting and partitioning in Linux
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Steps to create a partition
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: fdisk, lsblk, df, and du
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Displaying (dpkg and rpm) package space
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: mkfs, mke2fs, and fdformat, and more
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The history and evolution of disk formatting and partitioning in Linux
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The history of disk formatting and partitioning in Unix/Linux dates back to
    the early days of computing when disk storage was a scarce resource. Disk partitioning
    was essential in organizing disk space into smaller, manageable sections. It allowed
    system administrators to allocate disk space more efficiently and reduced the
    risk of data loss in the event of a disk failure. In the early days of Unix, disk
    partitioning was done using the `fdisk` command, which allowed the user to create,
    delete, and modify disk partitions. With the introduction of Linux, the partitioning
    tool was updated to use the more advanced **GUID Partition Table** (**GPT**) format,
    which provided support for larger disks and more partitions.
  prefs: []
  type: TYPE_NORMAL
- en: Over time, disk formatting and partitioning in Unix/Linux have become more sophisticated,
    with new commands and utilities being added to improve the process. For instance,
    the `mke2fs` command, which is used to create an `ext2` or `ext3` filesystem,
    was introduced in Linux version 1.2\. This command created a more efficient filesystem,
    which reduced the risk of data loss and made disk management more manageable.
    The introduction of the `mke2fs` command was a significant milestone in the evolution
    of disk formatting and partitioning in Unix/Linux as it allowed administrators
    to create more reliable filesystems and manage disk space more efficiently. The
    advent of cloud computing and virtualization has also had a significant impact
    on disk formatting and partitioning in Unix/Linux. Cloud computing has enabled
    the use of virtual disks, which can be partitioned and formatted using the same
    tools as physical disks. In virtualized environments, administrators can easily
    create, modify, and resize virtual disks, making it easier to manage storage space.
    Additionally, cloud storage providers have developed their own disk formatting
    and partitioning tools, such as Amazon **Elastic Block Store** (**EBS**), which
    allows users to create and attach virtual disks to their instances. These tools
    have made it easier for administrators to manage disk space in the cloud and ensure
    that their data is stored securely.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are three types of partitions:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Primary partition**: A primary partition is a basic partition that can be
    used to boot an operating system. In a hard disk, you can create up to four primary
    partitions. If you want to create more partitions, you can create an extended
    partition, which is a special partition that can contain multiple logical partitions.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Logical partition**: A logical partition is a partition that is created within
    an extended partition. You can create multiple logical partitions within an extended
    partition, which can be useful when you want to create multiple partitions but
    you have already created four primary partitions.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Extended partition**: An extended partition is a special partition that is
    used to create multiple logical partitions. An extended partition can only be
    created if there are no more than four primary partitions on the hard disk. Once
    an extended partition has been created, you can create multiple logical partitions
    within it.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: These partition types are used to organize and manage data on a hard disk. By
    creating multiple partitions, you can separate different types of data and manage
    them more effectively. For example, you could create a separate partition for
    the operating system, one for user data, and one for backup files. This can make
    it easier to manage your data and protect it in the event of a failure or data
    loss. The different types of partitions offer flexibility in how you organize
    your data on a hard disk, depending on your needs and the limitations of the hard
    disk.
  prefs: []
  type: TYPE_NORMAL
- en: Steps to create a partition
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Partitioning is the process of dividing a physical hard drive into multiple
    logical storage units. In Linux, the process of creating a partition involves
    defining the size and location of a new partition on a physical hard drive, and
    then formatting it with a filesystem such as `ext4`, `XFS`, or `btrfs`. Creating
    partitions is essential for managing disk space effectively and efficiently. With
    partitioning, system administrators can organize and allocate space on a hard
    drive to various functions such as the operating system, application files, user
    data, and swap space.
  prefs: []
  type: TYPE_NORMAL
- en: The process of creating partitions in Linux involves several steps. The first
    step is to identify the physical hard drive that needs to be partitioned, using
    the `fdisk` command or other disk management tools such as `lsblk`, `df`, and
    `du`. Next, the system administrator must decide on the size and location of the
    new partition and use the `fdisk` command to create it. The new partition must
    then be formatted with a filesystem using the `mkfs` command. Finally, the system
    administrator must mount the new partition to make it accessible to the operating
    system and its applications.
  prefs: []
  type: TYPE_NORMAL
- en: Partitioning is important for several reasons. Firstly, it allows system administrators
    to manage disk space efficiently by organizing data into logical units. With partitioning,
    it becomes easier to back up and restore data, as well as to allocate space for
    specific applications or functions. Secondly, partitioning can improve system
    performance by reducing disk fragmentation and optimizing access times. Additionally,
    partitioning can improve security by isolating sensitive data on separate partitions
    and protecting it from unauthorized access. Remember that partitioning is a critical
    tool for system administrators to manage disk space, optimize system performance,
    and enhance security.
  prefs: []
  type: TYPE_NORMAL
- en: 'The demonstration will be easy as we only require a drive connected to the
    Linux machine, and we can begin partitioning by launching the Terminal. The commands
    we’ll be making use of for this partitioning are `lsblk` and `fdisk`. The `lsblk`
    command will list the available devices so that we can select the correct one
    to format, and `fdisk` command will effectively format the selected device. Let’s
    get started with the demonstration:'
  prefs: []
  type: TYPE_NORMAL
- en: 'To verify the available devices, execute the `lsblk` command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 4.1 – Verifying disk space](img/B18212_04_1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.1 – Verifying disk space
  prefs: []
  type: TYPE_NORMAL
- en: As we can see, we have listed the available devices and their respective disk
    spaces, but our main target is the connected drive on `/dev/sdb`. Note that `/dev`
    represents the device directory in Linux, where hardware devices are represented
    as files. In this case, `/dev/sdb` is the second SCSI disk drive on the system.
    Notice that it already has a partition (`sdb1`). We will delete that partition,
    verify it again, and then create our own partition. Let’s proceed with the next
    steps.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, execute the `fdisk` command to open its utility for the `/dev/sdb` drive.
    Please ensure you have `sudo` access to run this command. Once you have opened
    the utility, you can create a new partition, but first, let’s delete the previous
    one:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 4.2 – Viewing the fdisk utility for the /dev/sdb drive](img/B18212_04_2.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.2 – Viewing the fdisk utility for the /dev/sdb drive
  prefs: []
  type: TYPE_NORMAL
- en: Here, we used the `p` command, which stands for print, to display information
    about the existing partition we had previously identified using the `lsblk` command.
    Now, we need to delete that partition so that we can create a new one according
    to our needs.
  prefs: []
  type: TYPE_NORMAL
- en: 'To delete the `sdb1` partition, use the `d` command, which stands for delete,
    to remove the `sdb1` partition:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 4.3 – Deleting and saving changes made](img/B18212_04_3.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.3 – Deleting and saving changes made
  prefs: []
  type: TYPE_NORMAL
- en: 'After that, we can make use of the `lsblk` command to check whether the partition
    was really deleted. As we can see, the deleted partition (`sdb1`) is not listed
    anymore, proving that the deletion succeeded:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 4.4 – Verifying that the partition was deleted](img/B18212_04_4.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.4 – Verifying that the partition was deleted
  prefs: []
  type: TYPE_NORMAL
- en: Once we have confirmed this, we can proceed with creating our own partition.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, call the `fdisk` utility for the `/dev/sdb` drive, and type `p` to print
    the current partition table. This will help you understand how the disk is currently
    partitioned. Next, type `n` to create a new partition. The `n` command in the
    `fdisk` tool is used to create a new partition on the selected disk. When the
    command is entered, we are prompted to select the type of partition we wish to
    create. In this case, we are presented with two partition types – `primary` and
    `extended`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 4.5 – Creating a new partition](img/B18212_04_5.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.5 – Creating a new partition
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we selected `p` for the primary partition type. Then, we were prompted
    to select the number of partitions, and we left it as the default value by pressing
    *Enter*. For the first sector, we also pressed *Enter*. The same went for the
    last sector. Finally, we confirmed that we wanted to remove the signature by typing
    `yes` and then used the `w` command to save all the changes that we made:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 4.6 – Choosing the primary partition and saving changes](img/B18212_04_6.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.6 – Choosing the primary partition and saving changes
  prefs: []
  type: TYPE_NORMAL
- en: 'Verify its creation by calling `fdisk -l /dev/sdb` and `lsblk`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 4.7 – Verifying the new partition (sdb1)](img/B18212_04_7.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.7 – Verifying the new partition (sdb1)
  prefs: []
  type: TYPE_NORMAL
- en: Congratulations! You have successfully created a partition.
  prefs: []
  type: TYPE_NORMAL
- en: fdisk, lsblk, df, and du
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Among the utilities used in Linux systems to manage filesystems, there’s `fdisk`,
    `lsblk`, `df`, and `du`. Each of these utilities performs a specific function
    in disk management, and their proper use is essential to ensure the efficient
    functioning of the system.
  prefs: []
  type: TYPE_NORMAL
- en: 'We introduced `fdisk`, a command-line utility that’s used to partition disks,
    previously. It allows us to create and modify partition tables, enabling administrators
    to organize storage space as required. Partitioning is essential for efficiently
    utilizing storage space, improving system performance, and simplifying the management
    of the filesystem. `fdisk` can create different types of partitions, including
    primary, logical, and extended partitions. Additionally, it can be used to change
    the partition size, delete partitions, and modify partition types. Without `fdisk`,
    managing and organizing the filesystem would be complex, cumbersome, and prone
    to errors. We can call this command by simply typing `fdisk -l` to list the partition:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.8 – List partition with fdisk](img/B18212_04_8.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.8 – List partition with fdisk
  prefs: []
  type: TYPE_NORMAL
- en: '`lsblk` is another command-line utility that’s used in Linux systems to list
    all the available block devices, including hard drives, USB devices, and CD-ROM
    drives. This utility is useful in identifying the storage devices attached to
    the system, and the details of each block device. The output of `lsblk` provides
    critical information about the block devices, such as the device name, the size,
    the filesystem type, and the mount point. An example of this can be seen here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.9 – Output of block devices](img/B18212_04_9.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.9 – Output of block devices
  prefs: []
  type: TYPE_NORMAL
- en: This information is crucial in making decisions on how to allocate storage space
    and organize the filesystem efficiently. `lsblk` is essential in disk management
    as it helps system administrators identify the storage devices attached to the
    system, troubleshoot device connectivity issues, and make informed decisions regarding
    partitioning and disk organization.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `df` (**Disk Free**) utility is a command-line tool that displays the disk
    space used and available in filesystems on Linux systems. This tool is important
    in monitoring filesystem usage, identifying storage space consumption patterns,
    and making decisions on how to allocate storage space efficiently. Let’s try and
    display the disk space usage for a specific filesystem, such as the root filesystem:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.10 – Displaying disk usage with df](img/B18212_04_10.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.10 – Displaying disk usage with df
  prefs: []
  type: TYPE_NORMAL
- en: 'With `df`, administrators can identify filesystems that are running low on
    disk space, which can cause system performance issues or data loss:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.11 – Monitoring disk usage](img/B18212_04_11.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.11 – Monitoring disk usage
  prefs: []
  type: TYPE_NORMAL
- en: In this example, the administrator is monitoring the disk space usage on the
    filesystem where the website files are stored, which is mounted on `/var/www/html`.
    The `df` command is used with the `-h` option to display the output in a human-readable
    format, making it easier to understand the disk space usage. The output shows
    the total size of the filesystem, the amount of space used, the available space,
    the percentage of space used, and the mount point. The administrator can use this
    information to identify the directories that are consuming the most space and
    optimize them for better performance. Additionally, the administrator can use
    this information to plan for future disk space needs. The `df` utility provides
    a detailed report on the filesystem usage, including the filesystem type, the
    total size, the used space, the available space, and the percentage of the disk
    space used. With this information, administrators can optimize disk usage, increase
    performance, and avoid system crashes.
  prefs: []
  type: TYPE_NORMAL
- en: The `du` utility is another essential command-line tool that’s used in Linux
    systems to determine the amount of space used by specific directories and files.
    With `du`, administrators can identify files or directories that are consuming
    too much space and decide whether to delete, archive, or move them to another
    filesystem. The `du` utility also displays the amount of space used by each subdirectory,
    enabling administrators to pinpoint storage hogs quickly. The `du` utility’s importance
    in disk management cannot be overstated as it helps system administrators optimize
    disk usage, identify space-hogging files, and troubleshoot space consumption issues.
  prefs: []
  type: TYPE_NORMAL
- en: Checking the disk space usage of a directory
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this example, we will use the `du` command to check the disk space usage
    of a directory.
  prefs: []
  type: TYPE_NORMAL
- en: 'The steps are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Navigate to the directory whose disk space usage you want to check.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Type the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 4.12 – Using du to check disk usage](img/B18212_04_12.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.12 – Using du to check disk usage
  prefs: []
  type: TYPE_NORMAL
- en: We have used the `du -sh` command to check the disk space usage of the directory.
    The output shows that the directory is using 13 GB of disk space.
  prefs: []
  type: TYPE_NORMAL
- en: Finding large files in a directory
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this example, we will use the `du` command to find large files in a directory.
  prefs: []
  type: TYPE_NORMAL
- en: 'The steps are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Navigate to the directory whose large files you want to find.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Type the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 4.13 – Using du to find large files](img/B18212_04_13.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.13 – Using du to find large files
  prefs: []
  type: TYPE_NORMAL
- en: 'Utilize the `du -a | sort -rn | head –n 10` command to identify the 10 largest
    files in the directory. The resulting output provides the size of each file in
    bytes, along with its corresponding file path. Let’s apply this command to a different
    folder and observe the results:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.14 – Viewing the file size with du](img/B18212_04_14.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.14 – Viewing the file size with du
  prefs: []
  type: TYPE_NORMAL
- en: Utilities such as `fdisk`, `lsblk`, `df`, and `du` are essential in managing
    and organizing disk space in Linux systems. `fdisk` is used in partitioning disks,
    `lsblk` is used in identifying the storage devices attached to the system, `df`
    is used in monitoring filesystem usage, and `du` is used in determining the amount
    of space used by specific directories and files. Proper use of these utilities
    is crucial in optimizing disk usage, increasing system performance, and avoiding
    data loss.
  prefs: []
  type: TYPE_NORMAL
- en: Displaying (dpkg and rpm) package space
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Package management systems such as `dpkg` and `rpm` are used to install, remove,
    and manage software packages in Linux and Unix operating systems. The `dpkg` tool
    is used in Debian-based systems such as Ubuntu and the `rpm` tool is used in Red
    Hat-based systems such as CentOS. These tools not only provide an easy way to
    manage software packages but also offer valuable information about disk space
    usage by the installed packages. One important use of the `dpkg` and `rpm` tools
    is to display the package space, which refers to the amount of disk space used
    by the installed packages. By using these tools, administrators can identify the
    packages that are consuming the most disk space and make decisions on whether
    to remove or keep them. This is particularly useful in systems with limited disk
    space, where optimizing the use of disk space is critical to avoid system crashes,
    performance issues, or data loss.
  prefs: []
  type: TYPE_NORMAL
- en: In addition, the `dpkg` and `rpm` tools provide information about the package
    dependencies, which are other packages that are required by the installed package
    to function properly. This information is useful in identifying the packages that
    can be safely removed without affecting the system’s stability or functionality.
    By removing unnecessary packages, administrators can free up disk space, reduce
    system complexity, and improve system performance. The `dpkg` and `rpm` tools
    also offer an easy way to upgrade or install packages with their dependencies
    automatically resolved. With these tools, administrators can easily install security
    patches, updates, and new software packages without worrying about the dependencies.
    This reduces the time and effort required to manage packages and ensures that
    the system is up to date with the latest software versions. We are currently using
    CentOS 8, meaning `rpm` (**Red Hat Package Manager**) will be our number one example.
  prefs: []
  type: TYPE_NORMAL
- en: Installing a package
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The following example demonstrates how to utilize `rpm` to install packages
    on CentOS 8:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.15 – Using rpm to install a package](img/B18212_04_15.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.15 – Using rpm to install a package
  prefs: []
  type: TYPE_NORMAL
- en: This command installs the specified package using RPM. It searches for the `package`
    file in the current directory, or you can specify a path to the `package` file.
    This command is useful for installing new software on a Linux system, whether
    it is a single package or a set of packages.
  prefs: []
  type: TYPE_NORMAL
- en: Querying the details of a package
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `rpm` command can be used to query the details of a package installed on
    the system. For example, to query the details of the `ftp` package, use the following
    command:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.16 – Querying the details of a package that’s been installed](img/B18212_04_16.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.16 – Querying the details of a package that’s been installed
  prefs: []
  type: TYPE_NORMAL
- en: The `dpkg` and `rpm` tools are essential for managing software packages and
    optimizing the use of disk space in Linux and Unix systems. By providing valuable
    information about package space, dependencies, and upgrade options, these tools
    enable administrators to make informed decisions and ensure the stability, security,
    and performance of the system.
  prefs: []
  type: TYPE_NORMAL
- en: mkfs, mke2fs, fdformat, and more
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Disk formatting is the process of preparing a storage device such as a hard
    drive, SSD, or USB flash drive for data storage. Formatting creates a filesystem
    on the storage device, which allows the operating system to organize and manage
    files on the device. In Linux, several disk formatting tool commands can be used
    to format storage devices. These tools include `mkfs`, `mke2fs`, `fdformat`, and
    more.
  prefs: []
  type: TYPE_NORMAL
- en: '`mkfs` is a command that’s used to create a filesystem on a storage device.
    This command can be used to create a variety of filesystems, including `ext2`,
    `ext3`, `ext4`, `XFS`, `btrfs`, and more. The `mkfs` command is important in preparing
    storage devices for use in Linux systems. For example, when a new hard drive is
    added to a Linux server, it must be formatted before it can be used for data storage.
    Let’s examine a straightforward approach to utilize this tool on CentOS 8:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.17 – Formatting a partition using mkfs.ext4](img/B18212_04_17.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.17 – Formatting a partition using mkfs.ext4
  prefs: []
  type: TYPE_NORMAL
- en: This will format the `/dev/sdb1` partition with the `ext4` filesystem. The newly
    formatted partition can then be mounted and used for data storage.
  prefs: []
  type: TYPE_NORMAL
- en: '`mke2fs` is a variant of the `mkfs` command that is specifically designed to
    create `ext2`, `ext3`, and `ext4` filesystems. The `mke2fs` command is important
    in creating and managing Linux filesystems. With this command, administrators
    can specify the size of the filesystem, the block size, and other parameters to
    optimize the filesystem for specific use cases. For example, a filesystem created
    with the `mke2fs` command can be optimized for high-performance workloads or used
    with large files, as shown in the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.18 – Creating an ext3 filesystem](img/B18212_04_18.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.18 – Creating an ext3 filesystem
  prefs: []
  type: TYPE_NORMAL
- en: Here, the command creates an `ext3` filesystem on the `/dev/sdb1` partition.
    The `-t ext3` option specifies the filesystem type as `ext3`.
  prefs: []
  type: TYPE_NORMAL
- en: The `fdformat` command is primarily used for low-level formatting of floppy
    disks, which are legacy storage media. It writes a new disk geometry and sector
    layout to the floppy disk, preparing it for use. However, this command is not
    intended for formatting modern storage devices such as pen drives or USB flash
    drives.
  prefs: []
  type: TYPE_NORMAL
- en: For formatting pen drives or USB flash drives in Linux, `mkfs` (make filesystem)
    commands are typically used, such as `mkfs.fat` for creating a `FAT` filesystem
    or `mkfs.ext4` for creating an `ext4` filesystem, as shown in the previous examples.
    These commands are specifically designed for formatting different types of storage
    devices, including pen drives, USB flash drives, and hard drives.
  prefs: []
  type: TYPE_NORMAL
- en: The `mkswap` command is used to create a swap area on a Linux system. A swap
    area is a dedicated space on a hard drive that the system can use as virtual memory
    when it runs out of physical memory. The `mkswap` command initializes a disk partition
    or a file as a swap area and assigns it a unique identifier.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s delve into comprehensive examples to demonstrate the practical utilization
    of these commands:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Check the available disk partitions:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 4.19 – Viewing the available disk partitions](img/B18212_04_19.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.19 – Viewing the available disk partitions
  prefs: []
  type: TYPE_NORMAL
- en: 'Identify the desired partition for swap, such as `/dev/sdb1`, and then proceed
    to execute the `sudo mkswap /dev/sdb1` command. This command formats the partition
    as `swap`, resulting in the following output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 4.20 – Using mkswap to format the partition as swap](img/B18212_04_20.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.20 – Using mkswap to format the partition as swap
  prefs: []
  type: TYPE_NORMAL
- en: The `gdisk` command is a variant of the `fdisk` command and is used to partition
    hard drives on Linux systems. `gdisk` is primarily designed for GPT, which is
    a newer partitioning scheme that has replaced the older `gdisk` command is a powerful
    tool that allows you to create, modify, and delete partitions on GPT disks.
  prefs: []
  type: TYPE_NORMAL
- en: In this scenario, the system administrator is using the `gdisk` command to create
    a new partition on the `/dev/sdb` disk. The administrator enters the `gdisk /dev/sdb`
    command to launch the `gdisk` utility for the specified disk.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Once inside the `gdisk` utility, the administrator uses the `n` command to
    create a new partition. The utility prompts for the partition number, first sector,
    and last sector. The administrator can choose the default values or specify custom
    values based on their requirements:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 4.21 – Using gdisk to create a new partition](img/B18212_04_21.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.21 – Using gdisk to create a new partition
  prefs: []
  type: TYPE_NORMAL
- en: 'In this example, the administrator sets the partition type to `Linux swap`
    by entering a hex code of `8300`. After confirming the changes, the administrator
    uses the `w` command to write the changes to the disk and exit the `gdisk` utility:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 4.22 – The partition was created](img/B18212_04_22.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.22 – The partition was created
  prefs: []
  type: TYPE_NORMAL
- en: The `parted` command is a partition editor that allows you to create, delete,
    resize, and move partitions on a hard drive. Parted supports both MBR and GPT
    partitioning schemes and can work with multiple filesystem types. It is a powerful
    tool for managing disk partitions and is commonly used in server environments.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s explore a practical scenario of using the `parted` command:'
  prefs: []
  type: TYPE_NORMAL
- en: In this scenario, the system administrator is using the `parted` command to
    create a new partition on the `/dev/sdb` disk. The administrator enters the `parted
    /dev/sdb` command to launch the parted utility for the specified disk.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Once inside the parted utility, the administrator uses the `mklabel gpt` command
    to create a new GPT partition table on the disk. This ensures compatibility with
    modern systems and larger disk sizes.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Next, the administrator uses the `mkpart primary ext4 0% 100%` command to create
    a new primary partition that spans the entire disk. The partition is formatted
    with the `ext4` filesystem.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: After creating the partition, the administrator can use the `print` command
    to verify the partition layout and details. This helps ensure that the partition
    was created correctly.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Finally, the administrator uses the `quit` command to exit the parted utility:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 4.23 – Using parted to create a partition table](img/B18212_04_23.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.23 – Using parted to create a partition table
  prefs: []
  type: TYPE_NORMAL
- en: By using the `parted` command in this scenario, the system administrator can
    easily create and manage partitions on the specified disk, allowing for effective
    disk management and utilization.
  prefs: []
  type: TYPE_NORMAL
- en: The `dd` command is a low-level tool that’s used for copying and converting
    data between files, disks, and partitions. The `dd` command is commonly used for
    creating bootable USB drives, backing up and restoring disk images, and cloning
    disks. It can also be used to write zeros to a hard drive, which is useful for
    securely wiping sensitive data.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s explore a practical example scenario for the `dd` command:'
  prefs: []
  type: TYPE_NORMAL
- en: In this scenario, the system administrator is using the `dd` command to copy
    the contents of a source file to a USB device represented by `/dev/sdb`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The administrator starts by executing the `dd` command. The `if` option is
    used to specify the input file, followed by the path to the source file (`/home/instructor/backup.tar.gz`
    in this example):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 4.24 – Using the dd command to copy on the USB device](img/B18212_04_24.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.24 – Using the dd command to copy on the USB device
  prefs: []
  type: TYPE_NORMAL
- en: Next, the `of` option is used to specify the output file, which is the USB device
    represented by `/dev/sdb`. This means that the contents of the source file will
    be written to the USB device.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The `bs` option is used to specify the block size for data transfer. In this
    example, `bs=4M` indicates a block size of 4 megabytes.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: By executing this command, the system administrator can effectively copy the
    contents of the source file to the USB device. This can be useful for tasks such
    as creating bootable USB drives, transferring large files, or creating disk images.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: It’s important to exercise caution when using the `dd` command with block devices
    such as `/dev/sdb` as any data on the destination device will be overwritten.
    As an administrator, you should double-check and ensure they are targeting the
    correct device to avoid accidental data loss.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In conclusion, disk formatting tool commands are an essential part of managing
    storage devices in Linux systems. These commands allow administrators to prepare
    storage devices for use, optimize filesystems for specific use cases, and ensure
    that devices are reliable and performant. Understanding the purpose and use of
    these commands is important for any Linux administrator who works with storage
    devices.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter explored the steps of creating a partition, a fundamental process
    in disk management. We provided a detailed walk-through of utilizing tools such
    as `fdisk`, `lsblk`, `df`, and `du` to create, modify, and analyze partitions
    on storage devices. These tools play a crucial role in partition management, allowing
    system administrators to allocate disk space efficiently, monitor disk usage,
    and make informed decisions for optimal storage utilization. Additionally, this
    chapter delved into the topic of displaying package space using commands such
    as `dpkg` and `rpm`. These commands enable system administrators to obtain information
    about installed packages, including their sizes and disk space consumption. By
    leveraging `dpkg` and `rpm`, administrators can keep track of package installations,
    identify space-intensive packages, and manage package dependencies to ensure efficient
    disk utilization.
  prefs: []
  type: TYPE_NORMAL
- en: Furthermore, this chapter covered the usage of `mkfs`, `mke2fs`, and `fdformat`,
    among other disk formatting tools. These commands provide administrators with
    the ability to format disks and partitions with various filesystems, facilitating
    data organization and compatibility. Proper disk formatting is crucial for optimal
    performance and storage utilization. System administrators can utilize these tools
    to prepare disks for specific purposes, create filesystems for data storage, or
    format removable media.
  prefs: []
  type: TYPE_NORMAL
- en: In summary, this chapter served as a comprehensive guide to effective file management
    and storage optimization in Linux. By incorporating the steps of creating a partition,
    utilizing tools such as `fdisk`, `lsblk`, `df`, and `du`, displaying package space
    with `dpkg` and `rpm`, and employing disk formatting commands such as `mkfs`,
    `mke2fs`, and `fdformat`, system administrators can efficiently manage their files
    and storage resources. This enables them to enhance storage utilization, ensure
    data integrity, and maintain an organized and optimized system environment.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will thoroughly explore and discuss important commands
    such as `chmod`, `chown`, `chgrp`, `umask`, and `sudo`. These commands play a
    critical role in granting and managing file permissions, modifying ownership and
    group settings, setting default file permissions, and executing commands with
    administrative privileges.
  prefs: []
  type: TYPE_NORMAL
