- en: '6'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '6'
- en: Text-Stream Filters – Part 1
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 文本流过滤器 - 第1部分
- en: This is the first of two chapters in which I introduce the concept of text-stream
    filters. We’ll look at what they are and how to use them from the command-line.
    In the following chapters, I’ll present some examples of how these filter utilities
    can be used in shell scripts.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 这是介绍文本流过滤器概念的两章中的第一章。我们将讨论它们是什么以及如何从命令行使用它们。在接下来的章节中，我会展示这些过滤工具如何在Shell脚本中使用的一些例子。
- en: There are two reasons why you should learn about these various utilities. First,
    they’re very helpful if you need to create shell scripts that can automate the
    creation of different types of documents, such as reports. The second reason is
    that they are covered on certain Linux certification exams, such as the CompTIA
    Linux+/Linux Professional Institute exams.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该学习这些实用工具的原因有两个。首先，如果你需要创建能够自动生成不同类型文档（如报告）的脚本，这些工具非常有帮助。第二个原因是，它们会出现在某些Linux认证考试中，例如CompTIA
    Linux+/Linux专业人员协会考试。
- en: 'Topics in this chapter include:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的主题包括：
- en: Introduction to text-stream filters
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 文本流过滤器简介
- en: Using `cat`
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`cat`
- en: Using `tac`
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`tac`
- en: Using `cut`
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`cut`
- en: Using `paste`
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`paste`
- en: Using `join`
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`join`
- en: Using `sort`
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`sort`
- en: Okay, let’s get cracking, shall we?
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，开始吧，怎么样？
- en: Technical Requirements
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: Use any of your Linux virtual machines for this chapter, because these filter
    utilities work the same on all of them. Or, if you just happen to be running either
    Linux or macOS on your host machine, feel free to use it instead of a virtual
    machine. There’s no hands-on lab, so feel free to try out all the commands on
    your own machine as you go through the chapter.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 本章请使用你任何的Linux虚拟机，因为这些过滤工具在所有Linux系统上都一样有效。或者，如果你正好在主机上运行Linux或macOS，也可以直接使用它，而不需要虚拟机。没有动手实验，所以可以在自己机器上尝试所有命令，边学边操作。
- en: You’ll be working with a lot of text files in both this chapter and the next
    one. For your convenience, I’ve placed the files in the GitHub repository. If
    you’re using Linux, the best way to retrieve them is to install `git` on your
    system with your distro’s normal package manager.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一章和下一章中，你将处理大量的文本文件。为了方便起见，我已将文件放入GitHub仓库。如果你使用的是Linux，获取这些文件的最佳方式是通过你发行版的正常包管理器安装`git`。
- en: 'Then, use the following command to download the files:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，使用以下命令下载文件：
- en: '[PRE0]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Then, `cd` into the `The-Ultimate-Linux-Shell-Scripting-Guide` directory that
    the `git` command created, where you’ll find subdirectories for the various chapters.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，`cd`进入`The-Ultimate-Linux-Shell-Scripting-Guide`目录，这是`git`命令创建的，你会找到各章节的子目录。
- en: If you’re on a Mac, you’ll need to open the App Store and install the `Xcode`
    package in order to use `git`. Then, use the command that I’ve just shown you
    to download the files.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你使用的是Mac，你需要打开App Store并安装`Xcode`包才能使用`git`。然后，使用我刚才给出的命令来下载文件。
- en: I’ve also included a few examples of how some of these utilities work on FreeBSD
    and OpenIndiana. You can create a FreeBSD and an OpenIndiana virtual machine if
    you like, but it’s not strictly necessary just yet.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 我还包括了如何在FreeBSD和OpenIndiana上使用一些这些工具的例子。如果你愿意，可以创建一个FreeBSD和OpenIndiana的虚拟机，但目前还不是必须的。
- en: Introduction to Text-Stream Filters
  id: totrans-21
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 文本流过滤器简介
- en: As either a Linux systems administrator or an office worker who uses Linux on
    the desktop, you’ll probably have a certain number of text files that you need
    to work with. You may even get tasked with extracting data from these files and
    presenting the data effectively.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 作为Linux系统管理员或使用Linux桌面的办公室工作人员，你可能会有一定数量的文本文件需要处理。你甚至可能需要从这些文件中提取数据，并有效地展示这些数据。
- en: Or, you might need to extract data from utilities that show the status of your
    Linux system or from within scripts that automatically scrape the web for some
    specific information. The **text-stream filter utilities** that I present in this
    topic can help make these jobs easier. Once you learn them, you may even find
    that you can extract and display data with them more quickly than you could with
    text editors or word processors.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，你可能需要从显示Linux系统状态的工具中提取数据，或者从自动抓取网络特定信息的脚本中提取数据。我在本节中介绍的**文本流过滤器工具**可以帮助简化这些任务。一旦你学会了它们，你甚至可能发现，使用这些工具提取和展示数据的速度比使用文本编辑器或文字处理软件还要快。
- en: '![](img/B21693_06_01.png)'
  id: totrans-24
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B21693_06_01.png)'
- en: 'Figure 6.1: The basic concept of text-stream filters'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.1：文本流过滤器的基本概念
- en: With only one exception, you won’t use these utilities to modify the original
    text file. You’ll use them either to view the selected data on-screen, pipe the
    selected data to another utility, or use a redirector to create or append the
    selected data to another text file.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 除了一个例外，你不会使用这些工具来修改原始文本文件。你将使用它们来查看屏幕上的选定数据，将选定的数据传输到另一个工具，或者使用重定向符将选定的数据创建或附加到另一个文本文件中。
- en: Using cat
  id: totrans-27
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 cat
- en: The `cat` utility has nothing to do with our feline friends. It’s used to either
    view, create, or join multiple text files together. (In fact, the term `cat` is
    short for *catenate*, which is a fancy way of saying “to join two things together,
    end-to-end”.)
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: '`cat` 工具与我们的猫咪朋友无关。它用于查看、创建或合并多个文本文件。（实际上，`cat` 是 *catenate* 的缩写，意思是“将两者连接起来，端对端”。）'
- en: I said in the introduction that Mac users can perform the demos in this chapter
    on their Macs. Now though, I have to add a bit of a caveat. That’s because there
    are at least three versions of `cat`, which all have different sets of option
    switches. I’ll point out the differences as we go along.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 我在介绍中提到过，Mac 用户可以在他们的 Mac 上执行本章的演示。不过现在，我必须加一点警告。因为至少有三个版本的 `cat`，它们有不同的选项开关。我将在过程中指出它们的差异。
- en: Sometimes, you’ll need to write scripts that are portable across various different
    operating systems. So, it’s important that you know about these little idiosyncrasies.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，你需要编写可以跨各种操作系统使用的脚本。所以，了解这些小的细节很重要。
- en: 'By default, `stdin` for cat is the keyboard, and `stdout` is the computer screen.
    If you just type `cat` at the command prompt, you’ll be able to type in text and
    make it echo back to you as soon as you hit *Enter*. It will keep doing this until
    you press *Ctrl-d* to end it. Here’s what it looks like:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，`stdin` 对于 cat 是键盘，`stdout` 是计算机屏幕。如果你在命令提示符下输入 `cat`，你可以开始输入文本，并且只要按下
    *Enter*，它就会立即回显文本。它会一直这样做，直到你按下 *Ctrl-d* 结束它。下面是它的样子：
- en: '[PRE1]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'I haven’t hit *Enter* yet. Watch what happens when I do:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 我还没有按 *Enter*。看我按下之后会发生什么：
- en: '[PRE2]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'This is the only line I want to enter, so I’ll exit out of `cat` with *Ctrl-d*:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我想要输入的唯一一行，所以我会通过 *Ctrl-d* 退出 `cat`：
- en: '[PRE3]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Of course, this by itself isn’t terribly useful. But, you can use `cat` with
    the `stdout` redirector to create simple text files. When you’re through typing
    the message, hit *Enter* once more to get to a blank line, and then press *Ctrl-d*
    to exit. It should look something like this:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，仅凭这一点并不是特别有用。但你可以将 `cat` 与 `stdout` 重定向符一起使用来创建简单的文本文件。当你输入完消息后，再按一次 *Enter*
    以跳到空白行，然后按 *Ctrl-d* 退出。它应该像这样：
- en: '[PRE4]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Once you’ve created your file you can use `cat` to display it. It’s not like
    the `less` utility though, because `cat` simply dumps everything in the file onto
    the display screen without pagination. You don’t need to use a `stdin` redirector
    with `cat`, because `cat` is designed to use arguments instead of `stdin` redirectors.
    Anyway, here’s what this looks like:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你创建了文件，你可以使用 `cat` 来显示它。不过，它与 `less` 工具不同，因为 `cat` 会直接将文件中的所有内容显示到屏幕上，而没有分页。你不需要在
    `cat` 中使用 `stdin` 重定向符，因为 `cat` 设计为使用参数而不是 `stdin` 重定向符。总之，下面是它的样子：
- en: '[PRE5]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Now, use `cat` to create a second file, like so:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，使用 `cat` 创建第二个文件，像这样：
- en: '[PRE6]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Here’s where the catenate part comes in. Invoke `cat` again, but use the names
    of both of your new files as arguments, like so:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是合并操作的部分。再次调用 `cat`，但是将两个新文件的名称作为参数传入，像这样：
- en: '[PRE7]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '![](img/B21693_06_02.png)'
  id: totrans-45
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B21693_06_02.png)'
- en: 'Figure 6.2: Directing the contents of two files into a third file.'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.2：将两个文件的内容导入到第三个文件。
- en: This time, you’ll see both of your files displayed as if they were one single
    file.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 这次，你会看到两个文件会显示得像一个单独的文件一样。
- en: 'Now, add a `stdout` redirector to create a new file by combining the first
    two, like this:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，添加一个 `stdout` 重定向符，通过将前两个文件合并来创建一个新文件，像这样：
- en: '[PRE8]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'It’s important to understand that you need to create a third text file when
    you do this. That’s because if you were to redirect the output of the two original
    files into either one of the two original files, you would completely obliterate
    the contents of that destination file. The only thing you’d have left would be
    the contents of the second file. In fact, let me show you:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 理解这一点很重要：当你这么做时，你需要创建一个第三个文本文件。这是因为如果你将两个原始文件的输出重定向到其中任何一个原始文件中，你将完全覆盖该目标文件的内容。你剩下的只有第二个文件的内容。实际上，让我给你看一下：
- en: '[PRE9]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: As you see, the text that was in the original `newtext.txt` file no longer exists.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，原来的 `newtext.txt` 文件中的文本已经不存在了。
- en: 'There are several display options that you can use with `cat`. To see how to
    use them, create another text file. This time, add some tabs and a whole bunch
    of empty lines. It will look something like this:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: '`cat`有多个显示选项，你可以使用它们。为了查看如何使用它们，创建另一个文本文件。这次，添加一些标签和一大堆空行。它看起来大致如下：'
- en: '[PRE10]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: At the beginning of the `of the options will work` line I inserted a few blank
    spaces. I began all of the other lines by hitting the *Tab* key once.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 在`of the options will work`行的开头，我插入了一些空格。其他所有行我都通过按一次*Tab*键开始。
- en: 'Let’s say that we don’t need so many consecutive blank lines. That’s no problem.
    I’ll just use the `-s` option to squeeze them out, like so:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们不需要这么多连续的空行，那也没问题。我只需使用`-s`选项将它们压缩掉，像这样：
- en: '[PRE11]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: It looks better, doesn’t it?
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 看起来更好，对吧？
- en: 'On Linux, FreeBSD, and macOS, you can see where all of the tabs are by using
    the `-t` option, like this:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 在Linux、FreeBSD和macOS上，你可以通过使用`-t`选项看到所有的标签，像这样：
- en: '[PRE12]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: You see that all of the tabs now show up as `^I` characters.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 你会看到现在所有的标签都显示为`^I`字符。
- en: 'On OpenIndiana you’ll need to combine the `-t` and the `-v` options to see
    the tab characters, because using the `-t` option alone won’t show you anything.
    Here’s how it looks on OpenIndiana:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 在OpenIndiana上，你需要将`-t`和`-v`选项结合使用才能看到标签字符，因为仅使用`-t`选项不会显示任何内容。以下是在OpenIndiana上的显示方式：
- en: '[PRE13]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'If you want to see where the end of each line is, use the `-e` option, like
    this:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想看到每行的结尾在哪里，请使用`-e`选项，像这样：
- en: '[PRE14]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'On OpenIndiana you’ll need to combine the `-e` and the `-v` options, because
    using the `-e` option alone won’t show you anything. Here’s how it looks on OpenIndiana:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 在OpenIndiana上，你需要将`-e`和`-v`选项结合使用，因为仅使用`-e`选项不会显示任何内容。以下是在OpenIndiana上的显示方式：
- en: '[PRE15]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: As you see, the end of each line is marked by a `$`.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，每一行的末尾用`$`表示。
- en: 'On Linux only, you can see both where the tabs are and where the end of each
    line is by using the `-A` option, like so:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 仅在Linux上，你可以通过使用`-A`选项查看标签的位置以及每行的结尾，像这样：
- en: '[PRE16]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Note that the `-A` option only works on the Linux version of `cat`. It does
    not work on OpenIndiana, FreeBSD, or macOS.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，`-A`选项只在Linux版本的`cat`上有效。它在OpenIndiana、FreeBSD或macOS上不起作用。
- en: Also, note that if script portability is a concern, you can use `cat -tv` as
    well as `cat -ev` on Linux machines, even though the `-v` option isn’t necessary
    on Linux.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，如果脚本的可移植性是一个问题，你可以在Linux机器上使用`cat -tv`和`cat -ev`，尽管在Linux上`-v`选项并不是必须的。
- en: 'The `-b` option will number all non-blank lines for you, like this:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: '`-b`选项会为所有非空行编号，像这样：'
- en: '[PRE17]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Or, use the `-n` option to have all lines numbered, like this:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，使用`-n`选项让所有行都编号，像这样：
- en: '[PRE18]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: That’s it for `cat`, so let’s look at `tac`.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是`cat`的内容，接下来我们来看一下`tac`。
- en: Using tac
  id: totrans-78
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用tac
- en: '`tac`--`cat` spelled backwards--displays one or more files at a time in reverse
    order. To see how it works, we’ll first create two text files that will look like
    this:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: '`tac`--`cat`的反向拼写--一次按逆序显示一个或多个文件。为了查看它是如何工作的，我们首先创建两个看起来像这样的文本文件：'
- en: '[PRE19]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Let’s use `cat` to view both of the files at once:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用`cat`同时查看两个文件：
- en: '[PRE20]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'You can use `tac` to view one file in reverse order:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用`tac`以逆序查看一个文件：
- en: '[PRE21]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Or, view two or more files in reverse order:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，按逆序查看两个或更多文件：
- en: '[PRE22]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Note that the contents of the first file is displayed first, followed by the
    contents of the second file.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，第一个文件的内容先显示，然后是第二个文件的内容。
- en: 'And, of course, you can use the `stdout` redirector to create a new text file,
    like this:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，你可以使用`stdout`重定向器来创建一个新的文本文件，像这样：
- en: '[PRE23]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: You would think that `tac` would use the same options as `cat`, but it doesn’t.
    None of the options for `cat` can be used for `tac`.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能以为`tac`会使用和`cat`相同的选项，但事实并非如此。`cat`的选项都不能用于`tac`。
- en: That’s it for `tac`. Next up is `cut`.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是`tac`的内容，接下来是`cut`。
- en: Using cut
  id: totrans-92
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用cut
- en: As its name implies, this handy utility is used to cut and display selected
    information from a text file. Think of it as something that will take a vertical
    slice of a text file and send it to the output of your choice. There are two ways
    to specify where you want to begin and end the slice. You can specify it either
    by specifying the starting and ending characters, or by specifying the fields.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 顾名思义，这个实用程序用于从文本文件中剪切并显示选定的信息。你可以把它当作是从文本文件中提取一个垂直切片并将其发送到你选择的输出。指定你想要开始和结束切片的方式有两种。你可以通过指定开始和结束字符来指定，也可以通过指定字段来指定。
- en: To specify your slice by fields, you’ll need to use both the `-d` and `-f` switches.
    The `-d` switch will specify the delimiter, the character that separates the fields.
    That’s so that `cut` will know where each field begins and ends. The `-f` switch
    will specify which fields you want to look at. In this diagram, you see that I
    used `cut` to extract the user name and real name--fields `1` and `5`--from the
    `/etc/passwd` file.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 要按字段指定切片，你需要同时使用`-d`和`-f`选项。`-d`选项将指定分隔符，即分隔字段的字符。这样`cut`就能知道每个字段的开始和结束位置。`-f`选项将指定你想查看的字段。在这个图示中，你可以看到我使用`cut`从`/etc/passwd`文件中提取了用户名和真实姓名——字段`1`和`5`。
- en: '![](img/B21693_06_03.png)'
  id: totrans-95
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B21693_06_03.png)'
- en: 'Figure 6.3: Using cut to view fields 1 and 5 of the passwd file'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.3：使用cut查看passwd文件的第1和第5字段
- en: Since the fields in this file are separated by colons, I used `-d:` for the
    delimiter switch.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这个文件中的字段由冒号分隔，我使用了`-d:`作为分隔符选项。
- en: The other method for specifying the slice is the character method. With this
    method, you select the beginning and the ending characters of the lines of text
    that you want to display. In the next diagram, you see that I’ve saved a listing
    of files in my current directory to `filelist.txt`.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种指定切片的方法是字符方法。使用这种方法，你可以选择要显示的文本行的开始字符和结束字符。在下图中，你可以看到我将当前目录中的文件列表保存到了`filelist.txt`中。
- en: '![](img/B21693_06_04.png)Figure 6.4: Using cut to view the first 20 characters'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: '![](img/B21693_06_04.png)图 6.4：使用cut查看前20个字符'
- en: 'I’ve decided that I only want to look at the first 20 characters of the lines
    of text in this file, so I used the `-c` switch appended with the appropriate
    character numbers. (Note that you can type the command as either `cut -c1-20 filelist.txt`
    or as `cut -c 1-20 filelist.txt`. The blank space between the `-c` and the first
    number is optional.) To further illustrate how this works, let me show you what
    the output of cutting an actual multi-line file looks like:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 我决定只查看该文件每行的前20个字符，所以我使用了`-c`选项，并附加了适当的字符编号。（注意，你可以将命令输入为`cut -c1-20 filelist.txt`，也可以输入为`cut
    -c 1-20 filelist.txt`，`-c`与第一个数字之间的空格是可选的。）为了进一步说明它是如何工作的，下面让我展示一下切割一个实际的多行文件时的输出：
- en: '[PRE24]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: You see that `cut` operates on every line in the file. Also, you see that the
    entire first line prints out because it consists of fewer than 20 characters.
    (The same thing happens when you use the field method.)
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以看到`cut`对文件中的每一行都进行了操作。此外，你还看到第一行完整地打印了出来，因为它的字符数少于20个。（当你使用字段方法时，情况也是一样的。）
- en: 'Of course, with both of the above examples, you have the option of using a
    `stdout` redirector to save the extracted information to a text file. For example,
    you could do something like this:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，对于上述两个例子，你可以选择使用`stdout`重定向器将提取的信息保存到文本文件。例如，你可以像这样操作：
- en: '[PRE25]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'As with most of the text-stream filter utilities, you can either pipe the output
    from `cut` into another utility, or pipe another utility’s output into `cut`.
    In the previous example, I really didn’t need to save the `ls -l` output to a
    text file. I could have just piped the `ls -l` output into `cut`, like this:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 和大多数文本流过滤工具一样，你可以将`cut`的输出通过管道传递给另一个工具，或者将另一个工具的输出通过管道传递给`cut`。在前面的例子中，我其实并不需要将`ls
    -l`的输出保存到文本文件中。我可以直接将`ls -l`的输出通过管道传递给`cut`，像这样操作：
- en: '[PRE26]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Add on a `stdout` redirector, and you can also save this to a text file, like
    so:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 添加一个`stdout`重定向器，你还可以将其保存到文本文件中，如下所示：
- en: '[PRE27]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: That’s it for `cut`. Now, let’s do some pasting.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是`cut`的所有内容。现在，让我们来看看如何进行粘贴。
- en: Using paste
  id: totrans-110
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用paste
- en: Instead of joining two or more files together end-to-end as `cat` does, `paste`
    joins them together side-by-side. This is handy when you have two or more files
    of columnar data, and you want to look at all of the data in one display. Go ahead
    and create the two text files that you see in the following diagram Then try out
    the `paste` command that you see in the diagram.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 与`cat`将两个或更多文件连接在一起不同，`paste`是将它们并排连接起来。当你有两个或更多列式数据的文件，并且你想在一个显示中查看所有数据时，这非常有用。请继续创建下图中所示的两个文本文件，然后尝试使用图示中的`paste`命令。
- en: '![](img/B21693_06_05.png)'
  id: totrans-112
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B21693_06_05.png)'
- en: 'Figure 6.5: Pasting two files together with paste'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.5：使用paste将两个文件合并
- en: 'There are two options that you can use with `paste`. The serial option, set
    with the `-s` switch, allows you to view the columns of data horizontally. Pasting
    the `myfile_1.txt` and `myfile_2.txt` with the `-s` option looks like this:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: '`paste`有两个选项可以使用。使用`-s`选项的串联模式，允许你将数据列水平显示。将`myfile_1.txt`和`myfile_2.txt`与`-s`选项一起粘贴，结果如下所示：'
- en: '[PRE28]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'The delimiter option, set by the `-d` switch, allows you to change how the
    columns are separated. If you leave out the `-d` switch, the columns of the pasted
    display will be separated by tabs, as you see in the preceding examples. To replace
    the tabs with something else, just place the desired replacement after the `-d`
    switch. Here, I’m using a set of double-quotes with a space in between to replace
    each tab with a normal space:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: '`-d`开关设置的分隔符选项可以让你更改列之间的分隔方式。如果你没有使用`-d`开关，粘贴显示的列将用制表符分隔，就像前面的示例中看到的那样。要将制表符替换为其他字符，只需在`-d`开关后面放置所需的替代字符。在这里，我使用一对双引号，中间有一个空格，将每个制表符替换为正常空格：'
- en: '[PRE29]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Now, here’s a really cool trick that you can use to impress your friends. First,
    create four new text files as follows:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，这里有一个非常酷的技巧，你可以用来给你的朋友留下深刻印象。首先，按如下方式创建四个新文本文件：
- en: '[PRE30]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Now, put them all together with paste. This time, place the `+`, `-`, and `=`
    signs between the quotes after the `-d`, like this:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，将它们全部合并到一起，使用paste命令。这一次，在`-d`后面的引号中放置`+`、`-`和`=`符号，像这样：
- en: '[PRE31]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: As you see, the three arithmetic operators got placed in the appropriate places.
    (Oh, and in case you’re wondering, uno, dos, tres, and cuatro are Spanish for
    1, 2, 3, and 4.)
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，三个算术运算符已经被放置在了适当的位置。（哦，顺便说一下，如果你在想，uno、dos、tres和cuatro是西班牙语的1、2、3和4。）
- en: This really is more than just a crazy party trick. I’ll show you a practical
    use for this in *Chapter 11, Performing Mathematical Operations*.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 这不仅仅是一个疯狂的派对技巧。我将在*第11章，执行数学运算*中展示这个方法的实际应用。
- en: Okay, now that we’ve pasted some files together, let’s join some together.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，现在我们已经将一些文件粘贴在一起，接下来让我们将它们合并。
- en: Using join
  id: totrans-125
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用join
- en: Here’s another handy utility you can use to combine two text files. (Unlike
    the other utilities we’ve looked at, you can use `join` for two text files, but
    no more than two.) To see how it works, take a look at the following diagram with
    its text files about famous Hollywood actors from a by-gone era. Then, go ahead
    and create the files, with tabs between the two columns of each file. Then, run
    the command that’s shown in the diagram.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个你可以用来合并两个文本文件的实用工具。（与我们之前讨论的其他工具不同，你只能用`join`合并两个文本文件，不能超过两个。）要了解它是如何工作的，查看下面的示意图，它展示了关于过去时代著名好莱坞演员的文本文件。然后，创建这些文件，在每个文件的两列之间用制表符分隔。接着，运行示意图中显示的命令。
- en: '![](img/B21693_06_06.png)'
  id: totrans-127
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B21693_06_06.png)'
- en: 'Figure 6.6: Joining two files together with join'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.6：使用join将两个文件合并在一起
- en: As you see, the `join` utility replaces the tabs that were between the columns
    with blank spaces.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，`join`工具将列之间的制表符替换为空格。
- en: Note that in each of the two input files, the first field is the same. (In this
    case, it’s the last name of each actor.) In the output, the first field--which
    we’ll call the **key field**--is only listed once. The information for each actor’s
    last name--the key field--is obtained from both of the two input files.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，在每个输入文件中，第一个字段是相同的。（在这个例子中，它是每个演员的姓氏。）在输出中，**关键字段**——第一个字段——只列出一次。每个演员的姓氏——关键字段——从两个输入文件中获取。
- en: The thing to remember here is that you have to have one field that is identical
    in both input files. It doesn’t have to be the first field, as we’ll illustrate
    in the next example.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 这里需要记住的是，你必须确保两个输入文件中有一个字段是相同的。这个字段不一定是第一个字段，正如我们在下一个例子中将展示的那样。
- en: 'You can use the `-j` switch to use another field, if you so desire. You can
    see this with the following two lists of numbers:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你需要，还可以使用`-j`开关选择另一个字段。你可以通过下面这两个数字列表看到这一点：
- en: '[PRE32]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Now, let’s join them:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们将它们合并起来：
- en: '[PRE33]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Here, the second field is identical in each input file, so I used the `-j 2`
    option to designate that field as the key field.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，第二个字段在每个输入文件中是相同的，因此我使用了`-j 2`选项将该字段指定为关键字段。
- en: 'You can pipe the output of `join` into other utilities for customized output.
    If you want to number the lines of the output, pipe it into `cat` with the `-n`
    option, like so:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以将`join`的输出通过管道传递给其他工具，以获得定制化的输出。如果你想为输出编号，可以将其通过管道传递给`cat`并使用`-n`选项，像这样：
- en: '[PRE34]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'It’s rather common these days for people to create spreadsheet files in **Comma
    Separated Values** (**csv**) format, rather than in a spreadsheet program’s native
    format. The advantages of this are that the files can be created in any plain-text
    editor, and that the files can be read by any spreadsheet program. You can make
    `join` work with these files by using the `-t` switch to specify that the fields
    are separated by commas instead of by tabs. To see how that works, copy the `actorfile_1.txt`
    and `actorfile_2.txt` files to corresponding `.csv` files, like so:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，很多人都喜欢创建**逗号分隔值**（**csv**）格式的电子表格文件，而不是使用电子表格程序的原生格式。这样做的好处是，文件可以在任何文本编辑器中创建，且任何电子表格程序都能读取这些文件。你可以通过使用`-t`开关来指定字段是由逗号而不是制表符分隔，从而让`join`与这些文件一起使用。要查看如何操作，可以将`actorfile_1.txt`和`actorfile_2.txt`文件复制为对应的`.csv`文件，如下所示：
- en: '[PRE35]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Next, edit the two `.csv` files to replace the tabs with commas. The first
    file will look like this:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，编辑这两个`.csv`文件，将制表符替换为逗号。第一个文件将如下所示：
- en: '[PRE36]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'The second file will look like this:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个文件将如下所示：
- en: '[PRE37]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Now, watch what happens when I try to use `join` in the normal way:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，看看当我尝试正常使用`join`时会发生什么：
- en: '[PRE38]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'It doesn’t work, because `join` thinks that there’s only one field in each
    file. To make it work, I’ll need to use the `-t` switch to specify the comma as
    my field separator, like so:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 它不起作用，因为`join`认为每个文件中只有一个字段。为了使其正常工作，我需要使用`-t`开关来指定逗号作为我的字段分隔符，如下所示：
- en: '[PRE39]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Cool, that looks much better. And of course, you can always redirect the output
    into a third `.csv` file that you can import into any spreadsheet program.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 很酷，看起来好多了。当然，你也可以将输出重定向到一个第三个`.csv`文件，然后将其导入到任何电子表格程序中。
- en: There are still more possibilities for how you can use `join`, which you can
    see in the `join` man page. Combine the power of `join` with the power of the
    next utility that we’re about to cover, and you’ll have the makings of an easy-to-use
    utility for creating simple databases.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: '`join`还有更多的使用方式，你可以在`join`的手册页中查看。将`join`的强大功能与我们即将介绍的下一个工具的功能结合起来，你将拥有一个易于使用的工具，可以用来创建简单的数据库。'
- en: Using sort
  id: totrans-151
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 sort
- en: This is a versatile utility that you can use by itself, or in conjunction with
    other utilities. You can use it to sort either one file, or multiple files together.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个多功能的工具，你可以单独使用它，也可以与其他工具配合使用。你可以用它来排序一个文件，或者将多个文件一起排序。
- en: There are lots of options for different purposes. You can choose how to format
    your output, how you want the data sorted, and what fields you want to use for
    the sort. You can even perform sorts on two or more fields at once, with the primary
    sort on one field and secondary sorts on others.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 有很多选项可以用于不同的目的。你可以选择如何格式化输出，如何对数据进行排序，以及你希望使用哪些字段进行排序。你甚至可以在两个或更多字段上同时进行排序，主排序基于一个字段，次排序基于其他字段。
- en: 'There are a lot of ways that you can use `sort`. As I’ve said before, the only
    limitation is your own imagination. To start, look at the following diagram. Create
    the text file on your own machine and then run the commands that you see:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用`sort`的方式有很多种。正如我之前所说，唯一的限制是你自己的想象力。首先，看看下面的图示。请在你的机器上创建文本文件，然后运行你看到的命令：
- en: '![](img/B21693_06_07.png)'
  id: totrans-155
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B21693_06_07.png)'
- en: 'Figure 6.7: Sorting the actorfile_1.txt file'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.7：排序 actorfile_1.txt 文件
- en: What you see in the above diagram is the simplest of sorts. By default, sorts
    are case-sensitive and are performed on each entire line of the input file.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 你在上面的图示中看到的是最简单的排序。默认情况下，排序是区分大小写的，并且是对输入文件的每一整行进行排序。
- en: In the next example, I’ll show you two options at once. The first is the `-k`
    option, which allows you to sort the input file on a particular field. The second
    is the `-o` option, which allows you to save the output to a text file. Of course,
    you can still do that with a redirector. But, unlike the redirector, the `-o`
    option allows you to save the sorted output back to the original input file without
    wiping out its contents.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一个示例中，我将同时展示两个选项。第一个是`-k`选项，它允许你根据特定字段对输入文件进行排序。第二个是`-o`选项，它允许你将输出保存到文本文件中。当然，你仍然可以使用重定向器来实现这一点。但与重定向器不同，`-o`选项允许你将排序后的输出保存回原始输入文件，而不会清空其内容。
- en: 'Before I show you that, I’m going to copy the `actorfile_1.txt` file over to
    the `actorfile_5.txt` file, so that I can use the `actorfile_1.txt` file again
    later:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 在我展示之前，我将把`actorfile_1.txt`文件复制到`actorfile_5.txt`文件，以便稍后我可以再次使用`actorfile_1.txt`文件：
- en: '[PRE40]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Now, let’s see how this works:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看它是如何工作的：
- en: '[PRE41]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: As you see, the original input file is now sorted according to the actors’ first
    names.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，原始输入文件现在已经按演员的名字排序。
- en: 'Let’s say that you need a list of actresses to go along with your list of actors,
    and that the list looks something like this:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你需要一个女演员列表来搭配你的男演员列表，而这个列表大致如下所示：
- en: '[PRE42]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Sort the `actorfile_1.txt` file and the `actorfile_6.txt` file together, like
    this:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 将`actorfile_1.txt`文件和`actorfile_6.txt`文件一起排序，如下所示：
- en: '[PRE43]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'After you view the results on screen, save the results to a new file, like
    this:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 在屏幕上查看结果后，将结果保存到一个新文件中，如下所示：
- en: '[PRE44]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: You can also pipe this through the `tee` utility, so that you can see the output
    on screen and save it to a file at the same time.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以通过`tee`工具将其管道传输，这样你既能在屏幕上看到输出，又能同时将其保存到文件中。
- en: '[PRE45]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'There are a few other options that could help you out in special situations.
    To demonstrate, create the file `fruit.txt`, which will look like this:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一些其他选项，可以在特殊情况下帮助你。为了演示，创建一个名为`fruit.txt`的文件，它将如下所示：
- en: '[PRE46]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'You see that there are some duplicate entries. Let’s see what a normal sort
    would look like:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 你会看到有一些重复条目。让我们看看正常排序会是什么样子：
- en: '[PRE47]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Since you only need one entry for each fruit, use the `-u` option to get rid
    of duplicate entries, like this:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 由于每种水果只需要一个条目，可以使用`-u`选项来去除重复条目，如下所示：
- en: '[PRE48]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'That looks somewhat better. But, do you really need to have the fruit names
    repeated in both upper-case and lower-case? If not, then add the `-f` switch to
    make `sort` look at all letters as if they were uppercase, like so:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 这看起来稍微好一些。但是，你真的需要在大写和小写字母中重复显示水果名称吗？如果不需要，那么添加`-f`开关，使`sort`将所有字母视为大写字母进行排序，如下所示：
- en: '[PRE49]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: Some older Linux books may tell you that text files with a mixture of upper-case
    and lower-case letters in the sorted fields won’t sort properly unless you use
    the `-f` switch.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 一些旧版Linux书籍可能会告诉你，文本文件中包含大小写字母混合的排序字段，除非使用`-f`开关，否则不会正确排序。
- en: For example, the name “MacLeod” would have come before the name “Mack” because
    the upper-case L would have been placed before the lower-case k. The `-f` switch
    would have forced `sort` to place the list items in proper alphabetical order,
    regardless of case. However, with the newer Linux distros, this is no longer a
    problem. The `-f` switch still has its uses, as you see in the above example.
    But, this problem that those other Linux books tell you about no longer exists.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，名字“MacLeod”会排在“Mack”之前，因为大写字母L会排在小写字母k之前。`-f`开关会强制`sort`将列表项按正确的字母顺序排序，不论大小写。然而，在更新的Linux发行版中，这已不再是问题。`-f`开关仍然有其用途，正如你在上面的例子中看到的。但是，那些其他Linux书籍中提到的问题已经不复存在。
- en: For our next demonstration, create a file with a list of numbers.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一个示例中，创建一个包含数字的文件。
- en: '[PRE50]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'Here’s what you’ll get when you try to sort the list:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 这是你尝试排序列表时得到的结果：
- en: '[PRE51]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'That’s probably not what you want. To make it sort in proper numerical order,
    use the `-n` switch, like so:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 这可能不是你想要的。为了按正确的数字顺序排序，请使用`-n`开关，如下所示：
- en: '[PRE52]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'Add the `-r` switch to sort the file in reverse order:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 添加`-r`开关，以便按逆序排序文件：
- en: '[PRE53]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'This time, just for fun, create a text file with some decimals and negative
    numbers, as well as some positive numbers:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 这次，玩一下，创建一个包含小数和负数的文本文件，以及一些正数：
- en: '[PRE54]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'Now, let’s see how this sorts out without any option switches:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看在没有任何选项开关的情况下，排序结果如何：
- en: '[PRE55]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'As before, add the `-n` switch to sort the list in proper numerical order:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 和之前一样，添加`-n`开关以按正确的数字顺序排序列表：
- en: '[PRE56]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'For our next example, let’s create a file list of used automobiles. We’ll list
    the make, model, year, mileage (in thousands), and the selling price. (If you’re
    not here with me in the United States, just pretend that the miles are really
    kilometers.) Here’s what the list looks like:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一个示例中，让我们创建一个二手汽车的文件列表。我们将列出品牌、型号、年份、里程（以千英里为单位）和售价。（如果你不在美国，可以假装英里实际上是公里。）列表如下所示：
- en: '[PRE57]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'We’ll first do a normal sort, like so:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先进行正常排序，如下所示：
- en: '[PRE58]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: By default, a sort operation will start with the first column of a file, and
    go through each entire row until it runs out of non-unique entries. Here, we see
    that everything sorts properly until it gets to the year column. (We’ll fix that
    in a moment.)
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，排序操作将从文件的第一列开始，然后逐行处理，直到遇到非唯一条目。在这里，我们看到所有内容都按正确的顺序排序，直到年份列。（稍后我们会修复这个问题。）
- en: Whenever there is more than one car of a certain make, the sort will continue
    to the model column. When there is more than one of a given model, the sort will
    continue on to the year column. The mileage column is considered in the sort as
    well, even though it may not look like it in this example. That’s because of the
    problem with numerical sorting that I showed you a couple of pages ago.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 当某个品牌的汽车超过一辆时，排序将继续到型号列。当某个型号超过一辆时，排序将继续到年份列。即使在这个示例中看起来没有，里程列也会参与排序。这是因为我在几页前展示过的数字排序问题。
- en: 'In order to sort numbers in numerical order instead of machine-sort order,
    you have to use the `-n` switch. We can do that by using the `-k` switch to specify
    the individual columns that we want to sort, like so:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 为了按数字顺序排序数字而不是机器排序顺序，您必须使用`-n`选项。我们可以通过使用`-k`选项来指定要排序的单独列，如下所示：
- en: '[PRE59]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: The `-k1,3` option means to sort on fields one through three. (In other words,
    sort on the make, model, and year fields.) The `-k4n` option means to also sort
    on the fourth (the mileage) field in numerical order.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: '`-k1,3`选项表示对第一个到第三个字段进行排序。（换句话说，按品牌、型号和年份字段排序。）`-k4n`选项表示还要按第四个（里程）字段以数字顺序排序。'
- en: Note that you can specify sort options for individual fields. Also note that
    the price column will never be considered in this sort, since no line entries
    are completely identical up through the mileage column.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，您可以为单独的字段指定排序选项。还要注意，价格列在此排序中永远不会被考虑，因为直到里程列之前，没有任何行条目是完全相同的。
- en: 'Next, let’s sort our autos list first by both manufacturer and then by price.
    For this, you would have to sort on fields one and five. Since we already know
    that we need the `-n` switch for column five to sort properly, we’ll go ahead
    and add it in, like so:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们先按制造商和价格对汽车列表进行排序。为此，您需要对第一个和第五个字段进行排序。由于我们已经知道需要使用`-n`选项来正确排序第五列，因此我们将继续添加它，如下所示：
- en: '[PRE60]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: Whenever you specify two or more `-k` switches, `sort` will perform its operation
    in more than one pass. For the first pass, it will sort on the field specified
    with the first `-k` switch. Sorts on the remaining specified fields will be performed
    in subsequent passes.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 每当您指定两个或更多的`-k`选项时，`sort`将在多个回合中执行其操作。在第一次回合中，它将按第一个`-k`选项指定的字段进行排序。对其余指定字段的排序将在后续回合中执行。
- en: Here, we see that `sort` ignored the second `-k` switch. That’s because the
    first `-k` switch didn’t specify an end point for its sort. So, `sort` evaluated
    each entire line on the first pass, and decided that a second pass wasn’t needed.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们看到`sort`忽略了第二个`-k`选项。这是因为第一个`-k`选项没有为其排序指定结束点。所以，`sort`在第一次回合中评估了每一整行，认为不需要第二次回合。
- en: Now, let’s specify an endpoint for the first `-k` switch to see if that makes
    a difference.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们为第一个`-k`选项指定一个结束点，看看这是否会有所不同。
- en: '[PRE61]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: The `-k1,1` option means that we want the first pass to sort on the first—and
    only the first—field of our file. By adding that end point, our sort works as
    we want it to.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: '`-k1,1`选项表示我们希望第一次排序仅按照文件的第一个字段进行排序。通过添加该结束点，我们的排序就按预期工作了。'
- en: You don’t have to start with the first field for your sorts. For this next example,
    we’ll sort first by field three (year), and then by field one (make).
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 您不必从第一个字段开始排序。在下一个示例中，我们将首先按第三个字段（年份）排序，然后按第一个字段（品牌）排序。
- en: '[PRE62]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: Again, you can see what happens when you don’t specify an end point for your
    first sort field. So, let’s try this again.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，您可以看到当没有为第一个排序字段指定结束点时会发生什么。让我们再试一次。
- en: '[PRE63]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: Okay, so it still didn’t work. Everything is still sorted correctly by year,
    but not by make. We’re not the ones to give up here, so let’s try it one more
    time.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 好吧，它还是没有工作。所有内容仍然按年份正确排序，但没有按品牌排序。我们不是轻易放弃的人，所以再试一次。
- en: '[PRE64]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: Note how in four out of the five fields, the text strings are of different lengths.
    Theoretically, the extra blank spaces in the lines with shorter text strings should
    have adversely affected all of the sort operations that we’ve performed. For some
    reason, however, only this last sort operation was affected. By adding the `-b`
    switch, we’re telling `sort` to ignore the extra blank spaces.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，在五个字段中的四个字段中，文本字符串的长度不同。理论上，较短文本字符串行中的额外空格应该会对我们执行的所有排序操作产生不利影响。然而，由于某种原因，只有最后一次排序操作受到了影响。通过添加`-b`选项，我们告诉`sort`忽略多余的空格。
- en: Okay, maybe you don’t have a collection of antique automobiles. But, you might
    have lists of other items that you’ll need to sort in various ways. Keep in mind
    that you can use the techniques that I’ve presented here for any type of list
    that you might have.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 好吧，也许你没有一辆古董汽车的收藏。但你可能有其他需要按各种方式排序的项目清单。请记住，你可以使用我在这里展示的技巧来处理任何类型的清单。
- en: 'All right, that’s enough for the vintage automobiles. Let’s now look at sorting
    lists of months. First, let’s create the list, like so:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，这样就足够了，关于古董汽车的内容就到此为止。让我们现在看看如何排序月份列表。首先，让我们创建这个列表，像这样：
- en: '[PRE65]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'Now, use the `-M` switch to sort the list by month:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，使用 `-M` 开关按月份排序列表：
- en: '[PRE66]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: As you see, the `-M` switch isn’t case-sensitive.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，`-M` 开关不区分大小写。
- en: 'Now, use the techniques you’ve learned in the previous examples to sort first
    by year, and then by month, like so:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，使用你在前面的示例中学到的技巧，先按年份排序，再按月份排序，像这样：
- en: '[PRE67]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'And finally, as promised, I’ll now show you how to use `join` and `sort` together
    to somewhat emulate a simple relational database program. Let’s first take a peek
    at the input files, which are the same ones that we used before. First, we have
    `actorfile_1.txt`:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，正如我承诺的，我现在将向你展示如何将 `join` 和 `sort` 一起使用，来大致模拟一个简单的关系数据库程序。让我们首先看一下输入文件，它们是我们之前使用的相同文件。首先，我们有
    `actorfile_1.txt`：
- en: '[PRE68]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'The second input file is `actorfile_2.txt`, which looks like this:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个输入文件是 `actorfile_2.txt`，内容如下：
- en: '[PRE69]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: Now, we’ll join them together and feed the results through `sort`. (Again, note
    how `join` turns the tabs in the input into normal spaces.)
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将它们连接起来，并将结果通过 `sort` 传递。（再一次，注意 `join` 如何将输入中的制表符转为普通空格。）
- en: '[PRE70]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'Okay, this doesn’t look so great, because `join` doesn’t maintain proper column
    alignment. Let’s fix that by piping the output into the `column -t` command, like
    this:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 好吧，这样看起来不太好，因为 `join` 无法保持列的正确对齐。让我们通过将输出管道传输到 `column -t` 命令来解决这个问题，像这样：
- en: '[PRE71]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: We can use the techniques we’ve already learned to sort by category, and then
    by last name.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用已经学到的技巧按类别排序，然后按姓氏排序。
- en: '[PRE72]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: As you see, there’s a lot to this topic, but don’t let that discourage you.
    With a little practice, you’ll be sorting with the pros.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，这个话题有很多内容，但不要因此而气馁。通过一点点练习，你会像专业人士一样进行排序。
- en: Okay, that just about wraps things up for this chapter. Let’s summarize and
    move on.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，这一章差不多就到此为止了。让我们总结一下并继续。
- en: Summary
  id: totrans-240
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: As a Linux systems administrator, a developer, or even an office clerk who uses
    Linux, you might need to extract and format data from either text files or the
    output of system commands. In this chapter you learned about various text-stream
    filters and how they can be useful for helping you do this. There are plenty more
    filters left to cover, which we’ll do in the next chapter. I’ll see you there.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 作为一个Linux系统管理员、开发者，甚至是一个使用Linux的办公室文员，你可能需要从文本文件或系统命令的输出中提取并格式化数据。在本章中，你学习了各种文本流过滤器以及它们如何帮助你完成这些任务。还有很多其他过滤器需要覆盖，我们将在下一章中讨论。我会在那里等你。
- en: Questions
  id: totrans-242
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: Which of the following utilities would you use to join two or more files together
    side-by-side?
  id: totrans-243
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下哪个实用程序可以用来将两个或更多文件并排连接在一起？
- en: '`join`'
  id: totrans-244
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`join`'
- en: '`cat`'
  id: totrans-245
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`cat`'
- en: '`tac`'
  id: totrans-246
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`tac`'
- en: '`paste`'
  id: totrans-247
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`paste`'
- en: Which two of the following utilities can you use together to create simple databases?
    (Choose two.)
  id: totrans-248
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下哪两个实用程序可以一起使用来创建简单的数据库？（选择两个。）
- en: '`paste`'
  id: totrans-249
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`paste`'
- en: '`sort`'
  id: totrans-250
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`sort`'
- en: '`join`'
  id: totrans-251
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`join`'
- en: '`cat`'
  id: totrans-252
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`cat`'
- en: Which of the following commands would properly save the output of the cat operation?
  id: totrans-253
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下哪个命令可以正确保存 `cat` 操作的输出？
- en: '`cat file1.txt file2.txt > file1.txt`'
  id: totrans-254
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`cat file1.txt file2.txt > file1.txt`'
- en: '`cat file1.txt file2.txt > file2.txt`'
  id: totrans-255
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`cat file1.txt file2.txt > file2.txt`'
- en: '`cat file1.txt file2.txt > file3.txt`'
  id: totrans-256
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`cat file1.txt file2.txt > file3.txt`'
- en: You want `sort` to sort on Field 1, and only Field 1, of your file. What would
    your command look like?
  id: totrans-257
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果你希望 `sort` 仅按文件的第1列进行排序，命令应该是什么样的？
- en: '`sort -F1 myfile.txt`'
  id: totrans-258
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`sort -F1 myfile.txt`'
- en: '`sort -F1,1 myfile.txt`'
  id: totrans-259
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`sort -F1,1 myfile.txt`'
- en: '`sort -k1 myfile.txt`'
  id: totrans-260
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`sort -k1 myfile.txt`'
- en: '`sort -k1,1 myfile.txt`'
  id: totrans-261
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`sort -k1,1 myfile.txt`'
- en: Which of the following option switches would you use with cat to eliminate duplicate
    blank lines?
  id: totrans-262
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下哪个选项开关可以与 `cat` 一起使用，以去除重复的空白行？
- en: '`-d`'
  id: totrans-263
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`-d`'
- en: '`-s`'
  id: totrans-264
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`-s`'
- en: '`-o`'
  id: totrans-265
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`-o`'
- en: '`-u`'
  id: totrans-266
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`-u`'
- en: Further Reading
  id: totrans-267
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: 'Linux Professional Institute Exam 101 Objectives: [https://www.lpi.org/our-certifications/exam-101-objectives](https://www.lpi.org/our-certifications/exam-101-objectives)'
  id: totrans-268
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Linux专业认证考试101目标：[https://www.lpi.org/our-certifications/exam-101-objectives](https://www.lpi.org/our-certifications/exam-101-objectives)
- en: 'How to Use the join Command on Linux: [https://www.howtogeek.com/542677/how-to-use-the-join-command-on-linux/](https://www.howtogeek.com/542677/how-to-use-the-join-command-on-linux/)'
  id: totrans-269
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '如何在Linux上使用join命令: [https://www.howtogeek.com/542677/how-to-use-the-join-command-on-linux/](https://www.howtogeek.com/542677/how-to-use-the-join-command-on-linux/)'
- en: 'sort Command Examples: [https://linuxhandbook.com/sort-command/](https://linuxhandbook.com/sort-command/)'
  id: totrans-270
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '排序命令示例: [https://linuxhandbook.com/sort-command/](https://linuxhandbook.com/sort-command/)'
- en: Answers
  id: totrans-271
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 答案
- en: d
  id: totrans-272
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: d
- en: b and c
  id: totrans-273
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: b和c
- en: c
  id: totrans-274
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: c
- en: d
  id: totrans-275
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: d
- en: b
  id: totrans-276
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: b
- en: Join our community on Discord!
  id: totrans-277
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 加入我们的Discord社区！
- en: Read this book alongside other users, Linux experts, and the author himself.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 与其他用户、Linux专家以及作者本人一起阅读本书。
- en: Ask questions, provide solutions to other readers, chat with the author via
    Ask Me Anything sessions, and much more. Scan the QR code or visit the link to
    join the community.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 提问、为其他读者提供解决方案、通过问我任何问题环节与作者互动，更多内容。扫描二维码或访问链接加入社区。
- en: '[https://packt.link/SecNet](https://packt.link/SecNet)'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://packt.link/SecNet](https://packt.link/SecNet)'
- en: '![](img/QR_Code10596186092701843.png)'
  id: totrans-281
  prefs: []
  type: TYPE_IMG
  zh: '![](img/QR_Code10596186092701843.png)'
