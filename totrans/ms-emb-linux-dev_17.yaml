- en: '14'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '14'
- en: Managing Power
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 管理电源
- en: 'For devices operating on battery power, power management is critical. Anything
    we can do to reduce power usage will increase battery life. Even for devices running
    on mains power, reducing power usage lowers energy costs and decreases the need
    for cooling. In this chapter, I will introduce the four principles of power management:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 对于使用电池供电的设备，电源管理至关重要。我们能做的任何减少功耗的事情都会延长电池寿命。即便是使用主电源的设备，减少功耗也能降低能源成本并减少散热需求。本章将介绍电源管理的四个原则：
- en: Don’t rush if you don’t have to.
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果不急，就不要着急。
- en: Don’t be ashamed of being idle.
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不要为空闲而感到羞耻。
- en: Turn off things you are not using.
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 关闭不使用的设备。
- en: Sleep when there is nothing else to do.
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 没有其他事情做时就去休息吧。
- en: In more technical terms, the power management system should reduce the CPU clock
    frequency. During idle periods, it should choose the deepest sleep state possible;
    it should reduce the load by powering down unused peripherals; and it should put
    the whole system into a suspended state while ensuring power state transitions
    are quick.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 更技术性地说，电源管理系统应当降低 CPU 时钟频率。在空闲时，应选择最深的睡眠状态；应通过关闭未使用的外设来减轻负载；并应确保整个系统进入挂起状态，同时确保电源状态的切换迅速。
- en: Linux has features that address each of these points. I will describe each one
    in turn with examples and advice on how to apply them to an embedded system.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: Linux 具有解决这些问题的功能。我将逐一描述每个功能，并提供示例和如何将其应用于嵌入式系统的建议。
- en: Some of the terms, such as **C-states** and **P-states**, are taken from the
    **Advanced Configuration and Power Interface** (**ACPI**) specification. I will
    describe these as we get to them. The full reference to the specification is given
    in the *Further study* section.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 一些术语，如 **C-state** 和 **P-state**，取自 **高级配置和电源接口**（**ACPI**）规范。我们将在讨论时详细描述这些术语。该规范的完整参考可见于
    *进一步学习* 部分。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下主题：
- en: Measuring power usage
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 测量功耗
- en: Scaling the clock frequency
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 调整时钟频率
- en: Selecting the best idle state
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 选择最佳空闲状态
- en: Powering down peripherals
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 关闭外设电源
- en: Putting the system to sleep
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将系统置于睡眠状态
- en: Technical requirements
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'To follow along with the examples, make sure you have the following:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 要跟随示例，确保你拥有以下设备：
- en: An Ubuntu 24.04 or later LTS host system
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一台 Ubuntu 24.04 或更高版本的 LTS 主机系统
- en: A microSD card reader and card
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一张 microSD 卡和读卡器
- en: balenaEtcher for Linux
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: balenaEtcher for Linux
- en: An Ethernet cable and router with an available port for network connectivity
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一根以太网线和一个有可用端口的路由器，用于网络连接
- en: A USB-to-TTL serial cable with 3.3 V logic level
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一条带有 3.3 V 逻辑电平的 USB 到 TTL 串口电缆
- en: BeaglePlay
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: BeaglePlay
- en: A 5 V USB-C power supply capable of delivering 3 A
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一款能够提供 3 A 电流的 5 V USB-C 电源
- en: 'The code used in this chapter can be found in the chapter folder in this book’s
    GitHub repository: [https://github.com/PacktPublishing/Mastering-Embedded-Linux-Development](https://github.com/PacktPublishing/Mastering-Embedded-Linux-Development).'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中使用的代码可以在本书 GitHub 仓库的章节文件夹中找到：[https://github.com/PacktPublishing/Mastering-Embedded-Linux-Development](https://github.com/PacktPublishing/Mastering-Embedded-Linux-Development)。
- en: Measuring power usage
  id: totrans-26
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测量功耗
- en: For the examples in this chapter, we need to use real hardware rather than virtual.
    This means that we need a BeaglePlay with working power management. The necessary
    firmware for BeaglePlay’s **Power Management Integrated Circuit** (**PMIC**) might
    exist in the `meta-ti` layer but I did not investigate that. We will use a pre-built
    Debian image instead.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的示例需要使用真实硬件，而非虚拟硬件。这意味着我们需要一个具备正常电源管理的 BeaglePlay。BeaglePlay 的 **电源管理集成电路**（**PMIC**）所需的固件可能在
    `meta-ti` 层中，但我并未深入调查。我们将使用预构建的 Debian 镜像。
- en: The procedure for installing Debian on BeaglePlay is the same as in [*Chapter
    12*](Chapter_04.xhtml#_idTextAnchor126). Revisit the *Installing Debian on BeaglePlay*
    section and flash the eMMC with Debian Bookworm if you have not already. Remove
    any microSD from your BeaglePlay and boot from the eMMC. SSH to `beaglebone.local`
    and log in as the `debian` user.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 在 BeaglePlay 上安装 Debian 的过程与[*第 12 章*](Chapter_04.xhtml#_idTextAnchor126)相同。如果还没有，重新访问
    *在 BeaglePlay 上安装 Debian* 部分，并用 Debian Bookworm 刷写 eMMC。移除 BeaglePlay 上的任何 microSD
    卡，并从 eMMC 启动。通过 SSH 连接到 `beaglebone.local` 并以 `debian` 用户登录。
- en: 'Verify that the correct version of Debian is running:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 验证是否正在运行正确版本的 Debian：
- en: '[PRE0]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Now check whether the power management is working:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 现在检查电源管理是否正常工作：
- en: '[PRE1]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: If you see all three states, then everything is working fine. If you see only
    `freeze`, then the power management subsystem is not working. Go back and double-check
    the previous steps.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你看到所有三个状态，那么一切正常。如果只看到`freeze`，那么电源管理子系统没有工作。请返回并仔细检查之前的步骤。
- en: 'Now we can move on to measuring power usage. There are two approaches: *external*
    and *internal*. To measure power externally, we need an ammeter to measure the
    current and a voltmeter to measure the voltage, then multiply the two together
    to get the wattage. You can use basic meters that give a readout that you then
    jot down, or they can be much more sophisticated and integrate data logging so
    that you can see the change in power as the load fluctuates millisecond by millisecond.
    For the purposes of this chapter, I powered the BeaglePlay from the USB-C port
    and used a cheap USB-C power monitor of the type that costs a few dollars.'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以继续进行功耗测量了。有两种方法：*外部*和*内部*。要进行外部功耗测量，我们需要一个安培计来测量电流，一个伏特计来测量电压，然后将两者相乘得到功率。你可以使用基本的仪表读取数据，然后记录下来，或者使用更复杂的设备，集成数据记录功能，以便你可以看到功率随负载波动的变化，精确到毫秒级。为了本章的目的，我使用USB-C端口为BeaglePlay供电，并使用一个便宜的USB-C电源监视器，这种监视器的价格只需要几美元。
- en: The other approach is to use the monitoring systems that are built into Linux.
    You will find that plenty of information is reported to you via `sysfs`. There
    is also a very useful program called **PowerTOP**, which gathers information together
    from various sources and presents it in a single place. PowerTOP is a package
    for both The Yocto Project and Buildroot. It is also available for installation
    on Debian.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种方法是使用内建于Linux的监控系统。你会发现很多信息通过`sysfs`向你报告。还有一个非常有用的程序叫做**PowerTOP**，它从各种来源收集信息并集中展示。PowerTOP是一个适用于Yocto项目和Buildroot的包，也可以在Debian上安装。
- en: 'To install PowerTOP on BeaglePlay from Debian Bookworm, run the following:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 要在Debian Bookworm上为BeaglePlay安装PowerTOP，请运行以下命令：
- en: '[PRE2]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Don’t forget to plug your BeaglePlay into Ethernet before updating the list
    of available packages and installing PowerTOP.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 更新可用包列表并安装PowerTOP之前，别忘了将BeaglePlay连接到以太网。
- en: 'Here is an example of PowerTOP running on BeaglePlay:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 这是PowerTOP在BeaglePlay上运行的一个例子：
- en: '![Figure 14.1 – PowerTOP overview](img/B18466_14_01.png)'
  id: totrans-40
  prefs: []
  type: TYPE_IMG
  zh: '![图14.1 – PowerTOP概览](img/B18466_14_01.png)'
- en: Figure 14.1 – PowerTOP overview
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 图14.1 – PowerTOP概览
- en: In this screenshot, we can see that the system is quiet, with only 2.7% of CPU
    used. I will show more interesting examples later in the *Using CPUFreq* and *CPUIdle
    driver* subsections of this chapter.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 在这张截图中，我们可以看到系统处于空闲状态，仅使用了2.7%的CPU。稍后我将在本章的*使用CPUFreq*和*CPUIdle驱动程序*小节中展示更多有趣的例子。
- en: 'Now that we have a way to measure power consumption, let’s look at one of the
    biggest knobs for managing power in an embedded Linux system: the clock frequency.'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们有了测量功耗的方法，接下来我们来看看在嵌入式Linux系统中管理电源的一个重要调整项：时钟频率。
- en: Scaling the clock frequency
  id: totrans-44
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 调整时钟频率
- en: If running for a kilometer takes more energy than walking, then maybe running
    the CPU at a lower frequency can save energy. Let’s see.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 如果跑步一公里消耗的能量比走路更多，那么也许将CPU运行在较低频率下能节省能源。让我们来看看。
- en: 'The power consumption of a CPU when executing code is the sum of a static component,
    caused primarily by gate leakage current, and a dynamic component, caused by the
    gate switching:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: CPU在执行代码时的功耗是静态组件和动态组件的总和，静态组件主要由门电流泄漏引起，动态组件由门切换引起：
- en: '*P*[cpu] *= P*[static] *+ P*[dyn]'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: '*P*[cpu] *= P*[static] *+ P*[dyn]'
- en: 'The dynamic power component is dependent on the total capacitance of the logic
    gates being switched, the clock frequency, and the square of the voltage:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 动态功耗组件依赖于被切换的逻辑门的总电容、时钟频率和电压的平方：
- en: '*P*[dyn] *= CFV*[2]'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: '*P*[dyn] *= CFV*[2]'
- en: Changing the frequency by itself does not save energy because the same number
    of CPU cycles need to be completed for a given task. If we reduce the frequency
    by half while keeping the voltage constant, then it will take twice as long to
    complete the task, even though the total amount of energy expended is the same.
    In fact, reducing the frequency may actually increase the power budget because
    it takes longer for the CPU to enter an idle state. This is especially the case
    when there are no other competing tasks to run, and the CPU’s idle state is extremely
    energy efficient. So, under these conditions, it is best to use the highest frequency
    possible so that the CPU can go back to idle quickly. This is called the **race
    to idle**.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 仅仅改变频率本身并不能节省能量，因为对于给定任务，需要完成相同数量的 CPU 周期。如果我们将频率降低一半，同时保持电压不变，那么完成任务的时间将是原来的两倍，尽管所消耗的总能量是相同的。事实上，降低频率可能会实际上增加功耗，因为
    CPU 进入空闲状态所需的时间更长。特别是当没有其他竞争任务时，CPU 的空闲状态是非常节能的。因此，在这种情况下，最好使用尽可能高的频率，以便 CPU 可以快速返回空闲状态。这被称为
    **竞速空闲**。
- en: '**IMPORTANT NOTE**'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: '**重要注意事项**'
- en: 'There is another motivation to reduce frequency: **thermal management**. It
    may become necessary to operate at a lower frequency just to keep the temperature
    of the package within bounds. But that is not our focus here.'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 降低频率的另一个动机是：**热管理**。有时可能需要以较低的频率运行，以保持封装温度在允许范围内。但这不是我们这里关注的重点。
- en: Therefore, if we want to reduce power consumption, we must be able to change
    the voltage that the CPU core operates at. But for any given voltage, there is
    a maximum frequency beyond which the switching of the gates becomes unreliable.
    Higher frequencies need higher voltages, and so the two need to be adjusted together.
    Many SoCs implement such a feature. It is called **Dynamic Voltage and Frequency
    Scaling** (**DVFS**). Manufacturers calculate optimum combinations of core frequency
    and voltage. Each combination is called an **Operating Performance Point** (**OPP**).
    The ACPI specification refers to them as **P-states**, with `P0` being the OPP
    with the highest frequency. Although an OPP is a combination of a frequency and
    a voltage, it is most often referred to by the frequency component alone.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，如果我们想要减少功耗，我们必须能够调整 CPU 核心的工作电压。但对于任何给定的电压，都有一个最大频率，超过该频率，晶体管门的切换将变得不可靠。更高的频率需要更高的电压，因此两者需要一起调整。许多
    SoC 实现了这样的功能，这被称为 **动态电压和频率调节** (**DVFS**) 。制造商计算出核心频率和电压的最佳组合。每个组合被称为 **工作性能点**
    (**OPP**) 。ACPI 规范将它们称为 **P 状态**，其中 `P0` 是具有最高频率的 OPP。虽然 OPP 是频率和电压的组合，但它通常仅按频率来称呼。
- en: A kernel driver is needed to switch between P-states. Next, we will look at
    that driver and the governors that control it.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 需要一个内核驱动程序来在 P 状态之间进行切换。接下来，我们将查看该驱动程序及其控制的调节器。
- en: CPUFreq driver
  id: totrans-55
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: CPUFreq 驱动
- en: 'Linux has a component named **CPUFreq** that manages the transitions between
    OPPs. It is part of the board support for the package for each SoC. CPUFreq consists
    of drivers that make the transition from one OPP to another and a set of governors
    that implement the policy of when to switch. It is controlled per CPU via the
    `/sys/devices/system/cpu/cpuN/cpufreq` directory, with `N` being the CPU number.
    In there, we find a number of files, the most interesting of which are:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: Linux 有一个名为 **CPUFreq** 的组件，用于管理不同 OPP（工作性能点）之间的转换。它是每个 SoC 包的板级支持的一部分。CPUFreq
    包含驱动程序，用于实现从一个 OPP 到另一个 OPP 的过渡，以及一组调节器（governors），用于实现何时切换的策略。它是通过 `/sys/devices/system/cpu/cpuN/cpufreq`
    目录对每个 CPU 进行控制，其中 `N` 是 CPU 编号。在该目录下，我们可以找到一些文件，其中最有趣的包括：
- en: '`cpuinfo_cur_freq`, `cpuinfo_max_freq`, and `cpuinfo_min_freq`: These are the
    current frequencies for this CPU, together with the maximum and minimum in KHz.'
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`cpuinfo_cur_freq`、`cpuinfo_max_freq` 和 `cpuinfo_min_freq`：这些是该 CPU 的当前频率，以及最大频率和最小频率，单位为
    KHz。'
- en: '`cpuinfo_transition_latency`: This is the time in nanoseconds to switch from
    one OPP to another. If the value is unknown, it is set to `-1`.'
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`cpuinfo_transition_latency`：这是从一个 OPP 切换到另一个 OPP 所需的时间，单位为纳秒。如果值未知，则设置为 `-1`。'
- en: '`scaling_available_frequencies`: This is a list of OPP frequencies available
    on this CPU.'
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`scaling_available_frequencies`：这是该 CPU 上可用的 OPP 频率列表。'
- en: '`scaling_available_governors`: This is a list of governors available on this
    CPU.'
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`scaling_available_governors`：这是该 CPU 上可用的调节器列表。'
- en: '`scaling_governor`: This is the CPUFreq governor currently being used.'
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`scaling_governor`：这是当前使用的 CPUFreq 调节器。'
- en: '`scaling_min_freq` and `scaling_max_freq`: This is the range of frequencies
    available to the governor in KHz.'
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`scaling_min_freq`和`scaling_max_freq`：这是调度器在KHz中的可用频率范围。'
- en: '`scaling_setspeed`: This is a file that allows you to manually set the frequency
    when the governor is `userspace`, which I will describe at the end of this subsection.'
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`scaling_setspeed`：这是一个文件，允许在调度器为`userspace`时手动设置频率，我将在本小节最后描述。'
- en: 'The governor sets the policy to change the OPP. It can set the frequency between
    the limits of `scaling_min_freq` and `scaling_max_freq`. The governors are named:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 调度器设置更改OPP的策略。它可以在`scaling_min_freq`和`scaling_max_freq`的限制之间设置频率。调度器命名如下：
- en: '`performance`: This always selects the highest frequency.'
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`performance`：这始终选择最高的频率。'
- en: '`powersave`: This always selects the lowest frequency.'
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`powersave`：这始终选择最低频率。'
- en: '`userspace`: This is where the frequency is set by a user-space program.'
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`userspace`：这是用户空间程序设置频率的地方。'
- en: '`ondemand`: This changes the frequency based on the CPU utilization. If the
    CPU is idle less than 20% of the time, it sets the frequency to the maximum. If
    the CPU is idle more than 30% of the time, it lowers the frequency as idle time
    increases.'
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ondemand`：这根据CPU的利用率更改频率。如果CPU空闲时间少于20%，它会将频率设置为最大值。如果CPU空闲时间超过30%，它会随着空闲时间的增加而降低频率。'
- en: '`conservative`: This is like `ondemand` except it switches to higher frequencies
    in 5% steps rather than going immediately to the maximum.'
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`conservative`：这类似于`ondemand`，只是它以5%的步长切换到更高的频率，而不是立即切换到最大频率。'
- en: '`schedutil`: This aims at better integration with the Linux scheduler.'
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`schedutil`：这个旨在与Linux调度器更好地集成。'
- en: 'The default governor when Debian Bookworm starts up is `performance`:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: Debian Bookworm启动时的默认调度器是`performance`：
- en: '[PRE3]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The TI Linux kernel for BeaglePlay comes with only two governors built-in:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: BeaglePlay的TI Linux内核仅内置了两个调度器：
- en: '[PRE4]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The other governors can be loaded dynamically using `cpupower` or `modprobe`:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 其他调度器可以通过`cpupower`或`modprobe`动态加载：
- en: '[PRE5]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'To install `cpupower` on BeaglePlay from Debian Bookworm, run the following:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 要从Debian Bookworm在BeaglePlay上安装`cpupower`，运行以下命令：
- en: '[PRE6]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'To switch to the `ondemand` governor, run the following:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 要切换到`ondemand`调度器，运行以下命令：
- en: '[PRE7]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The parameters that the `ondemand` governor uses to decide when to change OPP
    can be found and set in `/sys/devices/system/cpu/cpufreq/ondemand/`.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: '`ondemand`调度器用来决定何时更改OPP的参数可以在`/sys/devices/system/cpu/cpufreq/ondemand/`找到并设置。'
- en: Both the `ondemand` and `conservative` governors take into account the effort
    required to change frequency and voltage. This CPUFreq value is `cpuinfo_transition_latency`.
    This calculation only applies to threads with a normal scheduling policy. If a
    thread is being scheduled in real time, both governors will immediately select
    the highest OPP so that the thread can meet its scheduling deadline.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: '`ondemand`和`conservative`调度器都会考虑改变频率和电压所需的努力。这个CPUFreq值是`cpuinfo_transition_latency`。这个计算仅适用于具有普通调度策略的线程。如果线程被实时调度，两个调度器都会立即选择最高的OPP，以便线程能够满足其调度截止时间。'
- en: The `userspace` governor allows the logic of selecting the OPP to be performed
    by a user-space daemon. Examples include `cpudyn` and `powernowd`, although both
    are orientated toward x86-based laptops rather than embedded devices.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: '`userspace`调度器允许通过用户空间守护进程来选择OPP的逻辑。示例包括`cpudyn`和`powernowd`，尽管这两者都偏向于x86架构的笔记本电脑，而非嵌入式设备。'
- en: Now that we know where the runtime details about the CPUFreq driver are located,
    let’s look at how to define the OPPs at compile time.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们知道了有关CPUFreq驱动程序的运行时详细信息所在的位置，让我们来看一下如何在编译时定义OPP。
- en: Using CPUFreq
  id: totrans-85
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用CPUFreq
- en: 'Looking at BeaglePlay, we find that the OPPs are coded in the device tree.
    Here is an extract from `k3`-`am625.dtsi`:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 查看BeaglePlay，我们发现OPP在设备树中进行了编码。以下是`k3`-`am625.dtsi`中的摘录：
- en: '[PRE8]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'We can confirm that these are the OPPs in use at runtime by viewing the available
    frequencies:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过查看可用的频率来确认这些是运行时使用的OPP：
- en: '[PRE9]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Select the `userspace` governor:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 选择`userspace`调度器：
- en: '[PRE10]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'List the available frequency steps:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 列出可用的频率步骤：
- en: '[PRE11]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Now we can measure the power consumed at each OPP with a USB-C power monitor.
    These measurements are not very accurate, so do not take them too seriously.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以使用USB-C电源监测器来测量每个OPP的功耗。这些测量不太准确，所以不要太当真。
- en: 'Set the frequency by writing to `scaling_setspeed`:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 通过写入`scaling_setspeed`来设置频率：
- en: '[PRE12]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Build and run the `MELD/Chapter14/do-work` program on BeaglePlay:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 在BeaglePlay上构建并运行`MELD/Chapter14/do-work`程序：
- en: '[PRE13]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'If we run this constant load while varying the frequency, then we observe the
    following:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们在变化频率的同时保持恒定负载，那么我们观察到以下现象：
- en: '| **Frequency (MHz)** | **CPU utilization (%)** | **Power (mW)** |'
  id: totrans-100
  prefs: []
  type: TYPE_TB
  zh: '| **频率 (MHz)** | **CPU利用率 (%)** | **功率 (mW)** |'
- en: '| 200 | 88 | 1,160 |'
  id: totrans-101
  prefs: []
  type: TYPE_TB
  zh: '| 200 | 88 | 1,160 |'
- en: '| 400 | 44 | 1,160 |'
  id: totrans-102
  prefs: []
  type: TYPE_TB
  zh: '| 400 | 44 | 1,160 |'
- en: '| 600 | 29 | 1,160 |'
  id: totrans-103
  prefs: []
  type: TYPE_TB
  zh: '| 600 | 29 | 1,160 |'
- en: '| 800 | 22 | 1,210 |'
  id: totrans-104
  prefs: []
  type: TYPE_TB
  zh: '| 800 | 22 | 1,210 |'
- en: '| 1,000 | 18 | 1,210 |'
  id: totrans-105
  prefs: []
  type: TYPE_TB
  zh: '| 1,000 | 18 | 1,210 |'
- en: '| 1,250 | 14 | 1,210 |'
  id: totrans-106
  prefs: []
  type: TYPE_TB
  zh: '| 1,250 | 14 | 1,210 |'
- en: '| 1,400 | 13 | 1,210 |'
  id: totrans-107
  prefs: []
  type: TYPE_TB
  zh: '| 1,400 | 13 | 1,210 |'
- en: Table 14.1 – Power consumed at different frequencies
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 表 14.1 – 不同频率下的功耗
- en: This shows power savings of about 4% at the lower frequencies.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 这表明在较低频率下大约节省了4%的功率。
- en: In most cases, the `ondemand` governor is the best one to use since it switches
    between OPPs based on CPU load. To select a particular governor, you can either
    configure the kernel with a default governor like `CPU_FREQ_DEFAULT_GOV_ONDEMAND`,
    or you can use an `init` script to change the governor at boot time. See `MELD/Chapter14/cpufrequtils`
    for an example of how Debian does this with SysVinit.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 在大多数情况下，`ondemand` 调节器是最佳选择，因为它会根据CPU负载在不同的OPP之间切换。要选择特定的调节器，可以通过配置内核，使用默认调节器如`CPU_FREQ_DEFAULT_GOV_ONDEMAND`，或者使用`init`脚本在启动时更改调节器。有关Debian如何使用SysVinit的示例，请参见`MELD/Chapter14/cpufrequtils`。
- en: For more information on the CPUFreq driver, look at the files in the `Documentation/cpu-freq`
    directory of the Linux kernel source tree.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 有关CPUFreq驱动程序的更多信息，请查看Linux内核源代码树中`Documentation/cpu-freq`目录下的文件。
- en: In this section, we were concerned about the power used when the CPU is busy.
    In the next section, we will look at how to save power when the CPU is idle.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们关注的是CPU忙碌时的功耗。在下一节中，我们将探讨如何在CPU空闲时节省功耗。
- en: Selecting the best idle state
  id: totrans-113
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 选择最佳空闲状态
- en: When a processor has no more work to do, it executes a **halt instruction**
    and enters an idle state. While idle, the CPU uses less power. It exits the idle
    state when an event such as a hardware interrupt occurs. Most CPUs have multiple
    idle states that use varying amounts of power. Usually, there is a trade-off between
    the power usage and the latency, or the length of time, it takes to exit the state.
    In the ACPI specification, they are called **C-states**.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 当处理器没有更多工作要做时，它会执行**停止指令**并进入空闲状态。在空闲状态下，CPU的功耗较低。当发生硬件中断等事件时，CPU会退出空闲状态。大多数CPU有多个空闲状态，每个状态消耗的功率不同。通常，功率使用和延迟之间存在权衡，即退出空闲状态所需的时间。在ACPI规范中，这些状态被称为**C状态**。
- en: In the deeper C-states, more circuitry is turned off at the expense of losing
    some state, so it takes longer to return to normal operation. For example, in
    some C-states, the CPU caches may be powered off, and so when the CPU runs again,
    it may have to reload some information from the main memory. This is expensive,
    so you only want to do this if there is a good chance that the CPU will remain
    in this state for some time. The number of states varies from one system to another.
    Each takes some time to recover from sleeping to being fully active.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 在更深的C状态中，更多的电路会关闭，代价是失去一些状态，因此恢复到正常操作所需的时间更长。例如，在某些C状态下，CPU缓存可能会关闭，因此当CPU重新运行时，可能需要从主内存重新加载一些信息。这是非常昂贵的，因此只有在CPU有较大的概率在此状态下保持一段时间时，才应执行此操作。不同系统之间的状态数量不同，每个状态从休眠到完全激活都需要一些时间。
- en: 'The key to selecting the right idle state is to have a good idea of how long
    the CPU is going to be inactive. Predicting the future is always tricky, but there
    are some things that can help. One is the current CPU load: if it is high now,
    it is likely to continue to be so in the immediate future, so a deep sleep would
    not be beneficial. Even if the load is low, it is worth looking to see whether
    there is a timer event that expires soon. If there is no load and no timer, then
    a deeper idle state is justified.'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 选择正确的空闲状态的关键是要有一个清晰的了解，CPU将会有多长时间处于不活动状态。预测未来总是具有挑战性，但有一些因素可以提供帮助。其中之一是当前的CPU负载：如果当前负载很高，短期内很可能继续保持这种状态，这时深度休眠将没有太大好处。即使负载较低，也值得查看是否存在即将到期的定时事件。如果没有负载也没有定时器，那么进入更深的空闲状态是合理的。
- en: The part of Linux that selects the best idle state is the CPUIdle driver. There
    is a good deal of information about it available in the `Documentation/driver-api/pm/cpuidle.rst`
    file inside the Linux kernel source tree.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 选择最佳空闲状态的部分代码是CPUIdle驱动程序。有关它的详细信息，可以查看Linux内核源代码树中的`Documentation/driver-api/pm/cpuidle.rst`文件。
- en: CPUIdle driver
  id: totrans-118
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: CPUIdle驱动程序
- en: Like the CPUFreq subsystem, **CPUIdle** consists of a driver that is part of
    the BSP and a governor that determines the policy. Unlike CPUFreq, the governor
    cannot be changed at runtime and there is no interface for user-space governors.
    There was no CPUIdle support in Debian Bookworm for BeaglePlay at the time of
    writing, so I can only describe it here.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 与CPUFreq子系统类似，**CPUIdle**由BSP的一部分驱动程序和决定策略的调度器组成。与CPUFreq不同，调度器无法在运行时更改，并且没有供用户空间调度器使用的接口。在撰写本文时，Debian
    Bookworm并未支持BeaglePlay的CPUIdle，因此我只能在此进行描述。
- en: 'CPUIdle exposes information about each of the idle states in the `/sys/devices/system/cpu/cpu0/cpuidle`
    directory. Inside that directory, there is a subdirectory for each of the sleep
    states named `state0` to `stateN`. `state0` is the lightest sleep and `stateN`
    is the deepest. Note that the numbering does not match that of the C-states and
    that CPUIdle does not have a state equivalent to `C0` (running). Each state has
    these files:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: CPUIdle暴露了`/sys/devices/system/cpu/cpu0/cpuidle`目录中每个空闲状态的信息。在该目录中，每个睡眠状态都有一个名为`state0`到`stateN`的子目录。`state0`是最轻的睡眠状态，`stateN`是最深的。请注意，编号与C状态不匹配，并且CPUIdle没有与`C0`（运行）对应的状态。每个状态下有以下文件：
- en: '`desc`: A short description of the state'
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`desc`：此状态的简短描述'
- en: '`disable`: An option to disable this state by writing `1` to this file'
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`disable`：通过向此文件写入`1`来禁用此状态的选项'
- en: '`latency`: The time in microseconds that the CPU core takes to resume normal
    operation when exiting this state'
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`latency`：当退出此状态时，CPU核心恢复正常操作所需的时间（单位：微秒）'
- en: '`name`: The name of this state'
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`name`：此状态的名称'
- en: '`power`: The power in milliwatts consumed while in this idle state'
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`power`：在此空闲状态下消耗的功率，单位为毫瓦'
- en: '`time`: The total time in microseconds spent in this idle state'
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`time`：在此空闲状态下花费的总时间（单位：微秒）'
- en: '`usage`: The count of the number of times this state was entered'
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`usage`：该状态被进入的次数'
- en: 'CPUIdle has two governors:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: CPUIdle有两个调度器：
- en: '`ladder`: Steps idle states down or up, one at a time, depending on the time
    spent in the last idle period. It works well with a regular timer tick but not
    with a dynamic tick.'
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ladder`：根据上一个空闲期的持续时间，逐步向下或向上进入空闲状态。它适用于常规的定时器滴答，但不适用于动态滴答。'
- en: '`menu`: Selects an idle state based on the expected idle time. It works well
    with dynamic tick systems.'
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`menu`：根据预期的空闲时间选择一个空闲状态。它适用于动态滴答系统。'
- en: You should choose one or the other depending on your configuration of `NO_HZ`,
    which I will describe at the end of this section.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 您应根据`NO_HZ`的配置选择其中之一，我将在本节末尾描述该配置。
- en: 'Once again, user interaction is via the `sysfs` filesystem. In the `/sys/devices/system/cpu/cpuidle`
    directory, you will find two files:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 再次强调，用户交互是通过`sysfs`文件系统进行的。在`/sys/devices/system/cpu/cpuidle`目录下，您将找到两个文件：
- en: '`current_driver`: This is the name of the CPUIdle driver.'
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`current_driver`：这是CPUIdle驱动程序的名称。'
- en: '`current_governor_ro`: This is the name of the governor.'
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`current_governor_ro`：这是调度器的名称。'
- en: These show which driver and which governor are being used.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 这些文件显示正在使用哪个驱动程序和哪个调度器。
- en: Even with the CPU fully idling, most Linux systems are still configured to wake
    up periodically on receipt of a system timer interrupt. To save more power, we
    need to configure the Linux kernel for tickless operation.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 即使CPU完全处于空闲状态，大多数Linux系统仍然配置为在接收到系统定时器中断时定期唤醒。为了节省更多的电力，我们需要将Linux内核配置为无滴答操作。
- en: Tickless operation
  id: totrans-137
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 无滴答操作
- en: A related topic is the tickless, or `NO_HZ`, option. If the system is truly
    idle, the most likely source of interruptions will be the system timer, which
    is programmed to generate a regular time tick at a rate of `HZ` per second, where
    `HZ` is typically `100`. Historically, Linux uses the timer tick as the main time
    base for measuring timeouts.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 一个相关的话题是无滴答操作或`NO_HZ`选项。如果系统完全空闲，最可能的中断源是系统定时器，它被编程为以每秒`HZ`次的频率生成定时滴答，其中`HZ`通常为`100`。历史上，Linux使用定时滴答作为测量超时的主要时间基准。
- en: And yet it is plainly wasteful to wake the CPU up to process a timer interrupt
    if no timer events are registered for that given moment. The dynamic tick kernel
    configuration option, `CONFIG_NO_HZ_IDLE`, looks at the timer queue at the end
    of the timer processing routine and schedules the next interruption at the time
    of the next event. This avoids unnecessary wakeups and allows the CPU to be idle
    for long periods. In any power-sensitive application, the kernel should be configured
    with this option enabled.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果没有注册定时器事件，在某个特定时刻唤醒CPU来处理定时器中断是显然浪费的。动态滴答内核配置选项`CONFIG_NO_HZ_IDLE`会在定时器处理例程结束时查看定时器队列，并在下一个事件发生时安排下次中断。这避免了不必要的唤醒，使CPU可以长时间处于空闲状态。在任何对电源敏感的应用中，都应该配置内核启用此选项。
- en: While the CPU consumes much of the power in an embedded Linux system, there
    are other components of the system that can also be powered down for energy savings.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然CPU消耗了嵌入式Linux系统中的大部分电力，但系统中也有其他组件可以关闭以节省能源。
- en: Powering down peripherals
  id: totrans-141
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 关闭外设电源
- en: The discussion up to now has been about CPUs and how to reduce power consumption
    when they are running or idling. Now it is time to focus on other parts of the
    system and see whether we can achieve power savings here.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 直到现在，我们讨论的都是CPU以及如何在其运行或空闲时减少功耗。现在是时候关注系统的其他部分，看看是否能在这里实现节能了。
- en: In the Linux kernel, this is managed by the **runtime power management system**,
    or **runtime pm** for short. It works with drivers that support runtime pm by
    shutting down those that are not in use and waking them again when they are next
    needed.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 在Linux内核中，这由**运行时电源管理系统**（runtime power management system）管理，简称**运行时电源管理（runtime
    pm）**。它与支持运行时电源管理的驱动程序配合工作，关闭未使用的设备，并在需要时再次唤醒它们。
- en: It is dynamic and should be transparent to user space. It is up to the device
    driver to decide how to power down the hardware. Typically, runtime pm includes
    turning off the clock to the subsystem, also known as clock gating, and turning
    off core circuitry where possible.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 它是动态的，且应对用户空间透明。设备驱动程序决定如何关闭硬件电源。通常，运行时电源管理包括关闭子系统时钟，也称为时钟门控（clock gating），以及在可能的情况下关闭核心电路。
- en: 'Runtime power management is exposed via a `sysfs` interface. Each device has
    a subdirectory named `power` where you will find these files:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 运行时电源管理通过`sysfs`接口暴露。每个设备都有一个名为`power`的子目录，在这里你可以找到以下文件：
- en: '`control`: This allows user space to determine whether runtime pm is used on
    this device. If it is set to `auto`, then runtime pm is enabled, but by setting
    it to `on`, the device is always on and does not use runtime pm.'
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`control`：这允许用户空间决定是否在此设备上使用运行时电源管理（runtime pm）。如果设置为`auto`，则启用运行时电源管理；但如果设置为`on`，设备始终开启，且不使用运行时电源管理。'
- en: '`runtime_enabled`: This reports that runtime pm is `enabled` or `disabled`,
    or, if `control` is `on`, it reports `forbidden`.'
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`runtime_enabled`：此项报告运行时电源管理是否`启用`或`禁用`，如果`control`设置为`on`，则报告`禁止`。'
- en: '`runtime_status`: This reports the current state of the device. It may be `active`,
    `suspended`, or `unsupported`.'
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`runtime_status`：这报告设备的当前状态。它可能是`活动`、`挂起`或`不支持`。'
- en: '`autosuspend_delay_ms`: This is the time before the device is suspended. `-1`
    means wait forever. Some drivers implement this if there is a significant cost
    to suspending the device hardware since it prevents rapid suspend/resume cycles.'
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`autosuspend_delay_ms`：这是设备挂起之前的时间。`-1`表示永远等待。如果挂起设备硬件的代价较高，某些驱动程序会实现此功能，因为它可以防止设备快速挂起和恢复循环。'
- en: 'For a concrete example, let’s look at the MMC driver on BeaglePlay:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 以具体示例为例，让我们来看一下BeaglePlay上的MMC驱动：
- en: '[PRE14]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: So, runtime pm is disabled, the device is currently unsupported, and we cannot
    determine how much delay there will be when it is suspended again.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，运行时电源管理已被禁用，设备当前不受支持，我们无法确定再次挂起时会有多少延迟。
- en: For more information on runtime pm, look in the Linux kernel source code at
    `Documentation/power/runtime_pm.rst`.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 有关运行时电源管理的更多信息，请查看Linux内核源代码中的`Documentation/power/runtime_pm.rst`。
- en: Now that we know what the runtime pm is and what it does, let’s see it in action.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们知道了运行时电源管理是什么以及它是如何工作的，让我们看看它是如何实际应用的。
- en: Putting the system to sleep
  id: totrans-155
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使系统进入休眠状态
- en: 'There is one more power management technique to consider: putting the whole
    system into sleep mode with the expectation that it will not be used again for
    a while. In the Linux kernel, this is known as **system sleep**. It is usually
    user-initiated: the user decides that the device should be shut down for a while.
    For example, I shut the lid of my laptop and put it in my bag when it is time
    to go home. Much of the support for system sleep in Linux comes from the support
    for laptops. In the laptop world, there are usually two options:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一种电源管理技术需要考虑：将整个系统置于睡眠模式，预期它一段时间内不会再被使用。在Linux内核中，这被称为**系统睡眠**。通常由用户发起：用户决定设备应关闭一段时间。例如，当我准备回家时，我合上笔记本电脑的盖子并将其放进包里。Linux中对系统睡眠的大部分支持来自笔记本电脑的支持。在笔记本电脑世界中，通常有两种选择：
- en: Suspend
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 挂起
- en: Hibernate
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 休眠
- en: The first, also known as **suspend to RAM**, shuts everything down except the
    system memory, so the machine is still consuming a little power. When the system
    wakes up, the memory retains all the previous state, and my laptop is operational
    within a few seconds.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个选项，也叫做**挂起到内存**，关闭除了系统内存之外的所有内容，因此机器仍然会消耗一点电量。当系统恢复时，内存会保留所有之前的状态，我的笔记本几秒钟内就能恢复工作。
- en: If I select the **hibernate** option, the contents of the memory are saved to
    the hard drive. The system consumes no power at all, and so it can stay in this
    state indefinitely. On wake up, it takes some time to restore the memory from
    disk. Hibernate is very seldom used in embedded systems, mostly because the flash
    storage tends to be quite slow on read/write, but also because it is intrusive
    to the flow of work.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我选择**休眠**选项，内存的内容会被保存到硬盘。系统完全不消耗电力，因此可以无限期地处于此状态。唤醒时，需要一些时间从硬盘恢复内存。休眠在嵌入式系统中很少使用，主要是因为闪存的读写速度较慢，也因为它对工作流程有侵入性。
- en: For more information, look at the `Documentation/power` directory in the kernel
    source tree.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 如需更多信息，请查看内核源树中的`Documentation/power`目录。
- en: The suspend to RAM and hibernate options map to two of the four sleep states
    supported by Linux. We’ll look at these two types of system sleep and the rest
    of the ACPI power states next.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 挂起到内存和休眠选项对应于Linux支持的四种睡眠状态中的两种。接下来，我们将讨论这两种系统睡眠类型以及其他ACPI电源状态。
- en: Power states
  id: totrans-163
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 电源状态
- en: 'In the ACPI specification, the sleep states are called **S-states**. Linux
    supports four sleep states (**freeze**, **standby**, **mem**, and **disk**), which
    are shown in the following list along with the corresponding ACPI S-state ([`S0`],
    `S1`, `S3`, and `S4`):'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 在ACPI规范中，睡眠状态被称为**S状态**。Linux支持四种睡眠状态（**freeze**、**standby**、**mem** 和 **disk**），这些状态与相应的ACPI
    S状态（[`S0`]、`S1`、`S3` 和 `S4`）对应，具体如下：
- en: '`freeze` ([S0]): This stops (freezes) all activity in user space while the
    CPU and memory continue to operate as normal.'
  id: totrans-165
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`freeze` ([S0])：这会停止（冻结）所有用户空间的活动，同时CPU和内存继续正常工作。'
- en: The power savings result from the fact that no user-space code is being run.
    ACPI does not have an equivalent state so S0 is the closest match. S0 is the state
    for a running system.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 节能的原因在于没有运行任何用户空间代码。ACPI没有等效的状态，因此S0是最接近的匹配。S0是运行系统的状态。
- en: '`standby` (S1): This is like `freeze` except that, in addition, it takes all
    CPUs offline except for the boot CPU.'
  id: totrans-167
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`standby` (S1)：这类似于`freeze`，不同的是，除了启动CPU外，它会将所有CPU下线。'
- en: '`mem` (S3): This powers down the system and puts the memory in self-refresh
    mode. Also known as **suspend to RAM**.'
  id: totrans-168
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`mem` (S3)：这会关闭系统电源并将内存置于自刷新模式。也被称为**挂起到内存**。'
- en: '`disk` (S4): This saves the memory to the hard disk and powers the system down.
    Also known as **suspend to disk**.'
  id: totrans-169
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`disk` (S4)：这将内存保存到硬盘，并关闭系统电源。也被称为**挂起到硬盘**。'
- en: 'Not all systems have support for all states. To find out which are available,
    read the `/sys/power/state` file as shown:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 不是所有系统都支持所有状态。要了解哪些状态是可用的，请读取`/sys/power/state`文件，如下所示：
- en: '[PRE15]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: To enter one of the system sleep states, just write the desired state to `/sys/power/state`.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 要进入其中一个系统睡眠状态，只需将所需状态写入`/sys/power/state`。
- en: 'For embedded devices, the most common need is to suspend to RAM using the `mem`
    option. For example, I can suspend BeaglePlay like this:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 对于嵌入式设备，最常见的需求是使用`mem`选项挂起到内存。例如，我可以像这样挂起BeaglePlay：
- en: '[PRE16]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The device powers down in less than a second and then power usage drops down
    to 10 milliwatts, as measured by my basic multimeter. But how do I wake it up
    again? That is the next topic.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 设备在不到一秒的时间内关闭电源，然后电力消耗下降至10毫瓦，用我的基础万用表测量得出的数据。但如何再次唤醒它呢？这就是接下来的主题。
- en: Wakeup events
  id: totrans-176
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 唤醒事件
- en: 'Before you suspend a device, you must have some way of waking it up again.
    The kernel tries to help you here. If there is not at least one wakeup source,
    the system will refuse to suspend and will return the following message:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 在暂停设备之前，你必须有一种方式将其重新唤醒。内核在这方面会帮助你。如果没有至少一个唤醒源，系统将拒绝暂停并返回以下信息：
- en: '[PRE17]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Of course, this means that some parts of the system have to remain powered on
    even during the deepest sleep. This usually involves the **power management IC**
    (**PMIC**) and the **real-time clock** (**RTC**), and may additionally include
    interfaces such as GPIO, UART, Ethernet, and Wi-Fi.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，这意味着系统的某些部分必须保持开启，即使是在最深的休眠状态下。这通常涉及到**电源管理集成电路**（**PMIC**）和**实时时钟**（**RTC**），并可能还包括如GPIO、UART、以太网和Wi-Fi等接口。
- en: 'Wakeup events are controlled through `sysfs`. Each device in `/sys/device`
    has a subdirectory named `power` containing a `wakeup` file with one of these
    strings:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 唤醒事件通过`sysfs`进行控制。`/sys/device`中的每个设备都有一个名为`power`的子目录，其中包含一个`wakeup`文件，文件内容为以下字符串之一：
- en: '`enabled`: Means this device will generate wakeup events'
  id: totrans-181
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`enabled`：表示该设备将生成唤醒事件'
- en: '`disabled`: Means this device will not generate wakeup events'
  id: totrans-182
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`disabled`：表示该设备不会生成唤醒事件'
- en: '(empty): Means this device is not capable of generating wakeup events'
  id: totrans-183
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: （空）：表示该设备无法生成唤醒事件
- en: 'To get a list of devices that can generate wakeups, search for all devices
    where `wakeup` contains either `enabled` or `disabled`:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 若要获取能够生成唤醒事件的设备列表，请搜索所有`wakeup`包含`enabled`或`disabled`的设备：
- en: '[PRE18]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: We’ve seen how to put a device to sleep and then wake it up with an event from
    a peripheral interface like a UART. What if we want a device to wake itself up
    without any outside interaction? This is where the RTC comes into play.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经了解了如何将设备挂起并通过外部接口（如UART）事件唤醒它。如果我们希望设备在没有外部交互的情况下自我唤醒，该怎么办呢？这时RTC就发挥作用了。
- en: Timed wakeups from the real-time clock
  id: totrans-187
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 来自实时时钟的定时唤醒
- en: BeaglePlay has an RTC that can generate alarm interrupts up to 24 hours in the
    future. If so, the `/sys/class/rtc/rtc1` directory will exist. It should contain
    the `wakealarm` file. Writing a number to `wakealarm` will cause it to generate
    an alarm that number of seconds later. If you also enable wakeup events from `rtc1`,
    the RTC will resume a suspended device.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: BeaglePlay具有一个RTC，可以生成最长24小时内的警报中断。如果存在，`/sys/class/rtc/rtc1`目录将存在。该目录应包含`wakealarm`文件。将一个数字写入`wakealarm`文件会导致它在指定秒数后生成警报。如果你还启用了来自`rtc1`的唤醒事件，RTC将恢复一个挂起的设备。
- en: 'For example, the following `rtcwake` command puts the system in `freeze` with
    the RTC waking it up after 5 seconds:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，以下`rtcwake`命令会将系统置于`freeze`状态，并在5秒后通过RTC唤醒：
- en: '[PRE19]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'The corresponding `journalctl` output looks like this:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 相应的`journalctl`输出如下所示：
- en: '[PRE20]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: The **Power** button on BeaglePlay is also a wakeup source so you can use that
    to resume from `freeze` in the absence of a serial console. Make sure to press
    the **Power** button and not the **Reset** button, which is next to it; otherwise,
    the board will reboot.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: BeaglePlay上的**电源**按钮也是一个唤醒源，因此在没有串口控制台的情况下，你可以使用它从`freeze`状态恢复。确保按下**电源**按钮，而不是旁边的**重置**按钮；否则，板子将重新启动。
- en: This concludes our coverage of the four Linux system sleep modes. We learned
    how to suspend a device to the `mem` or `freeze` power state and then wake it
    up via an event from an RTC or the **Power** button. While the runtime pm in Linux
    was created mostly for laptops, we can leverage this support for embedded systems
    that also run on battery power.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 这篇文章结束了我们对四种Linux系统休眠模式的讨论。我们了解了如何将设备挂起至`mem`或`freeze`电源状态，并通过来自RTC或**电源**按钮的事件唤醒它。虽然Linux中的运行时电源管理主要是为笔记本电脑创建的，但我们可以利用这一支持来为也依靠电池供电的嵌入式系统服务。
- en: Summary
  id: totrans-195
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: 'Linux has sophisticated power management functions. In this chapter, I described
    four main components:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: Linux具有复杂的电源管理功能。在本章中，我描述了四个主要组件：
- en: '**CPUFreq** changes the OPP of each processor core to reduce power on those
    that are busy but have some bandwidth to spare, thereby allowing us to scale the
    frequency back. OPPs are known as P-states in the ACPI specification.'
  id: totrans-197
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**CPUFreq**根据每个处理器核心的工作负载变化来调整OPP，减少忙碌但仍有部分带宽剩余的核心的功耗，从而使我们能够降低频率。OPP在ACPI规范中称为P状态。'
- en: '**CPUIdle** selects deeper idle states when the CPU is not expected to be woken
    up for a while. Idle states are known as C-states in the ACPI specification.'
  id: totrans-198
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**CPUIdle**选择更深的空闲状态，当CPU预期一段时间内不会被唤醒时。空闲状态在ACPI规范中被称为C状态。'
- en: '**Runtime pm** will shut down peripherals that are not needed.'
  id: totrans-199
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**运行时电源管理（Runtime pm）**会关闭不需要的外设。'
- en: '**System sleep** modes will put the whole system into a low-power state. They
    are usually under end user control, for example, by pressing a standby button.
    System sleep states are known as S-states in the ACPI specification.'
  id: totrans-200
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**系统睡眠**模式会将整个系统置于低功耗状态。通常由最终用户控制，例如，通过按下待机按钮。系统睡眠状态在ACPI规范中称为S状态。'
- en: Most of the power management is done for you by the BSP. Your main task is to
    make sure that it is configured correctly for your intended use cases. Only the
    last component, selecting a system sleep state, requires you to write some code
    that will allow the end user to enter and exit the state.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 大部分电源管理工作由BSP（主引导程序）为你完成。你的主要任务是确保其为你预期的使用场景配置正确。只有最后一个组件，即选择系统睡眠状态，需要你编写一些代码，使最终用户能够进入和退出该状态。
- en: The next part of the book is about writing embedded applications. We will start
    with packaging and deploying Python code and then explore containerization techniques.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 本书的下一部分将讨论嵌入式应用程序的编写。我们将从打包和部署Python代码开始，然后探索容器化技术。
- en: Further study
  id: totrans-203
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步学习
- en: '*Advanced Configuration and Power Interface Specification*, UEFI Forum, Inc.
    – [https://uefi.org/sites/default/files/resources/ACPI_Spec_6_5_Aug29.pdf](https://uefi.org/sites/default/files/resources/ACPI_Spec_6_5_Aug29.pdf)'
  id: totrans-204
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*高级配置与电源管理接口规范*，UEFI论坛公司 – [https://uefi.org/sites/default/files/resources/ACPI_Spec_6_5_Aug29.pdf](https://uefi.org/sites/default/files/resources/ACPI_Spec_6_5_Aug29.pdf)'
- en: Join our community on Discord
  id: totrans-205
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 加入我们的Discord社区
- en: 'Join our community’s Discord space for discussions with the authors and other
    readers: https://packt.link/embeddedsystems'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 加入我们社区的Discord空间，与作者和其他读者进行讨论： https://packt.link/embeddedsystems
- en: '![](img/QR_Code12308107448340296.png)'
  id: totrans-207
  prefs: []
  type: TYPE_IMG
  zh: '![](img/QR_Code12308107448340296.png)'
