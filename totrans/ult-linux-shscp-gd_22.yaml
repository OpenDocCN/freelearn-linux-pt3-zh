- en: '22'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Introduction to Z Shell Scripting
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Thus far, we’ve mainly talked about `bash`, since it’s the preeminent login
    shell and scripting environment for Linux. In recent years, a fairly new kid on
    the block, **Z Shell** (`zsh`) has been gaining a bit of popularity as a default
    login shell. But, even on the operating systems that come with `zsh` as the login
    shell, `bash` is still there, and `bash` is what most people still use for scripting
    purposes. Be aware though, that scripting in `zsh` does have certain advantages,
    such as better math capabilities, enhanced variable expansion, and the ability
    to use native `zsh` commands instead of utilities such as `find`, `grep`, or `sed`.
    These features can help you create scripts that are a bit simpler and lighter
    than equivalent `bash` scripts.
  prefs: []
  type: TYPE_NORMAL
- en: Most articles and YouTube videos that you see about `zsh` focus on the user
    interface enhancements, and very few focus on `zsh` scripting. Unfortunately,
    the few books and tutorials that do focus on `zsh` scripting aren’t very well-written,
    and you won’t get much out of them. Hopefully, I can provide some clarification.
  prefs: []
  type: TYPE_NORMAL
- en: Rather than present a detailed tutorial, I’d like to just present a high-level
    overview of `zsh` scripting, so that you can decide for yourself if it’s for you.
  prefs: []
  type: TYPE_NORMAL
- en: 'Topics in this chapter include:'
  prefs: []
  type: TYPE_NORMAL
- en: Introducing `zsh`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Installing `zsh`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding the Unique Features of `zsh` Scripting
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using `zsh` Modules
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If you’re ready, let’s dig in.
  prefs: []
  type: TYPE_NORMAL
- en: Technical Requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'You can use any of your Linux virtual machines for this chapter. As always,
    you can grab the demo scripts by doing:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Introducing zsh
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Z Shell was created in 1990 by Paul Falstad. It’s an extension of the Bourne
    Shell, but also includes features from `bash`, Korn Shell (`ksh`), and C Shell
    (`tcsh`).
  prefs: []
  type: TYPE_NORMAL
- en: The **C Shell**, which used to be somewhat popular with Unix and Unix-like distros,
    is vastly different from anything you’ve seen. Writing a C Shell script is more
    akin to writing a C language program than it is to what you’re used to. So if
    you’re a C language programmer, you might like it. If you’re not, then you might
    not like it so much.
  prefs: []
  type: TYPE_NORMAL
- en: Z Shell comes as the default login shell for both macOS and Kali Linux. For
    pretty much everything else, you’ll need to install it yourself. As far as `zsh`
    scripting goes, most of what you’ve learned about scripting in `bash` also applies
    to scripting in `zsh`. So, in this chapter I’ll just present the unique features
    of `zsh`, and show you some simple scripting examples.
  prefs: []
  type: TYPE_NORMAL
- en: Installing zsh
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `zsh` package is available in all Linux and BSD-type distros that I’ve tried,
    as well as on OpenIndiana. The package name is `zsh` in all cases, so you can
    just install it with your normal package manager.
  prefs: []
  type: TYPE_NORMAL
- en: 'On the BSD distros, you’ll have the same path problem that you had with `bash`.
    That is, on BSD distros, the `zsh` executable is in the `/usr/local/bin/` directory,
    instead of the `/bin/` directory. That’s okay, though. Just create a symbolic
    link in the `/bin/` directory, as you did for `bash`. On my FreeBSD machine, the
    command looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, if you need to run your `zsh` scripts on Linux, OpenIndiana, and BSD machines,
    you can use the same shebang line, which looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'If you want to use `zsh` as your temporary login shell, you can just enter
    `zsh` at your normal shell’s command prompt. If you want to set `zsh` as your
    permanent login shell, use the `chsh` command on Linux and the BSD distros, and
    the `passwd` command on OpenIndiana. Here’s how that looks on Linux and the BSD
    distros:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Here’s how it looks on OpenIndiana:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Note that when you change the shell for your own user account, you’ll be prompted
    to enter your own user password. However, this has nothing to do with `sudo`,
    because even non-privileged users can use `chsh` on Linux/BSD distros and `passwd
    -e` on OpenIndiana to change their own default shells.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first time you log in with `zsh`, you’ll be presented with a setup menu
    that looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Hit the **1** key to go to the main menu, and choose your preferred setup options.
    The configuration will be saved to the `.zshrc` file in your home directory.
  prefs: []
  type: TYPE_NORMAL
- en: Next, let’s look at some of the unique features of `zsh` scripting.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the Unique Features of zsh Scripting
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When you script in `zsh`, you can take advantage of certain enhancements that
    aren’t in `bash`. Here’s a quick review of some of those enhancements.
  prefs: []
  type: TYPE_NORMAL
- en: Differences in Variable Expansion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In *Chapter 8—Basic Shell Script Construction*, I explained the concept of **variable
    expansion**, which is also sometimes called **parameter expansion**. This allows
    you to write cool scripts that do cool things, such as changing the filename extensions
    on a whole batch of files at a time. Most of the same variable expansion constructs
    that are in `bash` are also in `zsh`, but `zsh` has additional ones that provide
    additional capabilities. Let’s look at a few examples.
  prefs: []
  type: TYPE_NORMAL
- en: Substituting Values
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Substituting values in `zsh` works the same as it does in `bash`, with one
    exception. That is, if you substitute a value in a text string that includes an
    exclamation point, you’ll have to escape it in a `zsh` script. For example, here’s
    how it works in `bash`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'As I explained in *Chapter 8*, the `variable_name:-default_value` construct
    supplies a default value for any variable that doesn’t yet have a value assigned
    to it. This same construct is supposed to work in `zsh`, but watch what happens
    when I try it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'When I hit the **Enter** key after typing the `echo` command, `zsh` takes me
    to the `dquote>` prompt. If I hit the `"` key a second time, I get the output
    that I want. To get it right the first time, I’ll just place a `\` before the
    `!`, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: So, with the `\` in front of the exclamation point, it works just fine. I don’t
    know why the `!` needs to be escaped in `zsh`, but whatever works, right?
  prefs: []
  type: TYPE_NORMAL
- en: Substituting Substrings
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Substring substitution partly works in `bash`, but not completely. Here’s what
    I mean.
  prefs: []
  type: TYPE_NORMAL
- en: 'I’ll first create the `name` variable with the value of `lionel`. Then, on
    both `bash` and `zsh`, I’ll attempt to replace the first lower-case *l* with an
    upper-case *l*. First, on `bash`, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, on `zsh`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'In the `${name/l/L}` construct, you see that I first listed the variable `name`
    with a forward slash and the letter that I want to replace, followed by another
    forward slash and the letter that I want to substitute. As you can see, this works
    on both `bash` and `zsh`. I can also replace both both occurrences of the lower-case
    *l* by using two forward slashes after the `name` variable, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: 'On `bash`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'On `zsh`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Again, this works on both `bash` and `zsh`. So, if this works on both shells,
    why am I showing this to you? Well, it’s just that on `bash`, this only works
    if the text string doesn’t contain any blank spaces.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s an example of what I mean:'
  prefs: []
  type: TYPE_NORMAL
- en: 'On `bash`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: This time, I wanted to replace all occurrences of *and* with an ampersand. But,
    this doesn’t work on `bash` because the text string contains blank spaces. So,
    let’s try this on `zsh`.
  prefs: []
  type: TYPE_NORMAL
- en: 'On `zsh`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: On `zsh`, having a text string with blank spaces doesn’t matter.
  prefs: []
  type: TYPE_NORMAL
- en: Translating Between Upper and Lower Case
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Here’s an example of the exact opposite situation. This time, I’ll show you
    something that works on `bash`, but not on `zsh`. Then, I’ll show you the alternative
    method for `zsh`.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, let’s say that we want to capitalize the first letter of the value that’s
    assigned to the `name` variable. Here’s how to do it on `bash`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'All I did here was to place a `^` after the `name` variable in the `echo` statement.
    Now, let’s say that I want to capitalize all letters. I’ll do that by using two
    `^` characters, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'If you have a text string with all upper-case characters, use either one or
    two commas to convert either the first letter or all letters to lower-case, like
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'On `zsh`, none of this works at all, as you see here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: I’m showing you this because some `zsh` scripting books say this will work on
    `zsh`. But, as you see, it definitely doesn’t.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, what’s the alternative on `zsh`? Well, you just use a builtin `zsh` function.
    Let’s first use the `U` function to convert an entire text string to upper-case:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Instead of placing a pair of `^` characters after the name variable, I just
    placed a `(U)` before the `name` variable.
  prefs: []
  type: TYPE_NORMAL
- en: 'As far as I’ve been able to find, there’s no function that converts just the
    first letter. So, let’s convert the first letter like this, instead:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: This is the same method that I’ve just shown you in the previous section.
  prefs: []
  type: TYPE_NORMAL
- en: Next, let’s do some globbing.
  prefs: []
  type: TYPE_NORMAL
- en: Extended File Globbing
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '“What’s **file globbing”**, you say? Well, you’ve actually been working with
    it throughout this book. It’s just that I’ve never told you what it’s called.
    All it means is that you can use wildcard characters, such as the `*` and the
    `?`, to work with multiple files at the same time. For example, you can do this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: All I’m doing here is using the `*` wildcard to view all of the `.zip` files
    in my directory.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can do all this and more in `zsh`. The only catch is that you need to have
    the `extendedglob` feature turned on. To verify that it is, look in the `.zshrc`
    file in your home directory. You should see a line that looks something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: If the `extendedglob` option is there, then you’re good. If it isn’t, just add
    it in. So now, let’s look at a few examples of extended globbing.
  prefs: []
  type: TYPE_NORMAL
- en: Why is extended file globbing on `zsh` useful? Well, it’s just that in many
    cases, you’ll be able to use the extended globbing features of `zsh` instead of
    using the `find` utility. You might find this easier than using `find`. Or, you
    might prefer using `find`, if that’s what you’re used to using. I’ll let you make
    the decision.
  prefs: []
  type: TYPE_NORMAL
- en: Also, for demo purposes, I’m mainly showing you this with the `ls` utility.
    But, you can also use globbing with other utilities, such as `cp`, `mv`, `rm`,
    `chmod`, or `chown`.
  prefs: []
  type: TYPE_NORMAL
- en: Filtering ls Output
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'With this cool feature enabled, you can do cool things like excluding files
    that you don’t want to see. For example, let’s say that you want to see all files
    in your directory except for the `.sh` files. Just do this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: The `^` that precedes the `*.sh` is a negation symbol. This is what prevents
    the `ls` command from showing you the `.sh` files.
  prefs: []
  type: TYPE_NORMAL
- en: Note that I had to include the `-d` option for `ls`. Otherwise, you’ll also
    see files in any subdirectories that you might have. For some reason, the `^`
    filters out the unwanted files in my top level directory, but it doesn’t filter
    out the unwanted files in the subdirectories. So, without the `-d`, you’ll also
    see all files that are in the subdirectories, including the ones that you want
    to filter out.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can use the `*~` operator to accomplish the same thing. Here’s how that
    looks:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'As you see, the output is identical to that of the `ls -d ^.sh` output. To
    exclude multiple types of files, just use the *or* operator (`|`), like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: So in this case, I filtered out the `.sh`, `.jpg`, `.txt`, and `.c` files. Now,
    let’s look at our next trick.
  prefs: []
  type: TYPE_NORMAL
- en: Grouping ls Searches
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Something else that you can’t do in `bash` is to group your `ls` searches,
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: Here, I’m using the `|` symbol as an *or* operator, to view all files with either
    `ex` or `test` as the first portion of their filenames.
  prefs: []
  type: TYPE_NORMAL
- en: Using Globbing Flags
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'As you know, Linux and Unix operating systems are normally case-sensitive.
    So, if you were to use the `ls *.jpg` command to view all JPEG-type graphics files,
    you would completely miss any files that might have the `*.JPG` extension. With
    `zsh`, you can use **globbing flags** to make your commands case-insensitive.
    Here’s an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: The `(#i)` in the second `ls` command is the globbing flag. The `#` indicates
    that it’s a flag, and it will precede the pattern that you want to match.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `(#l)` flag will match either a lower-case or upper-case pattern if you
    specify a lower-case pattern for your search. If you specify an upper-case pattern,
    then it will only match the upper-case pattern. Here’s how that looks:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: You see here that when I specified `*.jpg` as the pattern, it also found the
    `.JPG` file. But, when I specified `.JPG` as the pattern, it only found the `.JPG`
    file.
  prefs: []
  type: TYPE_NORMAL
- en: Now, let’s expand some directories.
  prefs: []
  type: TYPE_NORMAL
- en: Expanding Directories
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'You can use **globbing qualifiers** to view different types of directories
    or files. We’ll start with the qualifiers for directories, which are:'
  prefs: []
  type: TYPE_NORMAL
- en: '`*(F)`: This expands non-empty directories.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`*(^F)`: This expands both plain files and empty directories.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`*(/^F)`: This only expands empty directories.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: First, let’s look at the non-empty directories that are in my home directory.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: You see here that this command shows the non-empty directories and their contents.
    But, it doesn’t show any files that are in my top-level home directory. So, it’s
    all good.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, I want to see all of the files that are in my top-level home directory,
    along with any empty directories that might also be there. I’ll do that like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: The two empty directories show up at the bottom of the output.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, I only want to see the empty directories, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: Pretty cool, eh?
  prefs: []
  type: TYPE_NORMAL
- en: Next, let’s look at file expansion.
  prefs: []
  type: TYPE_NORMAL
- en: Expanding Files
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: There are several ways to expand files. First, we’ll expand by either the file
    or directory file types.
  prefs: []
  type: TYPE_NORMAL
- en: Expanding Files and Directories
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'If you want to see the files in your directory, but don’t want to see any directories,
    do this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'If you only want to see your directories, both empty and non-empty, do this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: Okay, I think you see what’s going on with this. Let’s move on to look at file
    permissions.
  prefs: []
  type: TYPE_NORMAL
- en: Expanding by File Permissions
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: In *Chapter 20, Shell Script Security*, I explained about how file and directory
    permissions work. Let’s do a quick review.
  prefs: []
  type: TYPE_NORMAL
- en: 'The permissions settings are divided between the *user*—which is what we call
    the owner of the file or directory—the *group*, and *others*. Each of these can
    have any combination of read, write, and executable permissions set for any given
    file or directory. If you need to search for files or directories with certain
    permissions settings, you can use the `find` utility. On `zsh`, you can use **globbing
    qualifiers** instead of `find`. Here’s the list of the qualifiers that you’ll
    work with:'
  prefs: []
  type: TYPE_NORMAL
- en: 'For the user:'
  prefs: []
  type: TYPE_NORMAL
- en: '`r:`The user has the read permission.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`w`: This denotes files for which the user has the write permission.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`x`: The user has the executable permission.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`U`: This looks for files or directories that belong to the current user.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`s`: This looks for files with the SUID permission set.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'For the group:'
  prefs: []
  type: TYPE_NORMAL
- en: '`A`: The group has the read permission.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`I`: The group has the write permission.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`E`: The group has the executable permission.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`G`: This looks for files or directories that belong to the current user’s
    group.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`S`: This looks for files or directories that have the SGID permission set.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'For others:'
  prefs: []
  type: TYPE_NORMAL
- en: '`R`: Others have the read permission.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`W`: Others have the write permission.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`X`: Others have the executable permission.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`t`: This looks for directories that have the sticky bit set.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'So, how does all this work? Well, let’s say that you’re in the `/bin/` directory,
    and you want to see all of the files that have the SUID permission set. Just do
    something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'If you’re in your own home directory and want to see all of the SUID files
    that are on the entire filesystem, just make your search recursive, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'Unlike `find`, `ls` isn’t inherently recursive. So, if want to search through
    all of the lower-level subdirectories of the directory you’re already in, just
    do this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: The only difference between this and the full filesystem search is that I used
    `**/*(s)` instead of `/**/*(s)`. (Of course, there are no SUID files in my home
    directory, which is to be expected.)
  prefs: []
  type: TYPE_NORMAL
- en: 'If you need to actually do something with this `ls` output, you can create
    a `zsh` script, like this `find_suid.sh` script:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'It’s just a simple little script that creates a text file with a list of the
    SUID files on your system. But hey, who says we can’t fancy it up a bit? Let’s
    see what we can do in the `find_suid2.sh` script:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: With this script, you’ll specify the name of the file where you want the results
    to be saved. If there’s already a file with that filename, the script will give
    you a warning message and then exit.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can use any of the other globbing qualifiers in the same manner. For example,
    let’s say that you need to search through the entire filesystem for files that
    belong to you. Let’s see how that works:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'This will make for a very long list, so I have to pipe this into `less` to
    prevent the output from scrolling off the top of the screen. Here’s some of what
    you’ll see:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: As you see, a typical Linux system has files that belong to you all over the
    place.
  prefs: []
  type: TYPE_NORMAL
- en: This is one clear advantage that `zsh` has over every other shell, including
    `bash`. The extended file globbing capabilities of `zsh` can replace much of the
    functionality of `find`, but with much simpler syntax. (Of course, you can also
    use this trick with other utilities besides `ls`, such as `cp`, `mv`, `rm`, `chmod`,
    or `chown`.)
  prefs: []
  type: TYPE_NORMAL
- en: You can also use `zsh` file globbing to replace utilities such as `grep`, `awk`
    and `tr`. Honestly though, the syntax for globbing commands that replace those
    utilities is so convoluted that you’re better off using the utilities. On the
    other hand, using `zsh` file globbing instead could make your scripts somewhat
    lighter and faster. And, you can use file globbing in those rare cases where you
    might find that the utilities aren’t installed.
  prefs: []
  type: TYPE_NORMAL
- en: 'At any rate, if you want to read about the additional file globbing capabilities
    of `zsh`, here’s the link:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Zsh Native Scripting Handbook:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://github.zshell.dev/docs/zsh/Zsh-Native-Scripting-Handbook.html](https://github.zshell.dev/docs/zsh/Zsh-Native-Scripting-Handbook.html)'
  prefs: []
  type: TYPE_NORMAL
- en: You can also find out more about both file globbing and variable expansion by
    reading the `zshexpn` man page.
  prefs: []
  type: TYPE_NORMAL
- en: All right, let’s talk briefly about arrays.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding zsh Arrays
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'This will be quick, because there are only three things that I want to point
    out about `zsh` arrays. The first thing is that instead of having array index
    numbers begin with 0, as is the case with `bash` arrays, the index numbers for
    `zsh` arrays begin with 1\. Here’s how it looks on `bash`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'You see how using an index number of 0 brings up the first name in the list,
    and an index number of 1 brings up the second name. Now, here’s how it looks on
    `zsh`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: This time, the index number of 0 brings up nothing, because index 0 doesn’t
    exist.
  prefs: []
  type: TYPE_NORMAL
- en: 'The second big difference is in how you can view the entire contents of an
    array. With `bash`, you need to do something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'You can still do this on `zsh` if you like, but you don’t have to. Instead,
    you can just view the contents of the array the same as you’d view the value of
    a normal variable, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, I want to show you how to eliminate duplicate entries that might be
    in a array. To demonstrate, let’s create an array with a list of fruits, like
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'As you see, there are several duplicates in the list. To get rid of the duplicates,
    just do this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: Replacing the `(u)` with `(U)` prints out the entire list in upper-case letters.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: Combine the `u` with the `U`, and you’ll eliminate duplicates and print out
    the list in upper-case letters.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'To show this in practice, let’s look at the `fruit_array.sh` script:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'In the first stanza, I’m using a `for` loop to print out each individual fruit
    that’s in the `fruits` array. In the second stanza, I wanted to print out each
    individual fruit, without the duplicates. Using `echo` would have printed all
    of the fruits out on a single line, as I showed you in the command-line example
    above. So instead of `echo`, I used `printf`. Here, the `%s` parameter tells `printf`
    to print the designated text strings, which in this case is each member of the
    array. The `\n` option inserts a newline after each fruit. Running the script
    looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: There are actually a lot more things that you can do with arrays than I can
    show you here. To read about them, take a look at the `zshexpn` man page.
  prefs: []
  type: TYPE_NORMAL
- en: That does it for arrays. So now, let’s talk about math.
  prefs: []
  type: TYPE_NORMAL
- en: Enhanced Math Capabilities
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In *Chapter 11—Performing Mathematical Operations*, I explained that `bash`
    has only limited builtin math capabilities, and that it can only work with integers.
    For anything beyond that, you’ll need to use an external program, such as `bc`,
    in your `bash` scripts. On the other hand, `zsh` has expanded math capabilities
    built right in.
  prefs: []
  type: TYPE_NORMAL
- en: 'For our first example, let’s try to divide 5 by 2 from the `zsh` command-line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: Well, that wasn’t what I wanted. I should see a final answer of 2.5, instead
    of 2\. What’s going on? The answer is that to perform floating point math, you
    have to explicitly express one of the numbers as a floating point number. So,
    let’s fix that.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'Much better. By expressing the first number as 5.0 instead of 5, the floating
    point math works. Unfortunately though, the `zsh` math isn’t quite perfect. I
    mean, it worked fine for this division example, but watch what happens when I
    try any other operation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'For some reason that I don’t understand, `zsh` adds extra trailing digits after
    the decimal point. It wouldn’t matter much if they were all zeros, but you also
    have the spurious 2 and 9 at the end, which throws off our calculations. Fortunately,
    we can easily correct that by just assigning the results to a variable, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: The trailing zeros are still there, but at least the spurious 2 and 9 digits
    aren’t.
  prefs: []
  type: TYPE_NORMAL
- en: Even after some rather extensive research, I was never able to find any command
    or option switch that I can use to specify the number of digits to show past the
    decimal point.
  prefs: []
  type: TYPE_NORMAL
- en: 'Grouping math operations, in order to specify their precedence, looks like
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: If just simple math isn’t enough for you, you can load the `mathfunc` module,
    which I’ll show you in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Using zsh Modules
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A lot of `zsh` functionality is contained in loadable `zsh` modules. I can’t
    cover all of the `zsh` modules in this chapter, so let’s just look at some of
    the more useful ones.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, let’s see which modules get loaded into a `zsh` session by default:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: There are a lot more optional modules that you can load yourself by using the
    `zmodload` command, as we’ll see next.
  prefs: []
  type: TYPE_NORMAL
- en: To read about all of the available `zsh` modules, see the `zshmodules` man page.
  prefs: []
  type: TYPE_NORMAL
- en: Now, let’s get a bit more specific by looking at the `mathfunc` module.
  prefs: []
  type: TYPE_NORMAL
- en: Using the mathfunc Module
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'If you want to create some really fancy math scripts without having to use
    an external utility such as `bc`, just load the `mathfunc` module, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'This module provides functions for trigonometry, logarithms, exponentiation,
    as well as some other math functions. You can see all the functions that the modules
    provide, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: 'So now, let’s say that you want to see the square root of 9\. Do it like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let’s put this into the `squareroot.sh` script:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: Note here that I’ve had to place a `zmodload zsh/mathfunc` command at the beginning
    of this script. That’s because every time you close your terminal or log out of
    your machine, any modules that you’ve loaded from the command-line will automatically
    unload. So, you’ll have to add this `zmodload` command to your scripts.
  prefs: []
  type: TYPE_NORMAL
- en: Here, I’m using the `your_number` variable to contain the value of the number
    that the user specifies for the `$1` parameter. Let’s see if it works.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: Oh yeah, it works just fine, and all without messing with any external programs,
    such as `bc`.
  prefs: []
  type: TYPE_NORMAL
- en: All of the other `mathfunc` functions work in a similar manner. Use your own
    imagination and the scripting concepts that I’ve shown you for `bash` to come
    up with your own `zsh` math scripts.
  prefs: []
  type: TYPE_NORMAL
- en: That does it for your introduction of the `mathfunc` module. Next, let’s briefly
    look at the `datetime` module.
  prefs: []
  type: TYPE_NORMAL
- en: The datetime Module
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `datetime` module does pretty much the same job as the `date` utility.
    You can use either one to do cool things, like creating files with timestamps
    in their filenames. It’s not loaded by default, so let’s do that now:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let’s see what it provides:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: 'Here’s the breakdown of what you’re looking at:'
  prefs: []
  type: TYPE_NORMAL
- en: '`strftime`: This is the only function that this module contains. You can use
    it the same as you’d use the `date` utility.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`EPOCHSECONDS`: This environmental variable is an integer value that represents
    the number of seconds that have elapsed since the beginning of the Unix epoch.
    This variable is also available in `bash`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`EPOCHREALTIME`: This environmental variable is a floating point value that
    represents the number of seconds that have elapsed since the beginning of the
    Unix epoch. Depending upon the particular system, this value can be to either
    nanosecond or microsecond accuracy. This variable is also available in `bash`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`epochtime`: This variable contains two components. It’s like the `EPOCHREALTIME`
    variable, except that the decimal point is replaced by a blank space. This variable
    is not available in `bash`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Unix epoch began on 1 January, 1970\. In the early days of Unix, Unix developers
    decided that the easiest way to set the time on a Unix computer would be to express
    it as the number of seconds that have elapsed since that date.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can see the current values of the three variables like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let’s create the `zsh_time.sh` script that uses the `strftime` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: 'The `strftime` function uses the same date and time formatting options as the
    `date` utility uses. In this case we have:'
  prefs: []
  type: TYPE_NORMAL
- en: '`%A`: This is the day of the week.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`%F`: This is the date in YYYY-MM-DD format.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`%T`: This is the time in HH:MM:SS format.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The only real difference between using `date` and `strftime` is that with `date`,
    you have to precede the string of formatting options with a `+`, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: The `strftime` function has its own man page, which you can view by doing `man
    strftime`.
  prefs: []
  type: TYPE_NORMAL
- en: 'After I run the script, I should have my file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: I’ve covered what I believe are the most useful modules. If you want to read
    about the rest of the `zsh` modules, take a look at the `zshmodules` man page.
  prefs: []
  type: TYPE_NORMAL
- en: I think that this will just about do it for our introduction to `zsh` scripting.
    Let’s wrap up and move on.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, I introduced you to the concept of scripting in `zsh` instead
    of in `bash`. I began by showing you how to install `zsh`, if it isn’t installed
    already. I showed you some of the differences between `bash` and `zsh` features
    that could impact how you’d write a `zsh` script. These include differences in
    file globbing, variable expansion, array indexing, and math operations. Along
    the way, I showed you how these `zsh` features can help you build scripts that
    are simpler, yet more functional, than `bash` scripts.
  prefs: []
  type: TYPE_NORMAL
- en: The main problem with `zsh` scripting, other than the fact that `bash` is much
    more prevalent, is the lack of documentation. There are plenty of tutorials and
    articles about setting up a `zsh` user environment, but very little about `zsh`
    scripting. Hopefully, you’ll be able to use the knowledge that I’ve provided here
    to write some cool `zsh` scripts.
  prefs: []
  type: TYPE_NORMAL
- en: In the next and final chapter, I’ll introduce you to the idea of using PowerShell
    on Linux. (Yes, you read that correctly.) I’ll see you there.
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Which command would you use to view all of the `zsh` modules that have been
    loaded into your `zsh` session?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`zmodls`'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '`zmod -l`'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '`zmodload -l`'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '`zmodload`'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: You want to load the math function module. Which of these commands would you
    use?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`zmod mathfunc`'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '`zmod zsh/mathfunc`'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '`zmodload -l mathfunc`'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '`zmodload -l zsh/mathfunc`'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '`zmodload zsh/mathfunc`'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: What is a major difference between the way that `bash` and `zsh` handle arrays?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: There is no difference.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '`bash` array indexing begins at 1, `zsh` array indexing begins at 0.'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '`bash` array indexing begins at 0, `zsh` array indexing begins at 1.'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '`bash` can work with arrays, but `zsh` can’t.'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Which `zsh` command would you use to view all of the `.png` files and all of
    the `.PNG` files that are in your directory?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`ls *.png`'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '`ls (#i).png`'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '`ls (#l).PNG`'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '`ls *.PNG`'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: You only want to view the empty directories that are in your current working
    directory. Which of these `zsh` commands would you use?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`ls -l *(/^F)`'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '`ls -l *(^F)`'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '`ls -l *(F)`'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '`ls -ld`'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Further Reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The Z Shell Manual: [https://zsh-manual.netlify.app/](https://zsh-manual.netlify.app/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'What is ZSH, and Why Should You Use It Instead of Bash?: [https://www.howtogeek.com/362409/what-is-zsh-and-why-should-you-use-it-instead-of-bash/](https://www.howtogeek.com/362409/what-is-zsh-and-why-should-you-use-it-instead-of-bash/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'ZSH for Starters: Exploring Linux’s Elegant Shell: [https://www.fosslinux.com/133167/zsh-for-beginners-exploring-linuxs-elegant-shell.htm](https://www.fosslinux.com/133167/zsh-for-beginners-exploring-linuxs-elegant-shell.htm)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'How to Write Script for ZSH: [https://www.linuxtoday.com/blog/writing-scripts-for-zsh/](https://www.linuxtoday.com/blog/writing-scripts-for-zsh/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Answers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: d
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: e
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: c
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: b
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: a
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Join our community on Discord!
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Read this book alongside other users, Linux experts, and the author himself.
  prefs: []
  type: TYPE_NORMAL
- en: Ask questions, provide solutions to other readers, chat with the author via
    Ask Me Anything sessions, and much more. Scan the QR code or visit the link to
    join the community.
  prefs: []
  type: TYPE_NORMAL
- en: '[https://packt.link/SecNet](https://packt.link/SecNet)'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/QR_Code10596186092701843.png)'
  prefs: []
  type: TYPE_IMG
