- en: '9'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Don’t Repeat Yourself – Functions and Scriptblocks
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we’re going to look at one of the basic principles of software
    development and learn how to apply it to save ourselves effort and make our code
    easier to maintain: **Don’t Repeat Yourself**, also known as the **DRY** principle.
    In *The Pragmatic Programmer*, by Andy Hunt and Dave Thomas, the principle is
    stated as “*Every piece of knowledge must have a single, unambiguous, authoritative
    representation within a system.*” Some programmers will take this principle to
    its logical conclusion and have no repeating code anywhere. We’re writing scripts,
    and so we will apply the principle just as much as is convenient. We will talk
    about the concept of functions within code. By the end of the chapter, we will
    have seen how to write functions in our scripts to replace repeating code and
    learned how doing this makes our scripts easier to adapt and repair. We will also
    learn about another type of expression that is related to functions: **scriptblocks**.
    Along the way, we will also inevitably have to discuss the concept of **scope**.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we are going to cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Why do we care about repeating code?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to turn repeating code into a function
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The concept of scope
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Exploring scriptblocks
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let’s do something useful
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Why do we care about repeating code?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The obvious reason is that it is boring to figure out how to do something in
    PowerShell and then keep repeating the same lines over and over. For example,
    back in [*Chapter 4*](B17600_04.xhtml#_idTextAnchor071), *PowerShell Variables
    and Data Structures*, we discussed objects by referring to `TypeName Imaginary.Bike`.
    The `Imaginary.Bike` object had three properties: `handlebar`, `wheel`, and `color`.
    Let’s say we want to write a short script that validates that an imaginary bike
    has all its properties. It might look something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'In the first line, I’m just defining my imaginary bike. The validation script
    starts after that. I’ve thrown in a non-existent property, `gears`, just to make
    sure that the code works. We can see that the script has a lot of `if` statements
    that do almost exactly the same thing as each other: they check whether an attribute
    is present and output a message if it is missing. We’re not too bothered about
    the repetition because we’re only checking four properties. But what if we needed
    to check 40 or 400? This is where the DRY principle comes in. We could write a
    script to do the same thing like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Each property we add from now on just needs a single word added to the `$properties`
    array, rather than three new lines of code. Great, huh?
  prefs: []
  type: TYPE_NORMAL
- en: We’re not just saving ourselves the effort of typing stuff out twice here, though.
    We’re also saving ourselves the effort of finding our typing mistakes in possibly
    hundreds of lines of code. If that `foreach` loop works for one property, it will
    work for all of them, unless we mistyped the property name when we added it to
    the `$properties` array. We know exactly where to look if something isn’t working,
    and so does anyone who needs to troubleshoot our script after us.
  prefs: []
  type: TYPE_NORMAL
- en: 'The DRY principle doesn’t just refer to excessive code duplication; it can
    be applied far more widely in software. To quote *The Pragmatic Programmer* again,
    “*Many people took it [DRY] to refer to code only: they thought that DRY means
    “don’t copy-and-paste lines of source.” […] DRY is about the duplication of knowledge,
    of intent. It’s about expressing the same thing in two different places, possibly
    in two totally* *different ways.*”'
  prefs: []
  type: TYPE_NORMAL
- en: Imagine if we had written not just one script but a whole bunch of scripts that
    worked with imaginary bikes. Perhaps we run an imaginary bike shop and want a
    stock control application. We might find we need to refer to imaginary bike properties
    frequently in those scripts. It may be that we would end up with lists of properties
    in lots of places. It’s not hard to imagine that those lists might differ. Some
    might be incomplete. Some might be out of date. If we were to apply DRY to this,
    then there would be just one list of properties for all the scripts, a single
    source of truth when it comes to the properties that an imaginary bike might have,
    and whenever a script needed to refer to the list of properties, this is where
    they would find them.
  prefs: []
  type: TYPE_NORMAL
- en: 'To summarize, then, we care about repeating code for three reasons:'
  prefs: []
  type: TYPE_NORMAL
- en: We don’t want to write more code than is necessary.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We want it to be easier to find mistakes.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We want a single source of truth for our code.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Do we want to reduce code duplication all the time, in every case? Probably
    not. Going back to the section on automation in [*Chapter 8*](B17600_08.xhtml#_idTextAnchor162),
    *Writing Our First Script – Turning Simple Cmdlets into Reusable Code*, sometimes
    the effort required to reduce duplication to the minimum just isn’t worth it.
    Perhaps we’re only going to use a piece of code twice; in this case, copying and
    pasting it is perfectly fine, rather than working out how to do it just once.
    There are also two other software development principles worth knowing about:
    `if` statement, is preferable to writing the script in the second example with
    an abstraction that isn’t going to be used (*You Aren’t Gonna Need It*). We should
    do the simplest thing that could possibly work. One of the main takeaways from
    this is that software developers love an acronym.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we know why we should reduce code duplication, let’s look at one of the
    main ways to do it in PowerShell: by using functions.'
  prefs: []
  type: TYPE_NORMAL
- en: How to turn repeating code into a function
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A function is a **named** section of code, a piece of code within a script or
    program that is given a label, and may be used by referring to the label. This
    is a very common programming paradigm and appears in most imperative programming
    languages. Some languages, such as PowerShell and Python, call these pieces of
    code functions. Some call them subroutines, subprograms, methods, or procedures.
    The paradigm is called procedural programming and lies between the scripting that
    most people practice with PowerShell and full object-oriented programming in languages
    such as C++ and Java. Functional programming is a different paradigm, with a declarative
    style.
  prefs: []
  type: TYPE_NORMAL
- en: Imperative, Declarative, Procedural, and Functional
  prefs: []
  type: TYPE_NORMAL
- en: I’m throwing around a lot of new words here, so it’s worth quickly explaining
    what they mean.
  prefs: []
  type: TYPE_NORMAL
- en: '**Imperative** languages are *recipe* languages such as Python and PowerShell.
    Each step in the script or program tells the computer to do something, and often,
    how to do that thing. This is usually the first style of programming that people
    learn; often, it is the only style they learn.'
  prefs: []
  type: TYPE_NORMAL
- en: '`<Heading>`, but it is up to the browser that is interpreting the HTML to decide
    what a `<Heading>` looks like.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Procedural** programming is the style of programming we’re going to be examining
    in this chapter: writing procedures, which are called functions in PowerShell,
    and calling them from within our script. The overall programming style is still
    imperative.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Functional** programming is a declarative style of programming, where we
    create functions on objects and then call the functions. Pure functional programming
    is often described as declarative programming. Functional programming in PowerShell
    is not impossible, but it is pretty advanced, so we’re not going to cover it in
    this book. If you are really interested in having a look at it, then visit Chris
    Kuech’s GitHub page at [https://github.com/chriskuech/functional](https://github.com/chriskuech/functional)
    and have a play with his **functional** module for PowerShell.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s have a look at a function. In the PowerShell console, try this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, type `get-square`, followed by a number, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: As if by magic, the square of our number is returned. While the console is open,
    we can use `get-square` as often as we like.
  prefs: []
  type: TYPE_NORMAL
- en: What have we done there? Well, we’ve taken some code, `{$a * $a}`, and given
    it a label (or name), `get-square`, by using the `function` keyword. We’ve also
    told it to expect a variable, `$a`, by placing the variable in brackets directly
    after the name. Whenever we use the name of the function, the code runs on the
    object we’re passing – in this case, the integer `23`.
  prefs: []
  type: TYPE_NORMAL
- en: 'It’s pretty rare we would define and use a function in the console like that.
    Instead, I usually incorporate functions into my scripts. Let’s do that now. Open
    a new PowerShell file in VS Code so we can carry on playing. Let’s do something
    a little more adventurous. Let’s create a function that gets the square root of
    a number by approximation. Type this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'All this code does is start at `1`, and keep multiplying numbers by themselves
    until it gets to a number that is larger than the number we originally pass to
    the function – in this case, `785692`. It’s pretty rough and ready. If we run
    this code, we find that the approximate square root of 785,692 is 886, pretty
    close to the actual square root of 886.392 but not exact. It demonstrates one
    of the strengths of machines: fast repetition. It’s gone through that `while`
    loop 887 times.'
  prefs: []
  type: TYPE_NORMAL
- en: Notice the `param()` block that we’ve opened on the second line. It’s the same
    as the `param()` blocks we’ve been using already. In fact, we can turn this function
    into an `cmdletbinding()` attribute, and then we could use all the common parameters
    with `Get-RoughRoot`. We can do all the same things with the `param()` block in
    a function as we can do with the `param()` block in a script.
  prefs: []
  type: TYPE_NORMAL
- en: Activity 1
  prefs: []
  type: TYPE_NORMAL
- en: If we type `65378 | Get-RoughRoot` at the end of our script and run it, what’s
    going to happen? Why is that, and how could we make that line work?
  prefs: []
  type: TYPE_NORMAL
- en: Once we’ve created our function within a script, we can call it as many times
    as we like, just by referring to the name of the function and providing values
    for the parameters. Yes, there is a really easy way to get an accurate square
    root with PowerShell, and it’s much shorter, but where’s the fun in that?
  prefs: []
  type: TYPE_NORMAL
- en: What makes a function?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To create functions, we need the following:'
  prefs: []
  type: TYPE_NORMAL
- en: The keyword, `function`, at the start.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A descriptive and meaningful name. It’s best to follow the PowerShell naming
    conventions and use an approved verb in a verb-noun pair, especially if the function
    is going to be shared with others.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A set of PowerShell cmdlets in braces, `{}`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We can include a set of parameters, either within a `param()` block after we’ve
    opened the braces, or we can include them in brackets appended to the name. It’s
    preferable to use the `param()` block, especially if we’ve got multiple parameters
    or if we want to add statements to the parameters – for instance, to control how
    they accept pipeline input, or what types they accept.
  prefs: []
  type: TYPE_NORMAL
- en: When we’re including functions in scripts, it is important to remember that
    the script is read by the computer from top to bottom, rather than ingested whole
    before executing. It is important, therefore, that we have defined our functions
    before we call them in the script. It’s usual to define all the functions in a
    script at the top, after the parameters.
  prefs: []
  type: TYPE_NORMAL
- en: 'Each function consists of four statement blocks: `begin`, `process`, `end`,
    and `clean`. We don’t need to include these statements for our function to work,
    but we need to be aware of how PowerShell will read our code if we don’t include
    them.'
  prefs: []
  type: TYPE_NORMAL
- en: The `begin` statement block is for statements that set up the function and will
    only run once when the function is called before the function does anything with
    its input. Similarly, the `end` block will only run once when the function is
    called. The `process` block will run for each object in the pipeline that is fed
    to the function, which is why we need to include it when accepting multiple objects
    from the pipeline, because if no statement blocks are specified, then PowerShell
    assigns all statements to the `end` block.
  prefs: []
  type: TYPE_NORMAL
- en: The `clean` statement block was introduced in PowerShell 7.3\. It is similar
    to the `end` statement block, but it will always run, even if the function terminates
    due to an error or if the function is deliberately halted by pressing *Ctrl* +
    *C*, whereas the `end` block will not. The other difference is that the `end`
    block can output objects to the pipeline, and `clean` cannot.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s see how this looks in actual code. In the following figure, we’ve added
    `begin`, `end`, `process`, and `clean` statement blocks to our `Get-RoughRoot`
    function:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.1 – Begin, process, end, and clean statement blocks](img/B17600_09_001.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.1 – Begin, process, end, and clean statement blocks
  prefs: []
  type: TYPE_NORMAL
- en: The `begin` statement on line `12` contains a `Write-Output` cmdlet to display
    the value that is currently held in the `-number` parameter. We can see from the
    output at the bottom that there is no value held in this parameter when the `begin`
    block runs. The `process` block on line `15` then runs and feeds the current value
    of `-number` to the pipeline, and repeats for as many values of `-number` as there
    are in the pipeline. The `end` block on line `24` then runs once, and can only
    see the final value passed by the `-number` parameter. Finally, the `clean` block
    executes on line `28`. We can see that it produces no output at all, although
    it does complete successfully. If you don’t believe me, try it – write a line
    of code that can’t run, such as `write-rubbish "here is some rubbish"`. There
    will be a whole load of red text as PowerShell fails to execute it.
  prefs: []
  type: TYPE_NORMAL
- en: 'There is also an important keyword to be aware of: `return`. The `return` keyword
    ends the current iteration of the block that is running. Let’s see what happens
    when we use it. Here is the code for the `Get-RoughRoot` function, with an `if`
    statement in the `process` block that returns the `pop` string if the original
    number is less than 10:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Let’s now pass a number less than 10 in our pipeline, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'We will get the output in the following figure:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.2 – Using the return keyword](img/B17600_09_002.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.2 – Using the return keyword
  prefs: []
  type: TYPE_NORMAL
- en: We can see that the rough roots of the two large numbers are returned, but the
    process block has terminated early when fed a number less than 10.
  prefs: []
  type: TYPE_NORMAL
- en: The `return` keyword has returned the value it has been assigned (`pop`), but
    that is purely optional – we don’t need to assign a value to `return`. It’s worth
    noting that this is slightly confusing for those of us who are familiar with other
    languages. For example, in Python, the `return` statement is used to supply the
    result of the function. In both Python and PowerShell, `return` statements work
    in very similar ways but the intention behind them is different; PowerShell will
    return the output of the function without the `return` keyword, whereas Python
    will not. For both Python and PowerShell, `return` will stop the function at the
    point it is used.
  prefs: []
  type: TYPE_NORMAL
- en: Basic and advanced functions
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Most of the functions I write within scripts are basic functions, but we can
    make a function behave like a cmdlet by using the `CmdletBinding` attribute. This
    gives us access to a range of behaviors that we see in cmdlets, such as the `-whatif`
    and `-confirm` parameters. It also gives us access to advanced methods such as
    `WriteCommandDetail` and `WriteError`.
  prefs: []
  type: TYPE_NORMAL
- en: Function parameters
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As we’ve mentioned, parameters for functions work the same way as parameters
    in scripts, but it’s worth recapping them here.
  prefs: []
  type: TYPE_NORMAL
- en: Types of parameters
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'There are four types of parameters we can use with functions (and scripts!):'
  prefs: []
  type: TYPE_NORMAL
- en: Named parameters
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Switch parameters
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Positional parameters
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Dynamic parameters.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let’s take a closer look.
  prefs: []
  type: TYPE_NORMAL
- en: Named parameters
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Named parameters are the parameters we’ve been working with, where we supply
    a variable that is used as the parameter’s name, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'The name of that parameter, whether it is in a function or a script, is `-number`.
    We can use the `$number` variable anywhere within our function, and it will have
    the value supplied in the parameter. As we saw in [*Chapter 8*](B17600_08.xhtml#_idTextAnchor162),
    *Writing Our First Script – Turning Simple Cmdlets into Reusable Code*, we can
    set a default value for a parameter like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'We can also specify the type of the parameter by supplying a type value in
    square brackets before the variable: `[int]$number`.'
  prefs: []
  type: TYPE_NORMAL
- en: Switch parameters
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Switch parameters don’t require a value, they are simply on or off. If we supply
    the parameter to the function, then they are on; if they’re not supplied, then
    they are off. We specify the type of the parameter as `[switch]`, like this: `[switch]$heads`.
    We can test for the presence of the switch in our function with an `if` statement,
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: We don’t need the `.ispresent` property, we could just type `if ($heads)`, but
    I think that’s less clear. We could also use the `if ($heads -eq $true)` construction,
    which we may see in older articles on the web, but that is not Microsoft’s preferred
    method.
  prefs: []
  type: TYPE_NORMAL
- en: Positional parameters
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'These parameters make use of the `$Args` automatic variable instead of using
    a `param()` block. This parameter exists for every basic function and allows us
    to create unnamed parameters, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'This means we can supply parameters like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'We can see the result in the following figure:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.3 – Using positional parameters](img/B17600_09_003.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.3 – Using positional parameters
  prefs: []
  type: TYPE_NORMAL
- en: We can see the function has correctly assigned the values we supplied. The `$Args`
    parameter is an array.
  prefs: []
  type: TYPE_NORMAL
- en: 'Note that if we use a `param()` block, then that will override this functionality;
    it won’t work, as we will need to specify positional parameters. By default, parameters
    are positional, in the order that the parameters are written down, so this will
    work:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: The value `2` will be assigned to `$a`, and the value `4` will be assigned to
    `$b`. If it is important that a parameter be at a specific position, however,
    we should use the `position` attribute, discussed in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `$Args` automatic variable can also be used to splat parameters into a
    function – review [*Chapter 4*](B17600_04.xhtml#_idTextAnchor071), *PowerShell
    Variables and Data Structures*, for more about splatting. Let’s see how that works
    in the following figure:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.4 – Splatting the $Args variable](img/B17600_09_004.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.4 – Splatting the $Args variable
  prefs: []
  type: TYPE_NORMAL
- en: 'In the first line, we are creating a simple function called `Get-Fifteen20`.
    It runs `Get-Random`. We tell it to accept arguments from the command line into
    an array called `@Args` (note the array symbol, `@`). After that, we tell it to
    output the value of the `$Args` automatic variable. From the output, we can see
    we first get a random number between 15 and 20 (`19`), then we get the contents
    of the `$Args` variable. We can see it is an array of four objects: `-minimum`,
    `15`, `-maximum`, and `20`. These are supplied in sequence to the `Get-Random`
    cmdlet in the function, giving us an effective PowerShell statement of `Get-Random
    -minimum 15 -maximum 20`, which works just fine.'
  prefs: []
  type: TYPE_NORMAL
- en: Activity 2
  prefs: []
  type: TYPE_NORMAL
- en: Why doesn’t `Get-Fifteen20 15` `20` work?
  prefs: []
  type: TYPE_NORMAL
- en: Dynamic parameters
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Dynamic parameters are only available if a specified condition is true. They
    are not defined in the `param()` block, but in a separate `DynamicParam{}` block
    – note this uses braces, not brackets. Dynamic parameters are quite an advanced
    topic and should only be used if absolutely necessary, so we’re not going to spend
    much time on them here. A good example of how they work can be found in the `Get-ChildItem`
    cmdlet. `Get-ChildItem` can be used with any PSProvider – we covered PSProviders
    in [*Chapter 6*](B17600_06.xhtml#_idTextAnchor117), *PowerShell and Files – Reading,
    Writing, and Manipulating Data*. Depending on which PSProvider we are using, different
    parameters of `Get-ChildItem` are available. For instance, if we are in the `FileSystem`
    provider, we have access to parameters such as `-File` and `-Hidden`. If we are
    using the `Certificate` provider, then we can’t use those parameters but we have
    parameters such as `-DnsName` and `-``SslServerAuthentication` instead.
  prefs: []
  type: TYPE_NORMAL
- en: Now we’ve covered the types of parameters, let’s take a look at some of the
    attributes we can apply to our parameters.
  prefs: []
  type: TYPE_NORMAL
- en: Parameter attributes
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Attributes are optional arguments that we can use to control how parameters
    behave – whether they are mandatory or accept pipeline input, for example. To
    use attributes, we must start each parameter with the `Parameter()` attribute,
    which looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: The `Parameter()` attribute takes multiple arguments, but we must separate them
    with a comma (`,`). Let’s go through the more common parameters.
  prefs: []
  type: TYPE_NORMAL
- en: CmdletBinding
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The `CmdletBinding` attribute makes the function behave like a cmdlet. If we
    use this attribute within a function, we get access to the common parameters such
    as `-whatif` and `-confirm`. This removes access to the `$Args` automatic variable
    for that function.
  prefs: []
  type: TYPE_NORMAL
- en: Mandatory
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'As we saw in [*Chapter 8*](B17600_08.xhtml#_idTextAnchor162), *Writing Our
    First Script – Turning Simple Cmdlets into Reusable Code*, we can use the `Mandatory`
    argument to ensure a value is provided for a parameter, and the `HelpMessage`
    argument to provide help for that mandatory parameter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: This means that at least one integer must be supplied with the `-number` parameter,
    and a help message can be accessed.
  prefs: []
  type: TYPE_NORMAL
- en: Position
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The `Position` argument allows a parameter to be passed without explicitly
    naming it and can specify at which position it must be supplied:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: The preceding code tells us that the first value passed without a preceding
    parameter name will be applied to the `-number` parameter. Two things to note
    are that named parameters are not counted, and that numbering starts at `0`, so
    the second position is `Position=1`. Note that if we’re using a `param()` block,
    the `$Args` functionality we’ve just covered won’t work, and we’ll not be able
    to splat parameters into a cmdlet within our function.
  prefs: []
  type: TYPE_NORMAL
- en: If we don’t use a `Position` argument, then all the parameters will be assigned
    positions in the order they are declared in the `param()` block, but we shouldn’t
    rely on this working exactly as we expect. If we want a parameter to be positional,
    then we should declare it.
  prefs: []
  type: TYPE_NORMAL
- en: ParameterSetName
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: We can use the `ParameterSetName` argument to define parameters that are only
    present for particular parameter sets. If `ParameterSetName` is not supplied,
    a parameter belongs to all parameter sets. I adhere to the philosophy that a function
    should do one thing, and so I’ve never really found the need for parameter sets.
    Some people, however, like to write Swiss Army knife functions that do lots of
    things, and so parameter sets are useful for them.
  prefs: []
  type: TYPE_NORMAL
- en: ValueFromPipeline
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: We’ve used this already in this chapter – it’s necessary to allow a function
    parameter to accept an object from the pipeline. The parameter accepts the whole
    object.
  prefs: []
  type: TYPE_NORMAL
- en: ValueFromPipelineByPropertyName
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: If we only want the parameter to accept a property of an object (for instance,
    a name), then we can use this argument. If the object in the pipeline has a name
    property, `$object.name`, then that will be used for this parameter. The object
    property must match the parameter name; otherwise, it won’t get passed. For instance,
    if we pass a string through the pipeline to a function with a `-length` parameter
    that accepts pipeline values by property name, then the parameter will be populated
    with the length of the string, not the actual string. If the parameter is called
    `-stringlength`, then it will be empty because the string doesn’t have a `stringlength`
    property.
  prefs: []
  type: TYPE_NORMAL
- en: ValueFromRemainingArguments
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: We can use this parameter to hold an indeterminate number of arguments that
    might be passed to a function, as an array. We can then access those arguments
    by using the index of their position in the array. This is useful in advanced
    functions, where we don’t have access to the `$Args` automatic variable, and we
    want to capture an unknown number of arguments.
  prefs: []
  type: TYPE_NORMAL
- en: HelpMessage
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: As we’ve seen already, this attribute can be used to provide a helpful message
    for mandatory parameters.
  prefs: []
  type: TYPE_NORMAL
- en: Alias
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: I’m including this here for the sake of completeness, but I think I’ve made
    my views on aliases quite plain. They can occasionally be useful, but they also
    lead to confusion and make code less readable. It is possible, however, to use
    the `Alias` attribute to provide an alias for a parameter.
  prefs: []
  type: TYPE_NORMAL
- en: SupportsWildcards
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: We can use this parameter if we want a parameter to accept wildcards. Note that
    this doesn’t mean the function supports wildcards – we still need to write code
    in our function that can handle wildcard input.
  prefs: []
  type: TYPE_NORMAL
- en: Argument completion attributes
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: There are two argument completion attributes that allow a user to complete the
    values of a parameter using the *Tab* key. These are similar to the `ValidateSet`
    attribute. We’re not going to cover them in this book, but it’s useful to know
    that it is something we can do if we want to.
  prefs: []
  type: TYPE_NORMAL
- en: Validation attributes
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'There are currently 14 attributes that we can use to validate parameters and
    the values supplied for them. We can validate that a value is null, that a value
    follows a specific pattern such as a credit card number or IP address, and that
    a value is of a certain length or falls in a certain range. We discovered the
    `ValidateSet` attribute in [*Chapter 8*](B17600_08.xhtml#_idTextAnchor162), *Writing
    Our First Script – Turning Simple Cmdlets into Reusable Code*. It works like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: This will only accept the string if it appears in the array listed in `ValidateSet`.
    Note that validation attributes sit outside the `Parameter()` attribute.
  prefs: []
  type: TYPE_NORMAL
- en: 'While there are plenty more aspects of parameters we could cover, that’s enough
    for now. Let’s look at a specialized type of function: filters.'
  prefs: []
  type: TYPE_NORMAL
- en: Filters
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A filter is a specialized function that automatically runs on all objects in
    the pipeline. A filter is similar to a function with just a `process{}` statement
    block. We can use them like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.5 – Using a filter](img/B17600_09_005.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.5 – Using a filter
  prefs: []
  type: TYPE_NORMAL
- en: Instead of using the `function` keyword, we’ve used `filter`. We’ve called our
    filter `square` and defined it as multiplying the pipeline object by itself. Now
    we can feed a value to the filter via the pipeline, and get an output. Notice
    that we can’t use it like a function; `square 36` won’t work as there’s nothing
    in the pipeline for the filter to work on.
  prefs: []
  type: TYPE_NORMAL
- en: 'Before we can really get on with using functions, though, we need to talk about
    an important concept: scope.'
  prefs: []
  type: TYPE_NORMAL
- en: The concept of scope
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'PowerShell uses the concept of scope to protect variables, functions, PSDrives,
    and aliases from inadvertent change by limiting how they may be accessed and modified.
    Let’s demonstrate:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a variable and set its value:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create a function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: $ScopeTest
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Run our function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: $ScopeTest
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'PowerShell has the following types of scopes:'
  prefs: []
  type: TYPE_NORMAL
- en: '`$scopeTest` variable we just used. Anything that is defined in the global
    scope is available everywhere inside the current session.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Set-ScopeTest` function, there is a different scope to the global scope. When
    we changed the `$SetScope` variable inside our function, it only changed in the
    local scope of the function, not the global scope. The local scope is relative
    to other scopes, not a predefined scope, so it may refer to the global scope,
    a script scope, or a child of the global or script scopes. We can create many
    nested local scopes. When we run a script or a function, we are creating a new
    local scope.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Script**: This is the scope that is created when we run a script. Only the
    statements in the script run in the script scope, and those statements see the
    script scope as the local scope. Each script that is running has its own script
    scope; they don’t share objects.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Parent and child scopes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'There is a hierarchy of scopes. A scope that is contained in another scope
    is called a child scope, and the containing scope is called the parent scope.
    The global scope is always the root scope, the parent of all scopes, and other
    scopes are child scopes of the global scope. So, when we ran `Set-ScopeTest` previously,
    we created a local scope for the function that is a child of the global scope.
    The local scope can read the variables of the parent scope, but by default, does
    not change them in the parent scope; it can only change them in its local scope.
    Let’s add a few lines to our `Set-ScopeTest` function to illustrate this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.6 – Illustrating parent and child scopes](img/B17600_09_006.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.6 – Illustrating parent and child scopes
  prefs: []
  type: TYPE_NORMAL
- en: The first line we’ve added gets the value of the `$ScopeTest` variable that
    the function inherits from its parent scope (in this case, `10`) and writes it
    to the screen. We then change the value of `$ScopeTest` within the function, as
    before, and output the new value. Next, we’ve got a couple of lines using `Get-Variable`
    that retrieve the value of the `$ScopeTest` variable in the global and local scopes.
    We can see that even within the function, the global value of `$ScopeTest` remains
    `10` – it is only the local instance of `$ScopeTest` that is changed by the function.
    What happens if we want to modify the value of a variable in the parent scope
    with our function, though? Let’s take a look at how we can do that.
  prefs: []
  type: TYPE_NORMAL
- en: Scope modifiers
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Scopes are used for a reason – to protect ourselves from inadvertent changes
    – and we should only step outside the automatic scopes with caution, but sometimes
    we need to do it. PowerShell includes a number of scope modifiers that allow us
    to change the default scope. They include the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Global`: This specifies objects in the global scope.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Local`: This specifies an object in the current scope.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Script`: This specifies an object in the parent script scope, or in the global
    scope if there is no parent script; we’d use this with functions embedded in scripts.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Private`: When this is used while creating variables, this prevents child
    scopes from using the object.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`<Variable-namespace>` These refer to PSDrive namespaces, such as `env:` and
    `variable:`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'There are also a couple of others that we won’t cover here: `workflow:`, which
    is deprecated, and `using:`, which is used with cmdlets such as `Invoke-Command`
    and `Start-Job`. Scripts operate by default in the `script:` scope. Functions
    operate in the `local:` scope by default, even when they are defined in a script.'
  prefs: []
  type: TYPE_NORMAL
- en: 'We use the scope modifier between the `$` symbol and the variable name, like
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: This will create a variable in the global scope called `ScopeTest` and set its
    value to `10` (remember, the variable name doesn’t have a `$` symbol – we use
    the `$` symbol to refer to the contents of the variable).
  prefs: []
  type: TYPE_NORMAL
- en: 'Similarly, we can define the scope of a function like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Note that setting the scope of the function to global doesn’t change where
    the function acts, it changes where it is available. So, a function with a global
    scope doesn’t automatically act on global variables, as we can see here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.7 – Global functions and global variables](img/B17600_09_007.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.7 – Global functions and global variables
  prefs: []
  type: TYPE_NORMAL
- en: 'We can see the original value of `$ScopeTest` is `10`. We then define a global
    function called `Set-ScopeTest` that sets the value to `15`. Calling the function
    doesn’t change the global value of `$ScopeTest`. To do that, we need to tell the
    function to work on the global variable, not the local version running inside
    the function. We do that in the second command, with the following code: `$Global:ScopeTest
    =` `15`.'
  prefs: []
  type: TYPE_NORMAL
- en: As we work through the rest of the book, we’ll see the concept of scope, and
    no doubt be occasionally frustrated by it. Remember that it is there to protect
    us and provide a set of handy guardrails to prevent us from experiencing hilarious
    consequences. We should only step outside the default scope after some thought
    and consideration. We can often avoid this through passing variables as parameters,
    or explicitly writing output from inside our function and storing it as a variable.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we understand functions, let’s look at their very close relatives: scriptblocks.'
  prefs: []
  type: TYPE_NORMAL
- en: Exploring scriptblocks
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A scriptblock is a collection of statements inside braces (`{}`) that can be
    used as a single unit. We’ve already used them numerous times: in `Where-Object`
    cmdlets, `if` and `else` statements, `foreach` loops, and earlier in this chapter,
    when we were writing functions. In this section, we are going to look at some
    of the properties of scriptblocks and how we can use them in our code.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider everything we’ve just done on functions. A function consists of the
    `function` keyword, a name, and a scriptblock: a set of statements inside braces.
    We don’t need the keyword to use the scriptblock – the keyword supplies a label
    that we use to call the scriptblock when we need it.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Scriptblocks return the output of all the statements they contain; this may
    be a single object or an array of objects. We can use the `return` keyword, and
    it works the same as it does for a function: it will exit the scriptblock at that
    point.'
  prefs: []
  type: TYPE_NORMAL
- en: We can create parameters for scriptblocks using a `param()` block, and it will
    accept all the parameter types and attributes that we use with a function. What
    we can’t do is pass parameters outside the braces, as we can with functions, because
    there is no name value to attach them to.
  prefs: []
  type: TYPE_NORMAL
- en: How to run a scriptblock
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'There are many ways to call scriptblocks – lots of cmdlets and statements such
    as `foreach` accept them. Sometimes, however, we want to just run the scriptblock.
    `Invoke-Command` is one way to do it, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: This gives us the output `100`. Let’s look at some of the other ways we might
    do it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Unlike functions, scriptblocks may be stored in variables, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we can use the `$square` variable in the following ways:'
  prefs: []
  type: TYPE_NORMAL
- en: 'We can pass it as a parameter to `Invoke-Command`, either with the `-ScriptBlock`
    parameter name or not:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Using `Get-Member`, we can see that `$square` has a `TypeName` of `System.Management.Automation.ScriptBlock`.
    This type has a method called `invoke()`, which we can use like this:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Let’s say we’ve put a parameter in our scriptblock, like this:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'What we can’t do is just call the variable to run the scriptblock:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 9.8 – How not to run a scriptblock](img/B17600_09_008.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.8 – How not to run a scriptblock
  prefs: []
  type: TYPE_NORMAL
- en: 'As you can see, if we call the variable, we get the contents of the scriptblock,
    not the output. Instead, we use the call operator (`&`) like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: We can leave a space between `&` and `$square` as well, `& $square`, and we
    will often see it written like that.
  prefs: []
  type: TYPE_NORMAL
- en: 'There is one other way: dot sourcing. Instead of the call operator, we can
    use a period (`.`) like this:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We need to be very careful when we call scriptblocks like this. Using `Invoke-Command`,
    `invoke()` and the call operator all run the scriptblock in a child scope, as
    we would expect. Dot sourcing will run it in the parent scope, as we can see in
    the following figure:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.9 – The call operator and dot sourcing](img/B17600_09_009.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.9 – The call operator and dot sourcing
  prefs: []
  type: TYPE_NORMAL
- en: 'In the first line, we’ve defined a variable, `$SbScope`, as the `Global scope!`
    string. We then define a variable, `$ChangeSbScope`, as a scriptblock that sets
    `$SbScope` to `Local scope!` and returns it. When we call `$ChangeSbScope` with
    the call operator, it runs in the local scope and leaves the global value `of
    $SbScope` unchanged: `Global scope!`. However, when we dot source `$ChangeSbScope`,
    we can see that it changes the value of `$SbScope` in the global scope. Be careful.
    Don’t dot source unless you’re absolutely sure that’s what you have to do.'
  prefs: []
  type: TYPE_NORMAL
- en: Lambdas
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Most programming languages have the concept of a **lambda** – an anonymous
    function, a function without a name. In PowerShell, we have the scriptblock, which
    is a broader concept that includes lambdas. So in Python, we might have a lambda
    statement such as the following, which adds a value to itself:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'And we get the output `40`. In PowerShell, the equivalent lambda, using a scriptblock,
    would be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: And again, we get `40`. Lambdas in Python are limited to expressions and can’t
    include statements, whereas in PowerShell, we are not so restricted.
  prefs: []
  type: TYPE_NORMAL
- en: When do we want to use scriptblocks instead of functions? Generally, we use
    scriptblocks for short, simple blocks of code that may only occur a couple of
    times in a script. I often use them in the console as well. If I’m writing a script
    that is going to be used by other people, then anything more than a line or two
    of code would go in a function to improve readability and make sure other people
    know exactly what I was trying to do.
  prefs: []
  type: TYPE_NORMAL
- en: The final case for scriptblocks is for people who come to PowerShell knowing
    another language, such as Python. Using scriptblocks as a substitute for lambdas
    allows them to continue writing code in a style they are used to.
  prefs: []
  type: TYPE_NORMAL
- en: That’s enough to learn about functions and scriptblocks. Let’s look at a practical
    application.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s do something useful
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When I am writing PowerShell scripts for customers, I like to make sure that
    the script records information about what it is doing and any changes it has made
    in a log file so that I can quickly pinpoint what is going on. I don’t write the
    functionality each time I write a script, however; I just include some saved PowerShell
    snippets in the script that give me a log file function. Let’s think about how
    we might do that now.
  prefs: []
  type: TYPE_NORMAL
- en: First, we need to think about where we create the log file. I use `C:\temp`,
    as that directory is usually where we put things that we don’t want to keep forever,
    and it usually has fairly relaxed permissions. We might want to think about a
    different directory on Linux or macOS, such as `/var/log/`.
  prefs: []
  type: TYPE_NORMAL
- en: We also want to create a file that is as easy to read as possible; I write to
    a text file but I use the suffix `.log` so that I know what sort of text file
    it is. The file we create needs to be date-stamped so that we know which file
    relates to which instance the script was run. This means we need to create it
    outside the function, at the script level; otherwise, we’ll create a new file
    every time the function is called.
  prefs: []
  type: TYPE_NORMAL
- en: Each file entry needs to be time-stamped so we know in what order the events
    in the log occurred, and it also needs to record a string that we can pass from
    outside the function.
  prefs: []
  type: TYPE_NORMAL
- en: 'It looks like we need two parameters: `$LogFile` and `$LogString`. Let’s start
    writing this:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a new PowerShell file in VS Code; I’m calling mine `Write-Log.ps1`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'First, let’s create `$LogFilename`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, we need a descriptive name, such as `Write-Log`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Function Write-Log {
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Param(
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: $logString
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: )
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '}'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, let’s get onto the functionality. We need a variable that holds a string
    for the current date and time. Here’s another way to do it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: $LogMessage = "$stamp $Logstring"
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Finally, we need to write it to the log file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'And that’s it. Let’s add a line in the script after the function to check that
    it works:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: And let’s run it to see.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 9.10 – Yes it is](img/B17600_09_010.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.10 – Yes it is
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s my complete code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: The function I use for work does a number of other things as well, and we’ll
    be looking at some of them in the next chapter – [*Chapter 10*](B17600_10.xhtml#_idTextAnchor201),
    *Error Handling – Oh No! It’s* *Gone Wrong!*.
  prefs: []
  type: TYPE_NORMAL
- en: Activity 3
  prefs: []
  type: TYPE_NORMAL
- en: This function writes a file to a location on the client. If we regularly run
    scripts that make use of it, we’re going to end up with a lot of files cluttering
    things up. How might we go about writing a function that clears up old log files
    when we run the script?
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We’ve done some interesting stuff in this chapter. We considered some fundamental
    principles of software engineering, particularly DRY, and saw how we might apply
    them within PowerShell scripts. We looked in detail at how functions are constructed
    and how they work. We briefly discussed the difference between basic and advanced
    functions.
  prefs: []
  type: TYPE_NORMAL
- en: 'We then discussed the four types of parameters we can use with functions: named,
    switch, positional, and dynamic parameters. We also learned about the `$Args`
    automatic variable and saw how we can use that to splat parameters into cmdlets
    in our basic function.'
  prefs: []
  type: TYPE_NORMAL
- en: Next, we looked at the many types of attributes we can apply to our parameters
    to control how the script behaves. We concentrated on the more common attributes
    but acknowledged the existence of completion attributes and validation attributes.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we looked at a special type of function – the filter – and saw how
    we could use it to process pipeline objects.
  prefs: []
  type: TYPE_NORMAL
- en: We then spent some time looking at the concept of scope and saw how this is
    used to protect our environment and keep scripts and functions working in constrained
    areas of memory. We learned about parent and child scopes and the concept of scope
    hierarchy. Finally, we looked at how we could force functions and scripts to work
    outside their default scopes.
  prefs: []
  type: TYPE_NORMAL
- en: 'We then moved on to scriptblocks and saw how they are related to functions.
    We talked about different ways of calling them, including dot sourcing – a method
    we should use with caution. We then learned how scriptblocks relate to a common
    programming concept: the anonymous function or lambda.'
  prefs: []
  type: TYPE_NORMAL
- en: We covered a fair bit of theory, so we finished the chapter looking at how we
    could construct a function to do something useful that we can apply in many scripts
    – writing to a log file. I hope you found this useful; I know I use it a lot.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we’re going to be looking at how to handle errors, both
    in our script and ones we encounter when our script meets the outside world.
  prefs: []
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'For information on the software engineering concepts we covered at the start
    of the chapter: *The Pragmatic Programmer*, 20th Anniversary Edition, David Thomas
    and Andrew Hunt, 2019, Addison Wesley. There’s lots of other really useful stuff
    in there as well.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'There are lots of help *About* files included in PowerShell on the topics we’ve
    covered in this chapter. It’s worth knowing and reading these ones:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'About Functions: [https://learn.microsoft.com/en-us/powershell/ module/microsoft.powershell.core/about/about_functions?view=powershell-7.3](https://learn.microsoft.com/en-us/powershell/module/microsoft.powershell.core/about/about_functions?view=powershell-7.3'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: )
  prefs: []
  type: TYPE_NORMAL
- en: 'About Advanced Functions: [https://learn.microsoft.com/en-us/powershell/module/microsoft.powershell.core/about/about_functions_advanced?view=powershell-7.3](https://learn.microsoft.com/en-us/powershell/module/microsoft.powershell.core/about/about_functions_advanced?view=powershell-7.3)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'About Advanced Function Methods: [https://learn.microsoft.com/en-us/powershell/module/microsoft.powershell.core/about/about_functions_advanced_methods?view=powershell-7.3](https://learn.microsoft.com/en-us/powershell/module/microsoft.powershell.core/about/about_functions_advanced_methods?view=powershell-7.3)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'About Advanced Function Parameters: [https://learn.microsoft.com/en-us/powershell/module/microsoft.powershell.core/about/about_functions_advanced_parameters?view=powershell-7.3](https://learn.microsoft.com/en-us/powershell/module/microsoft.powershell.core/about/about_functions_advanced_parameters?view=powershell-7.3)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'About Advanced Function Argument Completion: [https://learn.microsoft.com/en-us/powershell/module/microsoft.powershell.core/about/about_functions_argument_completion?view=powershell-7.3](https://learn.microsoft.com/en-us/powershell/module/microsoft.powershell.core/about/about_functions_argument_completion?view=powershell-7.3)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'About CmdletBinding: [https://learn.microsoft.com/en-us/powershell/module/microsoft.powershell.core/about/about_functions_cmdletbindingattribute?view=powershell-7.3](https://learn.microsoft.com/en-us/powershell/module/microsoft.powershell.core/about/about_functions_cmdletbindingattribute?view=powershell-7.3)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'About Function Output: [https://learn.microsoft.com/en-us/powershell/module/microsoft.powershell.core/about/about_functions_outputtypeattribute?view=powershell-7.3](https://learn.microsoft.com/en-us/powershell/module/microsoft.powershell.core/about/about_functions_outputtypeattribute?view=powershell-7.3)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'About ScriptBlocks: [https://learn.microsoft.com/en-us/powershell/module/microsoft.powershell.core/about/about_script_blocks?view=powershell-7.3](https://learn.microsoft.com/en-us/powershell/module/microsoft.powershell.core/about/about_script_blocks?view=powershell-7.3)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Exercises
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: What does AHA stand for?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Why should we be very careful when using dot sourcing?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'We’ve created a variable called `$ScriptBlock` and populated it with a scriptblock.
    Let’s say we call it like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We don’t get the output we expect. Why not?
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: What parameter argument might we use to check that our input is a valid IP address?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'We’ve created a filter, `get-square`, and we’re trying to use it like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Why isn’t there any output?
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: What are we doing here?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: What’s the main difference between a function and a scriptblock?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What are we doing wrong here?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We’ve spent a lot of time in this chapter getting an inaccurate square root.
    How would we write a function to get an accurate square root?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
