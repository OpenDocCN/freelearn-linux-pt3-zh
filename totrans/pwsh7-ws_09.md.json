["```\n$mybike = @{handlebar = \"ApeHanger\"; color = \"Red\"; wheel = 15}\nif (!($mybike.handlebar)) {\n    write-output \"this bike has no handlebars\"\n}\nif (!($mybike.wheel)) {\n    write-output \"this bike has no wheels\"\n}\nif (!($mybike.color)) {\n    write-output \"this bike has no handlebars\"\n}\nif (!($mybike.gears)) {\n    write-output \"this bike has no gears\"\n}\n```", "```\n$properties = @('handlebar', 'wheel', 'color', 'gears')\nforeach ($property in $properties) {\n    if (!($mybike.($property))) {\n        write-output \"this bike has no $property\"\n    }\n}\n```", "```\nfunction get-square($a) {$a * $a}\n```", "```\nget-square 23\n```", "```\nfunction Get-RoughRoot {\n    param (\n        $number\n    )\n    $start = 1\n    while (($start * $start) -le $number)  {\n        $result = $start\n        $start += 1\n            }\n       return $result\n}\nGet-RoughRoot 785692\n```", "```\nfunction Get-RoughRoot {\n    param (\n        [Parameter(ValueFromPipeline)]\n        $number\n    )\n    begin {\n    write-output \"for the begin statement, the number is $number\"\n    }\n    process {\n        $start = 1\n        while (($start * $start) -le $number)  {\n            $result = $start\n            $start += 1\n                }\n        if ($number -lt 10) {\n            return \"pop\"\n        }\n        write-output \"The rough root of $number is $result\"\n        }\n    end {\n        write-output \"for the end statement, the number is $number\"\n    }\n}\n```", "```\n785692, 4, 3492858  | Get-RoughRoot\n```", "```\nParam(\n$number\n)\n```", "```\n$number = 100\n```", "```\nFunction get-flip {\n    param([switch]$heads)\n    if ($heads.ispresent) {\"Heads!\"}\n    else {\"Tails!\"}\n}\n```", "```\nFunction get-product {\n$product = $Args[0] * $Args[1]\nWrite-output \"The product of $($Args[0]) and $($Args[1]) is $product\"\n}\n```", "```\nGet-product 2 4\n```", "```\nFunction get-product {\nParam($a,$b)\n$product = $a * $b\n$product\n}\nGet-product 2 4\n```", "```\nParam(\n[Parameter(Argument = Value)]\n$ParameterName\n)\n```", "```\nParam(\n[Parameter(Mandatory, HelpMessage=\"Type one or more integers, separated by commas.\" )]\n[int[]]\n$number\n)\n```", "```\nParam(\n[Parameter(Mandatory, Position=0 )]\n[int[]]\n$number\n)\n```", "```\nParam(\n[Parameter (Mandatory)]\n[ValidateSet(\"Pontypool\", \"Newport\", \"Swansea\",\"Llanelli\", \"Cardiff\")]\n[string]$team\n)\n```", "```\n    $ScopeTest = 10\n    ```", "```\n    $ScopeTest by calling the variable:\n\n    ```", "```\n\n    ```", "```\n    $ScopeTest inside the function is 15. Let’s check whether the value has changed permanently:\n\n    ```", "```\n\n    No, it hasn’t. That’s because the function is operating on its local scope; it can read the value of the variable, and it can change it while it’s running, but it can’t change it permanently because the variable exists outside the function. This is known as the scope of the function.\n    ```", "```\n$global:ScopeTest = 10\n```", "```\nFunction Global:Set-ScopeTest {$ScopeTest = 15}\n```", "```\n$a = 10\nInvoke-Command -ScriptBlock {$a * $a}\n```", "```\n$square = {$a * $a}\n```", "```\n    Invoke-Command $square\n    ```", "```\n    $square.invoke()\n    ```", "```\n    $square = {param($a) $a * $a}\n    $square.invoke(20)\n    ```", "```\n&$square 20\n```", "```\n    . $square\n    ```", "```\nAdd = lambda a: a + a\nAdd(20)\n```", "```\n$add = {param($a) $a + $a}\n&$add(20)\n```", "```\n    -UFormat parameter of Get-Date; it’s to produce an easily readable text string that will work with Windows file-naming rules.\n    ```", "```\n    Function Write-Log {\n    param() block for our $LogString parameter:\n\n    ```", "```\n\n    ```", "```\n    $stamp variable and the $LogString variable that we get from the parameter:\n\n    ```", "```\n\n    ```", "```\n    Add-Content $Logfile –Value $LogMessage\n    ```", "```\n    Write-Log \"is this thing on?\"\n    ```", "```\n$LogFile = \"c:\\temp\\MyLogFile\" + $(Get-Date -UFormat \"%Y-%m-%d_%H-%M-%S\") + \".log\"\nFunction Write-Log {\n    Param (\n        [string]$LogString\n    )\n    $stamp = (Get-Date).ToString(\"yyyy/m/dd HH:mm:ss\")\n    $LogMessage = \"$stamp $Logstring\"\n    Add-Content $Logfile –Value $LogMessage\n}\nWrite-Log \"Is this thing on?\"\n```", "```\n    $ScriptBlock\n    ```", "```\n    Get-square 365\n    ```", "```\n    $private:number\n    ```", "```\n    Function get-square($a) {$a*$a}\n    15 | get-square\n    ```", "```\n    Function get-root($a) {\n    <what goes here?>\n    }\n    ```"]