<html><head></head><body>
<div id="sbo-rt-content"><div class="Basic-Text-Frame" id="_idContainer189">
<h1 class="chapterNumber">16</h1>
<h1 class="chapterTitle" id="_idParaDest-208">Virtualization</h1>
<p class="normal">There have been a great many advancements in the IT space in the last few decades, and a few technologies have come along that have truly revolutionized the technology industry. I’m sure few would argue that the internet is by far the most revolutionary technology to come around, but another technology that has created a paradigm shift in IT is virtualization. This concept changed the way we maintain our data centers, allowing us to segregate workloads into many smaller machines being run from a single server. This allows us to get even more use out of our hardware. Since Ubuntu features the latest advancements of the Linux kernel, virtualization support is actually built right into it. After installing just a few packages to allow us to interact with the virtualization features, we can create virtual machines on our Ubuntu server without the need for a pricey license agreement or support contract. In this chapter, I’ll walk you through setting up your own Ubuntu-based virtualization solution. Along the way, I’ll walk you through the following topics:</p>
<ul>
<li class="bulletList">Prerequisites and considerations</li>
<li class="bulletList">Setting up a virtual machine server</li>
<li class="bulletList">Creating virtual machines</li>
<li class="bulletList">Bridging the virtual machine network</li>
<li class="bulletList">Simplifying virtual machine creation with cloning</li>
<li class="bulletList">Managing virtual machines via the command line</li>
</ul>
<p class="normal">In order to get started, we’ll need a server to use for this task, and we’ll first have a discussion on some considerations to make when setting up a server for this purpose.</p>
<h1 class="heading-1" id="_idParaDest-209">Prerequisites and considerations</h1>
<p class="normal">I’m sure many of you have already used a virtualization solution before. In fact, I bet a great many <a id="_idIndexMarker851"/>readers are following along with this book while using a <strong class="keyWord">Virtual Machine</strong> (<strong class="keyWord">VM</strong>) running <a id="_idIndexMarker852"/>in a solution such as VirtualBox, Parallels, VMware, or one of the others. Those applications and others like them are great for testing Ubuntu or other operating systems on your desktop or laptop. In this section, we’ll set up a VM server that can act as a centrally available server on which to run VMs.</p>
<p class="normal">This will <a id="_idIndexMarker853"/>be easier than you may think—Ubuntu has virtualization built right in. This comes in the <a id="_idIndexMarker854"/>form of a dynamic duo consisting of <strong class="keyWord">Kernel-based VM</strong> (<strong class="keyWord">KVM</strong>) and <strong class="keyWord">Quick Emulator</strong> (<strong class="keyWord">QEMU</strong>), which together form a virtualization suite that <a id="_idIndexMarker855"/>enables Ubuntu (and Linux in general) to run VMs without the need for a third-party solution. KVM is the feature that is built right into the Linux kernel that performs the magic under the hood. It handles the low-level instructions in the kernel that are needed to separate tasks between those run on a physical host and on a guest VM. QEMU is also important, as it emulates hardware components that are generally found in physical servers. The combination of KVM and QEMU makes up the virtualization solution that can be enabled on an Ubuntu server to turn it into a host for VMs.</p>
<p class="normal">To be fair, you can set up something like VirtualBox on your Ubuntu Server to accomplish the same thing, and end up with a centrally available virtualization server. And that’s perfectly valid, there’s certainly nothing wrong with running VirtualBox this way, and many people do. But there are improvements to be had by utilizing a built-in system, and KVM offers a very fast interface to the Linux kernel to run your VMs with near-native speeds, depending on your use case. QEMU/KVM (which I’ll refer to simply as KVM going forward) is about as native as you can get.</p>
<p class="normal">I bet you’re eager to get started, but there are a few quick things to consider before we dive in. First, of all the activities I’ve walked you through in this book so far, setting up our own virtualization solution will be the most expensive from a hardware perspective. The more VMs you plan on running, the more resources your server will need to have available (especially RAM). Thankfully, most computers nowadays ship with 8 GB of RAM at a minimum, with 16 GB or more being fairly common. With most modern computers, you should be able to run VMs without too much of an impact. Depending on what kind of machine you’re using, the CPU and RAM may present bottlenecks, especially when it comes to legacy hardware.</p>
<p class="normal">For the purposes of this chapter, it’s recommended that you have a PC or server available with a processor that’s capable of supporting VM extensions. A good majority of CPUs on computers nowadays offer this, though some may not. To be sure, you can run the following command on the machine you intend to host the KVM VMs on in order to find out whether your CPU supports virtualization extensions:</p>
<pre class="programlisting con"><code class="hljs-con">egrep -c '(vmx|svm)' /proc/cpuinfo 
</code></pre>
<p class="normal">A result of <code class="inlineCode">1</code> or more <a id="_idIndexMarker856"/>means that your CPU does support virtualization <a id="_idIndexMarker857"/>extensions. A result of <code class="inlineCode">0</code> means it does not:</p>
<figure class="mediaobject"><img alt="" height="196" src="../Images/B18425_16_01.png" width="777"/></figure>
<p class="packt_figref">Figure 16.1: Checking the CPU for compatibility with virtualization</p>
<p class="normal">Even if your CPU does support virtualization extensions, it’s often the case that it’s disabled by default with most end user PCs sold today, and even some servers. To enable these extensions, you may need to enter the BIOS setup screen for your computer and enable the option. Depending on your CPU and chipset, this option may be named something similar to “virtualization support,” under a more technical name such as VT-x, AMD-V, or another verbiage. Unfortunately, I won’t be able to walk you through how to enable the virtualization extensions for your hardware, since the instructions will differ from one machine to another. If in doubt, refer to the documentation for your hardware.</p>
<p class="normal">One final note: I’m sure many of you are using VirtualBox, as it seems to be a very popular solution for those testing out Linux distributions (and rightfully so; it’s great!). However, you can’t run both VirtualBox and KVM VMs on the same machine simultaneously. You can certainly have both solutions installed on the same machine, but you just can’t have a VirtualBox VM up and running, and then expect to also be able to start up a KVM VM. The virtualization extensions of your CPU can only work with one solution at a time.</p>
<p class="normal">Another consideration to bear in mind is the amount of space the server has available, as VMs can take quite a bit of space. The default directory for KVM VM images is <code class="inlineCode">/var/lib/libvirt/images</code>. If your <code class="inlineCode">/var</code> directory is part of the <code class="inlineCode">root</code> filesystem, you may not have a lot <a id="_idIndexMarker858"/>of space to work with here. One trick is that you <a id="_idIndexMarker859"/>can mount an external storage volume to this directory, so you can store your VM disk images on another volume. Or you can simply create a symbolic link that will point this directory somewhere else. We discussed symbolic links in <em class="chapterRef">Chapter 5</em>, <em class="italic">Managing Files and Directories</em>. The choice is yours. If your <code class="inlineCode">root</code> filesystem has at least 10 GB available, you should be able to create at least one VM without needing to configure the storage. I think it’s a fair estimate to assume at least 10 GB of hard drive space per VM.</p>
<h1 class="heading-1" id="_idParaDest-210">Setting up a virtual machine server</h1>
<p class="normal">With all the discussion out of the way, let’s start the process and set up our virtualization server. Even though <a id="_idIndexMarker860"/>KVM is built into the Linux kernel, we’ll still need to install some packages in order to properly interface with it. Specifically, we’ll need to install several <code class="inlineCode">libvirt</code> packages, as well as QEMU itself. <code class="inlineCode">libvirt</code> itself gives us access to manage virtualization platforms on our server, as it provides us with a set of useful tools to manage our virtual machines.</p>
<p class="normal">These packages will require a decent number of dependencies, so it may take a few minutes for everything to install:</p>
<pre class="programlisting con"><code class="hljs-con">sudo apt install bridge-utils libvirt-clients libvirt-daemon-system qemu-system-x86
</code></pre>
<p class="normal">You’ll now have an additional service running on your server, <code class="inlineCode">libvirtd</code>. Once you’ve finished installing KVM’s packages, this service will be started and enabled for you. Feel free to take a look at it to see for yourself:</p>
<pre class="programlisting con"><code class="hljs-con">systemctl status libvirtd 
</code></pre>
<p class="normal">You should see information on the state of the service, similar to the following:</p>
<figure class="mediaobject"><img alt="" height="356" src="../Images/B18425_16_02.png" width="876"/></figure>
<p class="packt_figref">Figure 16.2: Checking the status of the libvirtd unit after installing KVM-related packages</p>
<p class="normal">Let’s stop this service for now, as we have some additional configuration to do:</p>
<pre class="programlisting con"><code class="hljs-con">sudo systemctl stop libvirtd
</code></pre>
<p class="normal">Next, we’ll need <a id="_idIndexMarker861"/>to make sure we have two required groups on our server, <code class="inlineCode">kvm</code> and <code class="inlineCode">libvirt</code>. It’s quite possible that the packages that we’ve installed have added these groups on our server already, so feel free to check the contents of <code class="inlineCode">/etc/group</code> and see if they’re there. If not, you can create them with the <code class="inlineCode">groupadd</code> command:</p>
<pre class="programlisting con"><code class="hljs-con">sudo groupadd kvm
sudo groupadd libvirt
</code></pre>
<p class="normal">Our primary user account should be a member of both groups. If your user isn’t already a member of these, add your user to the required groups (substitute the username, <code class="inlineCode">jay</code>, with yours):</p>
<pre class="programlisting con"><code class="hljs-con">sudo usermod -aG kvm jay
sudo usermod -aG libvirt jay
</code></pre>
<p class="normal">At this point, you may as well log out and then log in again to ensure the changes to your group memberships have taken effect.</p>
<p class="normal">To ensure we’ll be able to manage virtualization properly, we should ensure that users of the <code class="inlineCode">kvm</code> group have access to the <code class="inlineCode">/var/lib/libvirt/images</code> directory so that they’ll have access to the data that will be stored in the directory. First, we’ll apply the <code class="inlineCode">kvm</code> group to this folder:</p>
<pre class="programlisting con"><code class="hljs-con">sudo chown :kvm /var/lib/libvirt/images 
</code></pre>
<p class="normal">Then, we’ll set the permissions of <code class="inlineCode">/var/lib/libvirt/images</code> such that anyone in the <code class="inlineCode">kvm</code> group will be able to modify its contents:</p>
<pre class="programlisting con"><code class="hljs-con">sudo chmod g+rw /var/lib/libvirt/images 
</code></pre>
<p class="normal">With the initial <a id="_idIndexMarker862"/>packages and permissions in place, we can now start the <code class="inlineCode">libvirtd</code> service:</p>
<pre class="programlisting con"><code class="hljs-con">sudo systemctl start libvirtd 
</code></pre>
<p class="normal">Next, check the status of the service to make sure that there are no errors:</p>
<pre class="programlisting con"><code class="hljs-con">sudo systemctl status libvirtd 
</code></pre>
<p class="normal">Now that we’ve configured the server, we can set up our workstation to be able to connect to it and manage the virtualization implementation that we’ve set up. We’ll install a utility that <a id="_idIndexMarker863"/>will give us a <strong class="keyWord">graphical user interface</strong> (<strong class="keyWord">GUI</strong>) through which we can perform administration tasks relating to VMs. The utility we’ll be using for this purpose <a id="_idIndexMarker864"/>is known as <strong class="keyWord">Virtual Machine Manager</strong> abbreviated as <code class="inlineCode">virt-manager</code>. This utility is installed on Linux workstations, so you’ll need to install it on a laptop or desktop that’s running a desktop variant of Linux. If you have a computer running Debian or Ubuntu, the following command will install the packages that are required for this:</p>
<pre class="programlisting con"><code class="hljs-con">sudo apt install ssh-askpass virt-manager 
</code></pre>
<p class="normal">If you use a distribution of Linux other than Ubuntu, Debian, or one based on them, then you may need to consult the documentation for your distribution in order to install <code class="inlineCode">virt-manager</code>. If you’re not running Linux on your workstation at all, there is a suite of command-line utilities that can be used to manage VMs that we’ll cover later in this chapter when we discuss this in the <em class="italic">Managing virtual machines via the command line</em> section. If all else fails, you can install this utility inside a Linux VM running on your workstation.</p>
<p class="normal">Next, open <code class="inlineCode">virt-manager</code> on your administration machine. It should be located in the <strong class="screenText">Applications</strong> menu of your desktop environment, usually under the <strong class="screenText">System Tools</strong> section of <strong class="screenText">Virtual Machine Manager</strong>. If you have trouble finding it, simply run <code class="inlineCode">virt-manager</code> in your shell prompt. When you first launch it, you may see the following error:</p>
<figure class="mediaobject"><img alt="" height="289" src="../Images/B18425_16_03.png" width="675"/></figure>
<p class="packt_figref">Figure 16.3: A possible error that may appear when first launching virt-manager</p>
<p class="normal">If you do see <a id="_idIndexMarker865"/>the error, simply dismiss it and don’t worry about it. By default, <code class="inlineCode">virt-manager</code> defaults to attempting to connect to an instance of <code class="inlineCode">libvirtd</code> running on your local computer. Unless you are also running KVM VMs locally and you’ve already set it up, this attempt will fail. But that doesn’t matter for us, as we’ll be using <code class="inlineCode">virt-manager</code> to manage VMs on our server.</p>
<p class="normal">Once you’ve opened <code class="inlineCode">virt-manager</code>, you’ll see the main window, which will look similar to the following:</p>
<figure class="mediaobject"><img alt="" height="425" src="../Images/B18425_16_04.png" width="724"/></figure>
<p class="packt_figref">Figure 16.4: The virt-manager application</p>
<p class="normal">The <code class="inlineCode">virt-manager</code> utility is especially <a id="_idIndexMarker866"/>useful as it allows us to manage both remote and local KVM servers. From one utility, you can create connections to any of your KVM servers, including one or more external servers or <code class="inlineCode">localhost</code> if you are running KVM on your laptop or desktop. To create a new connection, click on <strong class="screenText">File</strong> and select <strong class="screenText">Add Connection</strong>. A new screen will appear, where we can fill out the details of the KVM server we wish to connect to:</p>
<figure class="mediaobject"><img alt="" height="430" src="../Images/B18425_16_05.png" width="495"/></figure>
<p class="packt_figref">Figure 16.5: Adding a new connection to virt-manager</p>
<p class="normal">In the <strong class="screenText">Add Connection</strong> window, enter the details of your connection. In the screenshot, you can see <a id="_idIndexMarker867"/>that I first checked the <strong class="screenText">Connect to remote host over SSH</strong> box, which selects SSH as my connection method, <code class="inlineCode">jay</code> for my <strong class="screenText">Username</strong>, and I’ve entered the IP address of my KVM server (<code class="inlineCode">172.16.250.19</code>) in the <strong class="screenText">Hostname</strong> field. Fill out the specific details here for your KVM server to set up your connection. Keep in mind that in order for this to work, the username you include here will need to be able to access the server via SSH and have permissions to the hypervisor (be a member of the <code class="inlineCode">kvm</code> and <code class="inlineCode">libvirtd</code> groups we added earlier), and the <code class="inlineCode">libvirtd</code> service must be running on the server. If all of these requirements are met, you’ll have a new connection set up to your KVM server when you click <strong class="screenText">Connect</strong>. You might see a pop-up dialog box with the text <code class="inlineCode">Are you sure you wish to continue connecting (yes/no)?</code>. If you do, type <code class="inlineCode">yes</code> and press <em class="keystroke">Enter</em>.</p>
<p class="normal">Either way, you should be prompted for your password to your KVM server; type that in and press <em class="keystroke">Enter</em>. You should now have a connection listed in your <code class="inlineCode">virt-manager</code> application. You can see the connection I added in the following screenshot; it’s the second one on the list. The first <a id="_idIndexMarker868"/>connection is <code class="inlineCode">localhost</code> since I also have KVM running on my local laptop in addition to having it installed on a remote server: </p>
<figure class="mediaobject"><img alt="" height="494" src="../Images/B18425_16_06.png" width="743"/></figure>
<p class="packt_figref">Figure 16.6: virt-manager with a new connection added</p>
<p class="normal">We’re almost at a point where we’ll be able to test our KVM server. But first, we’ll need a storage group for ISO images, for use when installing operating systems on our VMs. When we create a VM, we can attach an ISO image from our ISO storage group to our VM, which will <a id="_idIndexMarker869"/>allow it to install the operating system. </p>
<p class="normal">To create this storage group, open <code class="inlineCode">virt-manager</code> if it’s not open already. Right-click on the listing for your server connection, and then click on <strong class="screenText">Details</strong>. You’ll see a new window that will show details regarding your KVM server. Click on the <strong class="screenText">Storage</strong> tab:</p>
<figure class="mediaobject"><img alt="" height="536" src="../Images/B18425_16_07.png" width="682"/></figure>
<p class="packt_figref">Figure 16.7: The first screen while setting up a new storage pool</p>
<p class="normal">At first, you’ll only see the default connection we edited earlier. Now, we can add our ISO storage pool. Click on the plus symbol in the bottom-left corner to create the new pool:</p>
<figure class="mediaobject"><img alt="" height="392" src="../Images/B18425_16_08.png" width="601"/></figure>
<p class="packt_figref">Figure 16.8: The storage tab of the virt-manager application</p>
<p class="normal">In the <strong class="screenText">Name</strong> field, type <code class="inlineCode">ISO</code>. You can actually name it anything you want, but ISO makes sense, considering <a id="_idIndexMarker870"/>it will be storing ISO images. For the <strong class="screenText">Target Path</strong> field, set it to <code class="inlineCode">/var/lib/libvirt/images/ISO</code> unless you have a different directory in your filesystem for VM storage. Click <strong class="screenText">Finish</strong> to finalize our changes. We should also update the permissions for this directory so that it’s owned by the proper user, and members of the <code class="inlineCode">kvm</code> group have read and write access to it:</p>
<pre class="programlisting con"><code class="hljs-con">sudo chown root:kvm /var/lib/libvirt/images/ISO
sudo chmod g+rw /var/lib/libvirt/images/ISO
</code></pre>
<p class="normal">Congratulations! You now have a fully configured KVM server for creating and managing VMs. Our server has a place to store VMs as well as ISO images. You should also be able to connect to this instance using <code class="inlineCode">virt-manager</code>, as we’ve done in this section. Next, I’ll walk you through the process of setting up your first VM. Before we get to that, I recommend you copy some ISO images over to your KVM server. It doesn’t really matter which ISO image you use—any operating system should suffice. If in doubt, you can simply download Ubuntu Server 22.04 again like we did back in <em class="chapterRef">Chapter 1</em>, <em class="italic">Deploying Ubuntu Server</em>, when we set up our initial installation.</p>
<p class="normal">After you’ve chosen <a id="_idIndexMarker871"/>an ISO file and you’ve downloaded it, copy it over to your server via <code class="inlineCode">scp</code> or <code class="inlineCode">rsync</code>, and move it into the <code class="inlineCode">/var/lib/libvirt/images/ISO</code> directory. Both of those utilities were covered in <em class="chapterRef">Chapter 12</em>, <em class="italic">Sharing and Transferring Files</em>. Once the file has been copied over, you should have everything you need for now.</p>
<h1 class="heading-1" id="_idParaDest-211">Creating virtual machines</h1>
<p class="normal">Now, the time <a id="_idIndexMarker872"/>has come to put your new VM server to the test and create a VM. At this point, I’m assuming that the following is true:</p>
<ul>
<li class="bulletList">You’re able to connect to your KVM server via <code class="inlineCode">virt-manager</code></li>
<li class="bulletList">You’ve already copied one or more ISO images to the server</li>
<li class="bulletList">Your storage directory has at least 10 GB of space available</li>
<li class="bulletList">The KVM server has enough free RAM to be associated with the VM you intend on creating</li>
</ul>
<p class="normal">Go ahead and open up <code class="inlineCode">virt-manager</code>, and let’s get started!</p>
<p class="normal">In <code class="inlineCode">virt-manager</code>, right-click your server connection and click on <strong class="screenText">New</strong> to start the process of creating a new VM. The default selection will be on <strong class="screenText">Local install media (ISO image or CDROM)</strong>; leave this selection as is and click on <strong class="screenText">Forward</strong>:</p>
<figure class="mediaobject"><img alt="" height="484" src="../Images/B18425_16_09.png" width="485"/></figure>
<p class="packt_figref">Figure 16.9: The first screen while setting up a new VM</p>
<p class="normal">On the next <a id="_idIndexMarker873"/>screen, click on <strong class="screenText">Browse</strong> to open up another window where you can select the ISO image you’ve downloaded:</p>
<figure class="mediaobject"><img alt="" height="442" src="../Images/B18425_16_10.png" width="499"/></figure>
<p class="packt_figref">Figure 16.10: Creating a new VM and setting the VM options</p>
<p class="normal">If you click <a id="_idIndexMarker874"/>on your ISO storage pool, you should see a list of ISO images you’ve downloaded:</p>
<figure class="mediaobject"><img alt="" height="626" src="../Images/B18425_16_11.png" width="884"/></figure>
<p class="packt_figref">Figure 16.11: Choosing an ISO image during VM creation</p>
<p class="normal">If you don’t see <a id="_idIndexMarker875"/>any ISO images here, you may need to click the refresh icon. In my sample server, I added an install image for Ubuntu Server 22.04, which you can see in the list. Again, you can use whatever operating system you prefer. Click on the ISO image name to highlight it, and then click <strong class="screenText">Choose Volume</strong> to finalize the selection. Then, click <strong class="screenText">Forward</strong> to continue to the next screen.</p>
<p class="normal">Next, you’ll be asked to allocate RAM and CPU resources to the VM:</p>
<figure class="mediaobject"><img alt="" height="436" src="../Images/B18425_16_12.png" width="436"/></figure>
<p class="packt_figref">Figure 16.12: Adjusting the RAM and CPU count for the new VM</p>
<p class="normal">For most Linux <a id="_idIndexMarker876"/>distributions with no GUI, 2,048 MB is plenty (unless your workload demands more). One CPU core is fine for lightweight workloads, but consider adding more if the documentation for the application you intend on running recommends more than that. The resources you select here will depend on what you have available on your host. Click on <strong class="screenText">Forward</strong> when you’ve finished allocating resources.</p>
<p class="normal">Next, you’ll allocate free disk space for your VM’s virtual hard disk:</p>
<figure class="mediaobject"><img alt="" height="423" src="../Images/B18425_16_13.png" width="427"/></figure>
<p class="packt_figref">Figure 16.13: Allocating storage resources for the new VM</p>
<p class="normal">Set the disk <a id="_idIndexMarker877"/>image size to however much space you feel is relevant for the purpose of the VM. Click on <strong class="screenText">Forward</strong> when done.</p>
<p class="normal">Finally, you’ll name your VM:</p>
<figure class="mediaobject"><img alt="" height="476" src="../Images/B18425_16_14.png" width="479"/></figure>
<p class="packt_figref">Figure 16.14: Naming the new VM</p>
<p class="normal">This won’t be <a id="_idIndexMarker878"/>the hostname of the VM; it’s just the name you’ll see when you see the VM listed in <code class="inlineCode">virt-manager</code>. When you click on <strong class="screenText">Finish</strong>, the VM will start and it will automatically boot into the install ISO you’ve attached to the VM near the beginning of the process. The installation process for that operating system will then begin:</p>
<figure class="mediaobject"><img alt="" height="643" src="../Images/B18425_16_15.png" width="737"/></figure>
<p class="packt_figref">Figure 16.15: Installing Ubuntu Server inside a VM</p>
<p class="normal">When you <a id="_idIndexMarker879"/>click on the VM window, it will steal your keyboard and mouse and dedicate them to the window. Press <em class="keystroke">Ctrl</em> and <em class="keystroke">Alt</em> at the same time to release this control and regain full control of your keyboard and mouse.</p>
<p class="normal">Unfortunately, I can’t walk you through the installation process of your VM’s operating system since there are hundreds of possible candidates you may be installing. If you’re installing another instance of Ubuntu Server, you can refer back to <em class="chapterRef">Chapter 1</em>, <em class="italic">Deploying Ubuntu Server</em>, where we walked through the process. The process will be the same in the VM. From here, you should be able to create as many VMs as you need and have resources for.</p>
<p class="normal">Next, we’ll look at some concepts surrounding networking for our VMs.</p>
<h1 class="heading-1" id="_idParaDest-212">Bridging the virtual machine network</h1>
<p class="normal">Your KVM <a id="_idIndexMarker880"/>VMs will use their own network unless you configure bridged networking. This means your VMs will get an IP address in their own network, instead of yours. By default, each machine will be a member of the <code class="inlineCode">192.168.122.0/24</code> network, with an IP address in the range of <code class="inlineCode">192.168.122.2</code> to <code class="inlineCode">192.168.122.254</code>. If you’re utilizing KVM VMs on your personal laptop or desktop, this behavior might be adequate. You’ll be able to SSH into your VMs via their IP addresses if you’re connecting from the same machine the VMs are running on. If this satisfies your use case, there’s no further configuration you’ll need to do.</p>
<p class="normal">Bridged networking allows your VMs to receive an IP address from the DHCP server on your network instead of its internal one, which will allow you to communicate with your VMs from any other machine on your network. This use case is preferable if you’re setting up a central VM server to power infrastructure for your small office or organization, as your DHCP server can become a single source of truth for all of the IP addresses in use in your organization. With a bridged network on your VM server, each VM will be treated as any other network device. All you’ll need is a wired network interface, as wireless cards typically don’t work with bridged networking.</p>
<p class="normal">That last <a id="_idIndexMarker881"/>point is very important. Some network cards don’t support bridging, and if yours doesn’t, you won’t be able to use a bridge with your VM server unless you replace the network card. Before continuing, you may want to ensure your network card supports bridging by reading the documentation from the vendor of your device. In my experience, most wired cards made by Intel support bridging, and most wireless cards do NOT. Make sure you back up the Netplan configuration file before changing it, so you can revert back to the original version if you find that bridging doesn’t work for you.</p>
<p class="normal">To set up bridged networking, we’ll need to create a new interface on our server (the one that’s intended for hosting virtual machines). Open up the <code class="inlineCode">/etc/netplan/00-installer-config.yaml</code> file in your text editor with <code class="inlineCode">sudo</code>. We already talked about this file in <em class="chapterRef">Chapter 10</em>, <em class="italic">Connecting to Networks</em>, so I won’t go into too much detail about it here. Basically, this file includes the configuration for each of our network interfaces, and this is where we’ll add our new bridged interface.</p>
<p class="normal">Make sure you make a backup of the original Netplan configuration file, and then replace its contents with the following. Be sure to replace <code class="inlineCode">enp0s3</code> (the interface name) with your actual wired interface name if it’s different. There are two occurrences of it in the file.</p>
<p class="normal">If you’re reading the digital version of this book, it’s highly recommended that you refrain from copying and pasting the following code, but rather type it manually or copy it from the GitHub URL for the book’s code bundle. The reason is that the YAML format is extremely picky about spaces, and if you end up with a mix of spaces and tabs, the file might not work. When Netplan errors, it can be very hard to figure out exactly what it’s complaining about, but spacing is quite often the culprit even if the error output doesn’t lead you to believe so.</p>
<p class="normal">Take your time while configuring this file. If you make a single mistake, you will likely not have network access to the machine once it restarts:</p>
<pre class="programlisting code"><code class="hljs-code">network:
  ethernets:
    enp0s3:
      dhcp4: false
  bridges: 
    br0: 
      interfaces: [enp0s3] 
      dhcp4: true 
      parameters: 
        stp: false 
        forward-delay: 0 
</code></pre>
<p class="normal">After you <a id="_idIndexMarker882"/>make the change, you can apply the new settings immediately, or simply reboot the server. If you have a monitor and keyboard hooked up to the server, the following command is the easiest way to activate the new configuration:</p>
<pre class="programlisting con"><code class="hljs-con">sudo netplan apply 
</code></pre>
<p class="normal">If you’re connected to the server via SSH, restarting the network configuration will likely result in the server becoming inaccessible because the SSH connection will likely drop as soon as the network stops. This will disrupt the connection and prevent networking from starting back up. If you know how to use <code class="inlineCode">screen</code> or <code class="inlineCode">tmux</code>, you can run the <code class="inlineCode">restart</code> command from within either; otherwise, it may just be simpler for you to reboot the server.</p>
<p class="normal">After networking restarts or the server reboots, check whether you can still access network resources, such as pinging websites and accessing other network nodes from it. If you can, you’re all set. If you’re having any trouble, make sure you edited the Netplan config file properly.</p>
<p class="normal">Now, you should see an additional network interface listed when you run <code class="inlineCode">ip addr show</code>. The interface will be called <code class="inlineCode">br0</code>. The <code class="inlineCode">br0</code> interface should have an IP address from your DHCP server, in place of your <code class="inlineCode">enp0s3</code> interface (or whatever it may be named on your system). From this point forward, you’ll be able to use <code class="inlineCode">br0</code> for your VM’s networking, instead of the internal network. The internal KVM network will still be available, but you can select <code class="inlineCode">br0</code> to be used instead when you create new VMs.</p>
<p class="normal">If you have <a id="_idIndexMarker883"/>a VM you’ve already created that you’d like to switch to utilize your bridged networking, you can use the following steps to convert it:</p>
<ol class="numberedList" style="list-style-type: decimal;">
<li class="numberedList" value="1">First, open <code class="inlineCode">virt-manager</code> and double-click on your VM. A new window with a graphical console of your VM will open.</li>
<li class="numberedList">The second button along the top (which appears as a blue circle) will open the <strong class="screenText">Virtual Hardware Details</strong> tab, which will allow you to configure many different settings for the VM, such as the CPU count, the RAM amount, the boot device order, and more.</li>
<li class="numberedList">Among the options on the left-hand side of the screen, there will be one that reads <strong class="screenText">NIC</strong> and shows part of the VM’s network card’s MAC address. If you click on this, you can configure the VM to use your new bridge by selecting it in the list.</li>
<li class="numberedList">Finally, click on <strong class="screenText">Apply</strong>. You may have to restart the VM for the changes to take effect:</li>
</ol>
<figure class="mediaobject"><img alt="" height="690" src="../Images/B18425_16_16.png" width="776"/></figure>
<p class="packt_figref">Figure 16.16: Configuring a VM to use bridge br0</p>
<p class="normal">While creating <a id="_idIndexMarker884"/>a brand-new VM, there’s an additional step you’ll need to do in order to configure the VM to use bridged networking. In the last step of the process, where you set a name for the VM (as shown in <em class="italic">Figure 16.14</em>), you’ll also see <strong class="screenText">Advanced options</strong> listed near the bottom of the window. Expand this, and you’ll be able to set your network name. Change the dropdown in this section to<strong class="screenText"> Specify shared device name</strong> and set the bridge <strong class="screenText">Name</strong> to <code class="inlineCode">br0</code>. Now, you can click on <strong class="screenText">Finish</strong> to finalize the VM as before, and it should use your bridge whenever it starts up.</p>
<p class="normal">From this point onward, you should have not only a fully configured KVM server or instance but also a solution that can be treated as a full citizen of your network. Your VMs will be able to receive an IP address from a DHCP server and communicate with other network nodes directly. If you have a very beefy KVM server, you may even be able to consolidate other network appliances into VMs to save space, which is basically the entire purpose of virtualization.</p>
<p class="normal">In the next section, we’ll simplify the process a bit by discussing the creation of a template that can be used to act as a preconfigured starting point when setting up a new VM.</p>
<h1 class="heading-1" id="_idParaDest-213">Simplifying virtual machine creation with cloning</h1>
<p class="normal">Now that we have a KVM server, and we can spin up an army of VMs to do our bidding, we can try <a id="_idIndexMarker885"/>and find clever ways of automating <a id="_idIndexMarker886"/>some of the workload of setting up a new VM. Every time we go to create a new VM, we need to go through the entire installation process for its operating system again. While this process is not difficult, we can certainly simplify it.</p>
<p class="normal">Most prominent <a id="_idIndexMarker887"/>virtualization solutions include a feature that allows you to create a <strong class="keyWord">VM Template</strong>. With a template, we can create a VM once and get it completely configured. Then, we can convert it into a template and use it as a base for all future VMs that will use that same operating system. This saves a tremendous amount of time. You’ll probably recall the handful of screens you had to navigate through to install Ubuntu Server in our first chapter. Imagine not having to go through that process again (or at least not nearly as often).</p>
<p class="normal">Unfortunately, as great as QEMU/KVM is, it doesn’t have a template feature. This glaring hole in its feature set is a sizable setback, but thankfully we Linux administrators are very clever, and we can easily work around this to create a solution that’s essentially the same thing as templates.</p>
<p class="normal">Take the following screenshot, for example:</p>
<figure class="mediaobject"><img alt="" height="325" src="../Images/B18425_16_17.png" width="570"/></figure>
<p class="packt_figref">Figure 16.17: Virtual Machine Manager with a template listed</p>
<p class="normal">In the <a id="_idIndexMarker888"/>screenshot, you can see two VMs, <code class="inlineCode">ubuntu22.04</code> and <code class="inlineCode">ubuntu-server-template</code>. Although its name would lead you to <a id="_idIndexMarker889"/>believe otherwise, the latter is not a template at all; it’s just a VM. There’s nothing really different about it, aside from the fact that it isn’t running. What it is, though, is a clever workaround (if I do say so myself). If I want to create a new VM, I simply right-click on it, then click <strong class="screenText">Clone</strong>.</p>
<p class="normal">The following window will appear:</p>
<figure class="mediaobject"><img alt="" height="685" src="../Images/B18425_16_18.png" width="535"/></figure>
<p class="packt_figref">Figure 16.18: Cloning a VM</p>
<div class="note">
<p class="normal">When I <a id="_idIndexMarker890"/>click <strong class="screenText">Clone</strong> in this window, after <a id="_idIndexMarker891"/>giving the new VM a name, I’ve made a copy of it to serve as my new VM. It will use the original as a base, which I’ve already configured. Since Ubuntu Server was installed on the “template,” I don’t need to do all that work again.</p>
<p class="normal">If you create virtual machine templates for production use, it’s highly recommended that you check out <strong class="keyWord">cloud-init</strong>, which can help generalize its Ubuntu installation, which includes regenerating its SSH host keys and the machine ID. cloud-init is beyond the scope of this book but is definitely essential if you want to go even deeper into the topic of generating virtual machine templates.</p>
</div>
<p class="normal">Think about the tasks that you find yourself doing manually after setting up a new Ubuntu Server instance. With a base VM being used as if it were a template, you can include any <a id="_idIndexMarker892"/>tweaks or customizations <a id="_idIndexMarker893"/>you find yourself implementing right into that VM, so every time you clone it, all that work is done for you automatically. So long as you maintain your base VM, you can spin up as many VMs from it as you need and be able to do so with minimal configuration steps.</p>
<p class="normal">We’ve used <code class="inlineCode">virt-manager</code> quite a bit in this chapter to customize our VMs, and while it’s a great utility, we should also understand how to manage our infrastructure without it. In the next section, we’ll take a look at some command-line examples of managing VMs.</p>
<h1 class="heading-1" id="_idParaDest-214">Managing virtual machines via the command line</h1>
<p class="normal">In this chapter, I showed you how to manage VMs with <code class="inlineCode">virt-manager</code>. This is great if you have <a id="_idIndexMarker894"/>a secondary machine with a GUI running Linux as its operating system. But what do you do if such a machine isn’t <a id="_idIndexMarker895"/>available, and you’d like to perform simple tasks such as rebooting a VM or checking to see which VMs are running on the server?</p>
<p class="normal">On the VM server itself, you have access to the <code class="inlineCode">virsh</code> suite of commands, which will allow you to manage VMs even if a GUI isn’t available. To use these commands, simply connect to the machine that stores your VMs via SSH. What follows are some easy examples to get you started. Here’s the first one:</p>
<pre class="programlisting con"><code class="hljs-con">virsh list
</code></pre>
<p class="normal">This command will return an output like that shown in the following screenshot:</p>
<figure class="mediaobject"><img alt="" height="195" src="../Images/B18425_16_19.png" width="753"/></figure>
<p class="packt_figref">Figure 16.19: Showing running VMs with the virsh list command</p>
<p class="normal">With one command, we were able to list the VMs running on the server. In the example screenshot, you can see that I have a single VM running. If you’d also like to see non-running instances, simply add the <code class="inlineCode">--all</code> option to the command.</p>
<p class="normal">We can <a id="_idIndexMarker896"/>manage the state of our VMs <a id="_idIndexMarker897"/>with any of the following commands:</p>
<ul>
<li class="bulletList"><code class="inlineCode">virsh start vm-name</code></li>
<li class="bulletList"><code class="inlineCode">virsh shutdown vm-name</code></li>
<li class="bulletList"><code class="inlineCode">virsh suspend vm-name</code></li>
<li class="bulletList"><code class="inlineCode">virsh resume vm-name</code></li>
<li class="bulletList"><code class="inlineCode">virsh destroy vm-name</code></li>
<li class="bulletList"><code class="inlineCode">virsh undefine vm-name</code></li>
</ul>
<p class="normal">The command syntax for <code class="inlineCode">virsh</code> is extremely straightforward. By looking at the previous list of commands, you should be able to glean exactly what they do. The <code class="inlineCode">virsh</code> commands allow us to do things such as <code class="inlineCode">start</code>, <code class="inlineCode">shutdown</code>, <code class="inlineCode">suspend</code>, and <code class="inlineCode">resume</code> a VM. The <code class="inlineCode">virsh destroy</code> command is potentially destructive, as we’d use it when we want to halt a VM abruptly. It’s essentially the same result as pulling a power cable from a physical server; it stops the instance immediately. You should only run that command when you are dealing with an unresponsive VM. Finally, the <code class="inlineCode">virsh undefine</code> command deletes a VM, but you’ll have to remove any associated disk files with the <code class="inlineCode">rm</code> command. The default directory for disk files is <code class="inlineCode">/var/lib/libvirt/images</code>, so you can look inside that directory for any disk files that belong to the VM you’ve deleted (they will be named the same as the VM).</p>
<p class="normal">That’s not all <code class="inlineCode">virsh</code> can do, however. We can actually create a VM with the <code class="inlineCode">virsh</code> suite of commands as well. Learning how to do so is a good idea if you don’t use Linux as your workstation <a id="_idIndexMarker898"/>operating system, or you <a id="_idIndexMarker899"/>don’t have access to <code class="inlineCode">virt-manager</code> for some reason. However, manually creating VM disk images and configuration is outside the scope of this chapter. The main goal is for you to familiarize yourself with managing VMs via <code class="inlineCode">virsh</code>, and these simple basics will allow you to expand your knowledge further.</p>
<h1 class="heading-1" id="_idParaDest-215">Summary</h1>
<p class="normal">In this chapter, we took a look at virtualization, specifically with QEMU/KVM. We walked through the installation of KVM and the configuration required to get our virtualization server up and running. We walked through the process of creating a bridged network so that our VMs can be accessible from the rest of the network and created our first VM. In addition, although QEMU/KVM doesn’t have its own solution for templating, we worked around that and created our own solution.</p>
<p class="normal">In <em class="chapterRef">Chapter 17</em>, <em class="italic">Running Containers</em>, we’ll take a look at containerization, which will include both Docker and LXD. Stay tuned!</p>
<h1 class="heading-1" id="_idParaDest-216">Relevant video</h1>
<ul>
<li class="bulletList">cloud-init guide (LearnLinuxTV): <a href="https://linux.video/cloud-init"><span class="url">https://linux.video/cloud-init</span></a></li>
</ul>
<h1 class="heading-1" id="_idParaDest-217">Further reading</h1>
<ul>
<li class="bulletList">Ubuntu <code class="inlineCode">virsh</code> documentation: <a href="https://learnlinux.link/u-virsh"><span class="url">https://learnlinux.link/u-virsh</span></a></li>
<li class="bulletList"><em class="italic">Mastering KVM Virtualization</em>, by Vedran Dakic et al. (Packt Publishing): <a href="https://learnlinux.link/kvm-book"><span class="url">https://learnlinux.link/kvm-book</span></a></li>
</ul>
<h1 class="heading-1">Join our community on Discord</h1>
<p class="normal">Join our community’s Discord space for discussions with the author and other readers: </p>
<p class="normal"><a href="https://packt.link/LWaZ0"><span class="url">https://packt.link/LWaZ0</span></a></p>
<p class="normal"><img alt="" height="177" src="../Images/QR_Code50046724-1955875156.png" width="177"/></p>
</div>
</div></body></html>