- en: '2'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Exploring PowerShell Cmdlets and Syntax
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now we’ve got PowerShell installed, it’s time to get down to using it. The power
    of PowerShell lies in the huge number of cmdlets available for it. In this chapter,
    we’re going to learn about these. First, we’ll see how the naming conventions
    work, then we will learn how to control what they do with parameters.
  prefs: []
  type: TYPE_NORMAL
- en: We’ll take quite a deep dive into the syntax so that we understand exactly which
    parameters are available to a cmdlet and what information those parameters need
    to work. We’ll then look at how to get more cmdlets to work with, both from our
    local machine and from external sources.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we’ll talk about working interactively with PowerShell and will install
    an exciting new application for Windows that will help us do just that. By the
    end of the chapter, you will be able to confidently find and use unfamiliar cmdlets
    and be able to use the versatile Windows Terminal application.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we’re going to cover the following main topics:'
  prefs: []
  type: TYPE_NORMAL
- en: What are cmdlets?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding cmdlet syntax
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to find more cmdlets
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Working interactively with PowerShell
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter assumes you have a client machine, an internet connection, and
    have installed the latest stable version of PowerShell 7\. The last two sections
    of this chapter— *Windows Terminal – an alternative terminal emulator* and *Installing
    Windows Terminal from the Windows Store*—are specifically for Windows users. Those
    of us on Linux and macOS can feel happy that we don’t need to do these parts,
    as those operating systems already contain multi-tabbed terminals.
  prefs: []
  type: TYPE_NORMAL
- en: What are cmdlets?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Cmdlets** (pronounced *command-lets*) are the commands we use in PowerShell.
    They can either be entered via a terminal application or through a script. They
    may be **script-based** and constructed from other cmdlets, or they may be **binary**
    cmdlets written in **C#**. The cmdlets that install by default with PowerShell
    are binaries. Usually, cmdlets that we write ourselves or download from the internet
    will be script-based. Cmdlets take an **input object** from the pipeline, perform
    an action on it, and generally return an object for further processing. We will
    describe this in detail in [*Chapter 3*](B17600_03.xhtml#_idTextAnchor049), *The
    PowerShell Pipeline – How to String* *Cmdlets Together*.'
  prefs: []
  type: TYPE_NORMAL
- en: Exploring cmdlet structure
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We’ve already used a few cmdlets, and you may have noticed that they have a
    common structure: `Get-Help`, `Get-Command`, `Get-Member`. This is a **verb-noun**
    structure, and it’s intended to help us understand what a cmdlet does. The **verb**
    at the start tells us that in each case, these cmdlets are going to *get* something:
    help, a list of commands, or a list of members. There is a list of approved verbs
    here: [https://docs.microsoft.com/en-us/powershell/scripting/developer/cmdlet/approved-verbs-for-windows-powershell-commands?view=powershell-7.2](https://docs.microsoft.com/en-us/powershell/scripting/developer/cmdlet/approved-verbs-for-windows-powershell-commands?view=powershell-7.2).'
  prefs: []
  type: TYPE_NORMAL
- en: Why do we need a list of approved verbs? For the sake of clarity; one of the
    primary purposes of PowerShell is to be easily understood. By limiting the number
    of verbs and clearly defining what each one means and when it should be used,
    we can tell immediately what a cmdlet will do. For instance, a cmdlet named `Delete-Item`
    might be just as obvious as `Remove-Item`, but how about `Eliminate-Item`? It’s
    possible this is going to do something unpleasant and terminal. Most well-written
    cmdlets will conform to this list; hopefully, anything we write will as well.
  prefs: []
  type: TYPE_NORMAL
- en: Notice that not all the verbs in that list are actual verbs in English. `New`
    is not a verb, but for the purposes of cmdlets, we’re going to use it as one.
  prefs: []
  type: TYPE_NORMAL
- en: Activity 1
  prefs: []
  type: TYPE_NORMAL
- en: When should we use `New`, and when should we use `Add`? Check out the preceding
    link to find out.
  prefs: []
  type: TYPE_NORMAL
- en: The second part of the cmdlet is the `Get-Process`, never `Get-Processes`. The
    second rule is that they should be descriptive; that is, they should be immediately
    understandable. This can lead to some long cmdlet names, such as `Get-NetAdapterAdvancedProperty`.
    This is a bit of a mouthful, but it’s easily understood. Autocomplete, which we
    have already looked at in [*Chapter 1*](B17600_01.xhtml#_idTextAnchor013), *Introduction
    to PowerShell 7 – What It Is and How to Get It*, makes typing long cmdlets much
    easier. Type the first part of the noun, hit *Tab*, type the next part, hit *Tab*
    again, and so on until the cmdlet is complete. Try it with `Get-NetAdapterAdvancedProperty`.
    We only need to type `Get-NetA`, then press *Tab* twice to arrive at the right
    cmdlet. Repeatedly pressing *Tab* will cycle through the appropriate cmdlets on
    a Windows machine, or present you with a list of options on Linux and macOS.
  prefs: []
  type: TYPE_NORMAL
- en: There are also some standards around capitalization; **CamelCase** is preferred,
    whereby each word in the noun is capitalized. This not only makes it easier for
    us to read from the screen, but it also means that accessibility tools such as
    screen readers can handle them correctly.
  prefs: []
  type: TYPE_NORMAL
- en: The correct use of aliases
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'There is a way around cumbersome cmdlet names: `Get-Alias` into the command
    line. You should see a fairly long list of aliases for common cmdlets. For example,
    you should see that `man` is an alias for `Get-Help`. Try it; type in the following
    code and see what happens:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'There are two types of aliases, which exist for different reasons. Let’s have
    a closer look at them here:'
  prefs: []
  type: TYPE_NORMAL
- en: '`gci` for `Get-ChildItem`. These often require you to already know what the
    correct cmdlet is and can be quite cryptic. They are for people who know PowerShell
    and want to save time.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`man` is a Unix command that calls the `ls` and `dir` are both aliases for
    `Get-ChildItem` and produce output that looks like the output you might expect
    if you are familiar with the `ls` Unix command or the `dir` Windows command. These
    are for old people like me so that years of muscle memory don’t have to be relearned.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: While we can type `dir` in PowerShell and get relevant output, we are not getting
    output from the `dir` command. The command switches we may be familiar with in
    `dir` won’t work in PowerShell. We are calling a cmdlet with similar functionality.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can also define our own aliases for cmdlets we use regularly using the `Set-Alias`
    cmdlet. We can do it like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Try it. Type in the preceding cmdlet, and then type in `adapters`. You should
    see something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.1 – Setting an alias](img/B17600_02_001.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2.1 – Setting an alias
  prefs: []
  type: TYPE_NORMAL
- en: The drawback to doing this is that the alias you set is only available in the
    current PowerShell session. When you close the window, all your custom aliases
    are lost. You can save them in your PowerShell profile, but they’ll still only
    be available locally. I avoid using custom aliases and rely on autocomplete instead.
    It’s also poor practice to use them in a script, as this can hinder readability.
  prefs: []
  type: TYPE_NORMAL
- en: Now we have an understanding of what a cmdlet is, let’s take a look at the syntax
    we need to use with them.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding cmdlet syntax
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We’ve already seen that you can pass information to cmdlets for input, or to
    modify the output. For instance, in the previous section, we typed the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'The cmdlet is called `Set-Alias`, but there are two bits of information after
    that: `-Name` and `-Value`. These are called `-`), which tells PowerShell that
    the following characters up to the next *space* character represent an instruction,
    rather than a value. In each of the preceding parameters we’ve passed a string—we’ve
    told `Set-Alias` that the value of `-Name` is `adapters`, and `-Value` is `Get-NetAdapter`.
    Now, when we type `adapters` at Command Prompt, PowerShell knows to substitute
    it with `Get-NetAdapter`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'That’s great, but how do we know which parameters a cmdlet will take? Well,
    we’re going to go back to our friend `Get-Help` from [*Chapter 1*](B17600_01.xhtml#_idTextAnchor013),
    *Introduction to PowerShell 7 – What It Is and How to Get It*. Open a PowerShell
    prompt and type the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'This will call up the `Get-Random` help file. We are interested in the `SYNTAX`
    section, shown next:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.2 – Get-Random syntax](img/B17600_02_002.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2.2 – Get-Random syntax
  prefs: []
  type: TYPE_NORMAL
- en: 'Well, that’s great, but what does it all mean? The help file tells us that
    `Get-Random` can operate in three different ways; there is a set of parameters
    for each. Let’s concentrate on the first set. Remember, parameters always start
    with a dash (`-`), so we can see there are four parameters in that first set:
    `-Maximum`, `-Minimum`, `-Count`, and `-SetSeed`. As it says in the `DESCRIPTION`
    section: `You can use the parameters of Get-Random to specify the minimum and
    maximum values, the number of objects returned from a collection, or a seed number`.
    Hopefully, you completed the *Exercises* section in [*Chapter 1*](B17600_01.xhtml#_idTextAnchor013),
    *Introduction to PowerShell 7 – What It Is and How to Get It*, so you’ve seen
    this before. Let’s look at the second parameter set. There are three parameters
    there: `-InputObject`, `-Count`, and `-SetSeed`. Using these parameters makes
    `Get-Random` do something different. Instead of returning a random number, now
    it will return a random object from a list you give it in the first parameter.
    Let’s try it. In a PowerShell prompt, type the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Hopefully, `Get-Random` will return a random piece of fruit from that list.
    The comma character tells PowerShell that there are more items to come in the
    list.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following screenshot shows some of the ways you can get this wrong:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.3 – Passing a list of items the wrong way](img/B17600_02_003.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2.3 – Passing a list of items the wrong way
  prefs: []
  type: TYPE_NORMAL
- en: In the first example, I’ve only passed a single item with a lot of double quotes.
  prefs: []
  type: TYPE_NORMAL
- en: In the second one, I’ve passed a single item to the `-InputObject` parameter,
    and PowerShell is interpreting the second string, `pears`, as input for another
    parameter and getting confused.
  prefs: []
  type: TYPE_NORMAL
- en: In the third example, PowerShell is waiting for the next item in the list, shown
    by the `>>` symbol. If you find yourself with this and you don’t know what to
    type next, press *Ctrl* + *C* to break out.
  prefs: []
  type: TYPE_NORMAL
- en: 'But the `SYNTAX` section tells us a lot more than just the names and sets of
    the parameters. It also tells us which parameters are mandatory, which ones accept
    more than one item, which ones need to be explicitly named, and which types of
    values each parameter will accept. Hold tight—this is going to get a bit complicated.
    Let’s look at the `SYNTAX` section of the help file for `Get-Random` again, in
    the following screenshot. Keep your eyes on the square brackets:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.4 – Get-Random syntax](img/B17600_02_004.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2.4 – Get-Random syntax
  prefs: []
  type: TYPE_NORMAL
- en: Our first parameter set starts with `[[-Maximum] <System.Object>]`. `-Maximum`
    is the parameter name, and `<System.Object>` is the parameter `-Maximum` parameter
    will take as input.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you type `Get-Help Get-Random -Full`, then you will see that it only accepts
    integers, floating-point numbers, or objects that can be interpreted as integers,
    such as the string `two`, as shown in *Figure 2**.5*. The outer set of square
    brackets tells us that the `-Maximum` parameter is optional; we don’t need to
    include it to get a random number. The inner set of square brackets around the
    parameter name, `[-Maximum]`, tells us that we don’t need to include the parameter
    name to pass a maximum value to the cmdlet. In the following screenshot, we can
    see that the parameter has a position value of `0`—this means that the first unnamed
    argument will be interpreted as belonging to the `-``Maximum` parameter:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.5 – Detailed information about the -Maximum and -Minimum parameters](img/B17600_02_005.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2.5 – Detailed information about the -Maximum and -Minimum parameters
  prefs: []
  type: TYPE_NORMAL
- en: We can see that for the `[-Minimum <System.Object>]` parameter, there is no
    inner set of square brackets; this means the `-Minimum` parameter must always
    be named if we’re going to use it; we actually have to type `-Minimum`. For both
    the `-Minimum` and `-Maximum` parameters, there are no square brackets around
    `<System.Object>`. This means that if we use these parameters, we must pass an
    argument to them of the type `System.Object` (specifically in this case an integer,
    floating-point number, or string that can be interpreted as a number).
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s look at the second set of parameters. It starts with `[-InputObject]
    <System.Object[]>`; this means if we want to use the second set, we must provide
    some input. The square brackets around `[-Input.Object]` tell us the name of the
    parameter is optional, however; PowerShell will interpret the first argument it
    receives as the input. How is this different from the first set? Look closely
    at the `<System.Object[]>` argument—it contains a set of square brackets at the
    end. This shows that it can contain multiple values, separated by a comma. Try
    this. Type the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Hopefully, you should get one of those values back. PowerShell knows it has
    received multiple values and knows not to interpret that collection as an argument
    for `-Maximum`, because `-Maximum` can only contain a single value.
  prefs: []
  type: TYPE_NORMAL
- en: Activity 2
  prefs: []
  type: TYPE_NORMAL
- en: How might you provide a single numeric value to the `-``InputObject` parameter?
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s look now at the third set of parameters. At first glance, they look the
    same as the second set. They both start the same way, but notice at the end is
    this parameter: `-Shuffle`. It’s got no square brackets and no argument. This
    is a `switch` parameter. If we use it, we are automatically using the third parameter
    set; this means the `-Count` parameter is not available to us, as it’s not in
    the third set. It doesn’t take any argument because it tells PowerShell to return
    the entire list in random order.'
  prefs: []
  type: TYPE_NORMAL
- en: Each parameter set finishes with `[<CommonParameters>]`. This is a set of parameters
    that are available for any PowerShell cmdlet. You can read the `about_CommonParameters`
    help file for more information. They include variables to control the action PowerShell
    will take in the event of an error, or to produce more output from a cmdlet to
    help with troubleshooting. More on this in [*Chapter 10*](B17600_10.xhtml#_idTextAnchor201),
    *Error Handling – Oh No! It’s* *Gone Wrong!*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s summarize cmdlet syntax. There are six types of parameters, listed next:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Start-Service` has a mandatory parameter: `-DisplayName`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Get-Random` parameter `-InputObject` is an example of this.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Get-Random` parameter `-Count` is an example of this.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`-Maximum` is an example of this in the `Get-Random` cmdlet. The whole parameter
    is enclosed in square brackets, then there is a second set enclosing just the
    parameter name.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`-Shuffle` is a good example of a mandatory switch parameter.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Common parameters**: These are parameters that are available to all PowerShell
    cmdlets, and allow you to direct output or control error behavior.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Parameters are organized into `Get-Random` can return a random number, a random
    item from a list, or the whole list in random order.
  prefs: []
  type: TYPE_NORMAL
- en: Now we understand what cmdlets and parameters are, you’re probably wondering
    where we get them. There are lots included when we download PowerShell, but it’s
    not going to be anything like enough. We’ll explore how to get more cmdlets next.
  prefs: []
  type: TYPE_NORMAL
- en: How to find more cmdlets
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Cmdlets are usually bundled together into packages called modules. We’ll cover
    module structure in detail in [*Chapter 11*](B17600_11.xhtml#_idTextAnchor218),
    *Creating Our First Module*, but for now, it is enough to know that a module is
    a collection of cmdlets with a common theme, such as interacting with a particular
    application or performing a set of similar functions. Once a module is installed
    and imported, the cmdlets become available in the shell or to a script.
  prefs: []
  type: TYPE_NORMAL
- en: Finding modules and cmdlets on your machine
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We already have a number of modules available to us. Try this; type `Get-Module`
    into your shell. Depending on how long PowerShell has been installed, how long
    the session has been open, and the platform we are working on, we should see a
    relatively short list—something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.6 – List of imported modules](img/B17600_02_006.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2.6 – List of imported modules
  prefs: []
  type: TYPE_NORMAL
- en: 'That’s a list of modules that have been imported into the current session.
    But that’s not all the modules that we can use right now. Try running the cmdlet
    again, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: You should see a few more; if you’re running on Windows, you’ll see a lot more.
  prefs: []
  type: TYPE_NORMAL
- en: 'The output of the cmdlet will be split according to the directory the modules
    are in, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.7 – Modules and their directories](img/B17600_02_007.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2.7 – Modules and their directories
  prefs: []
  type: TYPE_NORMAL
- en: 'As you can see, on my machine, that cmdlet has found modules from PowerShell
    7 Preview and modules from Windows PowerShell, as well as many others. PowerShell
    uses the `PSModulePath` environment variable to know where to look for modules
    in your environment. We can check which locations are in that variable by typing
    the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: You’ll need to use a colon if you’re working on a Linux or macOS device.
  prefs: []
  type: TYPE_NORMAL
- en: 'Locations are put in that variable each time PowerShell is started, but they
    can also be added by applications, or even manually. You can see the results from
    my machine in the following screenshot. Notice the last entry is for `Microsoft
    Message Analyzer`; this was added when I installed that application:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.8 – The PSModulePath variable](img/B17600_02_008.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2.8 – The PSModulePath variable
  prefs: []
  type: TYPE_NORMAL
- en: While we can add paths manually, for most purposes it is better to make sure
    we install modules to the default paths. There’s lots more about the `PSModulePath`
    variable in the `about_PSModulePath` help file.
  prefs: []
  type: TYPE_NORMAL
- en: Now we know where to find modules on our machine, how do we know which cmdlets
    are in them? Notice in *Figure 2**.7* that there are properties in the `ExportedCommands`
    table; these are the cmdlets that will be available when we import the module.
    There may be cmdlets that aren’t exported and can only be used internally within
    the module; we won’t be able to type these in and use them. We can see just the
    exported cmdlets by running `Get-Command –Module`, followed by the name of the
    module.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s try something. In [*Chapter 1*](B17600_01.xhtml#_idTextAnchor013), *Introduction
    to PowerShell 7 – What It Is and How to Get It*, we used the `Get-Command` cmdlet
    to find cmdlets. That cmdlet searches all the available modules for cmdlets, or
    we can tell it to just search imported ones. Let’s say we’re interested in cmdlets
    for manipulating modules. We might type the following to get a list of cmdlets
    that include the word `module` in the name:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'However, if we type the following, then we will only get cmdlets from modules
    that we have already imported into the current session:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'This shows how those two cmdlets look on my machine:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.9 – Imported and installed cmdlets](img/B17600_02_009.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2.9 – Imported and installed cmdlets
  prefs: []
  type: TYPE_NORMAL
- en: 'How do we use cmdlets from modules that haven’t been imported? In two ways,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Firstly, we can use the `Import-Module` cmdlet to bring the module into the
    session, and then use the cmdlet we need.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Or, we can just use it anyway and allow PowerShell to implicitly import it.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Try it. In *Figure 2**.6*, there is a list of imported modules for my current
    session. It doesn’t contain the `PowerShellGet` module. It’s probable that your
    current session hasn’t imported that module either, so let’s do that now. Type
    the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'You’ll notice a little bit of a pause as PowerShell imports the `PowerShellGet`
    module, and then you’ll see a list of installed modules if any have been installed.
    That’s great, but the clever bit is this: type `Get-Module` again, to get a list
    of imported modules. You should see `PowerShellGet` has been imported in the background,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.10 – As if by magic… the module appears](img/B17600_02_010.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2.10 – As if by magic… the module appears
  prefs: []
  type: TYPE_NORMAL
- en: 'That leads to two questions. The first one is this: Why bother with importing
    and installing? Why not make all the cmdlets available every time, right from
    the start? The short answer is **space**. Each imported module requires a memory
    space; if we import hundreds of modules and thousands of cmdlets, then every time
    we start PowerShell, it will get incredibly unwieldy and slow, so we just import
    the modules and cmdlets we need, as we need them.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The other question is this: Why do we need an `Import-Module` cmdlet if we
    can get cmdlets implicitly? We need `Import-Module` for two reasons; firstly,
    you might not install a module into one of the default paths in `PSModulePath`,
    so implicit importing won’t be available. Secondly, you might want to control
    how the module is imported. For instance, you might not want to import cmdlets
    from a module that has the same name as cmdlets you have already imported, in
    which case you would use `Import-Module` with the `-NoClobber` parameter, rather
    than import implicitly.'
  prefs: []
  type: TYPE_NORMAL
- en: Activity 3
  prefs: []
  type: TYPE_NORMAL
- en: How might we import cmdlets, but change their names so that we know which module
    they are from?
  prefs: []
  type: TYPE_NORMAL
- en: Finding new modules and cmdlets
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: So far, we’ve looked at modules that are already on our system, but we have
    just now imported `PowerShellGet`, and it’s really useful because it can help
    us find modules that are held remotely, in a `PowerShellGet` connects to by default.
  prefs: []
  type: TYPE_NORMAL
- en: The PowerShell Gallery
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Let’s start by looking at how we might find modules in the gallery that we
    are interested in. Try running the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'This will give us a list of the cmdlets that are available in the module. We
    can see they fall into two categories—cmdlets for finding and installing resources
    such as modules and scripts, and cmdlets for managing repositories. Let’s have
    a look for a module. Try running the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'My results are shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.11 – Math-related modules in the PowerShell Gallery](img/B17600_02_011.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2.11 – Math-related modules in the PowerShell Gallery
  prefs: []
  type: TYPE_NORMAL
- en: 'Some of those look more or less useful—I’m not sure that I need `PokerMath`,
    but you may. How do we know which cmdlets are in those modules? We can’t use `Get-Command`,
    as the modules are not present on our local machine, but `PowerShellGet` includes
    the `Find-Command` cmdlet. If we pass `Find-Command` the name of a particular
    module, then it will list out the cmdlets in that module, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'If we run that, we can see that `psmath` contains a whole range of mathematical
    functions, from the fairly obvious—such as `Get-Math.sqrt`—to some more esoteric
    ones for **artificial intelligence** (**AI**) and statistics. To know how to use
    the functions, we will need to install the module and examine the help file. We
    can do this by typing the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'You may see a warning that the repository is untrusted, as in the following
    screenshot. This is expected, as by default, no repositories are trusted. We need
    to explicitly trust them with the `Set-PSrepository` cmdlet:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.12 – Do you trust this repository?](img/B17600_02_012.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2.12 – Do you trust this repository?
  prefs: []
  type: TYPE_NORMAL
- en: 'Type `Y` for yes. After a few seconds of a progress bar, the Command Prompt
    will reappear. The module is now installed, but not imported. Although we’ve used
    `PowerShellGet` to install the module, it’s been installed into a location that
    isn’t in the correct path for implicitly importing it by using one of the cmdlets,
    but we can explicitly import it using the `Import-Module` cmdlet, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'If we now type the following, we will see one of the disadvantages of community-provided
    modules:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'A lot of authors are more excited by writing their software than documenting
    it, and the help is pretty sparse. However, we can see that `Get-Math.Sqrt` takes
    two parameters: either values or an input object. The `-Values` parameter is positional.
    Interestingly, it also takes a list of values, not only a single one. You can
    use the input object to supply the output of another cmdlet or a variable. Try
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: This will generate a random number, and then calculate the square root of it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Why doesn’t `PowerShellGet` install modules in the right place? This is to
    do with scope. By default, `PowerShellGet` will install modules for the current
    user only, into a path in your `Documents` folder if you are on Windows, or into
    your home drive on Linux. We can change this by including the `-Scope` parameter
    with the `AllUsers` argument, but we would need to be running with administrator
    rights to do so. In the following screenshot, you can see the error message that
    comes up in this case. The alternative is to add the location to the `PATH` environment
    variable:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.13 – I’m afraid I can’t do that, Dave](img/B17600_02_013.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2.13 – I’m afraid I can’t do that, Dave
  prefs: []
  type: TYPE_NORMAL
- en: We can also view the PowerShell Gallery online at [https://www.powershellgallery.com/](https://www.powershellgallery.com/).
    Searching the website for `math` gives a lot more results, as it will not only
    search the module name but also any associated tags. We can get similar results
    by using the `-Filter` parameter with `Find-Module`.
  prefs: []
  type: TYPE_NORMAL
- en: The PowerShell Gallery is not the only repository
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: While the PowerShell Gallery is great, there are other repositories. You may
    have an internal repository where you work, or you may decide to build one for
    yourself later. The advantages of a repository are the version control and the
    automation it allows. The disadvantages are the maintenance and the potential
    for exploitation. If you need to use repositories other than the PowerShell Gallery,
    then `PowerShellGet` includes cmdlets for working with them, such as `Get-``PSRepository`,
    `Set-PSRepository`, and `Register-PSRepository`.
  prefs: []
  type: TYPE_NORMAL
- en: Other sources
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The main alternative to the PowerShell Gallery is GitHub, at [https://github.com](https://github.com),
    and similar online source code management tools such as GitLab. These platforms
    are not specific to PowerShell and contain code written in many other languages.
    The vast majority of the code is open source in one form or another. The GitHub
    platform is owned by Microsoft but not moderated by Microsoft, and contains everything
    ranging from the fully official PowerShell repository, with Microsoft’s own code,
    to unmaintained incomplete bits of scripts and malware. Unless you absolutely
    trust the repository owner always, *ALWAYS* read the code and understand what
    it does before downloading it.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can search GitHub for PowerShell modules by entering our search term on
    the GitHub website and adding `language:PowerShell`, as seen in the following
    screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.14 – 49 repositories on the GitHub website, some of which may be
    useful](img/B17600_02_014.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2.14 – 49 repositories on the GitHub website, some of which may be useful
  prefs: []
  type: TYPE_NORMAL
- en: We can also find plenty of PowerShell scripts on the internet; it’s less likely
    we’ll find full modules, but many useful websites publish perfectly usable scripts
    outside of source-controlled platforms. The caveat still stands, however, only
    more so. Even if you trust the author, read the code, and understand what it does
    before using it. Never just blindly run something and hope it’s OK. PowerShell
    is extremely powerful, and you should always run it securely. There’ll be plenty
    more on this in [*Chapter 12*](B17600_12.xhtml#_idTextAnchor236), *Securing PowerShell*
  prefs: []
  type: TYPE_NORMAL
- en: The final way to get cmdlets, modules, and scripts is to write them yourself.
    This is easier than you might think, and we’ll cover it in the second section
    of the book, starting in [*Chapter 8*](B17600_08.xhtml#_idTextAnchor162), *Writing
    Our First Script – Turning Simple Cmdlets into* *Reusable Code*.
  prefs: []
  type: TYPE_NORMAL
- en: We should now have a good idea of the many places where we can find PowerShell
    resources, and understand their relative value. In the next section, we’ll discuss
    the most basic way to work with PowerShell, and Windows users can have some fun.
  prefs: []
  type: TYPE_NORMAL
- en: Working interactively with PowerShell
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: PowerShell is, in my experience, unusual for a programming language, in that
    the huge number of cmdlets available make it particularly suitable for interactive
    use; open a terminal, type a line of code, and see something exciting happen.
    It is pretty difficult to do this in other interpreted languages, such as Python,
    because Python doesn’t come with many bundled commands, and it is difficult to
    import libraries into interactive sessions. Because of this, Python users very
    quickly move on to writing scripts. In the 10 years I have worked with PowerShell,
    I’ve found many of my colleagues never really progress from interactive PowerShell,
    and that’s fine. In the rest of this chapter, we’re going to recap how we’ve been
    using PowerShell, and Windows users can get to install a really useful utility
    called Windows Terminal, which will give them the same multi-tabbed terminal experience
    that Linux and macOS users can get by default.
  prefs: []
  type: TYPE_NORMAL
- en: Each time we’ve entered a line of code, we’ve called a cmdlet. Each cmdlet is
    a mini-script or program. This is similar to shell scripting; batch scripts in
    Windows or Bash scripts in Linux, where each line of code we enter calls a defined
    program.
  prefs: []
  type: TYPE_NORMAL
- en: Most scripts in PowerShell are written in the same way—the script can be run
    as if it were a cmdlet, with parameters to modify the behavior and actions. This
    means we can use them interactively as well, allowing us to share our efforts
    with our less technically inclined colleagues and friends. Before we start writing
    scripts, however, it would be good to set up a way to easily use PowerShell interactively.
    The provided shell is much improved with PowerShell 7, including highlighting
    to make it easier to see what we are typing and improved copy and paste. However,
    I prefer another tool—Windows Terminal.
  prefs: []
  type: TYPE_NORMAL
- en: Windows Terminal – an alternative terminal emulator
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'If you use Linux or macOS, you don’t need to do this part, as you already have
    multi-tabbed terminals, you lucky people. For Windows users, we had to open multiple
    applications; in the past, I might have had Windows Console (Command Prompt),
    Windows PowerShell, PowerShell 7, Azure Cloud Shell, PuTTY, Git Bash, and Python
    all open at once, running as separate applications. Since 2020, however, there
    is a much better choice—Windows Terminal. It can run multiple instances of any
    command-line program in separate tabs, which is enough to convince me on its own,
    but it also has support for emojis and glyphs, a split-pane function, and an allegedly
    fun new font called Cascadia Code, plus it’s open source. There are lots of details
    in this blog post if you want to know more: [https://devblogs.microsoft.com/commandline/introducing-windows-terminal/](https://devblogs.microsoft.com/commandline/introducing-windows-terminal/).'
  prefs: []
  type: TYPE_NORMAL
- en: Windows Terminal is hosted on GitHub at [https://github.com/Microsoft/Terminal](https://github.com/Microsoft/Terminal),
    and you can download and install the `.msixbundle` file from there. You can also
    install it using Winget if you installed that earlier, or if you are on Windows
    11\. The preferred way, however, is to install it from Microsoft Store. This allows
    the application to be automatically updated—as it is open source, software updates
    are frequent and often necessary, as they include bug fixes as well as improvements.
  prefs: []
  type: TYPE_NORMAL
- en: Installing Windows Terminal from Microsoft Store
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Installing from the Windows Store is a breeze. Here’s how to do it:'
  prefs: []
  type: TYPE_NORMAL
- en: Type `store` into your search bar in Windows and launch the Microsoft Store
    app.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Type `Windows Terminal` into the search bar in the Store app.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Click **Get**, as shown in the following screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 2.15 – Getting Windows Terminal: not suitable for toddlers](img/B17600_02_015.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2.15 – Getting Windows Terminal: not suitable for toddlers'
  prefs: []
  type: TYPE_NORMAL
- en: After a few minutes, Terminal will be available in your **Start** menu.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'And that’s it. Windows Terminal will now be updated automatically. Let’s start
    configuring it for our purposes. Because we’ve already installed PowerShell 7,
    Terminal will default to that when you open it; if we hadn’t, it would default
    to Windows PowerShell instead. Depending on which other applications you have
    installed on your client, it may automatically pick them up and make them available.
    Click the *down* icon in the toolbar to see what is already available and select
    an application other than the default, as illustrated in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.16 – The basic applications available in Windows Terminal](img/B17600_02_016.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2.16 – The basic applications available in Windows Terminal
  prefs: []
  type: TYPE_NORMAL
- en: 'That’s great, but it doesn’t begin to cover the number of command-line applications
    you might have. Let’s see how we can do that. I’ve got Python on my machine because
    I often enjoy a change of perspective. If you want to follow along and you don’t
    have Python installed, you can download it from here: [https://www.python.org/downloads](https://www.python.org/downloads)/.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Python by default installs to `C:\Users\<yourname>\AppData\Local\Programs\Python\<version
    number>`, as in the following screenshot. You’ll need to make a note of the path,
    and enable viewing hidden files in **File Explorer**:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.17 – Where Python is](img/B17600_02_017.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2.17 – Where Python is
  prefs: []
  type: TYPE_NORMAL
- en: 'To configure Windows Terminal to access Python, you’ll need to set up a new
    profile. Here’s how you can do this:'
  prefs: []
  type: TYPE_NORMAL
- en: Start Windows Terminal.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click the *down* button on the toolbar, and select **Settings**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Select **Add a new profile** in the left-hand pane, and click on **New empty
    profile**, as shown in the following screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 2.18 – Creating a new profile](img/B17600_02_018.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2.18 – Creating a new profile
  prefs: []
  type: TYPE_NORMAL
- en: Fill in the name—in my case, I’m using `Python 3.10`, so I know which version
    of Python it will launch.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Fill in the path to the `python.exe` executable file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select a starting directory, if you like. I like to put all my rubbish in one
    place.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'I like to use icons. You can find Python icons here: `C:\Users\<username>\AppData\Local\Programs\Python\Python310\Lib\test\imghdrdata`.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click **Save**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'You can see an overview of this in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.19 – Creating a new profile, completed](img/B17600_02_019.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2.19 – Creating a new profile, completed
  prefs: []
  type: TYPE_NORMAL
- en: And we’re done. Now, when you click on the *down* button in the toolbar, you’ll
    see **Python 3.10** as an option. Why have I used Python as an example here? Why
    didn’t I use the PowerShell 7 Preview version? Because Windows Terminal is pretty
    clever. If you install PowerShell 7 Preview after installing Windows Terminal,
    just restart Windows Terminal, and voilà! PowerShell 7 Preview will be an option.
    Cool, eh?
  prefs: []
  type: TYPE_NORMAL
- en: 'Here, you can see Python running in Windows Terminal:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.20 – Running Python in Windows Terminal](img/B17600_02_020.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2.20 – Running Python in Windows Terminal
  prefs: []
  type: TYPE_NORMAL
- en: 'There’s another thing we must do. We’ve discussed the importance of being able
    to start PowerShell as an administrator; we need to do that for Windows Terminal
    as well. The easiest way to do that is to pin the Terminal app to the taskbar.
    If you right-click the icon on the taskbar, we can then right-click the **Terminal**
    icon in the pop-up menu and select **Run as administrator**, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.21 – Running Windows Terminal as an administrator](img/B17600_02_021.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2.21 – Running Windows Terminal as an administrator
  prefs: []
  type: TYPE_NORMAL
- en: If you open the settings for a profile in Windows Terminal, then you can set
    just that profile to run as an administrator. There are lots of other things you
    can do with Windows Terminal. The settings are available through the **user interface**
    (**UI**), or there is a convenient settings file in **JavaScript Object Notation**
    (**JSON**) that you can edit directly.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we have explored cmdlets quite thoroughly. By now, we should
    understand the naming conventions, the syntax that cmdlets use, how to find out
    the parameters a cmdlet takes, and what to put in them. We then looked at some
    ways of discovering new cmdlets and modules, both on our local machine and with
    the PowerShell Gallery. Finally, we discussed working interactively with PowerShell
    and looked at an exciting new application for Windows users; Windows Terminal.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we’re going to take a long hard look at the pipeline; how
    it works, how to string cmdlets together, how to understand what’s gone wrong,
    and what to do about it. We’ll also look at another great application for working
    with PowerShell, and this time everyone can install it, not just Windows users.
  prefs: []
  type: TYPE_NORMAL
- en: Exercises
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Which of these is the correct cmdlet to obtain the contents of a file in PowerShell:
    `Get-Content` or `Read-Content`?'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What happens if you type `"alive alive" | oh` into the shell, and why?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How many parameter sets does the `Get-ChildItem` cmdlet have? Which parameter
    determines which set we will use?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If you see the `Get-ChildItem c:\foo *.exe` cmdlet, you can tell that `c:\foo`
    is an argument being passed to the `-Path` parameter. Which parameter is `*.exe`
    being passed to?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Without actually trying it, will the `Get-ChildItem c:\foo -Filter *.exe, *.txt`
    cmdlet run? If not, why not?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How might you find cmdlets to work with **Amazon Web** **Services** (**AWS**)?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How might you find cmdlets to work with AliCloud?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How could you change the text size in Windows Terminal?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
