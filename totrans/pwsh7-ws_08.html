<html><head></head><body>
		<div id="_idContainer170">
			<h1 id="_idParaDest-158" class="chapter-number"><a id="_idTextAnchor162"/>8</h1>
			<h1 id="_idParaDest-159"><a id="_idTextAnchor163"/>Writing Our First Script – Turning Simple Cmdlets into Reusable Code</h1>
			<p>Starting in this chapter, we’re going to look at how we can put the basic concepts we’ve learned together into scripts and tools that we can reuse, adapt, and distribute for others. In the coming chapters, we’re going to look at creating functions and script blocks, error handling and debugging, creating modules that allow us to distribute our code as tools, and finally, securing PowerShell. In this chapter, though, we’re going to start with the basics: turning a handful of cmdlets into <span class="No-Break">a script.</span></p>
			<p>We’ll start by discussing scripts in general and why we might want to write one. After that, we’ll take a quick look at where we can find PowerShell scripts online, and then we’ll cover how we can <span class="No-Break">run scripts.</span></p>
			<p>Once we understand how to use other people’s scripts, we’ll dive into writing our own. First, we’ll learn how to identify changing values in a working cmdlet pipeline, then we’ll learn how to turn those into parameters so we can pass the values into the cmdlets when we run the script, rather than having to edit the script each time. We’ll cover how to make parameters mandatory, how to take values from the pipeline, and how to create switch parameters, before moving on to cover how to help ourselves and others use <span class="No-Break">our scripts.</span></p>
			<p>In the second part of this chapter, we’ll cover how to add comments and comment blocks to our script that explain what we’re trying to do in each part and help us and others edit and adapt the script. Next, we’ll look at how we can write help information that can be accessed from outside the script using the <strong class="source-inline">Get-Help</strong> cmdlet. After that, we’ll move on to a script construct that can help us understand what is going on when the script is producing unexpected output – the <strong class="source-inline">Write-Verbose</strong> cmdlet. Finally, we’ll cover how to add help messages for mandatory parameters, which will prompt users with information about how to use <span class="No-Break">the parameter.</span></p>
			<p>In this chapter, we are going to cover the following <span class="No-Break">main topics:</span></p>
			<ul>
				<li>Introduction <span class="No-Break">to scripting</span></li>
				<li>Writing <span class="No-Break">a script</span></li>
				<li>Identifying <span class="No-Break">changing values</span></li>
				<li>Working <span class="No-Break">with parameters</span></li>
				<li>Providing help for <span class="No-Break">our script</span></li>
			</ul>
			<h1 id="_idParaDest-160"><a id="_idTextAnchor164"/>Introduction to scripting</h1>
			<p>A script is a sequence<a id="_idIndexMarker572"/> of instructions written in a human-readable form for a computer to carry out. They are usually written in a scripting language such as PowerShell, Python, or JavaScript. We covered the differences between scripting languages and programming languages back in <a href="B17600_01.xhtml#_idTextAnchor013"><span class="No-Break"><em class="italic">Chapter 1</em></span></a>, <em class="italic">Introduction to PowerShell 7 – What It Is and How to Get It</em>; the key thing to remember is that scripting languages are interpreted and so need a program (such as PowerShell) to be running on the client to run the script, whereas programming languages are compiled; they will run directly in the <span class="No-Break">operating system.</span></p>
			<p>Scripting, to me, is an art form. It’s probably the truest cybernetic art form; what we write in a script has to make sense to both human beings and machines. In <a href="B17600_06.xhtml#_idTextAnchor117"><span class="No-Break"><em class="italic">Chapter 6</em></span></a>, <em class="italic">PowerShell and Files – Reading, Writing, and Manipulating Data</em>, we talked about <em class="italic">Exercises in Programming Style</em> by Cristina Videira Lopes, where a term frequency task was solved in dozens of different ways. This is equally true of scripts in PowerShell. There is no one way to write a script, and what seems lovely to one person may be really ugly to another; I have a deep loathing of code golf, where a script is written with as few lines and characters as possible, but that is a personal preference – other people love it. Simplicity, and clean and functional code – these things are beautiful, and it requires a creative and inventive mind to write it. In this chapter, we’re going to cover how I approach <span class="No-Break">writing scripts.</span></p>
			<h2 id="_idParaDest-161"><a id="_idTextAnchor165"/>Why do we want to write scripts?</h2>
			<p>Fundamentally, because <a id="_idIndexMarker573"/>we are lazy. A script allows us to capture a series of steps that may be complicated or time-consuming, and repeat them easily without work. Secondly, because we are fallible and easily distracted. The longer and more complicated a task is, the more likely we are to make a mistake. Writing a script means the task will be completed in the same way every time. If we can get it right once and capture that process, then we almost never need to get it right again. We can go and make our mistakes somewhere else. Finally, because we don’t want to do the thing at all; if we write a script, we can give it to somebody else <span class="No-Break">to do.</span></p>
			<p>Script writing is an example of toolmaking, where we create something to make our task easier to accomplish. Some script writing might be proper automation, but generally, automation includes the concept of a feedback loop, where the tool responds to an external stimulus without user intervention. A central heating boiler is a tool; it makes heating your house much easier than building a fire in each room. A thermostat is automation; when the temperature is too low, it turns the boiler on, and when it is too high, it turns the boiler off. If we’ve set it correctly, then we should never be too warm or <span class="No-Break">too cold.</span></p>
			<p>There is some theory around toolmaking and automation that is worth considering, as it can help us decide <a id="_idIndexMarker574"/>whether we want to write a script or not. Let’s quickly cover the three basic principles <span class="No-Break">of automation:</span></p>
			<ul>
				<li><strong class="bold">Compensatory principle</strong>: This is <a id="_idIndexMarker575"/>based on the concept that <a id="_idIndexMarker576"/>machines are better at some tasks than people, and people are better at some tasks than machines. Automation and tools based on this principle divide work based on the strengths and weaknesses of people <span class="No-Break">and machines.</span></li>
				<li><strong class="bold">Complementarity principle</strong>: Constantly using tools to accomplish difficult tasks can de-skill the<a id="_idIndexMarker577"/> human operator; we forget how to do things. Then, when we really need to take over, when things are going wrong, we can’t fix the problem. We use this principle where the human operator must retain the skills that the automation is replacing. Aircraft autopilots are a good example of this; the operator doesn’t use them all the time or may only use part of them so that they retain the skills they need when the autopilot can’t land the plane because of weather or a <span class="No-Break">mechanical failure.</span></li>
				<li><strong class="bold">Left-over principle</strong>: This is<a id="_idIndexMarker578"/> the principle we most commonly associate with scripting. It’s the idea that we automate everything we can, and then manually do what is <span class="No-Break">left over.</span></li>
			</ul>
			<p>Of course, it’s a little bit more complicated than that. Sometimes, tasks are too hard to automate, or we do them so rarely it’s not worth bothering. We’ll not save any time or effort by writing a script. A rule of thumb is to script anything that will take less time to script than you will spend doing it manually over three years. So, if you have a task that you do every weekday that takes 5 minutes, and it will take you 4 hours to script, then that works out at 62 hours over 3 years. By spending 4 hours scripting it, you’ll save over a week of work for yourself, over 3 years. Let’s start by understanding where we can get scripts that <a id="_idIndexMarker579"/>other people <span class="No-Break">have written.</span></p>
			<h2 id="_idParaDest-162"><a id="_idTextAnchor166"/>Getting scripts</h2>
			<p>We discussed different<a id="_idIndexMarker580"/> places to get PowerShell modules and cmdlets in <a href="B17600_02.xhtml#_idTextAnchor034"><span class="No-Break"><em class="italic">Chapter 2</em></span></a>, <em class="italic">Exploring PowerShell Cmdlets and Syntax</em>. We can use those same places to find PowerShell scripts as well. Let’s just <span class="No-Break">recap them:</span></p>
			<ul>
				<li><strong class="bold">PowerShell repositories</strong>: Whether it’s the official PowerShell repository at <a href="https://www.powershellgallery.com/">https://www.powershellgallery.com/</a>, the Microsoft Learn repository at <a href="https://learn.microsoft.com/en-us/samples/browse/">https://learn.microsoft.com/en-us/samples/browse/</a>, or an internal one, repositories are great places to find scripts. Generally speaking, scripts in the PowerShell Gallery have undergone some minimal validation and will have information about the author, the version, and the license <span class="No-Break">for use.</span></li>
				<li><strong class="bold">GitHub</strong>: This is also a good source for PowerShell scripts, but they’re generally not validated and may not be complete <span class="No-Break">or functional.</span></li>
				<li><strong class="bold">Online elsewhere</strong>: There are very good scripts elsewhere online. For example, the <a id="_idIndexMarker581"/>Practical 365 site (<a href="https://practical365.com">https://practical365.com</a>) has some extremely useful scripts for working with Microsoft 365. However, the quality of online scripts may <span class="No-Break">be variable.</span></li>
			</ul>
			<p>Whenever we get a script from an author we don’t know or trust, we should be careful to understand what the script does and how it does it before running it in an environment we care about. We should do this even when we do trust the author, of course. It is worth <a id="_idIndexMarker582"/>starting a sandbox or virtual machine to test the <span class="No-Break">script first.</span></p>
			<h2 id="_idParaDest-163"><a id="_idTextAnchor167"/>Running scripts</h2>
			<p>There are two things <a id="_idIndexMarker583"/>we need to be aware of before we can run a script. The first is that PowerShell scripts always have an extension of <strong class="source-inline">.ps1</strong>. Files with this extension are not registered as executables, so double-clicking them in Windows Explorer will open them in Notepad or another editor; it won’t run the script. Files with this extension also require a relative or absolute path to run from the PowerShell terminal, so with either <strong class="source-inline">PS C:\myscripts&gt; .\MySuperScript.ps1</strong> (relative path) or <strong class="source-inline">PS C:\&gt; C:\myscripts\MySuperScript.ps1</strong> (absolute path) without the <strong class="source-inline">.\</strong>, the script <span class="No-Break">won’t run.</span></p>
			<p>Secondly, PowerShell has an execution policy for running scripts, but only on Windows computers. By default, on a Windows client, the execution policy is <strong class="source-inline">Restricted</strong>, which means that scripts cannot run. Happily, we can change this for the current user by running the <span class="No-Break">following cmdlet:</span></p>
			<pre class="console">
Set-ExecutionPolicy -ExecutionPolicy RemoteSigned -Scope CurrentUser</pre>			<p>This will allow the current user to run scripts that have been written on the local machine, or scripts downloaded from the internet that include a code signature. We’ll be covering execution policy and code signing in detail in <a href="B17600_12.xhtml#_idTextAnchor236"><span class="No-Break"><em class="italic">Chapter 12</em></span></a>, <em class="italic">Securing PowerShell</em>, but for now, run this cmdlet so that we can get on with writing <span class="No-Break">a script.</span></p>
			<p>If we are using a Linux or Mac client, we don’t need to do this. The policy is effectively <strong class="source-inline">Unrestricted</strong> for those computers because of differences in the way security is implemented in the<a id="_idIndexMarker584"/> Linux and macOS <span class="No-Break">operating systems.</span></p>
			<p>That’s enough introduction; let’s get on with what we’re here for: writing <span class="No-Break">a script.</span></p>
			<h1 id="_idParaDest-164"><a id="_idTextAnchor168"/>Writing a script</h1>
			<p>How do we go <a id="_idIndexMarker585"/>about writing a script? Pretty much every script I write from scratch starts with writing down the steps and cmdlets I need to complete a task. Once I can complete the task with only the information in the list, and all the cmdlets work, I know I am ready. Let’s start our script with a working command. As an example, consider the <span class="No-Break">following cmdlet:</span></p>
			<pre class="console">
Invoke-RestMethod -Uri 'https://api.weatherapi.com/v1/current.json?q=London&amp;aqi=no' -Method GET -Headers @{"key" = "fp3eofkf3-0ef-2kdwpoepwoe03eper30r"}| ConvertTo-Html | Out-File "c:\temp\poshbook\ch8\WeatherData.html"</pre>			<p>This cmdlet gets some weather data for my location from the API service from the Weather API, using a personal key, and writes it to an HTML file for display. Obviously, I’ve not put my real personal key in the preceding cmdlet, so it will fail with an API key error if we run that exact code. Let’s consider how we might turn this cmdlet into a script. To continue, we’ll need to get our own <span class="No-Break">personal key.</span></p>
			<p class="callout-heading">Getting a Personal Key for the Weather API Service</p>
			<p class="callout">To work through this<a id="_idIndexMarker586"/> chapter, we’ll need our own personal key for the Weather <span class="No-Break">API service:</span></p>
			<p class="callout">1. Go to <a href="https://www.weatherapi.com">https://www.weatherapi.com</a> and click the <strong class="bold">Sign </strong><span class="No-Break"><strong class="bold">Up</strong></span><span class="No-Break"> button.</span></p>
			<p class="callout">2. Enter an email address (twice) and a new password (twice), accept the terms and conditions, complete the CAPTCHA, and we will be sent a <span class="No-Break">verification email.</span></p>
			<p class="callout">3. Clicking the link in the verification email will open a web page to tell us that we are verified, and will invite us to <span class="No-Break">log in.</span></p>
			<p class="callout">4. Do this by clicking the login link and entering our email address and the password we have just created. At the top of the next page is our personal API key. This is the key we will use to run <span class="No-Break">this cmdlet.</span></p>
			<p class="callout">5. Copy it and save it in a text file somewhere safe. You can always find it again by logging in to <span class="No-Break">the service.</span></p>
			<p>Now we’ve got a key, let’s <a id="_idIndexMarker587"/>open VS Code and create a new file. Call it <strong class="source-inline">weatherdata.ps1</strong>. Type the following, using the key we’ve just generated from the Weather API instead of <strong class="source-inline">&lt;our new </strong><span class="No-Break"><strong class="source-inline">key here&gt;</strong></span><span class="No-Break">:</span></p>
			<pre class="console">
Invoke-RestMethod -Uri 'https://api.weatherapi.com/v1/current.json?q=London&amp;aqi=no' -Method GET -Headers @{"key" = "&lt;our new key here&gt;"}| ConvertTo-Html | Out-File "c:\temp\poshbook\ch8\WeatherData.html"</pre>			<p>Let’s think about tidying this cmdlet up so that it is more readable. The cmdlet does two things; it gets information from the API, and it outputs that information to a file, so let’s split <span class="No-Break">those up:</span></p>
			<pre class="console">
$response = Invoke-RestMethod -Uri 'https://api.weatherapi.com/v1/current.json?q=London&amp;aqi=no' -Method GET -Headers @{"key" = "&lt;our new key here&gt;"}
$response | Convertto-Html | Out-File "c:\temp\poshbook\ch8\WeatherData.html"</pre>			<p>So now, we are storing the response in a variable and then outputting it in the <span class="No-Break">second line.</span></p>
			<p>How else might we make this more readable? That first cmdlet is very long. We could break out the headers and the URI to make it more readable, as we can see in the <span class="No-Break">following figure:</span></p>
			<div>
				<div id="_idContainer157" class="IMG---Figure">
					<img src="image/B17600_08_001.jpg" alt="Figure 8.1 – Readable code"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 8.1 – Readable code</p>
			<p>If we<a id="_idIndexMarker588"/> save <strong class="source-inline">weatherdata.ps1</strong>, we can now run it from the PowerShell console by switching to the directory we save it in and running the following at <span class="No-Break">the prompt:</span></p>
			<pre class="console">
.\weatherdata.ps1</pre>			<p>While the code is readable, it’s not very flexible. It does one thing, and if we want it to do something slightly different (for instance, produce the data for a different city) or if we want to share it with someone else, we need to make some changes. Let’s look at where we might start <span class="No-Break">with that.</span></p>
			<h1 id="_idParaDest-165"><a id="_idTextAnchor169"/>Identifying changing values</h1>
			<p>Let’s think about<a id="_idIndexMarker589"/> things we might want to<a id="_idIndexMarker590"/> change in this code. We want it to get weather information from the web and write it to a HTML document. This means it’s unlikely that we want to change the <strong class="source-inline">Invoke-RestMethod</strong>, <strong class="source-inline">Convertto-Html</strong>, and <strong class="source-inline">Out-File</strong> cmdlets. Think about what values might change before we <span class="No-Break">move on.</span></p>
			<p><span class="No-Break">Ready? Good.</span></p>
			<p>These are some things that we might want to be able to change the values of when we run <span class="No-Break">the script:</span></p>
			<ul>
				<li>We might want to change <span class="No-Break">the city.</span></li>
				<li>We might want to change where we save the <span class="No-Break">HTML output.</span></li>
				<li>We might want to change the <span class="No-Break">API key.</span></li>
				<li>We might not want to hardcode the API key in the script <span class="No-Break">at all.</span></li>
			</ul>
			<p>We can pass values for these things when we call the script by making them parameters within the script. The next section will be all about parameterizing <span class="No-Break">our script.</span></p>
			<h1 id="_idParaDest-166"><a id="_idTextAnchor170"/>Working with parameters</h1>
			<p>Parameters are values <a id="_idIndexMarker591"/>for script variables that can be passed when we run the script, rather than being hardcoded into the script. As we’ve just seen in the previous section, we run the script in much the same way as we run any other cmdlet, and, as with cmdlets, we can pass parameter values to our script. Let’s look at how we <span class="No-Break">do that.</span></p>
			<p>The first thing we need <a id="_idIndexMarker592"/>is the <strong class="source-inline">CmdletBinding</strong> attribute. Attributes are a way of telling PowerShell how we want it to process the elements of our script. We’ve used them before in <a href="B17600_04.xhtml#_idTextAnchor071"><span class="No-Break"><em class="italic">Chapter 4</em></span></a>, <em class="italic">PowerShell Variables and Data Structures</em>, when we learned how to cast variables. The <strong class="source-inline">CmdletBinding</strong> attribute tells PowerShell that we want it to treat the script as a cmdlet. Some of the big advantages this has are that our script will be able to access common parameters such as <strong class="source-inline">-Verbose</strong>, as well as positional binding. Let’s add it. At the top of our script, create a new line and <span class="No-Break">add this:</span></p>
			<pre class="source-code">
[CmdletBinding()]</pre>			<p>Next, we need to create a <strong class="source-inline">Param()</strong> block to hold the variables we want to use as parameters. On a line directly under the <strong class="source-inline">CmdletBinding</strong> attribute, <span class="No-Break">type this:</span></p>
			<pre class="source-code">
Param()</pre>			<p>The <strong class="source-inline">Param()</strong> block must precede all the code that we’re going to write. We will add our parameters inside the brackets, so it’s best to press <em class="italic">Enter</em> a couple of times inside the brackets so that we have some space to <span class="No-Break">add them:</span></p>
			<pre class="source-code">
[CmdletBinding()]
Param(
)</pre>			<p>Now, we’re ready<a id="_idIndexMarker593"/> to start <span class="No-Break">creating parameters.</span></p>
			<h2 id="_idParaDest-167"><a id="_idTextAnchor171"/>Creating useful parameters</h2>
			<p>The most <a id="_idIndexMarker594"/>useful parameters are values that change. Let’s start with the city we’re getting weather data for. The city is embedded in the <strong class="source-inline">$uri</strong> variable, which is a string. We can easily create a new variable to just hold the city name and pass it to <a id="_idIndexMarker595"/>the <strong class="source-inline">$uri</strong> variable. <span class="No-Break">Try this:</span></p>
			<pre class="source-code">
[CmdletBinding()]
Param(
$City = "London"
)</pre>			<p>And change the <strong class="source-inline">$uri</strong> variable to look <span class="No-Break">like this:</span></p>
			<pre class="source-code">
$uri = "https://api.weatherapi.com/v1/current.json?q=$($City)&amp;aqi=no"</pre>			<p>Remember we need to use double quotes here (<strong class="source-inline">"</strong>) so that the <strong class="source-inline">$City</strong> variable will be expanded. We can check our code against the <span class="No-Break">following figure:</span></p>
			<div>
				<div id="_idContainer158" class="IMG---Figure">
					<img src="image/B17600_08_002.jpg" alt="Figure 8.2 – Adding the CmdletBinding attribute and a param() block"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 8.2 – Adding the CmdletBinding attribute and a param() block</p>
			<p>This will write the value of <strong class="source-inline">$city</strong> into the <strong class="source-inline">$uri</strong> value when we <span class="No-Break">run it.</span></p>
			<p class="callout-heading">Test, Test, Test</p>
			<p class="callout">This is really important; if we make two changes and the script stops working, we will have to work out which change broke the script. Test after every change. Make sure it all still works before moving on to <span class="No-Break">another change.</span></p>
			<p>Let’s test it. From<a id="_idIndexMarker596"/> the console, make sure we’re in the directory where we’ve saved the script, and type <span class="No-Break">the following:</span></p>
			<pre class="console">
.\WeatherData.ps1 -City Paris</pre>			<p>Now, check the <strong class="source-inline">WeatherData.html</strong> file. It should look <span class="No-Break">like this:</span></p>
			<div>
				<div id="_idContainer159" class="IMG---Figure">
					<img src="image/B17600_08_003.jpg" alt="Figure 8.3 – Welcome to beautiful Paris"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 8.3 – Welcome to beautiful Paris</p>
			<p>If this has worked for you, congratulations! You have parameterized your first script. Let’s look at what <span class="No-Break">we’ve done.</span></p>
			<p>By putting the <strong class="source-inline">$City</strong> variable into the <strong class="source-inline">Param()</strong> block, we’ve made it accessible from outside the script so that we can pass values to it when we run the script. By assigning a value to the variable, writing <strong class="source-inline">$City = "London"</strong>, we’ve set a default value so that if we don’t pass a value via a parameter, the script will <span class="No-Break">still run.</span></p>
			<p>We can put as many variables as we like in the <strong class="source-inline">Param()</strong> block, but we must separate each one with a comma (<strong class="source-inline">,</strong>). Let’s do another one; try the <span class="No-Break">following activity.</span></p>
			<p class="callout-heading">Activity 1</p>
			<p class="callout">How might we pass the location where we want to save the output? And how might we make that as easy <span class="No-Break">as possible?</span></p>
			<p class="callout">Hint: if we pass just a filename, it will save the output in the same location as the script is running from. Would we want that <span class="No-Break">every time?</span></p>
			<p>Let’s look at what <a id="_idIndexMarker597"/>we could do with the key. Keys are a long string of random characters, so it’s not going to be practical to type that into a parameter. How might we get <span class="No-Break">around this?</span></p>
			<p>We could save the key to a file, and then use <strong class="source-inline">Get-Content</strong> to extract the string from the file and use it that way. In <a href="B17600_07.xhtml#_idTextAnchor140"><span class="No-Break"><em class="italic">Chapter 7</em></span></a>, <em class="italic">PowerShell and the Web – HTTP, REST, and JSON</em> we saw there are two ways of passing a key to <strong class="source-inline">Invoke-RestMethod</strong>. We can either pass it to the <strong class="source-inline">-Key</strong> parameter or include it in the <strong class="source-inline">-Headers</strong> parameter, as we are doing in this script. The important difference is that in one scenario the key must be encoded, and in the other, it must be plain text. Can you remember which is which? Look back to the last chapter to <span class="No-Break">find out.</span></p>
			<p>If you remembered, well done. If you worked it out from how our script currently works, even better. We’re already passing an unencoded string in the header, so we don’t need to encode our key before <span class="No-Break">saving it.</span></p>
			<p>Open a new text document using your preferred text editor and save it as <strong class="source-inline">key.txt</strong> in the same folder as the script – in my case, <strong class="source-inline">c:\temp\poshbook\ch8</strong>. Copy and paste your <strong class="source-inline">WeatherApi</strong> key into it and <span class="No-Break">save it.</span></p>
			<p>Now all we need to do is add a parameter that points to the file, and a line that gets the content from the file. Then, we can add that to the <strong class="source-inline">$headers</strong> variable. It might look something <span class="No-Break">like this:</span></p>
			<pre class="source-code">
[CmdletBinding()]
Param(
$City = "London",
$KeyFile = "key.txt"
)
$key = Get-Content $KeyFile
$headers = @{"key" = "$key"}</pre>			<p>We’ve identified our changing values and created <span class="No-Break">our parameters.</span></p>
			<p class="callout-heading">Activity 2</p>
			<p class="callout">Knowing what we know from previous chapters, how might we rewrite our script so that we can accept multiple values for the <strong class="source-inline">-</strong><span class="No-Break"><strong class="source-inline">City</strong></span><span class="No-Break"> parameter?</span></p>
			<p class="callout">Hint 1: Look at a help file for a cmdlet that accepts multiple strings in a parameter to see how we could write an attribute for the <strong class="source-inline">-City</strong> parameter. <strong class="source-inline">Get-Random</strong> accepts multiple objects <span class="No-Break">for </span><span class="No-Break"><strong class="source-inline">-InputObject</strong></span><span class="No-Break">.</span></p>
			<p class="callout">Hint 2: We’re going to want a way of processing each string in turn. Remember, multiple strings passed into a parameter are <span class="No-Break">an array.</span></p>
			<p class="callout">Hint 3: We’re going to want to send each city to a <span class="No-Break">different output.</span></p>
			<p>Let’s look at <a id="_idIndexMarker598"/>how we might improve them <span class="No-Break">using attributes.</span></p>
			<h2 id="_idParaDest-168"><a id="_idTextAnchor172"/>Specifying type</h2>
			<p>We can limit the<a id="_idIndexMarker599"/> possibility of errors by specifying the type of the parameter in the same way as we specify the type of a variable, by typing the attribute before the variable. In your script, replace the <strong class="source-inline">$City = "London"</strong> line <span class="No-Break">with this:</span></p>
			<pre class="console">
[String]$City = "London"</pre>			<p>Now, whatever we pass in the <strong class="source-inline">-City</strong> parameter will be cast to <span class="No-Break">a string.</span></p>
			<h2 id="_idParaDest-169"><a id="_idTextAnchor173"/>Making parameters mandatory</h2>
			<p>We might want<a id="_idIndexMarker600"/> our <a id="_idIndexMarker601"/>script to require an explicit value for the <strong class="source-inline">–City</strong> parameter each time we run it. We could do that by changing the <strong class="source-inline">-City</strong> parameter <span class="No-Break">like this:</span></p>
			<pre class="source-code">
[CmdletBinding()]
Param(
[Parameter(Mandatory = $true)]
$City = "London"
)</pre>			<p>We’ve added the line <strong class="source-inline">[Parameter(Mandatory = $true)]</strong> before the <strong class="source-inline">$City</strong> parameter. Note that there is no comma (<strong class="source-inline">,</strong>) after the attribute. Now we’ve done that, the script ignores the default value for the parameter (<strong class="source-inline">"London"</strong>), and it prompts for <span class="No-Break">a city:</span></p>
			<div>
				<div id="_idContainer160" class="IMG---Figure">
					<img src="image/B17600_08_004.jpg" alt="Figure 8.4 – Mandatory parameters"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 8.4 – Mandatory parameters</p>
			<p>In the figure, we can see that because we didn’t include a value for the <strong class="source-inline">-City</strong> parameter, we get prompted. One of the most useful things we can do with a script is to make it accept parameter values from the pipeline. Let’s have a look at how we can <span class="No-Break">do that.</span></p>
			<h2 id="_idParaDest-170"><a id="_idTextAnchor174"/>Taking values from the pipeline</h2>
			<p>We covered how <a id="_idIndexMarker602"/>parameters can take values from the pipeline in <a href="B17600_03.xhtml#_idTextAnchor049"><span class="No-Break"><em class="italic">Chapter 3</em></span></a>, <em class="italic">The PowerShell Pipeline – How to String Cmdlets Together</em>. In this section, we’re going to see how easy it is to make our script accept pipeline values. Remember, there are two ways that a parameter can take values from the pipeline: <strong class="source-inline">ByValue</strong> and <strong class="source-inline">ByName</strong>. For our script, it would be best if we let the <strong class="source-inline">-City</strong> parameter accept pipeline input by value, so let’s <span class="No-Break">do this:</span></p>
			<pre class="source-code">
[CmdletBinding()]
Param(
[Parameter(ValueFromPipeline)]
$City = "London",</pre>			<p>All we’ve done is add the line <strong class="source-inline">[Parameter(ValueFromPipeline)]</strong> to the <strong class="source-inline">Param()</strong> block. We can see the difference it makes in the <span class="No-Break">following figure:</span></p>
			<div>
				<div id="_idContainer161" class="IMG---Figure">
					<img src="image/B17600_08_005.jpg" alt="Figure 8.5 – Accepting values from the pipeline"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 8.5 – Accepting values from the pipeline</p>
			<p>In the first example, we can see that we’ve created a string, <strong class="source-inline">"cwmbran"</strong>, and tried to pass it through the pipeline to the script. The script doesn’t accept values from the pipeline, and we <a id="_idIndexMarker603"/>get an error message in red telling us just that. If we then alter the <strong class="source-inline">-City</strong> parameter to accept values from the pipeline, we can see the script completing without error in the <span class="No-Break">second example.</span></p>
			<p>Let’s see what happens if we try feeding two values into the script through the pipeline, as in <span class="No-Break">this example:</span></p>
			<pre class="console">
"Manila","Cardiff" | .\weatherdata.ps1</pre>			<p>We will only get an output for the last item. To make this work properly, we need to include the part of the script we want to repeat for each item in a <strong class="source-inline">process {}</strong> block, <span class="No-Break">like this:</span></p>
			<div>
				<div id="_idContainer162" class="IMG---Figure">
					<img src="image/B17600_08_006.jpg" alt="Figure 8.6 – Making pipeline input work properly"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 8.6 – Making pipeline input work properly</p>
			<p>I’m opening a <strong class="source-inline">process {}</strong> block on line <strong class="source-inline">44</strong>, and then closing it on line <strong class="source-inline">61</strong>. I can now feed multiple cities into the pipeline and get an HTML file for each of them, <span class="No-Break">like this:</span></p>
			<pre class="console">
"Bristol", "Brighton" | .\weatherdata.ps1</pre>			<p>Note that doesn’t <a id="_idIndexMarker604"/>mean we can get rid of the <strong class="source-inline">foreach</strong> loop from <em class="italic">Activity 2</em> entirely, though. If we pass multiple cities explicitly using the <strong class="source-inline">-City</strong> parameter, we will still need to process them individually with <span class="No-Break">a loop.</span></p>
			<p>There are lots of other things we can do with parameters, which are detailed in the article <span class="No-Break">here: </span><a href="https://learn.microsoft.com/en-us/powershell/scripting/lang-spec/chapter-12"><span class="No-Break">https://learn.microsoft.com/en-us/powershell/scripting/lang-spec/chapter-12</span></a><span class="No-Break">.</span></p>
			<p>Many of them can be used to validate the parameter input: making sure that it is the correct type, or<a id="_idIndexMarker605"/> even selecting input from a list of <span class="No-Break">accepted values.</span></p>
			<h2 id="_idParaDest-171"><a id="_idTextAnchor175"/>Switch parameters</h2>
			<p>There’s one last<a id="_idIndexMarker606"/> feature of parameters we should talk about before moving on: switch parameters. Many of the cmdlets we’ve been using have parameters that act as switches; they don’t take a value, they just have to be present to change the behavior of the cmdlet. For example, using<a id="_idIndexMarker607"/> the <strong class="source-inline">-Full</strong> parameter in <strong class="source-inline">Get-Help</strong> changes the amount of help information that is returned. We can do that in our script too. Try this – after the <strong class="source-inline">param()</strong> block, add the <span class="No-Break">following lines:</span></p>
			<pre class="source-code">
If ($Joke.IsPresent) {
Write-Output "Why did the chicken cross the road?"
}</pre>			<p>Then on the last line of the <strong class="source-inline">param()</strong> block, add the following line before the closing parenthesis. Remember, you will also need to add a comma after the <span class="No-Break">previous parameter:</span></p>
			<pre class="console">
[switch] $Joke</pre>			<p>The following figure shows how it looks in my script and shows the output when we use our <a id="_idIndexMarker608"/>new <strong class="source-inline">-</strong><span class="No-Break"><strong class="source-inline">Joke</strong></span><span class="No-Break"> parameter:</span></p>
			<div>
				<div id="_idContainer163" class="IMG---Figure">
					<img src="image/B17600_08_007.jpg" alt="Figure 8.7 – Only joking"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 8.7 – Only joking</p>
			<p>In line <strong class="source-inline">40</strong>, I’ve added a comma after the parameter, so PowerShell knows there’s another parameter <a id="_idIndexMarker609"/>coming. I’ve added the new <strong class="source-inline">-Joke</strong> switch parameter in line <strong class="source-inline">41</strong>, and then on lines <strong class="source-inline">44</strong>-<strong class="source-inline">46</strong>, I’ve added an <strong class="source-inline">If</strong> statement to tell PowerShell what to do if the switch is present. Finally, I’ve used the switch in the terminal at the bottom when I called the script, and the script told me the best joke in the world. <span class="No-Break">Simple, huh?</span></p>
			<p>Note that when we’re looking at other people’s scripts on the internet, we may well see a different construction for switch parameters. Instead of using <strong class="source-inline">If ($Joke.IsPresent)</strong>, we will often see <strong class="source-inline">If ($Joke -eq $true)</strong>. While this will work, it’s a much older way of doing things and could be confusing. Using the <strong class="source-inline">.IsPresent</strong> method of the parameter is the way <span class="No-Break">Microsoft recommends.</span></p>
			<p>We’ll be using <a id="_idIndexMarker610"/>parameters a lot as we go through the rest of the book, but for now, let’s look at the other main topic of this chapter, providing help in <span class="No-Break">our scripts.</span></p>
			<h1 id="_idParaDest-172"><a id="_idTextAnchor176"/>Providing help for our script</h1>
			<p>Writing scripts is great<a id="_idIndexMarker611"/> fun, and we learn new things every time we write one. We include the new techniques or shortcuts, finish the script, put it to work, and then forget about it. The next time we look at it might be months or even years later, by which time we might well have forgotten how it works or why we wrote it the way we did. The answer to this is to write comprehensive help for the script, explaining how our script works and how to use it. This is even more important for scripts that we make available for other people <span class="No-Break">to use.</span></p>
			<p>In this section, we’re going to cover four ways of providing help. First, we’re going to briefly look at how we can comment our code to help ourselves and others. After that, we’ll look at creating comment-based help for use with the <strong class="source-inline">Get-Help</strong> cmdlet. Then, we’re going to look at the <strong class="source-inline">Write-Verbose</strong> cmdlet, and how we can use it to understand what the script is doing. Finally, we’ll look at how we can provide help for <span class="No-Break">mandatory parameters.</span></p>
			<p>Let’s start with commenting <span class="No-Break">our code.</span></p>
			<h2 id="_idParaDest-173"><a id="_idTextAnchor177"/>Comments</h2>
			<p>We briefly mentioned <a id="_idIndexMarker612"/>comments in <a href="B17600_05.xhtml#_idTextAnchor096"><span class="No-Break"><em class="italic">Chapter 5</em></span></a>, <em class="italic">PowerShell Control Flow – Conditionals and Loops</em>. We saw that a single line may be turned into a comment by adding a hash at the start (<strong class="source-inline">#</strong>), and we could create multiline comments by enclosing a body of text like this: <strong class="source-inline">&lt;# … #&gt;</strong>. However, we didn’t really talk about why comments are useful. PowerShell is a scripting language – a particularly friendly one, in my opinion. Most of the time, it is reasonably obvious to someone who knows the language what a line of code will do, but a line of explanation means that we don’t need to parse each line to know what was intended. And, of course, what we write doesn’t always do what we intend. A comment that records what we want the line to do makes our lives a lot easier when we’re digging through four or five hundred lines of code. When the script is being adapted by somebody else, comments are invaluable. Have a look at the <span class="No-Break">example below:</span></p>
			<pre class="source-code">
# concatenate the strings to produce an output filename
$Output = "$($OutputPath)\$($item)_$($OutputFile)"</pre>			<p>The comment line tells us exactly what the slightly unreadable code is hopefully going <span class="No-Break">to achieve.</span></p>
			<h3>Comment blocks</h3>
			<p>Comments are<a id="_idIndexMarker613"/> intended to be read in an editor of some sort. To make them easier to read, we will want to split a long comment across multiple lines. We could use the backtick character (<strong class="source-inline">`</strong>) to escape manual line breaks, but that doesn’t really make it easier to read, particularly for some editors and some fonts. It’s better to use the blockquote construct, <strong class="source-inline">&lt;#...#&gt;</strong>. Have a look at the <span class="No-Break">following figure:</span></p>
			<div>
				<div id="_idContainer164" class="IMG---Figure">
					<img src="image/B17600_08_008.jpg" alt="Figure 8.8 – Comment blocks"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 8.8 – Comment blocks</p>
			<p>The comment block is in green and explains the intention of the following lines. Let’s have a look at some dos and don’ts for writing <span class="No-Break">good comments:</span></p>
			<ul>
				<li>Comment on a separate line; adding a comment on the same line makes the line either too long or causes it to wrap in <span class="No-Break">the editor.</span></li>
				<li>Comment before the line you’re explaining; prepare the reader for what’s coming next in the script, not <span class="No-Break">what’s been.</span></li>
				<li>Don’t comment on the obvious; generally speaking, too many comments are better than too few but don’t waste your time explaining things that don’t need it. Better to comment what a block of simple lines does than each <span class="No-Break">individual line.</span></li>
			</ul>
			<p>Let’s look at how <a id="_idIndexMarker614"/>we can provide help for our script with the <span class="No-Break"><strong class="source-inline">Get-Help</strong></span><span class="No-Break"> cmdlet.</span></p>
			<h2 id="_idParaDest-174"><a id="_idTextAnchor178"/>Comment-based help</h2>
			<p>The <strong class="source-inline">Get-Help</strong> cmdlet<a id="_idIndexMarker615"/> reads XML help files included with the main PowerShell program, and for modules and functions that have them. However, it can also read correctly formatted comments embedded in a script. This is <a id="_idIndexMarker616"/>called <strong class="bold">comment-based help</strong>. We can write comment-based help by adding special help comment keywords at the start of <span class="No-Break">our script.</span></p>
			<p>There are a number of rules to remember about writing <span class="No-Break">comment-based help:</span></p>
			<ul>
				<li>It must be either <a id="_idIndexMarker617"/>at the start or the end of a script. For a couple of reasons, including the best practices for comments we covered previously, we should put it at <span class="No-Break">the start.</span></li>
				<li>Comment-based help must be contiguous. We can’t split it up into different <span class="No-Break">comment blocks.</span></li>
				<li>Each section of the help must start with a legitimate keyword. The keyword is not case-sensitive, but it must be preceded by a <span class="No-Break">dot (</span><span class="No-Break"><strong class="source-inline">.</strong></span><span class="No-Break">).</span></li>
				<li>There must be two blank lines after the <span class="No-Break">comment-based help.</span></li>
			</ul>
			<p>Luckily, VS Code makes writing comment-based help a breeze. Let’s see <span class="No-Break">it working.</span></p>
			<p>In our script, create a new line at the start of the script, and type <strong class="source-inline">comm</strong>. As we can see in the following figure, VS Code will offer us the <strong class="source-inline">comment-help</strong> function helper if we have the PowerShell <span class="No-Break">extension installed.</span></p>
			<div>
				<div id="_idContainer165" class="IMG---Figure">
					<img src="image/B17600_08_009.jpg" alt="Figure 8.9 – The comment-help function in VS Code"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 8.9 – The comment-help function in VS Code</p>
			<p>Go ahead and select it. VS Code will create a comment-based help template for us with the most commonly used keywords, correctly formatted, and even add the two blank lines after the block <span class="No-Break">for us.</span></p>
			<p>Let’s have a look at the <a id="_idIndexMarker618"/><span class="No-Break">common sections:</span></p>
			<ul>
				<li><strong class="source-inline">.SYNOPSIS</strong>: This section should be one line that summarizes what the <span class="No-Break">script does.</span></li>
				<li><strong class="source-inline">.DESCRIPTION</strong>: This is where we put the full description, including how it works, what it should be used for, different ways to use it, and <span class="No-Break">so on.</span></li>
				<li><strong class="source-inline">.NOTES</strong>: This is where we should put warnings about incompatibilities, prerequisites for running the script (for instance, that we need to have a <strong class="source-inline">weatherapi</strong> key saved to a text file), and any other useful information that doesn’t fit in <span class="No-Break">the description.</span></li>
				<li><strong class="source-inline">.LINK</strong>: This will provide a link for <strong class="source-inline">Get-Help -Online</strong> to consume. Personally, I never use it and delete it from the <span class="No-Break">help section.</span></li>
				<li><strong class="source-inline">.EXAMPLE</strong>: We can put examples of usage here to explain how to use the parameters. Separate each example with a new <strong class="source-inline">.EXAMPLE</strong> keyword on a <span class="No-Break">new line.</span></li>
			</ul>
			<p>I’ll admit, the first time I did this, it was a real thrill seeing my script help looking like the real thing. It doesn’t <span class="No-Break">get old:</span></p>
			<div>
				<div id="_idContainer166" class="IMG---Figure">
					<img src="image/B17600_08_010.jpg" alt="Figure 8.10 – Retrieving comment-based help for a script"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 8.10 – Retrieving comment-based help for a script</p>
			<p>This works just like anything else with <strong class="source-inline">Get-Help</strong>. To see the notes, type <strong class="source-inline">Get-Help .\weatherdata.ps1 -Detailed</strong>. To get everything, use the <strong class="source-inline">-</strong><span class="No-Break"><strong class="source-inline">Full</strong></span><span class="No-Break"> parameter.</span></p>
			<p class="callout-heading">Activity 3</p>
			<p class="callout">Write a short comment-based help for the script. Test it by calling <strong class="source-inline">Get-Help .\weatherdata.ps1</strong> from <span class="No-Break">the console.</span></p>
			<p>That’s it for<a id="_idIndexMarker619"/> comment-based help. It’s incredibly useful, whether we read it in the editor or using the <strong class="source-inline">Get-Help</strong> cmdlet. I recommend we use it as often as we can. Let’s look at something else now, that isn’t strictly help, but is definitely helpful: the <span class="No-Break"><strong class="source-inline">Write-Verbose</strong></span><span class="No-Break"> cmdlet.</span></p>
			<h2 id="_idParaDest-175"><a id="_idTextAnchor179"/>Write-Verbose</h2>
			<p>Back in <a href="B17600_03.xhtml#_idTextAnchor049"><span class="No-Break"><em class="italic">Chapter 3</em></span></a>, <em class="italic">The PowerShell Pipeline – How to String Cmdlets Together</em>, we talked briefly about the standard streams: output <a id="_idIndexMarker620"/>streams that exist in most programming <a id="_idIndexMarker621"/>languages and classify and direct output. The verbose stream is one of them and is intended for messages that help users understand what a cmdlet is doing. It’s particularly useful for troubleshooting long-running cmdlets that don’t appear to be doing anything. Every PowerShell cmdlet has a <strong class="source-inline">-Verbose</strong> switch parameter that allows us to see what the cmdlet is doing and whether it’s got stuck, although not all of them produce a verbose stream output. We can see this in action already in our script because the <strong class="source-inline">Invoke-RestMethod</strong> cmdlet has a particularly useful verbose output. <span class="No-Break">Try this:</span></p>
			<pre class="console">
.\weatherdata.ps1 -Verbose</pre>			<p>You should see something like the <span class="No-Break">following figure:</span></p>
			<div>
				<div id="_idContainer167" class="IMG---Figure">
					<img src="image/B17600_08_011.jpg" alt="Figure 8.11 – Verbose output from inside our script"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 8.11 – Verbose output from inside our script</p>
			<p>We’re able to access this verbose output because we have used the <strong class="source-inline">CmdletBinding()</strong> attribute at the start of the script, which gives us access to advanced functions. Without it, we can call the <strong class="source-inline">-Verbose</strong> parameter without an error, but it <a id="_idIndexMarker622"/>won’t <a id="_idIndexMarker623"/>produce <span class="No-Break">any output.</span></p>
			<p>We can do even more than this, though; we can write our own verbose stream messages with the <strong class="source-inline">Write-Verbose</strong> cmdlet. Why is this useful? Because when we are processing many items in a loop in our script, it can tell us which item in the loop is failing. Let’s say we ask our script to produce the data for three cities <span class="No-Break">as follows:</span></p>
			<pre class="console">
.\weatherdata.ps1 -City "London", "Paris", "Llareggub"</pre>			<p>Then, we’ll get an error saying that when <strong class="source-inline">Invoke-RestMethod</strong> ran, a matching location couldn’t be found, but the line of code that threw the error is <span class="No-Break">as follows:</span></p>
			<pre class="source-code">
Invoke-RestMethod -Uri $uri -Method GET -Headers $headers</pre>			<p>So it could be any of the cities that <span class="No-Break">doesn’t exist.</span></p>
			<p>We can fix this by changing the start of the <span class="No-Break"><strong class="source-inline">foreach</strong></span><span class="No-Break"> loop:</span></p>
			<pre class="source-code">
foreach ($item in $City) {
    Write-Verbose "Processing $item"
    $Output = "$($OutputPath)\$($item)_$($OutputFile)"</pre>			<p>We’ve added the line <strong class="source-inline">Write-Verbose "Processing $Item"</strong> at the start of the loop, which means that if we use the <strong class="source-inline">-Verbose</strong> parameter now, the script tells us which city it’s processing, and we can see which of our cities is fictitious, as in the <span class="No-Break">following figure:</span></p>
			<div>
				<div id="_idContainer168" class="IMG---Figure">
					<img src="image/B17600_08_012.jpg" alt="Figure 8.12 – Using Write-Verbose to illuminate the Bible-black"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 8.12 – Using Write-Verbose to illuminate the Bible-black</p>
			<p>When we run the script in the first line, all we see is the error, but when we run it with the <strong class="source-inline">-Verbose</strong> parameter, it<a id="_idIndexMarker624"/> tells<a id="_idIndexMarker625"/> us which city it was processing when it encountered the error. Let’s look at the final type of help we’ll cover in this chapter: parameter <span class="No-Break">help messages.</span></p>
			<h2 id="_idParaDest-176"><a id="_idTextAnchor180"/>Parameter help messages</h2>
			<p>As well as controlling<a id="_idIndexMarker626"/> how parameters work in a script, we can also write helpful comments to guide people in using parameters in our scripts. These comments only apply to mandatory comments and are available if the mandatory parameter isn’t provided. Let’s try it. Edit the <strong class="source-inline">$City</strong> parameter <span class="No-Break">like this:</span></p>
			<pre class="source-code">
Param(
[Parameter(Mandatory, HelpMessage="Enter one or more city names separated by commas")]
[string[]]$City = "London",</pre>			<p>Now, when we run it without supplying a value for the <strong class="source-inline">$City</strong> parameter, we get a message suggesting we type an interrobang (<strong class="source-inline">!?</strong>) <span class="No-Break">for help:</span></p>
			<div>
				<div id="_idContainer169" class="IMG---Figure">
					<img src="image/B17600_08_013.jpg" alt="Figure 8.13 – Accessing the HelpMessage parameter"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 8.13 – Accessing the HelpMessage parameter</p>
			<p>Once we type the interrobang, the message we wrote in the script is presented. It’s as easy as that; just remember that we can only use parameter help messages with <span class="No-Break">mandatory</span><span class="No-Break"><a id="_idIndexMarker627"/></span><span class="No-Break"> parameters.</span></p>
			<p>That about wraps it up for this chapter. Let’s review what <span class="No-Break">we’ve learned.</span></p>
			<h1 id="_idParaDest-177"><a id="_idTextAnchor181"/>Summary</h1>
			<p>In this chapter, we’ve moved on from learning the building blocks of PowerShell syntax, and now we’re beginning to put things together. The techniques we’ve learned may not be familiar to us, but with time and practice, they will become familiar and easy. As we go through the rest of the book, we will have plenty of opportunities to <span class="No-Break">use them.</span></p>
			<p>We started by talking about what scripts are and why we might want to write scripts at all. We looked briefly at where we can find other people’s scripts, and what we need to do to run them on <span class="No-Break">our machines.</span></p>
			<p>We’ve done a lot of practical work in this chapter. Firstly, we looked at how we might make it easier for people to read what we’re doing by breaking long pipelines up and substituting variables for hardcoded values in cmdlets, particularly values that <span class="No-Break">might change.</span></p>
			<p>We moved on to look at how we could pass those values into the script from outside using parameters, and we looked at various ways we could define and manipulate those parameters by making them mandatory or taking values from <span class="No-Break">the pipeline.</span></p>
			<p>We then looked at how we could make our scripts more easily understood by providing comments, before creating full-blown comment-based help for them, so that we can use the <span class="No-Break"><strong class="source-inline">Get-Help</strong></span><span class="No-Break"> cmdlet.</span></p>
			<p>After that, we looked at using the <strong class="source-inline">Write-Verbose</strong> cmdlet to provide verbose output. This helps us understand what our script is doing when it doesn’t seem to be working as <span class="No-Break">we hoped.</span></p>
			<p>Finally, we looked at providing help messages for mandatory parameters to make it easier for people to run <span class="No-Break">our scripts.</span></p>
			<p>In the next chapter, we’re going to look at how we can make our code simpler and easier to write using script blocks, lambdas, <span class="No-Break">and functions.</span></p>
			<h1 id="_idParaDest-178"><a id="_idTextAnchor182"/>Further reading</h1>
			<ul>
				<li>Output <span class="No-Break">streams: </span><span class="No-Break">https://learn.microsoft.com/en-us/powershell/module/microsoft.powershell.core/about/about_output_streams</span></li>
				<li>Some automation <span class="No-Break">theory: </span><span class="No-Break">https://poshidiot.wordpress.com/2018/06/12/how-do-i-know-what-to-automate/</span></li>
				<li><em class="italic">The Practice of Cloud System Administration</em>, Limoncelli, T., Hogan, C., and Chalup, S. (2017) Boston: Addison-Wesley, <a href="B17600_12.xhtml#_idTextAnchor236"><span class="No-Break"><em class="italic">Chapter 12</em></span></a><span class="No-Break">.</span></li>
				<li><em class="italic">Time Management for System Administrators</em>, Sebastopol: Limoncelli, T. (2008), O’Reilly Media, Inc., <a href="B17600_13.xhtml#_idTextAnchor267"><span class="No-Break"><em class="italic">Chapter 13</em></span></a><span class="No-Break">.</span></li>
				<li><em class="italic">Why the Fitts list has persisted throughout the history of function allocation</em>: de Winter, J. C. F., and Dodou, D. (2014), Journal of Cognition, Technology &amp; <span class="No-Break">Work</span></li>
				<li>Learn more about attributes and <span class="No-Break">parameters: </span><span class="No-Break">https://learn.microsoft.com/en-us/powershell/scripting/lang-spec/chapter-12</span></li>
			</ul>
			<h1 id="_idParaDest-179"><a id="_idTextAnchor183"/>Exercises</h1>
			<ol>
				<li>On attempting to run a script we’ve written, another user on our machine gets an error message that says <strong class="source-inline">running scripts is disabled on this system</strong>. What do we have to do to allow them to run <span class="No-Break">the script?</span></li>
				<li>We have a young relative who loves <em class="italic">Dungeons and Dragons</em>, but they’ve lost their 20-sided die. We write a short PowerShell script for them, <strong class="source-inline">Get-Die.ps1</strong>, <span class="No-Break">as follows:</span><pre class="source-code">
Get-Random -Minimum 1 -Maximum 20</pre><p class="list-inset">This will produce a random number between 1 and 20 every time it is run. Which value in this line of code is most likely to change if they lose another die with a different number <span class="No-Break">of sides?</span></p></li>				<li>In the <strong class="source-inline">Get-Die.ps1</strong> script from the previous question, how would we parameterize the <span class="No-Break">changing value?</span></li>
				<li>What type of parameter should it be, and how would we <span class="No-Break">specify it?</span></li>
				<li>They like the script, and now they’ve lost their four-sided die. They’ve discovered that they can put any number they like into the parameter. While this was quite cool at first, now they want the script to only let them roll the dice that are used in the game. How could we do that? We need to know that <em class="italic">Dungeons and Dragons</em> uses 4-, 6-, 8-, 10-, 12-, and 20-sided dice, and we’ll also need to read the link about parameters given in <span class="No-Break">the text.</span></li>
				<li>Our relative explains that sometimes they need to roll more than one die of the same type at a time and asks whether there is a way to do this. Well, of course there is… let’s write it <span class="No-Break">for them.</span></li>
				<li>They’ve noticed that sometimes they forget to put the number of dice in, and they get a total of 0. How could we stop that <span class="No-Break">from happening?</span></li>
				<li>We’re not always going to be around, and sometimes they aren’t sure what to put in the parameters. How could we make it easier <span class="No-Break">for them?</span></li>
				<li>They are really trying our patience. Every now and then, they need to roll something they call a d100. This is a 10-sided die, with numbers going up in tens: 0, 10, 20, 30, and so on, plus a roll of a normal 10-sided die, which added together gives them a number between 1 and 100. Promising ourselves we’ll never babysit for them again, how do we <span class="No-Break">do that?</span></li>
			</ol>
		</div>
	</body></html>