- en: Performing Routine Maintenance with Ansible
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As you have worked through this book, you will have completed many steps to
    define and build a Linux environment for your enterprise that supports automation.
    However, Ansible's assistance with your environment does not end here. Even an
    environment that has been built and is in active use requires maintenance and
    intervention from time to time. Historically, these interventions would have been
    performed manually by system administrators, using shell commands or scripts.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
- en: As we have discussed many times throughout this book, tasks that are run by
    hand present a number of challenges for the enterprise—not least that they may
    not be well documented, and hence there is a steep learning curve for new members
    of staff. In addition, our old friends auditability and repeatability come into
    play—how can you be sure of who did what, and when, if everyone is logging on
    to the shell of your Linux machines and performing tasks by hand?
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we explore the ways in which Ansible can assist the enterprise
    with the day-to-day management of the Linux estate and, especially, in performing
    routine maintenance tasks. Ansible is extremely powerful, and your possibilities
    for routine maintenance are not limited to the examples in this chapter—rather,
    they are intended to get you started, and show by example the kinds of tasks you
    may be able to automate.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
- en: 'Specifically, we will cover the following topics in this chapter:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
- en: Tidying up disk space
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Monitoring for configuration drift
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Managing processes with Ansible
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Rolling updates with Ansible
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This chapter includes examples, based on the following technologies:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
- en: Ubuntu Server 18.04 LTS
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: CentOS 7.6
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Ansible 2.8
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To run through these examples, you will need access to two servers or virtual
    machines running one each of the operating systems just listed, and also Ansible.
    Note that the examples given in this chapter may be destructive in nature (for
    example, they delete files, and make changes to server configuration), and if
    run as is, are only intended to be run in an isolated test environment.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
- en: Once you are satisfied that you have a safe environment in which to operate,
    let's get started with routine system maintenance, with Ansible.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
- en: All example code discussed in this chapter is available from GitHub, at the
    following URL: [https://github.com/PacktPublishing/Hands-On-Enterprise-Automation-on-Linux/tree/master/chapter12](https://github.com/PacktPublishing/Hands-On-Enterprise-Automation-on-Linux/tree/master/chapter12).
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
- en: Tidying up disk space
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One of the most routine and mundane (and yet, vitally important) tasks that
    a system administrator has to complete on a routine basis is clearing out disk
    space. Although ideally, systems should be well behaved—for example, log files
    should be rotated, and temporary files cleaned up—those with experience in the
    industry will know that this is not always the case. The author of this book has
    worked in environments where clearing out a given directory was considered a routine
    task—hence, a prime candidate for automation.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 系统管理员需要定期完成的最常规、最琐碎（但却至关重要）任务之一就是清理磁盘空间。尽管理想情况下，系统应该是良好运作的——例如，日志文件应该进行轮换，临时文件应该被清理——但是在这个行业有经验的人都会知道，情况并不总是如此。本书的作者曾在一些环境中工作，在这些环境中，清理某个特定目录被视为常规任务——因此，它是自动化的最佳候选项。
- en: 'Of course, you would not just randomly delete files from a filesystem. Any
    task like this should be performed in a precise manner. Let''s proceed with a
    practical example—as this is hypothetical, let''s create some test files to work
    with. Suppose our fictional application creates a data file every day, and never
    prunes its `data` directory. To synthesize this, we might create some data files,
    as follows:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，你不会随便从文件系统中删除文件。任何这样的任务都应该以精确的方式执行。让我们来看一个实际的例子——由于这是假设的，我们来创建一些测试文件。假设我们的虚构应用每天都会创建一个数据文件，并且从不清理其
    `data` 目录。为了模拟这个情况，我们可能会创建一些数据文件，像这样：
- en: '[PRE0]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The preceding commands create a directory called `/var/lib/appdata`, and then
    create one (empty) file for each day, for the last 20 days. We could, of course,
    create files with data in, but it makes no difference to this example—we don't
    actually want to fill the disk up!
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 上面的命令创建了一个名为 `/var/lib/appdata` 的目录，并且为过去 20 天的每一天创建了一个（空的）文件。当然，我们也可以创建有数据的文件，但这对这个例子没有影响——我们并不想真正填满磁盘！
- en: 'Now, let''s suppose that our disk is getting full and that we want to prune
    this directory, keeping only the last 5 days'' worth. If we were to do this by
    hand, we might use the venerable `find` command, to list the files meeting our
    criteria, and remove anything older. This might look something like this:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，假设我们的磁盘空间快满了，我们想清理这个目录，只保留最近 5 天的数据。如果我们手动执行此操作，可能会使用久经考验的 `find` 命令，列出符合条件的文件，并删除较旧的文件。这看起来可能是这样：
- en: '[PRE1]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'That is an easy enough command to run, and you might be surprised to learn
    how common it is to see commands like that in enterprise run-books for Linux servers.
    Let''s improve on this, with Ansible. We know that if we implement this in Ansible,
    the following will be the case:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个相当简单的命令，你可能会惊讶地发现，类似的命令在企业级的 Linux 服务器运行手册中非常常见。让我们用 Ansible 来改进这个过程。我们知道，如果我们在
    Ansible 中实现它，以下情况将会发生：
- en: The Ansible engine will return an appropriate status—`ok`, `changed`, or `failed`,
    depending on the actions taken. The `find` command shown in the preceding code
    block will return the same output and exit code, whether it deletes any files
    or not.
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Ansible 引擎将根据所采取的操作返回适当的状态——`ok`、`changed` 或 `failed`。前面的代码块中展示的 `find` 命令无论是否删除任何文件，都会返回相同的输出和退出代码。
- en: The Ansible code we write will be self-documenting—for example, it will begin
    with an appropriate `name`—perhaps `Prune /var/lib/appdata`.
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们编写的 Ansible 代码将具有自我文档化的特性——例如，它将以适当的 `name` 开始——可能是 `Prune /var/lib/appdata`。
- en: The Ansible code can be run from AWX or Ansible Tower, ensuring that this routine
    task can be delegated to the appropriate team, using the built-in role-based access
    controls.
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Ansible 代码可以从 AWX 或 Ansible Tower 运行，确保这个常规任务可以委派给适当的团队，使用内置的基于角色的访问控制。
- en: In addition, the task can be given a user-friendly name in AWX, meaning operators
    don't need any specialist knowledge to jump in and start being effective in assisting
    with Linux environment management.
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 此外，任务可以在 AWX 中赋予一个用户友好的名称，这意味着操作员无需任何专业知识即可开始有效地协助管理 Linux 环境。
- en: AWX and Ansible Tower will faithfully log the output from the task run, to ensure
    it is possible to audit these cleanup jobs in the future.
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: AWX 和 Ansible Tower 会忠实地记录任务执行的输出，确保将来能够审核这些清理任务。
- en: 'Of course, none of these Ansible benefits is new to us by now—we have frequently
    referred to them throughout the book. Nonetheless, it is my wish to impress upon
    you the benefits of effective automation in the enterprise. Let''s start by defining
    a role to perform exactly this function—prune a directory of files over 5 days
    old with Ansible:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
- en: 'We start by making use of the Ansible `find` module, which enables us to build
    up a list of filesystem objects (such as files or directories), just as the `find`
    shell command does. We will `register` the output in an Ansible variable to make
    use of it later on, as follows:'
  id: totrans-31
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The code fragment shown here should be fairly self-explanatory—note, however, 
    that we have made use of variables for the `path` and `age` parameters; this is
    with good reason. Roles are all about reuse of code, and if we define these parameters
    using variables, we can reuse this role to prune other directories (for example,
    for different applications), without needing to change the role code itself. You
    will also observe that we can use the variables in the `name` of the task—very
    useful and powerful when returning to audit Ansible runs in the future.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
- en: 'The `find` module will build up a list of files we need to delete—however,
    given our goal of auditing, it might be useful for us to print these filenames
    in the Ansible output, to ensure we can come back later and find out exactly what
    was deleted. Note that we could print more data than just the path—perhaps also
    capturing size and timestamp information could be useful? All of this is available
    in the `prune_list` variable we captured earlier, and it is left as an exercise
    for you to explore this. (Hint: Replace `msg: "{{ item.path }}"` with `msg: "{{
    item }}"`, to see all the information captured by the `find` task.) Run the following
    code:'
  id: totrans-34
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Here, we are simply using an Ansible loop to iterate over the data generated
    by the `find` module—specifically, extracting the `path` dictionary item from
    the `files` dictionary within our variable. The `loop_control` option prevents
    Ansible from printing the entire dictionary structure above each `debug` message,
    instead, just using the `path` to each file as the `label`.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, we use the `file` module to remove the files, again looping over `prune_list`,
    just as we did previously, as follows:'
  id: totrans-37
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'With the role complete, we must define the variables for our play—in this example,
    I am defining them in the `site.yml` playbook that references our new role, as
    follows:'
  id: totrans-39
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Running this code with the test files generated earlier in this section will
    result in an output that looks something like this:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/644b6558-b091-4fb4-be4f-c2244b4faff0.png)'
  id: totrans-42
  prefs: []
  type: TYPE_IMG
- en: The test file set has been reduced for the preceding screenshot, to ensure it
    fits on the screen—however, you can clearly see the output, and which files were
    deleted.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
- en: While good housekeeping is an essential part of server maintenance, sometimes
    it is only desirable to take action (such as pruning a directory) if it is absolutely
    necessary. What if we decided that this role should only run when there is 10%
    or less disk space remaining on the filesystem containing `/var/lib/appdata`?
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
- en: 'The following process demonstrates how Ansible can be used to perform conditional
    housekeeping, operating only when the disk is more than 90% full:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
- en: 'We start by modifying our existing role—first of all, we add a new task to
    the role, to get the disk usage as a percentage from our `target` directory, as
    follows:'
  id: totrans-46
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Although there are Ansible facts that contain disk usage information, we use
    the `df` command here because it can query our directory directly—we must somehow
    trace this back to the mount point on which it lives if we are to successfully
    use Ansible facts. We also make use of `changed_when: false`, as this shell task
    will always show a changed result otherwise, which can be confusing in the output—this
    is a read-only query, so nothing should have changed!'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
- en: 'With this data gathered and registered in the `dfresult` variable, we then
    wrap our existing code in a block. A block in Ansible is simply a way of wrapping
    a set of tasks together—thus, rather than having to put a `when` condition on
    each of our three tasks from our earlier example, we simply put the conditional
    on the block instead. The block would begin something like this:'
  id: totrans-49
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Note how the previous set of tasks is now indented by two spaces. This ensures
    that Ansible understands it is part of the block. Indent all the existing tasks,
    and conclude the block with the following code:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Here, we are using the standard output captured in the `dfresult` variable,
    casting it to an integer, and then, checking to see if it is 90% or more. Thus,
    we only run the pruning tasks if the filesystem is more than 90% full. This is,
    of course, just one conditional—you could gather any data that you require to
    make any of your tasks run, in a variety of other cases. Running this new role
    on my test server, which has much less than 90% disk utilization, shows the pruning
    tasks being skipped altogether now, as can be seen in the following screenshot:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/153ab9cf-57c9-49fc-b1eb-09882d409f3a.png)'
  id: totrans-54
  prefs: []
  type: TYPE_IMG
- en: In this way, it is easy for us to perform routine disk housekeeping tasks across
    a large enterprise estate, and—as is ever the case with Ansible—the sky is the
    limit for what you can do. Hopefully, the examples from this section will give
    you some ideas on how to get started. In the next section, we will look at how
    Ansible can be used to effectively monitor for configuration drift, across your
    Linux estate.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
- en: Monitoring for configuration drift
  id: totrans-56
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In [Chapter 7](200bea26-7066-4feb-a571-481a5f047ae4.xhtml), *Configuration Management
    with Ansible*, we have explored the ways that Ansible can be used both to deploy
    configuration at an enterprise scale and to enforce it. Let us now build on this,
    with something else—monitoring for configuration drift.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第7章](200bea26-7066-4feb-a571-481a5f047ae4.xhtml)中，*使用Ansible进行配置管理*，我们探讨了Ansible如何在企业规模上部署配置并强制执行它。现在，让我们在此基础上，增加一个新的内容——监控配置漂移。
- en: As we discussed in [Chapter 1](c7596fb8-4971-44d7-943a-7660c5eecb17.xhtml),
    *Building a Standard Operating Environment on Linux*, manual changes are the enemy
    of automation. Beyond this, they are also a security risk. Let us work with a
    specific example here, to demonstrate. As was suggested previously in this book,
    it would be advisable to manage the **Secure Shell** (**SSH**) server configuration
    with Ansible. SSH is the standard protocol for managing Linux servers and can
    be used not only for management but also for file transfer. In short, it is one
    of the key mechanisms through which people will access your servers, and hence
    it is vital that it is secure.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在[第1章](c7596fb8-4971-44d7-943a-7660c5eecb17.xhtml)中讨论的，*在Linux上构建标准操作环境*，手动更改是自动化的敌人。除此之外，它们也是一个安全风险。让我们通过一个具体的例子来演示。如本书前面所建议的，建议通过Ansible管理**安全外壳（SSH）**服务器配置。SSH是管理Linux服务器的标准协议，不仅可以用于管理，还可以用于文件传输。简而言之，它是人们访问你的服务器的关键机制之一，因此确保其安全至关重要。
- en: It is also common, however, for a variety of people to have root access to Linux
    servers. Whether developers are deploying code, or system administrators are performing
    routine (or break-fix) work, it is considered perfectly normal for many people
    to have root access to a server. This is fine if everyone is *well behaved*, and
    actively supports the principles of automation in your enterprise. However, what
    happens if someone makes unauthorized changes?
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，也常见多个人拥有Linux服务器的root访问权限。无论是开发人员在部署代码，还是系统管理员在执行日常（或修复）工作，很多人拥有服务器的root访问权限是完全正常的。如果每个人都*表现得很得体*，并积极支持企业中的自动化原则，那是没问题的。但是，如果有人做出未经授权的更改怎么办？
- en: Through the SSH configuration, they might enable remote root logins. They might
    turn on password-based authentication when you have disabled this in favor of
    key-based authentication. Many times, these kinds of changes are made to support
    laziness—it is easier to copy files around as a root user, for example.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 通过SSH配置，可能会启用远程root登录。也可能在你禁用了密码认证并改用基于密钥的认证时，重新启用基于密码的认证。许多时候，这些更改是为了支持懒惰——例如，作为root用户复制文件更容易。
- en: Whatever the intention and root cause, someone manually making these changes
    to a Linux server you deployed previously is a problem. How do you go about detecting
    them, though? Certainly, you don't have time to log in to every server and check
    the files by hand. Ansible, however, can help.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 无论意图和根本原因如何，某人手动更改你之前部署的Linux服务器配置都是一个问题。那么，如何检测这些更改呢？当然，你没有时间登录到每台服务器手动检查文件。然而，Ansible可以提供帮助。
- en: In [Chapter 7](200bea26-7066-4feb-a571-481a5f047ae4.xhtml), *Configuration Management
    with Ansible*, we proposed a simple Ansible example that deployed the SSH server
    configuration from a template and restarted the SSH service if the configuration
    was changed using a handler.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第7章](200bea26-7066-4feb-a571-481a5f047ae4.xhtml)中，*使用Ansible进行配置管理*，我们提出了一个简单的Ansible示例，该示例从模板中部署SSH服务器配置，并在配置发生更改时使用处理程序重启SSH服务。
- en: We can actually repurpose this code for our configuration drift checks. Without
    even making any code changes, we can run the playbook with Ansible in *check*
    mode. Check mode makes no changes to the systems on which it is working—rather,
    it tries its best to predict any changes that might occur. The reliability of
    these predictions depends very much on the modules used in the role. For example,
    the `template` module can reliably predict changes because it knows whether the
    file that would be written is different from the file that is in place. Conversely,
    the `shell` module can never know the difference between a `change` and an `ok`
    result because it is such a general-purpose module (though it can detect failures
    with a reasonable degree of accuracy). Thus, I advocate strongly the use of `changed_when` when
    this module is used.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s see what happens if we rerun the `securesshd` role from before, this
    time in check mode. The result can be seen in the following screenshot:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/1e3395f9-8bd4-4af4-aaf2-2ed627fdd564.png)'
  id: totrans-65
  prefs: []
  type: TYPE_IMG
- en: 'Here, we can see that someone has indeed changed the SSH server configuration—if
    it matched the template we were providing, the output would look like this instead:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/3a0b8a58-c5b3-448a-9570-ec42ac43e597.png)'
  id: totrans-67
  prefs: []
  type: TYPE_IMG
- en: So far, so good—you could run this against a hundred, or even a thousand, servers,
    and you would know that any `changed` results came from servers where the SSH
    server configuration no longer matches the template. You could even run the playbook
    again to rectify the situation, only this time not in check mode (that is, without
    the `-C` flag on the command line).
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
- en: In an environment such as AWX or Ansible Tower, jobs (that is to say, running
    playbooks) are categorized into two different states—success and failure. Success
    is categorized as any playbook that runs to completion, producing only `changed`
    or `ok` results. Failure, however, comes about from one or more `failed` or `unreachable`
    states being returned from the playbook run.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
- en: 'Thus, we could enhance our playbook by getting it to issue a `failed` state
    if the configuration file is different from the templated version. The bulk of
    the role remains exactly the same, but, on our template task, we add the following
    clauses:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'These have the following effect on the operation of this task:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
- en: The result of the task is registered in the `template_result` variable.
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We change the  failure condition of this task to the following:'
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The template task result was changed, and we are running it in check mode.
  id: totrans-75
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Or, the template task failed for some other reason—this is a catch-all case,
    to ensure we still report other failure cases correctly (for example, access denied
    to a file).
  id: totrans-76
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'You will observe the use of both logical `and` and `or` operators in the `failed_when`
    clause—a powerful way to expand on the operation of Ansible. Now, when we run
    the playbook in check mode and the file has changed, we see the following result:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/03d63c86-98b2-418c-b46d-14cae77c2b8a.png)'
  id: totrans-78
  prefs: []
  type: TYPE_IMG
- en: Now, we can very clearly see that there is an issue on our host, and it will
    be reported as a failure in AWX and Ansible Tower too.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
- en: 'Of course, this works very well for plain text files. What about binary files,
    though? Ansible is, of course, not a complete replacement for a file integrity
    monitoring tool such as **Advanced Intrusion Detection Environment** (**AIDE**)
    or the venerable **Tripwire**—however, it can help with the use of binary files
    too. In fact, the process is very simple. Let''s suppose you want to ensure the
    integrity of `/bin/bash`—this is the shell that everyone uses by default on most
    systems, so the integrity of this file is incredibly important. If you have space
    to store a copy of the original binary on your Ansible server, then you can use
    the `copy` module to copy it across to the target hosts. The `copy` module makes
    use of checksumming to determine whether a file needs to be copied, and so, you
    can be sure that, if the `copy` module results in a `changed` result, then the
    target file differs from your original version, and integrity is compromised.
    The role code for this would look very similar to our template example here:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Of course, storing original binaries on your Ansible server is inefficient,
    and also, means you have to keep them up to date, in line with your server patching
    schedule, which is not desirable when you have a large number of files to check.
    Fortunately, the Ansible `stat` module can generate checksums, as well as returning
    lots of other useful data about files, and so, we could very easily write a playbook
    to check that our binary for Bash has not been tampered with, by running the following
    code:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'This is a very simple example and could be enhanced significantly by ensuring
    the file path and name, and checksum, are variables rather than static values.
    It could also be made to loop over a dictionary of files and their respective
    checksums—these tasks are left as an exercise for you, and this is entirely possible,
    using techniques we have covered throughout this book. Now, if we run this playbook
    (whether in check mode or not), we will see a failed result if the integrity of
    Bash has not been maintained, and `ok` otherwise, as follows:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/5b4a99b8-fbc9-4a79-912b-bd17cbac9ba4.png)'
  id: totrans-85
  prefs: []
  type: TYPE_IMG
- en: Checksumming can be used to verify the integrity of configuration files too,
    so, this example role serves as a good basis for any file integrity checking you
    might wish to undertake.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
- en: We have now completed our exploration of file and integrity monitoring with
    Ansible, and hence, the ability check for configuration drift. In the next section
    of this chapter, we'll take a look at how Ansible can be used to manage processes
    across an Enterprise Linux estate.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
- en: Understanding process management with Ansible
  id: totrans-88
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Sooner or later, you will end up with the need to manage, and possibly even
    kill, processes on one or more Linux servers within your enterprise. Obviously,
    this is not an ideal scenario, and in day-to-day operations, most services should
    be managed using the Ansible `service` module, many examples of which we have
    seen in this book.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
- en: 'What if, however, you need to actually kill a service that has hung? Obviously,
    a system administrator could SSH into the errant server and issue commands such
    as the following:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'If the process refuses stubbornly to terminate, then the following may become
    necessary:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: While this is a fairly standard practice, in which most system administrators
    will be well versed (and indeed, may have their own favorite tools to handle,
    such as `pkill`), it suffers the same problem as most manual interventions on
    a server—how can you keep track of what happened, and which processes were affected?
    If numeric **process IDs** (**PIDs**) were used, then even with access to the
    command history, it is still impossible to tell which process historically held
    that numeric PID.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
- en: What we propose here is an unconventional use of Ansible—yet one that, if run
    through a tool such as AWX or Ansible Tower, would enable us to track all operations
    that were performed, along with details of who ran them and, if we put the process
    name in a parameter, what the target was too. This could be useful if, in the
    future, it becomes necessary to analyze the history of a problem, whereupon it
    would be easy to check which servers were acted upon, and which processes were
    targeted, along with precise timestamps.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s build up a role to perform exactly this set of tasks. This chapter was
    originally written against Ansible 2.8, which did not feature a module for process
    management, and so, the following example uses native shell commands to handle
    this case:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
- en: 'We start by running the process listing we proposed earlier in this section,
    but this time, registering the list of PIDs into an Ansible variable, as follows:'
  id: totrans-97
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Most people familiar with shell scripting should be able to understand this
    line—we are filtering the system process table for whole-word matches for the
    Ansible variable `procname`, and removing any extraneous process names that might
    come up and confuse the output, such as `grep` and `ansible`. Finally, we use
    `awk` to process the output into a comma-separated list, containing the PID, in
    the first column, and the process name itself in the second.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we must start to take action on this output. We now loop over the `process_ids`
    variable populated previously, issuing a `kill` command against the first column
    in the output (that is, the numeric PID), as follows:'
  id: totrans-100
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: You will observe the use of Jinja2 filtering here—we can use the built-in `split`
    function to split the data we created in the previous code block, taking only
    the first column of output (the numeric PID). However, we use the `loop_control`
    label to set the task label containing both the PID and process name, which could
    be very useful in an auditing or debugging scenario.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
- en: 'Any experienced system administrator will know that it is not sufficient to
    just issue a `kill` command to a process—some processes must be forcefully killed
    as they are hung. Not all processes exit immediately, so we will use the Ansible
    `wait_for` module to check for the PID in the `/proc` directory—when it becomes
    `absent`, then we know the process has exited. Run the following code:'
  id: totrans-103
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: We have set the timeout here to 5 seconds—however, you should set it as appropriate
    in your environment. Once again, we register the output to a variable—we need
    to know which processes failed to exit, and hence, try killing them more forcefully.
    Note that we set `ignore_errors` here, as the `wait_for` module produces an error
    if the desired state (that is, `/proc/PID` becomes `absent`) does not occur within
    the `timeout` specified. This should not be an error in our role, simply a prompt
    for further processing.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
- en: 'We now loop over the results of the `wait_for`  task —only this time, we use
    the Jinja2 `selectattr` function, to select only dictionary items that have `failed`
    asserted; we don''t want to forcefully terminate non-existent PIDs. Run the following
    code:'
  id: totrans-106
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Now, we attempt to kill the stuck processes with the `-9` flag—normally, sufficient
    to kill most hung processes. Note again the use of Jinaj2 filtering and the tidy
    labeling of the loop, to ensure we can use the output of this role for auditing
    and debugging.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we run the playbook, specifying a value for `procname`—there is no default
    process to be killed, and I would not suggest that setting a default value for
    this variable is safe. Thus, in the following screenshot, I am setting it using
    the `-e` flag when I invoke the `ansible-playbook` command:'
  id: totrans-109
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/99908df0-83de-4c8e-ad70-76dae520fc2c.png)'
  id: totrans-110
  prefs: []
  type: TYPE_IMG
- en: From the preceding screenshot, we can clearly see the playbook killing the `mysqld`
    process, and the output of the playbook is tidy and concise, yet contains enough
    information for debugging, should the need occur.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
- en: 'As an addendum, if you are using Ansible 2.8 or later, there is now a native
    Ansible module called `pids` that will return a nice, clean list of PIDs for a
    given process name, if it is running. Adapting our role for this new functionality,
    we can, first of all, remove the shell command and replace it with the `pids`
    module, which is much easier to read, like this:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'From this point on, the role is almost identical to before, except that, rather
    than the comma-separated list we generated from our shell command, we have a simple
    list that just contains the PIDs for each running process that matches the procname
    variable in name. Thus, we no longer need to use the split Jinja2 filter on our
    variables when executing commands on them. Run the following code:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: This block of code performs the same functions as before, only now, it is a
    little more readable, as we've reduced the number of Jinja2 filters required,
    and we have removed one shell command, in favor of the `pids` module. These techniques,
    combined with the `service` module discussed earlier, should give you a sound
    basis to meet all of your process control needs with Ansible.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
- en: In the next and final section of this chapter, we'll take a look at how to use
    Ansible when you have multiple nodes in a cluster, and you don't want to take
    them all out of service at once.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
- en: Rolling updates with Ansible
  id: totrans-118
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: No chapter on routine maintenance would be complete without a look at rolling
    updates. So far in this book, we have kept our examples simple with one or two
    hosts, and have worked on the basis that all examples can be scaled up to manage
    hundreds, if not thousands, of servers using the same roles and playbooks.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
- en: 'This, by and large, holds true—however, there are certain special cases where
    perhaps we need to look a little deeper at the operation of Ansible. Let''s build
    up a hypothetical example, where we have four web application servers behind a
    load balancer. A new release of the web application code needs to be deployed,
    and the deployment process requires multiple steps (thus, multiple Ansible tasks).
    In our simple example, the deployment process will be as follows:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
- en: Deploy the web application code to the server.
  id: totrans-121
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Restart the web server service, to pick up the new code.
  id: totrans-122
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In a production environment, you would almost certainly want to take further
    steps to ensure the integrity of your web service—for example, if it is behind
    a load balancer, you would take it out of service during the code deployment,
    and ensure it is not returned to service until it is validated as working properly.
    It is not anticipated that everyone reading this book will have access to such
    an environment, and so, the example has been kept simple, to ensure everyone can
    try it out.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
- en: 'We could easily write a simple Ansible role to perform this task—an example
    is shown, as follows:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'This code performs our two steps in turn, exactly as we desire. However, let''s
    have a look at what happens when we run this role in a playbook. The result is
    shown in the following screenshot:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/9d39932e-4386-4e93-846f-bbb71bd6d76f.png)'
  id: totrans-127
  prefs: []
  type: TYPE_IMG
- en: Notice how Ansible performed the tasks. First of all, the new code was deployed
    on all four servers. Only then, were they restarted. This may not be desirable,
    for a number of reasons. For example, the servers may be in an inconsistent state
    after the first task, and you would not want all four servers to be in an inconsistent
    state at once, as anyone using the web application would experience errors. Also,
    if the playbook goes wrong for some reason and produces a failed state, it will
    faithfully fail on all four servers, thus breaking the entire web application
    for everyone, and causing a service outage.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
- en: 'To prevent these kinds of issues from occurring, we can use the `serial` keyword,
    to ask Ansible to only perform the update on a given number of servers at a time.
    For example, if we insert the line `serial: 2` into the `site.yml` playbook calling
    this role, suddenly the behavior becomes rather different, as the following screenshot
    shows:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/d36cc8c5-8931-40e9-b934-d5ae7827d1f8.png)'
  id: totrans-130
  prefs: []
  type: TYPE_IMG
- en: The preceding output is truncated to save space but clearly shows that the playbook
    is now being run on only two servers at a time—thus, during the initial phase
    of the run, only `cluster1` and `cluster2` are inconsistent, while `cluster3`
    and `cluster4` remain consistent and untouched. Only when all tasks are completed
    on the first two servers are the next two processed.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
- en: Failure handling is also important, and a danger of automation is that you could
    break an entire environment very easily if an issue exists in the code or playbook.
    For example, if our `Deploy new code` task fails for all servers, running the
    playbook on two servers at a time will not help. Ansible will still faithfully
    do what it is asked—in this case, break all four servers.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
- en: 'In this instance, it is a good idea to add to the playbook the `max_fail_percentage`
    parameter too. For example, if we set this to `50`, then Ansible will stop processing
    hosts as soon as 50% of its inventory has failed, as shown in the following screenshot:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/173b92e9-ce2b-459b-93c4-caeca67c9f43.png)'
  id: totrans-134
  prefs: []
  type: TYPE_IMG
- en: As we can see here, even though our inventory has not been changed, Ansible
    has stopped after processing `cluster1` and `cluster2`—because they failed, it
    is not performing any tasks on `cluster3` and `cluster4`; thus, at least two hosts
    remain in service with good code, allowing users to continue using the web application,
    in spite of the failure.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
- en: It is important to make use of these Ansible features when working with large,
    load-balanced environments, to ensure that failures do not propagate to an entire
    estate of servers. That concludes our look at the use of Ansible in routine server
    maintenance—as ever, the possibilities are endless, but it is hoped that once
    again, this chapter has given you some inspiration and examples upon which to
    build.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-137
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Ansible is a very powerful tool, but not just for deployment and configuration
    management. Although these are core strengths it possesses, it is also of powerful
    assistance when it comes to day-to-day management tasks. As ever, when coupled
    with an enterprise management tool such as AWX or Ansible Tower, it becomes incredibly
    important in the management of your Linux estate, especially for auditing and
    debugging purposes.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, you learned how to tidy up disk space using Ansible, and how
    to make this conditional. You then learned how Ansible can help monitor configuration
    drift, and even alert to possible tampering with binary files. You learned how
    to manage processes on remote servers using Ansible, and finally, how to perform
    rolling updates in a graceful and managed fashion, across a load-balanced pool
    of servers.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we take a look at securing your Linux servers in a standardized
    fashion, with CIS Benchmarks.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  id: totrans-141
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Why might you make use of the output from the `df` command rather than an Ansible
    fact when examining disk space?
  id: totrans-142
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Which Ansible module is used to locate files based on given criteria, such as
    age?
  id: totrans-143
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Why is it important to monitor for configuration drift?
  id: totrans-144
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What are two ways in which you can monitor a text-based configuration file for
    changes in Ansible?
  id: totrans-145
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How would you manage a `systemd` service on a remote server using Ansible?
  id: totrans-146
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is the name of the built-in filtering within Ansible that can help process
    string output (for example, to split a comma-separated list)?
  id: totrans-147
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How would you split a comma-separated list in an Ansible variable?
  id: totrans-148
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: When operating in a load-balanced environment, why would you not want all tasks
    performed on all the servers in one go?
  id: totrans-149
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Which Ansible feature can prevent you from rolling out a failed task to all
    servers?
  id: totrans-150
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Further reading
  id: totrans-151
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For an in-depth understanding of Ansible, please refer to *Mastering Ansible,
    Third Edition—James Freeman* and *Jesse Keating* ([https://www.packtpub.com/gb/virtualization-and-cloud/mastering-ansible-third-edition](https://www.packtpub.com/gb/virtualization-and-cloud/mastering-ansible-third-edition))
  id: totrans-152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
