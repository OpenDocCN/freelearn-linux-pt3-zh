# *第六章*：数据库

技术上，数据库系统是运行在操作系统之上的应用程序，对于我们作为系统管理员来说不应直接关注。这是一个很好的理论。然而在现实世界中，数据库与操作系统密切相关，往往是通用的知识项目，需要深入的技术知识，而总体上需要的时间相对较少。因此，普遍来说数据库管理的责任落在系统管理员身上；特别是在当今的 Linux 发行版上，因为我们可能使用的大多数数据库已经与操作系统捆绑在一起。

在本章中，我们将学习以下内容：

+   将数据库与 DBMS 分离

+   比较关系型数据库和 NoSQL 数据库

+   在 Linux 上发现常见的数据库

+   理解数据库复制和数据保护概念

在旧日的好时光，系统管理和数据库管理几乎总是两个独立的任务。系统管理员（SA）和数据库管理员（DBA）角色会密切合作，但是由于各自角色的专业技能和大量时间需求，它们通常是独立的、专门的工作人员。通常情况下，每五到二十名系统管理员只需要一个数据库管理员，因此团队规模较小，职业领域也总是较小，因为即使在没有数据库需要管理的公司中，系统管理员角色仍然存在。

随着操作系统和数据库管理系统变得更简单、更健壮，需要对数据库平台进行大量调整的需求已经减少到几乎可以忽略的程度，因此 DBA 职业道路几乎已经消失。今天已经不存在建立在单一数据库平台周围的职业需要。管理数据库的人通常会管理各种不同的数据库，可能在多个操作系统上。

随着时间的推移，大多数关键工作负载变得商品化。我们的意思是，它们从专门知识转变为通用知识。这些的典型例子包括电子邮件服务器（MTA）和网页服务器。二十年前（大约在 2001 年），运行这些服务器是高度专业化的知识，只有非常少的系统管理员才会理解其中的工作原理。通常你会有一个专门的操作系统管理员，然后有一个专门的电子邮件管理员或网页管理员，专门管理他们所擅长的单一应用程序。那时不会是*所有电子邮件服务器*之类的情况。管理一个单一的邮件服务器，比如 Postfix 或 Exchange，往往是一项专业技能。你的知识将完全集中在这个单一产品及其独特的特点和需求上。这种情况非常极端，以至于像 Postfix、Exchange、Apache、MS SQL Server、Oracle 数据库、IBM DB2 等产品，都有专门的认证和职业发展路径。如今，我们只是默认任何有经验的系统管理员都能够管理任何电子邮件、网页或数据库服务器。

由于数据库非常复杂，并且在过去几十年中已经发展成为远超其过去的形态，因此作为系统管理员，我们应该普遍理解其中的许多概念。数据库是高度状态化的，代表着文件系统和一般存储子系统的二级存储层。它们并不代表特殊情况，而是需要我们深入理解的通用情况的广泛应用。网页服务器、电子邮件服务器和其他应用程序仍然很重要，但它们代表的是应用设计中的标准预期情境，因此在这种情况下不需要特别的考虑。直白地说，数据库用于存储数据，并且极其脆弱。其他应用程序使用数据库或文件系统来存储数据，因此从管理的角度来看，它们比较简单。正因为数据库代表了第二层数据存储层，它才被视为特殊。

为了以系统管理员的方式处理这一问题，我们将从深入了解数据库是什么、它是如何工作的以及为什么它成为一种存储形式开始。然后，我们可以研究常见的数据库类型及其在 Linux 发行版中的具体情况。最后，我们将通过探讨数据库的最重要方面——如何保护它们，来结束本篇内容。

让我们开始吧，弄清楚数据库究竟是什么，以及为什么我们如此关心它们。

# 将数据库与数据库管理系统（DBMS）分开

就像生活中大多数事情一样，关于数据库的术语往往不准确，许多高度技术化且具体的术语被用来主要指代与其原本含义不同的东西。但通过深入了解数据库到底是什么，以及它们如何几乎普遍地工作，并在这个话题上建立正确的语义，我们将从系统管理员的角度，建立起对数据库需求的几乎内在理解。通常来说，找到准确的描述方式本身就能帮助我们理解。数据库并非魔法，但往往被当作魔法来看待。

## 数据库

我们必须首先问一下，什么是数据库？《牛津词典》对数据库的定义是*在计算机中保存的一组结构化数据，特别是可以通过多种方式访问的数据*。嗯，这样的定义并没有告诉我们太多。不过，从某种程度上说，它其实说了些东西。数据库不能是无结构的；这是最重要的一点，计算机存储的东西，比如文件，也都是结构化的。所以，数据库是计算机中存储的结构化数据，可以是存储在磁盘上的文件或文件集，或者它们存在于计算机内存中，永远不写入磁盘。在后一种情况下，数据库是短暂的，对系统管理员来说并不重要。但在前一种情况下，代表了百分之九十九以上的使用案例，这个问题就非常重要了。让我们给出一个作为系统管理员可以有效使用的定义：数据库是包含结构化数据的文件或文件集。

你可能会立刻跳出来说，*但是我运行的是一个数据库，它是一个服务，而不是文件——我可以与它互动！* 我们会很快解决这个问题。跟我走，数据库其实就是文件。

我们应该从一些例子开始，因为这有助于快速理解我们的意思。假设我们有一个标准的文本文件，也许是我们写下的一些笔记。这是一个文件，但它是数据库吗？不是的，它不是。没错，文件是用某种 ANSI 字符标准编码的，但数据是临时的，没有结构。我们*可以*手动给文件添加结构，这样做是可以的，但文件和读取该文件的工具并不知道这些结构。任何结构对于使用它的人来说是可访问或可见的，但对系统本身不可见。这是无结构的。

好吧，那么文本文件不是数据库。那么 Word 文件呢？一样的道理。它可能有比文本文件更强的格式，但 Word 文件中存储的内容完全没有结构。我们可以在文件中随意放入任何内容，放在任何地方。它是无结构的。

那么，电子表格文件呢？就像我们用 Excel 或 CSV 时得到的那样？这是一个棘手的问题。我们进入了一个灰色区域。在正常情况下，这些文件并不被视为数据库，但名义上它们是。我会把它们称为*半结构化的*。它们包含一些结构（你可以看到的是单元格），并且有一种方法来指定该结构中包含的内容，以及某些数据组（即表现为列或行的数据），这些数据被期望相互关联。但单元格内或单元格之间的任何结构都没有被建议或强制执行。因此，虽然有结构，但我们通常认为它没有数据库所需的结构那么多。我们称之为“也许”。不要在下一个 IT 鸡尾酒会上拿出`CSV`文件，并试图为它辩护是新的数据库格式，因为这是站不住脚的。它仅仅是作为一个思维实验有意义。但我们可以看到，电子表格格式很容易有潜力像数据库一样发挥作用。

通过稍微增加一些结构化，我们开始看到真正的轻量级数据库文件的出现。XML 就是一个很好的例子。XML 比 CSV 这样的电子表格格式更有结构，可以作为一个完整的数据库使用。有些数据库格式就是基于 XML 的。XML 仍然只是 ANSI 文本，但具有足够的特定结构，可以让我们走向*非常简单的数据库*。XML 可能不是最强大的数据库，也不是使用最快的数据库，但它非常简单，并且在合适的用途下可以非常有效。

专门构建的数据库通常避免使用 ANSI 或类似的文本格式的多余膨胀，因为这会在软件使用时减慢系统速度，而且数据库本身通常并不是为了让人类直接阅读的。通常，会使用某种形式的二进制格式或甚至压缩来减少存储的读写时间，并尽量减少今天所需的存储空间。一个很好的例子是*SQLite*，这是一个免费的开源数据库，它使用高度优化、但公开的格式，如果有兴趣，你可以研究它。它仍然只是一个文件，就像其他任何文件一样，但比 XML 提供的结构更加丰富。

所有这些示例使用的都是每个数据库一个文件。但数据库使用多个文件并不是没有理由的。这样做的一个常见目的可能只是将数据拆分开来，以避免将所有数据存储在一个过大、无法轻松操作的单一文件中，或者数据可以按用途拆分。想象一下一个存储用户地址和用户电话号码的数据库。一个只包含地址的文件和一个只包含电话号码的文件会是一个合理的*磁盘存储*设计。

## 数据库引擎

现在我们知道什么是数据库。它其实就是我们存储的一个文件（或者多个文件），这些文件包含我们的结构化数据。我们*假设*在生产环境中，我们将使用一种高效的数据库格式，这种格式不是为了让人类直接打开和读取，这样做显然是不明智的。所以，计算机会读取、写入并操作这个文件或这些文件。

那么，计算机如何知道如何处理那个格式如此具体的数据库文件呢？在回答这个问题之前，我们应该先来比较一下存储。

在存储中，我们有一个标准的原始格式，称为块存储。在此基础上，我们实现了文件系统。这些文件系统通过提供操作系统可以用来存储和检索数据的标准文件访问格式，与操作系统进行交互。每个文件系统可以以不同的方式执行此操作。为了让操作系统能够与文件系统交互，它必须有一个文件系统驱动程序。

数据库的工作方式相同，但通常是在更高一层的堆栈中进行的。对数据库来说，文件系统是通用存储。高度结构化的数据位于文件系统之上，包含在一个文件或多个文件中。但就像我们需要操作系统驱动程序来知道如何与文件系统进行交互一样，我们也需要一个驱动程序来让应用程序知道如何与数据库进行交互！我们可以将其称为数据库驱动程序，但它通常被称为数据库引擎或数据库库。

### 文件系统实际上是数据库

这就是那些我们在 IT 领域工作的人应该理解的奇怪事情，而你永远不能在那个所谓的鸡尾酒派对上提出来，因为你永远无法说服任何人相信这是真的，但它确实如此。文件系统本身实际上是一种数据库形式。它们是磁盘上的高结构化数据格式，可以包含其他特定格式的数据，以文件的形式存储，包含关于这些文件的结构化数据，并且通常包含复杂的机制来搜索数据结构。文件系统在各个方面都是数据库。甚至包括它通常的使用方式。它们只是具有独特但极为常见的目的的数据库，这个目的重要到我们已经忘记了它在背后究竟是什么。

这与网络服务器实际上是文件服务器的情况类似，但它们是如此特殊的案例，以至于没人谈论它们本质上就是这样。理解它们是如何工作的非常有用，因为这有助于我们更好地理解它们，并且避免大脑在意识到它们之间有重叠时感到困惑，进而搞不清楚它们是如何分开的——因为它们根本就不是分开的。

这一点非常正确，过去有些高性能数据库甚至会放弃使用文件来存储数据，而直接存储在块设备上，这样它们的位置和文件系统通常一样。但因为没有文件，它们实际上并不是文件系统。但在所有实际用途上，它们却是。

这种替代文件系统的过程曾经很流行，是为了提升系统性能，因为文件系统曾经会给服务器带来显著的开销。今天，文件系统的开销已经微不足道，而试图替代文件系统带来的复杂性和问题已经变得如此庞大，以至于几乎被完全避免。

一旦你将数据库看作是数据的某种文件系统，一切就都变得更有意义了。

数据库引擎才是真正的魔法所在。数据库本身仅仅是存放在磁盘上（或内存中的）数据。没错，它有结构，但这个结构已经存在。数据库并不创建、强制或以任何方式维护这个结构——所有这些工作都由数据库引擎完成。数据库引擎是数据库栈的主力军。这里是处理能力的来源，这就是我们需要安装的地方，也是魔法酱料被应用的地方。

在某些情况下，我们会大量讨论数据库引擎。在一些情况下，我们直接使用它们，比如**SQLite**或**Berkeley DB**，我们只需安装库（数据库引擎），然后使用它访问一个文件，哇，系统就能工作了，可以用作数据库。或者在其他情况下，比如使用**MongoDB**或**MariaDB**产品时，我们常常会讨论在背后选择的数据库引擎（**WiredTiger**、**InnoDB**、**MyISAM**等），它们是影响数据库特性和性能的关键因素。

数据库引擎在许多情况下得不到应有的关注，大多数人完全忽视了这一数据库服务栈中至关重要的一层，因为它很难理解，而且通常是隐藏在背后的。眼不见，心不烦，这里完全适用。

在某些情况下，比如我之前提到的 BDB 和 SQLite，我们作为系统管理员，需要负责将这些库安装到服务器上，以便软件可以访问它们。当然，这些库通常仅作为依赖列出，并由我们服务器上的包管理系统自动安装和维护，这些包管理系统来自我们的 Linux 发行版，使得这一过程变得简单，甚至对我们来说可能是透明的。正因为如此，系统管理员往往几乎对他们所维护的系统上部署或使用的数据库引擎一无所知。

这可能看起来显而易见，但值得注意的是，数据库引擎是代码库（即驱动程序），而不是运行的程序或服务。因此，在系统上检测特定的数据库引擎可能会相当困难。当然，如果通过 APT 或 DNF 安装了 SQLite，我们可以查询系统并轻松找到它。它是一个存储在磁盘上的库，拥有一个目录，并且在包配置日志中有所记录。我们无法在进程列表中看到它的运行，也找不到它在服务目录中，但我们总能以某种方式找到它。

但完全有可能，数据库引擎库的代码会被包含到并编译到某个软件项目中，使其几乎不可能被检测到，因为它只是某个应用程序内部磁盘上的二进制数据。当然，块级工具可以扫描磁盘上的每一部分数据，查找磁盘上的模式，但这属于极端级别，更适用于取证或执法，而在系统管理中并不太有用。从实际角度来看，一个编译进软件中的数据库引擎对使用该系统的任何人来说都是完全不可见的。

当我们讨论某个数据库的性能或特性时，几乎总是这些特性或性能特征来自正在使用的数据库引擎。在大多数情况下，数据库引擎还会实现查询语言或应用程序编程接口（API），用于查询磁盘上的数据。

对于那些跟随学习的人，你可能已经注意到，由于数据库引擎本身并不*运行*，因此你无法远程访问它。为了与数据库引擎进行交互，你必须在程序中使用驱动程序与数据库进行交互。

## 数据库管理系统

数据库技术栈中最显眼的组件，也是唯一完全可选的部分，是数据库管理系统，通常缩写为 DBMS。对于大多数人来说，甚至是那些具有丰富数据库经验的技术人员，唯一了解的数据库系统部分就是数据库管理系统。

在我们深入了解数据库管理系统究竟是什么之前，我们应该先举一些实际的 DBMS 例子：**MySQL**、**MariaDB**、**PostgreSQL**、**Oracle DB**、**Microsoft SQL Server**、**IBM DB2**、**MongoDB**、**Redis**、**Firebase**，以及更多其他的。这些名字对你们中的大多数人来说，比数据库引擎的名字更为熟悉。

DBMS 本身做的事情其实非常有限。DBMS 是一个程序，它使用一个或多个数据库引擎与磁盘上的物理数据库进行交互，然后提供对该数据库的访问控制。DBMS 可能有一个始终与之关联的单一数据库引擎，或者像 MySQL 一样，提供对一系列数据库引擎的访问，并为它们提供一个通用接口，使开发人员能够方便地使用它们。熟悉 MySQL 的人会知道，在 MySQL 中创建一个新数据库时，你必须告诉它你希望使用哪种引擎。确实，如果你不选择，它会有一个默认选项，但在这种情况下，不选择实际上也是一种选择。

在使用数据库引擎时，你必须指定你正在操作的文件或文件集。因此，任何与数据库引擎的交互都仅限于单一的数据库，不管那个文件中存储的是哪个数据库。DBMS 通常不是这样工作的。标准的 DBMS 会连接到多个数据库，这些数据库可能连接到多个*实例*的数据库引擎，这些引擎可能是相同的库被多次实例化，或者可能是不同的引擎用于不同的数据库，所有这些都可以同时访问。因此，我们所设想的数据库大部分来自 DBMS。

正是 DBMS 提供了（当然是可选的）通过网络或甚至通过互联网连接数据库的方式。任何网络功能都来自 DBMS。此外，DBMS*运行*，通常作为服务，在你的计算机上运行。这就是你看到内存消耗、CPU 使用情况以及其他数据库使用详情的地方。DBMS 通常提供一些引擎本身无法提供的扩展功能，例如内存缓存。

显然，在纯数据库引擎的场景中，数据库中数据的访问控制完全来自于文件系统的权限。这就像用 Microsoft Word 打开一个 Word 文件一样。如果你对文件有读写权限，并且能够运行读取文件的应用程序，那么你就可以读取文件并将更改写回文件。对于像 SQLite 这样的数据库引擎，也可以尝试同样的方式。要允许用户使用数据库，你只需给他们相应的文件系统权限即可。这非常简单，但也非常有限。

使用 DBMS 我们有更多的选择。大多数 DBMS 添加了网络功能，通过这些功能我们可以使用数据库自身的工具在粒度级别上控制访问权限，同时我们还可以使用操作系统和网络工具进一步控制访问。这变得更加复杂，但正是从这种复杂性中，我们获得了强大和灵活性。DBMS 通常会提供用户级别的控制和机器级别的控制，并且通常在其管理的数据库集合中提供非常精细的控制，例如行、表或文档级别的控制，具体取决于使用的数据库引擎类型。

数据库管理系统（DBMS）为数据库生态系统增加了强大的功能和灵活性，在大多数情况下也提高了易用性。在生产环境中，完全可以直接使用数据库引擎，很多人也确实这样做。但总体来说，DBMS 主导着企业的数据存储。当人们使用*数据库服务器*这一术语时，按照定义，他们指的是包含 DBMS 的主机。正是 DBMS 的网络能力使得数据库能够存储在专用服务器（或服务器集群）上并从中提供服务，而不需要数据库始终与使用它的应用程序本地化。这种灵活性在应用程序增长并需要更多资源时非常重要。对于小型应用程序，在资源充足的情况下，可以将整个应用程序及其数据库托管在单个服务器上，通常直接使用数据库引擎能获得最佳性能。但一旦超出这种规模，DBMS 则是支持数据库变得更大的关键。

数据库引擎本身并不严格是一个单连接受限的系统，但它实际上是这样。虽然多个用户可以同时连接到文件系统中的同一个文件，但这会带来明显的问题。如果两个人试图在差不多相同的时间进行修改，是否会互相覆盖？如何通知其他人正在进行的更改？等等。这些问题与在 SAN 中连接多个服务器到同一文件系统时遇到的问题类似。它通过数据库文件内部使用相同的集群文件系统机制来解决这些问题。（看吧，我告诉过你，数据库就像文件系统！）

文件级锁定和访问控制可以应对轻量级使用，最多支持大约五个用户，之后会开始出现明显的性能问题。对于重度使用，即便是两个连接也会变得有问题。微软 Access 以鼓励使用 JetDB 数据库引擎（通常称为 Access 数据库）而著称，且其文件锁定性能极差，导致系统无法承载超过少量用户的使用。相同的系统可以切换到使用**MS SQL Server DBMS**，并且能够处理数千个用户，毫无问题。

因此，对于任何真正需要多重连接的情况（这可能由单个用户或多个运行中的服务实例引起，它们需要从数据库中拉取数据），都需要使用 DBMS。DBMS 提供了更多的缓存、锁定和权限控制机制。

### 识别共享数据库引擎与 DBMS 的区别

如果你是数据库新手，可能不了解常见的识别方法来判断使用的是哪种方式。有些情况非常简单，比如如果你必须配置数据库的网络连接详细信息，包括主机名和端口，那么你就知道必须涉及 DBMS。但并非所有情况都那么明显。

很多应用程序处理自己的连接细节，而你可能很难了解它们在背后是如何工作的。所以，除了寻找开放端口或类似的东西外，你可能会一无所知。

然而，一个常见的机制是要求共享映射驱动器访问文件或文件。这在除了极少数情况下的数据库管理系统（DBMS）中是不需要的，如果确实需要，那么你就遇到了严重的性能问题。将数据库文件直接共享给用户或应用程序进行访问是直接使用数据库引擎的标志。这种情况常见于许多遗留或构建不当的应用程序，因此你可能已经遇到过，或者将来会遇到，并且了解数据库引擎的工作方式有助于解释这些部署中访问、锁定、性能或甚至是数据损坏的问题。

作为系统管理员，甚至可能作为数据库管理员，假设是除了安装数据库引擎库之外，我们与运行中的数据库的互动将全部通过数据库管理系统（DBMS）进行。在这里，我们需要管理和监控服务、资源利用、安 全、补丁、访问控制等。

现在我们已经了解了数据库是什么、它们是如何工作的，以及它们的组成部分，这样我们就可以批判性地思考安全性和性能的影响。缺乏对数据库的理解，会使得解决更复杂的问题，如性能调优或有效的备份措施变得非常困难。在下一节中，我们将非常高层次地讨论数据库的类型，给我们一些关于系统管理员如何处理这些不同数据存储形式的见解。

# 比较关系型和 NoSQL 数据库

数据库分为两大类：*关系型* 和 *NoSQL*。这些分类非常糟糕，但不幸的是，它们就是世界上看待数据库的方式。这些术语非常糟糕，原因有几个。首先，NoSQL 是指 *非关系型*。这意味着数据库要么是关系型，要么是非关系型。这本身就是一个很糟糕的分类法。更糟糕的是，SQL 是与关系型数据库常关联的 *结构化查询语言*；它是为查询关系型数据库而编写的语言。因此，NoSQL 这个术语指的是非关系型数据库，但这就像试图通过称人们为非英语使用者来指代那些不是来自英格兰的人。两者有时会重叠，但通常不会。

SQL 不是关系的内在语言；它只是用于查询关系的常见约定。你可以创建一个不能使用 SQL 查询的关系型数据库，同样，你也可以创建一个可以使用 SQL 的非关系型数据库！不仅可以，事实上，这非常常见。所以，为了明确一点，你可以在 NoSQL 数据库中使用 SQL，而且人们经常这么做！这是什么疯狂的事情？

在 NoSQL 世界中，通常每个数据库都会使用一种或多种查询语言。这些查询语言通常是特定于每个数据库的，但没有某种查询语言，就几乎不可能将数据导入或导出数据库。正是这些语言构成了数据库与应用程序之间通信的基础。例如，MongoDB 实现了他们自己的 MongoDB 查询语言。

所以我们必须接受这些术语从一开始就很荒谬，并意识到我们所讨论的，一方面是关系型数据库，另一方面是所有其他非关系型数据库，这是一种包含许多不同数据库技术的集合。这种奇怪的情况之所以存在，仅仅是因为大多数流行且知名的数据库都是关系型的，且很多年里人们一直认为只有关系型数据库才是*足够好的*，适合生产使用。事实证明这一观点完全不正确，但它在行业中仍然产生着影响。

因此，NoSQL 本身就让人感到望而生畏，因为它包含了这么多的内容和数据结构类型。话虽如此，我们并不需要了解所有的内容。我们真正需要理解的只是，NoSQL 数据库可以使用任何类型的磁盘上的数据结构（当然，除了关系型数据库），并且可能会使用 SQL 或其他查询语言，也可能不使用。这就留下了更多的问题而不是答案。作为系统管理员，我们通常只是被要求学习应用程序所需要的数据库。这可能是一些非常常见的数据库，关于它有大量的知识，或者它可能是一些非常冷门的数据库。

第一代数据库按今天的标准来看，实际上是 NoSQL 的。这就让人觉得很奇怪，为什么早期的数据库现在被认为与后来的数据库不同。早期的数据库功能非常有限。在 1970 年代，关系型理论出现，随之而来的是第一批真正的现代数据库。关系型数据库诞生了，并且证明它们既安全又高效，以至于其他类型的数据库几乎在短时间内都被淘汰了。关系型数据库成为了王者，且永远存在。

几十年来，关系型数据库几乎代表了所有商业级数据库，其他类型的数据库几乎只存在于历史注脚中。当它们应用于实际系统时，通常是由应用程序独立实现的，而不是由大型数据库供应商提供。因此，即使它们被使用，它们也相对不为人知。一个嵌入在应用程序中的数据库引擎对系统管理员来说基本是不可见的，因此即使这些数据库引擎被定期部署，只有原始开发者才会知道。事实上，我的职业生涯开始于 20 世纪 80 年代末期，当时我为一个 NoSQL 数据库引擎编写了代码，并为其开发了一个图形化数据检索系统。我亲眼见证了开发者使用 NoSQL 数据库，而信息技术部门对其毫无了解的现象，这正是在关系型数据库占主导地位的时期。

关系型数据库的优势来自于其存储数据的高效性，这在数据库早期几十年尤其重要，那时找到足够大的存储系统来容纳数据一直是一个挑战；同时，它还能很好地处理诸如事务和数据完整性等问题。这使得关系型数据库非常适合任何处理金融或其他关键事务的系统，这些系统需要高水平的保证，确保事务要么完全完成，要么根本不发生。早期的数据库自然非常注重金融事务，因为这些数据存储操作极为关键，足以证明使用昂贵计算机来确保数据准确无误的必要性。当数据库的实现成本达到几百万美元时，可以轻松理解为什么银行会使用它，但要为其运行一个博客就显得非常难以合理化了。

关系型数据库得名于它们用于指定数据之间实际关系的方式。例如，如果你创建了一个用户数据，你可能会创建一个电话号码数据，并在它们之间建立关系。接着你可能会创建更多数据，比如地址。这个地址也会与用户有关联。关系型数据库背后的基本理念是数据库引擎会主动控制这些关系。比如，如果删除用户，它可能会自动删除电话和地址；它可能会确保一个电话号码只能属于一个人，或者可以显示多个人住在同一个地址。它甚至可以阻止你创建不符合某种格式的电话号码，或者阻止你填写不完整的字段。

关系型数据库听起来可能简单且表面化，但当它们被精心设计并加以应用时，能够为数据完整性提供强大的保护。它们大大减轻了软件开发人员的负担，并且将数据完整性置于一个能确保保护数据的约束条件下，即使使用这些数据的应用程序被绕过了。关系型数据库是一种强大的机制，但这种强大是以复杂性为代价的。

NoSQL 数据库由于不受关系型数据库规则的约束，也不必使用 SQL 方言，因此可以探索各种数据存储和完整性方法。一些方法以一种*享乐主义*的随意态度处理数据，这对传统的数据库管理员来说简直是震惊。数据可以随意存储在任何地方，几乎没有任何控制。虽然可能存在某种结构，但这种结构更像是一种建议，而不是强制要求。从关系型理论的严格规则出发，例如，文档数据库就像是“荒野西部”：数据随意乱丢。一个文档的结构可能根本与下一个文档不匹配。这简直是数据逻辑的混乱。

NoSQL 的真正优势来自于这种灵活性。我们不再需要在一个强预定义的、严格约束的模式下工作，而是可以根据特定需求自由使用数据，选择最合适的方式。我们可以用博客作为一个极好的例子，它与财务数据在关注点上几乎是完全相反的。

对于财务数据，我们通常非常关注准确性、一致性和事务完整性。而对于博客，我们更多关注的是速度，其他的则不太重要。如果我们有一个受欢迎的网站，并希望让我们的博客在全球范围内快速访问，我们很可能会希望通过全球各地的节点来提供该内容，从而让大多数人能够从相对本地的副本中获取博客内容，而不是使用一个可能托管在其他大陆上的远程集中式博客。

一个通过复制到多个地区来提供内容的数据库，并且将速度作为首要优先级，可能会错过最新的更新，或在数据更新过程中短暂地出现顺序错乱，而这正是关系型数据库设计时会避免的情况。能够在时间允许的情况下复制数据，同时仍然提供本地可用的数据，可以带来显著的性能提升。对于许多工作负载而言，这种性能权衡是理想的选择。

随着越来越多的系统被计算机化，越来越多的工作负载使用数据库，这意味着数据库的使用方式正在变得更加广泛。如今，数据库的实现往往*免费*或成本极低，这意味着几乎所有事情都将在某个阶段使用数据库。如今，数据库不再是仅仅为高需求工作负载所专用的工具。

仅提供非常简单的查找、会话缓存等功能的数据库并不常见。或者是替代文本文件用于日志记录的数据库，能够更快速地访问日志数据，并且更重要的是，可以对这些日志进行强大的搜索，现在几乎随处可见。NoSQL 正在让数据库世界变得更加强大和灵活。

作为系统管理员，我们很少，甚至几乎不可能，有机会选择在任务中使用哪种数据库类型。即使了解哪些数据库类型在不同情况下最为有用，这通常也是不必要的，尽管这可能非常有趣。更重要的是，我们需要理解，数据库现在呈现出丰富的多样性，尽管它们之间有许多共同的系统管理特点，但不再有诸如 SQL 是通用语言的内建假设，而我们的应用程序将决定我们需要学习和支持哪些数据库类型和产品。

理解关系型和 NoSQL 数据库代表着我们*两大阵营*的数据库产品后，我们将简要概述目前在你的 Linux 生态系统中最有可能出现的实际产品。

# 在 Linux 上发现常见的数据库

大多数操作系统都有一两个非常流行的关键数据库产品与之相关。例如，Windows 上的数据库产品是 Microsoft SQL Server。Linux 在这方面则完全不同。Linux 不仅没有一个特定的数据库产品与操作系统紧密地在意识形态上相关，而且通常有大量的数据库选项已经包含在几乎每个 Linux 发行版中。这使得成为一名 Linux 系统管理员变得更加具有挑战性，因为人们期望你不仅要了解各种不同的数据库产品，还要能够管理它们。与此相对的 Windows 系统管理员通常只需要了解一个非常固定的产品，就可以声称自己具备了该领域的基础知识。尽管许多数据库*可以运行*在 Windows 上，但除了 MS SQL Server 之外的其他任何数据库都被视为特例和专业知识，通常不会期望你有任何相关经验或知识。

在 Linux 上，大多数情况下不会期望你对每个可能的数据库选项都具备非常深入的知识，但期望你了解其中的许多并能够准备好管理几乎任何数据库系统是相当普遍的。单个服务器上部署多个数据库管理系统是很常见的，因为它们是内建的，并且相比 MS SQL Server 更加针对特定目的，因此一个数据库管理系统负责某一特定任务，另一个负责处理数据存储需求截然不同的任务是常见的，并且非常有效。

我们将保持数据库类别的自然划分，考察常见的关系型数据库产品以及非关系型或 NoSQL 数据库产品。

## Linux 上常见的关系型数据库

可能在 Linux 上最著名的四个数据库，甚至可能是全球最著名的数据库，是关系型数据库。这四个大牌是**MySQL**、**MariaDB**、**PostgreSQL** 和 **SQLite**。排名第五和第六的数据库（不分先后）是 **Firebird** 和 **MS SQL Server**。没错，你没看错，那个 Windows 生态系统中的关键数据库产品也可以在 Linux 上使用。

### MySQL

与任何其他数据库相比，MySQL 与 Linux 系统几乎是同义词。MySQL 可能在 Linux 上最为人知，但它也正式提供 Windows 版本，并在 Windows 上有一定的使用量。MySQL 功能强大、速度极快且极其知名。几乎每个 Linux 系统管理员都曾经使用过它。MySQL 是一个完整的数据库管理系统，包含多个数据库引擎。

MySQL 首次真正流行是作为早期动态网站的数据库。它免费、速度快，且缺乏更高级的金融交易所需的功能对于内容管理引擎（如博客和类似的动态生成内容的站点）来说并不重要。MySQL 被称为*首选*产品，用于网站需求，但由于这种刻板印象，它常常被其他需求排除在外。

今天的 MySQL 已经成熟、先进，具备几乎所有你可能需要的功能，适用于任何类型的工作负载。如果你只打算学习一个数据库管理系统，MySQL 肯定是最好的选择（或者是 MariaDB，我稍后会解释）。MySQL 拥有最广泛的用户基础，几乎所有具备 Linux 经验的系统管理员，以及很多没有 Linux 经验的管理员，都能自信地管理它。针对它也有大量标准工具，比如 phpMyAdmin，当你想避免或超越命令行时，它能让你更轻松地使用 MySQL。几乎所有为 Linux 开发的主要应用项目都在某种程度上使用 MySQL，尽管它可能不是最常部署的数据库，但与 MariaDB 结合使用时，它是最常被*有意*部署的数据库，不仅在 Linux 上，在所有操作系统上都是如此。

### MariaDB

真的很难谈论 MySQL 而不提到 MariaDB。MySQL 的社区和方向在多年前分裂，许多原 MySQL 团队成员离开了这个项目，将开源基础带走，创建了 MariaDB，旨在成为他们认为的 MySQL 的精神继任者。对许多人来说，MariaDB 才是*真正的* MySQL，因为它在理念上与原始产品一致，完全基于相同的代码库构建，而且由原始团队开发。许多 Linux 发行版，可能大多数，放弃了 MySQL，改用 MariaDB。甚至现在，大多数声称使用 MySQL 的人实际上是在使用 MariaDB——往往连他们自己都不知道。

## 即插即用替代品

MariaDB 的真正亮点是它是 MySQL 的完整 *即插即用替代品*。这意味着它被设计成能够完全透明地在任何使用 MySQL 的地方使用。它使用完全相同的协议、接口、工具、名称、端口、约定等。理论上，所有的东西都是一样的。

MariaDB 做得如此出色，以至于许多人在说自己使用 MySQL 时，实际上他们使用的是 MariaDB。有些人说这有点像是一种代码；还有人说是因为管理层期望这样做，而解释为什么使用 MariaDB 而非 MySQL 是不值得的；还有一些人根本不知道自己安装的不是 MySQL。管理 MariaDB 最常用的工具是 `mysql` 命令行工具，这也是许多人接触系统时最接近实际系统的工具。一个数据库设计师或开发人员只需要知道该系统与 MySQL 兼容。没有真正的迹象让他们怀疑这到底是某个产品或另一个产品。它们看起来和运行起来的方式完全一样。

现在人们常常提到著名的 LAMP 堆栈，曾经是 Linux + Apache + MySQL + PHP，现在变成了 Linux + Apache + MariaDB + PHP。看起来 MariaDB 确实已经完全取代了 MySQL 在市场中的位置。但很难准确评估这一点，因为在 MariaDB 市场中，有一个不确定的大比例部分报告自己使用 MySQL，要么是因为他们没有意识到它们是不同的，要么是因为他们随意报告不准确，要么是他们根本不知道自己在使用什么。

即插即用的兼容性带来了额外的好处，即学习 MySQL 就意味着学习 MariaDB，反之亦然。你无需学习一个或另一个，因为你在一个系统上做的所有事情，在另一个系统上也完全一样。

### PostgreSQL

无论看起来多么不相似，*post gress* 的发音使得 PostgreSQL 可以说是今天在 Linux 系统上最成熟和先进的数据库。PostgreSQL（最初写作 POSTGRES）始于 1980 年代，作为成功的 Ingress 数据库产品的继任者（**Postgres** 意味着 **POST inGRESs**）。

今天，PostgreSQL 常被认为是 Linux 系统上最快速、最稳定、功能最丰富的数据库产品，甚至可能是所有数据库中最优秀的。像这样的数据库区别通常更多的是个人意见，因为性能测量很少可以直接比较，并且功能差异往往比直接的查询性能更为重要，但 PostgreSQL 的声誉无疑是无可匹敌的卓越，代价是相比于其竞争对手，它更复杂且不太为人所知，而后者通常被认为是更简单的系统。

近年来，PostgreSQL 在流行度上经历了重大复兴。今天，你会发现越来越多的部署软件支持并甚至推荐它作为首选数据库，这是自十多年前 MySQL 的全盛时期以来，数据库界的一大变化。

作为一名 Linux 系统管理员，PostgreSQL 数据库生态系统是一个稳固的第二选择，甚至可能是首选，与 MySQL（以及与 MySQL 相同的 MariaDB）一起学习，因为大多数 Linux 系统管理员在某个时刻都需要管理 PostgreSQL。

### SQLite

比大多数系统管理员意识到的更常用的是 `sqlite` 客户端工具，你可以用它来读取和修改 SQLite 数据库文件，但这与数据库服务器完全不同。

SQLite 的强大之处在于它的简单与微妙。除了安装其访问库外，系统管理员通常不需要了解系统中是否存在 SQLite。它不需要调优或配置。它就存在在那里。由于软件仓库和自动依赖管理的魔力，SQLite 通常会作为其他软件的依赖项被部署，我们甚至可能没有意识到它已被安装或可用。它自动出现并完成它的工作。甚至它可能被内建在使用它的应用程序中，且可能以我们无法在系统中搜索到的形式存在！

由于 SQLite 的存在和部署方式大多数时候是这样，普通用户对 SQLite 的部署情况一无所知。正常的安装并不会隐藏驱动程序：系统管理员如果想要发现它、修补它或仅仅是查找它在哪里，通常都不会遇到什么困难。但是除非你特别在寻找它，典型的服务器上可能会有数百甚至上千个类似的软件包，我们通常无法花时间去了解每个系统上存在哪些库，更不用说知道哪些软件依赖于哪些包了。这实在是不切实际的。

### Firebird

相比 MySQL、PostgreSQL、SQLite 和 MariaDB，**Firebird** 的知名度要低得多。Firebird 是一个完整且成熟的数据库管理系统，基于 Interbase 6，但在 2000 年与该项目分离。尽管在 Linux 世界中被视为相对次要的软件，但 Firebird 依然是一个功能强大且成熟的数据库管理系统，其主要的特点是所需的系统资源非常少。

Firebird 在对话中出现的概率远高于实际部署到你的服务器上。它实在是不太常见。Linux 上有很多数据库选项，这使得即便像 Firebird 这样成熟且严肃的数据库选项也很难获得关注。

### Microsoft SQL Server

这份榜单上的参与者总是让那些不了解其可用性的人感到震惊。长期以来，微软 SQL Server 被认为是市场上最好的数据库产品之一，但始终仅限于微软 Windows 操作系统。但近年来，微软试图在数据库许可空间（与操作系统许可相比更具吸引力）获得更多市场份额，开始将 MS SQL Server 发布到 Linux 以及 Windows 上。如今，MS SQL Server 对 Linux 系统管理员来说已经是一个完全合理且可行的选择。

像这份榜单上大多数传统选项一样，MS SQL Server 是一个完整的数据库管理系统，其内部有多个数据库引擎。它是一个功能强大的产品，具备许多高级功能和特性。

MS SQL Server 在 Linux 上仍然不常见，并且可能会在相当长的时间内保持这种状态。但它已经比例如 Firebird 要普遍得多。数据库部门通常非常专注于 Linux，或者至少是 UNIX 系统，因此如果应用程序需要 MS SQL Server，而团队通常不使用 Windows Server，则必须管理一个完全不同的平台，这是一个问题。

## Linux 上常见的 NoSQL 数据库产品

如果关系数据库产品的列表看起来很长，那与我们可以讨论的 NoSQL 或非关系数据库产品的潜在列表相比根本不算什么。与关系数据库列表不同，其中所有产品都以类似的方式工作，并且适合由类似的软件任务使用，NoSQL 列表变化多端。对于一个任务来说是一个了不起的产品，对于另一个任务来说可能完全没用。

我们不可能详尽介绍这些数据库产品的所有细节，甚至只是涵盖这个类别的各种数据库类型。仅仅是 NoSQL 数据库的例子就可以轻松填满一本这样大小的书。我们将尽力快速概述并提供足够的亮点，让您了解存在哪些产品、为何重视以及如何开始自己的产品调研。

### MongoDB

无疑，在 NoSQL 领域的头号领导者是 MongoDB。MongoDB 被称为文档数据库管理系统。像许多我们提到的数据库管理系统一样，MongoDB 可以使用多个数据库引擎，但如今几乎所有使用它的人都使用其**WiredTiger**数据库引擎。文档数据库是最接近关系数据库的 NoSQL 数据库类型之一，许多情况下两者都能胜任。文档数据库几乎就像我们把关系数据库和传统文件系统放在一起，它们在中间相遇。

## 文档数据库

文档数据库存储结构化文档。尽管每个文档数据库可以使用自己的格式和方法，但这一概念是通用的。一个好的例子是 XML。XML 可以是文档数据库中单个文档的格式。数据库可能会规定 XML 的结构，或者它可能是自由格式的。数据库可能包含数百万个这样的 XML 文档。

由于数据库知道其包含文档的预期用途，因此它能够使用文档中的共同字段生成索引和其他工件，使数据库能够执行更多操作，远超过你将这些 XML 文档简单保存到硬盘上所能做到的。

但只需要像这样的一个简单例子，你就会开始明显地意识到文件系统不仅仅是一个数据库，而是一个专门的文档数据库！

文档数据库通常易于使用，非常直观，使开发人员和系统管理员的工作变得轻松。它们已被证明是关系型数据库在许多常见工作负载中非常理想且有效的替代品。

MongoDB 在各种不同的场景中得到了广泛部署和使用。像我们最初提到的大多数关系型数据库示例一样，MongoDB 通常与第三方软件包一起使用，也会在 Linux 发行版供应商的软件包中出现，同时它也在内部软件团队进行定制开发时仍然很受欢迎。如果你打算在 Linux 上开始尝试 NoSQL 数据库，我通常会建议你从 MongoDB 开始，因为即使 MongoDB 最终没有成为你在生产环境中支持的数据库管理系统，它几乎肯定会提供最有价值的经验。

MongoDB 是探索许多替代数据库方法的绝佳途径，其中许多方法在 *关系型之后* 的世界中已经成为某种标准。

虽然文档数据库已被证明是关系型数据库在常见软件使用中的最常见替代方案，但并不是很多文档数据库都崭露头角。MongoDB 是唯一一个真正的大型、知名的例子。其他例子包括 **Apache CouchDB** 和 **OrientDB** 作为数据库管理系统，以及 **NeDB**，它是一个数据库引擎，数据结构几乎与 MongoDB 完全相同。

### Redis

存储数据的另一种完全不同的方法是 Redis，它是一种所谓的键值存储数据库管理系统。这种类型的数据库作为辅助存储而非主要存储更加流行。键值存储的思想是，使用该数据库的应用程序提供一个键，数据库返回与该键关联的数据。与我们已经遇到的数据库类型相比，它是一种极其简单的机制，但却是非常有用的。

键值存储（有时称为字典查找）常用于高速在线缓存，是管理如会话数据等数据的一种极好方式。虽然应用程序仅使用键值数据库作为唯一数据存储机制的情况很少，但也不是不可能。几乎总是作为多部分数据库策略中的一部分。

Redis 为巨型在线应用提供了许多所需的高级功能，例如跨节点集群的能力和方便的访问方法，这使得它在大型应用中非常受欢迎。它的性能和简便性使其在网页托管领域广受青睐。

其他的键值存储仍然很受欢迎，例如**memcached**，它在 Linux 上用于网页托管非常流行，**LevelDB**，甚至是**MS SQL Server**下的一个键值数据库引擎。

### Cassandra

一个与关系型数据库和文档数据库在*通用应用*领域的主要竞争对手是宽列数据库，最著名的就是 Cassandra。宽列数据库比我们在这里能涵盖的要更值得关注和描述，但无需多言，它们主要处理与关系型数据库相同的工作负载，并且在大多数情况下关注于更大的灵活性和可扩展性。

与 Cassandra 一起，**Apache HBase**和**ScyllaDB**是常见的 Linux 下的主要宽列数据库。你不会像看到键值和文档数据库那样频繁遇到这种类型的数据库，但它有一定的市场份额，且易于获取和实验，如果你希望扩展自己对数据库特性或类型的了解，它是个不错的选择。

更进一步：NoSQL 并不局限于定义，专用数据库和数据库类型不断涌现。我还建议你调查一下**Amazon OpenSearch**，这是一个搜索数据库，以及**InfluxDB**和**Prometheus**，它们是时间序列数据库。这三种数据库，以及这两类数据库，通常用于以高速和大容量存储日志或类似日志的数据。

不要害怕自己去搜索新的或有趣的数据库方法和产品。这个领域发展迅速，书本的内容很快就会过时。Linux 在数据库平台方面在市场份额、稳定性、性能和多样性等各个方面都是领先的。你应该对主要的产品有所了解，知道自己发行版中包含哪些内容，以及你的应用程序可能使用哪些数据库。同时要对你需要投入的工作有一个大致的了解。记住，一些组织会继续使用专职的数据库管理员来处理与系统管理团队分离的数据库任务，但几乎所有公司都会将这些角色合并，导致你需要理解多个数据库平台的情况通常会落在你身上。

我们现在对在 Linux 系统管理的实际环境中可能遇到的产品有了很好的理解。所有这些数据库概念都很有趣，并且很激动人心，能够接触到许多不同的产品总是令人兴奋，但真正重要的是我们如何保护这些系统，这也是我们在下一部分将要讨论的内容。

# 理解数据库复制和数据保护概念

从 Linux 系统管理员的角度来看，数据库保护将是最重要的事情，这包括，正如它对系统整体所做的那样，灾难避免和灾难恢复。因为数据库至关重要，而且非常普遍，此外它们的需求与我们通常在系统中遇到的需求截然不同，所以我们在这里单独讨论，以便能够处理与数据保护相关的数据库世界几乎独特的需求。

因为数据库存储的是结构化数据，所以它们面临着保护那些高频使用的存储系统的所有挑战，实际上它们就是这样的存储系统。由于数据库高度有状态，我们必须非常小心，以免在进行数据保护时破坏状态。

这些在最简单的术语中是什么意思？基本上，数据库就是用来存储数据的，为了有效地进行数据存储，它们需要同时保持代表其数据的文件在磁盘上打开，并且通常在任何给定的时间都要在内存中保持大量的数据。这给我们带来了在数据保护方面的几个挑战。

打开中的文件始终是备份的难题。没有好的方法来备份当前被应用程序打开的文件，因为我们无法知道文件写入时的状态。也许文件目前是完全正常的，或者可能它已经被部分修改，数据是乱码，直到更多的当前内存数据或可能尚未计算的数据被添加到文件中，或者文件的格式没有损坏，但文件中的数据已经不再准确。从使用该文件的应用程序外部，我们无法知道一个打开文件的实际状态，除了它无法被信任以外。

因此，大多数基于文件的备份将会忽略该文件，因为它们无法锁定文件进行备份。对于大多数文件来说，这并不是问题，因为文件只偶尔被锁定，如果你定期进行备份，通常会最终获得某个文件的有效备份。这可能不是确定性安全的，但它是统计学上安全的。如果你需要确定性，你可以使用日志查看关键文件是否已经安全备份。

基于块的备份，也就是从块设备层而不是文件层进行备份，并且不关注单个文件或文件系统的机制，能够轻松地备份打开的文件，但它们无法判断文件是否处于安全或准确的状态。所以，在第一种情况下，我们假设打开的文件会被简单跳过。在第二种情况下，我们假设会备份它，但该备份的准确性只能在恢复时确定。当然，这两种选择都不是理想的。两者都比什么都没有要好。

传统的将*也许我们有一个好的备份*或*我们几乎总是有一个好的备份*转变为完全知道备份是好的方法是使用一个代理，该代理通知应用程序完成事务，将所有数据写入磁盘并在备份操作期间关闭文件。有些应用程序具有执行此操作的机制，API 调用会通知它们准备进行备份，而对于其他应用程序，你需要通过暴力方式，在备份之前完全关闭应用程序，并在备份完成后重新启动它。这里的问题是，只有极少数应用程序支持这种通信方式，而任何备份软件代理必须分别支持每个独特的软件才能做到这一点。所以，这需要双方的合作，考虑到市场上应用程序和备份工具的数量，这种合作并不常见。因此，这种方法是不切实际的。

许多应用程序采取的做法是通过执行内部数据转储过程来获取它们自己的*备份*，并以安全的方式将数据保存到另一个存储位置。这些文件是应用程序中所有数据的完整副本，并且保持关闭状态，仅供备份软件读取和使用，而不是使用实时数据。这为绕过因打开文件导致的数据损坏问题提供了一种通用机制。它易于应用程序开发人员实现，并且与所有备份软件通用。

这种方法完全有效，但有一个重大警告：我们必须关闭应用程序才能使其工作。这意味着我们必须有一种方法，能够在正确的时间关闭应用程序，并在正确的时间重新启动它。这个部分通常是可行的，并且不需要太多工作，尽管除了少数常见的应用程序外，通常都是手动操作。但真正的问题是让组织同意定期关闭应用程序，以便进行备份操作。不同于系统重启，我们通常只希望每周或每月进行一次重启，我们通常至少希望每天进行备份，有时是每小时一次，甚至几乎是持续备份。这并不是我们总能做到的事情。

除了预定备份频率之外，通常我们还希望能够随时进行*临时*备份。如果*临时*备份会导致应用程序停机，这通常是不可接受的。因此，需要其他方法来处理。

所有这些因素共同作用，使得数据库备份成为一个严重的问题。数据库几乎总是你 IT 基础设施中最关键的*幕后*工作负载组件，最无法承受任何长时间或意外停机的影响，通常也是唯一需要无限期保持文件打开的组件，并且备份对它们来说至关重要。

这个挑战远远超出了备份问题。如果我们处理的是无状态的应用程序，而不是数据库，例如典型的网站，我们有许多复制选项，可以简单到仅仅是将应用程序目录在服务器之间复制。负载均衡选项可以简单到将部分流量引导到一个应用服务器或另一个应用服务器。在大多数情况下，非数据库应用程序的复制、备份甚至负载均衡都很简单。

对于数据库，我们没有简单地在系统之间复制文件的选项。为了确保数据一致性和更新，运行在每个主机上的数据库管理系统需要相互协调，确保诸如锁定、缓存和磁盘刷新等概念能够一致地执行，并在集群中进行通信。如果复制功能对你所使用的数据库管理系统来说是可选的，它通常相当复杂，并且有很多限制。没有简单的方法能够在不引入显著性能挑战的情况下实现数据库的复制或集群。

因此，既要保护数据库免受故障影响，又要确保在出现故障时能够轻松可靠地恢复，这是一个挑战。尽管实现这一目标的技术在最高层次上可能有些共性，但它每次都需要在特定工具层面上进行配置和应用。所以，了解一个生态系统如何处理这些问题，并不一定能反映到另一个生态系统中。

在所有情况下，备份、复制和集群将由数据库管理系统本身或专门为该数据库设计的工具来处理。系统的功能将是该数据库独有的。例如，一些数据库管理系统仅支持非常简单的集群，可能只是通过一对镜像服务器，或者仅支持单个节点能够进行磁盘修改，而集群中的其他节点则保持部分或全部数据的缓存副本，并负责提供读取请求。另一些系统具有巨大的可扩展性，可能允许数百个独立节点，每个节点都能完全读取和写入数据！

因此，由于这种复杂性，我们必须完全单独学习每个产品。NoSQL 数据库有一种强烈的*tendency*，即具备复制和冗余选项。这通常源于缺乏控制和约束。此外，大多数 NoSQL 数据库是在近年来构建的，而大多数关系型数据库则已有几十年历史，因此它们设计时的考虑因素截然不同。今天你所了解的大多数关系型数据库首先必须适应网络，然后是互联网，这一过程持续了许多年。几乎所有你将遇到的 NoSQL 数据库都是在互联网成为日常生活的一部分之后几十年才创建的。

在许多情况下，将数据库放入集群中时，会通过锁定数据库的某些文件、记录、文档、行或其他离散部分来工作，并向其他集群成员发出锁定信号。然后，原始系统等待所有成员以确认锁定的方式进行通信。一旦被锁定，系统就无法写入新数据到系统的至少某个部分，必须在解锁后才能继续执行数据存储请求。在某些情况下，这种锁定可能非常快速，或者可能对存储产生足够大的影响，从而影响应用程序的可用性。在单服务器数据库上执行此操作可能会产生显著影响。在集群中，由于集群节点需要相互等待以完成其锁定任务并相互报告，这种影响可能会放大很多倍。如果我们还需要在等待互联网延迟和可能发生的故障时进行相同的操作，锁定操作的潜在影响规模可能会再次放大很多倍。锁定可以确保一致性，但总是以性能和复杂性为代价。我们的数据库系统越大，即使是锁定系统的一部分，其潜在影响也越大。

传统上，尤其是在关系型数据库中，我们假设通过*纵向扩展*来提高性能——即增加更多的 CPU、更快的 CPU、更多的内存以及更多或更快的存储。这种方式在我们需要中心化地访问数据时非常有效，直到我们能够不断将更多、更快的 CPU 压入一个单一的盒子中为止。之后，我们就会遇到性能瓶颈，卡住了。

如今，我们越来越多地看到*分布式*设计，即向集群添加更多的较小节点，就像我们在早期章节中讨论的那样。关系型设计并不完全无法使用这种模型，但在期望写入和读取操作与系统扩展时，它们往往难以高效运行。NoSQL 已经采用了这种数据访问需求，并以非常高效的方式进行了处理。新的数据库从头开始设计，以此为基础，通过在顶层（例如通过 SQL 语言查询）提供通用关系接口，为旧设计增加了新的性能选项。

数据库集群引入了新的潜在数据保护计划复杂性。根据数据库和数据完整性设计，备份或复制操作可能需要一些戏剧性的措施，例如在备份过程中暂时*冻结*整个数据库集群。或者可能需要从各个节点收集数据，每个节点都包含独特的数据，以组装完整的备份数据，这些数据在备份操作之前在任何一个位置都不存在完整。这种方法通常称为分片数据库，从逻辑上讲很有挑战性，因为可能存在一定规模的数据，没有节点能够很好地处理，而且数据恢复也可能很复杂，因为数据必须重新输入到集群中并分发到节点上。重新组装数据可能是一项艰巨的任务。其他数据库可能只是*随机应变*，提供它们所拥有的备份，而不与其他集群节点进行检查。这一切取决于数据库及其设置。

当处理数据库集群时，有许多考虑因素。虽然我们可以在这里讨论高层次的方法，但在现实世界中，每个数据库甚至数据库部署都是独特的。我们需要查阅有关独特设置的文档，并注意确保整个收集和存储数据过程的一致性。

我们还必须考虑直接数据库引擎的情况，这些引擎不包括数据库管理系统。在这种情况下，没有数据库管理系统来创建一致的备份文件到磁盘或处理复制。任何数据保护功能都需要由使用数据库的应用程序处理，而不是由数据库产品来完成工作。对系统管理员来说，这种情况非常困难，因为每个应用程序都可能非常独特和具有挑战性。当然，我们可以*随时*通过关闭应用程序甚至整个服务器来进行备份，但这不是一个理想的过程。

使用数据库引擎时，如果我们希望在不关闭系统的情况下实现任何数据保护功能，我们需要依赖相关应用程序提供这些功能。*这*可能提供最佳的数据保护选项（当然，也包括在数据库管理系统上运行的应用程序提供类似功能），因为应用程序本身通常会拥有对数据库的独占访问权限，并且对整个应用栈的当前使用案例有全面了解。理论上，应用层凭借其对系统状态和预期使用案例的额外了解，可以在更有意义的时间进行备份，并以更动态的方式存储备份。

例如，应用层可以实时复制部分数据，只有那些被认为至关重要的数据，复制到一个任意的数据存储位置，可能是异地。也许它将数据记录在类似日志的结构中，以便重新创建。或者它知道何时会出现写操作的停机时间，并且可以锁定数据库，并用比数据库管理系统本身更智能的方式进行复制，或者应用层可以在将数据写入数据库存储之前，跨应用节点复制事务以确保一致性。应用层凭借其更深的洞察力和灵活性，可以使数据存储层变得更好。

应用层备份有可能做出一些有趣的事情，比如基于一天中的空闲时间进行备份，并能够自动化备份和恢复。如果应用程序允许，自动化新节点的设置将是一个巨大的好处。

正如在数据库集群的情况中所说，每种情况可能是独特的，并且需要了解应用程序，了解它为数据完整性提供的支持，并结合我们自己的知识，确保能够实现一致且完整的数据集。一个集群化的应用程序可能会呈现与集群化数据库相同的挑战和机会。

# 总结

数据库几乎是我们作为系统管理员需要处理的最重要的事情。无论是我们自己运行数据库，还是仅仅管理运行数据库的操作系统，它们都将需要我们更多的关注，并且比我们做的任何事情都更容易给我们带来压力。在处理数据库时，我们的技能和专业知识将变得尤为重要，且我们的技能范围在这里将会受到最严峻的考验。

无论数据库在哪里运行或使用，我们都需要评估数据如何存储在磁盘上，如何确保一致性，以及如何将这些一致的数据移动到备份位置，无论是磁带、在线存储还是其他。这可能是我们在系统管理中做的最重要的任务，无论是在 Linux 还是其他系统上。

我们关于数据库的最佳实践真正集中在数据保护上。我们很想讨论如何选择适合我们执行的任务的正确数据库类型，但除了最少数几种情况外，这些决策通常在任何事情到达系统管理团队之前就已经做出了。

数据库备份的最佳实践是确保使用完整、一致、完全安全的、封闭的数据集作为备份源，以确保数据保护是可预测的。无论是由数据库、使用数据库的应用程序，还是手动处理，都必须有一个机制，确保在数据获取时数据不会处于传输中。

在集群场景中，同样的逻辑适用。但现在我们必须确保，在整个集群的上下文中，节点可以访问的数据是准确且完整的。

在下一章中，我们将开始深入探讨那些不那么引人注目但极其重要的领域——文档、监控和日志记录。
