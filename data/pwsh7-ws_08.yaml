- en: '8'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '8'
- en: Writing Our First Script – Turning Simple Cmdlets into Reusable Code
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编写我们的第一个脚本 – 将简单的 Cmdlet 转换为可重用代码
- en: 'Starting in this chapter, we’re going to look at how we can put the basic concepts
    we’ve learned together into scripts and tools that we can reuse, adapt, and distribute
    for others. In the coming chapters, we’re going to look at creating functions
    and script blocks, error handling and debugging, creating modules that allow us
    to distribute our code as tools, and finally, securing PowerShell. In this chapter,
    though, we’re going to start with the basics: turning a handful of cmdlets into
    a script.'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 从本章开始，我们将学习如何将我们学到的基本概念结合起来，编写可以重用、调整和分发给他人的脚本和工具。在接下来的章节中，我们将讨论如何创建函数和脚本块、错误处理和调试、创建模块使我们能够将代码作为工具分发，最后，我们还会讨论如何保护
    PowerShell。但在本章中，我们将从基础开始：将一小部分 cmdlet 转换为脚本。
- en: We’ll start by discussing scripts in general and why we might want to write
    one. After that, we’ll take a quick look at where we can find PowerShell scripts
    online, and then we’ll cover how we can run scripts.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从讨论脚本的一般概念以及为什么我们可能想要编写脚本开始。之后，我们将简要了解我们可以在哪里在线找到 PowerShell 脚本，然后我们将讨论如何运行脚本。
- en: Once we understand how to use other people’s scripts, we’ll dive into writing
    our own. First, we’ll learn how to identify changing values in a working cmdlet
    pipeline, then we’ll learn how to turn those into parameters so we can pass the
    values into the cmdlets when we run the script, rather than having to edit the
    script each time. We’ll cover how to make parameters mandatory, how to take values
    from the pipeline, and how to create switch parameters, before moving on to cover
    how to help ourselves and others use our scripts.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们理解了如何使用他人的脚本，我们就会开始编写自己的脚本。首先，我们将学习如何在工作中的 cmdlet 管道中识别变化的值，接着我们会学习如何将这些值转化为参数，这样我们就能在运行脚本时将这些值传递给
    cmdlets，而不需要每次都编辑脚本。我们将涵盖如何使参数成为必填项、如何从管道中获取值以及如何创建切换参数，之后我们将学习如何帮助自己和他人使用我们的脚本。
- en: In the second part of this chapter, we’ll cover how to add comments and comment
    blocks to our script that explain what we’re trying to do in each part and help
    us and others edit and adapt the script. Next, we’ll look at how we can write
    help information that can be accessed from outside the script using the `Get-Help`
    cmdlet. After that, we’ll move on to a script construct that can help us understand
    what is going on when the script is producing unexpected output – the `Write-Verbose`
    cmdlet. Finally, we’ll cover how to add help messages for mandatory parameters,
    which will prompt users with information about how to use the parameter.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的第二部分，我们将讨论如何在脚本中添加注释和注释块，解释我们在每个部分尝试做的事情，并帮助我们和他人编辑和调整脚本。接下来，我们将探讨如何编写帮助信息，使其可以通过
    `Get-Help` cmdlet 从脚本外部访问。之后，我们将讨论一个脚本构造，它可以帮助我们理解当脚本产生意外输出时发生了什么——`Write-Verbose`
    cmdlet。最后，我们将讲解如何为必填参数添加帮助信息，提示用户如何使用该参数。
- en: 'In this chapter, we are going to cover the following main topics:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将覆盖以下主要内容：
- en: Introduction to scripting
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 脚本编写简介
- en: Writing a script
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编写脚本
- en: Identifying changing values
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 识别变化的值
- en: Working with parameters
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用参数
- en: Providing help for our script
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为我们的脚本提供帮助
- en: Introduction to scripting
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 脚本编写简介
- en: A script is a sequence of instructions written in a human-readable form for
    a computer to carry out. They are usually written in a scripting language such
    as PowerShell, Python, or JavaScript. We covered the differences between scripting
    languages and programming languages back in [*Chapter 1*](B17600_01.xhtml#_idTextAnchor013),
    *Introduction to PowerShell 7 – What It Is and How to Get It*; the key thing to
    remember is that scripting languages are interpreted and so need a program (such
    as PowerShell) to be running on the client to run the script, whereas programming
    languages are compiled; they will run directly in the operating system.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 脚本是一系列指令，用人类可读的形式编写，供计算机执行。它们通常使用脚本语言编写，例如 PowerShell、Python 或 JavaScript。我们在[*第1章*](B17600_01.xhtml#_idTextAnchor013)，*PowerShell
    7 简介 – 它是什么以及如何获取*中讨论了脚本语言和编程语言之间的区别；需要记住的关键点是，脚本语言是解释型的，因此需要一个程序（如 PowerShell）在客户端运行来执行脚本，而编程语言是编译型的；它们会直接在操作系统中运行。
- en: Scripting, to me, is an art form. It’s probably the truest cybernetic art form;
    what we write in a script has to make sense to both human beings and machines.
    In [*Chapter 6*](B17600_06.xhtml#_idTextAnchor117), *PowerShell and Files – Reading,
    Writing, and Manipulating Data*, we talked about *Exercises in Programming Style*
    by Cristina Videira Lopes, where a term frequency task was solved in dozens of
    different ways. This is equally true of scripts in PowerShell. There is no one
    way to write a script, and what seems lovely to one person may be really ugly
    to another; I have a deep loathing of code golf, where a script is written with
    as few lines and characters as possible, but that is a personal preference – other
    people love it. Simplicity, and clean and functional code – these things are beautiful,
    and it requires a creative and inventive mind to write it. In this chapter, we’re
    going to cover how I approach writing scripts.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 对我来说，脚本编写是一种艺术形式。这可能是最真实的控制论艺术形式；我们在脚本中编写的内容必须对人类和机器都有意义。在[*第6章*](B17600_06.xhtml#_idTextAnchor117)，*PowerShell
    和文件 – 读取、写入和操作数据*，我们谈到了Cristina Videira Lopes的*编程风格练习*，在其中以几十种不同的方式解决了术语频率任务。这同样适用于PowerShell中的脚本。没有一种编写脚本的唯一方法，对一个人来说看起来美好的东西对另一个人来说可能非常丑陋；我非常厌恶代码高尔夫，即尽可能少的行数和字符编写脚本，但这是个人偏好
    – 其他人却喜欢。简单、干净和功能性代码 – 这些东西是美丽的，编写它们需要创造性和富有创造力的头脑。在本章中，我们将讨论我如何编写脚本的方法。
- en: Why do we want to write scripts?
  id: totrans-15
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 为什么我们想要编写脚本呢？
- en: Fundamentally, because we are lazy. A script allows us to capture a series of
    steps that may be complicated or time-consuming, and repeat them easily without
    work. Secondly, because we are fallible and easily distracted. The longer and
    more complicated a task is, the more likely we are to make a mistake. Writing
    a script means the task will be completed in the same way every time. If we can
    get it right once and capture that process, then we almost never need to get it
    right again. We can go and make our mistakes somewhere else. Finally, because
    we don’t want to do the thing at all; if we write a script, we can give it to
    somebody else to do.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 基本上，因为我们懒惰。脚本允许我们捕捉一系列可能复杂或耗时的步骤，并轻松地重复执行而不需要额外工作。其次，因为我们容易出错和容易分心。任务越复杂越长，我们犯错的可能性就越大。编写脚本意味着任务每次都会以相同的方式完成。如果我们能够做对一次并捕捉该过程，那么我们几乎永远不需要再次做对。我们可以去其他地方犯错误。最后，因为我们根本不想做这件事；如果我们编写一个脚本，我们可以把它交给别人去做。
- en: Script writing is an example of toolmaking, where we create something to make
    our task easier to accomplish. Some script writing might be proper automation,
    but generally, automation includes the concept of a feedback loop, where the tool
    responds to an external stimulus without user intervention. A central heating
    boiler is a tool; it makes heating your house much easier than building a fire
    in each room. A thermostat is automation; when the temperature is too low, it
    turns the boiler on, and when it is too high, it turns the boiler off. If we’ve
    set it correctly, then we should never be too warm or too cold.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 脚本编写是工具制造的一个例子，我们创建一些东西来使任务更容易完成。一些脚本编写可能是适当的自动化，但一般来说，自动化包括反馈循环的概念，即工具在没有用户干预的情况下响应外部刺激。中央供暖锅炉就是一个工具；它使得加热房屋比在每个房间里生火要容易得多。恒温器是自动化的一种；当温度过低时，它打开锅炉，而当温度过高时，它关闭锅炉。如果我们设置正确，那么我们就不会太热或太冷。
- en: 'There is some theory around toolmaking and automation that is worth considering,
    as it can help us decide whether we want to write a script or not. Let’s quickly
    cover the three basic principles of automation:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 有一些围绕工具制造和自动化的理论值得考虑，因为它可以帮助我们决定是否要编写脚本。让我们快速了解自动化的三个基本原则：
- en: '**Compensatory principle**: This is based on the concept that machines are
    better at some tasks than people, and people are better at some tasks than machines.
    Automation and tools based on this principle divide work based on the strengths
    and weaknesses of people and machines.'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**补偿原则**：基于这样一个概念，即机器在某些任务上比人类更擅长，而人类在某些任务上又比机器更擅长。基于这一原则的自动化和工具根据人类和机器的优势和劣势来分配工作。'
- en: '**Complementarity principle**: Constantly using tools to accomplish difficult
    tasks can de-skill the human operator; we forget how to do things. Then, when
    we really need to take over, when things are going wrong, we can’t fix the problem.
    We use this principle where the human operator must retain the skills that the
    automation is replacing. Aircraft autopilots are a good example of this; the operator
    doesn’t use them all the time or may only use part of them so that they retain
    the skills they need when the autopilot can’t land the plane because of weather
    or a mechanical failure.'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**互补性原理**：不断使用工具完成困难的任务可能会削弱人类操作员的技能；我们会忘记如何做事。然后，当我们真的需要接管时，当事情出错时，我们无法修复问题。我们使用这个原理，要求人类操作员必须保持自动化替代的技能。飞机自动驾驶仪就是一个很好的例子；操作员并不是一直使用它们，或者可能只使用其中的一部分，以便在自动驾驶仪因为天气或机械故障无法着陆时，操作员能保持所需的技能。'
- en: '**Left-over principle**: This is the principle we most commonly associate with
    scripting. It’s the idea that we automate everything we can, and then manually
    do what is left over.'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**剩余原理**：这是我们最常与脚本编写相关联的原理。它的想法是我们自动化所有能自动化的任务，然后手动完成剩下的部分。'
- en: Of course, it’s a little bit more complicated than that. Sometimes, tasks are
    too hard to automate, or we do them so rarely it’s not worth bothering. We’ll
    not save any time or effort by writing a script. A rule of thumb is to script
    anything that will take less time to script than you will spend doing it manually
    over three years. So, if you have a task that you do every weekday that takes
    5 minutes, and it will take you 4 hours to script, then that works out at 62 hours
    over 3 years. By spending 4 hours scripting it, you’ll save over a week of work
    for yourself, over 3 years. Let’s start by understanding where we can get scripts
    that other people have written.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，这比听起来要复杂一点。有时任务太难以自动化，或者我们做得很少，以至于不值得麻烦。通过编写脚本我们并不会节省时间或精力。一个经验法则是，如果你有一个任务，每天都要做，且每次花费
    5 分钟，而写脚本需要 4 小时，那么在 3 年内，这个任务将花费 62 小时。通过花费 4 小时编写脚本，你将在 3 年内为自己节省一周的工作。让我们从了解如何获取别人编写的脚本开始。
- en: Getting scripts
  id: totrans-23
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 获取脚本
- en: 'We discussed different places to get PowerShell modules and cmdlets in [*Chapter
    2*](B17600_02.xhtml#_idTextAnchor034), *Exploring PowerShell Cmdlets and Syntax*.
    We can use those same places to find PowerShell scripts as well. Let’s just recap
    them:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在 [*第 2 章*](B17600_02.xhtml#_idTextAnchor034)《探索 PowerShell Cmdlet 和语法》中讨论了获取
    PowerShell 模块和 Cmdlet 的不同途径。我们也可以利用这些途径来查找 PowerShell 脚本。让我们回顾一下这些资源：
- en: '**PowerShell repositories**: Whether it’s the official PowerShell repository
    at [https://www.powershellgallery.com/](https://www.powershellgallery.com/), the
    Microsoft Learn repository at [https://learn.microsoft.com/en-us/samples/browse/](https://learn.microsoft.com/en-us/samples/browse/),
    or an internal one, repositories are great places to find scripts. Generally speaking,
    scripts in the PowerShell Gallery have undergone some minimal validation and will
    have information about the author, the version, and the license for use.'
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**PowerShell 仓库**：无论是官方的 PowerShell 仓库 [https://www.powershellgallery.com/](https://www.powershellgallery.com/)，还是
    Microsoft Learn 仓库 [https://learn.microsoft.com/en-us/samples/browse/](https://learn.microsoft.com/en-us/samples/browse/)，或者内部的仓库，都是寻找脚本的好地方。一般来说，PowerShell
    Gallery 中的脚本经过了一些基本验证，会提供关于作者、版本和使用许可的信息。'
- en: '**GitHub**: This is also a good source for PowerShell scripts, but they’re
    generally not validated and may not be complete or functional.'
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**GitHub**：这是另一个很好的 PowerShell 脚本来源，但这些脚本通常没有经过验证，可能不完整或不可用。'
- en: '**Online elsewhere**: There are very good scripts elsewhere online. For example,
    the Practical 365 site ([https://practical365.com](https://practical365.com))
    has some extremely useful scripts for working with Microsoft 365\. However, the
    quality of online scripts may be variable.'
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**其他在线资源**：网上有很多很好的脚本。例如，Practical 365 网站（[https://practical365.com](https://practical365.com)）有一些非常有用的
    Microsoft 365 脚本。然而，在线脚本的质量可能会有所不同。'
- en: Whenever we get a script from an author we don’t know or trust, we should be
    careful to understand what the script does and how it does it before running it
    in an environment we care about. We should do this even when we do trust the author,
    of course. It is worth starting a sandbox or virtual machine to test the script
    first.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 每当我们从不认识或不信任的作者那里获取脚本时，应该小心理解脚本的作用和运行方式，再在我们关注的环境中运行它。当然，即使我们信任作者，仍然值得先在沙箱或虚拟机中测试脚本。
- en: Running scripts
  id: totrans-29
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 运行脚本
- en: There are two things we need to be aware of before we can run a script. The
    first is that PowerShell scripts always have an extension of `.ps1`. Files with
    this extension are not registered as executables, so double-clicking them in Windows
    Explorer will open them in Notepad or another editor; it won’t run the script.
    Files with this extension also require a relative or absolute path to run from
    the PowerShell terminal, so with either `PS C:\myscripts> .\MySuperScript.ps1`
    (relative path) or `PS C:\> C:\myscripts\MySuperScript.ps1` (absolute path) without
    the `.\`, the script won’t run.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们运行脚本之前，有两件事需要注意。第一，PowerShell 脚本的扩展名始终是 `.ps1`。具有此扩展名的文件不会被注册为可执行文件，因此在 Windows
    资源管理器中双击它们将会在记事本或其他编辑器中打开，而不会运行脚本。具有此扩展名的文件还需要一个相对路径或绝对路径才能从 PowerShell 终端运行，因此无论是
    `PS C:\myscripts> .\MySuperScript.ps1`（相对路径）还是 `PS C:\> C:\myscripts\MySuperScript.ps1`（绝对路径），如果没有
    `.\`，脚本都无法运行。
- en: 'Secondly, PowerShell has an execution policy for running scripts, but only
    on Windows computers. By default, on a Windows client, the execution policy is
    `Restricted`, which means that scripts cannot run. Happily, we can change this
    for the current user by running the following cmdlet:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 其次，PowerShell 对运行脚本有执行策略，但仅限于 Windows 计算机。默认情况下，在 Windows 客户端上，执行策略是 `Restricted`，这意味着脚本无法运行。幸运的是，我们可以通过运行以下
    cmdlet 为当前用户更改此设置：
- en: '[PRE0]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: This will allow the current user to run scripts that have been written on the
    local machine, or scripts downloaded from the internet that include a code signature.
    We’ll be covering execution policy and code signing in detail in [*Chapter 12*](B17600_12.xhtml#_idTextAnchor236),
    *Securing PowerShell*, but for now, run this cmdlet so that we can get on with
    writing a script.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 这将允许当前用户运行本地计算机上编写的脚本，或从互联网下载并包含代码签名的脚本。我们将在 [*第 12 章*](B17600_12.xhtml#_idTextAnchor236)《*PowerShell
    安全*》中详细讨论执行策略和代码签名，但现在请运行此 cmdlet，以便我们继续编写脚本。
- en: If we are using a Linux or Mac client, we don’t need to do this. The policy
    is effectively `Unrestricted` for those computers because of differences in the
    way security is implemented in the Linux and macOS operating systems.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们使用的是 Linux 或 Mac 客户端，我们无需执行此操作。由于 Linux 和 macOS 操作系统在安全性实现上的差异，这些计算机的策略实际上是
    `Unrestricted`。
- en: 'That’s enough introduction; let’s get on with what we’re here for: writing
    a script.'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 这就够了，接下来我们开始进入正题：编写脚本。
- en: Writing a script
  id: totrans-36
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编写脚本
- en: 'How do we go about writing a script? Pretty much every script I write from
    scratch starts with writing down the steps and cmdlets I need to complete a task.
    Once I can complete the task with only the information in the list, and all the
    cmdlets work, I know I am ready. Let’s start our script with a working command.
    As an example, consider the following cmdlet:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 我们该如何编写脚本呢？几乎每一个我从零开始编写的脚本，都是从列出完成任务所需的步骤和 cmdlet 开始的。一旦我能够仅凭列表中的信息完成任务，且所有
    cmdlet 都能正常工作，我就知道我准备好了。让我们从一个有效的命令开始我们的脚本。作为示例，考虑以下 cmdlet：
- en: '[PRE1]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: This cmdlet gets some weather data for my location from the API service from
    the Weather API, using a personal key, and writes it to an HTML file for display.
    Obviously, I’ve not put my real personal key in the preceding cmdlet, so it will
    fail with an API key error if we run that exact code. Let’s consider how we might
    turn this cmdlet into a script. To continue, we’ll need to get our own personal
    key.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 这个 cmdlet 使用个人密钥从天气 API 服务中获取我的位置的天气数据，并将其写入 HTML 文件以进行显示。显然，我没有在前面的 cmdlet
    中放入我的真实个人密钥，因此如果我们运行那段代码，系统会因为 API 密钥错误而失败。让我们考虑如何将这个 cmdlet 转换成一个脚本。接下来，我们需要获取我们自己的个人密钥。
- en: Getting a Personal Key for the Weather API Service
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 获取天气 API 服务的个人密钥
- en: 'To work through this chapter, we’ll need our own personal key for the Weather
    API service:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 要完成本章内容，我们需要为天气 API 服务获取个人密钥：
- en: 1\. Go to [https://www.weatherapi.com](https://www.weatherapi.com) and click
    the **Sign** **Up** button.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 1\. 访问 [https://www.weatherapi.com](https://www.weatherapi.com)，点击 **注册** 按钮。
- en: 2\. Enter an email address (twice) and a new password (twice), accept the terms
    and conditions, complete the CAPTCHA, and we will be sent a verification email.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 2\. 输入电子邮件地址（两次）和新密码（两次），接受条款和条件，完成验证码，我们将收到一封验证电子邮件。
- en: 3\. Clicking the link in the verification email will open a web page to tell
    us that we are verified, and will invite us to log in.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 3\. 点击验证电子邮件中的链接将打开一个网页，告诉我们已验证成功，并邀请我们登录。
- en: 4\. Do this by clicking the login link and entering our email address and the
    password we have just created. At the top of the next page is our personal API
    key. This is the key we will use to run this cmdlet.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 4\. 通过点击登录链接并输入我们刚刚创建的电子邮件地址和密码来完成此操作。下一页的顶部是我们的个人API密钥。这就是我们将用来运行此cmdlet的密钥。
- en: 5\. Copy it and save it in a text file somewhere safe. You can always find it
    again by logging in to the service.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 5\. 复制它并保存在某个安全的文本文件中。你可以随时通过登录服务再次找到它。
- en: 'Now we’ve got a key, let’s open VS Code and create a new file. Call it `weatherdata.ps1`.
    Type the following, using the key we’ve just generated from the Weather API instead
    of `<our new` `key here>`:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了密钥，让我们打开VS Code并创建一个新文件。命名为`weatherdata.ps1`。输入以下内容，使用我们刚刚从天气API生成的密钥，而不是`<our
    new key here>`：
- en: '[PRE2]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Let’s think about tidying this cmdlet up so that it is more readable. The cmdlet
    does two things; it gets information from the API, and it outputs that information
    to a file, so let’s split those up:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们思考如何整理这个cmdlet，以使其更加可读。这个cmdlet做了两件事：它从API获取信息，然后将这些信息输出到文件中，所以我们可以将这两部分拆开：
- en: '[PRE3]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: So now, we are storing the response in a variable and then outputting it in
    the second line.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将响应存储在一个变量中，然后在第二行输出它。
- en: 'How else might we make this more readable? That first cmdlet is very long.
    We could break out the headers and the URI to make it more readable, as we can
    see in the following figure:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以如何使这个代码更具可读性？第一个cmdlet非常长。我们可以将头部和URI分开，以使其更具可读性，正如以下图所示：
- en: '![Figure 8.1 – Readable code](img/B17600_08_001.jpg)'
  id: totrans-53
  prefs: []
  type: TYPE_IMG
  zh: '![图 8.1 – 可读代码](img/B17600_08_001.jpg)'
- en: Figure 8.1 – Readable code
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.1 – 可读代码
- en: 'If we save `weatherdata.ps1`, we can now run it from the PowerShell console
    by switching to the directory we save it in and running the following at the prompt:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们保存`weatherdata.ps1`，现在可以从PowerShell控制台运行它，只需切换到我们保存它的目录，并在提示符下运行以下命令：
- en: '[PRE4]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: While the code is readable, it’s not very flexible. It does one thing, and if
    we want it to do something slightly different (for instance, produce the data
    for a different city) or if we want to share it with someone else, we need to
    make some changes. Let’s look at where we might start with that.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然代码是可读的，但它并不太灵活。它做一件事，如果我们希望它做一些稍微不同的事情（例如，获取不同城市的数据），或者如果我们想与其他人共享它，我们需要做一些更改。让我们看看从哪里开始做这些更改。
- en: Identifying changing values
  id: totrans-58
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 识别变化的值
- en: Let’s think about things we might want to change in this code. We want it to
    get weather information from the web and write it to a HTML document. This means
    it’s unlikely that we want to change the `Invoke-RestMethod`, `Convertto-Html`,
    and `Out-File` cmdlets. Think about what values might change before we move on.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们思考一下在这段代码中可能需要更改的内容。我们希望它从网络获取天气信息并将其写入HTML文档。这意味着我们不太可能想要更改`Invoke-RestMethod`、`Convertto-Html`和`Out-File`这些cmdlet。想一想在我们继续之前可能会更改的值。
- en: Ready? Good.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 准备好了吗？很好。
- en: 'These are some things that we might want to be able to change the values of
    when we run the script:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是我们可能希望在运行脚本时能够更改其值的一些内容：
- en: We might want to change the city.
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可能想要更改城市。
- en: We might want to change where we save the HTML output.
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可能想要更改HTML输出的保存位置。
- en: We might want to change the API key.
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可能想要更改API密钥。
- en: We might not want to hardcode the API key in the script at all.
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可能根本不想在脚本中硬编码API密钥。
- en: We can pass values for these things when we call the script by making them parameters
    within the script. The next section will be all about parameterizing our script.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过在脚本中将它们设置为参数来传递这些值。下一节将专门讲解如何将脚本参数化。
- en: Working with parameters
  id: totrans-67
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用参数
- en: Parameters are values for script variables that can be passed when we run the
    script, rather than being hardcoded into the script. As we’ve just seen in the
    previous section, we run the script in much the same way as we run any other cmdlet,
    and, as with cmdlets, we can pass parameter values to our script. Let’s look at
    how we do that.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 参数是脚本变量的值，可以在我们运行脚本时传递，而不是硬编码到脚本中。正如我们在上一节中所看到的，我们以与运行其他cmdlet相同的方式运行脚本，并且，像cmdlet一样，我们可以向脚本传递参数值。让我们看看如何做到这一点。
- en: 'The first thing we need is the `CmdletBinding` attribute. Attributes are a
    way of telling PowerShell how we want it to process the elements of our script.
    We’ve used them before in [*Chapter 4*](B17600_04.xhtml#_idTextAnchor071), *PowerShell
    Variables and Data Structures*, when we learned how to cast variables. The `CmdletBinding`
    attribute tells PowerShell that we want it to treat the script as a cmdlet. Some
    of the big advantages this has are that our script will be able to access common
    parameters such as `-Verbose`, as well as positional binding. Let’s add it. At
    the top of our script, create a new line and add this:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要的第一件事是`CmdletBinding`特性。特性是告诉 PowerShell 我们希望它如何处理脚本元素的方式。我们之前在[*第 4 章*](B17600_04.xhtml#_idTextAnchor071)中使用过它们，*PowerShell
    变量和数据结构*，当时我们学习了如何转换变量。`CmdletBinding`特性告诉 PowerShell 我们希望它将脚本视为 cmdlet。这样做的主要好处之一是我们的脚本可以访问常用的参数，如`-Verbose`，以及位置绑定。让我们添加它。在脚本的顶部创建一行，并添加以下内容：
- en: '[PRE5]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Next, we need to create a `Param()` block to hold the variables we want to
    use as parameters. On a line directly under the `CmdletBinding` attribute, type
    this:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要创建一个`Param()`块，用来保存我们希望作为参数使用的变量。在`CmdletBinding`特性下方的行中，输入以下内容：
- en: '[PRE6]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The `Param()` block must precede all the code that we’re going to write. We
    will add our parameters inside the brackets, so it’s best to press *Enter* a couple
    of times inside the brackets so that we have some space to add them:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: '`Param()`块必须位于我们要编写的所有代码之前。我们将在括号内添加参数，所以最好按*Enter*键几次，给括号内部留出一些空间，以便添加它们：'
- en: '[PRE7]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Now, we’re ready to start creating parameters.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们准备开始创建参数了。
- en: Creating useful parameters
  id: totrans-76
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建有用的参数
- en: 'The most useful parameters are values that change. Let’s start with the city
    we’re getting weather data for. The city is embedded in the `$uri` variable, which
    is a string. We can easily create a new variable to just hold the city name and
    pass it to the `$uri` variable. Try this:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 最有用的参数是那些会变化的值。让我们从我们获取天气数据的城市开始。城市嵌入在`$uri`变量中，这是一个字符串。我们可以轻松创建一个新变量来仅保存城市名称，并将其传递给`$uri`变量。试试这个：
- en: '[PRE8]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'And change the `$uri` variable to look like this:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 并将`$uri`变量更改为如下所示：
- en: '[PRE9]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Remember we need to use double quotes here (`"`) so that the `$City` variable
    will be expanded. We can check our code against the following figure:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，我们在这里需要使用双引号（`"`)以便扩展`$City`变量。我们可以通过以下图示来检查我们的代码：
- en: '![Figure 8.2 – Adding the CmdletBinding attribute and a param() block](img/B17600_08_002.jpg)'
  id: totrans-82
  prefs: []
  type: TYPE_IMG
  zh: '![图 8.2 – 添加 CmdletBinding 特性和 param() 块](img/B17600_08_002.jpg)'
- en: Figure 8.2 – Adding the CmdletBinding attribute and a param() block
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.2 – 添加 CmdletBinding 特性和 param() 块
- en: This will write the value of `$city` into the `$uri` value when we run it.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 这将在我们运行时把`$city`的值写入`$uri`的值中。
- en: Test, Test, Test
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 测试，测试，再测试
- en: This is really important; if we make two changes and the script stops working,
    we will have to work out which change broke the script. Test after every change.
    Make sure it all still works before moving on to another change.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 这非常重要；如果我们做了两个更改，而脚本停止工作了，我们将不得不找出哪个更改导致脚本中断。每次更改后都要进行测试。在进行下一次更改之前，确保一切仍然有效。
- en: 'Let’s test it. From the console, make sure we’re in the directory where we’ve
    saved the script, and type the following:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们测试一下。从控制台开始，确保我们在保存脚本的目录中，然后输入以下内容：
- en: '[PRE10]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Now, check the `WeatherData.html` file. It should look like this:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，检查一下`WeatherData.html`文件。它应该是这样的：
- en: '![Figure 8.3 – Welcome to beautiful Paris](img/B17600_08_003.jpg)'
  id: totrans-90
  prefs: []
  type: TYPE_IMG
  zh: '![图 8.3 – 欢迎来到美丽的巴黎](img/B17600_08_003.jpg)'
- en: Figure 8.3 – Welcome to beautiful Paris
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.3 – 欢迎来到美丽的巴黎
- en: If this has worked for you, congratulations! You have parameterized your first
    script. Let’s look at what we’ve done.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 如果这对你有效，恭喜你！你已经为第一个脚本实现了参数化。让我们看看我们做了什么。
- en: By putting the `$City` variable into the `Param()` block, we’ve made it accessible
    from outside the script so that we can pass values to it when we run the script.
    By assigning a value to the variable, writing `$City = "London"`, we’ve set a
    default value so that if we don’t pass a value via a parameter, the script will
    still run.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 通过将`$City`变量放入`Param()`块中，我们使其可以从脚本外部访问，以便在运行脚本时将值传递给它。通过给变量赋值，写成`$City = "London"`，我们设置了一个默认值，这样如果我们没有通过参数传递值，脚本仍然能够运行。
- en: We can put as many variables as we like in the `Param()` block, but we must
    separate each one with a comma (`,`). Let’s do another one; try the following
    activity.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在`Param()`块中放入任意数量的变量，但每个变量必须用逗号（`,`）分隔。让我们再做一个，试试下面的操作。
- en: Activity 1
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 活动 1
- en: How might we pass the location where we want to save the output? And how might
    we make that as easy as possible?
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 我们怎么传递我们想要保存输出的位置呢？我们又该如何让这件事变得尽可能简单？
- en: 'Hint: if we pass just a filename, it will save the output in the same location
    as the script is running from. Would we want that every time?'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 提示：如果我们只传递一个文件名，它将把输出保存在与脚本运行位置相同的地方。我们每次都想这样做吗？
- en: Let’s look at what we could do with the key. Keys are a long string of random
    characters, so it’s not going to be practical to type that into a parameter. How
    might we get around this?
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看可以如何使用密钥。密钥是一个长字符串，由随机字符组成，因此直接将其输入参数中并不实际。我们怎样解决这个问题呢？
- en: We could save the key to a file, and then use `Get-Content` to extract the string
    from the file and use it that way. In [*Chapter 7*](B17600_07.xhtml#_idTextAnchor140),
    *PowerShell and the Web – HTTP, REST, and JSON* we saw there are two ways of passing
    a key to `Invoke-RestMethod`. We can either pass it to the `-Key` parameter or
    include it in the `-Headers` parameter, as we are doing in this script. The important
    difference is that in one scenario the key must be encoded, and in the other,
    it must be plain text. Can you remember which is which? Look back to the last
    chapter to find out.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将密钥保存到文件中，然后使用`Get-Content`从文件中提取字符串并以此方式使用它。在[*第7章*](B17600_07.xhtml#_idTextAnchor140)中，*PowerShell
    和 Web – HTTP、REST 和 JSON*，我们看到有两种将密钥传递给`Invoke-RestMethod`的方法。我们可以将其传递给`-Key`参数，或者像在此脚本中那样将其包含在`-Headers`参数中。重要的区别在于，在一种情况下密钥必须被编码，而在另一种情况下它必须是纯文本。你能记得是哪种情况吗？回顾上一章找到答案吧。
- en: If you remembered, well done. If you worked it out from how our script currently
    works, even better. We’re already passing an unencoded string in the header, so
    we don’t need to encode our key before saving it.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你记得，那就做得好。如果你是从我们当前脚本的工作方式推理出来的，那就更好了。我们已经在头部传递了一个未编码的字符串，因此我们不需要在保存之前对我们的密钥进行编码。
- en: Open a new text document using your preferred text editor and save it as `key.txt`
    in the same folder as the script – in my case, `c:\temp\poshbook\ch8`. Copy and
    paste your `WeatherApi` key into it and save it.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 使用你喜欢的文本编辑器打开一个新文本文件，并将其保存为`key.txt`，放在与脚本相同的文件夹中——在我的情况下是`c:\temp\poshbook\ch8`。将你的`WeatherApi`密钥复制粘贴进去并保存。
- en: 'Now all we need to do is add a parameter that points to the file, and a line
    that gets the content from the file. Then, we can add that to the `$headers` variable.
    It might look something like this:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们所需要做的就是添加一个指向文件的参数，并添加一行从文件中获取内容的代码。然后，我们可以将其添加到`$headers`变量中。它可能看起来像这样：
- en: '[PRE11]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: We’ve identified our changing values and created our parameters.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经确定了变化的价值观并创建了我们的参数。
- en: Activity 2
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 活动 2
- en: Knowing what we know from previous chapters, how might we rewrite our script
    so that we can accept multiple values for the `-``City` parameter?
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 根据我们从前面章节中学到的内容，我们怎样重写脚本，使得可以接受`-City`参数的多个值呢？
- en: 'Hint 1: Look at a help file for a cmdlet that accepts multiple strings in a
    parameter to see how we could write an attribute for the `-City` parameter. `Get-Random`
    accepts multiple objects for `-InputObject`.'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 提示 1：查看接受多个字符串作为参数的 cmdlet 的帮助文件，看看我们如何为`-City`参数编写一个属性。`Get-Random`接受多个对象作为`-InputObject`。
- en: 'Hint 2: We’re going to want a way of processing each string in turn. Remember,
    multiple strings passed into a parameter are an array.'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 提示 2：我们将希望有一种方法来依次处理每个字符串。记住，传递给参数的多个字符串实际上是一个数组。
- en: 'Hint 3: We’re going to want to send each city to a different output.'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 提示 3：我们将希望将每个城市发送到不同的输出。
- en: Let’s look at how we might improve them using attributes.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如何使用属性来改进它们。
- en: Specifying type
  id: totrans-111
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 指定类型
- en: 'We can limit the possibility of errors by specifying the type of the parameter
    in the same way as we specify the type of a variable, by typing the attribute
    before the variable. In your script, replace the `$City = "London"` line with
    this:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过指定参数类型来限制错误的可能性，就像我们为变量指定类型一样，在变量前面加上属性。在你的脚本中，将`$City = "London"`这一行替换为如下代码：
- en: '[PRE12]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Now, whatever we pass in the `-City` parameter will be cast to a string.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，传入`-City`参数的任何内容都会被强制转换为字符串。
- en: Making parameters mandatory
  id: totrans-115
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使参数变为必需
- en: 'We might want our script to require an explicit value for the `–City` parameter
    each time we run it. We could do that by changing the `-City` parameter like this:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可能希望每次运行脚本时都需要显式提供`–City`参数的值。我们可以通过如下方式修改`-City`参数来实现：
- en: '[PRE13]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'We’ve added the line `[Parameter(Mandatory = $true)]` before the `$City` parameter.
    Note that there is no comma (`,`) after the attribute. Now we’ve done that, the
    script ignores the default value for the parameter (`"London"`), and it prompts
    for a city:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在`$City`参数之前添加了行`[Parameter(Mandatory = $true)]`。请注意，属性后面没有逗号（`,`）。现在我们这么做了，脚本就会忽略该参数的默认值（`"London"`），并提示输入城市：
- en: '![Figure 8.4 – Mandatory parameters](img/B17600_08_004.jpg)'
  id: totrans-119
  prefs: []
  type: TYPE_IMG
  zh: '![图 8.4 – 强制参数](img/B17600_08_004.jpg)'
- en: Figure 8.4 – Mandatory parameters
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.4 – 强制参数
- en: In the figure, we can see that because we didn’t include a value for the `-City`
    parameter, we get prompted. One of the most useful things we can do with a script
    is to make it accept parameter values from the pipeline. Let’s have a look at
    how we can do that.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 在图中，我们可以看到因为我们没有为`-City`参数提供值，所以系统会提示我们。我们能通过脚本做的最有用的事情之一，就是让它接受来自管道的参数值。让我们看看如何做到这一点。
- en: Taking values from the pipeline
  id: totrans-122
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 从管道获取值
- en: 'We covered how parameters can take values from the pipeline in [*Chapter 3*](B17600_03.xhtml#_idTextAnchor049),
    *The PowerShell Pipeline – How to String Cmdlets Together*. In this section, we’re
    going to see how easy it is to make our script accept pipeline values. Remember,
    there are two ways that a parameter can take values from the pipeline: `ByValue`
    and `ByName`. For our script, it would be best if we let the `-City` parameter
    accept pipeline input by value, so let’s do this:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在[*第 3 章*](B17600_03.xhtml#_idTextAnchor049)，*PowerShell 管道 – 如何将 Cmdlet 串联起来*中讲解了参数如何从管道接受值。在本节中，我们将看到让我们的脚本接受管道值是多么简单。记住，参数可以通过两种方式从管道接受值：`ByValue`和`ByName`。对于我们的脚本来说，最好让`-City`参数通过值来接受管道输入，因此我们来这样做：
- en: '[PRE14]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'All we’ve done is add the line `[Parameter(ValueFromPipeline)]` to the `Param()`
    block. We can see the difference it makes in the following figure:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 我们所做的仅仅是在`Param()`块中添加了行`[Parameter(ValueFromPipeline)]`。我们可以在下图中看到它带来的区别：
- en: '![Figure 8.5 – Accepting values from the pipeline](img/B17600_08_005.jpg)'
  id: totrans-126
  prefs: []
  type: TYPE_IMG
  zh: '![图 8.5 – 从管道接受值](img/B17600_08_005.jpg)'
- en: Figure 8.5 – Accepting values from the pipeline
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.5 – 从管道接受值
- en: In the first example, we can see that we’ve created a string, `"cwmbran"`, and
    tried to pass it through the pipeline to the script. The script doesn’t accept
    values from the pipeline, and we get an error message in red telling us just that.
    If we then alter the `-City` parameter to accept values from the pipeline, we
    can see the script completing without error in the second example.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一个示例中，我们看到我们创建了一个字符串`"cwmbran"`，并尝试将其通过管道传递给脚本。因为脚本不接受来自管道的值，我们会看到一个红色的错误消息提示我们这一点。如果我们随后更改`-City`参数来接受来自管道的值，那么在第二个示例中我们就能看到脚本顺利完成，没有错误。
- en: 'Let’s see what happens if we try feeding two values into the script through
    the pipeline, as in this example:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如果尝试通过管道向脚本传递两个值会发生什么，如下例所示：
- en: '[PRE15]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'We will only get an output for the last item. To make this work properly, we
    need to include the part of the script we want to repeat for each item in a `process
    {}` block, like this:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 我们只会得到最后一个项的输出。为了让它正确工作，我们需要将要为每个项重复的脚本部分放入`process {}`块中，像这样：
- en: '![Figure 8.6 – Making pipeline input work properly](img/B17600_08_006.jpg)'
  id: totrans-132
  prefs: []
  type: TYPE_IMG
  zh: '![图 8.6 – 正确处理管道输入](img/B17600_08_006.jpg)'
- en: Figure 8.6 – Making pipeline input work properly
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.6 – 正确处理管道输入
- en: 'I’m opening a `process {}` block on line `44`, and then closing it on line
    `61`. I can now feed multiple cities into the pipeline and get an HTML file for
    each of them, like this:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 我在第`44`行打开了一个`process {}`块，然后在第`61`行关闭它。现在，我可以将多个城市输入到管道中，并为每个城市生成一个HTML文件，如下所示：
- en: '[PRE16]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Note that doesn’t mean we can get rid of the `foreach` loop from *Activity 2*
    entirely, though. If we pass multiple cities explicitly using the `-City` parameter,
    we will still need to process them individually with a loop.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，这并不意味着我们可以完全去掉*活动 2*中的`foreach`循环。如果我们显式地使用`-City`参数传递多个城市，我们仍然需要通过循环逐个处理它们。
- en: 'There are lots of other things we can do with parameters, which are detailed
    in the article here: [https://learn.microsoft.com/en-us/powershell/scripting/lang-spec/chapter-12](https://learn.microsoft.com/en-us/powershell/scripting/lang-spec/chapter-12).'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 还有很多其他操作可以在参数上执行，具体内容请参见这篇文章：[https://learn.microsoft.com/en-us/powershell/scripting/lang-spec/chapter-12](https://learn.microsoft.com/en-us/powershell/scripting/lang-spec/chapter-12)。
- en: 'Many of them can be used to validate the parameter input: making sure that
    it is the correct type, or even selecting input from a list of accepted values.'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 它们中的许多可以用于验证参数输入：确保它是正确的类型，或者甚至从接受的值列表中选择输入。
- en: Switch parameters
  id: totrans-139
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 开关参数
- en: 'There’s one last feature of parameters we should talk about before moving on:
    switch parameters. Many of the cmdlets we’ve been using have parameters that act
    as switches; they don’t take a value, they just have to be present to change the
    behavior of the cmdlet. For example, using the `-Full` parameter in `Get-Help`
    changes the amount of help information that is returned. We can do that in our
    script too. Try this – after the `param()` block, add the following lines:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 在继续之前，我们应该讨论一下参数的最后一个特性：开关参数。我们一直在使用的许多 cmdlet 都有作为开关的参数；它们不需要值，只需存在即可改变 cmdlet
    的行为。例如，在`Get-Help`中使用`-Full`参数会改变返回的帮助信息量。我们也可以在脚本中做到这一点。试试看——在`param()`块之后，添加以下行：
- en: '[PRE17]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Then on the last line of the `param()` block, add the following line before
    the closing parenthesis. Remember, you will also need to add a comma after the
    previous parameter:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，在`param()`块的最后一行，在闭括号之前添加以下行。记住，你还需要在前一个参数后添加逗号：
- en: '[PRE18]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'The following figure shows how it looks in my script and shows the output when
    we use our new `-``Joke` parameter:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图示展示了在我的脚本中它的样子，并显示了我们使用新`-Joke`参数时的输出：
- en: '![Figure 8.7 – Only joking](img/B17600_08_007.jpg)'
  id: totrans-145
  prefs: []
  type: TYPE_IMG
  zh: '![图 8.7 – 只是开个玩笑](img/B17600_08_007.jpg)'
- en: Figure 8.7 – Only joking
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.7 – 只是开个玩笑
- en: In line `40`, I’ve added a comma after the parameter, so PowerShell knows there’s
    another parameter coming. I’ve added the new `-Joke` switch parameter in line
    `41`, and then on lines `44`-`46`, I’ve added an `If` statement to tell PowerShell
    what to do if the switch is present. Finally, I’ve used the switch in the terminal
    at the bottom when I called the script, and the script told me the best joke in
    the world. Simple, huh?
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 在第`40`行，我在参数后添加了一个逗号，这样 PowerShell 就知道接下来会有另一个参数。我在第`41`行添加了新的`-Joke`开关参数，然后在第`44`至`46`行，我添加了一个`If`语句，告诉
    PowerShell 如果开关存在应该做什么。最后，在终端底部调用脚本时，我使用了这个开关，脚本告诉我世界上最棒的笑话。很简单，是吧？
- en: Note that when we’re looking at other people’s scripts on the internet, we may
    well see a different construction for switch parameters. Instead of using `If
    ($Joke.IsPresent)`, we will often see `If ($Joke -eq $true)`. While this will
    work, it’s a much older way of doing things and could be confusing. Using the
    `.IsPresent` method of the parameter is the way Microsoft recommends.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，当我们查看互联网上其他人的脚本时，可能会看到一种不同的开关参数构造。我们常见的写法是`If ($Joke -eq $true)`，而不是使用`If
    ($Joke.IsPresent)`。虽然这样也能工作，但这是更旧的做法，可能会引起混淆。使用参数的`.IsPresent`方法是微软推荐的方式。
- en: We’ll be using parameters a lot as we go through the rest of the book, but for
    now, let’s look at the other main topic of this chapter, providing help in our
    scripts.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们继续阅读本书的其余部分时，我们将大量使用参数，但现在，让我们来看看本章的另一个主要话题——为我们的脚本提供帮助。
- en: Providing help for our script
  id: totrans-150
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为我们的脚本提供帮助
- en: Writing scripts is great fun, and we learn new things every time we write one.
    We include the new techniques or shortcuts, finish the script, put it to work,
    and then forget about it. The next time we look at it might be months or even
    years later, by which time we might well have forgotten how it works or why we
    wrote it the way we did. The answer to this is to write comprehensive help for
    the script, explaining how our script works and how to use it. This is even more
    important for scripts that we make available for other people to use.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 编写脚本非常有趣，每次编写脚本时我们都会学到新东西。我们会加入新的技巧或快捷方式，完成脚本，投入使用，然后忘记它。下次回顾时，可能是几个月或甚至几年后，到那时我们可能已经忘记了它是如何工作的，或者为什么我们当初以那种方式编写它。解决这个问题的方法是为脚本编写全面的帮助文档，解释脚本如何工作以及如何使用它。对于我们提供给其他人使用的脚本，这一点尤为重要。
- en: In this section, we’re going to cover four ways of providing help. First, we’re
    going to briefly look at how we can comment our code to help ourselves and others.
    After that, we’ll look at creating comment-based help for use with the `Get-Help`
    cmdlet. Then, we’re going to look at the `Write-Verbose` cmdlet, and how we can
    use it to understand what the script is doing. Finally, we’ll look at how we can
    provide help for mandatory parameters.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一节中，我们将介绍提供帮助的四种方式。首先，我们将简要了解如何通过注释代码来帮助自己和他人。接着，我们将研究如何为`Get-Help` cmdlet创建基于注释的帮助。然后，我们将了解`Write-Verbose`
    cmdlet，并学习如何使用它来理解脚本的执行情况。最后，我们将看看如何为必填参数提供帮助。
- en: Let’s start with commenting our code.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从注释代码开始。
- en: Comments
  id: totrans-154
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 注释
- en: 'We briefly mentioned comments in [*Chapter 5*](B17600_05.xhtml#_idTextAnchor096),
    *PowerShell Control Flow – Conditionals and Loops*. We saw that a single line
    may be turned into a comment by adding a hash at the start (`#`), and we could
    create multiline comments by enclosing a body of text like this: `<# … #>`. However,
    we didn’t really talk about why comments are useful. PowerShell is a scripting
    language – a particularly friendly one, in my opinion. Most of the time, it is
    reasonably obvious to someone who knows the language what a line of code will
    do, but a line of explanation means that we don’t need to parse each line to know
    what was intended. And, of course, what we write doesn’t always do what we intend.
    A comment that records what we want the line to do makes our lives a lot easier
    when we’re digging through four or five hundred lines of code. When the script
    is being adapted by somebody else, comments are invaluable. Have a look at the
    example below:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: '我们在[*第 5 章*](B17600_05.xhtml#_idTextAnchor096)《PowerShell 控制流 – 条件语句和循环》中简要提到过注释。我们看到，可以通过在行首添加井号(`#`)将一行变成注释，也可以通过用
    `<# … #>` 包围一段文本来创建多行注释。然而，我们并没有深入讨论注释的作用。PowerShell 是一种脚本语言——在我看来，它特别友好。大多数时候，熟悉语言的人可以合理地推测出一行代码的功能，但如果有注释，我们就不需要逐行解析来了解代码的意图。当然，我们写的代码并不总是按我们预期的那样执行。记录我们希望代码执行的注释，可以在我们翻阅四五百行代码时大大简化工作。当脚本被其他人修改时，注释尤为重要。来看下面的示例：'
- en: '[PRE19]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: The comment line tells us exactly what the slightly unreadable code is hopefully
    going to achieve.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 注释行准确告诉我们这些略微难以阅读的代码希望实现的功能。
- en: Comment blocks
  id: totrans-158
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注释块
- en: 'Comments are intended to be read in an editor of some sort. To make them easier
    to read, we will want to split a long comment across multiple lines. We could
    use the backtick character (`` ` ``) to escape manual line breaks, but that doesn’t
    really make it easier to read, particularly for some editors and some fonts. It’s
    better to use the blockquote construct, `<#...#>`. Have a look at the following
    figure:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 注释是为了在某种编辑器中阅读。为了使其更易于阅读，我们希望将长注释拆分成多行。我们可以使用反引号字符（`` ` ``）来转义手动换行符，但这并不真正使其更易于阅读，尤其是在某些编辑器和字体中。最好使用块注释语法，`<#...#>`。请看下面的图示：
- en: '![Figure 8.8 – Comment blocks](img/B17600_08_008.jpg)'
  id: totrans-160
  prefs: []
  type: TYPE_IMG
  zh: '![图 8.8 – 注释块](img/B17600_08_008.jpg)'
- en: Figure 8.8 – Comment blocks
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.8 – 注释块
- en: 'The comment block is in green and explains the intention of the following lines.
    Let’s have a look at some dos and don’ts for writing good comments:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 注释块是绿色的，解释了接下来的代码行的意图。让我们看看编写良好注释的一些注意事项：
- en: Comment on a separate line; adding a comment on the same line makes the line
    either too long or causes it to wrap in the editor.
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 注释应单独放在一行；在同一行添加注释会导致行过长或在编辑器中换行。
- en: Comment before the line you’re explaining; prepare the reader for what’s coming
    next in the script, not what’s been.
  id: totrans-164
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在你解释的代码行之前添加注释；为读者预告接下来脚本中的内容，而不是已发生的内容。
- en: Don’t comment on the obvious; generally speaking, too many comments are better
    than too few but don’t waste your time explaining things that don’t need it. Better
    to comment what a block of simple lines does than each individual line.
  id: totrans-165
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不要对显而易见的内容进行注释；一般来说，注释过多总比过少好，但不要浪费时间去解释那些不需要解释的内容。最好注释一块简单代码的作用，而不是每一行的作用。
- en: Let’s look at how we can provide help for our script with the `Get-Help` cmdlet.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看一下如何使用`Get-Help` cmdlet为脚本提供帮助。
- en: Comment-based help
  id: totrans-167
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 基于注释的帮助
- en: The `Get-Help` cmdlet reads XML help files included with the main PowerShell
    program, and for modules and functions that have them. However, it can also read
    correctly formatted comments embedded in a script. This is called **comment-based
    help**. We can write comment-based help by adding special help comment keywords
    at the start of our script.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: '`Get-Help` 命令读取与 PowerShell 主程序一起提供的 XML 帮助文件，以及具有这些文件的模块和函数。然而，它也可以读取正确格式化的嵌入脚本中的注释。这就是所谓的
    **基于注释的帮助**。我们可以通过在脚本的开始部分添加特殊的帮助注释关键字来编写基于注释的帮助。'
- en: 'There are a number of rules to remember about writing comment-based help:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 关于编写基于注释的帮助文档，有一些规则需要记住：
- en: It must be either at the start or the end of a script. For a couple of reasons,
    including the best practices for comments we covered previously, we should put
    it at the start.
  id: totrans-170
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它必须位于脚本的开始或结束。出于多个原因，包括我们之前讨论的最佳注释实践，我们应该把它放在开始处。
- en: Comment-based help must be contiguous. We can’t split it up into different comment
    blocks.
  id: totrans-171
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基于注释的帮助必须是连续的。我们不能将其分割成不同的注释块。
- en: Each section of the help must start with a legitimate keyword. The keyword is
    not case-sensitive, but it must be preceded by a dot (`.`).
  id: totrans-172
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每个帮助部分必须以合法的关键字开始。关键字不区分大小写，但必须以点（`.`）开头。
- en: There must be two blank lines after the comment-based help.
  id: totrans-173
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基于注释的帮助后必须有两行空行。
- en: Luckily, VS Code makes writing comment-based help a breeze. Let’s see it working.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，VS Code 使编写基于注释的帮助变得非常简单。我们来看看它是如何工作的。
- en: In our script, create a new line at the start of the script, and type `comm`.
    As we can see in the following figure, VS Code will offer us the `comment-help`
    function helper if we have the PowerShell extension installed.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 在脚本中，在脚本的开始处创建一行，输入 `comm`。如下面的图所示，如果我们安装了 PowerShell 扩展，VS Code 会提供 `comment-help`
    功能助手。
- en: '![Figure 8.9 – The comment-help function in VS Code](img/B17600_08_009.jpg)'
  id: totrans-176
  prefs: []
  type: TYPE_IMG
  zh: '![图 8.9 – VS Code 中的注释帮助功能](img/B17600_08_009.jpg)'
- en: Figure 8.9 – The comment-help function in VS Code
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.9 – VS Code 中的注释帮助功能
- en: Go ahead and select it. VS Code will create a comment-based help template for
    us with the most commonly used keywords, correctly formatted, and even add the
    two blank lines after the block for us.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 继续选择它。VS Code 会为我们创建一个基于注释的帮助模板，模板中包含最常用的关键字，格式正确，甚至会在块后面自动添加两个空行。
- en: 'Let’s have a look at the common sections:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看常见的部分：
- en: '`.SYNOPSIS`: This section should be one line that summarizes what the script
    does.'
  id: totrans-180
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`.SYNOPSIS`：此部分应为一行，总结脚本的功能。'
- en: '`.DESCRIPTION`: This is where we put the full description, including how it
    works, what it should be used for, different ways to use it, and so on.'
  id: totrans-181
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`.DESCRIPTION`：在这里我们写下完整的描述，包括它是如何工作的，应该用来做什么，如何使用等。'
- en: '`.NOTES`: This is where we should put warnings about incompatibilities, prerequisites
    for running the script (for instance, that we need to have a `weatherapi` key
    saved to a text file), and any other useful information that doesn’t fit in the
    description.'
  id: totrans-182
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`.NOTES`：在这里，我们应放置关于不兼容性、运行脚本的前提条件（例如，我们需要将 `weatherapi` 密钥保存到文本文件中）以及任何其他不适合描述部分的有用信息。'
- en: '`.LINK`: This will provide a link for `Get-Help -Online` to consume. Personally,
    I never use it and delete it from the help section.'
  id: totrans-183
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`.LINK`：这将为 `Get-Help -Online` 提供一个链接。就个人而言，我从不使用它，并且会从帮助部分删除它。'
- en: '`.EXAMPLE`: We can put examples of usage here to explain how to use the parameters.
    Separate each example with a new `.EXAMPLE` keyword on a new line.'
  id: totrans-184
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`.EXAMPLE`：我们可以在此处放置使用示例，以说明如何使用参数。每个示例应与新行中的 `.EXAMPLE` 关键字分开。'
- en: 'I’ll admit, the first time I did this, it was a real thrill seeing my script
    help looking like the real thing. It doesn’t get old:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 我承认，第一次做这个时，看到我的脚本帮助文档看起来像真正的帮助文档时，我感到非常兴奋。这种感觉永远不会过时：
- en: '![Figure 8.10 – Retrieving comment-based help for a script](img/B17600_08_010.jpg)'
  id: totrans-186
  prefs: []
  type: TYPE_IMG
  zh: '![图 8.10 – 检索脚本的基于注释的帮助](img/B17600_08_010.jpg)'
- en: Figure 8.10 – Retrieving comment-based help for a script
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.10 – 检索脚本的基于注释的帮助
- en: This works just like anything else with `Get-Help`. To see the notes, type `Get-Help
    .\weatherdata.ps1 -Detailed`. To get everything, use the `-``Full` parameter.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 这与 `Get-Help` 中的其他内容一样工作。要查看注释，请输入 `Get-Help .\weatherdata.ps1 -Detailed`。要获取所有信息，请使用
    `-Full` 参数。
- en: Activity 3
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 活动 3
- en: Write a short comment-based help for the script. Test it by calling `Get-Help
    .\weatherdata.ps1` from the console.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 为脚本编写简短的基于注释的帮助文档。通过从控制台调用 `Get-Help .\weatherdata.ps1` 来测试它。
- en: 'That’s it for comment-based help. It’s incredibly useful, whether we read it
    in the editor or using the `Get-Help` cmdlet. I recommend we use it as often as
    we can. Let’s look at something else now, that isn’t strictly help, but is definitely
    helpful: the `Write-Verbose` cmdlet.'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是基于注释的帮助内容。它非常有用，无论我们是在编辑器中查看，还是使用`Get-Help` cmdlet。我建议我们尽可能多地使用它。现在让我们来看一些其他内容，虽然它不严格属于帮助，但绝对有帮助：`Write-Verbose`
    cmdlet。
- en: Write-Verbose
  id: totrans-192
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Write-Verbose
- en: 'Back in [*Chapter 3*](B17600_03.xhtml#_idTextAnchor049), *The PowerShell Pipeline
    – How to String Cmdlets Together*, we talked briefly about the standard streams:
    output streams that exist in most programming languages and classify and direct
    output. The verbose stream is one of them and is intended for messages that help
    users understand what a cmdlet is doing. It’s particularly useful for troubleshooting
    long-running cmdlets that don’t appear to be doing anything. Every PowerShell
    cmdlet has a `-Verbose` switch parameter that allows us to see what the cmdlet
    is doing and whether it’s got stuck, although not all of them produce a verbose
    stream output. We can see this in action already in our script because the `Invoke-RestMethod`
    cmdlet has a particularly useful verbose output. Try this:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 在[*第3章*](B17600_03.xhtml#_idTextAnchor049)中，我们简要讨论了标准流：存在于大多数编程语言中的输出流，用于分类和引导输出。详细流就是其中之一，用于传达帮助用户理解cmdlet正在做什么的消息。它对于排查看似没有任何操作的长时间运行的cmdlet特别有用。每个PowerShell
    cmdlet都有一个`-Verbose`开关参数，允许我们看到cmdlet正在做什么，以及它是否卡住了，尽管并不是所有cmdlet都会产生详细流输出。我们已经在脚本中看到它的作用，因为`Invoke-RestMethod`
    cmdlet具有特别有用的详细输出。试试这个：
- en: '[PRE20]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'You should see something like the following figure:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该看到类似于下图的内容：
- en: '![Figure 8.11 – Verbose output from inside our script](img/B17600_08_011.jpg)'
  id: totrans-196
  prefs: []
  type: TYPE_IMG
  zh: '![图 8.11 – 脚本内部的详细输出](img/B17600_08_011.jpg)'
- en: Figure 8.11 – Verbose output from inside our script
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.11 – 脚本内部的详细输出
- en: We’re able to access this verbose output because we have used the `CmdletBinding()`
    attribute at the start of the script, which gives us access to advanced functions.
    Without it, we can call the `-Verbose` parameter without an error, but it won’t
    produce any output.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 我们能够访问这些详细输出是因为我们在脚本开始时使用了`CmdletBinding()`特性，它为我们提供了访问高级功能的权限。如果没有它，我们可以调用`-Verbose`参数而不会出错，但不会产生任何输出。
- en: 'We can do even more than this, though; we can write our own verbose stream
    messages with the `Write-Verbose` cmdlet. Why is this useful? Because when we
    are processing many items in a loop in our script, it can tell us which item in
    the loop is failing. Let’s say we ask our script to produce the data for three
    cities as follows:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，我们可以做得比这更多；我们可以使用`Write-Verbose` cmdlet编写我们自己的详细输出信息。为什么这有用呢？因为当我们在脚本中循环处理多个项目时，它可以告诉我们循环中的哪个项目出错。假设我们让脚本生成以下三个城市的数据：
- en: '[PRE21]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Then, we’ll get an error saying that when `Invoke-RestMethod` ran, a matching
    location couldn’t be found, but the line of code that threw the error is as follows:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们会收到一个错误，说明在`Invoke-RestMethod`运行时，未找到匹配的位置，但抛出错误的代码行如下：
- en: '[PRE22]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: So it could be any of the cities that doesn’t exist.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 所以它可能是任何一个不存在的城市。
- en: 'We can fix this by changing the start of the `foreach` loop:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过更改`foreach`循环的开始部分来修复此问题：
- en: '[PRE23]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'We’ve added the line `Write-Verbose "Processing $Item"` at the start of the
    loop, which means that if we use the `-Verbose` parameter now, the script tells
    us which city it’s processing, and we can see which of our cities is fictitious,
    as in the following figure:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在循环开始时添加了行`Write-Verbose "Processing $Item"`，这意味着如果现在使用`-Verbose`参数，脚本会告诉我们正在处理哪个城市，并且我们可以看到哪些城市是虚构的，如下图所示：
- en: '![Figure 8.12 – Using Write-Verbose to illuminate the Bible-black](img/B17600_08_012.jpg)'
  id: totrans-207
  prefs: []
  type: TYPE_IMG
  zh: '![图 8.12 – 使用Write-Verbose来照亮黑暗](img/B17600_08_012.jpg)'
- en: Figure 8.12 – Using Write-Verbose to illuminate the Bible-black
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.12 – 使用Write-Verbose来照亮黑暗
- en: 'When we run the script in the first line, all we see is the error, but when
    we run it with the `-Verbose` parameter, it tells us which city it was processing
    when it encountered the error. Let’s look at the final type of help we’ll cover
    in this chapter: parameter help messages.'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们运行脚本的第一行时，我们只看到错误，但当我们使用`-Verbose`参数运行时，它会告诉我们在遇到错误时正在处理哪个城市。让我们来看一下本章将介绍的最后一种帮助类型：参数帮助信息。
- en: Parameter help messages
  id: totrans-210
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参数帮助信息
- en: 'As well as controlling how parameters work in a script, we can also write helpful
    comments to guide people in using parameters in our scripts. These comments only
    apply to mandatory comments and are available if the mandatory parameter isn’t
    provided. Let’s try it. Edit the `$City` parameter like this:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 除了控制脚本中参数的工作方式外，我们还可以写出有用的注释，以指导人们如何在我们的脚本中使用参数。这些注释仅适用于必填参数，并且在没有提供必填参数时可用。让我们试试看。编辑`$City`参数如下：
- en: '[PRE24]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Now, when we run it without supplying a value for the `$City` parameter, we
    get a message suggesting we type an interrobang (`!?`) for help:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，当我们在没有为`$City`参数提供值的情况下运行时，会得到一条提示信息，建议我们输入一个反问符号(`!?`)来获取帮助：
- en: '![Figure 8.13 – Accessing the HelpMessage parameter](img/B17600_08_013.jpg)'
  id: totrans-214
  prefs: []
  type: TYPE_IMG
  zh: '![图 8.13 – 访问 HelpMessage 参数](img/B17600_08_013.jpg)'
- en: Figure 8.13 – Accessing the HelpMessage parameter
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.13 – 访问 HelpMessage 参数
- en: Once we type the interrobang, the message we wrote in the script is presented.
    It’s as easy as that; just remember that we can only use parameter help messages
    with mandatory parameters.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们输入反问符号，脚本中编写的信息就会显示出来。就这么简单；只要记住，只有在必填参数时才能使用参数帮助消息。
- en: That about wraps it up for this chapter. Let’s review what we’ve learned.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 本章内容差不多到此为止。让我们回顾一下我们所学的内容。
- en: Summary
  id: totrans-218
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we’ve moved on from learning the building blocks of PowerShell
    syntax, and now we’re beginning to put things together. The techniques we’ve learned
    may not be familiar to us, but with time and practice, they will become familiar
    and easy. As we go through the rest of the book, we will have plenty of opportunities
    to use them.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们已经从学习 PowerShell 语法的基本构件开始，接下来将把它们组合起来。我们学到的技术可能对我们来说不太熟悉，但随着时间和实践的积累，它们将变得熟悉且易于掌握。在接下来的书籍中，我们将有很多机会使用它们。
- en: We started by talking about what scripts are and why we might want to write
    scripts at all. We looked briefly at where we can find other people’s scripts,
    and what we need to do to run them on our machines.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先讨论了脚本是什么，以及我们为什么要编写脚本。我们简要了解了如何找到其他人的脚本，以及如何在自己的机器上运行它们。
- en: We’ve done a lot of practical work in this chapter. Firstly, we looked at how
    we might make it easier for people to read what we’re doing by breaking long pipelines
    up and substituting variables for hardcoded values in cmdlets, particularly values
    that might change.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 本章我们做了很多实践工作。首先，我们探讨了如何通过拆分长管道并用变量替代 cmdlet 中的硬编码值，特别是可能会变化的值，来使他人更容易理解我们正在做的事情。
- en: We moved on to look at how we could pass those values into the script from outside
    using parameters, and we looked at various ways we could define and manipulate
    those parameters by making them mandatory or taking values from the pipeline.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 我们接着讨论了如何通过使用参数从外部将这些值传递到脚本中，并查看了我们可以通过将参数设置为必填项或从管道中获取值来定义和操作这些参数的不同方法。
- en: We then looked at how we could make our scripts more easily understood by providing
    comments, before creating full-blown comment-based help for them, so that we can
    use the `Get-Help` cmdlet.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们研究了如何通过提供注释使我们的脚本更易于理解，接着为它们创建了完整的基于注释的帮助，以便我们能够使用`Get-Help` cmdlet。
- en: After that, we looked at using the `Write-Verbose` cmdlet to provide verbose
    output. This helps us understand what our script is doing when it doesn’t seem
    to be working as we hoped.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，我们查看了如何使用`Write-Verbose` cmdlet来提供详细输出。这帮助我们理解当脚本似乎没有按预期工作时，脚本到底在做什么。
- en: Finally, we looked at providing help messages for mandatory parameters to make
    it easier for people to run our scripts.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们研究了如何为必填参数提供帮助消息，以便让人们更容易地运行我们的脚本。
- en: In the next chapter, we’re going to look at how we can make our code simpler
    and easier to write using script blocks, lambdas, and functions.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将探讨如何使用脚本块、lambda 表达式和函数来使我们的代码更简洁、更容易编写。
- en: Further reading
  id: totrans-227
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: 'Output streams: https://learn.microsoft.com/en-us/powershell/module/microsoft.powershell.core/about/about_output_streams'
  id: totrans-228
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 输出流：[https://learn.microsoft.com/en-us/powershell/module/microsoft.powershell.core/about/about_output_streams](https://learn.microsoft.com/en-us/powershell/module/microsoft.powershell.core/about/about_output_streams)
- en: 'Some automation theory: https://poshidiot.wordpress.com/2018/06/12/how-do-i-know-what-to-automate/'
  id: totrans-229
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一些自动化理论：[https://poshidiot.wordpress.com/2018/06/12/how-do-i-know-what-to-automate/](https://poshidiot.wordpress.com/2018/06/12/how-do-i-know-what-to-automate/)
- en: '*The Practice of Cloud System Administration*, Limoncelli, T., Hogan, C., and
    Chalup, S. (2017) Boston: Addison-Wesley, [*Chapter 12*](B17600_12.xhtml#_idTextAnchor236).'
  id: totrans-230
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*云系统管理实践*，Limoncelli, T., Hogan, C., 和 Chalup, S.（2017），波士顿：Addison-Wesley，[*第12章*](B17600_12.xhtml#_idTextAnchor236)。'
- en: '*Time Management for System Administrators*, Sebastopol: Limoncelli, T. (2008),
    O’Reilly Media, Inc., [*Chapter 13*](B17600_13.xhtml#_idTextAnchor267).'
  id: totrans-231
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*系统管理员时间管理*，Sebastopol: Limoncelli, T. (2008)，O''Reilly Media, Inc.，[*第13章*](B17600_13.xhtml#_idTextAnchor267)。'
- en: '*Why the Fitts list has persisted throughout the history of function allocation*:
    de Winter, J. C. F., and Dodou, D. (2014), Journal of Cognition, Technology &
    Work'
  id: totrans-232
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*为什么Fitts列表在功能分配史上持续存在*：de Winter, J. C. F. 和 Dodou, D. (2014), 《认知学、技术与工作杂志》'
- en: 'Learn more about attributes and parameters: https://learn.microsoft.com/en-us/powershell/scripting/lang-spec/chapter-12'
  id: totrans-233
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 了解更多关于属性和参数的信息：[https://learn.microsoft.com/en-us/powershell/scripting/lang-spec/chapter-12](https://learn.microsoft.com/en-us/powershell/scripting/lang-spec/chapter-12)
- en: Exercises
  id: totrans-234
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 练习
- en: On attempting to run a script we’ve written, another user on our machine gets
    an error message that says `running scripts is disabled on this system`. What
    do we have to do to allow them to run the script?
  id: totrans-235
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当我们尝试运行我们写的脚本时，机器上的另一个用户收到一条错误信息，提示`running scripts is disabled on this system`。我们需要做什么才能允许他们运行这个脚本？
- en: 'We have a young relative who loves *Dungeons and Dragons*, but they’ve lost
    their 20-sided die. We write a short PowerShell script for them, `Get-Die.ps1`,
    as follows:'
  id: totrans-236
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们有一个喜欢*龙与地下城*的年轻亲戚，但他们丢失了20面骰。我们为他们写了一个简短的PowerShell脚本`Get-Die.ps1`，如下所示：
- en: '[PRE25]'
  id: totrans-237
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: This will produce a random number between 1 and 20 every time it is run. Which
    value in this line of code is most likely to change if they lose another die with
    a different number of sides?
  id: totrans-238
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这段代码每次运行时都会生成一个介于1和20之间的随机数。如果他们失去了一颗不同面数的骰子，那么这行代码中最有可能变化的值是什么？
- en: In the `Get-Die.ps1` script from the previous question, how would we parameterize
    the changing value?
  id: totrans-239
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在前一个问题中的`Get-Die.ps1`脚本中，我们该如何为变化的值设置参数？
- en: What type of parameter should it be, and how would we specify it?
  id: totrans-240
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这个参数应该是什么类型的，我们该如何指定它？
- en: They like the script, and now they’ve lost their four-sided die. They’ve discovered
    that they can put any number they like into the parameter. While this was quite
    cool at first, now they want the script to only let them roll the dice that are
    used in the game. How could we do that? We need to know that *Dungeons and Dragons*
    uses 4-, 6-, 8-, 10-, 12-, and 20-sided dice, and we’ll also need to read the
    link about parameters given in the text.
  id: totrans-241
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 他们喜欢这个脚本，现在他们失去了四面骰。他们发现可以在参数中放入任何自己喜欢的数字。虽然一开始这很酷，但现在他们希望脚本只允许他们掷游戏中使用的骰子。我们该怎么做呢？我们需要知道*龙与地下城*使用的是4面、6面、8面、10面、12面和20面骰子，并且我们还需要阅读文本中提供的关于参数的链接。
- en: Our relative explains that sometimes they need to roll more than one die of
    the same type at a time and asks whether there is a way to do this. Well, of course
    there is… let’s write it for them.
  id: totrans-242
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们的亲戚解释说，有时他们需要一次掷多个相同类型的骰子，并问是否有办法做到这一点。当然有……我们来为他们写一个吧。
- en: They’ve noticed that sometimes they forget to put the number of dice in, and
    they get a total of 0\. How could we stop that from happening?
  id: totrans-243
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 他们注意到有时会忘记输入骰子的数量，然后结果总是0。我们该如何阻止这种情况发生？
- en: We’re not always going to be around, and sometimes they aren’t sure what to
    put in the parameters. How could we make it easier for them?
  id: totrans-244
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们不可能一直在场，有时他们不确定该在参数中输入什么。我们该如何让他们更容易使用？
- en: 'They are really trying our patience. Every now and then, they need to roll
    something they call a d100\. This is a 10-sided die, with numbers going up in
    tens: 0, 10, 20, 30, and so on, plus a roll of a normal 10-sided die, which added
    together gives them a number between 1 and 100\. Promising ourselves we’ll never
    babysit for them again, how do we do that?'
  id: totrans-245
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 他们真是让我们耐心到了极限。时不时他们需要掷一个叫做d100的骰子。这是一个10面骰，数字以十为单位递增：0, 10, 20, 30，依此类推，再加上一颗普通的10面骰子，两者加在一起给出一个介于1和100之间的数字。我们答应自己再也不为他们看管了，应该怎么做呢？
