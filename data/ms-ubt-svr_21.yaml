- en: '21'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '21'
- en: Securing Your Server
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 保护你的服务器
- en: It seems like every month there are new reports about companies getting their
    servers compromised. In some cases, entire databases end up freely available on
    the internet, which may even include sensitive user information that can aid miscreants
    in stealing identities. Linux is a very secure platform, but it’s only as secure
    as the administrator who sets it up. Security patches are made available on a
    regular basis, but they offer no value unless you install them. OpenSSH is indispensable
    for remote administration, but it’s also a popular target for threat actors trying
    to break into servers. Backups are a must-have but are potentially useless if
    they’re not tested regularly or they fall into the wrong hands. In some cases,
    even your own employees can cause intentional or unintentional damage. In this
    chapter, we’ll look at some of the ways you can secure your servers from threats.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 每个月似乎都会有关于公司服务器被攻破的新报道。在一些情况下，整个数据库最终会在互联网上公开，这可能包括敏感的用户信息，帮助不法分子窃取身份。Linux是一个非常安全的平台，但它的安全性取决于管理员的设置。安全补丁会定期发布，但只有在安装后才有价值。OpenSSH是远程管理必不可少的工具，但它也是威胁者试图攻入服务器的热门目标。备份是必不可少的，但如果不定期测试或它们落入错误的人手中，备份可能毫无用处。在某些情况下，甚至是你的员工也可能造成有意或无意的损害。在本章中，我们将探讨一些保护服务器免受威胁的方法。
- en: 'In this chapter, we will cover:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将覆盖：
- en: Lowering your attack surface
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 降低攻击面
- en: Understanding and responding to **Common Vulnerabilities and Exposures** (**CVEs**)
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解并响应**常见漏洞和暴露**（**CVE**）
- en: Installing security updates
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 安装安全更新
- en: Automatically installing patches with the Canonical Livepatch service
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Canonical Livepatch服务自动安装补丁
- en: Securing OpenSSH
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 加固OpenSSH
- en: Installing and configuring Fail2ban
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 安装和配置Fail2ban
- en: MariaDB best practices for secure database servers
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: MariaDB最佳实践：确保数据库服务器安全
- en: Setting up a firewall
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设置防火墙
- en: Encrypting and decrypting disks with **Linux Unified Key Setup** (**LUKS**)
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用**Linux统一密钥设置**（**LUKS**）加密和解密磁盘
- en: Locking down sudo
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 锁定sudo
- en: To get started, let’s first talk about ways you may be able to lower your attack
    surface.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们讨论一下如何降低攻击面。
- en: Lowering your attack surface
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 降低攻击面
- en: Your Ubuntu Server installations will likely have one or more important applications
    running on them, some of which might be available to the public internet. This
    is very common for web servers, for example, as it’s the primary goal of a web
    server to offer a website that your users can access.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 你的Ubuntu服务器安装上很可能会运行一个或多个重要的应用程序，其中一些可能对外部互联网开放。例如，Web服务器非常常见，因为Web服务器的主要目标就是提供一个用户可以访问的网站。
- en: Every application that is accessible from outside the walls of your organization
    is a potential entry point for threat actors who might attempt to break into your
    server. The **attack surface** of a server is essentially a list of all the things
    that are potentially exploitable. In regards to security, it’s important to understand
    which applications must be accessible remotely, and which ones you can lock down.
    Every application you lock down lowers the likelihood of it being taken over by
    an outside threat. The process of locking things down is what we refer to as lowering
    your attack surface.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 任何可以从你组织外部访问的应用程序，都是威胁者可能利用的入侵点。服务器的**攻击面**本质上是所有潜在可利用项目的列表。在安全方面，了解哪些应用程序必须远程访问，哪些应用程序可以被锁定非常重要。每一个你锁定的应用程序都会降低它被外部威胁控制的可能性。锁定这些东西的过程就是我们所说的降低攻击面。
- en: Ideally, in a perfect world, we would disallow all outside connections to all
    of our servers. Threat actors can’t break into a server that is completely inaccessible
    from the outside. That doesn’t mean that there aren’t any threats at all, as disgruntled
    employees are always a potential risk. But a server that’s completely inaccessible
    is the most secure of all. However, it’s often not feasible to disallow all outside
    connections. If your company provides a popular public website, then it has to
    be publicly available. However, if you have an application running on your server
    that is only used by users internally, then you should lock it down if you can.
    Whenever possible, it’s good to implement a policy that outside connections are
    always disallowed by default unless there’s a business need to open it up.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 理想情况下，在一个完美的世界里，我们会禁止所有外部连接到我们的所有服务器。威胁行为者无法侵入完全不可从外部访问的服务器。这并不意味着没有任何威胁，因不满的员工总是潜在的风险。但一个完全无法访问的服务器是最安全的。然而，完全禁止所有外部连接通常是不可行的。如果你的公司提供一个流行的公共网站，那么它必须对外开放。然而，如果你在服务器上运行的应用仅供内部用户使用，那么如果可能的话，你应该将其锁定。尽可能地，最好实施一种策略，即除非有业务需要，否则外部连接默认总是被禁止。
- en: What do we mean by “disallow?” There are multiple ways you can disallow access
    to an application on your server. The most effective of these is to completely
    uninstall the application. If you don’t have an application installed at all,
    it’s impossible for it to be a problem. It probably goes without saying that you
    should uninstall applications that aren’t necessary, but the entire point of running
    a server is to serve resources to users, so you’ll always have applications running
    on your server (otherwise there, wouldn’t be a point in having a server at all
    to begin with). Aside from removing an application, you can utilize a firewall
    to only allow specific connections. We’ll actually take a look at setting up a
    firewall later on in this chapter.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 我们所说的“禁止”是什么意思？你可以通过多种方式禁止外部访问你服务器上的应用程序。最有效的方法是完全卸载该应用。如果根本没有安装应用程序，它就不可能成为问题。可能不用说，你应该卸载那些不必要的应用，但运行服务器的核心目的是为用户提供资源，因此你总会在服务器上运行一些应用程序（否则根本就没有必要搭建服务器）。除了移除应用程序，你还可以利用防火墙来仅允许特定的连接。实际上，我们将在本章后面讨论如何设置防火墙。
- en: Most importantly, after a new server is implemented, an administrator should
    always perform a security check to ensure that it’s as secure as it can possibly
    be. No administrator can think of everything, and even the best among us can make
    a mistake, but it’s always important that we do our best to ensure we secure a
    server as much as we can. There are many ways you can secure a server, but the
    first thing you should do is lower your attack surface. This means that you should
    close as many holes as you can, and limit the number of things that outsiders
    could potentially be able to access. In a nutshell, if it’s not required to be
    available from the outside, lock it down. If it’s not necessary at all, remove
    it.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 最重要的是，在新服务器部署后，管理员应该始终进行安全检查，确保它的安全性达到最佳状态。没有管理员能够想到所有的安全细节，即使是我们中最优秀的也可能犯错，但我们始终应该尽最大努力确保服务器的安全。确保服务器安全的方式有很多，但首先要做的是降低攻击面。这意味着你应该尽可能关闭漏洞，限制外部人员可能访问的内容。简而言之，如果某个服务不需要外部访问，就把它锁定。如果根本不需要，就直接移除它。
- en: 'To start inspecting your attack surface, the first thing you should do is see
    which ports are listening for network connections. When an attacker wants to break
    into your server, it’s almost certain that a port scan is the first thing they
    will perform. They’ll inventory which ports on your server are listening for connections,
    determine what kind of application is listening on those ports, and then try a
    list of known vulnerabilities to try to gain access. To inspect which ports are
    listening on your server, you can do a simple port query with the `ss` command:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 要开始检查你的攻击面，首先要做的是查看哪些端口正在监听网络连接。当攻击者试图侵入你的服务器时，他们几乎肯定会先进行端口扫描。他们会列出哪些端口在监听连接，确定哪些应用程序在这些端口上监听，然后尝试已知的漏洞列表来获得访问权限。要检查哪些端口正在你的服务器上监听，你可以使用`ss`命令进行简单的端口查询：
- en: '[PRE0]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The `sudo` portion of that command is optional, but if you do include `sudo`,
    you’ll see more information in the output. Normally I’d include a screenshot here,
    but there’s so much information that it won’t fit on this page. From the output,
    you’ll see a list of ports that are listening for connections. If the port is
    listening on `0.0.0.0`, then it’s listening for connections from any network.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: '`sudo`命令部分是可选的，但如果你包括了`sudo`，你将在输出中看到更多的信息。通常我会在这里包含一张截图，但信息太多，无法适应这一页面。从输出中，你将看到一个监听连接的端口列表。如果端口监听在`0.0.0.0`上，那么它正在监听来自任何网络的连接。'
- en: This is potentially bad. If the port is listening on `127.0.0.1`, then it’s
    not actually accepting outside connections. Take a minute to inspect one of your
    servers with the `ss` command and note which services are listening for outside
    connections.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 这可能是个坏消息。如果端口监听在`127.0.0.1`上，那么它实际上并未接受外部连接。花点时间用`ss`命令检查你的其中一台服务器，看看哪些服务正在监听外部连接。
- en: Armed with the knowledge of what ports your server is listening on, you can
    make a decision about what to do with each one. Some of those ports may be required,
    as the entire purpose of a server is to serve something, which usually means communicating
    over the network. All of these legitimate ports should be protected in some way,
    which usually means configuring the service after reviewing its documentation
    for best practices (which will depend on the particular service) or enabling a
    firewall, which we’ll get to in the *Setting up a firewall* section. If any of
    the ports are not needed, you should close them down. You can either stop their
    daemon and disable it, or remove the package outright. I usually go for the latter,
    since it would just be a matter of reinstalling the package if I changed my mind.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 了解了你的服务器正在监听哪些端口后，你可以决定如何处理每个端口。有些端口可能是必需的，因为服务器的整体目的是提供服务，而这通常意味着通过网络进行通信。所有这些合法端口应该以某种方式得到保护，这通常意味着在查看相关文档并遵循最佳实践（取决于特定服务）后配置该服务，或者启用防火墙，这将在*设置防火墙*部分中讨论。如果有任何端口不再需要，你应该关闭它们。你可以停止其守护进程并禁用它，或者直接移除相应的包。我通常选择后者，因为如果我改变主意，只需要重新安装该包即可。
- en: OpenSSH is a service that you’re almost always going to have running on your
    servers. As you are already well aware, it’s a great tool for remote administration.
    But as useful as it is, it’s usually going to be the first target for any attacker
    attempting to gain entry into your server.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: OpenSSH是你几乎总会在服务器上运行的服务。正如你已经非常清楚的，它是一个远程管理的好工具。但尽管它非常有用，它通常会成为任何攻击者试图侵入服务器时的首要目标。
- en: We won’t want to remove this though, because it’s something we’ll want to take
    advantage of. What should we do? Not to worry, I’ll be dedicating a section to
    securing OpenSSH later in this chapter. I mention this now in order to make sure
    you’re aware that lowering your attack surface will absolutely need to include
    at least a basic amount of security tweaking for OpenSSH. In addition, I’ll go
    over Fail2ban in this chapter as well, which can help add an additional layer
    of security to OpenSSH.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不希望删除这个服务，因为这是我们希望利用的功能。我们该怎么办呢？别担心，我将在本章稍后专门讲解如何加固OpenSSH。我现在提到这一点是为了确保你意识到，降低攻击面绝对需要对OpenSSH进行至少基本的安全调整。此外，我还会在本章中介绍Fail2ban，它可以帮助为OpenSSH增加额外的安全层。
- en: 'As I’ve mentioned, I’m a big fan of removing packages that aren’t needed. The
    more packages you have installed, the larger your attack surface is. It’s important
    to remove anything you don’t absolutely need. Even if a package isn’t listed as
    an open port, it could still be leveraged in a **vulnerability chain**. If an
    attacker uses a vulnerability chain, that essentially means that they first break
    into one service and then use a vulnerability in another (possibly unrelated)
    package to elevate their privileges and attempt to gain full access. For that
    reason, I will need to underscore the fact that you should remove any packages
    you don’t need on your server. An easy way to get a list of all the packages you
    have installed is with the following command:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我之前提到的，我非常支持删除不需要的软件包。你安装的软件包越多，你的攻击面就越大。移除任何不绝对必要的东西是很重要的。即使某个软件包没有列为开放端口，它仍然可能在**漏洞链**中被利用。如果攻击者使用漏洞链，那意味着他们首先攻破一个服务，然后利用另一个（可能不相关）软件包中的漏洞来提升他们的权限并试图获得完全访问权限。因此，我必须强调，你应该删除服务器上不需要的任何软件包。获取所有已安装软件包列表的一个简单方法是使用以下命令：
- en: '[PRE1]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: This command will result in the creation of a text file that will contain a
    list of all the packages that you have installed on your server. Take a moment
    to look at it. Does anything stand out that you know for sure you don’t need?
    You most likely won’t know the purpose of every single package, and there could
    be hundreds or more. A lot of the packages that will be contained in the text
    file are distribution-required packages you can’t remove if you want your server
    to boot up the next time you go to restart it. If you don’t know whether or not
    a package can be removed, do some research on Google. If you still don’t know,
    maybe you should leave that package alone and move on to inspect others. By going
    through this exercise on your servers, you’ll never really remember the purpose
    of every single package and library, but you should still find some things that
    you’ll be able to clean up. Eventually, you’ll come up with a list of typical
    packages most of your servers don’t need, which you can make sure are removed
    each time you set up a new server. You could even curate a list of unneeded packages,
    and then create an Ansible playbook to make sure they’re not installed.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 该命令将生成一个文本文件，文件中包含你在服务器上安装的所有软件包的列表。花点时间查看它。有任何你确定不需要的东西突出显示吗？你很可能不知道每个软件包的用途，可能有数百个或更多。文本文件中包含的许多软件包是分发所必需的，如果你希望服务器在下次重新启动时能够启动，这些软件包是不能移除的。如果你不确定某个软件包是否可以删除，可以在Google上做些研究。如果仍然不确定，也许你应该保持这个软件包不变，转而检查其他的软件包。通过在服务器上进行这样的操作，你或许永远也记不住每个软件包和库的具体用途，但你仍然能找到一些可以清理的东西。最终，你会得出一份典型的软件包列表，大部分服务器都不需要这些软件包，你可以确保在每次设置新服务器时删除它们。你甚至可以整理一份不需要的软件包列表，然后创建一个Ansible
    playbook来确保它们不会被安装。
- en: 'While attempting to clean up unneeded packages, a useful trick is to use the
    following command to check whether or not other packages depend on the package
    you are thinking of removing:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 在尝试清理不需要的软件包时，一个有用的技巧是使用以下命令检查是否有其他软件包依赖于你想要移除的软件包：
- en: '[PRE2]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'As an example, I ran that command against the `tmux` package that I installed
    on a test server, but you can use whichever package name you’d like as an argument
    to check to see if anything depends on it:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，我在一个测试服务器上运行了针对`tmux`软件包的命令，但你可以使用任何你喜欢的软件包名称作为参数来检查是否有其他软件包依赖于它：
- en: '[PRE3]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The output I received on my end is the following:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 我在我的终端上收到的输出如下：
- en: '![](img/B18425_21_01.png)'
  id: totrans-36
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B18425_21_01.png)'
- en: 'Figure 21.1: Updating packages on an Ubuntu server'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 图21.1：在Ubuntu服务器上更新软件包
- en: With the output of the previous command, you can easily identify if another
    package depends on the package you are thinking about removing. In the example
    output, we can see that `tmux` is actually installed as a dependency of the `ubuntu-server`
    package. This means that `tmux` is quite possibly installed by default on your
    server, but that may vary depending on whether or not you’ve installed Ubuntu
    Server yourself or are using a cloud image. Cloud providers don’t always configure
    Ubuntu Server images the same way. But at the very least, you can identify dependencies
    and make a more informed decision on whether or not you can safely remove a package.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 使用前一个命令的输出，你可以轻松识别是否有其他软件包依赖于你想要删除的软件包。在示例输出中，我们可以看到`tmux`实际上是作为`ubuntu-server`软件包的依赖项被安装的。这意味着`tmux`很可能是默认安装在你的服务器上的，但这可能会根据你是否自己安装了Ubuntu
    Server或是否使用了云镜像而有所不同。云服务提供商并不总是以相同的方式配置Ubuntu Server镜像。但至少，你可以识别出依赖关系，并做出是否可以安全删除软件包的更明智决定。
- en: Even if the output shows a package has no dependencies, you still may not want
    to remove it unless you understand the functionality it provides and what impact
    removing the package may have on your system. You can always Google the package
    name for more details, but at the very least you should look for open ports and
    focus on those first, since open ports have a greater impact on the security of
    your server. We’ll look at this in more detail later in this chapter, in the *Setting
    up a firewall* section.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 即使输出显示某个软件包没有依赖关系，除非你理解它提供的功能以及删除该软件包可能对系统产生的影响，否则你仍然不应删除它。你可以随时通过Google搜索软件包名称来获取更多详细信息，但至少你应该查看开放的端口，并优先关注这些端口，因为开放端口对服务器的安全性影响更大。我们将在本章稍后的*设置防火墙*部分更详细地讨论这个问题。
- en: Another important consideration is making sure to use only strong passwords.
    This probably goes without saying, since I’m sure you already understand the importance
    of strong passwords. However, I’ve seen hacks recently in the news caused by administrators
    who set weak passwords for their external-facing database or web console, so you
    never know. The most important rule is that if you must have a service listening
    for outside connections, then it absolutely must have a strong, randomly generated
    password. Granted, some daemons don’t have a password associated with them (Apache
    is one example; it doesn’t require authentication for someone to view a web page
    on port `80`). However, if a daemon does have authentication, it should have a
    very strong password. OpenSSH is an example of this. If you must allow external
    access to OpenSSH, that user account should have a strong randomly generated password.
    Otherwise, it will likely be taken over within a couple of weeks by a multitude
    of bots that routinely go around scanning for these types of things. In fact,
    it’s best to disable password authentication in OpenSSH entirely, which we will
    do later in this chapter. Disabling password authentication increases the security
    around OpenSSH quite a bit.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个重要的考虑因素是确保只使用强密码。这点可能不言而喻，因为我相信你已经理解了强密码的重要性。然而，最近我看到一些黑客攻击事件是由于管理员为他们面向外部的数据库或Web控制台设置了弱密码，因此你永远无法预料。最重要的规则是，如果必须有一个服务监听外部连接，那么该服务的密码必须是强密码，并且最好是随机生成的。当然，某些守护进程并没有与之关联的密码（例如Apache；它不需要身份验证就能让某人查看`80`端口上的网页）。然而，如果某个守护进程确实需要身份验证，它的密码应该非常强大。OpenSSH就是一个例子。如果你必须允许外部访问OpenSSH，那么该用户账户的密码应该是一个强大且随机生成的密码。否则，它很可能会在几周内被大量自动扫描的机器人接管。实际上，最好完全禁用OpenSSH中的密码验证，这一点我们将在本章稍后讲解。禁用密码验证会大大增强OpenSSH的安全性。
- en: 'Finally, it’s important to employ the **principle of least privilege** for
    all your user accounts. You’ve probably gotten the impression from several points
    I’ve made throughout the book that I distrust users. While I always want to think
    the best of everyone, sometimes the biggest threats can come from within (disgruntled
    employees, accidental deletions of critical files, and so on). Therefore, it’s
    important to lock down user accounts as much as possible, and allow them access
    to only what they actually need to perform their job. This may involve, but is
    certainly not limited to:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，重要的是对所有用户账户采用**最小权限原则**。你可能已经从书中提到的多个方面感受到我对用户的怀疑。虽然我总是希望对每个人持最好的看法，但有时最大的威胁往往来自内部（如不满的员工、意外删除关键文件等）。因此，尽可能地限制用户账户的权限，只允许他们访问执行工作所需的资源。这可能包括但不限于：
- en: Adding a user to the smallest possible number of groups
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将用户添加到最少的组中
- en: Defaulting all network shares to read-only (users can’t delete what they don’t
    have permission to delete)
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 默认将所有网络共享设置为只读（用户不能删除他们没有权限删除的文件）
- en: Routinely auditing all your servers for user accounts that have not been logged
    into for a time
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 定期审计所有服务器，检查是否有用户账户长时间未登录
- en: Setting account expirations for user accounts, and requiring users to reapply
    to maintain account status (this prevents hanging user accounts)
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为用户账户设置到期时间，并要求用户重新申请以维持账户状态（这可以防止账户长期闲置）
- en: Allowing user accounts to access as few system directories as possible (preferably
    none, if you can help it)
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 允许用户账户访问尽可能少的系统目录（如果可能，最好是没有访问权限）
- en: Restricting `sudo` to specific commands (more on that later on in this chapter)
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 限制`sudo`命令仅对特定命令有效（稍后在本章中会详细讲解）
- en: Above all, make sure you document each of the changes you make to your servers,
    in the name of security. After you develop a good list, you can turn that list
    into a security checklist to serve as a baseline for securing your servers. Then,
    you can set reminders to routinely scan your servers for unused user accounts,
    unnecessary group memberships, and any newly opened ports.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 最重要的是，确保记录下你为提高服务器安全性所做的每一项更改。在你列出一份清单后，可以将其转化为一个安全检查清单，作为加固服务器的基准。然后，你可以设置提醒，定期扫描服务器是否存在未使用的用户账户、不必要的组成员身份或新开放的端口。
- en: Now you should have some good ideas on how you can lower your attack surface.
    It’s also important to keep up to date on the current trends and notices surrounding
    security issues that were reported. In the next section, we’ll take a look at
    **Common Vulnerabilities and Exposures** (**CVEs**), which can help you better
    understand the nature of threats in the wild.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你应该已经有了一些降低攻击面的方法。同时，了解与安全漏洞相关的最新趋势和通告也很重要。在接下来的部分中，我们将讨论**常见漏洞与暴露**（**CVE**），它将帮助你更好地理解现实中威胁的性质。
- en: Understanding and responding to CVEs
  id: totrans-50
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解并应对CVE
- en: I’ve already mentioned some of the things you can do in order to protect your
    server from some common threats, and I’ll give you more tips later on in this
    chapter. But how does one know when there’s a vulnerability that needs to be patched?
    How do you know when to take action? The best practices I’ll mention in this chapter
    will only go so far; at some point, there may be some sort of security issue that
    will require you to do something beyond generating a strong password or locking
    down a port.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 我已经提到了一些可以用来保护服务器免受常见威胁的措施，稍后在本章中我还会提供更多建议。但是，如何知道何时有漏洞需要修补？如何判断何时需要采取行动？我在本章中提到的最佳实践虽然有效，但总有一天，可能会遇到一些超出生成强密码或锁定端口的安全问题。
- en: The most important thing to do is to keep up with the news. Subscribe to sites
    that report news on security vulnerabilities, and I’ll even place a few of these
    in the *Further reading* section of this chapter. When a security flaw is revealed,
    it’s typically reported on these sites and given a CVE number, where security
    researchers will document their findings.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 最重要的是保持关注新闻。订阅一些报告安全漏洞的站点，稍后我还会将这些站点列在本章的*进一步阅读*部分。当安全漏洞被公开时，通常会在这些站点报道，并分配CVE编号，安全研究人员会记录他们的发现。
- en: CVEs are found in special online catalogs detailing security vulnerabilities
    and their related information. In fact, many Linux distributions (Ubuntu included)
    maintain their own CVE catalogs with vulnerabilities specific to their platform.
    On such a page, you can see which CVEs the version of your distribution is vulnerable
    to, which have been responded to, and what updates to install in order to address
    them.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: CVE（公共漏洞和暴露）可以在专门的在线目录中找到，这些目录详细列出了安全漏洞及其相关信息。实际上，许多 Linux 发行版（包括 Ubuntu）都维护着自己的
    CVE 目录，列出了特定于其平台的漏洞。在这样的页面上，你可以看到你的发行版版本易受哪些 CVE 的影响，哪些已得到响应，以及为了应对这些漏洞需要安装哪些更新。
- en: Often, when a security vulnerability is discovered, it will receive a CVE identification
    right away, even before mitigation techniques are known. In my case, I’ll often
    watch a CVE page for a flaw when one is discovered, and look for it to be updated
    with information on how to mitigate it once that’s determined.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，当发现安全漏洞时，CVE 标识符会立即分配给该漏洞，即使还没有确定解决方法。在我的情况下，每当发现一个漏洞时，我通常会关注这个 CVE 页面，等待该页面更新，并提供解决该漏洞的方法。
- en: Most often, closing the hole will involve installing a security update, which
    the security team for Ubuntu will create to address the flaw. In some cases, the
    new update will require restarting the server or at least a running service, which
    means I may have to wait for a maintenance period to perform the mitigation.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，修补漏洞需要安装安全更新，这些更新由 Ubuntu 的安全团队创建，用于解决漏洞。在某些情况下，新的更新可能需要重新启动服务器，或者至少需要重新启动某些正在运行的服务，这意味着我可能需要等待一个维护窗口来执行修复。
- en: I recommend taking a look at the Ubuntu CVE tracker, available at [https://ubuntu.com/security/cves](https://ubuntu.com/security/cves).
    On this site, Canonical (the makers of Ubuntu) keeps information regarding CVEs
    that affect the Ubuntu platform. There, you can get a list of vulnerabilities
    that are known to the platform as well as the steps required to address them.
    There’s no one rule about securing your server, but paying attention to CVEs is
    a good place to start. We’ll go over installing security updates in the next section,
    which is the most common method of mitigation.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 我推荐查看 Ubuntu CVE 跟踪器，网址为 [https://ubuntu.com/security/cves](https://ubuntu.com/security/cves)。在这个网站上，Canonical（Ubuntu
    的开发商）会更新与 Ubuntu 平台相关的 CVE 信息。在那里，你可以找到已知的漏洞列表以及解决这些漏洞所需的步骤。没有一种固定的规则来保护你的服务器，但关注
    CVE 是一个很好的起点。在接下来的章节中，我们将讨论安装安全更新，这是最常见的修复方法。
- en: Installing security updates
  id: totrans-57
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 安装安全更新
- en: Since I’ve mentioned updating packages several times, let’s have a formal conversation
    about it. Updated packages are made available for Ubuntu quite often, sometimes
    even daily. These updates mainly include the latest security updates but may also
    include new features. Since Ubuntu 22.04 is an LTS release, security updates are
    much more common than feature updates.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我提到过多次更新包，我们来正式讨论一下这个话题。Ubuntu 会非常频繁地发布更新包，有时甚至是每天都会发布。这些更新主要包括最新的安全更新，但也可能包括新功能。由于
    Ubuntu 22.04 是 LTS 版本，安全更新比功能更新更为常见。
- en: Installing the latest updates on your server is a very important practice, but,
    unfortunately, it’s not something that all administrators keep up with for various
    reasons.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 在你的服务器上安装最新的更新是一项非常重要的实践，但遗憾的是，由于各种原因，并不是所有管理员都能够做到这一点。
- en: When installed, security updates very rarely make many changes to your server,
    other than helping to keep it secure against the latest threats. However, it’s
    always possible that a security update that’s intended to fix a security issue
    ends up breaking something else. This is rare, but I’ve seen it happen. When it
    comes to production servers, it’s often difficult to keep them updated, since
    it may be catastrophic to your organization to introduce change within a server
    that’s responsible for a large portion of your profits. If a server goes down,
    it could be very costly. Then again, if your servers become compromised and your
    organization ends up the subject of a CNN hacking story, you’ll definitely wish
    you had kept your packages up to date!
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 安装后，安全更新通常不会对服务器进行太多更改，除非是帮助保持服务器抵御最新威胁的安全性。然而，安全更新有时也可能导致其他功能出现问题，尽管这种情况比较罕见，但我也见过这种情况发生。对于生产服务器而言，保持更新通常是很困难的，因为在负责公司大部分利润的服务器上进行任何更改都可能对公司造成灾难性后果。如果服务器宕机，可能会非常昂贵。但另一方面，如果你的服务器被攻破，而你的公司成为
    CNN 黑客新闻的焦点，你肯定会后悔没有及时保持软件包更新！
- en: The key to a happy data center is to test all updates before you install them.
    Many administrators will feature a system where updates will *graduate* from one
    environment to the next. For example, some may create virtual clones of their
    production servers, update them, and then see whether anything breaks. If nothing
    breaks, then those updates will be allowed on the production servers.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 一个快乐的数据中心的关键是，在安装任何更新之前先进行测试。许多管理员会设立一个系统，使得更新会从一个环境逐步*升级*到下一个环境。例如，有些管理员可能会创建他们生产服务器的虚拟克隆，更新它们，然后观察是否会出现任何故障。如果没有任何问题，那么这些更新就会被允许在生产服务器上安装。
- en: In a clustered environment, an administrator may just update one of the production
    servers, see how it gets impacted, and then schedule a time to update the rest.
    In the case of workstations, I’ve seen policies where select users are chosen
    for security updates before they are uploaded to the rest of the population. I’m
    not necessarily suggesting you treat your users as guinea pigs, but everyone’s
    organization is different, and finding the right balance for installing updates
    is very important. Although these updates represent change, there’s a reason that
    Ubuntu’s developers went through the hassle of making them available. These updates
    fix issues, some of which are security concerns that are already being exploited
    as you read this.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 在集群环境中，管理员可能只更新一个生产服务器，看看它受到了怎样的影响，然后安排时间更新其他服务器。在工作站的情况下，我见过一些策略，先选择特定用户进行安全更新，然后再将这些更新推送到其他用户群体中。我并不一定建议你把用户当作实验品，但每个组织都是不同的，找到合适的更新安装平衡非常重要。尽管这些更新代表着变更，但Ubuntu开发者之所以愿意进行这些麻烦的工作，还是有原因的。这些更新修复了很多问题，其中一些是安全问题，而这些问题已经在你阅读本文时被恶意利用。
- en: To begin the process of installing security updates, the first step is to update
    your local repository index. As we’ve discussed before, the way to do so is to
    run `sudo apt update`. This will instruct your server to check all of its subscribed
    repositories to see whether any new packages were added or whether any out-of-date
    packages were removed. Then, you can start the actual process.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 要开始安装安全更新，第一步是更新本地的存储库索引。如前所述，执行的命令是 `sudo apt update`。这会指示你的服务器检查所有已订阅的存储库，看是否有新增的包，或有过时的包被移除。然后，你可以开始实际的更新过程。
- en: There are two commands you can use to update packages. You can run either `sudo
    apt upgrade` or `sudo apt dist-upgrade`.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 有两个命令可以用来更新包。你可以运行 `sudo apt upgrade` 或 `sudo apt dist-upgrade`。
- en: The difference is that running `apt upgrade` will not remove any packages and
    is the safest to use. However, this command won’t pull down any new dependencies
    either. Basically, the `apt upgrade` command simply updates any packages on your
    server that have already been installed, without adding or removing anything.
    Since this command won’t install anything new, this also means your server will
    not have updated kernels installed either.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 不同之处在于，运行 `apt upgrade` 命令不会移除任何包，且它是最安全的使用方式。然而，这个命令也不会拉取任何新的依赖包。基本上，`apt upgrade`
    命令只是更新已经安装在你服务器上的任何包，而不会添加或移除任何内容。由于这个命令不会安装任何新东西，也就意味着你的服务器将不会安装更新的内核。
- en: The `apt dist-upgrade` command will update absolutely everything available.
    It will make sure all packages on your server are updated, even if that means
    installing a new package as a dependency that wasn’t required before. If a package
    needs to be removed in order to satisfy a dependency, it will do that as well.
    If an updated kernel is available, it will be installed. If you use this command,
    just take a moment to look at the proposed changes before you agree to have it
    run, as it will allow you to confirm the changes during the process.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: '`apt dist-upgrade` 命令会更新所有可用的软件包。它会确保服务器上的所有软件包都被更新，即使这意味着需要安装一个之前不需要的新的依赖包。如果为了满足依赖关系需要移除某个包，它也会这样做。如果有更新的内核可用，它也会被安装。如果你使用这个命令，执行前请先花点时间查看提议的变更，这样在执行过程中你可以确认这些变更。'
- en: Generally speaking, the `dist-upgrade` variation should represent your end goal,
    but it’s not necessarily where you should start. Updated kernels are important,
    since your distribution’s kernel receives security updates just like any other
    package. All packages should be updated eventually, even if that means something
    is removed because it’s no longer needed or something new ends up getting installed.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 一般来说，`dist-upgrade`变体应该代表你的最终目标，但这不一定是你应该开始的地方。更新内核很重要，因为你发行版的内核会像其他包一样接收安全更新。所有的包最终都应该更新，即使这意味着某些包会被移除，因为它们不再需要，或者会安装一些新的包。
- en: 'When you start the process of updating, it will look similar to the following:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 当你开始更新过程时，它将看起来像下面这样：
- en: '![](img/B18425_21_02.png)'
  id: totrans-69
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B18425_21_02.png)'
- en: 'Figure 21.2: Updating packages on an Ubuntu server'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 图21.2：在Ubuntu服务器上更新包
- en: Before the update process actually starts, you’ll be given an overview of what
    it wants to do. In my case, it wants to upgrade `11` packages. If you were to
    enter `Y` and then press *Enter*, the update process would begin. At this point,
    I’ll need to leave the terminal window open; it’s actually dangerous to close
    it in the middle of the update process. Closing the terminal window in the middle
    of a package management task may result in corrupted or partially installed packages.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 在更新过程正式开始之前，你将获得一个它想要执行操作的概述。在我的情况下，它想要升级`11`个包。如果你输入`Y`然后按*Enter*，更新过程将开始。此时，我需要保持终端窗口打开；在更新过程中关闭它是危险的。在包管理任务中途关闭终端窗口可能会导致包损坏或部分安装。
- en: Assuming that this process finishes successfully, we can run the `apt dist-upgrade`
    command to update the rest – specifically, the packages that were held back because
    they would’ve installed new packages or removed existing ones. There weren’t any
    in my case, but in such a situation you may see text indicating that some upgrades
    were held back, which is normal with `apt upgrade`. At that point, you’ll run
    `sudo apt dist-upgrade` to install any remaining updates that didn’t get installed
    with the first command.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 假设这个过程成功完成，我们可以运行`apt dist-upgrade`命令来更新剩余部分——特别是那些由于安装新包或移除现有包而被暂时保留的包。在我的情况下没有这类包，但在这种情况下，你可能会看到一些文本，表示某些升级被保留，这在`apt
    upgrade`中是正常的。此时，你将运行`sudo apt dist-upgrade`来安装第一个命令未能安装的剩余更新。
- en: In regard to updating the kernel, this process deserves some additional discussion.
    Some distributions are very risky when it comes to updating the kernel. Arch Linux
    is an example of this, where only one kernel is installed at any one time. Therefore,
    when that kernel gets updated, you really need to reboot the machine so that it
    can use it properly (sometimes, various system components may have difficulty
    in a case where you have a pending reboot after installing a new kernel).
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 关于更新内核，这个过程值得进一步讨论。有些发行版在更新内核时非常冒险。例如，Arch Linux就是这样，任何时候只有一个内核被安装。因此，当这个内核更新时，你真的需要重启机器，这样它才能正确使用这个内核（有时，当你安装新内核后有待重启时，系统的某些组件可能会遇到问题）。
- en: Ubuntu, on the other hand, handles kernel upgrades very efficiently. When you
    update a kernel in Ubuntu, it doesn’t replace the kernel your server is currently
    running on. Instead, it installs the updated kernel alongside your existing one.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，Ubuntu在处理内核升级方面非常高效。当你在Ubuntu中更新内核时，它不会替换你当前正在运行的内核。相反，它会将更新后的内核与现有的内核一起安装。
- en: In fact, these kernels will continue to be stacked and none of them will be
    removed as new ones are installed. When new versions of the Ubuntu kernel are
    installed, the GNU GRUB boot loader will be updated automatically to boot the
    new kernel the next time you perform a reboot.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，这些内核会继续堆叠，新的内核安装时，旧的内核不会被移除。当新的Ubuntu内核版本被安装时，GNU GRUB引导加载程序会自动更新，以便在你下次重启时启动新的内核。
- en: Until you do, you can continue to run on your current kernel for as long as
    you need to, and you shouldn’t notice any difference. The only real difference
    is the fact that you’re not taking advantage of the additional security patches
    of the new kernel until you reboot, which you can do during your next maintenance
    window. The reason this method of updating is great is that if you run into a
    problem where the new kernel doesn’t boot or has some sort of issue, you’ll have
    a chance to press *Esc* at the beginning of the boot process, where you’ll be
    able to browse a list of all of your installed kernels. Using this list, you can
    choose between your previous (known, working) kernels and continue to use your
    server as you were before you updated the kernel. This is a valuable safety net!
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 在你重启之前，你可以继续使用当前的内核，直到你需要为止，而且应该不会察觉到任何区别。唯一的区别是，在你重启之前，你没有利用新内核的额外安全补丁，你可以在下次维护窗口期间进行重启。这个更新方法之所以很棒，是因为如果遇到新内核无法启动或出现某些问题的情况，你可以在启动过程中按*Esc*键，这时你将能够浏览你所有已安装的内核列表。通过这个列表，你可以选择使用之前的（已知且可用的）内核，继续像更新内核之前一样使用服务器。这是一个非常有价值的安全保障！
- en: 'After you update the packages on your server, you may want to restart services
    in order to take advantage of the new security updates. In the case of kernels,
    you would need to reboot your entire server in order to take advantage of kernel
    updates, but other updates don’t require a reboot. Instead, if you restart the
    associated service, you’ll generally be fine (if the update itself didn’t already
    trigger a restart of a service). For example, if your DNS service (`bind9`) was
    updated, you would only need to execute the following to restart the service:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 在你更新完服务器上的软件包后，你可能希望重新启动服务，以便利用新的安全更新。对于内核更新，你需要重启整个服务器才能利用新的内核更新，但其他更新则不需要重启。相反，如果你重启相关服务，通常就可以了（如果更新本身没有触发服务的重启）。例如，如果你的DNS服务（`bind9`）被更新，你只需要执行以下命令来重启服务：
- en: '[PRE4]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'In addition to keeping packages up to date, it’s also important that you understand
    how to roll back an updated package in a situation where something went wrong.
    You can recover from such a situation by simply reinstalling an older version
    of a package manually. Previously downloaded packages are stored in the following
    directory:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 除了保持软件包更新外，了解如何在发生故障时回滚更新的软件包也同样重要。你可以通过手动重新安装旧版本的软件包来从这种情况中恢复。以前下载的软件包存储在以下目录中：
- en: '[PRE5]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'There, you should find the actual packages that were downloaded as a part of
    your update process. In a case where you need to restore an updated package to
    a previously installed version, you can manually install a package with the `dpkg`
    command. Generally, the syntax will be similar to the following:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 在那里，你应该能够找到作为更新过程一部分下载的实际软件包。如果你需要将更新的软件包恢复到先前安装的版本，可以使用`dpkg`命令手动安装该软件包。一般来说，语法类似于以下内容：
- en: '[PRE6]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'To be more precise, you would use a command such as the following to reinstall
    a previously downloaded package, using an older Linux kernel as an example:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 更准确地说，你可以使用如下命令重新安装之前下载的软件包，以较旧的Linux内核为例：
- en: '[PRE7]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'However, with the `dpkg` command, dependencies aren’t handled automatically,
    so if you are missing a package that your target package requires as a dependency,
    the package will still be installed, but you’ll have unresolved dependencies you’ll
    need to fix. You can try to resolve this situation with `apt`:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，使用`dpkg`命令时，依赖关系不会自动处理，因此如果缺少目标软件包所需的依赖软件包，软件包仍然会被安装，但会有未解决的依赖关系需要修复。你可以尝试使用`apt`来解决这个问题：
- en: '[PRE8]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The `apt -f install` command will attempt to fix your installed packages, looking
    for packages that are missing (but are required by an installed package), and
    will offer to install the missing dependencies for you. In a case where it cannot
    find a missing dependency, it will offer to remove the package that requires the
    missing packages if the situation cannot be worked out any other way.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: '`apt -f install`命令将尝试修复已安装的软件包，寻找缺失的软件包（但已安装的软件包需要的），并提供安装缺失依赖的选项。如果无法找到缺失的依赖，它会提供删除依赖缺失的软件包的选项，前提是无法通过其他方式解决问题。'
- en: Well, there you have it. At this point, you should be well on your way to not
    only installing packages but keeping them updated as well. There’s also a feature
    in Ubuntu that you can utilize to take advantage of the concept of **live patching**,
    which you can use to patch your server’s kernel automatically. That’s what we’ll
    cover in the next section.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 好了，事情就是这样。此时，你应该已经不仅仅能够安装软件包，而且能够保持它们的更新。Ubuntu中还有一个功能，你可以利用它来享受**实时补丁**的概念，从而自动修补服务器的内核。接下来，我们将在下一节中讨论这个内容。
- en: Automatically installing patches with the Canonical Livepatch service
  id: totrans-89
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Canonical Livepatch服务自动安装补丁
- en: In the previous section, I mentioned that if your updates include an update
    to the kernel, you’ll need to reboot your server for the new kernel to take effect.
    While this is generally true, Canonical offers a **Livepatch** service for Ubuntu,
    which allows it to receive updates and have them applied without rebooting. This
    is a game changer, as it takes care of keeping your running kernel patched without
    you having to do anything, not even reboot. This is a massive benefit to security,
    as it gives you the benefits of the latest security patches without the inconvenience
    of scheduling a restart of your servers right away.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 在前一节中，我提到过，如果你的更新包括内核更新，你将需要重启服务器才能使新的内核生效。虽然这通常是正确的，但Canonical为Ubuntu提供了一项**Livepatch**服务，使得更新可以在不重启的情况下进行并应用。这是一个游戏规则的改变，因为它能够在你不做任何事情（甚至不需要重启）的情况下，保持正在运行的内核得到修补。这对安全性是一个巨大的好处，因为它让你在不需要立即安排服务器重启的情况下，享受到最新的安全补丁。
- en: However, the service is not free or included with Ubuntu by default. Even so,
    you can install the Livepatch service on three of your servers without paying,
    so it’s still something you may want to consider. You’re even able to utilize
    this service on the desktop version of Ubuntu if you’d like. Since you can use
    this service for free on three servers, I see no reason why you shouldn’t benefit
    from this on your most critical resources.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这项服务并不是免费的，默认情况下也不包含在Ubuntu中。尽管如此，你可以在不付费的情况下，在三台服务器上安装Livepatch服务，所以它仍然是你可能想要考虑的东西。如果你愿意，你甚至可以在Ubuntu的桌面版上使用这项服务。由于你可以在三台服务器上免费使用这项服务，我认为没有理由不在你的最关键资源上也受益于此。
- en: Even though you generally won’t need to reboot your server in order to take
    advantage of patches with the Livepatch service, there may be some exceptions
    depending on the nature of the vulnerability. There have been exploits in the
    past that required complex changes, and even servers subscribed to this service
    still needed to reboot. This is the exception rather than the rule, though. Most
    of the time, a reboot is simply not something you’ll need to worry about if you’re
    utilizing Livepatch. More often than not, your server will have all patches applied
    and inserted right into the running kernel, which is an amazing thing.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管你通常不需要重启服务器就能利用Livepatch服务的补丁，但根据漏洞的性质，可能会有一些例外情况。过去曾有一些漏洞需要复杂的变更，甚至订阅了这项服务的服务器也需要重启。不过，这种情况是例外，而不是常规。大多数时候，如果你在使用Livepatch，重启根本不是你需要担心的事情。大多数情况下，你的服务器会将所有补丁应用并直接插入到正在运行的内核中，这是非常棒的。
- en: One important thing to note is that this doesn’t stop you from needing to install
    updates via `apt`. Live patches are inserted right into the kernel, but they’re
    not permanent. You’ll still want to install all of your package updates on a regular
    basis through the regular means. At the very least, live patches will make it
    so that you won’t be in such a hurry to reboot. If an exploit is revealed on Monday
    but you aren’t able to reboot your server until Sunday, it’s no big deal.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 需要注意的一点是，这并不意味着你不需要通过`apt`安装更新。实时补丁直接插入内核，但它们并不是永久性的。你仍然需要定期通过常规方式安装所有的软件包更新。至少，实时补丁可以让你在重启时不那么着急。如果一个漏洞在星期一被揭露，但你直到星期天才能重启服务器，那也没什么大问题。
- en: Since the Livepatch service requires a subscription, you’ll need to create an
    account in order to get started using it. You can get started with this process
    at [https://auth.livepatch.canonical.com/](https://auth.livepatch.canonical.com/).
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 由于Livepatch服务需要订阅，你需要创建一个账户才能开始使用它。你可以在[https://auth.livepatch.canonical.com/](https://auth.livepatch.canonical.com/)开始这个过程。
- en: The process will involve having you create an Ubuntu One account ([https://login.ubuntu.com/](https://login.ubuntu.com/)),
    which is Canonical’s centralized login system. You’ll enter your email address,
    choose a password, and then at the end of the process, you’ll be given a token
    to use with your Livepatch service, which will be a string of random characters.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 这个过程将要求你创建一个 Ubuntu One 账户 ([https://login.ubuntu.com/](https://login.ubuntu.com/))，这是
    Canonical 的集中登录系统。你需要输入电子邮件地址，选择密码，然后在过程结束时，你将获得一个用于 Livepatch 服务的令牌，它将是一个随机字符的字符串。
- en: 'Now that you have a token, you can decide on the three servers that are most
    important to you. On each of those servers, you can run the following commands
    to get started:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你有了一个令牌，你可以选择最重要的三台服务器。在每台服务器上，你可以运行以下命令来开始使用：
- en: '[PRE9]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Believe it or not, that’s all there is to it. With how amazing the Livepatch
    service is, you’d think it would be a complicated process to set up. The most
    time-consuming part is registering for a new account, as it only takes two commands
    to set this service up on a server. You can check the status of Livepatch with
    the following command:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 相信与否，这就是全部内容。考虑到 Livepatch 服务的强大，你可能会以为它的设置过程很复杂。最耗时的部分是注册一个新账户，实际上只需要两个命令就能在服务器上设置这个服务。你可以通过以下命令检查
    Livepatch 的状态：
- en: '[PRE10]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Depending on the budget of your organization, you may decide that this service
    is worth paying for, which will allow you to benefit from having it on more than
    three servers. It’s definitely worth considering. You’ll need to contact Canonical
    to inquire about additional support, should you decide to explore that option.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 根据你所在组织的预算，你可能会决定支付费用来使用此服务，这样你就能在三台以上的服务器上受益。这个选择绝对值得考虑。如果你决定选择这个选项，需要联系 Canonical
    了解更多的支持信息。
- en: At this point, we should switch gears and discuss some things we can do to better
    secure OpenSSH. I’ve mentioned a few times throughout this chapter that OpenSSH
    is a common target for outside threat actors, so in the next section, it’s time
    to take a closer look at this.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，我们应该换个思路，讨论一些可以改进 OpenSSH 安全性的方法。我在本章中提到过几次，OpenSSH 是外部威胁行为者的常见攻击目标，因此在下一节中，我们将仔细审视这一点。
- en: Securing OpenSSH
  id: totrans-102
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 安全加固 OpenSSH
- en: OpenSSH is a very useful utility; it allows us to configure our servers from
    a remote location as if we were sitting in front of the console. In the case of
    cloud resources, it’s typically the only way to access our servers. Considering
    the nature of OpenSSH itself (remote administration), it’s a very tempting target
    for miscreants who are looking to cause trouble. If we simply leave OpenSSH unsecured,
    this useful utility may be our worst nightmare.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: OpenSSH 是一个非常有用的工具，它使我们可以像坐在控制台前一样，从远程位置配置服务器。在云资源的情况下，通常这是访问我们服务器的唯一方式。考虑到
    OpenSSH 本身的性质（远程管理），它成为了那些寻求制造麻烦的不法分子非常有吸引力的目标。如果我们只是将 OpenSSH 放任不管，它这个有用的工具可能会变成我们的噩梦。
- en: Thankfully, configuring OpenSSH itself is very easy. However, the large number
    of configuration options may be intimidating to someone who doesn’t have much
    experience tuning it. While it’s a good idea to peruse the documentation for OpenSSH,
    in this section, we’ll take a look at the common configuration options you’ll
    want to focus your attention on first.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，配置 OpenSSH 本身是非常简单的。然而，大量的配置选项可能会让没有多少经验的人感到困惑。虽然查看 OpenSSH 的文档是一个好主意，但在本节中，我们将先来看看你需要重点关注的一些常见配置选项。
- en: The configuration file for OpenSSH itself is located at `/etc/ssh/sshd_config`,
    and we touched on it in *Chapter 10*, *Connecting to Networks*. This is the file
    we’re going to focus on in this section, as the configuration options I’m going
    to give you are to be placed in that file.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: OpenSSH 的配置文件位于 `/etc/ssh/sshd_config`，我们在 *第十章*，*连接到网络* 中提到过。这个文件就是我们本节要重点讨论的文件，因为我要给你的一些配置选项都需要放入这个文件中。
- en: 'With each of the tweaks in this section, make sure you first look through the
    file in order to see whether the setting is already there and change it accordingly.
    If the setting is not present in the file, add it. After you make your changes,
    it’s important to restart the OpenSSH daemon:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中的每一个调整步骤，确保你首先浏览该文件，查看设置是否已经存在并做出相应的更改。如果文件中没有该设置，请添加它。修改完成后，重启 OpenSSH
    守护进程非常重要：
- en: '[PRE11]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Go ahead and open this file in your editor, and we’ll go through some tweaks.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 继续并在编辑器中打开此文件，我们将进行一些调整。
- en: 'One really easy tweak is to change the port number that OpenSSH listens on,
    which defaults to port `22`. Since this is the first port that hackers will attempt,
    it makes sense to change it, and it’s a very easy change to make. However, I don’t
    want you to think that just because you change the port for OpenSSH, it’s magically
    hidden and cannot be detected. A persistent threat actor will still be able to
    find the port by running a port scan against your server. However, with the change
    being so easy to tweak, why not do it? To change it, simply look for the port
    number in the `/etc/ssh/sshd_config` file and change it from its default of `22`:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 一个非常简单的调整是改变 OpenSSH 监听的端口号，默认是端口`22`。由于这是黑客首先尝试的端口，改变它是有道理的，而且这是一个非常容易的修改。不过，我不希望你认为仅仅因为你更改了
    OpenSSH 的端口，它就神奇地被隐藏了并且无法被检测到。一个持续的威胁者仍然能够通过对你的服务器进行端口扫描来找到这个端口。然而，既然这个修改如此简单，为什么不做呢？要更改它，只需在`/etc/ssh/sshd_config`文件中查找端口号，并将其从默认的`22`更改：
- en: '[PRE12]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'The only downsides I can think of in regards to changing the SSH port are that
    you’ll have to remember to specify the port number when using SSH, and you’ll
    have to communicate the change to anyone that uses the server. To specify the
    port, we use the `-p` option with the `ssh` command:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 我能想到的唯一缺点是更改 SSH 端口后，你需要记得在使用 SSH 时指定端口号，并且必须将更改通知任何使用该服务器的人。要指定端口，我们使用`ssh`命令中的`-p`选项：
- en: '[PRE13]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'If you’re using `scp`, you’ll need to use an uppercase `P` instead:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你使用的是`scp`，你需要改用大写的`P`：
- en: '[PRE14]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Even though changing the port number won’t make your server bulletproof, we
    shouldn’t underestimate the value of doing so. In a hypothetical example where
    an attacker is scanning servers on the internet for an open port `22`, they’ll
    probably skip your server and move on to the next. Only determined attackers that
    specifically want to break into your server will scan other ports looking for
    it. This also keeps your log file clean; you’ll see intrusion attempts only from
    miscreants doing aggressive port scans, rather than random bots looking for open
    ports.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管更改端口号不会让你的服务器成为万无一失的堡垒，但我们不应低估这么做的价值。在一个假设的例子中，假如攻击者正在扫描互联网上的服务器寻找开放的`22`端口，他们可能会跳过你的服务器，继续扫描下一个。只有那些有决心的攻击者，专门想要入侵你的服务器，才会扫描其他端口来寻找它。这也能保持你的日志文件干净；你只会看到那些进行积极端口扫描的恶意行为，而不是那些随机的机器人寻找开放端口。
- en: If your server is internet-facing, this will result in far fewer entries in
    the logs! OpenSSH logs connection attempts in the authorization log, located at
    `/var/log/auth.log`. Feel free to check out that log file to see what typical
    logging looks like.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你的服务器面向互联网，这将导致日志中出现的条目大大减少！OpenSSH 会在授权日志中记录连接尝试，日志位置是`/var/log/auth.log`。你可以随时查看该日志文件，了解典型的日志记录内容。
- en: 'Another change that’s worth mentioning is which protocol OpenSSH listens for.
    Most versions of OpenSSH available in repositories today default to Protocol 2\.
    This is what you want. Protocol 2 is much more secure than Protocol 1\. You should
    never allow Protocol 1 in production under any circumstances. Chances are you’re
    probably already using the default of Protocol 2 on your server, unless you changed
    it for some reason. I mention it here just in case you have older servers still
    in production that are defaulting to the older protocol. Nowadays, OpenSSH is
    always on Protocol 2 in any modern release of a Linux distribution. If you do
    have an older server that’s still using Protocol 1, you can adjust that by finding
    the following line in the `/etc/ssh/sshd_config` file:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个值得提到的更改是 OpenSSH 监听的协议。大多数今天在仓库中提供的 OpenSSH 版本默认使用协议 2。这就是你想要的。协议 2 比协议 1
    安全得多。你绝不应该在生产环境中允许使用协议 1。除非你出于某种原因更改了它，否则你很可能已经在服务器上使用了协议 2 的默认设置。我在这里提到它是以防你仍在使用较老的服务器，它们默认使用旧协议。如今，任何现代版本的
    Linux 发行版中的 OpenSSH 都始终使用协议 2。如果你确实有使用协议 1 的旧服务器，你可以通过在`/etc/ssh/sshd_config`文件中找到以下行进行调整：
- en: '[PRE15]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Switching OpenSSH to use Protocol 2 is as simple as changing the `1` on that
    line to `2`, and then restarting the OpenSSH server:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 将 OpenSSH 切换到使用协议 2 只需将该行中的`1`改为`2`，然后重启 OpenSSH 服务器：
- en: '[PRE16]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Next, I’ll give you two tweaks for the price of one. There are two settings
    that deal with which users and groups are allowed to log in via SSH: `AllowUsers`
    and `AllowGroups`, respectively. By default, every user you create is allowed
    to log in to your server via SSH. With regards to `root`, that’s actually not
    allowed by default (more on that later). But each user you create is allowed in.
    However, only users that must have access should be allowed in. There are two
    ways to accomplish this.'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我将为您提供两个调整选项，价格只需一个。有两个设置涉及允许哪些用户和组通过SSH登录：`AllowUsers`和`AllowGroups`，分别是。默认情况下，您创建的每个用户都可以通过SSH登录到您的服务器。关于`root`，默认情况下实际上是不允许的（稍后详细介绍）。但是您创建的每个用户都被允许进入。但是，只有必须访问的用户才能进入。有两种方法可以实现这一点。
- en: 'One option is to use `AllowUsers`. With the `AllowUsers` option, you can specifically
    set which users can log in to your server. With `AllowUsers` present (which is
    not found in the `config` file by default), your server will not allow anyone
    to use SSH that you don’t specifically call out with that option. You can separate
    each user with a space:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 一种选项是使用`AllowUsers`。使用`AllowUsers`选项，您可以明确设置哪些用户可以登录到您的服务器上。有了`AllowUsers`存在（默认情况下在`config`文件中找不到），您的服务器将不允许任何未经特别指定的用户使用SSH。您可以用空格分隔每个用户：
- en: '[PRE17]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Personally, I find `AllowGroups` easier to manage. It works pretty much the
    same as `AllowUsers`, but with groups. If present, it will restrict OpenSSH connections
    to users who are a member of this group. To use it, you’ll first create the group
    in question (you can name it whatever makes sense to you):'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 就个人而言，我发现`AllowGroups`更易于管理。它与`AllowUsers`基本相同，但与组一起使用。如果存在，它将限制OpenSSH连接到属于此组的用户。要使用它，您首先需要创建相关的组（您可以按照自己的逻辑命名）：
- en: '[PRE18]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Then, you’ll make one or more users a member of that group:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，您将使一个或多个用户成为该组的成员：
- en: '[PRE19]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Once you have added the group and made a user or two a member of that group,
    add the following to your `/etc/ssh/sshd_config` file, replacing the sample groups
    with yours:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦您添加了该组并使一个或两个用户成为该组的成员，请添加以下内容到您的`/etc/ssh/sshd_config`文件，用您的示例组替换：
- en: '[PRE20]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: It’s fine to use only one group. Just make sure you add yourself to the group
    before you log out; otherwise, you’ll lock yourself out. I recommend you use only
    one or the other between `AllowUsers` and `AllowGroups`. I think that it’s much
    easier to use `AllowGroups`, since you’ll never need to touch the `sshd_config`
    file again; you’ll simply add or remove user accounts to and from the group to
    control access. Just so you’re aware, `AllowUsers` overrides `AllowGroups`.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 只使用一个组也是可以的。只需确保在注销前将自己添加到组中；否则，您将被锁定。我建议您只使用`AllowUsers`或`AllowGroups`中的一个。我认为使用`AllowGroups`更容易，因为您将永远不需要再次触及`sshd_config`文件；您只需将用户帐户添加或删除到组中以控制访问。只要您知道，`AllowUsers`将覆盖`AllowGroups`。
- en: 'Another important option is `PermitRootLogin`, which controls whether or not
    the `root` user account is able to make SSH connections. This should always be
    set to `no`. By default, this is usually set to `prohibit-password`, which means
    key authentication is allowed for `root` while passwords for `root` aren’t accepted.
    I don’t see any reason for this either. In my opinion, you should turn this off.
    Having `root` being able to log in to your server over a network connection is
    never a good idea. This is always the first user account attackers will try to
    use:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个重要选项是`PermitRootLogin`，它控制`root`用户帐户是否能够建立SSH连接。这应该始终设置为`no`。通常情况下，默认设置为`prohibit-password`，这意味着`root`可以使用密钥认证，但不接受密码。我也不认为有任何理由这样做。在我看来，您应该关闭此功能。使`root`能够通过网络连接登录到您的服务器绝不是一个好主意。这始终是攻击者尝试使用的第一个用户帐户：
- en: '[PRE21]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: There is one exception to the *no-root* rule with SSH. Some providers of cloud
    servers, such as Linode, may have you log in as `root` by default. This isn’t
    really typical, but some providers are set up that way. In such a case, I recommend
    creating a regular user with `sudo` access, and then disallowing `root` login.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 在SSH的*no-root*规则中有一个例外情况。一些云服务器提供商，例如Linode，默认情况下可能要求您以`root`身份登录。这并不是很典型，但有些提供商是这样设置的。在这种情况下，我建议创建一个具有`sudo`访问权限的常规用户，然后禁止`root`登录。
- en: My next suggestion is by no means easy to set up, but it’s worth it. By default,
    OpenSSH allows users to authenticate via passwords. This is one of the first things
    I disable on all my servers. Allowing users to enter passwords to establish a
    connection means that attackers will also be able to brute-force your server.
    If passwords aren’t allowed, then they can’t do that. What’s tricky is that before
    you can disable password authentication for SSH, you’ll first need to configure
    and test an alternate means of authenticating, which will usually be public key
    authentication. This is something we’ve gone over, in *Chapter 10*, *Connecting
    to Networks*. Basically, you can generate an SSH key pair on your local workstation,
    and then add that key to the `authorized_keys` file on the server, which will
    allow you in without a password. Again, refer to *Chapter 10*, *Connecting to
    Networks*, if you haven’t played around with this yet.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 我的下一个建议虽然设置起来不容易，但绝对值得。默认情况下，OpenSSH 允许用户通过密码进行身份验证。这是我在所有服务器上第一个禁用的功能。允许用户通过密码建立连接意味着攻击者也能暴力破解你的服务器。如果不允许密码认证，他们就无法这么做。问题是，在禁用
    SSH 密码认证之前，你首先需要配置并测试一种备用的身份验证方式，通常是公钥认证。这是我们在*第10章*《连接到网络》中讲解过的内容。基本上，你可以在本地工作站生成一对
    SSH 密钥，并将该密钥添加到服务器上的 `authorized_keys` 文件中，这样就可以无需密码登录。再说一遍，如果你还没做过，参考*第10章*《连接到网络》。
- en: 'If you disable password authentication for OpenSSH, then public key authentication
    will be the only way in. If someone tries to connect to your server and they don’t
    have the appropriate key, the server will deny their access immediately. If password
    authentication is enabled and you have a key relationship, then the server will
    ask the user for their password if their key isn’t installed. In my view, after
    you set up access via public key cryptography, you should disable password authentication
    (just make sure you test it first):'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你禁用 OpenSSH 的密码认证，那么公钥认证将是唯一的登录方式。如果有人尝试连接到你的服务器而没有合适的密钥，服务器将立即拒绝其访问。如果启用了密码认证并且你有密钥关系，那么如果用户的密钥没有安装，服务器将会要求他们输入密码。在我看来，在你设置好公钥加密方式的访问后，应当禁用密码认证（但一定要先进行测试）：
- en: '[PRE22]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'There you are – those are my most recommended tweaks for securing OpenSSH.
    There’s certainly more where that came from, but those are the settings you’ll
    benefit from the most. In the next section, we’ll add an additional layer, in
    the form of Fail2ban. With Fail2ban protecting OpenSSH and coupled with the tweaks
    I mentioned in this section, attackers will have a tough time trying to break
    into your server. For your convenience, here are all the OpenSSH configuration
    options I’ve covered in this section:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 就这些——这些是我推荐的最有效的 OpenSSH 安全性调整。虽然还有更多的措施可以采取，但这些设置是你最能从中受益的。在接下来的部分，我们将增加一个额外的安全层，那就是
    Fail2ban。通过 Fail2ban 保护 OpenSSH，加上我在本节中提到的这些调整，攻击者将很难攻破你的服务器。为了方便你，这里列出了我在本节中提到的所有
    OpenSSH 配置选项：
- en: '[PRE23]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: With OpenSSH better secured, we should be a bit more confident now when it comes
    to the security of our server. However, each tweak or improvement we make to improve
    security only helps us so much. The more protections we implement, the better.
    In the next section, we’ll explore Fail2ban, which can greatly increase the security
    of our server.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 随着 OpenSSH 安全性得到了进一步增强，我们现在在服务器安全性方面应该更加有信心了。然而，我们每进行一次安全改进或调整，所带来的保护也只是有限的。保护措施越多，安全性就越强。在接下来的部分，我们将介绍
    Fail2ban，它能够大大增强服务器的安全性。
- en: Installing and configuring Fail2ban
  id: totrans-140
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 安装和配置 Fail2ban
- en: Fail2ban, how I love thee! **Fail2ban** is one of those tools that once I learned
    how valuable it is, I wondered how I ever lived so long without it. Fail2ban is
    able to keep an eye on your log files, looking for authentication failures. You
    can set the number of failures that are allowed from any given IP address, and
    if there are more than the allowed number of failures, Fail2ban will block that
    individual’s IP address. It’s highly configurable and can enhance the security
    of your server.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: Fail2ban，我爱你！**Fail2ban** 是那种一旦我了解到它有多么有价值，就会觉得怎么之前没有使用它的工具。Fail2ban 能够监视你的日志文件，查找认证失败的记录。你可以设置允许来自任何特定
    IP 地址的失败次数，如果失败次数超过了允许的数量，Fail2ban 会屏蔽该 IP 地址。它具有高度的可配置性，能够增强服务器的安全性。
- en: 'Installing and configuring Fail2ban is relatively straightforward. First, install
    its package:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 安装和配置 Fail2ban 相对来说是比较简单的。首先，安装其软件包：
- en: '[PRE24]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'After installation, the `fail2ban` daemon will start up and be configured to
    automatically start at boot time. Configuring `fail2ban` is simply a matter of
    creating a configuration file. But this is one of the more interesting aspects
    of Fail2ban: you shouldn’t use its default `config` file. The default file is
    `/etc/fail2ban/jail.conf`. The problem with this file is that it can be overwritten
    when you install security updates, if those security updates ever include Fail2ban
    itself. To remedy this, Fail2ban also reads the `/etc/fail2ban/jail.local` file,
    if it exists. It will never replace that file, and the presence of a `jail.local`
    file will supersede the `jail.conf` file. The simplest way to get started is to
    make a copy of `jail.conf` and save it as `jail.local`:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 安装后，`fail2ban`守护进程将启动，并配置为在启动时自动启动。配置`fail2ban`只是创建一个配置文件的过程。但这是Fail2ban的一个有趣之处：你不应使用其默认的`config`文件。默认文件是`/etc/fail2ban/jail.conf`。这个文件的问题在于，当你安装安全更新时，如果这些安全更新包括Fail2ban本身，它可能会被覆盖。为了解决这个问题，Fail2ban还会读取`/etc/fail2ban/jail.local`文件（如果存在）。它永远不会替换这个文件，并且`jail.local`文件的存在将优先于`jail.conf`文件。最简单的方式是复制`jail.conf`文件并将其保存为`jail.local`：
- en: '[PRE25]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Next, I’ll go over some of the very important settings you should configure,
    so open up the `/etc/fail2ban/jail.local` file you just copied in a text editor.
    The first configuration item to change is located on or around line 92 and is
    commented out:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我将讲解一些你应该配置的非常重要的设置，所以请在文本编辑器中打开你刚才复制的`/etc/fail2ban/jail.local`文件。第一个需要更改的配置项位于第92行左右，并且被注释掉了：
- en: '[PRE26]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'First of all, uncomment it. Then, you should add additional networks that you
    don’t want to be blocked by Fail2ban. Basically, this will help prevent you from
    getting locked out in a situation where you accidentally trigger Fail2ban. Fail2ban
    is relentless; it will block any service that meets its block criteria, and it
    won’t think twice about it. This includes blocking you. To rectify this, add your
    company’s network here, as well as any other IP address you never want to be blocked.
    Make sure to leave the `localhost` IP intact:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，取消注释。然后，你应该添加你不希望被Fail2ban封锁的其他网络。基本上，这可以帮助你避免在不小心触发Fail2ban时被锁定。Fail2ban是无情的；它会封锁符合其封锁标准的任何服务，而且它不会犹豫。这包括封锁你自己。为了解决这个问题，将公司网络以及任何你不希望被封锁的IP地址添加到此处。确保保留`localhost`
    IP不变：
- en: '[PRE27]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: In that example, I added the `192.168.1.0/24` network, as well as a single IP
    address of `192.168.1.245/24`. Add your networks to this line to *ensure you don’t
    lock yourself out*.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我添加了`192.168.1.0/24`网络，以及单个IP地址`192.168.1.245/24`。将你的网络添加到这一行中，*确保你不会把自己锁定在外面*。
- en: 'Next, line 101 includes the `bantime` option. This option pertains to how many
    seconds a host is banned when Fail2ban blocks it. This option defaults to `10m`,
    or 10 minutes:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，第101行包含`bantime`选项。这个选项决定了当Fail2ban封锁主机时，主机会被封锁多少秒。此选项默认值为`10m`，即10分钟：
- en: '[PRE28]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Change this number to whatever you find reasonable, or just leave it as its
    default, which will also be fine. If a host gets banned, it will be banned for
    this specific number of minutes, and then it will eventually be allowed again.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 将这个数字更改为你认为合理的任何值，或者保持其默认值，这也是可以的。如果主机被封锁，它将被封锁这个特定的分钟数，然后最终将被允许再次访问。
- en: 'Continuing, we have the `maxretry` setting:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们来看`maxretry`设置：
- en: '[PRE29]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: This is specifically the number of failures that need to occur before Fail2ban
    takes action. If a service it’s watching reaches the number set here, game over!
    The IP will be blocked for the number of minutes included in the `bantime` option.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 这是指定Fail2ban采取行动之前需要发生的失败次数。如果它监视的服务达到这里设置的次数，就结束了！该IP将被封锁，持续时间为`bantime`选项中设置的分钟数。
- en: You can change this if you want to, if you don’t find `5` failures to be reasonable.
    The highest I would set it to is `7`, for those users on your network who insist
    they’re typing the correct password and they type the same (wrong) thing over
    and over. Hopefully, they’ll realize their error before their seventh attempt
    and won’t need to call the helpdesk.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你认为`5`次失败不合理，你可以更改这个设置。我建议将其设置为`7`，对于那些在你的网络上坚持认为自己输入了正确密码，但一直输入相同（错误）密码的用户。希望他们能在第七次尝试之前意识到自己的错误，避免需要打电话给技术支持。
- en: 'Skipping ahead all the way down to line 272 or thereabouts, we have the `Jails`
    section. From here, the `config` file will list several jails you can configure,
    which is basically another word for something Fail2ban will pay attention to.
    The first is `[sshd]`, which configures its protection of the OpenSSH daemon.
    Look for this option underneath `[sshd]`:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 跳到大约第272行左右，我们看到了`Jails`部分。从这里开始，`config`文件将列出几个可以配置的监狱，这基本上是Fail2ban需要关注的对象。第一个是`[sshd]`，它配置了OpenSSH守护进程的保护。在`[sshd]`下，查找以下选项：
- en: '[PRE30]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: '`port` being equal to `ssh` basically means that it’s defaulting to port `22`.
    If you’ve changed your SSH port, change this to reflect whatever that port is.
    There are two such occurrences, one under `[sshd]` and another underneath `[sshd-ddos]`:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: '`port`等于`ssh`基本上意味着它默认使用端口`22`。如果你更改了SSH端口，请修改此设置以反映新的端口号。这里有两个类似的地方，一个在`[sshd]`下，另一个在`[sshd-ddos]`下：'
- en: '[PRE31]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Before we go too much further, I want to underscore the fact that we should
    test whether Fail2ban is working after each configuration change we make. To do
    this, restart Fail2ban and then check its status:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们继续之前，我要强调的是，我们每次修改配置后，都应该测试Fail2ban是否正常工作。为此，重启Fail2ban，然后检查它的状态：
- en: '[PRE32]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: The status should always be `active (running)`. If it’s anything else (such
    as `failed`), that means that Fail2ban doesn’t like something in your configuration.
    Usually, that means that Fail2ban’s status will reflect that it exited. So, as
    we go, make sure to restart Fail2ban after each change and make sure it’s not
    complaining about something. The `status` command will show lines from Fail2ban’s
    log file for your convenience.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 状态应始终为`active (running)`。如果是其他任何状态（比如`failed`），则表示Fail2ban不喜欢你的配置中的某些内容。通常，这意味着Fail2ban的状态将显示它已经退出。因此，在整个过程中，确保在每次修改后重启Fail2ban，并确保它没有报错。`status`命令将显示Fail2ban日志文件中的内容，方便你查看。
- en: 'Another useful command to run after restarting Fail2ban is the following:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 重启Fail2ban后，另一个有用的命令是：
- en: '[PRE33]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: The output from that command will show all the jails that you have enabled.
    If you enable a new jail in the `config` file, you should see it listed within
    the output of that command.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 该命令的输出将显示你已启用的所有监狱。如果你在`config`文件中启用了一个新的监狱，你应该能在该命令的输出中看到它。
- en: 'So, how do you enable a jail? By default, all jails are disabled, except for
    the one for OpenSSH. To enable a jail, place the following within its `config`
    block in the `/etc/fail2ban/jail.local` file:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，如何启用一个监狱呢？默认情况下，所有监狱都被禁用，只有OpenSSH的监狱是启用的。要启用一个监狱，请在`/etc/fail2ban/jail.local`文件中的`config`块内加入以下内容：
- en: '[PRE34]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'If you want to enable the `apache-auth` jail, find its section, and place `enabled
    = true` right underneath its stanza. For example, `apache-auth` will look like
    the following after you add the `enabled` line:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想启用`apache-auth`监狱，找到其部分，并在其段落下方添加`enabled = true`。例如，在你添加`enabled`行后，`apache-auth`将如下所示：
- en: '[PRE35]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'In that example, the `enabled = true` portion wasn’t present in the default
    file. I added it. Now that I’ve enabled a new jail, we should restart `fail2ban`:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，`enabled = true`这一部分在默认文件中并不存在。我添加了它。现在我已经启用了一个新的监狱，我们应该重启`fail2ban`：
- en: '[PRE36]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Next, check its status to make sure it didn’t explode on startup:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，检查其状态，确保它在启动时没有出错：
- en: '[PRE37]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Assuming all went well, we should see the new jail listed in the output of
    the following command:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 假设一切顺利，我们应该能在以下命令的输出中看到新监狱：
- en: '[PRE38]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'On my test server, the output became the following once I enabled `apache-auth`:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 在我的测试服务器上，启用`apache-auth`后，输出结果如下：
- en: '[PRE39]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: If you enable a jail for a service you don’t have installed, Fail2ban may fail
    to start up. In my example, I actually did have `apache2` installed on that server
    before I enabled its jail. If I hadn’t, Fail2ban would likely have exited, complaining
    that it wasn’t able to find log files for Apache. This is the reason why I recommend
    that you test Fail2ban after enabling any jail. If Fail2ban decides it doesn’t
    like something, or something it’s looking for isn’t present, it may stop. Then,
    it won’t be protecting you at all, which is not good.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你为未安装的服务启用了一个监狱，Fail2ban可能无法启动。在我的示例中，我在启用`apache2`监狱之前，确实在服务器上安装了`apache2`。如果没有安装，Fail2ban可能会退出并抱怨找不到Apache的日志文件。这也是我建议在启用任何监狱后测试Fail2ban的原因。如果Fail2ban发现它不喜欢某个配置，或者它所需的某些文件缺失，它可能会停止工作。然后，它就无法为你提供保护了，这可不好。
- en: The basic order of operations for Fail2ban is to peruse the jail `config` file,
    looking for any jails you may benefit from. If you have a daemon running on your
    server, there’s a chance that there’s a jail for that. If there is, enable it
    and see whether Fail2ban breaks. If not, you’re in good shape. If it does fail
    to restart properly, inspect the status output and check what it’s complaining
    about.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: Fail2ban的基本操作顺序是浏览监狱的`config`文件，查看哪些监狱可能对你有帮助。如果你的服务器上运行着一个守护进程，那么有可能有一个监狱是专门为它设计的。如果有，启用它并查看Fail2ban是否能够正常启动。如果没有问题，那就很好。如果它无法正常重启，检查状态输出，看看它在抱怨什么。
- en: One thing you may want to do is add the `enabled = true` line to `[sshd]` and
    `[sshd-ddos]`. Sure, the `[sshd]` jail is already enabled by default, but since
    it wasn’t specifically called out in the `config` file, I don’t trust it. So you
    might as well add an `enabled` line to be safe. There are several jails you may
    benefit from. If you are using `SSL` with `Apache`, enable `[apache-modsecurity]`.
    Also, consider enabling `[apache-shellshock]` while you’re at it to potentially
    protect Apache from the Shellshock vulnerability. If you’re running your own mail
    server and have `Roundcube` running, enable `[roundcube-auth]` and `[postfix]`.
    There are a lot of default jails at your disposal!
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能需要做的一件事是将`enabled = true`这一行添加到`[sshd]`和`[sshd-ddos]`中。没错，`[sshd]`的监狱默认已经启用，但由于它在`config`文件中并没有特别标明，所以我对此不太信任。因此，你最好还是添加一个`enabled`行来确保安全。你可能还会从其他一些监狱中受益。如果你使用`SSL`和`Apache`，启用`[apache-modsecurity]`。同时，考虑启用`[apache-shellshock]`，以便在此过程中潜在地保护Apache免受Shellshock漏洞的影响。如果你正在运行自己的邮件服务器并且有`Roundcube`在运行，启用`[roundcube-auth]`和`[postfix]`。有很多默认的监狱可以供你使用！
- en: Like all security applications, Fail2ban isn’t going to automatically make your
    server impervious to all attacks, but it is a helpful additional layer you can
    add to your security regimen. When it comes to the jails for OpenSSH, Fail2ban
    is worth its weight in gold, and that’s really the least you should enable. Go
    ahead and give Fail2ban a go on your servers—just make sure you also add your
    own network to the `Ignoreip` list that was covered earlier, in case you accidentally
    type your own SSH password incorrectly too many times and potentially lock yourself
    out. Fail2ban doesn’t discriminate; it’ll block anyone. Once you get it fully
    configured, I think you’ll agree that Fail2ban is a worthy ally for your servers.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 像所有的安全应用程序一样，Fail2ban并不会自动让你的服务器对所有攻击免疫，但它是你可以添加到安全策略中的一个有用的附加层。就OpenSSH的监狱而言，Fail2ban的价值不言而喻，这实际上是你应该启用的最基本内容。快去在你的服务器上试试Fail2ban吧——只要确保你也将自己的网络添加到之前提到的`Ignoreip`列表中，以防你不小心输入错误的SSH密码太多次而可能把自己锁住。Fail2ban不分青红皂白；它会封锁任何人。一旦你完成了全面配置，我相信你会同意Fail2ban是你服务器的一个值得信赖的盟友。
- en: Earlier, I mentioned that each service that runs on your computer listening
    for connections is a potential target. While it’s impossible to go over every
    service you could possibly run on your server and how to secure it, we will want
    to consider securing our database server (if we have one) since organizations
    typically store valuable data there. We’ll learn some methods we can utilize to
    better secure MariaDB next.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 我之前提到过，每个在你的计算机上监听连接的服务都有可能成为攻击目标。虽然不可能逐一讲解你可能在服务器上运行的每个服务以及如何保护它们，但我们需要考虑保护我们的数据库服务器（如果有的话），因为组织通常会在这里存储重要数据。接下来我们将学习一些方法，可以帮助我们更好地保护MariaDB。
- en: MariaDB best practices for secure database servers
  id: totrans-185
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: MariaDB最佳实践：安全的数据库服务器
- en: MariaDB, as well as MySQL, is a very useful resource to have at your disposal.
    However, it can also be used against you if configured improperly. Thankfully,
    it’s not too hard to secure, but there are several points of consideration to
    make regarding your database server when developing your security design.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: MariaDB和MySQL是非常有用的资源，值得你使用。然而，如果配置不当，它们也可能被用来攻击你。幸运的是，它的安全性并不难把握，但在制定安全设计时，你需要考虑一些有关数据库服务器的要点。
- en: The first point is probably obvious to most of you, and I have mentioned it
    before, but I’ll mention it just in case. Your database server should not be reachable
    from the internet. I do understand that there are some edge cases when developing
    a network, and certain applications may require access to a MySQL database over
    the internet. However, if your database server is accessible over the internet,
    miscreants will try their best to attack it and gain entry. If there’s any vulnerability
    in your version of MariaDB or MySQL, they’ll most likely be able to hack into
    it.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 第一点对大多数人来说可能很明显，我之前也提到过，但我还是提一下，以防万一。您的数据库服务器不应该能通过互联网访问。我理解在开发网络时有一些特殊情况，某些应用可能需要通过互联网访问MySQL数据库。然而，如果您的数据库服务器可以通过互联网访问，坏人将会尽全力攻击并试图入侵。如果您的MariaDB或MySQL版本存在任何漏洞，他们很可能会成功入侵。
- en: In most organizations, a great way to implement a database server is to make
    it accessible by only internal servers. This means that while your web server
    would obviously be accessible from the internet, its backend database should exist
    on a different server on your internal network and accept communications only
    from the web server. If your database server is a VPS or cloud instance, it should
    especially be configured to only accept communications from your web server, as
    VPS machines are accessible via the internet by default. Therefore, it’s still
    possible for your database server to be breached if your web server is also breached,
    but it would be less likely to be compromised if it resides on a separate and
    restricted server.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 在大多数组织中，实施数据库服务器的一个好方法是只允许内部服务器访问。这意味着虽然您的Web服务器显然可以通过互联网访问，但它的后台数据库应该存在于您内部网络上的另一台服务器，并且仅接受来自Web服务器的通信。如果您的数据库服务器是VPS或云实例，它应该特别配置为仅接受来自Web服务器的通信，因为VPS机器默认是可以通过互联网访问的。因此，如果您的Web服务器被攻破，您的数据库服务器仍然有可能受到攻击，但如果数据库服务器存在于一个独立且受限的服务器上，被入侵的可能性就会小得多。
- en: Some VPS providers, such as DigitalOcean and Linode, feature local networking,
    which you can leverage for your database server instead of allowing it to be accessible
    over the internet. If your VPS provider features local networking, you should
    definitely utilize it and deny traffic from outside the local network.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 一些VPS提供商，如DigitalOcean和Linode，提供本地网络功能，您可以利用这一功能来让数据库服务器只能在本地网络中访问，而不是允许它通过互联网访问。如果您的VPS提供商提供本地网络功能，您应该毫不犹豫地使用它，并拒绝来自外部网络的流量。
- en: With regards to limiting which servers are able to access a database server,
    there are a few tweaks we can use to accomplish this. First, we can leverage the
    `/etc/hosts.allow` and `/etc/hosts.deny` files. With the `/etc/hosts.deny` file,
    we can stop traffic from certain networks or from specific services. With `/etc/hosts.allow`,
    we allow the traffic. This works because IP addresses included in `/etc/hosts.allow`
    override `/etc/hosts.deny`. So basically, if you deny everything in `/etc/hosts.deny`
    and allow a resource or two in `/etc/hosts.allow`, you’re saying, deny everything,
    except resources I explicitly allow from the `/etc/hosts.deny` file.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 关于限制哪些服务器能够访问数据库服务器，我们可以使用一些方法来实现。首先，我们可以利用`/etc/hosts.allow`和`/etc/hosts.deny`文件。通过`/etc/hosts.deny`文件，我们可以阻止来自某些网络或特定服务的流量。通过`/etc/hosts.allow`文件，我们允许特定流量。之所以这样工作，是因为在`/etc/hosts.allow`中列出的IP地址会覆盖`/etc/hosts.deny`中的设置。因此，基本上，如果您在`/etc/hosts.deny`中拒绝所有流量，并在`/etc/hosts.allow`中允许某些资源，实际上就是在说：拒绝所有流量，除非是我在`/etc/hosts.allow`中明确允许的资源。
- en: To make this change, we’ll want to edit the `/etc/hosts.allow` file first. By
    default, this file has no configuration other than some helpful comments. Within
    the file, we can include a list of resources we’d like to be able to access our
    server, no matter what. Make sure that you include your web server here, and also
    make sure that you immediately add the IP address you’ll be using to SSH into
    the machine; otherwise, you’ll lock yourself out once we edit the `/etc/hosts.deny`
    file.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 要进行此更改，首先我们需要编辑`/etc/hosts.allow`文件。默认情况下，此文件除了提供一些有用的注释外，没有其他配置。在文件中，我们可以列出希望始终能够访问服务器的资源。确保在此文件中包含您的Web服务器，并确保立即添加您将用于SSH连接到机器的IP地址；否则，一旦我们编辑`/etc/hosts.deny`文件，您将无法再访问服务器。
- en: Here are some example `hosts.allow` entries, with a description of what each
    example rule does.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是一些`hosts.allow`的示例条目，并附有对每个示例规则作用的描述。
- en: 'The first example rule allows a machine with an IP address of `192.168.1.50`
    to access the server:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个示例规则允许IP地址为`192.168.1.50`的机器访问服务器：
- en: '[PRE40]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'This rule allows any machine within the `192.168.1.0/24` network to access
    the server:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 这个规则允许任何来自`192.168.1.0/24`网络的机器访问服务器：
- en: '[PRE41]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'In this rule, we have an incomplete IP address. This acts as a wildcard, which
    means that any IP address beginning with `192.168.1` is allowed:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个规则中，我们有一个不完整的IP地址。这充当了一个通配符，意味着任何以 `192.168.1` 开头的IP地址都被允许：
- en: '[PRE42]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'This rule allows everything. You definitely don’t want to do this:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 这个规则允许一切。你绝对不想这样做：
- en: '[PRE43]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'We can also allow specific daemons. Here, I’m allowing OpenSSH traffic originating
    from any IP address beginning with `192.168.1`:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以允许特定的守护进程。这里，我允许来自任何以`192.168.1`开头的IP地址的OpenSSH流量：
- en: '[PRE44]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: On your end, if you wish to utilize this security approach, add the resources
    on the database server you’ll be comfortable accepting communications from. Make
    sure you at least add the IP address of another server with access to OpenSSH,
    so you’ll have a way to manage the machine. You can also add all your internal
    IP addresses with a rule similar to the previous examples. Once you have this
    set up, we can edit the `/etc/hosts.deny` file.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 在你的端，如果你希望使用这种安全方法，请添加你希望接受通信的数据库服务器上的资源。确保至少添加另一个具有OpenSSH访问权限的服务器的IP地址，这样你就可以管理该机器。你也可以像之前的示例一样，添加所有内部IP地址的规则。设置好之后，我们可以编辑`/etc/hosts.deny`文件。
- en: 'The `/etc/hosts.deny` file utilizes the same syntax as `/etc/hosts.allow`.
    To finish this little exercise, we can block any traffic not included in the `/etc/hosts.allow`
    file with the following rule:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: '`/etc/hosts.deny` 文件使用与 `/etc/hosts.allow` 相同的语法。为了完成这个小练习，我们可以通过以下规则阻止任何不在
    `/etc/hosts.allow` 文件中的流量：'
- en: '[PRE45]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: The `/etc/hosts.allow` and `/etc/hosts.deny` files don’t represent a complete
    layer of security but are a great first step in securing a database server, especially
    one that might contain sensitive user or financial information. They’re by no
    means specific to MariaDB either, but I mention them here because databases very
    often contain data that, if leaked, could potentially wreak havoc on your organization
    and even put someone out of business. A database server should only ever be accessible
    by the application that needs to utilize it.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: '`/etc/hosts.allow` 和 `/etc/hosts.deny` 文件并不是完整的安全层，但它们是保护数据库服务器的一个很好的第一步，尤其是当服务器可能包含敏感的用户或财务信息时。它们也并不特定于MariaDB，但我在这里提到它们是因为数据库通常包含的数据，如果泄露，可能会对你的组织造成严重影响，甚至让某些公司破产。数据库服务器应该仅仅由需要使用它的应用程序访问。'
- en: 'Another point of consideration is user security. We walked through creating
    database users in *Chapter 13*, *Managing Databases*. In that chapter, we walked
    through the MySQL commands for creating a user as well as `GRANT`, performing
    both in one single command. This is the example I used:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个需要考虑的点是用户安全。我们在*第13章*《管理数据库》中讲解了如何创建数据库用户。在那一章中，我们详细讲解了如何使用MySQL命令创建用户并使用`GRANT`进行授权，将这两者结合在一个命令中。这是我使用的示例：
- en: '[PRE46]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: What’s important here is that we’re allowing access to the `mysampledb` database
    by a user named `appuser`. If you look closer at the command, we’re also specifying
    that this connection is allowed only if it’s coming in from `localhost`. If we
    tried to access this database remotely, it wouldn’t be allowed.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 这里需要注意的是，我们允许名为`appuser`的用户访问`mysampledb`数据库。如果你仔细看这个命令，我们还指定了只有当连接来自`localhost`时才允许访问。如果我们尝试远程访问这个数据库，是不允许的。
- en: 'This is a great default. But you’ll also, at some point, need to access the
    database from a different server. Perhaps your web server and database server
    are separate machines, which is a common enterprise. You could do this:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个很好的默认设置。但在某些时候，你可能需要从不同的服务器访问数据库。也许你的Web服务器和数据库服务器是分开的机器，这是企业中常见的做法。你可以这样做：
- en: '[PRE47]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: However, in my opinion, this is a very bad practice. The `%` character in a
    MySQL `GRANT` command is a wildcard, similar to `*` with other commands. Here,
    we’re basically telling our MariaDB or MySQL instance to accept connections from
    this user, from any network. There is almost never a good reason to do this. I’ve
    heard some administrators use the argument that they don’t allow external traffic
    from their company firewall, so allowing MySQL traffic from any machine shouldn’t
    be a problem. However, that logic breaks down when you consider that if an attacker
    does gain access to any machine in your network, they can immediately target your
    database server. If an internal employee gets angry at management and wants to
    destroy the database, they’ll be able to access it from their workstation. If
    an employee’s workstation becomes affected by malware that targets database servers,
    it may find your database server and try to brute-force it. I could go on and
    on with examples of why allowing access to your database server from any machine
    is a bad idea. Just don’t do it!
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在我看来，这是一种非常糟糕的做法。MySQL `GRANT` 命令中的 `%` 字符是一个通配符，类似于其他命令中的 `*`。在这里，我们基本上是告诉
    MariaDB 或 MySQL 实例接受来自任何网络的这个用户的连接。几乎没有正当理由这样做。我听说一些管理员会用这样的论点来辩解：他们的公司防火墙不允许外部流量，所以允许来自任何机器的
    MySQL 流量应该没问题。然而，这个逻辑在你考虑到如果攻击者确实获得了你网络中任何机器的访问权限时，它们就可以立刻攻击你的数据库服务器时就会崩溃。如果某个内部员工对管理层感到愤怒，想要摧毁数据库，他们就能从自己的工作站访问它。如果某个员工的工作站被恶意软件感染，而这些恶意软件专门针对数据库服务器，那么它可能会找到你的数据库服务器，并尝试进行暴力破解。我可以举出很多例子，说明为什么允许任何机器访问你的数据库服务器是一个糟糕的主意。总之，不要这样做！
- en: 'If we want to give access to a specific IP address, we can do so with the following
    instead:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想允许某个特定的 IP 地址访问，可以使用以下方法：
- en: '[PRE48]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'With the previous example, only a server or workstation with an IP address
    of `192.168.1.50` is allowed to use the `appuser` account to obtain access to
    the database. That’s much better. You can, of course, allow an entire subnet as
    well:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 在之前的示例中，只有 IP 地址为 `192.168.1.50` 的服务器或工作站可以使用 `appuser` 账户访问数据库。这样好多了。当然，你也可以允许整个子网：
- en: '[PRE49]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: Here, any IP address beginning with `192.168.1` is allowed. Honestly, I really
    don’t like allowing an entire subnet. But depending on your network design, you
    may have a dozen or so machines that need access. Hopefully, the subnet you allow
    is not the same subnet your users’ workstations use!
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，任何以 `192.168.1` 开头的 IP 地址都被允许。老实说，我并不喜欢允许整个子网访问。但根据你的网络设计，可能有十几个机器需要访问。希望你允许的子网不是用户工作站所在的子网！
- en: Finally, another point of consideration is security patches for your database
    server software. I know I talk about updates quite a bit, but as I’ve mentioned,
    these updates exist for a reason. Developers don’t release patches for enterprise
    software simply because they’re bored; these updates often patch real problems
    that real people are taking advantage of right now as you read this. Install updates
    regularly. I understand that updates on server applications can scare some people,
    as an update always comes with the risk that it may disrupt business. But as an
    administrator, it’s up to you to create a rollout plan for security patches, and
    ensure they’re installed in a timely fashion. Sure, it’s tough and often has to
    be done after hours. But the last thing I want to do is read about yet another
    company where the contents of their database server were leaked and posted freely
    online. A good security design includes regular patching.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，另一个需要考虑的因素是数据库服务器软件的安全补丁。我知道我经常提到更新，但正如我之前提到的，这些更新是有原因的。开发者不会仅仅因为无聊而发布企业软件的补丁；这些更新通常修复了真实的问题，而这些问题正被现实中的攻击者利用，就在你阅读本文时。请定期安装更新。我理解，服务器应用程序的更新可能会让一些人感到害怕，因为每次更新都伴随一定风险，可能会影响到业务。但作为管理员，你有责任制定一个安全补丁的推广计划，并确保及时安装这些补丁。当然，这很艰难，通常需要在非工作时间进行。但我最不愿意看到的，就是又看到一家公司的数据库服务器内容被泄露，并被随意发布到网上。一个好的安全设计包括定期的补丁更新。
- en: Now that our database server is more secure, there’s another topic worth diving
    into, and that is the subject of implementing a firewall. There are several different
    firewall solutions out there, but UFW is a great choice. It’s easy to set up,
    and quite effective. In the next section, I’ll go over how to implement it.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们的数据库服务器更加安全了，还有一个值得深入探讨的主题，那就是实施防火墙。市面上有几种不同的防火墙解决方案，但 UFW 是一个非常好的选择。它易于设置，且非常有效。在接下来的章节中，我会介绍如何实施它。
- en: Setting up a firewall
  id: totrans-220
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置防火墙
- en: Firewalls are a very important aspect to include in your network and security
    design. Firewalls are extremely easy to implement, but sometimes hard to implement
    well. The problem with firewalls is that they can sometimes offer a false sense
    of security to those who aren’t familiar with the best ways to manage them. Sure,
    they’re good to have, but simply having a firewall isn’t enough by itself.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 防火墙在网络和安全设计中是一个非常重要的组成部分。防火墙非常容易实现，但有时很难做到完美实施。防火墙的问题在于，它们有时会给那些不熟悉最佳管理方式的人带来虚假的安全感。没错，拥有防火墙是好的，但单纯拥有防火墙本身并不足够。
- en: The false sense of security comes when someone thinks that they’re protected
    just because a firewall is installed and enabled, but they’re also often opening
    traffic from any network to internal ports. Take into consideration the firewall
    that was introduced with Windows XP and enabled by default with Windows XP Service
    Pack 2\. Yes, it was a good step but users simply clicked the **allow** button
    whenever something wanted access, which defeats the entire purpose of having a
    firewall. Windows implements this better nowadays, but the false sense of security
    it created remains. Firewalls are not a “set it and forget it” solution!
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 虚假的安全感出现在某些人认为仅仅因为安装并启用了防火墙就能得到保护，但他们往往也会允许从任何网络访问内部端口。考虑一下Windows XP引入的防火墙，它在Windows
    XP Service Pack 2中默认启用。是的，这是一个好的开始，但用户每次看到某些东西请求访问时只是点击了**允许**按钮，这实际上违背了拥有防火墙的整个目的。如今，Windows的实现方式更好，但它曾经带来的虚假安全感依然存在。防火墙不是一个“设置完就忘记”的解决方案！
- en: Firewalls work by allowing or disallowing access to a network port from other
    networks. Most good firewalls block outside traffic by default. When a user or
    administrator enables a service, they open a port for it. Then, that service is
    allowed in. This is great in theory, but where it breaks down is that administrators
    will often allow access from everywhere when they open a port. If an administrator
    does this, they may as well not have a firewall at all. If you need access to
    a server via OpenSSH, you may open up port `22` (or whatever port OpenSSH is listening
    on) to allow it through the firewall. But if you simply allow the port, it’s open
    for everyone else as well.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 防火墙通过允许或拒绝来自其他网络的端口访问来工作。大多数优秀的防火墙默认会阻止外部流量。当用户或管理员启用某个服务时，他们会为该服务打开一个端口。然后，该服务被允许访问。这在理论上很好，但问题在于，管理员在打开端口时经常会允许来自任何地方的访问。如果管理员这样做，他们与没有防火墙几乎没有区别。如果您需要通过OpenSSH访问服务器，您可能会打开端口`22`（或者任何OpenSSH监听的端口）来允许其通过防火墙。但如果您仅仅允许该端口，它也会对其他所有人开放。
- en: When configured properly, a firewall will enable access to a port only from
    specific places. For example, rather than allowing port `22` for OpenSSH to your
    entire network, why not just allow traffic to port `22` from specific IP addresses
    or subnets? Now we’re getting somewhere! In my opinion, allowing all traffic through
    a port is usually a bad idea, though some services actually do need this (such
    as web traffic to your web server). If you can help it, only allow traffic from
    specific networks when you open a port. This is where the use case for a firewall
    really shines.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 当配置正确时，防火墙只允许来自特定地方的端口访问。例如，与其允许整个网络访问端口`22`以使用OpenSSH，不如只允许来自特定IP地址或子网的流量访问端口`22`？现在我们有了思路！在我看来，通常允许所有流量通过某个端口是一个糟糕的主意，尽管某些服务确实需要这样做（例如，向您的Web服务器发送的Web流量）。如果可以的话，在打开端口时只允许来自特定网络的流量。这就是防火墙使用案例的真正亮点所在。
- en: 'In Ubuntu Server, **Uncomplicated Firewall** (**UFW**) is a really useful tool
    for configuring your firewall. As the name suggests, it makes firewall management
    a breeze. To get started, install the `ufw` package:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 在Ubuntu Server中，**简单防火墙**（**UFW**）是一个非常有用的防火墙配置工具。顾名思义，它使得防火墙管理变得轻松无比。首先，安装`ufw`包：
- en: '[PRE50]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'By default, the UFW is inactive. This is a good thing, because we wouldn’t
    want to enable a firewall until after we’ve configured it. The `ufw` package features
    its own command for checking its status:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，UFW是非活动的。这是件好事，因为在我们配置好防火墙之前，我们不希望它被启用。`ufw`包有自己的命令来检查其状态：
- en: '[PRE51]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: Unless you’ve already configured your firewall, the status will come back as
    inactive.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 除非您已经配置了防火墙，否则状态会显示为非活动。
- en: 'With the `ufw` package installed, the first thing we’ll want to do is enable
    traffic via SSH, so we won’t get locked out when we do enable the firewall:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 安装完`ufw`包后，首先我们要做的是启用SSH流量，这样我们在启用防火墙时就不会被锁定：
- en: '[PRE52]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: You can probably see from that example how easy UFW’s syntax is. With that example,
    we’re allowing the `192.168.1.156` IP address access to port `22` via TCP as well
    as UDP. In your case, you would change the IP address accordingly, as well as
    the port number if you’re not using the OpenSSH default port. The `any` option
    refers to any protocol (TCP or UDP).
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能已经从这个示例中看出UFW的语法是多么简单。通过这个示例，我们允许`192.168.1.156`的IP地址通过TCP和UDP访问端口`22`。在你的情况下，你需要相应地更改IP地址，以及如果你不使用OpenSSH默认端口，修改端口号。`any`选项指的是任何协议（TCP或UDP）。
- en: 'You can also allow traffic by subnet:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以按子网允许流量：
- en: '[PRE53]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'Although I don’t recommend this, you can allow all traffic from a specific
    IP to access anything on your server. Use this with care, if you have to use it
    at all:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然我不推荐这样做，但你可以允许特定IP的所有流量访问你服务器上的任何内容。如果必须使用，请小心：
- en: '[PRE54]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'Now that we’ve configured our firewall to allow access via OpenSSH, you should
    also allow any other ports or IP addresses that are required for your server to
    operate efficiently. If your server is a web server, for example, you’ll want
    to allow traffic from ports `80` and `443`. This is one of those few exceptions
    where you’ll want to allow traffic from any network, assuming your web server
    serves an external page on the internet:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们已经配置了防火墙以允许通过OpenSSH访问，你还应该允许任何其他端口或IP地址，以便服务器能够高效运行。例如，如果你的服务器是Web服务器，你将希望允许`80`和`443`端口的流量。这是少数几个例外之一，你可能希望允许任何网络的流量，前提是你的Web服务器在互联网上提供外部页面：
- en: '[PRE55]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'There are various other use patterns for the `ufw` command; refer to the main
    page ([http://manpages.ubuntu.com/manpages/focal/man8/ufw.8.xhtml](http://manpages.ubuntu.com/manpages/focal/man8/ufw.8.xhtml))
    for more. In a nutshell, these examples should enable you to allow traffic through
    specific ports, as well as via specific networks and IP addresses. Once you’ve
    finished configuring the firewall, we can enable it:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: '`ufw`命令还有其他多种使用模式；有关更多信息，请参考主页面([http://manpages.ubuntu.com/manpages/focal/man8/ufw.8.xhtml](http://manpages.ubuntu.com/manpages/focal/man8/ufw.8.xhtml))。简而言之，这些示例应该能让你允许特定端口的流量通过，以及通过特定的网络和IP地址。一旦完成防火墙配置，我们可以启用它：'
- en: '[PRE56]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: Just as the output suggests, our firewall is active and will start up automatically
    whenever we reboot the server.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 正如输出所示，我们的防火墙已激活，并将在每次重启服务器时自动启动。
- en: The UFW package is basically an easy-to-use frontend to the `iptables` firewall,
    and it acts as the default firewall for Ubuntu. The commands we’ve executed so
    far in this section trigger the `iptables` command, which is a command that administrators
    can use to set up a firewall manually. A full walk-through of `iptables` is outside
    the scope of this chapter, and it’s essentially unnecessary, since Ubuntu features
    UFW as its preferred firewall administration tool and it’s the tool you should
    use while administering a firewall on your Ubuntu server.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: UFW软件包基本上是`iptables`防火墙的一个易于使用的前端，并且它作为Ubuntu的默认防火墙。到目前为止，我们在本节中执行的命令触发了`iptables`命令，管理员可以使用该命令手动设置防火墙。`iptables`的详细操作不在本章范围内，且实际上没有必要，因为Ubuntu将UFW作为其首选的防火墙管理工具，而这正是你在管理Ubuntu服务器上的防火墙时应该使用的工具。
- en: With a well-planned firewall implementation, you can better secure your Ubuntu
    Server installation from outside threats. Preferably, each port you open should
    only be accessible from specific machines, with the exception being servers that
    are meant to serve data or resources to external networks. Like all security solutions,
    a firewall won’t make your server invincible, but it does represent an additional
    layer that attackers would have to bypass in order to do harm.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 通过精心规划的防火墙实施，你可以更好地保护你的Ubuntu服务器免受外部威胁。最好是，你打开的每个端口都应该只能从特定的机器访问，唯一的例外是那些用于为外部网络提供数据或资源的服务器。像所有安全解决方案一样，防火墙不能让你的服务器变得刀枪不入，但它确实增加了一个额外的层次，攻击者必须绕过这个层次才能造成伤害。
- en: If your company stores sensitive information, it’s important to ensure the storage
    underneath that data is encrypted. Next, we’re going to look at **Linux Unified
    Key Setup** (**LUKS**), which will help us encrypt and decrypt disks.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你的公司存储敏感信息，确保存储在这些数据下方的部分是加密的非常重要。接下来，我们将介绍**Linux统一密钥设置**（**LUKS**），它将帮助我们加密和解密磁盘。
- en: Encrypting and decrypting disks with LUKS
  id: totrans-245
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用LUKS加密和解密磁盘
- en: An important aspect of security that many people don’t even think about is encryption.
    As I’m sure you know, backups are essential for business continuity. If a server
    breaks down, or a resource stops functioning, backups will be your saving grace.
    But what happens if your backup medium gets stolen or somehow falls into the wrong
    hands? If your backup is not encrypted, then anyone will be able to view its contents.
    Some data isn’t sensitive, so encryption isn’t always required. But anything that
    contains personally identifiable information, company secrets, or anything else
    that would cause any kind of hardship if leaked should be encrypted. In this section,
    I’ll walk you through setting up **LUKS** encryption on an external backup drive.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 安全的一个重要方面是加密，很多人甚至没有考虑过。如你所知，备份对于业务的连续性至关重要。如果服务器故障或资源停止运行，备份将是你的救命稻草。但如果你的备份介质被盗或者不慎落入他人之手，会发生什么呢？如果你的备份没有加密，任何人都可以查看其内容。有些数据并不敏感，因此并不总是需要加密。但包含个人身份信息、公司机密或者其他一旦泄露会带来任何不良后果的内容都应该加密。在本节中，我将指导你在外部备份驱动器上设置**LUKS**加密。
- en: Before we get into that though, I want to quickly mention the importance of
    full-disk encryption for your distribution as well. Although this section is going
    to go over how to encrypt external disks, it’s possible to encrypt the volume
    for your entire Linux installation as well. In the case of Ubuntu, full-disk encryption
    is an option during installation, for both the server and workstation flavors.
    This is especially important when it comes to mobile devices, such as laptops,
    which are stolen quite frequently. If a laptop is planned to store confidential
    data that you cannot afford to have leaked out, you should choose the option during
    installation to encrypt your entire Ubuntu installation. If you don’t, anyone
    that knows how to boot a Live OS disc and mount a hard drive will be able to view
    your data. I’ve seen unencrypted company laptops get stolen before, and it’s not
    a wonderful experience.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 在继续之前，我想简要提到对于您的发行版来说完整磁盘加密的重要性。尽管本节将介绍如何加密外部磁盘，但也可以对整个Linux安装的卷进行加密。对于Ubuntu来说，在安装过程中，无论是服务器版还是工作站版，都可以选择全磁盘加密选项。这在涉及到移动设备（如经常被盗的笔记本电脑）时尤为重要。如果计划在笔记本电脑上存储不能泄露的机密数据，应在安装期间选择加密整个Ubuntu安装选项。否则，任何知道如何引导Live
    OS光盘并挂载硬盘的人都可以查看您的数据。我曾见过未加密的公司笔记本电脑被盗的情况，这并不是一种美好的体验。
- en: 'Anyway, back to the topic of encrypting external volumes. For the purpose of
    encrypting disks, we’ll need to install the `cryptsetup` package:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 无论如何，我们重新回到加密外部卷的话题。为了加密磁盘，我们需要安装`cryptsetup`软件包：
- en: '[PRE57]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: The `cryptsetup` utility allows us to encrypt and unencrypt disks. To continue,
    you’ll need an external disk you can safely format, as encrypting the disk will
    remove any data stored on it. This can be an external hard disk or a flash drive.
    Both can be treated the exact same way. In addition, you can use this same process
    to encrypt a secondary internal hard disk attached to your virtual machine or
    server. I’m assuming that you don’t care about the contents saved on the drive,
    because the process of setting up encryption will wipe it.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: '`cryptsetup`实用程序允许我们加密和解密磁盘。为了继续，您需要一个可以安全格式化的外部磁盘，因为加密磁盘将删除存储在其中的任何数据。这可以是外部硬盘或闪存驱动器。两者可以完全相同地处理。此外，您还可以使用相同的过程来加密连接到虚拟机或服务器的次要内部硬盘。我假设您不关心驱动器上保存的内容，因为设置加密的过程将擦除它。'
- en: If you’re using an external disk, use the `fdisk -l` command as `root` or the
    `lsblk` command to view a list of hard disks attached to your computer or server
    before you insert it. After you insert your external disk or flash drive, run
    the command again to determine the device designation for your removable media.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在使用外部磁盘，请在将其插入计算机或服务器之前，以`root`用户身份使用`fdisk -l`命令或使用`lsblk`命令查看连接到计算机或服务器的硬盘列表。插入外部磁盘或闪存驱动器后，请再次运行命令以确定可移动介质的设备标识。
- en: In my examples, I used `/dev/sdb`, but you should use whatever designation your
    device was given. This is important, because you don’t want to wipe out your `root`
    partition or an existing data partition!
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 在我的示例中，我使用了`/dev/sdb`，但您应该使用您设备分配的任何标识。这很重要，因为您不希望擦除您的`root`分区或现有的数据分区！
- en: 'First, we’ll need to use `cryptsetup` to format our disk:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要使用`cryptsetup`来格式化我们的磁盘：
- en: '[PRE58]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'You’ll receive the following warning:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 你将收到以下警告：
- en: '[PRE59]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: Type `YES` and press *Enter* to continue. Next, you’ll be asked for the passphrase.
    This passphrase will be required in order to unlock the drive. Make sure you use
    a good, randomly generated password and that you store it somewhere safe. If you
    lose it, you will not be able to unlock the drive. You’ll be asked to confirm
    the passphrase.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 输入`YES`并按*Enter*键继续。接下来，你将被要求输入密码短语。此密码短语将用于解锁驱动器。确保使用一个良好的、随机生成的密码，并将其保存在安全的地方。如果你丢失了它，将无法解锁驱动器。你将被要求确认密码短语。
- en: 'Once the command completes, we can format our encrypted disk. At this point,
    it has no filesystem, so we’ll need to create one. First, open the disk with the
    following command:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦命令完成，我们就可以格式化我们的加密磁盘。此时，它没有文件系统，因此我们需要创建一个。首先，使用以下命令打开磁盘：
- en: '[PRE60]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'The `backup_drive` name can be anything you want; it’s just an arbitrary name
    you can refer to the disk as. At this point, the disk will be attached to `/dev/mapper/disk_name`,
    where `disk_name` is whatever you called your disk in the previous command (in
    my case, `backup_drive`). Next, we can format the disk. The following command
    will create an ext4 filesystem on the encrypted disk:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: '`backup_drive`的名称可以是你想要的任何名字；它只是你用来引用磁盘的一个任意名称。此时，磁盘将附加到`/dev/mapper/disk_name`，其中`disk_name`是你在上一个命令中为磁盘指定的名称（在我的例子中是`backup_drive`）。接下来，我们可以对磁盘进行格式化。以下命令将在加密磁盘上创建一个ext4文件系统：'
- en: '[PRE61]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: The `-L` option allows us to add a label to the drive, so feel free to change
    that label to whatever you prefer to name the drive.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: '`-L`选项允许我们为驱动器添加标签，因此你可以随意将该标签更改为你喜欢的驱动器名称。'
- en: 'With the formatting out of the way, we can now mount the disk:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 在格式化完成后，我们现在可以挂载磁盘：
- en: '[PRE62]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'The `mount` command will mount the encrypted disk located at `/dev/mapper/backup_drive`
    and attach it to a mount point, such as `/media/backup_drive` in my example. The
    target mount directory must already exist. With the disk mounted, you can now
    save data onto the device as you would any other volume. When finished, you can
    unmount the device with the following commands:'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: '`mount`命令将挂载位于`/dev/mapper/backup_drive`的加密磁盘，并将其附加到一个挂载点，例如在我的示例中是`/media/backup_drive`。目标挂载目录必须已经存在。磁盘挂载后，你可以像操作任何其他卷一样将数据保存到设备上。完成后，你可以使用以下命令卸载设备：'
- en: '[PRE63]'
  id: totrans-266
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'First, we unmount the volume just like we normally would. Then, we tell `cryptsetup`
    to close the volume. To mount it again, we would issue the following commands:'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们像平常一样卸载卷。然后，我们告诉`cryptsetup`关闭该卷。要重新挂载它，我们可以执行以下命令：
- en: '[PRE64]'
  id: totrans-268
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: The first of those commands should prompt you for your passphrase. If successful,
    you can use the second of those commands to mount the volume.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 这些命令中的第一个应该会提示你输入密码短语。如果成功，你可以使用第二个命令来挂载该卷。
- en: 'If we wish to change the passphrase, we can use the following command. The
    disk must not be mounted or open in order for this to work:'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们希望更改密码短语，可以使用以下命令。为了使此操作生效，磁盘必须未挂载或未打开：
- en: '[PRE65]'
  id: totrans-271
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: The command will ask you for the current passphrase, and then the new one twice.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 该命令会要求你输入当前的密码短语，然后要求你输入两次新的密码短语。
- en: Keep in mind that you should absolutely be careful typing in the new passphrase,
    so that you don’t lock yourself out of the drive.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，在输入新密码短语时，你必须非常小心，以免将自己锁定在驱动器之外。
- en: That’s basically all there is to it. With the `cryptsetup` utility, you can
    set up your own LUKS-encrypted volumes for storing your most sensitive information.
    If the disk ever falls into the wrong hands, it won’t be as bad a situation as
    it would have been if the disk had been unencrypted. Breaking a LUKS-encrypted
    volume would take considerable effort that wouldn’t be feasible.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 这基本上就是全部。使用`cryptsetup`工具，你可以为存储最敏感信息设置自己的LUKS加密卷。如果磁盘落入不法之手，情况将不会像磁盘未加密时那么糟糕。破解一个LUKS加密的卷需要相当大的努力，而这通常是不可行的。
- en: In the next section, we’ll explore how we can lock down `sudo`. Since `sudo`
    is an essential command that gives us the ability to run tasks as other users,
    we’ll want to be sure to lock that down too.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一部分中，我们将探讨如何锁定`sudo`。由于`sudo`是一个基本命令，使我们能够以其他用户身份执行任务，我们将确保将其锁定。
- en: Locking down sudo
  id: totrans-276
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 锁定`sudo`
- en: We’ve been using the `sudo` command throughout the book. In fact, we took a
    deeper look at it in *Chapter 2*, *Managing Users and Permissions*. Therefore,
    I won’t go into too much detail regarding `sudo` here, but some things bear repeating
    as `sudo` has a direct impact on security.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在本书中一直在使用`sudo`命令。实际上，我们在*第2章*，*用户与权限管理*中深入探讨了它。因此，我在这里不会详细讨论`sudo`，但是有些内容值得重复，因为`sudo`对安全性有直接影响。
- en: First and foremost, access to `sudo` should be locked down as much as possible.
    A user with full `sudo` access is a threat, plain and simple. All it would take
    is for someone with full `sudo` access to make a single mistake with the `rm`
    command to cause you to lose data or render your entire server useless. After
    all, a user with full `sudo` access can do anything `root` can do (which is everything).
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，应该尽可能限制对`sudo`的访问权限。拥有完全`sudo`访问权限的用户是一个威胁，明摆着。只要某个拥有完全`sudo`访问权限的人在执行`rm`命令时犯了一个小错误，就可能导致数据丢失或使整个服务器无法使用。毕竟，拥有完全`sudo`访问权限的用户可以做任何`root`能够做的事（也就是所有事情）。
- en: 'By default, the user you’ve created during installation will be made a member
    of the `sudo` group. Members of this group have full access to the `sudo` command.
    Therefore, you shouldn’t make any users a member of this group unless you absolutely
    have to. In *Chapter 2*, *Managing Users and Permissions*, I talked about how
    to control access to `sudo` with the `visudo` command; refer to that chapter for
    a refresher if you need it. In a nutshell, you can lock down access to `sudo`
    to specific commands, rather than allowing your users to do everything. For example,
    if a user needs access to shut down or reboot a server, you can give them access
    to perform those tasks (and only those tasks) with the following setting:'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，在安装过程中创建的用户将成为`sudo`组的成员。该组成员对`sudo`命令有完全访问权限。因此，除非绝对必要，否则不应将任何用户加入该组。在*第2章*，*用户与权限管理*中，我谈到了如何使用`visudo`命令控制`sudo`的访问权限；如果需要复习，可以参考该章。简而言之，你可以限制`sudo`的访问权限，只允许特定命令，而不是让用户做任何事情。例如，如果用户需要关闭或重启服务器，你可以通过以下设置只授予他们执行这些任务（而且仅限这些任务）的权限：
- en: '[PRE66]'
  id: totrans-280
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: For the most part, if a user needs access to `sudo`, just give them access to
    the specific commands that are required as part of their job. If a user needs
    access to work with removable media, give them `sudo` access for the `mount` and
    `umount` commands. If they need to be able to install new software, give them
    access to the `apt` suite of commands, and so on. The fewer permissions you give
    a user, the better. This goes all the way back to the principle of least privilege
    that we went over near the beginning of this chapter.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数情况下，如果用户需要访问`sudo`，只需授予他们完成工作所需的特定命令的权限。如果用户需要访问可移动媒体，授予他们对`mount`和`umount`命令的`sudo`访问权限。如果他们需要安装新软件，授予他们对`apt`命令集的访问权限，等等。你给用户的权限越少越好。这一切都回到了我们在本章开头提到的最小权限原则。
- en: Although most of the information in this section is not new to anyone who has
    already read *Chapter 2*, *Managing Users and Permissions*, `sudo` access is one
    of those things a lot of people don’t think about when it comes to security. The
    `sudo` command with full access is equivalent to giving someone full access to
    the entire server. Therefore, it’s an important thing to keep in mind when it
    comes to hardening the security of your network.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管本节中的大部分信息对于已经阅读过*第2章*，*用户与权限管理*的人来说并不新鲜，但`sudo`访问权限是很多人在考虑安全时往往忽略的一个方面。拥有完全访问权限的`sudo`命令相当于给某人提供了对整个服务器的完全访问权限。因此，在加强网络安全时，保持这一点非常重要。
- en: Summary
  id: totrans-283
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we looked at the ways in which we can harden the security of
    our server. A single chapter or book can never give you an all-inclusive list
    of all the security settings you could possibly configure, but the examples we
    worked through in this chapter are a great starting point. Along the way, we looked
    at the concepts of lowering your attack surface, as well as the principle of least
    privilege. We also looked into securing OpenSSH, which is a common service that
    many attackers will attempt to use in their favor.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们探讨了可以增强服务器安全性的方法。单一的章节或书籍永远无法给出所有可能配置的安全设置的完整清单，但我们在本章中的示例是一个很好的起点。过程中，我们讨论了降低攻击面和最小权限原则的概念。我们还研究了OpenSSH的安全性，这是许多攻击者试图利用的常见服务。
- en: We also looked into Fail2ban, which is a handy daemon that can block other nodes
    when there are a certain number of authentication failures. We also discussed
    configuring our firewall, using the UFW utility. Since data theft is also unfortunately
    common, we covered encrypting our backup disks.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还研究了 Fail2ban，它是一个有用的守护进程，当发生一定次数的身份验证失败时，可以阻止其他节点。我们还讨论了如何使用 UFW 工具配置防火墙。由于数据盗窃也不幸很常见，我们介绍了如何加密备份磁盘。
- en: In the next chapter, we’ll take a look at troubleshooting our server when things
    go wrong.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章，我们将探讨在服务器出现故障时的故障排除方法。
- en: Further reading
  id: totrans-287
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: 'Landscape documentation: [https://learnlinux.link/ls-docs](https://learnlinux.link/ls-docs)'
  id: totrans-288
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Landscape 文档：[https://learnlinux.link/ls-docs](https://learnlinux.link/ls-docs)
- en: 'Fail2ban manual: [https://learnlinux.link/f2b-man](https://learnlinux.link/f2b-man)'
  id: totrans-289
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Fail2ban 手册：[https://learnlinux.link/f2b-man](https://learnlinux.link/f2b-man)
- en: '`sshd_config` file guide: [https://learnlinux.link/sshd-config-doc](https://learnlinux.link/sshd-config-doc)'
  id: totrans-290
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`sshd_config` 文件指南：[https://learnlinux.link/sshd-config-doc](https://learnlinux.link/sshd-config-doc)'
- en: 'Ubuntu CVE tracker: [https://learnlinux.link/u-cve](https://learnlinux.link/u-cve)'
  id: totrans-291
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Ubuntu CVE 跟踪器：[https://learnlinux.link/u-cve](https://learnlinux.link/u-cve)
- en: 'Password haystacks (find out how secure your password is): [https://learnlinux.link/haystack](https://learnlinux.link/haystack)'
  id: totrans-292
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 密码干草堆（了解你的密码有多安全）：[https://learnlinux.link/haystack](https://learnlinux.link/haystack)
- en: 'SECURITY NOW (a very informative security podcast): [https://learnlinux.link/sn-podcast](https://learnlinux.link/sn-podcast)'
  id: totrans-293
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: SECURITY NOW（一个非常有价值的安全播客）：[https://learnlinux.link/sn-podcast](https://learnlinux.link/sn-podcast)
- en: 'ShieldsUP! (a useful tool to see which ports your router has open): [https://learnlinux.link/grc-su](https://learnlinux.link/grc-su)'
  id: totrans-294
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: ShieldsUP！（一个查看路由器哪些端口开放的有用工具）：[https://learnlinux.link/grc-su](https://learnlinux.link/grc-su)
- en: Join our community on Discord
  id: totrans-295
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 加入我们的 Discord 社区
- en: 'Join our community’s Discord space for discussions with the author and other
    readers:'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 加入我们社区的 Discord 空间，与作者和其他读者进行讨论：
- en: '[https://packt.link/LWaZ0](https://packt.link/LWaZ0)'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://packt.link/LWaZ0](https://packt.link/LWaZ0)'
- en: '![](img/QR_Code50046724-1955875156.png)'
  id: totrans-298
  prefs: []
  type: TYPE_IMG
  zh: '![](img/QR_Code50046724-1955875156.png)'
