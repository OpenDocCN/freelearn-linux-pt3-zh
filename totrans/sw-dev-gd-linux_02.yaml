- en: '2'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '2'
- en: Working with Processes
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 与进程打交道
- en: 'As a developer, you are already intuitively familiar with processes. They are
    the fruits of your labor: after writing and debugging code, your program finally
    executes, transforming into a beautiful operating system process!'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 作为开发者，你已经直观地熟悉了进程。它们是你劳动的成果：在编写和调试代码之后，你的程序最终执行，转变成一个美丽的操作系统进程！
- en: A process on Linux can be a long-running application, a quick shell command
    like `ls`, or anything that the kernel spawns to do some work on the system. If
    something is getting done in Linux, a process is doing it. Your web browser, text
    editor, vulnerability scanner, and even things like reading files and the commands
    you’ve learned so far all spawn a process.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Linux 中，进程可以是一个长时间运行的应用程序，也可以是像 `ls` 这样的快速 shell 命令，或者是内核用来在系统上执行某些工作的任何任务。如果在
    Linux 中有任务在进行，那就是进程在执行它。你的网页浏览器、文本编辑器、漏洞扫描器，甚至像读取文件和你目前学到的命令等操作，都会启动一个进程。
- en: 'Linux’s process model is important to understand because the abstraction it
    gives you – the Linux process – is what all the commands and tools you’ll use
    to manage processes depend on. Gone are the details you’re used to seeing from
    a developer’s perspective: variables, functions, and threads have all been encapsulated
    as “a process.” You’re left with a different, external set of knobs to manipulate
    and gauges to check: process ID, status, resource usage, and all the other process
    attributes we’ll be covering in this chapter.'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 理解 Linux 的进程模型非常重要，因为它所提供的抽象——Linux 进程——是你管理进程时所有命令和工具所依赖的基础。你不再看到从开发者角度出发的细节：变量、函数和线程都被封装为“一个进程”。你现在面对的是一组不同的、外部的控制按钮和监控仪表：进程
    ID、状态、资源使用情况以及我们将在本章中涵盖的所有其他进程属性。
- en: First, we’ll take a close look at the process abstraction itself, and then we’ll
    dive into useful, practical things you can do with Linux processes. While we’re
    covering the practical aspects, we’ll pause to add detail to a few aspects that
    are a common source of problems, like permissions, and give you some heuristics
    for troubleshooting processes.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将深入了解进程抽象本身，然后我们将深入探讨你可以用 Linux 进程做的一些有用的、实用的事情。在讨论实际操作时，我们会暂停并详细讲解一些常见问题的来源，例如权限问题，并为你提供一些排查进程问题的启发式方法。
- en: 'In this chapter, you’ll learn about the following topics:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你将学习以下主题：
- en: What a Linux process is, and how to see the processes currently running on your
    system
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 什么是 Linux 进程，以及如何查看当前系统上运行的进程
- en: The attributes a process has, so you know what information you can gather while
    troubleshooting
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 进程具有的属性，了解在排查问题时可以收集哪些信息
- en: Common commands for viewing and finding processes
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 查看和查找进程的常用命令
- en: 'More advanced topics that can come in handy for a developer actually writing
    programs that execute as Linux processes: Signals and inter-process communication,
    the `/proc` virtual filesystem, seeing open file handles with the `lsof` command,
    and how processes are created in Linux'
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 更高级的话题，实际上对于编写作为 Linux 进程执行的程序的开发者非常有用：信号与进程间通信、`/proc` 虚拟文件系统、使用 `lsof` 命令查看打开的文件句柄，以及在
    Linux 中进程是如何创建的。
- en: You’ll also get a practical review of everything you’ve learned in an example
    troubleshooting session that uses the theory and commands we cover in this chapter.
    Now, let’s dive into what exactly a Linux process is.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 你还将通过一个实际的故障排查示例回顾你在本章中学到的所有内容，使用我们讨论的理论和命令。现在，让我们深入了解 Linux 进程究竟是什么。
- en: Process basics
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进程基础知识
- en: 'When we refer to a “process” in Linux, we’re referring to the operating system’s
    internal model of what exactly a running program *is*. Linux needs a general abstraction
    that works for *all* programs, which can encapsulate the things the operating
    system cares about. A process is that abstraction, and it enables the OS to track
    some of the important context around programs that are executing; namely:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们提到 Linux 中的“进程”时，我们指的是操作系统内部对正在运行的程序是什么的抽象模型。Linux 需要一个适用于 *所有* 程序的通用抽象，它可以封装操作系统关心的内容。进程就是这种抽象，它使操作系统能够跟踪正在执行的程序的一些重要上下文信息；即：
- en: Memory usage
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 内存使用
- en: Processor time used
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用的处理器时间
- en: Other system resource usage (disk access, network usage)
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 其他系统资源使用情况（磁盘访问、网络使用）
- en: Communication between processes
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 进程间通信
- en: Related processes that a program starts, for example, firing off a shell command
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 程序启动的相关进程，例如触发一个 shell 命令
- en: 'You can get a listing of all system processes (at least the ones your user
    is allowed to see) by running the `ps` program with the `aux` flags:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过运行带有`aux`标志的`ps`程序，获取所有系统进程的列表（至少是用户允许查看的那些进程）：
- en: '![](img/B19251_02_01.png)'
  id: totrans-20
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B19251_02_01.png)'
- en: 'Figure 2.1: List of system processes'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.1：系统进程列表
- en: We’ll cover the attributes most relevant to your work as a developer in this
    chapter.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将重点介绍与开发人员工作最相关的进程属性。
- en: What is a Linux process made of?
  id: totrans-23
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Linux 进程由什么组成？
- en: 'From the perspective of the operating system, a “process” is simply a data
    structure that makes it easy to access information like:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 从操作系统的角度来看，“进程”只是一个数据结构，使得访问类似以下信息变得简单：
- en: '**Process ID** (**PID** in the `ps` output above). PID 1 is the init system
    – the original parent of all other processes, which bootstraps the system. The
    kernel starts this as one of the first things it does after starting to execute.
    When a process is created, it gets the next available process ID, in sequential
    order. Because it is so important to the normal functioning of the operating system,
    init cannot be killed, even by the root user. Different Unix operating systems
    use different init systems – for example, most Linux distributions use `systemd`,
    while macOS uses `launchd`, and many other Unixes use SysV. Regardless of the
    specific implementation, we’ll refer to this process by the name of the role it
    fills: “init.”'
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**进程 ID**（**PID**，如上`ps`输出所示）。PID 1 是 init 系统——所有其他进程的原始父进程，负责引导系统。内核启动时，会首先执行此操作。当进程创建时，它会获得下一个可用的进程
    ID，按顺序排列。由于其对操作系统正常功能至关重要，init 进程无法被终止，即使是 root 用户也无法终止。不同的 Unix 操作系统使用不同的 init
    系统——例如，大多数 Linux 发行版使用`systemd`，而 macOS 使用`launchd`，许多其他 Unix 系统使用 SysV。无论具体实现如何，我们将根据其所扮演的角色称呼此进程：“init”。'
- en: '**Note**'
  id: totrans-26
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '**注意**'
- en: In containers, processes are namespaced – in the “real” environment, all container
    processes might be PID 3210, while that single PID maps to lots of processes (`1..n`,
    where `n` is the number of running processes in the container). You can see this
    from outside but not inside the container.
  id: totrans-27
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在容器中，进程是命名空间化的——在“真实”环境中，所有容器进程的 PID 可能是 3210，而该单一 PID 映射到多个进程（`1..n`，其中`n`是容器中运行的进程数量）。你可以从外部看到这一点，但不能在容器内部看到。
- en: '**Parent Process PID** (**PPID**). Each process is spawned by a parent. If
    the parent process dies while the child is alive, the child becomes an “orphan.”
    Orphaned processes are re-parented to init (PID 1).'
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**父进程 PID**（**PPID**）。每个进程都是由一个父进程生成的。如果父进程在子进程存活时终止，子进程会变成“孤儿”进程。孤儿进程会被重新归属于
    init（PID 1）。'
- en: '**Status** (**STAT** in the `ps` output above). `man ps` will show you an overview:'
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**状态**（**STAT**，如上`ps`输出所示）。`man ps`会显示一个概述：'
- en: D – uninterruptible sleep (usually IO)
  id: totrans-30
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: D – 不可中断的睡眠状态（通常是 IO）
- en: I – idle kernel thread
  id: totrans-31
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: I – 空闲内核线程
- en: R – running or runnable (on run queue)
  id: totrans-32
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: R – 正在运行或可运行（在运行队列中）
- en: S – interruptible sleep (waiting for an event to complete)
  id: totrans-33
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: S – 可中断的睡眠状态（等待某个事件完成）
- en: T – stopped by job control signal
  id: totrans-34
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: T – 被作业控制信号停止
- en: t – stopped by debugger during tracing
  id: totrans-35
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: t – 被调试器在跟踪过程中停止
- en: X – dead (should never be seen)
  id: totrans-36
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: X – 死亡状态（不应该出现）
- en: Z – defunct (“zombie”) process, terminated but not reaped by its parent
  id: totrans-37
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: Z – 僵尸进程（已终止，但其父进程未收养）
- en: '**Priority** status (“niceness” – does this process allow other processes to
    take priority over it?).'
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**优先级**状态（“友好度”——该进程是否允许其他进程优先于它？）'
- en: A process **Owner** (USER in the `ps` output above); the effective user ID.
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 进程**所有者**（`ps`输出中的USER字段）；有效用户 ID。
- en: Effective **Group ID** (EGID), which is used.
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有效**组 ID**（EGID），表示当前使用的组 ID。
- en: An **address map** of the process’s memory space.
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 进程内存空间的**地址映射**。
- en: Resource usage – open files, network ports, and other resources the process
    is using (**VSZ** and **RSS** for memory usage in the `ps` output above).
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 资源使用情况——进程正在使用的打开文件、网络端口以及其他资源（在`ps`输出中，**VSZ**和**RSS**表示内存使用情况）。
- en: '(Citation: from the *Unix and Linux System Administration Handbook*, *5th edition*,
    p.91.)'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: (引用：来自*Unix 和 Linux 系统管理手册*，*第五版*，第91页。)
- en: Let’s take a closer look at a few of the process attributes that are most important
    for developers and occasional troubleshooters to understand.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们仔细看看几个对开发人员和偶尔的故障排除人员来说最重要的进程属性。
- en: Process ID (PID)
  id: totrans-45
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 进程 ID（PID）
- en: Each process is uniquely identifiable by its process ID, which is just a unique
    integer that is assigned to a process when it starts. Much like a relational database
    with IDs that uniquely identify each row of data, the Linux operating system keeps
    track of each process by its PID.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 每个进程都有一个唯一的进程 ID（PID），这是在进程启动时分配给它的唯一整数。就像关系型数据库中的 ID 唯一标识每一行数据一样，Linux 操作系统通过
    PID 来跟踪每个进程。
- en: A PID is by far the most useful label for you to use when interacting with processes.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: PID 是你与进程交互时最有用的标签。
- en: Effective User ID (EUID) and Effective Group ID (EGID)
  id: totrans-48
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 有效用户 ID（EUID）和有效组 ID（EGID）
- en: These determine which system user and group your process is running as. Together,
    user and group permissions determine what a process is allowed to do on the system.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 这些决定了你的进程是以哪个系统用户和组身份运行的。用户和组权限共同决定了一个进程在系统上可以执行什么操作。
- en: As you’ll see in *Chapter 5*, *Introducing Files*, files have user and group
    ownership set on them, which determines who their permissions apply to. If a file’s
    ownership and permissions are essentially a lock, then a process with the right
    user/group permissions is like a key that opens the lock and allows access to
    the file. We’ll dive deeper into this later, when we talk about permissions.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你在 *第五章*《文件介绍》中将看到的那样，文件有用户和组所有权，这决定了哪些权限适用于它们。如果文件的所有权和权限本质上是一个锁，那么具有正确用户/组权限的进程就像一把钥匙，打开锁并允许访问该文件。我们将在后面深入探讨权限部分时详细讨论这一点。
- en: Environment variables
  id: totrans-51
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 环境变量
- en: You’ve probably used environment variables in your applications – they’re a
    way for the operating system environment that launches your process to pass in
    data that the process needs. This commonly includes things like configuration
    directives (`LOG_DEBUG=1`) and secret keys (`AWS_SECRET_KEY`), and every programming
    language has some way to read them out from the context of the program.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能在应用程序中使用过环境变量 —— 它们是操作系统环境传递给进程的需要的数据。这通常包括配置指令（`LOG_DEBUG=1`）和密钥（`AWS_SECRET_KEY`），每种编程语言都有某种方式从程序的上下文中读取这些变量。
- en: 'For example, this Python script gets the user’s home directory from the `HOME`
    environment variable, and then prints it:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，这个 Python 脚本从 `HOME` 环境变量获取用户的主目录，然后打印出来：
- en: '[PRE0]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'In my case, running this program in the `python3` REPL on a Linux machine results
    in the following output:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 在我的案例中，在 Linux 机器的 `python3` REPL 中运行这个程序，得到如下输出：
- en: '[PRE1]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Working directory
  id: totrans-57
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作目录
- en: A process has a “current working directory,” just like your shell (which is
    just a process, anyway). Typing `pwd` in your shell prints its current working
    directory, and every process has a working directory. The working directory for
    a process can change, so don’t rely on it too much.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 进程有一个“当前工作目录”，就像你的 shell（反正也是一个进程）一样。在 shell 中输入 `pwd` 会打印当前工作目录，每个进程也都有一个工作目录。进程的工作目录是可以变化的，所以不要过于依赖它。
- en: This concludes our overview of the process attributes that you should know about.
    In the next section, we’ll step away from theory and look at some commands you
    can use to start working with processes right away.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 这部分内容概述了你应该了解的进程属性。接下来，我们将跳出理论部分，看看一些你可以立即使用的命令，帮助你开始处理进程。
- en: Practical commands for working with Linux processes
  id: totrans-60
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 用于操作 Linux 进程的实用命令
- en: 'Here are some of the commands you’ll use most often:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是一些你最常使用的命令：
- en: '`ps` – Shows processes on the system; you saw an example of this command earlier
    in the chapter. Flags modify which process attributes are displayed as columns.
    This command is usually used with filters to control how much output you get,
    for example, (`ps aux | head –n 10`) to cut your output down to just the top 10
    lines. A few more useful tricks:'
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ps` – 显示系统上的进程；你在本章前面已经看到过这个命令的示例。标志可以修改显示的进程属性列。这个命令通常与过滤器一起使用，以控制输出的内容，比如
    (`ps aux | head –n 10`) 只输出前 10 行。还有一些有用的小技巧：'
- en: '`ps –eLf` shows thread information for processes'
  id: totrans-63
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ps –eLf` 显示进程的线程信息'
- en: '`ps -ejH` is useful for seeing the relationships between parent and child processes
    visually (children are indented under their parents)![](img/B19251_02_02.png)'
  id: totrans-64
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ps -ejH` 对于直观地查看父子进程之间的关系非常有用（子进程会在父进程下缩进）![](img/B19251_02_02.png)'
- en: 'Figure 2.2: Examples of outputs of the ps command with flags'
  id: totrans-65
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图 2.2：带有标志的 ps 命令输出示例
- en: '`pgrep` – Find process IDs by name. Can use regular expressions.'
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`pgrep` – 根据名称查找进程 ID。可以使用正则表达式。'
- en: '![](img/B19251_02_03.png)'
  id: totrans-67
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B19251_02_03.png)'
- en: 'Figure 2.3: Examples of outputs of the pgrep command with flags'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.3：带标志的 `pgrep` 命令输出示例
- en: '`top` – An interactive program that polls all processes (once a second, by
    default) and outputs a sorted list of resource usage (you can configure what it
    sorts by). Also displays total system resource usage. Press *Q* or use *Ctrl*
    + *C* to quit. You’ll see an example of this command’s output later in this chapter.'
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`top` – 一个交互式程序，用来轮询所有进程（默认每秒一次）并输出资源使用的排序列表（你可以配置按什么排序）。还显示系统的总资源使用情况。按 *Q*
    或使用 *Ctrl* + *C* 退出。你将在本章稍后的部分看到这个命令的输出示例。'
- en: '`iotop` – Like `top`, but for disk IO. Extremely useful for finding IO-hungry
    processes. Not installed on all systems by default, but available via most package
    managers.'
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`iotop` – 类似于 `top`，但用于磁盘 IO。对于寻找 IO 消耗大的进程非常有用。并非所有系统默认安装，但可以通过大多数包管理器获取。'
- en: '![](img/B19251_02_04.png)'
  id: totrans-71
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B19251_02_04.png)'
- en: 'Figure 2.4: Example of output of the iotop command'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.4：`iotop` 命令输出示例
- en: '`nethogs` – Like `top`, but for network IO. Groups network usage by process,
    which is incredibly convenient. Available via most package managers.'
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`nethogs` – 类似于 `top`，但用于网络 IO。按进程分组网络使用情况，非常方便。可以通过大多数包管理器获取。'
- en: '![](img/B19251_02_05.png)Figure 2.5: Example of output of the nethogs command'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: '![](img/B19251_02_05.png)图 2.5：`nethogs` 命令输出示例'
- en: '`kill` – Allows users to send signals to processes, usually to stop them or
    make them re-read their configuration files. We’ll explain signals and `kill`
    command usage later in this chapter.'
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`kill` – 允许用户向进程发送信号，通常是停止进程或让它重新读取其配置文件。我们将在本章稍后解释信号和 `kill` 命令的使用方法。'
- en: Advanced process concepts and tools
  id: totrans-76
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 高级进程概念与工具
- en: This marks the beginning of the “advanced” section of this chapter. While you
    don’t need to master all the concepts in this section to work effectively with
    Linux processes, they can be extremely helpful. If you have a few extra minutes,
    we recommend at least familiarizing yourself with each one.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 这标志着本章“高级”部分的开始。虽然你不需要掌握本部分的所有概念就能有效地与 Linux 进程工作，但它们非常有用。如果你有一些额外的时间，我们建议至少熟悉一下每个概念。
- en: Signals
  id: totrans-78
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 信号
- en: How does `systemctl` tell your web server to re-read its configuration files?
    How can you politely ask a process to shut down cleanly? And how can you kill
    a malfunctioning process immediately, because it’s bringing your production application
    to its knees?
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: '`systemctl` 是如何告诉你的 Web 服务器重新读取配置文件的？你如何礼貌地要求一个进程优雅地关闭？如果一个进程故障，如何立刻杀死它，因为它已经让你的生产应用瘫痪了？'
- en: In Unix and Linux, all of this is done with signals. Signals are numerical messages
    that can be sent between programs. They’re a way for processes to communicate
    with each other and with the operating system, allowing processes to send and
    receive specific messages.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Unix 和 Linux 中，所有这些操作都是通过信号来完成的。信号是可以在程序之间发送的数字消息。它们是进程之间和操作系统之间进行通信的一种方式，允许进程发送和接收特定的消息。
- en: These messages can be used to communicate a variety of things to a process,
    for example, indicating that a particular event has happened or that a specific
    action or response is required.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 这些消息可以用来向进程传递各种信息，例如，指示某个特定事件已经发生，或某个特定的操作或响应是必需的。
- en: Practical uses of signals
  id: totrans-82
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 信号的实际应用
- en: Let’s look at a few examples of the practical value that the signal mechanism
    enables. Signals can be used to implement inter-process communication; for example,
    one process can send a signal to another process indicating that it’s finished
    with a particular task and that the other process can now start working. This
    allows processes to coordinate their actions and work together in a smooth and
    efficient manner, much like execution threads in programming languages (but without
    the associated memory sharing).
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看几个信号机制所带来的实际价值的例子。信号可以用于实现进程间通信；例如，一个进程可以向另一个进程发送信号，指示它已完成某项任务，另一个进程可以开始工作了。这使得进程能够协调它们的行动，像编程语言中的执行线程一样顺畅高效地合作（但没有与之相关的内存共享）。
- en: Another common application of process signals is to handle program errors. For
    example, a process can be designed to catch the `SIGSEGV` signal, which indicates
    a segmentation fault. When a process receives this signal, it can trap that signal
    and then take action to log the error, dump core for debugging purposes, or clean
    up any resources that were being used before shutting down gracefully.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 进程信号的另一个常见应用是处理程序错误。例如，设计一个进程来捕获 `SIGSEGV` 信号，这表明出现了段错误。当进程接收到此信号时，它可以捕获该信号并采取措施记录错误、生成核心转储以进行调试，或者在优雅地关闭之前清理正在使用的资源。
- en: Process signals can also be used to implement graceful shutdowns. For example,
    when a system is shutting down, a signal can be sent to all processes to give
    them a chance to save their state and clean up any resources they were using,
    via “trapping” signals.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 进程信号也可以用于实现优雅的关闭。例如，当系统关闭时，可以向所有进程发送信号，给它们一个机会保存状态并清理它们正在使用的资源，方法是通过“捕获”信号。
- en: Trapping
  id: totrans-86
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 捕获
- en: 'Many of the signals can be “trapped” by the processes that receive them: this
    is essentially the same idea as catching and handling an error in a programming
    language.'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 许多信号可以被接收它们的进程“捕获”：这本质上与编程语言中捕获并处理错误的想法相同。
- en: If the receiving process has a handler function for the signal that’s being
    sent, then that handler function is run. That’s how programs re-read their configuration
    without restarting, and finish their database writes and close their file handles
    after receiving the shutdown signal.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 如果接收信号的进程有一个信号处理函数，那么该处理函数会被执行。这就是程序在不重新启动的情况下重新读取配置，并在接收到关闭信号后完成数据库写入和关闭文件句柄的方式。
- en: The kill command
  id: totrans-89
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: kill 命令
- en: 'However, it’s not just processes that communicate via signals: the frighteningly
    named (and, technically speaking, incorrectly named) `kill` is a program that
    allows users to send signals to processes, too.'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，不仅仅是进程通过信号进行通信：那令人毛骨悚然（并且在技术上讲，名称不准确）的 `kill` 是一个允许用户向进程发送信号的程序。
- en: One of the most common uses of user-sent processes via the `kill` command is
    to interrupt a process that is no longer responding. For example, if a process
    is stuck in an infinite loop, a “kill” signal can be sent to force it to stop.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: '`kill` 命令通过用户发送进程中最常见的用途之一是中断一个不再响应的进程。例如，如果一个进程卡在了一个无限循环中，可以发送一个“kill”信号迫使它停止。'
- en: 'The `kill` command allows you to send a signal to a process by specifying its
    PID. If the process you’d like to terminate has PID `2600`, you’d run:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: '`kill` 命令允许你通过指定进程的 PID 向进程发送信号。如果你想终止的进程的 PID 是 `2600`，你可以运行：'
- en: '[PRE2]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: This command would send signal 15 (`SIGTERM`, or “terminate”) to the process,
    which would then have a chance to trap the signal and shut down cleanly.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 该命令会向进程发送信号 15（`SIGTERM`，或“终止”），进程有机会捕获该信号并进行正常关闭。
- en: '**Note**'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: As you can see from the included table of standard signal numbers, the default
    signal that `kill` sends is “terminate” (signal 15), not “kill” (`SIGKILL` is
    9). The `kill` program is not just for killing processes but also for sending
    any kind of signal. It’s really confusingly named and I’m sorry about that – it’s
    just one of those idiosyncrasies of Unix and Linux that you’ll get used to.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 从包含的标准信号编号表中可以看到，`kill` 发送的默认信号是“终止”（信号 15），而不是“杀死”（`SIGKILL` 是 9）。`kill` 程序不仅仅用于杀死进程，还用于发送任何类型的信号。这个名字起得真让人困惑，很抱歉——这只是
    Unix 和 Linux 中一些特殊之处，你会逐渐习惯的。
- en: 'If you don’t want to send the default signal 15, you can specify the signal
    you’d like to send with a dash; to send a `SIGHUP` to the same process, you’d
    run:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你不想发送默认的信号 15，可以用一个短横线指定你想要发送的信号；例如，要向同一进程发送 `SIGHUP` 信号，可以运行：
- en: '[PRE3]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Running `man` `signal` will give you a list of signals that you can send:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 运行 `man` `signal` 会列出可以发送的信号：
- en: '![](img/B19251_02_06.png)'
  id: totrans-100
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B19251_02_06.png)'
- en: 'Figure 2.6: Example of output of the man signal command'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.6：man signal 命令输出示例
- en: 'It pays – sometimes quite literally, in engineering interviews – to be familiar
    with a few of these:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 熟悉其中一些信号是有好处的——有时甚至在工程面试中也能派上用场：
- en: '`SIGHUP` (1) – “hangup”: interpreted by many applications – for example, nginx
    – as “re-read your configuration because I’ve made changes to it.”'
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SIGHUP` (1) – “挂断”：许多应用程序解释为“重新读取你的配置，因为我已经做了更改”（例如 nginx）。'
- en: '`SIGINT` (2) – “interrupt”: often interpreted the same as `SIGTERM` - “please
    shut down cleanly.”'
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SIGINT` (2) – “中断”：通常与 `SIGTERM` 相同——“请干净地关闭”。'
- en: '`SIGTERM` (15) – “terminate”: nicely asks a process to shut down.'
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SIGTERM`（15）– “终止”：温和地请求进程关闭。'
- en: '`SIGUSR1` (30) and `SIGUSR2` (31) are sometimes used for application-defined
    messaging For example, SIGUSR1 asks nginx to re-open the log files it’s writing
    to, which is useful if you’ve just rotated them.'
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SIGUSR1`（30）和`SIGUSR2`（31）有时用于应用程序定义的消息传递。例如，SIGUSR1 会要求 nginx 重新打开它正在写入的日志文件，如果你刚刚旋转了这些文件，这会非常有用。'
- en: '`SIGKILL` (9) – `SIGKILL` cannot be trapped and handled by processes. If this
    signal is sent to a program, the operating system will kill that program immediately.
    Any cleanup code, like flushing writes or safe shutdown, is not performed, so
    this is generally a last resort, since it could lead to data corruption.'
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SIGKILL`（9）– `SIGKILL` 无法被进程捕获并处理。如果将此信号发送给程序，操作系统会立即杀死该程序。任何清理代码，比如写入刷新或安全关闭，都不会执行，因此这通常是最后的手段，因为它可能导致数据损坏。'
- en: If you want to explore Linux a bit deeper, feel free to poke around the `/proc`
    directory. That’s definitely beyond the basics, but it’s a directory that contains
    a filesystem subtree for every process, where live information about the processes
    is looked up as you read those files.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想更深入地探索 Linux，可以随意浏览 `/proc` 目录。这确实超出了基础知识，但它是一个包含每个进程文件系统子树的目录，在你读取这些文件时，进程的实时信息会被查询出来。
- en: '[PRE4]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: In practice, this knowledge can come in handy during troubleshooting when you’ve
    identified a misbehaving (or mysterious) process and want to know exactly what
    it’s doing in real time.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，这些知识在故障排除时会派上用场，特别是当你已经识别出一个行为异常（或神秘）的进程，并且想知道它在实时执行什么操作时。
- en: You can learn a lot about a process by poking around in its `/proc` subdirectory
    and casually googling.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过浏览其`/proc`子目录并随便谷歌搜索，来了解很多关于进程的信息。
- en: Many of the tools we show you in this chapter actually use `/proc` to gather
    process information, and only show you a subset of what’s there. If you want to
    see *everything* and do the filtering yourself, `/proc` is the place to look.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中展示的许多工具实际上使用`/proc`来收集进程信息，并且只显示其中的一部分内容。如果你想查看*所有*信息并自己进行筛选，`/proc` 就是你需要查看的地方。
- en: lsof – show file handles that a process has open
  id: totrans-113
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: lsof – 显示进程打开的文件句柄
- en: The `lsof` command shows all files that a process has opened for reading and
    writing. This is useful because it only takes one small bug for a program to leak
    file handles (internal references to files that it has requested access to). This
    can lead to resource usage issues, file corruption, and a long list of strange
    behavior.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: '`lsof` 命令显示一个进程为读取和写入而打开的所有文件。这非常有用，因为程序只需要一个小的漏洞，就可能泄露文件句柄（它已请求访问的文件的内部引用）。这可能导致资源使用问题、文件损坏以及一长串奇怪的行为。'
- en: 'Thankfully, getting a list of files that a process has open is easy. Just run
    `lsof` and pass the `–p` flag with a PID (you’ll usually have to run this as root).
    This will return the list of files that the process (in this case, with PID 1589)
    has open:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，获取一个进程已打开文件的列表非常简单。只需运行 `lsof` 并传递 `–p` 标志和一个 PID（通常你需要以 root 身份运行）。这将返回该进程（在本例中是
    PID 1589）打开的文件列表：
- en: '[PRE5]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '![](img/B19251_02_07.png)'
  id: totrans-117
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B19251_02_07.png)'
- en: 'Figure 2.7: Example of list of files opened by the 1589 process using the lsof
    -p 1589 command'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.7：使用 `lsof -p 1589` 命令列出的 1589 进程打开的文件示例
- en: 'The above is the output for an nginx web server process. The first line shows
    you the current working directory for the process: in this case, the root directory
    (`/`). You can also see that it has file handles open on its own binary (`/usr/sbin/nginx`)
    and various libraries in `/usr/lib/`.'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 上述是 nginx Web 服务器进程的输出。第一行显示了该进程的当前工作目录：在这个例子中是根目录（`/`）。你还可以看到它已打开自己的二进制文件（`/usr/sbin/nginx`）和
    `/usr/lib/` 中的各种库文件。
- en: 'Further down, you might notice a few more interesting filepaths:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面，你可能会注意到一些更有趣的文件路径：
- en: '![](img/B19251_02_08.png)'
  id: totrans-121
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B19251_02_08.png)'
- en: 'Figure 2.8: Further opened files of the 1589 process'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.8：1589 进程进一步打开的文件
- en: This listing includes the log files nginx is writing to, and socket files (Unix,
    IPv4, and IPv6) that it’s reading and writing to. In Unix and Linux, network sockets
    are just a special kind of file, which makes it easy to use the same core toolset
    across a wide variety of use cases – tools that work with files are extremely
    powerful in an environment where almost everything is represented as a file.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 该列表包括 nginx 正在写入的日志文件和它正在读取和写入的套接字文件（Unix、IPv4 和 IPv6）。在 Unix 和 Linux 中，网络套接字只是一种特殊类型的文件，这使得在各种用例中使用相同的核心工具集变得容易
    – 与文件相关的工具在几乎所有事物都被表示为文件的环境中非常强大。
- en: Inheritance
  id: totrans-124
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 继承
- en: Except for the very first process, `init` (`PID 1`), all processes are created
    by a parent process, which essentially makes a copy of itself and then “forks”
    (splits) that copy off. When a process is forked, it typically inherits its parent’s
    permissions, environment variables, and other attributes.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 除了第一个进程`init`（`PID 1`），所有进程都是由父进程创建的，父进程基本上会复制自己，然后“fork”（分叉）该副本。当一个进程被fork时，它通常会继承其父进程的权限、环境变量和其他属性。
- en: 'Although this default behavior can be prevented and changed, it’s a bit of
    a security risk: software that you run manually receives the permissions of your
    current user (or even root privileges, if you use `sudo`). All child processes
    that might be created by that process – for example, during installation, compilation,
    and so on – inherit those permissions.'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然可以防止并改变这种默认行为，但这有一定的安全风险：你手动运行的软件将获得当前用户的权限（如果你使用`sudo`，则可能是root权限）。由该进程可能创建的所有子进程——例如在安装、编译等过程中——都会继承这些权限。
- en: Imagine a web server process that was started with root privileges (so it could
    bind to a network port) and environment variables containing cloud authentication
    keys (so it could grab data from the cloud). When this main process forks off
    a child process that needs neither root privileges nor sensitive environment variables,
    it’s an unnecessary security risk to pass those along to the child. As a result,
    dropping privileges and clearing environment variables is a common pattern in
    services spawning child processes.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一个用 root 权限启动的 Web 服务器进程（这样它就可以绑定到网络端口），并且它的环境变量中包含云认证密钥（这样它就能从云端抓取数据）。当这个主进程派生出一个不需要
    root 权限和敏感环境变量的子进程时，将这些信息传递给子进程是一个不必要的安全风险。因此，降级权限和清除环境变量是服务启动子进程时常见的模式。
- en: From a security perspective, it is important to keep this in mind to prevent
    situations where information such as passwords or access to sensitive files could
    be leaked. While it is outside the scope of this book to go into details of how
    to avoid this, it’s important to be aware of this if you’re writing software that’s
    going to run on Linux systems.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 从安全角度来看，牢记这一点非常重要，以防止如密码或访问敏感文件等信息泄露的情况发生。虽然本书不会详细讲解如何避免这种情况，但如果你在编写将在 Linux
    系统上运行的软件时，意识到这一点是很重要的。
- en: Review – example troubleshooting session
  id: totrans-129
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 回顾——故障排除示例会话
- en: Let’s look at an example troubleshooting session. All we know is that one specific
    Linux server is running extremely slowly.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一个故障排除的示例会话。我们所知道的只是某个特定的 Linux 服务器运行非常缓慢。
- en: To begin with, we want to see what’s happening on the system. You just learned
    that you can see a live view of processes running on a system by running the interactive
    `top` command. Let’s try that now.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要查看系统上发生了什么。你刚刚学会了通过运行交互式的`top`命令，可以查看系统上正在运行的进程的实时视图。现在我们来试试这个。
- en: '![](img/B19251_02_09.png)'
  id: totrans-132
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B19251_02_09.png)'
- en: 'Figure 2.9: Example of output of the top command'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.9：top 命令输出示例
- en: By default, the `top` command sorts processes by CPU usage, so we can simply
    look at the first listed process to find the offending one. Indeed, the top process
    is using 94% of one CPU’s available processing time.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，`top`命令按 CPU 使用率对进程进行排序，因此我们可以简单地查看列出的第一个进程，找到问题进程。的确，排名最前的进程使用了一个 CPU
    可用处理时间的 94%。
- en: 'As a result of running `top`, we’ve gotten a few useful pieces of information:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 通过运行`top`命令，我们获得了几个有用的信息：
- en: The problem is CPU usage, as opposed to some other kind of resource contention.
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 问题是 CPU 使用率，而不是其他资源争用。
- en: The offending process is PID 1763, and the command being run (listed in the
    **COMMAND** column) is `bzip2`, which is a compression program.
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 产生问题的进程是PID 1763，正在运行的命令（在**COMMAND**列中列出）是`bzip2`，这是一款压缩程序。
- en: 'We determine that this `bzip2` process doesn’t need to be running here, and
    we decide to stop it. Using the `kill` command, we ask the process to terminate:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 我们确定这个`bzip2`进程在这里不需要运行，于是决定停止它。通过`kill`命令，我们请求终止该进程：
- en: '[PRE6]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'After waiting a few seconds, we check to see if this (or any other) `bzip2`
    process is running:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 等待几秒钟后，我们检查是否有这个（或其他）`bzip2`进程正在运行：
- en: '[PRE7]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Unfortunately, we see that the same PID is still running. It’s time to get
    serious:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，我们看到相同的 PID 仍在运行。是时候认真处理了：
- en: '[PRE8]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'This orders the operating system to kill the process without allowing the process
    to trap (and potentially ignore) the signal. A `SIGKILL` (signal #9) simply kills
    the process where it stands.'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 这会指示操作系统终止该进程，并且不会允许进程拦截（并可能忽略）信号。`SIGKILL`（信号#9）直接终止进程。
- en: Now that you’ve killed the offending process, the server is running smoothly
    again and you can start tracking down the developer who thought it was a good
    idea to compress large source directories on this machine.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经杀死了那个有问题的进程，服务器再次平稳运行，你可以开始追查那个认为在这台机器上压缩大型源目录是个好主意的开发者。
- en: 'In this example, we followed the most common systems troubleshooting pattern
    in existence:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们遵循了最常见的系统故障排除模式：
- en: We looked at resource usage (via `top` in this example). This can be any of
    the other tools we discussed, depending on which resource is the one being exhausted.
  id: totrans-147
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们查看了资源使用情况（通过`top`命令查看）。这可以是我们讨论的任何其他工具，具体取决于哪个资源被耗尽。
- en: We found a PID to investigate.
  id: totrans-148
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们找到了一个PID来进行调查。
- en: We acted on that process. In this example, no further investigation was necessary
    and we sent a signal, asking it to shut down (15, `SIGTERM`).
  id: totrans-149
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们按照这个流程操作。在这个例子中，无需进一步调查，我们发送了一个信号，要求它关闭（15, `SIGTERM`）。
- en: Conclusion
  id: totrans-150
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 结论
- en: In this chapter, we took a close look at the process abstraction that Linux
    wraps around executing programs. You’ve seen the common components that all processes
    have and learned the basic commands you need to find and inspect running processes.
    With these tools, you’ll be able to identify when a process is misbehaving, and
    more importantly, *which* process is misbehaving.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们深入了解了Linux对执行程序的进程抽象。你已经看到所有进程都有的共同组件，并学习了查找和检查正在运行的进程所需的基本命令。借助这些工具，你将能够识别进程何时出现问题，更重要的是，*哪个*进程出现了问题。
- en: Learn more on Discord
  id: totrans-152
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在Discord上了解更多
- en: 'To join the Discord community for this book – where you can share feedback,
    ask questions to the author, and learn about new releases – follow the QR code
    below:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 若要加入本书的Discord社区——在这里你可以分享反馈，向作者提问，了解新版本的发布——请扫描下面的二维码：
- en: '[https://packt.link/SecNet](https://packt.link/SecNet)'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://packt.link/SecNet](https://packt.link/SecNet)'
- en: '![](img/QR_Code1768422420210094187.png)'
  id: totrans-155
  prefs: []
  type: TYPE_IMG
  zh: '![](img/QR_Code1768422420210094187.png)'
