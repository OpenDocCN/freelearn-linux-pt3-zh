- en: '2'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '2'
- en: Managing Users and Permissions
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 管理用户和权限
- en: In the previous chapter, we set up our very own Ubuntu Server installation,
    and we can now learn how to maintain it, starting with a look at managing who
    is able to use our server.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们设置了自己的Ubuntu服务器安装，现在我们可以开始学习如何维护它，从管理谁能够使用我们的服务器开始。
- en: As administrators of Ubuntu servers, users can be your greatest asset and also
    your biggest headache. During your career, you’ll add countless new users, manage
    their passwords, remove their accounts when they leave the company, and grant
    or remove access to resources across the network. Even on servers on which you’re
    the only user, you’ll still find yourself managing user accounts, since even system
    processes run as users. To be successful at managing Linux servers, you’ll also
    need to know how to manage permissions, create password policies, and limit who
    can execute administrative commands on the machine. In this chapter, we’ll work
    through these concepts so that you have a clear idea of how to manage users and
    their resources.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 作为Ubuntu服务器的管理员，用户既可以是你最大的资产，也可能是你最大的头痛。在你的职业生涯中，你将添加无数的新用户，管理他们的密码，在他们离开公司时删除他们的帐户，并授予或撤销他们对网络资源的访问权限。即使在你是唯一用户的服务器上，你也会发现自己在管理用户帐户，因为即使是系统进程也是以用户身份运行的。要成功地管理Linux服务器，你还需要知道如何管理权限、创建密码策略并限制谁可以在机器上执行管理命令。在本章中，我们将深入探讨这些概念，以便你清楚地了解如何管理用户及其资源。
- en: 'In particular, we will cover:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 具体来说，我们将涵盖：
- en: Understanding the purpose of users and groups
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解用户和组的目的
- en: Understanding when to use `root`
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解何时使用`root`
- en: Creating and removing users
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建和删除用户
- en: Understanding the `/etc/passwd` and `/etc/shadow` files
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解`/etc/passwd`和`/etc/shadow`文件
- en: Distributing default configuration files with `/etc/skel`
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`/etc/skel`分发默认配置文件
- en: Switching between users
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在用户之间切换
- en: Managing groups
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 管理组
- en: Managing passwords and password policies
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 管理密码和密码策略
- en: Configuring administrator access with `sudo`
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`sudo`配置管理员访问权限
- en: Setting permissions on files and directories
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设置文件和目录的权限
- en: In the first section, we will have a quick discussion about the nature of managing
    users.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一部分，我们将简要讨论管理用户的性质。
- en: Understanding the purpose of users and groups
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解用户和组的目的
- en: When it comes to a server, users are very important—without users to serve,
    then there’s no real need for a server in the first place. The subject of user
    management itself within the world of IT is in and of itself quite vast. Entire
    books have been written on individual methods of authentication, and entire technologies
    (such as **Lightweight Directory Access Protocol**, or **LDAP**) exist around
    it. In this chapter, we’ll look at managing users that exist locally on our server,
    and the groups that help define what they are able to do.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 当谈到服务器时，用户非常重要——如果没有用户可供服务，那么根本就不需要服务器。在IT领域，用户管理这一主题本身是相当广泛的。关于认证的单个方法已经有整本书籍被写成，并且存在围绕它的技术（如**轻量级目录访问协议**，或**LDAP**）。在本章中，我们将重点介绍如何管理存在于我们服务器本地的用户以及帮助定义他们权限的组。
- en: Since Ubuntu Server is a distribution of Linux, it adopts the Unix style of
    managing user accounts, groups, and permissions. Although our focus is on Ubuntu,
    many of the same commands around user management that you’ll learn in this chapter
    will apply to other platforms as well. There are commands that allow you to add,
    remove, and change users, as well as commands that allow you to alter permissions.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 由于Ubuntu Server是一个Linux发行版，它采用了Unix风格的用户帐户、组和权限管理方式。尽管我们的重点是Ubuntu，但本章中你将学习到的许多与用户管理相关的命令也适用于其他平台。有一些命令允许你添加、删除和更改用户，还有一些命令可以改变权限。
- en: Users in the context of a server refer to who (or what) is able to use the server.
    For example, you may have an accountant named Susan, or an IT administrator named
    Haneef, who both need to access the server. Perhaps Susan only needs access to
    a file share directory for accounting-related files, and Haneef might have more
    access to the server as a system administrator. The user accounts we create on
    our server will represent the actual people that will use it.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 在服务器的上下文中，用户指的是谁（或什么）能够使用该服务器。例如，你可能有一个名叫Susan的会计，或一个名叫Haneef的IT管理员，他们都需要访问服务器。也许Susan只需要访问一个文件共享目录来存取与会计相关的文件，而Haneef可能作为系统管理员需要更多的访问权限。我们在服务器上创建的用户帐户将代表实际使用服务器的人。
- en: Groups allow us to segregate access to specific files and directories. As we’ll
    learn later, files and directories have user and group assignments. When combined
    with permissions, we’ll be able to manage what our users are able to do with our
    server.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 组（Groups）允许我们将对特定文件和目录的访问进行隔离。正如我们稍后将学到的，文件和目录有用户和组的分配。当与权限结合使用时，我们就可以管理用户在服务器上可以执行的操作。
- en: Users aren’t always people, though. We also have system users on our server
    that applications and running processes might use for background or automated
    tasks. An example of this might be a backup job, and you may have a backup user
    that runs a task in the background to facilitate some sort of file copy task that
    copies important files to another place. You don’t have to worry about system-related
    users for now, just know that they exist. You’ll see more examples of this as
    we go through the book.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，用户并不总是指人类。我们的服务器上也有系统用户，这些用户可能会被应用程序和运行中的进程用于后台或自动化任务。一个例子可能是备份任务，可能有一个备份用户在后台运行任务，将重要文件复制到其他位置。你现在不需要担心与系统相关的用户，只需要知道它们的存在。随着我们阅读本书，你将会看到更多此类的例子。
- en: More advanced organizations may have a central login server, such as **Active
    Directory** (**AD**) or standard LDAP. There are others aside from those, as well.
    In this book, we won’t cover those technologies, but just keep in mind that central
    authentication servers are a possibility for your organization, should you choose
    to explore them.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 更高级的组织可能会有一个中央登录服务器，例如**Active Directory**（**AD**）或标准的LDAP。除此之外，还有其他类似的技术。本书中我们不会深入讨论这些技术，但请记住，中央认证服务器是你所在组织可能会采用的一种选择，若你决定进一步了解这方面的内容。
- en: The most powerful user of all, though, is `root`. This special user gives us
    the most control, but as you’ll see in the next section, that comes with risks.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，最强大的用户是`root`。这个特殊的用户赋予我们最大权限，但正如你将在下一节看到的那样，这也伴随着一定的风险。
- en: Understanding when to use root
  id: totrans-24
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解何时使用root用户
- en: In the last chapter, we set up our very own Ubuntu Server installation. During
    the installation process, we were instructed to create a user account to act as
    a system administrator. So, at this point, we should have at least two users on
    our server. We have the aforementioned administrative user, as well as `root`.
    We can certainly create additional user accounts with varying levels of access
    (and we will do so in this chapter), but before we get to that, some discussion
    is in order regarding the administrator account you created, as well as the `root`
    user that was created for you.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们设置了自己独立的Ubuntu服务器安装。在安装过程中，我们被要求创建一个作为系统管理员的用户账户。所以，到目前为止，我们的服务器上应该至少有两个用户：前面提到的管理员用户，以及`root`用户。我们当然可以创建其他具有不同访问权限的用户账户（我们将在本章中进行此操作），但在我们开始之前，关于你创建的管理员账户以及为你创建的`root`用户的讨论是必要的。
- en: 'The `root` user account exists on all Linux distributions and is the most powerful
    user account on the planet. The `root` user account can be used to do anything
    within your server, and I do mean *anything*. Want to create files and directories
    virtually anywhere on the filesystem? Want to install software? These processes
    are easily performed with `root`. The `root` account can even be used to destroy
    your entire installation with one typo or ill-conceived command: if you instruct
    `root` to delete all the files on your entire hard disk, it won’t hesitate to
    do so. It’s always assumed on a Linux system that if you are using `root`, you
    are doing so because you know what you are doing. So, there’s often not so much
    as a confirmation prompt while executing any command as `root`. It will simply
    do as instructed, for better or worse.'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: '`root`用户账户存在于所有Linux发行版中，是地球上最强大的用户账户。`root`用户账户可以用来在服务器内做任何事情，真的是*任何*事情。如果想在文件系统中的几乎任何地方创建文件和目录？想要安装软件？这些操作都可以通过`root`轻松完成。甚至，`root`账户可以通过一次打错字或错误命令摧毁整个安装：如果你指示`root`删除整个硬盘上的所有文件，它将毫不犹豫地执行这一操作。在Linux系统中，假定你正在使用`root`时，意味着你知道自己在做什么。因此，在以`root`身份执行任何命令时，通常不会有确认提示。它会按照指示执行，不论好坏。'
- en: It’s for this reason that every Linux distribution I’ve ever used has stated,
    or at least highly recommended, that you create a standard user during the installation
    process. It’s generally recommended in the Linux community for an administrator
    to have their own account and then switch to `root` whenever a task comes up that
    requires `root` privileges to complete. This approach is less likely to destroy
    your server with an accidental typo or bad command. Some administrators will strictly
    use `root` at all times without any issue, but again, it’s recommended to use
    `root` only when you have to.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 正因为如此，我用过的每一个 Linux 发行版都表示，或者至少强烈建议，你在安装过程中创建一个标准用户。Linux 社区普遍建议，管理员应拥有自己的账户，并在需要`root`权限来完成任务时切换到`root`。这种做法不太可能因不小心的输入错误或错误命令而毁掉你的服务器。一些管理员会始终严格使用`root`，但同样，建议仅在必须时使用`root`。
- en: Most distributions ask you to create a `root` password during installation in
    order to protect that account. Even Debian (on which Ubuntu is based) has you
    set a `root` password during installation. Ubuntu just decides to do things a
    little bit differently. The reason for this is that, unlike many other distributions,
    Ubuntu defaults to locking out the `root` account altogether. There’s nothing
    stopping you from enabling `root`, or switching to the `root` user after you log
    in. Being disabled by default just means the `root` account isn’t as easily accessible
    as it normally would be. I’ll cover how to enable this account later in this chapter,
    should you feel the need to do so.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数发行版要求你在安装过程中设置一个`root`密码，以保护该账户。即便是基于 Debian 的 Ubuntu，也要求你在安装过程中设置一个`root`密码。Ubuntu只是决定做一些不同的事情。这样做的原因是，与许多其他发行版不同，Ubuntu默认会完全锁定`root`账户。虽然默认情况下`root`账户不可用，但你仍然可以在登录后启用`root`，或者切换到`root`用户。默认禁用只是意味着`root`账户不像平时那样容易访问。如果你需要启用该账户，我会在本章稍后介绍如何操作。
- en: An exception to this rule is that some VPS providers, such as Linode, will enable
    the `root` account even on their Ubuntu servers. Sometimes, the `root` password
    will be randomly generated and emailed to you. However, you should still create
    a user for yourself with administrative access regardless.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 这一规则的例外是一些VPS提供商，比如 Linode，即使是在它们的 Ubuntu 服务器上，也会启用`root`账户。有时，`root`密码会被随机生成并通过电子邮件发送给你。不过，你仍然应该创建一个具有管理员权限的用户账户。
- en: Instead of using `root` outright, Ubuntu (as well as its server version) recommends
    the use of `sudo`. Specifically, `sudo` enables you to run individual commands
    with elevated privileges instead of being logged in as `root` all the time.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: Ubuntu（包括其服务器版本）推荐使用`sudo`，而不是直接使用`root`。具体来说，`sudo`使你能够以提升的权限运行单个命令，而不需要一直以`root`身份登录。
- en: Using sudo to run privileged commands
  id: totrans-31
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用sudo运行特权命令
- en: 'I’ll go over how to manage `sudo` later on in this chapter, but for now, just
    keep in mind that the purpose of `sudo` is to enable you to use your user account
    to do things that normally only `root` would be able to do. For example, as a
    normal user, you cannot issue a command such as the following to install a software
    package (don’t worry about the `apt` command for now, as we’ll cover that in *Chapter
    3*, *Managing Software Packages*):'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 我会在本章稍后介绍如何管理`sudo`，但现在请记住，`sudo`的目的是让你可以使用用户账户执行通常只有`root`才能做的事情。例如，作为一个普通用户，你不能像下面这样发出安装软件包的命令（别担心现在的`apt`命令，我们将在*第三章*，*软件包管理*中介绍）：
- en: '[PRE0]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Instead, you’ll receive an error:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 反而，你会收到一个错误信息：
- en: '[PRE1]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'But if you prefix the command with `sudo` (assuming your user account has access
    to it), the command will work just fine:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，如果你在命令前加上`sudo`（假设你的用户账户有权限使用它），命令将正常工作：
- en: '[PRE2]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: When you use `sudo`, you’ll be asked for your user’s password for confirmation,
    and then the command will execute. Subsequent commands prefixed with `sudo` may
    not prompt for your password, as it will cache your password for a short period
    of time until it times out or the terminal is closed. Understanding this should
    clarify the usefulness of the user account you created during installation. I
    referred to this user as an administrative account earlier, but it’s really just
    a user account that is able to utilize `sudo`. Ubuntu Server automatically gives
    the first user account you create during installation access to `sudo`.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 当您使用`sudo`时，系统会要求您输入用户密码以确认，然后命令将被执行。后续带有`sudo`前缀的命令可能不会再提示您输入密码，因为系统会缓存您的密码一段时间，直到超时或终端关闭。理解这一点应该能够澄清在安装期间创建的用户帐户的实用性。我之前提到这个用户是一个管理帐户，但实际上它只是一个能够使用`sudo`的用户帐户。Ubuntu
    Server在安装期间会自动为第一个创建的用户帐户授予`sudo`访问权限。
- en: The intent is that you’ll use that account to administer the system, rather
    than `root`. When you create additional user accounts, they will not have access
    to `sudo` by default, unless you explicitly grant it to them.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 所期望的是，您将使用该帐户来管理系统，而不是`root`。当您创建额外的用户帐户时，默认情况下它们将无法访问`sudo`，除非您明确授予它们权限。
- en: Creating and removing users
  id: totrans-40
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建和删除用户
- en: 'Creating users in Ubuntu can be done with one of two commands: `adduser` and
    `useradd`. This can be a little confusing at first, because both of these commands
    do the same thing (in different ways) and are named very similarly. I’ll go over
    the `useradd` command first and then I’ll explain how `adduser` differs. You may
    even prefer the latter, but we’ll get to that in a moment.'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 在Ubuntu中创建用户可以通过两个命令之一完成：`adduser`和`useradd`。这一开始可能会有些混淆，因为这两个命令执行的是相同的操作（方式不同），并且命名非常相似。我会首先介绍`useradd`命令，然后解释`adduser`的区别。您甚至可能更喜欢后者，但我们稍后会详细讨论。
- en: Using useradd
  id: totrans-42
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用`useradd`
- en: 'First, here’s an example of the `useradd` command in action:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，这里是`useradd`命令实际应用的一个例子：
- en: '[PRE3]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: With this command, I created a user named `jdoe`. With the `-d` option, I’m
    clarifying that I would like a home directory created for this user, and following
    that, I called out `/home/jdoe` as the user’s home directory. The `-m` flag tells
    the system that I would like the home directory to be created during the process;
    otherwise, I would’ve had to create the directory myself. Finally, I called out
    the username for my new user (in this case, `jdoe`).
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 使用此命令，我创建了一个名为`jdoe`的用户。通过`-d`选项，我澄清我希望为此用户创建一个主目录，并且在此之后，我指定`/home/jdoe`作为用户的主目录。`-m`标志告诉系统我希望在过程中创建主目录；否则，我将不得不自己创建目录。最后，我指定了我的新用户的用户名（在本例中为`jdoe`）。
- en: As we go along in this book, there will be commands that require `root` privileges
    in order to execute. The preceding command was an example of this. For commands
    that require such permissions, I’ll prefix the commands with `sudo`. When you
    see these, it just means that `root` privileges are required to run the command.
    For these, you can also log in as `root` (if `root` is enabled) or switch to `root`
    to execute these commands as well. However, as I mentioned before, using `sudo`
    instead of using the `root` account is strongly encouraged.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 随着我们在本书中的进展，会有需要`root`权限才能执行的命令。前面的命令就是一个例子。对于需要这种权限的命令，我会在命令前加上`sudo`。当您看到这些命令时，这意味着需要`root`权限才能运行。对于这些命令，您也可以登录为`root`（如果`root`已启用），或者切换到`root`以执行这些命令。但是，如我之前提到的，强烈建议使用`sudo`而不是使用`root`帐户。
- en: 'Now, list the storage of `/home` using the following command:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，使用以下命令列出`/home`的存储：
- en: '[PRE4]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'You should see a folder listed there for our new user:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 您应该会看到一个列出我们新用户的文件夹：
- en: '![](img/B18425_02_01.png)'
  id: totrans-50
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B18425_02_01.png)'
- en: 'Figure 2.1: Listing the contents of /home after our first user was created'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.1：在我们创建第一个用户后列出`/home`目录的内容
- en: 'What about creating our user’s password? We may have been asked for our current
    user’s password due to using `sudo`, but we weren’t asked for a password for the
    new user. To create a password for the user, we can use the `passwd` command.
    The `passwd` command defaults to allowing you to change the password for the user
    you’re currently logged in as, but it also allows you to set a password for any
    other user if you run it as `root` or with `sudo`. If you enter `passwd` by itself,
    the command will first ask you for your current password, then your new password,
    and then it will ask you to confirm your new password again. If you prefix the
    command with `sudo` and then specify a different user account, you can set the
    password for any user you wish. An example of the output of this process is as
    follows:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 那么如何为我们的用户设置密码呢？由于使用了 `sudo`，可能会要求输入当前用户的密码，但并没有要求为新用户设置密码。要为用户创建密码，我们可以使用 `passwd`
    命令。`passwd` 命令默认允许你更改当前登录用户的密码，但如果以 `root` 用户身份或通过 `sudo` 执行，它也允许你为任何其他用户设置密码。如果你单独输入
    `passwd`，命令会首先要求你输入当前密码，然后是新密码，最后再确认一次新密码。如果在命令前加上 `sudo` 并指定其他用户帐户，你就可以为任何用户设置密码。以下是此过程的输出示例：
- en: '![](img/B18425_02_02.png)'
  id: totrans-53
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B18425_02_02.png)'
- en: 'Figure 2.2: Changing the password of a user'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.2：更改用户的密码
- en: As you can see in the previous screenshot, you won’t see any asterisks or any
    kind of output when you type a password using the `passwd` command. This is normal.
    Although you won’t see any visual indication of input, your input is being recognized.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你在上一个截图中看到的，当使用 `passwd` 命令输入密码时，你不会看到任何星号或其他类型的输出。这是正常的。虽然你不会看到输入的视觉指示，但你的输入已经被识别。
- en: Now we have a new user and we were able to set a password for that user. The
    `jdoe` user will now be able to access the system with the password we’ve chosen.
    This user won’t have access to `sudo` by default, but we’ll cover how to change
    this later on in the chapter.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了一个新用户，并且我们已经为该用户设置了密码。`jdoe` 用户现在可以使用我们选择的密码访问系统。默认情况下，该用户无法使用 `sudo`，但我们将在本章稍后讲解如何更改这一点。
- en: Using adduser
  id: totrans-57
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 adduser
- en: 'Earlier, I mentioned the `adduser` command as another way of creating a user.
    The difference (and convenience) of this command should become apparent immediately
    once you’ve used it. Go ahead and give it a try; execute `adduser` along with
    a username for a user you wish to create. An example run of this process is as
    follows:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 之前，我提到过 `adduser` 命令作为创建用户的另一种方式。这个命令的区别（和便捷性）一旦使用后就会立刻显现。去尝试一下吧；执行 `adduser`
    并指定你想创建的用户的用户名。以下是该过程的示例：
- en: '![](img/B18425_02_03.png)'
  id: totrans-59
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B18425_02_03.png)'
- en: 'Figure 2.3: Creating a user with the adduser command'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.3：使用 `adduser` 命令创建用户
- en: 'In the preceding process, I executed `sudo adduser dscully` (commands that
    modify users require `sudo` or `root`) and then I was asked a series of questions
    regarding how I wanted the user to be created. I was asked for the password (twice),
    `Full Name`, `Room Number`, `Work Phone`, and `Home Phone`. In the `Other` field,
    I entered the comment `Trust no one`, which is a great mindset to adopt while
    managing users. The latter prompts prior to the final confirmation were all optional:
    I didn’t have to enter `Full Name`, `Room Number`, and so on. I could’ve pressed
    *Enter* to skip those prompts if I wanted to. The only things that are really
    required are the username and the password.'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 在前述过程中，我执行了 `sudo adduser dscully`（修改用户的命令需要 `sudo` 或 `root` 权限），然后我被问到一系列关于如何创建用户的问题。我被要求输入密码（两次）、`全名`、`房间号`、`工作电话`
    和 `家庭电话`。在 `其他` 字段中，我输入了评论 `Trust no one`，这是管理用户时非常好的心态。最后的提示（在最终确认之前）都是可选的：我不必输入
    `全名`、`房间号` 等等。如果我想跳过这些提示，我可以直接按 *Enter* 键。真正必须的只有用户名和密码。
- en: From the output, we can see that the `adduser` command performed quite a bit
    of work for us. The command defaulted to using `/home/dscully` as the home directory
    for the user, the account was given the next available **User ID** (**UID**) and
    **Group ID** (**GID**) of `1002`, and it also copied files from `/etc/skel` into
    our new user’s `home` directory. In fact, both the `adduser` and `useradd` commands
    copy files from `/etc/skel`, but `adduser` is more verbose regarding the actions
    it performs.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 从输出中，我们可以看到`adduser`命令为我们做了不少工作。该命令默认将`/home/dscully`作为用户的主目录，帐户被分配了下一个可用的**用户
    ID**（**UID**）和**组 ID**（**GID**），其值为`1002`，并且它还将`/etc/skel`中的文件复制到了我们新用户的`home`目录中。实际上，`adduser`和`useradd`命令都会从`/etc/skel`复制文件，但`adduser`在执行操作时更加详细。
- en: Don’t worry if you don’t understand what `UID`, `GID`, and `/etc/skel` are yet.
    We’ll work through those concepts soon.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你还不明白`UID`、`GID`和`/etc/skel`是什么，不用担心，我们稍后会讲解这些概念。
- en: In a nutshell, the `adduser` command is much more convenient in the sense that
    it prompts you for various options while it creates the user without requiring
    that you memorize command-line options. It also gives you detailed information
    about what it has done. At this point, you may be wondering why someone would
    want to use `useradd` at all, considering how much more convenient `adduser` seems
    to be. Unfortunately, `adduser` is not available on all distributions of Linux.
    It’s best to familiarize yourself with `useradd` in case you find yourself on
    a Linux system that’s not Ubuntu.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 总而言之，`adduser`命令在创建用户时更加方便，它会提示你输入各种选项，而无需记住命令行选项。它还会提供关于它所做操作的详细信息。此时，你可能会想，既然`adduser`看起来如此方便，为什么还要使用`useradd`呢？不幸的是，`adduser`并不是所有Linux发行版都提供的。最好还是熟悉一下`useradd`，以防你在一个非Ubuntu的Linux系统上遇到问题。
- en: 'It may be interesting for you to see what exactly the `adduser` command is.
    It’s not even a binary program—it’s a **shell script**. A shell script is simply
    a text file that can be executed as a program. You don’t have to worry too much
    about scripting now, as we will cover it in *Chapter 6*, *Boosting Your Command-line
    Efficiency*. In the case of `adduser`, it’s a script written in **Perl**, which
    is a programming language that is sometimes used for administrative tasks. Since
    it’s not binary, you can even open it in a text editor in order to view all the
    code that it executes behind the scenes. However, make sure you don’t open the
    file in a text editor with `root` privileges, to ensure that you don’t accidentally
    save changes to the file and break the script. The following command will open
    `adduser` in a text editor on an Ubuntu Server system:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会觉得看到`adduser`命令到底是什么很有趣。它甚至不是一个二进制程序——它是一个**Shell脚本**。Shell脚本其实就是一个可以作为程序执行的文本文件。现在你不需要太担心脚本的内容，因为我们会在*第6章*中讲解，*提高你的命令行效率*。就`adduser`而言，它是一个用**Perl**编写的脚本，Perl是一种有时用于管理任务的编程语言。由于它不是二进制文件，你甚至可以在文本编辑器中打开它，查看它在后台执行的所有代码。然而，请确保不要在带有`root`权限的文本编辑器中打开该文件，以免不小心保存更改并破坏脚本。以下命令将在Ubuntu
    Server系统中打开`adduser`脚本：
- en: '[PRE5]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Use your up/down arrows as well as the *Page Up* and *Page Down* keys to scroll
    through the file. When you’re finished, press *Ctrl* + *x* on your keyboard to
    exit the text editor. If the editor prompts you to save changes, don’t do so.
    Anyway, those of you with keen eyes will likely notice that the `adduser` script
    is calling `useradd` to perform its actual work. So either way, you’re either
    directly or indirectly using `useradd`.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 使用上下箭头以及*Page Up*和*Page Down*键在文件中滚动。当完成后，按下*Ctrl* + *x*退出文本编辑器。如果编辑器提示你保存更改，请不要保存。无论如何，你们这些眼睛尖锐的人可能会注意到，`adduser`脚本调用了`useradd`来执行实际的工作。所以，不管怎样，你实际上是直接或间接地使用了`useradd`。
- en: Now that we know how to create users, it will be useful to understand how to
    remove them as well.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们知道了如何创建用户，了解如何删除它们也是很有用的。
- en: Removing users
  id: totrans-69
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 删除用户
- en: Removing or disabling an account is very important when a user no longer needs
    to access a system, as unmanaged accounts often become a security risk. To remove
    a user account, we’ll use the `userdel` command.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 当用户不再需要访问系统时，删除或禁用帐户非常重要，因为未管理的帐户往往会成为安全隐患。要删除用户帐户，我们将使用`userdel`命令。
- en: Before removing an account, though, there is one very important question you
    should ask yourself. Will you (or another person) need access to the user’s files?
    Most companies have retention policies in place that detail what should happen
    to a user’s data when they leave the organization. Sometimes, these files are
    copied into an archive for long-term storage. Often, a manager, coworker, or new
    hire will need access to the former user’s files, perhaps to continue working
    on a project where they left off. It’s important to understand this policy ahead
    of managing users. If you don’t have a policy in place that outlines retention
    requirements for files when users resign, you should probably work with your management
    team and create one.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在删除账户之前，你应该问自己一个非常重要的问题：你（或其他人）是否需要访问该用户的文件？大多数公司都有文件保留政策，详细说明了当员工离职时应该如何处理用户的数据。有时，这些文件会被复制到存档中进行长期存储。通常，经理、同事或新员工可能需要访问前用户的文件，或许是为了继续完成某个项目。理解这一政策对管理用户非常重要。如果你没有明确规定离职用户文件的保留要求，最好与管理团队合作制定一项政策。
- en: 'By default, the `userdel` command does not remove the contents of the user’s
    `home` directory. Here, we use the following command to remove `dscully` from
    the system:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，`userdel`命令不会删除用户的`home`目录的内容。在这里，我们使用以下命令将`dscully`从系统中删除：
- en: '[PRE6]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'We can see that the files for the `dscully` user still exist by entering the
    following command:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过输入以下命令来查看`dscully`用户的文件是否仍然存在：
- en: '[PRE7]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'The preceding commands will result in the following outputs:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的命令将会产生以下输出：
- en: '![](img/B18425_02_04.png)'
  id: totrans-77
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B18425_02_04.png)'
- en: 'Figure 2.4: The home directory for the user dscully still exists, even though
    we removed the user'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.4：尽管我们已经删除了用户，但`dscully`的主目录仍然存在。
- en: 'With the `/home` directory for `dscully` still existing, we’re able to move
    the contents of this directory anywhere we would like to. If we had a directory
    called `/store/file_archive`, for example, we could easily move the files there:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 由于`dscully`的`/home`目录仍然存在，我们可以将该目录的内容移动到任何我们想要的地方。例如，如果我们有一个名为`/store/file_archive`的目录，我们可以轻松地将文件移动到那里：
- en: '[PRE8]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Of course, it’s up to you to create the directory where your long-term storage
    will ultimately be, but you get the idea.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，最终存储的目录由你决定，但你明白我的意思。
- en: 'If you weren’t already aware, you can create a new directory with the `mkdir`
    command. You can create a directory within any other directory that your logged-in
    user has access to. The following command will create the `file_archive` directory
    I mentioned in the preceding example:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你还不知道，你可以使用`mkdir`命令来创建一个新目录。你可以在任何你的登录用户有权限访问的目录中创建一个目录。以下命令将创建我在前面示例中提到的`file_archive`目录：
- en: '[PRE9]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The `-p` flag simply creates the parent directory if it didn’t already exist.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: '`-p`标志只是会在父目录不存在时创建父目录。'
- en: 'If you do actually want to remove a user’s home directory at the same time
    that you remove an account, just add the `-r` option. This will eliminate the
    user and their data in one shot:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你确实希望在删除账户时同时删除用户的主目录，只需添加`-r`选项。这样可以一并删除该用户及其数据：
- en: '[PRE10]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'To remove the `/home` directory for the user after the account was already
    removed (if you didn’t use the `-r` parameter the first time), use the `rm -r`
    command to get rid of it, as you would any other directory:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在账户删除后仍需要删除`/home`目录（如果你第一次没有使用`-r`参数），可以使用`rm -r`命令像删除任何其他目录一样删除它：
- en: '[PRE11]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'It probably goes without saying, but the `rm` command can be extremely dangerous.
    If you’re logged in as `root` or using `sudo` while using `rm`, you can easily
    destroy your entire installed system if you’re not careful. *DO NOT run this command*,
    but as a hypothetical example, the following command (while seemingly innocent
    at first glance) will likely completely destroy your entire filesystem:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 可能不言而喻，但`rm`命令可能非常危险。如果你以`root`身份登录或在使用`rm`时使用了`sudo`，如果不小心，可能会轻易摧毁你整个已安装的系统。*不要运行此命令*，但作为一个假设性的示例，以下命令（乍一看似乎无害）很可能会完全摧毁你整个文件系统：
- en: '[PRE12]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Notice the typo: I accidentally typed a space after the first forward slash.
    I literally accidentally told my system to remove the contents of the entire filesystem.
    If that command were executed, the server probably wouldn’t even boot the next
    time we attempted to start it. All user and program data would be wiped out. If
    there was ever any single reason for us to be protective over the `root` account,
    the `rm` command is most certainly it!'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意错字：我不小心在第一个斜杠后面输入了一个空格。我实际上不小心告诉我的系统删除整个文件系统的内容。如果执行该命令，下次我们尝试启动服务器时，它可能甚至无法引导。所有用户和程序数据都将被清除。如果有一个单一的原因让我们保护
    `root` 账户，那就是 `rm` 命令绝对是其中之一！
- en: At this point, we understand how to add and remove users. In the next section,
    we’ll look deeper into passwords.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们知道如何添加和删除用户。在下一节中，我们将更深入地了解密码。
- en: Understanding the /etc/passwd and /etc/shadow files
  id: totrans-93
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解 `/etc/passwd` 和 `/etc/shadow` 文件
- en: 'Now that we know how to create (and delete) user accounts on our server, we
    are well on our way to being able to manage our users. But where exactly is this
    information stored? We know that users store their personal files in `/home`,
    but is there some kind of database somewhere that keeps track of which user accounts
    are on our system? Actually, user account information is stored in two special
    text files:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们知道如何在服务器上创建（和删除）用户账户，我们已经可以管理用户了。但是这些信息究竟存储在哪里？我们知道用户将其个人文件存储在 `/home` 中，但是是否有某种数据库可以追踪我们系统上的用户账户？实际上，用户账户信息存储在两个特殊的文本文件中：
- en: '`/etc/passwd`'
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`/etc/passwd`'
- en: '`/etc/shadow`'
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`/etc/shadow`'
- en: 'You can display the contents of each of those two files with the following
    commands. Note that any user can look at the contents of `/etc/passwd`, while
    only `root` has access to `/etc/shadow`:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用以下命令显示这两个文件的内容。请注意，任何用户都可以查看 `/etc/passwd` 的内容，而只有 `root` 用户可以访问 `/etc/shadow`：
- en: '[PRE13]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Go ahead and take a look at these two files (just don’t make any changes), and
    I will help you understand them.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 随便看看这两个文件（只是不要做任何更改），我将帮助您理解它们。
- en: Understanding the /etc/passwd file
  id: totrans-100
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 理解 `/etc/passwd` 文件
- en: 'First, let’s go over the `/etc/passwd` file. What follows is some example output
    from this file on my test server. For brevity, I have limited the output to the
    last eight lines:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们来看一下 `/etc/passwd` 文件。接下来是我测试服务器上此文件的一些示例输出。为了简洁起见，我将输出限制为最后八行：
- en: '![](img/B18425_02_05.png)'
  id: totrans-102
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B18425_02_05.png)'
- en: 'Figure 2.5: Example /etc/passwd file'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.5：示例 `/etc/passwd` 文件
- en: Each line within this file corresponds to a user account on the system. Entries
    are split into columns, separated by a colon (`:`). The username is in the first
    column, so you can see that I’ve created users `jay` and `jdoe`. The next column
    on each is simply an `x`. I’ll go over what that means a bit later. For now, let’s
    skip to the third and fourth columns, which reference the UID and GID respectively.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 此文件中的每一行对应系统上的一个用户账户。条目被分割成由冒号（`:`）分隔的列。用户名在第一列，因此您可以看到我创建了用户 `jay` 和 `jdoe`。每个条目的下一列只是一个
    `x`。稍后我会解释这意味着什么。现在，让我们跳到第三和第四列，它们分别引用 UID 和 GID。
- en: On a Linux system, user accounts and groups are actually referenced by their
    IDs. While it’s easier for you and I to manage users by their names, usernames
    and group names are nothing more than a label placed on the UID and GID in order
    to help us identify them more easily.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Linux 系统上，用户账户和用户组实际上是通过它们的 ID 引用的。虽然我们更容易通过名称管理用户，但用户名和组名只是放在 UID 和 GID 上的标签，以帮助我们更轻松地识别它们。
- en: For example, it may be frustrating to try to remember that `jdoe` is UID `1001`
    on our server each time we want to manage this account. Managing it by referring
    to the account as `jdoe` is easier for humans, since we don’t remember numbers
    as well as we do names. But to Linux, each time we reference user `jdoe`, we’re
    actually just referencing UID `1001`. When a user is created, the system (by default)
    automatically assigns the next available UID to the account. If you manage multiple
    Ubuntu servers, note that the UIDs will not match from one system to another,
    so keep in mind that UIDs don’t synchronize between installations.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，尝试记住 `jdoe` 在我们服务器上的 UID `1001` 可能会很烦人。通过引用账户名 `jdoe` 来管理它对人类来说更容易，因为我们不太能记住数字，而是名字。但是对于
    Linux 系统来说，每次我们引用用户 `jdoe`，实际上我们只是引用 UID `1001`。当创建用户时，默认情况下系统会自动为账户分配下一个可用的 UID。如果您管理多个
    Ubuntu 服务器，请注意 UID 在不同系统之间不会匹配，因此请记住 UID 在安装之间不会同步。
- en: In my case (as shown in *Figure 2.5*), the UID of each user is the same as their
    GID. This is just a coincidence on my system and it isn’t always that way in practice.
    While I’ll discuss creating groups later in this chapter, understand that creating
    groups works in a similar way to creating users, in the sense that the group is
    assigned the next available GID in much the same way as new user accounts are
    assigned the next available UID. When you create a user, the user’s primary group
    is the same as their username (unless you request otherwise). For example, when
    I created `jdoe`, the system also automatically created a `jdoe` group as well.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 在我的例子中（如*图2.5*所示），每个用户的UID与其GID相同。这只是我系统中的一个巧合，实际使用中不一定是这样。虽然我稍后会在本章讨论创建组的内容，但需要理解的是，创建组的过程与创建用户相似，都是通过分配下一个可用的GID来进行的，类似于为新用户分配下一个可用的UID。当你创建一个用户时，该用户的主组与其用户名相同（除非你要求其它方式）。例如，当我创建了`jdoe`时，系统也自动创建了一个名为`jdoe`的组。
- en: This is what you’re actually seeing here—the UID for the user, as well as the
    GID for the user’s primary group. Again, we’ll get to groups in more detail later.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是你实际看到的内容——用户的UID，以及用户主组的GID。我们稍后会详细讨论组。
- en: You probably also noticed that the `/etc/passwd` file on your system contains
    entries for many more users than the ones we’ve created ourselves. This is perfectly
    normal, as Linux uses user accounts for various processes and services that run
    in the background. You’ll likely never interact with the default accounts at all,
    though you may someday create your own system user for a process to run as. For
    example, perhaps you’ll create a data processor account for an automated data-processing
    script to run under.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能还注意到，你系统中的`/etc/passwd`文件包含了比我们自己创建的用户更多的条目。这是完全正常的，因为Linux使用用户帐户来处理后台运行的各种进程和服务。你可能永远不会与默认帐户交互，尽管你或许会在某一天为某个进程创建自己的系统用户。例如，也许你会为自动化数据处理脚本创建一个数据处理帐户来运行。
- en: Anyway, back to our `/etc/passwd` file. The fifth column is designated for user
    info, most commonly the user’s first and last names. In my example, the fifth
    field is blank for `jdoe`, as I created `jdoe` with the `useradd` command, which
    didn’t prompt me for the first and last names. This field is also nicknamed the
    `GECOS` field, and you may see it referred to as such when you read the documentation.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，回到我们的`/etc/passwd`文件。第五列用于存储用户信息，通常是用户的名字和姓氏。在我的例子中，`jdoe`的第五列是空的，因为我通过`useradd`命令创建了`jdoe`，该命令没有提示我输入名字和姓氏。这个字段也被昵称为`GECOS`字段，你在阅读文档时可能会看到它以这种方式被提及。
- en: In the sixth column, the home directory for each user is shown. In the case
    of `jdoe`, it’s set as `/home/jdoe`. Finally, we designate the user’s shell as
    `/bin/bash`. This field refers to the default shell the user will use, which defaults
    to `/bin/bash` when an account is created with the `adduser` command, and `/bin/sh`
    when created with the `useradd` command. (If you have no preference, `/bin/bash`
    is the best choice for most.) If we want the user to use a different shell, we
    can clarify that here (though shells other than `/bin/bash` aren’t covered in
    this book). If we wanted, we could change the user’s shell to something invalid
    to prevent them from logging in at all. This is useful for when a security issue
    requires us to disable an account quickly.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 在第六列，显示了每个用户的主目录。对于`jdoe`来说，它被设置为`/home/jdoe`。最后，我们为用户指定了默认的shell为`/bin/bash`。这个字段指的是用户将使用的默认shell，当使用`adduser`命令创建帐户时，默认的shell是`/bin/bash`，而使用`useradd`命令创建时，默认是`/bin/sh`。（如果你没有偏好，`/bin/bash`对大多数人来说是最好的选择。）如果我们希望用户使用不同的shell，可以在这里指定（不过本书并未涉及`/bin/bash`以外的shell）。如果我们愿意，也可以将用户的shell更改为一个无效的值，从而完全禁止他们登录。这在需要快速禁用帐户时非常有用。
- en: Understanding the /etc/shadow file
  id: totrans-112
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 理解/etc/shadow文件
- en: 'With that out of the way, let’s take a look at the `/etc/shadow` file. We can
    use `cat` to display the contents like any other text file, but unlike `/etc/passwd`,
    we need `root` privileges in order to view it. So, go ahead and display the contents
    of this file, and I’ll walk you through it:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 既然这些已经解释清楚了，让我们来看看`/etc/shadow`文件。我们可以像其他文本文件一样使用`cat`命令显示其内容，但与`/etc/passwd`不同，我们需要`root`权限才能查看它。所以，赶紧显示这个文件的内容，我会带你逐步分析：
- en: '[PRE14]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'This will display the following output:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 这将显示以下输出：
- en: '![](img/B18425_02_06.png)'
  id: totrans-116
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B18425_02_06.png)'
- en: 'Figure 2.6: Example /etc/shadow file'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.6：示例/etc/shadow文件
- en: The preceding screenshot, *Figure 2.6*, shows the last four lines of this file
    on my server. First, we have the username in the first column—no surprises there.
    Note that the output is not showing the UID for each user in this file. The system
    knows which username matches which UID based on the `/etc/passwd` file, so there’s
    no need to repeat that here. In the second column, we have what appears to be
    gobbledygook. Actually, that’s the most important part of this entire file. That’s
    the actual hash for the user’s password.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 上面的截图，*图2.6*，显示了我服务器上该文件的最后四行。首先，我们在第一列看到用户名——没有什么惊讶的。请注意，输出中没有显示每个用户的UID。系统根据`/etc/passwd`文件知道哪个用户名对应哪个UID，因此这里无需重复显示。第二列显示的似乎是一些乱码。实际上，这是整个文件中最重要的部分。那是用户密码的实际哈希值。
- en: A password hash is a conversion of the actual password to a different string
    that represents the original password. This is a one-way conversion, so you cannot
    find the actual password by reverse-engineering the hash. In the `/etc/passwd`
    file, the hash of the password is stored rather than the actual password, for
    security purposes.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 密码哈希是将实际密码转换为一个不同的字符串，代表原始密码。这是一个单向转换，因此你不能通过逆向工程哈希来找到实际密码。在`/etc/passwd`文件中，存储的是密码的哈希，而不是实际密码，这是出于安全考虑。
- en: If you recall, in the `/etc/passwd` file, each user listing had an `x` for the
    second column, and I mentioned I would explain that later. What the `x` refers
    to is the fact that the user’s password is encrypted and simply not stored in
    `/etc/passwd` and is instead stored in `/etc/shadow`. After all, the `/etc/passwd`
    file is viewable by everyone, so it would compromise security quite a bit if anyone
    could just open up the file and see what everyone’s passwords were.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你还记得，在`/etc/passwd`文件中，每个用户条目在第二列都有一个`x`，我提到过稍后会解释这个。`x`表示的是用户的密码被加密，并且没有直接存储在`/etc/passwd`中，而是存储在`/etc/shadow`中。毕竟，`/etc/passwd`文件是所有人都可以查看的，因此如果任何人都能打开该文件并看到每个人的密码，那将极大地危及安全性。
- en: In the days of old, you could actually store a user’s password in `/etc/passwd`,
    but it’s never done that way anymore. Whenever you create a user account on a
    modern Linux system, the user’s password is encrypted (an `x` is placed in the
    second column of `/etc/passwd` for the user), and the actual password hash is
    stored in the second column of `/etc/shadow` to keep it away from prying eyes.
    Hopefully, now the relationship between these two files has become apparent.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 在过去的日子里，你实际上可以将用户的密码存储在`/etc/passwd`中，但现在已经不再这么做了。每当你在现代Linux系统上创建用户账户时，用户的密码会被加密（在`/etc/passwd`的第二列会为该用户放置一个`x`），而实际的密码哈希会存储在`/etc/shadow`的第二列，以防止被窥视。希望现在你已经明白了这两个文件之间的关系。
- en: 'Remember earlier I mentioned that the `root` user account is locked out by
    default? Well, let’s actually see that in action. Execute the following command
    to see the `root` user account entry in `/etc/shadow`:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 记得我之前提到`root`用户账户默认是锁定的吗？好吧，让我们看看它是如何工作的。执行以下命令，查看`/etc/shadow`中的`root`用户账户条目：
- en: '[PRE15]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'On my system, I get the following output:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 在我的系统上，我得到以下输出：
- en: '![](img/B18425_02_07.png)'
  id: totrans-125
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B18425_02_07.png)'
- en: 'Figure 2.7: Example /etc/shadow file'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.7：示例 /etc/shadow 文件
- en: You should notice right away that the `root` user account doesn’t have a password
    hash at all. Instead, there’s an asterisk where the password hash would’ve been.
    In practice, placing an asterisk or exclamation point here is one way to lock
    an account. Even easier, you can use the `passwd -l` command against an account
    to lock it without having to edit a file. But either way, we can still switch
    to the `root` account anytime (which I’ll show you how to do later on in this
    chapter). Entering an asterisk or exclamation mark in the second field creates
    the restriction that we can’t directly log in as that user from the shell or over
    the network. We have to log in to the system as a normal user account first, and
    then we can still switch to that user if we want to.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该立即注意到，`root`用户账户根本没有密码哈希。相反，密码哈希的位置会显示一个星号。实际上，在这里放置一个星号或感叹号是一种锁定账户的方法。更简单的方法是，你可以使用`passwd
    -l`命令来锁定一个账户，而无需编辑文件。但无论哪种方式，我们仍然可以随时切换到`root`账户（稍后我会向你展示如何做到这一点）。在第二列输入一个星号或感叹号会创建一个限制，使得我们不能直接从shell或通过网络登录该用户。我们必须先以普通用户身份登录系统，然后如果需要，还可以切换到该用户。
- en: 'With the discussion of password hashes out of the way, there are a few more
    fields within `/etc/shadow` entries that we should probably understand. Here’s
    a contrived example line:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 在讨论完密码哈希后，`/etc/shadow`文件中还有一些字段我们应该理解。这里有一行构造的示例：
- en: '[PRE16]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Continuing on with the third column, we can see the number of days since the
    **Unix epoch** that the password was last changed. For those that don’t know,
    the Unix epoch is January 1, 1970\. Therefore, we can read that column as the
    password having last been changed 16,809 days after the Unix epoch.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 继续讨论第三列，我们可以看到自**Unix纪元**以来密码最后一次更改的天数。对于不清楚的人来说，Unix纪元是1970年1月1日。因此，我们可以将该列解读为密码是在Unix纪元后第16,809天更改的。
- en: 'Personally, I like to use the following command to show more easily when the
    password was last changed:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 个人而言，我喜欢使用以下命令来更方便地查看密码最后一次更改的时间：
- en: '[PRE17]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'This will result in an output that looks something like the following:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 这将导致输出类似于以下内容：
- en: '![](img/B18425_02_08.png)'
  id: totrans-134
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B18425_02_08.png)'
- en: 'Figure 2.8: Checking the date of the last password change for a user'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.8：检查用户最后一次密码更改的日期
- en: By executing this command, you can view information about any account on your
    system. The first column is obviously the username. The second has to do with
    the status of the password, which in this case is `L`, which refers to the fact
    that the user has a password that is locked. It would show `P` if the password
    was set and usable, or `NP` if the user didn’t have a password at all.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 执行此命令后，你可以查看系统中任何账户的信息。第一列显然是用户名。第二列与密码的状态有关，在这种情况下是`L`，表示该用户的密码被锁定。如果密码已设置且可用，则显示`P`，如果用户没有密码，则显示`NP`。
- en: The third column of this command’s output gives you the actual date of the last
    password change for the user. The fourth column tells us how many days are required
    to pass before the user will be able to change their password again. In this example,
    `jdoe` can change the password any time because the minimum number of days is
    set to `0`. We’ll talk about how to set the minimum number of days later on in
    this chapter, but I’ll give you a brief explanation of what this refers to. At
    first, it may seem silly to require a user to wait a certain number of days to
    be able to change their password. However, never underestimate the ability of
    your users to be oppositional. It’s quite common for a user, when required to
    change their password, to change their password to satisfy history requirements,
    only to then just change it back to what it was originally. By setting a minimum
    number of days, you’re forcing a waiting period in between password changes, making
    it less convenient for your users to cycle back through to their original password.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 该命令输出的第三列显示了用户最后一次密码更改的实际日期。第四列告诉我们用户在再次更改密码之前需要等待多少天。在这个例子中，`jdoe`可以随时更改密码，因为最小天数设置为`0`。我们稍后会在本章中讲解如何设置最小天数，但我会简要解释一下这个设置的含义。起初，要求用户等待一定天数才能更改密码似乎有些傻。然而，千万不要低估用户的反抗心理。当要求用户更改密码时，用户往往会为了满足历史要求而更改密码，但随后会迅速将其更改回原来的密码。通过设置最小天数，你强制要求用户在两次密码更改之间有一个等待期，这样就不那么方便用户直接更改回原来的密码。
- en: The fifth column, as you can probably guess, is the maximum number of days that
    can pass between password changes. If you require your users to change their passwords
    every certain number of days, you’ll see that in this column. By default, this
    is set to `99999` days. That number of days is way beyond the human lifespan,
    so it may as well be infinite.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 第五列，顾名思义，是密码更改之间允许的最大天数。如果你要求用户在每隔一定天数后更改密码，你将在这一列看到相应的数字。默认情况下，这个值设置为`99999`天。这个天数远远超过人的寿命，所以实际上可以认为它是无限的。
- en: Continuing with the sixth column, we have the number of days that will elapse
    before the expiration date on which the user is warned that they will soon be
    required to change their password. In the seventh column, we set how many days
    can pass after the password expires, in which case the account will be disabled.
    With our example user, this is not set. Finally, with the eighth column (which
    is not visible), we can see the number of days since the Unix epoch that will
    elapse before the account is disabled (in our case, there’s nothing here, so there
    is no disabled day set).
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 继续讲解第六列，我们列出了在密码过期前，用户会被提醒需要更改密码的天数。在第七列中，我们设置了密码过期后可以过去多少天，在这种情况下，账户将会被禁用。对于我们的示例用户，暂时没有设置此项。最后，在第八列（该列不可见）中，我们可以看到自
    Unix 纪元以来，账户将被禁用之前经过的天数（在我们的例子中，这里没有内容，因此没有设置禁用日期）。
- en: We’ll go over setting these fields later, but for now, hopefully you understand
    the contents of the `/etc/shadow` file better.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 我们稍后会讲解如何设置这些字段，但现在希望你能更好地理解`/etc/shadow`文件的内容。
- en: 'If at any time you’d like additional clarification, feel free to check out
    the Ubuntu man pages. A man page (short for manual page) can give you quite a
    bit more information about commands as well as files. For example, the following
    command shows you the man page for the `ls` command:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在任何时候你需要进一步的说明，随时可以查看 Ubuntu 的手册页。手册页（man page 的缩写）可以提供关于命令和文件的更多信息。例如，以下命令会显示`ls`命令的手册页：
- en: '[PRE18]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'More specific to this section, you can retrieve man pages for the `/etc/shadow`
    files as well:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 针对本节内容，你也可以检索`/etc/shadow`文件的手册页：
- en: '[PRE19]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Press *q* on your keyboard to exit out of a man page. Feel free to check out
    the man pages for any command in this book to learn more as you go along.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 按下键盘上的*q*退出手册页。随时可以查看本书中任何命令的手册页，以便更深入了解。
- en: Now that we fully understand how to manage our users, we can also look at how
    to provide them with default files in their home directory.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经完全理解了如何管理用户，我们还可以看看如何为他们的主目录提供默认文件。
- en: Distributing default configuration files with /etc/skel
  id: totrans-147
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 `/etc/skel` 分发默认配置文件
- en: In a typical organization, there are usually some defaults that are recommended
    for users in terms of files and configuration.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 在典型的组织中，通常会有一些推荐的默认文件和配置供用户使用。
- en: For example, in a company that performs software development, there are likely
    recommended settings for text editors and version control systems. Files that
    are contained within `/etc/skel` are copied into the home directory for all new
    users when you create them (assuming you’ve chosen to create a home directory
    while setting up the user).
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，在进行软件开发的公司中，通常会有推荐的文本编辑器和版本控制系统的设置。位于`/etc/skel`目录中的文件会在创建新用户时复制到他们的主目录中（假设你在设置用户时选择了创建主目录）。
- en: 'In fact, you can see this for yourself right now. Execute the following command:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 事实上，你现在就可以亲自验证这一点。执行以下命令：
- en: '[PRE20]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Now, you should be able to view the contents of the `/etc/skel` directory:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你应该能够查看`/etc/skel`目录的内容：
- en: '![](img/B18425_02_09.png)'
  id: totrans-153
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B18425_02_09.png)'
- en: 'Figure 2.9: Default /etc/skel files'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.9：默认的 `/etc/skel` 文件
- en: You probably already know how to list files within a directory, but I added
    the `-a` option because I wanted to view hidden files as well. The files included
    in `/etc/skel` by default are hidden (their filenames begin with a period). I
    threw in the `-l` parameter solely because it shows a long list, which I think
    is easier to read.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能已经知道如何列出目录中的文件，但我添加了`-a`选项，因为我想查看隐藏文件。默认情况下，`/etc/skel`中包含的文件是隐藏的（它们的文件名以句点开头）。我还加了`-l`参数，因为它显示的是长格式列表，我觉得这种格式更易读。
- en: Each time you create a new user and request a home directory to be created as
    well, these three files, shown in *Figure 2.9*, will be copied into their home
    directory, along with any other files you create here. You can verify this by
    listing the storage of the home directories for the users you’ve created so far.
    The `.bashrc` file in one user’s home directory should be the same as any other,
    unless they’ve made changes to it.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 每次创建新用户并要求同时创建主目录时，这三个文件（如*图 2.9*所示）会被复制到用户的主目录中，除此之外，任何你在此处创建的文件也会一同复制。你可以通过列出已创建用户的主目录存储内容来验证这一点。一个用户主目录中的`.bashrc`文件应该和其他任何用户的相同，除非他们对其进行了修改。
- en: Armed with this knowledge, it should be extremely easy to create default files
    for new users that you create. For example, you could create a file named `welcome`
    with your favorite text editor and place it in `/etc/skel`. Perhaps you may create
    this file to contain helpful phone numbers and information for new hires in your
    company. The file would then be automatically copied to the new user’s home directory
    when you create the account. The user, after logging in, would see this file in
    their home directory and see the information. More practically, if your company
    has specific editor settings that are favored for writing code, you can include
    those files in `/etc/skel` as well to help ensure your users are compliant. In
    fact, you can include default configuration files for any application your company
    uses.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 掌握了这些知识后，创建新用户的默认文件应该变得非常简单。例如，你可以使用自己喜欢的文本编辑器创建一个名为`welcome`的文件，并将其放置在`/etc/skel`目录中。也许你会创建一个包含公司新员工帮助电话和信息的文件。然后，在你创建账户时，这个文件会自动复制到新用户的主目录中。用户登录后，会在其主目录中看到该文件并查看相关信息。更实际一点，如果你的公司有特定的编辑器设置，适合写代码，你也可以将这些文件包含在`/etc/skel`中，以确保用户遵循这些设置。事实上，你可以为公司使用的任何应用程序包含默认配置文件。
- en: Go ahead and give it a try. Feel free to create some random text files and then
    create a new user afterward, and you’ll see that these files will propagate into
    the home directories of the new user accounts that you add to your system.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 赶紧试试吧。随便创建一些随机文本文件，然后创建一个新用户，接着你会看到这些文件会自动进入你系统中新账户的主目录中。
- en: Now that we have multiple users and have also seen how to manage their default
    files, we can take a look at how to switch from one user to another.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经有了多个用户，并且了解了如何管理它们的默认文件，我们可以看看如何在用户之间切换。
- en: Switching users
  id: totrans-160
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 切换用户
- en: Now that we have several users on our system, we need to know how to switch
    between them. Of course, you can always just log in to the server as one of the
    users, but you can actually switch to any user account at any time, provided you
    either know that user’s password or have `sudo` access.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们系统中已经有了多个用户，我们需要知道如何在它们之间切换。当然，你可以随时以某个用户身份登录到服务器，但实际上，你可以在任何时候切换到任何用户账户，只要你知道该用户的密码或拥有`sudo`权限。
- en: The command you will use to switch from one user to another is the `su` command.
    If you enter `su` with no options, it will assume that you want to switch to `root`
    and will ask you for the `root` password. As I mentioned earlier, Ubuntu locks
    the `root` account by default, so at this point you may not have a `root` password.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 切换用户时，你将使用`su`命令。如果你输入`su`而不带任何选项，它将默认假设你要切换到`root`用户，并会要求你输入`root`密码。正如我之前提到的，Ubuntu默认锁定了`root`账户，所以此时你可能没有`root`密码。
- en: Even though Ubuntu doesn’t create a password for `root` by default, some **Virtual
    Private Server** (**VPS**) providers unlock the `root` password and actually have
    you log in as the `root` user. Having an unlocked `root` account is not a standard
    Ubuntu practice, and is a customization specific to some cloud providers.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 即使Ubuntu默认不为`root`创建密码，某些**虚拟专用服务器**（**VPS**）提供商会解锁`root`密码，并让你以`root`用户身份登录。解锁`root`账户并不是Ubuntu的标准做法，而是某些云服务提供商的定制。
- en: 'Unlocking the `root` account is actually really simple; all you have to do
    is create a `root` password. To do that, you can execute the following command
    as any user with `sudo` access:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 解锁`root`账户其实非常简单；你只需要创建一个`root`密码。为此，你可以以任何拥有`sudo`权限的用户身份执行以下命令：
- en: '[PRE21]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'The command will ask you to create and confirm your `root` password. From this
    point on, you will be able to use the `root` account as any other account. You
    can log in as `root` or switch to `root`—it’s fully available now. However, you
    really don’t have to unlock the `root` account in order to use it. You certainly
    can, but there are ways to switch to `root` without unlocking it, and it’s typically
    better to leave the `root` account locked unless you have a very specific reason
    to unlock it. The following command will allow you to switch to `root` from a
    user account that has `sudo` access:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 命令将要求你创建并确认`root`密码。从此以后，你将能够像使用其他账户一样使用`root`账户。你可以直接以`root`身份登录，或者切换到`root`——现在它完全可用了。然而，实际上你并不需要解锁`root`账户就可以使用它。你当然可以解锁它，但有办法在不解锁`root`的情况下切换到`root`，通常最好保持`root`账户锁定，除非你有非常特殊的原因需要解锁它。以下命令将允许你从具有`sudo`权限的用户账户切换到`root`：
- en: '[PRE22]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Now you’ll be logged in as `root` and will be able to execute any command you
    want with no restrictions whatsoever. To return to your previously logged-in account,
    simply type `exit`. You can tell which user you’re logged in as by the value at
    the beginning of your `bash` prompt.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你将以`root`身份登录，并且可以执行任何你想要的命令，不会有任何限制。要返回到之前登录的账户，只需输入`exit`。你可以通过`bash`提示符开头的值来判断自己当前以哪个用户身份登录。
- en: 'What if you want to switch to an account other than `root`? Of course, you
    can simply log out and then log in as that user. But you really don’t have to
    do that. The following command will do the job, providing you know the password
    for the account:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想切换到`root`以外的账户怎么办？当然，你可以直接注销并以该用户身份重新登录。但其实你不需要这么做。只要知道账户的密码，下面的命令就能帮你完成切换：
- en: '[PRE23]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: The shell will ask for that user’s password and then you’ll be logged in as
    that user. Again, type `exit` when you’re done using the account, which will return
    you to the one you were using before you switched.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: Shell会要求输入该用户的密码，然后你将以该用户的身份登录。同样，当你使用完账户后，输入`exit`将返回到你之前使用的账户。
- en: That command is all well and good if you know the user’s password, but you often
    won’t. Typically, in an enterprise, you’ll create an account, force the user to
    change their password at first login, and then you will no longer know that user’s
    password.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你知道用户的密码，这个命令是没问题的，但通常你并不会知道。通常，在企业环境中，你会创建一个账户，强制用户在首次登录时更改密码，然后你将无法知道该用户的密码。
- en: 'Since you have `root` and `sudo` access, you could always change their password
    and then log in as them. But they’ll know something is amiss if their password
    suddenly stops working—you’re not eavesdropping, are you? Armed with `sudo` access,
    you can use `sudo` to change to any user you want to, even if you don’t know their
    password. Just prefix our previous command with `sudo` and you’ll only need to
    enter the password for your user account, instead of theirs:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 由于你拥有`root`和`sudo`权限，你可以随时更改他们的密码，然后以他们的身份登录。但如果他们的密码突然失效，他们肯定会发现问题——你不是在窃听吧？有了`sudo`权限，你可以使用`sudo`切换到任何你想要的用户，即使你不知道他们的密码。只需要在之前的命令前加上`sudo`，你只需要输入你自己账户的密码，而不是他们的：
- en: '[PRE24]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Switching to another user account is often very helpful for support (especially
    while troubleshooting permissions). As an example, say that a user comes to you
    complaining that they cannot access the contents of a specific directory, or they
    are unable to run a command. In that case, you can log in to the server, switch
    to their user account, and try to reproduce their problem. That way, you can not
    only see their problem yourself, but you can also test out whether or not your
    fix has solved their issue before you report back to them.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 切换到另一个用户账户对于支持工作（尤其是故障排除权限问题）通常非常有帮助。举个例子，假设某个用户找你抱怨无法访问特定目录的内容，或者无法运行某个命令。在这种情况下，你可以登录到服务器，切换到他们的用户账户，尝试重现他们的问题。这样，你不仅可以亲自看到他们的问题，还可以测试你的修复是否解决了问题，然后再回复他们。
- en: Now we have a full understanding of user accounts, and even how to switch between
    them. In the next section, we’ll look into groups, which allow us to categorize
    our users.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经完全理解了用户账户，甚至知道如何在它们之间切换。在接下来的部分，我们将探讨**用户组**，它允许我们对用户进行分类。
- en: Managing groups
  id: totrans-177
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 管理用户组
- en: Now that we understand how to create, manage, and switch between user accounts,
    we’ll need to understand how to manage **groups** as well. The concept of groups
    in Linux is not very different from other platforms and pretty much serves the
    exact same purpose. With groups, you can more efficiently control a user’s access
    to resources on your server. By assigning a group to a resource (a file, a directory,
    and so on), you can allow and disallow access to users by simply adding them or
    removing them from the group.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们理解了如何创建、管理和切换用户账户，我们还需要了解如何管理**用户组**。Linux中的用户组概念与其他平台并没有太大区别，基本上是为了实现相同的目的。有了用户组，你可以更高效地控制用户对服务器资源的访问。通过将用户组分配给某个资源（如文件、目录等），你可以通过简单地将用户添加或移除该组来允许或拒绝他们的访问。
- en: 'The way this works in Linux is that every file or directory has both a user
    and a group that takes ownership of it. This is contrary to platforms such as
    Windows, which can have multiple groups assigned to a single resource. With Linux,
    it’s just one-to-one ownership: just one user and just one group assigned to each
    file or directory. If you list the contents of a directory on a Linux system,
    you can see this for yourself:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Linux 中，工作方式是每个文件或目录都有一个用户和一个组来对其进行拥有。这与 Windows 等平台不同，Windows 允许一个资源被多个组分配。而
    Linux 是一对一的拥有：每个文件或目录只分配一个用户和一个组。如果你列出 Linux 系统上某个目录的内容，你可以亲眼看到这一点：
- en: '[PRE25]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'The following is a sample line of output from a directory on one of my servers:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是我其中一台服务器上某个目录的输出示例：
- en: '[PRE26]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: In this case, we can see that `root` owns the file and that the group `bind`
    is also assigned to it. Ignore the other fields for now; I’ll explain them later
    when we get to the section of this chapter dedicated to permissions. For now,
    just keep in mind that one user and one group are assigned to each file or directory.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们可以看到 `root` 拥有这个文件，并且组 `bind` 也被分配给了它。暂时忽略其他字段；当我们讲解关于权限的章节时，我会详细解释。现在，只需记住，每个文件或目录都分配了一个用户和一个组。
- en: While each file or directory can only have one group assignment, any user account
    can be a member of any number of groups. Entering the `groups` command by itself
    with no options will tell you what groups your logged-in user is currently a member
    of. If you add a username to the `groups` command, you’ll see which groups that
    user is a member of. Go ahead and give the `groups` command a try with and without
    providing a username to get the idea.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然每个文件或目录只能有一个组分配，但任何用户帐户都可以是多个组的成员。仅执行 `groups` 命令而不带任何选项，可以告诉你当前登录用户是哪些组的成员。如果你在
    `groups` 命令后添加用户名，你将看到该用户是哪些组的成员。可以尝试一下带或不带用户名的 `groups` 命令，了解一下其作用。
- en: On the Ubuntu Server platform, you’ll likely see that each of your user accounts
    is a member of a group that’s named the same as your username. As I mentioned
    earlier, when you create a user account, you’re also creating a group with the
    same name as the user. On some Linux distributions, though, a user’s primary group
    will default to a group called `users` instead. If you were to execute the `groups`
    command as a user on the Ubuntu desktop platform, you would likely see additional
    groups. This is due to the fact that distributions of Linux that cater to being
    a server platform are often more stripped down and users on desktop platforms
    need access to more objects such as printers, audio cards, and so on. Some packages
    that can be installed also add additional system users to the server.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Ubuntu Server 平台上，你很可能会发现每个用户帐户都是一个名为与用户名相同的组的成员。正如我之前提到的，当你创建一个用户帐户时，你也在创建一个与用户同名的组。然而，在某些
    Linux 发行版中，用户的主要组会默认是名为 `users` 的组。如果你在 Ubuntu 桌面平台上执行 `groups` 命令，你可能会看到更多的组。这是因为，面向服务器平台的
    Linux 发行版通常更加精简，而桌面平台上的用户需要访问更多的对象，如打印机、声卡等。一些可以安装的包也会为服务器添加额外的系统用户。
- en: 'If you were curious as to which groups exist on your server, all you would
    need to do is `cat` the contents of the `/etc/group` file. Similar to the `/etc/passwd`
    file we covered earlier, the `/etc/group` file contains information regarding
    the groups that have been created on your system. Go ahead and take a look at
    this file on your system:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想知道你的服务器上存在哪些组，你只需要执行 `cat` 命令来查看 `/etc/group` 文件的内容。与我们之前介绍的 `/etc/passwd`
    文件类似，`/etc/group` 文件包含了系统中已创建的组的信息。快去查看你系统上的这个文件：
- en: '[PRE27]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'The following is sample output from this file on one of my servers:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是我其中一台服务器上该文件的示例输出：
- en: '![](img/B18425_02_10.png)'
  id: totrans-189
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B18425_02_10.png)'
- en: 'Figure 2.10: Sample output from the /etc/group file'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.10：/etc/group 文件的示例输出
- en: Like before, the columns in this file are separated by colons, though each line
    is only four columns long. In the first column, we have the name of the group.
    No surprise there. In the second, we are able to store a password for the group,
    but this is not used often as it’s actually a security risk to do so. In the third
    column, we have the GID, which is similar in concept to the UID from when we were
    discussing users. Finally, in the last column, we (would) see a comma-separated
    list of each user that is a member of each of the groups.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 和之前一样，文件中的列是用冒号分隔的，不过每行只有四列。在第一列，我们有组的名称，这一点并不意外。在第二列，我们可以存储组的密码，但这不常用，因为这样做实际上会带来安全风险。在第三列，我们有`GID`，它的概念与我们讨论用户时的`UID`类似。最后，在最后一列，我们（会）看到一个以逗号分隔的成员列表，列出每个组的成员。
- en: Several entries don’t show any group memberships at all. Each user is indeed
    a member of their own group, so this is implied even though it doesn’t explicitly
    call that out in this file. If you take a look at the `/etc/passwd` entries for
    your users, you will see that their primary group (shown as the third column in
    the form of a GID) references a group contained in the `/etc/group` file.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 有些条目根本没有显示任何组成员。每个用户确实是自己组的成员，所以虽然文件中没有明确写出这一点，但这是隐含的。如果你查看`/etc/passwd`文件中用户的条目，你会看到他们的主组（作为第三列显示，以`GID`的形式）引用了`/etc/group`文件中的一个组。
- en: Creating new groups on your system is easy to do and is a great idea for categorizing
    your users and what they are able to do. Perhaps you create an `accounting` group
    for your accountants, an `admins` group for those in your IT department, and a
    `sales` group for your salespeople. The `groupadd` command allows you to create
    new groups.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 在系统中创建新组非常简单，也是分类用户及其权限的好方法。比如你可以为会计人员创建一个`accounting`组，为IT部门的员工创建`admins`组，为销售人员创建一个`sales`组。`groupadd`命令可以用来创建新组。
- en: 'If you wanted to, you could just edit the `/etc/group` file and add a new line
    with your group information manually, although, in my opinion, using `groupadd`
    saves you some work and ensures that group entries are created properly. Editing
    group and user files directly is typically frowned upon (and a typo can cause
    serious problems). Anyway, what follows is an example of creating a new group
    with the `groupadd` command:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你愿意的话，也可以直接编辑`/etc/group`文件，手动添加一行新的组信息，不过我认为使用`groupadd`命令可以省去一些工作，还能确保组条目正确创建。直接编辑组和用户文件通常是不推荐的（而且一个拼写错误可能导致严重问题）。无论如何，接下来是使用`groupadd`命令创建新组的示例：
- en: '[PRE28]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'If you take a look at the `/etc/group` file again after adding a new group,
    you’ll see that a new line was created in the file and a `GID` was chosen for
    you (the first one that hadn’t been used yet). Removing a group is just as easy.
    Just issue the `groupdel` command followed by the name of the group you wish to
    remove:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在添加新组后再次查看`/etc/group`文件，你会看到文件中创建了一行新内容，并且为你选择了一个`GID`（第一个尚未使用的GID）。删除组同样简单。只需要执行`groupdel`命令，后面跟上你想要删除的组名：
- en: '[PRE29]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Next, we’ll take a look at the `usermod` command, which will allow you to actually
    associate users with groups. The `usermod` command is more or less a Swiss Army
    knife; there are several things you can do with that command (adding a user to
    a group is just one of its abilities). If we wanted to add a user to our `admins`
    group, we would issue the following command:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将了解`usermod`命令，它可以让你将用户与组关联起来。`usermod`命令可以说是瑞士军刀式的工具；它有很多功能（将用户添加到组只是其中之一）。如果我们想要把一个用户添加到`admins`组，可以执行以下命令：
- en: '[PRE30]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: In that example, we’re supplying the `-a` option, which means append, and immediately
    following that, we’re using `-G`, which means we would like to modify secondary
    group membership. I put the two options together with a single dash (`-aG`), but
    you could also issue them separately (`-a -G`). The example I gave only adds the
    user to additional groups; it doesn’t replace their primary group.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们提供了`-a`选项，意味着追加，然后紧接着使用`-G`，表示我们希望修改次要组成员资格。我把这两个选项合并为一个（`-aG`），但你也可以分别使用它们（`-a
    -G`）。我给出的示例只是将用户添加到附加的组，而不会替换他们的主组。
- en: Be careful not to miss the `-a` option here, as by doing so, you will instead
    replace all current group memberships with the new one, which is usually not what
    you want. The `-a` option means append, or to add the existing list of group memberships
    for that user.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 注意不要遗漏`-a`选项，因为这样做会将所有当前的组成员资格替换为新的组，这通常不是你想要的。`-a`选项意味着附加，即将该用户的现有组成员资格列表添加到新组中。
- en: 'If you wanted to change a user’s primary group, you would use the `-g` option
    instead (lowercase *g* instead of an uppercase *G* as we used earlier):'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想更改用户的主组，可以使用`-g`选项（使用小写的*g*，而不是我们之前使用的大写*G*）：
- en: '[PRE31]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Feel free to check out the man pages for the `usermod` command, to see all
    the nifty things it allows you to manage relating to your users. You can peruse
    the man page for the `usermod` command with the following command:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 随时查看`usermod`命令的手册页，了解它允许你管理与用户相关的所有有用功能。你可以使用以下命令查看`usermod`命令的手册页：
- en: '[PRE32]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'One additional example is changing a user’s `/home` directory. Suppose that
    one of your users has undergone a name change, so you’d like to change their username,
    as well as moving their previous `home` directory (and their files) to a new one.
    The following commands will take care of that:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个例子是更改用户的`/home`目录。假设你的某个用户进行了改名，你希望更改他们的用户名，并将他们原来的`home`目录（以及文件）移动到新的位置。以下命令将完成这个操作：
- en: '[PRE33]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: In that example, we’re moving the home directory for `jdoe` to `/home/jsmith`,
    and then in the second example, we’re changing the username from `jdoe` to `jsmith`.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们将`jdoe`的主目录移动到`/home/jsmith`，在第二个例子中，我们将用户名从`jdoe`更改为`jsmith`。
- en: 'If you wish to remove a user from a group, you can use the `gpasswd` command
    to do so. `gpasswd -d` will do the trick:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你希望将用户从某个组中移除，可以使用`gpasswd`命令。`gpasswd -d`就可以完成这个操作：
- en: '[PRE34]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'In fact, `gpasswd` can also be used in place of `usermod` to add a user to
    a group:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，`gpasswd`也可以代替`usermod`，将用户添加到组中：
- en: '[PRE35]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: So, now you know how to manage groups. With the efficient management of groups,
    you’ll be able to manage the resources on your server better. Of course, groups
    are relatively useless without some explanation of how to manage permissions (otherwise,
    nothing would actually allow a member of a group access to a resource). Later
    on in this chapter, we’ll cover permissions so that you have a complete understanding
    of how to manage user access.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你已经知道如何管理组了。通过有效地管理组，你将能够更好地管理服务器上的资源。当然，如果不解释如何管理权限，组将相对无用（否则，任何成员都无法访问资源）。在本章稍后的部分，我们将介绍权限管理，以便你能完整了解如何管理用户访问。
- en: Managing passwords and password policies
  id: totrans-214
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 管理密码和密码策略
- en: In this chapter, we’ve already covered a bit of password management, since I’ve
    given you a few examples of the `passwd` command. If you recall, the `passwd`
    command allows us to change the password of the currently logged-in user. In addition,
    using `passwd` as `root` (and supplying a username) allows us to change the password
    for any user account on our system. But that’s not all this command can do.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们已经讲解了一些密码管理的内容，因为我给了你一些`passwd`命令的例子。如果你还记得，`passwd`命令允许我们更改当前登录用户的密码。此外，使用`passwd`命令作为`root`（并提供用户名），我们可以更改系统上任何用户账户的密码。但这并不是这个命令唯一的功能。
- en: Locking and unlocking user accounts
  id: totrans-216
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 锁定和解锁用户账户
- en: 'One thing I’ve neglected to mention regarding the `passwd` command is the fact
    that you can use it to lock and unlock a user’s account. There are many reasons
    why you may want to do this. For instance, if a user is going on vacation or extended
    leave, perhaps you’d want to lock their account so that it cannot be used while
    they are away. After all, the fewer active accounts, the smaller your attack surface.
    To lock an account, use the `-l` option:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 我之前没有提到的关于`passwd`命令的一件事是，你可以用它来锁定和解锁用户账户。有许多原因可能需要这么做。例如，如果一个用户要去度假或休长假，你可能想要锁定他们的账户，以便他们不在外出期间使用它。毕竟，活跃账户越少，你的攻击面就越小。要锁定账户，使用`-l`选项：
- en: '[PRE36]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'And to unlock it, use the `-u` option:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 要解锁账户，可以使用`-u`选项：
- en: '[PRE37]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: However, locking an account will not prevent the user from logging in if they
    have access to the server via SSH while utilizing public key authentication. In
    that case, you’d want to remove their ability to use SSH as well. One common way
    of doing this is to limit SSH access to users who are members of a specific group.
    When you lock an account, simply remove them from the group. Don’t worry so much
    about the SSH portion of this discussion if this is new to you. We will discuss
    securing your SSH server in *Chapter 21*, *Securing Your Server*. For now, just
    keep in mind that you can use `passwd` to lock or unlock accounts, and if you
    utilize SSH, you’ll want to lock your users out of that to prevent them from logging
    in.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，锁定账户不会阻止用户登录，如果他们通过 SSH 使用公钥认证访问服务器。在这种情况下，你需要撤销他们使用 SSH 的权限。一种常见的做法是将 SSH
    访问限制为某个特定组的成员。当你锁定账户时，只需将他们从该组中移除。如果你对 SSH 部分不太熟悉，不必过于担心。我们将在 *第 21 章*，*保护你的服务器*
    中讨论如何保障 SSH 服务器的安全。目前只需要记住，你可以使用 `passwd` 来锁定或解锁账户，如果你使用 SSH，你将需要将用户锁定，以防止他们登录。
- en: However, there’s more to password management than the `passwd` command, as we
    can also implement our own policies, such as viewing or adjusting password expiration
    details.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，密码管理不仅仅是 `passwd` 命令，我们还可以实施自己的策略，例如查看或调整密码过期的详细信息。
- en: Setting password expiration information
  id: totrans-223
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 设置密码过期信息
- en: 'Earlier, I mentioned that you can set an expiration date on a user’s password
    (during our discussion on the `/etc/shadow` file). In this section, we’ll go through
    how to actually do that. Specifically, the `chage` command gives us this ability.
    We can use `chage` to alter the expiration period of a user’s password, but it’s
    also a more convenient way of viewing current expiration information than viewing
    the `/etc/shadow` file. With the `-l` option of `chage`, along with providing
    a username, we can see the relevant info:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 之前我提到过，你可以为用户的密码设置过期日期（在我们讨论 `/etc/shadow` 文件时）。在这一节中，我们将介绍如何实际操作。具体来说，`chage`
    命令为我们提供了这个能力。我们可以使用 `chage` 来修改用户密码的过期周期，但它也是比查看 `/etc/shadow` 文件更方便的方式来查看当前的过期信息。通过
    `chage` 的 `-l` 选项，并提供用户名，我们可以看到相关信息：
- en: '[PRE38]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Using `sudo` or `root` is not required to run `chage`. You’re able to view expiration
    information for your own username without needing to escalate permissions. However,
    if you want to view information via `chage` for any user account other than your
    own, you will need to use `sudo`.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `sudo` 或 `root` 并不是运行 `chage` 的必要条件。你可以在不提升权限的情况下查看自己用户名的过期信息。然而，如果你想查看除自己账户以外的任何用户账户的过期信息，你需要使用
    `sudo`。
- en: 'In the example that follows, we can see the output of this command from a sample
    user account:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的示例中，我们可以看到来自一个示例用户账户的命令输出：
- en: '![](img/B18425_02_11.png)'
  id: totrans-228
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B18425_02_11.png)'
- en: 'Figure 2.11: Output from the chage command'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.11：`chage` 命令的输出
- en: In the output, we can see values for the date of expiration, the maximum number
    of days between password changes, and so on. Basically, it’s the same information
    stored in `/etc/shadow` but it’s much easier to read.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 在输出中，我们可以看到有关密码过期日期、密码更改的最大天数等信息。基本上，它包含了存储在 `/etc/shadow` 中的相同信息，但更易于阅读。
- en: If you would like to change this information, `chage` will again be the tool
    of choice. The first example I’ll provide is a very common one. When creating
    user accounts, you’ll certainly want them to change their password when they first
    log in.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你希望更改这些信息，`chage` 将再次是首选工具。下面提供的第一个示例是非常常见的。当创建用户账户时，你肯定希望用户在首次登录时更改密码。
- en: 'Unfortunately, not everyone will be keen on doing so. The `chage` command allows
    you to force a password change for a user when they first log in. Basically, you
    can set their number of days to expiry to `0` as follows:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，并不是每个人都乐意这样做。`chage` 命令允许你强制用户在首次登录时更改密码。基本上，你可以将他们的密码过期天数设置为 `0`，如下所示：
- en: '[PRE39]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'You can see the results of this command immediately if you run `chage -l` again
    against the user account you just modified:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你再次对刚修改过的用户账户运行`chage -l`，你将立即看到该命令的结果：
- en: '[PRE40]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'The output will display information regarding the password change:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 输出将显示有关密码更改的信息：
- en: '![](img/B18425_02_12.png)'
  id: totrans-237
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B18425_02_12.png)'
- en: 'Figure 2.12: The chage command listing a user that has a required password
    change period set'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.12：使用 `chage` 命令列出设置了密码过期周期的用户
- en: 'To set a user account to require a password change after a certain period of
    days, the following will do the trick:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 要设置用户账户在一定天数后强制要求更改密码，以下操作可以实现：
- en: '[PRE41]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: In that example, I’m setting the user account to expire and require a password
    change in 90 days. When the impending date reaches 7 days before the password
    is to be changed, the user will see a warning message when they log in.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我将用户账户设置为在 90 天后过期并要求更改密码。当即将到达密码更改日期前 7 天时，用户登录时将看到一条警告信息。
- en: 'As I mentioned earlier, users will often do whatever they can to cheat password
    requirements and may try to change their password back to what it was originally
    after satisfying the initially required password change. You can set the minimum
    number of days with the `-m` flag, as you can see in the next example where we
    set it to 5 days:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 如我之前提到的，用户通常会尽可能地绕过密码要求，可能在满足初始密码更改要求后，再把密码改回原来的密码。你可以使用 `-m` 参数设置最小天数，如下例所示，我们将其设置为
    5 天：
- en: '[PRE42]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: The trick with setting a minimum password age is to set it so that it will be
    inconvenient for the user to change their password to the original one, but you
    still want a user to be able to change their password when they feel the need
    to (so don’t set it too long, either). If a user wants to change their password
    before the minimum number of days elapses (for example, if your user feels that
    their account may have been compromised), they can always have you change it for
    them. However, if you make your password requirements too much of an inconvenience
    for your users, it can also work against you.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 设置最小密码年龄的诀窍是，将其设置为用户修改密码回原密码时感到不方便，但你仍然希望用户在需要时能够更改密码（因此也不要设置得太长）。如果用户想在最小天数还没到之前更改密码（例如，如果用户觉得他们的账户可能已经被泄露），他们可以随时让你为他们更改密码。然而，如果你让密码要求对用户来说过于不便，也可能会适得其反。
- en: Setting a password policy
  id: totrans-245
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 设置密码策略
- en: Next, we should discuss setting a password policy. After all, forcing your users
    to change their passwords does little good if they change it to something simple,
    such as `abc123`. A password policy allows you to force requirements on your users
    for things such as length, complexity, and so on.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们应该讨论如何设置密码策略。毕竟，如果用户将密码更改为简单的密码（如 `abc123`），强制用户更改密码也没有多大意义。密码策略允许你强制用户遵守一些要求，例如密码长度、复杂性等。
- en: To facilitate this, we have **Pluggable Authentication Module** (**PAM**) at
    our disposal. PAM gives us additional functionality and control over the process
    of authentication, and also provides additional plugins we can use to extend authentication
    and add additional features. Although a full walkthrough of PAM isn’t covered
    in this book, I recommend keeping it fresh in your mind in case you want to add
    additional features later.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 为了方便，我们可以使用 **Pluggable Authentication Module**（**PAM**）。PAM 为我们提供了额外的认证功能，并且提供了我们可以使用的额外插件，扩展认证并添加更多功能。虽然本书没有详细讲解
    PAM，但我建议你保持对它的记忆，以防你以后想添加更多的功能。
- en: 'Specific to the subject of setting up a password policy, we can install a PAM
    module to enable this, which involves installing a new package:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 针对设置密码策略的主题，我们可以安装一个 PAM 模块来启用这个功能，这需要安装一个新的软件包：
- en: '[PRE43]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Next, let’s take a look at the following file, which is provided with Ubuntu.
    Feel free to open it with a text editor, such as `nano`, as we’ll need to edit
    it:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们看看以下文件，这是 Ubuntu 提供的。你可以使用文本编辑器（如 `nano`）打开它，我们需要对其进行编辑：
- en: '[PRE44]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: An extremely important tip while modifying configuration files related to authentication
    (such as password requirements, `sudo` access, SSH, and so on) is to always keep
    a `root` shell open at all times while you make changes, and in another shell,
    test those changes. Do not log out of your initial `root` window until you are
    100% certain that your changes have been thoroughly tested. While testing a policy,
    make sure that not only can your users log in, but your admins too. Otherwise,
    you may remove your ability to log in to a server and make changes.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 在修改与认证相关的配置文件（如密码要求、`sudo` 权限、SSH 等）时，一个非常重要的提示是，在进行更改时，始终保持一个 `root` shell
    开放，并在另一个 shell 中测试这些更改。在你完全确认更改已经过充分测试之前，不要退出最初的 `root` 窗口。在测试策略时，确保不仅用户能够登录，管理员也能登录。否则，你可能会失去登录服务器并进行更改的能力。
- en: 'To enable a history requirement for your passwords (meaning the system remembers
    the last several passwords a user has used, preventing them from reusing them),
    we can add the following line to the file:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 要启用密码历史要求（即系统记住用户使用过的最后几个密码，防止他们重复使用），我们可以在文件中添加以下行：
- en: '[PRE45]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: In the example `config` line, I’m using `remember=99`, which (as you can probably
    guess) will cause our system to remember the last 99 passwords for each user and
    prevent them from using those passwords again. If you’ve configured a minimum
    password age earlier, for example, 5 days, it would take the user 495 days to
    cycle back to their original password if you take into account that the user changes
    their password once every 5 days, 99 times. That pretty much makes it impossible
    for the user to utilize their old passwords.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 在示例的 `config` 行中，我使用了 `remember=99`，这（你可能猜到）将使我们的系统记住每个用户的最后 99 个密码，并防止他们再次使用这些密码。如果你之前配置了密码的最小使用期限，例如
    5 天，那么如果考虑到用户每 5 天更改一次密码 99 次，用户将需要 495 天才能返回到他们的原密码。这几乎不可能让用户重新使用他们的旧密码。
- en: Another field worth mentioning within the `/etc/pam.d/common-password` file
    is the section that reads `difok=3`. This configuration mandates that at least
    three characters have to be different before the password is considered acceptable.
    Otherwise, the password would be deemed too similar to the old one and refused.
    You can change this value to whatever you like; the default is normally `5` but
    Ubuntu defaults it to `3` in their implementation of this config file. In addition,
    you’ll also see `obscure` mentioned in the file as well, which prevents simple
    passwords from being used (such as common dictionary words and so on).
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `/etc/pam.d/common-password` 文件中，另一个值得提及的部分是读取 `difok=3` 的配置项。此配置要求密码必须至少有三个字符与旧密码不同，才能被视为可接受。否则，密码会被认为与旧密码过于相似而被拒绝。你可以将此值更改为任何你喜欢的数字；默认值通常是
    `5`，但在 Ubuntu 中，它将其默认设置为 `3`。此外，文件中还会看到 `obscure` 配置项，它防止使用简单密码（如常见的字典词汇等）。
- en: Setting a password policy is a great practice to increase the security of your
    server. However, it’s also important to not get carried away. In order to strike
    a balance between security and user frustration, the challenge is always to create
    enough restrictions to increase your security, while trying to minimize the frustration
    of your users. Of course, the mere mention of the word “password” to a typical
    user is enough to frustrate them, so you can’t please everyone. But in terms of
    overall system security, I’m sure your users will appreciate the fact that they
    can be reasonably sure that you as an administrator have taken the necessary precautions
    to keep their (and your company’s) data safe. When it comes down to it, use your
    best judgment.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 设置密码策略是提高服务器安全性的一个好方法。然而，同样重要的是不要过度限制。为了在安全性和用户挫败感之间找到平衡，挑战在于制定足够的限制来提高安全性，同时尽量减少用户的挫败感。当然，单单提到“密码”这个词就足以让普通用户感到沮丧，所以你不可能让每个人都满意。但从整体系统安全的角度来看，我相信你的用户会感激你作为管理员已经采取了必要的预防措施，以确保他们（以及你们公司的）数据安全。最终，还是要用你最好的判断。
- en: Since we’re on the subject of security, we should also take a look at configuring
    `sudo` itself, which we’ll take care of in the next section.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们已经讨论了安全性问题，那么也应该看看如何配置 `sudo` 本身，这将在下一节中进行处理。
- en: Configuring administrator access with sudo
  id: totrans-259
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 配置管理员访问权限使用 `sudo`
- en: By now, we’ve already used `sudo` quite a few times in this book. At this point,
    you should already be aware of the fact that `sudo` allows you to execute commands
    as if you were logged in as another user, with `root` being the default. However,
    we haven’t had any formal discussion about it yet, nor have we discussed how to
    actually modify which of your user accounts are able to utilize `sudo`.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经在本书中使用了很多次 `sudo`。此时，你应该已经意识到 `sudo` 允许你以其他用户的身份执行命令，默认情况下是 `root`
    用户。然而，我们还没有正式讨论过它，也没有讨论如何修改哪些用户账户能够使用 `sudo`。
- en: On all Linux systems, you should protect your `root` account with a strong password
    and limit it to being used by as few people as possible. On Ubuntu, the `root`
    account is locked anyway, so unless you unlocked it by setting a password (or
    you’re using a version of Ubuntu supplied by a VPS provider), it cannot be used
    to log in to the system. Using `sudo` is an alternative to logging in as `root`
    to execute commands directly, so you can give your administrators access to perform
    tasks that require `root` privileges with `sudo` without actually giving them
    your `root` password or unlocking the `root` account. In fact, `sudo` allows you
    to be a bit more granular. Using `root` directly is basically all or nothing—if
    someone knows the `root` password and the `root` account is enabled, that person
    is not limited and can do whatever they want. With `sudo`, that can also be true,
    but you can actually restrict some users to use only particular commands and therefore
    limit the scope of what they are able to do on the system. For example, you could
    give an admin access to install software updates but not allow them to reboot
    the server.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 在所有 Linux 系统中，你应该用强密码保护你的 `root` 账户，并将其限制为尽可能少的人使用。在 Ubuntu 中，`root` 账户默认是锁定的，所以除非你通过设置密码解锁了它（或者你使用的是由
    VPS 提供商提供的 Ubuntu 版本），否则无法用它登录系统。使用 `sudo` 是一种替代直接以 `root` 用户身份登录执行命令的方法，因此你可以通过
    `sudo` 给管理员提供执行需要 `root` 权限的任务的权限，而不需要给他们 `root` 密码或解锁 `root` 账户。事实上，`sudo` 让你可以更加精细化管理。直接使用
    `root` 基本上就是全有或全无——如果有人知道 `root` 密码并且 `root` 账户已启用，那么此人没有任何限制，可以随意操作。而使用 `sudo`
    时，也可以出现类似情况，但你实际上可以限制某些用户只能使用特定的命令，从而限制他们在系统中能做的事情。例如，你可以给管理员提供安装软件更新的权限，但不允许他们重启服务器。
- en: 'By default, members of the `sudo` group are able to use `sudo` without any
    restrictions. Basically, members of this group can do anything `root` can do (which
    is everything). During installation, the user account you created was made a member
    of `sudo`. To give additional users access to `sudo`, all you would need to do
    is add them to the `sudo` group:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，`sudo` 组的成员可以不受限制地使用 `sudo`。基本上，这个组的成员可以做任何 `root` 能做的事情（也就是一切）。在安装过程中，你创建的用户帐户已成为
    `sudo` 组的成员。要为其他用户提供 `sudo` 权限，你只需要将他们添加到 `sudo` 组即可：
- en: '[PRE46]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: Not all distributions utilize the `sudo` group by default, or even automatically
    install `sudo`. Other distributions require you to install `sudo` manually and
    may use another group (such as `wheel`) to govern access to `sudo`.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 并非所有发行版默认使用 `sudo` 组，甚至有的不会自动安装 `sudo`。其他发行版需要你手动安装 `sudo`，并且可能使用另一个组（如 `wheel`）来管理对
    `sudo` 的访问。
- en: But again, that gives those users access to everything, and that may or may
    not be what you want. To actually configure `sudo`, we use the `visudo` command.
    This command assists you with editing `/etc/sudoers`, which is the configuration
    file that governs `sudo` access. Although you can edit `/etc/sudoers` yourself
    with a text editor, configuring `sudo` in that way is strongly discouraged. The
    `visudo` command checks to make sure your changes follow the correct syntax and
    helps prevent you from accidentally destroying the file. This is a very good approach,
    because if you did make any errors in the `/etc/sudoers` file, you may wind up
    in a situation where no one is able to gain administrative control over the server.
    And while there are ways to recover from such a mistake, it’s certainly not a
    very pleasant situation to find yourself in! So, the takeaway here is never to
    edit the `/etc/sudoers` file directly; always use `visudo` to do so.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 但再说一次，这样会给予那些用户一切权限，而这可能是你想要的，也可能不是。要实际配置 `sudo`，我们使用 `visudo` 命令。这个命令帮助你编辑
    `/etc/sudoers` 文件，这是一个控制 `sudo` 访问的配置文件。虽然你可以用文本编辑器直接编辑 `/etc/sudoers`，但强烈不建议用这种方式配置
    `sudo`。`visudo` 命令会检查你的修改是否遵循正确的语法，并帮助防止你不小心破坏文件。这是一个非常好的方法，因为如果你在 `/etc/sudoers`
    文件中犯了错误，可能会导致没有人能够获得服务器的管理员控制权。虽然有办法从这样的错误中恢复，但显然，这并不是一个你想要面对的局面！所以，这里要记住的一点是，永远不要直接编辑
    `/etc/sudoers` 文件；始终使用 `visudo` 来编辑它。
- en: 'Here’s an example of the type of warning the `visudo` command shows when you
    make a mistake:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是 `visudo` 命令在你犯错误时显示的警告类型的示例：
- en: '![](img/B18425_02_13.png)'
  id: totrans-267
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B18425_02_13.png)'
- en: 'Figure 2.13: The visudo command showing an error'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.13：`visudo` 命令显示错误
- en: If you do see this error, press *e* to return to edit the file, and then correct
    the mistake.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你看到这个错误，按 *e* 返回编辑文件，然后纠正错误。
- en: The way this works is when you run `visudo` from your shell, you are brought
    into a text editor with the `/etc/sudoers` file opened up. You can then make changes
    to the file and save it like you would any other text file. By default, Ubuntu
    opens up the `nano` text editor when you use `visudo`. With `nano`, you can save
    changes using *Ctrl* + *w*, and you can exit the text editor with *Ctrl* + *x*.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 这个过程的工作方式是，当你在终端运行`visudo`时，它会将你带入一个文本编辑器，并打开`/etc/sudoers`文件。然后，你可以像编辑其他文本文件一样，修改并保存文件。默认情况下，Ubuntu在使用`visudo`时会打开`nano`文本编辑器。在`nano`中，你可以使用*Ctrl*
    + *w*保存更改，使用*Ctrl* + *x*退出文本编辑器。
- en: 'So `visudo` allows you to make changes to who is able to access `sudo`. But
    how do you actually make these changes? Go ahead and scroll through the `/etc/sudoers`
    file that `visudo` opens and you should see a line similar to the following:'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，`visudo`允许你更改谁能够访问`sudo`。但你究竟如何进行这些更改呢？你可以滚动浏览`visudo`打开的`/etc/sudoers`文件，你应该能看到类似以下的行：
- en: '[PRE47]'
  id: totrans-272
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: This is the line of configuration that enables `sudo` access to anyone who is
    a member of the `sudo` group. You can change the group name to any that you’d
    like, for example, perhaps you’d like to create a group called `admins` instead.
    If you do change this, make sure that you actually create that group and add yourself
    and your staff to be members of it before you edit the `/etc/sudoers` file or
    log off; it would be rather embarrassing if you found yourself locked out of administrator
    access to the server.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 这是启用任何属于`sudo`组的成员访问`sudo`权限的配置行。你可以将组名更改为你喜欢的任何名称，例如，你可能希望创建一个名为`admins`的组。如果你做了这个更改，确保在编辑`/etc/sudoers`文件或注销之前，实际上已经创建了该组，并将你自己和你的团队添加为该组的成员；如果你发现自己被锁定，无法访问服务器的管理员权限，那可就尴尬了。
- en: 'Of course, you don’t have to enable access by group. You can actually call
    out a username instead. With the `/etc/sudoers` file, groups are preceded by `%`,
    while users are not. As an example of this, we also have the following line in
    the file:'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，你不必通过组来启用访问权限。你实际上也可以指定一个用户名。在`/etc/sudoers`文件中，组名前会有一个`%`符号，而用户名则没有。例如，文件中也有如下行：
- en: '[PRE48]'
  id: totrans-275
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: Here, we’re calling out a username (in this case, `root`), but the rest of the
    line is the same as the one I pointed out before. While you can certainly copy
    this line and paste it one or more times (substituting `root` for a different
    username) to grant access to others, using the group approach is really the best
    way. It’s easier to add and remove users from a group (such as the `sudo` group)
    than it is to use `visudo` each time.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，我们调用了一个用户名（在这个例子中是`root`），但这一行的其他部分和我之前提到的行是一样的。虽然你当然可以复制这一行并粘贴一遍或多遍（将`root`替换为其他用户名），以授予其他人访问权限，但使用组的方式实际上是最好的方法。将用户添加或移出一个组（如`sudo`组）要比每次使用`visudo`要容易得多。
- en: So, at this point, you’re probably wondering what the options on `/etc/sudoers`
    configuration lines actually mean. So far, both examples used `ALL=(ALL:ALL) All`.
    In order to fully understand `sudo`, understanding the other fields is extremely
    important, so let’s go through them (using the `root` line again as an example).
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 到此为止，你可能在想，`/etc/sudoers`配置行上的各个选项到底是什么意思。目前为止，两个例子都使用了`ALL=(ALL:ALL) All`。为了完全理解`sudo`，理解其他字段非常重要，所以让我们通过它们（再次使用`root`这一行作为例子）来逐一了解。
- en: The first `ALL` means that `root` is able to use `sudo` from any terminal. The
    second `ALL` means that `root` can use `sudo` to impersonate any other user. The
    third `ALL` means that `root` can impersonate any other group. Finally, the last
    `ALL` refers to what commands this user is able to use; in this case, any command
    they wish.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个`ALL`表示`root`可以从任何终端使用`sudo`。第二个`ALL`表示`root`可以使用`sudo`冒充任何其他用户。第三个`ALL`表示`root`可以冒充任何其他组。最后一个`ALL`表示该用户能够使用的命令；在这种情况下，是他们想使用的任何命令。
- en: 'To help drive this home, I’ll give some additional examples. Here’s a hypothetical
    example:'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 为了帮助理解，我将提供一些额外的示例。这里有一个假设的例子：
- en: '[PRE49]'
  id: totrans-280
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Here, we’re allowing user `charlie` to execute the `reboot` and `shutdown`
    commands. If user `charlie` tries to do something else (such as install a package),
    they will receive an error message:'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们允许用户`charlie`执行`reboot`和`shutdown`命令。如果用户`charlie`尝试做其他事情（例如安装软件包），他们将收到错误信息：
- en: '[PRE50]'
  id: totrans-282
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'However, if `charlie` wants to use the `reboot` or `shutdown` commands on the
    server, they will be able to do so because we explicitly called out those commands
    while setting up this user’s `sudo` access. We can limit this further by changing
    the first `ALL` to a machine name, in this case, `ubuntu`, to reference the host
    name of the server I’m using for my examples. I’ve also changed the command that
    `charlie` is allowed to run:'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果`charlie`想要在服务器上使用`reboot`或`shutdown`命令，他们将能够执行这些操作，因为我们在为该用户设置`sudo`权限时明确指定了这些命令。我们可以进一步限制，通过将第一个`ALL`改为机器名称，在本例中为`ubuntu`，来引用我在示例中使用的服务器主机名。我还修改了`charlie`被允许执行的命令：
- en: '[PRE51]'
  id: totrans-284
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: It’s always a good idea to use full paths to commands when editing `sudo` permissions,
    rather than the shortened versions. For example, we used `/usr/bin/apt` here,
    instead of just `apt`. This is important, as the user could create a script named
    `apt` to do mischievous things that we normally wouldn’t allow them to do. By
    using the full path, we’re limiting the user to the binary stored at that path.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 在编辑`sudo`权限时，最好使用命令的完整路径，而不是简化版本。例如，我们在这里使用了`/usr/bin/apt`，而不是仅仅使用`apt`。这是非常重要的，因为用户可以创建一个名为`apt`的脚本，做一些我们通常不允许他们做的恶意行为。通过使用完整路径，我们限制了用户只能使用该路径下存储的二进制文件。
- en: Now, `charlie` is only able to use `apt`. They can use `apt update`, `apt dist-upgrade`,
    and any other sub-command of `apt`. But if they try to reboot the server, remove
    protected files, add users, or anything else we haven’t explicitly set, they will
    be prevented from doing so.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，`charlie`只能使用`apt`。他们可以使用`apt update`、`apt dist-upgrade`以及`apt`的任何其他子命令。但如果他们尝试重启服务器、删除受保护的文件、添加用户，或者做其他我们未明确设置的操作，他们将被阻止。
- en: 'We have another problem, though. We’re allowing `charlie` to impersonate other
    users. This may not be completely terrible given the context of installing packages
    (impersonating another user would be useless unless that user also has access
    to install packages), but it’s bad form to allow this unless we really need to.
    In this case, we could just remove the `(ALL:ALL)` from the line altogether to
    prevent `charlie` from using the `-u` option of `sudo` to run commands as other
    users:'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，我们遇到了另一个问题。我们正在允许`charlie`模拟其他用户。鉴于安装软件包的上下文，这可能并不完全糟糕（模拟另一个用户在没有权限安装软件包的情况下是没有意义的），但除非我们确实需要这样做，否则允许这种行为是不合适的。在这种情况下，我们可以完全删除这一行中的`(ALL:ALL)`，从而防止`charlie`使用`sudo`的`-u`选项以其他用户身份运行命令：
- en: '[PRE52]'
  id: totrans-288
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'On the other hand, if we actually do want `charlie` to be able to impersonate
    other users (but only specific users), we can call out the username and group
    that `charlie` is allowed to act on behalf of by setting those values:'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，如果我们确实希望`charlie`能够模拟其他用户（但仅限于特定用户），我们可以通过设置这些值来指定`charlie`被允许代表的用户名和组：
- en: '[PRE53]'
  id: totrans-290
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: In that example, `charlie` is able to run commands on behalf of the user `dscully`
    and the group `admins`.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，`charlie`能够代表用户`dscully`和组`admins`运行命令。
- en: Of course, there is much more to `sudo` than what I’ve mentioned in this section.
    Entire books could be written about `sudo` (and have been), but 99% of what you
    will need for your daily management of this tool involves how to add access to
    users while being specific about what each user is able to do. As a best practice,
    use groups when you can (for example, you could have an `apt` group, a `reboot`
    group, and so on) and be as specific as you can regarding who is able to do what.
    This way, you’re not only able to keep the `root` account private (or even better,
    disabled), but you also have more accountability on your servers.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，`sudo`远远不止我在这一节中提到的内容。关于`sudo`可以写出整本书（事实上，已经有很多了），但你在日常管理这款工具时，99%的需求都涉及如何为用户添加访问权限，并明确规定每个用户能够做什么。作为最佳实践，尽可能使用组（例如，你可以有一个`apt`组、一个`reboot`组等等），并尽量具体地规定谁能做什么。通过这种方式，你不仅可以保持`root`账户的私密性（或者更好的是禁用它），还可以提高服务器的责任性。
- en: Now that we’ve explored granting access to `sudo`, we will next take a look
    at permissions, which give us even more control over what our users are able to
    access.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经探索了如何授予`sudo`访问权限，接下来我们将看看权限设置，它让我们对用户能够访问的内容有更高的控制权。
- en: Setting permissions on files and directories
  id: totrans-294
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置文件和目录的权限
- en: In this section, all the user management we’ve done in this chapter so far all
    comes together. We’ve learned how to add accounts, manage accounts, and secure
    them, but we haven’t actually done any work regarding managing the resources as
    far as who is able to access them. In this section, I’ll give you a brief overview
    of how permissions work in Ubuntu Server and then I’ll provide some examples for
    customizing them.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们之前在本章所做的所有用户管理工作都将汇聚在一起。我们已经学会了如何添加帐户、管理帐户并保护它们，但我们实际上还没有处理有关谁能够访问这些资源的管理工作。在本节中，我将简要概述
    Ubuntu Server 中权限的工作原理，然后提供一些自定义权限的示例。
- en: Viewing permissions
  id: totrans-296
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 查看权限
- en: 'I’m sure by now that you understand how to list the contents of a directory
    with the `ls` command. When it comes to viewing permissions, the `-l` flag is
    especially handy, as the output that the long listing provides allows us to view
    the permissions of an object:'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 我相信到现在你已经明白如何使用`ls`命令列出目录的内容。谈到查看权限时，`-l`标志特别有用，因为长格式列出的输出可以让我们查看对象的权限：
- en: '[PRE54]'
  id: totrans-298
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'The following are some example, hypothetical file listings:'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一些示例性的假设文件列表：
- en: '[PRE55]'
  id: totrans-300
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: In each line, we see several fields of information. The first column is our
    permission string for the object (for example, `-rw-r—r--`), which we’ll cover
    in more detail shortly. We also see the link count for the object (second column).
    Links are beyond the scope of this chapter but will be discussed in *Chapter 5*,
    *Managing Files and Directories*. Continuing on, the user that owns the file is
    displayed in the third column, the group that owns the file is in the fourth column,
    the size in bytes is in the fifth, the last date the file was modified is in the
    sixth, and finally there is the name of the file.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 在每一行中，我们可以看到几个信息字段。第一列是对象的权限字符串（例如，`-rw-r—r--`），稍后我们会更详细地讲解。我们还可以看到对象的链接数（第二列）。链接超出了本章的范围，但将在*第五章*、*管理文件和目录*中讨论。接着，文件的拥有者显示在第三列，文件所属的组显示在第四列，大小（以字节为单位）显示在第五列，文件最后修改的日期显示在第六列，最后是文件的名称。
- en: Keep in mind that depending on how your shell is configured, your output may
    look different and the fields may be in different places. For the sake of our
    discussion on permissions, what we’re really concerned with is the permissions
    string, as well as the owning user and group. In this case, we can see that the
    first file (named `welcome`) is owned by a user named `doctor`. The second file
    is named `profile` and is owned by `root`. Finally, we have a file named `exterminate`
    owned by a user named `dalek`.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，根据你的 shell 配置，输出可能会有所不同，字段可能位于不同的位置。为了讨论权限，我们真正关注的是权限字符串，以及拥有者用户和组。在本例中，我们可以看到第一个文件（名为`welcome`）由名为`doctor`的用户拥有。第二个文件名为`profile`，由`root`拥有。最后，我们有一个名为`exterminate`的文件，拥有者是名为`dalek`的用户。
- en: 'With these files, we have the permission strings of `-rw-rw-rw-`, `-rw-r--r--`,
    and `-rwxr-xr-x` respectively. If you haven’t worked with permissions before,
    these may seem strange, but it’s actually quite easy when you break them down.
    Each permission string can be broken down into four groups, as I’ll show you in
    the following table:'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这些文件，我们有`-rw-rw-rw-`、`-rw-r--r--`和`-rwxr-xr-x`的权限字符串。如果你以前没有接触过权限，它们可能看起来很陌生，但其实当你把它们拆解开来时，理解起来非常简单。每个权限字符串可以分解为四个部分，如下表所示：
- en: '| **Object type** | **User** | **Group** | **World** |'
  id: totrans-304
  prefs: []
  type: TYPE_TB
  zh: '| **对象类型** | **用户** | **组** | **世界** |'
- en: '| - | `rw-` | `rw-` | `rw-` |'
  id: totrans-305
  prefs: []
  type: TYPE_TB
  zh: '| - | `rw-` | `rw-` | `rw-` |'
- en: '| - | `rw-` | `r--` | `r--` |'
  id: totrans-306
  prefs: []
  type: TYPE_TB
  zh: '| - | `rw-` | `r--` | `r--` |'
- en: '| - | `rwx` | `rwx` | `r-x` |'
  id: totrans-307
  prefs: []
  type: TYPE_TB
  zh: '| - | `rwx` | `rwx` | `r-x` |'
- en: I’ve broken down each of the three example permission strings into four groups.
    Basically, I split them each at the first character and then again every third.
    The first section of a permission string is just one character. In each of these
    examples, it’s just a single hyphen. This refers to what type the object is. Is
    it a directory? A file? A link? In our case, each of these permission strings
    is a file, because the first positions of the permission strings are all hyphens.
    If the object were a directory, the first character would’ve been a `d` instead
    of a `-`. If the object were a link, this field would’ve been `l` (lowercase *L*)
    instead.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 我将每个示例权限字符串分解成了四个组。基本上，我将它们拆分到第一个字符处，然后每三个字符拆分一次。权限字符串的第一部分只有一个字符。在这些示例中，它都是一个破折号。这表示对象的类型是什么。是目录吗？文件吗？链接吗？在我们的例子中，这些权限字符串都是文件，因为权限字符串的第一个位置都是破折号。如果对象是目录，第一个字符应该是`d`，而不是`-`。如果对象是链接，那么该字段应该是`l`（小写字母*L*）。
- en: 'In the next section, in the second column of each object, we have three characters,
    `rw-`, `rw-`, and `rwx` respectively. This refers to the permissions that apply
    to the user that owns the file. For example, here is the first permission string
    again:'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一部分，每个对象的第二列有三个字符，分别是`rw-`、`rw-`和`rwx`。这表示适用于拥有文件的用户的权限。例如，以下是第一个权限字符串：
- en: '[PRE56]'
  id: totrans-310
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: The third section of the preceding code output shows us that `doctor` is the
    user that owns the file. Therefore, referring back to the table, the second column
    of the permission string (`rw-`) applies specifically to the user `doctor`. Moving
    on, the third column of permissions is also three characters; in this case, `rw-`
    again. This section of the permissions string refers to the group that owns the
    file. In this case, the group is also named `doctor`, as you can see in column
    four of the preceding code output. Finally, the last section of the permission
    string, visualized in the table (`rw-` yet again, in this case), refers to `world`,
    also known as *other*. This basically refers to anyone else other than the owning
    user and owning group. Therefore, literally everyone else gets at least `rw-`
    permissions on the object.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码输出的第三部分显示，`doctor`是拥有该文件的用户。因此，回到表格，权限字符串的第二列（`rw-`）特别适用于用户`doctor`。接下来，权限字符串的第三列也有三个字符，在这种情况下是`rw-`。这一部分权限字符串指的是拥有该文件的组。在本例中，该组也叫`doctor`，正如你在前面的代码输出中的第四列看到的那样。最后，权限字符串的最后一部分，在表格中可视化（再次是`rw-`），指的是`world`，也称为*其他*。这基本上指的是除了拥有文件的用户和组以外的任何人。因此，实际上其他每个人对该对象都至少拥有`rw-`权限。
- en: Individually, `r` stands for *read* and `w` stands for *write*. Therefore, we
    can read the second column (`rw-`), indicating that the user (`doctor`) has access
    to read and write to this file. The third column (`rw-` again) tells us the `doctor`
    group also has read and write access to this file. The fourth column of the permission
    string is the same, so anyone else would also have read and write permissions
    to the file as well.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 单独来看，`r`代表*读取*，`w`代表*写入*。因此，我们可以读取第二列（`rw-`），这表示用户（`doctor`）有权限读取和写入该文件。第三列（再次是`rw-`）告诉我们，`doctor`组也有读取和写入该文件的权限。权限字符串的第四列相同，因此其他任何人也会对该文件拥有读取和写入权限。
- en: 'The third permission string I gave as an example looks a bit different. Here
    it is again:'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 我给出的第三个权限字符串看起来有点不同。这里再次展示：
- en: '[PRE57]'
  id: totrans-314
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: Here, we see the `x` attribute set. The `x` attribute refers to the ability
    to execute the file as a script. So, with that in mind, we know that this file
    is likely a script and is executable by users, groups, and others. Given the filename
    of `exterminate`, this is rather suspicious, and if it were a real file, we’d
    probably want to look into it.
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们看到设置了`x`属性。`x`属性表示能够将文件作为脚本执行。因此，考虑到这一点，我们知道该文件可能是一个脚本，可以被用户、组和其他人执行。鉴于文件名为`exterminate`，这有点可疑，如果它是一个真实文件，我们可能需要进一步调查。
- en: 'If a permission is not set, it will simply be a single hyphen where there would
    normally be `r`, `w`, or `x`. This is the same as indicating that a permission
    is disabled. Here are some examples:'
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 如果某个权限未设置，则它会简单地显示为单个破折号，而不是`r`、`w`或`x`。这与表示某个权限被禁用是一样的。以下是一些示例：
- en: '`rwx`: Object has read, write, and execute permissions set for this field'
  id: totrans-317
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`rwx`：对象为该字段设置了读取、写入和执行权限。'
- en: '`r-x`: Object has read enabled, write disabled, and execute enabled for this
    field'
  id: totrans-318
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`r-x`：对象具有启用读取、禁用写入并启用执行权限。'
- en: '`r--`: Object has read enabled, write disabled, and execute disabled for this
    field'
  id: totrans-319
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`r--`: 对象具有读取权限，写入禁用，执行禁用'
- en: '`---`: Object has no permissions enabled for this field'
  id: totrans-320
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`---`: 对象没有启用此字段的任何权限'
- en: 'Bringing this discussion all the way home, here are a few more permission strings:'
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 将这个讨论推向结尾，以下是更多的权限字符串：
- en: '[PRE58]'
  id: totrans-322
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: For the first of these examples, we see that `sue` is the owning user of `budget.txt`
    and that this file is assigned an accounting group. This object is readable and
    writable by `sue` and readable by everyone else (`group` and `world`). This is
    probably bad, considering this is a budget file and is probably confidential.
    We’ll change it later.
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 在这些示例中的第一个，我们看到 `sue` 是 `budget.txt` 的所有用户，并且该文件被分配给一个会计组。该对象对 `sue` 可读可写，对其他所有人（`group`
    和 `world`）也可读。这可能不好，因为这是一个预算文件，可能是机密的。我们稍后会更改它。
- en: 'The `annual_projects` object is a directory, which we can tell from the `d`
    in the first column. This directory is owned by the `bob` user and the `sales`
    group. However, since this is a directory, each of the permission bits has different
    meanings. In the following two tables, I’ll outline the meanings of these bits
    for files and again for directories:'
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: '`annual_projects` 对象是一个目录，我们可以从第一列的 `d` 看出这一点。该目录由 `bob` 用户和 `sales` 组拥有。然而，由于这是一个目录，每个权限位具有不同的含义。在以下两张表中，我将分别列出这些位在文件和目录中的含义：'
- en: 'Files:'
  id: totrans-325
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 文件：
- en: '| **Bit** | **Meaning** |'
  id: totrans-326
  prefs: []
  type: TYPE_TB
  zh: '| **Bit** | **含义** |'
- en: '| `r` | The file can be read |'
  id: totrans-327
  prefs: []
  type: TYPE_TB
  zh: '| `r` | 文件可以被读取 |'
- en: '| `w` | The file can be written to |'
  id: totrans-328
  prefs: []
  type: TYPE_TB
  zh: '| `w` | 文件可以被写入 |'
- en: '| `x` | The file can be executed as a program |'
  id: totrans-329
  prefs: []
  type: TYPE_TB
  zh: '| `x` | 文件可以作为程序执行 |'
- en: 'Directories:'
  id: totrans-330
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 目录：
- en: '| **Bit** | **Meaning** |'
  id: totrans-331
  prefs: []
  type: TYPE_TB
  zh: '| **Bit** | **含义** |'
- en: '| `r` | The contents of the directory can be viewed |'
  id: totrans-332
  prefs: []
  type: TYPE_TB
  zh: '| `r` | 目录内容可以查看 |'
- en: '| `w` | The contents of the directory can be altered |'
  id: totrans-333
  prefs: []
  type: TYPE_TB
  zh: '| `w` | 目录内容可以被更改 |'
- en: '| `x` | The user or group can use `cd` to go inside the directory |'
  id: totrans-334
  prefs: []
  type: TYPE_TB
  zh: '| `x` | 用户或组可以使用 `cd` 进入目录 |'
- en: 'As you can see, permissions are read differently depending on their context:
    whether they apply to a file or a directory. In the example of the `annual_projects`
    directory, `bob` has `rwx` permissions to the directory. This means that the user
    `bob` can do everything (view the contents, add or remove contents, and use `cd`
    to move the current directory of his shell into the directory). Regarding a group,
    members of the `sales` group are able to view the contents of this directory and
    `cd` into it. However, no one in the `sales` group can add or remove items to
    or from the directory. On this object, *other* has no permissions set at all.
    This means that no one else can do anything at all with this object, not even
    view its contents.'
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，权限的读取方式根据其上下文不同而有所不同：它们适用于文件还是目录。在 `annual_projects` 目录的例子中，`bob` 对该目录有
    `rwx` 权限。这意味着用户 `bob` 可以执行所有操作（查看内容、添加或删除内容，以及使用 `cd` 将当前 shell 目录切换到该目录）。对于一个组，`sales`
    组的成员能够查看该目录的内容并进入该目录。然而，`sales` 组中的任何人都无法向目录中添加或删除项目。在该对象上，*其他* 没有设置任何权限。这意味着没有其他人可以对该对象进行任何操作，甚至无法查看其内容。
- en: Changing permissions
  id: totrans-336
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 更改权限
- en: So, now we understand how to read permissions on files and directories. That’s
    great, but how do we alter them? As I mentioned earlier, the `budget.txt` file
    is readable by everyone (*other*). This is not good because the file is confidential.
    To change permissions on an object, we will use the `chmod` command. This command
    allows us to alter the permissions of files and directories in a few different
    ways.
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，现在我们理解了如何读取文件和目录的权限。很好，但我们如何更改它们呢？如前所述，`budget.txt` 文件对所有人（*其他*）都是可读的。这不好，因为该文件是机密的。要更改对象的权限，我们将使用
    `chmod` 命令。该命令允许我们以几种不同的方式更改文件和目录的权限。
- en: 'First, we can simply remove read access from the `sue` user’s budget file by
    removing the read bit from the other field. We can do that with the following
    example:'
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们可以通过从其他字段中移除读取权限来简单地去除 `sue` 用户对预算文件的读取权限。我们可以通过以下示例来实现：
- en: '[PRE59]'
  id: totrans-339
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'If we are currently not in the directory where the file resides, we need to
    give a full path:'
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们当前不在文件所在的目录中，需要提供完整路径：
- en: '[PRE60]'
  id: totrans-341
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: If you’re using the `chmod` command against files other than those you own yourself,
    you’ll need to use `sudo`.
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你对不是自己拥有的文件使用 `chmod` 命令，你需要使用 `sudo`。
- en: 'But either way, you probably get the idea. With this example, we’re removing
    the `r` bit from *other* (`o-r`). If we wanted to add this bit instead, we would
    simply use `+` instead of `-`. Here are some additional examples of `chmod` in
    action:'
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 不管怎样，你应该已经理解了。以这个示例为例，我们将从*other*（`o-r`）移除`r`权限位。如果我们想要添加这个权限位，我们只需要用`+`代替`-`。以下是一些`chmod`实际应用的额外示例：
- en: '`chmod u+rw <filename>`: The object gets `rw` added to the `user` column'
  id: totrans-344
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`chmod u+rw <filename>`：该对象在`user`列中添加了`rw`权限'
- en: '`chmod g+r <filename>`: The owning group is given read access'
  id: totrans-345
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`chmod g+r <filename>`：拥有组被赋予读取权限'
- en: '`chmod o-rw <filename>`: *Other* is stripped of the `rw` bits'
  id: totrans-346
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`chmod o-rw <filename>`：*Other*移除`rw`权限位'
- en: 'In addition, you can also use octal point values to manage and modify permissions.
    This is actually the most common method of altering permissions. I like to think
    of this as a scoring system. That’s not what it is, but it makes it a lot easier
    to understand to think of each type of access as having its own value. Basically,
    each of the permission bits (`r`, `w`, and `x`) has its own octal equivalent,
    as follows:'
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，你还可以使用八进制值来管理和修改权限。这实际上是更改权限的最常用方法。我喜欢将其看作一个评分系统。虽然它并非真正的评分系统，但将每种访问类型看作有自己价值的方式，更容易理解。基本上，每个权限位（`r`、`w`
    和 `x`）都有其对应的八进制值，如下所示：
- en: 'Read: `4`'
  id: totrans-348
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 读取：`4`
- en: 'Write: `2`'
  id: totrans-349
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 写入：`2`
- en: 'Execute: `1`'
  id: totrans-350
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 执行：`1`
- en: 'With this style, there are only a few possibilities for numbers you can achieve
    when combining these octal values (each can only be used once). Therefore, we
    can get `0`, `1`, `2`, `3`, `4`, `5`, `6`, and `7` by adding (or not adding) these
    numbers in different combinations. Some of them you’ll almost never see, such
    as an object having write access but not read. For the most part, you’ll see `0`,
    `4`, `5`, `6`, and `7` used with `chmod` most often. For example, if we add `Read`
    and `Write`, we get `6`. If we add `Read` and `Execute`, we get `5`. If we add
    all three, we get `7`. If we add no permissions, we get `0`. We repeat this for
    each column (`User`, `Group`, and `Other`) to come up with a string of three numbers.
    Here are some examples:'
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这种风格时，结合这些八进制值时，你能得到的数字组合不多（每个值只能使用一次）。因此，我们可以通过以不同的组合添加（或不添加）这些数字来得到`0`、`1`、`2`、`3`、`4`、`5`、`6`和`7`。其中一些你几乎永远不会看到，比如一个对象有写入权限但没有读取权限。大多数情况下，你会看到`0`、`4`、`5`、`6`和`7`最常用与`chmod`。例如，如果我们将`读取`和`写入`加起来，我们得到`6`。如果我们将`读取`和`执行`加起来，我们得到`5`。如果我们将三者都加起来，我们得到`7`。如果我们不加任何权限，我们得到`0`。我们为每一列（`User`、`Group`和`Other`）重复这个过程，得出一个三位数的字符串。以下是一些示例：
- en: '`600`: `User` has read and write (4+2). No other permissions are set.'
  id: totrans-352
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`600`：`User`拥有读取和写入权限（4+2）。没有其他权限被设置。'
- en: This is the same as `-rw-------`.
  id: totrans-353
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这与`-rw-------`是相同的。
- en: '`740`: `User` has read, write, and execute. `Group` has read. `Other` has nothing.'
  id: totrans-354
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`740`：`User`拥有读取、写入和执行权限。`Group`拥有读取权限。`Other`没有任何权限。'
- en: This is the same as `-rwxr-----`.
  id: totrans-355
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这与`-rwxr-----`是相同的。
- en: '`770`: Both `User` and `Group` have full access (read, write, and execute).
    `Other` has nothing.'
  id: totrans-356
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`770`：`User`和`Group`都拥有完全的访问权限（读取、写入和执行）。`Other`没有任何权限。'
- en: This is the same as `-rwxrwx---`.
  id: totrans-357
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这与`-rwxrwx---`是相同的。
- en: '`777`: Everyone has everything.'
  id: totrans-358
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`777`：每个人都有所有权限。'
- en: This is the same as `-rwxrwxrwx`.
  id: totrans-359
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这与`-rwxrwxrwx`是相同的。
- en: 'Going back to `chmod`, we can use this numbering system in practice:'
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 回到`chmod`，我们可以在实践中使用这种编号系统：
- en: '`chmod 600 filename.txt`'
  id: totrans-361
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`chmod 600 filename.txt`'
- en: '`chmod 740 filename.txt`'
  id: totrans-362
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`chmod 740 filename.txt`'
- en: '`chmod 770 filename.txt`'
  id: totrans-363
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`chmod 770 filename.txt`'
- en: 'Hopefully you get the idea. If you wanted to change the permissions of a directory,
    the `-R` option may be helpful to you. This makes the changes recursive, meaning
    that you’ll not only make the changes to the directory but also to all files and
    directories underneath it in one shot:'
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: 希望你能理解。如果你想更改一个目录的权限，`-R`选项可能会对你有帮助。它使更改具有递归性，这意味着你不仅会更改该目录的权限，还会一次性更改它下面所有文件和子目录的权限：
- en: '[PRE61]'
  id: totrans-365
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'While using `-R` with `chmod` can save you some time, it can also cause trouble
    if you have a mix of directories and files underneath the directory you’re changing
    permissions on. The previous example gives permissions `770` to `mydir` and all
    of its contents. If there are files inside, they are now given executable permissions
    to the user and group, since `7` includes the execute bit (value of `1`). This
    may not be what you want. We can use the `find` command to differentiate these.
    While `find` is out of the scope of this chapter, it should be relatively simple
    to see what the following commands are doing and how they may be useful:'
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然使用`-R`选项配合`chmod`可以节省一些时间，但如果你在更改权限的目录下有文件和子目录混合的情况，它也可能引发问题。前面的例子将权限`770`授予`mydir`及其所有内容。如果目录内有文件，这些文件将被赋予可执行权限给用户和组，因为`7`包括了执行位（值为`1`）。这可能不是你想要的效果。我们可以使用`find`命令来区分这些情况。虽然`find`命令超出了本章内容的范围，但通过以下命令的使用，应该能相对简单地理解它们的功能，以及它们如何有用：
- en: '[PRE62]'
  id: totrans-367
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: Basically, in the first example, the `find` command is locating all files (`-type
    f`) in `/path/to/dir/` and everything it finds, it executes `chmod 644` against.
    The second example is locating all directories in this same path and changing
    them all to permission `755`. The `find` command isn’t covered in detail here
    because it easily deserves a chapter of its own, but I’m including it here because
    hopefully these examples are useful and will be handy for you to include in your
    own list of useful commands.
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: 基本上，在第一个例子中，`find`命令定位到`/path/to/dir/`路径下的所有文件（`-type f`），并对其执行`chmod 644`操作。第二个例子是定位该路径下的所有目录，并将它们的权限更改为`755`。这里没有详细介绍`find`命令，因为它很容易成为一章内容，但我将其包含在此，因为希望这些示例能对你有所帮助，并成为你自己有用命令列表中的一部分。
- en: Changing the ownership of objects
  id: totrans-369
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 更改对象的所有权
- en: 'Finally, we’ll need to know how to change the ownership of files and directories.
    It’s often the case that a particular user needs to gain access to an object,
    or perhaps we need to change the owning group as well. We can change user and
    group ownership of a file or directory with the `chown` command. As an example,
    if we wanted to change the owner of a file to `sue`, we could do the following:'
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们需要知道如何更改文件和目录的所有权。通常情况下，某个特定的用户可能需要访问某个对象，或者我们可能需要更改所有组。我们可以使用`chown`命令来更改文件或目录的用户和组所有权。例如，如果我们希望将文件的所有者更改为`sue`，我们可以执行以下命令：
- en: '[PRE63]'
  id: totrans-371
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'In the case of a directory, we can also use the `-R` flag to change the ownership
    of the directory itself, as well as all the files and directories it may contain:'
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: 在处理目录时，我们还可以使用`-R`标志来更改目录本身的所有权，以及它可能包含的所有文件和子目录的所有权：
- en: '[PRE64]'
  id: totrans-373
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'If we would like to change the group assignment to the object, we would follow
    the following syntax:'
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们希望更改对象的组分配，我们可以按照以下语法执行：
- en: '[PRE65]'
  id: totrans-375
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: Notice the colon separating the user and the group. With that command, we established
    that we would like the `sue` user and the `sales` group to own this resource.
    Again, we could use `-R` if the object were a directory and we wanted to make
    the changes recursive.
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: 注意冒号（:）用来分隔用户和组。在这个命令中，我们确定了希望`sue`用户和`sales`组拥有该资源。我们还可以使用`-R`选项，如果目标是目录并且想要递归更改。
- en: 'Another command worth knowing is the `chgrp` command, which allows you to directly
    change the group ownership of a file. To use it, you can execute the `chgrp` command
    along with the group you’d like to own the file, followed by the filename. For
    example, our previous `chown` command can be simplified to the following, since
    we were only modifying the group assignment of that file:'
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个值得了解的命令是`chgrp`命令，它允许你直接更改文件的组所有权。使用该命令时，你可以执行`chgrp`命令，并跟上你希望拥有该文件的组名，再加上文件名。例如，之前的`chown`命令可以简化为以下命令，因为我们只是修改了文件的组分配：
- en: '[PRE66]'
  id: totrans-378
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: Just like the `chown` command, we can use the `-R` option with `chgrp` to make
    our changes recursively, in the case of a directory.
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: 就像`chown`命令一样，我们也可以使用`-R`选项与`chgrp`命令一起使用，以便在处理目录时递归地更改权限。
- en: Well, there you have it. You should now be able to manage permissions of the
    files and directories on your server. If you haven’t worked through permissions
    on a Linux system before, it may take a few tries before you get the hang of it.
    The best thing for you to do is to practice. Create some files and directories
    (as well as users) and manage their permissions. Try to remove a user’s access
    to a resource and then try to access that resource as that user anyway and see
    what errors you get. Fix those errors and work through more examples. With practice,
    you should be able to get a handle on this very quickly.
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: 好了，你现在应该能管理服务器上的文件和目录权限了。如果你以前没有在 Linux 系统上处理过权限，可能需要几次尝试才能掌握。最好的方法就是多练习。创建一些文件和目录（以及用户）并管理它们的权限。尝试删除用户对某个资源的访问权限，然后作为该用户尝试访问该资源，看看会遇到什么错误。修复这些错误并尝试更多示例。通过练习，你应该能很快掌握这项技能。
- en: Summary
  id: totrans-381
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In Linux administration and related fields, managing users and permissions is
    something you’ll find yourself doing quite a bit. New users will join your organization,
    while others will leave, so this is something that will become ingrained in your
    mental toolset. Even if you’re the only person using your servers, you’ll find
    yourself managing permissions for applications as well, given the fact that processes
    cannot function if they don’t have access to their required resources.
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Linux 管理和相关领域，管理用户和权限是你会经常做的事情。新用户会加入你的组织，而其他用户则会离开，因此这将成为你思维工具集的一部分。即使你是唯一使用服务器的人，考虑到进程如果无法访问其所需资源就无法运行，你也会发现自己需要管理应用程序的权限。
- en: In this chapter, we took a lengthy dive into managing users, groups, and permissions.
    We worked through creating and removing users, assigning permissions, and managing
    administrative access with `sudo`. Practice these concepts on your server. When
    you get the hang of it, I’ll see you in our next chapter, where we’ll discuss
    all things related to package management. It’s going to be epic.
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一章中，我们深入探讨了用户、组和权限的管理。我们学习了创建和删除用户、分配权限，以及使用 `sudo` 管理管理员访问权限。请在你的服务器上实践这些概念。当你掌握了这些技能，我们将在下一章见面，届时我们将讨论与软件包管理相关的所有内容。这将是一次史诗级的学习之旅。
- en: Relevant videos
  id: totrans-384
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 相关视频
- en: 'Linux Crash Course – Managing Users (LearnLinuxTV): [https://linux.video/lcc-users](https://linux.video/lcc-users)'
  id: totrans-385
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'Linux 崩溃课程 – 管理用户 (LearnLinuxTV): [https://linux.video/lcc-users](https://linux.video/lcc-users)'
- en: 'Linux Crash Course – Understanding File & Directory Permissions (LearnLinuxTV):
    [https://linux.video/lcc-perm](https://linux.video/lcc-perm)'
  id: totrans-386
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'Linux 崩溃课程 – 理解文件与目录权限 (LearnLinuxTV): [https://linux.video/lcc-perm](https://linux.video/lcc-perm)'
- en: 'Linux Crash Course – usermod (LearnLinuxTV): [https://linux.video/lcc-usermod](https://linux.video/lcc-usermod)'
  id: totrans-387
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'Linux 崩溃课程 – usermod (LearnLinuxTV): [https://linux.video/lcc-usermod](https://linux.video/lcc-usermod)'
- en: 'Linux Crash Course – sudo (LearnLinuxTV): [https://linux.video/lcc-sudo](https://linux.video/lcc-sudo)'
  id: totrans-388
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'Linux 崩溃课程 – sudo (LearnLinuxTV): [https://linux.video/lcc-sudo](https://linux.video/lcc-sudo)'
- en: 'Linux Crash Course – User Account & Password Expiration (LearnLinuxTV): [https://linux.video/lcc-userexp](https://linux.video/lcc-userexp)'
  id: totrans-389
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'Linux 崩溃课程 – 用户账户与密码过期 (LearnLinuxTV): [https://linux.video/lcc-userexp](https://linux.video/lcc-userexp)'
- en: 'Linux Crash Course – Managing Groups (LearnLinuxTV): [https://linux.video/lcc-groups](https://linux.video/lcc-groups)'
  id: totrans-390
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'Linux 崩溃课程 – 管理组 (LearnLinuxTV): [https://linux.video/lcc-groups](https://linux.video/lcc-groups)'
- en: Further reading
  id: totrans-391
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: 'File permissions (Ubuntu community wiki): [https://learnlinux.link/ubuntu-perms](https://learnlinux.link/ubuntu-perms)'
  id: totrans-392
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 文件权限（Ubuntu 社区 Wiki）：[https://learnlinux.link/ubuntu-perms](https://learnlinux.link/ubuntu-perms)
- en: 'User management (Ubuntu documentation): [https://learnlinux.link/sec-users](https://learnlinux.link/sec-users)'
  id: totrans-393
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '用户管理（Ubuntu 文档）: [https://learnlinux.link/sec-users](https://learnlinux.link/sec-users)'
- en: Join our community on Discord
  id: totrans-394
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 加入我们的 Discord 社区
- en: 'Join our community’s Discord space for discussions with the author and other
    readers:'
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: 加入我们社区的 Discord 讨论空间，与作者及其他读者互动：
- en: '[https://packt.link/LWaZ0](https://packt.link/LWaZ0)'
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://packt.link/LWaZ0](https://packt.link/LWaZ0)'
- en: '![](img/QR_Code50046724-1955875156.png)'
  id: totrans-397
  prefs: []
  type: TYPE_IMG
  zh: '![](img/QR_Code50046724-1955875156.png)'
