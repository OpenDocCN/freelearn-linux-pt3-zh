<html><head></head><body><div id="sbo-rt-content" class="calibre1"><div id="_idContainer029" class="calibre2">
			<h1 id="_idParaDest-253" class="calibre5"><em class="italic"><a id="_idTextAnchor257" class="pcalibre calibre6 pcalibre1"/>Chapter 9</em>: Secure Virtualization</h1>
			<p class="calibre3">More and more system tools have built-in support for SELinux or use SELinux's features to further harden their own service offering. When we look at virtualization, libvirt is the reigning champion as a virtualization management tool, using the <strong class="bold">QEMU</strong> and <strong class="bold">Kernel-Based Virtual Machine</strong> (<strong class="bold">KVM</strong>) hypervisors.</p>
			<p class="calibre3">In this chapter, administrators will learn what <strong class="bold">secure Virtualization</strong> (<strong class="bold">sVirt</strong>) is and how it is applied by the libvirt tool suite, which SELinux domains are put in place, and how sVirt uses SELinux categories to isolate guests from each other. We will study how SELinux can help reduce the risks of virtualization and understand how the SELinux policy is tuned to support virtualization services.</p>
			<p class="calibre3">In this chapter, we're going to cover the following main topics:</p>
			<ul class="calibre8">
				<li class="calibre9">Understanding SELinux-secured virtualization</li>
				<li class="calibre9">Enhancing libvirt with SELinux support</li>
				<li class="calibre9">Using Vagrant with libvirt</li>
			</ul>
			<h1 id="_idParaDest-254" class="calibre5"><a id="_idTextAnchor258" class="pcalibre calibre6 pcalibre1"/>Technical requirements</h1>
			<p class="calibre3">Check out the following video to see the Code in Action: <a href="https://bit.ly/2T805Ug" class="pcalibre calibre6 pcalibre1">https://bit.ly/2T805Ug</a></p>
			<p class="calibre3">While it is possible to run the examples in this chapter on an older system, we recommend using a more modern system that has hardware support for virtualization. This will ensure higher performance during the exercises, as full emulation can severely hamper the progress, especially on older systems.</p>
			<p class="calibre3">To verify whether your system has hardware support for virtualization (and can therefore use the Linux KVM-based virtualization), the following command should have output:</p>
			<p class="source-code"># grep -E 'svm|vmx' /proc/cpuinfo</p>
			<p class="source-code">flags   : fpu vme de ... vmx ...</p>
			<p class="calibre3">If no output is shown, then the system does not support hardware-assisted virtualization.</p>
			<h1 id="_idParaDest-255" class="calibre5"><a id="_idTextAnchor259" class="pcalibre calibre6 pcalibre1"/>Understanding SELinux-secured virtualization</h1>
			<p class="calibre3">Virtualization <a id="_idIndexMarker655" class="pcalibre calibre6 pcalibre1"/>is a core concept that plays a part in many infrastructural service designs. Ever since its inception in the early 1970s as a means of isolating workloads and abstracting hardware dependencies, virtualization implementations have grown tremendously. When we look at infrastructure service offerings today, we quickly realize that many cloud providers would be out of service if they could not rely on the benefits and virtues of virtualization.</p>
			<p class="calibre3">One of the properties that virtualization offers is isolation, which SELinux can support and augment quite nicely.</p>
			<h2 id="_idParaDest-256" class="calibre10"><a id="_idTextAnchor260" class="pcalibre calibre6 pcalibre1"/>Introducing virtualization</h2>
			<p class="calibre3">When we <a id="_idIndexMarker656" class="pcalibre calibre6 pcalibre1"/>look at virtualization, we look at the abstraction layers it provides to hide certain resource views (such as hardware or processing power). Virtualization contributes to the development of more efficient hardware usage (which results in better cost control), centralized views on resources and systems, more flexibility in the number of operating systems that the company can deal with, standardization of resource allocation, and even improved security services.</p>
			<p class="calibre3">There are several virtualization types around:</p>
			<ul class="calibre8">
				<li class="calibre9"><strong class="bold">Full-system emulation</strong>: Where hardware is completely emulated through software. QEMU <a id="_idIndexMarker657" class="pcalibre calibre6 pcalibre1"/>is an open source emulation software capable of handling full-system emulation, allowing administrators and developers to run virtual platforms with different processor architectures not otherwise compatible with their own systems.</li>
				<li class="calibre9"><strong class="bold">Native virtualization</strong>: Where main parts of the hardware are shared across instances, and <a id="_idIndexMarker658" class="pcalibre calibre6 pcalibre1"/>guests can run unmodified <a id="_idIndexMarker659" class="pcalibre calibre6 pcalibre1"/>on them. Linux's <strong class="bold">KVM</strong>, which is also supported through QEMU, is an example of this type of virtualization.</li>
				<li class="calibre9"><strong class="bold">Paravirtualization</strong>: Where the guest operating system uses specific APIs offered by the <a id="_idIndexMarker660" class="pcalibre calibre6 pcalibre1"/>virtualization layer (on which unmodified operating systems cannot be hosted). Initial releases of Xen only supported paravirtualization. Using KVM with VirtIO drivers is another, more modular example.</li>
				<li class="calibre9"><strong class="bold">OS-level virtualization or containerization</strong>: Where the guest uses the host operating <a id="_idIndexMarker661" class="pcalibre calibre6 pcalibre1"/>system (kernel) but does <a id="_idIndexMarker662" class="pcalibre calibre6 pcalibre1"/>not see the processes and other resources running on the host. Docker containers or LXC containers are examples of OS-level virtualization.</li>
				<li class="calibre9"><strong class="bold">Application virtualization</strong>: Where the application runs under a specialized software <a id="_idIndexMarker663" class="pcalibre calibre6 pcalibre1"/>runtime. A popular example <a id="_idIndexMarker664" class="pcalibre calibre6 pcalibre1"/>here is the support for Java applications, running on the <strong class="bold">Java Virtual Machine</strong> (<strong class="bold">JVM</strong>).</li>
			</ul>
			<p class="calibre3">Many <a id="_idIndexMarker665" class="pcalibre calibre6 pcalibre1"/>virtualization platforms support a few virtualization types. QEMU can range from full emulation to paravirtualization, depending on its configuration.</p>
			<p class="calibre3">When we work with virtualization layers, the following terms come up frequently:</p>
			<ul class="calibre8">
				<li class="calibre9">The <strong class="bold">host</strong> is <a id="_idIndexMarker666" class="pcalibre calibre6 pcalibre1"/>the (native) operating system or server on which the virtualization software is running.</li>
				<li class="calibre9">The <strong class="bold">guest</strong> is the <a id="_idIndexMarker667" class="pcalibre calibre6 pcalibre1"/>virtualized service (generally an operating system or container) that runs on the host.</li>
				<li class="calibre9">The <strong class="bold">hypervisor</strong> is the <a id="_idIndexMarker668" class="pcalibre calibre6 pcalibre1"/>specialized virtualization software that manages the hardware abstraction and resource-sharing capabilities of the virtualization platform. It is responsible for creating and running the virtual machines.</li>
				<li class="calibre9">An <strong class="bold">image</strong> is a <a id="_idIndexMarker669" class="pcalibre calibre6 pcalibre1"/>file or set of files that represents the filesystem, disk, or other medium assigned to a guest.</li>
				<li class="calibre9">A <strong class="bold">virtual machine</strong> is the <a id="_idIndexMarker670" class="pcalibre calibre6 pcalibre1"/>abstracted hardware or resource set in which the guest runs.</li>
			</ul>
			<p class="calibre3">We will be using these terms in this chapter, as well as in <a href="B16276_10_Final_VK.xhtml#_idTextAnchor279" class="pcalibre calibre6 pcalibre1"><em class="italic">Chapter 10</em></a>, <em class="italic">Using Xen Security Modules with FLASK</em>, and <a href="B16276_11_Final_VK.xhtml#_idTextAnchor293" class="pcalibre calibre6 pcalibre1"><em class="italic">Chapter 11</em></a>, <em class="italic">Enhancing the Security of Containerized Workloads</em>, as those chapters also cover specific virtualization implementations and how SELinux actively provides additional security controls in them.</p>
			<p class="calibre3">Before we embark on configuring and tuning virtualization services, let's first see what SELinux has to offer for virtualized environments.</p>
			<h2 id="_idParaDest-257" class="calibre10"><a id="_idTextAnchor261" class="pcalibre calibre6 pcalibre1"/>Reviewing the risks of virtualization</h2>
			<p class="calibre3">Virtualization <a id="_idIndexMarker671" class="pcalibre calibre6 pcalibre1"/>comes with a number of risks though. If we ask architects or other risk-conscious people about the risks of virtualization, they will talk about virtual machine sprawl, challenges related to secure or insecure APIs, the higher complexity of virtualized services, and whatnot.</p>
			<p class="calibre3">Going over the challenges of virtualization itself is beyond the scope of this chapter, but there are a few notable risks that play directly into SELinux's field of interest. If we can integrate SELinux with a virtualization layer, then we can mitigate these risks more proactively:</p>
			<ul class="calibre8">
				<li class="calibre9">The first risk is <strong class="bold">data sensitivity</strong> within a virtual machine. Whenever multiple virtual <a id="_idIndexMarker672" class="pcalibre calibre6 pcalibre1"/>machines are hosted together, you could have the risk that one guest is able (be it through a flaw in the virtualization software, the hypervisor's networking capabilities, or through side-channel attacks) to access sensitive data on another virtual machine.<p class="calibre3">With SELinux, data sensitivity can be controlled using sensitivity ranges. Guests can run with different sensitivity ranges, guaranteeing the data sensitivity even on the virtualization layer.</p></li>
				<li class="calibre9">Another risk is the <strong class="bold">security of offline guest images</strong>. Here, either administrators or misconfigured virtual machines might gain access to another guest image. SELinux can prevent this through properly labeled guest images and ensuring that images of offline virtual machines are typed differently from online virtual machines.</li>
				<li class="calibre9">Virtual machines can also <strong class="bold">exhaust the resources</strong> on a system. On Linux systems, many resources <a id="_idIndexMarker673" class="pcalibre calibre6 pcalibre1"/>can be controlled through the <strong class="bold">control groups</strong> (<strong class="bold">cgroups</strong>) subsystem. As this subsystem is governed through system calls and regular file APIs, SELinux can be used to further control access to this facility, ensuring that the cgroups maintained by libvirt, for instance, remain solely under the control of libvirt.</li>
				<li class="calibre9"><strong class="bold">Break-out attacks</strong>, where vulnerabilities within the hypervisor are exploited to try to reach the host operating system, can be mitigated through SELinux's type enforcement as even a hypervisor does not require full administrative access to everything on the host.</li>
				<li class="calibre9">SELinux can also be used to <strong class="bold">authorize access to the hypervisor</strong>, ensuring that only the right teams (through the role-based access controls) are able to control the hypervisor and its definitions.</li>
				<li class="calibre9">Finally, SELinux also offers improved <strong class="bold">guest isolation</strong>, which goes beyond just the guest image accesses. Thanks to SELinux's MCS implementation, guests can be separated from each other in a mandatory approach. With type enforcement, the allowed behavior of guests can be defined and controlled. This is a key capability used by hosting providers as they allow running (for them) untrusted guest virtual machines.</li>
			</ul>
			<p class="calibre3">SELinux, however, is not <a id="_idIndexMarker674" class="pcalibre calibre6 pcalibre1"/>a full security solution for virtualization providers. One main design constraint with SELinux is that it is not dynamic if the system itself is not SELinux-aware. When we assign a type to a virtual machine, this type is generally rigid and set in stone. Virtual machines will have different behavior characteristics depending on the software running on them.</p>
			<p class="calibre3">A virtual machine running a web server has different behavior characteristics than one running a database or an email gateway. Although SELinux policy administrators would be capable of creating new domains for each virtual machine, this is not efficient. As a result, most SELinux policies will only offer a few domains usable by the virtual machine with broad characteristics.</p>
			<p class="calibre3">With libvirt, these domains are part of the sVirt solution.</p>
			<h2 id="_idParaDest-258" class="calibre10"><a id="_idTextAnchor262" class="pcalibre calibre6 pcalibre1"/>Reusing existing virtualization domains</h2>
			<p class="calibre3">When Red Hat <a id="_idIndexMarker675" class="pcalibre calibre6 pcalibre1"/>introduced its virtualization solution, it also added <a id="_idIndexMarker676" class="pcalibre calibre6 pcalibre1"/>SELinux support, calling the resulting technology <strong class="bold">sVirt</strong>, derived from <em class="italic">secure virtualization</em>. As secure virtualization as a term is hardly unique in the market, we use the term sVirt predominantly to refer to the SELinux integration within virtualization management solutions such as libvirt.</p>
			<p class="calibre3">With sVirt, the open source community has a reusable approach for augmenting the security posture of virtualization and containerization through SELinux. It does this through the following domains and types, which can be used regardless of the underlying virtualization platform:</p>
			<ul class="calibre8">
				<li class="calibre9">The hypervisor software itself, such as <strong class="source-inline">libvirtd</strong>, uses the <strong class="source-inline">virtd_t</strong> domain.</li>
				<li class="calibre9">Guests (virtual machines) that do not require any interaction with the host system and resources beyond those associated with a generic virtual machine generally use the <strong class="source-inline">svirt_t</strong> domain. This domain is the most isolated guest domain for full virtualization solutions.</li>
				<li class="calibre9">Guests that require more interaction with the host, such as using the QEMU networking capabilities and sharing services, will use the <strong class="source-inline">svirt_qemu_net_t</strong> domain.</li>
				<li class="calibre9">Guests that use the KVM networking capabilities and sharing services will use the <strong class="source-inline">svirt_kvm_net_t</strong> domain. It is very similar in permissions to <strong class="source-inline">svirt_qemu_net_t</strong> but optimized for KVM.</li>
				<li class="calibre9">Containerized guests, as we will see in <a href="B16276_11_Final_VK.xhtml#_idTextAnchor293" class="pcalibre calibre6 pcalibre1"><em class="italic">Chapter 11</em></a>, <em class="italic">Enhancing the Security of Containerized Workloads</em>, will use the <strong class="source-inline">svirt_lxc_net_t</strong> domain, whose privileges are optimized for OS-level virtualization.</li>
				<li class="calibre9">Guests that <a id="_idIndexMarker677" class="pcalibre calibre6 pcalibre1"/>require more flexible memory accesses (such as executing writable memory segments and memory stacks) will use the <strong class="source-inline">svirt_tcg_t</strong> domain. This flexible memory access is common for full virtualization <a id="_idIndexMarker678" class="pcalibre calibre6 pcalibre1"/>guests whose emulation/virtualization requires the use of a <strong class="bold">Tiny Code Generator</strong> (<strong class="bold">TCG</strong>), hence the name.</li>
				<li class="calibre9">Image files that contain a guest's data will be labeled with the <strong class="source-inline">svirt_image_t</strong> type.</li>
				<li class="calibre9">Image files that are not in use at the moment will use the default <strong class="source-inline">virt_image_t</strong> type.</li>
				<li class="calibre9">Image files used in a read-only fashion will have the <strong class="source-inline">virt_content_t</strong> type assigned to them.</li>
			</ul>
			<p class="calibre3">To enable some flexibility in what the domains are allowed to do, additional SELinux booleans are put in effect, which we'll cover next.</p>
			<h2 id="_idParaDest-259" class="calibre10"><a id="_idTextAnchor263" class="pcalibre calibre6 pcalibre1"/>Fine-tuning virtualization-supporting SELinux policy</h2>
			<p class="calibre3">Use caution <a id="_idIndexMarker679" class="pcalibre calibre6 pcalibre1"/>when toggling SELinux booleans to control the confinement of virtualization domains. Such booleans influence the SELinux policy on the host level, and cannot be used to change the access controls or privileges of individual guests. As such, when we change the value of an SELinux boolean, the change affects the permissions of all guests on that host.</p>
			<p class="calibre3">Let's see what the various SELinux booleans are for virtualized environments:</p>
			<ul class="calibre8">
				<li class="calibre9">The <strong class="source-inline">staff_use_svirt</strong> boolean, if enabled, allows the <strong class="source-inline">staff_t</strong> user domain to interact with and manage virtual machines, as by default this is only allowed for unconfined users.</li>
				<li class="calibre9">The <strong class="source-inline">unprivuser_use_svirt</strong> boolean, if enabled, allows unprivileged user domains (such as <strong class="source-inline">user_t</strong>) to interact with and manage virtual machines.</li>
				<li class="calibre9">With the <strong class="source-inline">virt_read_qemu_ga_data</strong> and <strong class="source-inline">virt_rw_qemu_ga_data</strong> booleans, the QEMU guest agent (which is an optional agent running inside the guests, facilitating operations such as freezing filesystems during backup routines) can read or even manage data labeled with the <strong class="source-inline">virt_qemu_ga_data_t</strong> type. This type, however, is not in use by default, and these SELinux booleans are disabled by default.</li>
				<li class="calibre9">The <strong class="source-inline">virt_sandbox_share_apache_content</strong> boolean allows the guest domains to share web content. This is most commonly used for containers but is possible on guests <a id="_idIndexMarker680" class="pcalibre calibre6 pcalibre1"/>as well if the hypervisor supports mapping host filesystems into the guest.</li>
				<li class="calibre9">With <strong class="source-inline">virt_sandbox_use_audit</strong> enabled, this boolean allows the guest domains to send audit messages to the host's audit service.</li>
				<li class="calibre9">The <strong class="source-inline">virt_sandbox_use_fusefs</strong> boolean grants the guest domains the privilege to mount <a id="_idIndexMarker681" class="pcalibre calibre6 pcalibre1"/>and interact with <strong class="bold">Filesystem in Userspace</strong> (<strong class="bold">FUSE</strong>) filesystems. The <strong class="source-inline">virt_use_fusefs</strong> boolean allows the guests to read files on these filesystems.</li>
				<li class="calibre9">If the <strong class="source-inline">virt_sandbox_use_netlink</strong> boolean is active, then guest domains can use Netlink system calls to manipulate the networking stack within the host.</li>
				<li class="calibre9">With <strong class="source-inline">virt_transition_userdomain</strong>, containers can transition to a user domain (including the unconfined user domain <strong class="source-inline">unconfined_t</strong>).</li>
				<li class="calibre9">When we enable <strong class="source-inline">virt_use_execmem</strong>, guests can use executable memory.</li>
				<li class="calibre9">The <strong class="source-inline">virt_use_glusterd</strong>, <strong class="source-inline">virt_use_nfs</strong>, and <strong class="source-inline">virt_use_samba</strong> booleans allow guests to use network filesystems mounted on the host, offered through GlusterFS, NFS, and Samba respectively. Note that this does not involve mounts inside the guest itself, such as a guest that connects to an NFS server. The booleans handle interaction through filesystem mounts on the host.</li>
				<li class="calibre9">Device access is also governed through some SELinux booleans, such as the <strong class="source-inline">virt_use_comm</strong> boolean to interact with serial and parallel communication ports, <strong class="source-inline">virt_use_pcscd</strong> to allow guests to access smartcards, and <strong class="source-inline">virt_use_usb</strong> to grant access to USB devices.</li>
				<li class="calibre9">The <strong class="source-inline">virt_use_rawip</strong> boolean allows guests to use and interact with raw IP sockets, allowing network interaction that circumvents some of the processing logic within the regular network stack.</li>
				<li class="calibre9">With <strong class="source-inline">virt_use_sanlock</strong>, guests can interact with the sanlock service, a lock manager for shared storage.</li>
				<li class="calibre9">When <strong class="source-inline">virt_use_xserver</strong> is set to true, guests can use the X server on the host.</li>
			</ul>
			<p class="calibre3">If security-sensitive operations need to be allowed for a single guest or a small set of guests, it is advisable <a id="_idIndexMarker682" class="pcalibre calibre6 pcalibre1"/>to run those guests on an isolated host where these operations are then allowed while running the other guests on hosts where the policy does not allow these particular actions.</p>
			<p class="calibre3">Administrators can also use different SELinux domains for specific guests, fine-tuning the access controls for an individual virtual machine. How we can assign specific domains depends on the underlying technology of course. In the <em class="italic">Enhancing libvirt with SELinux support</em> section, we will introduce this for libvirt-based virtualization.</p>
			<h2 id="_idParaDest-260" class="calibre10"><a id="_idTextAnchor264" class="pcalibre calibre6 pcalibre1"/>Understanding sVirt's use of MCS</h2>
			<p class="calibre3">The SELinux <a id="_idIndexMarker683" class="pcalibre calibre6 pcalibre1"/>domains and the mentioned types are not enough to implement proper confinement and isolation between guests. sVirt adds <a id="_idIndexMarker684" class="pcalibre calibre6 pcalibre1"/>another layer of security by using SELinux's <strong class="bold">Multi-Category Security</strong> (<strong class="bold">MCS</strong>) extensively.</p>
			<p class="calibre3">Within SELinux, some domains are marked as an MCS-constrained type. When this is the case, the domain will not be able to access resources that do not have the same set of categories (or more) assigned as the current context, as it will not be able to extend their own active category set—something we saw in <a href="B16276_08_Final_VK.xhtml#_idTextAnchor237" class="pcalibre calibre6 pcalibre1"><em class="italic">Chapter 8</em></a>, <em class="italic">SEPostgreSQL – Extending PostgreSQL with SELinux</em>.</p>
			<p class="calibre3">The sVirt implementation ensures that the virtualization domains mentioned earlier are all marked as MCS-constrained types. This can be confirmed by asking the system which types have the <strong class="source-inline">mcs_constrained_type</strong> attribute set:</p>
			<p class="source-code"># seinfo -amcs_constrained_type -x</p>
			<p class="source-code">Type Attributes: 1</p>
			<p class="source-code">  attribute mcs_constrained_type</p>
			<p class="source-code">    container_t</p>
			<p class="source-code">    netlabel_peer_t</p>
			<p class="source-code">    openshift_app_t</p>
			<p class="source-code">    openshift_t</p>
			<p class="source-code">    sandbox_min_t</p>
			<p class="source-code">    sandbox_net_t</p>
			<p class="source-code">    sandbox_t</p>
			<p class="source-code">    sandbox_web_t</p>
			<p class="source-code">    sandbox_x_t</p>
			<p class="source-code">    svirt_kvm_net_t</p>
			<p class="source-code">    svirt_qemu_net_t</p>
			<p class="source-code">    svirt_t</p>
			<p class="source-code">    svirt_tcg_t</p>
			<p class="calibre3">Through the MCS constraints, sVirt enables proper isolation between guests. Every running virtual machine (generally running as <strong class="source-inline">svirt_t</strong>) will be assigned two (random) SELinux categories. The images that virtual machine needs to use are assigned the same two SELinux categories.</p>
			<p class="calibre3">Whenever <a id="_idIndexMarker685" class="pcalibre calibre6 pcalibre1"/>a virtual machine wants to access the wrong image, the difference in MCS categories will result in SELinux denying the access. Similarly, if one virtual machine is trying to connect to or attack another virtual machine, the MCS protections will once again prevent these actions from happening.</p>
			<p class="calibre3">sVirt selects two categories to allow a large number of guests to run even when there are only a few categories available. Assume that the hypervisor is running with the <strong class="source-inline">c10.c99</strong> category range. That means that the hypervisor can only select 90 categories. If each guest only receives a single category, then the hypervisor can support 90 guests before allowing multiple guests to interact with each other (assuming a malicious actor found a vulnerability that allows that, of course, the hypervisor software will generally disallow such accesses as well). With two categories, however, the number of supported simultaneously running guests becomes 4,005 (the number of unique pairs in a set of 90, obtained through the formula <em class="italic">n*(n-1)/2)</em>.</p>
			<p class="calibre3">Let's see what libvirt's SELinux support looks like.</p>
			<h1 id="_idParaDest-261" class="calibre5"><a id="_idTextAnchor265" class="pcalibre calibre6 pcalibre1"/>Enhancing libvirt with SELinux support</h1>
			<p class="calibre3">The libvirt <a id="_idIndexMarker686" class="pcalibre calibre6 pcalibre1"/>project offers a virtualization abstraction layer, through which administrators can manage virtual machines without direct knowledge of or expertise in the underlying virtualization platform. As such, administrators can use the libvirt-offered tools to manage virtual machines running on QEMU, QEMU/KVM, Xen, and so on.</p>
			<p class="calibre3">To use the sVirt approach, libvirt can be built with SELinux support. When this is the case and the guests are governed (security-wise) through SELinux, then the sVirt domains and types are <a id="_idIndexMarker687" class="pcalibre calibre6 pcalibre1"/>used/enforced by libvirt. The libvirt code will also perform the category selection to enforce guest isolation and will ensure that the image files are assigned the right label (image files that are in use should get a different label than inactive images files).</p>
			<h2 id="_idParaDest-262" class="calibre10"><a id="_idTextAnchor266" class="pcalibre calibre6 pcalibre1"/>Differentiating between shared and dedicated resources</h2>
			<p class="calibre3">The different <a id="_idIndexMarker688" class="pcalibre calibre6 pcalibre1"/>labels for images allow for different use cases. The image used to host the main operating system (of the guest) will generally receive the <strong class="source-inline">svirt_image_t</strong> label and will be recategorized with the same pair of categories as the guest runtime itself (running as <strong class="source-inline">svirt_t</strong>). This image is writable by the guest.</p>
			<p class="calibre3">When we consider an image that needs to be readable or writable by multiple guests, then libvirt can opt not to assign any categories to the file. Without categories, MCS constraints don't apply (well, they still apply, but any set of categories dominates an empty set, and as such, actions against those properly labeled files are allowed).</p>
			<p class="calibre3">Images that need to be mounted read-only for a guest (such as bootable media) are assigned the <strong class="source-inline">virt_content_t</strong> type. If they are dedicated, then categories can be assigned as well. For shared read access, no categories need to be assigned.</p>
			<p class="calibre3">Note that these label differences apply mainly to virtualization technologies and not container technologies.</p>
			<h2 id="_idParaDest-263" class="calibre10"><a id="_idTextAnchor267" class="pcalibre calibre6 pcalibre1"/>Assessing the libvirt architecture</h2>
			<p class="calibre3">The libvirt <a id="_idIndexMarker689" class="pcalibre calibre6 pcalibre1"/>project has several clients that interact with the <strong class="source-inline">libvirtd</strong> daemon. This daemon is responsible for managing the local hypervisor software (be it QEMU/KVM, Xen, or any other virtualization software) and is even able to manage remote hypervisors. This latter functionality is often used for proprietary hypervisors that offer the necessary APIs to manage the virtual resources on the host:</p>
			<div class="calibre13">
				<div id="_idContainer028" class="img---figure">
					<img src="Images/B16276_09_001.jpg" alt="Figure 9.1 – High-level libvirt architecture " class="calibre27"/>
				</div>
			</div>
			<p class="figure-caption">Figure 9.1 – High-level libvirt architecture</p>
			<p class="calibre3">Due to the <a id="_idIndexMarker690" class="pcalibre calibre6 pcalibre1"/>cross-platform and cross-hypervisor nature of the libvirt project, sVirt is a good match. Instead of hypervisor-specific domains, generic (yet confined) domains are used to ensure the security of the environment.</p>
			<h2 id="_idParaDest-264" class="calibre10"><a id="_idTextAnchor268" class="pcalibre calibre6 pcalibre1"/>Configuring libvirt for sVirt</h2>
			<p class="calibre3">Most systems <a id="_idIndexMarker691" class="pcalibre calibre6 pcalibre1"/>that support libvirt on SELinux systems will have SELinux <a id="_idIndexMarker692" class="pcalibre calibre6 pcalibre1"/>support automatically enabled. If this is not the case, but SELinux support is possible, then all it takes is to configure libvirt to allow the SELinux security model. We map the SELinux security model in libvirt on a per-hypervisor basis.</p>
			<p class="calibre3">The configuration parameters related to sVirt are generally defined on a per-hypervisor basis. For instance, for the QEMU-based virtualization driver, we need to edit the <strong class="source-inline">/etc/libvirt/qemu.conf</strong> file. Let's look at the various parameters related to secure virtualization:</p>
			<ul class="calibre8">
				<li class="calibre9">The first parameter, which defines whether sVirt is active or not, is the <strong class="source-inline">security_</strong><strong class="source-inline">driver</strong> parameter. While libvirt will by default enable SELinux once it detects SELinux is active, we can explicitly mark sVirt support as enabled by setting the <strong class="source-inline">selinux</strong> value:<p class="source-code">security_driver = "selinux"</p><p class="calibre3">SELinux support will by default be enabled without explicitly marking the <strong class="source-inline">security_driver</strong> variable in the configuration file. If you want to use libvirt without SELinux support (and consequently without sVirt), then you need to explicitly mark the <strong class="source-inline">security_driver</strong> setting as <strong class="source-inline">none</strong>:</p><p class="source-code">security_driver = "none"</p></li>
				<li class="calibre9">A second <a id="_idIndexMarker693" class="pcalibre calibre6 pcalibre1"/>sVirt-related setting in libvirt is <strong class="source-inline">security_default_confined</strong>. This variable defines whether guests are by default confined (and thus associated with the sVirt protections) or not. The default value is <strong class="source-inline">1</strong>, which <a id="_idIndexMarker694" class="pcalibre calibre6 pcalibre1"/>means that the confinement is by default enabled. To disable it, you need to set it to <strong class="source-inline">0</strong>:<p class="source-code">security_default_confined = 0</p></li>
				<li class="calibre9">Users of the libvirt software can also ask to create an unconfined guest (and libvirt allows this by default). If we set <strong class="source-inline">security_require_confined</strong> to <strong class="source-inline">1</strong>, then no unconfined guests can be created:<p class="source-code">security_require_confined = 1</p></li>
			</ul>
			<p class="calibre3">We can confirm that sVirt is running when we have a guest active on the platform, as we can then consult the label for its processes to verify that it indeed received two random categories.</p>
			<p class="calibre3">Let's create such a guest, using the regular QEMU hypervisor. We use an Alpine Linux ISO to boot the guest with, but that is merely an example—you can substitute it with any ISO you want:</p>
			<p class="source-code"># virt-install --virt-type=qemu --name test \</p>
			<p class="source-code">  --ram 128 --vcpus=1 --graphics none \</p>
			<p class="source-code">  --os-variant=alpinelinux3.8 \</p>
			<p class="source-code">  --cdrom=/var/lib/libvirt/boot/alpine-extended-x86_64.iso \</p>
			<p class="source-code">  --disk path=/var/lib/libvirt/images/test.qcow2,size=1,format=qcow2</p>
			<p class="calibre3">The locations mentioned are important, as they will ensure that the files are properly labeled:</p>
			<ul class="calibre8">
				<li class="calibre9">In <strong class="source-inline">/var/lib/libvirt/boot</strong> (and <strong class="source-inline">/var/lib/libvirt/isos</strong>), read-only content should be placed, which will result in the files automatically being labeled with <strong class="source-inline">virt_content_t</strong>.</li>
				<li class="calibre9">In <strong class="source-inline">/var/lib/libvirt/images</strong>, we create the actual guest images. When the guests are shut down, the images will be labeled with <strong class="source-inline">virt_image_t</strong>, but once started, the labels will be adjusted to match the categories associated with the domain.</li>
			</ul>
			<p class="calibre3">The command will create a guest called <strong class="source-inline">test</strong>, with 128 MB of memory and 1 vCPU. No specific <a id="_idIndexMarker695" class="pcalibre calibre6 pcalibre1"/>graphics support will be enabled, meaning that the standard <a id="_idIndexMarker696" class="pcalibre calibre6 pcalibre1"/>console or screen of <a id="_idIndexMarker697" class="pcalibre calibre6 pcalibre1"/>the virtual machine will not be associated with any graphical service such as <strong class="bold">Virtual Network Computing</strong> (<strong class="bold">VNC</strong>) but will rely on a serial console definition inside the guest. Furthermore, we have the guest use a small, 1 GB disk <a id="_idIndexMarker698" class="pcalibre calibre6 pcalibre1"/>that uses the <strong class="bold">QEMU copy-on-write</strong> (<strong class="bold">QCOW2</strong>) format.</p>
			<p class="calibre3">Once we have created the guest and launched it, we can check its label easily:</p>
			<p class="source-code"># ps -efZ | grep test</p>
			<p class="source-code">system_u:system_r:svirt_tcg_t:s0:c533,c565 /usr/bin/qemu-system-x86_64 -name guest=test,...</p>
			<p class="calibre3">To list the currently defined guests, use the <strong class="source-inline">virsh</strong> command:</p>
			<p class="source-code"># virsh list --all</p>
			<p class="source-code"> Id   Name     State</p>
			<p class="source-code">------------------------</p>
			<p class="source-code"> 1    test     running</p>
			<p class="calibre3">The <strong class="source-inline">--all</strong> argument will ensure that even guests that are defined but are not running currently are listed as well.</p>
			<p class="callout-heading">Important note</p>
			<p class="callout">Within libvirt, guests <a id="_idIndexMarker699" class="pcalibre calibre6 pcalibre1"/>are actually called <strong class="bold">domains</strong>. As SELinux (and thus this book) also uses the term <em class="italic">domain</em> frequently when referring to the context of a process, we will be using <em class="italic">guest</em> as terminology when referring to libvirt's domains to keep possible confusion to a minimum.</p>
			<p class="calibre3">The <strong class="source-inline">virsh</strong> command is the main entry point for interacting with libvirt. For instance, to send a shutdown signal to a guest, you would use the <strong class="source-inline">shutdown</strong> argument, whereas the <strong class="source-inline">destroy</strong> argument will force the shutdown of the guest. Finally, to remove a definition, you would use <strong class="source-inline">undefine</strong>.</p>
			<p class="calibre3">As shown in the previous example, the guest we defined is running with the <strong class="source-inline">svirt_tcg_t</strong> domain. Let's see how we can adjust the labels used by libvirt for guests.</p>
			<h2 id="_idParaDest-265" class="calibre10"><a id="_idTextAnchor269" class="pcalibre calibre6 pcalibre1"/>Changing a guest's SELinux labels</h2>
			<p class="calibre3">Once a <a id="_idIndexMarker700" class="pcalibre calibre6 pcalibre1"/>guest has been defined, libvirt allows administrators to modify its parameters by editing an XML file representing the guest. Within this XML file, the SELinux labeling has a place as well.</p>
			<p class="calibre3">To view the current definition, you can use the <strong class="source-inline">dumpxml</strong> argument to <strong class="source-inline">virsh</strong>:</p>
			<p class="source-code"># virsh dumpxml test</p>
			<p class="calibre3">At the end of the XML, the security labels are shown. For SELinux, this could look like so:</p>
			<p class="source-code">&lt;seclabel type='dynamic' model='selinux' relabel='yes'&gt;</p>
			<p class="source-code">  &lt;label&gt;system_u:system_r:svirt_tcg_t:s0:c533,c565&lt;/label&gt;</p>
			<p class="source-code">  &lt;imagelabel&gt;system_u:object_r:svirt_image_t:s0:c533,c565&lt;/imagelabel&gt;</p>
			<p class="source-code">&lt;/seclabel&gt;</p>
			<p class="calibre3">If we want to modify these settings, we can use the <strong class="source-inline">edit</strong> argument to <strong class="source-inline">virsh</strong>:</p>
			<p class="source-code"># virsh edit test</p>
			<p class="calibre3">This will open the XML file in the local editor. However, once we accomplish that, we'll notice that the <strong class="source-inline">seclabel</strong> entries are nowhere to be found. That is because the default behavior is to use dynamic labels (hence <strong class="source-inline">type='dynamic'</strong>) with default labels, which does not require any default definition.</p>
			<p class="calibre3">Let's instead use a static definition, and have the guest run with the <strong class="source-inline">c123,c124</strong> category pair. In the displayed XML, at the end (but still within the <strong class="source-inline">&lt;domain&gt;...&lt;/domain&gt;</strong> definition), place the following XML snippet:</p>
			<p class="source-code">&lt;seclabel type='static' model='selinux' relabel='yes'&gt;</p>
			<p class="source-code">  &lt;label&gt;system_u:system_r:svirt_tcg_t:s0:c123,c124&lt;/label&gt;</p>
			<p class="source-code">&lt;/seclabel&gt;</p>
			<p class="calibre3">To run a guest with a different type is of course done in a similar fashion, changing <strong class="source-inline">svirt_tcg_t</strong> to a different type. However, keep in mind that not all types can be used regardless. For instance, the default <strong class="source-inline">svirt_t</strong> domain cannot be used with QEMU's full-system virtualization (as QEMU uses TCG if it cannot use KVM).</p>
			<p class="callout-heading">Important note</p>
			<p class="callout">The default types that libvirt uses are declared inside <strong class="source-inline">/etc/selinux/targeted/contexts</strong>, in the <strong class="source-inline">virtual_domain_context</strong> and <strong class="source-inline">virtual_image_context</strong> files. However, it is not recommended to change these files as they will be overwritten when SELinux policy updates are released by the distribution.</p>
			<p class="calibre3">The <strong class="source-inline">relabel</strong> statement requests libvirt to relabel all resources for the guest according to the guest's current assigned label (<strong class="source-inline">relabel='yes'</strong>) or not (<strong class="source-inline">relabel='no'</strong>). With dynamic category assignment, this will always be <strong class="source-inline">yes</strong>, while with static definitions both values are possible.</p>
			<p class="calibre3">Of course, if we <a id="_idIndexMarker701" class="pcalibre calibre6 pcalibre1"/>want to, we can use dynamic category assignment with custom type definitions as well. For that, we declare <strong class="source-inline">type='dynamic'</strong> but explicitly define a label within a <strong class="source-inline">&lt;baselabel&gt;</strong> entity, like so:</p>
			<p class="source-code">&lt;seclabel type='dynamic' model='selinux'&gt;</p>
			<p class="source-code">  &lt;baselabel&gt;system_u:system_r:svirt_t:s0&lt;/baselabel&gt;</p>
			<p class="source-code">&lt;/seclabel&gt;</p>
			<p class="calibre3">This will have the guest run with a dynamically associated category pair, while using a custom label rather than the default selected one.</p>
			<h2 id="_idParaDest-266" class="calibre10"><a id="_idTextAnchor270" class="pcalibre calibre6 pcalibre1"/>Customizing resource labels</h2>
			<p class="calibre3">If the guest <a id="_idIndexMarker702" class="pcalibre calibre6 pcalibre1"/>definition has relabeling active (either because it uses dynamic category assignment or on explicit request of the administrator), then the resources that the guest uses will be relabeled accordingly.</p>
			<p class="calibre3">Administrators can customize the labeling behavior of libvirt through the same interface we used previously: guest definition files. For instance, if we would not want libvirt to relabel the <strong class="source-inline">test.qcow2</strong> file that represents the guest's disk, we could add to the XML like so:</p>
			<p class="source-code">&lt;disk type='file' device='disk'&gt;</p>
			<p class="source-code">  &lt;driver name='qemu' type='qcow2'/&gt;</p>
			<p class="source-code">  &lt;source file='/var/lib/libvirt/images/test.qcow2'&gt;</p>
			<p class="source-code"><strong class="bold">    &lt;seclabel relabel='no'/&gt;</strong></p>
			<p class="source-code"><strong class="bold">  &lt;/source&gt;</strong></p>
			<p class="source-code">  &lt;target dev='hda' bus='ide'/&gt;</p>
			<p class="source-code">  &lt;address type='drive' controller='0' bus='0'</p>
			<p class="source-code">           target='0' unit='0'/&gt;</p>
			<p class="source-code">&lt;/disk&gt;</p>
			<p class="calibre3">This is useful when you want to allow the sharing of some resources across different guests, without making them readable by all guests. In such a situation, we could label the file itself with (say) <strong class="source-inline">svirt_image_t:s0:c123</strong> and have the guests with category pairs always contain the category <strong class="source-inline">c123</strong>.</p>
			<h2 id="_idParaDest-267" class="calibre10"><a id="_idTextAnchor271" class="pcalibre calibre6 pcalibre1"/>Controlling available categories</h2>
			<p class="calibre3">When libvirt <a id="_idIndexMarker703" class="pcalibre calibre6 pcalibre1"/>selects random categories, it does so based on its own category range. By default, MCS systems will have this range set to <strong class="source-inline">c0.c1023</strong>. To change the category range, we need to ensure that we launch the libvirt daemon (<strong class="source-inline">libvirtd</strong>) in the proper context.</p>
			<p class="calibre3">With systemd, we saw in <a href="B16276_07_Final_VK.xhtml#_idTextAnchor216" class="pcalibre calibre6 pcalibre1"><em class="italic">Chapter 7</em></a>, <em class="italic">Configuring Application-Specific SELinux Controls</em>, that this can be accomplished by editing the service unit file and defining the right <strong class="source-inline">SELinuxContext</strong> variable. Let's apply this to <strong class="source-inline">libvirtd</strong> as well:</p>
			<ol class="calibre18">
				<li class="calibre9">First, copy over the system-provided <strong class="source-inline">libvirtd.service</strong> file to <strong class="source-inline">/etc/systemd/system</strong>:<p class="source-code"><strong class="bold"># cp /usr/lib/systemd/system/libvirtd.service /etc/systemd/system</strong></p></li>
				<li class="calibre9">Edit the <strong class="source-inline">libvirtd.service</strong> file and add the following definition:<p class="source-code">SELinuxContext=system_u:system_r:virtd_t:s0-s0:c800.c899</p></li>
				<li class="calibre9">Reload the daemon definitions for systemd so that it picks up the new <strong class="source-inline">libvirtd.service</strong> file:<p class="source-code"><strong class="bold"># systemctl daemon-reload</strong></p></li>
				<li class="calibre9">Restart the <strong class="source-inline">libvirtd</strong> daemon:<p class="source-code"><strong class="bold"># systemctl stop libvirtd</strong></p><p class="source-code"><strong class="bold"># systemctl start libvirtd</strong></p></li>
				<li class="calibre9">We can now start our guests again and verify that each guest is now running with a category pair within the range defined for the <strong class="source-inline">libvirtd</strong> daemon:<p class="source-code"><strong class="bold"># virsh start test</strong></p><p class="source-code"><strong class="bold"># ps -efZ | grep virt</strong></p><p class="source-code"><strong class="bold">system_u:system_r:virtd_t:s0-s0:c800.c899 /usr/sbin/</strong><strong class="bold">libvirtd</strong></p><p class="source-code"><strong class="bold">system_u:system_r:svirt_t:s0:c846,c891 /usr/bin/qemu-</strong><strong class="bold">system-x86_64 -name guest=test...</strong></p><p class="calibre3">As we can see, the categories selected by libvirt are now within the defined range.</p></li>
			</ol>
			<p class="calibre3">Systems that do not use systemd can edit the SysV-style <strong class="source-inline">init</strong> script and use <strong class="source-inline">runcon</strong>:</p>
			<p class="source-code">runcon -l s0-s0:c800.c899 /usr/sbin/libvirtd \</p>
			<p class="source-code">  --config /etc/libvirt/libvirtd.conf --listen</p>
			<p class="calibre3">Every time we launch a new guest, the libvirt code will randomly select two categories. The service will then check whether these categories are part of its own range and whether the category <a id="_idIndexMarker704" class="pcalibre calibre6 pcalibre1"/>pair is already used or not. If any of these checks fail, libvirt will randomly select a new pair of categories until a free pair matches the requirements.</p>
			<h2 id="_idParaDest-268" class="calibre10"><a id="_idTextAnchor272" class="pcalibre calibre6 pcalibre1"/>Changing the storage pool locations</h2>
			<p class="calibre3">A very <a id="_idIndexMarker705" class="pcalibre calibre6 pcalibre1"/>common configuration change with libvirt is to reconfigure it to use a different storage pool location. This has a slight impact on SELinux as well, as we do not have proper file context definitions for the new location.</p>
			<p class="calibre3">Let's see how to create a new pool location and change the SELinux configuration for it:</p>
			<ol class="calibre18">
				<li value="1" class="calibre9">List the current storage pools to make sure the new pool name is not already taken:<p class="source-code"><strong class="bold"># virsh pool-list --all</strong></p><p class="source-code"><strong class="bold"> Name                   State     Autostart</strong></p><p class="source-code"><strong class="bold">-----------------------------------------------</strong></p><p class="source-code"><strong class="bold"> boot                   active    yes</strong></p><p class="source-code"><strong class="bold"> images                 active    yes</strong></p><p class="source-code"><strong class="bold"> root                   active    yes</strong></p></li>
				<li class="calibre9">Create the target location:<p class="source-code"><strong class="bold"># mkdir /srv/images</strong></p></li>
				<li class="calibre9">Create the new storage pool with <strong class="source-inline">pool-define-as</strong>. In the following command, we name the pool <strong class="source-inline">large_images</strong>:<p class="source-code"><strong class="bold"># virsh pool-define-as large_images dir - - - - "/srv/images"</strong></p><p class="source-code"><strong class="bold">Pool large_images defined</strong></p></li>
				<li class="calibre9">Configure SELinux to label the pool properly:<p class="source-code"><strong class="bold"># semanage fcontext -a -t virt_image_t "/srv/images(/.*)?" </strong></p></li>
				<li class="calibre9">Relabel the directory structure:<p class="source-code"><strong class="bold"># restorecon -R /srv/images</strong></p></li>
				<li class="calibre9">Have libvirt populate the directory structure:<p class="source-code"><strong class="bold"># virsh pool-build large_images</strong></p></li>
				<li class="calibre9">Start the storage pool:<p class="source-code"><strong class="bold"># virsh pool-start large_images</strong></p></li>
				<li class="calibre9">Turn on auto-start so that, when <strong class="source-inline">libvirtd</strong> starts, the pool is immediately usable as well:<p class="source-code"><strong class="bold"># virsh pool-autostart large_images</strong></p></li>
				<li class="calibre9">We can verify that everything is functioning properly with the <strong class="source-inline">pool-info</strong> command:<p class="source-code"><strong class="bold"># virsh pool-info large_images</strong></p><p class="calibre3">The output will show the current and available capacity for the new location.</p></li>
			</ol>
			<p class="calibre3">If we host <a id="_idIndexMarker706" class="pcalibre calibre6 pcalibre1"/>the storage pool on an NFS-mounted location, then we need to enable the <strong class="source-inline">virt_use_nfs</strong> SELinux boolean as well.</p>
			<p class="calibre3">Now that we've fully grasped how to configure libvirt and SELinux for it, let's see how we can use the popular Vagrant tool with libvirt.</p>
			<h1 id="_idParaDest-269" class="calibre5"><a id="_idTextAnchor273" class="pcalibre calibre6 pcalibre1"/>Using Vagrant with libvirt</h1>
			<p class="calibre3">Vagrant is a <a id="_idIndexMarker707" class="pcalibre calibre6 pcalibre1"/>framework to quickly spin up and manage virtual machines <a id="_idIndexMarker708" class="pcalibre calibre6 pcalibre1"/>and is very popular within development communities. While Vagrant uses Oracle VirtualBox as the hypervisor by default, we can install a libvirt plugin to use Vagrant with libvirt, benefiting from the sVirt security offered by SELinux.</p>
			<h2 id="_idParaDest-270" class="calibre10"><a id="_idTextAnchor274" class="pcalibre calibre6 pcalibre1"/>Deploying Vagrant and the libvirt plugin</h2>
			<p class="calibre3">The Vagrant <a id="_idIndexMarker709" class="pcalibre calibre6 pcalibre1"/>application can be installed from a single RPM file. Find <a id="_idIndexMarker710" class="pcalibre calibre6 pcalibre1"/>the latest version at <a href="https://www.vagrantup.com/downloads.html" class="pcalibre calibre6 pcalibre1">https://www.vagrantup.com/downloads.html</a> and install it. For instance, for CentOS systems, you <a id="_idIndexMarker711" class="pcalibre calibre6 pcalibre1"/>can use <strong class="source-inline">yum</strong> directly:</p>
			<p class="source-code"># yum install https://releases.hashicorp.com/vagrant/2.2.9/vagrant_2.2.9_x86_64.rpm</p>
			<p class="calibre3">To install the libvirt plugin, we first need to make sure that the dependencies are installed as well. The documentation, online at <a href="https://github.com/vagrant-libvirt/vagrant-libvirt" class="pcalibre calibre6 pcalibre1">https://github.com/vagrant-libvirt/vagrant-libvirt</a>, gives a good overview <a id="_idIndexMarker712" class="pcalibre calibre6 pcalibre1"/>of which packages need to be installed. Do not forget this step, as dependency failures during the plugin installation are not always obvious.</p>
			<p class="calibre3">Once the dependencies are installed, use <strong class="source-inline">vagrant</strong> itself to download and install the plugin:</p>
			<p class="source-code"># vagrant plugin install vagrant-libvirt</p>
			<p class="calibre3">After <a id="_idIndexMarker713" class="pcalibre calibre6 pcalibre1"/>installing the <a id="_idIndexMarker714" class="pcalibre calibre6 pcalibre1"/>plugin, we can go forward with setting up a Vagrant box.</p>
			<h2 id="_idParaDest-271" class="calibre10"><a id="_idTextAnchor275" class="pcalibre calibre6 pcalibre1"/>Installing a libvirt-compatible box</h2>
			<p class="calibre3">Vagrant <a id="_idIndexMarker715" class="pcalibre calibre6 pcalibre1"/>uses <strong class="bold">boxes</strong>: images prepared for quick installation using Vagrant. Not all Vagrant boxes are compatible with the libvirt provider. Luckily, the <a id="_idIndexMarker716" class="pcalibre calibre6 pcalibre1"/>Vagrant Cloud website at <a href="https://app.vagrantup.com/boxes/search?provider=libvirt" class="pcalibre calibre6 pcalibre1">https://app.vagrantup.com/boxes/search?provider=libvirt</a> allows you to quickly find compatible boxes.</p>
			<p class="calibre3">Suppose we want to use a Fedora image called <strong class="source-inline">fedora/32-cloud-base</strong>, then we can configure it as follows:</p>
			<ol class="calibre18">
				<li value="1" class="calibre9">Create a new directory, which we will define the box configuration in, and enter this location:<p class="source-code"><strong class="bold"># mkdir vagrant</strong></p><p class="source-code"><strong class="bold"># cd vagrant</strong></p></li>
				<li class="calibre9">Initialize the Vagrant box, using the <strong class="source-inline">fedora/32-cloud-base</strong> box definition:<p class="source-code"><strong class="bold"># vagrant init fedora/32-cloud-base</strong></p><p class="calibre3">This will create an empty <strong class="source-inline">Vagrantfile</strong> that can be used to further configure the box.</p></li>
				<li class="calibre9">Edit the <strong class="source-inline">Vagrantfile</strong>, and add the following code:<p class="source-code">config.vm.provider :libvirt do |libvirt|</p><p class="source-code">  libvirt.storage_pool_name = "images"</p><p class="source-code">  libvirt.driver = "qemu" # or kvm</p><p class="source-code">end</p><p class="calibre3">This will configure the libvirt provider to use the <strong class="source-inline">images</strong> directory as the default storage pool, and use the QEMU driver within libvirt.</p></li>
				<li class="calibre9">Still inside the <strong class="source-inline">Vagrantfile</strong>, add the following code to give the box a proper name:<p class="source-code">config.vm.define :test do |test|</p><p class="source-code">  test.vm.box = "fedora/32-cloud-base"</p><p class="source-code">end</p><p class="calibre3">The name chosen here is <strong class="source-inline">test</strong>, and will result in a virtual guest named <strong class="source-inline">vagrant_test</strong>.</p></li>
				<li class="calibre9">To launch the test guest, run the <strong class="source-inline">vagrant up</strong> command like so:<p class="source-code"><strong class="bold"># vagrant up --provider=libvirt</strong></p><p class="calibre3">Depending on the speed of the system, this step can take a while to complete.</p><p class="callout-heading">Tip</p><p class="callout">Rather than calling <strong class="source-inline">vagrant up</strong> every time with the <strong class="source-inline">--provider=libvirt</strong> parameter, we can also declare the <strong class="source-inline">VAGRANT_DEFAULT_PROVIDER="libvirt"</strong> environment variable and drop the command-line argument, as the environment variable will then be used.</p></li>
			</ol>
			<p class="calibre3">Once the <a id="_idIndexMarker717" class="pcalibre calibre6 pcalibre1"/>guest is up and running, you can connect to it using <strong class="source-inline">vagrant ssh</strong>. While you can manipulate the guest with the <strong class="source-inline">virsh</strong> commands, you can also use <strong class="source-inline">vagrant halt</strong> to shut down, or <strong class="source-inline">vagrant destroy</strong> followed by <strong class="source-inline">vagrant box remove</strong> to remove the box from the system completely.</p>
			<h2 id="_idParaDest-272" class="calibre10"><a id="_idTextAnchor276" class="pcalibre calibre6 pcalibre1"/>Configuring Vagrant boxes</h2>
			<p class="calibre3">Once a <a id="_idIndexMarker718" class="pcalibre calibre6 pcalibre1"/>box is deployed, it is available through libvirt as a standard guest. That means that the operations we've seen before to modify its labels or tweak SELinux controls using the SELinux booleans still apply.</p>
			<p class="calibre3">Let's first verify that Vagrant is indeed using libvirt to launch its own boxes:</p>
			<p class="source-code"># virsh list --all</p>
			<p class="source-code"> Id    Name            State</p>
			<p class="source-code">-----------------------------</p>
			<p class="source-code"> 1     vagrant_test    running</p>
			<p class="calibre3">Sure enough, the <a id="_idIndexMarker719" class="pcalibre calibre6 pcalibre1"/>guest is available and titled <strong class="source-inline">vagrant_test</strong>. We can modify its configuration with <strong class="source-inline">virsh edit</strong> as well:</p>
			<p class="source-code"># virsh edit vagrant_test</p>
			<p class="calibre3">As long as the Vagrant box is not destroyed, the settings in libvirt will persist. </p>
			<h1 id="_idParaDest-273" class="calibre5"><a id="_idTextAnchor277" class="pcalibre calibre6 pcalibre1"/>Summary</h1>
			<p class="calibre3">Virtualization is a powerful technology whose security posture can be augmented thanks to SELinux. With sVirt, the open source community has a powerful approach to isolate guests and ensure virtual machines are only able to access the resources they should.</p>
			<p class="calibre3">In this chapter, we looked at virtualization and the risks associated with it. We discussed how some of these risks can be mitigated through the same set of controls that SELinux offers, such as type enforcement (limiting what guests can do) and MCS confinement (isolating guests from each other).</p>
			<p class="calibre3">We then covered how libvirt supports several virtualization technologies on Linux platforms and how it includes a technology called sVirt that enables SELinux integration, offering guest isolation and access controls. We saw how administrators can manipulate the sVirt logic within libvirt, such as through different domain labels or category sets. We finished the chapter with information on how to use Vagrant with libvirt.</p>
			<p class="calibre3">In the next chapter, we'll look at another virtualization solution, called Xen, which has adopted an SELinux-based technology for its hardening.</p>
			<h1 id="_idParaDest-274" class="calibre5"><a id="_idTextAnchor278" class="pcalibre calibre6 pcalibre1"/>Questions</h1>
			<ol class="calibre18">
				<li value="1" class="calibre9">What is unique about sVirt that cannot be done with regular SELinux configuration?</li>
				<li class="calibre9">What are the two main risks that SELinux tackles with virtualization?</li>
				<li class="calibre9">What is the difference between <strong class="source-inline">virt_image_t</strong>, <strong class="source-inline">svirt_image_t</strong>, and <strong class="source-inline">virt_content_t</strong>?</li>
				<li class="calibre9">How do you change guest labels with libvirt?</li>
				<li class="calibre9">How can we use Vagrant yet still benefit from sVirt?</li>
			</ol>
		</div>
	</div></body></html>