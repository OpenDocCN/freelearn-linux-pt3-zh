<html><head></head><body>
<div class="Basic-Text-Frame" id="_idContainer088">
<h1 class="chapterNumber"><span class="koboSpan" id="kobo.1.1">17</span></h1>
<h1 class="chapterTitle" id="_idParaDest-388"><span class="koboSpan" id="kobo.2.1">Load Balancing and HTTP</span></h1>
<p class="normal"><span class="koboSpan" id="kobo.3.1">We’re going to take a slightly different approach with this chapter, so buckle up. </span><span class="koboSpan" id="kobo.3.2">On the one hand, we’re going to review some background on the </span><strong class="keyWord"><span class="koboSpan" id="kobo.4.1">Hypertext Transfer Protocol</span></strong><span class="koboSpan" id="kobo.5.1"> (</span><strong class="keyWord"><span class="koboSpan" id="kobo.6.1">HTTP</span></strong><span class="koboSpan" id="kobo.7.1">) and focus on </span><a id="_idIndexMarker614"/><span class="koboSpan" id="kobo.8.1">some misconceptions that trip up many web developers in the real world.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.9.1">On the other hand, we’re going to keep this practical and cover one of the most powerful standard HTTP </span><a id="_idIndexMarker615"/><span class="koboSpan" id="kobo.10.1">tools that’s available on the command line, </span><code class="inlineCode"><span class="koboSpan" id="kobo.11.1">curl</span></code><span class="koboSpan" id="kobo.12.1">. </span><span class="koboSpan" id="kobo.12.2">Specifically, we’re going to teach you the basics of </span><code class="inlineCode"><span class="koboSpan" id="kobo.13.1">curl</span></code><span class="koboSpan" id="kobo.14.1"> in the context of how you can use it to troubleshoot common web application issues.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.15.1">We assume that if you’re a web developer, you already know your way around HTTP. </span><span class="koboSpan" id="kobo.15.2">So, while the goal of this chapter is not to teach you the absolute basics of this protocol, we are going to review some of those basics to get you up to speed if it’s been a while. </span><span class="koboSpan" id="kobo.15.3">If you </span><em class="italic"><span class="koboSpan" id="kobo.16.1">are</span></em><span class="koboSpan" id="kobo.17.1"> totally new to HTTP, there is lots of excellent documentation on the web that you can use. </span><span class="koboSpan" id="kobo.17.2">For what it’s worth, we highly recommend MDN by Mozilla as your source for this information.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.18.1">Instead, we want to focus on the common misunderstandings and pitfalls around HTTP and how it’s used in the real world, which often catch people by surprise. </span><span class="koboSpan" id="kobo.18.2">These misunderstandings often come from the fact that as a developer, you write web applications in a very simple local environment but run them in complicated production setups that look quite different from the laptop you built and tested them on.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.19.1">This difference between what an application interacts with when in development on a local machine, and the infrastructure around it after it has been deployed to a staging or production environment, is the source of much confusion and many subtle bugs.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.20.1">In this chapter, we’ll cover the most important of these differences: you’ll learn about gateways, upstreams, and other concepts that intersect with the infrastructure layer around a modern website or web application. </span><span class="koboSpan" id="kobo.20.2">Then we’ll cover some of the most common mistakes people make with HTTP that cause hard-to-debug issues with headers, status codes, and more. </span><span class="koboSpan" id="kobo.20.3">We’ll look at some of the modern security features that have been added, such </span><a id="_idIndexMarker616"/><span class="koboSpan" id="kobo.21.1">as </span><strong class="keyWord"><span class="koboSpan" id="kobo.22.1">Cross-Origin Resource Sharing</span></strong><span class="koboSpan" id="kobo.23.1"> (</span><strong class="keyWord"><span class="koboSpan" id="kobo.24.1">CORS</span></strong><span class="koboSpan" id="kobo.25.1">), along with the history of HTTP and the versions you’re likely to come across. </span><span class="koboSpan" id="kobo.25.2">Finally, you’ll learn a bit about how load balancing is done: knowing the basics will prevent you from having an incorrect model of the client request path in your mind, which is a common source of design problems at the application/infrastructure boundary.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.26.1">You’ll learn:</span></p>
<ul>
<li class="bulletList"><span class="koboSpan" id="kobo.27.1">Some basic terminology that you’ll need to understand the more complex web infrastructure we discuss later in the chapter.</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.28.1">Common misunderstandings about HTTP statuses, which when fully understood, can help you write cleaner and more correct status-handling code.</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.29.1">HTTP headers, and some related problems you might see in your own web applications.</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.30.1">The different HTTP versions you might encounter in the wild.</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.31.1">How load balancing works, and why you need to understand it as a developer, even if you never plan on touching application infrastructure.</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.32.1">How to troubleshoot web issues relating to all of these topics from the command line with a tool called </span><code class="inlineCode"><span class="koboSpan" id="kobo.33.1">curl</span></code><span class="koboSpan" id="kobo.34.1">.</span></li>
</ul>
<p class="normal"><span class="koboSpan" id="kobo.35.1">The only prerequisite knowledge for this chapter is a basic understanding of how HTTP requests work, and a basic idea of the developer tooling that exists for web applications (for example, you should know how to use your browser’s console and other dev tools to debug basic HTTP issues).</span></p>
<p class="normal"><span class="koboSpan" id="kobo.36.1">Let’s start with some basic terminology that will come in handy when we get to troubleshooting.</span></p>
<h1 class="heading-1" id="_idParaDest-389"><span class="koboSpan" id="kobo.37.1">Basic terminology</span></h1>
<p class="normal"><span class="koboSpan" id="kobo.38.1">Later sections will use a few terms you may not be familiar with, so let’s quickly cover them here.</span></p>
<h2 class="heading-2" id="_idParaDest-390"><span class="koboSpan" id="kobo.39.1">Gateway</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.40.1">In today’s world, the gateway</span><a id="_idIndexMarker617"/><span class="koboSpan" id="kobo.41.1"> is usually an HTTP reverse proxy, a load balancer, and frequently a combination of both. </span><span class="koboSpan" id="kobo.41.2">This can be an HTTP server, such as nginx or Apache, a physical load balancer in the classical sense, or a cloud variant of this same idea. </span><span class="koboSpan" id="kobo.41.3">It can also be a </span><strong class="keyWord"><span class="koboSpan" id="kobo.42.1">content-delivery network</span></strong><span class="koboSpan" id="kobo.43.1"> (</span><strong class="keyWord"><span class="koboSpan" id="kobo.44.1">CDN</span></strong><span class="koboSpan" id="kobo.45.1">). </span><span class="koboSpan" id="kobo.45.2">So, when </span><a id="_idIndexMarker618"/><span class="koboSpan" id="kobo.46.1">you receive an HTTP status code mentioning an error related to the gateway, it’s one of these gateway devices or applications talking to you.</span></p>
<h2 class="heading-2" id="_idParaDest-391"><span class="koboSpan" id="kobo.47.1">Upstream</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.48.1">The upstream</span><a id="_idIndexMarker619"/><span class="koboSpan" id="kobo.49.1"> is the service that an application proxies to. </span><span class="koboSpan" id="kobo.49.2">In most situations, this will be the actual application or service, for example, an HTTP service you wrote. </span><span class="koboSpan" id="kobo.49.3">It is good to keep in mind that one can cascade or layer proxies, so there might be another intermediate proxy between the first proxy and the actual web application. </span><span class="koboSpan" id="kobo.49.4">For example, in many cloud infrastructures there is an ingress load balancer that handles and filters incoming traffic, behind which is an application load balancer that actually inspects the HTTP traffic and routes it to the right application server pool.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.50.1">Now that we’ve covered a few bits of terminology that go beyond HTTP, you’re prepared for the later sections of this chapter. </span><span class="koboSpan" id="kobo.50.2">Let’s now take a closer look at a few commonly misunderstood parts of HTTP and start using the </span><code class="inlineCode"><span class="koboSpan" id="kobo.51.1">curl</span></code><span class="koboSpan" id="kobo.52.1"> tool to practice common CLI troubleshooting commands.</span></p>
<h1 class="heading-1" id="_idParaDest-392"><span class="koboSpan" id="kobo.53.1">Common misunderstandings about HTTP</span></h1>
<p class="normal"><span class="koboSpan" id="kobo.54.1">When developing web applications and HTTP APIs, it can pay to be aware of a few details that many developers miss. </span><span class="koboSpan" id="kobo.54.2">Let’s look at a few of the key areas where knowing a bit extra can really pay off in terms of the reliability of the applications you create. </span><span class="koboSpan" id="kobo.54.3">The </span><code class="inlineCode"><span class="koboSpan" id="kobo.55.1">curl</span></code><span class="koboSpan" id="kobo.56.1"> skills we cover in this chapter will also give you the ability to start troubleshooting something as vague as “the website is down” from the command line.</span></p>
<h2 class="heading-2" id="_idParaDest-393"><span class="koboSpan" id="kobo.57.1">HTTP statuses</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.58.1">In the following sections, we will cover some of the common HTTP statuses you’ll encounter. </span><span class="koboSpan" id="kobo.58.2">We’ll also consider some important information and myths about these statuses that you should keep in mind.</span></p>
<h3 class="heading-3" id="_idParaDest-394"><span class="koboSpan" id="kobo.59.1">Don’t just check for 200 OK</span></h3>
<p class="normal"><span class="koboSpan" id="kobo.60.1">A common way to check</span><a id="_idIndexMarker620"/><span class="koboSpan" id="kobo.61.1"> for errors is only checking for a 200 or the whole 2xx range of status codes to know whether a request was a success. </span><span class="koboSpan" id="kobo.61.2">There are some caveats to be aware of when doing this, though.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.62.1">The 200 range (2xx, as in, every status code between 200 and 299) tends to indicate success and many APIs return 204 No Content to indicate that an operation was successful, especially when the API usually returns the resource that was created or modified, but in certain scenarios, like DELETEs or when it would be a waste of resources, it does not.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.63.1">Checking to see whether a response status is inside the 2xx range might be enough for some applications, but it is important to understand that application logic like “if it’s not a 200, log an error” is wrong. </span><span class="koboSpan" id="kobo.63.2">Neither the 1xx range nor the 3xx range indicate an error, even though they aren’t 200s. </span></p>
<p class="normal"><span class="koboSpan" id="kobo.64.1">It’s somewhat rare to see the 1xx range without expecting it, since the most common situations involving 100s are things like switching to WebSockets, but that doesn’t make them errors. </span><span class="koboSpan" id="kobo.64.2">The 3xx status code is returned quite often to inform the client about redirections, and while it might indicate that some action is needed – perhaps updating a path for some content that has moved – it’s definitely not a failure on its own.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.65.1">One status code in the 3xx range that tends to be seen a lot more often in production than in development is 304 Not Modified. </span><span class="koboSpan" id="kobo.65.2">This can be easily overlooked at development time and might also appear due to infrastructure changes or library updates that improve or introduce new caching behaviors. </span><span class="koboSpan" id="kobo.65.3">This status code is used when the client, such as a browser or an HTTP library, sends the request with an If-Not-Modified header, especially to take advantage of caching.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.66.1">For these reasons, it</span><a id="_idIndexMarker621"/><span class="koboSpan" id="kobo.67.1"> usually makes sense to only consider status codes starting with 400 to be any kind of potential error, instead of considering only 2xx status codes to be a success. </span><span class="koboSpan" id="kobo.67.2">This still lends itself to neat logic inside your application: checking if a status code is greater than or equal to 400 is just as concise as checking to see if it’s in the 2xx range.</span></p>
<h3 class="heading-3" id="_idParaDest-395"><span class="koboSpan" id="kobo.68.1">404 Not Found</span></h3>
<p class="normal"><span class="koboSpan" id="kobo.69.1">Something important to keep in</span><a id="_idIndexMarker622"/><span class="koboSpan" id="kobo.70.1"> mind is that the Not Found status code can mean different things depending on the application. </span><span class="koboSpan" id="kobo.70.2">404 can be returned by (file) servers and gateways, but also by the application. </span><span class="koboSpan" id="kobo.70.3">It can imply that a route does not exist, but also that a specific resource (for example, a post or comment) does not exist for some reason (for example, if, it was deleted).</span></p>
<p class="normal"><span class="koboSpan" id="kobo.71.1">This is why 404 is often part of the normal response set returned by a healthy application that’s working as designed. </span><span class="koboSpan" id="kobo.71.2">In some situations, a client might even depend on this behavior, for example to verify that something doesn’t exist – before creating a certain resource or when indicating to a user whether a certain resource or resource name is already taken.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.72.1">In other words, the 404 status</span><a id="_idIndexMarker623"/><span class="koboSpan" id="kobo.73.1"> code alone (without more context about the application and the request) isn’t enough to indicate a problem. </span><span class="koboSpan" id="kobo.73.2">As you just saw, it may even indicate a success on multiple levels and layers. </span><span class="koboSpan" id="kobo.73.3">This is sometimes avoided by not using it in the application layer and signaling any “Not Found” situations differently, for example by still returning a status code of 200. </span><span class="koboSpan" id="kobo.73.4">What the right way is depends on both the application and what a team or standard agrees on, and which architectural style is used in your application.</span></p>
<h3 class="heading-3" id="_idParaDest-396"><span class="koboSpan" id="kobo.74.1">502 Bad Gateway</span></h3>
<p class="normal"><span class="koboSpan" id="kobo.75.1">This status code means that the </span><a id="_idIndexMarker624"/><span class="koboSpan" id="kobo.76.1">gateway didn’t understand what the upstream returned; in other words, the response to the request that the gateway forwarded wasn’t a complete and valid HTTP response. </span><span class="koboSpan" id="kobo.76.2">This typically indicates a problem with the upstream service.</span></p>
<h3 class="heading-3" id="_idParaDest-397"><span class="koboSpan" id="kobo.77.1">503 Service Unavailable</span></h3>
<p class="normal"><span class="koboSpan" id="kobo.78.1">A 503 usually means that the</span><a id="_idIndexMarker625"/><span class="koboSpan" id="kobo.79.1"> upstream service isn’t reachable on the port that the gateway is configured to try. </span><span class="koboSpan" id="kobo.79.2">Practically, this means that the web application might have crashed, or that it’s not listening for HTTP requests, or that it’s listening on the wrong port, or that it’s blocked by a firewall rule or a broken routing rule, or a myriad of other reasons.</span></p>
<h3 class="heading-3" id="_idParaDest-398"><span class="koboSpan" id="kobo.80.1">504 Gateway Timeout</span></h3>
<p class="normal"><span class="koboSpan" id="kobo.81.1">When a gateway creates a </span><a id="_idIndexMarker626"/><span class="koboSpan" id="kobo.82.1">connection to an upstream, this connection times out at some point. </span><span class="koboSpan" id="kobo.82.2">This is important because hanging processes consume resources on both ends; on the gateway </span><em class="italic"><span class="koboSpan" id="kobo.83.1">and</span></em><span class="koboSpan" id="kobo.84.1"> the service. </span><span class="koboSpan" id="kobo.84.2">Usually, such timeouts only occur if this is unexpected and there are no bytes being written or read.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.85.1">If the upstream service has a long-running request caused by waiting for computation or something similar, one option is to increase the time a request can take until this timeout occurs. </span><span class="koboSpan" id="kobo.85.2">However, it is usually advisable to take a different approach. </span><span class="koboSpan" id="kobo.85.3">For example, making that endpoint asynchronous or starting to write bytes earlier (such as by streaming data) can help.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.86.1">The reason for this is that until there is a timeout, resources are used up and the requesting side doesn’t know whether the application will ever return a response. </span><span class="koboSpan" id="kobo.86.2">So, if the web service malfunctions, neither the gateway nor the client will know about it. </span><span class="koboSpan" id="kobo.86.3">This might also cause the gateway to think that the malfunctioning service is still up and running, instead of quickly detecting the problem and failing over to another instance of the service.</span></p>
<h3 class="heading-3" id="_idParaDest-399"><span class="koboSpan" id="kobo.87.1">Introduction to curl: checking HTTP response status</span></h3>
<p class="normal"><span class="koboSpan" id="kobo.88.1">If you learn only one command-line tool to help you troubleshoot HTTP, you would do well to learn</span><a id="_idIndexMarker627"/> <code class="inlineCode"><span class="koboSpan" id="kobo.89.1">curl</span></code><span class="koboSpan" id="kobo.90.1">. </span><span class="koboSpan" id="kobo.90.2">As we continue to talk about areas of HTTP that are useful to understand in more depth, we’ll add sections like this to show you practical </span><code class="inlineCode"><span class="koboSpan" id="kobo.91.1">curl</span></code><span class="koboSpan" id="kobo.92.1"> commands you can use while </span><a id="_idIndexMarker628"/><span class="koboSpan" id="kobo.93.1">troubleshooting common issues related to the aspects of HTTP we just covered.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.94.1">The simplest </span><code class="inlineCode"><span class="koboSpan" id="kobo.95.1">curl</span></code><span class="koboSpan" id="kobo.96.1"> invocation is something like this:</span></p>
<pre class="programlisting con"><code class="hljs-con"><span class="koboSpan" id="kobo.97.1">curl https://tutorialinux.com/
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.98.1">This is just like pasting the URL into the browser – except it cuts out the browser and directly returns the web server’s response on the command line. </span><span class="koboSpan" id="kobo.98.2">Not the most exciting way to browse the web, to be sure. </span><span class="koboSpan" id="kobo.98.3">Let’s do something that’s a bit more useful for your next troubleshooting script: checking the status of an HTTP response!</span></p>
<p class="normal"><span class="koboSpan" id="kobo.99.1">Curl can easily be used to check whether a web server is up and responding to requests:</span></p>
<pre class="programlisting con"><code class="hljs-con"><span class="koboSpan" id="kobo.100.1">curl -IsS https://tutorialinux.com/ | head -n 1
HTTP/2 200
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.101.1">Based on this output, we know that the web server is up and the </span><code class="inlineCode"><span class="koboSpan" id="kobo.102.1">/</span></code><span class="koboSpan" id="kobo.103.1"> route is responding with a 200 OK status. </span><span class="koboSpan" id="kobo.103.2">You also see the HTTP version here (HTTP/2), which we’ll discuss later. </span><span class="koboSpan" id="kobo.103.3">Specifically, this command issues a HEAD request (</span><code class="inlineCode"><span class="koboSpan" id="kobo.104.1">-I</span></code><span class="koboSpan" id="kobo.105.1"> or</span><code class="inlineCode"><span class="koboSpan" id="kobo.106.1"> --head</span></code><span class="koboSpan" id="kobo.107.1">), muting curl’s progress and error messages (</span><code class="inlineCode"><span class="koboSpan" id="kobo.108.1">-s</span></code><span class="koboSpan" id="kobo.109.1"> or </span><code class="inlineCode"><span class="koboSpan" id="kobo.110.1">--silent</span></code><span class="koboSpan" id="kobo.111.1">).</span></p>
<p class="normal"><span class="koboSpan" id="kobo.112.1">You’ll still see error messages when something is wrong, though, thanks to the </span><code class="inlineCode"><span class="koboSpan" id="kobo.113.1">-S</span></code><span class="koboSpan" id="kobo.114.1"> (or </span><code class="inlineCode"><span class="koboSpan" id="kobo.115.1">--show-error</span></code><span class="koboSpan" id="kobo.116.1">) option:</span></p>
<pre class="programlisting con"><code class="hljs-con"><span class="koboSpan" id="kobo.117.1">curl -IsS https://tutoriajsdkfksjdhfkjshdflinux.com/ | head -n 1
curl: (6) Could not resolve host: tutoriajsdkfksjdhfkjshdflinux.com
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.118.1">Finally, we’re chopping off most of the headers and only looking for the status code, which is the first line (</span><code class="inlineCode"><span class="koboSpan" id="kobo.119.1">| head -n 1</span></code><span class="koboSpan" id="kobo.120.1">).</span></p>
<p class="normal"><span class="koboSpan" id="kobo.121.1">However, you’ll often want to see the headers when troubleshooting. </span><span class="koboSpan" id="kobo.121.2">Let’s look at a few header-related HTTP gotchas and then try using </span><code class="inlineCode"><span class="koboSpan" id="kobo.122.1">curl</span></code><span class="koboSpan" id="kobo.123.1"> to inspect headers.</span></p>
<h2 class="heading-2" id="_idParaDest-400"><span class="koboSpan" id="kobo.124.1">HTTP headers</span></h2>
<h3 class="heading-3" id="_idParaDest-401"><span class="koboSpan" id="kobo.125.1">Case-insensitive headers</span></h3>
<p class="normal"><span class="koboSpan" id="kobo.126.1">The headers in HTTP are</span><a id="_idIndexMarker629"/><span class="koboSpan" id="kobo.127.1"> case-insensitive. </span><span class="koboSpan" id="kobo.127.2">Some software relies on this fact, and as a result certain gateways might modify and “normalize” these headers. </span><span class="koboSpan" id="kobo.127.3">Fortunately, it is rare for developers to directly interact with raw header values when writing a web application. </span><span class="koboSpan" id="kobo.127.4">Instead, they use web libraries, which abstract most of this complexity away and take care of these kinds of details. </span><span class="koboSpan" id="kobo.127.5">However, you should still make sure this is the case and normalize them, for example by lower-casing headers that your web application sets. </span><span class="koboSpan" id="kobo.127.6">This can also prevent situations where response headers are accidentally added multiple times with different letter casings.</span></p>
<h3 class="heading-3" id="_idParaDest-402"><span class="koboSpan" id="kobo.128.1">Custom headers</span></h3>
<p class="normal"><span class="koboSpan" id="kobo.129.1">When you create custom </span><a id="_idIndexMarker630"/><span class="koboSpan" id="kobo.130.1">HTTP headers for an application, be aware of the prefix you decide to use. </span><span class="koboSpan" id="kobo.130.2">It used to be common to prefix custom headers with </span><code class="inlineCode"><span class="koboSpan" id="kobo.131.1">X-</span></code><span class="koboSpan" id="kobo.132.1">, for example </span><code class="inlineCode"><span class="koboSpan" id="kobo.133.1">X-My-Header</span></code><span class="koboSpan" id="kobo.134.1">. </span><span class="koboSpan" id="kobo.134.2">This practice is now considered bad (see </span><span class="Hyperlink"><span class="koboSpan" id="kobo.135.1">RFC 6648</span></span><span class="koboSpan" id="kobo.136.1">, which deprecates it). </span><span class="koboSpan" id="kobo.136.2">Instead, it makes sense to create a custom prefix, such as the name of the project, product, or company, or an abbreviation of it. </span><span class="koboSpan" id="kobo.136.3">This prevents situations where that header will be reused by other developers who mistake it for an official part of the HTTP standard.</span></p>
<h3 class="heading-3" id="_idParaDest-403"><span class="koboSpan" id="kobo.137.1">Viewing HTTP headers with curl</span></h3>
<p class="normal"><span class="koboSpan" id="kobo.138.1">The </span><code class="inlineCode"><span class="koboSpan" id="kobo.139.1">-I</span></code><span class="koboSpan" id="kobo.140.1"> option we</span><a id="_idIndexMarker631"/><span class="koboSpan" id="kobo.141.1"> introduced in the previous </span><code class="inlineCode"><span class="koboSpan" id="kobo.142.1">curl</span></code><span class="koboSpan" id="kobo.143.1"> example is useful for </span><a id="_idIndexMarker632"/><span class="koboSpan" id="kobo.144.1">viewing the response headers, which can help reveal caching problems, content-type mismatches, and other issues. </span><span class="koboSpan" id="kobo.144.2">Let’s see what the tutorialinux server has to say in its headers:</span></p>
<pre class="programlisting con"><code class="hljs-con"><span class="koboSpan" id="kobo.145.1">curl -I https://tutorialinux.com/
HTTP/2 200
server: nginx/1.24.0
date: Sat, 21 Oct 2023 16:37:12 GMT
content-type: text/html; charset=UTF-8
vary: Accept-Encoding
x-powered-by: PHP/8.2.11
link: &lt;https://tutorialinux.com/wp-json/&gt;; rel="https://api.w.org/"
strict-transport-security: max-age=31536000; includeSubdomains; preload
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.146.1">There’s nothing </span><a id="_idIndexMarker633"/><span class="koboSpan" id="kobo.147.1">wrong with the server at the moment, but these </span><a id="_idIndexMarker634"/><span class="koboSpan" id="kobo.148.1">headers already give me a few ideas of how to improve my nginx configuration: leaking software names and version numbers is usually a bad idea from a security perspective, and no one receiving HTML or JSON from this server needs to know that the backend is using PHP.</span></p>
<h2 class="heading-2" id="_idParaDest-404"><span class="koboSpan" id="kobo.149.1">HTTP versions</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.150.1">To explain </span><a id="_idIndexMarker635"/><span class="koboSpan" id="kobo.151.1">some of the newer HTTP features you’ll see used, we’ll give you a brief history of the protocol. </span><span class="koboSpan" id="kobo.151.2">HTTP has been around for a while and has changed a lot, especially in recent years as web applications have come into vogue. </span><span class="koboSpan" id="kobo.151.3">The main concepts and primitives have largely remained the same since HTTP’s inception, however, some tricks, optimizations, and behaviors have changed. </span><span class="koboSpan" id="kobo.151.4">Being aware of the protocol version can help with debugging or preventing issues and reduce unnecessary or counter-productive optimizations and workarounds.</span></p>
<h3 class="heading-3" id="_idParaDest-405"><span class="koboSpan" id="kobo.152.1">HTTP/0.9</span></h3>
<p class="normal"><span class="koboSpan" id="kobo.153.1">You’re unlikely to come across this version of HTTP anymore. </span><span class="koboSpan" id="kobo.153.2">It is the most minimal HTTP one can imagine. </span><span class="koboSpan" id="kobo.153.3">HTTP/0.9 allows </span><a id="_idIndexMarker636"/><span class="koboSpan" id="kobo.154.1">for sending a </span><code class="inlineCode"><span class="koboSpan" id="kobo.155.1">GET</span></code><span class="koboSpan" id="kobo.156.1"> request to a server and receiving what we now call the </span><em class="italic"><span class="koboSpan" id="kobo.157.1">body </span></em><span class="koboSpan" id="kobo.158.1">of an HTTP request. </span><span class="koboSpan" id="kobo.158.2">No headers were sent or returned, not even a version header or a status code.</span></p>
<h3 class="heading-3" id="_idParaDest-406"><span class="koboSpan" id="kobo.159.1">HTTP/1.0 and HTTP/1.1</span></h3>
<p class="normal"><span class="koboSpan" id="kobo.160.1">HTTP/1.0 and</span><a id="_idIndexMarker637"/><span class="koboSpan" id="kobo.161.1"> especially HTTP/1.1 came </span><a id="_idIndexMarker638"/><span class="koboSpan" id="kobo.162.1">a lot closer to what people think of when they think of HTTP today. </span><span class="koboSpan" id="kobo.162.2">While HTTP/1.0 added a version number and headers, HTTP/1.1 paved the way for methods and a substantial number of extensions, usually in the form of headers.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.163.1">HTTP/1.1 also added (and defaults to) pipelining. </span><span class="koboSpan" id="kobo.163.2">This means that multiple requests could be sent using the same TCP connection. </span><span class="koboSpan" id="kobo.163.3">Another widely used addition is the </span><code class="inlineCode"><span class="koboSpan" id="kobo.164.1">Host</span></code><span class="koboSpan" id="kobo.165.1"> header, which allows for the same server or IP to use multiple hostnames. </span></p>
<p class="normal"><span class="koboSpan" id="kobo.166.1">For example, a web server could now be configured to respond with requests for </span><code class="inlineCode"><span class="koboSpan" id="kobo.167.1">http://example.org/</span></code><span class="koboSpan" id="kobo.168.1">, </span><code class="inlineCode"><span class="koboSpan" id="kobo.169.1">http://www.example.org/</span></code><span class="koboSpan" id="kobo.170.1">, </span><code class="inlineCode"><span class="koboSpan" id="kobo.171.1">http://forum.example.org/</span></code><span class="koboSpan" id="kobo.172.1">, and </span><code class="inlineCode"><span class="koboSpan" id="kobo.173.1">http://blog.example.org/</span></code><span class="koboSpan" id="kobo.174.1"> without requiring a separate IP address for each of them.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.175.1">HTTP/1.1 also enabled many extensions: caching, compression, various authentication schemes, content negotiation, and even things like WebSockets. </span><span class="koboSpan" id="kobo.175.2">All of these are widely used in today’s web.</span></p>
<h3 class="heading-3" id="_idParaDest-407"><span class="koboSpan" id="kobo.176.1">HTTP/2</span></h3>
<p class="normal"><span class="koboSpan" id="kobo.177.1">There are many articles </span><a id="_idIndexMarker639"/><span class="koboSpan" id="kobo.178.1">extolling the virtues of HTTP/2. </span><span class="koboSpan" id="kobo.178.2">It is a huge and controversial step in a new direction for HTTP. </span><span class="koboSpan" id="kobo.178.3">While HTTP/1.1 was a text-based protocol that allowed anyone to create complete and valid requests in a terminal or text editor, HTTP/2 is a binary protocol that also handles streams, which are a mechanism to create a lightweight variant of a TCP connection.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.179.1">The binary format and header compression mean that dedicated tools are now required to talk to an HTTP server (or client). </span><span class="koboSpan" id="kobo.179.2">The overall concepts, however, have remained the same as in earlier versions of HTTP, so as a web developer you’ll only notice the differences in specific situations.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.180.1">While HTTP/2 also adds a lot of entirely new features, many of them are rarely used in user-facing web applications and might not even be implemented by browsers.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.181.1">While this isn’t technically part of the official standard, HTTP/2 in the browser is typically limited to HTTPS.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.182.1">In most situations, web</span><a id="_idIndexMarker640"/><span class="koboSpan" id="kobo.183.1"> applications will benefit from enhancements such as using a single TCP connection with multiple streams, especially when many requests, such as those for static files and AJAX, are made in parallel. </span><span class="koboSpan" id="kobo.183.2">This can render some optimizations, like sprite sheets or combining many files into a single one, unnecessary. </span><span class="koboSpan" id="kobo.183.3">When some of these optimizations lead to redundant data being transferred, they might even be counterproductive.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.184.1">Some applications designed for HTTP/1.1 might require changes when switching to HTTP/2, because things like keeping connections alive might have unpredictable side-effects. </span><span class="koboSpan" id="kobo.184.2">For this and other reasons, it’s a good idea to test web applications before converting them to HTTP/2. </span><span class="koboSpan" id="kobo.184.3">There are even instances where people have found that switching their applications to HTTP/2 increases page load times or increases resource use.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.185.1">This means that real life tests and monitoring to compare the differences between HTTP protocols are a good idea. </span><span class="koboSpan" id="kobo.185.2">Since many of the benefits of HTTP/2 target real-life usage by web browsers, a simple command-line load test might not give the same results as real users accessing the web application. </span><span class="koboSpan" id="kobo.185.3">A typical mistake, for example, is not taking HTTP/1.1’s pipelining feature into consideration.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.186.1">However, for most real-life websites, HTTP/2 will bring benefits. </span><span class="koboSpan" id="kobo.186.2">For internal HTTP APIs on microservices, many companies are choosing to keep using HTTP/1.1 or gRPC.</span></p>
<h3 class="heading-3" id="_idParaDest-408"><span class="koboSpan" id="kobo.187.1">HTTP/3 and QUIC</span></h3>
<p class="normal"><span class="koboSpan" id="kobo.188.1">HTTP/3 builds </span><a id="_idIndexMarker641"/><span class="koboSpan" id="kobo.189.1">on the </span><a id="_idIndexMarker642"/><span class="koboSpan" id="kobo.190.1">developments of HTTP/2 and moves its concepts to a UDP-based transport protocol called QUIC (instead of TCP, which all other HTTP versions use).</span></p>
<p class="normal"><span class="koboSpan" id="kobo.191.1">Like the previous version of HTTP, HTTP/3 uses streams as a lightweight alternative to establishing a new TCP connection. </span><span class="koboSpan" id="kobo.191.2">Unlike HTTP/2 this isn’t done by initiating streams inside an existing TCP connection, but rather by using QUIC, which is a protocol designed to allow for such streams.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.192.1">QUIC</span><a id="_idIndexMarker643"/><span class="koboSpan" id="kobo.193.1"> has some advantages over TCP for common HTTP use cases. </span><span class="koboSpan" id="kobo.193.2">For example, because it’s UDP-based – UDP is the User Datagram Protocol, a more bare-bones but faster alternative to TCP – QUIC prevents situations where the whole connection can stall because a single packet hasn’t arrived (yet), even if that packet is destined for a different stream. </span><span class="koboSpan" id="kobo.193.3">QUIC is also optimized for quickly establishing that initial connection, including initiating TLS to secure the connection between the client and server. </span><span class="koboSpan" id="kobo.193.4">QUIC itself was created with extensibility and support for future versions in mind, and shortly after its standardization many such extensions were already on their way to being standardized.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.194.1">Since HTTP/3 is based on UDP and designed to avoid </span><em class="italic"><span class="koboSpan" id="kobo.195.1">protocol ossification</span></em><span class="koboSpan" id="kobo.196.1">, many traditional forms of intermediate nodes and gateways become obsolete.</span></p>
<div class="note">
<p class="normal"><strong class="keyWord"><span class="koboSpan" id="kobo.197.1">Note</span></strong></p>
<p class="normal"><span class="koboSpan" id="kobo.198.1">Protocol ossification is what happens when intermediate nodes (or anything that interacts with a protocol) require a protocol to keep a certain form, thereby making it hard to continue developing and changing that protocol (for example by adding extensions).</span></p>
</div>
<p class="normal"><span class="koboSpan" id="kobo.199.1">Let’s look at how these basic HTTP concepts fit into the larger infrastructure that most of your web applications will be running in. </span><span class="koboSpan" id="kobo.199.2">In an architecture like this, it’s rarely just a single web server and a client (like your web browser or </span><code class="inlineCode"><span class="koboSpan" id="kobo.200.1">curl</span></code><span class="koboSpan" id="kobo.201.1">): there are usually several layers of HTTP communication happening, and simple problems can compound and become hard to troubleshoot.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.202.1">As usual, we’ll give you the most important concepts you need to understand, followed by a few practical tips on troubleshooting more complex web infrastructures using </span><code class="inlineCode"><span class="koboSpan" id="kobo.203.1">curl</span></code><span class="koboSpan" id="kobo.204.1"> on the command line.</span></p>
<h2 class="heading-2" id="_idParaDest-409"><span class="koboSpan" id="kobo.205.1">Load balancing</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.206.1">Load balancing is a </span><a id="_idIndexMarker644"/><span class="koboSpan" id="kobo.207.1">way to spread the load destined for a service across many instances of that service. </span><span class="koboSpan" id="kobo.207.2">While this is certainly not limited to HTTP and web services, HTTP is one of the most common contexts in which load balancing is used today.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.208.1">It’s important for you to understand how web application load balancing works, because it affects how bugs and problems show up in production. </span><span class="koboSpan" id="kobo.208.2">For example, in your local development environment, you are usually dealing with a single client (your browser or another API consumer) and a single server (the web application or service you’re working on). </span><span class="koboSpan" id="kobo.208.3">In the real world, there are often multiple layers of servers between your client and the application, each speaking and relaying your HTTP traffic and possibly introducing its own problems or bugs into the flow.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.209.1">The material in this section will give you a high-level understanding of the moving parts that become part of the application as a whole, even though they’re not part of the application code you write.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.210.1">HTTP load balancing</span><a id="_idIndexMarker645"/><span class="koboSpan" id="kobo.211.1"> is usually achieved by putting a layer of infrastructure in front of the application to proxy HTTP requests; usually one of the following:</span></p>
<ol class="numberedList" style="list-style-type: decimal;">
<li class="numberedList" value="1"><span class="koboSpan" id="kobo.212.1">Gateway service, such as an HTTP server supporting it (such as nginx or Apache)</span></li>
<li class="numberedList"><span class="koboSpan" id="kobo.213.1">Dedicated service (such as HAProxy or relayd)</span></li>
<li class="numberedList"><span class="koboSpan" id="kobo.214.1">Cloud service (GCP’s Load Balancer, AWS’s ELB or ALB, and so on)</span></li>
<li class="numberedList"><span class="koboSpan" id="kobo.215.1">Hardware load balancer</span></li>
</ol>
<p class="normal"><span class="koboSpan" id="kobo.216.1">Sometimes, engineers choose to use a custom service or a DNS-based solution, especially in the context of regional load balancing which is often used as an additional layer in front of one of the other methods mentioned above. </span><span class="koboSpan" id="kobo.216.2">Container orchestrators and dedicated service discovery mechanisms also usually provide yet another mechanism for load balancing.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.217.1">Introducing load balancers into the mix pulls in a few other concepts to understand – specifically around how these load balancers actually map requests coming from a client to a server running an instance of the web application that you lovingly crafted.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.218.1">Session and cookie management becomes complex, because long-running sessions are no longer guaranteed to hit the same server every time. </span><span class="koboSpan" id="kobo.218.2">One server in your application pool going down becomes an issue – will your users’ experience be interrupted, or will they lose data? </span><span class="koboSpan" id="kobo.218.3">Will you, as an engineer troubleshooting your own web application, be unable to replicate an issue because it’s only happening on a single server out of tens or hundreds?</span></p>
<p class="normal"><span class="koboSpan" id="kobo.219.1">Understanding how modern load balancing works is essential to avoid application design flaws or troubleshooting woes like this, and the next few sections will equip you with a basic mental model that you can use to avoid them.</span></p>
<h3 class="heading-3" id="_idParaDest-410"><span class="koboSpan" id="kobo.220.1">Sticky sessions, cookies, and deterministic hashing</span></h3>
<p class="normal"><span class="koboSpan" id="kobo.221.1">When setting</span><a id="_idIndexMarker646"/><span class="koboSpan" id="kobo.222.1"> up load balancing for HTTP services, one of the first questions to ask is whether a service requires sticky sessions. </span><span class="koboSpan" id="kobo.222.2">Sticky sessions are a mechanism for tying a client to a specific application server for the duration of the session; they’re</span><a id="_idIndexMarker647"/><span class="koboSpan" id="kobo.223.1"> often required for applications that keep session state on the application server itself.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.224.1">This is one of the reasons why it’s best practice to design “stateless” applications, which write state to a shared data layer – in these applications, it doesn’t matter if a client’s first request is handled by a different server than that client’s second request. </span><span class="koboSpan" id="kobo.224.2">Thankfully in today’s world, especially when relying on a cloud-based infrastructure, sticky sessions are usually not required. </span><span class="koboSpan" id="kobo.224.3">However, this is something to keep in mind, especially when troubleshooting issues that mysteriously only crop up in load-balanced production environments.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.225.1">While there are many ways to create sticky sessions in HTTP, the most common way is through </span><a id="_idIndexMarker648"/><span class="koboSpan" id="kobo.226.1">cookies. </span><span class="koboSpan" id="kobo.226.2">This </span><a id="_idIndexMarker649"/><span class="koboSpan" id="kobo.227.1">can either be via application cookies (such as session cookies) that the load balancer is aware of, or via dedicated cookies that the load balancer manages on its own.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.228.1">Implementing sticky sessions by storing additional state on the load balancer is fraught with its own problems, though. </span><span class="koboSpan" id="kobo.228.2">If a load balancer must keep an internal mapping of IP addresses to application servers, what happens if that load balancer goes down and is replaced, losing that state? </span><span class="koboSpan" id="kobo.228.3">You can see that we’ve simply moved the state problem from the application server to the load balancer, and are hoping that nothing bad happens there. </span><span class="koboSpan" id="kobo.228.4">However, as the adage says, hope is not a viable strategy.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.229.1">One clever way to achieve sticky sessions without dealing with the problem of needing to store state on the load balancer is to load balance using an IP hash. </span><span class="koboSpan" id="kobo.229.2">To achieve this, a hash of the client’s IP is created and used to map request IPs to instances of a service. </span><span class="koboSpan" id="kobo.229.3">As long as the IP of the client stays the same, the session will be “sticky” to that particular application instance.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.230.1">Now, one or many load balancers will </span><a id="_idIndexMarker650"/><span class="koboSpan" id="kobo.231.1">deterministically match IPs to application servers, without needing to communicate or share state. </span><span class="koboSpan" id="kobo.231.2">Servers can come and go as they please, and each new server will make the same matching decisions as all other </span><a id="_idIndexMarker651"/><span class="koboSpan" id="kobo.232.1">servers, since they’re all using the same hashing algorithm and will always match a given IP to the same application server.</span></p>
<h3 class="heading-3" id="_idParaDest-411"><span class="koboSpan" id="kobo.233.1">Round-robin load balancing</span></h3>
<p class="normal"><span class="koboSpan" id="kobo.234.1">If sticky</span><a id="_idIndexMarker652"/><span class="koboSpan" id="kobo.235.1"> sessions aren’t required, the </span><a id="_idIndexMarker653"/><span class="koboSpan" id="kobo.236.1">most common mechanism for balancing load is round-robin. </span><span class="koboSpan" id="kobo.236.2">This means that every new connection or request is routed to the next instance. </span><span class="koboSpan" id="kobo.236.3">In mathematical terms this means that the instance is chosen by </span><code class="inlineCode"><span class="koboSpan" id="kobo.237.1">request_count % instance_count</span></code><span class="koboSpan" id="kobo.238.1"> (% being modulo).</span></p>
<h3 class="heading-3" id="_idParaDest-412"><span class="koboSpan" id="kobo.239.1">Other mechanisms</span></h3>
<p class="normal"><span class="koboSpan" id="kobo.240.1">You now have a high-level overview of how HTTP load balancing works in the real world. </span><span class="koboSpan" id="kobo.240.2">Of course, there are many other mechanisms that can be chosen, such as spreading the load based on resource usage, but you should be careful to really understand the effects of added complexity – many “clever” load-balancing algorithms are not without major pitfalls.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.241.1">For example, resource-utilization-based load balancers can encounter problems handling short spikes in load, which can cause underutilization of one instance and over-utilization of another, because the real-life workload the service deals is spiky and the load measurements come at the wrong time and don’t even out these spikes.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.242.1">Adding another layer of complexity to even out such spikes might cause other issues such as having many of these spikes stack on top of each other. </span><span class="koboSpan" id="kobo.242.2">If you find yourself leaving the well-trodden path of more established load-balancing mechanisms, make sure your team is putting enough technical consideration into the architecture and the context of the actual application and its usage.</span></p>
<h3 class="heading-3" id="_idParaDest-413"><span class="koboSpan" id="kobo.243.1">High availability</span></h3>
<p class="normal"><span class="koboSpan" id="kobo.244.1">While a primary goal of </span><a id="_idIndexMarker654"/><span class="koboSpan" id="kobo.245.1">load balancing might be to ensure quick responses, a load balancer will typically keep track of which services are reachable. </span><span class="koboSpan" id="kobo.245.2">It might use health checking to verify that the servers it sends requests to are fully functional. </span><span class="koboSpan" id="kobo.245.3">This means that load balancing is also a way to achieve high availability and often also an integral part of a zero-downtime architecture where a service can be replaced (for example, when a new version is deployed) without clients noticing.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.246.1">This can be achieved by allowing some form of graceful shutdown of instances, where connections to clients aren’t simply dropped, but connections will remain active until they are fully processed, while new connections are only routed to updated instances. </span><span class="koboSpan" id="kobo.246.2">When the last session ends the outdated instance can be fully shut down.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.247.1">Health checks allow a load balancer to determine whether a service is fully operational. </span><span class="koboSpan" id="kobo.247.2">The most basic check, of course, is whether a connection can be established. </span><span class="koboSpan" id="kobo.247.3">However in microservice architectures, an external dependency (like another service) not being reachable can prevent a service from properly responding to requests. </span><span class="koboSpan" id="kobo.247.4">This can also be indicated via a dedicated status endpoint.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.248.1">Many application and infrastructure teams agree on a route like </span><code class="inlineCode"><span class="koboSpan" id="kobo.249.1">/healthcheck</span></code><span class="koboSpan" id="kobo.250.1">, whose status code indicates whether requests should be routed to the service. </span><span class="koboSpan" id="kobo.250.2">In some more complex environments, such a route might even indicate which </span><em class="italic"><span class="koboSpan" id="kobo.251.1">kinds </span></em><span class="koboSpan" id="kobo.252.1">of requests can be routed to the instance.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.253.1">When skilled application developers and platform/SRE teams get together, healthcheck routes can even be built to signal situations that require action from the infrastructure, such as the instance being critically unhealthy and needing to be replaced. </span><span class="koboSpan" id="kobo.253.2">If such routes are well designed, they typically also respond with additional context and information on the problem to ease debugging production issues.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.254.1">As the infrastructure that supports a web application grows larger and more complex, the number of things that can go wrong increases exponentially, and is highly dependent on the specific architecture and application. </span><span class="koboSpan" id="kobo.254.2">One class of problem that becomes more likely the more layers of proxying and routing a web infrastructure has is redirect loops and </span><a id="_idIndexMarker655"/><span class="koboSpan" id="kobo.255.1">general redirection errors.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.256.1">Thankfully, this is something that a command-line tool like </span><code class="inlineCode"><span class="koboSpan" id="kobo.257.1">curl</span></code><span class="koboSpan" id="kobo.258.1"> is perfectly positioned to troubleshoot.</span></p>
<h3 class="heading-3" id="_idParaDest-414"><span class="koboSpan" id="kobo.259.1">Troubleshooting redirects with curl</span></h3>
<p class="normal"><span class="koboSpan" id="kobo.260.1">As we just</span><a id="_idIndexMarker656"/><span class="koboSpan" id="kobo.261.1"> mentioned, redirects can be a </span><a id="_idIndexMarker657"/><span class="koboSpan" id="kobo.262.1">common symptom of bugs, problems, and </span><a id="_idIndexMarker658"/><span class="koboSpan" id="kobo.263.1">more generally unexpected behavior in a web application and its surrounding infrastructure. </span><span class="koboSpan" id="kobo.263.2">Use curl’s </span><code class="inlineCode"><span class="koboSpan" id="kobo.264.1">-L</span></code><span class="koboSpan" id="kobo.265.1"> (or </span><code class="inlineCode"><span class="koboSpan" id="kobo.266.1">--location</span></code><span class="koboSpan" id="kobo.267.1">) option to follow them:</span></p>
<pre class="programlisting con"><code class="hljs-con"><span class="koboSpan" id="kobo.268.1">curl -IL http://www.tutorialinux.com/
HTTP/1.1 301 Moved Permanently
Server: nginx/1.24.0
Date: Sun, 22 Oct 2023 22:58:02 GMT
Content-Type: text/html
Content-Length: 169
Connection: keep-alive
Location: https://tutorialinux.com/
 
HTTP/2 200
server: nginx/1.24.0
date: Sun, 22 Oct 2023 22:58:02 GMT
content-type: text/html; charset=UTF-8
vary: Accept-Encoding
x-powered-by: PHP/8.2.11
link: &lt;https://tutorialinux.com/wp-json/&gt;; rel="https://api.w.org/"
strict-transport-security: max-age=31536000; includeSubdomains; preload
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.269.1">You’ll see that the server replies with a </span><code class="inlineCode"><span class="koboSpan" id="kobo.270.1">301</span></code><span class="koboSpan" id="kobo.271.1"> (Moved Permanently) and the correct location, </span><a href="https://tutorialinux.com/"><span class="url"><span class="koboSpan" id="kobo.272.1">https://tutorialinux.com/</span></span></a><span class="koboSpan" id="kobo.273.1">. </span><code class="inlineCode"><span class="koboSpan" id="kobo.274.1">curl</span></code><span class="koboSpan" id="kobo.275.1"> follows the redirect and makes a request to that new location, where it gets a 200 (OK) status.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.276.1">This redirect is </span><a id="_idIndexMarker659"/><span class="koboSpan" id="kobo.277.1">working as expected, but you</span><a id="_idIndexMarker660"/><span class="koboSpan" id="kobo.278.1"> can use this </span><code class="inlineCode"><span class="koboSpan" id="kobo.279.1">curl</span></code><span class="koboSpan" id="kobo.280.1"> command to do things like </span><a id="_idIndexMarker661"/><span class="koboSpan" id="kobo.281.1">identify redirect loops in an application or troubleshoot caching and routing issues in multi-layer load balancer setups.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.282.1">Sometimes, though, you’ll need to go deeper and send data to a web application to troubleshoot it. </span><code class="inlineCode"><span class="koboSpan" id="kobo.283.1">curl</span></code><span class="koboSpan" id="kobo.284.1"> can help there, too!</span></p>
<h3 class="heading-3" id="_idParaDest-415"><span class="koboSpan" id="kobo.285.1">Using curl as an API testing tool</span></h3>
<p class="normal"><span class="koboSpan" id="kobo.286.1">Having a quick</span><a id="_idIndexMarker662"/> <code class="inlineCode"><span class="koboSpan" id="kobo.287.1">curl</span></code><span class="koboSpan" id="kobo.288.1"> command loaded up in your brain for </span><a id="_idIndexMarker663"/><span class="koboSpan" id="kobo.289.1">API testing comes in handy more than you’d think. </span><span class="koboSpan" id="kobo.289.2">Especially </span><a id="_idIndexMarker664"/><span class="koboSpan" id="kobo.290.1">when dealing with JSON APIs that accept POST data, it’s common to want to send some test data to an endpoint to make sure the backend is returning what you expect:</span></p>
<pre class="programlisting con"><code class="hljs-con"><span class="koboSpan" id="kobo.291.1">curl --header "Content-Type: application/json" \
     --request POST \
     --data '{"some":"JSON","goes":"here"}' \
     http://localhost:4000/api/v1/endpoint
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.292.1">This command uses a few flags that you’ll want to remember. </span><span class="koboSpan" id="kobo.292.2">First, the </span><code class="inlineCode"><span class="koboSpan" id="kobo.293.1">--header</span></code><span class="koboSpan" id="kobo.294.1"> (</span><code class="inlineCode"><span class="koboSpan" id="kobo.295.1">-H</span></code><span class="koboSpan" id="kobo.296.1">) argument lets you specify a header string to set (you can supply multiple headers by simply repeating this argument). </span><span class="koboSpan" id="kobo.296.2">Next, the </span><code class="inlineCode"><span class="koboSpan" id="kobo.297.1">--request</span></code><span class="koboSpan" id="kobo.298.1"> (or </span><code class="inlineCode"><span class="koboSpan" id="kobo.299.1">-X</span></code><span class="koboSpan" id="kobo.300.1">) flag lets you specify the HTTP request type (by default, </span><code class="inlineCode"><span class="koboSpan" id="kobo.301.1">curl</span></code><span class="koboSpan" id="kobo.302.1"> performs GET requests, but using this flag lets you change that). </span><span class="koboSpan" id="kobo.302.2">And when you’re POSTing or PATCHing some data, as in this case, you’ll want the </span><code class="inlineCode"><span class="koboSpan" id="kobo.303.1">--data</span></code><span class="koboSpan" id="kobo.304.1"> (or </span><code class="inlineCode"><span class="koboSpan" id="kobo.305.1">-d</span></code><span class="koboSpan" id="kobo.306.1">) argument, which lets you send data.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.307.1">In the case of </span><code class="inlineCode"><span class="koboSpan" id="kobo.308.1">--data</span></code><span class="koboSpan" id="kobo.309.1">, remember that bash escape characters play a role here, so for complex data you’ll probably find it easier to use the </span><code class="inlineCode"><span class="koboSpan" id="kobo.310.1">--data</span></code><span class="koboSpan" id="kobo.311.1"> option, like this:</span></p>
<pre class="programlisting con"><code class="hljs-con"><span class="koboSpan" id="kobo.312.1">curl -X POST --data "@my/data/file" https://localhost/api/v1/endpoint
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.313.1">Remember to prepend the </span><code class="inlineCode"><span class="koboSpan" id="kobo.314.1">@</span></code><span class="koboSpan" id="kobo.315.1"> character to your filepath. </span><span class="koboSpan" id="kobo.315.2">If you’re sending complex data, read up on </span><code class="inlineCode"><span class="koboSpan" id="kobo.316.1">--data-raw</span></code><span class="koboSpan" id="kobo.317.1">, </span><code class="inlineCode"><span class="koboSpan" id="kobo.318.1">--data-binary</span></code><span class="koboSpan" id="kobo.319.1">, and </span><code class="inlineCode"><span class="koboSpan" id="kobo.320.1">--data-urlencode</span></code><span class="koboSpan" id="kobo.321.1"> as well. </span><span class="koboSpan" id="kobo.321.2">You may need to send extra headers as well, depending on what your web application expects.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.322.1">You’ve now </span><a id="_idIndexMarker665"/><span class="koboSpan" id="kobo.323.1">seen how to get more interactive with the</span><a id="_idIndexMarker666"/><span class="koboSpan" id="kobo.324.1"> web applications you’re troubleshooting, using</span><a id="_idIndexMarker667"/> <code class="inlineCode"><span class="koboSpan" id="kobo.325.1">curl</span></code><span class="koboSpan" id="kobo.326.1"> to send them custom data. </span><span class="koboSpan" id="kobo.326.2">But there’s one last </span><code class="inlineCode"><span class="koboSpan" id="kobo.327.1">curl</span></code><span class="koboSpan" id="kobo.328.1"> trick we want to show you: TLS (short for Transport Layer Security, the way we encrypt modern web traffic in HTTPS) is not necessarily a “misunderstood” aspect of web applications, but it’s a common failure point that </span><code class="inlineCode"><span class="koboSpan" id="kobo.329.1">curl</span></code><span class="koboSpan" id="kobo.330.1"> can help with.</span></p>
<h3 class="heading-3" id="_idParaDest-416"><span class="koboSpan" id="kobo.331.1">Accepting and displaying bad TLS certificates with curl</span></h3>
<p class="normal"><code class="inlineCode"><span class="koboSpan" id="kobo.332.1">curl</span></code><span class="koboSpan" id="kobo.333.1"> gives us the </span><code class="inlineCode"><span class="koboSpan" id="kobo.334.1">--insecure</span></code><span class="koboSpan" id="kobo.335.1"> option, which allows it to accept invalid TLS certificates from a server, and</span><a id="_idIndexMarker668"/><span class="koboSpan" id="kobo.336.1"> continue the request. </span><span class="koboSpan" id="kobo.336.2">This can come in handy </span><a id="_idIndexMarker669"/><span class="koboSpan" id="kobo.337.1">when troubleshooting misconfigured</span><a id="_idIndexMarker670"/><span class="koboSpan" id="kobo.338.1"> servers:</span></p>
<pre class="programlisting con"><code class="hljs-con"><span class="koboSpan" id="kobo.339.1">curl --insecure -v https://www.tutorialinux.org/
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.340.1">The </span><code class="inlineCode"><span class="koboSpan" id="kobo.341.1">--insecure</span></code><span class="koboSpan" id="kobo.342.1"> (</span><code class="inlineCode"><span class="koboSpan" id="kobo.343.1">-k</span></code><span class="koboSpan" id="kobo.344.1">) option will make </span><code class="inlineCode"><span class="koboSpan" id="kobo.345.1">curl</span></code><span class="koboSpan" id="kobo.346.1"> behave as if the TLS certificate is valid, even if it isn’t. </span><span class="koboSpan" id="kobo.346.2">Obviously, this is a security risk and should only be used for troubleshooting, but it can make </span><code class="inlineCode"><span class="koboSpan" id="kobo.347.1">curl</span></code><span class="koboSpan" id="kobo.348.1"> continue in cases where TLS certificate validation would fail and </span><code class="inlineCode"><span class="koboSpan" id="kobo.349.1">curl</span></code><span class="koboSpan" id="kobo.350.1"> would normally abort the request.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.351.1">Let’s take a quick look at one last piece of HTTP that’s worth learning a bit about if you have anything to do with building or troubleshooting web applications: CORS.</span></p>
<h2 class="heading-2" id="_idParaDest-417"><span class="koboSpan" id="kobo.352.1">CORS</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.353.1">CORS stands</span><a id="_idIndexMarker671"/><span class="koboSpan" id="kobo.354.1"> for Cross-Origin Resource Sharing. </span><span class="koboSpan" id="kobo.354.2">That is a fancy word for saying resources, such as images, videos, HTML, JavaScript, or even </span><strong class="keyWord"><span class="koboSpan" id="kobo.355.1">Asynchronous Javascript and XML</span></strong><span class="koboSpan" id="kobo.356.1"> (</span><strong class="keyWord"><span class="koboSpan" id="kobo.357.1">AJAX</span></strong><span class="koboSpan" id="kobo.358.1">) responses</span><a id="_idIndexMarker672"/><span class="koboSpan" id="kobo.359.1"> will be coming from a different hostname. </span><span class="koboSpan" id="kobo.359.2">To prevent situations where resources are loaded from a third party, the browser first asks that third party whether it is allowed to do so. </span><span class="koboSpan" id="kobo.359.3">This is called a pre-flight request.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.360.1">A pre-flight request is an </span><code class="inlineCode"><span class="koboSpan" id="kobo.361.1">OPTIONS</span></code><span class="koboSpan" id="kobo.362.1"> request that expects a response containing HTTP headers informing whether the request is allowed or not. </span><span class="koboSpan" id="kobo.362.2">Such a response typically has a 204 (No Content) status code and only contains the headers. </span><span class="koboSpan" id="kobo.362.3">If no such headers are found or the headers do not indicate that such a request is allowed, no subsequent request of the resource will be triggered.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.363.1">Here is an example of what such an exchange might look like.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.364.1">A browser opening </span><a href="https://www.example.org/"><span class="url"><span class="koboSpan" id="kobo.365.1">https://www.example.org/</span></span></a><span class="koboSpan" id="kobo.366.1"> asks whether it is okay to POST to </span><code class="inlineCode"><span class="koboSpan" id="kobo.367.1">/api/test</span></code><span class="koboSpan" id="kobo.368.1"> on </span><code class="inlineCode"><span class="koboSpan" id="kobo.369.1">api.example.org</span></code><span class="koboSpan" id="kobo.370.1">:</span></p>
<pre class="programlisting con"><code class="hljs-con"><span class="koboSpan" id="kobo.371.1">OPTIONS /api/test
Origin: https://www.example.org
Access-Control-Request-Method: POST
Access-Control-Request-Headers: X-Custom-Header, Content-Type
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.372.1">An accepting response would look like this:</span></p>
<pre class="programlisting con"><code class="hljs-con"><span class="koboSpan" id="kobo.373.1">HTTP/1.1 204 No Content
Access-Control-Allow-Origin: https://www.example.org
Access-Control-Allow-Methods: POST, GET, OPTIONS
Access-Control-Allow-Headers: X-Custom-Header, Content-Type
Access-Control-Allow-Max-Age: 3600
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.374.1">Since this indicates that the request is allowed, the browser can subsequently send the original request, which is now authorized:</span></p>
<pre class="programlisting con"><code class="hljs-con"><span class="koboSpan" id="kobo.375.1">POST /api/test
Origin: https://www.example.org
Content-Type: application/json
X-Custom-Header: foobarbaz
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.376.1">In the case of a request that’s not allowed, there is no response with an error status that signals a rejection per se – just a lack of the expected </span><code class="inlineCode"><span class="koboSpan" id="kobo.377.1">Access-Control-Allow-Origin</span></code><span class="koboSpan" id="kobo.378.1"> header. </span><span class="koboSpan" id="kobo.378.2">In this case, the client sees that the request is not authorized and logs an error.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.379.1">You can see errors like this as they happen in your browser’s developer console. </span><span class="koboSpan" id="kobo.379.2">They’ll look something like this:</span></p>
<pre class="programlisting con"><code class="hljs-con"><span class="koboSpan" id="kobo.380.1">Cross-Origin Request Blocked: The Same Origin Policy disallows reading the remote resource at https://not-allowed. </span><span class="koboSpan" id="kobo.380.2">(Reason: something).
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.381.1">This is just a quick introduction to</span><a id="_idIndexMarker673"/><span class="koboSpan" id="kobo.382.1"> CORS, because it’s a topic that’s important for web developers to understand. </span><span class="koboSpan" id="kobo.382.2">While it’s not specific to the command line, it’s not out of the ordinary for a developer to have to understand these concepts and check their web client for these kinds of error logs. </span><span class="koboSpan" id="kobo.382.3">For a deeper treatment of this material, we recommend MDN’s article on the subject, which you can find at </span><a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/CORS"><span class="url"><span class="koboSpan" id="kobo.383.1">https://developer.mozilla.org/en-US/docs/Web/HTTP/CORS</span></span></a><span class="koboSpan" id="kobo.384.1">.</span></p>
<h1 class="heading-1" id="_idParaDest-418"><span class="koboSpan" id="kobo.385.1">Conclusion</span></h1>
<p class="normal"><span class="koboSpan" id="kobo.386.1">In this chapter, you learned what you need to know to avoid some of the common misunderstandings, bugs, and frustrating design flaws that we see when web applications leave a developer’s laptop and start to interact with the real world through complex infrastructure. </span><span class="koboSpan" id="kobo.386.2">You learned about some of the infrastructure that mediates access to your applications, like gateways and upstreams.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.387.1">You also saw some of the most common mistakes that we see developers make with HTTP, and you’ll be able to use that knowledge to avoid hard-to-debug issues with headers, incorrect or vague status codes, and more. </span><span class="koboSpan" id="kobo.387.2">You learned about </span><strong class="keyWord"><span class="koboSpan" id="kobo.388.1">Cross-Origin Resource Sharing</span></strong><span class="koboSpan" id="kobo.389.1"> (</span><strong class="keyWord"><span class="koboSpan" id="kobo.390.1">CORS</span></strong><span class="koboSpan" id="kobo.391.1">) and how HTTP has evolved into its current form.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.392.1">Maybe most importantly, you saw how you can level up your game as a developer by learning a command-line tool like </span><code class="inlineCode"><span class="koboSpan" id="kobo.393.1">curl</span></code><span class="koboSpan" id="kobo.394.1"> and combining it with your theoretical knowledge of HTTP.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.395.1">What you learned in this chapter makes it possible for you to quickly and accurately troubleshoot web application issues, whether it’s identifying a redirect loop on a broken WordPress site, pinpointing a subtle caching issue by inspecting the headers returned by a Ruby-on-Rails application, or replicating a production bug (and verifying a fix) at four in the morning by POSTing specific JSON data to a development server.</span></p>
<h1 class="heading-1"><span class="koboSpan" id="kobo.396.1">Learn more on Discord</span></h1>
<p class="normal"><span class="koboSpan" id="kobo.397.1">To join the Discord community for this book – where you can share feedback, ask questions to the author, and learn about new releases – follow the QR code below:</span></p>
<p class="normal"><a href="https://packt.link/SecNet"><span class="url"><span class="koboSpan" id="kobo.398.1">https://packt.link/SecNet</span></span></a></p>
<p class="normal"><span class="koboSpan" id="kobo.399.1"><img alt="" role="presentation" src="../Images/QR_Code1768422420210094187.png"/></span></p>
</div>
</body></html>