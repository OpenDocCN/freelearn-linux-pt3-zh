<html><head></head><body>
		<div id="_idContainer220">
			<h1 id="_idParaDest-88" class="chapter-number"><a id="_idTextAnchor094"/>8</h1>
			<h1 id="_idParaDest-89"><a id="_idTextAnchor095"/>Web Servers and Web Traffic – Learning How to Create and Control Traffic</h1>
			<p>In this chapter, we are going to overview what a web server is and install it. We will dive into securing the web server in order to ensure that the data is safe when you access it as a customer. We will also talk about how to automate this process using Ansible Automation. Without a good web server setup, you could possibly stunt your company’s growth. The ability to provide access to your products is vital, and being able to safeguard your customer’s information is equally as important. Let’s go ahead and step into the world of <span class="No-Break">web servers.</span></p>
			<p>In this chapter, we’re going to cover the following <span class="No-Break">main topics:</span></p>
			<ul>
				<li>Getting started with web servers and <span class="No-Break">traffic control</span></li>
				<li>Learning to set up web servers manually and <span class="No-Break">control traffic</span></li>
				<li>Learning to use Ansible Automation to automate web servers and <span class="No-Break">control traffic</span></li>
			</ul>
			<h1 id="_idParaDest-90"><a id="_idTextAnchor096"/>Technical requirements</h1>
			<p>The technical requirements in this chapter are covered in the <span class="No-Break">following sections.</span></p>
			<h2 id="_idParaDest-91"><a id="_idTextAnchor097"/>Setting up GitHub access</h2>
			<p>Please<a id="_idIndexMarker440"/> refer to the instructions found in <a href="B18607_01.xhtml#_idTextAnchor016"><span class="No-Break"><em class="italic">Chapter 1</em></span></a>, <em class="italic">Block Storage – Learning How to Provision Block Storage on Red Hat Enterprise Linux</em>, to gain access to GitHub, and you will find the Ansible automation playbooks for this chapter at the following link: <a href="https://github.com/PacktPublishing/Red-Hat-Certified-Specialist-in-Services-Management-and-Automation-EX358-Exam-Guide/tree/main/Chapter08">https://github.com/PacktPublishing/Red-Hat-Certified-Specialist-in-Services-Management-and-Automation-EX358-Exam-Guide/tree/main/Chapter08</a>. Remember these are suggested playbooks and are not the only way you can write them to make the playbooks work <span class="No-Break">for you.</span></p>
			<p>You can<a id="_idIndexMarker441"/> always change them using raw, shell, or cmd to achieve the same results, but we are demonstrating the best way to accomplish our goals. Also, keep in mind that we are not using the FCQN needed in the future version of Ansible, as that will not be supported in the exam since it is testing against <span class="No-Break">Ansible 2.9.</span></p>
			<h1 id="_idParaDest-92"><a id="_idTextAnchor098"/>Getting started with web servers and traffic control</h1>
			<p>The ability to<a id="_idIndexMarker442"/> set up and run your own web server is important to most companies. In this digital age, you must be able to keep up with the demands of the fast-paced world. Without a strong website to offer your customers access to your product or services you will greatly hinder your sales potential. The ability to grow your business, especially internationally, is the dream of most people that start a new business. Setting up a web server on RHEL 8 is pretty straightforward using Apache httpd or NGINX but can become complex when implementing rules to <span class="No-Break">protect yourself.</span></p>
			<p>The ability to keep these<a id="_idIndexMarker443"/> same resources safe is a must for any business. The need to be able to block malicious traffic or spoofing is vital to keep your company in good standing with your customers. Being able to respond to threats from <strong class="bold">distributed denial-of-service</strong> (<strong class="bold">DDoS</strong>) attacks, for instance, is one of the things you need to be prepared for as a web server admin. We will go further, in future sections, into keeping your web server safe from unwanted access from third parties trying to gain your information for <span class="No-Break">nefarious purposes.</span></p>
			<p>We will showcase how to install a web server using Apache httpd and NGINX and how to configure it so that the system is secure. We will showcase how to house more than one web server endpoint on a physical server. Next, we will demonstrate how to access the web server once you have it up and running. We will do this using config files that will allow us to customize what is shown from the web server. Finally, we will automate all of this using Ansible Automation to take the headache out of deployments that need to be done over and <span class="No-Break">over again.</span></p>
			<h1 id="_idParaDest-93"><a id="_idTextAnchor099"/>Learning to set up web servers manually and control traffic</h1>
			<p>We are going to<a id="_idIndexMarker444"/> start with Apache httpd. We will commence <a id="_idIndexMarker445"/>by installing the service and configuring the files. We can see in the following screenshot the installation of <span class="No-Break">Apache httpd:</span></p>
			<div>
				<div id="_idContainer190" class="IMG---Figure">
					<img src="image/Figure_8.01_B18607.jpg" alt="Figure 8.1 – Installing Apache httpd web service"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 8.1 – Installing Apache httpd web service</p>
			<p>We are going to look at the default <strong class="source-inline">httpd.conf</strong> file in order to showcase the out-of-the-box setup for Apache httpd. We can see in the following screenshot the layout of the <strong class="source-inline">/</strong><span class="No-Break"><strong class="source-inline">etc/httpd/conf/httpd.conf</strong></span><span class="No-Break"> file:</span></p>
			<div>
				<div id="_idContainer191" class="IMG---Figure">
					<img src="image/Figure_8.02_B18607.jpg" alt="Figure 8.2 – The /etc/httpd/conf/httpd.conf truncated file"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 8.2 – The /etc/httpd/conf/httpd.conf truncated file</p>
			<p>As seen<a id="_idIndexMarker446"/> in the <a id="_idIndexMarker447"/>previous screenshot, information on how to set up a web server can be found in the Apache <a id="_idIndexMarker448"/>httpd <strong class="bold">manual page</strong> (<strong class="bold">man</strong>) pages. You can utilize these to understand what you are setting and to remind you of items you may have forgotten. The <strong class="source-inline">/etc/httpd/conf/httpd.conf</strong> file is also a good place to look for help and reminders, but do not rely on <span class="No-Break">it alone.</span></p>
			<p>Next, will use what we can learn from the man pages and the <strong class="source-inline">httpd.conf</strong> file to create a <strong class="source-inline">.conf</strong> file within the <strong class="source-inline">/etc/httpd/conf.d/</strong> directory. This will allow us to create a web server to meet our needs. We are going to set up virtual hosts within Apache httpd and use the <strong class="source-inline">/etc/httpd/conf.d/</strong> directory to store our websites. Before we do that, we have to ensure that the web server is set up within the default <strong class="source-inline">httpd.conf</strong> file, where we <a id="_idIndexMarker449"/>need to check the <span class="No-Break">following code:</span></p>
			<pre class="source-code">
ServerRoot "/etc/httpd"
Listen 80
User apache
Group apache</pre>
			<p>The preceding code states that <strong class="source-inline">ServerRoot</strong> is <strong class="source-inline">/etc/httpd/</strong>, the web server <strong class="source-inline">Listen</strong> port is <strong class="source-inline">80</strong>, and <strong class="source-inline">User</strong> for the web server is set to <strong class="source-inline">apache</strong>. These ensure that the ownership<a id="_idIndexMarker450"/> of the files is correct when serving the web server to the public and tell the server what port to listen on, which in this case would be port <strong class="source-inline">80</strong> or HTTP , which most of us are used to, or HTTPS which is more secure. For now, we will stick to this <span class="No-Break">basic configuration.</span></p>
			<p>Next, we will build the <a id="_idIndexMarker451"/>configuration for the virtual servers using the <strong class="source-inline">website.conf</strong> file, which we will save to <strong class="source-inline">/etc/httpd/conf.d/website.conf</strong>. We can see the contents of the <strong class="source-inline">website.conf</strong> file in the following screenshot, which displays the minimum required arguments to set up a <span class="No-Break">web server:</span></p>
			<div>
				<div id="_idContainer192" class="IMG---Figure">
					<img src="image/Figure_8.03_B18607.jpg" alt="Figure 8.3 – The website.conf file used to configure the virtual web server"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 8.3 – The website.conf file used to configure the virtual web server</p>
			<p>In the<a id="_idIndexMarker452"/> preceding screenshot, we can see that we are defining a <a id="_idIndexMarker453"/>directory for files, the IP of the server with a listen port of <strong class="source-inline">80</strong>, and the website name. This will allow us to create files such as <strong class="source-inline">index.html</strong> in <strong class="source-inline">/srv/website/www</strong> in order to control the content of our web server. We need to create an <strong class="source-inline">index.html</strong> file and then start and enable the service. In the following screenshot, you can see that I have created a simple <strong class="source-inline">index.html</strong> file <span class="No-Break">within </span><span class="No-Break"><strong class="source-inline">/srv/website/www/</strong></span><span class="No-Break">:</span></p>
			<div>
				<div id="_idContainer193" class="IMG---Figure">
					<img src="image/Figure_8.04_B18607.jpg" alt="Figure 8.4 – The index.hmtl file for Apache httpd web server"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 8.4 – The index.hmtl file for Apache httpd web server</p>
			<p>Next, we<a id="_idIndexMarker454"/> will start and enable httpd, as shown in the <a id="_idIndexMarker455"/><span class="No-Break">following screenshot:</span></p>
			<div>
				<div id="_idContainer194" class="IMG---Figure">
					<img src="image/Figure_8.05_B18607.jpg" alt="Figure 8.5 – Start, enable and status of Apache httpd"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 8.5 – Start, enable and status of Apache httpd</p>
			<p>We now <a id="_idIndexMarker456"/>have to open the firewall rules. As a habit I suggest you adopt, we<a id="_idIndexMarker457"/> will open this for HTTP and HTTPS so that we can utilize both <strong class="source-inline">80</strong> and <strong class="source-inline">443</strong> if necessary to access our web server. In the following screenshot, we can see that we are opening the firewall rules, making them permanent, and then reloading <span class="No-Break">the firewall:</span></p>
			<div>
				<div id="_idContainer195" class="IMG---Figure">
					<img src="image/Figure_8.06_B18607.jpg" alt="Figure 8.6 – Opening the firewall rules for Apache httpd"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 8.6 – Opening the firewall rules for Apache httpd</p>
			<p>Next, we will<a id="_idIndexMarker458"/> restore the SELinux policy so that the web server<a id="_idIndexMarker459"/> showcases the correct information, which can be seen in the <span class="No-Break">following screenshot:</span></p>
			<p class="IMG---Figure"> </p>
			<div>
				<div id="_idContainer196" class="IMG---Figure">
					<img src="image/Figure_8.07_B18607.jpg" alt="Figure 8.7 – The SELinux command to restore the directory permissions"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 8.7 – The SELinux command to restore the directory permissions</p>
			<p>Finally, we are <a id="_idIndexMarker460"/>going<a id="_idIndexMarker461"/> to browse to the website, as shown in the <span class="No-Break">following screenshot:</span></p>
			<div>
				<div id="_idContainer197" class="IMG---Figure">
					<img src="image/Figure_8.08_B18607.jpg" alt="Figure 8.8 – Successful web server browsing of the index.html file"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 8.8 – Successful web server browsing of the index.html file</p>
			<p>Up until this <a id="_idIndexMarker462"/>point, we have successfully opened up our web server<a id="_idIndexMarker463"/> to the world. By having many servers behind a load balancer, you can alter where the traffic goes by the way the load balancer <span class="No-Break">is configured.</span></p>
			<p>Next, we will <a id="_idIndexMarker464"/>troubleshoot virtual hosts within Apache httpd. We will show you how to narrow down common problems when setting up virtual hosts and how to identify and fix them easily. First, let’s create a virtual host with Apache httpd. One of the key things to note is the SELinux construct and how to restore it. The key takeaway from knowing this understanding what has caused the <a id="_idIndexMarker465"/>problem is if you receive the normal Apache httpd resource page, as seen in the <span class="No-Break">following screenshot:</span></p>
			<div>
				<div id="_idContainer198" class="IMG---Figure">
					<img src="image/Figure_8.09_B18607.jpg" alt="Figure 8.9 – The default Apache httpd page"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 8.9 – The default Apache httpd page</p>
			<p>After using <a id="_idIndexMarker466"/>the following command on the directory that you are using as the root directory for your server, you should see the <strong class="bold">Testing for </strong><span class="No-Break"><strong class="bold">EX358book!!!</strong></span><span class="No-Break"> message:</span></p>
			<pre class="source-code">
[emcleroy@rhel1 html]$ sudo restorecon -rv /var/</pre>
			<p>The next thing you will want to do is look at the VirtualHost information found in <strong class="source-inline">/etc/httpd/conf.d/&lt;name of the server&gt;.conf</strong> for where the default files are held for the virtual host in case they are not in the default of <strong class="source-inline">/var/www/html</strong>. This way, you know where to restore the SELinux context in order to resolve <span class="No-Break">the issue.</span></p>
			<p>Next, make <a id="_idIndexMarker467"/>sure that you include the <strong class="source-inline">Required all granted</strong> command line for the directories; otherwise, you will not be able to see any as, by default, they are hidden from the world. This<a id="_idIndexMarker468"/> can be observed in the following virtual <span class="No-Break">host screenshot:</span></p>
			<div>
				<div id="_idContainer199" class="IMG---Figure">
					<img src="image/Figure_8.10_B18607.jpg" alt="Figure 8.10 – Example of an httpd virtual host"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 8.10 – Example of an httpd virtual host</p>
			<p>We can use this information to know where to restore the <span class="No-Break">SELinux context.</span></p>
			<p>Finally, check the firewall rules to make sure they are allowing <strong class="source-inline">443</strong> in this instance, as shown in the <span class="No-Break">following screenshot:</span></p>
			<div>
				<div id="_idContainer200" class="IMG---Figure">
					<img src="image/Figure_8.11_B18607.jpg" alt="Figure 8.11 – Firewall rules show HTTP (80) and HTTPS (443) are both open"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 8.11 – Firewall rules show HTTP (80) and HTT<strong class="source-inline">PS</strong> (443) are both open</p>
			<p>After we <a id="_idIndexMarker469"/>ensure the firewall rules are in place, the web server <a id="_idIndexMarker470"/>should function correctly. You can ensure that httpd is running through a status check, as shown in the <span class="No-Break">following screenshot:</span></p>
			<div>
				<div id="_idContainer201" class="IMG---Figure">
					<img src="image/Figure_8.12_B18607.jpg" alt="Figure 8.12 – Apache httpd status showing it is enabled and running"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 8.12 – Apache httpd status showing it is enabled and running</p>
			<p>After the <a id="_idIndexMarker471"/>system status, firewall rules, and SELinux have <a id="_idIndexMarker472"/>been checked and corrected if needed, your web server should <span class="No-Break">perform correctly.</span></p>
			<p>Next, we will set up an <a id="_idIndexMarker473"/>Apache web server with TLS certificates. For this, we will use <strong class="source-inline">mod_ssl</strong>. We will start by installing <strong class="source-inline">mod_ssl</strong> using the <span class="No-Break">following command:</span></p>
			<pre class="console">
[emcleroy@rhel1 ~]$ sudo dnf install mod_ssl -y</pre>
			<p>After you have installed it, you will need to modify the location of the certificates to match where you have them saved. This can be set in the <strong class="source-inline">/etc/httpd/conf.d/ssl.conf</strong> config file. The areas that need modification can be seen in the <span class="No-Break">following screenshot:</span></p>
			<div>
				<div id="_idContainer202" class="IMG---Figure">
					<img src="image/Figure_8.13_B18607.jpg" alt="Figure 8.13 – Key location for the mod_ssl HTTP web server"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 8.13 – Key location for the mod_ssl HTTP web server</p>
			<p>This will <a id="_idIndexMarker474"/>default the web server to <span class="No-Break">TLS HTTPS.</span></p>
			<p>We will <a id="_idIndexMarker475"/>now set up a web server using NGINX. This is a slightly different way of configuring web servers, and we will go into detail on how this <span class="No-Break">is accomplished.</span></p>
			<p>First, let’s remove httpd and the firewall rules so that we have a fresh server to work on, which can be seen in the <span class="No-Break">following screenshot:</span></p>
			<div>
				<div id="_idContainer203" class="IMG---Figure">
					<img src="image/Figure_8.14_B18607.jpg" alt="Figure 8.14 – Removed Apache httpd and firewall rules"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 8.14 – Removed Apache httpd and firewall rules</p>
			<p>Now that<a id="_idIndexMarker476"/> Apache httpd has been removed, we can start with a<a id="_idIndexMarker477"/> fresh NGINX install. We will install NGINX using the commands in the <span class="No-Break">following screenshot:</span></p>
			<div>
				<div id="_idContainer204" class="IMG---Figure">
					<img src="image/Figure_8.15_B18607.jpg" alt="Figure 8.15 – Installing the NGINX web server"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 8.15 – Installing the NGINX web server</p>
			<p>Next, we are <a id="_idIndexMarker478"/>going to configure the NGINX web server using<a id="_idIndexMarker479"/> the following files, which follow a similar pattern to that of Apache httpd. We will be looking at the main configuration file and server files separately. The main configuration file can be found at <strong class="source-inline">/etc/nginx/nginx.conf</strong>, and the server configuration files are found in the <strong class="source-inline">/etc/nginx/conf.d</strong> directory and have a <strong class="source-inline">.conf</strong> naming convention. The configuration of these files is slightly different from that of Apache httpd, as you can see in the following screenshot of the <span class="No-Break">server configuration:</span></p>
			<div>
				<div id="_idContainer205" class="IMG---Figure">
					<img src="image/Figure_8.16_B18607.jpg" alt="Figure 8.16 – Configuration example of an NGINX web server"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 8.16 – Configuration example of an NGINX web server</p>
			<p>As you<a id="_idIndexMarker480"/> can see, the <a id="_idIndexMarker481"/>layout is different, and we will need to adjust it accordingly. We will now create a <strong class="source-inline">website.conf</strong> file and save it in the <strong class="source-inline">/etc/nginx/conf.d</strong> directory. An example of a web server setup for NGINX is shown in the <span class="No-Break">following screenshot:</span></p>
			<div>
				<div id="_idContainer206" class="IMG---Figure">
					<img src="image/Figure_8.17_B18607.jpg" alt="Figure 8.17 – Example of the configuration file for NGINX web server for rhel1"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 8.17 – Example of the configuration file for NGINX web server for rhel1</p>
			<p>After we <a id="_idIndexMarker482"/>have <a id="_idIndexMarker483"/>saved the <strong class="source-inline">website.conf</strong> file, we will create <strong class="source-inline">index.html</strong> in the <strong class="source-inline">/var/www/html</strong> directory previously specified, as shown in the <span class="No-Break">following screenshot:</span></p>
			<div>
				<div id="_idContainer207" class="IMG---Figure">
					<img src="image/Figure_8.18_B18607.jpg" alt="Figure 8.18 – The index.html file for the NGINX web server"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 8.18 – The index.html file for the NGINX web server</p>
			<p>Following<a id="_idIndexMarker484"/> that, we will run the following command<a id="_idIndexMarker485"/> on the <strong class="source-inline">/var/</strong> directory in order to fix any <span class="No-Break">SELinux issues:</span></p>
			<pre class="source-code">
[emcleroy@rhel1 ~]$ sudo restorecon -Rv /var/
Relabeled /var/log/dnf.librepo.log from system_u:object_r:rpm_log_t:s0 to system_u:object_r:var_log_t:s0
Relabeled /var/log/dnf.rpm.log from system_u:object_r:rpm_log_t:s0 to system_u:object_r:var_log_t:s0
Relabeled /var/log/Xorg.9.log.old from system_u:object_r:var_log_t:s0 to system_u:object_r:xserver_log_t:s0
Relabeled /var/log/Xorg.9.log from system_u:object_r:var_log_t:s0 to system_u:object_r:xserver_log_t:s0
Relabeled /var/log/dnf.log.1 from system_u:object_r:rpm_log_t:s0 to system_u:object_r:var_log_t:s0
Relabeled /var/log/dnf.log from system_u:object_r:rpm_log_t:s0 to system_u:object_r:var_log_t:s0</pre>
			<p>Next, we <a id="_idIndexMarker486"/>will start, enable, and open the firewall rules as needed as<a id="_idIndexMarker487"/> if this was a fresh server, as shown in the <span class="No-Break">following screenshot:</span></p>
			<div>
				<div id="_idContainer208" class="IMG---Figure">
					<img src="image/Figure_8.19_B18607.jpg" alt="Figure 8.19 – Start, enable, and open firewall rules for the NGINX web server"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 8.19 – Start, enable, and open firewall rules for the NGINX web server</p>
			<p>Now, we can<a id="_idIndexMarker488"/> successfully <a id="_idIndexMarker489"/>browse to the new web server, as shown in the <span class="No-Break">following screenshot:</span></p>
			<div>
				<div id="_idContainer209" class="IMG---Figure">
					<img src="image/Figure_8.20_B18607.jpg" alt="Figure 8.20 – Successful browsing to the NGINX web server"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 8.20 – Successful browsing to the NGINX web server</p>
			<p>After we have our <a id="_idIndexMarker490"/>web servers set up, we are going to use<a id="_idIndexMarker491"/> HAProxy to control traffic to our servers. HAProxy provides load balancer abilities that enable us to determine what servers are currently in rotation for <strong class="source-inline">roundrobin</strong>, which allows connections to be dispersed on each new connection to a different web host for instance. By using HAProxy, we can lower our downtime during maintenance and ensure that we have high availability if a <span class="No-Break">server fails.</span></p>
			<p>We will start <a id="_idIndexMarker492"/>by installing HAProxy, as<a id="_idIndexMarker493"/> shown in the <span class="No-Break">following screenshot:</span></p>
			<div>
				<div id="_idContainer210" class="IMG---Figure">
					<img src="image/Figure_8.21_B18607.jpg" alt="Figure 8.21 – Installing HAProxy"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 8.21 – Installing HAProxy</p>
			<p>Once it is installed, we will enable and start the service, as shown in the <span class="No-Break">following screenshot:</span></p>
			<div>
				<div id="_idContainer211" class="IMG---Figure">
					<img src="image/Figure_8.22_B18607.jpg" alt="Figure 8.22 – Starting and enabling HAProxy"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 8.22 – Starting and enabling HAProxy</p>
			<p>Once we<a id="_idIndexMarker494"/> have<a id="_idIndexMarker495"/> the service up and running, we will configure the main file that controls HAProxy, which is the <strong class="source-inline">/etc/haproxy/haproxy.cfg</strong> file, as shown in the <span class="No-Break">following screenshot:</span></p>
			<div>
				<div id="_idContainer212" class="IMG---Figure">
					<img src="image/Figure_8.23_B18607.jpg" alt="Figure 8.23 – The /etc/haproxy/haproxy.cfg file"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 8.23 – The /etc/haproxy/haproxy.cfg file</p>
			<p>A<a id="_idIndexMarker496"/> takeaway<a id="_idIndexMarker497"/> from this review of the config file is that the listening port of the frontend has been changed to <strong class="source-inline">80</strong> as normal for HTTP traffic. The backend servers are where we should put the web servers we want to control access to. Finally, the round robin balancing is set to <strong class="source-inline">roundrobin</strong>, which will rotate whichever backend server the user hits when attempting to browse to the <span class="No-Break">web server.</span></p>
			<p>One thing to take away from HAProxy is that by default, SELinux allows many ports to be utilized out of the box, such as <strong class="source-inline">80</strong> and <strong class="source-inline">443</strong>. However, if you wanted to change to something that was not a well-known HTTP or HTTPS port, you would need to make sure that the following command was set to allow other ports for HAProxy <span class="No-Break">through SELinux:</span></p>
			<pre class="source-code">
[emcleroy@rhel1 ~]$ sudo setsebool -P haproxy_connect_any on</pre>
			<p>In this <a id="_idIndexMarker498"/>section, we learned how to set up Apache httpd, NGINX, and how to use HAProxy as a load balancer. Next, we<a id="_idIndexMarker499"/> will work on automating these sections to make life easier regardless of what you choose to deploy, whether Apache or NGINX, with HAProxy able to utilize both as <span class="No-Break">backend servers.</span></p>
			<h1 id="_idParaDest-94"><a id="_idTextAnchor100"/>Learning how to use Ansible Automation to automate web servers and control traffic</h1>
			<p>We <a id="_idIndexMarker500"/>will set up a multi-task playbook that allows Apache httpd to be installed on the server rhel1 and NGINX to be installed on rhel2. After that, we <a id="_idIndexMarker501"/>will install HAProxy and set the two servers to <strong class="source-inline">roundrobin</strong> load balance, all through the <a id="_idIndexMarker502"/>use of <span class="No-Break">Ansible Automation.</span></p>
			<p>Let’s start <a id="_idIndexMarker503"/>with the inventory, which will include the httpd web server, NGINX web server, and the HAProxy server, as shown in the <span class="No-Break">following screenshot:</span></p>
			<div>
				<div id="_idContainer213" class="IMG---Figure">
					<img src="image/Figure_8.24_B18607.jpg" alt="Figure 8.24 – Ansible Automation inventory file"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 8.24 – Ansible Automation inventory file</p>
			<p>Next, we<a id="_idIndexMarker504"/> will write out the playbook and files <a id="_idIndexMarker505"/>needed <a id="_idIndexMarker506"/>to make this work successfully. To<a id="_idIndexMarker507"/> do that, first, we will write out the beginning part of the playbook for the first server shown <span class="No-Break">as follows:</span></p>
			<pre class="source-code">
---
- name: Install and configure Apache httpd
  hosts: rhel1.example.com
  become: true
  become_method: sudo
  tasks:
    - name: Install Apache httpd
      package:
        name: httpd
        state: latest
    - name: Copy Apache httpd web server configuration
      template:
        src: httpd.j2
        dest: /etc/httpd/conf.d/website.conf
    - name: Copy Apache httpd web server index.html
      template:
        src: httpd_html.j2
        dest: /var/www/html/index.html
    - name: Restore SELinux
      command:
        cmd: restorecon -rv /var/
    - name: Add firewall rules
      firewalld:
        service: http
        state: enabled
        permanent: true
    - name: Reload firewall
      command:
        cmd: firewall-cmd --reload
    - name: Start and enable Apache httpd
      service:
        name: httpd
        state: started
        enabled: true</pre>
			<p>The files <a id="_idIndexMarker508"/>mentioned for copying are<a id="_idIndexMarker509"/> displayed in the <a id="_idIndexMarker510"/><span class="No-Break">following </span><span class="No-Break"><a id="_idIndexMarker511"/></span><span class="No-Break">screenshot:</span></p>
			<div>
				<div id="_idContainer214" class="IMG---Figure">
					<img src="image/Figure_8.25_B18607.jpg" alt="Figure 8.25 – httpd.j2"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 8.25 – httpd.j2</p>
			<p>In the following screenshot, we can see the template <strong class="source-inline">.j2</strong> file for the <strong class="source-inline">httpd_html</strong> conversion when we configure the <span class="No-Break">web host:</span></p>
			<div>
				<div id="_idContainer215" class="IMG---Figure">
					<img src="image/Figure_8.26_B18607.jpg" alt="Figure 8.26 – httpd_html.j2"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 8.26 – httpd_html.j2</p>
			<p>Next, we<a id="_idIndexMarker512"/> will <a id="_idIndexMarker513"/>configure the NGINX web server <a id="_idIndexMarker514"/>within the <a id="_idIndexMarker515"/>same playbook, as seen in the <span class="No-Break">following code:</span></p>
			<pre class="source-code">
        state: started
        enabled: true
- name: Install and configure nginx
  hosts: rhel2.example.com
  become: true
  become_method: sudo
  tasks:
    - name: Install Nginx
      package:
        name: nginx
        state: latest
    - name: Create web server directory
      file:
        path: /srv/website/www
        state: directory
        mode: '0755'
    - name: Copy Nginx web server configuration
      template:
        src: nginx.j2
        dest: /etc/nginx/conf.d/website.conf
    - name: Copy Nginx web server index.html
      template:
        src: nginx_html.j2
        dest: /srv/website/www/index.html
    - name: Restore SELinux
      command:
        cmd: restorecon -rv /srv/
    - name: Add firewall rules
      firewalld:
        service: http
        state: enabled
        permanent: true
    - name: Reload firewall
      command:
        cmd: firewall-cmd --reload
    - name: Start and enable Nginx
      service:
        name: nginx
        state: started
        enabled: true</pre>
			<p>The<a id="_idIndexMarker516"/> files <a id="_idIndexMarker517"/>used within this portion of the playbook <a id="_idIndexMarker518"/>can be found in the <span class="No-Break">following </span><span class="No-Break"><a id="_idIndexMarker519"/></span><span class="No-Break">screenshot:</span></p>
			<div>
				<div id="_idContainer216" class="IMG---Figure">
					<img src="image/Figure_8.27_B18607.jpg" alt="Figure 8.27 – nginx.j2"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 8.27 – nginx.j2</p>
			<p>In <a id="_idIndexMarker520"/>the<a id="_idIndexMarker521"/> following screenshot, we<a id="_idIndexMarker522"/> can see the <strong class="source-inline">.j2</strong> file that allows us to copy over the <a id="_idIndexMarker523"/>configuration of the NGINX <span class="No-Break">web server:</span></p>
			<div>
				<div id="_idContainer217" class="IMG---Figure">
					<img src="image/Figure_8.28_B18607.jpg" alt="Figure 8.28 – nginx_html.j2"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 8.28 – nginx_html.j2</p>
			<p>After<a id="_idIndexMarker524"/> those web servers are <a id="_idIndexMarker525"/>configured, we will need <a id="_idIndexMarker526"/>to set<a id="_idIndexMarker527"/> up HAProxy, as shown in the remainder of <span class="No-Break">the playbook:</span></p>
			<pre class="source-code">
    - name: Start and enable Nginx
      service:
        name: nginx
        state: started
        enabled: true
- name: Install and configure haproxy
  hosts: rhel3.example.com
  become: true
  become_method: sudo
  tasks:
    - name: Install haproxy
      package:
        name: haproxy
        state: latest
    - name: Copy configuration file for haproxy
      template:
        src: haproxy.j2
        dest: /etc/haproxy/haproxy.cfg
    - name: Add firewall rules
      firewalld:
        service: http
        state: enabled
        permanent: true
    - name: Reload firewall
      command:
        cmd: firewall-cmd --reload
    - name: Start and enable haproxy
      service:
        name: haproxy
        state: started
        enabled: true</pre>
			<p>The <a id="_idIndexMarker528"/>file <a id="_idIndexMarker529"/>used to configure the HAProxy can be found in <a id="_idIndexMarker530"/>the <span class="No-Break">following screenshot:</span></p>
			<div>
				<div id="_idContainer218" class="IMG---Figure">
					<img src="image/Figure_8.29_B18607.jpg" alt="Figure 8.29 – haproxy.j2"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 8.29 – haproxy.j2</p>
			<p>After we have <a id="_idIndexMarker531"/>created the playbook and the supporting files, we run the playbook <span class="No-Break">as follows:</span></p>
			<pre class="source-code">
ansible-playbook -i inventory web_servers.yml -u emcleroy -k --ask-become</pre>
			<p>As you <a id="_idIndexMarker532"/>can <a id="_idIndexMarker533"/>see in the following screenshot, we have a successful <span class="No-Break">playbook run:</span></p>
			<div>
				<div id="_idContainer219" class="IMG---Figure">
					<img src="image/Figure_8.30_B18607.jpg" alt="Figure 8.30 – Successful Ansible Automation playbook run"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 8.30 – Successful Ansible Automation playbook run</p>
			<p>After<a id="_idIndexMarker534"/> the playbook runs successfully, we can now browse to <strong class="source-inline">rhel3.example.com</strong>, and it will round robin through<a id="_idIndexMarker535"/> the two <span class="No-Break">backend servers.</span></p>
			<p>In this section, we learned how to create both Apache httpd web servers and NGINX web servers. We also learned how to set up HAProxy to load balance and provide high availability <a id="_idIndexMarker536"/>to our web servers. This<a id="_idIndexMarker537"/> enables us to take servers <a id="_idIndexMarker538"/>out of rotation <a id="_idIndexMarker539"/>without our customers knowing what is happening, all through Ansible <span class="No-Break">Automation playbooks.</span></p>
			<h1 id="_idParaDest-95"><a id="_idTextAnchor101"/>Summary</h1>
			<p>In this chapter, we learned about web servers and how we can create different flavors from Apache to NGINX. We learned how to control server access and to resolve issues setting them up. Through HAProxy, we learned how to stir traffic through load balancing in order to ensure that we have servers up and running for the end users at all times. In the next chapter, we will wrap up what we have learned throughout this book with an overview followed by practice exam questions. This will help prepare you and drive home the information you have learned while studying <a id="_idTextAnchor102"/>this book. In the next c<a id="_idTextAnchor103"/>hapter, we will work with mock exam questions to prepare you for test day. I look forward to seeing you all there and helping you succeed in passing the EX358 <span class="No-Break">certification exam.</span></p>
		</div>
	</body></html>