- en: '13'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '13'
- en: Starting Up – The init Program
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 启动 – `init`程序
- en: We looked at how the kernel boots up to the point where it launches the first
    program, `init`, in [*Chapter 4*](Chapter_04.xhtml#_idTextAnchor096). In *Chapters
    5* and *6*, we looked at creating root filesystems of varying complexity, all
    of which contained an `init` program. Now, it is time to look at the `init` program
    itself in more detail and discover why it is so important to the rest of the system.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在[*第4章*](Chapter_04.xhtml#_idTextAnchor096)中已经了解了内核如何启动并启动第一个程序`init`。在[*第5章*](Chapter_04.xhtml#_idTextAnchor096)和[*第6章*](Chapter_04.xhtml#_idTextAnchor110)中，我们创建了不同复杂度的根文件系统，这些文件系统都包含了`init`程序。现在，是时候更详细地了解`init`程序，并探索它对系统其他部分的重要性。
- en: 'There are many implementations of `init`. In this chapter, I will describe
    the three main ones: BusyBox `init`, System V `init`, and `systemd`. I will explain
    how they work and what types of systems are best suited for each. Part of this
    is balancing the tradeoff between size, complexity, and flexibility. We will learn
    how to launch a daemon using both BusyBox `init` and System V `init`. We will
    also learn how to add a service to `systemd`.'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: '`init`有很多实现版本。在本章中，我将描述三种主要的实现：BusyBox `init`、System V `init` 和 `systemd`。我将解释它们是如何工作的，以及哪些类型的系统最适合使用每种实现。部分内容涉及在大小、复杂性和灵活性之间做出权衡。我们将学习如何使用BusyBox
    `init`和System V `init`启动一个守护进程。同时，我们还将学习如何向`systemd`添加一个服务。'
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将讨论以下主题：
- en: After the kernel has booted
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在内核启动后
- en: Introducing the `init` programs
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 介绍`init`程序
- en: BusyBox `init`
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: BusyBox `init`
- en: System V `init`
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: System V `init`
- en: '`systemd`'
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`systemd`'
- en: Technical requirements
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'To follow along with the examples, make sure you have the following:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 要跟随示例操作，确保你具备以下条件：
- en: An Ubuntu 24.04 or later LTS host system with at least 90 GB of free disk space
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一台至少有90GB空闲磁盘空间的Ubuntu 24.04或更高版本的LTS主机系统
- en: Buildroot 2024.02.6 LTS release
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Buildroot 2024.02.6 LTS版
- en: Yocto 5.0 (scarthgap) LTS release
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Yocto 5.0（scarthgap）LTS版
- en: You should have already installed the 2024.02.6 LTS release of Buildroot for
    [*Chapter 6*](Chapter_04.xhtml#_idTextAnchor110). If you have not, then refer
    to the *System requirements* section of *The Buildroot user manual* ([https://buildroot.org/downloads/manual/manual.html)](https://buildroot.org/downloads/manual/manual.html))
    before installing Buildroot on your Linux host according to the instructions from
    [*Chapter 6*](Chapter_04.xhtml#_idTextAnchor110).
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该已经为[*第6章*](Chapter_04.xhtml#_idTextAnchor110)安装了Buildroot 2024.02.6 LTS版。如果还没有，请参考[*Buildroot用户手册*](https://buildroot.org/downloads/manual/manual.html)中的*系统要求*部分，按照[*第6章*](Chapter_04.xhtml#_idTextAnchor110)的说明，在Linux主机上安装Buildroot。
- en: You should have already built the 5.0 (scarthgap) LTS release of Yocto in [*Chapter
    6*](Chapter_04.xhtml#_idTextAnchor110). If you have not, then please refer to
    the *Compatible Linux Distribution* and *Build Host Packages* sections of the
    *Yocto Project Quick Build* guide ([https://docs.yoctoproject.org/brief-yoctoprojectqs/](https://docs.yoctoproject.org/brief-yoctoprojectqs/))
    before building Yocto on your Linux host according to the instructions in [*Chapter
    6*](Chapter_04.xhtml#_idTextAnchor110).
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该已经在[*第6章*](Chapter_04.xhtml#_idTextAnchor110)构建了5.0（scarthgap）LTS版的Yocto。如果还没有，请参考*兼容的Linux发行版*和*构建主机包*部分，按照[*Yocto项目快速构建*](https://docs.yoctoproject.org/brief-yoctoprojectqs/)指南的说明，在Linux主机上构建Yocto。
- en: 'The code used in this chapter can be found in the chapter folder in this book’s
    GitHub repository: [https://github.com/PacktPublishing/Mastering-Embedded-Linux-Development](https://github.com/PacktPublishing/Mastering-Embedded-Linux-Development).'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中使用的代码可以在本书GitHub仓库的章节文件夹中找到：[https://github.com/PacktPublishing/Mastering-Embedded-Linux-Development](https://github.com/PacktPublishing/Mastering-Embedded-Linux-Development)。
- en: After the kernel has booted
  id: totrans-18
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在内核启动后
- en: In [*Chapter 4*](Chapter_04.xhtml#_idTextAnchor096), we saw how the kernel bootstrap
    code looks for a root filesystem, either `initramfs` or a filesystem specified
    by `root=` on the kernel command line. The kernel bootstrap code then executes
    a program, which, by default, is `/init` for `initramfs` and `/sbin/init` for
    a regular filesystem. The `init` program has `root` privilege, and since it is
    the first process to run, it has a **process ID** (**PID**) of 1\. If, for some
    reason, `init` cannot be started, the kernel will panic and the system will fail
    to boot.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 在[**第 4 章**](Chapter_04.xhtml#_idTextAnchor096)中，我们看到内核启动代码会寻找根文件系统，可能是 `initramfs`
    或内核命令行中由 `root=` 指定的文件系统。内核启动代码接着执行一个程序，默认情况下，对于 `initramfs` 是 `/init`，对于常规文件系统则是
    `/sbin/init`。`init` 程序具有 `root` 权限，并且由于它是第一个运行的进程，因此它的 **进程 ID** (**PID**) 是 1。如果因为某些原因无法启动
    `init`，内核将会 panic，系统无法启动。
- en: 'The `init` program is the ancestor of all other processes, as shown here by
    the `pstree` command running on a simple embedded Linux system:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: '`init` 程序是所有其他进程的祖先，如下面 `pstree` 命令在一个简单的嵌入式 Linux 系统上显示的那样：'
- en: '[PRE0]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The job of the `init` program is to take control of the boot process in user
    space and set it running. It may be as simple as a shell command running a shell
    script—there is an example of this at the start of [*Chapter 5*](Chapter_05.xhtml#_idTextAnchor138)—but
    in most cases, you will use a dedicated `init` daemon to perform the following
    tasks:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: '`init` 程序的工作是接管用户空间中的引导过程并使其运行。它可能像是一个运行 shell 脚本的简单 shell 命令——在[**第 5 章**](Chapter_05.xhtml#_idTextAnchor138)的开始有一个例子——但在大多数情况下，你将使用一个专门的
    `init` 守护进程来执行以下任务：'
- en: Start other daemons and configure system parameters and other things needed
    to get the system into a working state.
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 启动其他守护进程并配置系统参数以及将系统配置到工作状态所需的其他任务。
- en: Optionally, launch a login daemon, such as `getty`, on terminals that allow
    a login shell.
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可选地，在允许登录 shell 的终端上启动登录守护进程，如 `getty`。
- en: Adopt processes that become orphaned due to their immediate parent terminating
    and there being no other processes in the thread group.
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 采用因其直接父进程终止且线程组中没有其他进程而成为孤儿的进程。
- en: Respond to any of its immediate children terminating by catching the `SIGCHLD`
    signal and collecting the return value to prevent them from becoming zombie processes.
    I will talk more about zombies in [*Chapter 17*](Chapter_17.xhtml#_idTextAnchor542).
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 响应其任何直接子进程终止，捕获 `SIGCHLD` 信号并收集返回值，以防止它们成为僵尸进程。我将在[**第 17 章**](Chapter_17.xhtml#_idTextAnchor542)中详细讨论僵尸进程。
- en: Optionally, restart other daemons that have terminated.
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可选地，重启其他已终止的守护进程。
- en: Handle system shutdown.
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 处理系统关机。
- en: In other words, `init` manages the life cycle of the system from bootup to shutdown.
    There is a school of thought that says `init` is well placed to handle other runtime
    events such as new hardware and the loading and unloading of modules. This is
    what `systemd` does.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 换句话说，`init` 管理系统从启动到关机的生命周期。有一种观点认为，`init` 很适合处理其他运行时事件，如新硬件的加入和模块的加载与卸载。这正是
    `systemd` 所做的工作。
- en: Introducing the init programs
  id: totrans-30
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 引入 init 程序
- en: The three init programs you are most likely to encounter in embedded devices
    are BusyBox `init`, System V `init`, and `systemd`. Buildroot offers all three
    with BusyBox `init` as the default. The Yocto Project lets you choose between
    System V `init` and `systemd` with System V `init` as the default. While Yocto’s
    tiny distribution ships with BusyBox `init`, most other distro layers do not.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 你最有可能在嵌入式设备中遇到的三种 init 程序是 BusyBox `init`、System V `init` 和 `systemd`。Buildroot
    提供这三种程序，其中 BusyBox `init` 是默认选项。Yocto 项目允许你在 System V `init` 和 `systemd` 之间选择，默认是
    System V `init`。虽然 Yocto 的小型发行版包含 BusyBox `init`，但大多数其他发行版层并不包含它。
- en: 'The following table gives some metrics to compare the three:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 以下表格列出了一些指标，用于比较三者：
- en: '| **Metric** | **BusyBox init** | **System V init** | **systemd** |'
  id: totrans-33
  prefs: []
  type: TYPE_TB
  zh: '| **指标** | **BusyBox init** | **System V init** | **systemd** |'
- en: '| Complexity | Low | Medium | High |'
  id: totrans-34
  prefs: []
  type: TYPE_TB
  zh: '| 复杂度 | 低 | 中 | 高 |'
- en: '| Bootup speed | Fast | Slow | Medium |'
  id: totrans-35
  prefs: []
  type: TYPE_TB
  zh: '| 启动速度 | 快 | 慢 | 中等 |'
- en: '| Required shell | ash | dash or bash | None |'
  id: totrans-36
  prefs: []
  type: TYPE_TB
  zh: '| 必需的 shell | ash | dash 或 bash | 无 |'
- en: '| Number of executables | 1(*) | 4 | 50 |'
  id: totrans-37
  prefs: []
  type: TYPE_TB
  zh: '| 可执行文件数量 | 1(*) | 4 | 50 |'
- en: '| libc | Any | Any | glibc |'
  id: totrans-38
  prefs: []
  type: TYPE_TB
  zh: '| libc | 任何 | 任何 | glibc |'
- en: '| Size (MB) | < 0.1(*) | 0.1 | 34(**) |'
  id: totrans-39
  prefs: []
  type: TYPE_TB
  zh: '| 大小（MB） | < 0.1(*) | 0.1 | 34(**) |'
- en: Table 13.1 – Comparison of BusyBox init, System V init, and systemd
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 表 13.1 – BusyBox init、System V init 和 systemd 的比较
- en: (*) BusyBox `init` is part of BusyBox’s single executable, which is optimized
    for size on disk.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: (*) BusyBox `init` 是 BusyBox 单一可执行文件的一部分，经过优化以减少磁盘空间占用。
- en: (**) Based on the Buildroot configuration of `systemd`.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: (**) 基于 `systemd` 的 Buildroot 配置。
- en: Broadly speaking, there is an increase in flexibility and complexity as you
    go from BusyBox `init` to `systemd`.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 从广义上讲，从 BusyBox `init` 到 `systemd`，灵活性和复杂性都有所增加。
- en: BusyBox init
  id: totrans-44
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: BusyBox init
- en: BusyBox has a minimal `init` program that uses an `/etc/inittab` configuration
    file to start programs at bootup and stop them at shutdown. The actual work is
    done by shell scripts, which, by convention, are placed in the `/etc/init.d` directory.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: BusyBox 有一个最小化的 `init` 程序，它使用 `/etc/inittab` 配置文件在启动时启动程序，在关机时停止程序。实际的工作由 shell
    脚本完成，按照约定，这些脚本放在 `/etc/init.d` 目录中。
- en: '`init` begins by reading `/etc/inittab`. This file contains a list of programs
    to run, one per line, in this format:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: '`init` 从读取 `/etc/inittab` 开始。该文件包含一系列程序，每行一个，格式如下：'
- en: '[PRE1]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The roles of these parameters are:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 这些参数的作用是：
- en: '`id`: The controlling terminal for the command'
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`id`：命令的控制终端'
- en: '`action`: When and how to run the program'
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`action`：何时以及如何运行程序'
- en: '`program`: The program to run along with all its command-line arguments'
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`program`：要运行的程序及其所有命令行参数'
- en: 'The actions are:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 这些操作是：
- en: '`sysinit`: Runs the program when `init` starts before any of the other types
    of actions.'
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`sysinit`：在 `init` 启动时，先于其他类型的操作运行该程序。'
- en: '`respawn`: Runs the program and restarts it if it terminates. It is used to
    run a program as a daemon.'
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`respawn`：运行该程序，并在其终止时重新启动。用于将程序作为守护进程运行。'
- en: '`askfirst`: The same as `respawn`, but it prints the message **Please press
    Enter to activate this console** to the console and runs the program after *Enter*
    has been pressed. It is used to start an interactive shell on a terminal without
    prompting for a username or password.'
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`askfirst`：与 `respawn` 相同，但它会在控制台上显示**请按 Enter 键激活此控制台**的消息，按下 *Enter* 后运行程序。用于在终端启动交互式外壳，而无需提示输入用户名或密码。'
- en: '`once`: Runs the program once but does not attempt to restart it if it terminates.'
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`once`：运行该程序一次，但如果它终止，不会尝试重新启动它。'
- en: '`wait`: Runs the program and waits for it to complete.'
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`wait`：运行该程序并等待其完成。'
- en: '`restart`: Runs the program when `init` receives the `SIGHUP` signal, indicating
    that it should reload the `inittab` file.'
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`restart`：当 `init` 接收到 `SIGHUP` 信号时运行该程序，表示它应该重新加载 `inittab` 文件。'
- en: '`ctrlaltdel`: Runs the program when `init` receives the `SIGINT` signal, usually
    as a result of pressing *Ctrl + Alt + Del* on the console.'
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ctrlaltdel`：当 `init` 接收到 `SIGINT` 信号时运行该程序，通常是因为在控制台上按下 *Ctrl + Alt + Del*。'
- en: '`shutdown`: Runs the program when `init` shuts down.'
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`shutdown`：当 `init` 关闭时运行该程序。'
- en: 'Here is a small example that mounts `proc` and `sysfs` and then runs a shell
    on a serial interface:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个小例子，它挂载了 `proc` 和 `sysfs`，然后在串口接口上运行一个外壳：
- en: '[PRE2]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: For simple projects in which you want to launch a small number of daemons and
    start a login shell on a serial terminal, it is easy to write the scripts manually.
    This is appropriate if you are creating a **roll-your-own** (**RYO**) embedded
    Linux. However, you will find that handwritten `init` scripts rapidly become unmaintainable
    as the number of things to be configured increases. They are not very modular
    and need updating each time a new component is added or removed.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 对于一些简单的项目，如果你只需要启动少量守护进程并在串口终端上启动登录外壳，手动编写脚本是非常容易的。如果你正在创建一个**自主定制**（**RYO**）的嵌入式
    Linux，这种方法是适当的。然而，你会发现，随着需要配置的内容增多，手写的 `init` 脚本会迅速变得不可维护。它们不是很模块化，每次添加或删除新组件时都需要更新。
- en: Buildroot init scripts
  id: totrans-64
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Buildroot init 脚本
- en: Buildroot has been making effective use of BusyBox `init` for many years. Buildroot
    has two scripts in `/etc/init.d/` named `rcS` and `rcK` (`rc` stands for “run
    commands”). The `rcS` script runs at bootup. It iterates over all the scripts
    in `/etc/init.d/` with names that begin with a capital `S` followed by two digits
    and runs them in numerical order. These are the start scripts. The `rcK` script
    is run at shutdown. It iterates over all the scripts beginning with a capital
    `K` followed by two digits and runs them in numerical order. These are the kill
    scripts.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: Buildroot 多年来有效地使用 BusyBox `init`。Buildroot 在 `/etc/init.d/` 中有两个脚本，分别是 `rcS`
    和 `rcK`（`rc` 代表“运行命令”）。`rcS` 脚本在启动时运行。它遍历 `/etc/init.d/` 中所有名称以大写字母 `S` 开头并跟随两位数字的脚本，并按数字顺序运行它们。这些是启动脚本。`rcK`
    脚本在关机时运行。它遍历所有以大写字母 `K` 开头并跟随两位数字的脚本，并按数字顺序运行它们。这些是停止脚本。
- en: With this structure in place, it becomes easy for Buildroot packages to supply
    their own start and kill scripts so that the system becomes extensible. The two-digit
    number controls the order in which the `init` scripts are run. If you are using
    Buildroot, this structure is transparent. If not, then you can use it as a model
    for writing your own BusyBox `init` scripts.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这个结构，Buildroot 软件包可以提供自己的启动和停止脚本，使得系统变得可扩展。两位数字控制 `init` 脚本的执行顺序。如果你正在使用 Buildroot，这个结构是透明的。如果没有使用，你可以将其作为编写自己
    BusyBox `init` 脚本的模型。
- en: Like BusyBox `init`, System V `init` relies on shell scripts inside `/etc/init.d`
    and an `/etc/inittab` configuration file. While the two `init` systems are similar
    in many ways, System V `init` has more features and a much longer history.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 像 BusyBox `init` 一样，System V `init` 依赖于 `/etc/init.d` 中的 shell 脚本和 `/etc/inittab`
    配置文件。虽然这两种 `init` 系统在许多方面相似，但 System V `init` 拥有更多功能和更长的历史。
- en: System V init
  id: totrans-68
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: System V init
- en: This `init` program was inspired by the one from Unix System V and dates back
    to the mid-1980s. The version most often found in Linux distributions was written
    initially by Miquel van Smoorenburg. Until recently, it was the `init` daemon
    for almost all desktop and server distributions and a fair number of embedded
    systems as well. However, in recent years it has been replaced by `systemd`, which
    we will describe in the next section.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 这个 `init` 程序的灵感来源于 Unix System V，追溯到上世纪80年代中期。大多数 Linux 发行版中常见的版本最初由 Miquel
    van Smoorenburg 编写。直到最近，它一直是几乎所有桌面和服务器发行版以及许多嵌入式系统的 `init` 守护进程。然而，近年来它已被 `systemd`
    替代，我们将在下一节中介绍它。
- en: 'The BusyBox `init` daemon is just a trimmed-down version of System V `init`.
    System V `init` has two advantages compared to BusyBox `init`:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: BusyBox 的 `init` 守护进程只是一个简化版的 System V `init`。与 BusyBox `init` 相比，System V `init`
    有两个优势：
- en: Firstly, the boot scripts are written in a well-known modular format making
    it easy to add new packages at build time or runtime.
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 首先，启动脚本采用众所周知的模块化格式编写，便于在构建时或运行时添加新软件包。
- en: Secondly, it has the concept of **runlevels**, which allow a collection of programs
    to be started or stopped in one go when switching from one runlevel to another.
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 其次，它具有 **运行级别** 的概念，允许在从一个运行级别切换到另一个运行级别时，一次性启动或停止一组程序。
- en: 'There are eight runlevels numbered from `0` to `6` plus `S`:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 有八个运行级别，从 `0` 到 `6`，再加上 `S`：
- en: '`S`: Runs startup tasks'
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`S`：执行启动任务'
- en: '`0`: Halts the system'
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`0`：停止系统'
- en: '`1` to `5`: Available for general use'
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`1` 到 `5`：可供一般使用'
- en: '`6`: Reboots the system'
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`6`：重新启动系统'
- en: 'Levels `1` to `5` can be used as desired. On most desktop Linux distributions,
    they are assigned as:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 级别 `1` 到 `5` 可以根据需要使用。在大多数桌面 Linux 发行版中，它们被分配为：
- en: '`1`: Single user'
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`1`：单用户模式'
- en: '`2`: Multi-user without network configuration'
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`2`：没有网络配置的多用户模式'
- en: '`3`: Multi-user with network configuration'
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`3`：具有网络配置的多用户模式'
- en: '`4`: Not used'
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`4`：未使用'
- en: '`5`: Multi-user with graphical login'
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`5`：具有图形登录的多用户模式'
- en: 'The `init` program starts the default runlevel given by the `initdefault` line
    in `/etc/inittab`:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: '`init` 程序启动 `/etc/inittab` 文件中 `initdefault` 行指定的默认运行级别：'
- en: '[PRE3]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'You can change the runlevel at runtime using the `telinit <runlevel>` command,
    which sends a message to `init`. You can find the current runlevel and the previous
    one using the `runlevel` command. Here is an example:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用 `telinit <runlevel>` 命令在运行时更改运行级别，这会向 `init` 发送一条消息。你可以使用 `runlevel` 命令查找当前运行级别和先前的运行级别。以下是一个示例：
- en: '[PRE4]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The initial output from the `runlevel` command is `N 5`. An `N` indicates that
    there is no previous runlevel because the runlevel has not changed since booting.
    The current runlevel is `5`. After changing the runlevel, the output is `5` `3`,
    indicating that there has been a transition from `5` to `3`.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: '`runlevel` 命令的初始输出是 `N 5`。`N` 表示没有先前的运行级别，因为自启动以来运行级别没有变化。当前的运行级别是 `5`。在更改运行级别后，输出为
    `5` `3`，表示从 `5` 过渡到 `3`。'
- en: 'The `halt` and `reboot` commands switch to runlevels `0` and `6`, respectively.
    You can override the default runlevel by giving a different one (a single digit
    from `0` to `6`) on the kernel command line. For example, to force the default
    runlevel to be single user, you append `1` to the kernel command line like this:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: '`halt` 和 `reboot` 命令分别切换到运行级别 `0` 和 `6`。你可以通过在内核命令行中指定不同的运行级别（从 `0` 到 `6` 的单个数字）来覆盖默认的运行级别。例如，要强制默认运行级别为单用户模式，你可以在内核命令行中添加
    `1`，如下所示：'
- en: '[PRE5]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Each runlevel has a number of kill scripts that stop things, and another group
    of start scripts to get them going. When entering a new runlevel, `init` first
    runs the kill scripts followed by the start scripts from the new level. Daemons
    that are currently running and have neither a start script nor a kill script in
    the new runlevel are sent a `SIGTERM` signal. In other words, the default action
    when switching runlevels is to terminate daemons unless told otherwise.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 每个运行级别都有一组杀死脚本，用于停止进程，还有一组启动脚本，用于启动进程。当进入新运行级别时，`init`首先运行杀死脚本，然后是新级别的启动脚本。当前正在运行的守护进程，如果在新运行级别中既没有启动脚本也没有杀死脚本，将会收到`SIGTERM`信号。换句话说，切换运行级别时的默认操作是终止守护进程，除非另有指示。
- en: In truth, runlevels are not used much in embedded Linux. Most devices simply
    boot to the default runlevel and stay there. I have a feeling this is partly because
    most people are not aware of them.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 事实上，嵌入式Linux中并不常用运行级别（runlevel）。大多数设备直接启动到默认运行级别并保持在那里。我觉得这部分原因是大多数人并不了解它们。
- en: '**Tip**'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: '**提示**'
- en: Runlevels are a simple and convenient way to switch between modes, for example,
    from production to maintenance mode.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 运行级别是一种简单便捷的方式，用于在不同模式之间切换，例如从生产模式切换到维护模式。
- en: System V `init` is an option in Buildroot and The Yocto Project. In both cases,
    the `init` scripts have been stripped of any `bash` shell specifics, so they will
    work with the BusyBox `ash` shell. However, Buildroot cheats somewhat by replacing
    the BusyBox `init` program with System V `init` and adding an `inittab` that mimics
    the behavior of BusyBox. Buildroot does not implement runlevels except for `0`
    and `6`, which halt or reboot the system.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 系统V `init`是Buildroot和Yocto项目中的一种选项。在这两种情况下，`init`脚本都已去除任何`bash` shell的特定内容，因此它们能够在BusyBox的`ash`
    shell中工作。然而，Buildroot通过将BusyBox的`init`程序替换为系统V的`init`并添加一个模拟BusyBox行为的`inittab`，稍微作弊了一下。Buildroot除了`0`和`6`运行级别（它们用于停止或重启系统）外，不实现其他运行级别。
- en: Next, let’s look at some of the details. The following examples are taken from
    The Yocto Project 5.0 release. Other Linux distributions may implement `init`
    scripts a little differently.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们来看一些细节。以下示例取自Yocto项目5.0版本。其他Linux发行版可能会略有不同地实现`init`脚本。
- en: inittab
  id: totrans-97
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: inittab
- en: The `init` program begins by reading entries that define what happens at each
    runlevel from an `/etc/inittab` configuration file. The format is an extended
    version of the BusyBox `inittab` described in the preceding section. This is no
    surprise since BusyBox borrowed it from System V in the first place.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: '`init`程序首先通过读取`/etc/inittab`配置文件中的条目来定义每个运行级别发生的操作。其格式是前面章节中描述的BusyBox `inittab`的扩展版。因为BusyBox本来就从系统V借用了这一格式，所以这并不令人惊讶。'
- en: 'The format of each entry in the `inittab` is:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 每个`inittab`条目的格式如下：
- en: '[PRE6]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The fields are:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 这些字段包括：
- en: '`id`: A unique identifier of up to four characters'
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`id`：最多四个字符的唯一标识符'
- en: '`runlevels`: The runlevels this entry belongs to'
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`runlevels`：此条目所属的运行级别'
- en: '`action`: When and how to run the command'
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`action`：命令的运行时机和方式'
- en: '`process`: The command to run'
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`process`：要运行的命令'
- en: 'The actions are the same as for BusyBox `init`: `sysinit`, `respawn`, `once`,
    `wait`, `restart`, `ctrlaltdel`, and `shutdown`. However, System V `init` does
    not have `askfirst`, which is specific to BusyBox.'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 这些操作与BusyBox的`init`相同：`sysinit`、`respawn`、`once`、`wait`、`restart`、`ctrlaltdel`和`shutdown`。然而，系统V的`init`没有`askfirst`，这是BusyBox特有的。
- en: 'Here is the complete `inittab` supplied by The Yocto Project when building
    `core-image-minimal` for the `qemuarm` machine:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是Yocto项目在为`qemuarm`机器构建`core-image-minimal`时提供的完整`inittab`：
- en: '[PRE7]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'The first `id:5:initdefault` entry sets the default runlevel to `5`. The next
    `si::sysinit` entry runs the `/etc/init.d/rcS` script at bootup. All the `rcS`
    script does is enter the `S` runlevel:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个`id:5:initdefault`条目将默认运行级别设置为`5`。接下来的`si::sysinit`条目在启动时运行`/etc/init.d/rcS`脚本。`rcS`脚本所做的就是进入`S`运行级别：
- en: '[PRE8]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Hence, the first runlevel entered is `S`, followed by the default runlevel of
    `5`. Note that runlevel `S` is not recorded and is never displayed as a prior
    runlevel by the `runlevel` command.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，第一次进入的运行级别是`S`，接着是默认运行级别`5`。请注意，运行级别`S`不会被记录，也不会在`runlevel`命令中作为之前的运行级别显示出来。
- en: The seven entries beginning with `l0` to `l6` run the `/etc/init.d/rc` script
    whenever there is a change to the runlevel. The `rc` script is responsible for
    processing the start and kill scripts.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 从`l0`到`l6`的七个条目，在运行级别发生变化时会执行`/etc/init.d/rc`脚本。`rc`脚本负责处理启动和杀死脚本。
- en: 'Scan down a bit further for an entry that runs a `getty` daemon:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 再往下查看，找到一个运行`getty`守护进程的条目：
- en: '[PRE9]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: This entry generates a login prompt on `/dev/ttyAMA0` when entering runlevels
    `1` through `5` allowing you to log in and get an interactive shell. The `ttyAMA0`
    device is the serial console on the Arm Versatile board emulated by QEMU. The
    device name may be different for serial consoles on other development boards.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 该条目会在进入运行级别`1`到`5`时，在`/dev/ttyAMA0`上生成一个登录提示，允许你登录并获得一个交互式终端。`ttyAMA0`设备是QEMU仿真中的Arm
    Versatile开发板的串行控制台。其他开发板的串行控制台可能会有不同的设备名称。
- en: 'The last entry runs another `getty` daemon on `/dev/tty1`:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一项会在`/dev/tty1`上运行另一个`getty`守护进程：
- en: '[PRE10]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: This entry is triggered when entering runlevels `2` through `5`. The `tty1`
    device is a virtual console that is mapped to a graphical screen when you build
    your kernel with `CONFIG_FRAMEBUFFER_CONSOLE` or `VGA_CONSOLE`.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 该条目会在进入运行级别`2`到`5`时触发。`tty1`设备是一个虚拟控制台，当你在构建内核时启用了`CONFIG_FRAMEBUFFER_CONSOLE`或`VGA_CONSOLE`选项，它会映射到一个图形屏幕。
- en: Desktop Linux distributions usually spawn six `getty` daemons on virtual terminals
    1 to 6, with `tty7` reserved for the graphical screen. Ubuntu and Arch Linux are
    notable exceptions since they use `tty1` for graphics. You can switch between
    virtual terminals with key combinations *Ctrl + Alt + F1* through *Ctrl + Alt
    + F6*. Virtual terminals are seldom used on embedded devices.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 桌面Linux发行版通常会在虚拟终端1到6上启动六个`getty`守护进程，`tty7`则保留用于图形屏幕。Ubuntu和Arch Linux是值得注意的例外，因为它们使用`tty1`来显示图形界面。你可以通过组合键*Ctrl
    + Alt + F1*到*Ctrl + Alt + F6*在虚拟终端之间切换。嵌入式设备很少使用虚拟终端。
- en: The init.d scripts
  id: totrans-120
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: init.d脚本
- en: 'Each component that needs to respond to a runlevel change has a script in `/etc/init.d`
    to perform the change. The script should expect two parameters: `start` and `stop`.
    I will give an example of each in the *Adding a new daemon* section.'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 每个需要响应运行级别变化的组件，在`/etc/init.d`中都有一个脚本来执行该变化。脚本应该接收两个参数：`start`和`stop`。我会在*添加一个新的守护进程*部分给出每个的示例。
- en: 'The `/etc/init.d/rc` runlevel-handling script takes the runlevel it is switching
    to as a parameter. There is a directory named `rc<runlevel>.d` for each runlevel:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: '`/etc/init.d/rc`运行级别处理脚本接收要切换的运行级别作为参数。每个运行级别都有一个名为`rc<runlevel>.d`的目录：'
- en: '[PRE11]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'There you will find a set of scripts beginning with a capital `S` followed
    by two digits. You may also find scripts beginning with a capital `K`. These are
    the start and kill scripts. Here is an example of the scripts for runlevel `5`:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 你会找到一组脚本，这些脚本以大写字母`S`开头，后面跟着两个数字。你也可能会找到以大写字母`K`开头的脚本。这些是启动和终止脚本。以下是`5`级别运行时的脚本示例：
- en: '[PRE12]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: These are, in fact, symbolic links back to their corresponding scripts in `init.d`.
    The `rc` script first runs all the scripts beginning with a `K` passing in the
    `stop` parameter. Then it runs all the scripts beginning with an `S` passing in
    the `start` parameter. Once again, the two-digit codes are there to impart the
    order in which to execute the scripts.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 这些实际上是指向`init.d`中对应脚本的符号链接。`rc`脚本首先运行所有以`K`开头的脚本，传入`stop`参数。然后，它运行所有以`S`开头的脚本，传入`start`参数。再次强调，两个数字的代码是用来表示脚本执行的顺序的。
- en: Adding a new daemon
  id: totrans-127
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 添加一个新的守护进程
- en: 'Imagine that you have a program named `simpleserver` that is written as a traditional
    Unix daemon; in other words, it forks and runs in the background. The code for
    this program is in `MELD/Chapter13/simpleserver`. The corresponding `init.d` script
    (see below) is in `MELD/Chapter13/simpleserver-sysvinit/init.d`:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你有一个名为`simpleserver`的程序，它作为传统的Unix守护进程运行；换句话说，它会分叉并在后台运行。这个程序的代码位于`MELD/Chapter13/simpleserver`。对应的`init.d`脚本（见下文）位于`MELD/Chapter13/simpleserver-sysvinit/init.d`：
- en: '[PRE13]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '`start-stop-daemon` is a program that makes it easier to manipulate background
    processes. It originally came from the Debian installer package (`dpkg`) but most
    embedded systems use the one from BusyBox. Running `start-stop-daemon` with the
    `-S` parameter starts the daemon, making sure that there is never more than one
    instance running at any one time. Running `start-stop-daemon` with the `-K` parameter
    stops the daemon by sending it a signal, `SIGTERM` by default, to indicate to
    the daemon that it is time to terminate.'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: '`start-stop-daemon`是一个简化后台进程操作的程序。它最初来自Debian安装包（`dpkg`），但大多数嵌入式系统使用的是来自BusyBox的版本。使用`-S`参数运行`start-stop-daemon`时，会启动守护进程，确保每次只有一个实例在运行。使用`-K`参数运行`start-stop-daemon`时，会通过发送`SIGTERM`信号（默认）来停止守护进程，通知守护进程是时候终止了。'
- en: 'To make `simpleserver` operational, copy the `init.d` script to `/etc/init.d`
    and make it executable. Then, add links from each of the runlevels that you want
    to run this program from—in this case, only the default runlevel of `5`:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 要使`simpleserver`正常工作，请将`init.d`脚本复制到`/etc/init.d`并使其可执行。然后，从你希望该程序运行的每个运行级别添加链接——在此情况下，只有默认运行级别`5`：
- en: '[PRE14]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The number `99` means that this will be one of the last programs to start.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 数字`99`表示这是最后启动的程序之一。
- en: '**Important note**'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: '**重要说明**'
- en: Bear in mind that there may be other links beginning with `S99`, in which case
    the `rc` script will just run them in lexical order.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，可能还会有其他以`S99`开头的链接，在这种情况下，`rc`脚本会按字母顺序运行它们。
- en: 'It is rare in embedded devices to have to worry too much about shutdown operations,
    but if there is something that needs to be done, add kill links to levels `0`
    and `6`:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 在嵌入式设备中，通常不需要过多担心关机操作，但如果有需要处理的事项，可以在`0`级和`6`级添加kill链接：
- en: '[PRE15]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: We can circumvent runlevels and ordering for more immediate testing and debugging
    of `init.d` scripts.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以绕过运行级别和顺序，直接测试和调试`init.d`脚本。
- en: Starting and stopping services
  id: totrans-139
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 启动和停止服务
- en: 'You can interact with the scripts in `/etc/init.d` by calling them directly.
    Here is an example using the `syslog` script that controls the `syslogd` and `klogd`
    daemons:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过直接调用脚本与`/etc/init.d`中的脚本交互。以下是一个使用`syslog`脚本的示例，该脚本控制`syslogd`和`klogd`守护进程：
- en: '[PRE16]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: All scripts implement `start` and `stop`, and they should also implement `help`.
    Some implement `status` as well, which will tell you whether the service is running
    or not. Mainstream distributions that still use System V `init` have a command
    named `service` to start and stop services, which hides the details of calling
    the scripts directly.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 所有脚本都实现了`start`和`stop`，它们还应该实现`help`。有些脚本还实现了`status`，可以告诉你服务是否正在运行。仍然使用System
    V `init`的主流发行版有一个名为`service`的命令，用于启动和停止服务，该命令隐藏了直接调用脚本的细节。
- en: System V `init` is a simple `init` daemon that has served Linux admins for decades.
    While runlevels offer a greater degree of sophistication than BusyBox `init`,
    System V `init` still lacks the ability to monitor services and restart them if
    needed. As System V `init` starts to show its age, most popular Linux distributions
    have moved on to `systemd`.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: System V `init`是一个简单的`init`守护进程，已经为Linux管理员服务了数十年。虽然运行级别提供了比BusyBox `init`更高的复杂性，但System
    V `init`仍然无法监控服务并在需要时重新启动它们。随着System V `init`逐渐显得过时，最受欢迎的Linux发行版已经转向了`systemd`。
- en: systemd
  id: totrans-144
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: systemd
- en: '`systemd` ([https://systemd.io/](https://systemd.io/)) defines itself as a
    *system and service manager*. The project was initiated in 2010 by Lennart Poettering
    and Kay Sievers to create an integrated set of tools for managing a Linux system
    based around an `init` daemon. It also includes device management (`udev`) and
    logging, among many other things. `systemd` is state of the art and is still evolving
    rapidly. It is common on desktop and server Linux distributions and is becoming
    increasingly popular on embedded Linux systems. So, how is it better than System
    V `init`?'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: '`systemd` ([https://systemd.io/](https://systemd.io/)) 自我定义为*系统和服务管理器*。该项目由Lennart
    Poettering和Kay Sievers于2010年发起，旨在创建一套集成的工具，用于管理基于`init`守护进程的Linux系统。它还包括设备管理（`udev`）和日志记录等多个功能。`systemd`是最新的技术，并且仍在快速发展中。它在桌面和服务器Linux发行版中很常见，且在嵌入式Linux系统中越来越受欢迎。那么，它比System
    V `init`更好在哪里呢？'
- en: Configuration is simpler and more logical (once you understand it). Instead
    of convoluted shell scripts, `systemd` has unit configuration files that are written
    in a well-defined format.
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 配置更简单且更有逻辑性（理解后即可）。与复杂的Shell脚本不同，`systemd`使用单位配置文件，这些文件采用一种明确定义的格式编写。
- en: There are explicit dependencies between services. This is a huge improvement
    over two-digit numbers that only control the order in which scripts are executed.
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 服务之间有明确的依赖关系。这比只能控制脚本执行顺序的两位数字系统有了巨大的改进。
- en: It is easy to set the permissions and resource limits for each service in the
    interest of security.
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在安全性方面，为每个服务设置权限和资源限制是很容易的。
- en: It can monitor services and restart them if needed.
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它可以监控服务并在需要时重新启动它们。
- en: Services are started in parallel, reducing boot time.
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 服务是并行启动的，从而减少了启动时间。
- en: A complete description of `systemd` is not possible here. As with System V `init`,
    I will focus on the embedded use cases with examples based on The Yocto Project
    5.0 release with `systemd` version 255.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 这里无法提供关于`systemd`的完整描述。与System V `init`一样，我将重点介绍基于`systemd`版本255的The Yocto Project
    5.0发布版的嵌入式用例示例。
- en: Building systemd with The Yocto Project and Buildroot
  id: totrans-152
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用The Yocto Project和Buildroot构建systemd
- en: 'The default `init` daemon in The Yocto Project is System V. To select `systemd`,
    add this line to your `conf/local.conf`:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: The Yocto Project中的默认`init`守护进程是System V。要选择`systemd`，请在`conf/local.conf`中添加以下行：
- en: '[PRE17]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Buildroot uses BusyBox `init` by default. You can select `systemd` through `menuconfig`
    by looking in the **System configuration | Init system** menu. You will also have
    to configure the toolchain to use `glibc` for the C library since `systemd` does
    not officially support `uClibc-ng` or `musl`. In addition, there are restrictions
    on the version and configuration of the kernel. There is a complete list of library
    and kernel dependencies in the `README` file at the top level of the `systemd`
    source code.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，Buildroot使用BusyBox的`init`。你可以通过`menuconfig`选择`systemd`，方法是进入**系统配置 | 初始化系统**菜单。你还需要将工具链配置为使用`glibc`作为C库，因为`systemd`官方不支持`uClibc-ng`或`musl`。此外，内核的版本和配置也有限制。`systemd`源代码顶层的`README`文件中列出了库和内核的所有依赖关系。
- en: Introducing targets, services, and units
  id: totrans-156
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 介绍目标、服务和单元
- en: 'Before I describe how `systemd` works, I need to introduce three key concepts:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 在描述`systemd`如何工作之前，我需要介绍三个关键概念：
- en: '**Unit**: A configuration file that describes a target, a service, or several
    other things. Units are text files that contain properties and values.'
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**单元**：一个描述目标、服务或其他几个事物的配置文件。单元是包含属性和值的文本文件。'
- en: '**Service**: A daemon that can be started and stopped, much like a System V
    `init` service.'
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**服务**：一个可以启动和停止的守护进程，类似于System V的`init`服务。'
- en: '**Target**: A group of services, similar to a System V `init` runlevel. There
    is a default target consisting of all the services that are started at boot time.'
  id: totrans-160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**目标**：一组服务，类似于System V的`init`运行级别。默认目标由所有在启动时启动的服务组成。'
- en: You can change states and find out what is going on using the `systemctl` command.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用`systemctl`命令来更改状态并了解当前发生了什么。
- en: Units
  id: totrans-162
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 单元
- en: 'The basic item of configuration is the **unit** file. Unit files are found
    in four different places:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 配置的基本项是**单元**文件。单元文件位于四个不同的位置：
- en: '`/etc/systemd/system`: Local configuration'
  id: totrans-164
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`/etc/systemd/system`：本地配置'
- en: '`/run/systemd/system`: Runtime configuration'
  id: totrans-165
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`/run/systemd/system`：运行时配置'
- en: '`/usr/lib/systemd/system:` Distribution-wide configuration (default location)'
  id: totrans-166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`/usr/lib/systemd/system`：分发级别的配置（默认位置）'
- en: '`/lib/systemd/system`: Distribution-wide configuration (legacy default location)'
  id: totrans-167
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`/lib/systemd/system`：分发级别的配置（传统默认位置）'
- en: When looking for a unit, `systemd` searches these directories in the preceding
    order, stopping as soon as it finds a match. You can override the behavior of
    a distribution-wide unit by placing a unit of the same name in `/etc/systemd/system`.
    You can also disable a unit completely by creating a local file that is empty
    or linked to `/dev/null`.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 在查找单元时，`systemd`会按前述顺序搜索这些目录，找到匹配项后停止搜索。你可以通过在`/etc/systemd/system`中放置同名的单元来覆盖分发级别单元的行为。你还可以通过创建一个空文件或链接到`/dev/null`来完全禁用一个单元。
- en: 'All unit files begin with a section marked `[Unit]` that contains basic information
    and dependencies. For example, here is the `Unit` section of the D-Bus service
    `/lib/systemd/system/dbus.service`:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 所有单元文件都以`[Unit]`标记的部分开始，其中包含基本信息和依赖关系。例如，以下是D-Bus服务`/lib/systemd/system/dbus.service`的`Unit`部分：
- en: '[PRE18]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: In addition to the description and a reference to the documentation, there is
    a dependency on the `dbus.socket` unit expressed through the `Requires` keyword.
    This tells `systemd` to create a local socket when the D-Bus service is started.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 除了描述和文档引用外，还有一个通过`Requires`关键字表达的对`dbus.socket`单元的依赖关系。这告诉`systemd`在启动D-Bus服务时创建一个本地套接字。
- en: 'Dependencies are expressed by the `Requires`, `Wants`, and `Conflicts` keywords:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 依赖关系通过`Requires`、`Wants`和`Conflicts`关键字表达：
- en: '`Requires`: A list of units that this unit depends on; these are started when
    this unit is started.'
  id: totrans-173
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Requires`：此单元依赖的单元列表；这些单元会在该单元启动时启动。'
- en: '`Wants`: A weaker form of `Requires`; this unit continues even when any of
    these dependencies fails to start.'
  id: totrans-174
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Wants`：一种比`Requires`更弱的形式；即使这些依赖项中的任何一个未能启动，该单元仍然会继续运行。'
- en: '`Conflicts`: A negative dependency; these units are stopped when this one is
    started, and conversely, if one of them is subsequently restarted, then this one
    is stopped.'
  id: totrans-175
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Conflicts`：一种负依赖关系；当此单元启动时，这些单元会被停止，反之，如果其中一个单元随后重新启动，则此单元会被停止。'
- en: These three keywords define **outgoing dependencies**. They are used to create
    dependencies between *targets*. There is another set of dependencies called **incoming
    dependencies**, which are used to create links between *services* and *targets*.
    In other words, outgoing dependencies are used to create the list of targets that
    need to be started as the system goes from one state to another, and incoming
    dependencies are used to determine the services that should be started or stopped
    when entering any state. Incoming dependencies are created by the `WantedBy` keyword,
    which I will describe in the upcoming section, *Adding your own service*.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 这三个关键字定义了**外向依赖**。它们用于在 *目标* 之间创建依赖关系。还有一组依赖关系称为**内向依赖**，用于在 *服务* 和 *目标* 之间创建链接。换句话说，外向依赖用于创建在系统从一个状态切换到另一个状态时需要启动的目标列表，内向依赖用于确定在进入任何状态时应启动或停止的服务。内向依赖通过
    `WantedBy` 关键字创建，我将在接下来的章节 *添加自定义服务* 中描述。
- en: 'Processing the dependencies produces a list of units that should be started
    or stopped. The `Before` and `After` keywords determine the order in which they
    are started. The stop order is simply the reverse of the start order:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 处理依赖关系会生成一个应启动或停止的单元列表。`Before` 和 `After` 关键字决定它们的启动顺序。停止顺序只是启动顺序的反向：
- en: '`Before`: Start this unit before the units listed.'
  id: totrans-178
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Before`：在列出的单元之前启动该单元。'
- en: '`After`: Start this unit after the units listed.'
  id: totrans-179
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`After`：在列出的单元之后启动该单元。'
- en: 'For example, the `After` directive ensures that the following web server is
    started after the network subsystem is started:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，`After` 指令确保在网络子系统启动后启动以下 Web 服务器：
- en: '[PRE19]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: In the absence of a `Before` or `After` directive, the units are started or
    stopped in parallel with no ordering.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 在没有 `Before` 或 `After` 指令的情况下，单元会并行启动或停止，没有特定顺序。
- en: Services
  id: totrans-183
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 服务
- en: A **service** is a daemon that can be started and stopped like a System V `init`
    service. A service has a unit file with a name ending in `.service`.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: '**服务** 是一个守护进程，可以像 System V `init` 服务一样启动和停止。一个服务有一个以 `.service` 结尾的单元文件。'
- en: 'A service unit has a `[Service]` section that describes how the service should
    be run. Here is the `[Service]` section from `lighttpd.service`:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 服务单元有一个 `[Service]` 部分，描述了服务如何运行。以下是 `lighttpd.service` 中的 `[Service]` 部分：
- en: '[PRE20]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: These are the commands to run when starting and restarting the service. There
    are many more configuration points you can add here so refer to the manual page
    for `systemd.service(5)`.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是在启动和重启服务时运行的命令。你可以在这里添加更多配置项，详情请参考 `systemd.service(5)` 手册页。
- en: Targets
  id: totrans-188
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 目标
- en: 'A **target** is a unit that groups services or other types of units together.
    A target is a metaservice in that respect and serves as a synchronization point.
    A target only has dependencies. Targets have names ending in `.target` like `multi-user.target`.
    A target is a desired state that performs the same role as System V `init` runlevels.
    Here is the complete `multi-user.target`:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: '**目标** 是一个将服务或其他类型的单元组合在一起的单元。目标在这方面是一个元服务，起到同步点的作用。目标只有依赖关系。目标的名称以 `.target`
    结尾，例如 `multi-user.target`。目标是一个期望的状态，扮演着 System V `init` 运行级别的角色。以下是完整的 `multi-user.target`：'
- en: '[PRE21]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: This says that the basic target must be started before the multi-user target.
    This also says that since it conflicts with the rescue target, starting the rescue
    target will cause the multi-user target to be stopped first. The rescue and multi-user
    targets cannot run simultaneously because the rescue target boots into single-user
    mode. Activating the rescue target only makes sense during system recovery.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着基本目标必须在多用户目标之前启动。这还意味着，由于它与救援目标冲突，启动救援目标将首先停止多用户目标。救援目标和多用户目标不能同时运行，因为救援目标启动的是单用户模式。只有在系统恢复时，激活救援目标才有意义。
- en: How systemd boots the system
  id: totrans-192
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何 systemd 启动系统
- en: 'Let’s see how `systemd` implements the bootstrap. The kernel starts `systemd`
    because `/sbin/init` is symbolically linked to `/lib/systemd/systemd`. `systemd`
    runs `default.target`, which is always a link to the desired target: either `multi-user.target`
    for a text login or `graphical.target` for a graphical environment. If the default
    target is `multi-user.target`, you will see this symbolic link:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看 `systemd` 如何实现启动过程。内核启动 `systemd`，因为 `/sbin/init` 被符号链接到 `/lib/systemd/systemd`。`systemd`
    运行 `default.target`，它始终是指向目标的链接：如果是文本登录，指向 `multi-user.target`，如果是图形环境，指向 `graphical.target`。如果默认目标是
    `multi-user.target`，你将看到这个符号链接：
- en: '[PRE22]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Override the default target by passing `system.unit=<new target>` on the kernel
    command line.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 通过在内核命令行中传递`system.unit=<new target>`来覆盖默认目标。
- en: 'To discover the default target:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 查找默认目标：
- en: '[PRE23]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Starting a target like `multi-user.target` creates a tree of dependencies that
    bring the system into a working state. In a typical system, `multi-user.target`
    depends on `basic.target`, which depends on `sysinit.target`, which depends on
    the services that need to be started early.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 启动类似`multi-user.target`的目标会创建一个依赖树，将系统带入工作状态。在典型的系统中，`multi-user.target`依赖于`basic.target`，后者依赖于`sysinit.target`，而`sysinit.target`又依赖于需要早期启动的服务。
- en: 'To print a text graph of system dependencies:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 打印系统依赖的文本图：
- en: '[PRE24]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'To list all services and their current states:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 列出所有服务及其当前状态：
- en: '[PRE25]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'To list all targets:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 列出所有目标：
- en: '[PRE26]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Now that we’ve seen the dependency tree for the system, how do we insert an
    additional service?
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经看到了系统的依赖树，那么如何插入一个额外的服务呢？
- en: Adding your own service
  id: totrans-206
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 添加你自己的服务
- en: 'Here is a unit for our `simpleserver` service:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们的`simpleserver`服务的单元：
- en: '[PRE27]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: You will find this `simpleserver.service` file in `MELD/Chapter13/simpleserver-systemd`.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在`MELD/Chapter13/simpleserver-systemd`中找到这个`simpleserver.service`文件。
- en: The `[Unit]` section only contains a description that shows up under `systemctl`.
    There are no dependencies since this service is very simple.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: '`[Unit]`部分只包含一个描述，这个描述会出现在`systemctl`下。没有依赖项，因为这个服务非常简单。'
- en: The `[Service]` section points to the executable and has a flag to indicate
    that it forks. If `simpleserver` was even simpler and ran in the foreground, `systemd`
    would do the daemonizing for us and `Type=forking` would not be needed.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: '`[Service]`部分指向可执行文件，并有一个标志表示它会分叉。如果`simpleserver`更简单，并在前台运行，`systemd`会为我们进行守护进程化，因此不需要`Type=forking`。'
- en: The `[Install]` section creates an incoming dependency on `multi-user.target`
    so that our server is started when the system enters multi-user mode.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: '`[Install]`部分创建了一个到`multi-user.target`的传入依赖，这样当系统进入多用户模式时，我们的服务器会被启动。'
- en: 'Once you place the `simpleserver.service` file in the `/etc/systemd/system`
    directory, you can start and stop the service using the `systemctl start simpleserver`
    and `sytemctl stop simpleserver` commands. You can also use `systemctl` to get
    its current status:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你将`simpleserver.service`文件放入`/etc/systemd/system`目录，你就可以使用`systemctl start
    simpleserver`和`sytemctl stop simpleserver`命令来启动和停止该服务。你还可以使用`systemctl`获取它的当前状态：
- en: '[PRE28]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: At this point, the service only starts and stops on command. To make it persistent,
    you need to add a permanent dependency to a target. The `[Install]` section says
    that when this service is enabled, it becomes dependent on `multi-user.target`
    so that it starts at boot time.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 此时，该服务仅在命令下启动和停止。为了使其持久化，你需要添加一个指向目标的永久依赖。`[Install]`部分表示，当启用该服务时，它会依赖`multi-user.target`，以便在启动时启动。
- en: 'To enable the service:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 启用该服务：
- en: '[PRE29]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'To update the `systemd` dependency tree without rebooting:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 更新`systemd`依赖树而无需重启：
- en: '[PRE30]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'You can also add dependencies to services without having to edit target unit
    files. A target can have a directory named `<target_name>.target.wants` with links
    to services. Creating a link inside this directory is the same as adding a unit
    to the `[Wants]` list in the target. The `systemctl enable` `simpleserver` command
    created the following link:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以为服务添加依赖，而无需编辑目标单元文件。一个目标可以有一个名为`<target_name>.target.wants`的目录，其中包含指向服务的链接。在此目录中创建一个链接就相当于将单元添加到目标的`[Wants]`列表中。`systemctl
    enable` `simpleserver`命令创建了以下链接：
- en: '[PRE31]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'You might want to restart an important service if it crashes. To achieve that,
    add the following flag to the `[Service]` section:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一个重要服务崩溃，你可能希望重启它。为此，在`[Service]`部分添加以下标志：
- en: '[PRE32]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: The other `Restart` options are `on-success`, `on-failure`, `on-abnormal`, `on-watchdog`,
    and `always`.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 其他`Restart`选项包括`on-success`、`on-failure`、`on-abnormal`、`on-watchdog`和`always`。
- en: Adding a watchdog
  id: totrans-225
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 添加看门狗
- en: 'Many embedded systems require a watchdog: you need to act if a critical service
    stops. This usually means rebooting the system. Most embedded SoCs have a hardware
    watchdog that can be accessed via the `/dev/watchdog` device node. The **watchdog**
    is initialized with a timeout at boot. If this timer is not reset within the timeout
    period, the watchdog is triggered and the system reboots. The interface with the
    watchdog driver is described in the kernel source under `Documentation/watchdog/`
    and the code for the drivers is in `drivers/watchdog/`.'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 许多嵌入式系统需要看门狗：如果一个关键服务停止工作，你需要采取行动。这通常意味着需要重启系统。大多数嵌入式SoC都有一个硬件看门狗，可以通过`/dev/watchdog`设备节点访问。**看门狗**在启动时会初始化一个超时时间。如果在超时时间内没有重置这个计时器，看门狗将会被触发，系统将重启。与看门狗驱动程序的接口在内核源代码的`Documentation/watchdog/`下进行了描述，驱动程序的代码位于`drivers/watchdog/`。
- en: A problem arises when there are two or more critical services that need to be
    protected by a watchdog. `systemd` has a useful feature that distributes the watchdog
    between multiple services. `systemd` can be configured to expect a regular keepalive
    call from a service and act when no keepalive is received, creating a software
    watchdog. For this to work, you need to add code to the daemon to send the keepalive
    messages. The daemon reads the value of the `WATCHDOG_USEC` environment variable
    and calls `sd_notify(false, "WATCHDOG=1")` within this time period. The period
    should be set to about half the watchdog timeout. There are examples in the `systemd`
    source code.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 当有两个或更多关键服务需要通过看门狗进行保护时，就会出现一个问题。`systemd`提供了一个有用的功能，可以在多个服务之间分配看门狗。可以配置`systemd`期望服务定期发送保持活跃信号，并在未收到该信号时采取行动，从而创建一个软件看门狗。为了实现这一功能，你需要在守护进程中添加代码，发送保持活跃信号。守护进程读取`WATCHDOG_USEC`环境变量的值，并在此时间段内调用`sd_notify(false,
    "WATCHDOG=1")`。该时间段应设置为看门狗超时的约一半。`systemd`源代码中有相关示例。
- en: 'To enable the software watchdog in a service unit, add something like this
    to the `[Service]` section:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 要在服务单元中启用软件看门狗，可以在`[Service]`部分添加如下内容：
- en: '[PRE33]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: In this example, the service expects a keepalive call every 30 seconds. If the
    keepalive fails to be delivered, the service is restarted, but if it is restarted
    more than four times in 5 minutes, `systemd` immediately reboots the entire system.
    There is a full description of these settings in the `systemd.service(5)` manual
    page.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，服务每30秒需要接收到一次保持活跃的信号。如果保持活跃信号未能发送，服务会被重启，但如果在5分钟内重启超过四次，`systemd`会立即重启整个系统。关于这些设置的详细描述，可以参考`systemd.service(5)`手册页。
- en: A software watchdog takes care of individual services, but what if `systemd`
    itself fails, the kernel crashes, or the hardware locks up? In those cases, we
    need to tell `systemd` to use the hardware watchdog. Add `RuntimeWatchdogSec=<N>`
    to `/etc/systemd/system.conf`. This will reset the watchdog within the given `N`
    period so that the system reboots if `systemd` fails for some reason. This will
    be an immediate hard reboot or “reset” of the system without any graceful shutdown.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 软件看门狗负责监控单个服务，但如果`systemd`本身失败、内核崩溃或硬件死锁该怎么办？在这些情况下，我们需要告诉`systemd`使用硬件看门狗。将`RuntimeWatchdogSec=<N>`添加到`/etc/systemd/system.conf`中。这将会在给定的`N`时间内重置看门狗，从而在`systemd`因某种原因失败时重启系统。这将是一个立即的硬重启或系统“重置”，没有任何优雅的关机过程。
- en: Implications for embedded Linux
  id: totrans-232
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 嵌入式Linux的影响
- en: '`systemd` has a lot of features that are useful for embedded Linux. This chapter
    only mentions some of them. The others include resource control (described in
    the manual pages for `systemd.slice(5)` and `systemd.resource-control(5)`), device
    management (`udev(7)`), system logging facilities (`journald(5)`), mount units
    for auto-mounting filesystems, and timer units for `cron` jobs.'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: '`systemd`有许多对嵌入式Linux有用的功能。本章仅提到了其中的一些。其他功能包括资源控制（可以参考`systemd.slice(5)`和`systemd.resource-control(5)`手册页）、设备管理（`udev(7)`）、系统日志功能（`journald(5)`）、自动挂载文件系统的挂载单元以及`cron`作业的定时器单元。'
- en: You need to balance these features with `systemd`'s size. Even a minimal build
    of just the core components (`systemd`, `udevd`, and `journald`) approaches 10
    MB of storage including shared libraries.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 你需要平衡这些功能与`systemd`的体积。即使是仅包含核心组件（`systemd`、`udevd`和`journald`）的最小构建，其存储空间也接近10
    MB，包括共享库。
- en: You also need to keep in mind that `systemd` development follows the kernel
    and `glibc` closely, so a `systemd` release won’t work on a kernel and `glibc`
    more than a year or two older than itself.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 你还需要记住，`systemd`的开发与内核和`glibc`紧密跟随，因此`systemd`的版本无法在比其发布版本早一到两年的内核和`glibc`上运行。
- en: Summary
  id: totrans-236
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: Every Linux device needs an `init` program of some kind. If you are designing
    a system that only needs to launch a small number of daemons at startup, then
    BusyBox `init` is sufficient. BusyBox `init` is also usually a good choice if
    you are using Buildroot as your build system.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 每个 Linux 设备都需要某种形式的 `init` 程序。如果你设计的系统只需要在启动时启动少量守护进程，那么 BusyBox `init` 足够用了。如果你使用
    Buildroot 作为构建系统，BusyBox `init` 通常也是一个不错的选择。
- en: On the other hand, if you have a system with complex dependencies between services
    at boot time or runtime, then `systemd` is the best choice. Even without such
    complexity, `systemd` has some useful features like watchdogs, remote logging,
    and so on. If you have the storage space, you should seriously consider `systemd`.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，如果你的系统在启动或运行时具有复杂的服务依赖关系，那么 `systemd` 是最佳选择。即便没有这样的复杂性，`systemd` 也有一些有用的功能，比如看门狗、远程日志等。如果你的存储空间足够，应该认真考虑使用
    `systemd`。
- en: Meanwhile, System V `init` lives on. It is well understood and there are already
    `init` scripts for every component that is important to us. System V remains the
    default `init` for The Yocto Project reference distribution (Poky). In terms of
    boot time, `systemd` is faster for similar workloads. However, if you are looking
    for the fastest boot, neither beats simple BusyBox `init` with minimal boot scripts.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 与此同时，System V `init` 仍然存在。它已经被广泛理解，并且每个对我们来说重要的组件都有对应的 `init` 脚本。System V 仍然是
    Yocto 项目参考发行版（Poky）的默认 `init`。在启动时间方面，`systemd` 对于类似的工作负载来说更快。然而，如果你追求的是最快的启动速度，简单的
    BusyBox `init` 配合最小化的启动脚本则更胜一筹。
- en: Further study
  id: totrans-240
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步学习
- en: '*systemd System and Service Manager* – [https://systemd.io/](https://systemd.io/)'
  id: totrans-241
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*systemd 系统与服务管理器* – [https://systemd.io/](https://systemd.io/)'
