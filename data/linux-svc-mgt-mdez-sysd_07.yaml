- en: '*Chapter 6*: Understanding systemd Targets'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第6章*：理解`systemd` targets'
- en: In this chapter, we'll look at what `systemd` targets are, and what they can
    do for us. Now, I have to tell you that there is a bit of confusion that surrounds
    this topic, and I hope to clear that up.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将看看`systemd` targets是什么，以及它们能为我们做些什么。现在，我得告诉你，这个话题有些困惑，我希望能澄清这一点。
- en: 'Specific topics covered in this chapter include the following:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖的特定主题包括以下内容：
- en: Understanding the purpose of `systemd` targets
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解`systemd` targets的目的
- en: Understanding the structure of a target file
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解target文件的结构
- en: Comparing `systemd` targets to SysVinit run levels
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将`systemd` targets与SysVinit运行级别进行比较
- en: Understanding target dependencies
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解target依赖关系
- en: Changing the default target
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 更改默认target
- en: Temporarily changing the target
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 临时更改target
- en: Understanding targets is important and can help you out either in the server
    room or in your own home. If you're ready, let's get started.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 理解targets非常重要，它可以在服务器机房或在你自己家里为你提供帮助。如果你准备好了，我们就开始吧。
- en: Technical requirements
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: For this chapter, you'll need a virtual machine that's running with a graphical
    desktop environment. I'll be using my *AlmaLinux virtual machine*, which is running
    with the *Gnome 3 desktop*.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 对于本章，您需要一台运行带有图形桌面环境的虚拟机。我将使用我的*AlmaLinux虚拟机*，它运行的是*Gnome 3桌面*。
- en: 'Check out the following link to see the Code in Action video: [https://bit.ly/3Dgar9d](https://bit.ly/3Dgar9d)'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 查看以下链接以观看《代码实战》视频：[https://bit.ly/3Dgar9d](https://bit.ly/3Dgar9d)
- en: As always, this is hands-on, so feel free to follow along.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 一如既往，这是实践操作，随时跟着做吧。
- en: Understanding the purpose of systemd targets
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解`systemd` targets的目的
- en: The legacy `systemd`, we have *targets* instead of runlevels. Several of these
    targets perform the same function that runlevels used to. That part is easy to
    understand.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: '`systemd`的遗产，我们有*targets*代替了运行级别。许多这些targets执行着运行级别曾经执行的相同功能。这部分很容易理解。'
- en: Where the confusion comes in is that targets are more than just runlevels. As
    we'll soon see, there are many different targets, all with their own specific
    purposes. In `systemd`, a target is a unit that groups together other `systemd`
    units for a particular purpose. The units that a target can group together include
    services, paths, mount points, sockets, and even other targets.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 困惑之处在于，targets不仅仅是运行级别。正如我们很快会看到的，targets有很多种，每种都有其特定的目的。在`systemd`中，target是一个单元，它将其他`systemd`单元组合在一起，达到特定的目的。一个target可以组合的单元包括服务、路径、挂载点、套接字，甚至其他targets。
- en: 'By doing a `systemctl list-units -t target` command, you can see all of the
    active targets on your system, which should look like this:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 通过执行`systemctl list-units -t target`命令，您可以查看系统上所有活动的targets，结果应该是这样的：
- en: '![](img/Figure_6.1_B17491.jpg)'
  id: totrans-18
  prefs: []
  type: TYPE_IMG
  zh: '![](img/Figure_6.1_B17491.jpg)'
- en: Figure 6.1 – Active targets on AlmaLinux
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.1 – AlmaLinux中的活动targets
- en: 'Add the `--inactive` option to see the inactive targets:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 添加`--inactive`选项来查看非活动的targets：
- en: '![](img/Figure_6.2_B17491.jpg)'
  id: totrans-21
  prefs: []
  type: TYPE_IMG
  zh: '![](img/Figure_6.2_B17491.jpg)'
- en: Figure 6.2 – Inactive targets on AlmaLinux
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.2 – AlmaLinux中的非活动targets
- en: You can probably figure out what a lot of these targets are doing just by looking
    at their names. For the ones that aren't so obvious, either just look in the `systemd.special`
    man page or search for a man page with a particular target name.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能通过查看这些targets的名称就能大致猜到它们在做什么。对于那些不那么明显的，您可以查看`systemd.special`手册页，或搜索具有特定target名称的手册页。
- en: Next, let's peek inside a few of these target files to see what we can see.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们深入看看这些target文件，看看我们能发现什么。
- en: Understanding the structure of a target file
  id: totrans-25
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解target文件的结构
- en: As I've said before, the best way to learn `systemd` is to look at examples
    of the various unit files. In this section, we'll look at some `.target` files.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我之前所说，学习`systemd`的最好方式是查看各种单元文件的示例。在本节中，我们将查看一些`.target`文件。
- en: Understanding the sockets.target file
  id: totrans-27
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 理解`sockets.target`文件
- en: 'Let''s start with the `sockets.target` file, which is one of the simplest targets
    we have:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从` sockets.target`文件开始，它是我们拥有的最简单的target之一：
- en: '[PRE0]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Yeah, that''s it, the entire file. The `[Unit]` section is the only section
    it has, and it only consists of the `Description=` line and the `Documentation=`
    line. At first glance, you would think that this can''t possibly be doing anything
    for us. But that''s where you''d be wrong. Look in the `/etc/systemd/system/sockets.target.wants`
    directory, and you''ll see that this target is just a group of all the sockets
    that we need to have running:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 对，只有这些，整个文件。`[Unit]` 部分是它唯一的部分，只包含 `Description=` 行和 `Documentation=` 行。乍一看，你可能会觉得这肯定对我们没有任何作用。但你错了。查看
    `/etc/systemd/system/sockets.target.wants` 目录，你会看到这个目标只是我们需要运行的所有套接字的集合：
- en: '[PRE1]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'To see how this works, let''s look inside the `cups.socket` file:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 为了查看这如何工作，让我们看一下 `cups.socket` 文件：
- en: '[PRE2]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'You can see in the `[Install]` section that this socket is wanted by `sockets.target`.
    In other words, this socket for the `sockets.target` is activated. Of course,
    `sockets.target` is already active by default on pretty much any Linux system,
    so you normally won''t have to worry about activating it yourself. `cups.socket`
    is also normally active by default, but you might not always need it. Let''s say
    that you''re running a text-mode server, and you know for a fact that you''ll
    never need to print anything from it. You can disable `cups.socket` the same way
    that you''d disable a service:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在 `[Install]` 部分看到这个套接字是由 `sockets.target` 所需要的。换句话说，这个 `sockets.target`
    的套接字会被激活。当然，`sockets.target` 在几乎所有 Linux 系统上默认都是激活的，所以你通常不需要自己去激活它。`cups.socket`
    通常也是默认激活的，但你可能并不总是需要它。假设你正在运行一个文本模式的服务器，而且你确定你永远不会从中打印任何东西。你可以像禁用服务一样禁用 `cups.socket`：
- en: '[PRE3]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: When you do this, the associated `cups.service` is still running, so you'll
    also need to stop and disable it. If you change your mind, you can always re-enable
    the service and the socket.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 当你这样做时，相关的 `cups.service` 仍然在运行，所以你还需要停止并禁用它。如果你改变主意，随时可以重新启用该服务和套接字。
- en: Understanding dependencies in the sshd.service file
  id: totrans-37
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 理解 `sshd.service` 文件中的依赖关系
- en: We've already looked at the `sshd.service` file, but it's worthwhile to look
    at it again. To save space, I'll just show the `[Unit]` and `[Install]` sections,
    which are the only two sections that we need to look at.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经查看过 `sshd.service` 文件，但再看一遍还是很有价值的。为了节省空间，我将只展示 `[Unit]` 和 `[Install]` 部分，这也是我们需要查看的两个部分。
- en: The [Unit] and [Install] sections
  id: totrans-39
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '`[Unit]` 和 `[Install]` 部分'
- en: 'Here are the `[Unit]` and `[Install]` sections of the `sshd.service` file:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是 `sshd.service` 文件中的 `[Unit]` 和 `[Install]` 部分：
- en: '[PRE4]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: We've already seen the `WantedBy=multi-user.target` line in the `[Install]`
    section, which means that the secure shell service will automatically start when
    the machine boots into multi-user mode.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经在 `[Install]` 部分看到了 `WantedBy=multi-user.target` 这一行，意味着当机器启动到多用户模式时，安全
    shell 服务会自动启动。
- en: In the `[Unit]` section of the `sshd.service` file, we see that `sshd.service`
    won't start until after `network.target` and `sshd-keygen.target` have started.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `sshd.service` 文件的 `[Unit]` 部分，我们看到 `sshd.service` 直到 `network.target` 和 `sshd-keygen.target`
    启动后才会启动。
- en: Now, let's see what's in the `network.target` file.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看 `network.target` 文件里有什么。
- en: Understanding passive targets
  id: totrans-45
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 理解被动目标
- en: 'The `network.target` file looks like this:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: '`network.target` 文件是这样的：'
- en: '[PRE5]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: One interesting thing here is the `RefuseManualStart=yes` line that we see at
    the end. This just means that this target will start automatically and that we
    can't start it ourselves. This is why we consider `network.target` as a *passive*
    target. We also see that `network.target` will start after `network-pre.target`,
    which is also a passive target.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个有趣的地方，就是我们在文件末尾看到的 `RefuseManualStart=yes` 这一行。这意味着这个目标会自动启动，我们不能手动启动它。这就是为什么我们将
    `network.target` 视为 *被动* 目标的原因。我们还看到 `network.target` 会在 `network-pre.target`
    启动后启动，而 `network-pre.target` 也是一个被动目标。
- en: 'What''s even more interesting, and a bit curious, is that this `network.target`
    doesn''t appear to be doing anything for us. I mean, there''s no code here that''s
    really doing anything; it doesn''t appear to be starting any services, and there''s
    no `.wants` directory under the `/etc/systemd/system/` directory that would allow
    us to add services to it. We can see that here:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 更有趣且稍显好奇的是，`network.target` 似乎并没有为我们做任何事情。我的意思是，这里没有任何真正做事的代码；它似乎并没有启动任何服务，并且在
    `/etc/systemd/system/` 目录下也没有 `.wants` 目录，无法让我们向其中添加服务。我们可以在这里看到：
- en: '[PRE6]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'So, what''s going on here? Well, this is one of those things that takes a bit
    of detective work to find out, because the developers of `systemd` don''t document
    it well. The answer is that several targets are *hardcoded* into the `systemd`
    executable file. `network.target` is one example. To get a bit of a clue about
    this, we can use the `strings` utility to view any text strings that might be
    in the `systemd` executable file. The command to use it is:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，这里到底发生了什么呢？嗯，这是一个需要一点侦探工作才能找出答案的问题，因为 `systemd` 的开发者没有很好地记录这一点。答案是，多个目标被*硬编码*到
    `systemd` 可执行文件中。`network.target` 就是一个例子。为了更好地理解这一点，我们可以使用 `strings` 工具来查看可能存在于
    `systemd` 可执行文件中的任何文本字符串。使用命令如下：
- en: '[PRE7]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'The output should look something like this:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 输出应类似如下：
- en: '![](img/Figure_6.3_B17491.jpg)'
  id: totrans-54
  prefs: []
  type: TYPE_IMG
  zh: '![](img/Figure_6.3_B17491.jpg)'
- en: Figure 6.3 – Targets that are hardcoded into the systemd executable
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.3 – 硬编码进 systemd 可执行文件的目标
- en: Understand that not all of these hardcoded targets are passive targets. For
    example, at the top of the list, you see several targets that have to do with
    powering down the machine, rebooting the machine, or rescuing the machine. (I'm
    talking about everything down to `emergency.target`.) These are targets that we
    can definitely invoke ourselves.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 要理解，并非所有这些硬编码的目标都是被动目标。例如，在列表的顶部，你会看到一些与关闭机器、电源重启或抢救机器相关的目标。（我指的是从`emergency.target`到其他所有目标。）这些目标是我们可以自己调用的。
- en: Passive targets are automatically started during the system initialization portion
    of the boot process. `network.target` gets activated when the machine is able
    to reach the network. By placing `After=network.target` in the `[Unit]` section
    of the `sshd.service` file, we ensure that the Secure Shell service won't start
    until after the network is activated and available.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 被动目标在系统初始化部分的引导过程中会自动启动。当机器能够访问网络时，`network.target` 会被激活。通过在`sshd.service`文件的`[Unit]`部分中加入`After=network.target`，我们确保在网络激活并可用之后，安全外壳服务才会启动。
- en: Understanding service templates
  id: totrans-58
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 理解服务模板
- en: 'To refresh our memories, let''s take another look at the `[Unit]` section of
    our `sshd.service` file:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 为了刷新记忆，让我们再看一下我们`sshd.service`文件中的`[Unit]`部分：
- en: '[PRE8]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'We see that `sshd.service` wants `sshd-keygen.target`, and is not to start
    until after `sshd-keygen.target` has started. Let''s peek inside the `sshd-keygen.target`
    file:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 我们看到 `sshd.service` 要求 `sshd-keygen.target`，并且在 `sshd-keygen.target` 启动之前不会启动。让我们来看一下
    `sshd-keygen.target` 文件：
- en: '[PRE9]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'We see that `sshd.target` wants `sshd-keygen@.service` three different times.
    The `@` symbol in the filename indicates that this is a service *template*. When
    we invoke a service template, we''ll place the value of a variable after the `@`
    symbol, which allows us to run a service multiple times with different parameters.
    To see what I''m talking about, let''s look inside the `sshd-keygen@.service`
    file:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 我们看到 `sshd.target` 要求三次调用 `sshd-keygen@.service`。文件名中的 `@` 符号表示这是一个服务*模板*。当我们调用服务模板时，会将一个变量的值放在
    `@` 符号后面，这样我们就可以用不同的参数多次运行同一个服务。为了说明我说的是什么，我们来看一下 `sshd-keygen@.service` 文件：
- en: '[PRE10]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The first thing to note is the `%i` variable. In the `sshd-keygen.target` file,
    we see that the three values for this variable are `rsa`, `ecdsa`, and `ed25519`.
    These values represent the three types of secure shell keys that we want on our
    system.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 首先要注意的是 `%i` 变量。在 `sshd-keygen.target` 文件中，我们看到该变量的三个值分别是 `rsa`、`ecdsa` 和 `ed25519`。这些值代表了我们希望在系统中拥有的三种安全外壳密钥类型。
- en: 'The `ConditionFileNotEmpty=|!/etc/ssh/ssh_host_%i_key` line verifies whether
    or not these three key files already exist. On my AlmaLinux system, the keys look
    like this:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: '`ConditionFileNotEmpty=|!/etc/ssh/ssh_host_%i_key` 这一行验证这三个密钥文件是否已存在。在我的 AlmaLinux
    系统上，这些密钥如下所示：'
- en: '[PRE11]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: In this `ConditionFileNotEmpty=` line, the `!` means that we're looking for
    the *absence* of these three key files. The pipe symbol (`|`) that's before the
    `!` is the *trigger* symbol. When you put both of these symbols together, it means
    that nothing will happen if the three key files already exist. But if the key
    files *don't* exist, the `|` symbol will cause this service to run in order to
    create them.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个 `ConditionFileNotEmpty=` 行中，`!` 表示我们正在寻找这三个密钥文件的*缺失*。在 `!` 前面的管道符号 (`|`)
    是*触发*符号。当你将这两个符号结合在一起时，如果这三个密钥文件已经存在，就什么也不会发生。但如果密钥文件*不存在*，`|` 符号将使该服务运行，以创建这些文件。
- en: In the `[Service]` section, we see the `ExecStart=/usr/libexec/openssh/sshd-keygen
    %i` line. This will cause the `sshd-keygen` command to run once for every value
    of the `%i` variable that's defined in `sshd-keygen.target`. Each time it runs,
    it will create one of the three key files that we need.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 在`[Service]`部分，我们看到`ExecStart=/usr/libexec/openssh/sshd-keygen %i`这一行。这将导致每次`%i`变量在`sshd-keygen.target`中定义的每个值都会运行一次`sshd-keygen`命令。每次运行时，它都会创建我们需要的三个密钥文件之一。
- en: The last thing to look at here is the `Type=oneshot` line, which is also in
    the `[Service]` section. This causes the service to just run as a normal script
    that performs some specified one-time task, instead of as a continuously running
    daemon. After the specified commands have run, the service shuts down.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 这里最后需要查看的是`Type=oneshot`这一行，它也位于`[Service]`部分。这会使服务作为一个普通脚本运行，执行一些指定的单次任务，而不是作为一个持续运行的守护进程。当指定的命令执行完毕后，服务会关闭。
- en: Okay, we've seen what targets are, and we've seen a few simple examples. Now,
    let's look at the targets that have replaced the old-fashioned runlevels.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 好了，我们已经看到了什么是目标，并且也看了一些简单的示例。现在，让我们来看看取代旧式运行级别的目标。
- en: Comparing systemd targets to SysVinit runlevels
  id: totrans-72
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将systemd目标与SysVinit运行级别进行比较
- en: 'The old SysV runlevels defined which services would run when the operating
    system reached a certain state. It was a simple concept, except that there were
    four different sets of runlevel definitions that a Linux user would have to know.
    There was the generic set, which was created by the big Linux gurus at the Linux
    Foundation as part of the *Linux Standard Base*. The Red Hat definitions were
    almost identical to the generic ones. The *Slackware* and *Debian* developers
    basically came out of left field and created their own definitions that didn''t
    look anything like the generic ones. (Of course, Slackware and Debian are the
    two oldest surviving Linux distros, so it''s possible that they might have created
    their own definitions before the Linux Foundation gurus created the generic definitions.)
    This made things a bit confusing for new Linux users, especially for those of
    us who had to study for the Linux Professional Institute certification exam. It
    also made things a bit difficult for developers who needed to create new services
    that would run on all the different families of Linux distros. Fortunately, all
    we need to consider for now is the generic definitions, and how they compare to
    the `systemd` targets. Let''s look at the following table:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 旧的SysV运行级别定义了操作系统达到某个状态时需要运行的服务。这个概念很简单，除了有四组不同的运行级别定义，Linux用户需要了解这些定义。首先是通用定义集，这是由Linux基金会的大师们作为*Linux标准基础*的一部分创建的。Red
    Hat的定义几乎与通用定义一样。*Slackware*和*Debian*的开发者则从左场出来，创建了他们自己的定义，这些定义与通用定义完全不同。（当然，Slackware和Debian是两种最古老的存活Linux发行版，所以他们可能在Linux基金会的专家们创建通用定义之前就创建了自己的定义。）这让新Linux用户有些困惑，尤其是对于那些需要为Linux专业认证考试做准备的人来说。这也让开发者创建能在所有不同Linux发行版系列上运行的新服务变得有点困难。幸运的是，目前我们只需要考虑通用定义，以及它们与`systemd`目标的比较。我们来看看下面的表格：
- en: '![](img/B17491_06_Table_01.jpg)'
  id: totrans-74
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B17491_06_Table_01.jpg)'
- en: 'In `systemd`, there are some runlevel-type targets that have no SysV counterparts:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 在`systemd`中，有一些运行级别类型的目标，它们没有对应的SysV版本：
- en: '`emergency.target` is like `rescue.target`, except that filesystems are mounted
    as read-only.'
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`emergency.target`类似于`rescue.target`，只是文件系统以只读方式挂载。'
- en: '`hibernate.target` saves the system state and then powers down the machine.'
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`hibernate.target`保存系统状态，然后关闭机器。'
- en: '`suspend.target` just puts the system to sleep without powering it down.'
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`suspend.target`仅仅是将系统置于睡眠状态，而不关闭电源。'
- en: '`hibernate.target` and `suspend.target`, which aren''t needed on server implementations
    of Linux, are a big help to the growing numbers of people who use Linux on laptop
    and desktop computers. Prior to systemd, there was no good, standardized way of
    implementing these features.'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: '`hibernate.target`和`suspend.target`，它们在Linux的服务器实现中不需要，但对于越来越多在笔记本和台式计算机上使用Linux的人来说，这些功能是非常有帮助的。在systemd之前，实施这些功能没有一个好的、标准化的方式。'
- en: Note that in the official generic definition set, `runlevel 2` and `runlevel
    4` don't exactly correspond to the multi-user target. For some reason, every explanation
    of runlevels versus targets always places runlevels 2 and 4 here, and I'm not
    sure why.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，在官方的通用定义集中，`runlevel 2`和`runlevel 4`并不完全对应于多用户目标。由于某些原因，每次解释运行级别与目标的关系时，总是将运行级别2和4放在这里，我也不太清楚为什么。
- en: 'A big difference between SysV and `systemd` is that on SysV, each runlevel
    is its own independent unit. So, if you had a machine set up to boot into `runlevel
    5`, it would go directly to `runlevel 5`. On `systemd`, one target can depend
    upon another target, which in turn might depend upon yet another target. Take,
    for example, this `graphical.target` unit file:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: SysV 和 `systemd` 之间的一个重大区别是，在 SysV 中，每个运行级别都是一个独立的单元。所以，如果你将机器设置为启动到 `runlevel
    5`，它会直接进入 `runlevel 5`。在 `systemd` 中，一个目标可以依赖于另一个目标，而后者又可能依赖于另一个目标。以这个 `graphical.target`
    单元文件为例：
- en: '[PRE12]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The `Requires=multi-user.target` line means that `graphical.target` will fail
    to start unless `multi-user.target` is already running. All of the services that
    get started in multiuser mode will continue to run in graphical mode. The `Wants=display-manager.service`
    line means that it wants to start the display manager, but it won't fail if the
    display manager doesn't start.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: '`Requires=multi-user.target` 行意味着，除非 `multi-user.target` 已经在运行，否则 `graphical.target`
    将无法启动。所有在多用户模式下启动的服务将在图形模式下继续运行。`Wants=display-manager.service` 行意味着它希望启动显示管理器，但如果显示管理器没有启动，它不会失败。'
- en: The `Conflicts=rescue.service rescue.target` line tells `systemd` to shut down
    `graphical.target` if either `rescue.service` or `rescue.target` gets started,
    or to shut down `rescue.service` or `rescue.target` if `graphical.target` gets
    started. Of course, `shutdown.target` is also a conflict, but we don't need to
    list it. The `Conflicts=shutdown.target` parameter is already implied.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: '`Conflicts=rescue.service rescue.target` 行告诉 `systemd`，如果启动了 `rescue.service`
    或 `rescue.target`，则关闭 `graphical.target`；如果启动了 `graphical.target`，则关闭 `rescue.service`
    或 `rescue.target`。当然，`shutdown.target` 也是一个冲突项，但我们不需要列出它。`Conflicts=shutdown.target`
    参数已经隐含在其中。'
- en: The `After=` line seems a bit strange, doesn't it? I mean, it does make sense
    that `graphical.target` can't run until after `multi-user.target` and `display-manager.service`
    have completed starting up. But what about `rescue.service` and `rescue.target`?
    Why would we need these rescue units to run before starting `graphical.target`?
    Well, we actually don't. It's just that the `After=` directive also affects what
    happens when you shut down a target. In this case, the directive says that if
    you decide to switch from `graphical.target` to `rescue.target`, `rescue.target`
    and `rescue.service` won't start until after `graphical.target` shuts down. So,
    by switching from graphical mode to rescue mode, the `After=` line operates in
    an inverse fashion.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: '`After=` 行似乎有点奇怪，对吧？我的意思是，确实可以理解在 `multi-user.target` 和 `display-manager.service`
    启动完成之前，`graphical.target` 无法运行。但是 `rescue.service` 和 `rescue.target` 呢？为什么需要这些抢救单元在启动
    `graphical.target` 之前运行呢？实际上，我们并不需要它们。只是 `After=` 指令也影响着在关闭目标时会发生什么。在这种情况下，该指令表示，如果你决定从
    `graphical.target` 切换到 `rescue.target`，`rescue.target` 和 `rescue.service` 需要等到
    `graphical.target` 关闭后才会启动。所以，通过从图形模式切换到抢救模式，`After=` 行以相反的方式运作。'
- en: The last line is `AllowIsolate=yes`. This just means that we can switch from
    this target to another, if we so desire. For example, if we need to drop out of
    graphical mode to a pure command-line mode, we can *isolate* to `multi-user.target`.
    (Yeah, the terminology is a bit strange, but that's just the way it is.) Before
    we move on to that, let's talk a bit more about *dependencies*.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一行是 `AllowIsolate=yes`。这意味着我们可以根据需要从这个目标切换到另一个目标。例如，如果我们需要从图形模式切换到纯命令行模式，我们可以
    *孤立* 到 `multi-user.target`。（是的，术语有点奇怪，但就是这样。）在我们继续之前，让我们再多谈谈 *依赖关系*。
- en: Understanding target dependencies
  id: totrans-87
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解目标依赖关系
- en: 'In this `graphical.target` file, the `Requires=multi-user.target` line means
    that `multi-user.target` has to be running before `graphical.target` can start.
    So, `multi-user.target` is a dependency for `graphical.target`. Now, let''s peek
    into the `multi-user.target` file:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个 `graphical.target` 文件中，`Requires=multi-user.target` 行表示，`multi-user.target`
    必须在 `graphical.target` 启动之前已经运行。所以，`multi-user.target` 是 `graphical.target` 的依赖项。现在，让我们看看
    `multi-user.target` 文件：
- en: '[PRE13]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Here, we see that `multi-user.target` requires `basic.target`. So, let''s look
    at the `basic.target` file to see what it requires:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们看到 `multi-user.target` 需要 `basic.target`。所以，让我们看看 `basic.target` 文件，看看它需要什么：
- en: '[PRE14]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Okay, `basic.target` requires `sysinit.target`. So, let''s see what `sysinit.target`
    requires:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，`basic.target` 需要 `sysinit.target`。那么，让我们看看 `sysinit.target` 需要什么：
- en: '[PRE15]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '`sysinit.target` doesn''t *require* anything, but it does *want* `local-fs.target`
    and `swap.target`. Some of these chained targets have their own `.wants` directories
    in the `/etc/systemd/system/` directory that contain symbolic links to the services
    that will start for those targets. Here, for example, is the contents of the `/etc/systemd/system/sysinit.target.wants/`
    directory:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: '`sysinit.target`并不*要求*任何内容，但它*需要*`local-fs.target`和`swap.target`。这些链式目标中的一些在`/etc/systemd/system/`目录下有自己的`.wants`目录，里面包含指向将要启动的服务的符号链接。例如，这里是`/etc/systemd/system/sysinit.target.wants/`目录的内容：'
- en: '[PRE16]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Trying to figure out all of a target''s dependencies might seem like a complex
    operation, but it really isn''t. To see the dependencies for `graphical.target`,
    we''ll just do `systemctl list-dependencies graphical.target`, like this:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试弄清楚一个目标的所有依赖项可能看起来像是一个复杂的操作，但实际上并不是。要查看`graphical.target`的依赖项，我们只需执行`systemctl
    list-dependencies graphical.target`，像这样：
- en: '[PRE17]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: The whole output is too long to list here, but you get the idea.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 整个输出太长，无法在此列出，但你大概明白了。
- en: 'The `--after` and `--before` options show the dependencies that must start
    either *before* or *after* a target starts. (No, I didn''t do that backward. The
    `--after` option indicates that the target must start after the listed dependencies,
    and the `--before` option indicates that the target must start before the listed
    dependencies.) For a simple example, let''s see what must start before `network.target`
    can start:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: '`--after`和`--before`选项显示必须在目标启动*之前*或*之后*启动的依赖项。（不，我没有搞错。`--after`选项表示目标必须在列出的依赖项之后启动，而`--before`选项表示目标必须在列出的依赖项之前启动。）举个简单的例子，看看在`network.target`启动之前，必须先启动哪些内容：'
- en: '[PRE18]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'If you like, you can also create a graphical representation of a target''s
    dependencies. To do that, you''ll first need to install the `graphviz` package.
    The command to do that on the AlmaLinux machine is:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你愿意，你还可以创建一个图形化表示来展示目标的依赖项。为此，首先需要安装`graphviz`包。在 AlmaLinux 机器上执行的命令是：
- en: '[PRE19]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Next, let''s use `systemd-analyze` to create the graphics file that shows the
    dependencies for `graphical.target`. The command looks like this:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们使用`systemd-analyze`来创建显示`graphical.target`依赖项的图形文件。命令如下所示：
- en: '[PRE20]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Finally, open the resultant `graphical.svg` file in *Firefox*. Either resize
    the image to fit the screen or use the slider bar at the bottom to view different
    parts of the image:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，在*Firefox*中打开生成的`graphical.svg`文件。可以调整图像大小以适应屏幕，或者使用底部的滑块查看图像的不同部分：
- en: '![](img/Figure_6.4_B17491.jpg)'
  id: totrans-106
  prefs: []
  type: TYPE_IMG
  zh: '![](img/Figure_6.4_B17491.jpg)'
- en: Figure 6.4 – The graphical.target dependencies
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.4 – graphical.target 依赖项
- en: (Note that your graphic might not look exactly like mine. I don't know why,
    but that's how it is.)
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: （注意，您的图形可能与我的不完全相同。我不知道为什么，但事实就是如此。）
- en: The point I'm trying to make here is that targets can have an entire chain of
    dependencies. This allows us to have a more modular setup, so that we don't have
    to create each individual target file with its own complete list of dependencies.
    This is the opposite of how SysV works. With SysV, each runlevel has its own directory
    of symbolic links that point to all of the services that are to be started for
    the specified runlevel.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 我想表达的观点是，目标可以有一整条依赖链。这使得我们可以拥有更模块化的配置，从而无需为每个目标文件创建其完整的依赖列表。这与 SysV 的工作方式相反。对于
    SysV，每个运行级别都有一个符号链接目录，指向为该指定运行级别启动的所有服务。
- en: Now that we've seen what targets are and how they're constructed, let's see
    how to set the default target.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经了解了什么是目标以及它们是如何构建的，让我们看看如何设置默认目标。
- en: Changing the default target
  id: totrans-111
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 更改默认目标
- en: 'When you install a Linux operating system, the installer will configure either
    `multi-user.target` or `graphical.target` as the default, depending upon whether
    or not you choose to install a graphical desktop environment. When you boot up
    a Linux machine, it can be quite obvious what the default target is. If a graphical
    desktop shows up, you can rest assured that `graphical.target` is set as the default:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 当你安装 Linux 操作系统时，安装程序将根据是否选择安装图形桌面环境来配置`multi-user.target`或`graphical.target`为默认目标。当你启动
    Linux 机器时，默认目标可能非常明显。如果出现图形桌面，你可以放心地认为`graphical.target`已设置为默认目标：
- en: '![](img/Figure_6.5_B17491.jpg)'
  id: totrans-113
  prefs: []
  type: TYPE_IMG
  zh: '![](img/Figure_6.5_B17491.jpg)'
- en: Figure 6.5 – AlmaLinux with the Gnome 3 desktop
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.5 – 带有 Gnome 3 桌面的 AlmaLinux
- en: However, if a graphical desktop doesn't show up, it doesn't necessarily mean
    that the machine is set up with `multi-user.target` as its default. It could be
    that `graphical.target` is the default, and that the graphical display manager
    has failed to start. (I've seen that happen a few times when a video card driver
    is configured incorrectly.)
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果没有显示图形桌面，这并不一定意味着机器以 `multi-user.target` 作为其默认设置。可能是 `graphical.target`
    是默认设置，并且图形显示管理器未能启动。（我曾经见过视频卡驱动程序配置错误时发生几次。）
- en: 'To see which target is set as the default, use `systemctl get-default`:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看设置为默认的目标，请使用 `systemctl get-default`：
- en: '[PRE21]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'You can also see the default setting by looking at the `/etc/systemd/system/default.target`
    symbolic link, which looks like this:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以通过查看 `/etc/systemd/system/default.target` 符号链接来查看默认设置，看起来像这样：
- en: '[PRE22]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: We see that the symbolic link points to the `graphical.target` file.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 我们看到符号链接指向 `graphical.target` 文件。
- en: 'Now, let''s say that you no longer want this machine to boot into graphical
    mode. Just set it to multiuser mode, like this:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，假设您不再希望此计算机启动到图形模式。只需将其设置为多用户模式，就像这样：
- en: '[PRE23]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'You can see that the `default.target` symbolic link now points to the `multi-user.target`
    file. When you reboot this machine now, the graphical desktop won''t start up.
    After you''ve rebooted the machine to verify that this works, go ahead and change
    it back to graphical mode by doing:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以看到 `default.target` 符号链接现在指向 `multi-user.target` 文件。现在重新启动此计算机，图形桌面将不会启动。验证此操作有效后，继续通过以下方式将其切换回图形模式：
- en: '[PRE24]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Then, reboot the machine to get back into graphical mode.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 然后重新启动机器以返回到图形模式。
- en: All right, this is all good. But there might be times when we'll just want to
    change to another target temporarily without changing the default. Let's look
    at that.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，这一切都很好。但是有时我们可能只是想暂时切换到另一个目标，而不更改默认设置。让我们看看如何操作。
- en: Temporarily changing the target
  id: totrans-127
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 临时更改目标
- en: 'You can also change from one target to another without changing the default.
    This can come in handy for a few reasons. For example, let''s say that you''re
    setting up a gaming computer with an *Nvidia* graphics card. Now, if all you want
    to do with your Linux computer is just surf the web or do normal office work,
    the open source Nvidia drivers that come with your Linux distro work fine. For
    gaming though, the open source drivers might not give you the gaming performance
    that you really crave. To get around that, you''ll go to the Nvidia website and
    download their proprietary driver. The first step in the installation procedure
    is to drop the machine out of graphical mode, into text mode. To do that with
    `systemd`, we''ll use the `systemctl isolate` option, like this:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以在不更改默认设置的情况下从一个目标切换到另一个目标。这在某些情况下非常方便。例如，假设您正在设置一个带有 *Nvidia* 显卡的游戏电脑。现在，如果您的
    Linux 计算机只是用来上网或进行普通办公工作，那么随 Linux 发行版提供的开源 Nvidia 驱动程序完全足够。然而，对于游戏来说，开源驱动可能无法提供您真正需要的游戏性能。为了解决这个问题，您将访问
    Nvidia 网站并下载他们的专有驱动程序。安装过程的第一步是将机器从图形模式切换到文本模式。使用 `systemd`，我们将使用 `systemctl isolate`
    选项，就像这样：
- en: '[PRE25]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'This will shut down the graphics server and bring you back to a text-mode login
    prompt:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 这将关闭图形服务器，并将您带回文本模式登录提示符：
- en: '![](img/Figure_6.6_B17491.jpg)'
  id: totrans-131
  prefs: []
  type: TYPE_IMG
  zh: '![](img/Figure_6.6_B17491.jpg)'
- en: Figure 6.6 – Text-mode login on Alma Linux
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.6 – Alma Linux 上的文本模式登录
- en: 'To get back to graphical mode, you can reboot the machine, assuming that you
    still have `graphical.target` set as the default. Or, you can just run the `isolate`
    command again, like this:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 要返回到图形模式，您可以重新启动机器，假设仍将 `graphical.target` 设置为默认。或者，您可以再次运行 `isolate` 命令，如下所示：
- en: '[PRE26]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Be aware though that isolating back to graphical mode can sometimes be a bit
    quirky, so you might find it better to just reboot. Besides, if you're installing
    a video driver, you'll need to reboot in any case.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，有时候切换回图形模式可能会有些古怪，因此您可能会发现最好的方法是重新启动。此外，如果您安装了视频驱动程序，无论如何都需要重新启动。
- en: 'Now, if you''re an old-as-dirt codger like me, you might be so used to the
    old way of doing things that you can''t do things the new way. Well, I have good
    news. You can still use the old SysV commands to change targets if you really
    want to. To allow this to happen, the `systemd` developers created symbolic runlevel
    links that point to the corresponding targets. Here''s what they look like:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果你像我一样是个年纪较大的老家伙，你可能已经习惯了老式的做法，以至于不能适应新的方式。好消息是，你仍然可以使用旧的SysV命令来更改目标，如果你真的想的话。为了支持这种方式，`systemd`的开发者创建了指向相应目标的符号链接。它们看起来是这样的：
- en: '[PRE27]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'The legacy `init` and `telinit` commands are also still there, so you can still
    use either of them to change runlevels. For example, you can drop from graphical
    mode down to multiuser mode with either of these two commands:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 旧版的`init`和`telinit`命令仍然存在，所以你可以使用其中任一命令来更改运行级别。例如，你可以使用这两个命令中的任意一个从图形模式切换到多用户模式：
- en: '[PRE28]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: To get back to graphical mode, just run either of these commands again, replacing
    the `3` with a `5`.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 要返回图形模式，只需再次运行这些命令，将`3`替换为`5`。
- en: All jokes aside, it's great that they included the backward-compatibility stuff
    for those who really need it. Still though, you'll want to get used to the modern
    `systemctl isolate` way of doing things, because the `systemd` developers could
    pull this backward-compatibility stuff out at any time.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 说笑归说笑，很高兴他们为那些真正需要的人包括了向后兼容的内容。不过，你仍然应该习惯现代的`systemctl isolate`方式，因为`systemd`的开发者随时可能会移除这些向后兼容的内容。
- en: All righty, I think that about covers things. Let's wrap this chapter up and
    put a bow on it.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，我想这差不多涵盖了所有内容。让我们结束这一章并收尾。
- en: Summary
  id: totrans-143
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: As we always do, we've covered a lot of ground and seen a lot of cool stuff.
    We looked at the purpose of `systemd` targets and how they're structured. Then,
    we looked at how `systemd` targets compare to the old SysVinit runlevels, and
    at how to view a target's dependencies. We finished by looking at how to set the
    default runlevel, and how to temporarily change the runlevel.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 和往常一样，我们覆盖了大量内容并看到了很多酷的东西。我们了解了`systemd`目标的目的及其结构。然后，我们比较了`systemd`目标和旧版SysVinit运行级别的异同，并看了如何查看目标的依赖关系。最后，我们讨论了如何设置默认的运行级别以及如何临时更改运行级别。
- en: In the next chapter, we'll look at `systemd` timers. I'll see you there.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将讨论`systemd`定时器。下章见。
- en: Questions
  id: totrans-146
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: What is a target?
  id: totrans-147
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 什么是目标？
- en: a) It's just another name for the old-fashioned runlevels.
  id: totrans-148
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: a) 它只是旧式运行级别的另一种名称。
- en: b) It's a unit that groups together other units for a specific purpose.
  id: totrans-149
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: b) 它是一个将其他单元组合在一起以实现特定目的的单元。
- en: c) It's a unit that starts a service.
  id: totrans-150
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: c) 它是一个启动服务的单元。
- en: d) It's a unit that listens for incoming network connections.
  id: totrans-151
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: d) 它是一个监听网络连接的单元。
- en: What is a passive target?
  id: totrans-152
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 什么是被动目标？
- en: a) It's a target that you can't start yourself.
  id: totrans-153
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: a) 它是一个你无法自己启动的目标。
- en: b) It's a placeholder target that doesn't do anything.
  id: totrans-154
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: b) 它是一个占位目标，不做任何事情。
- en: c) A passive target is configured with the `TargetMode=passive` line.
  id: totrans-155
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: c) 被配置为`TargetMode=passive`的目标是被动目标。
- en: d) It's a target that just runs in the background.
  id: totrans-156
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: d) 它是一个仅在后台运行的目标。
- en: How would you change from graphical mode to text mode?
  id: totrans-157
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如何从图形模式切换到文本模式？
- en: a) `sudo systemctl isolate text-mode`
  id: totrans-158
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: a) `sudo systemctl isolate text-mode`
- en: b) `sudo systemctl 3`
  id: totrans-159
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: b) `sudo systemctl 3`
- en: c) `sudo systemctl isolate multi-user`
  id: totrans-160
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: c) `sudo systemctl isolate multi-user`
- en: d) `sudo runlevel multi-user`
  id: totrans-161
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: d) `sudo runlevel multi-user`
- en: What is a major difference between SysV runlevels and `systemd` targets?
  id: totrans-162
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: SysV运行级别和`systemd`目标之间的主要区别是什么？
- en: a) SysV runlevels depend upon each other. `systemd` targets are self-contained
    units.
  id: totrans-163
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: a) SysV运行级别相互依赖，`systemd`目标是独立的单元。
- en: b) `systemd` targets depend upon each other. Each SysV runlevel has its own
    complete list of services to run.
  id: totrans-164
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: b) `systemd`目标是相互依赖的。每个SysV运行级别都有自己完整的服务列表。
- en: c) SysV runlevels run more efficiently than `systemd` targets.
  id: totrans-165
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: c) SysV运行级别比`systemd`目标运行得更高效。
- en: d) There is no real difference.
  id: totrans-166
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: d) 没有真正的区别。
- en: Which of the following commands shows you the default target?
  id: totrans-167
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下哪个命令可以显示默认目标？
- en: a) `systemctl show-target`
  id: totrans-168
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: a) `systemctl show-target`
- en: b) `systemctl show-default`
  id: totrans-169
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: b) `systemctl show-default`
- en: c) `systemctl default`
  id: totrans-170
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: c) `systemctl default`
- en: d) `systemctl get-default`
  id: totrans-171
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: d) `systemctl get-default`
- en: Answers
  id: totrans-172
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 答案
- en: b
  id: totrans-173
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: b
- en: a
  id: totrans-174
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: a
- en: c
  id: totrans-175
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: c
- en: b
  id: totrans-176
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: b
- en: d
  id: totrans-177
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: d
- en: Further reading
  id: totrans-178
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: 'An explanation of `network.target`:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: '`network.target`的解释：'
- en: '[https://www.freedesktop.org/wiki/Software/systemd/NetworkTarget/](https://www.freedesktop.org/wiki/Software/systemd/NetworkTarget/)'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://www.freedesktop.org/wiki/Software/systemd/NetworkTarget/](https://www.freedesktop.org/wiki/Software/systemd/NetworkTarget/)'
- en: 'Booting CentOS into emergency or rescue mode:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 启动CentOS进入紧急模式或恢复模式：
- en: '[https://www.thegeekdiary.com/how-to-boot-into-rescue-mode-or-emergency-mode-through-systemd-in-centos-rhel-7-and-8/](https://www.thegeekdiary.com/how-to-boot-into-rescue-mode-or-emergency-mode-through-systemd-in-centos-rhel-7-and-8/)'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://www.thegeekdiary.com/how-to-boot-into-rescue-mode-or-emergency-mode-through-systemd-in-centos-rhel-7-and-8/](https://www.thegeekdiary.com/how-to-boot-into-rescue-mode-or-emergency-mode-through-systemd-in-centos-rhel-7-and-8/)'
- en: 'Booting Ubuntu into emergency or rescue mode:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 启动Ubuntu进入紧急模式或恢复模式：
- en: '[https://linuxconfig.org/how-to-boot-ubuntu-18-04-into-emergency-and-rescue-mode](https://linuxconfig.org/how-to-boot-ubuntu-18-04-into-emergency-and-rescue-mode)'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://linuxconfig.org/how-to-boot-ubuntu-18-04-into-emergency-and-rescue-mode](https://linuxconfig.org/how-to-boot-ubuntu-18-04-into-emergency-and-rescue-mode)'
