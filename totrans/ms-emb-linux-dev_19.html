<html><head></head><body><div id="book-content"><div id="sbo-rt-content"><div id="_idContainer136" class="Basic-Text-Frame">
    <h1 class="chapterNumber"><a id="_idTextAnchor483"/>15</h1>
    <h1 id="_idParaDest-422" class="chapterTitle"><a id="_idTextAnchor484"/>Packaging Python</h1>
    <p class="normal"><strong class="keyWord">Python</strong> is the most popular programming<a id="_idIndexMarker1040"/> language for<strong class="keyWord"> machine learning</strong> (<strong class="keyWord">ML</strong>). Combine that with the proliferation of ML in our day-to-day lives<a id="_idIndexMarker1041"/> and it is no surprise that the desire to run Python on edge devices is intensifying. Even in this era of transpilers and WebAssembly, packaging Python applications for deployment remains an unsolved problem. In this chapter, you will learn what choices are out there for bundling Python modules together and when to use one method over another.</p>
    <p class="normal">We start with a look back at the origins of today’s Python packaging solutions, from the built-in standard <code class="inlineCode">distutils</code> to its successor, <code class="inlineCode">setuptools</code>. Next, we examine the <code class="inlineCode">pip</code> package manager, before moving on to <code class="inlineCode">venv</code> for Python virtual environments, followed by <code class="inlineCode">conda</code>, the reigning general-purpose cross-platform solution.</p>
    <p class="normal">Since Python is an interpreted language, you cannot compile a program into a standalone executable like you can with a language such as Go. This makes deploying Python applications complicated. Running a Python application requires installing a Python interpreter and several runtime dependencies. These requirements need to be code-compatible for the application to work. That requires the precise versioning of software components. Solving these deployment problems is what Python packaging is all about.</p>
    <p class="normal">In this chapter, we will cover the following topics:</p>
    <ul>
      <li class="bulletList">Retracing the origins of Python packaging</li>
      <li class="bulletList">Installing Python packages with <code class="inlineCode">pip</code></li>
      <li class="bulletList">Managing Python virtual environments with <code class="inlineCode">venv</code></li>
      <li class="bulletList">Installing precompiled binaries with <code class="inlineCode">conda</code></li>
    </ul>
    <h1 id="_idParaDest-423" class="heading-1"><a id="_idTextAnchor485"/>Technical requirements</h1>
    <p class="normal">To follow along with the examples, make sure you have the following software installed on your Linux host system:</p>
    <ul>
      <li class="bulletList">Python: Python 3 interpreter and standard library</li>
      <li class="bulletList"><code class="inlineCode">pip</code>: Package installer for Python 3</li>
      <li class="bulletList"><code class="inlineCode">venv</code>: Python module for creating and managing lightweight virtual environments</li>
      <li class="bulletList">Miniconda: Minimal installer for the <code class="inlineCode">conda</code> package and virtual environment manager</li>
    </ul>
    <p class="normal">I recommend using Ubuntu 24.04 LTS or later for this chapter. Even though Ubuntu 24.04 LTS runs on the Raspberry Pi 4, I still prefer to develop on an x86-64 desktop PC or laptop. Ubuntu also comes with Python 3 and <code class="inlineCode">pip</code> already installed since Python is used extensively throughout the system. Do not uninstall <code class="inlineCode">python3</code> or you will render Ubuntu unusable. To install <code class="inlineCode">venv</code> on Ubuntu, enter the following:</p>
    <pre class="programlisting con"><code class="hljs-con">$ sudo apt install python3-venv
</code></pre>
    <div class="note">
      <p class="normal"><strong class="keyWord">IMPORTANT NOTE</strong></p>
      <p class="normal">Do not install Miniconda until you get to the section on <code class="inlineCode">conda</code> because it interferes with the earlier <code class="inlineCode">pip</code> exercises that rely on the system Python installation.</p>
    </div>
    <h1 id="_idParaDest-424" class="heading-1"><a id="_idTextAnchor486"/>Retracing the origins of Python packaging</h1>
    <p class="normal">The Python packaging landscape is a vast graveyard of failed attempts and abandoned tools. Best practices around dependency <a id="_idIndexMarker1042"/>management change often within the Python community, and the recommended solution one year may be a broken nonstarter the next. As you research this topic, remember to look at when the information was published and do not trust any advice that may be out of date.</p>
    <p class="normal">Most Python libraries <a id="_idIndexMarker1043"/>are distributed using <code class="inlineCode">setuptools</code>, including all the packages found on the <strong class="keyWord">Python Package Index</strong> (<strong class="keyWord">PyPI</strong>). This distribution method relies on a <code class="inlineCode">setup.py</code> project<a id="_idIndexMarker1044"/> specification file that the <strong class="keyWord">package installer for Python</strong> (<strong class="keyWord">pip</strong>) uses to install a package. <code class="inlineCode">pip</code> can also generate or <em class="italic">freeze</em> a precise list of dependencies after a project is installed. This optional <code class="inlineCode">requirements.txt</code> file is used by <code class="inlineCode">pip</code> in conjunction with <code class="inlineCode">setup.py</code> to ensure that project installations are repeatable.</p>
    <h2 id="_idParaDest-425" class="heading-2"><a id="_idTextAnchor487"/>distutils</h2>
    <p class="normal"><strong class="keyWord">distutils</strong> is the original packaging<a id="_idIndexMarker1045"/> system for Python. It was included in the Python standard library <a id="_idIndexMarker1046"/>from Python 2.0 until its removal in Python 3.12. <code class="inlineCode">distutils</code> provided a Python package of the same name that could be imported by your <code class="inlineCode">setup.py</code> script. Now that <code class="inlineCode">distutils</code> is deprecated, direct usage of the package is no longer supported. <code class="inlineCode">setuptools</code> has become its preferred replacement.</p>
    <p class="normal">While <code class="inlineCode">distutils</code> may continue to work for simple projects, the community has moved on. Today, <code class="inlineCode">distutils</code> survives only for legacy reasons. Many Python libraries were first published back when <code class="inlineCode">distutils</code> was the only game in town. Porting them to <code class="inlineCode">setuptools</code> now would take considerable effort and could break existing users.</p>
    <h2 id="_idParaDest-426" class="heading-2"><a id="_idTextAnchor488"/>setuptools</h2>
    <p class="normal"><strong class="keyWord">setuptools</strong> extends <code class="inlineCode">distutils</code> by adding support for complex constructs that make larger applications based on web frameworks<a id="_idIndexMarker1047"/> like Flask <a id="_idIndexMarker1048"/>and FastAPI easier to distribute. It has become the de facto packaging system within the Python community. Like <code class="inlineCode">distutils</code>, <code class="inlineCode">setuptools</code> offers a Python package of the same name that you can import into your <code class="inlineCode">setup.py</code> script. <code class="inlineCode">distribute</code> was an ambitious fork of <code class="inlineCode">setuptools</code> that eventually merged back into <code class="inlineCode">setuptools 0.7</code>, cementing the status of <code class="inlineCode">setuptools</code> as the definitive choice for Python packaging.</p>
    <p class="normal"><code class="inlineCode">setuptools</code> introduced a command-line utility known as <code class="inlineCode">easy_install</code> (now deprecated) and a Python package called <code class="inlineCode">pkg_resources</code> for runtime package discovery and access to resource files. <code class="inlineCode">setuptools</code> can also produce packages that act as plugins for other extensible packages (for example, frameworks and applications). You do this by registering entry points in your <code class="inlineCode">setup.py</code> script for the other overarching package to import.</p>
    <p class="normal">The term <em class="italic">distribution</em> means something different in the context of Python. A distribution is a versioned archive of packages, modules, and other resource files used to distribute a release. A <em class="italic">release</em> is a versioned snapshot of a Python project taken at a given point in time. To make matters worse, the terms <em class="italic">package</em> and <em class="italic">distribution</em> are overloaded and often used interchangeably by Pythonistas. For our purposes, let’s say that a distribution is what you download, and a package is the module that gets installed and imported.</p>
    <p class="normal">Cutting a release can result in multiple distributions, such as a source distribution and one or more built distributions. There can be different built distributions for different platforms, such as one that includes a Windows installer. The term <em class="italic">built distribution</em> means that no build step is required before installation. It does not necessarily mean precompiled. Some built distribution formats such as <strong class="keyWord">Wheel</strong> (<code class="inlineCode">.whl</code>) exclude <a id="_idIndexMarker1049"/>compiled Python files, for example. A built distribution containing <a id="_idIndexMarker1050"/>compiled extensions is known as a <em class="italic">binary distribution</em>.</p>
    <p class="normal">An <strong class="keyWord">extension module</strong> is a Python <a id="_idIndexMarker1051"/>module that is written in C or C++. Every extension module compiles down to a single dynamically loaded library, such as a shared object (<code class="inlineCode">.so</code>) on Linux and a dynamic link library (<code class="inlineCode">.pyd</code>) on Windows. Contrast this with pure modules, which must be written entirely in Python. The Egg (<code class="inlineCode">.egg</code>) built distribution format introduced by <code class="inlineCode">setuptools</code> supports both pure and extension modules. Since a Python source code (<code class="inlineCode">.py</code>) file compiles down to a bytecode (<code class="inlineCode">.pyc</code>) file when the Python interpreter imports a module at runtime, you can see how a built distribution format such as Wheel might exclude precompiled Python files.</p>
    <h2 id="_idParaDest-427" class="heading-2"><a id="_idTextAnchor489"/>setup.py</h2>
    <p class="normal">Say you are developing a small <a id="_idIndexMarker1052"/>program in Python, maybe something that queries a remote REST API and saves response <a id="_idIndexMarker1053"/>data to a local SQL database. How do you package your program together with its dependencies for deployment? You start by defining a <code class="inlineCode">setup.py</code> script that <code class="inlineCode">setuptools</code> can use to install your program. Deploying with <code class="inlineCode">setuptools</code> is the first step toward more elaborate automated deployment schemes.</p>
    <p class="normal">Even if your program is small enough to fit comfortably inside a single module, chances are it won’t stay that way for long. Let’s say that your program consists of a single file named <code class="inlineCode">follower.py</code>, like so:</p>
    <pre class="programlisting con"><code class="hljs-con">$ tree follower
follower
└── follower.py
</code></pre>
    <p class="normal">You could then convert this <a id="_idIndexMarker1054"/>module into a package by splitting <code class="inlineCode">follower.py</code> up into<a id="_idIndexMarker1055"/> three separate modules and placing them inside a nested directory, also named <code class="inlineCode">follower</code>:</p>
    <pre class="programlisting con"><code class="hljs-con">$ tree follower/
follower/
└── follower
 ├── fetch.py
 ├── __main__.py
 └── store.py
</code></pre>
    <p class="normal">The <code class="inlineCode">__main__.py</code> module is where your program starts, so it contains mostly top-level, user-facing functionality. The <code class="inlineCode">fetch.py</code> module contains functions for sending HTTP requests to the remote REST API and the <code class="inlineCode">store.py</code> module contains functions for saving response data to the local SQL database. To run this package as a script, you need to pass the <code class="inlineCode">-m</code> option to the Python interpreter as follows:</p>
    <pre class="programlisting con"><code class="hljs-con">$ PYTHONPATH=follower python -m follower
</code></pre>
    <p class="normal">The <code class="inlineCode">PYTHONPATH</code> environment variable points to the directory where a target project’s package directories are located. The <code class="inlineCode">follower</code> argument after the <code class="inlineCode">-m</code> option tells Python to run the <code class="inlineCode">__main__.py</code> module belonging to the <code class="inlineCode">follower</code> package. Nesting package directories inside a project directory like this paves the way for your program to grow into a larger application made up of multiple packages each with its own namespace.</p>
    <p class="normal">With the pieces of your project all in their right place, we are now ready to create a minimal <code class="inlineCode">setup.py</code> script that <code class="inlineCode">setuptools</code> can use to package and deploy it:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">from</span> setuptools <span class="hljs-keyword">import</span> setup
    setup(
    name=<span class="hljs-string">'follower'</span>,
    version=<span class="hljs-string">'0.1'</span>,
    packages=[<span class="hljs-string">'follower'</span>],
    include_package_data=<span class="hljs-literal">True</span>,
    install_requires=[<span class="hljs-string">'requests'</span>, <span class="hljs-string">'sqlalchemy'</span>]
)
</code></pre>
    <p class="normal">The <code class="inlineCode">install_requires</code> argument is a list of external dependencies that need to be installed automatically for a project to work at runtime. Notice that I did not specify what versions of these dependencies are needed or where to fetch them from in my example. I only asked for libraries that look and act like <code class="inlineCode">requests</code> and <code class="inlineCode">sqlalchemy</code>. Separating policy from implementation like this allows you to easily swap out the official PyPI version of a dependency with your own in case you need to fix a bug or add a feature.</p>
    <div class="note">
      <p class="normal"><strong class="keyWord">Information note</strong></p>
      <p class="normal">Adding optional version specifiers to your dependency declarations is fine, but hardcoding distribution URLs within <code class="inlineCode">setup.py</code> as <code class="inlineCode">dependency_links</code> is wrong in principle.</p>
    </div>
    <p class="normal">The <code class="inlineCode">packages</code> argument tells <code class="inlineCode">setuptools</code> what in-tree packages to distribute with a project release. Since every package is defined inside its own subdirectory of the parent project directory, the only package <a id="_idIndexMarker1056"/>being shipped in this case is <code class="inlineCode">follower</code>. I am including data files along <a id="_idIndexMarker1057"/>with my Python code in this distribution. To do that, you need to set the <code class="inlineCode">include_package_data</code> argument to <code class="inlineCode">True</code> so that <code class="inlineCode">setuptools</code> looks for a <code class="inlineCode">MANIFEST.in</code> file and installs all the files listed there. Here are the contents of the <code class="inlineCode">MANIFEST.in</code> file:</p>
    <pre class="programlisting code"><code class="hljs-code">include data/events.db
</code></pre>
    <p class="normal">If the data directory contained nested directories of data we wanted to include, we could glob all of them along with their contents using <code class="inlineCode">recursive-include</code>:</p>
    <pre class="programlisting code"><code class="hljs-code">recursive-include data *
</code></pre>
    <p class="normal">Here is the final directory layout:</p>
    <pre class="programlisting con"><code class="hljs-con">$ tree follower
follower
├── data
│   └── events.db
├── follower
│   ├── fetch.py
│   ├── __init__.py
│   └── store.py
├── MANIFEST.in
└── setup.py
</code></pre>
    <p class="normal"><code class="inlineCode">setuptools</code> excels at building and distributing Python packages that depend on other packages. It can do this thanks to features such as entry points and dependency declarations, which are simply absent from <code class="inlineCode">distutils</code>. <code class="inlineCode">setuptools</code> works well with <code class="inlineCode">pip</code> and new releases of <code class="inlineCode">setuptools</code> arrive on a regular basis. The Wheel build distribution format was created to replace the Egg format that <code class="inlineCode">setuptools</code> introduced. That effort has largely succeeded with the addition of a popular <code class="inlineCode">setuptools</code> extension for <a id="_idIndexMarker1058"/>building wheels and <code class="inlineCode">pip</code>'s great support for installing wheels.</p>
    <h1 id="_idParaDest-428" class="heading-1"><a id="_idTextAnchor490"/>Installing Python packages with pip</h1>
    <p class="normal">You now know how to define your project’s dependencies in a <code class="inlineCode">setup.py</code> script. But how do you install those dependencies? How do <a id="_idIndexMarker1059"/>you upgrade a dependency or replace it when you find a better one? How do you decide when it is safe to delete a dependency you <a id="_idIndexMarker1060"/>no longer need?</p>
    <p class="normal">Managing project dependencies is a tricky business. Luckily, Python comes with a tool called <strong class="keyWord">pip</strong> that can help, especially in the <a id="_idIndexMarker1061"/>early stages of your project. The name stands for <strong class="keyWord">pip installs Python</strong>, which is a recursive acronym. <code class="inlineCode">pip</code> is the official package manager for Python.</p>
    <p class="normal">The initial 1.0 release of <code class="inlineCode">pip</code> arrived on April 4, 2011, around the same time that Node.js and <code class="inlineCode">npm</code> were taking off. Before it became <code class="inlineCode">pip</code>, the tool was named <code class="inlineCode">pyinstall</code>. <code class="inlineCode">pyinstall</code> was created in 2008 as an alternative to <code class="inlineCode">easy_install</code>, which came bundled with <code class="inlineCode">setuptools</code> at the time. <code class="inlineCode">easy_install</code> is now deprecated and <code class="inlineCode">setuptools</code> recommends using <code class="inlineCode">pip</code> instead.</p>
    <p class="normal">Since <code class="inlineCode">pip</code> is included with the Python installer and you can have multiple versions of Python installed on your system (for example, 2.7 and 3.13), it helps to know which version of <code class="inlineCode">pip</code> you are running:</p>
    <pre class="programlisting con"><code class="hljs-con">$ pip --version
</code></pre>
    <p class="normal">If no <code class="inlineCode">pip</code> executable is found on your system, that probably means you are on Ubuntu 20.04 LTS or later and do not have Python 2.7 installed. That is fine. We will merely substitute <code class="inlineCode">pip3</code> for <code class="inlineCode">pip</code> and <code class="inlineCode">python3</code> for <code class="inlineCode">python</code> throughout the rest of this section:</p>
    <pre class="programlisting con"><code class="hljs-con">$ pip3 --version
</code></pre>
    <p class="normal">If there is <code class="inlineCode">python3</code> but no <code class="inlineCode">pip3</code> executable, then install it as shown on Debian-based distributions such as Ubuntu:</p>
    <pre class="programlisting con"><code class="hljs-con">$ sudo apt install python3-pip
</code></pre>
    <p class="normal"><code class="inlineCode">pip</code> installs packages to a directory called <code class="inlineCode">site-packages</code>. To find the location of your <code class="inlineCode">site-packages</code> directory, run the following command:</p>
    <pre class="programlisting con"><code class="hljs-con">$ python3 -m site | grep ^USER_SITE
</code></pre>
    <div class="note">
      <p class="normal"><strong class="keyWord">IMPORTANT NOTE</strong></p>
      <p class="normal">Now that Python 2 has been deprecated, <code class="inlineCode">pip3</code> and <code class="inlineCode">python3</code> commands are available on popular Linux distributions like Ubuntu. If your Linux distribution does not have the <code class="inlineCode">pip3</code> and <code class="inlineCode">python3</code> commands, then use the <code class="inlineCode">pip</code> and <code class="inlineCode">python</code> commands instead. </p>
    </div>
    <p class="normal">To get a list of packages already installed on your system, use this command:</p>
    <pre class="programlisting con"><code class="hljs-con">$ pip3 list
</code></pre>
    <p class="normal">The list shows that <code class="inlineCode">pip</code> is just another Python package, so you could use <code class="inlineCode">pip</code> to upgrade itself, but I would advise you not to do that, at least not in the long term. I’ll explain why in the next section when I introduce virtual environments.</p>
    <p class="normal">To get a list of packages installed in<a id="_idIndexMarker1062"/> your <code class="inlineCode">site-packages</code> directory, use the following:</p>
    <pre class="programlisting con"><code class="hljs-con">$ pip3 list --user
</code></pre>
    <p class="normal">This list should be empty or <a id="_idIndexMarker1063"/>much shorter than the list of system packages.</p>
    <p class="normal">Go back to the example project from the last section. <code class="inlineCode">cd</code> into the parent <code class="inlineCode">follower</code> directory where <code class="inlineCode">setup.py</code> is located. Then run the following command:</p>
    <pre class="programlisting con"><code class="hljs-con">$ pip3 install --ignore-installed --user --break-system-packages .
</code></pre>
    <p class="normal"><code class="inlineCode">pip</code> will use <code class="inlineCode">setup.py</code> to fetch and install the packages declared by <code class="inlineCode">install_requires</code> to your <code class="inlineCode">site-packages</code> directory. The <code class="inlineCode">--user</code> option instructs <code class="inlineCode">pip</code> to install packages to your <code class="inlineCode">site-packages</code> directory rather than globally. The <code class="inlineCode">--ignore-installed</code> option forces <code class="inlineCode">pip</code> to re-install any required packages already present on the system to <code class="inlineCode">site-packages</code> so that no dependencies go missing. The <code class="inlineCode">--break-system-packages</code> option is required on Debian-based Linux distributions like Ubuntu, which discourages users from installing non-Debian-packaged packages system-wide.</p>
    <p class="normal">Now list all the packages in your <code class="inlineCode">site-packages</code> directory again:</p>
    <pre class="programlisting con"><code class="hljs-con">$ pip3 list --user
Package            Version
------------------ ---------
certifi            2025.1.31
charset-normalizer 3.4.1
follower           0.1
greenlet           3.1.1
idna               3.10
requests           2.32.3
SQLAlchemy         2.0.38
typing_extensions  4.12.2
urllib3            2.3.0
</code></pre>
    <p class="normal">This time, you should see that both <code class="inlineCode">requests</code> and <code class="inlineCode">SQLAlchemy</code> are in the package list.</p>
    <p class="normal">To view details on the <code class="inlineCode">SQLAlchemy</code> package you just installed, issue the following:</p>
    <pre class="programlisting con"><code class="hljs-con">$ pip3 show sqlalchemy
</code></pre>
    <p class="normal">The details shown contain the <code class="inlineCode">Requires</code> and <code class="inlineCode">Required-by</code> fields. Both are lists of related packages. You could use the values in these fields and successive calls to <code class="inlineCode">pip show</code> to trace the dependency tree of your project. But it’s probably easier to <code class="inlineCode">pip install</code> a command-line tool called <code class="inlineCode">pipdeptree</code> and use that instead.</p>
    <p class="normal">When a <code class="inlineCode">Required-by</code> field becomes empty, that is a good indicator that it is now safe to uninstall a package from your<a id="_idIndexMarker1064"/> system. If no other packages depend on the <a id="_idIndexMarker1065"/>packages in the deleted package’s <code class="inlineCode">Requires</code> field, then it’s safe to uninstall those as well. This is how you uninstall <code class="inlineCode">sqlalchemy</code> using <code class="inlineCode">pip</code>:</p>
    <pre class="programlisting con"><code class="hljs-con">$ pip3 uninstall sqlalchemy -y --break-system-packages
</code></pre>
    <p class="normal">The trailing <code class="inlineCode">-y</code> suppresses the confirmation prompt. To uninstall more than one package at a time, simply add more package names before the <code class="inlineCode">-y</code>. The <code class="inlineCode">--user</code> option is omitted here because <code class="inlineCode">pip</code> is smart enough to uninstall from <code class="inlineCode">site-packages</code> first when a package is also installed globally.</p>
    <div class="packt_tip">
      <p class="normal"><strong class="keyWord">TIP</strong></p>
      <p class="normal">Uninstall the <code class="inlineCode">follower</code> package and all its dependencies from your <code class="inlineCode">site-packages</code> directory so that you do not pollute your Python installation or Linux distribution with non-Debian-packaged packages.</p>
    </div>
    <p class="normal">Sometimes you need a package that serves some purpose or utilizes a particular technology, but you don’t know the name of it. You can use <code class="inlineCode">pip</code> to perform a keyword search against PyPI from the command line, but that approach often yields too many results. It is much easier to search for packages <a id="_idIndexMarker1066"/>on the PyPI website (<a href="https://pypi.org/search/"><span class="url">https://pypi.org/search/</span></a>), which allows you to filter results by various classifiers.</p>
    <h2 id="_idParaDest-429" class="heading-2"><a id="_idTextAnchor491"/>requirements.txt</h2>
    <p class="normal"><code class="inlineCode">pip</code> <code class="inlineCode">install</code> will install the latest published version of a package, but often you want to install a specific version of a package that you know works with your project’s code. Eventually, you will want to upgrade your project’s <a id="_idIndexMarker1067"/>dependencies. But before I show you <a id="_idIndexMarker1068"/>how to do that, I first need to show you how to use <code class="inlineCode">pip freeze</code> to fix your dependencies.</p>
    <p class="normal">Requirements files allow you to specify exactly which packages and versions <code class="inlineCode">pip</code> should install for your project. By convention, project <strong class="keyWord">requirements files</strong> are <a id="_idIndexMarker1069"/>always named <code class="inlineCode">requirements.txt</code>. The contents of a requirements file are just a list of <code class="inlineCode">pip install</code> arguments enumerating your project’s dependencies. These dependencies are precisely versioned so that there are no surprises when someone attempts to rebuild and deploy your project. It is good practice to add a <code class="inlineCode">requirements.txt</code> file to your project’s repo to ensure reproducible builds.</p>
    <p class="normal">Returning to our <code class="inlineCode">follower</code> project, now that we have installed all our dependencies and verified that the code works as expected, we are now ready to freeze the latest versions of the packages that <code class="inlineCode">pip</code> installed <a id="_idIndexMarker1070"/>for us. <code class="inlineCode">pip</code> has a <code class="inlineCode">freeze</code> command that outputs the installed packages along with their versions. You redirect the output from this command to a <code class="inlineCode">requirements.txt</code> file:</p>
    <pre class="programlisting con"><code class="hljs-con">$ pip3 freeze --user &gt; requirements.txt
</code></pre>
    <p class="normal">Now that you have a <code class="inlineCode">requirements.txt</code> file, people who clone your project can install all its dependencies using the <code class="inlineCode">-r</code> option and the name of the requirements file:</p>
    <pre class="programlisting con"><code class="hljs-con">$ pip3 install --user -r requirements.txt
</code></pre>
    <p class="normal">The autogenerated requirements<a id="_idIndexMarker1071"/> file format defaults to exact version matching (<code class="inlineCode">==</code>). For example, a line such as <code class="inlineCode">requests==2.32.3</code> tells <code class="inlineCode">pip</code> that the version of <code class="inlineCode">requests</code> to install must be exactly <code class="inlineCode">2.32.3</code>. There are other version specifiers you can utilize in a requirements file, such as minimum version (<code class="inlineCode">&gt;=</code>), version exclusion (<code class="inlineCode">!=</code>), and maximum version (<code class="inlineCode">&lt;=</code>). Minimum version (<code class="inlineCode">&gt;=</code>) matches any version greater than or equal to the right-hand side. Version exclusion (<code class="inlineCode">!=</code>) matches any version except the right-hand side. Maximum version (<code class="inlineCode">&lt;=</code>) matches any version less than or equal to the right-hand side.</p>
    <p class="normal">You can combine multiple version specifiers in a single line using commas to separate them:</p>
    <pre class="programlisting code"><code class="hljs-code">requests &gt;=<span class="hljs-number">2.32.3</span>,&lt;<span class="hljs-number">3.0</span>
</code></pre>
    <p class="normal">The default behavior when <code class="inlineCode">pip</code> installs the packages specified in a requirements file is to fetch them all from PyPI. You can <a id="_idIndexMarker1072"/>override PyPI’s URL (<a href="https://pypi.org/simple/)"><span class="url">https://pypi.org/simple/)</span></a> with that of an alternate Python package index by adding a line such as the following to the top of your <code class="inlineCode">requirements.txt</code> file:</p>
    <pre class="programlisting code"><code class="hljs-code">--index-url http://pypi.mydomain.com/mirror
</code></pre>
    <p class="normal">The effort required to stand up and maintain your own private PyPI mirror is not insubstantial. When all you need to do is fix a bug or add a feature to a project dependency, it makes more sense to override the package source instead of the entire package index.</p>
    <p class="normal">I mentioned earlier how<a id="_idIndexMarker1073"/> hardcoding distribution URLs inside <code class="inlineCode">setup.py</code> is wrong. You can use the <code class="inlineCode">-e</code> argument form in a requirements file to override individual package sources:</p>
    <pre class="programlisting code"><code class="hljs-code">-e git+https://github.com/myteam/flask.git#egg=flask
</code></pre>
    <p class="normal">In this example, I am<a id="_idIndexMarker1074"/> instructing <code class="inlineCode">pip</code> to fetch the <code class="inlineCode">flask</code> package sources from my team’s GitHub fork of <code class="inlineCode">pallets/flask.git</code>. The <code class="inlineCode">-e</code> argument form also takes a Git branch name, commit hash, or tag name:</p>
    <pre class="programlisting code"><code class="hljs-code">-e git+https://github.com/myteam/flask.git@master
-e git+https://github.com/myteam/flask.git@5142930ef57e2f0ada00248bdaeb95406d18eb7c
-e git+https://github.com/myteam/flask.git@v1.0
</code></pre>
    <p class="normal">Using <code class="inlineCode">pip</code> to upgrade a project’s dependencies to the latest versions published on PyPI is straightforward:</p>
    <pre class="programlisting con"><code class="hljs-con">pip3 install --user --upgrade -r requirements.txt
</code></pre>
    <p class="normal">After you have verified that installing the latest versions of your dependencies does not break your project, you can then write them back out to the requirements file:</p>
    <pre class="programlisting con"><code class="hljs-con">$ pip3 freeze --user &gt; requirements.txt
</code></pre>
    <p class="normal">Make sure that freezing did not overwrite any of the overrides or special version handling in your requirements file. Undo any mistakes and commit the updated <code class="inlineCode">requirements.txt</code> file to version control.</p>
    <p class="normal">At some point, upgrading your project dependencies will result in your code breaking. A new package release may introduce a regression or incompatibility with your project. The requirements file format provides syntax to deal with these situations. Let’s say you have been using version 2.32.3 of <code class="inlineCode">requests</code> in your project and version 3.0 is released. According to the practice of semantic versioning, incrementing the major version number indicates that version 3.0 of <code class="inlineCode">requests</code> includes breaking changes to that library’s API.</p>
    <p class="normal">You can express the new version requirements like this:</p>
    <pre class="programlisting code"><code class="hljs-code">requests ~= 2.32.3
</code></pre>
    <p class="normal">The compatible release specifier (<code class="inlineCode">~=</code>) relies on semantic versioning. Compatible means greater than or equal to the right-hand side and less than the next version’s major number (for example, <code class="inlineCode">&gt;= 1.1</code> and <code class="inlineCode">== 1.*</code>). You have already seen me express these same version requirements for <code class="inlineCode">requests</code> less ambiguously as follows:</p>
    <pre class="programlisting code"><code class="hljs-code">requests &gt;=2.32.3,&lt;3.0
</code></pre>
    <p class="normal">These <code class="inlineCode">pip</code> dependency management techniques work fine if you only develop a single Python project at a time. But chances are you use the same machine to work on several Python projects at once, each potentially requiring a different version of the Python interpreter. The biggest problem with using only <code class="inlineCode">pip</code> for multiple projects is that it installs all packages to the same user <code class="inlineCode">site-packages</code> directory for a particular version of Python. This makes it very hard to isolate dependencies from one project to the next.</p>
    <p class="normal">As we’ll see in the next chapter, <code class="inlineCode">pip</code> combines well with Docker for deploying Python applications. You can add <code class="inlineCode">pip</code> to a Buildroot or Yocto-based Linux image but that only enables quick on-device experimentation. A Python runtime package installer such as <code class="inlineCode">pip</code> is ill-suited for Buildroot and Yocto environments where you want to define the entire contents of your embedded Linux image at<a id="_idIndexMarker1075"/> build time. <code class="inlineCode">pip</code> works great inside containerized environments such as Docker where the line between build time and runtime is often blurry.</p>
    <p class="normal">In <a href="Chapter_05.xhtml#_idTextAnchor151"><em class="italic">Chapter 7</em></a>, you learned about the Python modules available to you in the <code class="inlineCode">meta-python</code> layer and how to define a custom layer for your own application. You can use the <code class="inlineCode">requirements.txt</code> files generated by <code class="inlineCode">pip freeze</code> to inform the selection of dependencies from <code class="inlineCode">meta-python</code> for your own layer recipes. Buildroot and Yocto both install Python packages in a system-wide manner, so the virtual environment techniques we are going to discuss next do not apply to embedded Linux builds per se. They do, however, help you assemble a complete list of dependencies for your embedded Python applications.</p>
    <h1 id="_idParaDest-430" class="heading-1"><a id="_idTextAnchor492"/>Managing Python virtual environments with venv</h1>
    <p class="normal">A <strong class="keyWord">virtual environment</strong> is a self-contained directory tree containing a Python interpreter for a particular version of Python, a <code class="inlineCode">pip</code> executable for managing project dependencies, and a local <code class="inlineCode">site-packages</code> directory. Switching <a id="_idIndexMarker1076"/>between virtual environments tricks <a id="_idIndexMarker1077"/>the shell into thinking that the only Python and <code class="inlineCode">pip</code> executables available are the ones present in the active virtual environment. Best practice dictates that you create a different virtual environment for each of your projects. This form of isolation solves the problem of two projects depending on different versions of the same package.</p>
    <p class="normal">Virtual environments are not new to Python. The system-wide nature of Python installations necessitates them. Besides enabling you to install different versions of the same package, virtual environments also provide an easy way for you to run multiple versions of the Python interpreter. Several options exist for managing Python virtual environments. A tool that was immensely popular circa 2019 (<code class="inlineCode">pipenv</code>) has since languished. The popular <code class="inlineCode">conda</code> package manager has supported Python virtual environments since late 2014. Meanwhile, Python 3’s built-in support for virtual environments (<code class="inlineCode">venv</code>) introduced back in 2012 has slowly matured and is now widely adopted.</p>
    <p class="normal"><strong class="keyWord">venv</strong> has been shipping with Python since version 3.3. Because it only comes bundled with Python 3 installations, <code class="inlineCode">venv</code> is incompatible with projects that require Python 2.7. As support for Python 2.7 officially ended on January 1, 2020, this Python 3 limitation is less of a concern. <code class="inlineCode">venv</code> is based on the popular <code class="inlineCode">virtualenv</code> tool, which is still maintained and available on PyPI. If you have one or more projects that still require Python 2.7, then you can use <code class="inlineCode">virtualenv</code> instead of <code class="inlineCode">venv</code> to work on those.</p>
    <p class="normal">By default, <code class="inlineCode">venv</code> installs the most <a id="_idIndexMarker1078"/>recent version of Python found on your system. If you have multiple versions of Python on your system, you can select a specific Python version by running <code class="inlineCode">python3</code> or whichever version you want when creating each virtual environment (<em class="italic">The Python Tutorial</em>, <a href="https://docs.python.org/3/tutorial/venv.html"><span class="url">https://docs.python.org/3/tutorial/venv.html</span></a>). Developing with the most recent version of Python is usually fine for greenfield projects but unacceptable for most legacy and enterprise software. We will use the version of Python 3 that came with your Ubuntu system to create and <a id="_idIndexMarker1079"/>work with a virtual environment.</p>
    <p class="normal">To create a virtual environment, first, decide where you want to put it, and then run the <code class="inlineCode">venv</code> module as a script with the target directory path:</p>
    <ol>
      <li class="numberedList" value="1">Ensure <code class="inlineCode">venv</code> is installed on your Ubuntu system:
        <pre class="programlisting con"><code class="hljs-con">$ sudo apt install python3-venv
</code></pre>
      </li>
      <li class="numberedList">Create a new directory for your project:
        <pre class="programlisting con"><code class="hljs-con">$ mkdir myproject
</code></pre>
      </li>
      <li class="numberedList">Switch to that new directory:
        <pre class="programlisting con"><code class="hljs-con">$ cd myproject
</code></pre>
      </li>
      <li class="numberedList">Create the virtual environment inside a subdirectory named <code class="inlineCode">venv</code>:
        <pre class="programlisting con"><code class="hljs-con">$ python3 -m venv ./venv
</code></pre>
      </li>
    </ol>
    <p class="normal">Now that you have created a virtual environment, here is how you activate and verify it:</p>
    <ol>
      <li class="numberedList" value="1">Switch to your project directory if you haven’t already:
        <pre class="programlisting con"><code class="hljs-con">$ cd myproject
</code></pre>
      </li>
      <li class="numberedList">Check where your system’s <code class="inlineCode">pip3</code> executable is installed:
        <pre class="programlisting con"><code class="hljs-con">$ which pip3
/usr/bin/pip3
</code></pre>
      </li>
      <li class="numberedList">Activate the project’s virtual environment:
        <pre class="programlisting con"><code class="hljs-con">$ source ./venv/bin/activate
</code></pre>
      </li>
      <li class="numberedList">Check where your project’s <code class="inlineCode">pip3</code> executable is installed:
        <pre class="programlisting con"><code class="hljs-con">(venv) $ which pip3
/home/frank/myproject/venv/bin/pip3
</code></pre>
      </li>
      <li class="numberedList">List the packages that came installed with the virtual environment:
        <pre class="programlisting con"><code class="hljs-con">(venv) $ pip3 list
Package Version
------- -------
pip     24.0
</code></pre>
      </li>
    </ol>
    <p class="normal">If you enter the <code class="inlineCode">which pip</code> command from within your virtual environment, you will see that <code class="inlineCode">pip</code> now points to an<a id="_idIndexMarker1080"/> executable. You can now omit the <code class="inlineCode">3</code> when running either <code class="inlineCode">pip</code> or <code class="inlineCode">python</code> from within your virtual environment.</p>
    <p class="normal">Next, let’s install a property-based testing<a id="_idIndexMarker1081"/> library named <code class="inlineCode">hypothesis</code> into our existing virtual environment:</p>
    <ol>
      <li class="numberedList" value="1">Switch to your project directory if you haven’t already:
        <pre class="programlisting con"><code class="hljs-con">$ cd myproject
</code></pre>
      </li>
      <li class="numberedList">Reactivate the project’s virtual environment if it is not already active:
        <pre class="programlisting con"><code class="hljs-con">$ source ./venv/bin/activate
</code></pre>
      </li>
      <li class="numberedList">Install the <code class="inlineCode">hypothesis</code> package:
        <pre class="programlisting con"><code class="hljs-con">(venv) $ pip install hypothesis
</code></pre>
      </li>
      <li class="numberedList">List the packages now installed inside the virtual environment:
        <pre class="programlisting con"><code class="hljs-con">(venv) $ pip list
Package          Version
---------------- -------
attrs            25.1.0
hypothesis       6.125.2
pip              24.0
sortedcontainers 2.4.0
</code></pre>
      </li>
    </ol>
    <p class="normal">Notice that two new packages (<code class="inlineCode">attrs</code> and <code class="inlineCode">sortedcontainers</code>) were added to the list besides <code class="inlineCode">hypothesis</code>. <code class="inlineCode">hypothesis</code> depends on these two packages. Let’s say you had another Python project that depended on version 1.5.10 instead of version 2.4.0 of <code class="inlineCode">sortedcontainers</code>. Those two versions would be<a id="_idIndexMarker1082"/> incompatible and thus conflict with each other. Virtual environments allow you to install both versions of the same package, a different version for each of the two projects.</p>
    <p class="normal">You may have noticed that switching out of a project directory does not deactivate its virtual environment. Don’t worry. Deactivating a virtual environment is as easy as this:</p>
    <pre class="programlisting con"><code class="hljs-con">(venv) $ deactivate
$
</code></pre>
    <p class="normal">This puts you back in the global system environment where you have to enter <code class="inlineCode">python3</code> and <code class="inlineCode">pip3</code> again. You have now seen everything you need to know to get started with Python virtual environments. Creating and <a id="_idIndexMarker1083"/>switching between virtual environments is common practice now when developing in Python. Isolated environments make it easier to keep track of and manage your dependencies across multiple projects.</p>
    <h1 id="_idParaDest-431" class="heading-1"><a id="_idTextAnchor493"/>Installing precompiled binaries with conda</h1>
    <p class="normal"><strong class="keyWord">conda</strong> is a package and virtual <a id="_idIndexMarker1084"/>environment management system used by<a id="_idIndexMarker1085"/> the <strong class="keyWord">Anaconda</strong> distribution of software for the PyData community. The Anaconda distribution includes Python as well as binaries for several hard-to-build open source projects such as PyTorch and TensorFlow. <code class="inlineCode">conda</code> can be installed without the full Anaconda distribution, which is very large, or the minimal <strong class="keyWord">Miniconda</strong> distribution, which<a id="_idIndexMarker1086"/> is still over 256 MB.</p>
    <p class="normal">Even though it was created for Python shortly after <code class="inlineCode">pip</code>, <code class="inlineCode">conda</code> has evolved into a general-purpose package manager like APT or Homebrew. Now, it can be used to package and distribute software for any language. Because <code class="inlineCode">conda</code> downloads precompiled binaries, installing Python extension modules is a breeze. Another one of <code class="inlineCode">conda</code>'s big selling points is that it is cross-platform, with full support for Linux, macOS, and Windows.</p>
    <p class="normal">Besides package management, <code class="inlineCode">conda</code> is also a full-blown virtual environment manager. <code class="inlineCode">conda</code> virtual environments have all the benefits we have come to expect from Python <code class="inlineCode">venv</code> environments and more. Like <code class="inlineCode">venv</code>, <code class="inlineCode">conda</code> lets you use <code class="inlineCode">pip</code> to install packages from PyPI into a project’s local <code class="inlineCode">site-packages</code> directory. If you prefer, you can use <code class="inlineCode">conda</code>'s own package management capabilities to install packages from different channels. Channels are package feeds provided by Anaconda and other software distributions.</p>
    <h2 id="_idParaDest-432" class="heading-2"><a id="_idTextAnchor494"/>Environment management</h2>
    <p class="normal">Unlike <code class="inlineCode">venv</code>, <code class="inlineCode">conda</code>'s virtual environment manager can easily juggle multiple versions of Python, including Python 2.7. You will need to<a id="_idIndexMarker1087"/> have Miniconda installed on your Ubuntu system to do the following exercises. You want to use Miniconda instead of Anaconda for your virtual environments because Anaconda environments come with lots of preinstalled packages, many of which you will never need. Miniconda environments are stripped down and allow you to easily install any of Anaconda’s packages should you have to.</p>
    <p class="normal">To install and update Miniconda on Ubuntu 24.04 LTS:</p>
    <ol>
      <li class="numberedList" value="1">Download Miniconda:
        <pre class="programlisting con"><code class="hljs-con">$ wget https://repo.anaconda.com/miniconda/Miniconda3-latest-Linux-x86_64.sh
</code></pre>
      </li>
      <li class="numberedList">Install Miniconda:
        <pre class="programlisting con"><code class="hljs-con">$ bash Miniconda3-latest-Linux-x86_64.sh
</code></pre>
      </li>
      <li class="numberedList">Update all the installed packages in the root environment:
        <pre class="programlisting con"><code class="hljs-con">(base) $ conda update --all
</code></pre>
      </li>
    </ol>
    <p class="normal">Your fresh Miniconda installation comes with <code class="inlineCode">conda</code> and a root environment with a Python interpreter and some basic packages installed. By default, the <code class="inlineCode">python</code> and <code class="inlineCode">pip</code> executables of <code class="inlineCode">conda</code>'s root environment <a id="_idIndexMarker1088"/>are installed in your home directory. The <code class="inlineCode">conda</code> root environment is known as <code class="inlineCode">base</code>. You can view its location, along with the locations of any other available <code class="inlineCode">conda</code> environments, by issuing the following command:</p>
    <pre class="programlisting con"><code class="hljs-con">(base) $ conda env list
</code></pre>
    <p class="normal">Verify this root environment before creating your own <code class="inlineCode">conda</code> environment:</p>
    <ol>
      <li class="numberedList" value="1">Open a new shell after installing Miniconda.</li>
      <li class="numberedList">Check where the root environment’s <code class="inlineCode">python</code> executable is installed:
        <pre class="programlisting con"><code class="hljs-con">(base) $ which python
</code></pre>
      </li>
      <li class="numberedList">Check the version of Python:
        <pre class="programlisting con"><code class="hljs-con">(base) $ python --version
</code></pre>
      </li>
      <li class="numberedList">Check where the root environment’s <code class="inlineCode">pip</code> executable is installed:
        <pre class="programlisting con"><code class="hljs-con">(base) $ which pip
</code></pre>
      </li>
      <li class="numberedList">Check the version of <code class="inlineCode">pip</code>:
        <pre class="programlisting con"><code class="hljs-con">(base) $ pip --version
</code></pre>
      </li>
      <li class="numberedList">List the packages installed in the root environment:
        <pre class="programlisting con"><code class="hljs-con">(base) $ conda list
</code></pre>
      </li>
    </ol>
    <p class="normal">Next, create and work with your own <code class="inlineCode">conda</code> environment named <code class="inlineCode">py311</code>:</p>
    <ol>
      <li class="numberedList" value="1">Create a new virtual environment named <code class="inlineCode">py311</code>:
        <pre class="programlisting con"><code class="hljs-con">(base) $ conda create --name py311 python=3.11.9
</code></pre>
      </li>
      <li class="numberedList">Activate your new virtual environment:
        <pre class="programlisting con"><code class="hljs-con">(base) $ source activate py311
</code></pre>
      </li>
      <li class="numberedList">Check where your environment’s <code class="inlineCode">python</code> executable is installed:
        <pre class="programlisting con"><code class="hljs-con">(py311) $ which python
</code></pre>
      </li>
      <li class="numberedList">Check that the version of Python is 3.11.9:
        <pre class="programlisting con"><code class="hljs-con">(py311) $ python --version
</code></pre>
      </li>
      <li class="numberedList">List the packages <a id="_idIndexMarker1089"/>installed in your environment:
        <pre class="programlisting con"><code class="hljs-con">(py311) $ conda list
</code></pre>
      </li>
      <li class="numberedList">Deactivate your environment:
        <pre class="programlisting con"><code class="hljs-con">(py311) $ conda deactivate
</code></pre>
      </li>
    </ol>
    <p class="normal">Using <code class="inlineCode">conda</code> to create a virtual environment with Python 2.7 installed is as simple as the following:</p>
    <pre class="programlisting con"><code class="hljs-con">(base) $ conda create --name py27 python=2.7.18
</code></pre>
    <p class="normal">View your <code class="inlineCode">conda</code> environments again to see whether <code class="inlineCode">py311</code> and <code class="inlineCode">py27</code> now appear in the list:</p>
    <pre class="programlisting con"><code class="hljs-con">(base) $ conda env list
</code></pre>
    <p class="normal">Lastly, let’s delete the <code class="inlineCode">py27</code> environment since we won’t be using it:</p>
    <pre class="programlisting con"><code class="hljs-con">(base) $ conda remove --name py27 --all
</code></pre>
    <p class="normal">Now that you know how to use <code class="inlineCode">conda</code> to manage virtual environments, let’s use it to manage packages within those environments.</p>
    <h2 id="_idParaDest-433" class="heading-2"><a id="_idTextAnchor495"/>Package management</h2>
    <p class="normal">Since <code class="inlineCode">conda</code> supports virtual <a id="_idIndexMarker1090"/>environments, we can use <code class="inlineCode">pip</code> to manage Python dependencies from one project to another in an isolated manner, just like we did with <code class="inlineCode">venv</code>. As a general-purpose package manager, <code class="inlineCode">conda</code> has its own facilities for managing dependencies. We know that <code class="inlineCode">conda list</code> lists all the packages that <code class="inlineCode">conda</code> has installed in the active virtual environment. I also mentioned <code class="inlineCode">conda</code>'s use of package feeds, which are called channels:</p>
    <ol>
      <li class="numberedList" value="1">You can get the list of channel URLs <code class="inlineCode">conda</code> is configured to fetch from by entering this command:
        <pre class="programlisting con"><code class="hljs-con">(base) $ conda info
</code></pre>
      </li>
      <li class="numberedList">Before proceeding any further, let’s reactivate the <code class="inlineCode">py311</code> virtual environment you created during the last exercise:
        <pre class="programlisting con"><code class="hljs-con">(base) $ source activate py311
(py311) $
</code></pre>
      </li>
      <li class="numberedList">Most Python development nowadays happens inside a Jupyter notebook, so let’s install those packages first:
        <pre class="programlisting con"><code class="hljs-con">(py311) $ conda install jupyter notebook
</code></pre>
      </li>
      <li class="numberedList">Enter <em class="italic">y</em> when prompted. This will install the <code class="inlineCode">jupyter</code> and <code class="inlineCode">notebook</code> packages along with all their dependencies. When you enter <code class="inlineCode">conda list</code>, you’ll see that the list of installed packages is much longer than before. Now, let’s install some more Python packages that we would need for a computer vision project:
        <pre class="programlisting con"><code class="hljs-con">(py311) $ conda install opencv matplotlib
</code></pre>
      </li>
      <li class="numberedList">Again, enter <em class="italic">y</em> when <a id="_idIndexMarker1091"/>prompted. This time, the number of dependencies installed is smaller. Both <code class="inlineCode">opencv</code> and <code class="inlineCode">matplotlib</code> depend on <code class="inlineCode">numpy</code>, so <code class="inlineCode">conda</code> installs that package automatically without you having to specify it. If you want to specify an older version of <code class="inlineCode">opencv</code>, you can install the desired version of the package this way:
        <pre class="programlisting con"><code class="hljs-con">(py311) $ conda install opencv=4.6.0
</code></pre>
      </li>
      <li class="numberedList"><code class="inlineCode">conda</code> will then attempt to <em class="italic">solve</em> the active environment for this dependency. Since no other packages installed in this active virtual environment depend on <code class="inlineCode">opencv</code>, the target version is easy to solve for. If they did, then you might encounter a package conflict and the reinstallation would fail. After solving, <code class="inlineCode">conda</code> will prompt you before downgrading <code class="inlineCode">opencv</code> and its dependencies. Enter <em class="italic">y</em> to downgrade <code class="inlineCode">opencv</code> to version 4.6.0.</li>
      <li class="numberedList">Now let’s say you change your mind or a newer version of <code class="inlineCode">opencv</code> is released that addresses your previous concern. This is how you would upgrade <code class="inlineCode">opencv</code> to the latest version provided by the Anaconda distribution:
        <pre class="programlisting con"><code class="hljs-con">(py311) $ conda update opencv
</code></pre>
      </li>
      <li class="numberedList">This time, <code class="inlineCode">conda</code> will prompt you to ask whether you want to update <code class="inlineCode">opencv</code> and its dependencies for the latest version. This time, enter <em class="italic">n</em> to cancel the package update. Instead of updating packages individually, it’s often easier to update all the packages installed in an active virtual environment at once:
        <pre class="programlisting con"><code class="hljs-con">(py311) $ conda update --all
</code></pre>
      </li>
      <li class="numberedList">Removing installed packages is also straightforward:
        <pre class="programlisting con"><code class="hljs-con">(py311) $ conda remove jupyter notebook
</code></pre>
      </li>
    </ol>
    <p class="normal">When <code class="inlineCode">conda</code> removes <code class="inlineCode">jupyter</code> and <code class="inlineCode">notebook</code>, it removes all of their dangling dependencies as well. A dangling dependency is an installed package that no other installed packages depend on. Like most <a id="_idIndexMarker1092"/>general-purpose package managers, <code class="inlineCode">conda</code> will not remove any dependencies that other installed packages still depend on.</p>
    <ol>
      <li class="numberedList" value="10">Sometimes you may not know the exact name of a package you want to install. Amazon offers an AWS SDK for Python called Boto. Like many Python libraries, there is a version of Boto for<a id="_idIndexMarker1093"/> Python 2 and a newer version (Boto3) for Python 3. To search Anaconda for packages with the word <code class="inlineCode">boto</code> in their names, enter the following command:
        <pre class="programlisting con"><code class="hljs-con">(py311) $ conda search '*boto*'
</code></pre>
      </li>
      <li class="numberedList">You should see <code class="inlineCode">boto3</code> and <code class="inlineCode">botocore</code> in the search results. At the time of writing, the most recent version of <code class="inlineCode">boto3</code> available on Anaconda is 1.36.3. To view details on that specific version of <code class="inlineCode">boto3</code>, enter the following command:
        <pre class="programlisting con"><code class="hljs-con">(py311) $ conda search boto3=1.36.3 --info
</code></pre>
      </li>
    </ol>
    <p class="normal">The package details reveal that <code class="inlineCode">boto3</code> version 1.36.3 depends on <code class="inlineCode">botocore</code> (<code class="inlineCode">botocore &gt;=1.36.3,&lt;1.37.0</code>), so installing <code class="inlineCode">boto3</code> gets you both.</p>
    <p class="normal">Now let’s say you’ve installed all the packages you need to develop an OpenCV project inside a Jupyter notebook. How do you share these project requirements with someone else so that they can recreate your work environment? The answer may surprise you:</p>
    <ol>
      <li class="numberedList" value="1">You export your active virtual environment to a YAML file:
        <pre class="programlisting con"><code class="hljs-con">(py311) $ conda env export &gt; my-environment.yaml
</code></pre>
      </li>
      <li class="numberedList">Much like the list of requirements that <code class="inlineCode">pip freeze</code> generates, the YAML that <code class="inlineCode">conda</code> exports is a list of all the packages installed in your virtual environment together with their pinned versions. Creating a <code class="inlineCode">conda</code> virtual environment from an environment file requires the <code class="inlineCode">-f</code> option and the filename:
        <pre class="programlisting con"><code class="hljs-con">$ conda env create -f my-environment.yaml
</code></pre>
      </li>
      <li class="numberedList">The environment name is included in the exported YAML, so no <code class="inlineCode">--name</code> option is necessary to create the environment. Whoever creates a virtual environment from <code class="inlineCode">my-environment.yaml</code> will now see <code class="inlineCode">py311</code> in their list of environments when they issue <code class="inlineCode">conda env list</code>.</li>
    </ol>
    <p class="normal"><code class="inlineCode">conda</code> is a very powerful tool in a developer’s arsenal. By combining general-purpose package installation with virtual environments, it offers a compelling deployment story. <code class="inlineCode">conda</code> achieves many of the same goals Docker (up next) does, but without the use of containers. It has an edge over Docker with<a id="_idIndexMarker1094"/> respect to Python due to its focus on the data science community. Because the leading ML frameworks (such as PyTorch and TensorFlow) are largely CUDA-based, finding GPU-accelerated binaries is often difficult. <code class="inlineCode">conda</code> solves this problem by providing multiple precompiled binary versions of packages.</p>
    <p class="normal">Exporting <code class="inlineCode">conda</code> virtual environments to YAML files for installation on other machines offers another deployment option. This solution is popular among the data science community, but it does not work in production for embedded Linux. <code class="inlineCode">conda</code> is not one of the three package managers that Yocto supports. Even if <code class="inlineCode">conda</code> was an option, the storage needed to accommodate Miniconda on a Linux image is not a good fit for most embedded systems due to resource constraints.</p>
    <p class="normal">If your dev board has an NVIDIA GPU such as the NVIDIA Jetson series, then you really want to use <code class="inlineCode">conda</code> for on-device development. Luckily, there is<a id="_idIndexMarker1095"/> a <code class="inlineCode">conda</code> installer named <strong class="keyWord">Miniforge</strong> (<a href="https://github.com/conda-forge/miniforge)"><span class="url">https://github.com/conda-forge/miniforge)</span></a> that is known to work on 64-bit ARM machines like the Jetsons. With <code class="inlineCode">conda</code> on the device, you can then install <code class="inlineCode">jupyter</code>, <code class="inlineCode">numpy</code>, <code class="inlineCode">pandas</code>, <code class="inlineCode">scikit-learn</code>, and most of the other popular Python data science libraries out there.</p>
    <h1 id="_idParaDest-434" class="heading-1"><a id="_idTextAnchor496"/>Summary</h1>
    <p class="normal">By now, you’re probably asking yourself, “What does any of this Python packaging stuff have to do with embedded Linux?” The answer is “not much” but bear in mind that the word <em class="italic">development</em> also happens to be in the title of this book, and this chapter has everything to do with modern-day software development. To succeed as a developer, you need to be able to deploy your code to production fast, frequently, and in a repeatable manner. That means managing your dependencies carefully and automating as much of the process as possible. You now know how to do that with Python.</p>
    <h1 id="_idParaDest-435" class="heading-1"><a id="_idTextAnchor497"/>Further study</h1>
    <ul>
      <li class="bulletList"><em class="italic">Python Packaging User Guide</em>, PyPA – <a href="https://packaging.python.org"><span class="url">https://packaging.python.org</span></a></li>
      <li class="bulletList"><em class="italic">setup.py vs requirements.txt</em>, by Donald Stufft – <a href="https://caremad.io/posts/2013/07/setup-vs-requirement"><span class="url">https://caremad.io/posts/2013/07/setup-vs-requirement</span></a></li>
      <li class="bulletList"><em class="italic">pip User Guide</em>, PyPA – <a href="https://pip.pypa.io/en/latest/user_guide/"><span class="url">https://pip.pypa.io/en/latest/user_guide/</span></a></li>
      <li class="bulletList"><em class="italic">Conda User Guide</em>, Anaconda, Inc. – <a href="https://docs.conda.io/projects/conda/en/latest/user-guide"><span class="url">https://docs.conda.io/projects/conda/en/latest/user-guide</span></a></li>
    </ul>
  </div>
</div></div></body></html>