- en: '*Chapter 14*: Using journald'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第14章*：使用 journald'
- en: In this chapter, we will turn our attention to a new way of logging. Although
    the `journald` logging system isn't part of systemd's `init` system, it is part
    of the `systemd` ecosystem. The `journald` system has its advantages over the
    old `rsyslog` system. However, there are also a couple of big reasons why we still
    haven't completed the transition to `journald`. Still, `journald` is an important
    tool that can help a busy Linux administrator easily see what's going on.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将关注一种新的日志记录方式。虽然 `journald` 日志系统不是 systemd 的 `init` 系统的一部分，但它是 `systemd` 生态系统的一部分。`journald`
    系统相较于旧的 `rsyslog` 系统有其优势。然而，仍有几个主要原因使得我们还没有完全过渡到 `journald`。尽管如此，`journald` 仍然是一个重要工具，可以帮助繁忙的
    Linux 管理员轻松查看系统发生了什么。
- en: 'Specific topics in this chapter include:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的具体主题包括：
- en: Understanding the pros and cons of `rsyslog`
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解 `rsyslog` 的优缺点
- en: Understanding the pros and cons of `journald`
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解 `journald` 的优缺点
- en: Understanding `journald` on Ubuntu
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解 Ubuntu 中的 `journald`
- en: Using `journalctl`
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `journalctl`
- en: Sealing `journald` log files for security
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 密封 `journald` 日志文件以确保安全
- en: Setting up remote logging with `journald`
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `journald` 设置远程日志记录
- en: Technical requirements
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: All you need for this chapter is your normal Ubuntu Server 20.04 and Alma Linux
    8 virtual machines. (You'll need both because `journald` is implemented differently
    on each.) Now, let's start by looking at the old `rsyslog`.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 本章所需的只是你正常的 Ubuntu Server 20.04 和 Alma Linux 8 虚拟机。（你需要这两者，因为 `journald` 在每个系统中的实现方式不同。）现在，我们先来看看旧版的
    `rsyslog`。
- en: 'Check out the following link to see the Code in Action video: [https://bit.ly/3dbJmJR](https://bit.ly/3dbJmJR)'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 查看以下链接以观看 Code in Action 视频：[https://bit.ly/3dbJmJR](https://bit.ly/3dbJmJR)
- en: Understanding the pros and cons of rsyslog
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解 `rsyslog` 的优缺点
- en: Fedora was the first Linux distro to come with `rsyslog` as its default logging
    system, way back in 2007\. It has quite a few improvements over the old syslog,
    and it eventually replaced syslog as the standard logging system on Linux, Unix,
    and Unix-like operating systems. Despite now having `journald`, `rsyslog` is still
    with us, as we'll see in just a bit.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: Fedora 是第一个将 `rsyslog` 作为默认日志系统的 Linux 发行版，早在 2007 年就推出了这一功能。它相比旧版 syslog 有不少改进，最终取代
    syslog 成为 Linux、Unix 及类 Unix 操作系统上的标准日志系统。尽管现在有了 `journald`，`rsyslog` 仍然在我们身边，正如我们接下来所看到的。
- en: One of the best features of `rsyslog` is also its biggest weakness. That is,
    it stores log files in plaintext format. That's great in a way because you can
    use your normal text search and viewing utilities to view the log files and find
    whatever information that you need to find. The less, head, tail, awk, and grep
    utilities are your friends when it comes to working with these plaintext log files.
    This also makes it very easy to write shell scripts to extract and parse information
    automatically.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: '`rsyslog` 的一个最佳特点也恰恰是它最大的弱点。也就是它以纯文本格式存储日志文件。从某种角度来说，这样很好，因为你可以使用常规的文本搜索和查看工具来查看日志文件，找到你需要的信息。less、head、tail、awk
    和 grep 工具都是你处理这些纯文本日志文件时的好帮手。这也使得编写 shell 脚本来自动提取和解析信息变得非常简单。'
- en: But there are a few problems with using plaintext log files. The first one is
    that plaintext files can become quite large and eventually consume a lot of disk
    space. To deal with this, Linux distros all come with the `logrotate` system,
    which automatically deletes all the log files except the ones for the previous
    four weeks. If you need to keep log files for longer than that, you'll need to
    either edit the `/etc/logrotate.conf` file or transfer the older log files to
    another location before `logrotate` automatically deletes them. This can also
    make it a bit awkward to find things. If you search through the current log file
    soon after a log rotation has taken place, you'll see that the file is mostly
    empty. Then, you'll have to search through the archive files to find what you
    need.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 但是使用纯文本日志文件还是存在一些问题。第一个问题是纯文本文件可能变得相当大，并最终消耗大量磁盘空间。为了解决这个问题，所有 Linux 发行版都配有
    `logrotate` 系统，它会自动删除所有日志文件，只保留过去四周的文件。如果你需要保留比这更长时间的日志文件，你就需要编辑 `/etc/logrotate.conf`
    文件，或者在 `logrotate` 自动删除它们之前将旧日志文件转移到其他地方。这也可能让查找变得有些尴尬。如果你在日志轮换发生后不久就搜索当前的日志文件，你会发现文件大部分是空的。然后，你就得通过归档文件查找你需要的内容。
- en: 'The second problem, according to the `journald` developers at least, is that
    there''s no built-in way to structure the view of `rsyslog` log files, as shown
    in the following snippet from the AlmaLinux messages file:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个问题，至少根据 `journald` 的开发者所说，是 `rsyslog` 日志文件没有内置的方式来结构化显示，如以下 AlmaLinux 消息文件中的片段所示：
- en: '[PRE0]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: You see here that every entry begins with the `journald` displays log data in
    `rsyslog`-compatible format. However, `journald` also includes an API that allows
    developers to define custom fields for log messages, and the `journalctl` utility
    allows you to view log data in many different ways.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 你会看到这里每一条日志条目都以 `journald` 以 `rsyslog` 兼容格式显示日志数据开始。然而，`journald` 还包括一个 API，允许开发者为日志消息定义自定义字段，`journalctl`
    工具则允许你以多种方式查看日志数据。
- en: Another argument against `rsyslog` is its security. Any hacker who breaks into
    your system and gains root privileges could easily alter plaintext log files to
    delete any record of his or her malicious deeds. The theory is that the binary
    log files that `journald` creates are harder for an attacker to alter. Is it impossible,
    though? Well, perhaps not, because a bit later we'll see how to verify if `journald`
    log files have been altered. Also, the `lastlog`, `utmp`, `wtmp`, and `btmp` binary
    log files have been in Linux for many years, and it is possible to alter them.
    It might be a bit harder, but not impossible.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 反对 `rsyslog` 的另一个论点是它的安全性。任何黑客如果突破系统并获得 root 权限，就可以轻松篡改纯文本日志文件，删除任何有关他或她恶意行为的记录。理论上，`journald`
    创建的二进制日志文件更难被攻击者篡改。不过，这不意味着不可能吗？嗯，也许不是，因为稍后我们将看到如何验证 `journald` 的日志文件是否被篡改。另外，`lastlog`、`utmp`、`wtmp`
    和 `btmp` 这些二进制日志文件在 Linux 中已经存在很多年，而且是可以被篡改的。可能稍微难一些，但并非不可能。
- en: The final problem with `rsyslog` is that there are no built-in search capabilities.
    Yeah, it's good that we can use tools such as awk, grep, and the built-in search
    function of less to search for text strings or text string patterns. But, wouldn't
    it be nice to have a built-in function that could make those searches a bit easier?
    As we'll soon see, we have that capability with `journald`.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: '`rsyslog` 的最终问题是没有内置的搜索功能。是的，能够使用像 awk、grep 和 less 的内建搜索功能来搜索文本字符串或文本字符串模式是很好的。但如果有一个内置的功能可以让这些搜索变得更容易，不是很好吗？正如我们很快将看到的，`journald`
    提供了这种能力。'
- en: Note
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 注
- en: 'I must mention that not everyone agrees that not having searching and formatting
    capabilities built into `rsyslog` is a problem. The `journald` developers *do*
    see it as a problem, of course. But, a lot of text manipulation and search utilities
    come installed on pretty much every Linux distro, and it''s not hard to use them.
    Even a shell-scripting beginner could easily whip up a script that would automate
    the process of finding and formatting pertinent information from plaintext log
    files. For example, several years ago, I wrote such a shell script to help out
    one of my buddies. (It was for Apache log files, but the principle still applies.)
    Anyway, you can check out the article that I wrote about it here:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 我必须提到，并不是每个人都认为 `rsyslog` 不具备搜索和格式化功能是一个问题。`journald` 的开发者们当然*认为*这是一个问题。但很多文本处理和搜索工具几乎在每个
    Linux 发行版上都已预装，使用起来也不难。即便是一个 shell 脚本初学者，也能轻松编写一个脚本，自动化从纯文本日志文件中查找和格式化相关信息的过程。例如，几年前，我写了一个这样的
    shell 脚本，帮助一个朋友。（它是用来处理 Apache 日志文件的，但原则上仍然适用。）无论如何，你可以在这里查看我写的相关文章：
- en: '[http://beginlinux.com/blog/2009/08/detect-cross-site-scripting-attacks-with-a-bash-shell-script/](http://beginlinux.com/blog/2009/08/detect-cross-site-scripting-attacks-with-a-bash-shell-script/).'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: '[http://beginlinux.com/blog/2009/08/detect-cross-site-scripting-attacks-with-a-bash-shell-script/](http://beginlinux.com/blog/2009/08/detect-cross-site-scripting-attacks-with-a-bash-shell-script/)。'
- en: (It says at the top that the article was posted by *Mike*, but if you scroll
    to the bottom, you'll see that I wrote it.)
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: （文章顶部写着是 *Mike* 发布的，但如果你向下滚动，你会看到是我写的。）
- en: Having said all this, I should also mention that some things are still a bit
    difficult to do with plaintext files, such as converting them into JSON format.
    As we'll see shortly, `journald` is much better for that.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 话虽如此，我还应该提到，有些事情仍然用纯文本文件处理起来有点困难，比如将它们转换为 JSON 格式。正如我们稍后将看到的那样，`journald` 在这方面要好得多。
- en: Another advantage of `rsyslog` is that it's extremely easy to set up a central
    `rsyslog` server that can receive log files from other machines on the network.
    Of course, configuring the server to separate the files from different machines
    into their own sets of log files is a bit awkward, but it isn't that complex once
    you know how to do it.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: '`rsyslog`的另一个优点是，非常容易设置一个中央的`rsyslog`服务器，可以从网络上的其他计算机接收日志文件。当然，配置服务器以将来自不同机器的文件分离到自己的日志文件集中有点麻烦，但是一旦你知道如何做，它并不复杂。'
- en: Understanding the pros and cons of journald
  id: totrans-27
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解`journald`的利弊
- en: In contrast to `rsyslog`, `journald` stores its log files in binary format.
    This allows us to store more data in a smaller amount of disk space, which reduces
    the need to constantly rotate the log files. Reducing the need for rotation allows
    us to keep log files for the long term, without having to worry about moving them
    elsewhere.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 与`rsyslog`相比，`journald`将其日志文件存储为二进制格式。这使我们能够在更小的磁盘空间中存储更多的数据，从而减少了不断轮换日志文件的需求。减少轮换需求使我们能够长期保留日志文件，而不必担心将其移动到其他位置。
- en: Using binary files also gives us an extra bit of security. It's harder for an
    attacker to alter binary files, and there's also a way to see if the files have
    been altered.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 使用二进制文件还可以增加一点安全性。攻击者更难改变二进制文件，并且还有一种方法可以查看文件是否被更改。
- en: The `journalctl` utility comes with built-in filtering and viewing functions.
    We can even view the log information in JSON format, which makes it easier to
    export log data into other log-parsing programs.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: '`journalctl`实用程序具有内置的过滤和查看功能。我们甚至可以以JSON格式查看日志信息，这样可以更轻松地将日志数据导出到其他日志解析程序中。'
- en: Yet another cool thing about `journald` is that it stores system log files and
    user log files separately. Each user has his or her own set of log files. A user
    with administrative privileges can view files for the system and all users, and
    a non-privileged user can just view his or her log files. With `rsyslog`, only
    users with administrator privileges can view any of these log files.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 关于`journald`的另一个很酷的事情是，它将系统日志文件和用户日志文件分开存储。每个用户都有自己的一套日志文件。具有管理员权限的用户可以查看系统和所有用户的文件，非特权用户只能查看自己的日志文件。而对于`rsyslog`，只有具有管理员权限的用户才能查看这些日志文件中的任何一个。
- en: Unfortunately, this cloud's silver lining does have a bit of tarnish. It is
    possible to set up a central log server that can receive `journald` logs from
    other machines, but this feature is still in development and isn't considered
    production-ready. So, because of that and the fact that most third-party log aggregation
    tools still expect to see plaintext `rsyslog` files, `rsyslog` is still with us,
    and likely will be with us for quite some time to come. At the time of this writing,
    I don't know of any Linux distros that have completely transitioned to `journald`.
    Every Linux distro that I know of runs both `journald` and `rsyslog` together.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，这片云的银边确实有点被玷污。可以设置一个中央日志服务器来接收来自其他机器的`journald`日志，但这个功能仍在开发中，尚未被视为生产就绪。因此，由于大多数第三方日志聚合工具仍然期望看到明文的`rsyslog`文件，`rsyslog`仍然存在，并且可能还会长期存在。在撰写本文时，我不知道任何已完全过渡到`journald`的Linux发行版。我所知道的每个Linux发行版都同时运行`journald`和`rsyslog`。
- en: Note
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: 'It''s just been pointed out to me that the Fedora team initially had Fedora
    21 running with nothing but `journald`. However, they received so many complaints
    about it that they had to do an update that brought back `rsyslog`. I didn''t
    know this, because I had abandoned Fedora quite a few years ago due to its instability
    issues. I didn''t start working with it again until Fedora 23, after the instability
    issues had gotten worked out. Anyway, you can read a bit more about this drama
    here:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 刚才有人指出，Fedora团队最初曾让Fedora 21只运行`journald`。然而，他们收到了很多关于此问题的投诉，因此他们进行了更新，重新引入了`rsyslog`。我不知道这一点，因为我几年前就因为其不稳定性问题而放弃了Fedora。直到Fedora
    23解决了不稳定性问题后，我才重新开始使用它。无论如何，你可以在这里详细了解一下这个事件的情况：
- en: '[https://www.linuxquestions.org/questions/linux-newbie-8/where-are-var-log-dmesg-and-var-log-messages-4175533513/](https://www.linuxquestions.org/questions/linux-newbie-8/where-are-var-log-dmesg-and-var-log-messages-4175533513/).'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://www.linuxquestions.org/questions/linux-newbie-8/where-are-var-log-dmesg-and-var-log-messages-4175533513/](https://www.linuxquestions.org/questions/linux-newbie-8/where-are-var-log-dmesg-and-var-log-messages-4175533513/).'
- en: However, there are differences between how the various distros do this. In the
    next section, we'll look at how Ubuntu does it.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，各个发行版在处理这个问题上存在差异。在下一节中，我们将看看Ubuntu是如何处理的。
- en: Understanding journald on Ubuntu
  id: totrans-37
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解Ubuntu上的journald
- en: On Ubuntu systems, the `journald` and `rsyslog` services are both enabled by
    default, and they both run as completely independent entities. The `journald`
    logs are persistent, which means that they are permanently stored on disk, instead
    of getting deleted every time you shut down the machine. The `rsyslog` log files
    are also present, and they get rotated every week.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 在Ubuntu系统上，`journald`和`rsyslog`服务默认都会启用，它们各自作为完全独立的实体运行。`journald`的日志是持久性的，这意味着它们会永久存储在磁盘上，而不是在每次关机时就被删除。`rsyslog`日志文件也会存在，并且每周都会进行轮换。
- en: 'Two things make the `journald` log files persistent. First, is the very first
    configuration option in the `/etc/systemd/journald.conf` file, which looks like
    this:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 有两件事让`journald`日志文件保持持久性。首先，是`/etc/systemd/journald.conf`文件中的第一个配置选项，内容如下：
- en: '[PRE1]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'When you look at this whole file, you''ll see that every line in it is commented
    out. This just means that all of these options have been set to their default
    values. To change something, just uncomment the line and change the value. However,
    we don''t need to do anything with this `#Storage=auto` line. The `auto` here
    means that if the `/var/log/journal/` directory exists, then `journald` will permanently
    store its log files there. If the `/var/log/journal/` directory doesn''t exist,
    a transient set of log files will be created in the `/run/log/journal/` directory
    every time you boot the machine. When you shut the machine down, these transient
    log files will be deleted. On Ubuntu machines, the `/var/log/journal/` directory
    is already there for you, which means that the log files are persistent. To show
    you how persistent the `journald` log files are, let''s take a quick look at what
    I have on the host machine that I''m using to write this. This machine is running
    `Lubuntu 18.04`, which is just Ubuntu with an alternate desktop environment. I''ll
    use the `journalctl` command without any options, like this:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 当你查看整个文件时，你会看到其中的每一行都被注释掉了。这仅仅意味着所有这些选项都被设置为默认值。如果要更改某些内容，只需取消注释该行并修改值即可。然而，我们不需要对`#Storage=auto`这一行做任何处理。这里的`auto`意味着，如果`/var/log/journal/`目录存在，`journald`就会将日志文件永久存储在那里。如果`/var/log/journal/`目录不存在，则会在每次启动机器时，在`/run/log/journal/`目录中创建一组临时日志文件。关机时，这些临时日志文件会被删除。在Ubuntu机器上，`/var/log/journal/`目录已经为你创建好，这意味着日志文件是持久性的。为了展示`journald`日志文件有多持久，我们来快速看看我用来写这篇文章的主机上有什么。这台机器运行的是`Lubuntu
    18.04`，这只是带有替代桌面环境的Ubuntu。我将使用没有任何选项的`journalctl`命令，像这样：
- en: '[PRE2]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Here, we can see that the logs begin in November 2018, which is almost three
    years ago. (I''m writing this in August 2021.) Surely, three years of logs would
    take up lots of disk space, right? Well, let''s use the `journalctl --disk-usage`
    command to find out:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们可以看到日志始于2018年11月，差不多是三年前的事了。（我写这篇文章时是2021年8月。）三年的日志肯定会占用大量磁盘空间，对吧？嗯，让我们用`journalctl
    --disk-usage`命令来查明：
- en: '[PRE3]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'So, three years'' worth of `journald` log files doesn''t even take up a whole
    GB of disk space. That''s a lot less space than what three years'' worth of `rsyslog`
    text files would require. To see the actual `journald` log files, go into the
    `/var/log/journal/` directory. There, you''ll see a directory with a rather long
    hexadecimal number as its directory name, like this:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，三年的`journald`日志文件甚至没有占用整整一个GB的磁盘空间。这比三年积累下来的`rsyslog`文本文件所需的空间要少得多。要查看实际的`journald`日志文件，可以进入`/var/log/journal/`目录。在那里，你会看到一个目录，目录名是一个相当长的十六进制数字，像这样：
- en: '[PRE4]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Within that directory, you''ll see the log files:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 在该目录下，你会看到日志文件：
- en: '[PRE5]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'We can use `wc -l` to easily count how many files there are, like this:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用`wc -l`命令来轻松统计文件数量，像这样：
- en: '[PRE6]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: So, there are 75 `journald` log files on this machine. That's because `journald`
    is configured to store information in lots of smaller files instead of storing
    everything in one big honkin' monolithic file.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，这台机器上有75个`journald`日志文件。原因是`journald`配置为将信息存储在多个较小的文件中，而不是将所有内容存储在一个庞大的文件中。
- en: Note
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: When those of us in the southern United States say that something is *big honkin'*,
    we mean that it's *really big*.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们南方人说某样东西是*big honkin'（超级大的）*时，我们的意思是它*真的很大*。
- en: The coolest part is that when you use `journalctl` to view the files, it will
    automatically open all of these files as necessary, instead of making you open
    each file with a separate command. (This is another huge advantage that `journald`
    has over `rsyslog`.)
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 最酷的部分是，当你使用`journalctl`查看日志文件时，它会根据需要自动打开所有这些文件，而不是让你通过单独的命令打开每个文件。（这是`journald`相较于`rsyslog`的另一个巨大优势。）
- en: If you ever do need to limit the amount of disk space that `journald` uses for
    log file storage, you can set the proper parameters in the `/etc/systemd/journald.conf`
    file. (See the `journald.conf` man page for details.) Also, the `journalctl` man
    page shows you how to rotate log files and then delete old archived log files
    with the `--vacuum-size=`, `--vacuum-time=`, and `--vacuum-files=` options. Let's
    look at an example of how to do that.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你确实需要限制`journald`用于日志文件存储的磁盘空间，可以在`/etc/systemd/journald.conf`文件中设置适当的参数。（有关详细信息，请参见`journald.conf`的手册页。）另外，`journalctl`的手册页告诉你如何旋转日志文件，并使用`--vacuum-size=`,
    `--vacuum-time=`, 和`--vacuum-files=`选项删除旧的归档日志文件。让我们来看一个如何操作的示例。
- en: 'First, shut down the virtual machine and take a snapshot of it. (You''ll need
    to have plenty of log files for the upcoming demos.) Then, restart the virtual
    machine and ensure that the persistent logs are up-to-date with the transient
    logs, like this:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，关闭虚拟机并为其拍摄快照。（你将需要大量日志文件来进行接下来的演示。）然后，重启虚拟机并确保持久化日志与瞬态日志是同步的，像这样：
- en: '[PRE7]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Next, combine the `--rotate` and `--vacuum-time` options to archive the current
    log files, create new empty log files, and delete all the archived log files that
    are older than five days, like this:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，结合使用`--rotate`和`--vacuum-time`选项，将当前日志文件归档，创建新的空日志文件，并删除所有超过五天的旧归档日志文件，像这样：
- en: '[PRE8]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Finally, shut down the virtual machine, restore from the snapshot, and restart
    the virtual machine.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，关闭虚拟机，恢复快照，并重启虚拟机。
- en: Note
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: If you don't want your Ubuntu machine to persistently store `journald` log files,
    either delete the `/var/log/journal/` directory or go into the `/etc/systemd/journald.conf`
    file and change the `#Storage=auto` line to `Storage=volatile`.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你不希望你的Ubuntu机器持久存储`journald`日志文件，可以删除`/var/log/journal/`目录，或者进入`/etc/systemd/journald.conf`文件，将`#Storage=auto`行改为`Storage=volatile`。
- en: The final thing I want to mention about Ubuntu is that when you install the
    operating system, the user that gets created by the installer is a member of both
    the `sudo` and `adm` groups. Members of the `sudo` group have full `sudo` privileges,
    as you probably already know. On most other distros, you'd need to use `sudo`
    to view system log files. On Ubuntu machines, members of the `adm` group can view
    all `rsyslog` or `journald` logs without `sudo` privileges.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 关于Ubuntu，我最后想提到的是，当你安装操作系统时，安装程序创建的用户会同时成为`sudo`和`adm`组的成员。你可能已经知道，`sudo`组的成员拥有完全的`sudo`权限。在大多数其他发行版中，你需要使用`sudo`来查看系统日志文件。而在Ubuntu机器上，`adm`组的成员可以在没有`sudo`权限的情况下查看所有`rsyslog`或`journald`日志。
- en: Okay, that does it for `journald` on Ubuntu. Now, let's move on and look at
    `journald` on RHEL-type systems.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，关于Ubuntu上的`journald`就讲到这里。现在，我们继续来看RHEL类型系统上的`journald`。
- en: Understanding journald on RHEL-type systems
  id: totrans-65
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解RHEL类型系统上的journald
- en: 'There are a few big differences in how things are done in the Red Hat world.
    First, on your AlmaLinux machine, you''ll see that there is no `/var/log/journal/`
    directory, which means that `journald` log files will only be created in the `/run/log/journal/`
    directory and will disappear every time you shut down or reboot the machine. If
    you want to change that, all you have to do is create that journal subdirectory,
    like this:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 在Red Hat世界中，操作方式有一些显著的差异。首先，在你的AlmaLinux机器上，你会发现没有`/var/log/journal/`目录，这意味着`journald`日志文件只会在`/run/log/journal/`目录下创建，并且每次关闭或重启机器时都会消失。如果你想改变这一点，只需创建该日志子目录，像这样：
- en: '[PRE9]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: You'll immediately see that the `journald` log files are now persistent.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 你会立即看到，`journald`日志文件现在变成持久存储了。
- en: Note
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Before you make the `journald` log files persistent on a production machine,
    evaluate whether or not you need to.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 在将`journald`日志文件设置为生产机器上的持久存储之前，评估是否真的需要这样做。
- en: 'The other big difference is that on RHEL-type systems, `journald` and `rsyslog`
    work together, instead of independently. Instead of having both `journald` and
    `rsyslog` gather information from the rest of the operating system, only `journald`
    does. Then, `rsyslog` obtains the information from `journald` and stores it in
    the normal `rsyslog` text files. We can see how that''s enabled in the top portion
    of the `/etc/rsyslog.conf` file:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个重大区别是，在 RHEL 类型的系统上，`journald` 和 `rsyslog` 是协同工作的，而不是独立工作的。不是同时由 `journald`
    和 `rsyslog` 收集来自操作系统其余部分的信息，而是只有 `journald` 在做这件事。然后，`rsyslog` 从 `journald` 获取信息并将其存储在正常的
    `rsyslog` 文本文件中。我们可以看到在 `/etc/rsyslog.conf` 文件的顶部部分是如何启用这一功能的：
- en: '[PRE10]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Unlike the old `syslog` service that `rsyslog` replaced, you can extend the
    capabilities of `rsyslog` by adding new modules to it. Here, we can see the `imjournal`
    module, that allows `rsyslog` to receive data from the `journald` service. So,
    on RHEL 8-type machines, `journald` gathers the data from the rest of the system
    and passes it to `rsyslog`.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 与旧版的 `syslog` 服务（被 `rsyslog` 替代）不同，你可以通过添加新模块来扩展 `rsyslog` 的功能。在这里，我们可以看到 `imjournal`
    模块，它使得 `rsyslog` 能够从 `journald` 服务接收数据。所以，在 RHEL 8 类型的机器上，`journald` 收集来自整个系统的数据并将其传递给
    `rsyslog`。
- en: The final big difference is that on RHEL-type systems, you'll need the proper
    `sudo` privileges to view all of the log files. The `adm` group is there, but
    adding yourself to it doesn't do anything for you.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 最终的一个重大区别是，在 RHEL 类型的系统上，你需要适当的 `sudo` 权限才能查看所有的日志文件。虽然有 `adm` 组，但将自己添加到该组并不会对你有任何帮助。
- en: Now that we've seen the differences between how `journald` is set up on Ubuntu
    and RHEL, let's look at how to use `journalctl`, which works the same across all
    distros.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经了解了 Ubuntu 和 RHEL 上 `journald` 配置的差异，接下来我们来看一下如何使用 `journalctl`，它在所有发行版中都相同。
- en: Using journalctl
  id: totrans-76
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 journalctl
- en: The `journalctl` utility is cool because it has so much flexibility. Let's start
    by looking at the various ways to search for and display log data. We'll do this
    on the Ubuntu machine because Ubuntu's persistent `journald` logs will give us
    more to look at.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: '`journalctl` 工具非常有用，因为它具有很大的灵活性。让我们首先看看如何搜索和显示日志数据。我们将在 Ubuntu 机器上进行演示，因为 Ubuntu
    的持久 `journald` 日志能提供更多内容供我们查看。'
- en: Searching for and viewing log data with journalctl
  id: totrans-78
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 journalctl 搜索和查看日志数据
- en: 'The simplest command for viewing log files is just `journalctl`. As we see
    here, this will show you pretty much the same information that you''d see when
    you open a normal `rsyslog` file in `less`. You''ll also see that the `journalctl`
    output is automatically piped into `less`:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 查看日志文件的最简单命令就是 `journalctl`。正如我们所看到的，它会显示你在打开普通的 `rsyslog` 文件时通过 `less` 查看时几乎相同的信息。你还会看到
    `journalctl` 的输出会自动传递到 `less` 中：
- en: '[PRE11]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: A big difference from what you're used to with `rsyslog` is that long lines
    don't wrap around. Instead, they extend beyond the right-hand side of the visible
    window. To see the rest of these lines, you'll need to use the right cursor key.
    Other than that, you can use the same search and navigation commands that you'd
    normally use with the `less` utility. For example, to go directly to the bottom
    of the `journalctl` output, just use the *Shift* + *G* key combination. (Be patient,
    though, because `journalctl` has to read through all of those files that I showed
    you earlier, which takes a while.) To go to a specific line, just enter the line
    number followed by the lowercase `g`. To search for a text string, hit the `/`
    key and enter the search term. When you're done, just hit the *Q* key to quit.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 与你习惯使用的 `rsyslog` 不同的一个大区别是，长行不会换行显示。相反，它们会超出可视窗口的右侧。要查看这些行的其余部分，你需要使用右方向键。除此之外，你可以使用通常在
    `less` 工具中使用的搜索和导航命令。例如，要直接跳转到 `journalctl` 输出的底部，只需按下 *Shift* + *G* 键组合。（不过，要有耐心，因为
    `journalctl` 需要读取我之前展示过的所有文件，这需要一些时间。）要跳转到特定的行，只需输入行号后跟小写的 `g`。要搜索文本字符串，按 `/`
    键并输入搜索词。完成后，只需按 *Q* 键退出。
- en: Note
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: I should point out that since I'm using the Ubuntu virtual machine for this,
    where I'm a member of the `adm` group, I don't need `sudo` privileges to view
    all system logs. If you decide to try this on the AlmaLinux machine, you'll need
    to use `sudo`. Otherwise, you'll only see your user logs.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 我应该指出，由于我正在使用 Ubuntu 虚拟机，在其中我已经是 `adm` 组的成员，所以不需要 `sudo` 权限就能查看所有系统日志。如果你决定在
    AlmaLinux 机器上尝试，你需要使用 `sudo`。否则，你只能看到你的用户日志。
- en: If you look at the `journalctl` man page, you'll see a wide selection of display
    and search options. I can't demonstrate all of them to you, but we can look at
    a few examples.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你查看 `journalctl` 的手册页，你会看到很多显示和搜索选项。我无法向你展示所有的选项，但我们可以看一些示例。
- en: 'On a machine with persistent `journald` log files, you might just want to see
    the log entries from the current boot-up session. Now, to make this work, reboot
    your machine a few times so that you''ll have more to see. Then, use `journalctl
    -b`, like this:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 在一台具有持久 `journald` 日志文件的机器上，你可能只想查看当前启动会话的日志条目。为了让它生效，重启你的机器几次，这样你就有更多日志可供查看。然后，使用
    `journalctl -b`，像这样：
- en: '[PRE12]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Here, you can see that the logs began in January 2021, but the first entry
    it shows here is for the current date of August 10 at 2:20 P.M., which is when
    I last booted this virtual machine. To see the log entries from the previous boot-up
    session, just add a `-1`, like this:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，你可以看到日志始于 2021 年 1 月，但它显示的第一个条目是当前日期 8 月 10 日下午 2:20，即我最后一次启动虚拟机时的时间。要查看上一次启动会话的日志条目，只需添加
    `-1`，像这样：
- en: '[PRE13]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: So, it looks like I had booted this machine earlier today, at 1:36 P.M. You
    can also view files from earlier boot-up sessions by specifying a different number.
    For example, you can use `-2` to display files from two boot-up sessions ago,
    `-10` to show files from 10 boot-up sessions ago, and so on.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，看起来我今天下午 1:36 已经启动过这台机器。你也可以通过指定不同的数字来查看早期启动会话的文件。例如，你可以使用 `-2` 显示两次启动会话前的文件，使用
    `-10` 显示 10 次启动会话前的文件，依此类推。
- en: 'To see a list of all bootups, use the `--list-boots` option:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看所有启动的列表，使用 `--list-boots` 选项：
- en: '[PRE14]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: It looks like I've booted this virtual machine 47 times since I've created it.
    The long hexadecimal number you can see in the second field is the ID number of
    the boot-up session.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 看起来自从我创建这台虚拟机以来，我已经启动了 47 次。你在第二个字段中看到的长十六进制数字是启动会话的 ID 号。
- en: 'The `-g` option allows you to grep for either specific text strings or Perl-compatible
    regular expressions. If your search term consists only of lowercase letters, then
    the search will be case-insensitive. If the search term includes any uppercase
    letters, then the search is case-sensitive. For example, using `journalctl -g
    fail` shows you all the entries that contain some form of *fail*, regardless of
    whether *fail* contains lowercase, uppercase, or both upper and lowercase letters.
    But if you use `journalctl -g Fail`, you''ll only see entries that contain the
    specific specific string, `Fail`. If your search term consists of only lowercase
    letters and you want to make the search case-sensitive, just use the `--case-sensitive=`
    option, like this:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: '`-g` 选项允许你使用 grep 查找特定的文本字符串或 Perl 兼容的正则表达式。如果你的搜索词仅包含小写字母，则搜索将不区分大小写。如果搜索词包含任何大写字母，则搜索是区分大小写的。例如，使用
    `journalctl -g fail` 将显示所有包含某种形式的*fail*的条目，无论 *fail* 是小写、大写还是大小写混合。但如果你使用 `journalctl
    -g Fail`，你只会看到包含具体字符串 `Fail` 的条目。如果你的搜索词仅包含小写字母，而你想使搜索区分大小写，只需使用 `--case-sensitive=`
    选项，像这样：'
- en: '[PRE15]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'The priority levels for `journald` log messages are the same as for the `ryslog`
    log messages. The only difference is that you can now use either the name or the
    number of the priority level in your searches. In order of descending importance,
    the priority levels are:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: '`journald` 日志消息的优先级等级与 `ryslog` 日志消息相同。唯一的区别是你现在可以在搜索中使用优先级的名称或数字。按重要性降序排列，优先级等级如下：'
- en: '`0` or `emerg`: This is the emergency level, for things such as kernel panics.
    (Hopefully, you''ll rarely ever see these.)'
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`0` 或 `emerg`：这是紧急级别，用于处理像内核崩溃之类的情况。（希望你很少会看到这些。）'
- en: '`1` or `alert`: These aren''t quite an emergency, but they''re still bad news.'
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`1` 或 `alert`：这些不算紧急，但依然是不好的消息。'
- en: '`2` or `crit`: Don''t be too surprised if you see some critical messages. These
    can be caused by something as simple as a user fumble-fingering his or her password.
    They could also be caused by someone trying to brute-force a password, so it''s
    worth your while to pay attention to these.'
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`2` 或 `crit`：如果你看到一些关键消息，不要太惊讶。这些可能是由于用户输入密码时犯了小错误造成的。也可能是有人试图暴力破解密码，所以值得留意这些信息。'
- en: '`3` or `err`: These could be caused by a service that fails to start, a program
    that runs out of memory, problems with accessing a hardware device, and so forth.'
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`3` 或 `err`：这些可能是由无法启动的服务、内存不足的程序、无法访问硬件设备等问题引起的。'
- en: '`4` or `warning`: You''ll see lots of these, but most are nothing to worry
    about. Normally, most of them will be kernel messages from when you boot up the
    machine.'
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`4` 或 `warning`：你会看到很多这样的消息，但大多数不用担心。通常，它们大多数是从启动计算机时生成的内核消息。'
- en: '`5` or `notice`: These don''t constitute an emergency, but you still want to
    take *notice* of them. (See what I did there?)'
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`5` 或 `notice`：这些不属于紧急消息，但你仍然需要*注意*它们。（看看我这么说的意思了吗？）'
- en: '`6` or `info`: Most log messages you see should be of the `info` level.'
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`6` 或 `info`：你看到的大多数日志消息应该是 `info` 级别的。'
- en: '`7` or `debug`: This is is the lowest priority. It''s not enabled by default
    on `rsyslog`, but it is on `journald`.'
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`7` 或 `debug`：这是最低的优先级。默认情况下，`rsyslog` 上没有启用，但 `journald` 上启用了。'
- en: 'Now, let''s say that you want to only see the `emerg` (emergency) messages.
    Use the `-p` option with either the number or the name of the priority level,
    like this:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，假设你只想查看 `emerg`（紧急）消息。使用 `-p` 选项，后面跟优先级的数字或名称，如下所示：
- en: '[PRE16]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'So, there are no emergency messages, which is a good thing. What about `alert`
    messages? Let''s see:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，没有紧急消息，这是一件好事。那么 `alert` 消息呢？我们来看一下：
- en: '[PRE17]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Cool. There are none of them, either. But from priority level `2` (`crit`)
    on down, it''s a different story, as we see here:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 很好。也没有这些。但是从优先级 `2`（`crit`）开始往下的情况就不一样了，正如我们在这里看到的：
- en: '[PRE18]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'So, there are a few `critical` messages. Now, things get a bit trickier. It''s
    just that when you specify a priority level, you''ll see messages from that priority
    up through all of the upper priorities that also have messages. So, if I were
    to specify level `3` (`err`) right now, I''d also see the level `2` (`crit`) messages.
    To see nothing but level `3` messages, specify a range with level `3` as both
    the starting point and the ending point, like this:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，存在一些 `critical` 消息。现在，事情变得有些复杂。因为当你指定一个优先级时，你会看到从该优先级到所有较高优先级的消息。所以，如果我现在指定等级
    `3`（`err`），我也会看到等级 `2`（`crit`）的消息。如果只想看到等级 `3` 的消息，请指定一个范围，将等级 `3` 作为起点和终点，如下所示：
- en: '[PRE19]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Curiously, the `journalctl` man page tells you that you can specify ranges,
    but it doesn't tell you that you have to use two dots for it. I had to do a DuckDuckGo
    search to find out.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 奇怪的是，`journalctl` 的手册页告诉你可以指定范围，但它并没有告诉你必须使用两个点。为了搞明白这点，我不得不进行一次 DuckDuckGo
    搜索。
- en: 'Another carryover from `rsyslog` is the concept of *facilities*. Different
    Linux subsystems create different types, or facilities, of messages. The standard
    facilities are:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个来自 `rsyslog` 的概念是 *设施*。不同的 Linux 子系统生成不同类型的消息或设施。标准的设施有：
- en: '`auth`: Messages generated by the authorization system, login, `su`, and so
    on.'
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`auth`：由授权系统、登录、`su` 等生成的消息。'
- en: '`authpriv`: Messages generated by the authorization system but only readable
    by selected users.'
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`authpriv`：由授权系统生成的消息，但仅限选定用户可读。'
- en: '`cron`: Messages generated by the cron service.'
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`cron`：由 cron 服务生成的消息。'
- en: '`daemon`: Messages generated by all system daemons (`sshd`, `ftpd`, and so
    on),'
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`daemon`：由所有系统守护进程（如 `sshd`、`ftpd` 等）生成的消息。'
- en: '`ftp`: Messages generated by a **File Transfer Protocol** (**FTP**) service.'
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ftp`：由**文件传输协议**（**FTP**）服务生成的消息。'
- en: '`kern`: Messages generated by the Linux kernel.'
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`kern`：由 Linux 内核生成的消息。'
- en: '`lpr`: Messages generated by the line printer spooling.'
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`lpr`：由行打印机排队系统生成的消息。'
- en: '`mail`: Messages generated by the operating system''s internal mail system.'
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`mail`：由操作系统的内部邮件系统生成的消息。'
- en: '`mark`: These are periodic timestamps that can be inserted into the logs.'
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`mark`：这些是可以插入到日志中的周期性时间戳。'
- en: '`news`: This facility deals with messages from Usenet newsgroup services, which
    have pretty much died off. So, you''ll likely never see any of these messages.'
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`news`：这个功能处理来自 Usenet 新闻组服务的消息，这些服务也几乎已经消失了。所以，你很可能永远也看不到这些消息。'
- en: '`syslog`: Messages that are generated by rsyslog.'
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`syslog`：由 rsyslog 生成的消息。'
- en: '`user`: Messages generated by users.'
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`user`：由用户生成的消息。'
- en: '`uucp`: Messages from the Unix-to-Unix copy system. This system also has pretty
    much died off, so you''ll likely never see any of these messages, either.'
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`uucp`：来自 Unix 到 Unix 复制系统的消息。这个系统基本上已经废弃了，因此你可能永远看不到这些消息。'
- en: '`local0` through `local7`: You can use these to define custom facilities.'
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`local0` 到 `local7`：你可以使用这些来定义自定义设施。'
- en: 'To see messages from one specific facility, use the `--facility` option, like
    this:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看来自特定设施的消息，请使用 `--facility` 选项，如下所示：
- en: '[PRE20]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Okay, I did tell you that there would likely be no `uucp` messages. For a more
    realistic example, let''s look at `auth` and `authpriv` messages, and compare
    the difference between them:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，我确实告诉过你，可能没有`uucp`消息。为了一个更现实的示例，我们来看看`auth`和`authpriv`消息，并比较它们之间的差异：
- en: '[PRE21]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'For our final example, let''s get fancy. Let''s look at priority `4` `daemon`
    messages that have come up since yesterday:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们的最后一个示例，让我们做得更花哨一些。让我们查看自昨天以来优先级为`4`的`daemon`消息：
- en: '[PRE22]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: All right, that about covers it for priorities and facilities.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，关于优先级和设施部分就讲到这里。
- en: Note
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: 'To see a list of all of the available facilities, just do:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看所有可用设施的列表，只需执行：
- en: '**journalctl --facility=help**'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: '**journalctl --facility=help**'
- en: 'You can also view log entries for a certain user. To do that, you must obtain
    the user''s UID, like this:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以查看某个用户的日志条目。为此，你需要获取该用户的 UID，像这样：
- en: '[PRE23]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'So, Frank''s UID is `1002`. Now, let''s view his log entries:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，Frank 的 UID 是`1002`。现在，我们来看一下他的日志条目：
- en: '[PRE24]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Okay, that''s good. But all I want to see is his log entries for today. I can
    use either the `-S` or `--since` option for this:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，没问题。但我只想查看他今天的日志条目。我可以使用`-S`或`--since`选项来做到这一点：
- en: '[PRE25]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Okay, Frank hasn't logged in today, which isn't surprising. Remember that Frank
    is a cat, which means that he spends most of his time sleeping.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 好吧，Frank 今天没有登录，这也不奇怪。记住，Frank 是一只猫，这意味着他大部分时间都在睡觉。
- en: 'Now, let''s say that you want to view information about the Apache web server
    service, but you want to see it in JSON format. All right, let''s do this:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，假设你想查看关于 Apache Web 服务器服务的信息，但你想以 JSON 格式查看。好吧，我们来做这个：
- en: '[PRE26]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Is this output not pretty enough for you? No problem; we can make it pretty:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 这个输出不够美观吗？没问题，我们可以让它更美观：
- en: '[PRE27]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Note that more data fields show up in JSON format than in the standard default
    format. That's because the default output format for `journalctl` is meant to
    emulate the standard `rsyslog` format.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，JSON 格式中显示的字段比标准默认格式中更多。这是因为`journalctl`的默认输出格式旨在模拟标准的`rsyslog`格式。
- en: 'Now, let''s say that you just want to see Apache information from yesterday,
    and you want to save it to a JSON file and view the output on the screen at the
    same time. The `--no-pager` option allows you to pipe the `journalctl` output
    into another utility, as we''re doing here with the tee utility:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，假设你只想查看昨天的 Apache 信息，并且你希望将其保存为 JSON 文件，并同时在屏幕上查看输出。`--no-pager`选项允许你将`journalctl`的输出管道传输到另一个实用程序，就像我们在这里用
    tee 实用程序所做的那样：
- en: '[PRE28]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: You can also use `--no-pager` to pipe output into the standard Linux text filtering
    and manipulation utilities, such as grep or awk. This can be handy if you need
    to write shell scripts for use in Nagios or Icinga plugins, for example.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以使用`--no-pager`将输出传送到标准的 Linux 文本过滤和处理工具，例如 grep 或 awk。如果你需要编写用于 Nagios 或
    Icinga 插件的 shell 脚本，这会很有用。
- en: I could give you a lot more examples, but you get the idea. Besides, this is
    one of those rare instances in the world of free-as-in-speech software where the
    documentation that other people have written is so good that I can't improve upon
    their efforts. So, if you want to see more, I'll direct your attention to the
    `journalctl` man page and the resources in the *Further reading* section.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 我可以给你更多的示例，但你应该已经明白了。再说，这也是自由软件世界中少数几个可以直接使用其他人编写的文档而无需改进的情况之一。所以，如果你想查看更多内容，我会把你引导到`journalctl`的手册页和*进一步阅读*部分的资源。
- en: Sealing journald log files for security
  id: totrans-154
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为了安全封印journald日志文件
- en: I've already told you how easy it is for a malicious person to tamper with the
    text-mode `rsyslog` files to delete his or her nefarious activities. The `journald`
    log files are already harder to tamper with because they're in binary format.
    We can make it even harder to tamper with them by *sealing* them. (Of course,
    this only works if you have persistent `journald` logs.)
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 我已经告诉你，恶意人员篡改文本模式下的`rsyslog`文件以删除他们的恶意活动是多么容易。而`journald`日志文件因为是二进制格式，已经更难篡改。通过*封印*它们，我们可以让篡改变得更加困难。（当然，前提是你有持久的`journald`日志。）
- en: 'The first step is to create a set of **Forward Secure Sealing** (**FSS**) keys,
    like this:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 第一步是创建一组**前向安全封印**（**FSS**）密钥，像这样：
- en: '[PRE29]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'This command creates two keys. The *sealing key* is named `fss` and is stored
    in the same directory as the `journald` log files, as we see here:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 此命令创建了两个密钥。*封印密钥*名为`fss`，并存储在与`journald`日志文件相同的目录中，如下所示：
- en: '[PRE30]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'The verification key only appears as a text string on your screen, as we see
    here:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 验证密钥仅以文本字符串的形式显示在你的屏幕上，如下所示：
- en: '![](img/Figure_14.1_B17491.jpg)'
  id: totrans-161
  prefs: []
  type: TYPE_IMG
  zh: '![](img/Figure_14.1_B17491.jpg)'
- en: Figure 14.1 – Creating the Forward Secure Sealing (FSS) keys
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: Figure 14.1 – Creating the Forward Secure Sealing (FSS) keys
- en: It says to write this key down, but I'd rather cheat by copying and pasting
    it into a text file that I can store in a secure location. (For this demo, you
    can just store the text file in your home directory.)
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: It says to write this key down, but I'd rather cheat by copying and pasting
    it into a text file that I can store in a secure location. (For this demo, you
    can just store the text file in your home directory.)
- en: 'Now, you can periodically run a `verify` operation to ensure that nobody has
    tampered with your log files. Just copy and paste the verification key into the
    command, like this:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 'Now, you can periodically run a `verify` operation to ensure that nobody has
    tampered with your log files. Just copy and paste the verification key into the
    command, like this:'
- en: '[PRE31]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: That's about it for sealing your log files. Now, let's talk very briefly about
    setting up remote logging with `journald`.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: That's about it for sealing your log files. Now, let's talk very briefly about
    setting up remote logging with `journald`.
- en: Setting up remote logging with journald
  id: totrans-167
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Setting up remote logging with journald
- en: Sometimes, it's handy to set up a central log collection server and have all
    the other machines on the network send their log files to it.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: Sometimes, it's handy to set up a central log collection server and have all
    the other machines on the network send their log files to it.
- en: As I've already said, `journald` remote logging is still in a proof-of-concept
    phase and isn't considered ready for production use. Also, most third-party log-aggregation
    utilities are still set up to use plaintext `rsyslog` files. So, if you have remote
    logging on your site or if you need to set up remote logging, you'll most likely
    use `rsyslog`.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: As I've already said, `journald` remote logging is still in a proof-of-concept
    phase and isn't considered ready for production use. Also, most third-party log-aggregation
    utilities are still set up to use plaintext `rsyslog` files. So, if you have remote
    logging on your site or if you need to set up remote logging, you'll most likely
    use `rsyslog`.
- en: However, I do realize that some of you might be interested in playing around
    with a remote `journald` logging setup. If that's the case, I'd like to direct
    your attention to the procedure that's linked in the *Further reading* section.
    However, be aware that you'll need to install security certificates on the `journald`
    log server and all of the clients. This procedure has you install certificates
    from *Let's Encrypt*, which requires you to have your machines in a domain that's
    registered on the public **Domain Name Service** (**DNS**) servers. If the Let's
    Encrypt installer can't find your machines on a public DNS server, the install
    operation will abort.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: However, I do realize that some of you might be interested in playing around
    with a remote `journald` logging setup. If that's the case, I'd like to direct
    your attention to the procedure that's linked in the *Further reading* section.
    However, be aware that you'll need to install security certificates on the `journald`
    log server and all of the clients. This procedure has you install certificates
    from *Let's Encrypt*, which requires you to have your machines in a domain that's
    registered on the public **Domain Name Service** (**DNS**) servers. If the Let's
    Encrypt installer can't find your machines on a public DNS server, the install
    operation will abort.
- en: Fortunately, if you just want to set up centralized `journald` logging for an
    internal LAN, you can modify the procedure so that it uses certificates that you
    create locally from a local Certificate Authority server. (Showing you how to
    set up a local Certificate Authority is beyond the scope of this book, but you
    can read about it in my other book, *Mastering Linux Security and Hardening*.)
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: Fortunately, if you just want to set up centralized `journald` logging for an
    internal LAN, you can modify the procedure so that it uses certificates that you
    create locally from a local Certificate Authority server. (Showing you how to
    set up a local Certificate Authority is beyond the scope of this book, but you
    can read about it in my other book, *Mastering Linux Security and Hardening*.)
- en: Well, I think that that should do it for `journald`. Let's wrap things up and
    move on.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: Well, I think that that should do it for `journald`. Let's wrap things up and
    move on.
- en: Summary
  id: totrans-173
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Summary
- en: In this chapter, we covered the `journald` logging system and compared it to
    the tried-and-true `rsyslog`. First, we looked at the pros and cons of both `rsyslog`
    and `journald`. Then, we saw how the two logging systems are implemented in both
    Ubuntu and RHEL distros. After that, we saw the various viewing, searching, and
    formatting options that we can use with the `journalctl` utility. We wrapped up
    by learned how to make our `journald` log files more tamper-resistant and briefly
    discussed setting up a centralized `journald` log server.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: In this chapter, we covered the `journald` logging system and compared it to
    the tried-and-true `rsyslog`. First, we looked at the pros and cons of both `rsyslog`
    and `journald`. Then, we saw how the two logging systems are implemented in both
    Ubuntu and RHEL distros. After that, we saw the various viewing, searching, and
    formatting options that we can use with the `journalctl` utility. We wrapped up
    by learned how to make our `journald` log files more tamper-resistant and briefly
    discussed setting up a centralized `journald` log server.
- en: In the next chapter, we'll look at using systemd's own network services. I'll
    see you there!
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: In the next chapter, we'll look at using systemd's own network services. I'll
    see you there!
- en: Questions
  id: totrans-176
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Questions
- en: 'Answer the following questions to test your knowledge of this chapter:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 请回答以下问题，测试你对本章内容的理解：
- en: What is the major difference between `journald` and `rsyslog`?
  id: totrans-178
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`journald` 和 `rsyslog` 之间的主要区别是什么？'
- en: A. `journald` stores files in plaintext format, while `rsyslog` stores files
    in binary format.
  id: totrans-179
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: A. `journald` 以纯文本格式存储文件，而 `rsyslog` 以二进制格式存储文件。
- en: B. There is no difference.
  id: totrans-180
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: B. 没有区别。
- en: C. `rsyslog` stores files in plaintext format, while `journald` stores files
    in binary format.
  id: totrans-181
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: C. `rsyslog` 以纯文本格式存储文件，而 `journald` 以二进制格式存储文件。
- en: Which of the following statements is true?
  id: totrans-182
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下哪项陈述是正确的？
- en: A. Modern systemd-based Linux distros come with either `rsyslog` or `journald`,
    but not both.
  id: totrans-183
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: A. 基于现代 systemd 的 Linux 发行版仅包含 `rsyslog` 或 `journald`，但不会同时包含两者。
- en: B. `journald` and `rsyslog` always work independently of each other.
  id: totrans-184
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: B. `journald` 和 `rsyslog` 总是彼此独立工作。
- en: C. Modern systemd-based Linux distros come with both `rsyslog` and `journald`.
  id: totrans-185
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: C. 基于现代 systemd 的 Linux 发行版同时包含 `rsyslog` 和 `journald`。
- en: D. `journald` and `rsyslog` can never work independently of each other.
  id: totrans-186
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: D. `journald` 和 `rsyslog` 永远不能独立工作。
- en: What are two major differences in how `journald` is implemented on Ubuntu and
    RHEL? (Choose 2.)
  id: totrans-187
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`journald` 在 Ubuntu 和 RHEL 上的实现方式有什么两大区别？（选择 2 项。）'
- en: A. `journald` logs are persistent on RHEL, but not on Ubuntu.
  id: totrans-188
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: A. 在 RHEL 上，`journald` 日志是持久的，但在 Ubuntu 上不是。
- en: B. On RHEL, `journald` works completely independently of `rsyslog`. On Ubuntu,
    they work together.
  id: totrans-189
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: B. 在 RHEL 上，`journald` 完全独立于 `rsyslog` 工作；在 Ubuntu 上，它们是一起工作的。
- en: C. On RHEL, `journald` and `rsyslog` work together. On Ubuntu, they work independently.
  id: totrans-190
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: C. 在 RHEL 上，`journald` 和 `rsyslog` 一起工作；在 Ubuntu 上，它们是独立工作的。
- en: D. On Ubuntu, `journald` logs are persistent. On RHEL, they are not.
  id: totrans-191
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: D. 在 Ubuntu 上，`journald` 日志是持久的；在 RHEL 上，则不是。
- en: E. There is no difference.
  id: totrans-192
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: E. 没有区别。
- en: Which of the following commands would delete all but the most recent one GB
    worth of `journald` log files?
  id: totrans-193
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下哪个命令可以删除所有 `journald` 日志文件，保留最新的 1GB？
- en: A. `sudo journalctl --vacuum-size=1G`
  id: totrans-194
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: A. `sudo journalctl --vacuum-size=1G`
- en: B. `sudo journalctl --rotate`
  id: totrans-195
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: B. `sudo journalctl --rotate`
- en: C. `sudo journalctl --size=1G`
  id: totrans-196
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: C. `sudo journalctl --size=1G`
- en: D. `sudo journalctl --clean=1G`
  id: totrans-197
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: D. `sudo journalctl --clean=1G`
- en: Answers
  id: totrans-198
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 答案
- en: C
  id: totrans-199
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: C
- en: C
  id: totrans-200
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: C
- en: C, D
  id: totrans-201
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: C, D
- en: A
  id: totrans-202
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: A
- en: Further reading
  id: totrans-203
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: 'The rocket-fast syslog server (the `rsyslog` project page):'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 超快的 syslog 服务器（`rsyslog` 项目页面）：
- en: '[https://www.rsyslog.com/](https://www.rsyslog.com/)'
  id: totrans-205
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://www.rsyslog.com/](https://www.rsyslog.com/)'
- en: Why `journald`?
  id: totrans-206
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为什么使用 `journald`？
- en: '[https://www.loggly.com/blog/why-journald/](https://www.loggly.com/blog/why-journald/)'
  id: totrans-207
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://www.loggly.com/blog/why-journald/](https://www.loggly.com/blog/why-journald/)'
- en: 'Understanding `journald`:'
  id: totrans-208
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解 `journald`：
- en: '[https://linuxconcept.com/tutorial/understanding-journald/](https://linuxconcept.com/tutorial/understanding-journald/)'
  id: totrans-209
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://linuxconcept.com/tutorial/understanding-journald/](https://linuxconcept.com/tutorial/understanding-journald/)'
- en: 'How to use `journalctl` to view and manipulate `systemd` logs:'
  id: totrans-210
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何使用 `journalctl` 查看和操作 `systemd` 日志：
- en: '[https://www.digitalocean.com/community/tutorials/how-to-use-journalctl-to-view-and-manipulate-systemd-logs](https://www.digitalocean.com/community/tutorials/how-to-use-journalctl-to-view-and-manipulate-systemd-logs)'
  id: totrans-211
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://www.digitalocean.com/community/tutorials/how-to-use-journalctl-to-view-and-manipulate-systemd-logs](https://www.digitalocean.com/community/tutorials/how-to-use-journalctl-to-view-and-manipulate-systemd-logs)'
- en: Did you know that `journald` can give JSON output?
  id: totrans-212
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你知道 `journald` 可以输出 JSON 格式吗？
- en: '[https://ailogs.design.blog/2020/02/01/linux-logs-did-you-know-systemd-journald-can-give-json-output/](https://ailogs.design.blog/2020/02/01/linux-logs-did-you-know-systemd-journald-can-give-json-output/)'
  id: totrans-213
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://ailogs.design.blog/2020/02/01/linux-logs-did-you-know-systemd-journald-can-give-json-output/](https://ailogs.design.blog/2020/02/01/linux-logs-did-you-know-systemd-journald-can-give-json-output/)'
- en: 'Logging with `journald`:'
  id: totrans-214
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `journald` 进行日志记录：
- en: '[https://sematext.com/blog/journald-logging-tutorial/](https://sematext.com/blog/journald-logging-tutorial/)'
  id: totrans-215
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://sematext.com/blog/journald-logging-tutorial/](https://sematext.com/blog/journald-logging-tutorial/)'
- en: 'How to centralize logs with `journald` on Ubuntu 20.04:'
  id: totrans-216
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何在 Ubuntu 20.04 上集中化日志：
- en: '[https://www.digitalocean.com/community/tutorials/how-to-centralize-logs-with-journald-on-ubuntu-20-04](https://www.digitalocean.com/community/tutorials/how-to-centralize-logs-with-journald-on-ubuntu-20-04)'
  id: totrans-217
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://www.digitalocean.com/community/tutorials/how-to-centralize-logs-with-journald-on-ubuntu-20-04](https://www.digitalocean.com/community/tutorials/how-to-centralize-logs-with-journald-on-ubuntu-20-04)'
