- en: Configuration Management with Ansible
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So far in this book, we have established a solid framework for our Enterprise
    Linux infrastructure, one that lends itself well to the large-scale deployments
    typical in an enterprise, and to automated management with Ansible at this scale.
    In this chapter, we now proceed to go into depth on the automated management aspect
    of this infrastructure, starting with the installation and configuration of software
    packages.
  prefs: []
  type: TYPE_NORMAL
- en: In just about every enterprise, one task is almost guaranteed to be required
    during the lifespan of a standardized Linux system—the installation and configuration
    of a service. This might simply involve the configuration of an existing system
    service, or possibly even the installation of the service itself, followed by
    post-configuration work.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will cover the following topics in this chapter, to explore Ansible configuration
    management in greater depth:'
  prefs: []
  type: TYPE_NORMAL
- en: Installing new software
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Making configuration changes with Ansible
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Managing configuration at an enterprise scale
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This chapter includes examples based on the following technologies:'
  prefs: []
  type: TYPE_NORMAL
- en: Ubuntu Server 18.04 LTS
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: CentOS 7.6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Ansible 2.8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To run through these examples, you will need access to two servers or virtual
    machines running one of each of the operating systems listed here, and also Ansible.
    Note that the examples given in this chapter may be destructive in nature (for
    example, they install and uninstall software packages and make changes to server
    configuration), and if run as-is, they are only intended to be run in an isolated
    test environment.
  prefs: []
  type: TYPE_NORMAL
- en: Once you are satisfied that you have a safe environment in which to operate,
    let's get started on looking at the installation of new software packages with
    Ansible.
  prefs: []
  type: TYPE_NORMAL
- en: All example code discussed in this chapter is available from GitHub, at the
    following URL: [https://github.com/PacktPublishing/Hands-On-Enterprise-Automation-on-Linux/tree/master/chapter07](https://github.com/PacktPublishing/Hands-On-Enterprise-Automation-on-Linux/tree/master/chapter07).
  prefs: []
  type: TYPE_NORMAL
- en: Installing new software
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Depending on your requirements, it is quite possible that your SOE operating
    system build has sufficient software installed, and requires only configuration
    work. However, for many people, that will not be the case, so we will begin this
    chapter with a section covering the installation of software. As with all our
    work so far, our desire is that anything we do here is repeatable and lends itself
    well to automation, and thus, even if new software is required, it is desirable
    that we do not install it by hand.
  prefs: []
  type: TYPE_NORMAL
- en: Let's start by looking at the simplest possible case here—installing a native
    operating system package.
  prefs: []
  type: TYPE_NORMAL
- en: Installing a package from operating system default repositories
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Suppose that you are rolling out a new service that requires a database server—for
    example, MariaDB. It is unlikely that you will have installed and enabled MariaDB
    in all of your SOE images, and hence, the first task before you do anything else
    will be to install the software package.
  prefs: []
  type: TYPE_NORMAL
- en: 'Both of our example operating systems in this book (and indeed, many of their
    derivatives) include native packages for MariaDB, so we could quite easily make
    use of these. When it comes to package installation, there is, of course, a need
    to understand what is going on behind the scenes in our target operating system.
    For example, on Ubuntu, we know that we would normally install our chosen software
    by using the APT package manager. Thus, if we wanted to install this manually,
    including the matching client for management purposes, we would issue the following
    command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Of course, on CentOS, things are quite different—even though packages are available
    for MariaDB, the command to install them would instead be the following one:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Although Ansible can automate a great deal of your Enterprise Linux requirements,
    it cannot abstract away some of the fundamental differences between different
    Linux operating systems. Fortunately, though, Ansible makes everything else quite
    straightforward. Consider the following inventory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: We have advocated building a standard operating environment throughout this
    book, so this inventory is rather unlikely to occur in real life—however, it serves
    as a good example here as we can demonstrate how to install a MariaDB server on
    two differing platforms. As with earlier examples in this book, we'll complete
    this task by making use of roles.
  prefs: []
  type: TYPE_NORMAL
- en: 'Building on our work on templates from earlier in this book, consider the following
    role:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: This neatly packaged role will operate correctly on both Ubuntu and CentOS (and,
    indeed, **Red Hat Enterprise Linux** (**RHEL**) and Debian, if required), and
    takes account of both the differing package managers and different package names.
    Naturally, if you are fortunate enough to have an environment that is completely
    unified (for example, only Ubuntu Server-based), then the code can be simplified
    even further.
  prefs: []
  type: TYPE_NORMAL
- en: There exists an Ansible module called `package` that attempts to detect the
    correct package manager to use, based on the operating system the playbook is
    run against. Although this removes the need for separate yum- and apt- based tasks,
    such as the ones we used previously, you still need to take into account the different
    package naming between different Linux operating systems, so you may still require
    a `when` clause.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will define a simple playbook to call the role, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we can run the playbook and observe what happens, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/e4e725fc-b55e-466c-9a15-af9836f065e1.png)'
  prefs: []
  type: TYPE_IMG
- en: From the preceding output, you can see how the tasks that are irrelevant to
    each system are skipped, while the successful installation of our desired package
    results in a `changed` status. Also, note that the task status returned was `ok` when
    installing the MariaDB client package called `mariadb` on our CentOS test system.
    The reason for this is that the `loop` defined in our `role` iterates over each
    listed package in turn, installing it; on CentOS, the `mariadb` package is a dependency
    of the `mariadb-server` package, and so it was installed when that particular
    task was run.
  prefs: []
  type: TYPE_NORMAL
- en: Although specifying this manually could be seen as redundant, it does no harm
    to keep it in our role as it ensures that whatever happens, the client package
    is present. It is also a form of self-documentation—in a few years, someone could
    come back to this playbook and understand that both the MariaDB client and server
    packages were required, even if they were unaware of this nuance of the CentOS
    7 operating system.
  prefs: []
  type: TYPE_NORMAL
- en: 'Before we build on this example, a note on package removal. Ansible tasks are,
    as we have discussed previously, idempotent. For example, if we run our playbook
    a second time, we will see that the results returned are all `ok`. In the following
    instance, Ansible has detected that our chosen packages are already installed,
    and doesn''t attempt a second installation:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/786cc962-eb89-4d1f-b0b6-d3dd70619b3a.png)'
  prefs: []
  type: TYPE_IMG
- en: 'However, what if you need to tidy something up? Perhaps a package that features
    in the standard image has become obsolete or needs removing, for security reasons.
    In this instance, it is not sufficient simply to remove the playbook or role.
    While the presence of our example role ensures the installation of packages, the
    removal of the role does not reverse this. In short, we must manually uninstall
    or remove changes if they are not required. Backing out of our installation would
    require a role such as this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Notice the almost identical nature of the role, except that we are now using
    `state: absent` instead of `state: present`. This is common to most Ansible tasks
    you might run—if you want to define a procedure for backing out or otherwise reverting
    a change, you will need to write that separately. Now, when we run the preceding
    role by calling it from a suitable playbook, we can see that the packages are
    cleanly uninstalled, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/1afc7d9c-e3a7-48cb-933c-2143ebd5e33b.png)'
  prefs: []
  type: TYPE_IMG
- en: Sometimes, of course, the packages we want to install are not available as part
    of the default operating system package repositories.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we will look at how to handle this in accordance with the
    automation principles we have set out so far.
  prefs: []
  type: TYPE_NORMAL
- en: Installing non-native packages
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Thankfully, the installation of non-native packages is not significantly more
    difficult with Ansible than with native ones. Ideally, in an enterprise environment,
    all required packages would be served out of an internal repository, and indeed,
    we will cover this later in the book. In this instance, the enterprise repository
    would be used in conjunction with Ansible roles, such as those from the previous
    section.
  prefs: []
  type: TYPE_NORMAL
- en: Occasionally, though, this may not be possible, or desirable. Take, for instance,
    a development or test system where a new package is being evaluated—here, you
    would probably not want to upload a test package to an enterprise repository server
    when it is not known whether there will be a requirement for the package moving
    forward. Nonetheless, we wish to adhere to our principles of automation and ensure
    that we perform our testing in a repeatable, self-documenting manner.
  prefs: []
  type: TYPE_NORMAL
- en: Suppose you are evaluating the Duplicati backup software for your enterprise
    and need to install the latest beta version to perform some testing. Obviously,
    you could download this manually from their releases page, copy it across to your
    target server, and install it by hand. However, this is inefficient, and certainly
    not a repeatable process. Luckily, the `apt` and `yum` modules we used earlier
    support the installation of packages, both from a local path and a remote URL.
  prefs: []
  type: TYPE_NORMAL
- en: 'Thus, to test the installation of Duplicati beta version 2.0.4.23, you could
    write a role such as this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see from this role, the installation proceeds without needing to
    separately download the package first, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/2cca5511-c3bd-4179-82f3-0ed287f9e8e9.png)'
  prefs: []
  type: TYPE_IMG
- en: Thus, in this way, whether for testing or production purposes, you can install
    packages that are not available in the default package repositories of your chosen
    operating system, and maintain the benefits of automation. In the next section,
    we will explore how Ansible can install software that is not packaged at all and
    that requires manual installation.
  prefs: []
  type: TYPE_NORMAL
- en: Installing unpackaged software
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Some software, of course, doesn't come neatly packaged and requires a more manual
    approach to installation. Take, for example, the hosting control panel software
    **Virtualmin**. This, at the time of writing, normally requires the user to download
    a shell script and execute it to perform the installation.
  prefs: []
  type: TYPE_NORMAL
- en: 'Fortunately, once again, Ansible can help here—consider the following role:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Here, we are making use of the Ansible `get_url` module to download the installation
    script and then using the `shell` module to run it. Notice also how we can put
    helpful instructions into the task names—although no substitute for good documentation,
    this is incredibly helpful as it tells anyone running the script how to check
    on the progress of the installation using the `tail` command.
  prefs: []
  type: TYPE_NORMAL
- en: Note that the `shell` module requires some care in its use—as it cannot possibly
    know whether the shell task you have given it has been run before, it runs the
    command every time the playbook is run. Thus, if you run the preceding role a
    second time, it will attempt to install Virtualmin again. You should use a `when` clause
    under your `shell` task to ensure it only runs under certain conditions—perhaps
    in the preceding example, when `/usr/sbin/virtualmin` (which is installed by `install.sh`)
    is not present.
  prefs: []
  type: TYPE_NORMAL
- en: This method could be extended to almost any software you can imagine—you could
    even download a source code tarball and extract it and build the code using a
    series of `shell` module calls in Ansible. This is an unlikely case, of course,
    but the emphasis here is that Ansible can help you create repeatable installations,
    even if you don't have access to pre-packaged software in an RPM or DEB format.
  prefs: []
  type: TYPE_NORMAL
- en: In this manner, almost any software can be installed—after all, the process
    of software installation is to download a file (or archive), put it into the right
    location, and configure it. This is, in essence, what package managers such as `yum`
    and `apt` are doing behind the scenes, and Ansible can handle this kind of activity
    just as well, as we have demonstrated here. In the next section, we will explore
    the use of Ansible to make configuration changes on systems on which you have
    built and/or installed software.
  prefs: []
  type: TYPE_NORMAL
- en: Making configuration changes with Ansible
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When it comes to configuring a new service, the task is rarely completed by
    simply installing the required software. There is almost always a configuration
    stage required after the installation.
  prefs: []
  type: TYPE_NORMAL
- en: Let's consider in detail some fundamental examples of the myriad of configuration
    changes that might be required.
  prefs: []
  type: TYPE_NORMAL
- en: Making small configuration changes with Ansible
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When it comes to making configuration changes, the `lineinfile` Ansible module
    is often your first port of call and can handle a lot of the small-scale changes
    that might be required. Consider the example of deploying a MariaDB server that
    we started earlier in this chapter. Although we successfully installed the packages,
    they will have been installed with their default configuration, and this is unlikely
    to suit all but the most basic of use cases.
  prefs: []
  type: TYPE_NORMAL
- en: For example, the default bind address for the MariaDB server is `127.0.0.1`,
    meaning that it is not possible to make use of our MariaDB installation from an
    external application. We have well established the need to make changes in a reliable,
    repeatable manner, so let's take a look at how we might change this using Ansible.
  prefs: []
  type: TYPE_NORMAL
- en: In order to change this configuration, the first thing we need to do is establish
    where the default configuration is located and what it looks like. From here,
    we will define an Ansible task, to rewrite the configuration.
  prefs: []
  type: TYPE_NORMAL
- en: 'Taking our Ubuntu server by way of example, the service bind-address is configured
    in the `/etc/mysql/mariadb.conf.d/50-server.cnf` file—the default directive looks
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Thus, in order to change this, we might employ a simple role, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s break the `lineinfile` task down and look at it in more detail:'
  prefs: []
  type: TYPE_NORMAL
- en: '`path`: Tells the module which configuration file to modify.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`regexp`: Used to locate an existing line to modify if there is one so that
    we don''t end up with two conflicting `bind-address` directives.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`line`: The line to replace/insert into the configuration file.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`insertafter`: If the `regexp` is not matched (that is, the line is not present
    in the file), this directive ensures that the `lineinfile` module inserts a new
    line after the `[mysqld]` statement, thus ensuring it is in the correct part of
    the file.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`state`: Setting this to `present` state ensures that the line is present in
    the file, even if the original `regexp` is not matched—in this instance, a line
    is added to the file in accordance with the value of `line`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Following on from this modification, we know that the MariaDB server will not
    pick up any configuration changes unless we restart it, so we do exactly that
    at the end of the role. Now, if we run this, we can see that it has the desired
    effect, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/60622338-2858-477d-9329-d34bce89455a.png)'
  prefs: []
  type: TYPE_IMG
- en: For simple configuration adjustments such as this, on a small number of systems,
    this achieves exactly the result that we desire. There are, however, drawbacks
    to this approach that need to be addressed, especially when it comes to not just
    the point in time where the change is made, but also to the long-term integrity
    of the system. Even with the best automation strategies in the world, someone
    making manual changes can remove the consistency and standardization that is core
    to good automation practice, and hence there is a real need to ensure that future
    playbook runs will still yield the desired end result. We will explore this issue
    in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Maintaining configuration integrity
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The issue with making changes in this manner is that they do not scale well.
    Tuning a MariaDB server for a production workload often requires setting perhaps
    half a dozen, or more, parameters. Thus, that simple role that we wrote previously
    could well grow to become a tangle of regular expressions and directives that
    are difficult to decipher, let alone manage.
  prefs: []
  type: TYPE_NORMAL
- en: 'Regular expressions themselves are not foolproof and are only as good as they
    are written to be. In our previous example, we used the following line to look
    for the bind-address directive, with a view to changing it. The regular expression `^bind-address\s+=` means
    to look for lines in the file that have the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Have the bind-address literal string at the start of the line (denoted by the `^`)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Have one or more spaces after the `bind-address` literal string
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Have a `=` sign after these spaces
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The idea behind this regular expression is to ensure that we ignore comments
    such as the following one:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'However, MariaDB is quite tolerant of whitespace in its configuration files,
    and the regular expression we have defined here will fail to match the following
    permutations of this line, all of which are equally valid:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'In these instances, since the `regexp` parameter didn''t match, our role will
    add a new line to the configuration file with the `bind-address = 0.0.0.0` directive. As
    MariaDB treats the preceding examples as valid configuration, we end up with two
    configuration directives in the file which, may well give you unexpected results.
    Different software packages will handle this differently too, adding to the confusion.
    There are other complexities to consider too. Many Linux services feature highly
    complex configurations that are often broken down across multiple files to make
    them easier to manage. The documentation that comes with the native MariaDB server
    package on our test Ubuntu system states the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'However, this configuration order is dictated by the `/etc/mysql/mariadb.cnf` file, which
    at the bottom has directives to include the files listed on lines 2 and 3 in the
    preceding code block. It is entirely possible for someone (well-meaning or otherwise)
    to simply come along and overwrite `/etc/mysql/mariadb.cnf` with a new version
    that removes the include statements for these subdirectories, and instead includes
    the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: As our role that makes use of `lineinfile` is completely unaware of this file,
    it will faithfully set the parameter in `/etc/mysql/mariadb.conf.d/50-server.cnf`, without
    understanding that this configuration file is no longer being referenced, and
    again, the results on the server will—at best—be unpredictable.
  prefs: []
  type: TYPE_NORMAL
- en: While the goal of enterprise automation is that all systems should have their
    changes managed centrally with a tool such as Ansible, the reality is that you
    cannot always guarantee that this will occur. Occasionally, things will break,
    and people who are in a hurry to fix them may be forced to bypass processes to
    save time. Equally, new staff members who are unfamiliar with systems may make
    changes in a manner such as we have suggested here.
  prefs: []
  type: TYPE_NORMAL
- en: 'Alternatively, take—for example—our proposed SSH daemon configuration from
    [Chapter 5](3802fb48-9f14-4a52-98c5-280d381260a4.xhtml), *Using Ansible to Build
    Virtual Machine Templates for Deployment*. Here, we proposed a simple role (shown
    again in the following code block, for reference) that would disable root logins
    over SSH, one of a number of recommended security parameters for the SSH daemon:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Note that our `regexp` has the same weaknesses as our other role when it comes
    to whitespace. When `sshd` has two duplicate parameters in its configuration file,
    it takes the first value as the correct one. Thus, if I knew that the role listed
    in the previous code block was being run against a system, all I would have to
    do is put these lines at the *very top* of `/etc/ssh/sshd_config`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Thus, our Ansible role will run faithfully against this server and report that
    it has successfully managed the SSH daemon configuration, while in reality, we
    have overridden it and enabled root logins.
  prefs: []
  type: TYPE_NORMAL
- en: 'These examples show us two things. First of all, be very careful when working
    with regular expressions. The more thorough you can be, especially when dealing
    with whitespace, the better. Obviously, in an ideal world, this would not even
    be necessary, but unexpected changes such as this have brought down many systems.
    To prevent the preceding SSH daemon example from being possible, we might try
    the following regular expression:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: This will take account of zero or more spaces before the `PermitRootLogin` keyword, and
    then take account of one or more spaces afterward, all while taking account of
    the whitespace tolerance built into `sshd`. However, regular expressions are very
    literal, and we haven't even taken account of tabs yet!
  prefs: []
  type: TYPE_NORMAL
- en: Ultimately, this brings us to the second factor demonstrated through these examples—that
    to maintain configuration and, hence, system integrity at enterprise scale, and
    ensure that you have a high degree of confidence in both your automation and the
    systems it produces, another approach might be required for configuration management.
    This is exactly what we go on to explore in the next section—techniques for reliably
    managing configuration at large, enterprise scales.
  prefs: []
  type: TYPE_NORMAL
- en: Managing configuration at an enterprise scale
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Clearly, from these examples, another approach is required for the management
    of configuration at an enterprise scale. There is nothing wrong with the `lineinfile` approach
    we discussed previously when it comes to making small numbers of changes in a
    well-controlled environment, yet let us consider a more robust approach to configuration
    management, better suited to a large organization.
  prefs: []
  type: TYPE_NORMAL
- en: We will start by considering scalable methods for simple static configuration
    changes (that is, those that are the same across all servers) in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Making scalable static configuration changes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: It is vital that the configuration changes that we make are version controlled,
    repeatable, and reliable—thus, let's consider an approach that achieves this aim.
    Let's start with a simple example by revisiting our SSH daemon configuration.
    On most servers, this is likely to be static, as requirements such as restricting
    remote root logins and disabling password-based logins are likely to apply across
    an entire estate. Equally, the SSH daemon is normally configured through one central
    file—`/etc/ssh/sshd_config`.
  prefs: []
  type: TYPE_NORMAL
- en: 'On an Ubuntu server, the default configuration is very simple, consisting of
    just six lines if we remove all the whitespace and comments. Let''s make some
    modifications to this file so that remote root logins are denied, `X11Forwarding`
    is disabled, and only key-based logins are allowed, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'We will store this file within our `roles/` directory structure and deploy
    it with the following role tasks:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we use the Ansible `copy` module to copy the `sshd_config` file we have
    created and stored within the role itself to our target host and ensure it has
    the ownership and mode that''s suitable for the SSH daemon. Finally, we restart
    the SSH daemon to pick up the changes (note that this service name is valid on
    Ubuntu Server and may vary on other Linux distributions). Thus, our completed
    `roles` directory structure looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we can run this to deploy the configuration to our test host, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/a3db5082-bbf1-4afb-997a-02eb6f7f5834.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Now, deploying the configuration through this means gives us a number of advantages
    over the methods we have explored previously, as listed here:'
  prefs: []
  type: TYPE_NORMAL
- en: The role itself can be committed to a version control system, thus implicitly
    bringing the configuration file itself (in the `files/` directory of the role)
    under version control.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Our role tasks are very simple—it is very easy for someone else to pick up this
    code and understand what it does, without the need to decipher the regular expressions.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It doesn't matter what happens to our target machine configuration, especially
    in terms of whitespace or configuration format. The pitfalls discussed at the
    end of the previous section are avoided completely because we simply overwrite
    the file on deployment.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: All machines have an identical configuration, not just in terms of directives,
    but in terms of order and formatting, thus ensuring it is easy to audit configuration
    across an enterprise.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Thus, this role represents a big step forward in terms of enterprise-scale
    configuration management. However, let''s see what happens if we run the role
    against the same host a second time. The resulting output can be seen in the following
    screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/a3db5082-bbf1-4afb-997a-02eb6f7f5834.png)'
  prefs: []
  type: TYPE_IMG
- en: From the preceding screenshot, we can see that Ansible has determined that the
    SSH configuration file is unmodified from the last run, and hence, the `ok` status
    is returned. However, in spite of this, the `changed` status of the `Restart SSH
    daemon` task indicates that the SSH daemon has been restarted, even though no
    configuration change was made. Restarting system services is normally disruptive,
    and so it should be avoided unless absolutely necessary. In this case, we would
    not wish to restart the SSH daemon unless a configuration change is made.
  prefs: []
  type: TYPE_NORMAL
- en: 'The recommended way to handle this is with a `handler`. A `handler` is an Ansible
    construct that is much like a task, except that it only gets called when a change
    is made. Also, when multiple changes are made to a configuration, the handler
    can be notified multiple times (once for each applicable change), and yet the
    Ansible engine batches up all handler calls and runs the handler once, only after
    the tasks complete. This ensures that when it is used to restart a service, such
    as in this example, the service is only restarted once, and only then when a change
    is made. Let''s test this now, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First of all, remove the service restart task from the role and add a `notify`
    clause to notify the handler (we shall create this in a minute). The resulting
    role tasks should look like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we need to create a `handlers/` directory in the role and add our previously
    removed handler code to it so that it looks like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'The resulting `roles` directory structure should now look like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, when we run the playbook twice on the same server (having initially reverted
    the SSH configuration to the original one), we see that the SSH daemon is only
    restarted in the instance where we have actually changed the configuration, as
    shown in the following screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/fa05dc02-d7f8-4f14-bebe-7de0a2ec42c8.png)'
  prefs: []
  type: TYPE_IMG
- en: 'To further demonstrate handlers before we move on, let''s consider this enhancement
    to the role tasks:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Here, we deploy our configuration file and perform an additional modification.
    We are putting a comment into the head of the file, which includes an Ansible
    variable, with the hostname of the target host.
  prefs: []
  type: TYPE_NORMAL
- en: 'This will result in two changed statuses on our target host, and yet, if we
    revert to the default SSH daemon configuration and then run our new playbook,
    we see the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/fc3fea96-62c6-4b72-bdd6-7054844eff25.png)'
  prefs: []
  type: TYPE_IMG
- en: Pay careful attention to the preceding output and the sequence in which the
    tasks are run. You will note that the handler is not run in sequence and is actually
    run once at the end of the play.
  prefs: []
  type: TYPE_NORMAL
- en: Even though our tasks both changed and hence would have notified the handler
    twice, the handler was only run at the end of the playbook run, minimizing restarts,
    just as required.
  prefs: []
  type: TYPE_NORMAL
- en: In this manner, we can make changes to static configuration files at large scales,
    across many hundreds—if not thousands—of machines. In the next section, we will
    build on this to demonstrate ways of managing configuration where dynamic data
    is required—for example, configuration parameters that might change on a per-host
    or per-group basis.
  prefs: []
  type: TYPE_NORMAL
- en: Making scalable dynamic configuration changes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: While the preceding examples resolve many of the challenges of making automated
    configuration changes at scale in an enterprise, it is noticeable that our final
    example was somewhat inefficient. We deployed a static, version-controlled configuration
    file, and made a change to it using the `lineinfile` module again.
  prefs: []
  type: TYPE_NORMAL
- en: This allowed us to insert an Ansible variable into the file, which in many instances
    is incredibly useful, especially when configuring more complex services. However,
    it is—at best—inelegant to split this change across two tasks. Also, reverting
    to the use of the `lineinfile` module again exposes us to the risks we discussed
    earlier and means we would need one `lineinfile` task for every variable we wish
    to insert into a configuration.
  prefs: []
  type: TYPE_NORMAL
- en: Thankfully, Ansible includes just the answer to such a problem. In this case,
    the concept of Jinja2 templating comes to our rescue.
  prefs: []
  type: TYPE_NORMAL
- en: Jinja2 is a templating language for Python that is incredibly powerful and easy
    to use. As Ansible is coded almost entirely in Python, it lends itself well to
    the use of Jinja2 templates. So, what is a Jinja2 template? At its most fundamental
    level, it is a static configuration file, such as the one we deployed for the
    SSH daemon earlier, but with the possibility of variable substitutions. Of course,
    Jinja2 is far more powerful than that—it is, in essence, a language in its own
    right, and features common language constructs such as `for` loops and `if...elif...else` constructs,
    just as you would find in other languages. This makes it incredibly powerful and
    flexible, and entire sections of a configuration file (for example) can be omitted,
    depending on how an `if` statement evaluates.
  prefs: []
  type: TYPE_NORMAL
- en: As you can imagine, Jinja2 deserves a book of its own to cover the detail of
    the language—however, here, we will provide a practical hands-on introduction
    to Jinja2 templating for the automation of configuration management in an enterprise.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s go back to our SSH daemon example for a minute, where we wanted to put
    the target hostname into a comment at the head of the file. While this is a contrived
    example, progressing it from the `copy`/`lineinfile` example to a single `template` task
    will show the benefits that templating brings. From here, we can progress to a
    more comprehensive example. To start with, let''s define our Jinja2 template for
    the `sshd_config` file, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Notice that the file is identical to the file we deployed using the copy module
    earlier, only now, we have included the comment in the file header and used the
    Ansible variable construct (denoted by pairs of curly braces) to insert the `inventory_hostname` variable.
  prefs: []
  type: TYPE_NORMAL
- en: Now, for the sake of our sanity, we will call this file `sshd_config.j2` to
    ensure we can differentiate templates from flat configuration files. Templates
    are normally placed into a `templates/` subdirectory within the role, and so are
    subject to version control in the same way that playbook, roles, and any associated
    flat configuration files are.
  prefs: []
  type: TYPE_NORMAL
- en: Now, rather than copying the flat file and then performing substitutions with
    one or more `lineinfile` tasks, we can use the Ansible `template` module to deploy
    this template and parse all Jinja2 constructs.
  prefs: []
  type: TYPE_NORMAL
- en: 'Thus, our tasks now look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: Notice that the task is almost identical to our earlier `copy` task and that
    we call our handler, just as before.
  prefs: []
  type: TYPE_NORMAL
- en: 'The completed module directory structure now looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s run this and evaluate the results, which can be seen in the following
    screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/0f735768-f96d-47c3-b238-69fd6252aa07.png)'
  prefs: []
  type: TYPE_IMG
- en: As can be seen here, the template has been copied across to the target host,
    and the variable in the header comment has been processed and the appropriate
    value substituted.
  prefs: []
  type: TYPE_NORMAL
- en: 'This becomes incredibly powerful as our configuration becomes more complex
    as, no matter how large and complex the template, the role still only requires
    the one `template` task. Returning to our MariaDB server, suppose that we want
    to set a number of parameters on a per-server basis to effect tuning appropriate
    to the different workloads we are deploying. Perhaps we want to set the following:'
  prefs: []
  type: TYPE_NORMAL
- en: The server bind-address, defined by `bind-address`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The maximum binary log size, defined by `max_binlog_size`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The TCP port that MariaDB listens on, as defined by `port`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'All of these parameters are defined in `/etc/mysql/mariadb.conf.d/50-server.cnf`.
    However, as discussed earlier, we need to also ensure the integrity of `/etc/mysql/mariadb.cnf` to
    ensure it includes this (and other) files, to reduce the possibility of someone
    overriding our configuration. Let''s start building our templates—first of all,
    a simplified version of the `50-server.cnf` file, with some variable substitutions.
    The first part of this file is shown in the following code—note the `port` and
    `bind-address` parameters, which are now defined using Ansible variables, denoted
    in the usual manner with pairs of curly braces:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'The second part of this file looks as follows—you will observe here the presence
    of the `mariadb_max_binlog_size` variable, while all other parameters remain static:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let''s also add in a templated version of `/etc/mysql/mariadb.cnf`, as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: This file might be short, but it serves a really important purpose. It is the
    first file that is read by the MariaDB service when it loads, and it references
    other files or directories to be included. If we did not maintain control of this
    file using Ansible, then anyone with sufficient privileges could log in and edit
    the file, possibly including entirely different configurations and bypassing our
    Ansible-defined configuration entirely. Whenever you deploy configuration with
    Ansible, it is important to consider factors such as this, as otherwise, your
    configuration changes might be bypassed by a well-meaning (or otherwise) administrator.
  prefs: []
  type: TYPE_NORMAL
- en: A template doesn't have to have any Jinja2 constructs in it—if there are no
    variables to insert, as in our second example, the file will simply be copied
    as-is to the target machine.
  prefs: []
  type: TYPE_NORMAL
- en: 'Obviously, it would be slightly more efficient to use the copy module to send
    this static configuration file to the remote server, but this requires two tasks,
    where we can use just one with a loop to process all our templates. Such an example
    is shown in the following code block:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we define a handler to restart MariaDB if the configuration has changed,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: Now, before we run this, a word on variables. In Ansible, variables can be defined
    at a wide number of levels. In a case such as this, where we are applying a different
    configuration to different hosts with differing purposes, it makes sense to define
    the variables at the host or hostgroup level. However, what happens if someone
    were to forget to put these in the inventory, or in another appropriate location?
    Fortunately, we can leverage the variable precedence order of Ansible to our advantage
    here and define default variables for our role. These are second lowest on the
    order of precedence, so are almost always overridden by another setting elsewhere,
    yet they provide a safety net, should they be missed accidentally. As our preceding
    templates have been written, if the variables are not defined anywhere, the configuration
    file will be invalid and the MariaDB server will refuse to start—a case we would
    definitely like to avoid.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s define the default values for these variables in our role now under
    `defaults/main.yml`, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'With this complete, our role structure should look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'Naturally, we want to override the default values, so we will define these in
    our inventory grouping—this is a good use case for inventory groups. All MariaDB
    servers that serve the same function would go in one inventory group, and then
    have a common set of inventory variables assigned to them, such that they all
    receive the same configuration. However, the use of templates in our role means
    that we can reuse this role in a number of situations, simply by providing differing
    configurations through variable definition. We will create an inventory for our
    test host that looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'With this complete, we can finally run our playbook and observe what happens.
    The result is shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/33ce9b9d-89fb-489d-ae12-f0c91c7fe9b9.png)'
  prefs: []
  type: TYPE_IMG
- en: With this successfully run, we have shown a complete end-to-end example of how
    to manage configuration on an enterprise scale, all while avoiding the pitfalls
    of regular expression substitutions and multi-part configurations. Although these
    examples are simple, they should serve as the basis for any well-thought-out enterprise
    automation strategy where a configuration is required.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Managing configuration across an enterprise Linux estate is filled with pitfalls
    and the potential for configuration drift. This can be caused by people with good
    intentions, even in *break-fix* scenarios where changes have to be made in a hurry.
    However, it can also be caused by those with malicious intent, seeking to circumvent
    security requirements. Good use of Ansible, especially templating, enables the
    construction of easy-to-read, concise playbooks that make it easy to ensure configuration
    management is reliable, repeatable, auditable, and version-controlled—all the
    basic tenets we set out earlier in this book for good enterprise automation practice.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, you gained practical experience in extending a Linux machine
    with new software packages. You then learned how to apply simple, static configuration
    changes to those packages, and the potential pitfalls associated with this. Finally,
    you learned best practices for managing configuration across an enterprise using
    Ansible. In the next chapter, we proceed to look at internal repository management
    with Pulp.
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: What are the different Ansible modules commonly used for making changes to configuration
    files?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How does templating work in Ansible?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Why must you consider configuration file structure when making changes with
    Ansible?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What are the pitfalls of using regular expressions when making file modifications?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How does a template behave if there are no variables in it?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How can you check that a configuration template you have deployed is valid before
    committing it to disk?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How can you quickly audit the configuration of 100 machines against a known
    template with Ansible?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For an in-depth understanding of Ansible, please refer to *Mastering Ansible,
    Third Edition*, by* James Freeman* and *Jesse Keating* ([https://www.packtpub.com/gb/virtualization-and-cloud/mastering-ansible-third-edition](https://www.packtpub.com/gb/virtualization-and-cloud/mastering-ansible-third-edition)).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
