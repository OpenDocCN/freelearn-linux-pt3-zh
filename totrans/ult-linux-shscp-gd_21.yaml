- en: '21'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '21'
- en: Debugging Shell Scripts
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 调试 Shell 脚本
- en: If you’ve ever written a beautiful looking script, only to be disappointed when
    it doesn’t work properly, don’t feel alone. This happens to all of us, and even
    happened to me a few times when I was creating scripts for this book. (I know,
    shocking, right?)
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你曾经写过一个看起来很漂亮的脚本，却在它无法正常工作时感到失望，不要觉得孤单。这种情况发生在我们所有人身上，甚至在我为这本书创建脚本时也发生了几次。（我知道，令人震惊吧？）
- en: The debugging process should begin the moment that you begin to design your
    code. Put careful thought into the design, test each portion as you write it,
    and—for goodness’ sake—use a text editor with color-coded syntax highlighting.
    (That color highlighting will prevent you from making a multitude of typographical
    errors.)
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 调试过程应该从你开始设计代码的那一刻起就开始。仔细思考设计，写代码时测试每个部分，并且——天哪——使用带有语法高亮显示的文本编辑器。（这种颜色高亮将帮助你避免大量的排版错误。）
- en: 'Topics in the chapter include:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中的主题包括：
- en: Understanding common scripting errors
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解常见的脚本错误
- en: Not Enough Quoting
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 引号不够
- en: Creating a Wild Loop
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建无限循环
- en: Using shell script debugging tools and techniques
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 shell 脚本调试工具和技术
- en: Using `echo` Statements
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `echo` 语句
- en: Using `xtrace` for Debugging
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `xtrace` 进行调试
- en: Checking for Undefined Variables
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 检查未定义的变量
- en: Checking for Errors with the `-e` Option
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `-e` 选项检查错误
- en: Using `bash` Debugger
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `bash` 调试器
- en: Debugging a script with bashdb
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 bashdb 调试脚本
- en: Getting help with bashdb
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 bashdb 获取帮助
- en: If you’re ready, let’s get started.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你准备好了，我们就开始吧。
- en: Technical Requirements
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: For this chapter, I’m mainly just using the Fedora workstation that I’m using
    to create this Word file. But, you can use whichever Linux virtual machine that
    you like, as long as it has a desktop environment installed. (One of the demos
    requires a desktop.)
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这一章，我主要使用的是我用来创建这个 Word 文件的 Fedora 工作站。但是，你可以使用任何你喜欢的 Linux 虚拟机，只要它安装了桌面环境。（其中一个演示需要桌面环境。）
- en: For the final topic, I’ll show you how to install and use `bashdb` on Debian/Ubuntu,
    Fedora, FreeBSD, and macOS.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 对于最后一个主题，我将展示如何在 Debian/Ubuntu、Fedora、FreeBSD 和 macOS 上安装和使用 `bashdb`。
- en: 'As always, you can grab the scripts by doing:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 一如既往，你可以通过以下命令获取脚本：
- en: '[PRE0]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Understanding Common Scripting Errors
  id: totrans-22
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解常见的脚本错误
- en: The most important step in debugging is understanding the common errors that
    could cause your scripts to either outright fail, or to give you incorrect results.
    Let’s look at a few examples.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 调试中最重要的步骤是理解可能导致脚本直接失败或返回错误结果的常见错误。让我们来看一些例子。
- en: Not Enough Quoting
  id: totrans-24
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 引号不够
- en: You can have a few different problems if you don’t surround variable names with
    quotes. Here are some examples.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你没有用引号将变量名包围起来，可能会遇到一些问题。这里有一些例子。
- en: Filenames with Blank Spaces
  id: totrans-26
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 文件名中有空格
- en: For this demo, I’ve moved into an empty directory in order to keep the files
    I’ll be creating separate from the files in my main home directory. I want to
    create some files with a timestamp in the filename. To do that, I’ll use the `date`
    command, without any option switches.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 为了演示，我进入了一个空目录，以便将要创建的文件与我主目录中的文件区分开来。我想创建一些文件，文件名中包含时间戳。为此，我将使用 `date` 命令，不加任何选项。
- en: 'First, I’ll create a file from the command-line using `touch`:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我将使用 `touch` 从命令行创建一个文件：
- en: '[PRE1]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Okay, let’s look at the file:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，让我们来看看文件：
- en: '[PRE2]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Whoa, now. What’s going on here? Instead of having one file, I have seven.
    Each file has a portion of the current date in its filename. Well, the problem
    is that `date`, without any option switches, produces output with blank spaces
    in it, like this:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 哇，现在发生了什么？我没有得到一个文件，而是得到了七个。每个文件的文件名中都有当前日期的一部分。问题是，`date` 在没有任何选项的情况下，会生成带有空格的输出，就像这样：
- en: '[PRE3]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'So when the shell saw those blank spaces, it thought that I wanted to create
    multiple files, instead of just one. Let’s delete all of these files, and try
    this again with some quotes:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 所以当 shell 看到这些空格时，它认为我想要创建多个文件，而不是仅仅一个。让我们删除所有这些文件，再尝试加上一些引号：
- en: '[PRE4]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: You see how I’ve surrounded the command substitution construct with a pair of
    double quotes, which causes the shell to ignore the blank spaces. So now, I have
    just one file with the correct filename.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 你看到我如何用一对双引号将命令替换构造包围起来，这使得 shell 忽略了空格。现在，我只有一个文件，文件名是正确的。
- en: Problems with Unset Variables
  id: totrans-37
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 未设置变量的问题
- en: 'For our next scenario, let’s look at the `quote_problem1.sh` script:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 对于下一个场景，让我们来看一下 `quote_problem1.sh` 脚本：
- en: '[PRE5]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'All it does is to tell us whether or not the value of `number` is 1\. Running
    the script looks like this:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 它只是告诉我们`number`的值是否为`1`。运行脚本的结果如下：
- en: '[PRE6]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Okay, it works fine. Now, I’ll edit the file to change the value of `number`
    to 2, and run the script again. Here’s how that looks:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，现在它运行正常。接下来，我会编辑文件，将`number`的值改为`2`，然后再次运行脚本。结果如下：
- en: '[PRE7]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Now, let’s try that with an unset variable, as you see in `quote_problem2.sh`:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们尝试使用未设置的变量，就像你在`quote_problem2.sh`中看到的那样：
- en: '[PRE8]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: When we say that a variable is unset, it just means that we defined the variable,
    but haven’t assigned a value to it. Let’s see what happens with I try to run this
    script.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们说变量未设置时，实际上是指我们定义了该变量，但没有为它赋值。让我们看看在尝试运行这个脚本时会发生什么。
- en: '[PRE9]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'The problem is that the `if [ $number = 1 ]` test is looking for some sort
    of value for the number variable. But, `number` has no value, which breaks the
    test. Fortunately, it’s an easy fix. All I’ll have to do is to surround the `$number`
    that’s in the test statement with a pair of double quotes, as you see in `quote_problem3.sh`:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 问题在于，`if [ $number = 1 ]`测试在寻找某种`number`变量的值。但`number`没有值，这导致测试失败。幸运的是，这很容易修复。只需要将测试语句中的`$number`用一对双引号包围，就像你在`quote_problem3.sh`中看到的那样：
- en: '[PRE10]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Running this script will show the correct results:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 运行这个脚本会显示正确的结果：
- en: '[PRE11]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: This works because instead of having no value at all as we had before, `number`
    now effectively has the value of a blank space. A blank space isn’t equal to 1,
    so the script works.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 之所以有效，是因为与之前没有值的情况不同，`number`现在有效地拥有了一个空格值。空格不等于`1`，所以脚本能够正常运行。
- en: It’s normally better to always assign an initial value to your variables as
    you create them, in order to prevent these kinds of problems. However, it’s sometimes
    desirable to use an unset variable. For example, you might want your script to
    do one thing if a variable is unset, or to do something else if the variable is
    set with a value. That’s perfectly fine as long as you know how to use quotes
    to avoid these kinds of parsing problems.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，最好在创建变量时就为它们赋一个初始值，以避免这些问题。然而，有时需要使用未设置的变量。例如，你可能希望脚本在一个变量未设置时执行一件事，或者在该变量有值时执行另一件事。只要你知道如何使用引号来避免这些解析问题，这完全没问题。
- en: 'To make this a bit more realistic, let’s make `quote_problem4.sh` so that it
    will accept a user-defined value:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 为了让这个问题更现实一些，我们来制作`quote_problem4.sh`，使其能够接受用户定义的值：
- en: '[PRE12]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Let’s see how it works with different values:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看它在不同值下是如何工作的：
- en: '[PRE13]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'It works fine with either 1 or 5 as a value, but doesn’t work when I don’t
    supply a value. So, it appears that I forgot to quote the `$number`. Not to worry,
    I’ll fix that in `quote_problem5.sh`:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 这个方法在`1`或`5`作为值时运行良好，但当我没有提供值时，它就无法工作。所以，看起来是我忘记引用`$number`了。别担心，我会在`quote_problem5.sh`中修复这个问题：
- en: '[PRE14]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Let’s see what we have now:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看现在的情况：
- en: '[PRE15]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: It works like a champ, which means that once again, we’ve achieved coolness.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 它运行得很顺利，这意味着我们再次取得了成功。
- en: 'Since we’ve been working with tests, let’s see what happens when we leave out
    a space, as I did in `space_problem1.sh`:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们在进行测试，让我们看看当我们像在`space_problem1.sh`中那样省略空格会发生什么：
- en: '[PRE16]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'It’s the same as the `quote_problem5.sh` script, except that I deleted the
    space between the `[` and the `"$number"`. Here’s what happens when I run it:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 这与`quote_problem5.sh`脚本相同，唯一的区别是我删除了`[`和`"$number"`之间的空格。运行它时，结果如下：
- en: '[PRE17]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Amazingly enough, it gives me the exact same error message as when I forgot
    to quote my `$number` variable. So, this shows us two things. First, you need
    to be careful about placing spaces in your test conditions. Secondly, you can’t
    always depend upon the shell’s error message to tell you exactly what the problem
    is. In this case, the exact same message showed up for two completely different
    errors.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 令人惊讶的是，它给出了与我忘记引用`$number`变量时相同的错误信息。所以，这告诉我们两件事。首先，你需要小心在测试条件中放置空格。其次，你不能总是依赖于shell的错误信息来准确告诉你问题所在。在这个案例中，两个完全不同的错误却显示出了完全相同的信息。
- en: 'But wait! Here’s one more way to troubleshoot this problem. We’ll just use
    the `-u` shell option to check for uninitialized variables, as you see here in
    the `quote_problem6.sh` script:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 等等！这里有一种解决问题的方式。我们只需要使用`-u` shell选项来检查未初始化的变量，正如你在`quote_problem6.sh`脚本中看到的那样：
- en: '[PRE18]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'The only difference between this script and the previous one is that I added
    `-u` to the end of the shebang line. Let’s see what happens when I run it without
    supplying a value for `$1`:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 这个脚本与之前的唯一不同是我在 shebang 行的末尾添加了 `-u`。我们来看看如果不提供 `$1` 的值时会发生什么：
- en: '[PRE19]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'This is cool, because it tells us exactly what the problem is, instead of just
    showing us a generic error message. If you need to see a more verbose message,
    just add the `v` option, like this:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 这很酷，因为它精确地告诉我们问题出在哪里，而不是只是显示一个通用的错误信息。如果你需要查看更详细的消息，只需添加 `v` 选项，像这样：
- en: '[PRE20]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Running the script now looks like this:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 现在运行脚本的样子是这样的：
- en: '[PRE21]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: When you’re finished debugging, be sure to delete the `-u` or `-uv` That’s because
    it could cause problems in production scripts.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 调试完成后，记得删除 `-u` 或 `-uv`，因为这可能会在生产脚本中引发问题。
- en: I’ll show you more about using the `-u` option in just a few pages, in the *Using
    Shell Script Debugging Tools* section.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 我将在接下来的几页中向你展示更多关于使用 `-u` 选项的内容，具体在 *使用 Shell 脚本调试工具* 部分。
- en: For the next problem, you’ll need to buckle your seat belt. That’s because things
    are going to get wild.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 对于下一个问题，你需要系好安全带。因为事情会变得很疯狂。
- en: Creating a Wild Loop
  id: totrans-79
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建一个疯狂的循环
- en: 'When you create some sort of loop, it’s real easy to accidentally create one
    that will run forever until you stop it. For example, let’s look at the `wild_loop1.sh`
    script:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 当你创建某种循环时，很容易不小心创建一个会无限运行，直到你手动停止它。例如，看看 `wild_loop1.sh` 脚本：
- en: '[PRE22]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'This loop begins with a `count` value of 30, which will increment by 1 on each
    iteration of the loop. It’s supposed to go until `count` reaches a value of 25\.
    Okay, I know that the problem is blatantly obvious this time, but bear with me
    anyway. This could happen if a coder got in a hurry and just didn’t notice it.
    Anyway, trying to run this will output a list of numbers that just keeps on going
    and going. No matter how fast you hit *Ctrl-c*, the output will scroll past the
    top of your terminal, so that you’ll never get to see the top part of the output.
    So, I’ll fix that by directing the output into a text file. First though, I’ll
    open a second terminal window, and create a blank text file, like this:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 这个循环从 `count` 值为 30 开始，每次迭代时 `count` 增加 1。它应该一直运行，直到 `count` 达到 25。好吧，我知道这次问题显而易见，但还是请你耐心一点。这种情况可能发生在某个程序员急于完成任务时，没有注意到这个问题。无论如何，试着运行这个脚本会输出一个不断增加的数字列表。无论你多快按下
    *Ctrl-c*，输出会一直滚动到终端的顶部，所以你根本看不到输出的顶部部分。因此，我会通过将输出导入到文本文件中来修复这个问题。不过首先，我会打开第二个终端窗口，创建一个空白文本文件，如下所示：
- en: '[PRE23]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Next, while still in that window, I’ll open the file with `tail -f`, in order
    to see the file as it gets updated:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我仍然在那个窗口中，使用 `tail -f` 打开文件，这样可以看到文件的更新内容：
- en: '[PRE24]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'I’ll now go back to my first terminal window, and run the `wild_loop1.sh` script,
    like this:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我回到我的第一个终端窗口，并像这样运行 `wild_loop1.sh` 脚本：
- en: '[PRE25]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'I hit *Cntrl-c* after only a few seconds. But, as you see in the second window,
    the count really went wild:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 我在几秒钟后按下了 *Ctrl-c*。但正如你在第二个窗口中看到的，`count` 真的是乱了：
- en: '![B21693_21_1](img/B21693_21_01.png)'
  id: totrans-89
  prefs: []
  type: TYPE_IMG
  zh: '![B21693_21_1](img/B21693_21_01.png)'
- en: 'Figure 21.1: The wild loop is going wild!'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 图 21.1：疯狂的循环正在疯狂运行！
- en: Open the `wild_loop.txt` file in `less`, and you’ll see that the script really
    does have the output begin at 30.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `less` 打开 `wild_loop.txt` 文件，你会看到脚本的输出确实是从 30 开始的。
- en: '[PRE26]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'As I said before, the problem here is obvious. It’s just that I accidentally
    reversed the values of `count` and `limit`. So, let’s fix that in `wild_loop2.sh`:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 就像我之前说的，这个问题很明显。只是我不小心交换了 `count` 和 `limit` 的值。所以，我们来在 `wild_loop2.sh` 中修复这个问题：
- en: '[PRE27]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'This time, `count` is set to 25 and `limit` is set to 30\. Running this script
    should work better. Let’s see:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 这次，`count` 设置为 25，`limit` 设置为 30。运行这个脚本应该效果更好。我们来看看：
- en: '[PRE28]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Oh yeah, that looks much better.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 哦，那个看起来好多了。
- en: There are a whole lot more shell scripting pitfalls that I could share with
    you. But, in the interest of not trying to reinvent the proverbial wheel, I’ll
    end this here and instead share a few excellent resources that you might find
    useful.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 还有很多 Shell 脚本的陷阱我可以与大家分享。但是，为了避免重新发明轮子，我就在这里结束，并分享一些你可能觉得有用的优秀资源。
- en: 'Filenames and Pathnames in Shell: How to do it Correctly:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: Shell 中的文件名和路径名：如何正确操作：
- en: '[https://dwheeler.com/essays/filenames-in-shell.html](https://dwheeler.com/essays/filenames-in-shell.html)'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://dwheeler.com/essays/filenames-in-shell.html](https://dwheeler.com/essays/filenames-in-shell.html)'
- en: 'Common Shell Script Mistakes:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 常见的 Shell 脚本错误：
- en: '[https://www.pixelbeat.org/programming/shell_script_mistakes.html](https://www.pixelbeat.org/programming/shell_script_mistakes.html)'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
- en: 'BashPitfalls:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
- en: '[http://mywiki.wooledge.org/BashPitfalls](http://mywiki.wooledge.org/BashPitfalls)'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
- en: All right, let’s move on to the debugging tools.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
- en: Using Shell Script Debugging Tools and Techniques
  id: totrans-106
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are a few different debugging tools that we can use, which include `shellcheck`,
    `checkbashisms`, and `shall`. We’ve already looked at them in *Chapter 19—Shell
    Script Portability*, so we won’t look at them again here. Instead, I’ll present
    some tools and techniques that we haven’t covered yet.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
- en: Using echo Statements
  id: totrans-108
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Sometimes, if you have a problem with a shell script that you can’t figure out,
    placing `echo` statements in strategic locations can help you find the problem.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
- en: You may see in other references that some people think of `echo` statements
    as the poor man’s debugging tool. That’s because `echo` is always available, and
    can be used if you can’t use anything else.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
- en: Back in *Chapter 16, Creating User Interfaces with yad, dialog, and xdialog*,
    I showed you the `xdialog-hello2.sh` script, which can automatically detect two
    things.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
- en: It can detect whether or not the `Xdialog` utility is present.
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It can also detect if your machine has a desktop environment installed.
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'If both a desktop environment and the `Xdialog` utility are detected, the script
    will run the graphical `Xdialog` utility. Otherwise, the script will run the ncurses-based
    `dialog` utility. Here’s what the script looks like:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: As a reminder, the `DISPLAY` environmental variable will have a non-zero length
    assigned value if a desktop environment is installed, and won’t have an assigned
    value if no desktop environment is installed. The `-n` in the `[[ -n $DISPLAY
    ]]` statement tests for the presence of a non-zero length assigned value. (The
    `-n` actually stands for *non-zero*.) So, if the `[[ -n $DISPLAY ]]` test returns
    a value of 0, which means that the condition is *true*, then a desktop environment
    has been detected.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
- en: 'Originally though, the script looked like this, as you see in the `xdialog-hello2-broken.sh`
    script:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: As you see, the only difference is that the test conditions in the two scripts
    are in a different order. The script that works has the `[[ $? == 0 ]]` test first,
    and the broken script has the `[[ -n $DISPLAY ]]` condition first.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
- en: When I tried running the original script, which had `[[ -n $DISPLAY ]]` first,
    it just wouldn’t work. I mean, it would work fine on desktop machines that had
    `Xdialog` installed or machines that were running in text mode. But, on desktop
    machines that didn’t have `Xdialog` installed, it would always tell me that it
    is installed. And of course, running the script would always fail because it was
    trying to run `Xdialog`. I couldn’t understand the reason for this, so I had to
    do some troubleshooting.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
- en: I’ve never installed `Xdialog` on my Fedora workstation, so I can use it to
    show you my troubleshooting steps. When you try this demo, be sure to try it on
    a desktop-type virtual machine that also does not have `Xdialog` installed.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 我从未在我的Fedora工作站上安装过`Xdialog`，所以我可以用它来展示我的故障排除步骤。当你尝试这个演示时，务必在一个没有安装`Xdialog`的桌面类型虚拟机上进行。
- en: 'You can start troubleshooting by placing an `echo $?` command and a `sleep
    10` command just under the `command -v Xdialog` line. The script now looks like
    this:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过在`command -v Xdialog`命令下方放置`echo $?`命令和`sleep 10`命令来开始故障排除。现在脚本看起来是这样的：
- en: '[PRE31]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: I wanted to see if the exit code would be 0 or 1, and the `sleep 10` command
    would pause the script long enough so that I could see the `echo $?` output.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 我想看看退出代码是0还是1，并且`sleep 10`命令会暂停脚本足够长的时间，这样我就能看到`echo $?`的输出。
- en: I inserted the `sleep 10` command to give myself ten seconds to see the output
    of the `echo $?` command. Otherwise, the `clear` command at the end would clear
    away the output before I could see it. If you prefer, you can omit the `sleep
    10` command, and instead just comment out the `clear` command. Either way works,
    so the choice is yours.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 我插入了`sleep 10`命令，给自己十秒钟时间查看`echo $?`命令的输出。否则，末尾的`clear`命令会在我看到输出之前清除它。如果你愿意，你可以省略`sleep
    10`命令，而改为注释掉`clear`命令。无论哪种方式都可以，所以选择权在你。
- en: 'A 1 would mean that `Xdialog` is not installed, and a 0 would mean that it
    is installed. Placing the `echo` and `sleep` commands under the `command -v Xdialog`
    command would show me if the script was properly detecting if the package was
    installed. Running the script now looks like this:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 1表示`Xdialog`未安装，而0表示已安装。将`echo`和`sleep`命令放在`command -v Xdialog`命令下方，可以让我看到脚本是否正确检测到软件包是否安装。现在运行脚本看起来是这样的：
- en: '[PRE32]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'The 1 exit code means that the script properly detects that `Xdialog` is not
    present. So, that portion of the script works. Next, you can comment out the whole
    `if. . then. .else` stanza, and place an `[[ -n $DISPLAY ]] && echo $?` statement
    and a `sleep 10` statement just above it, like this:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 1退出代码表示脚本正确地检测到`Xdialog`不存在。因此，脚本的这一部分正常工作。接下来，你可以注释掉整个`if...then...else`语句块，并在其上方放置`[[
    -n $DISPLAY ]] && echo $?`语句和`sleep 10`语句，像这样：
- en: '[PRE33]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Running the script with this modification looks like this:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 运行带有此修改的脚本看起来是这样的：
- en: '[PRE34]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: The 0 exit code indicates a true condition, which means that a desktop environment
    is indeed installed. So, that part of the code also works properly.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 0退出代码表示条件为真，这意味着确实安装了桌面环境。所以，这部分代码也正常工作。
- en: At this point we need to start thinking logically. If the `[[ -n $DISPLAY ]]`
    returns a 0 exit code, how would that affect the `[[ $? == 0 ]]` part? Well, it
    turns out that the `$?` in the second test condition was looking at the 0 exit
    code that was returned by the first test condition, instead of the exit code from
    the `command -v Xdialog` command. So on a desktop machine, the `$?` would always
    be looking at a 0 exit code, whether or not `Xdialog` was present. Fixing that
    was just a simple matter of swapping the order of the two test conditions, as
    you see above in the `xdialog-hello2.sh` script.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 这个时候我们需要开始进行逻辑思考。如果`[[ -n $DISPLAY ]]`返回0退出代码，这会如何影响`[[ $? == 0 ]]`部分呢？事实证明，第二个测试条件中的`$?`查看的是第一个测试条件返回的0退出代码，而不是`command
    -v Xdialog`命令的退出代码。因此，在桌面机器上，`$?`总是会查看0退出代码，无论`Xdialog`是否存在。解决这个问题的方法很简单，就是交换两个测试条件的顺序，如你在`xdialog-hello2.sh`脚本中看到的那样。
- en: In hindsight, the solution to this problem should have been obvious. But for
    some reason I was having a mental block that prevented me from seeing that. It
    just goes to show that even the best of us can sometimes be buffaloed by simple
    scripting errors.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 回想起来，解决这个问题应该是显而易见的。但由于某种原因，我当时陷入了思维障碍，无法看出这一点。这也表明，即使是最优秀的人，有时也会被简单的脚本错误难倒。
- en: All right, let’s move on to the next debugging tool.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，让我们继续下一种调试工具。
- en: Using xtrace for Debugging
  id: totrans-136
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用xtrace进行调试
- en: Using **xtrace** with your problematic scripts shows the actual execution of
    the commands in the scripts, along with their output. This can help you track
    down the source of your problems.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 使用**xtrace**调试你的有问题的脚本，显示了脚本中命令的实际执行情况及其输出。这可以帮助你追踪问题的根源。
- en: 'You can use `xtrace` mode in three different ways, which are:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过三种不同的方式使用`xtrace`模式，分别是：
- en: Append `-x` to the shebang line. This works for all shells that we’ve been working
    with. For example, if you’re writing a `bash` script, then the shebang line will
    be `#!/bin/bash -x`. If you’re creating a script where portability matters, you
    can use `#!/bin/sh -x`.
  id: totrans-139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将`-x`追加到shebang行的末尾。这对我们一直在使用的所有shell都有效。例如，如果你正在编写一个`bash`脚本，那么shebang行将是`#!/bin/bash
    -x`。如果你正在创建一个需要可移植性的脚本，你可以使用`#!/bin/sh -x`。
- en: Place a `set -x` command into the script where you want to turn on debugging
    mode.
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将`set -x`命令放入脚本中，确保你想开启调试模式的地方。
- en: Run the `set -x` command from the command-line before you invoke a script.
  id: totrans-141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在调用脚本之前，从命令行运行`set -x`命令。
- en: To demo this, let’s look at the `xdialog-hello2-broken2.sh` script, which has
    the same problem as the `xdialog-hello2-broken.sh` script that you saw in the
    previous section..
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 为了演示这个问题，让我们看看`xdialog-hello2-broken2.sh`脚本，它和你在上一节看到的`xdialog-hello2-broken.sh`脚本有着相同的问题。
- en: '[PRE35]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Here, I placed a `-x` at the end of the shebang line, and then placed a `sleep
    10` line after the `diag=Xdialog` line and the `diag=dialog` line. Now, let’s
    run it.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我将`-x`放置在shebang行的末尾，然后在`diag=Xdialog`行和`diag=dialog`行之后放置了`sleep 10`行。现在，让我们运行它。
- en: '[PRE36]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: You can immediately see how this is even more useful than using `echo` commands.
    The `[[ -n :0 ]]` line is the expansion of the `[[ -n $DISPLAY ]]` test. It shows
    that the `DISPLAY` variable does indeed have an assigned value (`:0`), which means
    that a desktop environment is installed. But, the real key here is the `[[ 0 ==
    0 ]]` line, which is the expansion of the `[[ $? == 0 ]]` test. Invoking `Xdialog`
    from this script requires that `$?` equals 0, which would require that *both*
    of our test conditions return a 0\.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以立即看到，这比使用`echo`命令更有用。`[[ -n :0 ]]`这一行是`[[ -n $DISPLAY ]]`测试的扩展。它表明`DISPLAY`变量确实有一个分配的值（`:0`），这意味着已经安装了桌面环境。但是，这里真正的关键是`[[
    0 == 0 ]]`这一行，它是`[[ $? == 0 ]]`测试的扩展。从这个脚本中调用`Xdialog`要求`$?`等于0，这就需要我们*两个*测试条件都返回0。
- en: This in turn requires that both `Xdialog` and a desktop environment are present.
    But, even though `Xdialog` is not installed on this machine, this script erroneously
    shows that it is, as you see in the `diag=Xdialog` line. So again, the only obvious
    answer is to swap the test conditions, as we did before, and test it again. After
    you do that, the `[[ $? == 0 ]]` will expand to `[[ 1 == 0 ]]`, which is what
    we want to see in this case.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 这就要求`Xdialog`和桌面环境都必须存在。但是，即使`Xdialog`没有安装在这台机器上，这个脚本错误地显示它已经安装了，就像你在`diag=Xdialog`这一行看到的那样。所以，再次强调，唯一明显的答案是交换测试条件，就像之前一样，并重新测试。这样，`[[
    $? == 0 ]]`将扩展为`[[ 1 == 0 ]]`，这是我们在这种情况下希望看到的。
- en: 'If you’re using `#!/usr/bin/env bash` as your shebang line, than appending
    `-x` to the end of the shebang line won’t work. That’s because `env` only recognizes
    one option at a time, which in this case is `bash`. So instead, you’ll need to
    either use `set -x` from the command-line before you run the script, or place
    a `set -x` command inside the script, like this:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你使用`#!/usr/bin/env bash`作为shebang行，那么在shebang行末尾追加`-x`将不起作用。这是因为`env`每次只识别一个选项，在这种情况下是`bash`。因此，你需要在运行脚本之前，或者在脚本中放置一个`set
    -x`命令，就像这样：
- en: '[PRE37]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: If you use `set -x` on the command-line, you can turn debug mode back off by
    doing `set +x`.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在命令行使用`set -x`，你可以通过执行`set +x`来关闭调试模式。
- en: 'If `-x` alone doesn’t show you enough information, you can enable verbose mode
    by adding the `v` option, as you see in `xdialog-hello2-broken4.sh`:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 如果单独使用`-x`没有显示足够的信息，你可以通过添加`v`选项来启用详细模式，就像你在`xdialog-hello2-broken4.sh`中看到的那样：
- en: '[PRE38]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Here’s the output:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 这是输出：
- en: '[PRE39]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: In addition to what we saw before, we now see the entire script echoed back
    at us. We also see that the value of the `diag` variable is `Xdialog`. Since `Xdialog`
    isn’t installed on this machine, the `diag` value should be `dialog`.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 除了我们之前看到的，现在我们看到整个脚本被回显出来。我们还看到`diag`变量的值是`Xdialog`。由于`Xdialog`没有安装在此机器上，因此`diag`的值应该是`dialog`。
- en: 'If you need a permanent record of your debugging for further study, you can
    redirect the `-x` output into a text file. The `-x` output is considered as `stderr`
    output, so you’ll redirect it like so:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你需要对调试过程进行永久记录以便进一步研究，可以将`-x`输出重定向到文本文件中。`-x`的输出被认为是`stderr`输出，因此你可以像这样进行重定向：
- en: '[PRE40]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: When you’re through debugging, be sure to remove the `-x` or set `-x` options
    from your script before you put it into production.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 当你调试完毕后，记得在将脚本投入生产之前，移除`-x`或`set -x`选项。
- en: Okay, let’s move on to our next trick.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，让我们继续下一个技巧。
- en: Checking for Undefined Variables
  id: totrans-160
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 检查未定义变量
- en: 'As I said at the beginning of this chapter, in the *Understanding Common Scripting
    Errors* section, it’s sometimes desirable to define a variable in a script without
    assigning an initial value to it. But, sometimes it isn’t. You can track down
    uninitialized variables by appending a `-u` to the end of your shebang line. In
    `bash` for example, you can use `#!/bin/bash -u`, which will turn this feature
    on for the entire script. Or, you can place a `set -u` command any place in the
    script where you’d like to start checking. For example, let’s look at the `unassigned_var1.sh`
    script, which has variable checking turned off:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我在本章开始时所说的，在 *理解常见脚本错误* 部分，有时在脚本中定义一个变量而不为其赋初值是可取的。但有时也不是。你可以通过在 shebang 行末尾附加
    `-u` 来追踪未初始化的变量。例如，在 `bash` 中，你可以使用 `#!/bin/bash -u`，这会使整个脚本都启用此功能。或者，你可以在脚本中任何你希望开始检查的地方加入
    `set -u` 命令。例如，看看 `unassigned_var1.sh` 脚本，它关闭了变量检查：
- en: '[PRE41]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Here’s the output:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 这是输出结果：
- en: '[PRE42]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'As you see, without the `-u` setting, the script runs to completion. It’s just
    that trying to echo the value of the uninitialized `myvar` just shows us a blank
    space. Next, let’s turn on variable checking by adding the `-u` option, as you
    see in the `unassigned_var2.sh` script:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，没有 `-u` 设置时，脚本会正常执行。只是尝试回显未初始化的 `myvar` 会显示一个空白空间。接下来，让我们通过添加 `-u` 选项来启用变量检查，如在
    `unassigned_var2.sh` 脚本中所见：
- en: '[PRE43]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Let’s see what this does:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看这会有什么结果：
- en: '[PRE44]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: This time the script failed as soon as it saw the uninitialized variable.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 这次，脚本一看到未初始化的变量就失败了。
- en: 'You can set the `-u` option anywhere in the script you like, by using `set
    -u`, as you see here in the `unassigned_var3.sh` script:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在脚本中的任何地方设置 `-u` 选项，通过使用 `set -u`，正如在 `unassigned_var3.sh` 脚本中看到的那样：
- en: '[PRE45]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'So now, I have one uninitialized variable at the top, on line 2\. (Let’s just
    say that for whatever reason, I want this particular variable to be uninitialized.)
    I then turn on variable checking on line 5\. Let’s see how this runs:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我在第 2 行有一个未初始化的变量。（假设出于某种原因，我希望这个特定变量保持未初始化状态。）然后，在第 5 行启用变量检查。让我们看看它是如何运行的：
- en: '[PRE46]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: Before I turn on variable checking, the uninitialized `myvar` just shows us
    a blank space. After I turn on variable checking, I initialized `myvar` with a
    value of `Donnie`, and it prints out normally. But, the uninitialized `myvar2`
    at the end crashes the script.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 在我启用变量检查之前，未初始化的 `myvar` 只是显示一个空白空间。启用变量检查后，我将 `myvar` 初始化为值 `Donnie`，它正常打印出来。但是，未初始化的
    `myvar2` 会导致脚本崩溃。
- en: If you search the web for shell scripting security tutorials, you’ll find several
    that tell you to make either `-u` or `set -u` a permanent part of your scripts.
    The authors of these tutorials say that it enhances the security of your scripts,
    without giving any convincing explanation of why or how. Using `-u` or `set -u`
    is great for debugging, but it should only be used for just that—debugging! So,
    when you’re through debugging your scripts, be sure to remove the `-u` or the
    `set -u` before you place the script into production. Otherwise, your scripts
    could give you some rather unpredictable results.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在网上搜索 shell 脚本安全性教程，你会发现有几篇教程告诉你将 `-u` 或 `set -u` 永久添加到你的脚本中。这些教程的作者表示，这样做能增强脚本的安全性，但并没有给出任何令人信服的解释，说明为什么或如何这样做。使用
    `-u` 或 `set -u` 对于调试很有帮助，但它应该仅限于调试！因此，当你调试完脚本后，一定要在将脚本投入生产前移除 `-u` 或 `set -u`。否则，你的脚本可能会产生一些非常不可预测的结果。
- en: Also, be aware that using `-u` can also help you detect typos in your scripts.
    For example, if you define a variable as `mynum=1`, but accidentally call back
    the value with `$mymum`, the `-u` will detect that `mymum` is an unset variable.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 另外，使用 `-u` 还可以帮助你检测脚本中的拼写错误。例如，如果你定义了一个变量 `mynum=1`，但不小心使用 `$mymum` 来引用它，`-u`
    会检测到 `mymum` 是一个未设置的变量。
- en: That about does it for the discussion of uninitialized variables. Let’s move
    on to our next trick.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 以上就是关于未初始化变量的讨论。接下来我们来看下一个技巧。
- en: Checking for Errors with the -e Option
  id: totrans-178
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 `-e` 选项检查错误
- en: Our next trick is to use either the `-e` shell option or the `set -e` command
    to test our scripts for errors that cause commands within the script to fail.
    Let’s look at the `bad_dir1.sh` script to see how that works.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的下一个技巧是使用 `-e` shell 选项或 `set -e` 命令来测试脚本中的错误，这些错误会导致脚本中的命令失败。让我们看看 `bad_dir1.sh`
    脚本，了解它是如何工作的。
- en: '[PRE47]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: With this, I want to create the `mydir` directory, `cd` into it, and then do
    a file listing. But, my typing isn’t up to what it should be today, so in the
    `cd` line I accidentally typed `mydire`, instead of `mydir`. Let’s see what happens
    when I run it.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这个，我想创建`mydir`目录，进入其中，并执行文件列表命令。但是，我今天打字不太顺，所以下面的`cd`命令我不小心打成了`mydire`，而不是`mydir`。让我们看看运行时会发生什么。
- en: '[PRE48]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: Yeah, this problem is obvious, but that’s okay. That’s because the `-e` option
    does more than just identify the problem. It would cause the script to immediately
    exit if any command fails. Let’s put this option into the `bad_dir2.sh` script
    to see how that works.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 是的，这个问题很明显，但没关系。因为`-e`选项不仅仅是识别问题，它还会导致脚本在任何命令失败时立即退出。让我们把这个选项放到`bad_dir2.sh`脚本中，看看它是怎么工作的。
- en: '[PRE49]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: All I did here was to insert the `-e` option. Now, I’ll delete the `mydir` directory
    that the first script created, and try running this one.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 我在这里所做的只是插入了`-e`选项。现在，我将删除第一个脚本创建的`mydir`目录，然后尝试运行这个脚本。
- en: '[PRE50]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: Using `-e` also works when the failing command is part of a compound command
    structure, as you see in `bad_dir3.sh`.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`-e`在失败的命令是复合命令结构的一部分时也同样有效，就像你在`bad_dir3.sh`中看到的那样。
- en: '[PRE51]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'As before, I’ll delete the `mydir` directory that the previous script created,
    and then run `bad_dir3.sh`, which looks like this:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 和之前一样，我将删除前一个脚本创建的`mydir`目录，然后运行`bad_dir3.sh`，它长这样：
- en: '[PRE52]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: So again, the `-e` stopped this script in its tracks when the `cd` command failed.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 所以再次强调，当`cd`命令失败时，`-e`立刻中止了脚本的执行。
- en: I know what you’re thinking, and I know that that’s a bit creepy. You’re thinking
    that the kinds of errors that `-e` would detect are fairly obvious. That’s because
    with these types of errors, the shell will display an error message that pinpoints
    the problem. So then, why do we need `-e`? Well, think of `-e` and `set -e` as
    more of a safety mechanism than a debugging tool. For example, if the next command
    after trying to `cd` into a non-existent directory is to `rm` all files, then
    allowing the script to run after the `cd` command fails could be disastrous.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 我知道你在想什么，我知道这有点让人毛骨悚然。你在想`-e`会检测到的错误类型应该是相当明显的。因为对于这些类型的错误，shell会显示一个错误信息，明确指出问题所在。那么，为什么我们还需要`-e`呢？其实，可以把`-e`和`set
    -e`当作一种安全机制，而不是调试工具。例如，如果尝试`cd`进入一个不存在的目录后，接下来的命令是`rm`所有文件，那么如果在`cd`命令失败后仍允许脚本继续运行，那可能会造成灾难性的后果。
- en: Okay, I’ve told you the good stuff about `-e` and `set -e`. Now, let me tell
    you some not-so-good stuff.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 好吧，我已经告诉你关于`-e`和`set -e`的好处。现在，让我告诉你一些不那么好的事情。
- en: Understanding the Problems with set -e and -e
  id: totrans-194
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 理解`set -e`和`-e`的问题
- en: Although `-e` and `set -e` can be helpful, they can also cause you headaches.
    Sometimes, they can actually break a script that worked before. Here’s what I
    mean.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管`-e`和`set -e`可以很有帮助，但它们也可能让你头疼。有时候，它们甚至会破坏一个之前正常工作的脚本。以下是我的意思。
- en: The `set -e` and `-e` settings work by detecting if a command in the script
    returns an exit code of something other than 0.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: '`set -e`和`-e`选项的工作原理是检测脚本中的命令是否返回非0的退出代码。'
- en: Remember that an exit code of 0 indicates a successful command execution, and
    a non-0 exit code indicates a failure.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，退出代码为0表示命令执行成功，非0退出代码表示命令执行失败。
- en: 'Sometimes though, you’ll need for some commands in your script to return a
    non-0 exit code in order for the script to work. This makes the operation of `set
    -e` and `-e` unpredictable, at best. For example, take a look at this `set_e_fails1.sh`
    script:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，有时候你需要脚本中的某些命令返回非0的退出代码，以使脚本正常工作。这使得`set -e`和`-e`的操作变得不可预测。举个例子，看看这个`set_e_fails1.sh`脚本：
- en: '[PRE53]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: Note that `let i++` is a bashism that I haven’t yet shown you. You can replace
    it with `i=$(( i + 1 ))` in order to make the script portable to non-`bash` shells.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，`let i++`是一个bash特性，我还没有展示给你。你可以用`i=$(( i + 1 ))`来替代它，以使脚本能够在非`bash`的shell中运行。
- en: 'This creates the `i` variable with a value of 0, increments that value by 1,
    and then prints out the final value of `i`. But, watch what happens with the `-e`
    setting:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 这会创建一个值为0的`i`变量，将其值增加1，然后打印出`i`的最终值。但看看在`-e`设置下会发生什么：
- en: '[PRE54]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'Well, it prints out nothing. Let’s see what happens if I comment out the `set
    -e` command, like so:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 好吧，它什么都没有打印出来。让我们看看如果我把`set -e`命令注释掉，会发生什么：
- en: '[PRE55]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: Let’s run it again.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们再运行一次。
- en: '[PRE56]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'So, the script runs perfectly fine without the `set -e`, but inserting the
    `set -e` breaks it. I know, that’s crazy, right? To help us figure out what’s
    going on, let’s create the `set_e_fails2.sh` script, like so:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，脚本在没有`set -e`的情况下运行完全正常，但插入`set -e`却会导致它出错。我知道，这听起来很疯狂，对吧？为了帮助我们弄清楚发生了什么，下面我们创建`set_e_fails2.sh`脚本，如下所示：
- en: '[PRE57]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'The only difference is that I omitted the `set -e` line, and inserted `echo`
    statements that display the exit code of each command. Now, to run it:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 唯一的区别是，我省略了`set -e`这一行，并插入了`echo`语句来显示每条命令的退出代码。现在，来运行它：
- en: '[PRE58]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'The `Exit code after incrementing i: 1` line shows us the problem. It’s just
    that for some truly bizarre reason that I don’t understand, the `let i++` command
    produces an exit code of 1, even though the command is successful. So in this
    case, using `-e` created a problem, instead of solving one. (Curiously though,
    using the portable `i=$(( i + 1 ))` construct will return exit code 0, which will
    prevent this problem. I have no idea why that is.)'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: '`增量i后的退出代码: 1`这一行显示了问题所在。只是由于某种我无法理解的奇怪原因，`let i++`命令尽管成功执行，却返回了退出代码1。所以在这种情况下，使用`-e`造成了问题，而不是解决问题。（然而，使用便携式的`i=$((
    i + 1 ))`语法会返回退出代码0，这会避免这个问题。我也不知道为什么会这样。）'
- en: I mentioned in the *Checking for Undefined Variables* section that some articles
    you’ll find on the web recommend making either `-u` or `set -u` a permanent part
    of your scripts, in order to enhance security. These authors actually recommend
    making both the `-e`/`set -e` and `-u`/`set -u` a permanent part of your scripts.
    But, as I’ve just demonstrated, `-e`/`set -e` can be rather unpredictable, and
    could cause you more problems than it solves. At any rate, if you do use this
    tool for troubleshooting, be sure to delete it from your scripts before you place
    them into production.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 我在*检查未定义变量*部分提到过，一些网站上的文章建议将`-u`或`set -u`作为脚本的永久部分，以增强安全性。这些作者实际上建议将`-e`/`set
    -e`和`-u`/`set -u`都作为脚本的永久部分。但正如我刚才所展示的，`-e`/`set -e`可能会变得相当不可预测，并且可能会带来更多问题，而非解决问题。无论如何，如果你使用此工具进行故障排除，请确保在将脚本投入生产之前，删除它。
- en: 'Although my personal belief is that `-e` and `set -e` can be useful when used
    with caution, that’s actually a controversial opinion. In the following article,
    you’ll see a lengthy write-up about why you should never, ever use `-e` or `set
    -e`:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管我个人认为`-e`和`set -e`在谨慎使用的情况下是有用的，但这是一个有争议的观点。在以下文章中，你将看到一篇长文，解释为什么你永远不应该使用`-e`或`set
    -e`：
- en: 'BashFAQ105—Greg’s Wiki:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: BashFAQ105—Greg的Wiki：
- en: '[https://mywiki.wooledge.org/BashFAQ/105](https://mywiki.wooledge.org/BashFAQ/105)'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://mywiki.wooledge.org/BashFAQ/105](https://mywiki.wooledge.org/BashFAQ/105)'
- en: This author’s belief is that you would be better served by creating your own
    error checks, rather than relying on `-e`/`set -e`.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 这位作者认为，你最好自己编写错误检查，而不是依赖`-e`/`set -e`。
- en: If you like, give the page a visit, and work through the examples that the author
    provides. The author also provides a link to a page with the counter-argument
    to this, so be sure to check that out as well so that you can decide for yourself.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你愿意，可以访问该页面，并按照作者提供的示例进行操作。作者还提供了一个链接，指向与此相对立的观点页面，记得也去查看，这样你可以自己做出决定。
- en: Okay, let’s move on to our final debugging tool.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，我们继续讲解最后一个调试工具。
- en: Using bash Debugger
  id: totrans-219
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用bash调试器
- en: The **bash Debugger**, which you’ll normally see referred to as **bashdb**,
    allows you to step through a `bash` script, one command at a time. This allows
    you to see what each command in the script is doing before moving on to the next
    command. It’s pretty simple to use, once you get installed.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: '**bash 调试器**，通常被称为**bashdb**，允许你逐行执行`bash`脚本，每次执行一条命令。这样你可以在执行下一条命令之前，查看脚本中的每一条命令到底在做什么。一旦安装好，它的使用非常简单。'
- en: You’ll find a lot of `bashdb` tutorials on the web, but a lot of them are very
    old, and show you an obsolete method for installing `bashdb`. That’s because years
    ago, `bashdb` was included in the repositories of pretty much every Linux distro.
    So, you could install it with your normal package manager as those tutorials showed.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 你会在网上找到很多`bashdb`教程，但其中很多已经很老了，而且展示的是一种过时的安装`bashdb`的方法。这是因为多年前，`bashdb`几乎包含在每个Linux发行版的仓库中。所以，你可以像这些教程所示的那样，使用普通的包管理器进行安装。
- en: Unfortunately, for some strange reason, `bashdb` has been removed from most,
    if not all, Linux repositories. So now, if you want to run `bashdb` on Linux,
    you’ll need to compile it from source code as I’m about to show you.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，由于某些奇怪的原因，`bashdb` 已从大多数（如果不是全部）Linux 仓库中删除了。所以，现在如果你想在 Linux 上运行 `bashdb`，你需要从源代码进行编译，接下来我将向你展示如何操作。
- en: On the other hand, `bashdb` is in the FreeBSD repository and in the Homebrew
    repository for macOS, so you’re all good there.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，`bashdb` 已经包含在 FreeBSD 仓库和 macOS 的 Homebrew 仓库中，所以你在这些系统上没有问题。
- en: Okay, let’s look at installing `bashdb`.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，让我们来看一下如何安装 `bashdb`。
- en: Installing bashdb on Linux
  id: totrans-225
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 在 Linux 上安装 bashdb
- en: As I mentioned above in the info box, you’ll need to install `bashdb` from source
    code. Don’t fret though, because it’s easy.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我在信息框中提到的，你需要从源代码安装 `bashdb`。不过别担心，这很简单。
- en: 1\. You’ll first need to install the `autoconf` and `texinfo` packages from
    your normal distro repository, using your distro’s normal package manager.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 1\. 你需要先通过你常用的发行版包管理器，从正常的发行版仓库中安装 `autoconf` 和 `texinfo` 包。
- en: '2\. Download the `bashdb` source code by doing:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 2\. 通过执行以下命令下载 `bashdb` 源代码：
- en: '[PRE59]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 3\. `cd` into the `bashdb/` directory that the `git` command created.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 3\. 使用 `cd` 命令进入 `git` 命令创建的 `bashdb/` 目录。
- en: '4\. Run the following set of commands to compile and install `bashdb`:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 4\. 运行以下命令集以编译和安装 `bashdb`：
- en: '[PRE60]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: That’s all there is to it.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 就这些了。
- en: Installing bashdb on FreeBSD
  id: totrans-234
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 在 FreeBSD 上安装 bashdb
- en: 'This is even easier. Just do:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 这更简单。只需执行：
- en: '[PRE61]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: Installing on macOS
  id: totrans-237
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 在 macOS 上安装
- en: 'On a Mac with Homebrew installed, just do:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 在安装了 Homebrew 的 Mac 上，只需执行：
- en: '[PRE62]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: Now that `bashdb` is installed, let’s see if we can actually use it.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 现在 `bashdb` 已经安装好了，接下来让我们看看是否能真正使用它。
- en: Debugging a Script with bashdb
  id: totrans-241
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 bashdb 调试脚本
- en: 'Let’s start with a clean, unmodified copy of the original broken `xdialog`
    script, which I’ll call `xdialog-hello2-broken5.sh`, which looks like this:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从一个干净的、未修改的原始损坏 `xdialog` 脚本开始，我将其命名为 `xdialog-hello2-broken5.sh`，内容如下：
- en: '[PRE63]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'As you’ve seen in the *Using xtrace for Debugging* section, the problem is
    that the script won’t properly detect if both `Xdialog` and a desktop display
    are installed. Let’s step through this with `bashdb` to see what it can tell us.
    Begin like so:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你在 *使用 xtrace 进行调试* 部分看到的那样，问题在于脚本无法正确检测 `Xdialog` 和桌面显示器是否已安装。让我们使用 `bashdb`
    一步步调试，看看它能告诉我们什么。开始如下：
- en: '[PRE64]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'This runs the first command in the script, and then dumps us out at the `bashdb`
    command prompt. To run the next command, just enter `step`, like so:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 这将运行脚本中的第一个命令，然后把我们带到 `bashdb` 命令提示符。要运行下一个命令，只需输入 `step`，像这样：
- en: '[PRE65]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'Here, we see the `DISPLAY` variable that’s inside the test construct. Let’s
    examine that variable to see what its value is, by using the `examine` command:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们看到了测试结构内部的 `DISPLAY` 变量。让我们通过使用 `examine` 命令来检查该变量的值：
- en: '[PRE66]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: The `declare -x` part means that `bashdb` is marking the `DISPLAY` variable
    for export to subsequent commands. But, that’s not the important part. What’s
    important is that the `DISPLAY` variable has a value of `:0`, which means that
    the `[[ -n $DISPLAY ]]` test will return a value of 0 to indicate a true condition.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: '`declare -x` 部分意味着 `bashdb` 正在将 `DISPLAY` 变量标记为导出到后续命令。但是，这并不是最重要的部分。重要的是，`DISPLAY`
    变量的值为 `:0`，这意味着 `[[ -n $DISPLAY ]]` 测试将返回值 0，表示条件为真。'
- en: 'Instead of using the `examine DISPLAY` command, you can use the `print $DISPLAY`
    command, like so:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 与其使用 `examine DISPLAY` 命令，你可以使用 `print $DISPLAY` 命令，像这样：
- en: '[PRE67]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: This way, the only thing that shows up is just the actual `DISPLAY` value.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 这样，显示的就只有实际的 `DISPLAY` 值。
- en: 'At this point, we need to put on our thinking caps and ponder what it means
    to have this `DISPLAY` test come before the `$?` test. Well, we’ve already come
    up with that answer when we used the `echo` statement and `xtrace` methods to
    troubleshoot this. It’s just that if we do the `DISPLAY` detection first, the
    `$?` value in the second test will always be 0, even if no `Xdialog` executable
    is detected. But, for the sake of showing you a bit more, let’s say that we haven’t
    figured that out, and need to see more of what the script is doing. To do that,
    enter the series of commands that you see in the next snippet:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们需要动动脑筋，思考将 `DISPLAY` 测试放在 `$?` 测试之前意味着什么。嗯，我们已经在使用 `echo` 语句和 `xtrace`
    方法排查问题时得出了答案。问题是，如果我们先进行 `DISPLAY` 检测，那么第二个测试中的 `$?` 值将始终为 0，即使没有检测到 `Xdialog`
    可执行文件也是如此。但为了让你看到更多内容，假设我们还没有弄明白这一点，且需要查看更多脚本的执行情况。为此，输入你在下一个代码段中看到的一系列命令：
- en: '[PRE68]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: I started this by issuing two `step` commands, which gets me down to where the
    `diag` variable is defined and what its assigned value is. I then issued the `print
    $diag` command, but nothing showed up. Then, I issued another `step` command,
    followed by another `print $diag` command. At that point, I finally see that the
    `diag` variable has the value of `Xdialog`, even though `Xdialog` isn’t installed
    on this workstation.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 我通过执行两个`step`命令开始，带我进入了`diag`变量定义的地方，并查看了它的赋值。接着，我执行了`print $diag`命令，但什么也没有显示。然后，我执行了另一个`step`命令，接着又执行了`print
    $diag`命令。这时，我终于看到`diag`变量的值是`Xdialog`，尽管`Xdialog`并没有安装在这台工作站上。
- en: The clear advantage of using `bashdb` is that I didn’t have to modify the script
    in order to debug it. As you see, I didn’t have to add any `echo` statements to
    obtain the value of the `DISPLAY` and `diag` variables. I also didn’t have to
    add a `sleep` command or comment out the ending `clear` command in order to prevent
    the screen from clearing before I could see the `DISPLAY` value. Obviously, this
    is a big win for `bashdb`.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`bashdb`的明显优势是我不需要修改脚本就能进行调试。如你所见，我不需要添加任何`echo`语句来获取`DISPLAY`和`diag`变量的值。我也不需要添加`sleep`命令或注释掉结尾的`clear`命令，以防在我查看`DISPLAY`值之前屏幕被清空。显然，这对`bashdb`来说是一个巨大的优势。
- en: Of course, you might at times need to find extra information about what you
    can do with `bashdb`. Let’s look at that next.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，有时候你可能需要查找有关如何使用`bashdb`的额外信息。接下来我们就来看这个。
- en: Getting Help with bashdb
  id: totrans-259
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 获取bashdb帮助
- en: 'When you install `bashdb`, a man page will get installed with it. Frankly though,
    it doesn’t tell you much. Fortunately, `bashdb` has a built-in help function that
    you can use any time that you’re at the `bashdb` command-prompt. Just enter the
    `help` command, and you’ll see this:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 当你安装`bashdb`时，系统会安装一份man页面。坦率地说，它告诉你不多。幸运的是，`bashdb`有一个内置的帮助功能，你可以在`bashdb`命令提示符下随时使用。只需输入`help`命令，你就能看到如下内容：
- en: '![](img/B21693_21_02.png)'
  id: totrans-261
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B21693_21_02.png)'
- en: 'Figure 21.2: The bashdb help display'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 图21.2：bashdb帮助显示
- en: 'This shows the list of available `bashdb` commands. To see how to use a particular
    command, just enter `help` followed by the command name, like so:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 这显示了可用的`bashdb`命令列表。要查看如何使用某个特定命令，只需输入`help`，后面跟上命令名称，如下所示：
- en: '![](img/B21693_21_03.png)'
  id: totrans-264
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B21693_21_03.png)'
- en: 'Figure 21.3: Getting help for the break command'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 图21.3：获取`break`命令的帮助
- en: That about wraps things up for this chapter. Let’s summarize and move on.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 本章内容差不多到此为止。让我们总结一下，然后继续前进。
- en: Summary
  id: totrans-267
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we covered some cool tips and tricks that can help you troubleshoot
    your code. We began by looking at some common shell scripting errors, and showed
    how to find them in a broken script. We then looked at some common debugging tools
    and techniques. For the `-u` and `-e` shell options, I showed you both the pros
    and the cons of using them. Finally, I showed you how to install and use `bashdb`.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中，我们介绍了一些有用的技巧和窍门，帮助你排查代码中的问题。我们首先查看了几种常见的shell脚本错误，并展示了如何在损坏的脚本中找到它们。接着，我们介绍了一些常见的调试工具和技术。对于`-u`和`-e`
    shell选项，我向你展示了使用它们的利弊。最后，我向你展示了如何安装和使用`bashdb`。
- en: In the next chapter, we’ll take a brief look at scripting with `zsh`. I’ll see
    you there.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章，我们将简要介绍如何使用`zsh`进行脚本编写。我在那里等你。
- en: Questions
  id: totrans-270
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: This time, instead of presenting you with questions to answer, I’ll present
    you with some buggy shell scripts. Try running them to observe the errors, and
    then try to debug them. Can you debug them? Sure you can. I have faith in you.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 这次，我不会给你提供需要回答的问题，而是给你一些有bug的shell脚本。尝试运行它们，观察错误，然后尝试调试它们。你能调试它们吗？当然能，我相信你。
- en: 'We’ll start with the `bug1.sh` script:'
  id: totrans-272
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将从`bug1.sh`脚本开始：
- en: '[PRE69]'
  id: totrans-273
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'Here’s the `bug2.sh` script:'
  id: totrans-274
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这是`bug2.sh`脚本：
- en: '[PRE70]'
  id: totrans-275
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'Now, for `bug3.sh`:'
  id: totrans-276
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，来看一下`bug3.sh`：
- en: '[PRE71]'
  id: totrans-277
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'Here’s the fourth and final, `bug4.sh`:'
  id: totrans-278
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这是第四个也是最后一个，`bug4.sh`：
- en: '[PRE72]'
  id: totrans-279
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE72]'
- en: Further Reading
  id: totrans-280
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: 'Writing Shell Scripts—Lesson 9: Stay Out of Trouble: [http://linuxcommand.org/lc3_wss0090.php](http://linuxcommand.org/lc3_wss0090.php)'
  id: totrans-281
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编写Shell脚本——第9课：避免麻烦：[http://linuxcommand.org/lc3_wss0090.php](http://linuxcommand.org/lc3_wss0090.php)
- en: 'How to Debug Bash Scripts: [https://linuxconfig.org/how-to-debug-bash-scripts](https://linuxconfig.org/how-to-debug-bash-scripts)'
  id: totrans-282
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何调试Bash脚本：[https://linuxconfig.org/how-to-debug-bash-scripts](https://linuxconfig.org/how-to-debug-bash-scripts)
- en: '15 Essential Bash Debugging Techniques and Tools: [https://www.fosslinux.com/104144/essential-bash-debugging-techniques-and-tools.htm](https://www.fosslinux.com/104144/essential-bash-debugging-techniques-and-tools.htm)'
  id: totrans-283
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '15 个必备的 Bash 调试技巧和工具: [https://www.fosslinux.com/104144/essential-bash-debugging-techniques-and-tools.htm](https://www.fosslinux.com/104144/essential-bash-debugging-techniques-and-tools.htm)'
- en: 'Debugging a Bash Script: [https://www.baeldung.com/linux/debug-bash-script](https://www.baeldung.com/linux/debug-bash-script)'
  id: totrans-284
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '调试 Bash 脚本: [https://www.baeldung.com/linux/debug-bash-script](https://www.baeldung.com/linux/debug-bash-script)'
- en: '5 Simple Steps On How to Debug a Bash Shell Script: [https://www.shell-tips.com/bash/debug-script/#gsc.tab=0](https://www.shell-tips.com/bash/debug-script/#gsc.tab=0)'
  id: totrans-285
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '5 个简单步骤，学会如何调试 Bash Shell 脚本: [https://www.shell-tips.com/bash/debug-script/#gsc.tab=0](https://www.shell-tips.com/bash/debug-script/#gsc.tab=0)'
- en: 'Filenames and Pathnames in Shell: How to do it Correctly:'
  id: totrans-286
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Shell 中的文件名和路径名：如何正确处理：
- en: '[https://dwheeler.com/essays/filenames-in-shell.html](https://dwheeler.com/essays/filenames-in-shell.html)'
  id: totrans-287
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://dwheeler.com/essays/filenames-in-shell.html](https://dwheeler.com/essays/filenames-in-shell.html)'
- en: 'Common Shell Script Mistakes:'
  id: totrans-288
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '常见的 Shell 脚本错误:'
- en: '[https://www.pixelbeat.org/programming/shell_script_mistakes.html](https://www.pixelbeat.org/programming/shell_script_mistakes.html)'
  id: totrans-289
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://www.pixelbeat.org/programming/shell_script_mistakes.html](https://www.pixelbeat.org/programming/shell_script_mistakes.html)'
- en: 'BashPitfalls:'
  id: totrans-290
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'BashPitfalls:'
- en: '[http://mywiki.wooledge.org/BashPitfalls](http://mywiki.wooledge.org/BashPitfalls
    )'
  id: totrans-291
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[http://mywiki.wooledge.org/BashPitfalls](http://mywiki.wooledge.org/BashPitfalls
    )'
- en: 'Debugging your shell scripts with bashdb: [https://www.linux.com/news/debug-your-shell-scripts-bashdb/](https://www.linux.com/news/debug-your-shell-scripts-bashdb/)'
  id: totrans-292
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '使用 bashdb 调试您的 shell 脚本: [https://www.linux.com/news/debug-your-shell-scripts-bashdb/](https://www.linux.com/news/debug-your-shell-scripts-bashdb/)'
- en: 'Debugging bash scripts with the bashdb debugger: [https://dafoster.net/articles/2023/02/22/debugging-bash-scripts-with-the-bashdb-debugger/](https://dafoster.net/articles/2023/02/22/debugging-bash-scripts-with-the-bashdb-debugger/)'
  id: totrans-293
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '使用 bashdb 调试器调试 bash 脚本: [https://dafoster.net/articles/2023/02/22/debugging-bash-scripts-with-the-bashdb-debugger/](https://dafoster.net/articles/2023/02/22/debugging-bash-scripts-with-the-bashdb-debugger/)'
- en: 'Using BashDB to Debug Your Shell Scripts—YouTube: [https://www.youtube.com/watch?v=jbOQJDSTksA](https://www.youtube.com/watch?v=jbOQJDSTksA)'
  id: totrans-294
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '使用 BashDB 调试您的 Shell 脚本—YouTube: [https://www.youtube.com/watch?v=jbOQJDSTksA](https://www.youtube.com/watch?v=jbOQJDSTksA)'
- en: 'BASH Debugger documentation: [https://bashdb.sourceforge.net/bashdb.html](https://bashdb.sourceforge.net/bashdb.html)'
  id: totrans-295
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'BASH 调试器文档: [https://bashdb.sourceforge.net/bashdb.html](https://bashdb.sourceforge.net/bashdb.html)'
- en: 'The Bash Trap Trap: [https://medium.com/@dirk.avery/the-bash-trap-trap-ce6083f36700](https://medium.com/@dirk.avery/the-bash-trap-trap-ce6083f36700)'
  id: totrans-296
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'Bash 陷阱陷阱: [https://medium.com/@dirk.avery/the-bash-trap-trap-ce6083f36700](https://medium.com/@dirk.avery/the-bash-trap-trap-ce6083f36700)'
- en: Answers
  id: totrans-297
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 答案
- en: In the `if` statement, you need to insert a blank space between the `[` and
    the `$a`.
  id: totrans-298
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `if` 语句中，您需要在 `[` 和 `$a` 之间插入一个空格。
- en: You need to place a `done` statement after the `echo $i` statement.
  id: totrans-299
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `echo $i` 语句后面需要放置一个 `done` 语句。
- en: There are a couple of problems with this script. First, the regular expression
    is set up wrong, which causes you to get either no or incorrect output from this
    script. Instead of
  id: totrans-300
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这个脚本有几个问题。首先，正则表达式设置错误，导致您无法从此脚本中得到任何或正确的输出。而不是
- en: '`[a-z]*.sh`, it should be `[a-z].sh`. (The `*` actually isn’t needed for this.)'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: '`[a-z]*.sh`，应该是 `[a-z].sh`。（对于这种情况，实际上 `*` 是不需要的。）'
- en: You can review the concept of regular expressions in *Chapter 9—Filtering Text
    with grep, sed, and Regular Expressions*.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以查阅《第 9 章——使用 grep、sed 和正则表达式过滤文本》中关于正则表达式的概念。
- en: There’s also the fact this regular expression isn’t doing much for us. Unless
    you have scripts with filenames that consist of nothing but either digits or upper-case
    characters, this `grep` command is going to show you all of the scripts in your
    directory. So, you could probably just omit the `grep` command altogether, and
    go with a simple `ls *.sh` command.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一个事实是，这个正则表达式并没有对我们产生太大的帮助。除非您的脚本文件名仅由数字或大写字符组成，否则这个 `grep` 命令将显示目录中的所有脚本。因此，您可能可以完全省略
    `grep` 命令，并使用简单的 `ls *.sh` 命令。
- en: 'Finally, in the `echo` statement, you need to surround the variable with a
    pair of double quotes, like this:'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，在 `echo` 语句中，您需要用一对双引号括起变量，像这样：
- en: '[PRE73]'
  id: totrans-305
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: This will prevent problems with filenames that have blank spaces in them.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 这将防止文件名中包含空格时出现问题。
- en: 'This script is supposed to take values from the first and third field of the
    `sample.data` file that the script created, and add them together. The values
    of the first and third fields are 1 and 3, so the sum of the two should be 4\.
    However, here’s how it looks when you run it:'
  id: totrans-307
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这个脚本应该从脚本创建的`sample.data`文件中获取第一列和第三列的值，并将它们相加。第一列和第三列的值分别是1和3，因此它们的和应该是4。然而，当你运行它时，结果如下：
- en: '[PRE74]'
  id: totrans-308
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE74]'
- en: The problem is that the `cut` command on line 3 is piping its output into the
    `read` command. The problem with that is that the `read` command is built into
    the shell, instead of having its own executable file.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 问题在于，第三行的`cut`命令将输出传递给了`read`命令。问题在于，`read`命令是内建在shell中的，而不是拥有自己可执行文件的命令。
- en: That’s significant, because you can only pipe output of one command into a command
    that has its own executable. So, you can’t pipe output into a command that’s a
    shell builtin.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 这很重要，因为你只能将一个命令的输出传递给一个有自己可执行文件的命令。因此，你不能将输出传递给一个内建命令。
- en: 'Instead of using a pipe, you can instead send the first and third field values
    to the `tmp.data` file, and then use the input redirector to obtain the input
    from the `tmp.data` file, as you see here in the `bug5.sh` script:'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以不使用管道，而是将第一列和第三列的值发送到`tmp.data`文件中，然后使用输入重定向从`tmp.data`文件中获取输入，就像你在`bug5.sh`脚本中看到的那样：
- en: '[PRE75]'
  id: totrans-312
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: 'Another option would be to use a *here* document, as you see in the `bug6.sh`
    script:'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个选项是使用*here*文档，正如你在`bug6.sh`脚本中看到的那样：
- en: '[PRE76]'
  id: totrans-314
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: 'Either way, you’ll now see the correct results:'
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 无论如何，你现在会看到正确的结果：
- en: '[PRE77]'
  id: totrans-316
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: Join our community on Discord!
  id: totrans-317
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 加入我们的Discord社区！
- en: Read this book alongside other users, Linux experts, and the author himself.
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 读这本书时，可以与其他用户、Linux专家和作者本人一起学习。
- en: Ask questions, provide solutions to other readers, chat with the author via
    Ask Me Anything sessions, and much more. Scan the QR code or visit the link to
    join the community.
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 提问，给其他读者提供解决方案，通过“问我任何问题”环节与作者交流，等等。扫描二维码或访问链接加入社区。
- en: '[https://packt.link/SecNet](https://packt.link/SecNet)'
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://packt.link/SecNet](https://packt.link/SecNet)'
- en: '![](img/QR_Code10596186092701843.png)'
  id: totrans-321
  prefs: []
  type: TYPE_IMG
  zh: '![](img/QR_Code10596186092701843.png)'
