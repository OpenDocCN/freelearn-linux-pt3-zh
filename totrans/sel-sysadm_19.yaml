- en: '*Chapter 16*: Developing Policies with SELinux CIL'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第16章*：使用 SELinux CIL 开发策略'
- en: While the reference policy is the most frequently used language and development
    style for SELinux policies, the **Common Intermediate Language** (**CIL**) is
    a powerful, but more low-level language construct to use to develop SELinux policies.
    Low-level as it might be though, it is still very much readable and well supported,
    as SELinux tools will use CIL under the hood when using other languages.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然参考策略是 SELinux 策略中最常用的语言和开发风格，但 **通用中间语言** (**CIL**) 是一个功能强大但更低级的语言结构，可以用于开发
    SELinux 策略。尽管它比较低级，但它仍然非常易读，并且得到了良好的支持，因为 SELinux 工具在使用其他语言时会在后台使用 CIL。
- en: Since CIL is the main language used, we know it can be used to build entire
    policies. Sadly, there are no supporting constructs available for developers to
    use, unlike the reference policy. However, we can still learn how to customize
    the current policy, creating specific definitions that are not possible with the
    more common reference policy, and even build a complete application policy if
    we choose.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 CIL 是主要使用的语言，我们知道它可以用于构建整个策略。遗憾的是，与参考策略不同，开发人员没有可以使用的支持构造。然而，我们仍然可以学习如何定制当前的策略，创建参考策略无法实现的特定定义，甚至如果我们选择的话，构建一个完整的应用程序策略。
- en: 'In this chapter, we''re going to cover the following main topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将讨论以下主要内容：
- en: Introducing CIL
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 介绍 CIL
- en: Creating fine-grained definitions
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建细粒度定义
- en: Building complete application policies
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构建完整的应用程序策略
- en: Technical requirements
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'Check out the following video to see the Code in Action: [https://bit.ly/3dLYP2Q](https://bit.ly/3dLYP2Q)'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 查看以下视频，查看代码实际运行：[https://bit.ly/3dLYP2Q](https://bit.ly/3dLYP2Q)
- en: Introducing CIL
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍 CIL
- en: CIL has been designed to be the main language to have policies built in, and
    is the lowest readable format. After CIL, the SELinux code is transformed in binary
    to send off to the Linux kernel (and SELinux subsystem) for loading in memory.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: CIL 的设计目的是成为构建策略的主要语言，并且是最低级的可读格式。在 CIL 之后，SELinux 代码会被转换为二进制格式，以便发送到 Linux
    内核（和 SELinux 子系统）以加载到内存中。
- en: Administrators might be inclined to think that the binary files, generated when
    building a SELinux policy module using the reference policy method, are the final
    binaries. However, as we've seen in [*Chapter 1*](B16276_01_Final_VK.xhtml#_idTextAnchor018),
    *Fundamental SELinux Concepts*, the `semodule` command converts and translates
    this into CIL before building the final format.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 管理员可能倾向于认为，在使用参考策略方法构建 SELinux 策略模块时生成的二进制文件就是最终的二进制文件。然而，正如我们在 [*第1章*](B16276_01_Final_VK.xhtml#_idTextAnchor018)《基础
    SELinux 概念》中看到的那样，`semodule` 命令会在构建最终格式之前将其转换并翻译成 CIL。
- en: Let's see how these translations work and what we can learn from them.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看这些翻译是如何工作的，以及我们可以从中学到什么。
- en: Translating .pp files to CIL
  id: totrans-13
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将 .pp 文件转换为 CIL
- en: When a non-CIL SELinux policy module is loaded, the `semodule` command is designed
    to first consider the module as an unknown format, and extract the `.pp` files
    are supported as an HLL.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 当加载一个非 CIL 的 SELinux 策略模块时，`semodule` 命令会首先将该模块视为一种未知格式，并提取 `.pp` 文件，支持作为高级语言（HLL）。
- en: 'As the HLL format of the SELinux policy modules built by reference policy (or
    the other classic SELinux development) is the same as the module generated, this
    phase often just involves creating a copy. We can see this when we compare an
    HLL file with the original:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 由于使用参考策略（或其他经典 SELinux 开发）构建的 SELinux 策略模块的高级语言（HLL）格式与生成的模块相同，因此此阶段通常只是涉及创建一个副本。我们可以通过将一个
    HLL 文件与原始文件进行比较来看到这一点：
- en: '[PRE0]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Once it has converted or extracted the data, `semodule` will convert it to CIL
    code. For each supported HLL, a convertor is available in `/usr/libexec/selinux/hll`.
    Currently, only the `pp` command is available, which is used to convert this older
    style into CIL.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦 `semodule` 转换或提取了数据，它将把数据转换为 CIL 代码。对于每种支持的高级语言（HLL），都可以在 `/usr/libexec/selinux/hll`
    中找到相应的转换器。目前，只有 `pp` 命令可用，用于将这种旧的风格转换为 CIL。
- en: 'Let''s see this in action:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看它是如何工作的：
- en: '[PRE1]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: So, in essence, when we are developing reference policy style modules, they
    will be converted into CIL anyway. The resulting CIL code, however, does not have
    any facilitating constructions inside. For instance, all permissions are expanded,
    and all interactions with other resources or types outside of the SELinux policy
    module are listed as well. There are no longer any supporting macros or interfaces.
    In the *Building complete application policies* section, we'll see that CIL does
    support abstractions, so the current observation is only due to the translation
    that the `pp` command performs.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，从本质上讲，当我们开发参考策略风格的模块时，它们无论如何都会被转换为 CIL。然而，生成的 CIL 代码内部并没有任何辅助的构造。例如，所有权限都会展开，并且与
    SELinux 策略模块外部其他资源或类型的所有交互也会列出。那里不再有任何支持宏或接口。在 *构建完整的应用程序策略* 部分，我们将看到 CIL 确实支持抽象，因此当前的观察仅仅是由于
    `pp` 命令执行的转换所致。
- en: Understanding CIL syntax
  id: totrans-21
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 理解 CIL 语法
- en: When we develop CIL, the most obvious observation is that it likes brackets.
    CIL uses S-expression syntax, popularized by Lisp, which results in tree-structured
    data. The first identifier in an expression that tells CIL what the construction
    is about.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开发 CIL 时，最明显的观察是它喜欢括号。CIL 使用 S 表达式语法，这种语法由 Lisp 推广，使得数据呈树状结构。表达式中的第一个标识符告诉
    CIL 该构造是关于什么的。
- en: 'Let''s take a look at the last statement we received when converting the `pgpool.pp`
    binary into CIL, now formatted for convenience:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看一下我们在将 `pgpool.pp` 二进制文件转换为 CIL 时收到的最后一条语句，现在为方便起见已格式化：
- en: '[PRE2]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'If we look at this statement in detail, we can deduce the following:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们仔细查看此语句，我们可以推断出以下内容：
- en: 'We have a `filecon` statement, which takes three arguments: the path expression,
    the type of resources to which it applies, and the SELinux context to associate
    with it.'
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们有一个 `filecon` 语句，它接受三个参数：路径表达式、适用的资源类型，以及要与之关联的 SELinux 上下文。
- en: 'The SELinux context has four fields associated with it: the SELinux user, the
    SELinux role, the SELinux type, and the SELinux sensitivity range.'
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: SELinux 上下文有四个相关字段：SELinux 用户、SELinux 角色、SELinux 类型和 SELinux 敏感度范围。
- en: The SELinux sensitivity range has two values, a low-end and a high-end value.
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: SELinux 敏感度范围有两个值：低端值和高端值。
- en: 'This statement is equivalent to what the reference policy would define in the
    file context part of the policy module (the file with the `.fc` suffix) like so:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 这条语句等同于参考策略在策略模块的文件上下文部分（带 `.fc` 后缀的文件）中定义的内容，如下所示：
- en: '[PRE3]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Luckily, we do not need to seek and interpret the code just to understand and
    see what is going on. The SELinux project has extensive CIL documentation available,
    explaining how the language works and what it all supports. The information is
    available at [https://github.com/SELinuxProject/selinux/tree/master/secilc/docs](https://github.com/SELinuxProject/selinux/tree/master/secilc/docs).
    Keep in mind though that CIL policy development is still in its infancy, so coverage
    of the CIL constructs that are not used by the HLL conversion mechanics is very
    low.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，我们不需要为了理解和查看发生了什么而去查找和解释代码。SELinux 项目提供了广泛的 CIL 文档，解释了该语言的工作原理及其所支持的内容。相关信息可以在
    [https://github.com/SELinuxProject/selinux/tree/master/secilc/docs](https://github.com/SELinuxProject/selinux/tree/master/secilc/docs)
    查阅。不过需要注意的是，CIL 策略开发仍处于初期阶段，因此 HLL 转换机制未使用的 CIL 构造的覆盖率非常低。
- en: Let's now see what we can do with CIL.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们来看看如何使用 CIL。
- en: Creating fine-grained definitions
  id: totrans-33
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建细粒度的定义
- en: Throughout this book, most small SELinux policy adjustments have been made using
    CIL. These are small, fine-grained definitions that require little development
    effort, and have the benefit of being directly loadable.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书中，大多数小型 SELinux 策略调整都是使用 CIL 完成的。这些是小型、细粒度的定义，开发工作量很小，且具有直接加载的优点。
- en: Depending on roles or types
  id: totrans-35
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 根据角色或类型
- en: The CIL language requires some order in how types or roles are linked in the
    policy. Sometimes, when we develop CIL policies, the order of the types might
    not be addressed properly.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: CIL 语言要求在策略中如何链接类型或角色有一定的顺序。有时候，在开发 CIL 策略时，类型的顺序可能没有得到正确处理。
- en: To work around this issue, a default attribute called `cil_gen_require` is used.
    When types or roles are assigned to the `cil_gen_require` attribute, they are
    automatically linked correctly in the policy. This is not a CIL requirement though,
    but a convention that the SELinux utilities use.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 为了绕过这个问题，使用了一个默认属性 `cil_gen_require`。当类型或角色被分配给 `cil_gen_require` 属性时，它们会在策略中自动正确链接。然而，这并不是
    CIL 的要求，而是 SELinux 工具使用的一种约定。
- en: 'The attribute actually exists twice, once as a type attribute and once as a
    role attribute. They might have the same name, but are two different attributes:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 这个属性实际上存在两次，一次作为类型属性，一次作为角色属性。它们可能有相同的名称，但是是两个不同的属性：
- en: '[PRE4]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The functions used, `roleattributeset` and `typeattributeset`, assign the second
    argument (which is the attribute name) to the third argument (which is the role
    or type). Roles or types can be attributes themselves, as shown for the `direct_run_init`
    attribute.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 使用的函数 `roleattributeset` 和 `typeattributeset`，将第二个参数（即属性名称）分配给第三个参数（即角色或类型）。角色或类型本身可以是属性，就像
    `direct_run_init` 属性所示。
- en: For developers, it is recommended to always have the types or roles that you
    are going to use made part of the `cil_gen_require` attribute, and to use attributes
    as much as possible to simplify development activities. Rather than granting all
    possible `allow` rules to each and every domain that can interact with your policy
    resources, grant them to an attribute, and then assign this attribute to the domains.
    This creates a much smaller policy and is easier to maintain.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 对于开发人员来说，建议始终将要使用的类型或角色作为 `cil_gen_require` 属性的一部分，并尽可能使用属性来简化开发活动。与其为每个可能与您的策略资源交互的域授予所有可能的
    `allow` 规则，不如将它们授予一个属性，然后将此属性分配给域。这样可以创建一个更小的策略，并且更容易维护。
- en: Defining a new port type
  id: totrans-42
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 定义一个新的端口类型
- en: When more intricate SELinux policies are developed, there are a few settings
    that we cannot add in a SELinux module—at least not when using the traditional
    or reference policy style coding. When we want to use these, we need to rebuild
    the entire policy and make the adjustments in the so-called base policy; the main
    and first policy loaded before the modules are added. This, however, requires
    access to the full SELinux policy sources and a process to use them (as you will
    overwrite the Linux distribution's SELinux policy and should make sure that any
    system update does not overwrite your policy again).
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 当开发更复杂的 SELinux 策略时，有一些设置我们不能在 SELinux 模块中添加，至少在使用传统或参考策略样式编码时不能添加。当我们想要使用这些设置时，我们需要重建整个策略并在所谓的基本策略中进行调整；这是加载模块之前加载的主要策略。然而，这需要访问完整的
    SELinux 策略源代码，并使用一个过程来使用它们（因为您将覆盖 Linux 发行版的 SELinux 策略，应确保任何系统更新不会再次覆盖您的策略）。
- en: One way to establish whether a statement is supported in a SELinux module, besides
    just testing it out, is to look at the online documentation. As an example, let's
    take the port declaration statement `portcon`, which is part of the network-oriented
    statements. This statement is documented on [https://selinuxproject.org/page/NetworkStatements](https://selinuxproject.org/page/NetworkStatements),
    where we can see that `portcon` is not valid in a module policy, nor can it be
    toggled through a SELinux Boolean.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 除了简单测试之外，确定一个语句是否在 SELinux 模块中受支持的另一种方法是查看在线文档。例如，让我们看看端口声明语句 `portcon`，它是网络导向语句的一部分。在
    [https://selinuxproject.org/page/NetworkStatements](https://selinuxproject.org/page/NetworkStatements)
    上有文档说明，我们可以看到 `portcon` 在模块策略中不是有效的，也不能通过 SELinux 布尔值进行切换。
- en: 'Luckily, this is not the case when using CIL. Let''s create a custom port type,
    for example, `pgpool_port_t`, and map it to a free port, say, TCP port `50123`:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，在使用 CIL 时情况并非如此。例如，让我们创建一个自定义端口类型，`pgpool_port_t`，并将其映射到一个空闲端口，比如 TCP 端口
    `50123`：
- en: '[PRE5]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Before we load the policy, we can clearly see that this port is not an assigned
    one:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 在加载策略之前，我们可以清楚地看到这个端口没有被分配：
- en: '[PRE6]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'As we''ve seen throughout this book, we can load this policy file immediately,
    without having to build or compile it:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在整本书中看到的，我们可以立即加载这个策略文件，而不需要构建或编译它：
- en: '[PRE7]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'After loading, the type is assigned to the port, and we can use it to fine-tune
    our SELinux policies:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 加载后，将类型分配给端口，我们可以使用它来优化我们的 SELinux 策略：
- en: '[PRE8]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Many of the constraints that policy developers had when using the traditional
    SELinux style development no longer apply to CIL. As the SELinux utilities convert
    all high-level constructs to CIL, it is possible that SELinux developers might
    remove these constraints altogether, although this has to be carefully assessed
    to make sure no unwanted side effects arise.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用传统的 SELinux 风格开发时，许多策略开发者遇到的约束条件在使用 CIL 时不再适用。由于 SELinux 工具将所有高级结构转换为 CIL，SELinux
    开发人员可能会完全移除这些约束，尽管这必须经过仔细评估，以确保不会出现意外的副作用。
- en: Adding constraints to the policy
  id: totrans-54
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 添加策略的约束条件：
- en: Another area that was not accessible for regular policy developers was to add
    constraints to the policy. Constraints limit actions based on the entire SELinux
    context (and not just types), and they are the closest thing we can find to negating
    existing rules.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个对于普通策略开发者来说不可访问的领域是向策略中添加约束。约束基于整个 SELinux 上下文（而不仅仅是类型）来限制操作，它们是我们能够找到的最接近否定现有规则的机制。
- en: Important note
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: We do not recommend adding constraints to an existing policy just to work around
    rules that we don't like. Constraints are not visible in regular policy queries,
    as with `sesearch`. Administrators might be very confused when `sesearch` indicates
    that an action is allowed while the system is refusing to allow it.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不建议仅仅为了绕过不喜欢的规则而向现有策略中添加约束。约束在常规的策略查询中不可见，比如在 `sesearch` 中。管理员可能会非常困惑，当 `sesearch`
    表明某个操作是允许的，但系统却拒绝执行该操作。
- en: With CIL, we can add constraints to a live policy to do exactly that. Keep in
    mind though that constraints don't actually allow anything – they merely put limits
    on what the SELinux subsystem will see as a valid action. A constraint statement
    that supports reading any possible type does not actually allow this, as there
    still need to be type enforcement rules in place to actually allow these actions.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 CIL，我们可以向实时策略中添加约束，做到这一点。但请记住，约束本身并不实际允许任何操作 —— 它们仅仅是限制 SELinux 子系统认为是有效操作的范围。一个支持读取所有可能类型的约束语句并不意味着它实际允许此操作，因为仍然需要有类型强制规则来实际允许这些操作。
- en: 'For instance, if we want to remove the `staff_t` domain''s ability to read
    the `/etc/passwd` file (which has the SELinux type, `passwd_file_t`), then we
    can add in a constraint that supports the reading of all possible types, unless
    the source domain is `staff_t`, in which case we support the reading of all possible
    types except `passwd_file_t`:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果我们想要移除 `staff_t` 域读取 `/etc/passwd` 文件（该文件具有 SELinux 类型 `passwd_file_t`）的能力，我们可以添加一个支持读取所有可能类型的约束，除非源域是
    `staff_t`，在这种情况下，我们支持读取所有可能类型，除了 `passwd_file_t`：
- en: '[PRE9]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Once loaded, we can confirm that the constraint is active:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 加载后，我们可以确认约束已经生效：
- en: '[PRE10]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'And indeed, trying to read the `passwd` file is prohibited:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 而实际上，尝试读取 `passwd` 文件是被禁止的：
- en: '[PRE11]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'To show how the use of constraints is confusing for administrators, let''s
    see what `sesearch` has to say on this:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 为了展示约束对管理员的困扰，我们来看一下 `sesearch` 对此有什么说法：
- en: '[PRE12]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: So, while the policy has two rules that would allow it (one for the `nsswitch_domain`
    attribute, and one explicitly for the `staff_t` domain), the constraint has limited
    this action, but this is not obvious from the `sesearch` output.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，尽管策略中有两个规则允许此操作（一个针对 `nsswitch_domain` 属性，另一个明确针对 `staff_t` 域），约束已限制了该操作，但从
    `sesearch` 输出中并不明显。
- en: Building complete application policies
  id: totrans-68
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建完整的应用策略
- en: We can build complete application policies with CIL as well. However, keep in
    mind that there are no interfaces or support macros out there that we can use
    to rapidly develop policies. Furthermore, there are no templates or suchlike available
    to jumpstart such initiatives.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以使用 CIL 构建完整的应用策略。然而，请记住，目前没有现成的接口或支持宏可以快速开发策略。此外，也没有可用的模板或类似工具来启动这些工作。
- en: But that shouldn't stop us, and it will allow us to show a few more details
    of the CIL language. We will also see that the CIL language does support interface
    constructs (they are even recommended), but the community has not yet fully embraced
    it through a reference policy-like project.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 但这不应该阻止我们，这将让我们展示更多 CIL 语言的细节。我们还会看到，CIL 语言确实支持接口构造（它们甚至被推荐使用），但社区尚未通过类似参考策略的项目完全接受它。
- en: Using namespaces
  id: totrans-71
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用命名空间
- en: The CIL language supports namespaces, which allows for a higher flexibility
    in developing policies. The generated CIL policies always use the main, global
    namespace, so we will not find examples of namespaces in the generated policies.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: CIL 语言支持命名空间，这使得在开发策略时具有更高的灵活性。生成的 CIL 策略始终使用主全局命名空间，因此在生成的策略中我们不会找到命名空间的示例。
- en: 'We can, however, show how this works easily. Let''s create a skeleton file
    that will contain our CIL-developed `pgpool` policy:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，我们可以轻松地展示它是如何工作的。让我们创建一个骨架文件，里面包含我们用 CIL 开发的 `pgpool` 策略：
- en: '[PRE13]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The namespace created in the preceding code is the `pgpool` namespace, identified
    through the `block` statement. Namespaces in CIL are hierarchical. If we want,
    we could create a namespace within `pgpool` by nesting another `block` statement
    within.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码中创建的命名空间是`pgpool`命名空间，通过`block`语句标识。在CIL中，命名空间是层次结构的。如果需要，我们可以通过在`block`语句内嵌套另一个`block`语句，在`pgpool`中创建一个新的命名空间。
- en: When we encounter namespaces in general constructions, we need to use the dot
    separator. In the example, we have defined a type called domain inside the `pgpool`
    namespace. If we would want to query it later through `sesearch`, the full name
    would be `pgpool.domain` (which would have the same purpose as the `pgpool_t`
    name in a more classically developed policy).
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们在一般结构中遇到命名空间时，需要使用点分隔符。在示例中，我们在`pgpool`命名空间中定义了一个名为`domain`的类型。如果以后想通过`sesearch`查询它，完整的名称将是`pgpool.domain`（这与在更传统开发的策略中使用的`pgpool_t`名称有相同的作用）。
- en: Informational note
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 说明性注释
- en: In subsequent code listings of the policy, we will only show the added and most
    relevant statements rather than including all previously added statements. Without
    supporting interfaces (which CIL calls macros), the policy file will quickly become
    quite large, which does not aid readability. By focusing on the relevant and added
    statements, the development pattern for CIL policies is easier to explain.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 在后续的策略代码中，我们将只显示添加的最相关语句，而不是包括所有先前添加的语句。如果没有支持的接口（CIL称之为宏），策略文件将迅速变得相当庞大，这对可读性没有帮助。通过集中展示相关和新增的语句，CIL策略的开发模式更容易解释。
- en: 'As the main policy has all objects within the global namespace, we will need
    to refer explicitly to this global namespace. This is done by prefixing the name
    with a dot. For instance, if we want to assign the `pgpool.domain` type to the
    `system_r` role, our policy needs to be adjusted with the following:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 由于主策略中的所有对象都位于全局命名空间中，我们需要显式地引用这个全局命名空间。这是通过在名称前加一个点来实现的。例如，如果我们想将`pgpool.domain`类型分配给`system_r`角色，我们的策略需要调整如下：
- en: '[PRE14]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Here, the `roletype` statement is used to assign the `domain` type (defined
    in the `pgpool` namespace) to the `system_r` role (defined in the `global` namespace).
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`roletype`语句用于将`pgpool`命名空间中定义的`domain`类型分配给`system_r`角色（该角色在`global`命名空间中定义）。
- en: Extending the policy with attribute assignments
  id: totrans-82
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 扩展策略并分配属性
- en: When we develop a policy, it is recommended to use attributes as much as possible.
    Many attributes will automatically grant the necessary privileges to jumpstart
    a policy development, reducing the number of `allow` statements that need to take
    part of the policy.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 在开发策略时，建议尽可能使用属性。许多属性会自动授予必要的权限，以启动策略开发，减少需要参与策略的`allow`语句数量。
- en: 'The main reference policy, which is still in use on the system as a whole,
    defines quite a few attributes, as seen in all previous chapters. So, let''s assign
    the `daemon` attribute to our domain:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 系统中仍在使用的主策略定义了很多属性，正如前面各章节所见。所以，让我们将`daemon`属性分配给我们的域：
- en: '[PRE15]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: By assigning the `daemon` attribute, all existing policy rules for daemons are
    automatically applied to the `pgpool.domain` SELinux domain.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 通过分配`daemon`属性，所有现有的守护进程策略规则会自动应用到`pgpool.domain` SELinux域。
- en: 'To find out which attributes are sensible to add, we can take a peek at existing
    daemon domains:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 要找出哪些属性是合理添加的，我们可以看看现有的守护进程域：
- en: '[PRE16]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Now, we do not need to blindly take up all attributes, starting instead with
    those we feel confident with.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们不需要盲目地采用所有属性，而是从我们有信心的属性开始。
- en: Adding entry point information
  id: totrans-90
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 添加入口点信息
- en: Our next step is to add entry point information to the policy. This is a necessary
    step before we can start testing out, because we want the domain to become active.
    For that to happen, it has to be executable by the init system (or systemd) and
    transition to the domain we've just declared.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是将入口点信息添加到策略中。在我们开始测试之前，这是一个必要的步骤，因为我们希望该域变为活动状态。为了实现这一点，它必须能够被初始化系统（或systemd）执行，并且过渡到我们刚刚声明的域。
- en: 'Let''s start by defining our `entrypoint` type (`pgpool.exec`) and associate
    it with the right attributes:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从定义`entrypoint`类型（`pgpool.exec`）并将其与正确的属性关联开始：
- en: '[PRE17]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'In this code block, we''ve performed several steps to ensure that a transition
    will occur:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个代码块中，我们执行了多个步骤以确保会发生过渡：
- en: We've associated the `pgpool.exec` type with the `file_type` attribute (which
    is a generic attribute for files) and the `direct_init_entry` attribute (which
    is for file types that are used to launch system services).
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们将`pgpool.exec`类型与`file_type`属性（这是文件的通用属性）和`direct_init_entry`属性（这是用于启动系统服务的文件类型）关联起来。
- en: We've marked the `pgpool.exec` type as `entrypoint` for the `pgpool.domain`
    type, as well as granted this domain the necessary privileges to read, open, and
    execute the `pgpool.exec` labeled resources (as needed for a starting process).
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们将`pgpool.exec`类型标记为`pgpool.domain`类型的`entrypoint`，并授予该域必要的权限来读取、打开和执行`pgpool.exec`标记的资源（这是启动进程所需的）。
- en: We've declared a type transition so that any `initrc_domain` labeled process
    that executes the `pgpool.exec` labeled resource will result in a domain transition
    toward `pgpool.domain`.
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们声明了一个类型转换，使得任何标记为`initrc_domain`的进程执行标记为`pgpool.exec`的资源时，会导致域向`pgpool.domain`转换。
- en: 'We can now finish this step by adding a file context definition:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以通过添加文件上下文定义来完成这一步：
- en: '[PRE18]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'With these changes made, we can load the policy and relabel the file:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 做出这些更改后，我们可以加载策略并重新标记文件：
- en: '[PRE19]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: We can now attempt to start the `pgpool` service, and hope that it fails (as
    that will show that the transition was successful, given that the `pgpool.domain`
    SELinux domain hardly has sufficient privileges to successfully start the entire
    service).
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以尝试启动`pgpool`服务，并希望它失败（因为这将表明转换成功，考虑到`pgpool.domain` SELinux域几乎没有足够的权限来成功启动整个服务）。
- en: Gradually extending the policy further
  id: totrans-103
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 逐步扩展策略
- en: Once the domain transitions are successful, we can gradually extend the policy
    further through trial and error, just like we would do when developing SELinux
    policies using the reference policy style. However, rather than using `audit2allow`
    to guide us, we will need to interpret the denials ourselves and see how to better
    approach it.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦域的转换成功，我们可以通过反复试验逐步扩展策略，就像我们在使用参考策略风格开发SELinux策略时一样。然而，与其使用`audit2allow`来引导我们，我们需要自己解释拒绝信息，并看看如何更好地处理它。
- en: 'Consider the failures that appear after starting the service:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑启动服务后出现的失败情况：
- en: '[PRE20]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Now, rather than immediately adding `allow` rules for these types, let''s see
    how this is accomplished for other daemons on the system:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在立即为这些类型添加`allow`规则之前，让我们看看其他系统守护进程是如何完成这个任务的：
- en: '[PRE21]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'So, this permission is based on the `domain` attribute, which we indeed forgot
    to add to the policy. Let''s rectify this and retry:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，这个权限是基于`domain`属性的，事实上我们确实忘记将其添加到策略中。让我们纠正这个问题并重新尝试：
- en: '[PRE22]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: In this example, we can also see clearly what the impact is of the namespaces
    within CIL. We assigned the (global namespace-hosted) `domain` attribute to the
    (`pgpool` namespace-hosted) `domain` type. They are both named `domain`, but have
    a different namespace. This also shows how important attributes are.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们还可以清楚地看到CIL中的命名空间的影响。我们将（全局命名空间托管的）`domain`属性分配给（`pgpool`命名空间托管的）`domain`类型。它们都被命名为`domain`，但有不同的命名空间。这也展示了属性的重要性。
- en: Of course, not all privileges can be granted through attributes. By adding the
    target types as a dependency, we can directly include `allow` statements in our
    policy, like we did with the `entrypoint` declaration.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，并不是所有权限都可以通过属性授予。通过将目标类型作为依赖项添加，我们可以像对`entrypoint`声明一样，直接在策略中包含`allow`语句。
- en: 'For instance, if we would want to explicitly allow our domain to signal the
    `postgresql_t` domain, execute the following command:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果我们希望显式地允许我们的域向`postgresql_t`域发送信号，可以执行以下命令：
- en: '[PRE23]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: As we are adding more and more privileges to the policy, we might want to optimize
    some of the definitions. There are two optimizations supported by CIL, and they
    are, not unsurprisingly, aligned with the reference policy's simplifications as
    CIL was developed by the same community.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 随着我们向策略中添加越来越多的权限，我们可能希望优化一些定义。CIL支持两种优化，这两种优化与参考策略的简化方式一致，因为CIL是由同一社区开发的。
- en: Introducing permission sets
  id: totrans-116
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 引入权限集
- en: 'The first simplification we can do is to simplify the permission sets we use.
    Remember the `allow` rule we added to allow our domain to execute its entrypoint
    file:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以做的第一个简化是简化我们使用的权限集。记得我们添加的`allow`规则，以允许我们的域执行其入口文件：
- en: '[PRE24]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Were we to use a reference policy-style approach, we would combine many of these
    permissions through the `exec_file_perms` macro. Well, CIL supports something
    similar, through a statement called `classpermissionset`.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们使用引用策略风格的方法，我们将通过`exec_file_perms`宏组合这些权限。好消息是，CIL通过一个名为`classpermissionset`的语句支持类似的功能。
- en: 'If we want to simulate the reference policy-style approach completely, we would
    define `classpermissionset` in the global namespace, and use it, as follows:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想要完全模拟引用策略风格的方法，我们会在全局命名空间中定义`classpermissionset`，然后按如下方式使用它：
- en: '[PRE25]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: In this example, we've defined `classpermissionset` in the global namespace,
    and then referred to it. Unlike the reference policy, however, we cannot just
    add `exec_file_perms` inside the permissions together with `entrypoint`. The `classpermissionset`
    statement has an explicit reference to the class associated with it. The `allow`
    statement in CIL is therefore a separate one that does not contain a class reference
    itself.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们在全局命名空间中定义了`classpermissionset`，然后引用它。然而，与引用策略不同的是，我们不能仅仅将`exec_file_perms`与`entrypoint`一起添加到权限中。`classpermissionset`语句明确引用了与之关联的类。因此，CIL中的`allow`语句是一个独立的语句，它本身不包含类引用。
- en: Furthermore, in the example, you will also notice that we did not prefix the
    `exec_file_perms` name with a dot, to refer to the global namespace. While we
    can prefix it perfectly to be consistent with the rest of the policy, using a
    dot prefix is not mandatory if there is no possible collision. If no local definition
    for a name exists within the current namespace, the policy will then check whether
    the parent namespace (and, hence, also the global namespace) has the name defined.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，在示例中，你会注意到我们并没有在`exec_file_perms`名前加上点符号，以引用全局命名空间。虽然我们可以加上点符号，以与其余策略保持一致，但如果没有潜在的冲突，使用点符号前缀并不是强制性的。如果当前命名空间中不存在某个名称的本地定义，策略将检查父命名空间（因此也包括全局命名空间）中是否定义了该名称。
- en: So, while the preceding policy will work just fine, we do recommend to prefix
    the global namespace-oriented names with a dot to make sure no local override
    would confuse the policy later on.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，尽管前面的策略完全可以正常工作，但我们确实建议在全局命名空间相关的名称前加上点符号，以确保后续没有本地覆盖可能会干扰策略。
- en: Adding macros
  id: totrans-125
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 添加宏
- en: The final simplification we can introduce is to add **macros**. CIL has an explicit
    support for macros, which allows them to be part of the loaded policy, and not
    just be referred to on the filesystem. With CIL macros, the code is part of the
    policy itself. There is no need to refer to the CIL code while building policies.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以引入的最后一个简化是添加**宏**。CIL明确支持宏，允许它们成为加载策略的一部分，而不仅仅是在文件系统中引用。通过CIL宏，代码成为策略的一部分。构建策略时无需再引用CIL代码。
- en: While this is a best practice that is aligned with object-oriented programming
    (as we can add macros to our namespaces so that they remain within the same object),
    the downside is that the current SELinux utilities are not able to quickly show
    which macros (and which interface they require) are available in the policy.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这是与面向对象编程一致的最佳实践（因为我们可以将宏添加到命名空间中，使它们保持在同一对象内），但缺点是当前的SELinux工具无法快速显示策略中可用的宏（以及它们需要的接口）。
- en: 'Now, let''s enhance our `pgpool` policy with a domain transition macro, similar
    to the `pgpool_domtrans()` interface that would be created through a reference
    policy-style development:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们通过一个域转换宏来增强我们的`pgpool`策略，类似于通过引用策略风格开发创建的`pgpool_domtrans()`接口：
- en: '[PRE26]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: The macro definition itself starts with a name (in our case, `domtrans`) followed
    by the interface. This interface defines how many arguments are passed to the
    macro, and which type they have. In our example, only one argument is passed,
    and it is a SELinux type.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 宏定义本身以名称开始（在我们的例子中是`domtrans`），后跟接口。该接口定义了传递给宏的参数数量及其类型。在我们的示例中，只传递了一个参数，它是一个SELinux类型。
- en: The macro is then followed by the code that is applied. The argument itself
    is referenced in the code (`SOURCEDOMAIN`) and will be substituted with the argument
    that is given later on, when the macro is explicitly called. While our example
    uses a capitalized variable name, this is not mandatory, and only serves as a
    visual statement of what will be substituted.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 宏后面跟着应用的代码。代码中引用了参数本身（`SOURCEDOMAIN`），并将在宏被显式调用时用后面给出的参数进行替换。虽然我们的示例使用了大写的变量名，但这并不是强制性的，仅仅是为了视觉效果，表示将要被替换的内容。
- en: 'In another CIL policy, we can refer to this macro through the `call` statement.
    For instance, to allow the `postgresql_t` domain to transition to the `pgpool.domain`
    SELinux domain, we would add the following `call` statement to our policy:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 在另一个CIL策略中，我们可以通过`call`语句引用这个宏。例如，要允许`postgresql_t`域转到`pgpool.domain` SELinux域，我们可以将以下`call`语句添加到我们的策略中：
- en: '[PRE27]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: CIL macros provide all that is needed to generate the same simplicity in developing
    SELinux policies as we have within the reference policy, and even more as there
    are many constraints not applicable to CIL policies.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: CIL宏提供了所需的一切，以便在开发SELinux策略时实现与参考策略相同的简洁性，甚至更多，因为有许多约束不适用于CIL策略。
- en: 'While it is possible that this will happen in the future, it is not planned
    at this moment for a number of reasons:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然未来有可能会发生这种情况，但目前由于种种原因并没有计划这样做：
- en: The current reference policy has a significant amount of code in it, which would
    all need to be reworked. Furthermore, Linux distributions have extended this policy
    with many of their own additions, so the work needed to rewrite the SELinux policy
    code into CIL is significant. Not impossible, but not a feat to accomplish in
    a few weeks.
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当前的参考策略包含大量代码，这些代码都需要重新编写。此外，Linux发行版已经在此策略基础上做了许多扩展，因此将SELinux策略代码重写为CIL的工作量非常大。这并非不可能，但不是几周内能够完成的任务。
- en: Almost all of the information and documentation online that helps developers
    in writing SELinux policies is based upon the current reference policy. This major
    source of information would become stale the moment a switch occurs, and the amount
    of documentation available online for CIL-based policy development is still pretty
    slim.
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 几乎所有帮助开发者编写SELinux策略的在线信息和文档都是基于当前的参考策略。这个重要的信息源一旦发生切换就会变得过时，而针对基于CIL的策略开发的在线文档目前仍然非常稀少。
- en: The CIL policy, while very powerful, is also a bit more complex due to its S-expressions.
    The design intention of CIL was not to replace SELinux policy development with
    CIL, but to allow higher level languages to be developed that translate and convert
    into CIL easily. Hence, if a rework is going to be done anyway, it is much more
    likely that a user- and development-friendly language will be designed that can
    be easily converted into CIL.
  id: totrans-138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: CIL策略虽然非常强大，但由于其S表达式，它也有些复杂。CIL的设计初衷并不是用CIL替代SELinux策略开发，而是允许开发更高级的语言，这些语言可以轻松地转换为CIL。因此，如果需要重新设计，用户友好和开发者友好的语言很可能会被设计出来，并且能够轻松转换为CIL。
- en: As the SELinux development progresses, both on the policy level as well as in
    terms of user space and kernel support, we can expect more additions to be added
    to CIL and to its supporting tools.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 随着SELinux开发的进展，无论是在策略层面，还是在用户空间和内核支持方面，我们可以期待CIL及其支持工具会有更多的新增功能。
- en: Summary
  id: totrans-140
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: 'CIL for SELinux is a powerful, lower-level syntax and language that is used
    to express all possible SELinux policy code. The SELinux userspace utilities will
    automatically convert existing policies into CIL code, but through this conversion,
    a lot of CIL constructs are not used: the conversion only uses a smaller set of
    CIL capabilities to establish a valid translation.'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: SELinux的CIL是一种强大且较低级的语法和语言，用于表达所有可能的SELinux策略代码。SELinux用户空间工具会自动将现有策略转换为CIL代码，但通过这种转换，许多CIL构造并未被使用：转换只使用了一个较小的CIL功能集来建立有效的翻译。
- en: The more advanced CIL capabilities, such as namespace support, macros, and the
    permission sets through the `classpermissionset` statement, are useful when developing
    our own, CIL-based SELinux policies. In this chapter, we've learned how to use
    CIL to build complete application policies. Because there is no reference policy-like
    framework to simplify development, we had to write all of the necessary code constructs
    ourselves.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 更高级的CIL功能，例如命名空间支持、宏以及通过`classpermissionset`语句进行的权限集，在开发我们自己的基于CIL的SELinux策略时非常有用。在本章中，我们已经学习了如何使用CIL来构建完整的应用程序策略。由于没有类似参考策略的框架来简化开发，我们必须自己编写所有必要的代码构造。
- en: While this means that developing CIL-based policies is more resource intensive,
    we did also see that CIL has a few benefits that reference policy-style development
    cannot deal with, such as the ability to declare ports or add SELinux constraints
    to an active policy.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这意味着开发基于CIL的策略需要更多的资源，但我们也看到CIL具有一些参考策略开发无法解决的优势，例如声明端口或向活动策略添加SELinux约束的能力。
- en: We ended the chapter with a brief overview of why CIL-based development is not
    more widely used, but we will notice continuous improvements within SELinux on
    this matter in the foreseeable future.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 我们以简要概述结束本章，解释了为什么基于 CIL 的开发没有被广泛使用，但在可预见的未来，我们将在 SELinux 中看到这一方面的持续改进。
- en: This concludes our book and the information we have to offer to you. However,
    it is only the start of a journey, not the end. SELinux is a widely used technology,
    and we hope that this book provides you with the right material and knowledge
    to understand, grow, and contribute to the ecosystem. Thank you for your interest
    and your dedication.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是我们本书的全部内容以及我们能提供的信息。然而，这仅仅是一个旅程的开始，而非结束。SELinux 是一种广泛使用的技术，我们希望本书能为您提供正确的材料和知识，以便理解、成长并为生态系统做出贡献。感谢您的关注与投入。
- en: Questions
  id: totrans-146
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: How do we know CIL is here to stay?
  id: totrans-147
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们如何知道 CIL 会持续存在？
- en: Is the `cil_gen_require` attribute mandatory for CIL development?
  id: totrans-148
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`cil_gen_require` 属性在 CIL 开发中是必需的吗？'
- en: What are examples of declarations that developers can do with CIL but not with
    other SELinux language styles?
  id: totrans-149
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 开发者可以使用 CIL 进行的声明，其他 SELinux 语言风格不能做的例子有哪些？
- en: How can we create similar support constructions such as interfaces in CIL?
  id: totrans-150
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们如何在 CIL 中创建类似接口的支持结构？
