<html><head></head><body>
<div id="sbo-rt-content"><div id="_idContainer076">
<h1 class="chapter-number" id="_idParaDest-159"><a id="_idTextAnchor189"/>11</h1>
<h1 id="_idParaDest-160"><a id="_idTextAnchor190"/>Logging Configuration and Remote Logging</h1>
<p>Logging is an important aspect of any operating system, including Linux. It provides a way to collect and analyze system <a id="_idIndexMarker524"/>events and activities, which can be useful for troubleshooting, monitoring, and auditing purposes. In this chapter, we will explore the different aspects of logging configuration and remote logging <span class="No-Break">in Linux.</span></p>
<p>In this chapter, we will cover the <span class="No-Break">following topics:</span></p>
<ul>
<li><span class="No-Break">Logging configuration</span></li>
<li><span class="No-Break">Log rotation</span></li>
<li><span class="No-Break">Journald</span></li>
<li><span class="No-Break">Log forwarding</span></li>
</ul>
<h1 id="_idParaDest-161"><a id="_idTextAnchor191"/>Logging configuration</h1>
<p>Linux uses the syslog <a id="_idIndexMarker525"/>system for logging. The syslog daemon collects messages from different parts of the system and writes them to log files. The syslog configuration file is usually located at <strong class="source-inline">/etc/syslog.conf</strong> or <strong class="source-inline">/etc/rsyslog.conf</strong>, depending on the distribution. This file contains the rules that specify which messages to log and where to <span class="No-Break">store them.</span></p>
<p>There is a critical parameter called <strong class="source-inline">facility.severity</strong> that is a crucial part of the logging configuration in Linux. It allows <a id="_idIndexMarker526"/>you to control which log messages should be recorded and where they should be stored. The facility and severity can be specified either numerically or using their symbolic names. For example, the following rule logs all messages with a severity level of warning or higher from the auth facility to the <strong class="source-inline">/</strong><span class="No-Break"><strong class="source-inline">var/log/auth.log</strong></span><span class="No-Break"> file:</span></p>
<pre class="source-code">
auth.warning /var/log/auth.log</pre>
<p>The target part of the configuration file specifies where to store the logged messages. The target can be a file, a remote host, or a program that processes the messages. The target syntax is <span class="No-Break">as follows:</span></p>
<pre class="source-code">
target_type(target_options)</pre>
<p>The target type can be one of <span class="No-Break">the following:</span></p>
<ul>
<li><strong class="source-inline">file</strong>: Stores the messages in a <span class="No-Break">local file</span></li>
<li><strong class="source-inline">remote</strong>: Sends the messages to a remote host using the <span class="No-Break">syslog protocol</span></li>
<li><strong class="source-inline">program</strong>: Sends the messages to a local program <span class="No-Break">for processing</span></li>
</ul>
<p>For example, the following rule sends all messages with a severity level of error or higher to a remote host with an IP address of <strong class="source-inline">192.168.1.100</strong> using the <span class="No-Break">syslog protocol:</span></p>
<pre class="source-code">
*.err @192.168.1.100</pre>
<p>After modifying the syslog configuration file, the syslog daemon must be restarted to apply the changes. The command to restart the syslog daemon varies depending on the distribution. For example, on Ubuntu, the command is <span class="No-Break">as follows:</span></p>
<pre class="source-code">
sudo service rsyslog restart</pre>
<p>A log message’s primary focus is on log data. Alternatively stated, log data is the explanation behind a log message. If you <a id="_idIndexMarker527"/>use an image, file, or other resources on a website, the server that hosts your site will likely keep track of that fact. You may see who accessed a certain resource by examining the log data – in this case, the <span class="No-Break">user’s username.</span></p>
<p>The term <em class="italic">logs</em> is shorthand for a <a id="_idIndexMarker528"/>collection of log messages that can be pieced together to provide context for <span class="No-Break">an event.</span></p>
<p>Each entry in the log file can be roughly classified as one of <span class="No-Break">the following:</span></p>
<ul>
<li><strong class="bold">Informational</strong>: Purposely vague, these messages aim to inform users and administrators that a positive change has occurred. For instance, Cisco IOS will notify appropriate parties whenever the system reboots. However, caution is required. If a restart occurs at an inconvenient time, such as outside of maintenance or business hours, you may have cause for concern. The next few chapters of this book will teach you the knowledge and techniques you’ll need to deal with a situation <span class="No-Break">like this.</span></li>
<li><strong class="bold">Debug</strong>: When something goes wrong with running application code, debug messages are sent by the system to help developers identify and address <span class="No-Break">the problem.</span></li>
<li><strong class="bold">Warning</strong>: This is issued when something is lacking or needed for a system, but not to the point where its absence would prevent the system from functioning. Some programs may log a notice to the user or operator if they don’t receive the expected number of arguments on the command line, even though they can still operate normally <span class="No-Break">without them.</span></li>
<li><strong class="bold">Error</strong>: In the event of an error, the computer system stores the relevant information in a log that may be analyzed later. An OS might generate an error log, for instance, if it is unable to synchronize buffers to disk. Unfortunately, many error messages simply provide a broad outline of the problem. More investigation is usually required to determine the root of <span class="No-Break">a problem.</span></li>
<li><strong class="bold">Alert</strong>: The purpose of <a id="_idIndexMarker529"/>an alert is to draw your attention to a noteworthy development. In most cases, notifications will come from security-related devices and systems, although this is not always the case. All incoming data to a network can be inspected by an <strong class="bold">intrusion prevention system</strong> (<strong class="bold">IPS</strong>) placed at its <a id="_idIndexMarker530"/>entrance. It examines the information included in the packets to determine whether or not to enable a certain network connection. The IPS can react in several predetermined ways if it detects a potentially malicious connection. The action and the decision will <span class="No-Break">be documented.</span></li>
</ul>
<p>Next, we’ll quickly go through the processes involved in transmitting and collecting log data. Then, we’ll discuss what a log <span class="No-Break">message is.</span></p>
<h1 id="_idParaDest-162"><a id="_idTextAnchor192"/>How does log data get sent and gathered?</h1>
<p>It’s easy to send and <a id="_idIndexMarker531"/>gather log data. Syslog is a protocol used for sending and gathering log data in <a id="_idIndexMarker532"/>computer networks. It is a standard protocol that allows different devices to send log messages to a central logging server <span class="No-Break">or device.</span></p>
<p>Here’s how it <span class="No-Break">typically works:</span></p>
<ol>
<li>A device generates a log message. This could be a server, network device, application, or any other device that <span class="No-Break">generates logs.</span></li>
<li>The device sends the log message to a syslog server using the syslog protocol. The syslog server can be located on-premises or in <span class="No-Break">the cloud.</span></li>
<li>The syslog server receives the log message and processes it. It can store the log message in a file or database, or forward it to other systems for <span class="No-Break">further analysis.</span></li>
<li>The syslog server can also apply filters and rules to the log messages it receives. For example, it can discard log messages that are not relevant or send an alert when a critical <span class="No-Break">error occurs.</span></li>
<li>System administrators and analysts can access the log data stored in the syslog server for troubleshooting, analysis, <span class="No-Break">and reporting.</span></li>
</ol>
<p>The following are some of the advantages of using a centralized <span class="No-Break">log collector:</span></p>
<ul>
<li>It’s a centralized <a id="_idIndexMarker533"/>repository for all of your <span class="No-Break">log messages</span></li>
<li>Logs can be stored there <span class="No-Break">for safekeeping</span></li>
<li>This is where all of your server’s log information may <span class="No-Break">be inspected</span></li>
</ul>
<p>Log analysis is crucial to the health of applications and server architecture, but it can be laborious if data is dispersed in multiple locations. Why not have just one consolidated logbook rather than a bunch of individual ones? Rsyslog may be the solution you’ve been <span class="No-Break">looking for.</span></p>
<p>Using a centralized <a id="_idIndexMarker534"/>logging system, you may collect the logs from all of your servers and <a id="_idIndexMarker535"/>programs into one centralized area. In addition, this tutorial will help you implement centralized logging on Linux nodes by use of the <span class="No-Break">rsyslog configuration.</span></p>
<p>This section is meant to be a practical example. </p>
<h1 id="_idParaDest-163"><a id="_idTextAnchor193"/>Checking rsyslog service on all servers</h1>
<p>A high-performance log <a id="_idIndexMarker536"/>processing system called rsyslog is pre-installed <a id="_idIndexMarker537"/>and ready to use on both Debian and <span class="No-Break">RHEL systems.</span></p>
<p>The syslog protocol has been improved with rsyslog, which gives it more contemporary and dependable features. These additional features include a large number of inputs and outputs, a modular design, and <span class="No-Break">excellent filtering.</span></p>
<p>The most recent version of rsyslog as of this writing is v8.2112.0. Therefore, you will verify the rsyslog service’s status and the version of rsyslog installed on your computer. This will guarantee that rsyslog is running at its most <span class="No-Break">recent version.</span></p>
<p>Open a command prompt and use the following <strong class="source-inline">sudo su</strong> command to take control of all servers. When prompted, enter <span class="No-Break">your password.</span></p>
<p>In the following screenshot, you’ll find that Centos 8 ships with rsyslog v8.2102.0 <span class="No-Break">by default:</span></p>
<div>
<div class="IMG---Figure" id="_idContainer069">
<img alt="Figure 11.1 – Checking the rsyslog version" height="538" src="image/B18575_11_01.jpg" width="1008"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 11.1 – Checking the rsyslog version</p>
<p>Check the status <a id="_idIndexMarker538"/>of the rsyslog service by running <a id="_idIndexMarker539"/>the <strong class="source-inline">systemctl status </strong><span class="No-Break"><strong class="source-inline">rsyslog</strong></span><span class="No-Break"> command:</span></p>
<div>
<div class="IMG---Figure" id="_idContainer070">
<img alt="Figure 11.2 – Checking the status of the rsyslog service" height="315" src="image/B18575_11_02.jpg" width="1300"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 11.2 – Checking the status of the rsyslog service</p>
<p>As you can see, the service is active <span class="No-Break">and running.</span></p>
<p>To check the status of the rsyslog service on multiple servers, you can use a configuration management tool such as Ansible or write a simple bash script to automate the process. Here’s an example of how to check the rsyslog service on all servers using a <span class="No-Break">bash script:</span></p>
<ol>
<li>Create a file called <strong class="source-inline">servers.txt</strong> and add the list of servers you want to check, one <span class="No-Break">per line:</span><pre class="source-code">
server1.example.com</pre><pre class="source-code">
server2.example.com</pre><pre class="source-code">
server3.example.com</pre></li>
<li>Create a new bash script called <strong class="source-inline">check_rsyslog_service.sh</strong> and add the <span class="No-Break">following code:</span><pre class="source-code">
#!/bin/bash</pre><pre class="source-code">
while read server;</pre><pre class="source-code">
do</pre><pre class="source-code">
echo "Checking rsyslog service on $server"</pre><pre class="source-code">
ssh $server "systemctl status rsyslog" ; done &lt; servers.txt</pre></li>
<li>Make the <a id="_idIndexMarker540"/><span class="No-Break">script executable:</span><pre class="source-code">
<strong class="bold">chmod +x check_rsyslog_service.sh</strong></pre></li>
<li>Run <span class="No-Break">the script:</span><pre class="source-code">
<strong class="bold">./check_rsyslog_service.sh</strong></pre></li>
</ol>
<p>The script will iterate through <a id="_idIndexMarker541"/>the list of servers in <strong class="source-inline">servers.txt</strong> and execute the <strong class="source-inline">systemctl status rsyslog</strong> command over SSH to check the status of the rsyslog service on each server. The output will be displayed in the Terminal. You can modify the script to perform other actions on the servers, such as restarting the rsyslog service or updating the <span class="No-Break">rsyslog configuration.</span></p>
<h1 id="_idParaDest-164"><a id="_idTextAnchor194"/>Configuring rsyslog for centralized logging</h1>
<p>Centralized <a id="_idIndexMarker542"/>logging using the <strong class="source-inline">central-rsyslog</strong> server <a id="_idIndexMarker543"/>can be set up after you’ve updated to the most recent version <span class="No-Break">of rsyslog.</span></p>
<p>The central logging setup is created by turning on the rsyslog UDP input module, <strong class="source-inline">imudp</strong>, and building the rsyslog template to receive log messages from other servers. The <strong class="source-inline">imudp</strong> input module allows syslog messages to be broadcast over UDP to be received by the <span class="No-Break"><strong class="source-inline">central-rsyslog</strong></span><span class="No-Break"> server.</span></p>
<p>Enable the options shown in the following screenshot in <strong class="source-inline">/etc/rsyslog.conf</strong> (the rsyslog configuration file) before saving the file and closing <span class="No-Break">the editor.</span></p>
<p>The <strong class="source-inline">imudp</strong> input module needs to be configured to utilize the default UDP port of <strong class="source-inline">514</strong> <span class="No-Break">to work:</span></p>
<div>
<div class="IMG---Figure" id="_idContainer071">
<img alt="Figure 11.3 – imudp module configuration" height="540" src="image/B18575_11_03.jpg" width="1338"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 11.3 – imudp module configuration</p>
<p>Then, create a <a id="_idIndexMarker544"/>new rsyslog template (<strong class="source-inline">/etc/rsyslog.d/50-remote-logs.conf</strong>) and <a id="_idIndexMarker545"/>paste the configuration indicated in <span class="No-Break"><em class="italic">Figure 11</em></span><span class="No-Break"><em class="italic">.4</em></span><span class="No-Break">.</span></p>
<p>The following rsyslog template will allow you to collect logs from other servers and store them in the <strong class="source-inline">/var/log/remotelogs/</strong> directory on the <span class="No-Break"><strong class="source-inline">main-rsyslog</strong></span><span class="No-Break"> server:</span></p>
<div>
<div class="IMG---Figure" id="_idContainer072">
<img alt="Figure 11.4 – Template configuration" height="537" src="image/B18575_11_04.jpg" width="1010"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 11.4 – Template configuration</p>
<p>To establish a new log directory (<strong class="source-inline">/var/log/remotelogs/</strong>) owned by the root user with the <strong class="source-inline">adm</strong> group, run <a id="_idIndexMarker546"/>the following instructions. By doing this, the <a id="_idIndexMarker547"/>rsyslog service will be able to create logs in the <strong class="source-inline">/</strong><span class="No-Break"><strong class="source-inline">var/log/remotelogs</strong></span><span class="No-Break"> folder:</span></p>
<pre class="source-code">
mkdir -p /var/log/remotelogs</pre>
<p>Then, change the ownership of the <span class="No-Break"><strong class="source-inline">remotelogs</strong></span><span class="No-Break"> folder:</span></p>
<pre class="source-code">
chown -R root:adm /var/log/remotelogs/</pre>
<p>To check the rsyslog settings (<strong class="source-inline">/etc/rsyslog.conf</strong> and <strong class="source-inline">/etc/rsyslog.d/50-remote-logs.conf</strong>), simply execute the <strong class="source-inline">rsyslogd</strong> commands <span class="No-Break">provided here:</span></p>
<div>
<div class="IMG---Figure" id="_idContainer073">
<img alt="Figure 11.5 – Checking the syntax" height="99" src="image/B18575_11_05.jpg" width="1347"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 11.5 – Checking the syntax</p>
<p>After double-checking the settings, you can restart the rsyslog service using the <span class="No-Break">following command:</span></p>
<pre class="source-code">
systemctl restart rsyslog</pre>
<p>The rsyslog service, which has the <strong class="source-inline">imudp</strong> input module enabled, has exposed the syslog protocol’s default UDP port, <strong class="source-inline">514</strong>. Now, hosts can communicate with the <strong class="source-inline">main-rsyslog</strong> server by sending their <span class="No-Break">logs there:</span></p>
<pre class="source-code">
systemctl restart rsyslog</pre>
<p>You can double-check <a id="_idIndexMarker548"/>that your ports have been properly <a id="_idIndexMarker549"/>opened by running the <strong class="source-inline">ss</strong> command, <span class="No-Break">as follows:</span></p>
<pre class="source-code">
ss -tulpn</pre>
<p>Here’s <span class="No-Break">the output:</span></p>
<div>
<div class="IMG---Figure" id="_idContainer074">
<img alt="Figure 11.6 – Command to see ports listening" height="1013" src="image/B18575_11_06.jpg" width="1470"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 11.6 – Command to see ports listening</p>
<p>Syslog is a simple and efficient <a id="_idIndexMarker550"/>protocol for collecting and managing log data in a distributed network environment. It provides a centralized location for storing logs, which makes it easier to manage, monitor, and <span class="No-Break">troubleshoot systems.</span></p>
<h1 id="_idParaDest-165"><a id="_idTextAnchor195"/>Sending logs to a centralized rsyslog server</h1>
<p>You’ve already taken the first step toward streamlined log handling by configuring syslog on the <strong class="source-inline">main-rsyslog</strong> server. But <a id="_idIndexMarker551"/>how do you know <a id="_idIndexMarker552"/>that the <strong class="source-inline">main-rsyslog</strong> server is receiving the logs? Logs can be sent from a remote client system to a <strong class="source-inline">main-rsyslog</strong> server by activating and configuring the rsyslog output <span class="No-Break">module (</span><span class="No-Break"><strong class="source-inline">main-rsyslog</strong></span><span class="No-Break">).</span></p>
<p>In this example, the <strong class="source-inline">client01</strong> machine uses the rsyslog output module, <strong class="source-inline">omfwd</strong>, to transmit logs to the <span class="No-Break"><strong class="source-inline">main-rsyslog</strong></span><span class="No-Break"> server.</span></p>
<p>To process messages and logs, the <strong class="source-inline">omfwd</strong> module must be installed (it will be already). It can be used in conjunction with rsyslog templates. Finally, the module uses the rsyslog action object to transmit the data through UDP and TCP to the <span class="No-Break">specified destinations.</span></p>
<p>Set up the client machine so that it can submit logs to the <span class="No-Break"><strong class="source-inline">main-rsyslog</strong></span><span class="No-Break"> server.</span></p>
<p>Create a new rsyslog configuration (<strong class="source-inline">/etc/rsyslog.d/20-forward-logs.conf</strong>) in your preferred text editor and enter the settings shown in <span class="No-Break"><em class="italic">Figure 11</em></span><span class="No-Break"><em class="italic">.7</em></span><span class="No-Break">.</span></p>
<p>Using the <strong class="source-inline">SendRemote</strong> template, log messages are formatted before being sent via the UDP protocol to the <strong class="source-inline">main-rsyslog</strong> server (<strong class="source-inline">192.168.1.111</strong>). In this case, the IP address should be replaced with the IP address of your primary <span class="No-Break">rsyslog server:</span></p>
<div>
<div class="IMG---Figure" id="_idContainer075">
<img alt="Figure 11.7 – Template for SendRemote" height="904" src="image/B18575_11_07.jpg" width="1441"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 11.7 – Template for SendRemote</p>
<p>The preceding <a id="_idIndexMarker553"/>screenshot shows the content of <a id="_idIndexMarker554"/>a template file for <span class="No-Break">log forwarding.</span></p>
<p>Check if the syntax is correct by running <span class="No-Break">this command:</span></p>
<pre class="source-code">
rsyslogd -N1 -f /etc/rsyslog.d/20-remote-logs.conf</pre>
<p>Restart rsyslog by running the <strong class="source-inline">sudo systemctl restart rsyslog</strong> command and check whether the syslog server is receiving logs from <span class="No-Break">the client.</span></p>
<h1 id="_idParaDest-166"><a id="_idTextAnchor196"/>Log rotation</h1>
<p>Log rotation is a crucial process in Linux systems to manage log files efficiently. As applications and <a id="_idIndexMarker555"/>services generate log data over time, log files can grow significantly, consuming disk space and potentially leading to performance issues. Log rotation allows for the periodic compression, archival, and removal of old log files, ensuring the system maintains a manageable <span class="No-Break">log history.</span></p>
<p>In Linux, log rotation is typically handled by a log rotation tool called <strong class="source-inline">logrotate</strong>. The configuration file for <strong class="source-inline">logrotate</strong> is located at <strong class="source-inline">/etc/logrotate.conf</strong>, and it includes references to <a id="_idIndexMarker556"/>individual log rotation configurations in the <strong class="source-inline">/</strong><span class="No-Break"><strong class="source-inline">etc/logrotate.d/</strong></span><span class="No-Break"> directory.</span></p>
<p>Here’s a step-by-step guide on how to configure log rotation <span class="No-Break">in Linux:</span></p>
<ol>
<li><strong class="bold">Install logrotate (if not already installed)</strong>: Most Linux distributions come with <strong class="source-inline">logrotate</strong> pre-installed. However, if it’s not available on your system, you can install it using the package <a id="_idIndexMarker557"/>manager specific to your Linux distribution. For example, on Debian/Ubuntu-based systems, you can install it with the <span class="No-Break">following commands:</span><pre class="source-code">
<strong class="bold">sudo apt-get update</strong></pre><pre class="source-code">
<strong class="bold">sudo apt-get install logrotate</strong></pre></li>
<li><strong class="bold">Create a log rotation configuration file</strong>: You can create a new log rotation configuration file for your specific application/service or use the default one. It’s recommended to create separate files for different applications for <span class="No-Break">easier management.</span></li>
</ol>
<p>Navigate to the <strong class="source-inline">/etc/logrotate.d/</strong> directory and create a new configuration file – for <span class="No-Break">example, </span><span class="No-Break"><strong class="source-inline">myapp_logrotate</strong></span><span class="No-Break">:</span></p>
<pre class="source-code">
<strong class="bold">sudo nano /etc/logrotate.d/myapp_logrotate</strong></pre>
<ol>
<li value="3"><strong class="bold">Define the log rotation settings in the configuration file</strong>: The <strong class="source-inline">logrotate</strong> configuration file follows a specific syntax. Here’s a <span class="No-Break">basic example:</span><pre class="source-code">
/path/to/your/logfile.log {</pre><pre class="source-code">
rotate &lt;N&gt;     # Number of log files to keep before removal</pre><pre class="source-code">
daily          # Frequency of rotation (daily, weekly, monthly, etc.)</pre><pre class="source-code">
missingok      # Don't throw an error if the log file is missing</pre><pre class="source-code">
notifempty     # Do not rotate an empty log file</pre><pre class="source-code">
compress       # Compress the rotated log files using gzip</pre><pre class="source-code">
create &lt;mode&gt; &lt;user&gt; &lt;group&gt; # Create new empty log file with specified permissions, user, and group</pre><pre class="source-code">
}</pre></li>
</ol>
<p>Replace <strong class="source-inline">/path/to/your/logfile.log</strong> with the actual path to your log file. Replace <strong class="source-inline">&lt;N&gt;</strong> with the desired number of log files to keep before removal (for example, <strong class="source-inline">rotate 7</strong> to keep 7 days’ worth of logs). Replace <strong class="source-inline">&lt;mode&gt;</strong>, <strong class="source-inline">&lt;user&gt;</strong>, and <strong class="source-inline">&lt;group&gt;</strong> with the appropriate permissions and ownership for the newly created <span class="No-Break">log file.</span></p>
<p>Save the configuration <a id="_idIndexMarker558"/>file and exit the <span class="No-Break">text editor.</span></p>
<ol>
<li value="4"><strong class="bold">Test the configuration</strong>: To check if your <strong class="source-inline">logrotate</strong> configuration is error-free, you can run the <span class="No-Break">following command:</span><pre class="source-code">
<strong class="bold">sudo logrotate -d /etc/logrotate.d/myapp_logrotate</strong></pre></li>
</ol>
<p>The <strong class="source-inline">-d</strong> flag is for debugging, and it will show you what <strong class="source-inline">logrotate</strong> would do without actually rotating the <span class="No-Break">log files.</span></p>
<ol>
<li value="5"><strong class="bold">Perform a manual log rotation</strong>: Once you are confident that the configuration is correct, you can manually trigger log rotation with the <span class="No-Break">following command:</span><pre class="source-code">
<strong class="bold">sudo logrotate /etc/logrotate.d/myapp_logrotate</strong></pre></li>
<li><strong class="bold">Set up a cron job</strong>: To automate log rotation, set up a cron job that runs <strong class="source-inline">logrotate</strong> at regular intervals. You can add an entry to <strong class="source-inline">crontab</strong> using the <span class="No-Break">following command:</span><pre class="source-code">
<strong class="bold">sudo crontab -e</strong></pre></li>
</ol>
<p>Then, add the following line to run <strong class="source-inline">logrotate</strong> daily <span class="No-Break">at midnight:</span></p>
<pre class="source-code">
0 0 * * * /usr/sbin/logrotate /etc/logrotate.conf</pre>
<p>Save <strong class="source-inline">crontab</strong> and exit the <span class="No-Break">text editor.</span></p>
<p>Now, your log files will be automatically rotated and archived based on the configuration settings. You can adjust the <a id="_idIndexMarker559"/>rotation frequency and other options in the <strong class="source-inline">logrotate</strong> configuration file to suit your <span class="No-Break">specific needs.</span></p>
<h1 id="_idParaDest-167"><a id="_idTextAnchor197"/>Journald</h1>
<p>Journal is part of systemd. Messages from various parts of a systemd-enabled Linux machine are collected here. This comprises notifications from the kernel and boot process, syslog, and <span class="No-Break">other services.</span></p>
<p>Traditionally, during Linux’s boot process, the OS’s many subsystems and application daemons would each log <a id="_idIndexMarker560"/>messages in text files. Different levels of detail would be logged for each subsystem’s messages. When troubleshooting, administrators often had to sift through messages from several files spanning different periods and then correlate the contents. The journaling feature eliminates this problem by centrally logging all system and <span class="No-Break">application-level messages.</span></p>
<p>The systemd-journald daemon is in <a id="_idIndexMarker561"/>charge of the journal. It gathers data from several resources and inserts the gathered messages into <span class="No-Break">the diary.</span></p>
<p>When systemd is using in-memory journaling, the journal files are generated under the <strong class="source-inline">/run/log/journal</strong> folder. If there isn’t already such a directory, one will be made. The journal is generated with persistent storage in the <strong class="source-inline">/var/log/journal</strong> directory; again, systemd will establish this directory if necessary. Logs will be written to <strong class="source-inline">/run/log/journal</strong> in a non-persistent fashion if this directory is destroyed; systemd-journald will not recreate it automatically. When the daemon is restarted, the directory <span class="No-Break">is recreated.</span></p>
<p>The <strong class="source-inline">journalctl</strong> command is useful <a id="_idIndexMarker562"/>for debugging services and processes since it allows you to examine and modify the <span class="No-Break">systemd logs.</span></p>
<p>The <strong class="source-inline">journalctl</strong> command and its numerous display options will be described next, along with how to view systemd logs. Since each machine has its own set of records, the results <span class="No-Break">will vary.</span></p>
<p>To show all journal entries, use the <strong class="source-inline">journalctl</strong> command without <span class="No-Break">any options:</span></p>
<pre class="source-code">
[voxsteel@centos8 ~]$ journalctl
-- Logs begin at Wed 2023-01-18 14:07:03 GMT, end at Wed 2023-01-18 14:09:39 GMT. --
Jan 18 14:07:03 centos8 kernel: microcode: microcode updated early to revision 0xd6, date = 2019-10-03Jan 18 14:07:03 centos8 kernel: Linux version 4.18.0-348.7.1.el8_5.x86_64 (mockbuild@kbuilder.bsys.centos.org) (gcc version 8.5.0 20210514 (Red Hat 8.5.0&gt;Jan 18 14:07:03 centos8 kernel: Command line: BOOT_IMAGE=(hd1,gpt2)/vmlinuz-4.18.0-348.7.1.el8_5.x86_64 root=/dev/mapper/cl-root ro crashkernel=auto resu&gt;Jan 18 14:07:03 centos8 kernel: x86/fpu: Supporting XSAVE feature 0x001: 'x87 floating point registers'Jan 18 14:07:03 centos8 kernel: x86/fpu: Supporting XSAVE feature 0x002: 'SSE registers'Jan 18 14:07:03 centos8 kernel: x86/fpu: Supporting XSAVE feature 0x004: 'AVX registers'Jan 18 14:07:03 centos8 kernel: x86/fpu: Supporting XSAVE feature 0x008: 'MPX bounds registers'Jan 18 14:07:03 centos8 kernel: x86/fpu: Supporting XSAVE feature 0x010: 'MPX CSR'Jan 18 14:07:03 centos8 kernel: x86/fpu: xstate_offset[2]:  576, xstate_sizes[2]:  256Jan 18 14:07:03 centos8 kernel: x86/fpu: xstate_offset[3]:  832, xstate_sizes[3]:   64Jan 18 14:07:03 centos8 kernel: x86/fpu: xstate_offset[4]:  896, xstate_sizes[4]:   64Jan 18 14:07:03 centos8 kernel: x86/fpu: Enabled xstate features 0x1f, context size is 960 bytes, using 'compacted' format.Jan 18 14:07:03 centos8 kernel: BIOS-provided physical RAM map:Jan 18 14:07:03 centos8 kernel: BIOS-e820: [mem 0x0000000000000000-0x0000000000057fff] usableJan 18 14:07:03 centos8 kernel: BIOS-e820: [mem 0x0000000000058000-0x0000000000058fff] reserveJan 18 14:07:03 centos8 kernel: BIOS-e820: [mem 0x0000000000059000-0x000000000009dfff] usableJan 18 14:07:03 centos8 kernel: BIOS-e820: [mem 0x000000000009e000-0x000000000009efff] reservedJan 18 14:07:03 centos8 kernel: BIOS-e820: [mem 0x000000000009f000-0x000000000009ffff] usableJan 18 14:07:03 centos8 kernel: BIOS-e820: [mem 0x00000000000a0000-0x00000000000fffff] reservedJan 18 14:07:03 centos8 kernel: BIOS-e820: [mem 0x0000000000100000-0x00000000c70fafff] usableJan 18 14:07:03 centos8 kernel: BIOS-e820: [mem 0x00000000c70fb000-0x00000000c7c7efff] reservedJan 18 14:07:03 centos8 kernel: BIOS-e820: [mem 0x00000000c7c7f000-0x00000000c7e7efff] ACPI NVS</pre>
<p>The output shows <a id="_idIndexMarker563"/>the time range of the log data. The columns contain the following data in order from left <span class="No-Break">to right:</span></p>
<ul>
<li>Date <span class="No-Break">and time</span></li>
<li><span class="No-Break">Host</span></li>
<li><span class="No-Break">Log source</span></li>
<li><span class="No-Break">Log message</span></li>
</ul>
<p>To show logs specific to the current boot, use the <strong class="source-inline">-b</strong> tag, <span class="No-Break">as follows:</span></p>
<pre class="source-code">
[voxsteel@centos8 ~]$ journalctl -b
-- Logs begin at Wed 2023-01-18 14:07:03 GMT, end at Wed 2023-01-18 16:36:10 GMT. --
Jan 18 14:07:03 centos8 kernel: microcode: microcode updated early to revision 0xd6, date = 2019-10-03
Jan 18 14:07:03 centos8 kernel: Linux version 4.18.0-348.7.1.el8_5.x86_64 (mockbuild@kbuilder.bsys.centos.org) (gcc version 8.5.0 20210514 (Red Hat 8.5.0-4) (GCC)&gt;
Jan 18 14:07:03 centos8 kernel: Command line: BOOT_IMAGE=(hd1,gpt2)/vmlinuz-4.18.0-348.7.1.el8_5.x86_64 root=/dev/mapper/cl-root ro crashkernel=auto resume=/dev/m&gt;
Jan 18 14:07:03 centos8 kernel: x86/fpu: Supporting XSAVE feature 0x001: 'x87 floating point registers'
Jan 18 14:07:03 centos8 kernel: x86/fpu: Enabled xstate features 0x1f, context size is 960 bytes, using 'compacted' format.
Jan 18 14:07:03 centos8 kernel: BIOS-provided physical RAM map:
Jan 18 14:07:03 centos8 kernel: BIOS-e820: [mem 0x0000000000000000-0x0000000000057fff] usable
Jan 18 14:07:03 centos8 kernel: BIOS-e820: [mem 0x0000000000058000-0x0000000000058fff] reserved
Jan 18 14:07:03 centos8 kernel: BIOS-e820: [mem 0x00000000c7eff000-0x00000000c7efffff] usable
Jan 18 14:07:03 centos8 kernel: BIOS-e820: [mem 0x00000000c7f00000-0x00000000cc7fffff] reserved</pre>
<p>If you want to see the <a id="_idIndexMarker564"/>logs from the last 10 minutes, for example, then you can use <strong class="source-inline">journalctl -S "10 </strong><span class="No-Break"><strong class="source-inline">minutes ago"</strong></span><span class="No-Break">:</span></p>
<pre class="source-code">
[voxsteel@centos8 ~]$ journalctl -S "10 minutes ago"
-- Logs begin at Wed 2023-01-18 14:07:03 GMT, end at Wed 2023-01-18 16:38:00 GMT. --
Jan 18 16:31:49 centos8 systemd[1]: run-docker-runtime\x2drunc-moby-586ec0d1511775a767ac92e0bc680e5ca772a18e59e31f9e358f9632834faede-runc.ucvxT5.mount: Succeeded.
Jan 18 16:32:54 centos8 dbus-daemon[1048]: [system] Activating service name='org.fedoraproject.Setroubleshootd' requested by ':1.30' (uid=0 pid=987 comm="/usr/sbi&gt;
Jan 18 16:32:54 centos8 dbus-daemon[1048]: [system] Successfully activated service 'org.fedoraproject.Setroubleshootd'
Jan 18 16:32:55 centos8 setroubleshoot[45450]: AnalyzeThread.run(): Cancel pending alarm
Jan 18 16:32:55 centos8 dbus-daemon[1048]: [system] Activating service name='org.fedoraproject.SetroubleshootPrivileged' requested by ':1.1032' (uid=978 pid=45450&gt;
Jan 18 16:32:56 centos8 dbus-daemon[1048]: [system] Successfully activated service 'org.fedoraproject.SetroubleshootPrivileged'
Jan 18 16:32:57 centos8 setroubleshoot[45450]: SELinux is preventing /usr/sbin/haproxy from name_connect access on the tcp_socket port 8082. For complete SELinux &gt;
Jan 18 16:32:57 centos8 setroubleshoot[45450]: SELinux is preventing /usr/sbin/haproxy from name_connect access on the tcp_socket port 8082.</pre>
<p>If you want to display <a id="_idIndexMarker565"/>only kernel journal log messages, then use the <strong class="source-inline">-k</strong> option, <span class="No-Break">as follows:</span></p>
<pre class="source-code">
[voxsteel@centos8 ~]$ journalctl -k
-- Logs begin at Wed 2023-01-18 14:07:03 GMT, end at Wed 2023-01-18 16:46:01 GMT. --
Jan 18 14:07:03 centos8 kernel: microcode: microcode updated early to revision 0xd6, date = 2019-10-03
Jan 18 14:07:03 centos8 kernel: Linux version 4.18.0-348.7.1.el8_5.x86_64 (mockbuild@kbuilder.bsys.centos.org) (gcc version 8.5.0 20210514 (Red Hat 8.5.0-4) (GCC)&gt;
Jan 18 14:07:03 centos8 kernel: Command line: BOOT_IMAGE=(hd1,gpt2)/vmlinuz-4.18.0-348.7.1.el8_5.x86_64 root=/dev/mapper/cl-root ro crashkernel=auto resume=/dev/m&gt;
Jan 18 14:07:03 centos8 kernel: x86/fpu: Supporting XSAVE feature 0x001: 'x87 floating point registers'
Jan 18 14:07:03 centos8 kernel: x86/fpu: Supporting XSAVE feature 0x002: 'SSE registers'
Jan 18 14:07:03 centos8 kernel: x86/fpu: Supporting XSAVE feature 0x004: 'AVX registers'</pre>
<p>You can also filter log messages based on priority using the <span class="No-Break">following command:</span></p>
<pre class="source-code">
journalctl -p &lt;number or text priority&gt;</pre>
<p>The following are the <span class="No-Break">priorities levels:</span></p>
<ul>
<li><strong class="bold">Emergency</strong>: <strong class="source-inline">0</strong> <span class="No-Break">or </span><span class="No-Break"><strong class="source-inline">emerg</strong></span></li>
<li><strong class="bold">Alert</strong>: <strong class="source-inline">1</strong> <span class="No-Break">or </span><span class="No-Break"><strong class="source-inline">alert</strong></span></li>
<li><strong class="bold">Critical</strong>: <strong class="source-inline">2</strong> <span class="No-Break">or </span><span class="No-Break"><strong class="source-inline">crit</strong></span></li>
<li><strong class="bold">Error</strong>: <strong class="source-inline">3</strong> <span class="No-Break">or </span><span class="No-Break"><strong class="source-inline">err</strong></span></li>
<li><strong class="bold">Warning</strong>: <strong class="source-inline">4</strong> <span class="No-Break">or </span><span class="No-Break"><strong class="source-inline">warning</strong></span></li>
<li><strong class="bold">Notice</strong>: <strong class="source-inline">5</strong> <span class="No-Break">or </span><span class="No-Break"><strong class="source-inline">notice</strong></span></li>
<li><strong class="bold">Inform</strong>: <strong class="source-inline">6</strong> <span class="No-Break">or </span><span class="No-Break"><strong class="source-inline">info</strong></span></li>
<li><strong class="bold">Debug</strong>: <strong class="source-inline">7</strong> <span class="No-Break">or </span><span class="No-Break"><strong class="source-inline">debug</strong></span></li>
</ul>
<p>You can find all the <a id="_idIndexMarker566"/>parameters available for <strong class="source-inline">journalctl</strong> using the <strong class="source-inline">man </strong><span class="No-Break"><strong class="source-inline">journalctl</strong></span><span class="No-Break"> command.</span></p>
<h1 id="_idParaDest-168"><a id="_idTextAnchor198"/>DMESG</h1>
<p><strong class="bold">dmesg</strong> is a command-line tool in<a id="_idIndexMarker567"/> Linux that allows you to view the kernel ring buffer messages. The kernel ring buffer is a circular buffer in memory that stores messages generated by the kernel, such <a id="_idIndexMarker568"/>as hardware events, device driver information, and system <span class="No-Break">error messages.</span></p>
<p>The <strong class="source-inline">dmesg</strong> command displays the contents of this kernel ring buffer, allowing you to view messages that have been generated since the system was last booted. These messages can be useful for debugging system problems, identifying hardware issues, and monitoring <span class="No-Break">system events.</span></p>
<p>Some of the common <a id="_idIndexMarker569"/>use cases of <strong class="source-inline">dmesg</strong> include <span class="No-Break">the following:</span></p>
<ul>
<li><strong class="bold">Troubleshooting system issues</strong>: <strong class="source-inline">dmesg</strong> can be used to identify and diagnose system problems by displaying error messages, warnings, and other <span class="No-Break">relevant information</span></li>
<li><strong class="bold">Checking hardware status</strong>: <strong class="source-inline">dmesg</strong> can provide information about hardware devices and drivers, such as when a device is detected or when a driver fails <span class="No-Break">to load</span></li>
<li><strong class="bold">Monitoring system events</strong>: <strong class="source-inline">dmesg</strong> can be used to monitor system events, such as when a user plugs in a USB device or when a system service starts <span class="No-Break">or stops</span></li>
</ul>
<p>Here are some commonly used options that are used with the <span class="No-Break"><strong class="source-inline">dmesg</strong></span><span class="No-Break"> command:</span></p>
<ul>
<li><strong class="source-inline">-T</strong>: Displays the timestamp in <span class="No-Break">human-readable format</span></li>
<li><strong class="source-inline">-H</strong>: Displays the output in a more <span class="No-Break">human-readable format</span></li>
<li><strong class="source-inline">-l level</strong>: Displays only messages of the specified log level (<strong class="source-inline">debug</strong>, <strong class="source-inline">info</strong>, <strong class="source-inline">notice</strong>, <strong class="source-inline">warning</strong>, <strong class="source-inline">err</strong>, <strong class="source-inline">crit</strong>, <strong class="source-inline">alert</strong>, <span class="No-Break">or </span><span class="No-Break"><strong class="source-inline">emerg</strong></span><span class="No-Break">)</span></li>
<li><strong class="source-inline">-k</strong>: Displays only <span class="No-Break">kernel messages</span></li>
</ul>
<p>Overall, <strong class="source-inline">dmesg</strong> is a powerful tool that can help you troubleshoot system problems and monitor <a id="_idIndexMarker570"/>system events <span class="No-Break">in Linux.</span></p>
<p>The <strong class="source-inline">dmesg</strong> command provides a window into the inner workings of Linux. This <em class="italic">fault finder’s friend</em> allows you to read and observe messages sent by the kernel’s hardware devices and drivers from the kernel’s internal <span class="No-Break">ring buffer.</span></p>
<h1 id="_idParaDest-169"><a id="_idTextAnchor199"/>Understanding the ring buffer in Linux</h1>
<p>When a computer is <a id="_idIndexMarker571"/>powered on, several events occur in a specific order; in Linux <a id="_idIndexMarker572"/>and Unix-like systems, these activities are referred to as booting and <span class="No-Break">startup, respectively.</span></p>
<p>After the initialization of the system has been completed by the boot procedures (BIOS or UEFI, MBR, and GRUB), the kernel is loaded into memory, the initial ramdisk (initrd or initramfs) is connected to the kernel, and systemd <span class="No-Break">is launched.</span></p>
<p>The OS is handed over to the startup routines, which finish the setup. When a system is first booted, it may take a while for logging daemons such as syslogd and rsyslogd to become operational. The kernel features a ring buffer that it employs as a message cache to ensure that critical error messages and warnings from this phase of initialization are <span class="No-Break">not lost.</span></p>
<p>A ring buffer is a special area <a id="_idIndexMarker573"/>of memory where messages can be stored. It has a standard size and straightforward construction. When it reaches capacity, newer messages replace older ones. It can be seen <a id="_idIndexMarker574"/>conceptually as a <span class="No-Break"><em class="italic">circular buffer</em></span><span class="No-Break">.</span></p>
<p>Information such as device driver initialization messages, hardware messages, and kernel module messages are all kept in the kernel ring buffer. The ring buffer is a handy place to begin troubleshooting hardware faults or other startup issues because it stores these <span class="No-Break">low-level messages.</span></p>
<p>With the <strong class="source-inline">dmesg</strong> command, you can examine the log of messages saved in the system’s <span class="No-Break">ring buffer:</span></p>
<pre class="source-code">
dmesg -T | less</pre>
<p>I added <strong class="source-inline">-T</strong> to show the timestamps in a readable format, and <strong class="source-inline">less</strong> to make <span class="No-Break">it scrollable.</span></p>
<p>The following is the output of the <span class="No-Break">preceding command:</span></p>
<pre class="source-code">
[Fri Jan 20 08:12:36 2023] wlp2s0: associate with d4:5d:64:e1:e0:2c (try 1/3)
[Fri Jan 20 08:12:36 2023] wlp2s0: RX AssocResp from d4:5d:64:e1:e0:2c (capab=0x1011 status=0 aid=5)
[Fri Jan 20 08:12:36 2023] wlp2s0: associated
[Fri Jan 20 08:12:36 2023] wlp2s0: Limiting TX power to 23 (23 - 0) dBm as advertised by d4:5d:64:e1:e0:2c
[Fri Jan 20 15:08:39 2023] atkbd serio0: Unknown key pressed (translated set 2, code 0x85 on isa0060/serio0).
[Fri Jan 20 15:08:39 2023] atkbd serio0: Use 'setkeycodes e005 &lt;keycode&gt;' to make it known.
[Mon Jan 23 06:27:58 2023] wlp2s0: deauthenticating from d4:5d:64:e1:e0:2c by local choice (Reason: 2=PREV_AUTH_NOT_VALID)
[Mon Jan 23 06:27:59 2023] wlp2s0: authenticate with d4:5d:64:e1:e0:2c
[Mon Jan 23 06:27:59 2023] wlp2s0: send auth to d4:5d:64:e1:e0:2c (try 1/3)
[Mon Jan 23 06:27:59 2023] wlp2s0: authenticated
[Mon Jan 23 06:27:59 2023] wlp2s0: associate with d4:5d:64:e1:e0:2c (try 1/3)
[Mon Jan 23 06:27:59 2023] wlp2s0: RX AssocResp from d4:5d:64:e1:e0:2c (capab=0x1011 status=0 aid=5)
[Mon Jan 23 06:27:59 2023] wlp2s0: associated
[Mon Jan 23 06:27:59 2023] wlp2s0: Limiting TX power to 23 (23 - 0) dBm as advertised by d4:5d:64:e1:e0:2cresume=/dev/mapper/cl-swap rd.lvm.lv=cl/root rd.lvm.lv=cl/swap rhgb quiet
[Wed Jan 18 14:06:39 2023] x86/fpu: Supporting XSAVE feature 0x001: 'x87 floating point registers'</pre>
<p>The <strong class="source-inline">dmesg --follow</strong> command is a variation of the <strong class="source-inline">dmesg</strong> command that continuously displays new messages as they are <a id="_idIndexMarker575"/>generated in the kernel <span class="No-Break">ring buffer.</span></p>
<p>When you run <strong class="source-inline">dmesg --follow</strong> in a Terminal, it will display the most recent kernel messages and then <a id="_idIndexMarker576"/>continue to display any new messages that are generated in real time. This <a id="_idIndexMarker577"/>can be useful for monitoring system events as they occur or for diagnosing issues that may be occurring in <span class="No-Break">real time.</span></p>
<p>The <strong class="source-inline">--follow</strong> option is equivalent to the <strong class="source-inline">-w</strong> or <strong class="source-inline">--wait</strong> option, which tells <strong class="source-inline">dmesg</strong> to wait for new messages to be added to the kernel ring buffer and display them as they <span class="No-Break">come in.</span></p>
<p>Here are some use cases for the <strong class="source-inline">dmesg --</strong><span class="No-Break"><strong class="source-inline">follow</strong></span><span class="No-Break"> command:</span></p>
<ul>
<li><strong class="bold">Monitoring hardware events</strong>: If you’re troubleshooting a hardware issue, you can use <strong class="source-inline">dmesg --follow</strong> to monitor <a id="_idIndexMarker578"/>the kernel messages as you plug or unplug devices, or as you interact <span class="No-Break">with hardware</span></li>
<li><strong class="bold">Debugging system issues</strong>: If you’re trying to diagnose a system issue, <strong class="source-inline">dmesg --follow</strong> can help you see what’s happening in real time and identify any patterns or issues that may be causing <span class="No-Break">the problem</span></li>
<li><strong class="bold">Monitoring system health</strong>: If you want to keep an eye on your system’s health, you can use <strong class="source-inline">dmesg --follow</strong> to watch for any error messages or warnings that may be generated in the kernel <span class="No-Break">ring buffer</span></li>
</ul>
<p>It’s worth noting <a id="_idIndexMarker579"/>that because <strong class="source-inline">dmesg --follow</strong> continuously displays new messages, the <a id="_idIndexMarker580"/>output can quickly become overwhelming and difficult to read. To stop the <strong class="source-inline">dmesg</strong> command from running, you can press <em class="italic">Ctrl</em> + <em class="italic">C</em> in <span class="No-Break">the terminal:</span></p>
<pre class="source-code">
dmesg –follow
[151557.551942] wlp2s0: Limiting TX power to 23 (23 - 0) dBm as advertised by d4:5d:64:e1:e0:2c
[176520.971449] atkbd serio0: Unknown key pressed (translated set 2, code 0x85 on isa0060/serio0).
[176520.971452] atkbd serio0: Use 'setkeycodes e005 &lt;keycode&gt;' to make it known.
[404479.355923] wlp2s0: deauthenticating from d4:5d:64:e1:e0:2c by local choice (Reason: 2=PREV_AUTH_NOT_VALID)
[404480.713565] wlp2s0: authenticate with d4:5d:64:e1:e0:2c
[404480.722235] wlp2s0: send auth to d4:5d:64:e1:e0:2c (try 1/3)
[404480.724148] wlp2s0: authenticated
[404480.724865] wlp2s0: associate with d4:5d:64:e1:e0:2c (try 1/3)
[404480.725868] wlp2s0: RX AssocResp from d4:5d:64:e1:e0:2c (capab=0x1011 status=0 aid=5)
[404480.727602] wlp2s0: associated
[404480.781339] wlp2s0: Limiting TX power to 23 (23 - 0) dBm as advertised by d4:5d:64:e1:e0:2c</pre>
<p>Observe that you are not taken back to the prompt where you entered commands. Whenever fresh messages are received, <strong class="source-inline">dmesg</strong> will show them in the <span class="No-Break">Terminal’s footer.</span></p>
<p>You can see the last 15 messages, for example, by using the <span class="No-Break">following command:</span></p>
<pre class="source-code">
dmesg | tail -15</pre>
<p>Alternatively, you can <a id="_idIndexMarker581"/>search for specific terms (for example, <strong class="source-inline">memory</strong>) using <a id="_idIndexMarker582"/>the <strong class="source-inline">dmesg | grep -I </strong><span class="No-Break"><strong class="source-inline">memory</strong></span><span class="No-Break"> command:</span></p>
<pre class="source-code">
[    0.000000] Memory: 2839388K/12460644K available (12293K kernel code, 2261K rwdata, 7872K rodata, 2492K init, 13944K bss, 795924K reserved, 0K cma-reserved)
[    0.021777] Freeing SMP alternatives memory: 32K
[    0.048199] x86/mm: Memory block size: 128MB
[    4.052723] Freeing initrd memory: 53084K
[    4.215935] Non-volatile memory driver v1.3
[    6.181994] Freeing unused decrypted memory: 2036K
[    6.182301] Freeing unused kernel memory: 2492K
[    6.188636] Freeing unused kernel memory: 2012K
[    6.188833] Freeing unused kernel memory: 320K
[    8.302610] i915 0000:00:02.0: [drm] Reducing the compressed framebuffer size. This may lead to less power savings than a non-reduced-size. Try to increase stolen memory size if available in BIOS.
[   37.829370] PM: Saving platform NVS memory
[   37.837899] PM: Restoring platform NVS memory</pre>
<p>Use the <strong class="source-inline">man</strong> command to find out all the magic that you can do with one command. <strong class="source-inline">dmesg</strong> is a very powerful tool for <span class="No-Break">investigating logs.</span></p>
<h1 id="_idParaDest-170"><a id="_idTextAnchor200"/>Summary</h1>
<p>In this chapter, you learned about logs and how to configure rsyslog for centralized logging. Using various rsyslog input and output plugins, you transmitted server logs over the network to the consolidated rsyslog server. Your rsyslog server is now the only location you need to look <span class="No-Break">for logs.</span></p>
<p>We also provided examples of how to read systemd journal logs. The <strong class="source-inline">journalctl</strong> command is a powerful resource for diagnosing issues with Linux services and finding problems in <span class="No-Break">the OS.</span></p>
<p>Finally, you learned about the power of the <strong class="source-inline">dmesg</strong> command and how it can be used. <strong class="source-inline">dmesg</strong> is a powerful tool that can help you troubleshoot system problems and monitor system events <span class="No-Break">in Linux.</span></p>
<p>In the next chapter, we will talk about centralized authentication, where you can use a single server for all your clients to <span class="No-Break">authenticate against.</span></p>
</div>
</div></body></html>