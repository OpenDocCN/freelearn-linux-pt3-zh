<html><head></head><body>
<div id="_idContainer075">
<h1 class="chapter-number" id="_idParaDest-111"><a id="_idTextAnchor124"/><span class="koboSpan" id="kobo.1.1">7</span></h1>
<h1 id="_idParaDest-112"><a id="_idTextAnchor125"/><span class="koboSpan" id="kobo.2.1">The SCSI Subsystem</span></h1>
<p><span class="koboSpan" id="kobo.3.1">Throughout this book, we’ve gradually traversed from the higher layers in the storage stack to the lower layer. </span><span class="koboSpan" id="kobo.3.2">We started from VFS, explored the major VFS structures and filesystems, and explored the structures and scheduling techniques in the block layer. </span><span class="koboSpan" id="kobo.3.3">The VFS and block layer represent a major portion of the software side of things in the I/O hierarchy. </span><span class="koboSpan" id="kobo.3.4">As we gradually move down the ladder and enter the physical layer, things are slightly more generic, as the lower-level standards used to address physical drives are the same for </span><span class="No-Break"><span class="koboSpan" id="kobo.4.1">most systems.</span></span></p>
<p><span class="koboSpan" id="kobo.5.1">The </span><em class="italic"><span class="koboSpan" id="kobo.6.1">third part</span></em><span class="koboSpan" id="kobo.7.1"> of this book contains two chapters that are dedicated to building an understanding of the physical side of things. </span><span class="koboSpan" id="kobo.7.2">In this chapter, we’ll mainly focus on one particular subsystem that has existed for a while and is the most common standard and protocol for addressing physical devices, </span><strong class="bold"><span class="koboSpan" id="kobo.8.1">Small Computer System </span></strong><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.9.1">Interface</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.10.1"> (</span></span><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.11.1">SCSI</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.12.1">).</span></span></p>
<p><span class="koboSpan" id="kobo.13.1">The development of the SCSI protocol aimed to facilitate seamless data transfer between computers and peripheral devices, including disk drives, CD-ROMs, printers, scanners, and various other resources, ensuring efficient and reliable communication. </span><span class="koboSpan" id="kobo.13.2">Since we’re focusing on storage here, we’re only going to discuss its role in terms of disk drives. </span><span class="koboSpan" id="kobo.13.3">Any read or write request that is handed to SCSI from the upper layers is transformed into an equivalent SCSI command. </span><span class="koboSpan" id="kobo.13.4">It’s important to understand that SCSI does not handle the arrangement of blocks for transportation or their physical placement on disk. </span><span class="koboSpan" id="kobo.13.5">That comes under the ownership of the upper layers in the </span><span class="No-Break"><span class="koboSpan" id="kobo.14.1">I/O hierarchy.</span></span></p>
<p><span class="koboSpan" id="kobo.15.1">Before we dive into SCSI, it is important to get a basic understanding of the device model in Linux. </span><span class="koboSpan" id="kobo.15.2">The </span><strong class="bold"><span class="koboSpan" id="kobo.16.1">Linux Device Model</span></strong><span class="koboSpan" id="kobo.17.1">, based on the </span><strong class="source-inline"><span class="koboSpan" id="kobo.18.1">kobject</span></strong><span class="koboSpan" id="kobo.19.1"> structure in the kernel, provides a range of constructs that enable smooth communication and interaction between hardware devices and their corresponding device drivers. </span><span class="koboSpan" id="kobo.19.2">After getting some basic knowledge of the device model, we’ll try to explain the major components of the </span><span class="No-Break"><span class="koboSpan" id="kobo.20.1">SCSI subsystem.</span></span></p>
<p><span class="koboSpan" id="kobo.21.1">In this chapter, we will discuss the following </span><span class="No-Break"><span class="koboSpan" id="kobo.22.1">main topics:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.23.1">The device </span><span class="No-Break"><span class="koboSpan" id="kobo.24.1">driver model</span></span></li>
<li><span class="koboSpan" id="kobo.25.1">The </span><span class="No-Break"><span class="koboSpan" id="kobo.26.1">SCSI subsystem</span></span></li>
</ul>
<h1 id="_idParaDest-113"><a id="_idTextAnchor126"/><span class="koboSpan" id="kobo.27.1">Technical requirements</span></h1>
<p><span class="koboSpan" id="kobo.28.1">As SCSI is a protocol used to communicate with peripheral devices, such as hard drives, some basic knowledge about the functioning of these devices will aid in understanding the </span><span class="No-Break"><span class="koboSpan" id="kobo.29.1">SCSI subsystem.</span></span></p>
<p><span class="koboSpan" id="kobo.30.1">The commands and examples presented in this chapter are distribution-agnostic and can be run on any Linux operating system, such as Debian, Ubuntu, Red Hat, or Fedora. </span><span class="koboSpan" id="kobo.30.2">There are quite a few references to the kernel source code. </span><span class="koboSpan" id="kobo.30.3">If you want to download the kernel source, you can download it </span><span class="No-Break"><span class="koboSpan" id="kobo.31.1">from </span></span><a href="https://www.kernel.org"><span class="No-Break"><span class="koboSpan" id="kobo.32.1">https://www.kernel.org</span></span></a><span class="No-Break"><span class="koboSpan" id="kobo.33.1">.</span></span></p>
<h1 id="_idParaDest-114"><a id="_idTextAnchor127"/><span class="koboSpan" id="kobo.34.1">The device driver model</span></h1>
<p><span class="koboSpan" id="kobo.35.1">There are different subsystems in the kernel, such as the </span><strong class="bold"><span class="koboSpan" id="kobo.36.1">system call interface</span></strong><span class="koboSpan" id="kobo.37.1">, </span><strong class="bold"><span class="koboSpan" id="kobo.38.1">VFS</span></strong><span class="koboSpan" id="kobo.39.1">, </span><strong class="bold"><span class="koboSpan" id="kobo.40.1">process and memory management</span></strong><span class="koboSpan" id="kobo.41.1">, and the </span><strong class="bold"><span class="koboSpan" id="kobo.42.1">network stack</span></strong><span class="koboSpan" id="kobo.43.1">. </span><span class="koboSpan" id="kobo.43.2">Throughout this book, we’ve strictly kept our focus on the structures and entities that are a part of the I/O hierarchy in Linux. </span><span class="koboSpan" id="kobo.43.3">However, in reality, the process of reading and writing data to a storage device has to pass through most of these subsystems. </span><span class="koboSpan" id="kobo.43.4">As we saw, abstraction layers are the alpha and omega of the I/O stack, but this abstracted approach is not just limited to storage devices. </span><span class="koboSpan" id="kobo.43.5">For the kernel, the disk is just one of several pieces of hardware that it must manage. </span><span class="koboSpan" id="kobo.43.6">If there was a unique subsystem for managing the different types of devices, it would result in a bloated piece of code. </span><span class="koboSpan" id="kobo.43.7">Of course, different types of devices tend to be treated differently, as they might have contrasting roles, but for the end user, there should be a general abstract view of the </span><span class="No-Break"><span class="koboSpan" id="kobo.44.1">system structure.</span></span></p>
<p><span class="koboSpan" id="kobo.45.1">To achieve this unification, the Linux Device Model extracts the common attributes of device operations, abstracts them, and implements these common attributes in the kernel, providing a unified interface for newly added devices. </span><span class="koboSpan" id="kobo.45.2">This makes the driver development process much easier and smoother, as the developers only need to familiarize themselves with </span><span class="No-Break"><span class="koboSpan" id="kobo.46.1">the interface.</span></span></p>
<p><span class="koboSpan" id="kobo.47.1">The device model’s main objective is to maintain internal data structures that accurately represent a system’s state and configuration. </span><span class="koboSpan" id="kobo.47.2">This encompasses vital information such as the presence of devices, their associated buses and drivers, as well as the overall hierarchy and structure of buses, devices, and drivers within the system. </span><span class="koboSpan" id="kobo.47.3">To keep track of this information, the device model makes use of the following entities to map them to their </span><span class="No-Break"><span class="koboSpan" id="kobo.48.1">physical counterparts:</span></span></p>
<ul>
<li><strong class="bold"><span class="koboSpan" id="kobo.49.1">Bus</span></strong><span class="koboSpan" id="kobo.50.1">: There are several components in a system, such as CPU, memory, and input and output devices. </span><span class="koboSpan" id="kobo.50.2">Communication between these devices is dependent on a channel, which is the bus. </span><span class="koboSpan" id="kobo.50.3">The bus is a channel to transmit data. </span><span class="koboSpan" id="kobo.50.4">Think of it as a linear channel for the conveyance of traffic, similar to a road. </span><span class="koboSpan" id="kobo.50.5">In order to facilitate the abstraction of the device model, all devices should be connected to a bus. </span><span class="koboSpan" id="kobo.50.6">The bus in the device model is an abstraction based on the </span><span class="No-Break"><span class="koboSpan" id="kobo.51.1">physical bus.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.52.1">Device</span></strong><span class="koboSpan" id="kobo.53.1">: This represents a physical device that is attached to a bus. </span><span class="koboSpan" id="kobo.53.2">In the device model, the </span><em class="italic"><span class="koboSpan" id="kobo.54.1">device</span></em><span class="koboSpan" id="kobo.55.1"> abstracts all hardware devices in the system and describes their attributes, the bus it is connected to, and </span><span class="No-Break"><span class="koboSpan" id="kobo.56.1">other information.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.57.1">Device driver</span></strong><span class="koboSpan" id="kobo.58.1">: The driver is a software entity that is associated with a device. </span><span class="koboSpan" id="kobo.58.2">The device model uses the driver to abstract the driver of the hardware device, which includes device initialization and power management-related </span><span class="No-Break"><span class="koboSpan" id="kobo.59.1">interface implementations.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.60.1">Class</span></strong><span class="koboSpan" id="kobo.61.1">: The concept of class is a bit interesting. </span><span class="koboSpan" id="kobo.61.2">A class represents a collection of devices with similar functions or attributes. </span><span class="koboSpan" id="kobo.61.3">For example, there are SCSI and </span><strong class="bold"><span class="koboSpan" id="kobo.62.1">Advanced Technology Attachment</span></strong><span class="koboSpan" id="kobo.63.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.64.1">ATA</span></strong><span class="koboSpan" id="kobo.65.1">) drivers, which fall under the same disk class. </span><span class="koboSpan" id="kobo.65.2">Classes serve as a means of categorizing devices based on their functionality rather than their connectivity or operational mechanisms. </span><span class="koboSpan" id="kobo.65.3">This is a bit similar to the concept of classes in </span><span class="No-Break"><span class="koboSpan" id="kobo.66.1">object-oriented programming.</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.67.1">The device model provides a generic mechanism to represent and operate on every device in the system. </span><span class="koboSpan" id="kobo.67.2">As we explained in </span><a href="B19430_01.xhtml#_idTextAnchor015"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.68.1">Chapter 1</span></em></span></a><span class="koboSpan" id="kobo.69.1"> of this book, the kernel provides a window to export information about various kernel subsystems through VFS. </span><span class="koboSpan" id="kobo.69.2">The representation of the device model in user space can be viewed through the </span><strong class="source-inline"><span class="koboSpan" id="kobo.70.1">Sysfs</span></strong><span class="koboSpan" id="kobo.71.1"> VFS. </span><span class="koboSpan" id="kobo.71.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.72.1">Sysfs</span></strong><span class="koboSpan" id="kobo.73.1"> filesystem is mounted on the </span><strong class="source-inline"><span class="koboSpan" id="kobo.74.1">/sys</span></strong><span class="koboSpan" id="kobo.75.1"> directory, as shown in the </span><span class="No-Break"><span class="koboSpan" id="kobo.76.1">following screenshot:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer065">
<span class="koboSpan" id="kobo.77.1"><img alt="Figure 7.1 – The contents of Sysfs" src="image/B19430_07_01.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.78.1">Figure 7.1 – The contents of Sysfs</span></p>
<p><span class="koboSpan" id="kobo.79.1">The directories contain the </span><span class="No-Break"><span class="koboSpan" id="kobo.80.1">following information:</span></span></p>
<ul>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.81.1">block</span></strong><span class="koboSpan" id="kobo.82.1">: This encompasses all available block devices within the system, including disks </span><span class="No-Break"><span class="koboSpan" id="kobo.83.1">and partitions</span></span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.84.1">bus</span></strong><span class="koboSpan" id="kobo.85.1">: This represents various types of buses to which physical devices are connected, such as PCI, IDE, </span><span class="No-Break"><span class="koboSpan" id="kobo.86.1">and USB</span></span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.87.1">class</span></strong><span class="koboSpan" id="kobo.88.1">: This denotes the available driver classes in the system, such as network, sound, </span><span class="No-Break"><span class="koboSpan" id="kobo.89.1">and USB</span></span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.90.1">devices</span></strong><span class="koboSpan" id="kobo.91.1">: This signifies the hierarchical structure of connected devices within </span><span class="No-Break"><span class="koboSpan" id="kobo.92.1">the system</span></span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.93.1">firmware</span></strong><span class="koboSpan" id="kobo.94.1">: This contains information retrieved from system firmware, </span><span class="No-Break"><span class="koboSpan" id="kobo.95.1">particularly ACPI</span></span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.96.1">fs</span></strong><span class="koboSpan" id="kobo.97.1">: This provides details regarding the mounted </span><span class="No-Break"><span class="koboSpan" id="kobo.98.1">file systems</span></span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.99.1">kernel</span></strong><span class="koboSpan" id="kobo.100.1">: This offers kernel status information, including logged-in users and </span><span class="No-Break"><span class="koboSpan" id="kobo.101.1">hotplug events</span></span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.102.1">module</span></strong><span class="koboSpan" id="kobo.103.1">: This presents the current list of </span><span class="No-Break"><span class="koboSpan" id="kobo.104.1">loaded modules</span></span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.105.1">power</span></strong><span class="koboSpan" id="kobo.106.1">: This encompasses information pertaining to the power </span><span class="No-Break"><span class="koboSpan" id="kobo.107.1">management subsystem.</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.108.1">There is a correlation between the kernel data structures within the described model and the sub-directories in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.109.1">Sysfs</span></strong><span class="koboSpan" id="kobo.110.1"> VFS. </span><span class="koboSpan" id="kobo.110.2">There are a number of structures in the device model that allow communication between a device driver and the corresponding hardware device. </span><span class="koboSpan" id="kobo.110.3">We’re not going to explore these structures, but just so you know, the basic structure of the Linux Device Model is </span><strong class="source-inline"><span class="koboSpan" id="kobo.111.1">kobject</span></strong><span class="koboSpan" id="kobo.112.1">. </span><span class="koboSpan" id="kobo.112.2">Think of </span><strong class="source-inline"><span class="koboSpan" id="kobo.113.1">kobject</span></strong><span class="koboSpan" id="kobo.114.1"> as the glue that holds the device model and the </span><strong class="source-inline"><span class="koboSpan" id="kobo.115.1">Sysfs</span></strong><span class="koboSpan" id="kobo.116.1"> interface together. </span><span class="koboSpan" id="kobo.116.2">The structures in the higher levels of the model, as depicted in </span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.117.1">Figure 7</span></em></span><em class="italic"><span class="koboSpan" id="kobo.118.1">.2</span></em><span class="koboSpan" id="kobo.119.1">, are </span><span class="No-Break"><span class="koboSpan" id="kobo.120.1">as follows:</span></span></p>
<ul>
<li><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.121.1">struct bus_type</span></strong></span></li>
<li><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.122.1">struct device</span></strong></span></li>
<li><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.123.1">struct device_driver</span></strong></span></li>
</ul>
<p><span class="koboSpan" id="kobo.124.1">Here is </span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.125.1">Figure 7</span></em></span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.126.1">.2</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.127.1">:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer066">
<span class="koboSpan" id="kobo.128.1"><img alt="Figure 7.2 – The device model components" src="image/B19430_07_02.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.129.1">Figure 7.2 – The device model components</span></p>
<p><span class="koboSpan" id="kobo.130.1">To summarize, the Linux device model classifies hardware devices and implements abstraction through a set of standard data structures and interfaces. </span><span class="koboSpan" id="kobo.130.2">This model can be seen through user space by viewing the contents of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.131.1">Sysfs</span></strong><span class="koboSpan" id="kobo.132.1"> filesystem. </span><span class="koboSpan" id="kobo.132.2">The entities present in </span><strong class="source-inline"><span class="koboSpan" id="kobo.133.1">Sysfs</span></strong><span class="koboSpan" id="kobo.134.1"> have a close association with the actual physical implementations. </span><span class="koboSpan" id="kobo.134.2">Let’s move on and explore the architecture of the SCSI subsystem in </span><span class="No-Break"><span class="koboSpan" id="kobo.135.1">more detail.</span></span></p>
<h1 id="_idParaDest-115"><a id="_idTextAnchor128"/><span class="koboSpan" id="kobo.136.1">Explaining the SCSI subsystem</span></h1>
<p><span class="koboSpan" id="kobo.137.1">People can mean a couple of things when referring to the </span><strong class="bold"><span class="koboSpan" id="kobo.138.1">SCSI (</span></strong><span class="No-Break"><span class="koboSpan" id="kobo.139.1">pronounced SKUZ-ee):</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.140.1">A hardware bus to connect peripherals to </span><span class="No-Break"><span class="koboSpan" id="kobo.141.1">a computer</span></span></li>
<li><span class="koboSpan" id="kobo.142.1">A command set to communicate with devices over different types </span><span class="No-Break"><span class="koboSpan" id="kobo.143.1">of buses</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.144.1">For a long time, SCSI was the primary technology for I/O buses in computers. </span><span class="koboSpan" id="kobo.144.2">SCSI defines both an interface and a data protocol for connecting different types of devices to a computer. </span><span class="koboSpan" id="kobo.144.3">As a medium, SCSI defines a bus for data transmission. </span><span class="koboSpan" id="kobo.144.4">As a protocol, it defines how devices communicate with each other via the </span><span class="No-Break"><span class="koboSpan" id="kobo.145.1">SCSI bus.</span></span></p>
<p><span class="koboSpan" id="kobo.146.1">Initially, the connectivity of peripheral devices was achieved through a parallel SCSI bus. </span><span class="koboSpan" id="kobo.146.2">Over the years, the SCSI parallel bus has fallen out of favor and has been replaced with serial interfaces. </span><span class="koboSpan" id="kobo.146.3">The most common of these interfaces include </span><strong class="bold"><span class="koboSpan" id="kobo.147.1">Serial Attached SCSI</span></strong><span class="koboSpan" id="kobo.148.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.149.1">SAS</span></strong><span class="koboSpan" id="kobo.150.1">) and </span><strong class="bold"><span class="koboSpan" id="kobo.151.1">SCSI over Fibre Channel</span></strong><span class="koboSpan" id="kobo.152.1">. </span><span class="koboSpan" id="kobo.152.2">The serial interfaces provide far better data transfer rates and reliability. </span><span class="koboSpan" id="kobo.152.3">There is also an implementation of the SCSI protocol over TCP/IP, known as </span><strong class="bold"><span class="koboSpan" id="kobo.153.1">Internet </span></strong><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.154.1">SCSI</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.155.1"> (</span></span><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.156.1">iSCSI</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.157.1">).</span></span></p>
<p><span class="koboSpan" id="kobo.158.1">We will keep our focus here on the Linux side of things and discuss the organization of the SCSI subsystem in the I/O hierarchy. </span><span class="koboSpan" id="kobo.158.2">The SCSI standard defines command sets for a wide variety of devices, not just for hard drives. </span><span class="koboSpan" id="kobo.158.3">The SCSI commands can be sent over just about any kind of transporting mechanism. </span><span class="koboSpan" id="kobo.158.4">This makes SCSI the ipso facto standard for storage devices accessed via the SATA, SAS, or Fibre </span><span class="No-Break"><span class="koboSpan" id="kobo.159.1">Channel protocol.</span></span></p>
<h2 id="_idParaDest-116"><a id="_idTextAnchor129"/><span class="koboSpan" id="kobo.160.1">SCSI architecture</span></h2>
<p><span class="koboSpan" id="kobo.161.1">The SCSI subsystem uses a three-level architecture. </span><span class="koboSpan" id="kobo.161.2">The layer at the top represents the kernel’s highest interface for end user applications. </span><span class="koboSpan" id="kobo.161.3">The layer at the center provides some common services to the upper and lower layers of the SCSI stack. </span><span class="koboSpan" id="kobo.161.4">At the very bottom is the lower layer. </span><span class="koboSpan" id="kobo.161.5">The lower layer contains the actual drivers that interact with the underlying physical devices. </span><span class="koboSpan" id="kobo.161.6">Every operation involving the SCSI subsystem uses one driver at each of three layers. </span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.162.1">Figure 7</span></em></span><em class="italic"><span class="koboSpan" id="kobo.163.1">.3</span></em><span class="koboSpan" id="kobo.164.1"> highlights the multilayered design of the </span><span class="No-Break"><span class="koboSpan" id="kobo.165.1">SCSI subsystem:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer067">
<span class="koboSpan" id="kobo.166.1"><img alt="Figure 7.3 – SCSI architecture" src="image/B19430_07_03.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.167.1">Figure 7.3 – SCSI architecture</span></p>
<p><span class="koboSpan" id="kobo.168.1">The three layers are described in a bit more detail in the </span><span class="No-Break"><span class="koboSpan" id="kobo.169.1">following subsections.</span></span></p>
<h3><span class="koboSpan" id="kobo.170.1">Upper layer</span></h3>
<p><span class="koboSpan" id="kobo.171.1">The </span><strong class="bold"><span class="koboSpan" id="kobo.172.1">upper layer</span></strong><span class="koboSpan" id="kobo.173.1"> contains specific device-type drivers that are closest to the user space applications. </span><span class="koboSpan" id="kobo.173.2">These upper-layer drivers provide the interface between user space and kernel space. </span><span class="koboSpan" id="kobo.173.3">The most commonly used upper-layer drivers include </span><span class="No-Break"><span class="koboSpan" id="kobo.174.1">the following:</span></span></p>
<ul>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.175.1">sd</span></strong><span class="koboSpan" id="kobo.176.1">: The </span><span class="No-Break"><span class="koboSpan" id="kobo.177.1">disk driver</span></span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.178.1">sr</span></strong><span class="koboSpan" id="kobo.179.1">: The </span><span class="No-Break"><span class="koboSpan" id="kobo.180.1">CD-ROM driver</span></span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.181.1">sg</span></strong><span class="koboSpan" id="kobo.182.1">: The generic </span><span class="No-Break"><span class="koboSpan" id="kobo.183.1">SCSI driver</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.184.1">After looking at these driver names, it should come as no surprise that the device names for the corresponding device types are abbreviated with the prefix of the driver, such as </span><strong class="source-inline"><span class="koboSpan" id="kobo.185.1">sda</span></strong><span class="koboSpan" id="kobo.186.1">. </span><span class="koboSpan" id="kobo.186.2">The upper layer accepts requests from higher layers in the storage stack, such as VFS, and translates them into equivalent SCSI requests with the help of the middle and lower layers. </span><span class="koboSpan" id="kobo.186.3">After the completion of SCSI commands, the upper-level drivers inform the higher layers. </span><span class="koboSpan" id="kobo.186.4">The generic SCSI driver, </span><strong class="source-inline"><span class="koboSpan" id="kobo.187.1">sg</span></strong><span class="koboSpan" id="kobo.188.1">, allows you to directly send SCSI commands to SCSI devices, bypassing the </span><span class="No-Break"><span class="koboSpan" id="kobo.189.1">filesystem layer.</span></span></p>
<p><span class="koboSpan" id="kobo.190.1">The upper-level SCSI disk drivers are implemented in </span><strong class="source-inline"><span class="koboSpan" id="kobo.191.1">/linux/drivers/scsi/sd.c</span></strong><span class="koboSpan" id="kobo.192.1">. </span><span class="koboSpan" id="kobo.192.2">The upper-layer SCSI disk drivers self-initialize by calling </span><strong class="source-inline"><span class="koboSpan" id="kobo.193.1">register_blkdev</span></strong><span class="koboSpan" id="kobo.194.1"> to register as block devices, providing a set of functions through the </span><strong class="source-inline"><span class="koboSpan" id="kobo.195.1">scsi_register_driver</span></strong><span class="koboSpan" id="kobo.196.1"> function to represent all the </span><span class="No-Break"><span class="koboSpan" id="kobo.197.1">SCSI devices.</span></span></p>
<h3><span class="koboSpan" id="kobo.198.1">Mid layer</span></h3>
<p><span class="koboSpan" id="kobo.199.1">The </span><strong class="bold"><span class="koboSpan" id="kobo.200.1">mid layer</span></strong><span class="koboSpan" id="kobo.201.1"> is common to all SCSI operations and contains the core of the SCSI support. </span><span class="koboSpan" id="kobo.201.2">The mid layer stitches together the upper and lower layers by defining internal interfaces and providing common services to the upper- and lower-level drivers. </span><span class="koboSpan" id="kobo.201.3">It oversees the management of SCSI command queues, ensures efficient error handling, and facilitates power management functions. </span><span class="koboSpan" id="kobo.201.4">The upper- and lower-level drivers cannot function without the functionality provided by the </span><span class="No-Break"><span class="koboSpan" id="kobo.202.1">mid layer.</span></span></p>
<p><span class="koboSpan" id="kobo.203.1">The generic mid-level SCSI driver is implemented in </span><strong class="source-inline"><span class="koboSpan" id="kobo.204.1">linux/drivers/scsi/scsi.c</span></strong><span class="koboSpan" id="kobo.205.1">. </span><span class="koboSpan" id="kobo.205.2">The mid layer abstracts the implementation of the lower-level drivers and transforms commands from the upper layers into equivalent SCSI requests. </span><span class="koboSpan" id="kobo.205.3">The mid layer also implements command queuing. </span><span class="koboSpan" id="kobo.205.4">When a request is received from the upper layer, the mid layer queues the requests for processing. </span><span class="koboSpan" id="kobo.205.5">Once the requests have been served, it receives the response from the lower layer and notifies the upper layer. </span><span class="koboSpan" id="kobo.205.6">If a request times out, it is the responsibility of the mid layer to perform error handling or resend </span><span class="No-Break"><span class="koboSpan" id="kobo.206.1">the request.</span></span></p>
<p><span class="koboSpan" id="kobo.207.1">There are a couple of important functions through which the mid layer serves as a bridge between the upper and lower layers, </span><strong class="source-inline"><span class="koboSpan" id="kobo.208.1">sd_probe</span></strong><span class="koboSpan" id="kobo.209.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.210.1">sd_init</span></strong><span class="koboSpan" id="kobo.211.1">. </span><span class="koboSpan" id="kobo.211.2">During driver initialization and whenever a new SCSI device is connected to the system, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.212.1">sd_probe</span></strong><span class="koboSpan" id="kobo.213.1"> function plays a crucial role in determining whether the device is under the management of a SCSI disk driver. </span><span class="koboSpan" id="kobo.213.2">If the device falls within the purview of management, </span><strong class="source-inline"><span class="koboSpan" id="kobo.214.1">sd_probe</span></strong><span class="koboSpan" id="kobo.215.1"> generates a fresh </span><strong class="source-inline"><span class="koboSpan" id="kobo.216.1">scsi_disk</span></strong><span class="koboSpan" id="kobo.217.1"> structure to serve as its representative entity. </span><span class="koboSpan" id="kobo.217.2">When a read or write request is received from higher layers in the storage stack, such as a filesystem, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.218.1">sd_init_command</span></strong><span class="koboSpan" id="kobo.219.1"> function converts that request into an equivalent SCSI read or </span><span class="No-Break"><span class="koboSpan" id="kobo.220.1">write command.</span></span></p>
<h3><span class="koboSpan" id="kobo.221.1">Lower layer</span></h3>
<p><span class="koboSpan" id="kobo.222.1">The </span><strong class="bold"><span class="koboSpan" id="kobo.223.1">lower-level drivers</span></strong><span class="koboSpan" id="kobo.224.1"> are the closest to the hardware. </span><span class="koboSpan" id="kobo.224.2">These are the drivers for the various adapters and controllers supported by the operating system. </span><span class="koboSpan" id="kobo.224.3">These adapters or controllers are often called </span><strong class="bold"><span class="koboSpan" id="kobo.225.1">Host Bus Adapters</span></strong><span class="koboSpan" id="kobo.226.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.227.1">HBAs</span></strong><span class="koboSpan" id="kobo.228.1">). </span><span class="koboSpan" id="kobo.228.2">The lower-level drivers provide the actual support for the hardware platform running underneath. </span><span class="koboSpan" id="kobo.228.3">The lower-level drivers are vendor-specific and provide an interface to the underlying hardware. </span><span class="koboSpan" id="kobo.228.4">For example, </span><strong class="source-inline"><span class="koboSpan" id="kobo.229.1">lpfc</span></strong><span class="koboSpan" id="kobo.230.1"> is the device driver for Emulex HBAs. </span><span class="koboSpan" id="kobo.230.2">The lower-level drivers are present in the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.231.1">linux/drivers/scsi/</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.232.1"> directory.</span></span></p>
<p><span class="koboSpan" id="kobo.233.1">Now, let’s delve deeper into how the SCSI subsystem can be classified as operating within a </span><span class="No-Break"><span class="koboSpan" id="kobo.234.1">client-server model.</span></span></p>
<h2 id="_idParaDest-117"><a id="_idTextAnchor130"/><span class="koboSpan" id="kobo.235.1">The client and server model</span></h2>
<p><span class="koboSpan" id="kobo.236.1">The SCSI subsystem receives requests from higher layers in the storage stack to send or retrieve blocks of data from a storage device. </span><span class="koboSpan" id="kobo.236.2">When an application initiates a read or write request, the SCSI layer treats this request by transforming it into the equivalent SCSI command. </span><span class="koboSpan" id="kobo.236.3">The SCSI subsystem does not handle how data blocks are organized and placed on the storage device; that is the job of the higher layers in the I/O stack. </span><span class="koboSpan" id="kobo.236.4">SCSI sends blocks to a destination device, which can either be an individual disk or a </span><strong class="bold"><span class="koboSpan" id="kobo.237.1">redundant array of independent disks</span></strong><span class="koboSpan" id="kobo.238.1"> (</span><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.239.1">RAID</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.240.1">) controller.</span></span></p>
<p><span class="koboSpan" id="kobo.241.1">As the SCSI layer on the operating system side commences an operation on the storage device and the storage device, in turn, responds by performing said operation, this flow of events can be categorized as a client-server exchange model. </span><span class="koboSpan" id="kobo.241.2">In SCSI parlance, the two parties are referred to as </span><strong class="bold"><span class="koboSpan" id="kobo.242.1">initiators</span></strong><span class="koboSpan" id="kobo.243.1"> and </span><strong class="bold"><span class="koboSpan" id="kobo.244.1">targets</span></strong><span class="koboSpan" id="kobo.245.1">. </span><span class="koboSpan" id="kobo.245.2">The host operating system that initiates the request is said to act as an SCSI initiator. </span><span class="koboSpan" id="kobo.245.3">The destination storage device that receives and processes this request is known as an </span><span class="No-Break"><span class="koboSpan" id="kobo.246.1">SCSI target.</span></span></p>
<p><span class="koboSpan" id="kobo.247.1">The SCSI initiator resides on the host and generates requests on behalf of the higher layers in the I/O stack, such as applications and filesystems. </span><span class="koboSpan" id="kobo.247.2">The SCSI target waits for the initiator’s commands and then performs the requested data transfers. </span><span class="koboSpan" id="kobo.247.3">There has to be an underlying transport mechanism that ensures that the SCSI command from the initiator is delivered to the target. </span><span class="koboSpan" id="kobo.247.4">This is implemented through the SCSI transport layer. </span><span class="koboSpan" id="kobo.247.5">There are multiple transfer protocols available, such as </span><strong class="bold"><span class="koboSpan" id="kobo.248.1">Serial Attached SCSI</span></strong><span class="koboSpan" id="kobo.249.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.250.1">SAS</span></strong><span class="koboSpan" id="kobo.251.1">) for direct attached disks, and the Fibre Channel or iSCSI for SCSI targets that are part of a </span><strong class="bold"><span class="koboSpan" id="kobo.252.1">Storage Area Network</span></strong><span class="koboSpan" id="kobo.253.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.254.1">SAN</span></strong><span class="koboSpan" id="kobo.255.1">). </span><span class="koboSpan" id="kobo.255.2">The relationship between the SCSI initiator and the target is shown in </span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.256.1">Figure 7</span></em></span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.257.1">.4</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.258.1">:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer068">
<span class="koboSpan" id="kobo.259.1"><img alt="Figure 7.4 – The SCSI initiator and the target" src="image/B19430_07_04.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.260.1">Figure 7.4 – The SCSI initiator and the target</span></p>
<p><span class="koboSpan" id="kobo.261.1">Let us move on to the </span><span class="No-Break"><span class="koboSpan" id="kobo.262.1">addressing scheme.</span></span></p>
<h3><span class="koboSpan" id="kobo.263.1">Device addressing</span></h3>
<p><span class="koboSpan" id="kobo.264.1">Linux uses a four-part hierarchical addressing scheme to identify SCSI devices. </span><span class="koboSpan" id="kobo.264.2">This combination of four numbers uniquely identifies the location of a SCSI device within a system. </span><span class="koboSpan" id="kobo.264.3">If you run </span><strong class="source-inline"><span class="koboSpan" id="kobo.265.1">lsscsi</span></strong><span class="koboSpan" id="kobo.266.1"> or </span><strong class="source-inline"><span class="koboSpan" id="kobo.267.1">sg_map -x</span></strong><span class="koboSpan" id="kobo.268.1"> on the command line, you’ll see that a sequence of four numbers is used to represent every SCSI device in </span><span class="No-Break"><span class="koboSpan" id="kobo.269.1">your system:</span></span></p>
<pre class="source-code">
<strong class="bold"><span class="koboSpan" id="kobo.270.1">[root@linuxbox ~]# lsscsi</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.271.1">[0:0:0:0]    disk    ATA      SAMSUNG MZMTE512 400Q  /dev/sda</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.272.1">[4:0:0:0]    disk    ATA      ST9320320AS      SD57  /dev/sdb</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.273.1">[6:0:0:0]    disk    Generic- Multi-Card       1.00  /dev/sdc</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.274.1">[root@linuxbox ~]#</span></strong></pre>
<p><span class="koboSpan" id="kobo.275.1">This quad addressing scheme is known as </span><strong class="bold"><span class="koboSpan" id="kobo.276.1">Host, Bus, Target, and LUN</span></strong><span class="koboSpan" id="kobo.277.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.278.1">HBTL</span></strong><span class="koboSpan" id="kobo.279.1">), and its fields are explained </span><span class="No-Break"><span class="koboSpan" id="kobo.280.1">as follows:</span></span></p>
<ul>
<li><strong class="bold"><span class="koboSpan" id="kobo.281.1">Host</span></strong><span class="koboSpan" id="kobo.282.1">: The host represents a controller that can send and receive SCSI commands. </span><span class="koboSpan" id="kobo.282.2">The SCSI Host ID is the ID of the HBA, also referred to as the SCSI controller or SCSI adapter. </span><span class="koboSpan" id="kobo.282.3">The identifier represents an arbitrary numbering assigned to adapter cards present on the internal system buses. </span><span class="koboSpan" id="kobo.282.4">The kernel assigns this number in an ascending manner on the basis of the adapter discovery order. </span><span class="koboSpan" id="kobo.282.5">For instance, the first adapter will be assigned zero, the second will be assigned one, and </span><span class="No-Break"><span class="koboSpan" id="kobo.283.1">so on.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.284.1">Bus</span></strong><span class="koboSpan" id="kobo.285.1">: This is the bus or channel used within the SCSI controller. </span><span class="koboSpan" id="kobo.285.2">A controller can have more than one SCSI bus. </span><span class="koboSpan" id="kobo.285.3">This identifier is assigned by the kernel and reflects part of the hardware and firmware architecture of the SCSI controller. </span><span class="koboSpan" id="kobo.285.4">Usually, SCSI controllers will only have a single bus. </span><span class="koboSpan" id="kobo.285.5">High-end devices such as RAID controllers can have </span><span class="No-Break"><span class="koboSpan" id="kobo.286.1">multiple buses.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.287.1">Target</span></strong><span class="koboSpan" id="kobo.288.1">: Each bus can have multiple devices or targets connected to it. </span><span class="koboSpan" id="kobo.288.2">The target is the destination device within the bus. </span><span class="koboSpan" id="kobo.288.3">This identifier is also assigned by the kernel in the order of target discovery within a given </span><span class="No-Break"><span class="koboSpan" id="kobo.289.1">SCSI controller.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.290.1">The Logical Unit Number (LUN)</span></strong><span class="koboSpan" id="kobo.291.1">: This is the logical device within the SCSI target, as seen by the host operating system. </span><span class="koboSpan" id="kobo.291.2">The LUN is the entity capable of receiving SCSI commands from the host, meaning a disk drive. </span><span class="koboSpan" id="kobo.291.3">Each LUN has an exclusive request queue in the kernel’s block layer. </span><span class="koboSpan" id="kobo.291.4">The LUN identifier is assigned by the storage, making it the only part in the SCSI addressing scheme that is not assigned by </span><span class="No-Break"><span class="koboSpan" id="kobo.292.1">the kernel.</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.293.1">The following figure illustrates this addressing mechanism and the path from a host to a SCSI disk. </span><span class="koboSpan" id="kobo.293.2">Note that there is a relative SCSI target index associated with a SCSI controller or an HBA. </span><span class="koboSpan" id="kobo.293.3">The first SCSI storage target discovered attached to </span><strong class="source-inline"><span class="koboSpan" id="kobo.294.1">host0</span></strong><span class="koboSpan" id="kobo.295.1"> is assigned the SCSI target (relative index) 0, then 1, and 2, and </span><span class="No-Break"><span class="koboSpan" id="kobo.296.1">so on:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer069">
<span class="koboSpan" id="kobo.297.1"><img alt="Figure 7.5 – SCSI addressing" src="image/B19430_07_05.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.298.1">Figure 7.5 – SCSI addressing</span></p>
<p><span class="koboSpan" id="kobo.299.1">If you look inside </span><strong class="source-inline"><span class="koboSpan" id="kobo.300.1">/sys/class/scsi_host/</span></strong><span class="koboSpan" id="kobo.301.1">, you will see that hosts 0 to 6 correspond to </span><span class="No-Break"><span class="koboSpan" id="kobo.302.1">SCSI controllers:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer070">
<span class="koboSpan" id="kobo.303.1"><img alt="Figure 7.6 – The SCSI hosts in Sysfs" src="image/B19430_07_06.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.304.1">Figure 7.6 – The SCSI hosts in Sysfs</span></p>
<p><span class="koboSpan" id="kobo.305.1">Similarly, a structure of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.306.1">targetX:Y:Z</span></strong><span class="koboSpan" id="kobo.307.1"> format exists in </span><strong class="source-inline"><span class="koboSpan" id="kobo.308.1">/sys/bus/scsi/devices/</span></strong><span class="koboSpan" id="kobo.309.1"> and is attached to the </span><span class="No-Break"><span class="koboSpan" id="kobo.310.1">SCSI bus:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer071">
<span class="koboSpan" id="kobo.311.1"><img alt="Figure 7.7 – The SCSI targets in Sysfs" src="image/B19430_07_07.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.312.1">Figure 7.7 – The SCSI targets in Sysfs</span></p>
<p><span class="koboSpan" id="kobo.313.1">The LUNs can be identified through the unique four-level hierarchical addressing scheme, as </span><span class="No-Break"><span class="koboSpan" id="kobo.314.1">discussed earlier:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer072">
<span class="koboSpan" id="kobo.315.1"><img alt="Figure 7.8 – The SCSI LUNs in Sysfs" src="image/B19430_07_08.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.316.1">Figure 7.8 – The SCSI LUNs in Sysfs</span></p>
<p><span class="koboSpan" id="kobo.317.1">We’ll now explore some major data structures in the kernel that are relevant to the </span><span class="No-Break"><span class="koboSpan" id="kobo.318.1">SCSI subsystem.</span></span></p>
<h3><span class="koboSpan" id="kobo.319.1">Major data structures</span></h3>
<p><span class="koboSpan" id="kobo.320.1">The preceding concepts are implemented in the kernel using three major data structures – </span><strong class="source-inline"><span class="koboSpan" id="kobo.321.1">Scsi_Host</span></strong><span class="koboSpan" id="kobo.322.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.323.1">scsi_target</span></strong><span class="koboSpan" id="kobo.324.1">, and </span><strong class="source-inline"><span class="koboSpan" id="kobo.325.1">scsi_device</span></strong><span class="koboSpan" id="kobo.326.1">. </span><span class="koboSpan" id="kobo.326.2">Of course, these are not the only SCSI-related structures in the kernel. </span><span class="koboSpan" id="kobo.326.3">In addition to these three, there are several auxiliary structures, such as </span><strong class="source-inline"><span class="koboSpan" id="kobo.327.1">scsi_host_template</span></strong><span class="koboSpan" id="kobo.328.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.329.1">scsi_transport_template</span></strong><span class="koboSpan" id="kobo.330.1">. </span><span class="koboSpan" id="kobo.330.2">As the name might suggest, these structures are used to represent some common features for SCSI adapters and transport types. </span><span class="koboSpan" id="kobo.330.3">For instance, </span><a id="_idTextAnchor131"/><strong class="source-inline"><span class="koboSpan" id="kobo.331.1">scsi_host_template</span></strong><span class="koboSpan" id="kobo.332.1"> provides common content for the host adapters of the same model, including the request queue depth, the SCSI command processing callback function, and the error handling recovery functions. </span><span class="koboSpan" id="kobo.332.2">SCSI devices include hard disks, SSDs, optical drives, and so on, and all of these devices have some common functions. </span><span class="koboSpan" id="kobo.332.3">These common functions are extracted into templates in </span><span class="No-Break"><span class="koboSpan" id="kobo.333.1">the kernel.</span></span></p>
<p><span class="koboSpan" id="kobo.334.1">These three major structures are </span><span class="No-Break"><span class="koboSpan" id="kobo.335.1">as follows:</span></span></p>
<ul>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.336.1">Scsi_Host</span></strong><span class="koboSpan" id="kobo.337.1">: This is the data structure corresponding to the controller or the HBA, which is located under the SCSI bus. </span><span class="koboSpan" id="kobo.337.2">It contains information about the HBA, such as its unique identifier, maximum transfer size, supported features, and host-specific data. </span><span class="koboSpan" id="kobo.337.3">Multiple SCSI host structures can exist in the system, each representing a separate host adapter. </span><span class="koboSpan" id="kobo.337.4">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.338.1">SCSI</span></strong><strong class="source-inline"><span class="koboSpan" id="kobo.339.1">_</span></strong><strong class="source-inline"><span class="koboSpan" id="kobo.340.1">Host</span></strong><span class="koboSpan" id="kobo.341.1"> structure acts as the top-level structure for managing </span><span class="No-Break"><span class="koboSpan" id="kobo.342.1">SCSI communication.</span></span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.343.1">scsi_target</span></strong><span class="koboSpan" id="kobo.344.1">: This structure corresponds to a target device that is attached to a specific host adapter. </span><span class="koboSpan" id="kobo.344.2">It contains information about the target, such as its SCSI ID, </span><strong class="bold"><span class="koboSpan" id="kobo.345.1">LUN</span></strong><span class="koboSpan" id="kobo.346.1">, and some other flags and parameters. </span><span class="koboSpan" id="kobo.346.2">The SCSI target structure is associated with a specific SCSI Host structure and is used to manage communication and commands specific to that target device. </span><span class="koboSpan" id="kobo.346.3">The target device can be either physical </span><span class="No-Break"><span class="koboSpan" id="kobo.347.1">or virtual.</span></span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.348.1">scsi_device</span></strong><span class="koboSpan" id="kobo.349.1">: This structure represents a LUN within a SCSI target device. </span><span class="koboSpan" id="kobo.349.2">It denotes a specific device or partition within a target. </span><span class="koboSpan" id="kobo.349.3">When the operating system scans for a logical device connected to the host adapter, it creates a </span><strong class="source-inline"><span class="koboSpan" id="kobo.350.1">scsi_device</span></strong><span class="koboSpan" id="kobo.351.1"> structure for the upper-level SCSI driver to communicate with the device. </span><span class="koboSpan" id="kobo.351.2">It includes information such as the device’s SCSI ID, LUN, and queue depth. </span><span class="koboSpan" id="kobo.351.3">It is associated with both a SCSI Target structure and a SCSI Host structure and is used to manage communication and I/O operations for that </span><span class="No-Break"><span class="koboSpan" id="kobo.352.1">specific device.</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.353.1">This hierarchical scheme allows the kernel to manage SCSI devices and their communication efficiently. </span><span class="koboSpan" id="kobo.353.2">Commands and data transfers can be directed to specific SCSI devices or logical units, and error handling and status tracking can be performed at each level of the hierarchy. </span><span class="koboSpan" id="kobo.353.3">The interplay of these structures is highlighted in </span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.354.1">Figure 7</span></em></span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.355.1">.9</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.356.1">:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer073">
<span class="koboSpan" id="kobo.357.1"><img alt="Figure 7.9 – Major SCSI structures" src="image/B19430_07_09.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.358.1">Figure 7.9 – Major SCSI structures</span></p>
<p><span class="koboSpan" id="kobo.359.1">Please note that the actual implementation of SCSI devices in the Linux kernel is far more complex and involves additional data structures and interfaces. </span><span class="koboSpan" id="kobo.359.2">However, this simplified diagram demonstrates the basic interconnections between the SCSI Host, SCSI Target, and SCSI </span><span class="No-Break"><span class="koboSpan" id="kobo.360.1">Device structures.</span></span></p>
<h3><span class="koboSpan" id="kobo.361.1">Communicating with SCSI devices</span></h3>
<p><span class="koboSpan" id="kobo.362.1">As shown in </span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.363.1">Figure 7</span></em></span><em class="italic"><span class="koboSpan" id="kobo.364.1">.10</span></em><span class="koboSpan" id="kobo.365.1">, there are three different ways of communicating with </span><span class="No-Break"><span class="koboSpan" id="kobo.366.1">SCSI devices:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer074">
<span class="koboSpan" id="kobo.367.1"><img alt="Figure 7.10 – Communicating with SCSI devices" src="image/B19430_07_10.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.368.1">Figure 7.10 – Communicating with SCSI devices</span></p>
<p><span class="koboSpan" id="kobo.369.1">There are</span><a id="_idIndexMarker202"/><span class="koboSpan" id="kobo.370.1"> explained </span><span class="No-Break"><span class="koboSpan" id="kobo.371.1">as follows:</span></span></p>
<ul>
<li><strong class="bold"><span class="koboSpan" id="kobo.372.1">Filesystem-based</span></strong><span class="koboSpan" id="kobo.373.1">: The most common method is to access the SCSI device through the interface provided by the filesystem. </span><span class="koboSpan" id="kobo.373.2">This is how most regular user-space applications interact with </span><span class="No-Break"><span class="koboSpan" id="kobo.374.1">SCSI devices.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.375.1">RAW device access method</span></strong><span class="koboSpan" id="kobo.376.1">: Few applications allow for raw access to SCSI devices. </span><span class="koboSpan" id="kobo.376.2">While accessing a device through this approach is less prevalent, utilizing a raw device provides a more direct pathway to the physical device. </span><span class="koboSpan" id="kobo.376.3">It grants applications greater control over the timing of input/output operations to the SCSI device. </span><span class="koboSpan" id="kobo.376.4">It is important to note that the requests submitted through this approach will go through the block layer. </span><span class="koboSpan" id="kobo.376.5">A familiar example of this approach is the </span><strong class="source-inline"><span class="koboSpan" id="kobo.377.1">dd</span></strong><span class="koboSpan" id="kobo.378.1"> command in Linux. </span><span class="koboSpan" id="kobo.378.2">Using a raw access method does not require address mapping by </span><span class="No-Break"><span class="koboSpan" id="kobo.379.1">the filesystem.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.380.1">Pass-through mode</span></strong><span class="koboSpan" id="kobo.381.1">: The pass-through mode allows an application to directly send a SCSI command to the device. </span><span class="koboSpan" id="kobo.381.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.382.1">sg3_utils</span></strong><span class="koboSpan" id="kobo.383.1"> package available in Linux</span><a id="_idIndexMarker203"/><span class="koboSpan" id="kobo.384.1"> provides a set of utilities that can send SCSI commands to a device via the SCSI pass-through interface provided by the host </span><span class="No-Break"><span class="koboSpan" id="kobo.385.1">operating system.</span></span></li>
</ul>
<h3><span class="koboSpan" id="kobo.386.1">Interaction between the SCSI and block layers</span></h3>
<p><span class="koboSpan" id="kobo.387.1">The SCSI </span><a id="_idIndexMarker204"/><span class="koboSpan" id="kobo.388.1">layer and the block layer work together to facilitate the interaction between SCSI devices and the filesystem. </span><span class="koboSpan" id="kobo.388.2">The SCSI layer acts as an intermediate layer between the block layer and the device driver specific to the SCSI </span><span class="No-Break"><span class="koboSpan" id="kobo.389.1">Host adapter.</span></span></p>
<p><span class="koboSpan" id="kobo.390.1">The following provides an overview of how the SCSI layer interacts with the </span><span class="No-Break"><span class="koboSpan" id="kobo.391.1">block layer:</span></span></p>
<ol>
<li><span class="koboSpan" id="kobo.392.1">When a filesystem sends an I/O request, such as a read or write operation, it gets translated into a SCSI command by the block layer. </span><span class="koboSpan" id="kobo.392.2">The block layer constructs a </span><a id="_idIndexMarker205"/><span class="koboSpan" id="kobo.393.1">SCSI </span><strong class="bold"><span class="koboSpan" id="kobo.394.1">Command Descriptor Block</span></strong><span class="koboSpan" id="kobo.395.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.396.1">CDB</span></strong><span class="koboSpan" id="kobo.397.1">) that corresponds to the requested operation and passes it to the </span><span class="No-Break"><span class="koboSpan" id="kobo.398.1">SCSI layer.</span></span></li>
<li><span class="koboSpan" id="kobo.399.1">The SCSI mid layer receives the SCSI command from the block layer and performs the necessary processing, including command queuing, error handling, and </span><span class="No-Break"><span class="koboSpan" id="kobo.400.1">data transfer.</span></span></li>
<li><span class="koboSpan" id="kobo.401.1">The SCSI mid layer forwards the SCSI command to the appropriate lower-level SCSI device driver associated with the specific SCSI host adapter. </span><span class="koboSpan" id="kobo.401.2">The device driver interacts directly with the hardware and sends the SCSI command to the target device over the </span><span class="No-Break"><span class="koboSpan" id="kobo.402.1">SCSI bus.</span></span></li>
<li><span class="koboSpan" id="kobo.403.1">Once the SCSI command is executed by the target device, the lower-level SCSI device driver receives the command completion status and communicates this information back to the SCSI mid layer, which then passes it to the </span><span class="No-Break"><span class="koboSpan" id="kobo.404.1">block layer.</span></span></li>
<li><span class="koboSpan" id="kobo.405.1">The block layer receives the command completion status from the SCSI mid layer and uses this information to handle any errors, update the I/O request status, and </span><a id="_idIndexMarker206"/><span class="koboSpan" id="kobo.406.1">notify the filesystem about the completion or failure of the </span><span class="No-Break"><span class="koboSpan" id="kobo.407.1">I/O request.</span></span></li>
</ol>
<p><span class="koboSpan" id="kobo.408.1">Please note that this is a summarized view of the interaction between the block and SCSI layers. </span><span class="koboSpan" id="kobo.408.2">The block layer provides a standardized interface to the higher layers, such as filesystems. </span><span class="koboSpan" id="kobo.408.3">The SCSI layer handles the translation of block-level I/O requests into equivalent SCSI commands, and it manages the communication with the SCSI devices thr</span><a id="_idTextAnchor132"/><span class="koboSpan" id="kobo.409.1">ough lower-level device drivers specific to the SCSI </span><span class="No-Break"><span class="koboSpan" id="kobo.410.1">host adapter.</span></span></p>
<h1 id="_idParaDest-118"><a id="_idTextAnchor133"/><span class="koboSpan" id="kobo.411.1">Summary</span></h1>
<p><span class="koboSpan" id="kobo.412.1">This chapter focused on two major topics, the device model and the SCSI subsystem in Linux. </span><span class="koboSpan" id="kobo.412.2">We started by giving a brief overview of the device model in Linux and how the kernel provides its view in user space through the </span><strong class="source-inline"><span class="koboSpan" id="kobo.413.1">Sysfs</span></strong><span class="koboSpan" id="kobo.414.1"> VFS. </span><span class="koboSpan" id="kobo.414.2">We then moved on to the exploration of the SCSI subsystem and explained its </span><span class="No-Break"><span class="koboSpan" id="kobo.415.1">three-level architecture.</span></span></p>
<p><span class="koboSpan" id="kobo.416.1">As explained in this chapter, SCSI defines both an interface and a data protocol to connect different types of devices to a system. </span><span class="koboSpan" id="kobo.416.2">As a medium, it defines a bus for data transmission, and as a protocol, it defines how devices communicate with each other via the SCSI bus. </span><span class="koboSpan" id="kobo.416.3">When an application in user space initiates a write request to store data, the SCSI subsystem converts this write request into a SCSI command, to write the requested data on the specified disk location. </span><span class="koboSpan" id="kobo.416.4">It acts as a mediator between the higher layers in the I/O stack and the physical storage. </span><span class="koboSpan" id="kobo.416.5">SCSI does not assume responsibility for the assembly of blocks during transport or their physical placement on disk. </span><span class="koboSpan" id="kobo.416.6">The side that initiates a request is known as the initiator, while the destination side is known as the target in SCSI terminology. </span><span class="koboSpan" id="kobo.416.7">The target of the SCSI protocol can encompass a single physical drive, an HBA, or a RAID controller. </span><span class="koboSpan" id="kobo.416.8">The primary duty of the SCSI protocol is to guarantee the successful completion of the write task and report its status to the </span><span class="No-Break"><span class="koboSpan" id="kobo.417.1">higher layers.</span></span></p>
<p><span class="koboSpan" id="kobo.418.1">In the next chapter, we’ll discuss the different physical storage options available in today’s world, such as mechanical drives, SSDs, and NVMe drives. </span><span class="koboSpan" id="kobo.418.2">We’ll describe the differences in their design and see how they compare to </span><span class="No-Break"><span class="koboSpan" id="kobo.419.1">each other.</span></span></p>
</div>
</body></html>