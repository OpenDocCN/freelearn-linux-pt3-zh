<html><head></head><body><div id="sbo-rt-content"><div id="_idContainer247">
			<h1 id="_idParaDest-321"><em class="italic"><a id="_idTextAnchor328"/>Chapter 14</em>: Interacting with Shell Scripts</h1>
			<p>We are almost done with explaining the basic concepts of scripting, but before we can say we are completely done with them, we need to learn how to interact with shell scripts. This isn't always necessary in shell scripting, but it may apply to most situations. For example, it's one thing to create a script that does one job and one job only. It's completely different to create a script that requires us to make some choices as it gets executed. If nothing else, this second type is a prime candidate for shell script interaction. In this chapter, we are going to cover three different ways to deal with shell script interaction. </p>
			<p>In this chapter, we will cover the following recipes: </p>
			<ul>
				<li>Creating text-based interactive scripts</li>
				<li>Using expect to automate repetitive tasks based on text output</li>
				<li>Using dialog for menu-driven interactive scripts</li>
			</ul>
			<h1 id="_idParaDest-322"><a id="_idTextAnchor329"/>Technical requirements </h1>
			<p>As with all the chapters thus far, we are going to use the same virtual machine running the Bash shell. So, we need a virtual machine with Linux installed – any distribution is fine (in our case, it's going to be <em class="italic">Ubuntu 20.10</em>). </p>
			<p>Now, start your virtual machine!</p>
			<h1 id="_idParaDest-323"><a id="_idTextAnchor330"/>Creating text-based interactive scripts</h1>
			<p>The one thing <a id="_idIndexMarker982"/>that we haven't done so far is put any interaction in our scripts. The reason for this is simple – at this point, we've only discussed how to output information and not how to get it from the user or any other source. In the real world, interaction is something that we need to deal with because it is at the core of creating any script. We could say that there are two kinds of interaction. First, our script can interact with the system itself. This means using different variables and other information that we can get from the system – for example, free space in memory or on mounted disks. You could say that this is not real interaction but instead just reading real-time data from the system. But, still, it's a very useful way of making sure that a script does what it needs to do.</p>
			<p>Another thing that we can do is interact with the user starting it. If the script is run by the system, it isn't something that is going to interact with the user in any way, but user interaction is extremely important when we are creating scripts for day-to-day jobs. Consider this question – why would we create a script that backs up <em class="italic">a folder</em> (one folder only) when we can create a script that can be told to back up <em class="italic">one or more directories</em>? Isn't that way of designing a script much more usable?</p>
			<h2 id="_idParaDest-324"><a id="_idTextAnchor331"/>Getting ready</h2>
			<p>When we start creating our scripts, we must decide on the kind of interaction that we need in them. Depending on the type of script that's required, we may use interactive prompts, menus, some sort of pre-configuration, or even some graphical interface. For now, we are going to stay away from using GUIs for our scripts. However, we can use them if we <a id="_idIndexMarker983"/>need to with the help of some appropriate tools. Remember, scripts are barely more than some execution control that dictates how different commands and applications interact, so those commands are what matters most in the first place. </p>
			<p>For starters, our first recipe will be a simple interactive script asking the user for input and then acting on it. </p>
			<h2 id="_idParaDest-325"><a id="_idTextAnchor332"/>How to do it…</h2>
			<p>The main commands that we are going to use in this recipe are going to be <strong class="source-inline">read</strong> and <strong class="source-inline">echo</strong>. Before we do anything else, we need to learn a few tricks regarding these commands. In theory, <strong class="source-inline">read</strong> is simple to understand – it waits for user input and then stores that input in some variable. But to show you the different things that are made possible by this simple command, we need to show you a few examples. </p>
			<p><strong class="source-inline">read</strong>, in its basic form, accepts one argument – the variable – and then takes whatever the user types in and puts it into this variable so that we can use it later. Let's consider the following example:</p>
			<p class="source-code">#!/bin/bash</p>
			<p class="source-code">echo "Input a value: "</p>
			<p class="source-code">read Value1</p>
			<p class="source-code">echo "Your input was: $Value1"</p>
			<p>If we quickly test this script, this is what we will get as a result: </p>
			<p class="source-code">demo@cli1:~/interactive$ bash singlevar.sh </p>
			<p class="source-code">Input a value: </p>
			<p class="source-code">test</p>
			<p class="source-code">Your input was: test</p>
			<p class="source-code">demo@cli1:~/interactive$ bash singlevar.sh </p>
			<p class="source-code">Input a value: </p>
			<p class="source-code">test value</p>
			<p class="source-code">Your input was: test value</p>
			<p>Sometimes, this<a id="_idIndexMarker984"/> is not enough. Sometimes, we need to get more than one value into our script. The problem here is the way users type in the values. Shell uses space characters as separators, so a space is going to be what separates the value in the <strong class="source-inline">read</strong> command. If we need to get a value that contains spaces, we will have to deal with it differently. As we saw in the previous example, this will only become a problem if we use more than one return variable. </p>
			<p>If, however, we use values that do not contain spaces, we can simply use the following code and save it in the <strong class="source-inline">doublevar.sh</strong> file:</p>
			<p class="source-code">#!/bin/bash</p>
			<p class="source-code">echo -e "Input two numbers "</p>
			<p class="source-code">read num1 num2</p>
			<p class="source-code">echo "Two numbers are $num1 and $num2"</p>
			<p>Now, let's try it and see if it works the way we are expecting it to: </p>
			<p class="source-code">demo@cli1:~/interactive$ bash doublevar.sh </p>
			<p class="source-code">Input two numbers </p>
			<p class="source-code">2 3</p>
			<p class="source-code">Two numbers are 2 and 3</p>
			<p>We must stop here and do another test to clear a few things up. Bash performs no checks on what the type of the variable is. In our script, we presumed that the user is going to input numbers, but nothing stops them from using any string. Another thing would be how multiple values separated by spaces are going to be handled – the first value is going to be assigned to the first variable; everything after that is going to be assigned to the second one. If we use more than two variables to store values, the result is always going to be that each variable in the sequence will get one variable assigned and the last one will <a id="_idIndexMarker985"/>get whatever was left in the input line: </p>
			<p class="source-code">demo@cli1:~/interactive$ bash doublevar.sh </p>
			<p class="source-code">Input two numbers </p>
			<p class="source-code">First second</p>
			<p class="source-code">Two numbers are First and second</p>
			<p class="source-code">demo@cli1:~/interactive$ bash doublevar.sh </p>
			<p class="source-code">Input two numbers </p>
			<p class="source-code">first second third</p>
			<p class="source-code">Two numbers are first and second third</p>
			<p>Another way we can use <strong class="source-inline">read</strong> is to get the values into a predefined variable called <strong class="source-inline">$REPLY</strong>. If we simply omit the variable name, everything you type in is going to be in that variable, which can then be used in your script:</p>
			<p class="source-code">#!/bin/bash</p>
			<p class="source-code">echo "Input a value: "</p>
			<p class="source-code">Read</p>
			<p class="source-code">echo "Your input was: $REPLY"</p>
			<p>A simple test proves that this behaves exactly as if we gave the command a proper variable name: </p>
			<p class="source-code">demo@cli1:~/interactive$ bash novar.sh </p>
			<p class="source-code">Input a value: </p>
			<p class="source-code">test value no variable</p>
			<p class="source-code">Your input was: test value no variable</p>
			<p>Another way of using <strong class="source-inline">read</strong> is by using the <strong class="source-inline">-a</strong> switch. By using this, we are saying that we want to store all the values it got as an array. After this switch, we need to state the name of the variable we are going to use to store the values, or we can simply use the default <strong class="source-inline">$REPLY</strong> variable. What we should not do is use more than one variable name. This is because we are storing multiple values in one variable, so it makes no sense to try and reference <a id="_idIndexMarker986"/>more than one variable in the first place:</p>
			<p class="source-code">#!/bin/bash</p>
			<p class="source-code">echo "Input multiple values: "</p>
			<p class="source-code">read REGULAR</p>
			<p class="source-code">echo "Your input was: $REGULAR"</p>
			<p class="source-code">echo "This will not work: ${REGULAR[0]}"</p>
			<p class="source-code">echo "Now input multiple values again:"</p>
			<p class="source-code">read -a REGULAR</p>
			<p class="source-code">echo "This will work: ${REGULAR[0]}"</p>
			<p>Here, we are reading multiple values into a single variable. Since we didn't ask Bash to create an array, it is going to store everything into this variable, but there will be no way of referencing the elements inside this variable. Bash treats all the values in the variable as a single, first element, so if we try to print it out, we will get everything. </p>
			<p>The second time we do this, we are getting the values from the user. Here, we are using an array. Everything looks the same but if we reference the first element of the variable, we will only print the first element: </p>
			<p class="source-code">demo@cli1:~/interactive$ bash array.sh </p>
			<p class="source-code">Input multiple values: </p>
			<p class="source-code">first second third</p>
			<p class="source-code">Your input was: first second third</p>
			<p class="source-code">This will not work: first second third</p>
			<p class="source-code">Now input multiple values again:</p>
			<p class="source-code">first second third</p>
			<p class="source-code">This will work: first</p>
			<p>Now, we need to experiment a bit with the <strong class="source-inline">echo</strong> command. In the entire scripting part of this book, we have been using this command in its most basic form to, well, output text to screen or, to be more precise, to standard output. This will work for the majority of cases, but there are some scripts where we need more control over the output. The problem with the way <strong class="source-inline">echo</strong> works is that it always terminates the string it outputs with a newline <a id="_idIndexMarker987"/>character, forcing the output into a new line once it's printed whatever was given to it as a parameter. While this is alright for printing out information, when we try to interact with the user in our scripts, it will look strange if we always force the user to enter the values we are looking for in a new line. So, <strong class="source-inline">echo</strong> offers one additional option that changes the default behavior (<strong class="source-inline">-n</strong>). Let's consider this example: </p>
			<p class="source-code">#!/bin/bash</p>
			<p class="source-code">echo -n "Can you please input a word?: "</p>
			<p class="source-code">read  word</p>
			<p class="source-code">echo "I got: $word"</p>
			<p>What we told <strong class="source-inline">echo</strong> to do here is that it should print the text inside quotation marks, but after that, it should stay in the same line. Since our <strong class="source-inline">read</strong> command naturally continues wherever the cursor was placed by the previous command, the result will be that the value we type in will appear most logically on screen: </p>
			<p class="source-code">demo@cli1:~/interactive$ bash echoline.sh </p>
			<p class="source-code">Can you please input a word?: singleword</p>
			<p class="source-code">I got: singleword</p>
			<p>There is another way to do this that looks more complicated but behaves the same: </p>
			<p class="source-code">#!/bin/bash</p>
			<p class="source-code">echo -e "Can you please input a word?:  \c "</p>
			<p class="source-code">read  word</p>
			<p class="source-code">echo "I got: $word"</p>
			<p>The reason we are showing you this is because this example uses special characters to denote the end of the line, but at the same time, there are more characters we can use for even finer control <a id="_idIndexMarker988"/>over the output. By default, the most commonly used are as follows: </p>
			<ul>
				<li><strong class="source-inline">\\     backslash</strong>: When we need to output the actual <strong class="source-inline">\</strong> character.</li>
				<li><strong class="source-inline">\a     alert (BEL)</strong>: When we want to warn the user by using a loud sound.</li>
				<li><strong class="source-inline">\b     backspace</strong>: We use this when we need to provide a backspace character, deleting whatever is on the same line under the cursor.</li>
				<li><strong class="source-inline">\c     produce no further output</strong>: This is used to tell <strong class="source-inline">echo</strong> to simply stop the output.</li>
				<li><strong class="source-inline">\t     horizontal tab</strong>: This is used to provide <strong class="source-inline">tab</strong> and align the output.</li>
			</ul>
			<p>Now that we know about some of the basic <strong class="source-inline">read</strong> and <strong class="source-inline">echo</strong> syntaxes, let's try to put that to good use in a script.</p>
			<h2 id="_idParaDest-326"><a id="_idTextAnchor333"/>How it works…</h2>
			<p>Now that we know how to deal with everything in the Bash script that can be used for interaction, we can create a script that will show it all. Here, we are creating a simple menu: </p>
			<p class="source-code">#!/bin/bash</p>
			<p class="source-code">echo "Your favourite scripting language?"</p>
			<p class="source-code">echo "1) bash"</p>
			<p class="source-code">echo "2) perl"</p>
			<p class="source-code">echo "3) python"</p>
			<p class="source-code">echo "4) c++"</p>
			<p class="source-code">echo "5) Dunno!"</p>
			<p class="source-code">echo -n "Your choice is: "</p>
			<p class="source-code">read choice;</p>
			<p class="source-code"># we do a simple case structure</p>
			<p class="source-code">case $choice in</p>
			<p class="source-code">    1) echo "You chose bash";;</p>
			<p class="source-code">    2) echo "You chose perl";;</p>
			<p class="source-code">    3) echo "You chose python";;</p>
			<p class="source-code">    4) echo "You chose c++";;</p>
			<p class="source-code">    5) exit</p>
			<p class="source-code">esac</p>
			<p>Try it out!</p>
			<p>There is another way <a id="_idIndexMarker989"/>to create an interactive menu that we can use in our script – using the <strong class="source-inline">select</strong> command. This command is often used to create simple menus, like this: </p>
			<p class="source-code">#!/bin/bash</p>
			<p class="source-code">PS3='Please choose an option: '</p>
			<p class="source-code">options=("Option 1" "Option 2" "Option 3" "Quit")</p>
			<p class="source-code">select opt in "${options[@]}"</p>
			<p class="source-code">do</p>
			<p class="source-code">    case $opt in</p>
			<p class="source-code">        "Option 1")</p>
			<p class="source-code">            echo "you chose Option 1"</p>
			<p class="source-code">            ;;</p>
			<p class="source-code">        "Option 2")</p>
			<p class="source-code">            echo "you chose Option 2"</p>
			<p class="source-code">            ;;</p>
			<p class="source-code">        "Option 3")</p>
			<p class="source-code">            echo "you chose Option $REPLY which is $opt"</p>
			<p class="source-code">            ;;</p>
			<p class="source-code">        "Quit")</p>
			<p class="source-code">            break</p>
			<p class="source-code">            ;;</p>
			<p class="source-code">        *) echo "invalid option $REPLY"</p>
			<p class="source-code">            ;;</p>
			<p class="source-code">    esac</p>
			<p class="source-code">done</p>
			<p><strong class="source-inline">select</strong> looks a lot <a id="_idIndexMarker990"/>like some sort of loop; it requires us to set a few variables in advance. <strong class="source-inline">$PS3</strong> contains the question that the user will see, while <strong class="source-inline">$options</strong> contains an array of strings that represent options. When a user runs this script, it will be presented with a list of numbered options, and they can input any of them as a number. <strong class="source-inline">select</strong> is going to then substitute the string from our options list based on the number that the user selected and run the appropriate command: </p>
			<p class="source-code">demo@cli1:~/interactive$ bash select.sh </p>
			<p class="source-code">1) Option 1</p>
			<p class="source-code">2) Option 2</p>
			<p class="source-code">3) Option 3</p>
			<p class="source-code">4) Quit</p>
			<p class="source-code">Please choose an option: 1</p>
			<p class="source-code">you chose Option 1</p>
			<p class="source-code">Please choose an option: 2</p>
			<p class="source-code">you chose Option 2</p>
			<p class="source-code">Please choose an option: 3</p>
			<p class="source-code">you chose Option 3 which is Option 3</p>
			<p class="source-code">Please choose an option: 4</p>
			<p class="source-code">demo@cli1:~/interactive$</p>
			<p>This is a great <a id="_idIndexMarker991"/>way to quickly create a script with multiple choices. </p>
			<h2 id="_idParaDest-327"><a id="_idTextAnchor334"/>See also</h2>
			<p>A lot more<a id="_idIndexMarker992"/> can be<a id="_idIndexMarker993"/> found about the <strong class="source-inline">echo</strong> and <strong class="source-inline">read</strong> commands at the following links: </p>
			<ul>
				<li><a href="https://linuxhint.com/bash_read_command/">https://linuxhint.com/bash_read_command/</a></li>
				<li><a href="https://www.javatpoint.com/bash-read-user-input">https://www.javatpoint.com/bash-read-user-input</a></li>
			</ul>
			<h1 id="_idParaDest-328"><a id="_idTextAnchor335"/>Using expect to automate repetitive tasks based on text output</h1>
			<p>Bash is a <a id="_idIndexMarker994"/>formidable tool<a id="_idIndexMarker995"/> but sometimes, we need to do a particular thing that needs additional tools. In this recipe, we are going to be working with just such a tool called <strong class="source-inline">expect</strong>. Before we start, we must note that <strong class="source-inline">expect</strong> is not part of Bash scripting – it is a whole separate scripting language, written for a particular purpose, to enable interaction between your scripts and users and other systems. The idea behind it is to enable your scripts to not only execute <strong class="source-inline">normal</strong> commands that provide information when executed (command output) but to also be able to interact with any application that has a <strong class="bold">command-line interface</strong> (<strong class="bold">CLI</strong>) and <a id="_idIndexMarker996"/>get information from it. </p>
			<h2 id="_idParaDest-329"><a id="_idTextAnchor336"/>Getting ready</h2>
			<p>In a simplified way, <strong class="source-inline">expect</strong> acts as a virtual keyboard that can type in some text and read what is on the screen. This is a powerful thing that is often needed because several applications and scripts are created by people who either had no reason to enable scripting support or just didn't want to do it. This means that without a tool such as <strong class="source-inline">expect</strong>, we will not be able to interact with those applications. This sometimes means that we will not be able to do what we want from inside our scripts. </p>
			<p>In this recipe, we <a id="_idIndexMarker997"/>will learn how to<a id="_idIndexMarker998"/> use <strong class="source-inline">expect</strong> to interact with another shell on another computer, how to type in a password and log in, and how to type commands and get a response from the other side. </p>
			<p>But before we even do that, we need to install <strong class="source-inline">expect</strong> if it isn't installed on the system since it is not a standard part of the system. </p>
			<p>Use the following command and wait for it to finish:</p>
			<p class="source-code">sudo apt install expect</p>
			<p>We need to use <strong class="source-inline">sudo</strong> here. Only an administrator can install packages, so expect to have to input your user password. </p>
			<h2 id="_idParaDest-330"><a id="_idTextAnchor337"/>How to do it…</h2>
			<p>Since <strong class="source-inline">expect</strong> is not Bash, we must tell our script to use it. The syntax is the same as when we're creating a script using Bash – we need to make running <strong class="source-inline">expect</strong> the first line of our script. Note that this immediately means that our script no longer uses any of the commands from Bash, but we get many new things we can do. </p>
			<p>We are going to start with the simple <strong class="source-inline">hello world</strong> script: </p>
			<p class="source-code">#!/usr/bin/expect</p>
			<p class="source-code">expect "hello"</p>
			<p class="source-code">send "world"</p>
			<p>What the script does is exactly what the commands sound like they do; when we start it, the script is going to look for a <strong class="source-inline">hello</strong> string and after it receives it, it is going to reply with the <strong class="source-inline">world</strong> string.</p>
			<p>Strings are case-sensitive, so nothing else than the exact match will work. Also, <strong class="source-inline">expect</strong> has a built-in period during which it expects to get the string. If nothing is matched during that period, the script is going to continue from the next command. In our example, even if we give it no input, we are going to get the <strong class="source-inline">world</strong> string printed. </p>
			<p>When we start our script, we must use the <strong class="source-inline">expect</strong> command; we cannot start this script using Bash since it is written specifically for <strong class="source-inline">expect</strong>: </p>
			<p class="source-code">demo@cli1:~/interactive$ expect expect1.exp </p>
			<p class="source-code">HEllo</p>
			<p class="source-code">helo</p>
			<p class="source-code">hello</p>
			<p class="source-code">world</p>
			<p>We tried <a id="_idIndexMarker999"/>three <a id="_idIndexMarker1000"/>different ways of spelling the string here, and only the exact match worked. </p>
			<p>Let's do something more interesting and explain what we did along the way: </p>
			<p class="source-code">#!/usr/bin/expect</p>
			<p class="source-code">set timeout 20</p>
			<p class="source-code">set host [lindex $argv 0]</p>
			<p class="source-code">set user [lindex $argv 1]</p>
			<p class="source-code">set password [lindex $argv 2]</p>
			<p class="source-code">spawn ssh "$user\@$host"</p>
			<p class="source-code">expect "Password:"</p>
			<p class="source-code">send "$password\r";</p>
			<p class="source-code">interact</p>
			<p>This script is intended to enable you to quickly connect to another host using the <strong class="source-inline">ssh</strong> protocol. When we run it, we need to provide three things: the name or IP address of the host, the username to use, and the cleartext password for the user that will log in. We are aware that using a password in this way is not normal at all, but we are providing an example here. </p>
			<p>At the start of the script, we are setting the timeout for the prompts. As we mentioned earlier, if the <strong class="source-inline">expect</strong> command doesn't detect any input, it will continue the script after the time specified in this <strong class="source-inline">timeout</strong> value. The next three lines deal with the arguments we passed to the script. We are assigning each of them to a variable so that we can use them later. </p>
			<p>After that, we are using the <strong class="source-inline">spawn</strong> command to call the <strong class="source-inline">ssh</strong> command in a separate process. We are using the standard <strong class="source-inline">ssh</strong> client and giving it usernames and hostnames so that we can start the login process. </p>
			<p>After this, our <a id="_idIndexMarker1001"/>script waits until <a id="_idIndexMarker1002"/>it detects that we need to type in the password. When it detects the <strong class="source-inline">password:</strong> part of the prompt, it sends our password in cleartext. </p>
			<p>The last command in the script is <strong class="source-inline">interact</strong> and it hands over control to us so that we can use our freshly logged-in session to do what we intend to do. This is what it looks like when it's run: </p>
			<p class="source-code">demo@cli1:~/interactive$ expect sshlogin.exp localhost demo demo</p>
			<p class="source-code">spawn ssh demo@localhost</p>
			<p class="source-code">demo@localhost's password: </p>
			<p class="source-code">Welcome to Ubuntu 20.10 (GNU/Linux 5.8.0-63-generic x86_64)</p>
			<p class="source-code"> Documentation:  https://help.ubuntu.com</p>
			<p class="source-code">* Management:     https://landscape.canonical.com</p>
			<p class="source-code">* Support:        https://ubuntu.com/advantage</p>
			<p class="source-code">0 updates can be installed immediately.</p>
			<p class="source-code">0 of these updates are security updates.</p>
			<p class="source-code">demo@cli1:~$</p>
			<p>This is a good start if we need to work on a remote system. But how do we run other commands on the other system and what can we do with that? </p>
			<p>There are two ways to continue here; one is to simply wait for the prompt to show and then send commands, while another one is to script this <em class="italic">blindly</em> and just wait for a predetermined period and then send the commands that we need. So, let's make an example script for both concepts. Our goal is to have a scenario in which one part of the script does its job <a id="_idIndexMarker1003"/>as<a id="_idIndexMarker1004"/> an <em class="italic">answer</em> to command output (in our script, this is the <strong class="source-inline">ssh</strong> part and its output). The second part is related to the concept of waiting for a predetermined period (<strong class="source-inline">sleep 5</strong> means waiting for 5 seconds) and then doing something. Let's check out our example:</p>
			<p class="source-code">#!/usr/bin/expect</p>
			<p class="source-code">set timeout 20</p>
			<p class="source-code">set host [lindex $argv 0]</p>
			<p class="source-code">set user [lindex $argv 1]</p>
			<p class="source-code">set password [lindex $argv 2]</p>
			<p class="source-code">spawn ssh "$user\@$host"</p>
			<p class="source-code">expect "password:"</p>
			<p class="source-code">send "$password\r";</p>
			<p class="source-code">sleep 5</p>
			<p class="source-code">send "clear\r";</p>
			<p class="source-code">send "ip link\r";</p>
			<p class="source-code">expect "$"</p>
			<p class="source-code">puts $expect_out(buffer);</p>
			<p class="source-code">send "exit\r";</p>
			<p>We added two things that we haven't mentioned previously. The first one is that we are using the <strong class="source-inline">puts</strong> command to print information to the screen. It behaves similar to <strong class="source-inline">echo</strong> does in Bash. </p>
			<p>The <strong class="source-inline">$expect_out (buffer)</strong> variable holds data that the script got from running commands between two matches. So, in our script, this is going to hold information that was provided by the <strong class="source-inline">ip add</strong> command. If you are wondering where the login information disappeared, it is not visible since we issued the <strong class="source-inline">clear</strong> command to clear the screen, which, in turn, cleared the buffer. </p>
			<h2 id="_idParaDest-331"><a id="_idTextAnchor338"/>How it works…</h2>
			<p><strong class="source-inline">expect</strong> is an amazing tool that has even more things up its sleeve. One of its main purposes is to automate administration tasks using scripts. One of the most common usages was what we did in the previous example – running commands remotely. The reason we <a id="_idIndexMarker1005"/>may <a id="_idIndexMarker1006"/>use it often is not only to automate logins but also to automate testing. After running a particular command, we can do whatever we want and then get the results into our scripts. </p>
			<p>In this way, <strong class="source-inline">expect</strong> is usually used as part of another script. When we need some sort of data that only <strong class="source-inline">expect</strong> can provide, we call it and then continue processing the data in our main script. However, automating scripts can mean one more thing – getting them to accept information, which enables us to write tests to check if our script works. For this reason, <strong class="source-inline">expect</strong> has a tool that is used to create an <strong class="source-inline">expect</strong> script out of running any script that contains interaction with the user. </p>
			<p>The following is a quick example to demonstrate what we mean, but first, we are going to create a very simple script where we will use different ways of calling <strong class="source-inline">echo</strong> and <strong class="source-inline">read</strong> in Bash: </p>
			<p class="source-code">#!/bin/bash</p>
			<p class="source-code">#echo -e "Can you please input a word?:  \c "</p>
			<p class="source-code">echo -n "Can you please input a word?:   "</p>
			<p class="source-code">read  word</p>
			<p class="source-code">echo "I got: $word"</p>
			<p class="source-code">echo -e "Now please input two words: "</p>
			<p class="source-code">read word1 word2</p>
			<p class="source-code">echo "I got: \"$word1\" \"$word2\""</p>
			<p class="source-code">echo -e "Any more thoughts? "</p>
			<p class="source-code"># read will by default create $REPLY variable</p>
			<p class="source-code">read</p>
			<p class="source-code">echo "$REPLY is not a bad thing "</p>
			<p class="source-code">echo -e "Can you give me three of your favorite colors? "</p>
			<p class="source-code"># read -a will read an array of words</p>
			<p class="source-code">read -a colours</p>
			<p class="source-code">echo "Amazing, I also like ${colours[0]}, ${colours[1]} and \n</p>
			<p class="source-code">${colours[2]}:-)"</p>
			<p>Now, we are<a id="_idIndexMarker1007"/> going <a id="_idIndexMarker1008"/>to start the <strong class="source-inline">autoexpect</strong> tool to grab both the input and output for the script: </p>
			<p class="source-code">demo@cli1:~/interactive$ autoexpect bash simpleecho.sh </p>
			<p class="source-code">autoexpect started, file is script.exp</p>
			<p class="source-code">Can you please input a word?:   word one</p>
			<p class="source-code">I got: word one</p>
			<p class="source-code">Now please input two words: </p>
			<p class="source-code">two words</p>
			<p class="source-code">I got: "two" "words"</p>
			<p class="source-code">Any more thoughts? </p>
			<p class="source-code">none whatsoever</p>
			<p class="source-code">none whatsoever is not a bad thing </p>
			<p class="source-code">Can you give me three of your favourite colors? </p>
			<p class="source-code">blue yellow cyan</p>
			<p class="source-code">Amazing, I also like blue, yellow and cyan</p>
			<p class="source-code">autoexpect done, file is script.exp</p>
			<p>Here, <strong class="source-inline">autoexpect</strong> was tracking what our script used as prompts, as well as what we gave as answers. When we finished executing our script, it created an <strong class="source-inline">expect</strong> script, which enables us to completely automate running our Bash script. We are going to omit part of this script since it contains a lot of comments that give us both the information about the tool<a id="_idIndexMarker1009"/> and <a id="_idIndexMarker1010"/>the disclaimer. Here's what the <strong class="source-inline">autoexpect</strong> output looks like; it is saved in a file named <strong class="source-inline">script.exp</strong>:</p>
			<p class="source-code">#!/usr/bin/expect -f</p>
			<p class="source-code"># This Expect script was generated by autoexpect on Sun Oct \n</p>
			<p class="source-code">10 13:35:52 2021</p>
			<p class="source-code">set force_conservative 0  ;# set to 1 to force conservative \n</p>
			<p class="source-code">mode even if</p>
			<p class="source-code">                                        ;# script wasn't run \n</p>
			<p class="source-code">conservatively</p>
			<p class="source-code">          Originally</p>
			<p class="source-code">               if {$force_conservative} {                                            </p>
			<p class="source-code">                          set send_slow {1 .1}</p>
			<p class="source-code">                          proc send {ignore arg} {</p>
			<p class="source-code">                          sleep .1</p>
			<p class="source-code">                          exp_send -s -- $arg</p>
			<p class="source-code">             }</p>
			<p class="source-code">} </p>
			<p class="source-code">set timeout -1</p>
			<p class="source-code">spawn bash simpleecho.sh</p>
			<p class="source-code">match_max 100000</p>
			<p class="source-code">expect -exact "Can you please input a word?:   "</p>
			<p class="source-code">send -- "word one\r"</p>
			<p class="source-code">expect -exact "word one\r</p>
			<p class="source-code">I got: word one\r</p>
			<p class="source-code">Now please input two words: \r</p>
			<p class="source-code">"</p>
			<p class="source-code">send -- "two rods "</p>
			<p class="source-code">expect -exact "</p>
			<p class="source-code">send -- ""</p>
			<p class="source-code">expect -exact "</p>
			<p class="source-code">send -- ""</p>
			<p class="source-code">expect -exact "</p>
			<p class="source-code">send -- ""</p>
			<p class="source-code">expect -exact "</p>
			<p class="source-code">send -- ""</p>
			<p class="source-code">expect -exact "</p>
			<p class="source-code">send -- "words\r"</p>
			<p class="source-code">expect -exact "words\r</p>
			<p class="source-code">I got: \"two\" \"words\"\r</p>
			<p class="source-code">Any more thoughts? \r</p>
			<p class="source-code">"</p>
			<p class="source-code">send -- "none whatsoever\r"</p>
			<p class="source-code">expect -exact "none whatsoever\r</p>
			<p class="source-code">none whatsoever is not a bad thing \r</p>
			<p class="source-code">Can you give me three of your favorite colors? \r</p>
			<p class="source-code">"</p>
			<p class="source-code">send -- "blue llow and "</p>
			<p class="source-code">expect -exact "</p>
			<p class="source-code">send -- ""</p>
			<p class="source-code">expect -exact "</p>
			<p class="source-code">send -- ""</p>
			<p class="source-code">expect -exact "</p>
			<p class="source-code">send -- ""</p>
			<p class="source-code">expect -exact "</p>
			<p class="source-code">send -- "cz"</p>
			<p class="source-code">expect -exact "</p>
			<p class="source-code">send -- "yan\r"</p>
			<p class="source-code">expect eof</p>
			<p>This script is a good starting point for automating our work, but be careful of one fatal flaw. In the last part that checks the inputs and outputs, it logged every typo and error that we made <a id="_idIndexMarker1011"/>during <a id="_idIndexMarker1012"/>input, but it hasn't saved the entire process of deleting them, so this input will not work. Before we can use it, we must edit this script and sort all the errors and inputs out. After that, we can expand on it and use additional arguments to test how our script is going to behave. </p>
			<h2 id="_idParaDest-332"><a id="_idTextAnchor339"/>See also</h2>
			<p><strong class="source-inline">expect</strong> is amazing for <a id="_idIndexMarker1013"/>testing. For more examples, please go to the following links: </p>
			<ul>
				<li>Expect command: <a href="https://likegeeks.com/expect-command/">https://likegeeks.com/expect-command/</a></li>
				<li>Expect man page: <a href="https://linux.die.net/man/1/expect">https://linux.die.net/man/1/expect</a></li>
			</ul>
			<h1 id="_idParaDest-333"><a id="_idTextAnchor340"/>Using dialog for menu-driven interactive scripts</h1>
			<p>Now that we've <a id="_idIndexMarker1014"/>used <strong class="source-inline">expect</strong>, we know how<a id="_idIndexMarker1015"/> to interact with other applications. The only thing left to do is learn how to make our scripts more interactive. It will come as no surprise that this problem is already solved in a standard way. In this recipe, we will use <strong class="source-inline">dialog</strong>, a command that may look deceptively simple but enables you to create both complex and visually interesting interactions with end users. </p>
			<h2 id="_idParaDest-334"><a id="_idTextAnchor341"/>Getting ready</h2>
			<p>By definition, <strong class="source-inline">dialog</strong>, as with any interaction, makes your scripts unusable in a non-interactive environment. This can be solved by either not using <strong class="source-inline">dialog</strong> at all or detecting if the script is running as a service or as an interactive script. </p>
			<p>Like <strong class="source-inline">expect</strong>, we must install <strong class="source-inline">dialog</strong> to use it. Simply use the following command:</p>
			<p class="source-code">sudo apt install dialog</p>
			<p>Everything that you need is going to be installed as required. </p>
			<h2 id="_idParaDest-335"><a id="_idTextAnchor342"/>How to do it…</h2>
			<p><strong class="source-inline">dialog</strong> is a whole application that contains not only menus but a lot of other widgets that are displayed in a GUI under text mode. It will use colors if they are available on your terminal (they probably are – terminals that are unable to show colors are long gone in our day and age) and will use cursor keys for navigation. We are going to show you a few of the most common ones, as well as how to use them. </p>
			<p>For a start, try running this command: </p>
			<p class="source-code">dialog --clear --backtitle "Simple menu" --title "Available \n</p>
			<p class="source-code">options" --menu "Choose one:" 16 50 4 1 "First" 2 "Second" 3 \n</p>
			<p class="source-code">"Third"</p>
			<p>If everything has gone well, you should see something like this (the size will depend on your terminal window): </p>
			<div>
				<div id="_idContainer241" class="IMG---Figure">
					<img src="Images/Figure_14.1_B16269.jpg" alt="Figure 14.1 – The dialog command enables us to create menus in a single line of our script&#13;&#10;" width="1192" height="654"/>
				</div>
			</div>
			<p class="figure-caption">Figure 14.1 – The dialog command enables us to create menus in a single line of our script</p>
			<p><strong class="source-inline">dialog</strong> acts as<a id="_idIndexMarker1016"/> a <a id="_idIndexMarker1017"/>good-looking proxy between your script and the user. Your script is responsible for the logic of the process you are trying to automate; <strong class="source-inline">dialog</strong> is responsible for dealing with user input and output. We need to do something with this menu; if we just call it from our Bash prompt, we have no use for it. The reason we used it this way was to show you how to call a widget. A lot of people expect a complicated procedure when they first see <strong class="source-inline">dialog</strong> being used in a script, which is just a command in one line and a couple of arguments. To demonstrate this, let's create an actual menu and save it in a file named <strong class="source-inline">menu.sh</strong>: </p>
			<p class="source-code">#!/bin/bash</p>
			<p class="source-code">HEIGHT=16</p>
			<p class="source-code">WIDTH=50</p>
			<p class="source-code">CHOICE_HEIGHT=4</p>
			<p class="source-code">BACKTITLE="Simple menu"</p>
			<p class="source-code">TITLE="Available options"</p>
			<p class="source-code">MENU="Choose one:"</p>
			<p class="source-code">OPTIONS=(1 "First" 2 "Second" 3 "Third")</p>
			<p class="source-code">CHOICE=$(dialog --clear \</p>
			<p class="source-code">                --backtitle "$BACKTITLE" \</p>
			<p class="source-code">                --title "$TITLE" \</p>
			<p class="source-code">                --menu "$MENU" \</p>
			<p class="source-code">                $HEIGHT $WIDTH $CHOICE_HEIGHT \</p>
			<p class="source-code">                "${OPTIONS[@]}" \</p>
			<p class="source-code">                2&gt;&amp;1 &gt;/dev/tty)</p>
			<p class="source-code">clear</p>
			<p class="source-code">case $CHOICE in</p>
			<p class="source-code">        1)</p>
			<p class="source-code">            echo "You chose First"</p>
			<p class="source-code">            ;;</p>
			<p class="source-code">        2)</p>
			<p class="source-code">            echo "You chose Second"</p>
			<p class="source-code">            ;;</p>
			<p class="source-code">        3)</p>
			<p class="source-code">            echo "You chose Third"</p>
			<p class="source-code">            ;;</p>
			<p class="source-code">esac</p>
			<p>What are we doing here? <strong class="source-inline">dialog</strong> requires a couple of parameters for every widget it can display. It needs a lot of values to correctly show whether something comes from your terminal. These are values such as the width and height of the screen and how to display the output correctly. As a rule, widgets only require user-defined things – the height and width of the widget itself, titles and other strings that are used in the widget, and the choices the user has. They are different from widget to widget, depending on the way it works and is used. In our first example, we are using a menu widget that requires a list of options and the size of the menu. We needed this list of options as it helps the user who's starting this script make a correct choice. We are also providing it with the titles, although we don't need all of them for our menu to function. </p>
			<p>An interesting thing to notice here is the way <strong class="source-inline">dialog</strong> returns the value that the user chose. To get that, we are providing indices in our list of possible options. When we run <strong class="source-inline">dialog</strong>, we are<a id="_idIndexMarker1018"/> going to assign the value it got <a id="_idIndexMarker1019"/>from the user directly to a variable and then act accordingly. </p>
			<h2 id="_idParaDest-336"><a id="_idTextAnchor343"/>How it works…</h2>
			<p><strong class="source-inline">dialog</strong> is based on displaying different widgets using different graphical characters to give the feel of a graphical interface inside the normal terminal. As somebody who uses dialog, you can change almost all the elements' appearance if you want, but usually, most scripts simply use <strong class="source-inline">dialog</strong> to quickly get the user to input the data they require. </p>
			<p>Using something like <strong class="source-inline">dialog</strong> is a great way to enable the user to choose values for different things in their script while avoiding a lot of input errors. </p>
			<p>For another example, let's imagine we need to ask a user to provide us with a date. We can do this using a simple entry with the <strong class="source-inline">read</strong> and <strong class="source-inline">echo</strong> commands. This will work but with a big risk of the user using the wrong format. You could solve this by explaining to your users what format you expect, but they will inevitably forget and use the wrong one. </p>
			<p>In <strong class="source-inline">dialog</strong>, you could do something simple, like this: </p>
			<p class="source-code">#!/bin/bash</p>
			<p class="source-code">DATEPROMPT="Choose a date"</p>
			<p class="source-code">CHOSENDATE=$(dialog --stdout --calendar "$DATEPROMPT" 0 0)</p>
			<p class="source-code">echo "Chosen date is $CHOSENDATE"</p>
			<p>The following is the output:</p>
			<div>
				<div id="_idContainer242" class="IMG---Figure">
					<img src="Images/Figure_14.2_B16269.jpg" alt="Figure 14.2 – Using the calendar widget to display dates is easy&#13;&#10;" width="1336" height="806"/>
				</div>
			</div>
			<p class="figure-caption">Figure 14.2 – Using the calendar widget to display dates is easy</p>
			<p>The date we <a id="_idIndexMarker1020"/>are<a id="_idIndexMarker1021"/> going to get will be in the right format, depending on the regional setting of the system running the script, and the user can choose from several good-looking calendars. <strong class="source-inline">dialog</strong> helps a lot here since it will even jump to the current date if we do not specify which specific date is going to be the default. Depending on the type of terminal emulation, <strong class="source-inline">dialog</strong> may even support using a computer mouse to select data. </p>
			<p>There are more very useful widgets that <strong class="source-inline">dialog</strong> provides, so we are going to show a few of them. We are not going to create a script for all of them since they are simple to use. The simplest way is to use the <strong class="source-inline">—stdout</strong> option to get the result of <strong class="source-inline">dialog</strong> into a variable and then work from there. </p>
			<p>If we need to choose a directory, that can be a big problem since the user would usually forget to write the path correctly or use absolute paths instead of relative ones. By using a simple <strong class="source-inline">dialog command</strong>, such as the following, we can avoid a lot of problems: </p>
			<p class="source-code">dialog --dselect ~ 10 39</p>
			<p>This is <a id="_idIndexMarker1022"/>the <a id="_idIndexMarker1023"/>expected result:</p>
			<div>
				<div id="_idContainer243" class="IMG---Figure">
					<img src="Images/Figure_14.3_B16269.jpg" alt="Figure 14.3 – Choosing directories using dialog avoids a lot of errors&#13;&#10;" width="665" height="702"/>
				</div>
			</div>
			<p class="figure-caption">Figure 14.3 – Choosing directories using dialog avoids a lot of errors</p>
			<p>A simple <strong class="source-inline">dialog</strong> is useful when we need to get a simple <em class="italic">yes</em> or <em class="italic">no</em> answer from the user. We can use the following code to do so:</p>
			<p class="source-code">dialog --yesno "Do you wish to do it?" 0 0</p>
			<p>Using this <strong class="source-inline">dialog</strong> command, we should get the following output:</p>
			<div>
				<div id="_idContainer244" class="IMG---Figure">
					<img src="Images/Figure_14.4_B16269.jpg" alt="Figure 14.4 – Sometimes, you need to ask a simple question that will have a simple answer&#13;&#10;" width="518" height="237"/>
				</div>
			</div>
			<p class="figure-caption">Figure 14.4 – Sometimes, you need to ask a simple question that will have a simple answer</p>
			<p>Then, we have <a id="_idIndexMarker1024"/>more<a id="_idIndexMarker1025"/> informative ones. In our scripts, we are often having to present the user with some information that they need to read. Having it in a formatted box is much nicer than simply printing it in a terminal: </p>
			<p class="source-code">dialog --msgbox "A lot of text can be displayed here!" 10 30</p>
			<p>This example will create the following output:</p>
			<div>
				<div id="_idContainer245" class="IMG---Figure">
					<img src="Images/Figure_14.5_B16269.jpg" alt="Figure 14.5 – Displaying text is easy and effective when you're using the right widget&#13;&#10;" width="566" height="420"/>
				</div>
			</div>
			<p class="figure-caption">Figure 14.5 – Displaying text is easy and effective when you're using the right widget</p>
			<p>There are a<a id="_idIndexMarker1026"/> few <a id="_idIndexMarker1027"/>widgets we will not mention as we are trying to give you a quick glimpse into what is possible. For the last example, we are going to show you a useful one – this widget shows the contents of a text file and automatically updates it with changes, enabling you, for example, to show a log to the user while they're installing something:</p>
			<p class="source-code">dialog --tailbox /var/log/syslog 40 80</p>
			<p>This is the expected output:</p>
			<div>
				<div id="_idContainer246" class="IMG---Figure">
					<img src="Images/Figure_14.6_B16269.jpg" alt="Figure 14.6 – tailbox is the same as using tail -f on a file but is much better looking&#13;&#10;" width="1332" height="834"/>
				</div>
			</div>
			<p class="figure-caption">Figure 14.6 – tailbox is the same as using tail -f on a file but is much better looking</p>
			<p>This concludes <a id="_idIndexMarker1028"/>our <a id="_idIndexMarker1029"/>overview of what <strong class="source-inline">dialog</strong> can do. Make sure that you read the documentation to learn about the rest of the widgets that you can use, as well as how to use them correctly. </p>
			<p>Note that there are other implementations of the same idea. One of those is called <em class="italic">whiptail</em> and is the same as <strong class="source-inline">dialog</strong> but uses a different way to draw objects on the screen. However, it is not as complete as <strong class="source-inline">dialog</strong>, and it lacks some widgets compared to <strong class="source-inline">dialog</strong>. </p>
			<h2 id="_idParaDest-337"><a id="_idTextAnchor344"/>See also</h2>
			<ul>
				<li><strong class="source-inline">dialog</strong> <a id="_idIndexMarker1030"/>man page: <a href="https://linux.die.net/man/1/dialog">https://linux.die.net/man/1/dialog</a></li>
				<li>Menu box guide: <a href="https://bash.cyberciti.biz/guide/A_menu_box">https://bash.cyberciti.biz/guide/A_menu_box</a></li>
			</ul>
		</div>
	</div></body></html>