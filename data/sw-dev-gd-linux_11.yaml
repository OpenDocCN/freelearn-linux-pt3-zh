- en: '11'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '11'
- en: Pipes and Redirection
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 管道和重定向
- en: 'In this chapter, you’re going to learn how to harness one of the most powerful
    computing concepts in existence: pipes! Pipes can be used to connect commands,
    building up complex, customized flows that accomplish a specific task. By the
    end of the chapter, you’ll be able to understand (or compose) something like this:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你将学习如何利用现有的最强大的计算概念之一：管道！管道可以用来连接命令，构建复杂的定制化流程，完成特定的任务。在本章结束时，你将能够理解（或编写）像这样的内容：
- en: '[PRE0]'
  id: totrans-3
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'In case you’re curious, this prints out a top-10 list of your most commonly
    used shell commands; on my machine, it produces this output:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你有兴趣，这会打印出你最常用的十大 shell 命令列表；在我的机器上，它会输出以下内容：
- en: '[PRE1]'
  id: totrans-5
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: To really understand pipes, you need to first understand file descriptors and
    input/output redirection, so that’s where we’ll start. Some of the information
    in this chapter is quite dense; just take your time and try out all the examples
    to make sure you understand everything. The time you invest in learning these
    concepts now will save you many hours throughout your career.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 要真正理解管道，你需要首先了解文件描述符和输入/输出重定向，这也是我们将要开始的内容。本章的一些信息可能比较密集，慢慢来，尝试所有示例，确保你理解每一个概念。现在投入的时间学习这些概念，将在你的职业生涯中为你节省大量时间。
- en: 'In this chapter, we’ll cover the following topics:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: File descriptors
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 文件描述符
- en: Connecting commands together with pipes (`|`)
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用管道（`|`）将命令连接在一起
- en: The CLI tools you need to know
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你需要了解的 CLI 工具
- en: Practical pipe patterns
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实用的管道模式
- en: Inspecting file descriptors
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 检查文件描述符
- en: File descriptors
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 文件描述符
- en: You’re probably familiar with file handles (also known as *file descriptors*)
    from your software engineering experience. If not, we recommend you check out
    *Chapter 5**, Introducing Files*. In short, if your program needs to read or write
    a file on the operating system, opening that file gives you a “file handle” to
    it – a pointer, or reference, to that file object.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能熟悉文件句柄（也称为*文件描述符*），这来自你在软件工程方面的经验。如果不熟悉，我们建议你查阅《第5章，介绍文件》。简而言之，如果你的程序需要读取或写入操作系统上的文件，打开该文件会给你一个“文件句柄”——它是该文件对象的指针或引用。
- en: Because the operating system mediates all access to system resources like files,
    it tracks which file handles, or descriptors, your program is actively referencing.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 因为操作系统会调度对系统资源（如文件）的所有访问，它会追踪你的程序当前正在引用哪些文件句柄或描述符。
- en: 'But even if a process doesn’t touch a single file on the operating system,
    it’s got some file handles open. In Unix-like operating systems, every process
    has at least three file descriptors:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 但即便是一个进程没有触碰操作系统上的任何文件，它也会打开一些文件句柄。在类似 Unix 的操作系统中，每个进程至少有三个文件描述符：
- en: '`stdin`: standard input - or, `fd 0` (“file descriptor zero”)'
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`stdin`：标准输入 - 或，`fd 0`（“文件描述符零”）'
- en: '`stdout`: standard output - or, `fd 1` (“file descriptor one”)'
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`stdout`：标准输出 - 或，`fd 1`（“文件描述符一”）'
- en: '`stderr`: standard error - or, `fd 2` (“file descriptor two”)'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`stderr`：标准错误 - 或，`fd 2`（“文件描述符二”）'
- en: These first three file descriptors function as standard communication channels
    to (and from) a process. As a result, they exist in the same order for every process
    created on the system. The first always points to a file which will be used to
    read in input. The second points to a file that will be used for writing output.
    And the third references a file that will receive error output.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 这三个文件描述符作为进程的标准通信通道，因此，它们对于系统上创建的每个进程来说，顺序都是一样的。第一个始终指向一个用于读取输入的文件。第二个指向一个用于写出输出的文件。第三个则指向一个用于接收错误输出的文件。
- en: 'Optionally, after those first three standard file descriptors, there can be
    any number of other file descriptors/handles, based on what the program is doing.
    Your process could have:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 可选地，在前面提到的三个标准文件描述符之后，可能会有任意数量的其他文件描述符/句柄，具体取决于程序的操作。你的进程可能会有：
- en: Files it’s working with
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它正在操作的文件
- en: Sockets it’s reading from or writing to (think Unix or TCP sockets being written
    to for networking)
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它正在读取或写入的套接字（考虑到 Unix 或 TCP 套接字用于网络通信时的写入）
- en: Devices like keyboards or disks it needs to use
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设备，如键盘或磁盘，它需要使用的设备
- en: What do these file descriptors reference?
  id: totrans-25
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 这些文件描述符引用了什么？
- en: 'You now know, from the perspective of a process, what these file descriptors
    are used for:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你从一个进程的角度，已经知道了这些文件描述符的作用：
- en: '`0` (`STDIN`): get input from here'
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`0`（`STDIN`）：从这里获取输入'
- en: '`1` (`STDOUT`): put regular output here'
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`1`（`STDOUT`）：将常规输出放到这里'
- en: '`2` (`STDERR`): put error output here'
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`2`（`STDERR`）：将错误输出放到这里'
- en: But if we zoom outside of a single process, which files are these file descriptors
    actually pointing to? Where does input come from, and where do output and errors
    get written to?
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，如果我们跳出单个进程来看，这些文件描述符到底指向哪些文件呢？输入来自哪里，输出和错误又写入哪里？
- en: 'Let’s use a Bash shell process as an example: by default, it takes input (STDIN)
    from your terminal (which is represented by a file on the filesystem). Bash prints
    output and errors to the same terminal. In essence, your entire shell session
    is happening via read and write operations to a single file. You’ll learn much
    more about Bash in the next chapter, *Automating Tasks with Shell Scripts*.'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们以Bash shell进程为例：默认情况下，它从你的终端（在文件系统中表示为一个文件）获取输入（STDIN）。Bash将输出和错误打印到相同的终端。实际上，你的整个shell会话都是通过对一个文件进行读写操作来进行的。在下一章*使用Shell脚本自动化任务*中，你将学到更多关于Bash的知识。
- en: Let’s look at this kind of input and output redirection in more detail.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更详细地看看这种输入和输出重定向。
- en: Input and output redirection (or, playing with file descriptors for fun and
    profit)
  id: totrans-33
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 输入输出重定向（或者说，玩转文件描述符以获得乐趣和收益）
- en: 'This knowledge comes in handy quite often during real-life development tasks:
    every time you want to avoid typing lots of input and take it from a file instead,
    or when you want to log the output of a program, and many more situations. When
    you create a process, you can control where its three standard file descriptors
    point, with powerful results.'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 这些知识在实际开发任务中非常有用：每当你想避免输入大量内容而改为从文件中获取，或者当你想记录程序输出时，都会用到这种技巧，还有许多其他情况。当你创建一个进程时，可以控制它的三个标准文件描述符指向哪里，从而产生强大的效果。
- en: 'Input redirection: <'
  id: totrans-35
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 输入重定向：<
- en: The `<` (less-than) symbol lets you control where a process gets its input from.
    For example, you’re used to giving input to Bash with your keyboard, one command
    at a time. Let’s try giving Bash input from a file, instead!
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: '`<`（小于）符号让你控制一个进程的输入来源。例如，你通常是通过键盘逐个命令给Bash提供输入。让我们尝试从文件给Bash提供输入吧！'
- en: 'Assume I have a file named `commands.txt` with the following content (I’m using
    `cat` here to print out my example file):'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我有一个名为`commands.txt`的文件，内容如下（我在这里用`cat`来打印我的示例文件）：
- en: '[PRE2]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'These are valid shell commands, as far as Bash is concerned, so I’m going to
    launch a new Bash process and use this file as standard input:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 这些都是Bash认为有效的Shell命令，所以我要启动一个新的Bash进程，并将此文件作为标准输入使用：
- en: '[PRE3]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Instead of prompting me for input and waiting until I give it, Bash reads and
    executes one line at a time: it reads input from the file until it comes across
    a newline (`\n`) character, and just as if you’d hit the *RETURN* key, it executes
    the command.'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: Bash不会提示我输入并等待我输入，而是一次读取并执行一行：它从文件中读取输入，直到遇到换行符（`\n`）为止，就像你按下*RETURN*键一样，它执行命令。
- en: In this example, the program’s standard output is still going back to our terminal,
    where we can read it. Let’s change that now.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，程序的标准输出仍然回到我们的终端，我们可以读取它。现在让我们来改变它。
- en: 'Output redirection: >'
  id: totrans-43
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 输出重定向：>
- en: 'We want to redirect `STDOUT` (file descriptor `1`) to a file instead of a terminal,
    logging the output of each command instead of printing it out to the terminal
    in real time:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 我们想将`STDOUT`（文件描述符`1`）重定向到一个文件，而不是终端，将每个命令的输出记录下来，而不是实时地打印到终端：
- en: '[PRE4]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Notice that there is no visible output in the terminal now – because the `>`
    character has redirected output to `output.log`. Use `cat` to print out the log
    file and confirm that it contains the expected output:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，现在终端中没有可见的输出——因为`>`字符将输出重定向到了`output.log`。使用`cat`打印出日志文件，确认它包含了预期的输出：
- en: '[PRE5]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Interestingly, you’ll notice that because file descriptor `1` is standard output,
    writing `>` is the same as writing `1>`. You’ll rarely see a `1` used, because
    it’s assumed that standard output is being redirected. In other words:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 有趣的是，你会注意到，由于文件描述符`1`是标准输出，写`>`和写`1>`是一样的。你很少看到使用`1`，因为通常会假设标准输出被重定向了。换句话说：
- en: '[PRE6]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Use >> to append output without overwriting
  id: totrans-50
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用`>>`追加输出而不覆盖
- en: In the previous example, we created a log file by redirecting command output
    with `>`. If you run the example a few times, you’ll notice that the log file
    doesn’t grow at all. Each time you redirect output to a file with `> filename`,
    anything in that file will be overwritten.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 在之前的例子中，我们通过重定向命令输出到`>`创建了一个日志文件。如果你多次运行这个例子，你会注意到日志文件一点也没有增长。每次用`> filename`重定向输出到文件时，文件中的任何内容都会被覆盖。
- en: To avoid that – as in the case of a long-lived log file that collects output
    from more than a single process or command – use `>>` (append). This will simply
    append to your output file, instead of overwriting its entire contents each time.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 为了避免这种情况——就像处理一个长期存在的日志文件，这个文件收集来自多个进程或命令的输出——可以使用`>>`（追加）。这样，每次运行时，它会将内容追加到输出文件中，而不是覆盖文件的整个内容。
- en: 'We’ll cover Bash scripts in more detail in a later chapter, but for now, here’s
    a quick script that writes a timestamp of the current time to a log file once
    per second:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在后面的章节中更详细地介绍Bash脚本，但现在，这里有一个简单的脚本，它每秒将当前时间的时间戳写入日志文件：
- en: '[PRE7]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: In this example script, we create an infinite loop (while true; do [ ... ] done)
    which runs the date command. It redirects the output of this command to the `/tmp/date.log`
    file using `>>`, which appends the output to the file (`>` would overwrite the
    file each time). Then, the script sleeps for one second, and starts again from
    the beginning.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例脚本中，我们创建了一个无限循环（while true; do [ ... ] done），它运行`date`命令。它将此命令的输出重定向到`/tmp/date.log`文件中，使用`>>`，这会将输出追加到文件中（`>`每次都会覆盖文件）。然后，脚本会休眠一秒钟，再从头开始。
- en: 'Running the `date` command once produces the following output:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 运行一次`date`命令会产生以下输出：
- en: '[PRE8]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Running this script, on the other hand, does nothing visible at first, because
    the output is being redirected to a file. Here’s what it looks like when I paste
    this little script into my terminal, let it run for a bit, kill it with *Ctrl*
    + *C*, and then print out the contents of the file it created:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，运行这个脚本最初不会看到任何可见的输出，因为输出被重定向到文件中。下面是我将这个小脚本粘贴到终端中，运行一会儿，按*Ctrl* + *C*终止它，然后打印出它创建的文件内容时的情况：
- en: '[PRE9]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: You’ll use this kind of simple output redirection in all kinds of everyday situations,
    like creating an ad hoc log file for a quick debug script you throw together.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 在所有日常情况下，你都会使用这种简单的输出重定向，比如为快速调试脚本创建一个临时的日志文件。
- en: Error redirection with 2>
  id: totrans-61
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 错误重定向使用2>
- en: Many command-line programs that have a lot of expected output will also output
    occasional errors – think of a `find` command that encounters occasional “permission
    denied” errors for directories you’re not allowed to peek inside.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 许多命令行程序都有大量预期的输出，同时也会偶尔输出错误——想想一个`find`命令，它会遇到“权限拒绝”的错误，因为你没有权限查看某些目录。
- en: Although these kinds of errors are minor and expected, you don’t want them mixed
    in with everything else, polluting your output. This becomes especially important
    when you’re not using command-line tools interactively, but rather writing small
    scripts or larger programs that process the output of the commands you’re running.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管这些错误是微小且可以预见的，但你不希望它们与其他内容混在一起，污染你的输出。当你不是交互式地使用命令行工具，而是编写小脚本或更大的程序来处理你运行的命令的输出时，这一点尤其重要。
- en: 'You’ve seen how to redirect Standard Input (`fd 0`) and Standard Output (`fd
    1`). Let’s look at how to redirect Standard Error (`fd 2`) using the `2>` (redirect
    file descriptor 2) syntax:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 你已经看到如何重定向标准输入（`fd 0`）和标准输出（`fd 1`）。现在我们来看看如何使用`2>`（重定向文件描述符2）语法来重定向标准错误（`fd
    2`）：
- en: '[PRE10]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: This command searches for any files named `php.ini` inside the `/etc` directory
    tree. The files it finds (`find`'s `STDOUT`) are written to `/tmp/phpinis.log`,
    and any errors it encounters are ignored by sending them to a special file called
    `/dev/null`.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 这个命令在`/etc`目录树内查找任何名为`php.ini`的文件。它找到的文件（`find`的`STDOUT`）会写入`/tmp/phpinis.log`，而遇到的任何错误都会通过将其发送到一个特殊的文件`/dev/null`来忽略。
- en: '**Tip**'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: '**提示**'
- en: '`/dev/null` is a special file-like object that returns zeros when you try to
    read from it and ignores anything written to it – it’s used as a kind of garbage
    dump for output that engineers want to silence or ignore. You’ll see it used quite
    often in scripts.'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: '`/dev/null`是一个特殊的类文件对象，当你尝试从中读取时，它返回零，写入任何内容时会被忽略——它作为一种垃圾桶，用来存放工程师希望静默或忽略的输出。你将在脚本中经常看到它的使用。'
- en: 'Now that you’ve seen input and output redirection, let’s look at pipes, which
    put both of those concepts together: they redirect the output of one command to
    the input of another.'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经了解了输入和输出的重定向，我们来看一下管道，它将这两个概念结合在一起：它们将一个命令的输出重定向到另一个命令的输入。
- en: Connecting commands together with pipes (|)
  id: totrans-70
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用管道（|）将命令连接在一起
- en: You’ve learned how to redirect each of the three standard file descriptors to
    various locations and seen why that’s often useful. But what if, instead of just
    redirecting input and output to and from various files, you wanted to connect
    *multiple programs* together?
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 你已经学会了如何将三个标准文件描述符重定向到不同的位置，并了解了为什么这样做通常很有用。但如果你不仅仅是将输入输出重定向到不同的文件，而是想将 *多个程序*
    连接在一起怎么办？
- en: 'On the command line, you can use the pipe character (`|`) to connect the output
    of one program to the input of another program. This is an extremely powerful
    paradigm that is heavily used in Unix and Linux to create custom sorting, filtering,
    and processing commands:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 在命令行中，你可以使用管道符（`|`）将一个程序的输出连接到另一个程序的输入。这是一个非常强大的范式，在 Unix 和 Linux 中被广泛使用来创建自定义的排序、过滤和处理命令：
- en: '[PRE11]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'If you paste this into your shell, you’ll see `treasure found` printed out.
    Here’s what happened:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你将这段代码粘贴到你的 shell 中，你会看到打印出 `treasure found`。下面是发生了什么：
- en: The first command, `echo`, runs and produces the output you see between double
    quotes (the newline characters make this a 3-line string).
  id: totrans-75
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 第一个命令 `echo` 执行并生成你看到的输出（这些输出被双引号包围，换行符使其成为一个三行字符串）。
- en: The pipe character streams that output (file descriptor 1) to the input of the
    next command (file descriptor 0), `grep`. `grep`'s input is now hooked up to the
    output of the previous command.
  id: totrans-76
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 管道符将该输出（文件描述符 1）流向下一个命令（文件描述符 0）的输入，即 `grep`。`grep` 的输入现在与前一个命令的输出连接在一起。
- en: The `grep` command looks at each newline-delimited line in turn and finds a
    match for `treasure` on the second line. `grep` prints that second line to its
    standard output.
  id: totrans-77
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`grep` 命令依次查看每一行以换行符分隔的内容，并在第二行找到 `treasure` 的匹配项。`grep` 将第二行打印到其标准输出中。'
- en: Multi-pipe commands
  id: totrans-78
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 多重管道命令
- en: 'Here’s the – fairly extreme – example you saw at the beginning of the chapter:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 这是你在本章开头看到的—相当极端—示例：
- en: '[PRE12]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Each pipe in this complex command simply takes the output of the previous command
    (`STDOUT`) and uses it as the input (`STDIN`) for the next command.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个复杂的命令中，每个管道只是将前一个命令的输出（`STDOUT`）作为输入（`STDIN`）传递给下一个命令。
- en: Piping the output of one command into the input of another is what enables these
    kinds of flows, filtering and sorting the data streaming between these commands
    without actually having to write any custom software. Just because there’s no
    program called `top10commands` doesn’t mean you can’t quickly cobble one together
    with existing, standard commands like this.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 将一个命令的输出传递到另一个命令的输入中，就是实现这些流程的方式，它能在不编写任何自定义软件的情况下，过滤和排序这些命令之间流动的数据。仅仅因为没有名为
    `top10commands` 的程序，并不意味着你不能快速利用现有的标准命令来拼凑一个类似的程序。
- en: Reading (and building) complex multi-pipe commands
  id: totrans-83
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 阅读（并构建）复杂的多管道命令
- en: 'No matter how complex or magical some of the piped-together commands you encounter
    will seem, they were all built the same way: one command at a time. Whether you’re
    trying to read a complex series of commands like this or creating one of your
    own, the process is the same:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 无论你遇到的管道连接命令看起来多么复杂或神奇，它们都是通过相同的方式构建的：一次一个命令。无论你是在尝试理解像这样的复杂命令序列，还是自己创建一个，过程都是一样的：
- en: Take the first command and make sure you understand what it does, at a basic
    level. Scan the man page or other documentation if you aren’t familiar with it.
  id: totrans-85
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 先看第一个命令，确保你基本理解它的作用。如果你不熟悉它，可以查看 man 页面或其他文档。
- en: Run the command and inspect its output.
  id: totrans-86
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行命令并检查其输出。
- en: Add the pipe and the command following it.
  id: totrans-87
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加管道符及其后面的命令。
- en: Repeat from *step 1* until you’ve made it all the way through the commands.
  id: totrans-88
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从 *步骤 1* 开始重复，直到你完成所有命令。
- en: You’ll see that even the scariest shell/pipe monstrosities become manageable
    when you apply this process. Always remember that you’re just dealing with a data
    stream, which flows through the pipes from command to command, being shaped, modified,
    filtered, redirected, and transformed along the way.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 你会看到，即使是最复杂的 shell/pipe 命令怪物，当你应用这个过程时也变得可以管理。始终记住，你所处理的只是一个数据流，它通过命令之间的管道流动，在这个过程中被塑形、修改、过滤、重定向和转换。
- en: 'We’ll discuss this more in *Chapter 12*, *Automating Tasks with Shell Scripts*,
    but try to be respectful of other programmers who must read your code: limit your
    statements to two or three pipes, and use well-named variables to store intermediate
    results for easy reading if your memory constraints allow it.'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在 *第12章*，《使用 Shell 脚本自动化任务》中进一步讨论这个话题，但请尽量尊重其他需要阅读你代码的程序员：将你的语句限制为两到三个管道，并使用有意义的变量来存储中间结果，以便于阅读，如果你的内存限制允许的话。
- en: Now that you’ve seen how the primitives of file descriptors are exposed as easy-to-use
    input and output redirection, let’s look at some real-world examples of useful
    program combinations that rely on this composability that’s built into Unix.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经看到文件描述符的原始操作如何作为易于使用的输入和输出重定向暴露出来，让我们来看一些依赖于 Unix 内置可组合性的实际程序组合的示例。
- en: The CLI tools you need to know
  id: totrans-92
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 你需要了解的 CLI 工具
- en: Before we jump into the kinds of wild combinations that you saw at the beginning
    of the chapter, let’s look at some of the most common Unix helper tools that are
    used to filter, sort, and glue together these data streams you’ll be creating
    on the command line.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们跳入章节开始时看到的那些复杂组合之前，先让我们看一些最常用的 Unix 辅助工具，这些工具用于过滤、排序和组合你将在命令行上创建的数据流。
- en: cut
  id: totrans-94
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: cut
- en: '`cut` takes a delimiter (`-d`) and splits input on that delimiter, like `String.Split()`
    or `String.Fields()` in many programming languages. You then select which field
    (list element) you want to output with `-f`, for example, `f1` for the first field.'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: '`cut` 接收一个分隔符（`-d`）并根据该分隔符拆分输入，类似于许多编程语言中的 `String.Split()` 或 `String.Fields()`。然后，你可以使用
    `-f` 选择要输出的字段（列表元素），例如，`f1` 表示第一个字段。'
- en: 'If you feed `cut` more than one line of input, it will repeat that same operation
    on all lines:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你输入多行给 `cut`，它会在所有行上重复相同的操作：
- en: '[PRE13]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'You can see how using different delimiters for cut would work, too; in the
    following example, we cut on the hyphen character instead of a space:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以看到使用不同分隔符的 `cut` 是如何工作的；在以下示例中，我们按连字符而不是空格进行切割：
- en: '[PRE14]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: You can see that this changes the number of fields available as well – two in
    this case, since there’s only one hyphen in the text. Trying to print the fourth
    field with `–f4`, as in the previous example, will just give you an empty line.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以看到这也改变了可用字段的数量——在这种情况下是两个，因为文本中只有一个连字符。尝试使用 `–f4` 打印第四个字段，如前面的示例所示，将只返回一个空行。
- en: 'To get friendly names for all users with root in their names on an macOS machine,
    you can use the following:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 要获取所有用户名中包含 root 字符串的 macOS 用户的友好名称，可以使用以下命令：
- en: '[PRE15]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: sort
  id: totrans-103
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: sort
- en: '`sort` does a per-line sorting, alphabetical or numeric.'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: '`sort` 执行逐行排序，可以是字母顺序或数字顺序。'
- en: Reverse-sorting with `-r` is often useful when dealing with numeric data (`-n`).
    You’ll often want `-rn` together (see Top X in the Practical pipe patterns section
    of this chapter).
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `-r` 进行反向排序通常在处理数字数据（`-n`）时很有用。你通常会一起使用 `-rn`（参见本章的实践管道模式中的 Top X 部分）。
- en: 'The `-h` flag can be very useful for sorting by human-readable output of many
    other commands, like this:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: '`-h` 标志对于排序许多其他命令的可读输出非常有用，像这样：'
- en: '[PRE16]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: uniq
  id: totrans-108
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: uniq
- en: 'Removes duplicate lines. This command needs sorted data to work the way you
    expect, otherwise it only checks whether each line is a duplicate of the previous
    line:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 删除重复行。此命令需要排序数据才能按预期工作，否则它只会检查每行是否为前一行的重复：
- en: '[PRE17]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Default behavior; probably not what you want:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 默认行为；可能不是你想要的：
- en: '[PRE18]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: '`uniq` skips occurrences when they follow each other but leaves them when they’re
    separated by other text. Now the same thing, with sorted data:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: '`uniq` 会跳过相邻的重复项，但如果它们被其他文本分隔开，仍然会保留它们。现在，使用已排序的数据，效果如下：'
- en: '[PRE19]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Counting
  id: totrans-115
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 计数
- en: '`uniq` also has a useful “count” option, accessible with `–c`. The same caveat
    about sorted input is worth restating here – for example, a file with the following
    content:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: '`uniq` 还提供了一个有用的“计数”选项，通过 `–c` 来访问。关于输入必须排序的警告值得在这里重申——例如，文件包含以下内容：'
- en: '[PRE20]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Will produce the following output when run through `uniq -c`:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 运行 `uniq -c` 后将产生以下输出：
- en: '[PRE21]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'This is not what most users expect: there are 3 occurrences of `arch` in the
    file, but `uniq` shows two separate counts for the same word. To get the behavior
    you expect (`uniq` should return output that doesn’t contain any duplicate lines),
    your input must be sorted.'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 这不是大多数用户期望的结果：文件中有 3 次出现 `arch`，但 `uniq` 显示两个分别的计数。为了得到你期望的行为（`uniq` 应该返回没有重复行的输出），输入必须是已排序的。
- en: 'This is annoying for beginners, but very much in line with the Unix philosophy:
    tools should be small and sharp and shouldn’t duplicate functionality from each
    other. If you write a sorting tool, it should only sort, and if you write a uniquifying
    tool, it is allowed to depend on sorting from another tool to ensure extremely
    conservative (and consistent) memory usage.'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 这对初学者来说可能有些麻烦，但这正符合 Unix 的哲学：工具应该是小巧且锋利的，不应该重复彼此的功能。如果你编写一个排序工具，它应该只负责排序；如果你编写一个去重工具，它可以依赖于另一个工具的排序功能，以确保极其保守（且一致）的内存使用。
- en: 'Here, we sort before using `uniq`, which gets us the output we expect:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们在使用`uniq`之前进行排序，这样可以得到我们预期的输出：
- en: '[PRE22]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'You’ll notice that this sorts in ascending order, which isn’t what you want
    for the top-X list of commands you saw at the beginning of the chapter. To solve
    this, we do a “reverse numeric” sort (`-rn`) of this numbered list (since each
    line now starts with a number, thanks to `uniq –c`, this is easy to do). Here’s
    an example of this in action, on a file with many more duplicates:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 你会注意到，这个排序是按升序进行的，而这并不是你想要的，对于开头部分看到的命令的top-X列表。为了解决这个问题，我们对这个编号列表进行“反向数字”排序（`-rn`）（因为每行现在都以数字开头，感谢`uniq
    -c`，这变得很容易）。下面是一个在包含更多重复项的文件上执行的例子：
- en: '[PRE23]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: wc
  id: totrans-126
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: wc
- en: 'With this command you can measure the word, line, character, and byte input
    counts. You can also count space-delimited words with `-w`:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这个命令，你可以测量单词、行、字符和字节的输入计数。你还可以使用`-w`来计数字符串中用空格分隔的单词：
- en: '[PRE24]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Line-counting is extremely common in the following format:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 行计数在以下格式中非常常见：
- en: '[PRE25]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: head
  id: totrans-131
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: head
- en: '`Head` returns the first lines of a stream or file – 10 lines by default. Specify
    how many lines you want with `-n`:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: '`Head`返回流或文件的前几行——默认情况下是10行。使用`-n`指定你想要的行数：'
- en: '[PRE26]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: tail
  id: totrans-134
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: tail
- en: 'This is the opposite of `head`: it returns lines from the end of the file or
    stream. It takes `-n` just like `head`.'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 这与`head`相反：它返回文件或流的末尾几行。它像`head`一样接受`-n`参数。
- en: '`tail` can also be used interactively for following along with a log file,
    even as that file has new data streamed/written to it. You’ll see it used a lot
    like this during troubleshooting:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: '`tail`也可以用于交互式地跟踪日志文件，即使该文件正在被写入新数据。你会在故障排除时经常看到它这样使用：'
- en: '[PRE27]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: tee
  id: totrans-138
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: tee
- en: Sometimes, one copy of the data from standard input just isn’t enough. `tee`
    copies standard input to standard output, while also making a copy in a file.
    As a software developer, I really like `tee` for two specific cases.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 有时候，标准输入的一个副本是不够的。`tee`将标准输入复制到标准输出的同时，还将其复制到一个文件中。作为软件开发人员，我特别喜欢在两种情况下使用`tee`。
- en: 'First, for debugging and logging: when I’m running scripts or programs that
    generate output, `tee` can be used to both display the output on the screen and
    log it to a file for later analysis. We’re using the `echo` command here, but
    you’d likely be calling your own program before the first pipe here:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，为了调试和记录日志：当我运行生成输出的脚本或程序时，`tee`可以同时将输出显示在屏幕上，并将其记录到文件中以供后续分析。我们这里使用的是`echo`命令，但你可能会在第一个管道前调用自己的程序：
- en: '[PRE28]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: The second use case where `tee` comes in handy is for copying data from a pipeline
    like the ones we’re learning to construct in this chapter. You can use `tee` to
    intercept this flow at any point in the pipe, and save/inspect the intermediate
    results without disrupting the pipeline.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: '`tee`的第二个用途是从管道中复制数据，像我们在本章中学习构建的管道。你可以使用`tee`在管道的任何点拦截数据流，并保存/检查中间结果而不干扰管道的运行。'
- en: 'Here’s the “top 10 commands” example from earlier, but with `tee` inserted
    before limiting the results to just 10\. This saves the full results in a temp
    file before we truncate them:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 这是之前提到的“前10个命令”的例子，但是在将结果限制为前10个之前，插入了`tee`。这样会在我们截断结果之前将完整的结果保存在临时文件中：
- en: '[PRE29]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Now if you want to see all of the commands, not just the top 10, you can just
    use `cat` or `less` to inspect the `/tmp/all_commands.txt` file.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想查看所有命令，而不仅仅是前10个，你可以使用`cat`或`less`来查看`/tmp/all_commands.txt`文件。
- en: awk
  id: totrans-146
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: awk
- en: '`awk` is often just used for dealing with columns of data, but it’s actually
    a whole language.'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: '`awk`通常用于处理数据的列，但它实际上是一种完整的语言。'
- en: 'For example, you can grab the second column from each line in the following
    way:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，你可以通过以下方式提取每行的第二列：
- en: '[PRE30]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: sed
  id: totrans-150
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: sed
- en: '`sed` is a stream editor with tons of options. Most commonly, it’s used for
    character replacement in streams or files.'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: '`sed`是一个流编辑器，具有许多选项。最常用的是用于在流或文件中进行字符替换。'
- en: 'Imagine we have a file like this:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们有一个这样的文件：
- en: '[PRE31]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'If we want to redact ONLY the line that has `password`, and nothing else, on
    it:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们只想编辑包含`password`的那一行，且不修改其他内容：
- en: '[PRE32]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: This example uses a file rather than an input stream coming from another command.
    By default, this will not modify the original file. If you *do* want to modify
    the input file, use the `-i` (in-place) option.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子使用的是一个文件，而不是来自其他命令的输入流。默认情况下，这不会修改原始文件。如果你*确实*想修改输入文件，可以使用`-i`（就地）选项。
- en: Now that you’ve been introduced to pipes and have seen some of the most common
    command-line tools, let’s put those building blocks together and learn several
    practical patterns that you can use to make your daily command-line life a bit
    easier.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经了解了管道符并且看到了常见的命令行工具，接下来我们将把这些基础知识结合起来，学习几种实用的模式，帮助你使日常的命令行工作变得更轻松。
- en: Practical pipe patterns
  id: totrans-158
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实用的管道模式
- en: As mentioned before, longer multi-pipe commands are built iteratively – one
    command at a time. However, there are some useful patterns that you’ll see re-used
    frequently.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，较长的多管道命令是逐步构建的——一次一个命令。然而，有一些常用的模式，你会经常看到它们被重复使用。
- en: “Top X”, with count
  id: totrans-160
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: “前 X 名”，并附上计数
- en: This pattern sorts the input by the number of occurrences, in descending order.
    You saw this in the original example from this chapter, which displayed the most
    frequently used shell commands from Bash’s history file.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 这个模式根据出现的次数对输入进行排序，按降序排列。你在本章的原始示例中看到了这个，它展示了从 Bash 历史文件中提取的最常用的 shell 命令。
- en: 'Here’s the pattern:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是这个模式的示例：
- en: '[PRE33]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'We can note the following details about this pattern:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以注意到这个模式的一些细节：
- en: The input is sorted alphabetically, and then run through `uniq -c`, which needs
    sorted input to work on.
  id: totrans-165
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 输入按字母顺序排序，然后通过 `uniq -c` 进行处理，`uniq -c` 需要已排序的输入才能正常工作。
- en: '`uniq -c` eliminates duplicates, but adds a count (`-c`) of how many duplicates
    it found for each entry.'
  id: totrans-166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`uniq -c` 消除重复项，但会添加一个计数（`-c`），表示每个条目出现的次数。'
- en: '`sort` is run again, this time as a reverse-numeric (`-r` and `-n`) sort which
    sorts the unique counts from the input and outputs the lines in reverse (highest
    number first) sorted order.'
  id: totrans-167
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`sort` 会再次运行，这次是按逆数字（`-r` 和 `-n`）排序，按输入中的唯一计数排序，并输出逆序（从高到低）的排序结果。'
- en: '`head` takes that top ranking and cuts it down to three lines (`-n 3`), giving
    you the top three strings from the original input, along with how often they occurred.'
  id: totrans-168
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`head` 会获取排名靠前的部分，并将其缩减为三行（`-n 3`），展示原始输入中的前三个字符串，以及它们出现的频率。'
- en: This pattern can come in handy when you need to know the most common browser
    user-agents hitting your website, the IP addresses of the worst offenders who
    are trying to probe and exploit your website, or any other situation where a sorted,
    ranked list is useful.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 当你需要了解最常见的浏览器用户代理访问你的网站、那些试图探测并利用你网站的最恶劣的 IP 地址，或者任何其他排序和排名列表有用的情况时，这个模式会非常有用。
- en: curl | bash
  id: totrans-170
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: curl | bash
- en: 'The `curl | bash` pattern is a common shortcut used in Linux to download and
    execute scripts directly from the internet. This method combines two powerful
    command-line tools: `curl`, which fetches the content from a URL, and `bash`,
    the shell interpreter, which executes the downloaded script. This pattern is a
    significant time-saver, allowing developers to quickly deploy applications or
    run scripts without manually downloading and then executing them.'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: '`curl | bash` 模式是 Linux 中常用的快捷方式，用于直接从互联网下载并执行脚本。这个方法结合了两个强大的命令行工具：`curl`，用于从
    URL 获取内容；以及 `bash`，用于执行下载的脚本。这个模式节省了大量时间，使开发人员可以快速部署应用程序或运行脚本，而无需手动下载然后执行它们。'
- en: 'As an example, let’s install the Pi-hole adblocking DNS server using this pattern:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，让我们使用这个模式安装 Pi-hole 广告拦截 DNS 服务器：
- en: '[PRE34]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Let’s break this down, step by step:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们一步步地分解这个模式：
- en: '`curl -sSL https://install.pi-hole.net`: This fetches the Pi-hole installation
    script, which is hosted at this URL. We pass two options:'
  id: totrans-175
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`curl -sSL https://install.pi-hole.net`: 该命令会获取 Pi-hole 安装脚本，该脚本托管在此 URL 上。我们传递了两个选项：'
- en: '`-sS`: Silent mode gives you the raw response from the server, but shows errors
    should they occur.'
  id: totrans-176
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-sS`: 静默模式会从服务器获取原始响应，但如果发生错误，则会显示错误信息。'
- en: '`-L`: Follow redirects.'
  id: totrans-177
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-L`: 跟随重定向。'
- en: '`|`: The pipe symbol passes the output of the previous command (`curl`) as
    input to the next command (`bash`).'
  id: totrans-178
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`|`: 管道符将前一个命令（`curl`）的输出作为输入传递给下一个命令（`bash`）。'
- en: '`bash`: Executes the script fetched by `curl`.'
  id: totrans-179
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`bash`: 执行通过 `curl` 获取的脚本。'
- en: This is a tremendously useful pattern for automating things like code deployments
    or local environment installation/configuration. However, take special care that
    the script you download and execute is not malicious. Blindly running scripts
    from the internet is extremely bad practice.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个非常有用的模式，适用于自动化如代码部署或本地环境安装/配置等任务。然而，特别需要小心的是，下载并执行的脚本不能是恶意的。从互联网随便运行脚本是极其不推荐的做法。
- en: Security considerations for curl | sudo | bash
  id: totrans-181
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: curl | sudo | bash 的安全性考虑
- en: 'Anytime you trust a third party to run code on your machine, you’re trading
    some security for convenience. In that sense, using `curl | sudo | bash` to install
    something via a script hosted on a trusted server is not much different from using
    a package manager. Most package managers (except for `nix`) don’t have a particularly
    impressive security design either, but they generally give you a reasonable set
    of security features. You’re giving all of these security features up when you
    `curl | sudo | bash` an install script:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 每当你信任第三方在你的机器上运行代码时，你就已经在安全性和便利性之间做出了权衡。从这个角度来看，使用`curl | sudo | bash`通过托管在受信任服务器上的脚本安装软件，与使用包管理器并没有太大区别。大多数包管理器（除了`nix`）的安全设计也不算特别出色，但它们通常会提供合理的安全功能。你在执行`curl
    | sudo | bash`安装脚本时，实际上放弃了所有这些安全特性：
- en: There’s no package that can be checksummed and cryptographically signed to make
    sure you got the correct and official version.
  id: totrans-183
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 没有可以进行校验和和加密签名的包来确保你获得了正确和官方的版本。
- en: 'There’s no restriction on – or enforcement of – which servers you download
    from, and you don’t know how secure those servers are: you have no way to identify
    a compromised server hosting malicious install scripts.'
  id: totrans-184
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 下载文件时没有任何限制或强制措施，你也无法知道这些服务器的安全性：你无法识别是否有被破坏的服务器托管恶意安装脚本。
- en: The scripts themselves are just code being run as the root user on your machine,
    so they can do anything *you* can on your machine, for better or worse. To be
    fair, many popular package managers also have this problem.
  id: totrans-185
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这些脚本本身就是在你的机器上以root用户身份运行的代码，因此它们可以做任何*你*能在机器上做的事情，无论好坏。公平地说，许多流行的包管理器也存在这个问题。
- en: 'For all of these reasons, please heed our warning to split `curl` into its
    own step and read through the downloaded install script before running `sudo`
    `bash` to execute it. The main things to look out for are:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 基于以上所有原因，请注意我们的警告：将`curl`命令拆分成单独的步骤，并在运行`sudo` `bash`执行之前仔细阅读下载的安装脚本。需要注意的主要事项有：
- en: Ensure the server/domain you’re downloading the script from is trustworthy;
    this should be a reputable developer’s website or a trusted third-party code hosting
    platform.
  id: totrans-187
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 确保你下载脚本的服务器/域名是值得信赖的；它应该是一个有声誉的开发者网站或受信任的第三方代码托管平台。
- en: Ensure you use HTTPS for the `curl` download (i.e., the URL should start with
    `https://`).
  id: totrans-188
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 确保使用HTTPS下载`curl`（即URL应该以`https://`开头）。
- en: Read through the script carefully, to see which commands it runs and where it
    pulls additional code or executables from. If it downloads additional scripts
    or executables, have a look at those too.
  id: totrans-189
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 仔细阅读脚本，查看它运行了哪些命令，以及从哪里拉取了额外的代码或可执行文件。如果它下载了额外的脚本或可执行文件，也要查看这些内容。
- en: I think we’ve established that `curl | sudo | bash` is not a particularly secure
    method of installing software. Following these guidelines can help you be a bit
    safer if you – like most of us – give into temptation one day and follow this
    installation method for a specific piece of software (for example, `homebrew`
    on macOS).
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经确定，`curl | sudo | bash`并不是一种特别安全的软件安装方法。如果你像大多数人一样，某一天禁不住诱惑，使用这种安装方法来安装某个特定的软件（例如macOS上的`homebrew`），遵循这些指南可以帮助你在一定程度上提高安全性。
- en: 'Let’s look at another common pattern now: filtering and searching with `grep`.'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们来看一个常见的操作模式：使用`grep`进行过滤和搜索。
- en: Filtering and searching with grep
  id: totrans-192
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用`grep`进行过滤和搜索
- en: When you run commands that produce a lot of output, it’s generally best practice
    to filter the output down to just what you need. The most common tool for this
    is called `grep`, and you can think of it as a highly configurable text search
    or string-matching function. Here’s an example of what filtering might look like.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 当你运行产生大量输出的命令时，通常最好将输出过滤到仅需要的内容。最常见的工具是`grep`，你可以将其视为一个高度可配置的文本搜索或字符串匹配功能。以下是过滤操作可能的示例。
- en: 'Imagine that you need to find a Linux process’s working directory. The `lsof`
    tool can accomplish this:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你需要找到一个Linux进程的工作目录。`lsof`工具可以实现这个功能：
- en: '[PRE35]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Here’s a quick description of what’s happening:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是发生情况的简要说明：
- en: I’m getting a listing of open file handles for a specific process (PID 3243),
    using `lsof`.
  id: totrans-197
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我正在使用`lsof`获取一个特定进程（PID 3243）的打开文件句柄列表。
- en: I’m then passing the results (`|`) to the `grep` utility and using that to search
    the results for the string `cwd`. There’s only one line of results that contains
    the string `cwd`, so that’s the only line that `grep` prints to the terminal.
  id: totrans-198
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我将结果（`|`）传递给 `grep` 工具，并用它在结果中搜索字符串 `cwd`。只有一行结果包含字符串 `cwd`，因此 `grep` 只会将该行输出到终端。
- en: 'This pattern is useful anytime you have a *lot* of data as input, but you only
    need a subset of that data that can be identified by a specific string. `grep`
    operates on lines of input text, so it’s hugely helpful for picking out data like:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 该模式在输入数据量*很大*时特别有用，但你只需要从中筛选出可以通过特定字符串识别的子集。`grep` 作用于输入文本的每一行，因此在提取像以下数据时非常有用：
- en: Loglines containing the IP address you are following
  id: totrans-200
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 包含你正在跟踪的 IP 地址的日志行
- en: Occurrences of a username in a piped data stream
  id: totrans-201
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在管道数据流中出现的用户名
- en: Lines that match a pattern (`grep` is regular-expression aware and can take
    string patterns in addition to literal search strings)
  id: totrans-202
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 匹配某个模式的行（`grep` 支持正则表达式，并且可以接受字符串模式，除了字面搜索字符串之外）
- en: '`grep` is a large and powerful tool that you’ll have occasion to use almost
    every day. For more information, check out the manpage for grep by typing `man
    grep`.'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: '`grep` 是一个功能强大且广泛使用的工具，你几乎每天都会用到它。有关更多信息，请通过输入 `man grep` 查看 `grep` 的手册页。'
- en: You’ve already seen `grep` used on files in this book (for example, `grep searchstring
    hello.txt`), but it’s also an invaluable filtering component in piped commands.
    Let’s look at a practical example now.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 你在本书中已经看到过 `grep` 在文件中的使用（例如，`grep searchstring hello.txt`），但它也是管道命令中的一个宝贵过滤组件。现在让我们来看一个实际的例子。
- en: grep and tail for log monitoring
  id: totrans-205
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 grep 和 tail 进行日志监控
- en: 'When you’re looking at production logs to try to figure out what’s wrong, you’ll
    often only want to see loglines containing certain keywords or search strings.
    To do that, you’d run something like:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 当你查看生产日志时，试图找出问题所在，通常你只想查看包含特定关键字或搜索字符串的日志行。为了实现这一点，你可以运行类似这样的命令：
- en: '[PRE36]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: This pattern continuously monitors the log file for new entries whose content
    matches “yourSearchRegex”, so you can see only the logs you need for the task
    at hand.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 该模式持续监控日志文件中的新条目，条目的内容符合“yourSearchRegex”正则表达式，从而让你仅看到当前任务需要的日志。
- en: find and xargs for bulk file operations
  id: totrans-209
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 find 和 xargs 执行批量文件操作
- en: '`xargs` is a powerful utility that gives you the power of iteration (in other
    words, a “for” loop) inside of a single command. By default, `xargs` takes each
    (space, tab, newline, and end-of-file delimited) chunk of input it receives and
    executes the specified program using that chunk as input. For example, if you
    need to search for specific file content across `ONLY` the files returned by a
    certain `find` query, you can run this command:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: '`xargs` 是一个强大的工具，它赋予你迭代的能力（换句话说，就是一个“for”循环），并且可以在单个命令中使用。默认情况下，`xargs` 会接受每个（空格、制表符、换行符和文件结尾符分隔的）输入块，并使用该块作为输入执行指定的程序。例如，如果你需要在由某个
    `find` 查询返回的特定文件中搜索文件内容，可以运行以下命令：'
- en: '[PRE37]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: This command finds all files whose names end with `.txt` and then uses `xargs`
    to apply the `grep` command to each file individually. This pattern is handy for
    searching or modifying multiple files at once. Please be forewarned that `xargs`
    is a powerful – and *large* –program, capable of doing many things (including
    string interpolation into the command it executes). We can’t cover it all here,
    so please read the manpage and scour the internet for examples if you’re in a
    situation where this kind of functionality would save the day.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 此命令会查找所有以 `.txt` 结尾的文件，然后使用 `xargs` 对每个文件分别应用 `grep` 命令。此模式非常适合一次搜索或修改多个文件。请注意，`xargs`
    是一个强大且*庞大的*工具，能够做许多事情（包括将字符串插入到它执行的命令中）。我们无法在这里涵盖所有内容，如果你遇到这种情况，请阅读手册页并在互联网上查找示例，看看这种功能如何帮你解决问题。
- en: sort, uniq, and reverse numerical sort for data analysis
  id: totrans-213
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 对数据分析进行排序、去重和反向数字排序
- en: 'This is a useful pattern that you saw applied at the beginning of the chapter,
    where I used it to filter a large command history to get a list of the “top X
    most popular commands run on this system.” The core pattern is this:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个有用的模式，在本章开头你曾看到过应用，我用它来过滤大量命令历史记录，获取“在该系统上执行次数最多的前 X 条命令”列表。核心模式是这样的：
- en: '[PRE38]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Useful for analyzing data, this pattern sorts the data from the input stream,
    deduplicates it while counting unique occurrences, and then performs a reverse
    numerical sort to give you the deduplicated data, with the most common lines first.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 这种模式非常适合分析数据，它会对输入流中的数据进行排序，去重并统计唯一的出现次数，然后执行反向数字排序，最终输出去重后的数据，并将最常见的行排在前面。
- en: 'This is commonly truncated with `| head -n $NUMBER` to get only the top `$NUMBER`
    of results:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 这通常通过 `| head -n $NUMBER` 截断，以仅获取前 `$NUMBER` 条结果：
- en: '[PRE39]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Here, we use history to fetch the entire shell command history. This gives
    us a series of lines like:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们使用 history 获取整个 Shell 命令历史记录。这样会给出一系列像这样的行：
- en: '[PRE40]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: We’re only interested in the top-level command (in this case, `brew`), so we
    use `awk` to fetch the second column.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 我们只关心顶级命令（在这个例子中是 `brew`），所以我们使用 `awk` 来获取第二列。
- en: Then we sort so that duplicates of the same command occur next to each other
    in the stream. Then we remove those duplicates with `uniq`, adding a count of
    occurrences to each remaining one. Now we sort again – this time using `-rn` for
    a reverse numerical sort, which gives us the “top X” effect. Finally, we take
    the first 10 lines with head.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们对数据进行排序，使得相同命令的重复项在流中紧挨着。接着，我们用 `uniq` 去除这些重复项，并为每个剩余的命令添加出现次数的计数。接下来，我们再次排序，这次使用
    `-rn` 进行反向数字排序，这样就实现了“前 X 名”的效果。最后，我们用 head 取出前10行。
- en: 'This prints out the aforementioned top-10 list of your most-used shell commands;
    on my machine, it produces this:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 这会打印出你最常用的10个 Shell 命令列表；在我的机器上，它会输出：
- en: '[PRE41]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: awk and sort for reformatting data and field-based processing
  id: totrans-225
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: awk 和 sort 用于数据重新格式化和基于字段的处理
- en: '`awk` is more than a program; it’s a stream-processing language. If you work
    with data streams on Unix system, then spending a few days learning the basics
    can save you weeks of time over your career. That said, just using `$#` syntax
    to reference whitespace-delimited columns in each line of the data stream is a
    good start.'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: '`awk` 不仅是一个程序，它还是一种流处理语言。如果你在 Unix 系统上处理数据流，那么花几天时间学习基础知识可以为你未来的职业节省数周时间。也就是说，使用
    `$#` 语法引用每行数据流中的空白分隔列是一个很好的起点。'
- en: 'Let’s look at an example given a data stream like the following:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一个示例，假设有如下数据流：
- en: '[PRE42]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'When the awk interpreter sees `$1`, it interprets this to mean “the first column”
    or in this case `Foo` in line 1 and `Some` in line 2\. `$2` is the second column
    (`bar`, `data`), and so on. This is an incredibly common feature to use when working
    with data that’s just a bit too complex for simple `cut` commands:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 当 awk 解释器看到 `$1` 时，它将其解释为“第一列”，在这种情况下，第1行是 `Foo`，第2行是 `Some`。`$2` 是第二列（`bar`，`data`），依此类推。当处理稍微复杂一些的数据时，这是一个非常常用的功能，比简单的
    `cut` 命令更有效：
- en: '[PRE43]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'This would produce output like:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 这将产生类似如下的输出：
- en: '[PRE44]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: In this case, it prints out column 2 before column 1 for each file, and ignores
    all other data in each line. This is often used for reformatting and organizing
    data based on specific fields.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，它会将每个文件的第2列打印在第1列之前，并忽略每行中的其他数据。这通常用于基于特定字段重新格式化和整理数据。
- en: sed and tee for editing and backup
  id: totrans-234
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: sed 和 tee 用于编辑和备份
- en: '**sed** stands for **Stream EDitor** and is used when you want to transform
    a data stream. You do this ten times a day in your text editor when you find/replace
    a symbol. The following command is essentially the command-line version of that
    functionality: it transforms all occurrences of `old` in `file.txt` into the string
    `new` and writes the resulting stream to a new file, `file.txt.changed`. It does
    this without making changes to the original `file.txt` `file`:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: '**sed** 代表 **Stream EDitor**，用于在你想要转换数据流时使用。当你在文本编辑器中进行查找/替换符号时，你每天都会执行这项操作十次。以下命令本质上是该功能的命令行版本：它将
    `file.txt` 中所有的 `old` 替换为字符串 `new`，并将结果流写入新文件 `file.txt.changed`。这样做不会修改原始的 `file.txt`
    `file`：'
- en: '[PRE45]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Although editing file content is an easy demonstration of this concept, `sed`
    is tremendously useful for transforming stream data as it zips from the output
    of one command to the input of the next:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然编辑文件内容是此概念的简单演示，但 `sed` 对于转换数据流非常有用，因为它可以在一个命令的输出和下一个命令的输入之间快速传递数据流：
- en: '[PRE46]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: ps, grep, awk, xargs, and kill for process management
  id: totrans-239
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: ps、grep、awk、xargs 和 kill 用于进程管理
- en: 'Although `pgrep` is a good utility for sending signals to all processes whose
    name matches a pattern, sometimes it’s just not available on your system. You
    can cobble together similar functionality (and get much more specific with what
    you want to target, not just the name) by using this set of piped-together commands:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然 `pgrep` 是一个很好的工具，可以向所有匹配模式的进程发送信号，但有时它在你的系统上不可用。你可以通过以下一组管道命令组合来拼凑出类似的功能（并且能更具体地指定你想要定位的目标，而不仅仅是名称）：
- en: '[PRE47]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: '`ps` starts you off with a list of running processes, which `grep` filters
    to just those containing the pattern you’re searching for. `awk` gets the second
    column (the process ID) for each matching line, and then feeds all matched lines
    to `xargs` (our quasi for loop), which executes `kill` on each PID. This sends
    a `SIGTERM` to each matching process and (hopefully) halts it.'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: '`ps` 为你提供一个运行中进程的列表，`grep` 过滤出只包含你正在搜索的模式的进程。`awk` 获取每一行的第二列（进程 ID），然后将所有匹配的行传递给
    `xargs`（我们的类 for 循环），它在每个 PID 上执行 `kill`。这会向每个匹配的进程发送 `SIGTERM` 信号，并（希望）将其停止。'
- en: tar and gzip for backup and compression
  id: totrans-243
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: tar 和 gzip 用于备份和压缩
- en: 'Although many utilities have flags that let you do both, chaining together
    archiving and compression is another use case that makes sense. This gives you
    the added flexibility of adding additional chained commands. For example, if you
    want to add encryption, that’s just a single additional piped command away:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管许多工具有让你同时执行归档和压缩的标志，但将归档和压缩连接起来也是一种有意义的使用案例。这为你提供了额外的灵活性，可以添加更多的链式命令。例如，如果你想添加加密，那只需再加一个管道命令：
- en: '[PRE48]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'This creates a compressed archive of a directory, commonly used for file backup
    and storage. You can see larger commands using this kind of pattern:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 这将创建一个目录的压缩归档，通常用于文件备份和存储。你可以看到使用这种模式的更大的命令：
- en: '[PRE49]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: This is an especially fun example that logs into a database server using SSH,
    dumps out a database, compresses that data stream, shuttles it back to the local
    machine over SSH, decompresses it again, and finally dumps it into the local MySQL
    server.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个特别有趣的示例，它通过 SSH 登录到数据库服务器，导出数据库，压缩该数据流，通过 SSH 将其传回本地机器，再次解压缩，最后将其导入本地 MySQL
    服务器。
- en: Your aim shouldn’t necessarily be to write commands as complex as this one (or
    some of the others you’ve seen here), but if you know how to put something like
    this together in a pinch, it can get you out of some extremely tight spots as
    a developer. We hope this section has demonstrated that understanding the input
    and output redirection primitives that Unix systems expose to you – via `<`, `>`,
    `>>`, `|`, and file descriptors in general – is basically a superpower. Use it
    wisely.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 你的目标不一定是写出像这个（或你在这里看到的其他一些）那么复杂的命令，但如果你知道如何在关键时刻拼凑出这样的命令，它可以帮助你在开发过程中脱离一些极其紧迫的困境。我们希望这一部分能展示出，理解
    Unix 系统为你提供的输入输出重定向原语——通过 `<`、`>`、`>>`、`|` 以及一般的文件描述符——实际上是一种超级能力。明智地使用它。
- en: 'Advanced: inspecting file descriptors'
  id: totrans-250
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 高级：检查文件描述符
- en: On Linux, you can easily *see* where a process’s file descriptors are pointing.
    We’re going to use the slightly magical `/proc` virtual filesystem to do just
    that.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Linux 上，你可以轻松地 *查看* 一个进程的文件描述符指向哪里。我们将使用稍微神奇的 `/proc` 虚拟文件系统来完成这一操作。
- en: 'Procfs (the `proc` virtual filesystem) is a Linux-only abstraction that represents
    kernel and process state as files. The data inside of these files comes straight
    from the operating system kernel, and only exists while you’re reading them. Just
    listing the `/proc` directory will show you many files; here’s a selection of
    some of the more important ones, taken from the Arch Linux wiki:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: Procfs（`proc` 虚拟文件系统）是一个仅限 Linux 的抽象，它将内核和进程状态表示为文件。这些文件中的数据来自操作系统内核，并且只在你读取时存在。仅列出
    `/proc` 目录，你就能看到很多文件；以下是一些更为重要的文件，摘自 Arch Linux 的维基：
- en: '[PRE50]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'What’s most interesting to us with regard to file descriptors is something
    not shown in the listing above: `/proc` contains a directory for every single
    process running on the machine, named after each **process ID** (**PID**).'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 关于文件描述符，我们最感兴趣的是上面列出的清单中没有显示的内容：`/proc` 包含一个针对每个正在运行的进程的目录，目录名是每个 **进程 ID**（**PID**）的名称。
- en: In a process’s `/proc` directory, that process’s file descriptors are represented
    as symbolic links in a directory called `fd`. When you do a long listing on this
    `/proc/$PID/fd` directory, you’ll see that `l` is the first character in the long
    listing, which denotes a special `link` file, as you’ll recall from *Chapter 5*,
    *Introducing Files*.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 在一个进程的`/proc`目录中，该进程的文件描述符会以符号链接的形式表示，存放在名为`fd`的目录中。当你对这个`/proc/$PID/fd`目录进行长列表显示时，你会发现`l`是长列表中的第一个字符，它表示一个特殊的`link`文件，正如你在*第5章*《文件介绍》中回顾到的那样。
- en: Practically speaking, `/proc/1/` is the `init` process’s proc directory, and
    you can view init’s file descriptors by doing a long listing on `/proc/1/fd`.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 从实际角度看，`/proc/1/`是`init`进程的proc目录，你可以通过对`/proc/1/fd`进行长列表显示，查看init的文件描述符。
- en: 'Let’s look at the file descriptors for an interactive Bash shell process running
    on my machine, which `ps aux | grep bash` tells me is PID 9:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看我机器上运行的交互式Bash shell进程的文件描述符，`ps aux | grep bash`告诉我它的PID是9：
- en: '[PRE51]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'You’ll notice that it’s an interactive shell session: its standard input is
    coming from a virtual terminal (`/dev/pts/1`), and its standard error and output
    are going back to that same terminal. That checks out.'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 你会注意到这是一个交互式shell会话：它的标准输入来自一个虚拟终端（`/dev/pts/1`），其标准错误和输出也回到这个终端。这是正确的。
- en: Let’s look at a text editor like vim, which behaves a lot like a terminal –
    input and output happen via a terminal. However, there’s an added complication,
    which is that text editors usually keep one or more files open for writing. What
    does that look like?
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看像vim这样的文本编辑器，它的行为与终端非常相似——输入和输出都是通过终端进行的。然而，这里有一个附加的复杂性，那就是文本编辑器通常会保持一个或多个文件处于打开写入状态。这是什么样子的呢？
- en: 'In this example, I’m running the vim text editor, and editing a file in the
    `/tmp` directory. Let’s find the process ID for vim, so we know which `/proc`
    directory to look inside:'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我正在运行vim文本编辑器，并编辑`/tmp`目录中的一个文件。让我们找到vim的进程ID，这样我们就知道应该查看哪个`/proc`目录：
- en: '[PRE52]'
  id: totrans-262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'There it is; process 453\. Don’t be misled by the `grep` command which also
    includes `vim` in its command arguments. Now that we have the PID, let’s look
    at vim’s file descriptors:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 就是它；进程453。不要被`grep`命令误导，后者也在命令参数中包括了`vim`。现在我们已经得到了PID，接下来看看vim的文件描述符：
- en: '[PRE53]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: We can see that stdin (`0`), stdout (`1`), and stderr (`2`) are all pointing
    to a terminal device, just like a shell. And we also see that the editor has a
    file open, with file descriptor `3` linked to the file that vim is editing. When
    a process opens additional files, new file descriptors are created, and you can
    view them here.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到，stdin（`0`）、stdout（`1`）和stderr（`2`）都指向一个终端设备，就像shell一样。我们还看到编辑器打开了一个文件，文件描述符`3`链接到vim正在编辑的文件。当一个进程打开额外的文件时，会创建新的文件描述符，你可以在这里查看它们。
- en: 'Beyond being interesting for its own sake, this can come in handy when programs
    are behaving erratically due to bugs, or when you’re trying to trace what a potentially
    malicious program is doing. `procfs` is quite interesting and useful if you invest
    a bit of time in learning it: just type `man proc` to get started, or read the
    Arch Linux Wiki page for a gentler introduction at [https://wiki.archlinux.org/title/Procfs](https://wiki.archlinux.org/title/Procfs).'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 除了本身很有趣外，这对于调试程序行为异常时（比如程序出现bug时），或者你在追踪一个可能有恶意行为的程序时非常有用。如果你花点时间学习它，`procfs`会变得非常有趣和有用：只需要输入`man
    proc`开始，或者阅读Arch Linux Wiki页面，了解更温和的介绍：[https://wiki.archlinux.org/title/Procfs](https://wiki.archlinux.org/title/Procfs)。
- en: Conclusion
  id: totrans-267
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 结论
- en: 'In this chapter, we put together all of the previous skills and theory we’ve
    covered to unlock one of the most powerful features of Unix and Linux systems:
    streaming data through multiple commands using pipes and input/output redirection.'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将前面所学的所有技能和理论整合起来，解锁Unix和Linux系统最强大的功能之一：通过管道和输入/输出重定向将数据流经多个命令。
- en: We started by showing you how the operating system exposes primitives like file
    descriptors, and then started looking at practical uses of input and output redirection.
    Then, we covered pipes, which are arguably one of the most useful features of
    Linux and other Unix operating systems. After covering the necessary theory and
    showing you some useful examples, we dove deep into the most common helper tools
    that people use to slice and dice the data streams that they build up using pipes.
    Finally, we showed you some of the most common and useful patterns and program-combinations
    that people use in the real world.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从展示操作系统如何暴露像文件描述符这样的原始操作开始，然后开始研究输入输出重定向的实际应用。接着，我们讲解了管道，这是 Linux 和其他 Unix
    操作系统中最有用的功能之一。在介绍必要的理论并展示了一些实用示例后，我们深入探讨了人们用来切割和处理通过管道传输的数据流的最常见辅助工具。最后，我们向你展示了人们在实际工作中使用的一些最常见和最有用的模式和程序组合。
- en: What’s in this chapter is the foundation for much of the advanced command-line
    usage you’ll encounter and use in your day-to-day work. You’ve now been exposed
    to some of the basic theory, tools, and patterns that you’ll see in the wild,
    which will make it easy to dive in and start building custom commands for common
    development, troubleshooting, and automation use cases.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的内容是你将在日常工作中遇到并使用的许多高级命令行操作的基础。你已经接触到了一些基本理论、工具和模式，这将使你能够轻松地开始构建用于常见开发、故障排除和自动化用例的自定义命令。
- en: To grow your skills, use what you’ve seen in this chapter in your day-to-day
    work! Use it as a reference for patterns to try, and keep learning new tools and
    commands that you can add to your own custom recipes and use to filter or otherwise
    manipulate data on the command line. You’ll feel like a wizard in no time.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 要提升你的技能，将本章中所学应用到日常工作中！将其作为参考来尝试不同的模式，并持续学习新的工具和命令，将它们加入到自己的定制工作流中，用来过滤或处理命令行上的数据。你很快就会像个高手一样。
- en: Learn more on Discord
  id: totrans-272
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在 Discord 上了解更多
- en: 'To join the Discord community for this book – where you can share feedback,
    ask questions to the author, and learn about new releases – follow the QR code
    below:'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 要加入本书的 Discord 社区——你可以在这里分享反馈、向作者提问，并了解新版本的发布——请扫描下面的二维码：
- en: '[https://packt.link/SecNet](https://packt.link/SecNet)'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://packt.link/SecNet](https://packt.link/SecNet)'
- en: '![](img/QR_Code1768422420210094187.png)'
  id: totrans-275
  prefs: []
  type: TYPE_IMG
  zh: '![](img/QR_Code1768422420210094187.png)'
