<html><head></head><body>
<div class="Basic-Text-Frame" id="_idContainer081">
<h1 class="chapterNumber"><span class="koboSpan" id="kobo.1.1">15</span></h1>
<h1 class="chapterTitle" id="_idParaDest-343"><span class="koboSpan" id="kobo.2.1">Containerizing Applications with Docker</span></h1>
<p class="normal"><span class="koboSpan" id="kobo.3.1">Over the last decade, Docker containerization has become a kind of default packaging format for web applications and modern microservices. </span><span class="koboSpan" id="kobo.3.2">In a container, your program sits in a very lightweight, isolated shell of Linux filesystem, process, user, and network abstractions, safely separate from the host environment. </span><span class="koboSpan" id="kobo.3.3">Container images also happen to be incredibly portable – they’re easy to shuffle around from a developer’s laptop to a testing or staging environment to a production server. </span><span class="koboSpan" id="kobo.3.4">This solves many of the problems that have plagued software and infrastructure over the last several decades.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.4.1">In some sense, containers are quite similar to the Linux packages you’ve learned how to install from repositories. </span><span class="koboSpan" id="kobo.4.2">A container image is, roughly, a compressed archive (such as, a </span><code class="inlineCode"><span class="koboSpan" id="kobo.5.1">.tar.gz</span></code><span class="koboSpan" id="kobo.6.1"> file) of your application, along with all the configuration files and dependencies the application needs. </span><span class="koboSpan" id="kobo.6.2">That little package – an image – is executable by Docker. </span><span class="koboSpan" id="kobo.6.3">The revolutionary thing about such a container is that it neatly holds everything together in a single artifact and can run on any Linux system that has a container runtime (like Docker) installed.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.7.1">This chapter could easily be a book on its own – Docker and Linux containers in general are fairly large subjects. </span><span class="koboSpan" id="kobo.7.2">However, like with everything else in this book, we’re focusing on only the basic theory and practical skills that are necessary for you to be comfortable interacting with Docker-based infrastructure in your applications.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.8.1">In this chapter, you’ll learn about the following:</span></p>
<ul>
<li class="bulletList"><span class="koboSpan" id="kobo.9.1">The application development and operational problems that containers solve</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.10.1">What containers are, and how they’re similar to Linux packages</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.11.1">The difference between Docker images and Docker containers</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.12.1">All the practical basics for using Docker in your development workflow</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.13.1">How to build your own container images with Dockerfiles (you’ll containerize a real Python web application)</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.14.1">Some more advanced topics like how virtual machines and containers are different, and how Linux creates container abstraction via namespacing</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.15.1">Some hard-earned container tips, tricks, and best practices</span></li>
</ul>
<p class="normal"><span class="koboSpan" id="kobo.16.1">Let’s jump in.</span></p>
<h1 class="heading-1" id="_idParaDest-344"><span class="koboSpan" id="kobo.17.1">How containers work as packages</span></h1>
<p class="normal"><span class="koboSpan" id="kobo.18.1">Docker</span><a id="_idIndexMarker542"/><span class="koboSpan" id="kobo.19.1"> became standard tooling to package up software when the goal is to include a system that is known to be a working setup. </span><span class="koboSpan" id="kobo.19.2">A Docker container typically contains both the software you want to run as well as a whole, though frequently trimmed down, Linux system as its execution environment. </span><span class="koboSpan" id="kobo.19.3">This execution environment provides libraries and tools, as well as some other things, like basic system configuration, so that it can function as a standalone entity, independent of the system running the container. </span><span class="koboSpan" id="kobo.19.4">The primary goal is to make sure that the application can successfully be run on the developer’s machine, production and test environments, and elsewhere, without having to take care of details, such as the operating system versions, installed libraries.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.20.1">It is important to keep in mind that the operating system and libraries don’t disappear. </span><span class="koboSpan" id="kobo.20.2">Bugs in libraries may still exist and any packaged dependencies should be updated for security and other reasons. </span><span class="koboSpan" id="kobo.20.3">However, the consumers of the packaged software, be it end users or your system operators, as well as any orchestration software, are now provided with a common package and don’t need to take care about system dependencies. </span><span class="koboSpan" id="kobo.20.4">While the details of how the software is run and configured still depend on the software, the way it is executed (in a container) is somewhat standardized.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.21.1">In summary, that means that any specific setup of the environment, such as installing dependencies, is now described as part of the Dockerfile, and once a working container image is created, short of specific configuration, the container is expected to run on any system capable of running Docker, or more </span><a id="_idIndexMarker543"/><span class="koboSpan" id="kobo.22.1">broadly, </span><strong class="keyWord"><span class="koboSpan" id="kobo.23.1">OCI</span></strong><span class="koboSpan" id="kobo.24.1"> images.</span></p>
<div class="note">
<p class="normal"><strong class="keyWord"><span class="koboSpan" id="kobo.25.1">OCI</span></strong><span class="koboSpan" id="kobo.26.1"> (short for </span><strong class="keyWord"><span class="koboSpan" id="kobo.27.1">Open Container Initiative</span></strong><span class="koboSpan" id="kobo.28.1">) provides</span><a id="_idIndexMarker544"/><span class="koboSpan" id="kobo.29.1"> standards to specify things like image format and the execution of Linux containers. </span><span class="koboSpan" id="kobo.29.2">Sometimes it used synonymously with Docker in the sense that a developer might use Docker to create the image, but the execution on an orchestrator might not use Docker at all.</span></p>
</div>
<p class="normal"><span class="koboSpan" id="kobo.30.1">There’s no</span><a id="_idIndexMarker545"/><span class="koboSpan" id="kobo.31.1"> better way to get started than to install Docker on your machine and start trying some commands, so let’s do that.</span></p>
<h1 class="heading-1" id="_idParaDest-345"><span class="koboSpan" id="kobo.32.1">Prerequisite: Docker install</span></h1>
<p class="normal"><span class="koboSpan" id="kobo.33.1">First, download and</span><a id="_idIndexMarker546"/><span class="koboSpan" id="kobo.34.1"> install Docker Desktop. </span><span class="koboSpan" id="kobo.34.2">You can find instructions for this at </span><a href="https://docs.docker.com/get-docker/"><span class="url"><span class="koboSpan" id="kobo.35.1">https://docs.docker.com/get-docker/</span></span></a><span class="koboSpan" id="kobo.36.1">.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.37.1">There is also an excellent official tutorial for getting started at </span><a href="https://docs.docker.com/get-started/"><span class="url"><span class="koboSpan" id="kobo.38.1">https://docs.docker.com/get-started/</span></span></a><span class="koboSpan" id="kobo.39.1">, but we recommend that you wait to read that until after you’ve gone through this chapter. </span><span class="koboSpan" id="kobo.39.2">We’re going to cover some of the basics, but with less focus on specific command-line flags, and more focus on how you’ll use these commands and workflows as an application developer.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.40.1">Now that you’ve got Docker installed, let’s jump into actually starting our first container!</span></p>
<h1 class="heading-1" id="_idParaDest-346"><span class="koboSpan" id="kobo.41.1">Docker crash course</span></h1>
<p class="normal"><span class="koboSpan" id="kobo.42.1">A </span><strong class="keyWord"><span class="koboSpan" id="kobo.43.1">Docker image</span></strong><span class="koboSpan" id="kobo.44.1"> is the “package” from our metaphor – it’s a static artifact that is saved, stored, and moved </span><a id="_idIndexMarker547"/><span class="koboSpan" id="kobo.45.1">around. </span><span class="koboSpan" id="kobo.45.2">It becomes a </span><strong class="keyWord"><span class="koboSpan" id="kobo.46.1">container</span></strong><span class="koboSpan" id="kobo.47.1"> when it’s executed on a machine. </span><span class="koboSpan" id="kobo.47.2">This is important because you’ll sometimes hear these terms used incorrectly: Docker images are the immutable base from which a container – a running, namespaced process – is launched. </span><span class="koboSpan" id="kobo.47.3">Images are the pre-built template from which live containers are</span><a id="_idIndexMarker548"/><span class="koboSpan" id="kobo.48.1"> generated at runtime.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.49.1">Images are designed to be immutable: if you download an nginx web server image and run it, any changes you make to the resulting container don’t affect the underlying image at all. </span><span class="koboSpan" id="kobo.49.2">This is the part that trips up most developers who are used to long-running virtual machines that are provisioned once and then started and stopped many times, preserving their internal state the whole time.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.50.1">Docker containers</span><a id="_idIndexMarker549"/><span class="koboSpan" id="kobo.51.1"> are different. </span><span class="koboSpan" id="kobo.51.2">Ideally, they are designed to be ephemeral and stateless, while the images they’re spawned from act as a long-lived blueprint that can be used to spawn an infinite number of containers across many different execution environments.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.52.1">What follows is an example of a basic Docker workflow that’s designed to get you acquainted with the most important Docker commands. </span><span class="koboSpan" id="kobo.52.2">Don’t worry about memorizing the commands; we’ll cover them in depth later in this chapter. </span><span class="koboSpan" id="kobo.52.3">For now, we’ll just explain what’s happening at each step, so you can get used to what you’ll see on the screen at your next microservices gig.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.53.1">First, let’s start the nginx container (</span><code class="inlineCode"><span class="koboSpan" id="kobo.54.1">docker run</span></code><span class="koboSpan" id="kobo.55.1">) and interactively (</span><code class="inlineCode"><span class="koboSpan" id="kobo.56.1">-it</span></code><span class="koboSpan" id="kobo.57.1">) run the Bash shell (</span><code class="inlineCode"><span class="koboSpan" id="kobo.58.1">/bin/bash</span></code><span class="koboSpan" id="kobo.59.1">) inside of it:</span></p>
<pre class="programlisting con"><code class="hljs-con"><span class="koboSpan" id="kobo.60.1">→  ~ docker run -it nginx /bin/bash
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.61.1">This gets us a shell </span><a id="_idIndexMarker550"/><span class="koboSpan" id="kobo.62.1">prompt for the unique container that was started from the </span><code class="inlineCode"><span class="koboSpan" id="kobo.63.1">nginx</span></code><span class="koboSpan" id="kobo.64.1"> image. </span><span class="koboSpan" id="kobo.64.2">The container’s Bash shell is now connected to our terminal:</span></p>
<pre class="programlisting con"><code class="hljs-con"><span class="koboSpan" id="kobo.65.1">root@e96107c9a58e:/#
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.66.1">Let’s write a file called </span><code class="inlineCode"><span class="koboSpan" id="kobo.67.1">test.txt</span></code><span class="koboSpan" id="kobo.68.1"> and verify that it exists:</span></p>
<pre class="programlisting con"><code class="hljs-con"><span class="koboSpan" id="kobo.69.1">root@e96107c9a58e:/# echo "I am immutable" &gt;&gt; test.txt
root@e96107c9a58e:/# cat test.txt
I am immutable
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.70.1">We can exit the shell with the usual command, </span><code class="inlineCode"><span class="koboSpan" id="kobo.71.1">ctrl-d</span></code><span class="koboSpan" id="kobo.72.1">:</span></p>
<pre class="programlisting con"><code class="hljs-con"><span class="koboSpan" id="kobo.73.1">root@e96107c9a58e:/#
exit
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.74.1">The container exits and we’re now back in our regular shell. </span><span class="koboSpan" id="kobo.74.2">Here’s where it gets confusing for most first-time Docker users: let’s re-run the first command to start a container from the nginx Docker image again, and check on our file:</span></p>
<pre class="programlisting con"><code class="hljs-con"><span class="koboSpan" id="kobo.75.1">→  ~ docker run -it nginx /bin/bash
root@c3b4d95ab9e6:/# cat test.txt
cat: test.txt: No such file or directory
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.76.1">FILE A BUG REPORT! </span><span class="koboSpan" id="kobo.76.2">DOCKER IS BROKEN!</span></p>
<p class="normal"><span class="koboSpan" id="kobo.77.1">Actually, it’s not. </span><span class="koboSpan" id="kobo.77.2">This is not the same container as the one you wrote the </span><code class="inlineCode"><span class="koboSpan" id="kobo.78.1">test.txt</span></code><span class="koboSpan" id="kobo.79.1"> file in. </span><span class="koboSpan" id="kobo.79.2">If you were looking closely, you may have noticed that the hostname in the shell prompt was different on the second container. </span><span class="koboSpan" id="kobo.79.3">That’s because each </span><code class="inlineCode"><span class="koboSpan" id="kobo.80.1">docker run</span></code><span class="koboSpan" id="kobo.81.1"> command launches a new container from the specified image. </span><span class="koboSpan" id="kobo.81.2">Containers are designed to run, exit, and disappear forever.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.82.1">The original container is actually still around:</span></p>
<pre class="programlisting con"><code class="hljs-con"><span class="koboSpan" id="kobo.83.1">→  ~ docker ps -a
CONTAINER ID   IMAGE             COMMAND                  CREATED          STATUS                      PORTS                    NAMES
c3b4d95ab9e6   nginx             "/docker-entrypoint.…"   14 minutes ago   Exited (1) 6 minutes ago                             agitated_hofstadter
e96107c9a58e   nginx             "/docker-entrypoint.…"   14 minutes ago   Exited (0) 14 minutes ago                            nervous_gould
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.84.1">To get rid of them, you can use </span><code class="inlineCode"><span class="koboSpan" id="kobo.85.1">docker rm</span></code><span class="koboSpan" id="kobo.86.1"> with the ID of the container you want to delete:</span></p>
<pre class="programlisting con"><code class="hljs-con"><span class="koboSpan" id="kobo.87.1">→  ~ docker rm c3b4d95ab9e6
c3b4d95ab9e6
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.88.1">It is possible to start a stopped container with </span><code class="inlineCode"><span class="koboSpan" id="kobo.89.1">docker start</span></code><span class="koboSpan" id="kobo.90.1">:</span></p>
<pre class="programlisting con"><code class="hljs-con"><span class="koboSpan" id="kobo.91.1">→  ~ docker start e96107c9a58e
e96107c9a58e
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.92.1">At which point, you </span><a id="_idIndexMarker551"/><span class="koboSpan" id="kobo.93.1">would see the container running in your Docker process list:</span></p>
<pre class="programlisting con"><code class="hljs-con"><span class="koboSpan" id="kobo.94.1">→  ~ docker ps
CONTAINER ID   IMAGE     COMMAND                  CREATED          STATUS        PORTS     NAMES
e96107c9a58e   nginx     "/docker-entrypoint.…"   18 minutes ago   Up 1 second   80/tcp    nervous_gould
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.95.1">Then you could use </span><code class="inlineCode"><span class="koboSpan" id="kobo.96.1">docker exec</span></code><span class="koboSpan" id="kobo.97.1"> to execute a command inside that container, again starting and attaching to the Bash shell program with </span><code class="inlineCode"><span class="koboSpan" id="kobo.98.1">–it</span></code><span class="koboSpan" id="kobo.99.1">. </span><span class="koboSpan" id="kobo.99.2">From there, you can view the filesystem state (</span><code class="inlineCode"><span class="koboSpan" id="kobo.100.1">test.txt</span></code><span class="koboSpan" id="kobo.101.1">) that we modified:</span></p>
<pre class="programlisting con"><code class="hljs-con"><span class="koboSpan" id="kobo.102.1">→  ~ docker exec -it e96107c9a58e /bin/bash
root@e96107c9a58e:/# cat test.txt
I am immutable
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.103.1">However, keeping containers around for a long time – modifying their state and stopping and restarting them instead of always starting new containers from an image – is discouraged and leads back to many of the same bugs that Docker helped solve.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.104.1">Let’s avoid all of those mistakes and delete this running container forever by force-removing it:</span></p>
<pre class="programlisting con"><code class="hljs-con"><span class="koboSpan" id="kobo.105.1">→ ~ docker rm -f e96107c9a58e
e96107c9a58e
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.106.1">You could have also run </span><code class="inlineCode"><span class="koboSpan" id="kobo.107.1">docker stop</span></code><span class="koboSpan" id="kobo.108.1"> followed by </span><code class="inlineCode"><span class="koboSpan" id="kobo.109.1">docker rm</span></code><span class="koboSpan" id="kobo.110.1">, but force-removing with </span><code class="inlineCode"><span class="koboSpan" id="kobo.111.1">docker rm -f</span></code><span class="koboSpan" id="kobo.112.1"> will stop and remove a running container in one fell swoop.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.113.1">You can see how Docker encourages immutable containers to keep the state from drifting away from the image, which is the “source of truth” for your application’s initial environment. </span><span class="koboSpan" id="kobo.113.2">If you want to make changes to an image, you can’t do so directly – images are immutable.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.114.1">Changes should </span><a id="_idIndexMarker552"/><span class="koboSpan" id="kobo.115.1">be </span><em class="italic"><span class="koboSpan" id="kobo.116.1">explicit </span></em><span class="koboSpan" id="kobo.117.1">and </span><em class="italic"><span class="koboSpan" id="kobo.118.1">intentional</span></em><span class="koboSpan" id="kobo.119.1">, which is important for creating and running reliable software. </span><span class="koboSpan" id="kobo.119.2">How do we do this? </span><span class="koboSpan" id="kobo.119.3">We start with the original image, make our changes in a controlled and reproducible way (not “SSH to the server and try running these commands”), and then save them by creating a new image. </span><span class="koboSpan" id="kobo.119.4">Enter the mighty Dockerfile.</span></p>
<h1 class="heading-1" id="_idParaDest-347"><span class="koboSpan" id="kobo.120.1">Creating images with a Dockerfile</span></h1>
<p class="normal"><span class="koboSpan" id="kobo.121.1">If you’re ever</span><a id="_idIndexMarker553"/><span class="koboSpan" id="kobo.122.1"> tasked with building a new Docker image, or modifying</span><a id="_idIndexMarker554"/><span class="koboSpan" id="kobo.123.1"> an existing one – perhaps for a web application that you’re developing – you’ll be making heavy use of Dockerfiles (see the official Dockerfile documentation at </span><a href="https://docs.docker.com/engine/reference/builder/"><span class="url"><span class="koboSpan" id="kobo.124.1">https://docs.docker.com/engine/reference/builder/</span></span></a><span class="koboSpan" id="kobo.125.1">).</span></p>
<p class="normal"><span class="koboSpan" id="kobo.126.1">A large percentage of new software will already have an official (or at least open-source, third-party) Dockerfile available. </span><span class="koboSpan" id="kobo.126.2">Even if you need to do some customizing before you use these, a good place to look for examples is the documentation for the software or framework you use. </span><span class="koboSpan" id="kobo.126.3">These examples don’t tend to break as easily as your own custom Dockerfile when major upgrades are released for the packaged software.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.127.1">Also, some frameworks or development environments, for example, Spring Boot (Java), can generate Docker images as part of the build process.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.128.1">So, even though there’s a chance you’ll never have to touch a Dockerfile yourself, it’s unlikely, and you should have a basic idea of how they work.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.129.1">Let’s look at a very simple</span><a id="_idIndexMarker555"/><span class="koboSpan" id="kobo.130.1"> Dockerfile, from the open-source HTTP echo </span><a id="_idIndexMarker556"/><span class="koboSpan" id="kobo.131.1">server project (</span><a href="https://github.com/hashicorp/http-echo"><span class="url"><span class="koboSpan" id="kobo.132.1">https://github.com/hashicorp/http-echo</span></span></a><span class="koboSpan" id="kobo.133.1">). </span><span class="koboSpan" id="kobo.133.2">This creates a Docker image that packages a Go binary that acts as a simple web server:</span></p>
<pre class="programlisting con"><code class="hljs-con"><span class="koboSpan" id="kobo.134.1">FROM alpine
ADD "https://curl.haxx.se/ca/cacert.pem" "/etc/ssl/certs/ca-certificates.crt"
ADD "./pkg/linux_amd64/http-echo" "/"
RUN apk add curl
ENTRYPOINT ["/http-echo"]
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.135.1">Basically, this creates a new container image by:</span></p>
<ol class="numberedList" style="list-style-type: decimal;">
<li class="numberedList" value="1"><span class="koboSpan" id="kobo.136.1">Using the </span><code class="inlineCode"><span class="koboSpan" id="kobo.137.1">alpine</span></code><span class="koboSpan" id="kobo.138.1"> Linux image as a base to build on.</span></li>
<li class="numberedList"><span class="koboSpan" id="kobo.139.1">Downloading some certificates and adding them to an image layer (essentially adding something to the resulting container’s filesystem).</span></li>
<li class="numberedList"><span class="koboSpan" id="kobo.140.1">Copying the </span><code class="inlineCode"><span class="koboSpan" id="kobo.141.1">http-echo</span></code><span class="koboSpan" id="kobo.142.1"> binary from the build directory into the container image.</span></li>
<li class="numberedList"><span class="koboSpan" id="kobo.143.1">Running an alpine package installation command to install the </span><code class="inlineCode"><span class="koboSpan" id="kobo.144.1">curl</span></code><span class="koboSpan" id="kobo.145.1"> program.</span></li>
<li class="numberedList"><span class="koboSpan" id="kobo.146.1">Defining the executable or command that is run when a container started from this image is launched.</span></li>
</ol>
<p class="normal"><span class="koboSpan" id="kobo.147.1">Each of these steps is invoked by a (capitalized) </span><em class="italic"><span class="koboSpan" id="kobo.148.1">Instruction</span></em><span class="koboSpan" id="kobo.149.1"> that the Dockerfile parser knows how to execute. </span><span class="koboSpan" id="kobo.149.2">This specific Dockerfile only uses a subset of the instructions available to you in a Dockerfile (</span><code class="inlineCode"><span class="koboSpan" id="kobo.150.1">FROM</span></code><span class="koboSpan" id="kobo.151.1">, </span><code class="inlineCode"><span class="koboSpan" id="kobo.152.1">ADD</span></code><span class="koboSpan" id="kobo.153.1">, </span><code class="inlineCode"><span class="koboSpan" id="kobo.154.1">RUN</span></code><span class="koboSpan" id="kobo.155.1">, and </span><code class="inlineCode"><span class="koboSpan" id="kobo.156.1">ENTRYPOINT</span></code><span class="koboSpan" id="kobo.157.1">).</span></p>
<p class="normal"><span class="koboSpan" id="kobo.158.1">Here’s the full complement of instructions available to you when you’re creating new Docker images via a Dockerfile:</span></p>
<ul>
<li class="bulletList"><code class="inlineCode"><span class="koboSpan" id="kobo.159.1">ARG</span></code><span class="koboSpan" id="kobo.160.1">: Declares a build-time argument; basically, a variable to be used later in the build.</span></li>
<li class="bulletList"><code class="inlineCode"><span class="koboSpan" id="kobo.161.1">ENV</span></code><span class="koboSpan" id="kobo.162.1">: Environment vars to set during the build, which will persist in your running container environment (</span><em class="italic"><span class="koboSpan" id="kobo.163.1">not</span></em><span class="koboSpan" id="kobo.164.1"> just during the build!). </span><span class="koboSpan" id="kobo.164.2">Takes a </span><code class="inlineCode"><span class="koboSpan" id="kobo.165.1">key=value</span></code><span class="koboSpan" id="kobo.166.1"> format.</span></li>
<li class="bulletList"><code class="inlineCode"><span class="koboSpan" id="kobo.167.1">FROM</span></code><span class="koboSpan" id="kobo.168.1">: Base image.</span></li>
<li class="bulletList"><code class="inlineCode"><span class="koboSpan" id="kobo.169.1">CMD</span></code><span class="koboSpan" id="kobo.170.1">: This provides a default command (or default </span><code class="inlineCode"><span class="koboSpan" id="kobo.171.1">ENTRYPOINT</span></code><span class="koboSpan" id="kobo.172.1"> args) for the container to run when it’s started. </span><span class="koboSpan" id="kobo.172.2">It can be overridden, but you should have one in your Dockerfile. </span><span class="koboSpan" id="kobo.172.3">Only one per Dockerfile is allowed – if there’s more than one </span><code class="inlineCode"><span class="koboSpan" id="kobo.173.1">CMD</span></code><span class="koboSpan" id="kobo.174.1">, only the last one will count.</span></li>
<li class="bulletList"><code class="inlineCode"><span class="koboSpan" id="kobo.175.1">ADD</span></code><span class="koboSpan" id="kobo.176.1">: A flexible instruction that copies files and directories, adding them to the image’s filesystem. </span><span class="koboSpan" id="kobo.176.2">This can also be used to copy files from outside the image or from remote URLs (via HTTP), and to do complex things like expansion, decompression, unarchiving, and more. </span><span class="koboSpan" id="kobo.176.3">You saw it as a stand-in for the </span><code class="inlineCode"><span class="koboSpan" id="kobo.177.1">curl</span></code><span class="koboSpan" id="kobo.178.1"> command in the sample Dockerfile above, to download a CA certificate file.</span></li>
<li class="bulletList"><code class="inlineCode"><span class="koboSpan" id="kobo.179.1">COPY</span></code><span class="koboSpan" id="kobo.180.1">: Just copies files and directories – less complicated, magical, and powerful than </span><code class="inlineCode"><span class="koboSpan" id="kobo.181.1">ADD</span></code><span class="koboSpan" id="kobo.182.1">.</span></li>
<li class="bulletList"><code class="inlineCode"><span class="koboSpan" id="kobo.183.1">LABEL</span></code><span class="koboSpan" id="kobo.184.1">: Adds image metadata, in a </span><code class="inlineCode"><span class="koboSpan" id="kobo.185.1">key=value</span></code><span class="koboSpan" id="kobo.186.1"> format.</span></li>
<li class="bulletList"><code class="inlineCode"><span class="koboSpan" id="kobo.187.1">EXPOSE</span></code><span class="koboSpan" id="kobo.188.1">: Informs consumers of this image about which network protocols and ports this container will be listening on.</span></li>
<li class="bulletList"><code class="inlineCode"><span class="koboSpan" id="kobo.189.1">ENTRYPOINT</span></code><span class="koboSpan" id="kobo.190.1">: Tells the container what command to run when it starts. </span><span class="koboSpan" id="kobo.190.2">Use the </span><em class="italic"><span class="koboSpan" id="kobo.191.1">exec form</span></em><span class="koboSpan" id="kobo.192.1"> (</span><code class="inlineCode"><span class="koboSpan" id="kobo.193.1">ENTRYPOINT ["executable", "param1", "param2"]</span></code><span class="koboSpan" id="kobo.194.1">) to make sure your container can receive and respond to signals from outside the container process.</span></li>
<li class="bulletList"><code class="inlineCode"><span class="koboSpan" id="kobo.195.1">RUN command arg1 arg2</span></code><span class="koboSpan" id="kobo.196.1">: Run </span><code class="inlineCode"><span class="koboSpan" id="kobo.197.1">command</span></code><span class="koboSpan" id="kobo.198.1"> with arguments </span><code class="inlineCode"><span class="koboSpan" id="kobo.199.1">arg1</span></code><span class="koboSpan" id="kobo.200.1"> and </span><code class="inlineCode"><span class="koboSpan" id="kobo.201.1">arg2</span></code><span class="koboSpan" id="kobo.202.1"> in the image’s shell:</span><ul>
<li class="bulletList"><code class="inlineCode"><span class="koboSpan" id="kobo.203.1">RUN ["command", "arg1", "arg2, "argN"]</span></code><span class="koboSpan" id="kobo.204.1">: Same as above, but useful to avoid shell string munging.</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.205.1">Each </span><code class="inlineCode"><span class="koboSpan" id="kobo.206.1">RUN</span></code><span class="koboSpan" id="kobo.207.1"> instruction executes in a new image layer (we’re not diving into layers here but this can be helpful to know).</span></li>
<li class="bulletList"><code class="inlineCode"><span class="koboSpan" id="kobo.208.1">RUN --mount</span></code><span class="koboSpan" id="kobo.209.1"> can be used to temporarily mount filesystems into the container during the build, without copying the files themselves into an image layer.</span></li>
<li class="bulletList"><code class="inlineCode"><span class="koboSpan" id="kobo.210.1">RUN --network</span></code><span class="koboSpan" id="kobo.211.1"> and </span><code class="inlineCode"><span class="koboSpan" id="kobo.212.1">RUN --security</span></code><span class="koboSpan" id="kobo.213.1"> also exist for managing network context and privileged containers, respectively.</span></li>
</ul>
</li>
<li class="bulletList"><code class="inlineCode"><span class="koboSpan" id="kobo.214.1">WORKDIR</span></code><span class="koboSpan" id="kobo.215.1">: Sets the </span><a id="_idIndexMarker557"/><span class="koboSpan" id="kobo.216.1">working directory for instructions that</span><a id="_idIndexMarker558"/><span class="koboSpan" id="kobo.217.1"> follow in the Dockerfile. </span><span class="koboSpan" id="kobo.217.2">Equivalent to </span><code class="inlineCode"><span class="koboSpan" id="kobo.218.1">cd</span></code><span class="koboSpan" id="kobo.219.1"> in Unix-like operating systems.</span></li>
<li class="bulletList"><code class="inlineCode"><span class="koboSpan" id="kobo.220.1">SHELL</span></code><span class="koboSpan" id="kobo.221.1">: Override the default shell used to interpret commands during the Docker build. </span><span class="koboSpan" id="kobo.221.2">Commands must use the exec form.</span></li>
<li class="bulletList"><code class="inlineCode"><span class="koboSpan" id="kobo.222.1">STOPSIGNAL</span></code><span class="koboSpan" id="kobo.223.1">: Set the system call signal that this container should interpret as the signal to exit. </span><span class="koboSpan" id="kobo.223.2">By default, this is SIGTERM, like any other Linux process.</span></li>
<li class="bulletList"><code class="inlineCode"><span class="koboSpan" id="kobo.224.1">VOLUME</span></code><span class="koboSpan" id="kobo.225.1">: Define volumes that will be mounted in from the host.</span></li>
<li class="bulletList"><code class="inlineCode"><span class="koboSpan" id="kobo.226.1">USER</span></code><span class="koboSpan" id="kobo.227.1">: Change (container) user to use for build commands, from this point forward (can be used multiple times to switch users during a build).</span></li>
<li class="bulletList"><code class="inlineCode"><span class="koboSpan" id="kobo.228.1">ONBUILD</span></code><span class="koboSpan" id="kobo.229.1">: Define an instruction that’s triggered when this image is used as the base for another build.</span></li>
<li class="bulletList"><code class="inlineCode"><span class="koboSpan" id="kobo.230.1">HEALTHCHECK</span></code><span class="koboSpan" id="kobo.231.1">: Some health-checking functionality, which you likely won’t use because </span><a id="_idIndexMarker559"/><span class="koboSpan" id="kobo.232.1">your container scheduler has its</span><a id="_idIndexMarker560"/><span class="koboSpan" id="kobo.233.1"> own health-checking functionality.</span></li>
</ul>
<p class="normal"><span class="koboSpan" id="kobo.234.1">We’ll jump into a practical, end-to-end example of how to tie all of this together with a small project, but first let’s revisit the commands we just used in a bit more depth.</span></p>
<h1 class="heading-1" id="_idParaDest-348"><span class="koboSpan" id="kobo.235.1">Container commands</span></h1>
<p class="normal"><span class="koboSpan" id="kobo.236.1">Now let’s dive deeper into some of the more complicated, but important, commands and command invocations that you may run into when working with Docker.</span></p>
<h2 class="heading-2" id="_idParaDest-349"><span class="koboSpan" id="kobo.237.1">docker run</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.238.1">Let’s look at a more</span><a id="_idIndexMarker561"/><span class="koboSpan" id="kobo.239.1"> complex invocation of the </span><code class="inlineCode"><span class="koboSpan" id="kobo.240.1">docker run</span></code><span class="koboSpan" id="kobo.241.1"> command we used earlier:</span></p>
<pre class="programlisting con"><code class="hljs-con"><span class="koboSpan" id="kobo.242.1"> docker run --rm --name mywebcontainer -p 80:80 -v /tmp:/usr/share/nginx/html:ro -d nginx
</span></code></pre>
<ul>
<li class="bulletList"><code class="inlineCode"><span class="koboSpan" id="kobo.243.1">--rm</span></code><span class="koboSpan" id="kobo.244.1">: Clean up (remove) this container when it exits.</span></li>
<li class="bulletList"><code class="inlineCode"><span class="koboSpan" id="kobo.245.1">--name mywebcontainer</span></code><span class="koboSpan" id="kobo.246.1">: Give this container a friendly name – </span><code class="inlineCode"><span class="koboSpan" id="kobo.247.1">mywebcontainer</span></code><span class="koboSpan" id="kobo.248.1">.</span></li>
<li class="bulletList"><code class="inlineCode"><span class="koboSpan" id="kobo.249.1">-p 80:80</span></code><span class="koboSpan" id="kobo.250.1">: Map port </span><code class="inlineCode"><span class="koboSpan" id="kobo.251.1">80</span></code><span class="koboSpan" id="kobo.252.1"> of the host to port </span><code class="inlineCode"><span class="koboSpan" id="kobo.253.1">80</span></code><span class="koboSpan" id="kobo.254.1"> in the container. </span><span class="koboSpan" id="kobo.254.2">The left port number is on the “outside” (the environment running the container), and the right port number represents the “inside” (container) port. </span><span class="koboSpan" id="kobo.254.3">For example, </span><code class="inlineCode"><span class="koboSpan" id="kobo.255.1">-p 4000:80</span></code><span class="koboSpan" id="kobo.256.1"> will map the container’s port </span><code class="inlineCode"><span class="koboSpan" id="kobo.257.1">80</span></code><span class="koboSpan" id="kobo.258.1"> to </span><code class="inlineCode"><span class="koboSpan" id="kobo.259.1">localhost:4000</span></code><span class="koboSpan" id="kobo.260.1">.</span></li>
<li class="bulletList"><code class="inlineCode"><span class="koboSpan" id="kobo.261.1">-v /tmp:/usr/share/nginx/html:ro</span></code><span class="koboSpan" id="kobo.262.1">: Mount a volume – the host environment’s </span><code class="inlineCode"><span class="koboSpan" id="kobo.263.1">/tmp</span></code><span class="koboSpan" id="kobo.264.1"> directory will be mounted into the container at </span><code class="inlineCode"><span class="koboSpan" id="kobo.265.1">/usr/share/nginx/html</span></code><span class="koboSpan" id="kobo.266.1">; </span><code class="inlineCode"><span class="koboSpan" id="kobo.267.1">:ro</span></code><span class="koboSpan" id="kobo.268.1"> ensures that this will be a read-only mount (mounted files can’t be modified from inside the container).</span></li>
<li class="bulletList"><code class="inlineCode"><span class="koboSpan" id="kobo.269.1">-d</span></code><span class="koboSpan" id="kobo.270.1">: Run the container in detached mode (in the background).</span></li>
<li class="bulletList"><code class="inlineCode"><span class="koboSpan" id="kobo.271.1">nginx</span></code><span class="koboSpan" id="kobo.272.1">: The image to launch this container from.</span></li>
</ul>
<p class="normal"><span class="koboSpan" id="kobo.273.1">If you want to see some HTML at </span><code class="inlineCode"><span class="koboSpan" id="kobo.274.1">http://localhost:80</span></code><span class="koboSpan" id="kobo.275.1">, you can add an </span><code class="inlineCode"><span class="koboSpan" id="kobo.276.1">index.html</span></code><span class="koboSpan" id="kobo.277.1"> file to your </span><code class="inlineCode"><span class="koboSpan" id="kobo.278.1">/tmp</span></code><span class="koboSpan" id="kobo.279.1"> directory:</span></p>
<pre class="programlisting con"><code class="hljs-con"><span class="koboSpan" id="kobo.280.1">cat &lt;&lt;EOF &gt; /tmp/index.html
&lt;!doctype html&gt;
&lt;h1&gt;Hello World&lt;/h1&gt;
&lt;p&gt;This is my container&lt;/p&gt;
&lt;/html&gt;
EOF
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.281.1">Because our </span><code class="inlineCode"><span class="koboSpan" id="kobo.282.1">/tmp</span></code><span class="koboSpan" id="kobo.283.1"> directory is mapped to the container’s </span><code class="inlineCode"><span class="koboSpan" id="kobo.284.1">/usr/share/nginx/html</span></code><span class="koboSpan" id="kobo.285.1"> directory (where nginx will look for HTML files), nginx will immediately recognize and begin serving this file.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.286.1">Volumes are the </span><a id="_idIndexMarker562"/><span class="koboSpan" id="kobo.287.1">mechanism by which stateful applications can still be run using stateless containers.</span></p>
<h3 class="heading-3" id="_idParaDest-350"><span class="koboSpan" id="kobo.288.1">docker image list</span></h3>
<p class="normal"><span class="koboSpan" id="kobo.289.1">To see which images you’ve</span><a id="_idIndexMarker563"/><span class="koboSpan" id="kobo.290.1"> downloaded locally, you can run </span><code class="inlineCode"><span class="koboSpan" id="kobo.291.1">docker images</span></code><span class="koboSpan" id="kobo.292.1"> (or </span><code class="inlineCode"><span class="koboSpan" id="kobo.293.1">docker image list</span></code><span class="koboSpan" id="kobo.294.1">, if you prefer).</span></p>
<p class="normal"><span class="koboSpan" id="kobo.295.1">The list may be long if you’ve been building and using lots of Docker images!</span></p>
<pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta"><span class="koboSpan" id="kobo.296.1">$ </span></span><span class="koboSpan" id="kobo.297.1">docker image list
REPOSITORY                                                 TAG                  IMAGE ID       CREATED         SIZE
nginx                                                      latest               51086ed63d8c   10 days ago     142MB
vault                                                      latest               22fdc6314051   2 months ago    207MB
golang                                                     1.19-alpine          d0f5238dcb8b   2 months ago    352MB
</span></code></pre>
<h2 class="heading-2" id="_idParaDest-351"><span class="koboSpan" id="kobo.298.1">docker ps</span></h2>
<p class="normal"><code class="inlineCode"><span class="koboSpan" id="kobo.299.1">docker ps</span></code><span class="koboSpan" id="kobo.300.1"> is a bit </span><a id="_idIndexMarker564"/><span class="koboSpan" id="kobo.301.1">like the </span><code class="inlineCode"><span class="koboSpan" id="kobo.302.1">ps</span></code><span class="koboSpan" id="kobo.303.1"> command in Linux. </span><span class="koboSpan" id="kobo.303.2">It lets you see which containers are running on your host, along with some context like their ID, which command they are running, their creation time and uptime, port mapping, and more.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.304.1">Running the command</span></p>
<pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta"><span class="koboSpan" id="kobo.305.1">$ </span></span><span class="koboSpan" id="kobo.306.1">docker ps
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.307.1">will produce output like this:</span></p>
<pre class="programlisting con"><code class="hljs-con"><span class="koboSpan" id="kobo.308.1">CONTAINER ID   IMAGE          COMMAND                  CREATED              STATUS              PORTS                NAMES
2aca849eef73   nginx          "/docker-entrypoint.…"   About a minute ago   Up About a minute   0.0.0.0:80-&gt;80/tcp   mywebcontainer
</span></code></pre>
<h2 class="heading-2" id="_idParaDest-352"><span class="koboSpan" id="kobo.309.1">docker exec</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.310.1">During the development </span><a id="_idIndexMarker565"/><span class="koboSpan" id="kobo.311.1">of a container image, it’s common to jump into a container and run commands. </span><span class="koboSpan" id="kobo.311.2">To start an interactive shell in a running container, use </span><code class="inlineCode"><span class="koboSpan" id="kobo.312.1">docker exec</span></code><span class="koboSpan" id="kobo.313.1">:</span></p>
<pre class="programlisting con"><code class="hljs-con"><span class="koboSpan" id="kobo.314.1">docker exec -it mywebcontainer /bin/bash
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.315.1">In the case of our previously started nginx container, this will spawn a Bash shell inside the container environment. </span><span class="koboSpan" id="kobo.315.2">Any state changes you make (file creation, kernel settings, and so on) will be lost when the container is stopped – the next </span><code class="inlineCode"><span class="koboSpan" id="kobo.316.1">docker run</span></code><span class="koboSpan" id="kobo.317.1"> will simply spool up a new container from the same base image state.</span></p>
<h2 class="heading-2" id="_idParaDest-353"><span class="koboSpan" id="kobo.318.1">docker stop</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.319.1">To stop a</span><a id="_idIndexMarker566"/><span class="koboSpan" id="kobo.320.1"> container, run </span><code class="inlineCode"><span class="koboSpan" id="kobo.321.1">docker stop $CONTAINERNAME</span></code><span class="koboSpan" id="kobo.322.1"> – you can also use the container ID if it doesn’t have a friendly name:</span></p>
<pre class="programlisting con"><code class="hljs-con"><span class="koboSpan" id="kobo.323.1">docker stop mywebcontainer
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.324.1">If the container was started with the </span><code class="inlineCode"><span class="koboSpan" id="kobo.325.1">--rm</span></code><span class="koboSpan" id="kobo.326.1"> option, as our nginx container was, the container will be deleted and its state (if that state diverged from the base image) will be lost.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.327.1">If the container </span><a id="_idIndexMarker567"/><span class="koboSpan" id="kobo.328.1">was not started with </span><code class="inlineCode"><span class="koboSpan" id="kobo.329.1">--rm</span></code><span class="koboSpan" id="kobo.330.1">, its state remains on your filesystem and you can start the container again with </span><code class="inlineCode"><span class="koboSpan" id="kobo.331.1">docker start $CONTAINERNAME</span></code><span class="koboSpan" id="kobo.332.1">. </span><span class="koboSpan" id="kobo.332.2">Its state will be preserved.</span></p>
<h1 class="heading-1" id="_idParaDest-354"><span class="koboSpan" id="kobo.333.1">Docker project: Python/Flask application container</span></h1>
<p class="normal"><span class="koboSpan" id="kobo.334.1">We’re going to containerize</span><a id="_idIndexMarker568"/><span class="koboSpan" id="kobo.335.1"> a small Python web service that uses the Flask web framework. </span><span class="koboSpan" id="kobo.335.2">This is an extremely common pattern, and Python lends itself well to containerization because packaging and dependency management are famously messy in a lot of Python projects. </span><span class="koboSpan" id="kobo.335.3">You’ll create all the files yourself – try to use a command-line text editor for practice!</span></p>
<h2 class="heading-2" id="_idParaDest-355"><span class="koboSpan" id="kobo.336.1">1. </span><span class="koboSpan" id="kobo.336.2">Set up the application</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.337.1">First, create a new directory </span><a id="_idIndexMarker569"/><span class="koboSpan" id="kobo.338.1">and enter it:</span></p>
<pre class="programlisting con"><code class="hljs-con"><span class="koboSpan" id="kobo.339.1">mkdir dockerpy &amp;&amp; cd dockerpy
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.340.1">Create the tiny Python web application. </span><span class="koboSpan" id="kobo.340.2">I’m using vim in this example, but use whichever editor you like:</span></p>
<pre class="programlisting con"><code class="hljs-con"><span class="koboSpan" id="kobo.341.1">vim echo_server.py
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.342.1">Paste the following text inside:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.343.1">from</span></span><span class="koboSpan" id="kobo.344.1"> flask </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.345.1">import</span></span><span class="koboSpan" id="kobo.346.1"> Flask, request
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.347.1">import</span></span><span class="koboSpan" id="kobo.348.1"> os
app = Flask(__name__)
</span><span class="hljs-meta"><span class="koboSpan" id="kobo.349.1">@app.route(</span></span><span class="hljs-string"><span class="koboSpan" id="kobo.350.1">'</span></span><span class="hljs-string"><span class="koboSpan" id="kobo.351.1">/'</span></span><span class="hljs-meta"><span class="koboSpan" id="kobo.352.1">)</span></span>
<span class="hljs-keyword"><span class="koboSpan" id="kobo.353.1">def</span></span> <span class="hljs-title"><span class="koboSpan" id="kobo.354.1">echo</span></span><span class="koboSpan" id="kobo.355.1">():
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.356.1">return</span></span><span class="koboSpan" id="kobo.357.1"> {
        </span><span class="hljs-string"><span class="koboSpan" id="kobo.358.1">"method"</span></span><span class="koboSpan" id="kobo.359.1">: request.method,
        </span><span class="hljs-string"><span class="koboSpan" id="kobo.360.1">"headers"</span></span><span class="koboSpan" id="kobo.361.1">: </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.362.1">dict</span></span><span class="koboSpan" id="kobo.363.1">(request.headers),
        </span><span class="hljs-string"><span class="koboSpan" id="kobo.364.1">"args"</span></span><span class="koboSpan" id="kobo.365.1">: request.args
    }
</span><span class="hljs-meta"><span class="koboSpan" id="kobo.366.1">@app.route(</span></span><span class="hljs-string"><span class="koboSpan" id="kobo.367.1">'/health'</span></span><span class="hljs-meta"><span class="koboSpan" id="kobo.368.1">)</span></span>
<span class="hljs-keyword"><span class="koboSpan" id="kobo.369.1">def</span></span> <span class="hljs-title"><span class="koboSpan" id="kobo.370.1">health</span></span><span class="koboSpan" id="kobo.371.1">():
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.372.1">return</span></span><span class="koboSpan" id="kobo.373.1"> {</span><span class="hljs-string"><span class="koboSpan" id="kobo.374.1">"status"</span></span><span class="koboSpan" id="kobo.375.1">: </span><span class="hljs-string"><span class="koboSpan" id="kobo.376.1">"healthy"</span></span><span class="koboSpan" id="kobo.377.1">}
 
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.378.1">if</span></span><span class="koboSpan" id="kobo.379.1"> __name__ == </span><span class="hljs-string"><span class="koboSpan" id="kobo.380.1">"__main__"</span></span><span class="koboSpan" id="kobo.381.1">:
    env_port = os.environ.get(</span><span class="hljs-string"><span class="koboSpan" id="kobo.382.1">"PORT"</span></span><span class="koboSpan" id="kobo.383.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.384.1">8080</span></span><span class="koboSpan" id="kobo.385.1">)
    app.run(host=</span><span class="hljs-string"><span class="koboSpan" id="kobo.386.1">'0.0.0.0'</span></span><span class="koboSpan" id="kobo.387.1">, port=env_port)
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.388.1">That’s the whole web application – it simply reads some of the information from an incoming request and uses that to push a response back to the client.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.389.1">Save and exit the file (</span><code class="inlineCode"><span class="koboSpan" id="kobo.390.1">esc</span></code><span class="koboSpan" id="kobo.391.1">, </span><code class="inlineCode"><span class="koboSpan" id="kobo.392.1">:x</span></code><span class="koboSpan" id="kobo.393.1">).</span></p>
<p class="normal"><span class="koboSpan" id="kobo.394.1">Create a file named </span><code class="inlineCode"><span class="koboSpan" id="kobo.395.1">requirements.txt</span></code><span class="koboSpan" id="kobo.396.1"> containing just the following line:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="koboSpan" id="kobo.397.1">Flask&gt;=</span><span class="hljs-number"><span class="koboSpan" id="kobo.398.1">3.0.0</span></span>
</code></pre>
<p class="normal"><span class="koboSpan" id="kobo.399.1">Next, create your Dockerfile:</span></p>
<pre class="programlisting con"><code class="hljs-con"><span class="koboSpan" id="kobo.400.1">vim Dockerfile
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.401.1">Enter the</span><a id="_idIndexMarker570"/><span class="koboSpan" id="kobo.402.1"> following text:</span></p>
<pre class="programlisting con"><code class="hljs-con"><span class="koboSpan" id="kobo.403.1"># Use an official Python base image
FROM python:3.12-slim
 
# Set the working directory inside the container
WORKDIR /app
 
# Copy our list of dependencies into the container
COPY requirements.txt .
 
</span><span class="koboSpan" id="kobo.403.2"># Install Python dependencies
RUN pip install --no-cache-dir -r requirements.txt
 
# Copy the script into the container
COPY echo_server.py .
 
</span><span class="koboSpan" id="kobo.403.3"># Set a healthcheck to kill the container if it's not listening on the internal port
HEALTHCHECK --interval=30s --timeout=5s \
  CMD curl --fail http://localhost:8080/health || exit 1
 
# Expose port for the application
EXPOSE 8080
 
ENV PORT=8080
CMD ["python", "echo_server.py"]
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.404.1">That’s all you need for now. </span><span class="koboSpan" id="kobo.404.2">Your </span><code class="inlineCode"><span class="koboSpan" id="kobo.405.1">dockerpy</span></code><span class="koboSpan" id="kobo.406.1"> directory should now contain three files:</span></p>
<ul>
<li class="bulletList"><span class="koboSpan" id="kobo.407.1">Dockerfile</span></li>
<li class="bulletList"><code class="inlineCode"><span class="koboSpan" id="kobo.408.1">echo_server.py</span></code></li>
<li class="bulletList"><code class="inlineCode"><span class="koboSpan" id="kobo.409.1">requirements.txt</span></code></li>
</ul>
<h2 class="heading-2" id="_idParaDest-356"><span class="koboSpan" id="kobo.410.1">2. </span><span class="koboSpan" id="kobo.410.2">Create the Docker image</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.411.1">Build a new </span><a id="_idIndexMarker571"/><span class="koboSpan" id="kobo.412.1">Docker image with the </span><code class="inlineCode"><span class="koboSpan" id="kobo.413.1">docker build</span></code><span class="koboSpan" id="kobo.414.1"> command. </span><span class="koboSpan" id="kobo.414.2">The </span><code class="inlineCode"><span class="koboSpan" id="kobo.415.1">-t</span></code><span class="koboSpan" id="kobo.416.1"> is for “tagging” the container with a name:</span></p>
<pre class="programlisting con"><code class="hljs-con"><span class="koboSpan" id="kobo.417.1">docker build -t dockerpy .
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.418.1">Notice the </span><code class="inlineCode"><span class="koboSpan" id="kobo.419.1">.</span></code><span class="koboSpan" id="kobo.420.1"> character at the end, which is telling Docker to use the current directory as its build context.</span></p>
<h2 class="heading-2" id="_idParaDest-357"><span class="koboSpan" id="kobo.421.1">3. </span><span class="koboSpan" id="kobo.421.2">Start a container from your image</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.422.1">You’ve already</span><a id="_idIndexMarker572"/><span class="koboSpan" id="kobo.423.1"> used the </span><code class="inlineCode"><span class="koboSpan" id="kobo.424.1">docker run</span></code><span class="koboSpan" id="kobo.425.1"> command earlier in this chapter. </span><span class="koboSpan" id="kobo.425.2">Use it to launch a container from your newly built image:</span></p>
<pre class="programlisting con"><code class="hljs-con"><span class="koboSpan" id="kobo.426.1">docker run --rm -d -p 8080:8080 --name my-dockerpy dockerpy
(the command will print out the ID of your new container)
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.427.1">There are a few new arguments here:</span></p>
<ul>
<li class="bulletList"><code class="inlineCode"><span class="koboSpan" id="kobo.428.1">--rm</span></code><span class="koboSpan" id="kobo.429.1"> tells Docker to delete the container when it exits. </span><span class="koboSpan" id="kobo.429.2">This prevents old containers from hanging around on your filesystem, as you saw in the first examples in this chapter.</span></li>
<li class="bulletList"><code class="inlineCode"><span class="koboSpan" id="kobo.430.1">-d</span></code><span class="koboSpan" id="kobo.431.1"> tells Docker to daemonize the container. </span><span class="koboSpan" id="kobo.431.2">This keeps it from attaching to your terminal in the foreground.</span></li>
<li class="bulletList"><code class="inlineCode"><span class="koboSpan" id="kobo.432.1">-p</span></code><span class="koboSpan" id="kobo.433.1"> sets up a port mapping: the left side of the colon is the container port, while the right side is the host port that it’ll be mapped to. </span><span class="koboSpan" id="kobo.433.2">If the container application were running on port </span><code class="inlineCode"><span class="koboSpan" id="kobo.434.1">1234</span></code><span class="koboSpan" id="kobo.435.1"> and you wanted it to map to host port </span><code class="inlineCode"><span class="koboSpan" id="kobo.436.1">80</span></code><span class="koboSpan" id="kobo.437.1">, this would read </span><code class="inlineCode"><span class="koboSpan" id="kobo.438.1">–p 1234:80</span></code><span class="koboSpan" id="kobo.439.1">.</span></li>
<li class="bulletList"><code class="inlineCode"><span class="koboSpan" id="kobo.440.1">--name</span></code><span class="koboSpan" id="kobo.441.1"> tags your container with a name so you can find it easily in the output of </span><code class="inlineCode"><span class="koboSpan" id="kobo.442.1">docker ps</span></code><span class="koboSpan" id="kobo.443.1">.</span></li>
</ul>
<p class="normal"><span class="koboSpan" id="kobo.444.1">Now you’ve got your containerized application running, and can access it in a browser or on the command line. </span><span class="koboSpan" id="kobo.444.2">Let’s use the </span><code class="inlineCode"><span class="koboSpan" id="kobo.445.1">curl</span></code><span class="koboSpan" id="kobo.446.1"> command to connect to send a request to the web service:</span></p>
<pre class="programlisting con"><code class="hljs-con"><span class="koboSpan" id="kobo.447.1">curl localhost:8080
{"args":{},"headers":{"Accept":"*/*","Host":"localhost:8080","User-Agent":"curl/8.1.2"},"method":"GET"}
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.448.1">For those who have suffered through impossible-to-recreate dependency nightmares (Python, Ruby, and others are famous for this), this should be a revelation. </span><span class="koboSpan" id="kobo.448.2">All of the complexity that you used to have to drag around with your application – from local dev environments to CI and testing, to staging, and finally to production – is now condensed into a single artifact that’s guaranteed to contain the same stuff no matter where you run it.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.449.1">One command we haven’t used before is </span><code class="inlineCode"><span class="koboSpan" id="kobo.450.1">docker exec</span></code><span class="koboSpan" id="kobo.451.1">, which lets you execute a command inside a running container. </span><span class="koboSpan" id="kobo.451.2">This is useful if, for some reason, you absolutely have to inspect or modify a running container:</span></p>
<pre class="programlisting con"><code class="hljs-con"><span class="koboSpan" id="kobo.452.1">docker exec -it my-dockerpy /bin/sh
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.453.1">This launches and attaches to </span><code class="inlineCode"><span class="koboSpan" id="kobo.454.1">/bin/sh</span></code><span class="koboSpan" id="kobo.455.1"> in the container (most production containers will only have a minimal shell at </span><code class="inlineCode"><span class="koboSpan" id="kobo.456.1">/bin/sh</span></code><span class="koboSpan" id="kobo.457.1">, and won’t ship with something as full-featured as Bash).</span></p>
<p class="normal"><span class="koboSpan" id="kobo.458.1">Let’s stop the server with the last command we’ll cover here, which is </span><code class="inlineCode"><span class="koboSpan" id="kobo.459.1">docker kill</span></code><span class="koboSpan" id="kobo.460.1">:</span></p>
<pre class="programlisting con"><code class="hljs-con"><span class="koboSpan" id="kobo.461.1">docker kill my-dockerpy
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.462.1">This sends</span><a id="_idIndexMarker573"/><span class="koboSpan" id="kobo.463.1"> a </span><code class="inlineCode"><span class="koboSpan" id="kobo.464.1">SIGKILL</span></code><span class="koboSpan" id="kobo.465.1"> (Signal 9) as opposed to a </span><code class="inlineCode"><span class="koboSpan" id="kobo.466.1">SIGTERM</span></code><span class="koboSpan" id="kobo.467.1"> (Signal 15) to the process and stops it immediately without giving it the chance to shut down gracefully.</span></p>
<h1 class="heading-1" id="_idParaDest-358"><span class="koboSpan" id="kobo.468.1">Containers vs. </span><span class="koboSpan" id="kobo.468.2">virtual machines</span></h1>
<p class="normal"><span class="koboSpan" id="kobo.469.1">You’ve now gotten a taste of the workflow that you’ll use to create and work with Docker images. </span><span class="koboSpan" id="kobo.469.2">However, it pays to know a bit about the underlying differences between containers and virtual machines. </span><span class="koboSpan" id="kobo.469.3">This knowledge can make a difference when you’re troubleshooting operational issues, and it’s also a common interview question to gauge how well you understand the principles underlying containerization.</span></p>
<p class="normal"><strong class="keyWord"><span class="koboSpan" id="kobo.470.1">Virtual Machines</span></strong><span class="koboSpan" id="kobo.471.1"> (</span><strong class="keyWord"><span class="koboSpan" id="kobo.472.1">VMs</span></strong><span class="koboSpan" id="kobo.473.1">) allow </span><a id="_idIndexMarker574"/><span class="koboSpan" id="kobo.474.1">you to run complete operating systems like Linux, Windows, or DragonFly BSD on top of another host operating system. </span><span class="koboSpan" id="kobo.474.2">VMs run independently of the host system. </span><span class="koboSpan" id="kobo.474.3">In fact, running Docker on macOS will transparently use a VM to provide the Linux OS that’s needed for Docker.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.475.1">As a result, a virtual machine</span><a id="_idIndexMarker575"/><span class="koboSpan" id="kobo.476.1"> runs a full operating system like Linux, which in turn uses an init system like </span><code class="inlineCode"><span class="koboSpan" id="kobo.477.1">systemd</span></code><span class="koboSpan" id="kobo.478.1">. </span><span class="koboSpan" id="kobo.478.2">Because of this, you manage services and processes exactly as if your VM were a physical machine. </span><span class="koboSpan" id="kobo.478.3">In terms of day-to-day use, everything that applies to a physical machine also applies to virtual machines. </span><span class="koboSpan" id="kobo.478.4">However, this is not how containers are typically used.</span></p>
<p class="normal"><strong class="keyWord"><span class="koboSpan" id="kobo.479.1">Docker containers</span></strong><a id="_idIndexMarker576"/><span class="koboSpan" id="kobo.480.1"> usually contain single applications; in fact, they frequently contain only a single process. </span><span class="koboSpan" id="kobo.480.2">If there happen to be multiple processes inside a container, this is typically because of a multi-process application that has spawned child processes (web servers or command runners usually do this). </span><span class="koboSpan" id="kobo.480.3">Since the widely agreed-upon best practice is for a container to run only a single process, and to exit as soon as that process exits, any kind of internal process supervision and management would be wasted here. </span></p>
<p class="normal"><span class="koboSpan" id="kobo.481.1">Instead, you’ll find that the jobs typically done by an operating system’s init system have moved outside the container runtime environment, to the external systems </span><em class="italic"><span class="koboSpan" id="kobo.482.1">managing </span></em><span class="koboSpan" id="kobo.483.1">the containers, such as Kubernetes, Nomad, and others.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.484.1">In this new model, containers are what operating system processes used to be, and container orchestrators play assorted OS and scheduler roles.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.485.1">In a Docker container, PID1, which is the init system on a full Linux operating system, is whatever your CMD or ENTRYPOINT is. </span><span class="koboSpan" id="kobo.485.2">Usually, that’s the main process of the software you’re running. </span><span class="koboSpan" id="kobo.485.3">Typically, a container is expected to run a single process. </span><span class="koboSpan" id="kobo.485.4">While there are scenarios where people intentionally run their containers in a different way, running a single process and having the container halt when the process halts is the expected behavior. </span><span class="koboSpan" id="kobo.485.5">Especially when simply containerizing a service to be run in production, one should make sure to follow this approach. </span><span class="koboSpan" id="kobo.485.6">There are exceptions to this rule, especially when running software that</span><a id="_idIndexMarker577"/><span class="koboSpan" id="kobo.486.1"> predates the popularization of Docker containers, but in these cases, you’ll likely be aware and often base off containers made for this purpose.</span></p>
<h1 class="heading-1" id="_idParaDest-359"><span class="koboSpan" id="kobo.487.1">A quick note on Docker image repositories</span></h1>
<p class="normal"><span class="koboSpan" id="kobo.488.1">We’ve been working quite a bit </span><a id="_idIndexMarker578"/><span class="koboSpan" id="kobo.489.1">with the </span><code class="inlineCode"><span class="koboSpan" id="kobo.490.1">nginx</span></code><span class="koboSpan" id="kobo.491.1"> image in this chapter. </span><span class="koboSpan" id="kobo.491.2">But where exactly is this image coming from? </span><span class="koboSpan" id="kobo.491.3">By default, Docker attempts to download images from Docker</span><a id="_idIndexMarker579"/><span class="koboSpan" id="kobo.492.1"> Hub (</span><a href="https://hub.docker.com/"><span class="url"><span class="koboSpan" id="kobo.493.1">https://hub.docker.com/</span></span></a><span class="koboSpan" id="kobo.494.1">), which is a central repository of public Docker images. </span><span class="koboSpan" id="kobo.494.2">Docker Hub works like a Linux package repository, which contains uploaded Docker images ready for you to use. </span><span class="koboSpan" id="kobo.494.3">Most popular server software can be found there and can be downloaded and used as easily as you just saw with </span><code class="inlineCode"><span class="koboSpan" id="kobo.495.1">nginx</span></code><span class="koboSpan" id="kobo.496.1">.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.497.1">Not all applications are public, however, and it’s normal to use private repositories to store Docker images. </span><span class="koboSpan" id="kobo.497.2">There is an ever-changing list of Docker image repository providers, so we won’t list them here, but it’s enough to understand that they all work the same way as Docker Hub.</span></p>
<h1 class="heading-1" id="_idParaDest-360"><span class="koboSpan" id="kobo.498.1">Painfully learned container lessons</span></h1>
<p class="normal"><span class="koboSpan" id="kobo.499.1">As you start building your own containers, you can avoid many problems by keeping in mind the best practices discussed in Docker’s official documentation here: </span><a href="https://docs.docker.com/get-started/09_image_best/"><span class="url"><span class="koboSpan" id="kobo.500.1">https://docs.docker.com/get-started/09_image_best/</span></span></a><span class="koboSpan" id="kobo.501.1">.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.502.1">That said, we’ve compiled a small list of the most egregious containerization mistakes we’ve noticed, and how to avoid them. </span><span class="koboSpan" id="kobo.502.2">This section is the result of many sleepless nights, outages, and learning things the hard way.</span></p>
<h2 class="heading-2" id="_idParaDest-361"><span class="koboSpan" id="kobo.503.1">Image size</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.504.1">Start with minimal images, like Scratch or Alpine. </span><span class="koboSpan" id="kobo.504.2">To deploy most applications, it’s a good idea to try to stay away from big images and distributions like Ubuntu. </span><span class="koboSpan" id="kobo.504.3">When build dependencies are required, removing these, or using intermediate build containers when building larger/multi-container projects, is recommended.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.505.1">Small, minimal images don’t just mean faster download speeds and less resource usage, but also make it a lot easier for you to manage. </span><span class="koboSpan" id="kobo.505.2">If an image doesn’t include software and libraries you don’t need, that’s less for you to keep updated, less surface area for criminals to attack, and fewer noisy warnings from container security scanners.</span></p>
<h2 class="heading-2" id="_idParaDest-362"><span class="koboSpan" id="kobo.506.1">C standard library</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.507.1">Be aware of </span><a id="_idIndexMarker580"/><span class="koboSpan" id="kobo.508.1">which </span><strong class="keyWord"><span class="koboSpan" id="kobo.509.1">C Standard Library</span></strong><span class="koboSpan" id="kobo.510.1"> (also known as </span><em class="italic"><span class="koboSpan" id="kobo.511.1">libc</span></em><span class="koboSpan" id="kobo.512.1">) you’re using. </span><span class="koboSpan" id="kobo.512.2">Many Linux distributions use </span><code class="inlineCode"><span class="koboSpan" id="kobo.513.1">glibc</span></code><span class="koboSpan" id="kobo.514.1">; some, like Alpine Linux, use </span><code class="inlineCode"><span class="koboSpan" id="kobo.515.1">musl</span></code><span class="koboSpan" id="kobo.516.1"> or others. </span><span class="koboSpan" id="kobo.516.2">The libraries and any resulting binaries might not be compatible across those. </span><span class="koboSpan" id="kobo.516.3">For example, on Alpine, you may need to compile less popular tools yourself. </span><span class="koboSpan" id="kobo.516.4">If your projects depend on certain libraries being available via packages on your base image, you might run into incompatibilities. </span><span class="koboSpan" id="kobo.516.5">Of course, upgrading, downgrading, or switching base images completely might cause similar issues.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.517.1">However, because Alpine and </span><code class="inlineCode"><span class="koboSpan" id="kobo.518.1">musl</span></code><span class="koboSpan" id="kobo.519.1"> have been steadily gaining adoption, these sorts of issues are becoming less likely (and, at the very least, more googlable!). </span><span class="koboSpan" id="kobo.519.2">If you don’t depend on any C libraries, this usually won’t be an issue. </span><span class="koboSpan" id="kobo.519.3">Also, statically compiling your code can make you more independent of the underlying system and therefore the base image.</span></p>
<h2 class="heading-2" id="_idParaDest-363"><span class="koboSpan" id="kobo.520.1">Production is not your laptop: outside dependencies</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.521.1">Don’t depend on local mounts or other local containers. </span><span class="koboSpan" id="kobo.521.2">The environment for a deployed container will likely be very different from your laptop. </span><span class="koboSpan" id="kobo.521.3">Just because you’ve got a database container next to your web app container on your laptop, doesn’t mean these containers will be scheduled on the same machines in production.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.522.1">The same thing goes for data volumes – these outside-your-container touchpoints are where you’ll have to do some planning with your Ops/DevOps co-workers. </span><span class="koboSpan" id="kobo.522.2">You’ll likely be hooking into service discovery, health checking, and shared volumes via a scheduler or other DevOps tooling construct.</span></p>
<h1 class="heading-1" id="_idParaDest-364"><span class="koboSpan" id="kobo.523.1">Container theory: namespacing</span></h1>
<p class="normal"><span class="koboSpan" id="kobo.524.1">If you’re wondering how some of this container magic works underneath, or just worried that you’ll have to troubleshoot a container environment under pressure one day, it’s useful to familiarize yourself with the concept of namespacing. </span><span class="koboSpan" id="kobo.524.2">You can skip this section if you’re not interested in how the container abstraction is built on Linux.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.525.1">Namespacing is an overloaded term, used to mean different things in different technological niches. </span><span class="koboSpan" id="kobo.525.2">In the context of Linux containers, the idea of namespacing is best explained via </span><code class="inlineCode"><span class="koboSpan" id="kobo.526.1">chroot</span></code><span class="koboSpan" id="kobo.527.1"> (change root). </span><code class="inlineCode"><span class="koboSpan" id="kobo.528.1">chroot</span></code><span class="koboSpan" id="kobo.529.1"> is an old utility for Unix and Unix-like operating systems that allows a user to change the root (the </span><code class="inlineCode"><span class="koboSpan" id="kobo.530.1">/</span></code><span class="koboSpan" id="kobo.531.1"> path) of the filesystem.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.532.1">The usage of this tool is really quite simple: </span><code class="inlineCode"><span class="koboSpan" id="kobo.533.1">chroot /some/path</span></code><span class="koboSpan" id="kobo.534.1"> will set whatever is in </span><code class="inlineCode"><span class="koboSpan" id="kobo.535.1">/some/path</span></code><span class="koboSpan" id="kobo.536.1"> to be the new </span><code class="inlineCode"><span class="koboSpan" id="kobo.537.1">/</span></code><span class="koboSpan" id="kobo.538.1">. </span><span class="koboSpan" id="kobo.538.2">In addition to allowing OS installers to change into the system that is currently being installed to run commands, it also allows for basic namespacing. </span><span class="koboSpan" id="kobo.538.3">In fact, various software and the configuration of various Linux distributions have been making use of this to enhance security, because using </span><code class="inlineCode"><span class="koboSpan" id="kobo.539.1">chroot</span></code><span class="koboSpan" id="kobo.540.1"> essentially excludes parts of the filesystem from the currently readable scope – it makes anything outside the new root inaccessible. </span><span class="koboSpan" id="kobo.540.2">So, if an attacker uses an exploit that allows for remote code execution on a web server running inside a </span><code class="inlineCode"><span class="koboSpan" id="kobo.541.1">chroot</span></code><span class="koboSpan" id="kobo.542.1"> environment, the system and any files outside this directory will remain unaffected.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.543.1">The technical primitives used to implement containers on Linux and other operating systems have changed significantly over the last decade, and will likely continue to change. </span><span class="koboSpan" id="kobo.543.2">Thankfully, the low-level implementation is not critically important for you as a software engineer who is mainly a consumer of containerization, as opposed to an operator or implementer of this technology.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.544.1">The “container” abstraction relies on underlying technologies like:</span></p>
<ul>
<li class="bulletList"><span class="koboSpan" id="kobo.545.1">Filesystem namespacing (for example, with </span><code class="inlineCode"><span class="koboSpan" id="kobo.546.1">chroot</span></code><span class="koboSpan" id="kobo.547.1">).</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.548.1">User and process namespacing, making processes outside the container invisible from within the container. </span><span class="koboSpan" id="kobo.548.2">In other words, root and PID 5 in the container would respectively map to an unprivileged user and another process ID outside of the container namespace.</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.549.1">Resource grouping and accounting technologies such as </span><code class="inlineCode"><span class="koboSpan" id="kobo.550.1">cgroups</span></code><span class="koboSpan" id="kobo.551.1">.</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.552.1">Network virtualization/namespacing, so a container can’t access a network interface directly, but also so that port number overlaps can be handled. </span><span class="koboSpan" id="kobo.552.2">For example, you can run two different containers that expose port </span><code class="inlineCode"><span class="koboSpan" id="kobo.553.1">8080</span></code><span class="koboSpan" id="kobo.554.1">; there won’t be an error about the port being already in use, because the containers’ networking stacks are independent of each other.</span></li>
</ul>
<h1 class="heading-1" id="_idParaDest-365"><span class="koboSpan" id="kobo.555.1">How do we do Ops with containers?</span></h1>
<p class="normal"><span class="koboSpan" id="kobo.556.1">Although this is not a book for system administrators or site reliability engineers, you should know the basic context in which containers are generally run. </span><span class="koboSpan" id="kobo.556.2">The main idea is that containers are largely stateless “functions” that process inputs (web requests or HTTP messages from other services) and produce outputs (web responses, side effects, and logs streamed to STDOUT). </span><span class="koboSpan" id="kobo.556.3">In a well-run operations environment, containers can be thought of as an analog to Linux processes, or to functions in programming.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.557.1">Containers</span><a id="_idIndexMarker581"/><span class="koboSpan" id="kobo.558.1"> are usually “scheduled” onto hosts by a third-party tooling layer such as Kubernetes, Nomad, and others. </span><span class="koboSpan" id="kobo.558.2">If containers are like processes, then these fill the role of the operating system scheduler (the whole thing is a distributed system instead of a single host).</span></p>
<p class="normal"><span class="koboSpan" id="kobo.559.1">Container output is usually captured by the same tooling and redirected to logging solutions such as Logstash, Graylog, and Datadog. </span><span class="koboSpan" id="kobo.559.2">Metrics from all running containers may be extracted and fed into tools like Prometheus for analysis and troubleshooting.</span></p>
<h1 class="heading-1" id="_idParaDest-366"><span class="koboSpan" id="kobo.560.1">Conclusion</span></h1>
<p class="normal"><span class="koboSpan" id="kobo.561.1">In this chapter, you got a whirlwind tour of the most important things you need to know about working with Docker, and containers in general. </span><span class="koboSpan" id="kobo.561.2">Although individual technologies may change – which container scheduler is in vogue, or how log streaming is best handled – we’ve tried to stay focused on the core theory and skills that every modern software developer should have.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.562.1">We hope that you take away a few main ideas from this chapter. </span><span class="koboSpan" id="kobo.562.2">First, we hope you have an intuitive grasp of the problems that containerization solves for people, mainly by controlling complexity and packaging dependencies into a single artifact.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.563.1">It’s also important to remember the difference between images and containers, and to get some practice building your own Dockerfiles from scratch, using the official documentation.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.564.1">We hope that visiting a few more advanced topics, like how virtual machines and containers are different and how namespacing works, comes in handy during troubleshooting or a job interview. </span><span class="koboSpan" id="kobo.564.2">The best practices we discussed will come in handy there, too.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.565.1">Finally, to cement your learning, we recommend that you practice these skills by containerizing one of your own applications. </span><span class="koboSpan" id="kobo.565.2">You’ll learn a lot and it’ll be much easier to start while all of the information from this chapter is still fresh in your mind.</span></p>
<h1 class="heading-1"><span class="koboSpan" id="kobo.566.1">Learn more on Discord</span></h1>
<p class="normal"><span class="koboSpan" id="kobo.567.1">To join the Discord community for this book – where you can share feedback, ask questions to the author, and learn about new releases – follow the QR code below:</span></p>
<p class="normal"><a href="https://packt.link/SecNet"><span class="url"><span class="koboSpan" id="kobo.568.1">https://packt.link/SecNet</span></span></a></p>
<p class="normal"><span class="koboSpan" id="kobo.569.1"><img alt="" role="presentation" src="../Images/QR_Code1768422420210094187.png"/></span></p>
</div>
</body></html>