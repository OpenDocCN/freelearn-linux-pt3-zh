- en: '*Chapter 12*: Tuning SELinux Policies'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Until now, we have been working with an existing SELinux policy by tuning our
    system to deal with the proper SELinux contexts and assigning the right labels
    to files, directories, and even network ports. We've learned that the behavior
    that SELinux enforces is defined within the policies. To fine-tune the policy
    enforcement rules, we have already briefly covered SELinux booleans.
  prefs: []
  type: TYPE_NORMAL
- en: It's time we look into SELinux booleans in more detail, learning how to look
    up the impact booleans have. Within this chapter, we then consider SELinux policy
    modules themselves and what options administrators have when dealing with these
    modules. Finally, we will look at how to update or even replace existing policies.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we''re going to cover the following main topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Working with SELinux booleans
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Handling policy modules
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Replacing and updating existing policies
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Check out the following video to see the Code in Action: [https://bit.ly/2T7MkVK](https://bit.ly/2T7MkVK)'
  prefs: []
  type: TYPE_NORMAL
- en: Working with SELinux booleans
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One of the methods of manipulating SELinux policies is by toggling SELinux booleans.
    Ever since [*Chapter 2*](B16276_02_Final_VK.xhtml#_idTextAnchor045), *Understanding
    SELinux Decisions and Logging*, where we used the `secure_mode_policyload` boolean,
    these tunable settings have been popping up over the course of this book. With
    their simple ON/OFF state, they enable or disable parts of the SELinux policy.
    Policy developers and administrators use SELinux booleans to toggle parts of the
    policy that not all deployments always need to be active, but some still do.
  prefs: []
  type: TYPE_NORMAL
- en: These booleans are added to the policy based on feedback from, and with the
    help of, the community at large. By establishing which policy rules are necessary
    against those that are optional, SELinux developers can provide an SELinux policy
    that works for a majority of systems, even when the uses of these systems differ.
  prefs: []
  type: TYPE_NORMAL
- en: Listing SELinux booleans
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'An overview of SELinux booleans can be obtained by using the `semanage` command
    with the `boolean` option. On a regular system, we can easily find over a hundred
    SELinux booleans, so it is necessary to filter them out for the description of
    the boolean we need:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: The output not only gives us a brief description of the boolean, but also the
    current value (actually, it gives us the current value and then the value pending
    a policy change, but this will almost always be the same).
  prefs: []
  type: TYPE_NORMAL
- en: 'Another method for getting the current value of a boolean is through the `getsebool`
    command, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'If the name of the boolean is not exactly known, we can ask for an overview
    of all booleans (and their values) and filter for the one we need:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Another utility that can be used to view SELinux boolean descriptions is the
    `sepolicy booleans` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: However, this command does not show the current value of the boolean.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, booleans are also represented through the `/sys/fs/selinux` filesystem:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, booleans can be read as if they were regular files, and they return two
    values:'
  prefs: []
  type: TYPE_NORMAL
- en: The first value is the current state of the boolean, where `0` means OFF and
    `1` means ON.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The second value is the pending state of the boolean.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A pending state allows administrators to change multiple boolean values simultaneously,
    but only when manipulating booleans through the `/sys/fs/selinux` filesystem,
    as we will see next.
  prefs: []
  type: TYPE_NORMAL
- en: Changing boolean values
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We can change the value of a boolean using the `setsebool` command. For instance,
    to toggle the `httpd_can_sendmail` SELinux boolean, we can use the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Some Linux distributions might also have the `togglesebool` command available.
    This command will flip the value of the boolean, so ON becomes OFF, and OFF becomes
    ON:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: SELinux booleans have a default state defined by the policy administrator (and
    thus the default SELinux policy active on the system). Changing the value using
    `setsebool` updates the current active access controls, but this does not persist
    across reboots (if we toggle the boolean, then after rebooting, the old value
    will be used again).
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to keep the changes permanently, add the `-P` option to the `setsebool`
    command as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: In the background, the updated SELinux boolean value is included in the policy
    store. Then, the current policy file is rebuilt and loaded. As a result, the policy
    file (called `policy.##` with `##` representing an integer value) residing in
    `/etc/selinux/targeted/policy` will be regenerated. This regeneration takes time,
    which is why switching a boolean value persistently (using `-P`) takes more time
    to complete than when we change a value without persisting it (using `setsebool`
    without `-P` or `togglesebool`) to the policy store.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another way to change and persist the boolean settings is to use the `semanage
    boolean` command as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: In this case, we modify (`-m`) the boolean value and set it to ON (`--on`).
  prefs: []
  type: TYPE_NORMAL
- en: 'Booleans can also be changed through their `/sys/fs/selinux/booleans` representation.
    When this happens, the boolean value is not immediately activated â€“ the change
    of the value is pending. This allows administrators to modify multiple booleans
    through `/sys/fs/selinux/booleans` first:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'To commit the changes, write the value `1` into `/sys/fs/selinux/commit_pending_bools`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: As long as you modify booleans through the `semanage` or `setsebool` commands
    though, the changes will immediately be committed. Only operations through the
    `/sys/fs/selinux` structure allow pending boolean changes.
  prefs: []
  type: TYPE_NORMAL
- en: Inspecting the impact of a boolean
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To discover which policy rules a boolean manipulates, the description usually
    suffices. Sometimes though, we might want to know which SELinux rules change when
    we alter a boolean value. With the `sesearch` application, we can query the SELinux
    policy, displaying the rules affected by a given boolean. To show this information
    in detail, we use the `-b` option (for the boolean) and `-A` option (to show all
    `allow` rules):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'When we query the SELinux policy directly, conditional rules can be shown as
    part of the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: When `allow` rules are suffixed with an SELinux boolean between square brackets
    followed by `:True`, then these rules are only applied if the boolean is active.
    If the boolean is followed by `:False`, then the rule is applied if the boolean
    is not active.
  prefs: []
  type: TYPE_NORMAL
- en: Not all situations can be perfectly defined by policy writers though. Sometimes
    we will need to create our own SELinux policy modules and load those. Let's see
    how we can handle SELinux policy modules specifically.
  prefs: []
  type: TYPE_NORMAL
- en: Handling policy modules
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When the system loads the SELinux policy in memory, it uses the `policy.##`
    file, with `##` representing the policy version, as explained at the end of [*Chapter
    1*](B16276_01_Final_VK.xhtml#_idTextAnchor018), *Fundamental SELinux Concepts*.
    This file, which resides in `/etc/selinux/targeted/policy`, is generated every
    time the policy is modified. This can be when booleans are changed (and persisted),
    or when SELinux policy modules are added or removed.
  prefs: []
  type: TYPE_NORMAL
- en: Listing policy modules
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: SELinux policy modules are sets of SELinux rules that can be loaded and unloaded.
    These modules, with `.pp` or `.cil` suffixes, can be loaded and unloaded as needed
    by the administrator. Once loaded, the policy module is made part of the SELinux
    policy store, and will be loaded even after a system reboot. Unlike SELinux boolean
    changes, SELinux policy module loads are always persisted.
  prefs: []
  type: TYPE_NORMAL
- en: 'To list the currently loaded SELinux policy modules, we recommend using the
    `semodule` command. By default, `semodule` will show all loaded SELinux policy
    modules without any details:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'SELinux policy modules can, however, be loaded at a specified priority. This
    allows administrators to load a policy that overrules an already loaded policy:
    SELinux policy modules with a higher `--list-modules=full` argument:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Alongside the priority, the listing also shows whether the policy module is
    based upon the binary module format (`pp`) or the more modern `cil`).
  prefs: []
  type: TYPE_NORMAL
- en: 'The SELinux utilities will copy the active policy modules into a policy-specific
    location. This allows administrators to list the currently active modules through
    regular filesystem queries as well:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'The use of the filesystem location for querying active policies is, however,
    not recommended, as we have no guarantee that the loaded policies match the filesystem:
    non-SELinux utilities can add or remove files from these locations without adjusting
    the SELinux policy state.'
  prefs: []
  type: TYPE_NORMAL
- en: Loading and removing policy modules
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In the *Replacing and updating existing policies* section, we will learn how
    to generate new policy modules. Once created, they need to be loaded and/or removed.
    We load policy modules with `semodule` as well, regardless of the policy format
    (`.pp` or `.cil`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'By default, SELinux policy modules are loaded at the `400` priority when invoked
    by the administrator, whereas SELinux policy modules loaded as part of the default
    system policy will be loaded at the `100` priority. When loading policies, the
    priority can be adjusted using the `-X` option. For instance, to load the `test.cil`
    policy with a priority of `500` we use the `-X` option as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'To remove a policy module with `semodule`, use the `--remove` or `-r` option.
    In this case, we are not referring to an SELinux policy module *file*, but to
    the *name* of the module itself as displayed by `semodule`. Hence, we do not need
    to pass on a suffix:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'To remove an SELinux policy module from a specified priority, use the `-X`
    option:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'The order of the arguments is important: the `-X` option will set the priority
    for the actions that follow it, not those that precede it. If it is not set, then
    a priority value of `400` will be used.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, it is possible to keep an SELinux policy module but disable it. This
    keeps the module in the policy store, but disables all the SELinux policy rules
    inside of it. We use the `--disable` (or `-d`) option to accomplish this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'To re-enable the policy, use the `--enable` (or `-e`) option:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: The disabled and enabled states of SELinux policy modules persist through reboots
    as well. Furthermore, if you are disabling an SELinux module, all instances of
    that module (including lower priority ones) will be disabled.
  prefs: []
  type: TYPE_NORMAL
- en: Disabling policies is strongly recommended when the policy module is part of
    the distribution's SELinux policy, as the modules themselves are not always available
    on the system and might require a reinstallation of the policy package just to
    get it back.
  prefs: []
  type: TYPE_NORMAL
- en: With loading and unloading policies explained, let's see how we can generate
    updates on the current SELinux policy.
  prefs: []
  type: TYPE_NORMAL
- en: Replacing and updating existing policies
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When we replace or update existing policies, we need to load them using the
    `semodule` commands, as shown in the *Handling policy modules* section. But how
    do we create or update the policies, exactly? Let's consider a few use cases where
    SELinux policy adjustments are triggered.
  prefs: []
  type: TYPE_NORMAL
- en: Creating policies using audit2allow
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When SELinux prevents certain actions, we know it will log the appropriate denial
    (assuming no `dontaudit` statements are defined) in the audit logs. This denial
    can be used as the source to generate a custom SELinux policy that allows the
    activity.
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider the following denial, which occurred when a confined user called `su`
    to switch to the root user:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: If we are certain that these operations need to be granted, then we can use
    the `audit2allow` command to generate a policy module for us that allows these
    activities. The `allow` rules. These rules can then be saved in a file, ready
    to be built into an SELinux policy module, which can then be loaded.
  prefs: []
  type: TYPE_NORMAL
- en: 'To generate SELinux policy `allow` rules, pipe the denials through the `audit2allow`
    application:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Based on the denials, `audit2allow` prepared an `allow` rule. We can also ask
    `audit2allow` to immediately create an SELinux policy module:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: A file called `localpolicy.pp` will be available in the current directory, which
    we can load using the `semodule` command. The source file will also be present,
    named `localpolicy.te`.
  prefs: []
  type: TYPE_NORMAL
- en: 'If the denials that occurred are considered cosmetic in nature (meaning that
    the system functions as expected and the denials should not cause any updates
    on the policy), you can use `audit2allow` to generate `dontaudit` rules rather
    than `allow` rules. In that case, the denials will no longer be visible in the
    audit logs, while still preventing the actions from taking place:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: It is likely, after including the necessary rules, that the action will result
    in more denials that were not previously triggered. As long as the previous AVC
    denials are still available in the audit logs, it is sufficient to regenerate
    the policy and continue. After all, `audit2allow` will consider all AVC denials
    that it encountered, regardless of the current SELinux policy state.
  prefs: []
  type: TYPE_NORMAL
- en: Another popular approach is to put the system (or the application domain) in
    permissive mode to generate and fill up the audit logs with all the AVC denials
    related to the action. Although this generates more AVC denials to work with,
    it could also result in wrong decisions by the `audit2allow` command. Hence, always
    verify the denials before generating new policy constructs, and review the generated
    policy to make sure that it will enforce the right set of access controls and
    not grant more privileges than needed.
  prefs: []
  type: TYPE_NORMAL
- en: 'When the previous AVC denials are no longer available inside the audit log,
    a new policy module will need to be generated, as otherwise the previously fixed
    accesses will be denied again: the newly generated policy will no longer contain
    the `allow` rules from before, and when we load the new policy, the old policy
    is no longer active.'
  prefs: []
  type: TYPE_NORMAL
- en: Using sensible module names
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the previous section, we used the `audit2allow` command to generate a policy
    module named `localpolicy`. However, this name does not reveal what the purpose
    of the module is.
  prefs: []
  type: TYPE_NORMAL
- en: Once we create a (binary) policy (such as the `localpolicy.pp` file) and load
    it, it is not always clear to the administrators and users at first glance what
    this module is meant to accomplish. Although it is possible to unpack the `.pp`
    file (using `semodule_unpackage`) and then disassemble the resulting `.mod` file
    into a `.te` file, it requires software not available on most distributions (the
    `dismod` application, for instance, part of the `checkpolicy` software, is often
    not included). Considering that we just want to get insights into the rules that
    are part of a module, this is a very elaborate and time-intensive approach.
  prefs: []
  type: TYPE_NORMAL
- en: 'The content of a module can also be somewhat deduced from its CIL code. For
    instance, an active `screen` module will have its code available at `/var/lib/selinux/targeted/active/modules/100/screen`,
    in a file called `cil`. On some distributions, this file will be a compressed
    file, so you might need to unzip it before viewing:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: Still, having to dive into the rules to know what `localpolicy` is about is
    not only very cumbersome, but also requires sufficient privileges to be able to
    read these files.
  prefs: []
  type: TYPE_NORMAL
- en: Instead, it is a best practice to name the generated modules for their intended
    purposes. An SELinux policy that fixes a few AVC denials that come up when `su`
    executes from within the `staff_t` domain would be best named `custom_staff_su_faillog`,
    for instance.
  prefs: []
  type: TYPE_NORMAL
- en: 'It is also recommended to prefix (or suffix) the custom policies, so they can
    be more easily found:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: This identifies that the policy module has been added by the administrator (or
    organization) and is not sourced from the default Linux distribution's policy.
  prefs: []
  type: TYPE_NORMAL
- en: Generating reference policy style modules with audit2allow
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The reference policy project provides distributions and policy writers with
    a set of functions that simplify the development of SELinux policies. As an example,
    let''s see what the reference policy functions (called `su` situation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: The rule in the example is `auth_rw_faillog(staff_t)`. This is a reference policy
    macro that explains an SELinux rule (or set of rules) in a more human-readable
    way. In this case, it allows the `staff_t` domain to read/write on `faillog_t`
    labeled resources. The `faillog_t` type is part of the system authentication SELinux
    policy (as suggested by the `auth_` prefix, which identifies the source SELinux
    policy module).
  prefs: []
  type: TYPE_NORMAL
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: As `audit2allow -R` uses an automated approach for finding potential functions,
    we need to review the results carefully. Sometimes it selects a method that creates
    far more privileges for a domain than needed.
  prefs: []
  type: TYPE_NORMAL
- en: All major distributions base their SELinux policies upon the macros and content
    provided by the reference policy. The list of methods we can call while building
    SELinux policies is available on the local filesystem, at `/usr/share/doc/selinux-policy/html`.
  prefs: []
  type: TYPE_NORMAL
- en: These named methods bundle a set of rules related to the functionality that
    SELinux policy administrators want to enable. For instance, the `storage_read_tape()`
    method allows us to enhance an SELinux policy, providing a given domain with read
    access to tape storage devices.
  prefs: []
  type: TYPE_NORMAL
- en: Building reference policy - style modules
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If we generate an SELinux policy using reference policy macros but do not have
    access to the binary policy module anymore, then we need to build the policy before
    loading it. CIL-based policies can be loaded directly, which is why this book
    uses CIL as much as possible. However, given the wide use of the reference policy,
    knowing how to build these modules is important as well.
  prefs: []
  type: TYPE_NORMAL
- en: 'Suppose that the *reference policy*-based SELinux policy code resides in a
    file called `custom_staff_su_faillog.te`, then we can build it into a `.pp` file
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: Once built, we can load it using `semodule`. Every time we change the policy
    code (in the `.te` file) or other policy information (such as file context definitions
    in the `.fc` file), we need to rebuild the `.pp` file before we can load it.
  prefs: []
  type: TYPE_NORMAL
- en: Building legacy-style modules
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If we ask `audit2allow` to generate the policy rules without using reference
    policy style macros (which we call a *legacy-style* SELinux policy), then building
    the `.pp` file from it requires a different approach.
  prefs: []
  type: TYPE_NORMAL
- en: 'Suppose we have the `.te` file as generated by `audit2allow -M`, but not the
    `.pp` file, then we can generate it as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, create the `.mod` file using `checkmodule`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, generate the `.pp` file using `semodule_package`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The `audit2allow` command will automatically execute these commands, so this
    is only needed if the `.pp` file is no longer present, or when these more legacy-style
    SELinux policies are shared with you and you need to build and load them manually.
  prefs: []
  type: TYPE_NORMAL
- en: Replacing the default distribution policy
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When adding custom SELinux policies, all that users can do is to add more `allow`
    rules. SELinux does not have a deny rule that can be used to remove currently
    allowed access rules from the active policy.
  prefs: []
  type: TYPE_NORMAL
- en: If the current policy is too permissive for the administrator's liking, then
    the administrator will need to update the policy rather than just enhance it.
    That implies that the administrator has access to the current SELinux policy rules
    in use.
  prefs: []
  type: TYPE_NORMAL
- en: 'To replace an active SELinux policy, most Linux distributions allow you to
    get the source code of the policy. For instance, for RPM-based Linux distributions,
    the source RPM of the SELinux policy package can be downloaded and unpacked to
    gain access to the policy as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, find out what the current version of the SELinux policy is:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Next, try to obtain the source RPM shown in the output. Source RPMs can also
    be downloaded from third-party repositories. If the package is difficult to find,
    you can try to find it through [https://rpmfind.net](https://rpmfind.net).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Next, use the `rpmbuild` utility to extract the source RPM:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'When finished, the SELinux policy source code can be found inside `~/rpmbuild/SOURCES`
    and is probably named `selinux-policy-9c02e99.tar.gz` or similar, which you can
    extract further:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The policy files can now be safely copied over, manipulated at will, and built
    to replace the existing policy. If we load the updated SELinux policy module with
    the same (or higher) priority as the already loaded policy, it will take precedence
    in the policy.
  prefs: []
  type: TYPE_NORMAL
- en: Most distributions will also have their active SELinux policy available through
    an online source-controlled repository. For instance, the current SELinux policy
    for CentOS is available at [https://github.com/fedora-selinux/selinux-policy](https://github.com/fedora-selinux/selinux-policy).
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The SELinux policy can be adjusted by administrators, either through SELinux
    booleans as provided by the SELinux policy itself, or by loading new SELinux policy
    modules. These modules can be generated automatically, or built manually by the
    policy developers.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we've learned how to use SELinux booleans and how to query
    the active policy for the effects that the booleans will have on the system. We
    then learned how to use `semodule` to load and unload policies, or enable/disable
    modules on the system. We ended the chapter with information on how to generate
    and replace policies.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will extend our query of the SELinux policy beyond just
    booleans, and learn how to analyze policy behavior in detail using specialized
    tools.
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: How can we mark a boolean change as pending but not commit it yet?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Which command can be used to query the impact of a boolean?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Why can SELinux policy modules be loaded with different priorities?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How can denials be transformed into new SELinux policy modules?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
