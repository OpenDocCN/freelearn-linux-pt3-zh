- en: '8'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '8'
- en: Monitoring System Resources
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 监控系统资源
- en: In the last chapter, we learned how we can manage tasks that are running on
    our server. We now know how to see what’s running in the background, how to enable
    or disable a unit from starting at boot time, and also how to schedule tasks to
    run in the future. But in order for us to be able to effectively manage the tasks
    that our servers carry out, we also need to keep an eye on system resources. If
    we run out of RAM, fill up our disk, or overload our CPU, then a server that normally
    processes tasks very efficiently might come to a screeching halt. In this chapter,
    we’ll take a look at these resources and how to monitor them.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们学习了如何管理服务器上运行的任务。我们现在知道如何查看后台运行的任务，如何启用或禁用某个单元在启动时自动启动，以及如何安排任务在未来某个时间运行。但是，为了有效管理服务器执行的任务，我们还需要时刻关注系统资源。如果我们内存不足，磁盘已满，或者
    CPU 过载，那么本来高效处理任务的服务器可能会突然停滞。在这一章中，我们将探讨这些资源及如何监控它们。
- en: 'Our discussion on resource management will include:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 我们关于资源管理的讨论将包括：
- en: Viewing disk usage
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 查看磁盘使用情况
- en: Monitoring memory usage
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 监控内存使用情况
- en: Understanding load average
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解负载平均值
- en: Viewing resource usage with `htop`
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `htop` 查看资源使用情况
- en: One resource that is extremely important on our servers is storage, and keeping
    track of such things as available disk space is critical – even the most powerful
    server you can purchase would be unable to function without free disk space. We’ll
    take a look at some ways to monitor disk usage in the next section.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 我们服务器上的一个非常重要的资源是存储，跟踪可用磁盘空间等内容至关重要——即使是你能购买到的最强大服务器，也无法在没有空闲磁盘空间的情况下正常运行。我们将在下一节中探讨一些监控磁盘使用情况的方法。
- en: Viewing disk usage
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 查看磁盘使用情况
- en: Keeping an eye on your storage is always important, as no one enjoys getting
    a call in the middle of the night saying that a server encountered an issue, especially
    not something that could’ve been easily avoided, such as a filesystem growing
    too close to being full. Managing storage on Linux systems is simple once you
    master the related tools, the most useful of which I’ll go over in this section.
    In particular, we’ll look at tools we can use to answer the question “what’s using
    up all the disk space?”, which is the most common question that comes up when
    dealing with disk usage.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 时刻关注你的存储空间非常重要，因为没有人愿意在半夜接到电话，说服务器遇到了问题，尤其是那种本可以轻松避免的问题，例如文件系统空间即将满了。在 Linux
    系统上管理存储很简单，一旦你掌握了相关工具，这一过程就会变得容易。接下来我将介绍一些在这一节中最有用的工具，特别是我们将看看如何回答“是什么占用了所有磁盘空间？”这个问题，这是处理磁盘使用情况时最常遇到的问题。
- en: First, let’s look at the `df` command.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们来看一下 `df` 命令。
- en: Using df
  id: totrans-12
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 df
- en: 'The `df` command is likely always going to be your starting point in situations
    where you don’t already know which volume or mount point is becoming full. When
    executed, it gives you a high-level overview, so it’s not necessarily useful when
    you want to figure out who or what in particular is hogging all your space. However,
    when you just want to list all your mounted volumes and see how much space is
    left on each, `df` fits the bill. By default, it shows you the information in
    bytes. However, I find it easier to use the `-h` option with `df`, which will
    show output that’s more human-readable, and by doing so you’ll see information
    that’s a bit easier to read. Go ahead and give it a try:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: '`df` 命令通常会是你在不知道哪个卷或挂载点即将满时的起点。执行它后，它会给出一个高层次的概述，因此在你想弄清楚是谁或什么占用了所有空间时，它不一定会非常有用。然而，当你只想列出所有挂载的卷，并查看每个卷剩余的空间时，`df`
    是非常合适的。默认情况下，它会以字节为单位显示信息。不过，我发现使用 `df` 时加上 `-h` 选项更加方便，这样可以显示更具可读性的输出，读起来也更加轻松。试试看：'
- en: '[PRE0]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'This should produce an output that looks something like the following:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 这应该会生成类似以下内容的输出：
- en: '![](img/B18425_08_01.png)'
  id: totrans-16
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B18425_08_01.png)'
- en: 'Figure 8.1: Output from the df -h command'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.1：df -h 命令的输出
- en: The output will look different depending on the types of disks and mount points
    associated with your system. In the screenshot, you’ll see that the root filesystem
    is located on `/dev/mapper/ubuntu--vg-ubuntu--lv`. We know this because under
    the column `Mounted on` we see that the mount point is set to a single forward
    slash (`/`). As we discussed in *Chapter 4*, *Navigating and Essential Commands*,
    this single forward slash refers to the beginning of the filesystem (also referred
    to as the root filesystem). In my case, this is an LVM volume, which is why we
    have a device with such a long name, beginning with `/dev/mapper`. Let’s not worry
    about LVM at this point – we’ll discuss that later. But for now, just keep in
    mind that the single forward slash refers to the beginning of the filesystem,
    and the device name on the left refers to the actual device that’s mounted there.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 输出的结果会根据系统中与磁盘和挂载点相关联的类型有所不同。在截图中，你会看到根文件系统位于`/dev/mapper/ubuntu--vg-ubuntu--lv`。我们知道这一点是因为在“挂载点”这一列下，我们看到挂载点被设置为一个单一的正斜杠（`/`）。正如我们在*第4章*《*导航和基本命令*》中讨论的那样，这个单一的正斜杠表示文件系统的起始位置（也称为根文件系统）。在我的情况下，这是一个LVM卷，因此我们看到一个从`/dev/mapper`开始的长设备名称。现在不必担心LVM，我们稍后会讨论这个话题。不过目前，记住单一的正斜杠指的是文件系统的起点，左侧的设备名称则指的是实际挂载在那里设备的名称。
- en: The actual device name varies from one server to another and also varies depending
    on whether you chose to utilize LVM during installation. Instead of a long path
    beginning with `/dev/mapper`, you may instead see the device name as `/dev/sda1`,
    `/dev/xvda1`, `/dev/nvme0n1p1`, or other variations. The name of the device is
    generated by the type of hardware the underlying storage device is, such as the
    `/dev/nvme...` naming convention used for NVME hard drives, `/dev/sdaN` for standard
    SATA hard drives, and so on.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 实际设备名称因服务器不同而异，且也取决于你在安装过程中是否选择使用LVM。除了从`/dev/mapper`开始的长路径外，你可能会看到设备名称如`/dev/sda1`、`/dev/xvda1`、`/dev/nvme0n1p1`或其他变种。设备名称是根据底层存储设备的硬件类型生成的，例如用于NVME硬盘的`/dev/nvme...`命名约定，标准SATA硬盘则使用`/dev/sdaN`，依此类推。
- en: The actual type of device the underlying storage hardware is doesn’t matter
    so much; it only really matters that you can identify which device is in the most
    danger of becoming full. In the example screenshot, the root filesystem is using
    `35%` of its available space. In this case, we aren’t in danger of running out
    of space when it comes to that.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 实际底层存储硬件的设备类型并不那么重要；真正重要的是你能够识别出哪个设备最有可能变满。在示例截图中，根文件系统使用了`35%`的可用空间。在这种情况下，我们并不担心空间会被用完。
- en: If you do see that an important storage volume is either full or trending toward
    becoming full, then you’ll know which one in particular you should focus on, and
    we’ll explore additional ways that you can obtain more information about what’s
    using up space very shortly.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你确实发现某个重要的存储卷已满或接近满，那么你就能确定需要关注哪个卷，接下来我们会探索更多方法，帮助你获取有关哪些内容占用了空间的更多信息。
- en: However, sometimes a storage volume can be considered full, even when it appears
    that the volume has plenty of space free. This is due to the fact that on a Linux
    system, the actual data you’re storing and the size of that data isn’t the only
    consideration. We also have to take inodes into account as well.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，有时即使存储卷看似有足够的可用空间，它仍然可能被视为已满。这是因为在Linux系统中，存储的数据和数据的大小并不是唯一需要考虑的因素。我们还需要考虑inode。
- en: But, what exactly is an inode, and why would such a thing cause a disk to be
    reported as full when it’s actually not? Think of the concept of an inode as a
    type of *database object*, containing metadata for the actual items you’re storing.
    Information stored in inodes are details such as the owner of the file, permissions,
    last modified date, and type (whether it is a directory or a file). While metadata
    is certainly a good thing to have, the problem with inodes is that you can only
    have a limited number of them on any storage device. If a storage device reaches
    its inode limit, then the volume is still considered full, and will not be able
    to accept additional data.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，inode 究竟是什么？为什么这种东西会导致磁盘被报告为已满，实际上它并没有满呢？可以将 inode 看作一种*数据库对象*，它包含了你存储的实际项目的元数据。存储在
    inode 中的信息包括文件的所有者、权限、最后修改日期和类型（是目录还是文件）。尽管元数据有它的好处，但 inode 的问题在于，每个存储设备上可用的 inode
    数量是有限的。如果一个存储设备达到 inode 限制，那么该磁盘仍然被视为已满，无法接受更多数据。
- en: In practice, the symptom of this scenario is that commands such as `df` will
    show the volume as having free space, yet when you try to save a new file onto
    the device, you will see an error that you’re unable to do so because the volume
    is full. If you weren’t aware of the existence of inodes, then this situation
    might be a bit confusing.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，这种情况的症状是，像`df`这样的命令会显示磁盘有可用空间，但当你尝试将新文件保存到设备时，会看到一个错误，提示你无法保存，因为磁盘已满。如果你不了解
    inode 的存在，那么这种情况可能会让人感到困惑。
- en: While it may seem as though having another limit on storage in the form of inodes
    is a downside, in reality, the inode limit on storage volumes is usually extremely
    high and very hard to reach. Often, if an inode limit is reached, that usually
    means that there’s a bigger issue with the server that’s causing it to hit this
    limit. For example, perhaps there’s an issue on the server where it’s saving a
    much higher number of files than it should, such as an usual number of log files
    or queued e-mail message files.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管似乎有 inode 限制会给存储带来不便，实际上，存储卷上的 inode 限制通常非常高，并且很难达到。通常情况下，如果 inode 限制被触及，意味着服务器本身可能存在更大的问题，导致它达到这个限制。例如，可能是服务器存在问题，保存了比应有的更多文件，例如异常数量的日志文件或排队的电子邮件消息文件。
- en: 'Thankfully, determining whether or not you’re running out of inodes on a particular
    storage volume is very simple – rather than using the `-h` option with the `df`
    command, use the `-i` option instead. The `-i` option will display inode counts
    instead of standard size-based storage metrics. To help illustrate the difference,
    I’ll show you some output from one of my servers to give you an idea of what this
    looks like:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，确定特定存储卷是否快用完 inode 非常简单——与其使用`df`命令的`-h`选项，不如改用`-i`选项。`-i`选项将显示 inode 计数，而不是基于大小的存储度量。为了帮助说明这一点，我会展示一些来自我服务器的输出，帮助你了解这是什么样子的：
- en: '[PRE1]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The output of that command on my system is as follows:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 我系统上该命令的输出如下：
- en: '![](img/B18425_08_02.png)'
  id: totrans-29
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B18425_08_02.png)'
- en: 'Figure 8.2: Output from the df -i command'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.2：`df -i`命令的输出
- en: In this example, the root filesystem on the example server has a total of `999424`
    inodes available, of which `84223` are used and `915201` are free. In my case,
    I have plenty of inodes available. However, I recommend committing the `df -h`
    and `df -i` commands to memory. Whether any space issues with storage you may
    experience pertain to actual space or inode utilization, you’ll be able to know
    which is the case between those two commands.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，示例服务器上的根文件系统总共有`999424`个 inode，其中`84223`个已被使用，`915201`个是空闲的。在我的情况下，我有很多可用的
    inode。不过，我建议你把`df -h`和`df -i`命令记住。不论你遇到的存储空间问题是与实际空间还是 inode 使用相关，使用这两个命令就能知道具体是哪个问题。
- en: Assuming you have storage that’s on the verge of becoming full (or it already
    is), how do you pinpoint exactly what in particular is using up all that space?
    There are additional tools you can use that will help you narrow this down. And
    that’s exactly what we’ll explore next.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你有的存储快满了（或者已经满了），你该如何准确定位是哪个东西占用了所有空间呢？有一些额外的工具可以帮助你缩小范围。接下来我们就来探讨这一点。
- en: Diving deeper into disk usage
  id: totrans-33
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 深入了解磁盘使用情况
- en: The next step in investigating what’s gobbling up your disk space is finding
    out which files in particular are using it all up. At this stage, there is a multitude
    of tools you can use to investigate. The first I’ll mention is the `du` command,
    which is able to show you how much space a directory is using. Using `du` against
    directories and sub-directories will help you narrow down the problem. Like `df`,
    we can also use the `-h` option with `du` to make our output easier to read. By
    default, `du` will scan the current working directory your shell is attached to
    and give you a list of each item within the directory, the total space each item
    consists of, as well as a summary at the end.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 调查占用你磁盘空间的具体文件的下一步是找出哪些文件特别占用了这些空间。在这个阶段，你可以使用多种工具来进行调查。我要提到的第一个工具是`du`命令，它能够显示一个目录占用了多少空间。使用`du`命令对目录和子目录进行扫描将帮助你缩小问题范围。像`df`一样，我们也可以与`du`命令一起使用`-h`选项，以使输出更容易阅读。默认情况下，`du`会扫描当前shell附加的工作目录，并列出该目录中的每一项，显示每项所占用的总空间，并在最后给出总结。
- en: 'The `du` command is only able to scan directories that its calling user has
    permission to scan. If you run this as a non-root user, then you may not be getting
    the full picture. Also, the more files and sub-directories that are within your
    current working directory, the longer this command will take to execute. If you
    have an idea where the resource hog might be, try to `cd` into a directory further
    in the filesystem tree to narrow your search down and reduce the amount of time
    the command will take. The output of `du -h` can often be more verbose than you
    actually need in order to pinpoint your culprit and can fill several screens.
    To simplify it, my favorite variation of this command is the following:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: '`du`命令只能扫描调用该命令的用户有权限访问的目录。如果你以非root用户身份运行该命令，可能无法获取完整的信息。此外，当前工作目录中的文件和子目录越多，执行此命令的时间也会越长。如果你大致知道资源占用的地方在哪里，可以尝试`cd`进入文件系统树中更深的目录，缩小搜索范围，从而减少命令执行的时间。`du
    -h`的输出通常会比实际需要的更多，可能需要多个屏幕才能查看完。为了简化这一过程，我最喜欢的命令变体是：'
- en: '[PRE2]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Basically, you would run `du -hsc *` within a directory that’s as close as
    possible to where you think the problem is. The `-h` option, as we know, gives
    us human-readable output (essentially, giving us output in the form of megabytes,
    gigabytes, and so on). The `-s` option gives us a summary and `-c` provides us
    with the total amount of space used within our current working directory. The
    following screenshot shows this output from one of my computers:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 基本上，你需要在尽可能接近问题所在的目录中运行`du -hsc *`。正如我们所知道的，`-h`选项会让输出结果更易读（基本上是以兆字节、千兆字节等形式呈现）。`-s`选项会提供一个总结，而`-c`则会显示当前工作目录中所使用的总空间。下面的截图显示了我电脑中的输出结果：
- en: '![](img/B18425_08_03.png)'
  id: totrans-38
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B18425_08_03.png)'
- en: 'Figure 8.3: Example output from du -hsc *'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.3：`du -hsc *`命令的示例输出
- en: To make that example more interesting, I took the screenshot from my personal
    desktop, but the resulting command and its syntax won’t differ from one device
    to the next. As you can see, the information provided by `du -hsc *` is a nice,
    concise summary. From the output, we can clearly see how much space each of the
    directories within our working directory takes currently. For example, I have
    2.2 GB used in my `projects` directory right now, as well as 53 GB worth of ISO
    images.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 为了让这个示例更有趣，我从我的个人桌面上截图，但无论使用哪个设备，最终的命令和语法是一样的。如你所见，`du -hsc *`提供的信息是一个简洁的总结。从输出中，我们可以清楚地看到当前工作目录中的每个子目录占用了多少空间。例如，我的`projects`目录当前占用了2.2GB的空间，而ISO镜像文件占用了53GB的空间。
- en: At this point, we know which directories at the top level of our current working
    directories are using the most space. But we still need to narrow this down to
    *what* in particular within those directories is responsible for using that space.
    To dive deeper, we could `cd` into any of those large directories and run the
    `du` command again. After a few runs, we should be able to narrow down the largest
    files within these directories and make a decision on what we want to do with
    them. Perhaps we can clean unnecessary files or add another disk. Once we know
    what is using up our space, we can decide what we’re going to do about it.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 到这一步，我们已经知道当前工作目录顶部的哪些目录占用了最多的空间。但我们仍然需要缩小范围，查找这些目录中究竟是 *哪些* 项目在占用这些空间。为了深入分析，我们可以
    `cd` 进入这些大目录中的任何一个，再次运行 `du` 命令。经过几次操作后，我们应该能够缩小到这些目录中最大的文件，并决定如何处理它们。也许我们可以清理不必要的文件，或者添加另一个磁盘。一旦知道了是什么占用了我们的空间，我们就可以决定如何处理。
- en: At this point in reading this book, you’re probably under the impression that
    I have some sort of strange fixation on saving the best for last. You’d be right.
    I’d like to finish off this section by introducing you to one of my favorite applications,
    the **NCurses Disk Usage** utility (or more simply, `ncdu`). The `ncdu` command
    is one of those things that administrators who constantly find themselves dealing
    with disk space issues learn to love and appreciate. In one go, this command gives
    you not only a summary of what is eating up all your space but also gives you
    the ability to traverse the results without having to run a command over and over
    while manually traversing your directory tree. You simply execute it once and
    then you can navigate the results and drill down as far as you need.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 在阅读到本书的这一部分时，你可能已经认为我有一种奇怪的习惯，总是喜欢把最好的留到最后。你猜对了。我想通过介绍我最喜欢的应用之一来结束这一节，那就是 **NCurses
    磁盘使用情况** 工具（简称 `ncdu`）。`ncdu` 命令是那些经常处理磁盘空间问题的管理员学会喜爱和欣赏的工具之一。通过一次执行，这个命令不仅能给你提供占用空间的概览，还能让你在无需反复运行命令和手动浏览目录树的情况下，浏览并深入查看结果。你只需执行一次，然后可以导航结果，深入挖掘直到你需要的程度。
- en: 'To use `ncdu`, you will need to install it as it doesn’t come with Ubuntu by
    default:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用 `ncdu`，你需要安装它，因为它默认不随 Ubuntu 提供：
- en: '[PRE3]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Once installed, simply execute `ncdu` in your shell from any starting directory
    of your choosing. When done, simply press *q* on your keyboard to quit. Like `du`,
    `ncdu` is only able to scan directories that the calling user has access to. You
    may need to run it as `root` to get an accurate portrayal of your disk usage.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 安装完成后，只需在你选择的任何起始目录中执行 `ncdu`。完成后，只需按 *q* 键退出。像 `du` 一样，`ncdu` 只能扫描调用用户有权限访问的目录。你可能需要以
    `root` 身份运行它，以获得准确的磁盘使用情况。
- en: You may want to consider using the `-x` option with `ncdu`. This option will
    limit it to the current filesystem, meaning it won’t scan network mounts or additional
    storage devices; it’ll just focus on the device you started the scan on. This
    can save you from wasting time scanning areas that aren’t related to your issue.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能想考虑在使用 `ncdu` 时添加 `-x` 选项。此选项会将扫描限制在当前文件系统内，这意味着它不会扫描网络挂载点或其他存储设备；它只会关注你开始扫描的设备。这可以避免你浪费时间扫描与问题无关的区域。
- en: 'When executed, `ncdu` will scan every directory from its starting point onward.
    When finished, it will give you a menu-driven layout allowing you to browse through
    your results:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 执行时，`ncdu` 将从其起始位置开始扫描每个目录。完成后，它会提供一个基于菜单的布局，允许你浏览结果：
- en: '![](img/B18425_08_04.png)'
  id: totrans-48
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B18425_08_04.png)'
- en: 'Figure 8.4: ncdu in action'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.4：`ncdu` 实时展示
- en: Again, I took this screenshot from my desktop, from within my `home` directory.
    What `ncdu` does is show you your disk usage from your current directory down,
    and it will order the results by placing the items with the highest usage toward
    the top. To move around inside of `ncdu`, you do so by moving your selection (indicated
    with a long white highlight) with the up and down arrows on your keyboard.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 再次说明，我从我的桌面截图中获取了这张图，截图的目录是在我的 `home` 目录中。`ncdu` 的作用是展示从当前目录开始的磁盘使用情况，并且它会按使用空间从高到低排列结果。在
    `ncdu` 内部移动时，你可以通过键盘上的上下箭头来移动你的选择（长白色高亮显示）。
- en: If you press *Enter* on a directory, `ncdu` switches to showing you the summary
    of that directory, and you can continue to drill down as far as you need. In fact,
    you can actually delete items and entire folders by pressing *d*. Therefore, `ncdu`
    not only allows you to find what is using up your space but allows you to take
    action as well!
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在目录上按下*Enter*，`ncdu`将切换到显示该目录的摘要，你可以根据需要继续深入查看。实际上，你还可以按*d*删除项目和整个文件夹。因此，`ncdu`不仅允许你找出占用空间的内容，还允许你采取行动！
- en: Sometimes, it’s obvious what’s taking up space on a disk, and `ncdu` may not
    always be necessary. Generally speaking, you’ll start out your investigation with
    `df -h`, to see which storage volume is the one that’s running out of space. Then,
    you’ll go into that directory and run another command, such as `du -hsc *`, to
    see which directory is using up the most space. If you don’t immediately know
    from the output of `du` what the underlying issue is, then consider using a tool
    such as `ncdu` to dive down even deeper.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 有时候，磁盘上占用空间的内容很明显，`ncdu`可能并不总是必要的。一般来说，你会通过`df -h`开始调查，查看哪个存储卷空间不足。然后，你进入该目录并执行另一个命令，如`du
    -hsc *`，以查看哪个目录占用了最多的空间。如果从`du`的输出中无法立即识别问题所在，那么可以考虑使用像`ncdu`这样的工具，进一步深入查找。
- en: Although monitoring storage is critical, we also need to keep an eye on free
    memory. Next up, we’ll take a look at how to monitor the memory of our server.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管监控存储至关重要，我们还需要时刻关注空闲内存。接下来，我们将看看如何监控我们服务器的内存。
- en: Monitoring memory usage
  id: totrans-54
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 内存使用情况监控
- en: I forget things all the time. I regularly forget where my car keys are, even
    though they’re almost always right there in my pocket the entire time. I even
    forget to use `sudo` for commands that normally require it, despite working with
    Linux for over 20 years. Thankfully, computers have a better memory than I do,
    but if we don’t manage it effectively, the memory on our servers will be just
    as useless as I am when I forget to put freshly washed laundry in the dryer.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 我经常忘记事情。即便车钥匙几乎总是就在我的口袋里，我也经常忘记它们在哪里。即使已经使用Linux超过20年，我还是经常忘记在需要时使用`sudo`命令。幸运的是，计算机的记忆比我强大，但如果我们不有效地管理它，我们服务器上的内存就像我忘记把刚洗完的衣服放进干衣机一样，毫无用处。
- en: Understanding how Linux manages memory can actually be a somewhat complex topic,
    as understanding how much memory is truly free can be a hurdle for newcomers to
    overcome. You’ll soon see that how Linux manages memory on your server is actually
    fairly straightforward once explained.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 了解Linux如何管理内存实际上是一个相对复杂的话题，因为对于初学者来说，理解内存到底有多少是空闲的，可能会是一个难以克服的障碍。你会很快发现，一旦解释清楚，Linux如何管理你服务器的内存其实是相当简单的。
- en: Understanding server memory
  id: totrans-57
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 了解服务器内存
- en: 'For the purpose of monitoring memory usage on our server, we have the `free`
    command at our disposal, which we can use to see how much memory is being consumed
    at any given time. Giving the `free` command with no options will result in the
    output being shown in terms of kilobytes:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 为了监控我们服务器的内存使用情况，我们可以使用`free`命令，这个命令可以让我们查看在任何给定时刻内存的消耗情况。若不带任何选项地执行`free`命令，输出将以千字节为单位显示：
- en: '![](img/B18425_08_05.png)'
  id: totrans-59
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B18425_08_05.png)'
- en: 'Figure 8.5: Output of the free command'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.5：`free`命令的输出结果
- en: 'My favorite variation of this command is `free -m`, which shows the amount
    of memory in use in terms of megabytes. You can also use `free g` to show the
    output in terms of gigabytes, but the output won’t be precise enough on most servers.
    In my opinion, adding the `-m` option makes the `free` command much more readable:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 我最喜欢的这个命令的变种是`free -m`，它以兆字节为单位显示内存的使用量。你也可以使用`free g`以吉字节为单位显示输出，但在大多数服务器上，输出的精度不足。依我看，添加`-m`选项能让`free`命令的输出更易于阅读：
- en: '![](img/B18425_08_06.png)'
  id: totrans-62
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B18425_08_06.png)'
- en: 'Figure 8.6: Output of the free -m command'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.6：`free -m`命令的输出结果
- en: Since everything is broken down into megabytes, it’s much easier to read, at
    least for me.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 由于一切都以兆字节为单位显示，对我来说，阅读起来要容易得多。
- en: At first glance, it may appear as though this server has only `277` MB free.
    You’ll see this in the first row and third column under `free`. In actuality,
    the number you’ll really want to pay attention to is the number under `available`,
    which is `2943` MB in this case. That’s now much memory is actually free. Since
    this server has `3925` MB of total RAM available (you’ll see this on the first
    row, under `total`), this means that most of the RAM is free, and this server
    is not really working that hard at all.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 刚开始看，可能会觉得这个服务器只有`277` MB的空闲内存。你会在第一行和第三列的`free`下看到这个数值。实际上，你真正需要关注的数字是`available`列下的数字，这里是`2943`
    MB。那才是实际可用的内存。因为这个服务器总共有`3925` MB的RAM（你会在第一行的`total`下看到），这意味着大部分内存是空闲的，这台服务器其实并没有在高负荷运行。
- en: Some additional explanation is necessary to truly understand these numbers.
    You could very well stop reading this section right now as long as you take away
    from it that the `available` column represents how much memory is free for your
    applications to use. However, it’s not quite that simple.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 若要真正理解这些数字，需要一些额外的解释。你完全可以在此时停止阅读这一部分，只要记住`available`列表示的是应用程序可以使用的空闲内存量即可。不过，事情并没有那么简单。
- en: Technically, when you look at my output, the server really does have only `277`
    MB of memory free. The amount of memory listed under `available` is legitimately
    being used by the system in the form of a cache but would be freed up in the event
    that any application needed to use it. If an application starts and needs a decent
    chunk of memory in order to run, the kernel will provide it with some memory from
    this cache.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 从技术上讲，当你查看我的输出时，服务器实际上只有`277` MB的空闲内存。`available`列下列出的内存量实际上是被系统用作缓存的，但如果任何应用程序需要它，它将被释放。如果一个应用程序启动并需要较大内存来运行，内核会从这个缓存中提供一些内存。
- en: Linux, like most modern systems, subscribes to the belief that “unused RAM is
    wasted RAM.” RAM that isn’t being used by any process is given to what is known
    as a **filesystem cache**, which is utilized to make your server run more efficiently.
    When data needs to be written to a storage device, it’s not directly written right
    away. Instead, this data is written to the filesystem cache (a portion of RAM
    that’s set aside) and then synchronized to the storage device later in the background.
    The reason this makes your server more efficient is that this data being stored
    in RAM would be written to and retrieved faster than it would be from disk. Applications
    and services can synchronize data to the disk in the background without forcing
    you to wait for it. This cache also works for reading data, as when you first
    open a file, its contents are cached. The system will then retrieve it from RAM
    if you read the same file again, which is more efficient than loading it from
    the storage volume each time. If you just recently saved a new file and retrieve
    it right away, it’s likely still in the cache and then retrieved from there, rather
    than from the disk directly.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: Linux与大多数现代系统一样，遵循“未使用的RAM就是浪费的RAM”这一理念。未被任何进程使用的RAM会分配给所谓的**文件系统缓存**，用于提高服务器的运行效率。当数据需要写入存储设备时，并不会直接立即写入。相反，这些数据会先写入文件系统缓存（一个预留的RAM部分），然后在后台同步到存储设备。这样做使得服务器更高效的原因在于，存储在RAM中的数据相较于从硬盘读取，要写入和读取得更快。应用程序和服务可以在后台同步数据到硬盘，而不需要你等待。此外，这个缓存也适用于读取数据，比如当你第一次打开一个文件时，它的内容会被缓存。如果你再次读取该文件，系统会从RAM中获取，而不是每次都从存储设备加载。若你刚保存了一个新文件并立即访问它，很可能它仍然在缓存中，会从缓存中提取，而不是直接从硬盘读取。
- en: 'To understand all of the columns shown in *Figure 8.6*, I’ll outline the meaning
    of each in the following table:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 为了理解*图8.6*中显示的所有列，我将在下表中列出每列的含义：
- en: '| **Column** | **Meaning** |'
  id: totrans-70
  prefs: []
  type: TYPE_TB
  zh: '| **列** | **含义** |'
- en: '| `total` | The total amount of memory installed on the server. |'
  id: totrans-71
  prefs: []
  type: TYPE_TB
  zh: '| `total` | 服务器上安装的总内存量。 |'
- en: '| `used` | The memory that is used (from any source). This is calculated as
    follows: *used = total - free - buffers/cache*. |'
  id: totrans-72
  prefs: []
  type: TYPE_TB
  zh: '| `used` | 使用的内存（来自任何来源）。计算方法如下：*used = total - free - buffers/cache*。|'
- en: '| `free` | The memory not being used by anything, the cache or otherwise. |'
  id: totrans-73
  prefs: []
  type: TYPE_TB
  zh: '| `free` | 没有被任何东西使用的内存，无论是缓存还是其他。 |'
- en: '| `shared` | The memory used by `tmpfs` as well as other shared resources.
    |'
  id: totrans-74
  prefs: []
  type: TYPE_TB
  zh: '| `shared` | `tmpfs`以及其他共享资源使用的内存。 |'
- en: '| `buff`/`cache` | The amount of memory being used by the buffers and cache.
    |'
  id: totrans-75
  prefs: []
  type: TYPE_TB
  zh: '| `buff`/`cache` | 用于缓冲区和缓存的内存量。 |'
- en: '| `available` | The memory that is free for applications to use. |'
  id: totrans-76
  prefs: []
  type: TYPE_TB
  zh: '| `available` | 应用程序可以使用的空闲内存。 |'
- en: You may have noticed in *Figure 8.6* that memory usage is also listed for a
    resource called `swap`. Let’s take a look at that as well. We will dedicate the
    next section entirely to it so that we ensure we understand what it is, and what
    it does for us.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能已经注意到在 *图 8.6* 中，还列出了一个名为 `swap` 的资源的内存使用情况。我们也来看看这个。我们将专门为它保留下一节，以确保我们理解它是什么，以及它对我们有什么作用。
- en: Managing swap
  id: totrans-78
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 管理 `swap`
- en: '`swap` is one of those things we never want to use, but always want to make
    sure it is available. It’s kind of like car insurance, no one is excited to buy
    it, but we do want to have it in case something bad happens. There’s even some
    debate between administrators on whether or not `swap` is still relevant today.
    It’s definitely relevant, regardless of what anyone says, as it’s a safety net
    of sorts. (And disk space is cheaper nowadays, so dedicating some of our storage
    to this task isn’t really a big deal, so we may as well.)'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: '`swap` 是我们从不想要使用的东西之一，但总是希望确保它是可用的。这有点像汽车保险，没有人会为购买它感到兴奋，但如果发生不好的事情，我们确实希望有它。甚至在管理员之间，关于
    `swap` 在今天是否仍然相关还存在一些争论。无论别人怎么说，它绝对是相关的，因为它就像一种安全网。（而且现在磁盘空间更便宜了，所以将一些存储空间专门用于这项任务真的不是什么大问题，所以我们也可以这样做。）'
- en: So what is it? `swap` is basically a partition or a file that acts as RAM in
    situations where your server’s memory is saturated. If we manage a server properly,
    we hope to never need it, as `swap` is stored on your hard disk, which is orders
    of magnitude slower than RAM. But if something goes wrong on your server and your
    memory usage skyrockets, `swap` may save you from having your server go down.
    The **Out of Memory** (**OOM**) **Killer** may also activate itself when memory
    is full, to kill a misbehaving process that’s using the majority of your memory,
    but as much as possible, we don’t want to rely on that and instead ensure adequate
    `swap` in case memory is exhausted.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 那么它是什么？ `swap` 基本上是一个在服务器内存饱和时充当 RAM 的分区或文件。如果我们正确管理服务器，希望永远不需要它，因为 `swap` 存储在硬盘上，比
    RAM 慢几个数量级。但是，如果服务器出现问题，内存使用量飙升，`swap` 可能会防止服务器崩溃。当内存满时，**内存不足杀手**（OOM Killer）也可能自动激活，以终止使用大部分内存的行为不端进程，但我们尽可能不希望依赖它，而是确保有足够的
    `swap` 以防内存耗尽。
- en: The way `swap` is implemented by default in Ubuntu is in the form of a `swap`
    file. In previous versions of Ubuntu (specifically, 16.04 and earlier) it was
    implemented via a `swap` partition instead. In fact, if you have an existing server
    that you’ve upgraded to Ubuntu 22.04 and it started on an older Ubuntu version,
    you may still have a `swap` partition, even though you’re running the latest release.
    New installations of Ubuntu performed after 16.04 will have a `swap` file.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Ubuntu 中，默认实现 `swap` 的方式是通过一个 `swap` 文件。在早期版本的 Ubuntu（具体来说是 16.04 及之前的版本），它是通过一个
    `swap` 分区实现的。事实上，如果你有一个已经升级到 Ubuntu 22.04 的现有服务器，并且它在旧版 Ubuntu 上启动过，你可能仍然有一个 `swap`
    分区，即使你正在运行最新的发布版。在 16.04 之后进行的新安装的 Ubuntu 将使用 `swap` 文件。
- en: Is having a `swap` file better than a `swap` partition? I would say yes, it’s
    preferred – although you won’t notice any difference when it comes to performance.
    Whether `swap` on your server is in the form of a `swap` file or partition, it
    doesn’t change the fact that `swap` uses your disk and is slower than RAM. One
    benefit of a `swap` file compared to a `swap` partition is that it’s easier to
    grow or shrink a `swap` file than it is to do the same with a `swap` partition.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `swap` 文件比使用 `swap` 分区好吗？我会说是的，它更受欢迎 - 尽管在性能方面你不会注意到任何差异。无论在服务器上 `swap` 是以
    `swap` 文件还是分区的形式，它都不改变 `swap` 使用硬盘且比 RAM 慢的事实。与 `swap` 分区相比，`swap` 文件的一个好处是，它比
    `swap` 分区更容易扩展或收缩。
- en: Anyway, considering that `swap` files are the preferred method (and the new
    default) going forward, I won’t cover the process of creating `swap` as a partition,
    as there’s no reason to do so anymore.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 总之，考虑到 `swap` 文件是未来首选的方法（并且是新的默认设置），我不会再覆盖创建 `swap` 分区的过程，因为没有必要再这样做了。
- en: 'The `swap` file for your server is declared in the `/etc/fstab` file (we’ll
    discuss the `/etc/fstab` file in more detail in *Chapter 9*, *Managing Storage
    Volumes*). In most cases, you would’ve had a `swap` file created for you during
    installation. You could, of course, add a `swap` file later if for some reason
    you don’t have one. In the case of some cloud instance providers, you may not
    get a `swap` file by default. In that situation, you would create a `swap` file
    yourself (we’ll discuss the process later in this section) and then use the `swapon`
    command to activate it:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 你的服务器的`swap`文件在`/etc/fstab`文件中声明（我们将在*第9章*，*管理存储卷*中更详细地讨论`/etc/fstab`文件）。在大多数情况下，你在安装过程中已经为你创建了`swap`文件。当然，如果出于某种原因你没有`swap`文件，你可以稍后添加一个。在一些云实例提供商的情况下，默认情况下你可能不会获得`swap`文件。在这种情况下，你需要自己创建一个`swap`文件（我们将在本节稍后讨论这个过程），然后使用`swapon`命令来激活它：
- en: '[PRE4]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: When run, the `swapon -a` command will find your `swap` file in `/etc/fstab`
    (if one is listed there), mount it, and activate it for use. The inverse of this
    command is `swapoff -a`, which deactivates your `swap` file. It’s rare that you’d
    need to disable `swap`, unless, of course, you were planning on deleting your
    `swap` file in order to create a larger one. If you find out that your server
    has inadequate `swap`, that may be a course of action you would take.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 当运行`swapon -a`命令时，它会在`/etc/fstab`中找到你的`swap`文件（如果那里列出了它），挂载并激活它供使用。这个命令的反向操作是`swapoff
    -a`，它会停用你的`swap`文件。除非你计划删除`swap`文件并创建一个更大的文件，否则通常不需要禁用`swap`。如果你发现服务器的`swap`不足，可能需要采取这种操作。
- en: While having `swap` is generally a good idea, there are actually some applications
    that prefer that the server doesn’t have it at all. Not having `swap` isn’t a
    common requirement, but Kubernetes is a good example of a situation that might
    lead you to disabling `swap` altogether. In fact, the installation process for
    Kubernetes will complain (or possibly fail) if you do have `swap` enabled. In
    the case of a Kubernetes cluster, the individual servers within such a cluster
    would be a special case anyway, each dedicated to the task of running containers
    (which is what Kubernetes does; more on that in *Chapter 18*, *Container Orchestration*).
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然有`swap`通常是一个好主意，但实际上有些应用程序更倾向于服务器完全没有`swap`。没有`swap`并不是一个常见的要求，但Kubernetes就是一个可能需要完全禁用`swap`的情况的好例子。事实上，如果你启用了`swap`，Kubernetes的安装过程可能会报错（或者可能会失败）。对于Kubernetes集群来说，集群内的每个单独服务器本身就是一个特殊的情况，每个服务器都专门用于运行容器（这正是Kubernetes的功能；更多内容将在*第18章*，*容器编排*中介绍）。
- en: 'When you check your free memory (hint: execute `free -m`), you’ll see `swap`
    listed whether you have it or not, but when `swap` is deactivated, you will see
    all zeros for the size totals.'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 当你检查空闲内存时（提示：执行`free -m`），无论你是否有`swap`，都会看到`swap`被列出，但当`swap`被停用时，你会看到所有大小总计为零。
- en: 'So, how do you actually create a `swap` file if you wish to use it and you
    don’t already have one? To do so, you’ll first create the actual file to be used
    as `swap`. This can be stored anywhere, but `/swapfile` is typically ideal. You
    can use the `fallocate` command to create the actual file. The `fallocate` command
    will force a file to be a particular size:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，如果你希望使用`swap`并且当前没有`swap`文件，应该如何创建一个呢？首先，你需要创建一个实际的文件来用作`swap`。它可以存储在任何地方，但通常`/swapfile`是理想的选择。你可以使用`fallocate`命令来创建这个实际的文件。`fallocate`命令会强制文件为特定大小：
- en: '[PRE5]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Here, I’m creating a 4 GB `swap` file, but feel free to make yours whatever
    size you want in order to fit your needs. Next, we need to prepare this file to
    be used as `swap`. First, we’ll need to fix the permissions as we need this file
    to be a bit more restrictive than most:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我正在创建一个4 GB的`swap`文件，但你可以根据需要设置任何大小，以满足你的需求。接下来，我们需要准备这个文件以便用作`swap`。首先，我们需要修复文件的权限，因为我们需要这个文件比大多数文件更具限制性：
- en: '[PRE6]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Then, we can use the `mkswap` command to convert this file into an actual `swap`
    file:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们可以使用`mkswap`命令将此文件转换为实际的`swap`文件：
- en: '[PRE7]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Now, we have a handy-dandy `swap` file stored on our root filesystem. Next,
    we’ll need to mount it. As always, it’s recommended that we add this to our `/etc/fstab`
    file. What follows is an example entry:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们已经在根文件系统上存储了一个方便的`swap`文件。接下来，我们需要挂载它。像往常一样，推荐将其添加到`/etc/fstab`文件中。以下是一个示例条目：
- en: '[PRE8]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'From this point, we can activate our new `swap` file with the `swapon` command
    that I mentioned earlier:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 从这一点开始，我们可以通过之前提到的`swapon`命令来激活新的`swap`文件：
- en: '[PRE9]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: After running that command, the `swap` file should be active and in use. You
    can verify this by running `free -m` and seeing a `swap` file listed, with a size
    greater than 0\. While I certainly hope you won’t need to resort to using `swap`,
    I know from experience that it’s only a matter of time. Knowing how to add and
    activate `swap` when you need it is definitely a good practice, but for the most
    part, you should be fine because, by default on most platforms, you’ll have `swap`
    created for you when setting up Ubuntu for the first time during installation.
    If you do need to create it manually for whatever reason, I always recommend a
    bare minimum of 2 GB on servers, or higher if that better fits your use-case.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 运行该命令后，`swap`文件应该已激活并正在使用。您可以通过运行`free -m`命令，查看是否列出了`swap`文件，并且其大小大于0来验证这一点。尽管我真心希望您不需要使用`swap`，但根据我的经验，这只是时间问题。了解在需要时如何添加并激活`swap`绝对是一个好习惯，不过大多数情况下，您应该没问题，因为在大多数平台上，首次安装Ubuntu时，`swap`会自动创建。如果您出于某种原因需要手动创建`swap`，我总是建议在服务器上至少设置2GB，或者根据您的使用情况适当增加。
- en: How much `swap` is being used is something you should definitely keep an eye
    on. When the memory starts to get full, the server will start to utilize the `swap`
    file. It’s normal for a small portion of `swap` to be utilized even when the majority
    of the RAM is free. But if a decent chunk of `swap` is being used, it should be
    investigated (perhaps a process is using a larger than normal amount of memory).
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 您应当密切关注`swap`的使用情况。当内存开始接近满时，服务器会开始使用`swap`文件。即使大部分RAM空闲，`swap`也会被部分使用，这很正常。但如果大量`swap`被使用，就应该调查一下（可能某个进程使用了比平常更多的内存）。
- en: 'You can actually control at which point your server will begin to utilize `swap`.
    How frequently a Linux server utilizes `swap` is referred to as its `swappiness`.
    By default, the `swappiness` value on a Linux server is typically set to `60`.
    You can verify this with the following command:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，您可以控制服务器何时开始使用`swap`。Linux服务器使用`swap`的频率被称为其`swappiness`。默认情况下，Linux服务器的`swappiness`值通常设置为`60`。您可以通过以下命令验证这一点：
- en: '[PRE10]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The higher the `swappiness` value, the more likely your server will utilize
    `swap`. If the `swappiness` value is set to `100`, your server will use `swap`
    more often. If you set it to `0`, `swap` will be used a lot less often. This value
    correlates roughly to the percentage of RAM being used.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: '`swappiness`值越高，服务器越有可能使用`swap`。如果将`swappiness`值设置为`100`，服务器会更频繁地使用`swap`；如果将其设置为`0`，则会很少使用`swap`。该值大致与使用的RAM百分比相关。'
- en: 'To change this value on the fly, you can execute the following command:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 要实时更改此值，您可以执行以下命令：
- en: '[PRE11]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Once you execute that command, the change in the `swappiness` value will take
    effect immediately. However, once you reboot your server, the value will reset.
    In order to make the change persist, open the following file with your text editor
    of choice:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 执行该命令后，`swappiness`值的更改将立即生效。然而，一旦重启服务器，该值将恢复默认。为了使更改保持生效，请使用您选择的文本编辑器打开以下文件：
- en: '[PRE12]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'A line in that file corresponding to `swappiness` will typically not be included
    by default, but you can add it manually. To do so, add a line such as the following
    to the end of the file and save it:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 在该文件中，通常不会默认包含与`swappiness`对应的行，但您可以手动添加。为此，请在文件末尾添加类似以下内容的行并保存：
- en: '[PRE13]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Changing this value is one of many techniques within the realm of performance
    tuning. While the default value of `60` is probably fine for most, there may be
    a situation where you’re running a performance-minded application and can’t afford
    to have it `swap` any more than it absolutely has to. In such a situation, you
    would try different values for `swappiness` and use whichever one works best during
    your performance tests.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 更改此值是性能调优领域中的多种技术之一。虽然默认值`60`对大多数情况可能足够，但可能会遇到运行性能密集型应用程序的情况，在这种情况下，您无法承受过度使用`swap`。在这种情况下，您可以尝试不同的`swappiness`值，并在性能测试中使用最适合的值。
- en: 'In the next section, we’ll take a look at another important metric to keep
    an eye on: load average. The load average gives us an idea of how busy the CPU(s)
    might be, so we can better understand how to tell when our server is overwhelmed
    and we may need to take action.'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一部分中，我们将关注另一个重要的指标：负载平均值。负载平均值可以帮助我们了解CPU的忙碌程度，从而更好地判断何时服务器过载，可能需要采取措施。
- en: Understanding load average
  id: totrans-112
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解负载平均值
- en: 'Another very important topic to understand when monitoring performance is **load
    average**, which is a series of numbers that represents your server’s trend in
    CPU utilization over a given time. You’ve probably already seen these series of
    numbers before, as there are several places in which the load average appears.
    If you run the `htop` utility, for example, the load average is shown on the screen.
    In addition, if you execute the `uptime` command, you can see the load average
    in the output of that command as well. You can also view your load average by
    viewing the text file that stores it in the first place:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个在监控性能时需要理解的非常重要的话题是**负载平均值**，它是一系列数字，表示服务器在特定时间段内CPU使用率的趋势。你可能已经见过这些数字，因为负载平均值会出现在多个地方。例如，如果你运行`htop`工具，屏幕上会显示负载平均值。此外，如果你执行`uptime`命令，你也可以在该命令的输出中看到负载平均值。你还可以通过查看存储负载平均值的文本文件来查看它：
- en: '[PRE14]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Personally, I habitually use the `uptime` command in order to view the load
    average. The primary purpose of the `uptime` command is to display the amount
    of time that the server has been in use, and this time resets anytime you power
    off or reboot the server. But in addition to how long the server has been powered
    on, the `uptime` command displays the current load average of your server as well.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 就个人而言，我习惯使用`uptime`命令来查看负载平均值。`uptime`命令的主要功能是显示服务器运行的时间，并且每次你关机或重启服务器时，时间会重置。但是，除了显示服务器开机的时长，`uptime`命令还会显示当前服务器的负载平均值。
- en: 'Understanding load average might be a bit confusing at first, but you’ll quickly
    realize it’s not as complicated as it seems. The load average is a set of three
    numbers, each corresponding to a portion of time. From left to right, these numbers
    correspond to 1 minute, 5 minutes, and 15 minutes respectively. A typical load
    average may look something like the following:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 理解负载平均值一开始可能有点困惑，但你很快就会意识到它并不像看起来那么复杂。负载平均值是一组三个数字，每个数字对应一个时间段。从左到右，这些数字分别对应1分钟、5分钟和15分钟。一个典型的负载平均值可能是以下这样的：
- en: '[PRE15]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: In this example, we have a load average of `0.36` in the 1-minute section, `0.29`
    in the 5-minute section, and `0.31` in the 15-minute section. In particular, each
    number represents how many tasks were waiting for attention from the CPU for that
    given time period. Therefore, these numbers are really good. The server isn’t
    that busy, since virtually no task is waiting for the CPU at any one moment (each
    number is less than 1). This is contrary to something such as overall CPU percentages,
    which you may have seen in task managers on other platforms or even within such
    Linux tools as `htop`. While viewing your CPU usage percentage can be useful,
    the problem with this is that your CPUs will constantly go back and forth from
    a high percentage of usage to a low percentage of usage, which you can see for
    yourself by just running `htop` for a while. When a task does some sort of processing,
    you might see your cores shoot up to 100 percent and then right back down to a
    lower number. That really doesn’t tell you much, though. With load averages, you’re
    seeing the trend of usage over three given time frames, which is more accurate
    in determining whether your server’s CPUs are running efficiently or are choking
    on a workload it just can’t handle.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们在1分钟、5分钟和15分钟的时间段内分别有`0.36`、`0.29`和`0.31`的负载平均值。特别地，每个数字表示在给定时间段内，有多少任务在等待CPU处理。因此，这些数字非常理想。服务器并不繁忙，因为几乎没有任务在任何时刻等待CPU（每个数字都小于1）。这与诸如总体CPU使用百分比之类的指标不同，你可能在其他平台的任务管理器中见过，甚至在像`htop`这样的Linux工具中也能看到。虽然查看CPU使用百分比可能有用，但问题在于，CPU使用率会不断从高使用率变到低使用率，你可以通过运行`htop`一段时间来亲自观察。当任务进行某种处理时，你可能会看到CPU核心使用率飙升到100％，然后迅速下降到较低的数字。然而，这并不能告诉你太多。而负载平均值则展示了在三个给定时间段内的使用趋势，这在判断服务器的CPU是否高效运行或是否因无法处理的工作负载而陷入困境时更加准确。
- en: The main question, though, is at which point you should start to worry, which
    really depends on what kind of CPUs are installed on your server. Your server
    will have one or more CPUs, each with one or more cores. To Linux, each of these
    cores, whether they are physical or virtual, is the same thing (a CPU). In my
    case, the machine I took the earlier output from has a CPU with four cores.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，主要的问题是，你应该在什么时候开始担心，这实际上取决于你服务器上安装了什么样的 CPU。你的服务器将有一个或多个 CPU，每个 CPU 都有一个或多个核心。对于
    Linux 系统来说，这些核心无论是物理的还是虚拟的，都是一样的（即 CPU）。在我的案例中，我之前输出数据的机器有一个四核的 CPU。
- en: The more CPUs your server has, the more tasks it’s able to handle at any given
    time, which also means it can handle a higher load average.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 你服务器上的 CPU 越多，它在任何给定时间能够处理的任务就越多，这也意味着它能够处理更高的负载平均值。
- en: When a load average for a particular time period is equal to the number of CPUs
    on the system, that means your server is at 100% capacity. It’s handling a consistent
    number of tasks that are equal to the number of tasks it can handle. For example,
    if you have an 8-core CPU and the load average is 8 for a given time frame, then
    the CPU is 100% at its available capacity for that time frame. If your load average
    is consistently more than the number of cores you have available, that’s when
    you’d probably want to look into the situation. It’s fine for your server to be
    at capacity every now and then, but if it always is, that’s a cause for alarm.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 当某个时间段的负载平均值等于系统上的 CPU 数量时，这意味着你的服务器达到了 100% 的容量。它正在处理的任务数与它能够处理的任务数相等。例如，如果你有一个
    8 核的 CPU，而负载平均值在某个时间段是 8，那么 CPU 在该时间段内就是 100% 满负荷运行的。如果你的负载平均值持续高于可用核心数，那时你可能就需要关注这个情况。偶尔达到服务器满载是可以接受的，但如果一直处于满载状态，那就需要引起警惕了。
- en: I’d hate to use a cliché example in order to fully illustrate this concept,
    but I can’t resist, so here goes. A load average on a Linux server is equivalent
    to the check-out area at a supermarket. A supermarket will have several registers
    open, where customers can pay to finalize their purchases and move along. In my
    experience at typical stores in my area, you would have something like 20 check-out
    registers but only two cashiers working at any one time, but for this example,
    we’ll assume each register has a cashier operating it.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 我不太愿意使用陈词滥调的例子来充分说明这个概念，但我忍不住，所以还是用了这个。Linux 服务器上的负载平均值就相当于超市的结账区。超市会有多个收银台开放，顾客可以在这里支付并完成购物。在我所在地区典型商店的经验中，你会看到大约
    20 个收银台，但每次只有两个收银员在工作，不过在这个例子中，我们假设每个收银台都有一个收银员在操作。
- en: Each cashier is only able to handle one customer at a time. If there are more
    customers waiting to check out than there are cashiers, the lines will start to
    back up and customers will get frustrated. In a situation where there are four
    cashiers and a total of four customers at a particular time, the cashiers would
    be at capacity, which is not really a big deal since no one else is waiting. What
    can add to this problem is a customer that is paying by check and/or using a few
    dozen coupons, which makes the checkout process much longer (similar to a resource-intensive
    process). If there were four cashiers and six customers waiting, then there would
    be two more customers than the store is able to handle at the same time. In that
    case, the checkout area of the store would be above capacity. This is essentially
    how load average works. Each cashier is a CPU, and each customer is a process
    that needs CPU time.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 每个收银员一次只能处理一个顾客。如果等待结账的顾客多于收银员，排队就会开始积压，顾客会感到沮丧。在有四个收银员且此时有四个顾客的情况下，收银员将达到最大承载量，但这并不是什么大问题，因为没有其他顾客在等候。可能会加剧这个问题的是某个顾客使用支票支付和/或使用几打优惠券，这样结账过程就会变得更加耗时（类似于资源密集型进程）。如果有四个收银员，而有六个顾客在等待，那就意味着有两个顾客超出了商店同时能够处理的数量。在这种情况下，商店的结账区域将超出容量。这基本上就是负载平均值的工作原理。每个收银员就是一个
    CPU，每个顾客就是一个需要 CPU 时间的进程。
- en: Just like the cashiers, each CPU can only handle one task at a time, with some
    tasks hogging the CPU longer than others. If there are exactly as many tasks as
    there are CPUs, there’s no cause for concern. But if the lines start to back up,
    we may want to investigate what is taking so long. To gain control of the situation,
    we may hire an additional cashier (add a new CPU) or ask a disgruntled customer
    to leave (kill a process).
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 就像收银员一样，每个CPU一次只能处理一个任务，有些任务会占用CPU更长时间。如果任务的数量恰好和CPU数量一样，那就无需担心。但如果排队开始积压，我们可能需要调查是什么导致了这种延迟。为了控制局面，我们可以雇佣一个额外的收银员（增加一个CPU），或者请一个不满的顾客离开（终止一个进程）。
- en: 'Let’s take a look at another example load average:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一个其他的负载平均值示例：
- en: '[PRE16]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: In this situation, we shouldn’t be concerned, because our hypothetical server
    has 4 CPUs, and none of them have been at capacity within the 1-, 5-, or 15-minute
    time periods. Even though the load is consistently higher than 1, we have CPU
    resources to spare, so it’s no big deal. If we had one of those awesome new Threadripper
    CPUs from AMD (which can contain an impressive number of cores) then those numbers
    would represent *extremely* low load. Going back to our supermarket comparison,
    the load average in the previous example would be equivalent to having four cashiers
    with an average of almost two customers being assisted during any 1 minute. If
    this server only had one CPU, we would probably want to figure out what’s causing
    the line to begin to back up.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们不需要担心，因为我们的假设服务器有4个CPU，而且在1分钟、5分钟和15分钟的时间段内，没有任何一个CPU处于满负荷状态。即使负载始终高于1，我们仍然有CPU资源剩余，所以这并不是什么大问题。如果我们拥有AMD的那些非常强大的Threadripper
    CPU（可以包含大量的核心），那么这些数字就代表着*极其*低的负载。回到我们的超市比喻，前面例子中的负载平均值相当于有四个收银员在每一分钟内平均为几乎两名顾客提供服务。如果这台服务器只有一个CPU，我们可能需要搞清楚是什么导致了队伍的积压。
- en: While you might logically assume that having a low load average is a good thing,
    it can actually represent a really big problem depending on the context. When
    we deploy servers, we do so to get some sort of work done.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然你可能理性地认为低负载平均值是件好事，但实际上，根据具体情况，它可能代表着一个非常大的问题。当我们部署服务器时，我们是为了完成某种工作。
- en: Whether that “work” is to host an application or run jobs to process data, our
    servers need to be doing some sort of work, otherwise, we’re wasting money by
    having them. If the load average of your server drops to an abnormally low value,
    that might mean that a service that would normally be running all the time has
    failed and exited. For example, if you have a database server that constantly
    has a load within the 1.x range that suddenly drops to 0.x, that might mean that
    you either have legitimately less traffic or the database server service is no
    longer running. This is why it’s always a good idea to develop baselines for your
    server, in order to gauge what is normal and what isn’t. A baseline refers to
    resource usage, most of the time. If the resource usage is drastically higher
    or even lower than the baseline, that’s a potential cause for concern either way.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 无论这“工作”是托管一个应用程序，还是运行任务处理数据，我们的服务器需要在执行某些工作，否则我们就是在浪费钱。如果服务器的负载平均值下降到异常低的值，这可能意味着一个本应始终运行的服务已失败并退出。例如，如果你的数据库服务器的负载通常在1.x范围内，突然降到0.x，这可能意味着你要么流量确实减少了，要么数据库服务器服务已经停止运行。这就是为什么总是建议为服务器制定基准，以便判断什么是正常的，什么不是。基准通常指的是资源使用情况。如果资源使用量显著高于或低于基准，这无论如何都是潜在的关注点。
- en: Overall, load averages are something you’ll become very familiar with as a Linux
    administrator if you haven’t already. As a snapshot in time of how heavily utilized
    your server is, it will help you to understand when your server is running efficiently
    and when it’s having trouble. If a server is having trouble keeping up with the
    workload you’ve given it, it may be time to consider increasing the number of
    cores (if you can) or scaling out the workload to additional servers. When troubleshooting
    utilization, planning for upgrades, or designing a cluster, the process always
    starts with understanding your server’s load average so you can plan your infrastructure
    to run efficiently for its designated purpose.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 总的来说，如果你还没有遇到过，作为Linux管理员，你会非常熟悉负载均值。它是你服务器利用情况的时间快照，帮助你理解服务器什么时候运行高效，什么时候出现问题。如果服务器无法应对你分配的工作负载，可能是时候考虑增加核心数（如果可以的话）或将工作负载分配到其他服务器上。在排查资源利用问题、规划升级或设计集群时，整个过程通常是从了解服务器的负载均值开始的，这样你可以为其指定的任务有效地规划基础设施。
- en: Now that we’ve gone over the important resources that we need to monitor to
    ensure our server remains healthy, let’s take a look at a useful utility we can
    utilize that will make resource usage even easier to understand.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经讲解了需要监控的重要资源，以确保我们的服务器保持健康，让我们来看看一个有用的工具，它能让资源使用情况更加易于理解。
- en: Viewing resource usage with htop
  id: totrans-132
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用htop查看资源使用情况
- en: When wanting to view the overall performance of your server, nothing beats `htop`.
    Although not typically installed by default, `htop` is one of those utilities
    that I recommend everyone installs as soon as possible, since it’s indispensable
    when wanting to check on the resource utilization of your server. It’s so useful
    in fact that I’ve mentioned it several times earlier in this chapter, even before
    we started an actual discussion about it in this section. It’s a great utility.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 想要查看服务器的整体性能时，没有什么比`htop`更好的工具了。虽然它通常不是默认安装的，但`htop`是我推荐每个人尽早安装的工具，因为它在查看服务器资源利用情况时是不可或缺的。事实上，它有如此的实用性，以至于我在本章的前面就已经多次提到过它，即便我们在本节才开始讨论它。它真的是一个很棒的工具。
- en: 'If you don’t already have `htop` installed, all you need to do is install it
    with `apt`:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你还没有安装`htop`，只需使用`apt`安装即可：
- en: '[PRE17]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'When you run `htop` at your shell prompt, you will see the `htop` application
    in all its glory. In some cases, it may be beneficial to run `htop` as `root`,
    since doing so does give you additional options such as being able to kill processes,
    though this is not required:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 当你在终端提示符下运行`htop`时，你会看到`htop`应用程序的完整显示。在某些情况下，以`root`身份运行`htop`可能会更有利，因为这样你可以获得额外的选项，比如能够终止进程，尽管这并不是必需的：
- en: '![](img/B18425_08_07.png)'
  id: totrans-137
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B18425_08_07.png)'
- en: 'Figure 8.7: Running htop'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.7：运行htop
- en: At the top of the `htop` display, you’ll see a progress meter for each of your
    cores (the server used for my screenshot only has one core), as well as a meter
    for memory as well as `swap`. In addition, the upper portion will also show your
    `Uptime`, `Load average`, and the number of `Tasks` you have running. The lower
    section of `htop`'s display will show you a list of processes running on your
    server, with fields showing you useful information such as how much memory or
    CPU is being consumed by each process, as well as the command being run, the user
    running it, and its **Process ID** (**PID**). We discussed PIDs in *Chapter 7*,
    *Controlling and Managing Processes*. To scroll through the list of processes,
    you can press *Page Up* or *Page Down* or use your arrow keys. In addition, `htop`
    features mouse support, so you are also able to click on columns at the top in
    order to sort the list of processes by that criteria. For example, if you click
    on `MEM%` or `CPU%`, the process list will be sorted by memory or CPU usage respectively.
    The contents of the display will be updated every 2 seconds.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 在`htop`显示的顶部，你会看到每个核心的进度条（我截图时使用的服务器只有一个核心），以及内存和`swap`的进度条。此外，顶部还会显示你的`Uptime`、`Load
    average`和当前正在运行的`Tasks`数量。`htop`显示的下半部分会列出服务器上正在运行的进程，字段中会显示每个进程消耗的内存或CPU，以及正在运行的命令、运行该命令的用户和其**进程ID**（**PID**）。我们在*第7章*《控制和管理进程》中讨论过PID。要滚动查看进程列表，你可以按*Page
    Up*或*Page Down*，或者使用箭头键。此外，`htop`还支持鼠标操作，你可以点击顶部的列标题来按该标准对进程列表进行排序。例如，如果你点击`MEM%`或`CPU%`，进程列表将按内存或CPU使用率排序。显示的内容会每2秒更新一次。
- en: The `htop` utility is also customizable. If you prefer a different color scheme,
    for example, you can press *F2* to enter **Setup mode**, navigate to **Colors**
    on the left, and then you can switch your color scheme to one of the six that
    are provided. Other options include the ability to add additional meters, add
    or remove columns, and more. One tweak I find especially helpful on multicore
    servers is the ability to add an average CPU bar. Normally, `htop` shows you a
    meter for each core on your server, but if you have more than one, you may be
    interested in the average as well. To do so, enter **Setup mode** again (*F2*),
    then with **Meters** highlighted, arrow to the right to highlight **CPU average**,
    and then press *F5* to add it to the left column. There are other meters you can
    add as well, such as **Load average**, **Battery**, and more.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: '`htop` 工具也是可以定制的。例如，如果您更喜欢不同的颜色方案，可以按 *F2* 进入 **Setup mode**，然后在左侧导航到 **Colors**，选择六种提供的颜色方案之一。其他选项包括添加额外的计量表、增加或删除列等。对于多核服务器，我特别觉得有用的一个调整是能够添加一个
    CPU 平均负载条。通常，`htop` 会显示服务器上每个核心的计量表，但如果您有多个核心，您可能也会对平均值感兴趣。为此，请再次进入 **Setup mode**（按
    *F2*），然后在 **Meters** 高亮时，右箭头选择 **CPU average**，接着按 *F5* 将其添加到左侧列。您还可以添加其他计量表，如
    **Load average**、**Battery** 等。'
- en: Depending on your environment, function keys may not work correctly in terminal
    programs such as `htop`, because those keys may be mapped to something else. For
    example, *F10* is used to exit `htop`, but that may not work if *F10* is mapped
    to a function within your terminal emulator, and using a virtual machine solution
    such as VirtualBox may also prevent some of these keys from working normally.
    You can also navigate `htop` with your mouse, even via an SSH connection. This
    also means that you can click on the word **Quit** in the lower right-hand corner
    to exit the application.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 根据您的环境，功能键可能在终端程序中无法正常工作，例如 `htop`，因为这些键可能已被映射到其他功能。例如，*F10* 用于退出 `htop`，但如果
    *F10* 被映射到终端仿真器中的某个功能，这可能不起作用，使用虚拟机解决方案（如 VirtualBox）也可能会导致某些键无法正常工作。您还可以通过鼠标导航
    `htop`，即使是在 SSH 连接中。这也意味着，您可以点击右下角的 **Quit** 来退出应用程序。
- en: 'Here’s an example of `htop` configured with a meter for the CPU average:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个配置了 CPU 平均负载计量表的 `htop` 示例：
- en: '![](img/B18425_08_08.png)'
  id: totrans-143
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B18425_08_08.png)'
- en: 'Figure 8.8: htop with a meter for CPU average added'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.8：添加了 CPU 平均负载计量表的 htop
- en: When you open `htop`, you will see a list of processes for every user on the
    system. When you have a situation where you don’t already know which user/process
    is causing extreme load, this is ideal. However, a very useful trick (if you want
    to watch a specific user) is to press *u* on your keyboard, which will open up
    the **Show processes of:** menu. In this menu, you can highlight a specific user
    by highlighting it with the up or down arrow keys and then pressing *Enter* to
    only show processes for that user. This will greatly narrow down the list of processes.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 打开 `htop` 后，您将看到系统中每个用户的进程列表。当您遇到不知道是哪个用户/进程导致极端负载的情况时，这种方式非常理想。不过，一个非常实用的技巧（如果您想查看特定用户）是按下
    *u* 键，这将打开 **Show processes of:** 菜单。在此菜单中，您可以使用上下箭头键选择一个特定用户，并按 *Enter* 仅显示该用户的进程。这将大大缩小进程列表。
- en: Another useful view is the **tree view**, which allows you to see a list of
    processes organized by their parent/child relationship, rather than just a flat
    list. In practice, it’s common for a process to be spawned by another process.
    In fact, all processes in Linux are spawned from at least one other process, and
    this view shows that relationship directly. In a situation where you are stopping
    a process only to have it immediately re-spawn, you would need to know what the
    parent of that process is in order to stop it from resurrecting itself. Pressing
    *F5* will switch `htop` to tree view mode, and pressing it again will disable
    the tree view.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个有用的视图是 **树状视图**，它允许您查看按父子关系组织的进程列表，而不仅仅是一个平坦的列表。在实际操作中，进程通常是由另一个进程生成的。事实上，Linux
    中的所有进程都是从至少一个其他进程派生出来的，而这个视图直接显示了这种关系。在您停止一个进程，但它会立即重新生成的情况下，您需要知道该进程的父进程，以便阻止它自我恢复。按
    *F5* 将切换到树状视图模式，再次按 *F5* 将禁用树状视图。
- en: 'With the tree view activated, `htop` will appear similar to the following:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 启用树状视图后，`htop` 将显示如下：
- en: '![](img/B18425_08_09.png)'
  id: totrans-148
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B18425_08_09.png)'
- en: 'Figure 8.9: htop with tree view activated'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.9：启用树状视图的 htop
- en: 'As I’ve mentioned, `htop` updates its stats every 2 seconds by default. Personally,
    I find this to be acceptable, but if you want to change how fast it refreshes,
    you can call `htop` with the `-d` option and then apply a different number of
    seconds (entered in tenths of seconds) for it to refresh. For example, to run
    `htop` but have it update every 7 seconds, start `htop` with the following command:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我提到的，`htop` 默认每 2 秒更新一次其统计信息。就个人而言，我觉得这个更新频率是可以接受的，但如果你想改变刷新速度，可以在调用 `htop`
    时使用 `-d` 选项，然后设置刷新间隔（以十分之一秒为单位）。例如，要使 `htop` 每 7 秒更新一次，可以通过以下命令启动 `htop`：
- en: '[PRE18]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: To kill a process with `htop`, use your up and down arrow keys to highlight
    the process you wish to kill and press *F9*. A new menu will appear, giving you
    a list of signals you are able to send to the process with `htop`. `SIGTERM`,
    as we discussed before, will attempt to gracefully terminate the process. `SIGKILL`
    will terminate it uncleanly. Once you highlight the signal you wish to send, you
    can send it by pressing *Enter* or cancel the process with *Esc*.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用 `htop` 杀死一个进程，可以用上下箭头键选择你想要结束的进程，然后按 *F9*。会弹出一个新菜单，列出你可以通过 `htop` 发送给该进程的信号。如我们之前讨论过的，`SIGTERM`
    将尝试优雅地终止该进程，而 `SIGKILL` 则会强制结束它。一旦选中你想发送的信号，按 *Enter* 发送，或者按 *Esc* 取消操作。
- en: As you can see, `htop` can be incredibly useful and has (for the most part)
    replaced the legacy `top` command that was popular in the past for most administrators.
    The `top` command is available by default in Ubuntu Server and is worth a look,
    if only as a comparison to `htop`. Like `htop`, the `top` command gives you a
    list of processes running on your server, as well as their resource usage. There
    are no pretty meters and there is less customization possible, but the `top` command
    serves the same purpose. In most cases, though, `htop` is probably your best bet
    going forward.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所见，`htop` 非常有用，并且（在大多数情况下）已经取代了以前在许多管理员中流行的老旧 `top` 命令。`top` 命令在 Ubuntu 服务器中默认可用，值得一看，哪怕只是与
    `htop` 做个比较。和 `htop` 一样，`top` 命令也会列出你服务器上正在运行的进程及其资源使用情况。虽然没有漂亮的仪表盘，且定制化较少，但 `top`
    命令能完成相同的任务。然而，在大多数情况下，`htop` 可能是你未来的最佳选择。
- en: Summary
  id: totrans-154
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we learned how to monitor our server’s resource usage. We began
    with a look at the commands we can use to investigate disk usage, and we learned
    how to monitor memory usage as well. We also discussed `swap`, including what
    it is, why you’d want to have it, as well as how to create a `swap` file manually
    should the need to do so come up. We then took a look at load average and closed
    out the chapter by checking out `htop`, which is my favorite utility for getting
    an overall look at resource usage on servers.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们学习了如何监控服务器的资源使用情况。我们首先了解了可以用来查看磁盘使用情况的命令，并学习了如何监控内存使用情况。我们还讨论了 `swap`，包括它是什么，为什么你需要它，以及如何在需要时手动创建
    `swap` 文件。接着，我们看了负载平均值，并通过查看 `htop` 来结束本章，这是我最喜欢的一个工具，可以全方位查看服务器的资源使用情况。
- en: In *Chapter 9*, *Managing Storage Volumes*, we’ll take a closer look at storage.
    In this chapter, we learned how to see how much is being used, but in the next,
    we’ll look at more advanced concepts surrounding storage, such as formatting volumes,
    adding additional volumes, and even LVM. See you there!
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 在 *第 9 章*，*管理存储卷* 中，我们将深入探讨存储。在本章中，我们学习了如何查看使用情况，而在下一章中，我们将研究有关存储的更多高级概念，如格式化卷、添加额外的卷，甚至是
    LVM。到时见！
- en: Relevant videos
  id: totrans-157
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 相关视频
- en: 'Linux Crash Course – The du Command (LearnLinuxTV): [https://linux.video/du](https://linux.video/du)'
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Linux 快速入门 – du 命令（LearnLinuxTV）：[https://linux.video/du](https://linux.video/du)
- en: 'Linux Crash Course – htop (LearnLinuxTV): [https://linux.video/htop](https://linux.video/htop)'
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Linux 快速入门 – htop（LearnLinuxTV）：[https://linux.video/htop](https://linux.video/htop)
- en: 'Linux Crash Course – Load Average (LearnLinuxTV): [https://linux.video/loadavg](https://linux.video/loadavg)'
  id: totrans-160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Linux 快速入门 – 负载平均值（LearnLinuxTV）：[https://linux.video/loadavg](https://linux.video/loadavg)
- en: 'Linux Crash Course – Understanding Memory Usage (LearnLinuxTV): [https://linux.video/mem](https://linux.video/mem)'
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Linux 快速入门 – 理解内存使用情况（LearnLinuxTV）：[https://linux.video/mem](https://linux.video/mem)
- en: 'Awesome Linux Tools - ncdu (LearnLinuxTV): [https://linux.video/ncdu](https://linux.video/ncdu)'
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 精选 Linux 工具 - ncdu（LearnLinuxTV）：[https://linux.video/ncdu](https://linux.video/ncdu)
- en: Further reading
  id: totrans-163
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: 'Linux ate my RAM: [https://learnlinux.link/ate-ram](https://learnlinux.link/ate-ram)'
  id: totrans-164
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Linux 吃掉了我的 RAM：[https://learnlinux.link/ate-ram](https://learnlinux.link/ate-ram)
- en: Join our community on Discord
  id: totrans-165
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 加入我们的 Discord 社区
- en: 'Join our community’s Discord space for discussions with the author and other
    readers:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 加入我们社区的Discord空间，与作者和其他读者进行讨论：
- en: '[https://packt.link/LWaZ0](https://packt.link/LWaZ0)'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://packt.link/LWaZ0](https://packt.link/LWaZ0)'
- en: '![](img/QR_Code50046724-1955875156.png)'
  id: totrans-168
  prefs: []
  type: TYPE_IMG
  zh: '![](img/QR_Code50046724-1955875156.png)'
