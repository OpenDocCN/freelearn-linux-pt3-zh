<html><head></head><body>
<div id="sbo-rt-content"><div id="_idContainer026">
<h1 class="chapter-number" id="_idParaDest-34"><a id="_idTextAnchor040"/>3</h1>
<h1 id="_idParaDest-35"><a id="_idTextAnchor041"/>The Linux Filesystem</h1>
<p>Files and filesystems are the topics of discussion in this chapter. The Unix ethos of <em class="italic">everything is a file</em> carries on in Linux, and while that’s not true 100% of the time, most resources in Linux are <span class="No-Break">actually files.</span></p>
<p>In this chapter, we will first define several relevant concepts. Then we will investigate Linux’s implementation of the <em class="italic">everything is a file</em> concept. We will then cover the specialized filesystems the kernel makes use of to report data about running processes or attached hardware. We will then move on to normal files and filesystems, things you would typically associate with documents, data, and applications. Finally, we will explore standard filesystem operations and provide comparisons with other available alternatives. It is very important to know what limitations has each filesystem type in order for you to take the <span class="No-Break">best decisions.</span></p>
<p>In this chapter, we will cover the <span class="No-Break">following topics:</span></p>
<ul>
<li>The types of filesystems available and the differences <span class="No-Break">between them</span></li>
<li>The directory trees and <span class="No-Break">standard directories</span></li>
<li>How to <span class="No-Break">mount/unmount filesystems</span></li>
</ul>
<h1 id="_idParaDest-36"><a id="_idTextAnchor042"/>What is a filesystem?</h1>
<p>A filesystem (or sometimes <em class="italic">file system</em>) governs the storage<a id="_idIndexMarker113"/> and retrieval of data in computers. Without a filesystem, all the data saved on a computer’s hard drive would be jumbled together, making it impossible to find certain files. Instead, with a filesystem, data is easily isolated and identified by breaking it up into pieces and giving each piece a name. Each collection of data<a id="_idIndexMarker114"/> is referred to as a <em class="italic">file</em>, a name that originally came from information systems that use paper storage. A <em class="italic">filesystem</em> is a name for the organizational framework and logical principles used to handle the names and groups of bits <span class="No-Break">of data.</span></p>
<p>In fact, there are a variety of filesystems available for Linux; if you’re unsure which one to use, we’ll present a thorough list of the filesystems that <span class="No-Break">Linux supports.</span></p>
<p><em class="italic">What types of Linux filesystems </em><span class="No-Break"><em class="italic">are there?</em></span></p>
<p>Linux has a variety of filesystems to choose from, including <span class="No-Break">the following:</span></p>
<ul>
<li><strong class="bold">ext</strong>: The first filesystem constructed<a id="_idIndexMarker115"/> expressly for Linux was called <em class="italic">ext</em>, which is an acronym for <em class="italic">extended filesystem</em>, and was released in 1992. The primary objective<a id="_idIndexMarker116"/> of ext’s developers was to increase the maximum size of editable files, which at the time was limited to 64 MB. The maximum file size grew to 2 GB as a result of the new metadata structure that was created. The maximum length of filenames was also increased at the same time to <span class="No-Break">255 bytes.</span></li>
<li><strong class="bold">ext2</strong>: This is also known as the <em class="italic">second expanded system</em>. ext2 was developed<a id="_idIndexMarker117"/> by Remy Card, just like<a id="_idIndexMarker118"/> the first one, and was<a id="_idIndexMarker119"/> intended to replace Linux’s original extension system. It introduced innovations in fields such as storage capacity and overall performance. The maximum file size was notably increased to 2 TB, as opposed to the previous version’s 2 GB. Still, filenames remained limited to 255 <span class="No-Break">bytes long.</span></li>
<li><strong class="bold">ext3</strong>: ext3 is an upgraded version of ext2 and was first<a id="_idIndexMarker120"/> developed in 2001. The 2-TB maximum file<a id="_idIndexMarker121"/> size did not change, but ext3 was superior to ext2 in that it is a journaling filesystem. The 2-TB maximum file size does not change. This means that if the computer, hard drive(s), or both crash for any reason or encounter some type of power outage, the files can be repaired and restored upon rebooting using a separate log that contains the changes performed before <span class="No-Break">the crash.</span></li>
</ul>
<p>ext3 supports three levels <span class="No-Break">of journaling:</span></p>
<ul>
<li><strong class="bold">Journal</strong>: In the event of a power outage, the filesystem<a id="_idIndexMarker122"/> ensures effective filesystem recovery by writing both user data and metadata to the journal. Of the three ext3 journaling modes, this is the slowest. This journaling mode reduces the likelihood that any changes to any file in an ext3 filesystem will <span class="No-Break">be lost.</span></li>
<li><strong class="bold">Writeback</strong>: When using the <strong class="source-inline">data=writeback</strong> mode, only metadata updates are logged<a id="_idIndexMarker123"/> in the journal. Data<a id="_idIndexMarker124"/> updates, on the other hand, are written directly to their respective locations on the disk without being logged in the journal first. This approach can provide better performance for write-intensive workloads because it reduces the overhead of <span class="No-Break">journaling data.</span></li>
</ul>
<p><span class="No-Break"><strong class="bold">Pros</strong></span><span class="No-Break">:</span></p>
<ul>
<li>Improved performance<a id="_idIndexMarker125"/> for write-heavy workloads since data is written directly to disk without the extra overhead <span class="No-Break">of journaling</span></li>
<li>Lower write latency as data doesn’t need to be written twice (to the journal and then to <span class="No-Break">the filesystem)</span></li>
</ul>
<p><span class="No-Break"><strong class="bold">Cons</strong></span><span class="No-Break">:</span></p>
<ul>
<li>Reduced data consistency<a id="_idIndexMarker126"/> during a system crash or power failure. Since data updates are not journaled, there’s a possibility of data loss or inconsistency in case of <span class="No-Break">a crash.</span></li>
<li>In scenarios where data integrity is critical (for example, databases), the <strong class="source-inline">writeback</strong> mode may not be the best choice because it prioritizes performance over <span class="No-Break">data consistency.</span></li>
</ul>
<ul>
<li><strong class="bold">Ordered</strong>: This mode does not update<a id="_idIndexMarker127"/> related filesystem metadata; instead, it flushes changes from file data to disk before updating the associated filesystem metadata. This is ext3’s default journaling mode. Only the files that were in the process of being written to the disk <em class="italic">disappear</em> in the event of a power outage. The architecture of the filesystem <span class="No-Break">is undamaged.</span></li>
</ul>
<ul>
<li><strong class="bold">ext4</strong>: The <em class="italic">fourth extended system</em>, often known<a id="_idIndexMarker128"/> as ext4, was launched in 2008. This filesystem<a id="_idIndexMarker129"/> is commonly used as the default filesystem<a id="_idIndexMarker130"/> for the majority of Linux distributions since it overcomes a number of shortcomings that the third extended system had. Ext4 supports significantly larger filesystems and individual file sizes compared to Ext3. It can handle filesystems up to 1 exabyte (1 EB) and individual files up to 16 terabytes (16 TB). Additionally, a directory in ext4 can have up to 64,000 subdirectories (as opposed to 32,000 <span class="No-Break">in ext3).</span></li>
</ul>
<p>Extents have replaced fixed blocks as the primary method of data allocation in ext4. An extent’s beginning and end locations on the hard disk serve as a description of it. The number of pointers needed to represent the location of all the data in larger files can be greatly reduced because of the ability to express extremely long, physically contiguous<a id="_idIndexMarker131"/> files in a single inode <span class="No-Break">pointer</span><span class="No-Break"><a id="_idIndexMarker132"/></span><span class="No-Break"> entry.</span></p>
<ul>
<li><strong class="bold">JFS</strong>: JFS stands for <em class="italic">Journaled File System</em>. It is a 64-bit filesystem<a id="_idIndexMarker133"/> developed by IBM. In 1990, the first<a id="_idIndexMarker134"/> version of JFS (also known as <em class="italic">JFS1</em>) was introduced for use<a id="_idIndexMarker135"/> with IBM’s AIX <span class="No-Break">operating system.</span></li>
</ul>
<p>Data recovery after a power outage is simple and reliable. Additionally, compared to other filesystems, JFS<a id="_idIndexMarker136"/> requires less <span class="No-Break">CPU power.</span></p>
<ul>
<li><strong class="bold">XFS</strong>: SGI began working on XFS<a id="_idIndexMarker137"/> in the early 1990s with the intention of using it as the filesystem<a id="_idIndexMarker138"/> for their IRIX operating system. To tackle the most difficult computing challenges, XFS was designed as a high-performance 64-bit journaling filesystem. Large file manipulation and high-end hardware performance are strengths of XFS. In SUSE Linux Enterprise Server, XFS is the default filesystem for <span class="No-Break">data partitions.</span></li>
<li><strong class="bold">Btrfs</strong>: Chris Mason created the <strong class="bold">copy-on-write</strong> (<strong class="bold">COW</strong>) filesystem known as Btrfs. It is based<a id="_idIndexMarker139"/> on Ohad Rodeh’s COW-friendly<a id="_idIndexMarker140"/> B-trees. Btrfs<a id="_idIndexMarker141"/> is a logging-style filesystem that links the change after writing the block modifications in a new area as opposed to journaling them. New changes are not committed until the <span class="No-Break">last write.</span></li>
<li><strong class="bold">Swap</strong>: When the amount of memory available<a id="_idIndexMarker142"/> to the computer<a id="_idIndexMarker143"/> begins to run low, the system will use a file known as a swap file to generate temporary storage space on a solid-state drive or hard disk. The file replaces a section of memory in the RAM storage of a paused program with a new part, making memory available for use by <span class="No-Break">other processes.</span></li>
</ul>
<p>The computer is able to utilize more RAM than is physically installed by using a swap file. In other words, it is capable of running more programs than it would be able to execute if it relied solely on the limited resources provided by the RAM that was <span class="No-Break">physically installed.</span></p>
<p>Because swap files are not kept in the computer’s actual RAM, we can consider them to be a form of virtual memory. When a computer<a id="_idIndexMarker144"/> uses a swap file, its operating system essentially tricks itself into thinking that it has more RAM than it <span class="No-Break">actually does.</span></p>
<p>Linux is compatible with a wide variety of filesystems, including the FAT and NTFS filesystems that are standard to other operating systems such as Windows. It’s possible that embedded developers will support those, although in most cases, a Linux filesystem such as ext4, XFS, or Btrfs will be used for storage partitions. A better understanding of the benefits of the available alternatives will help you to choose the appropriate filesystem for a <span class="No-Break">certain application.</span></p>
<h1 id="_idParaDest-37"><a id="_idTextAnchor043"/>High scalability</h1>
<p>By leveraging allocation groups, XFS provides <span class="No-Break">excellent scalability.</span></p>
<p>The block device that supports the XFS filesystem<a id="_idIndexMarker145"/> is split into eight or more linear regions that are all the same size at the moment the filesystem is created. They are referred<a id="_idIndexMarker146"/> to as allocation groups. Each allocation group controls its own free disk space and inodes. The kernel can address multiple allocation groups at once since they are relatively independent of one another. The high scalability of XFS is made possible by this feature. These autonomous allocation groups naturally meet the requirements of <span class="No-Break">multiprocessor systems.</span></p>
<h1 id="_idParaDest-38"><a id="_idTextAnchor044"/>High performance</h1>
<p>XFS provides high performance<a id="_idIndexMarker147"/> by effectively managing <span class="No-Break">disk space.</span></p>
<p>Within the allocation groups, B+ trees manage free space and inodes. The effectiveness and scalability of XFS are considerably enhanced by the usage of B+ trees. XFS manages allocation in a delayed manner by dividing the allocation procedure into two steps. Pending transactions are kept in the RAM and the necessary amount of space is set aside. The precise location (in filesystem blocks) of the data’s storage is still left up to XFS. This choice is postponed until the very last second. If it is outdated when XFS selects where to save it, certain short-lived temporary data may never reach the disk. XFS improves write performance and lessens filesystem fragmentation in this way. Data loss after a crash during a write operation is likely to be more severe in a delayed-allocation filesystem than in <span class="No-Break">other filesystems.</span></p>
<h2 id="_idParaDest-39"><a id="_idTextAnchor045"/>What filesystem does my system use?</h2>
<p>If you aren’t sure<a id="_idIndexMarker148"/> which filesystem your distribution ships with, or if you just want to know which one you have installed, you can use some clever commands at the Terminal to <span class="No-Break">find out.</span></p>
<p>There are other ways to accomplish this, but we’ll demonstrate the simplest one here using the <strong class="source-inline">df -</strong><span class="No-Break"><strong class="source-inline">T</strong></span><span class="No-Break"> command.</span></p>
<div>
<div class="IMG---Figure" id="_idContainer019">
<img alt="Figure 3.1 – A command used to determine what type of filesystem is in use" height="320" src="image/Figure_3.1_B18575.jpg" width="1049"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.1 – A command used to determine what type of filesystem is in use</p>
<p>In the second column, labeled <strong class="source-inline">Type</strong>, you can see the descriptions of the filesystem formats. At this point, you should<a id="_idIndexMarker149"/> be able to tell which filesystem is mounted on your <span class="No-Break">Linux installation.</span></p>
<h1 id="_idParaDest-40"><a id="_idTextAnchor046"/>FUSE filesystem</h1>
<p>As a user, you shouldn’t have<a id="_idIndexMarker150"/> to worry too much about the underlying implementation when interacting with files and directories in user space. It is common practice for processes to make use of system calls to the kernel in order to read or write to a mounted filesystem. However, you do have access to data from the filesystem that doesn’t seem to belong in the user’s domain. The <strong class="source-inline">stat()</strong> system call in particular returns inode numbers and <span class="No-Break">link counts.</span></p>
<p>Do you have to worry about inode numbers, link counts, and other implementation details even when you’re not maintaining a filesystem? No (in most cases). This information is made available to user-mode programs for the primary purpose of maintaining backward compatibility. In addition, these filesystem internals aren’t present in every Linux filesystem because they’re not standardized. The VFS interface layer is responsible for ensuring that system calls always return inode numbers and link counts; however, the values of these numbers may or may not <span class="No-Break">indicate anything.</span></p>
<p>On non-traditional filesystems, it’s possible that you won’t be able to carry out operations that are typical of the Unix filesystem. For instance, you cannot use the <strong class="source-inline">ln</strong> command to create a hard link on a mounted VFAT filesystem because that filesystem’s directory entry structure does not support the concept of hard links. Because of the high level of abstraction provided by the system calls available in user space, working with files on Linux systems does not require any prior knowledge of the underlying implementation. Additionally, the format of filenames is flexible, and the use of mixed-case filenames is supported; both of these features make it simple to support other <span class="No-Break">hierarchical-style filesystems.</span></p>
<p class="callout-heading">Note</p>
<p class="callout">Keep in mind that the support for a particular filesystem does not necessarily need to be included in the kernel. To give one illustration, the role of the kernel in user-space filesystems is limited to that of a conduit for <span class="No-Break">system calls.</span></p>
<h1 id="_idParaDest-41"><a id="_idTextAnchor047"/>The directory tree and standard directories</h1>
<p>To see the main structure<a id="_idIndexMarker151"/> of the root folder, just use the following command: <strong class="source-inline">tree -</strong><span class="No-Break"><strong class="source-inline">L 1</strong></span><span class="No-Break">.</span></p>
<div>
<div class="IMG---Figure" id="_idContainer020">
<img alt="Figure 3.2 – The command to see a directory structure tree" height="830" src="image/Figure_3.2_B18575.jpg" width="352"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.2 – The command to see a directory structure tree</p>
<p>To better grasp how the Linux filesystem functions in general, let’s examine what each folder’s purpose is with reference to the Linux filesystem diagram shown in <span class="No-Break"><em class="italic">Figure 3</em></span><em class="italic">.2</em>. Not all of the folders mentioned here nor in the preceding examples will be found in every Linux distribution, but the vast majority of <span class="No-Break">them will:</span></p>
<ul>
<li><strong class="source-inline">/bin</strong>: The majority of your binary files<a id="_idIndexMarker152"/> are kept in this location, which is pronounced <em class="italic">bin,</em> and is often used by Linux Terminal commands and essential utilities such as <strong class="source-inline">cd</strong> (change directory), <strong class="source-inline">pwd</strong> (print working directory), <strong class="source-inline">mv</strong> (move), <span class="No-Break">and others.</span></li>
<li><strong class="source-inline">/boot</strong>: All of the boot files for Linux<a id="_idIndexMarker153"/> can be found in this folder. The majority of people, including myself, save this directory on a separate partition of their hard drive, especially if they plan to use dual-booting. Remember that even if <strong class="source-inline">/boot</strong> is physically located on a different partition, Linux still believes it to be <span class="No-Break">at </span><span class="No-Break"><strong class="source-inline">/boot</strong></span><span class="No-Break">.</span></li>
<li><strong class="source-inline">/dev</strong>: Your physical devices, such as hard<a id="_idIndexMarker154"/> drives, USB drives, and optical media, are mounted here. Additionally, your drive may have different partitions, in which case you’ll see <strong class="source-inline">/dev/sda1</strong>, <strong class="source-inline">/dev/sda2</strong>, and <span class="No-Break">so forth.</span></li>
<li><strong class="source-inline">/etc</strong>: This directory stores configuration<a id="_idIndexMarker155"/> files. Users can keep configuration files in their own <strong class="source-inline">/home</strong> folder, which affects only the given user, whereas configurations placed in <strong class="source-inline">/etc</strong> usually affect all users on <span class="No-Break">the system.</span></li>
<li><strong class="source-inline">/home</strong>: Because this directory contains<a id="_idIndexMarker156"/> all of your personal information, you’ll spend most of your time here. The <strong class="source-inline">/home/username</strong> directory contains the <strong class="source-inline">Desktop</strong>, <strong class="source-inline">Documents</strong>, <strong class="source-inline">Downloads</strong>, <strong class="source-inline">Photos</strong>, and <span class="No-Break"><strong class="source-inline">Videos</strong></span><span class="No-Break"> directories.</span></li>
<li><strong class="source-inline">/lib</strong>: Here is where you’ll find all the library<a id="_idIndexMarker157"/> buildings. There are always extra libraries that start with lib-something that get downloaded when you install a Linux distribution. The operation of your Linux program depends on <span class="No-Break">these files.</span></li>
<li><strong class="source-inline">/media</strong>: This is where external devices<a id="_idIndexMarker158"/> such as USB drives and CD-ROMs are mounted. This varies between <span class="No-Break">Linux distributions.</span></li>
<li><strong class="source-inline">/mnt</strong>: This directory basically serves<a id="_idIndexMarker159"/> as a mounting point for other folders or drives. This can be used for anything, although it is typically used for <span class="No-Break">network locations.</span></li>
<li><strong class="source-inline">/opt</strong>: This directory contains supplementary<a id="_idIndexMarker160"/> software for your computer that is not already managed by the package management tool that comes with <span class="No-Break">your distribution.</span></li>
<li><strong class="source-inline">/proc</strong>: The <em class="italic">processes</em> folder contains a variety<a id="_idIndexMarker161"/> of files holding system data (remember, everything is a file). In essence, it gives the Linux kernel—the heart of the operating system—a mechanism to communicate with the numerous processes that are active within the <span class="No-Break">Linux environment.</span></li>
<li><strong class="source-inline">/root</strong>: This is the equivalent of the <strong class="source-inline">/home</strong> folder for the root<a id="_idIndexMarker162"/> user, commonly known as the superuser. You should only touch<a id="_idIndexMarker163"/> anything in this directory if you are really sure you know what <span class="No-Break">you’re doing.</span></li>
<li><strong class="source-inline">/sbin</strong>: This is comparable to the <strong class="source-inline">/bin</strong> directory, with<a id="_idIndexMarker164"/> the exception that it contains instructions<a id="_idIndexMarker165"/> that can only be executed by the <em class="italic">root</em> user, sometimes known as <span class="No-Break">the </span><span class="No-Break"><em class="italic">superuser</em></span><span class="No-Break">.</span></li>
<li><strong class="source-inline">/tmp</strong>: Temporary files are kept here and are often<a id="_idIndexMarker166"/> erased when the computer shuts down, so you don’t have to manually remove them as you would <span class="No-Break">in Windows.</span></li>
<li><strong class="source-inline">/usr</strong>: This directory contains files<a id="_idIndexMarker167"/> and utilities that are shared <span class="No-Break">between users.</span></li>
<li><strong class="source-inline">/var</strong>: The files used by the system to store<a id="_idIndexMarker168"/> information as it runs are often located in the <strong class="source-inline">/var</strong> subfolder of the root directory in Linux and other Unix-like <span class="No-Break">operating systems.</span></li>
</ul>
<p>We’ve now covered the root directory, but many of the subdirectories also lead to additional files and folders. You can get a general concept of what the basic filesystem tree<a id="_idIndexMarker169"/> looks like from the <span class="No-Break">following diagram:</span></p>
<div>
<div class="IMG---Figure" id="_idContainer021">
<img alt="Figure 3.3 – Basic filesystem structure (Source: https://en.wikipedia.org/wiki/Unix_filesystem)" height="919" src="image/Figure_3.3_B18575.jpg" width="1650"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.3 – Basic filesystem structure (Source: <a href="https://en.wikipedia.org/wiki/Unix_filesystem">https://en.wikipedia.org/wiki/Unix_filesystem</a>)</p>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Having an understanding of the root directory structure will make your life much easier in the Linux world.</p>
<h1 id="_idParaDest-42"><a id="_idTextAnchor048"/>Links (hard and symbolic)</h1>
<p>There are two alternative ways to refer to a file on the hard drive: hard links <a id="_idIndexMarker170"/>and symbolic links. The filesystem, which organizes<a id="_idIndexMarker171"/> which file belongs where and how, includes several approaches such as symbolic link and hard link. A hard link basically refers to the inode of a file and is a synchronized carbon copy of that file. On the other hand, symbolic links point directly to the file, which in turn points to the inode, a shortcut. We need to next discuss inodes in order to comprehend how symbolic and hard <span class="No-Break">links function.</span></p>
<h2 id="_idParaDest-43"><a id="_idTextAnchor049"/>What is an inode?</h2>
<p>A Unix-style filesystem<a id="_idIndexMarker172"/> uses a data structure called an inode to describe filesystem objects such as files and directories. The properties and disk block locations of an object’s data are stored in each inode. Attributes of filesystem objects can include metadata, owner information, and <span class="No-Break">permission information.</span></p>
<p>Inodes are essentially a whole address’s numerical equivalent. The operating system can obtain details about a file, including permission privileges and the precise location of the data on the hard drive, using<a id="_idIndexMarker173"/> <span class="No-Break">an inode.</span></p>
<h2 id="_idParaDest-44"><a id="_idTextAnchor050"/>What is a hard link?</h2>
<p>On a computer system, a hard link<a id="_idIndexMarker174"/> is a special kind of link that points directly to a specific file by its name. A hard link will continue to point to the original file even if the file’s name is changed, unlike a <span class="No-Break">soft link.</span></p>
<p>When comparing the two methods of linking a directory entry or file to the same memory region, hard links are more reliable. As opposed to symbolic links, hard links prevent files from being deleted or moved. The <em class="italic">alias effect</em>, in which a file has numerous<a id="_idIndexMarker175"/> identifiers, can occur when multiple hard links point to the same file. Experts agree that all links, whether hard or soft, are pointers; nonetheless, hard links are distinguished as being more permanent than <span class="No-Break">soft connections.</span></p>
<h2 id="_idParaDest-45"><a id="_idTextAnchor051"/>What are symbolic links?</h2>
<p>Symbolic links<a id="_idIndexMarker176"/> are essentially shortcuts that refer to a file rather than the inode value of the file they point to. This method can be applied to directories and can be used to make references to data that is located on a variety of hard discs and volumes. A symbolic link will be broken or leave a dangling link if the original file is moved to a different folder. This is due to the fact that symbolic links refer to the original file and not the inode value of <span class="No-Break">the file.</span></p>
<p>Because a symbolic link points to the original file, any changes you make to the symbolic link should result in corresponding changes being made to the <span class="No-Break">actual file.</span></p>
<h1 id="_idParaDest-46"><a id="_idTextAnchor052"/>Mounting and unmounting filesystems</h1>
<p>In order for the computer to access files, the filesystem<a id="_idIndexMarker177"/> must be mounted. The <strong class="source-inline">mount</strong> command will show you what is mounted (usable) on your system at <span class="No-Break">the moment.</span></p>
<p>I created my own <strong class="source-inline">/data</strong> folder and mounted a new HDD <span class="No-Break">into it:</span></p>
<div>
<div class="IMG---Figure" id="_idContainer022">
<img alt="Figure 3.4 – A command showing what filesystem is mounted on /data" height="64" src="image/Figure_3.4_B18575.jpg" width="997"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.4 – A command showing what filesystem is mounted on /data</p>
<p>To mount your filesystem with a command, just run <span class="No-Break">the following:</span></p>
<pre class="source-code">
mount -t ext4 /dev/mapper/cs-home /data</pre>
<p>In order to have it automatically mounted on reboot, you have to define this entry <span class="No-Break">in </span><span class="No-Break"><strong class="source-inline">/etc/fstab</strong></span><span class="No-Break">.</span></p>
<p>If you want to mount a CD-ROM, just run the <span class="No-Break">following command:</span></p>
<pre class="source-code">
mount -t iso9660 /dev/cdrom /mnt/cdrom</pre>
<p>For more detailed information, consult the <strong class="source-inline">mount</strong> man page or run <strong class="source-inline">mount</strong> with the <strong class="source-inline">-h</strong> flag to <span class="No-Break">get assistance.</span></p>
<p>The <strong class="source-inline">cd</strong> command can be used to traverse the newly accessible filesystem through<a id="_idIndexMarker178"/> the mount point you just created <span class="No-Break">after mounting.</span></p>
<h2 id="_idParaDest-47"><a id="_idTextAnchor053"/>How to unmount the filesystem</h2>
<p>Using the <strong class="source-inline">umount</strong> command and specifying<a id="_idIndexMarker179"/> the mount point or device, you can unmount (detach) the filesystem from <span class="No-Break">your computer.</span></p>
<p>The following command, for instance, would unmount <span class="No-Break">a CD-ROM:</span></p>
<pre class="source-code">
umount /dev/cdrom</pre>
<h2 id="_idParaDest-48"><a id="_idTextAnchor054"/>Pseudo-filesystems</h2>
<p>A process information pseudo-filesystem<a id="_idIndexMarker180"/> is another name for the <strong class="source-inline">proc</strong> filesystem. It contains runtime system information rather than <em class="italic">actual</em> files (for example, system memory, devices mounted, hardware configuration, and so on). It can therefore be viewed as the kernel’s command and information hub. This directory (<strong class="source-inline">/proc</strong>) is accessed by many system utilities. The <strong class="source-inline">lsmod</strong> command lists the modules loaded by the kernel, and the <strong class="source-inline">lspci</strong> command displays the devices attached to the PCI bus. Both of these commands are functionally equivalent to <strong class="source-inline">cat /proc/modules</strong> and <strong class="source-inline">cat /proc/pci</strong>, respectively. Common examples of pseudo filesystems in Unix-like operating systems (for example, Linux) include <span class="No-Break">the following:</span></p>
<ul>
<li>Processes, the most <span class="No-Break">prominent use</span></li>
<li>Kernel information <span class="No-Break">and parameters</span></li>
<li>System metrics, such as <span class="No-Break">CPU usage</span></li>
</ul>
<h2 id="_idParaDest-49"><a id="_idTextAnchor055"/>Processes</h2>
<p>All the information about each running process<a id="_idIndexMarker181"/> can be found in the <strong class="source-inline">/proc/pid</strong> file. Here’s an illustration of a few PIDs in action <span class="No-Break">right now:</span></p>
<div>
<div class="IMG---Figure" id="_idContainer023">
<img alt="Figure 3.5 – A command to see running processes" height="313" src="image/Figure_3.5_B18575.jpg" width="902"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.5 – A command to see running processes</p>
<p>Let’s take, for example, PID <strong class="source-inline">1031</strong> and see what<a id="_idIndexMarker182"/> <span class="No-Break">is inside:</span></p>
<div>
<div class="IMG---Figure" id="_idContainer024">
<img alt="Figure 3.6 – A command to see what is inside of the process with PID 1031" height="963" src="image/Figure_3.6_B18575.jpg" width="854"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.6 – A command to see what is inside of the process with PID 1031</p>
<p>Finally, a synthetic filesystem<a id="_idIndexMarker183"/> is a filesystem that provides<a id="_idIndexMarker184"/> a tree-like interface to non-file objects, making them look like regular files<a id="_idIndexMarker185"/> in a disk-based or long-term storage filesystem. This type of filesystem is also known as a <span class="No-Break">faux filesystem.</span></p>
<h2 id="_idParaDest-50"><a id="_idTextAnchor056"/>Kernel and system information</h2>
<p>Numerous folders under <strong class="source-inline">/proc</strong> contain a wealth of knowledge<a id="_idIndexMarker186"/> about the kernel<a id="_idIndexMarker187"/> and the operating system. There are too many of them to include here, but we will cover a few along with a brief description of what <span class="No-Break">they contain:</span></p>
<ul>
<li><strong class="source-inline">/proc/cpuinfo</strong>: Information about <span class="No-Break">the CPU</span></li>
<li><strong class="source-inline">/proc/meminfo</strong>: Information about the <span class="No-Break">physical memory</span></li>
<li><strong class="source-inline">/proc/vmstats</strong>: Information about the <span class="No-Break">virtual memory</span></li>
<li><strong class="source-inline">/proc/mounts</strong>: Information about <span class="No-Break">the mounts</span></li>
<li><strong class="source-inline">/proc/filesystems</strong>: Information about filesystems that have been compiled into the kernel and whose kernel modules are <span class="No-Break">currently loaded</span></li>
<li><strong class="source-inline">/proc/uptime</strong>: This shows the current <span class="No-Break">system uptime</span></li>
<li><strong class="source-inline">/proc/cmdline</strong>: The kernel <span class="No-Break">command line</span></li>
</ul>
<h2 id="_idParaDest-51"><a id="_idTextAnchor057"/>CPU usage</h2>
<p>When evaluating a system’s overall <a id="_idIndexMarker188"/>performance, it is crucial to have a firm grasp of how much CPU time is being used. Knowing how to monitor CPU utilization in Linux via the command line is essential knowledge for everyone working with Linux, from enthusiasts to <span class="No-Break">system administrators.</span></p>
<p>One of the most common commands used for this purpose <span class="No-Break">is </span><span class="No-Break"><strong class="source-inline">top</strong></span><span class="No-Break">:</span></p>
<div>
<div class="IMG---Figure" id="_idContainer025">
<img alt="Figure 3.7 – Output of top command" height="568" src="image/Figure_3.7_B18575.jpg" width="1228"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.7 – Output of top command</p>
<p>The system’s response should be a comprehensive rundown of all active tasks where users, processes, CPU usage, and memory<a id="_idIndexMarker189"/> consumption can all <span class="No-Break">be viewed.</span></p>
<h1 id="_idParaDest-52"><a id="_idTextAnchor058"/>Summary</h1>
<p>In this chapter, we explored files and filesystems in Linux. Filesystems are a powerful and versatile approach to organize access to information in a hierarchical fashion. In Linux, filesystems are the focus of numerous technologies and ongoing efforts. Some are open source, but there is also a spectrum of <span class="No-Break">commercial options.</span></p>
<p>In the next chapter, we will talk about processes and <span class="No-Break">process control.</span></p>
</div>
</div></body></html>