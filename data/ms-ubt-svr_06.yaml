- en: '6'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '6'
- en: Boosting Your Command-line Efficiency
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 提高命令行效率
- en: Throughout this book, we’ve been using the command line quite heavily. Using
    the shell, we’ve installed packages, created users, edited configuration files,
    and more. In the last chapter, we took a look at file management to enhance our
    terminal skills further. This time around, we’ll dedicate an entire chapter to
    the shell, with the goal of becoming more efficient with it. Here, we’ll take
    what we already know and add some useful time-saving tips, some information on
    looping, variables, and we’ll even look into writing scripts.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书中，我们一直在大量使用命令行。通过使用 shell，我们安装了软件包、创建了用户、编辑了配置文件等等。在上一章中，我们探讨了文件管理，以进一步提升我们的终端技能。这一章，我们将专门用一整章的内容讲解
    shell，目标是提高我们的效率。在这里，我们将利用已经掌握的知识，加入一些有用的节省时间的技巧，介绍循环、变量等内容，甚至还会编写脚本。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一章中，我们将涵盖以下主题：
- en: Understanding the Linux shell
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解 Linux shell
- en: Understanding Bash history
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解 Bash 历史
- en: Learning some useful command-line tricks
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 学习一些有用的命令行技巧
- en: Understanding variables
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解变量
- en: Writing simple scripts
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编写简单脚本
- en: 'Putting it all together: Writing an `rsync` backup script'
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将所有内容结合起来：编写 `rsync` 备份脚本
- en: Let’s begin this chapter with further discussion regarding the Linux shell,
    which will help us better understand how we’re interacting with the server while
    we enter commands.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从进一步讨论 Linux shell 开始，这将帮助我们更好地理解在输入命令时与服务器的交互方式。
- en: Understanding the Linux shell
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解 Linux shell
- en: When it comes to the Linux shell, it’s important to understand what exactly
    the term pertains to. We’ve been using the command line repeatedly throughout
    the book, but we haven’t yet had any formal discussion about the actual interface
    through which our commands are entered.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 当谈到 Linux shell 时，理解这个术语的真正含义非常重要。我们在本书中反复使用命令行，但至今我们还没有正式讨论过实际输入命令的接口。
- en: Essentially, we’ve been entering our commands into a command interpreter known
    as the **Bourne Again Shell**, or simply **Bash**. Bash is just one of many different
    *shells* that you can use to enter commands.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 本质上，我们一直在通过一个命令解释器输入命令，这个命令解释器被称为**Bourne Again Shell**，简称**Bash**。Bash只是你可以用来输入命令的许多不同*shell*之一。
- en: There are other options, including **Zsh**, **Fish**, and **ksh**, but Bash
    is the default command shell for the majority of Linux distributions. It’s even
    available on macOS (although the default on that platform is Zsh nowadays), as
    well as on Windows by installing the Windows Subsystem for Linux. Therefore, by
    understanding the basics of Bash, your knowledge will be compatible with other
    distributions and platforms. While it’s fun to learn other shells such as Zsh,
    Bash is definitely the one to focus the most attention on if you’re just starting.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 还有其他选择，包括**Zsh**、**Fish**和**ksh**，但是 Bash 是大多数 Linux 发行版的默认命令 shell。它甚至可以在 macOS
    上使用（尽管在该平台上默认的是 Zsh），通过安装 Windows Subsystem for Linux（WSL）还可以在 Windows 上使用。因此，通过理解
    Bash 的基础知识，你的知识将与其他发行版和平台兼容。虽然学习其他 shell（如 Zsh）也很有趣，但如果你刚开始使用，Bash 无疑是最值得集中精力的。
- en: 'You may wonder, then, where you configure the shell that your user account
    will use. If you recall from *Chapter 2*, *Managing Users and Permissions*, we
    looked at the `/etc/passwd` file. As I’m sure you remember, this file keeps a
    list of user accounts available on the system. Go ahead and take a look at this
    file to refresh yourself by entering the following command:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会想知道，那么，在哪儿配置你的用户账户使用的 shell。回想一下*第 2 章*《管理用户和权限》，我们查看过 `/etc/passwd` 文件。相信你还记得，这个文件保存了系统上所有用户账户的列表。你可以通过输入以下命令，查看这个文件来刷新一下记忆：
- en: '[PRE0]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'This will produce an output like the one shown in *Figure 6.1*:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 这将产生类似*图 6.1*中所示的输出：
- en: '![Text  Description automatically generated](img/B18425_06_01.png)'
  id: totrans-18
  prefs: []
  type: TYPE_IMG
  zh: '![文本描述自动生成](img/B18425_06_01.png)'
- en: 'Figure 6.1: The last several lines of a sample /etc/passwd file'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.1：示例 /etc/passwd 文件的最后几行
- en: See the last field in every entry? That’s where we configure which shell is
    launched when a user logs in or starts a new terminal session. Unless you’ve already
    changed it, the entry for your user account should read `/bin/bash`.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 你看到每个条目的最后一个字段了吗？那是我们配置用户登录或启动新终端会话时启动哪个 shell 的地方。除非你已经更改过，否则你账户的条目应该是 `/bin/bash`。
- en: You’ll see other variations in this file, such as `/bin/false` or `/usr/sbin/nologin`.
    These are actually invalid shells that will prevent a user from logging in to
    the system if one of these is set as the default for that user. While it may seem
    strange to set a user’s shell to one that prevents them from logging in, this
    practice is fairly common – not all user accounts need to log in to a server.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 你会在这个文件中看到其他变体，例如`/bin/false`或`/usr/sbin/nologin`。这些实际上是无效的 shell，当某个用户的默认 shell
    设置为这些时，就会阻止该用户登录系统。虽然设置一个阻止登录的 shell 看起来很奇怪，但这种做法其实相当常见——并不是所有的用户账户都需要登录服务器。
- en: System accounts also exist alongside normal user accounts, which are created
    for background jobs. These system users won’t need to actually log in to the system
    in order to do their work, so it’s common to take that a step further and set
    the shell of a system user to an invalid shell, so that way, the account cannot
    be used to log in to the server if it’s taken over by an outside threat actor
    (the less an account can do, the safer it is).
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 系统账户与普通用户账户并存，这些账户是为后台工作创建的。系统用户不需要实际登录系统来执行工作，因此通常会进一步将系统用户的 shell 设置为无效的 shell，这样即使该账户被外部威胁者控制，也无法用来登录服务器（账户能做的事越少，就越安全）。
- en: The shell program itself is responsible for reading the commands you type and
    having the Linux kernel execute them. Some shells, Bash notably, have additional
    features, such as *history*, that are very useful to administrators.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: Shell 程序本身负责读取你输入的命令，并让 Linux 内核执行它们。某些 shell，特别是 Bash，具有额外的功能，如*history*，这些功能对于管理员非常有用。
- en: Understanding Bash history
  id: totrans-24
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解 Bash 历史
- en: Speaking of history, let’s dive right into that concept. By default, Bash keeps
    track of all the commands you enter during your sessions, so that if you need
    to recall a previously entered command, you can definitely do so. History also
    serves another purpose, and that is seeing what other users have been up to. However,
    since users can edit their own history to cover their tracks, it’s not always
    useful for that purpose.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 说到 history，让我们深入探讨这个概念。默认情况下，Bash 会记录你在会话期间输入的所有命令，这样你就可以在需要时回忆起之前输入的命令。History
    还有另一个用途，就是查看其他用户的活动。不过，由于用户可以编辑自己的历史记录来掩盖痕迹，因此这个功能在这个方面并不总是有用的。
- en: You may have already seen Bash’s history feature in some form, if you’ve ever
    pressed the up and down arrows on the shell to recall a previously used command.
    If you didn’t already know you could do that, go ahead and give it a try. You
    should see that by pressing the up and down arrows, you can cycle through commands
    that you’ve used previously.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你曾经按过 shell 中的上下箭头来回忆之前使用过的命令，你可能已经见过 Bash 的历史功能。如果你还不知道可以这么做，试试看吧。你会发现，按上下箭头可以浏览你之前使用过的命令。
- en: 'Another trick is that you can also simply type `history` in the shell and see
    a list of previously entered commands, as shown in *Figure 6.2*:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个技巧是，你也可以在 shell 中直接输入`history`，并查看之前输入过的命令列表，如*图 6.2*所示：
- en: '![A screenshot of a computer  Description automatically generated with medium
    confidence](img/B18425_06_02.png)'
  id: totrans-28
  prefs: []
  type: TYPE_IMG
  zh: '![A screenshot of a computer  Description automatically generated with medium
    confidence](img/B18425_06_02.png)'
- en: 'Figure 6.2: Output from the history command'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.2：history 命令的输出
- en: 'At this point, you can copy and paste a command you’ve used previously from
    this list to run it again. In fact, there’s an even easier way. Do you notice
    the number on the left of each command? We can utilize that number to quickly
    recall a previously used command. In my screenshot, item `566` is where I ran
    `sudo apt update`. If I wanted to run that same command again, I could simply
    enter the following command:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 此时，你可以从这个列表中复制并粘贴一个之前使用过的命令再次执行。实际上，还有一种更简单的方法。你注意到每个命令左侧的数字了吗？我们可以利用这个数字快速回忆起之前使用过的命令。在我的截图中，项`566`是我运行`sudo
    apt update`时的位置。如果我想再次运行相同的命令，只需输入以下命令：
- en: '[PRE1]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'In this case, I typed just four characters, and I was able to recall the previously
    used command, which performs the same action as typing this:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我只输入了四个字符，就能够回忆起之前使用过的命令，这个命令执行的操作与输入以下内容相同：
- en: '[PRE2]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: That saves a lot of typing, which is great because we administrators want to
    type as little as possible (unless we’re writing a book).
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 这节省了很多输入，真是太好了，因为我们管理员希望尽可能少打字（除非我们在写书）。
- en: 'Let’s look at a few additional history commands we can use. First, if we want
    to delete something from the history, we can simply do this:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看一些额外的历史命令。首先，如果我们想从历史记录中删除某个条目，我们可以简单地执行以下命令：
- en: '[PRE3]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'In this example, we deleted item `563` from Bash’s history. To delete a different
    history entry, simply replace `563` with whatever the number is for the item we
    would want to remove. You may be wondering why deleting something from the history
    would be necessary. The answer to that is simple: sometimes we make mistakes.
    Perhaps we mistyped something, and we don’t want a junior administrator to look
    at the history and rerun an invalid command. Worse, if we accidentally saved a
    password to the history, it would be there for all to see. We would definitely
    want to remove that item so that the password isn’t saved in plain text in the
    history file. One very common example of this is with MySQL or MariaDB. When you
    enter the MySQL or MariaDB shell, you can use the `-p` option and type the password
    in one line. It would look something like this:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们从 Bash 的历史记录中删除了条目`563`。要删除其他历史记录条目，只需将`563`替换为我们想要删除的条目的编号。你可能会想，为什么从历史记录中删除某些内容是必要的。这个问题的答案很简单：有时我们会犯错。也许我们打错了什么，而我们不希望某个初级管理员查看历史记录并重新执行一个无效的命令。更糟糕的是，如果我们不小心将密码保存到了历史记录中，那么它将会被所有人看到。我们肯定会想要删除那条记录，这样密码就不会以明文形式保存在历史文件中。一个非常常见的例子是
    MySQL 或 MariaDB。当你进入 MySQL 或 MariaDB 的 shell 时，可以使用`-p`选项并在一行中输入密码。它可能是这样子的：
- en: '[PRE4]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: That command may appear useful, because in one command you’d be logged in to
    your database server as its own version of the `root user`. However, this is one
    of my pet peeves—I really don’t like it when people run commands that include
    a password in the clear. Having the `root` password in your shell’s history is
    a HUGE security risk. This is just one example of something you won’t want in
    our Bash history, though. My main goal here is to demonstrate that you should
    think about security when entering commands. If you have a potentially sensitive
    item in your command history, you should remove it. In fact, you can actually
    enter a command and not have it saved in the history at all. Simply prefix the
    command with a space. If you do, it will not be recorded in the history file.
    Go ahead, give it a try and see for yourself.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 这个命令看起来很有用，因为它可以让你通过一个命令以数据库服务器的`root`用户身份登录。然而，这也是我非常不喜欢的一点——我真的不喜欢有人在命令中直接写明密码。将`root`密码保存在
    shell 历史记录中是一个巨大的安全隐患。这只是你不希望出现在 Bash 历史记录中的一个例子。我在这里的主要目的是提醒你，在输入命令时要考虑安全。如果你的命令历史中有潜在的敏感信息，你应该将其删除。事实上，你实际上可以输入一个命令，但不将它保存在历史记录中。只需在命令前加一个空格。如果你这样做，它将不会被记录在历史文件中。试试看，亲自体验一下吧。
- en: Having commands prefixed with a space ignored in Bash is actually a custom option
    enabled by default in Ubuntu Server. Not all distributions include this feature
    enabled by default. If you’re using a distribution that doesn’t have this enabled
    already, add the following to your `.bashrc` file (we will talk about this file
    in greater detail later).
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Bash 中，前缀为空格的命令被忽略，实际上是 Ubuntu Server 默认启用的自定义选项。并非所有的发行版都默认启用此功能。如果你使用的发行版没有默认启用这个功能，可以将以下内容添加到你的`.bashrc`文件中（我们稍后会详细讲解这个文件）。
- en: '[PRE5]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: This configuration line also causes duplicate commands to not be entered into
    the history file as well, which can condense the history file.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 这一配置行还会导致重复的命令不被写入历史记录文件，从而可以压缩历史记录文件。
- en: So, you might be wondering, where is this history information actually stored?
    Check out the `.bash_history` file, which is found in your home directory (or
    `/root` for the `root` user). When you exit your shell, your history is copied
    to that file. If you remove that file, you’re effectively clearing your history.
    I don’t recommend you make a habit of that, though. Having a history of commands
    is very useful, especially when you may not remember how you solved a problem
    last time. History in Bash can save you from looking up a command again. To find
    out more about what the `history` command can do, check out the relevant man page
    with `man history`.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，你可能会问，这些历史记录信息到底存储在哪里呢？查看一下`.bash_history`文件，它位于你的主目录中（对于`root`用户来说是`/root`目录）。当你退出
    shell 时，历史记录会被复制到这个文件中。如果你删除这个文件，实际上就是清空了历史记录。但我不建议你养成删除它的习惯。保留命令历史记录非常有用，特别是当你可能不记得上次是如何解决某个问题的时候。Bash
    中的历史记录可以帮助你避免重复查找命令。要了解更多关于`history`命令的功能，查看相关的 man 页面，命令是`man history`。
- en: Learning new tricks with the command line that allow me to work more efficiently
    is a great feeling, at least for me. In the next section, we’ll explore some useful
    tricks we can utilize while working with the shell.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 学习使用命令行的新技巧，使我能更高效地工作，这是一个很棒的感觉，至少对我来说是这样。在接下来的部分，我们将探讨一些在使用 shell 时可以利用的有用技巧。
- en: Learning some useful command-line tricks
  id: totrans-45
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 学习一些有用的命令行技巧
- en: Productivity hacks utilizing the shell are some of my favorite things in this
    world, right up there with music, video games, and Diet Pepsi. There’s nothing
    like the feeling you get when you discover a useful feature that saves you time
    or increases your efficiency. There are many things I’ve discovered along the
    way that I wish I had known earlier on. One of my goals while writing this book
    is to teach you as many things as I can that took me longer to learn than I’m
    comfortable admitting to. In this section, in no particular order, I’ll go over
    a few tricks that increased my workflow.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 利用 shell 提高生产力的技巧是我最喜欢的事情之一，和音乐、电子游戏、健怡可乐一样。没有什么比你发现一个可以节省时间或提高效率的有用功能时的感觉更好了。我在这条路上发现了许多事情，真希望我早些知道它们。我写这本书的目标之一，就是教你我学得比我愿意承认的还要慢的那些东西。在这一部分，按顺序不分先后，我将介绍一些提高我工作流的技巧。
- en: 'First, entering `!!` (two exclamation marks) in your terminal will repeat the
    command you last used. By itself, this may not seem like much. After all, you
    can press the up arrow key once and press *Enter* to recall the previous command
    and execute it. But, when paired with `sudo`, `!!` becomes more interesting. Imagine
    for a moment that you entered a command that needs `root` privileges, but you
    forgot to use `sudo`. We’ve all made this mistake. In fact, as of the time I’m
    writing this chapter, I’ve been using Linux for 20 years and I *still* forget
    to use `sudo` from time to time. When we forget `sudo`, we have to type the command
    all over again. Or, we can just do this:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，在终端输入 `!!`（两个感叹号）将重复你上次使用的命令。单独使用这个功能看起来可能没什么特别的。毕竟，你可以按一次上箭头键，然后按 *Enter*
    来回忆上一个命令并执行它。但是，当与 `sudo` 一起使用时，`!!` 变得更有趣了。想象一下，你输入了一个需要 `root` 权限的命令，但忘记加上 `sudo`。我们都犯过这个错误。实际上，直到我写这本书的时候，我已经用了
    20 年的 Linux 了，但我*仍然*时不时忘记使用 `sudo`。当我们忘记加 `sudo` 时，我们必须重新输入命令。或者，我们可以直接这么做：
- en: '[PRE6]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: And just like that, you prefixed the previously used command with `sudo` without
    having to completely retype it.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 就这样，你用 `sudo` 前缀加上了之前使用的命令，而不必重新输入它。
- en: 'Speaking of avoiding unnecessary typing, a very easy (yet incredibly useful)
    feature is **Tab Completion**. Often, the Bash shell will be able to automatically
    complete part of your commands. If you start typing a few characters of a command
    or path, press *Tab* on your keyboard, and if the characters you’ve typed are
    enough to narrow down the result, the shell will complete the path for you. You
    can also press *Tab* twice in succession to see a list of possibilities that match
    the characters you’ve typed so far. Go ahead and give it a shot. By way of a quick
    example, you can type `ls` along with the path to your home directory, leaving
    some characters out on purpose. Then press *Tab*, and see whether the command
    automatically completes. For example, I can type the following into the terminal:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 说到避免不必要的输入，一个非常简单（但极其有用）的功能是**Tab 完成**。通常，Bash shell 可以自动完成你输入的部分命令。如果你开始输入命令或路径的几个字符，按下键盘上的*Tab*键，如果你输入的字符足以缩小结果范围，shell
    会为你完成路径。你也可以连续按两次*Tab*，以查看与已输入字符匹配的所有可能选项。试试看吧。举个例子，你可以输入 `ls` 和你主目录的路径，故意漏掉一些字符，然后按下*Tab*，看看命令是否会自动完成。例如，我可以在终端输入以下内容：
- en: '[PRE7]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'And after I press *Tab*, it completes the command for me:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 然后按下 *Tab*，它就自动完成了命令：
- en: '[PRE8]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'In addition, there are other special keyboard keys that will help you to navigate
    the command line quicker. Here’s a table containing some of the most useful keyboard
    shortcuts:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，还有一些特殊的键盘快捷键可以帮助你更快速地导航命令行。下面是一个包含一些最有用的键盘快捷键的表格：
- en: '| **Keyboard shortcut** | **Result** |'
  id: totrans-55
  prefs: []
  type: TYPE_TB
  zh: '| **键盘快捷键** | **结果** |'
- en: '| *Ctrl + a* | Moves the cursor to the beginning of the line |'
  id: totrans-56
  prefs: []
  type: TYPE_TB
  zh: '| *Ctrl + a* | 将光标移动到行首 |'
- en: '| *Ctrl + e* | Moves the cursor to the end of the line |'
  id: totrans-57
  prefs: []
  type: TYPE_TB
  zh: '| *Ctrl + e* | 将光标移动到行尾 |'
- en: '| *Ctrl + l* | Clears the screen |'
  id: totrans-58
  prefs: []
  type: TYPE_TB
  zh: '| *Ctrl + l* | 清屏 |'
- en: '| *Ctrl + k* | Deletes characters from the cursor to the end of the line |'
  id: totrans-59
  prefs: []
  type: TYPE_TB
  zh: '| *Ctrl + k* | 删除光标到行尾的字符 |'
- en: '| *Ctrl + u* | Deletes everything you’ve typed on that line (also works to
    clear text while entering a password) |'
  id: totrans-60
  prefs: []
  type: TYPE_TB
  zh: '| *Ctrl + u* | 删除当前行输入的所有内容（在输入密码时也能清除文本） |'
- en: '| *Ctrl + w* | Deletes the word to the left of the cursor |'
  id: totrans-61
  prefs: []
  type: TYPE_TB
  zh: '| *Ctrl + w* | 删除光标左侧的一个单词 |'
- en: Going a bit further into the command history, we can also press *Ctrl + r* on
    the shell to initiate a search. After pressing these keys, we can start typing
    a command, and we’ll get a preview of a command that matches what we’re typing,
    which will be narrowed down further as we type more characters of it. This is
    one of those things that is hard for me to describe, and screenshots certainly
    don’t help here, so go ahead and just give it a shot. For example, press *Ctrl
    + r* and then start typing `sudo apt`. The last time you used that command should
    appear, and you can press *Ctrl + r* again, and again, and again to see additional
    examples of commands that you’ve typed in the past that contain those characters.
    When you get efficient with this, it’s actually faster than the `history` command,
    but it takes a bit to get used to this.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 进一步探讨命令历史，我们还可以在 shell 中按 *Ctrl + r* 来启动搜索。按下这两个键后，我们可以开始输入一个命令，并且会看到一个与输入内容匹配的命令预览，随着输入更多字符，这个预览会进一步缩小范围。这是我很难描述的事情，截图也不太有帮助，所以不妨试试看。例如，按下
    *Ctrl + r* 然后开始输入 `sudo apt`。你上次使用该命令时的记录应该会出现，你可以再次按 *Ctrl + r*，这样会看到包含这些字符的历史命令的更多实例。当你熟练掌握这一技巧时，它实际上比
    `history` 命令更高效，但这需要一些时间来适应。
- en: 'Another fun trick is editing a command you’ve previously typed in a text editor.
    I know this sounds strange, but hear me out. Assume you pressed the up arrow,
    you have a very long command, and you just want to edit part of it without having
    to execute the entire thing, perhaps a command like this:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个有趣的技巧是，在文本编辑器中编辑你之前输入的命令。我知道这听起来很奇怪，但请耐心听我解释。假设你按了上箭头键，输入了一个非常长的命令，而你只想编辑其中的一部分，而不必执行整个命令，比如像这样：
- en: '[PRE9]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Let’s assume you want to install `nginx` instead of `apache2`, but the rest
    of the command is right. If you hold *Ctrl* and then press *x* followed by *e*,
    the command will open in a text editor. There, you can change the command. Once
    you’re done making your changes, the command will execute once you save the file.
    Admittedly, this is usually only useful when you have a very long command and
    you need to just change part of it. It’s also a little weird, but so are computers.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你想安装 `nginx` 而不是 `apache2`，但其余的命令是正确的。如果你按住 *Ctrl* 然后按 *x* 再按 *e*，命令会在文本编辑器中打开。在那里，你可以更改命令。修改完毕后，一旦保存文件，命令就会执行。坦白说，这通常只有在你有非常长的命令，需要更改其中的一部分时才有用。虽然这有点奇怪，但计算机本身也挺奇怪的。
- en: 'Did you notice the two `&` symbols in the previous command? This is another
    useful trick; you can actually chain commands together. In the previous example
    command, we’re telling the shell to execute `sudo apt update`. Next, we’re telling
    the shell to then execute `sudo apt install apache2`. The double ampersand is
    known as the logical `AND` operator, so the second command is run if the first
    was successful. If the first command was successful, the second command will execute
    right after. Another method to chain commands is this:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 你注意到之前命令中的两个 `&` 符号了吗？这是另一个有用的技巧；你实际上可以将多个命令链接在一起。在之前的命令示例中，我们告诉 shell 执行 `sudo
    apt update`。接着，我们告诉 shell 执行 `sudo apt install apache2`。双重和号被称为逻辑 `AND` 运算符，因此第二个命令只有在第一个命令成功时才会执行。如果第一个命令成功，第二个命令会紧接着执行。另一种链接命令的方法是：
- en: '[PRE10]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'The difference with the semicolon is that we’re telling the shell to execute
    the second command *regardless* of whether the first command was successful. You
    may then be wondering, what constitutes success on the shell? An obvious answer
    to this question might be “it’s successful if there are no error messages.” While
    that’s often true, the shell utilizes exit codes to programmatically attribute
    success or failure. You can see the exit code of a command by typing this immediately
    after the previous command finishes:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 与分号的区别在于，我们告诉 shell 执行第二个命令，*无论*第一个命令是否成功。你可能会想，什么才算 shell 上的成功呢？一个显而易见的答案可能是“没有错误信息就是成功”。虽然这通常是对的，但
    shell 使用退出码来编程地标识成功或失败。你可以通过在上一个命令完成后立即输入以下命令来查看命令的退出码：
- en: '[PRE11]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: An exit code of `0` means success; anything else is some sort of error. Different
    programs will attribute different codes to different types of failures, but `0`
    is always a success. With this command, what we’re actually doing is printing
    the content of a variable. `$?` is actually a variable, which in this case only
    exists to hold an exit code. The `echo` command itself can be used to print text
    to the shell, but it’s often used to print the contents of a variable (we’ll get
    into this in more detail in the *Understanding variables* section).
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: '`0`的退出代码表示成功；其他任何代码则表示某种错误。不同的程序会为不同类型的失败分配不同的代码，但`0`始终表示成功。通过这个命令，我们实际上是在打印一个变量的内容。`$?`实际上是一个变量，在这种情况下它仅用于存储退出代码。`echo`命令本身可以用于向终端打印文本，但它常常被用来打印变量的内容（我们将在*理解变量*部分详细讨论这个）。'
- en: 'Now, it’s time for my favorite time-saving trick of them all—command aliases.
    The concept of an alias is simple: it allows you to create a command that is just
    another name for another command. This allows you to simplify commands down to
    just one word or a few letters. Consider this command, for example:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，到了我最喜欢的节省时间的小技巧——命令别名的时候了。别名的概念很简单：它允许你创建一个命令，实际上是另一个命令的别名。这让你可以将命令简化为一个单词或几个字母。比如，考虑这个命令：
- en: '[PRE12]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: When you enter the previous command, you will receive no actual output. But
    what happens is now you have a new command available—`install`. This command isn’t
    normally available; you just created it with this command.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 当你输入前面的命令时，实际上不会有任何输出。但发生的事情是你现在拥有了一个新命令——`install`。这个命令通常是不可用的，你刚刚通过这个命令创建了它。
- en: You can verify that the alias was created successfully by simply running the
    `alias` command, which will show you a list of aliases present in the shell. If
    you create a new alias, you should see it in the output. You’ll also see additional
    aliases in the output that you did not create. This is because Ubuntu sets up
    some by default. In fact, even the `ls` command is an alias!
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过运行`alias`命令来验证别名是否成功创建，这会显示当前在 shell 中存在的别名列表。如果你创建了新的别名，你应该能在输出中看到它。你还会看到输出中出现你没有创建的其他别名，这是因为
    Ubuntu 默认设置了一些别名。事实上，连`ls`命令本身也是一个别名！
- en: 'With this new alias created, any time you execute `install` on the command
    line, you’re instead executing `sudo apt install`. Now, installing packages becomes
    simpler:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 创建这个新的别名后，每次在命令行中执行`install`时，实际上是在执行`sudo apt install`。现在，安装软件包变得更简单了：
- en: '[PRE13]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Just like that, you installed `tmux`. You didn’t have to type `sudo apt install
    tmux`; you just simplified the first three words in the command into `install`.
    In fact, you can simplify it even further:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 就这样，你安装了`tmux`。你不需要输入`sudo apt install tmux`，你只是将命令中的前三个词简化成了`install`。事实上，你甚至可以将它进一步简化：
- en: '[PRE14]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Now, you can install a package with this:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你可以使用以下命令安装软件包：
- en: '[PRE15]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: With aliases, you can get very creative. Here are some of my personal favorites.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 使用别名，你可以发挥很大的创造力。这是我个人最喜欢的一些别名。
- en: 'View the top 10 most-CPU-consuming processes:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 查看消耗 CPU 最多的前 10 个进程：
- en: '[PRE16]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'View the top 10 most-RAM-consuming processes:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 查看消耗 RAM 最多的前 10 个进程：
- en: '[PRE17]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'View all mounted filesystems, and present the information in a clean tabbed
    layout:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 查看所有已挂载的文件系统，并以干净的标签页布局展示信息：
- en: '[PRE18]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Clear the screen by simply typing `c`:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 通过简单地输入`c`来清除屏幕：
- en: '[PRE19]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: What other aliases can you come up with? Think of a command you may use on a
    regular basis and simplify it.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 你能想出其他的别名吗？想一想你可能经常使用的命令，并简化它。
- en: 'There’s one issue though, and that is the fact that when you exit your terminal
    window, your aliases are wiped out. How do you retain them? That leads me to my
    next productivity trick, editing your `.bashrc` file. This file is present in
    your home directory and is read every time you start a new terminal session. You
    can add all of your `alias` commands there; just add them somewhere in the file
    (for example, at the end). You will need to include the entire command, beginning
    with `alias` and ending with the commands in quotes. If you wanted to steal my
    example aliases, you would enter the following lines somewhere in your `.bashrc`
    file:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 但是有一个问题，那就是当你退出终端窗口时，你的别名会被清除。如何保留它们呢？这就引出了我的下一个提高效率的小技巧，编辑你的`.bashrc`文件。这个文件位于你的主目录中，并且每次你启动一个新的终端会话时都会被读取。你可以在其中添加所有的`alias`命令；只需将它们添加到文件中的某个位置（例如，文件末尾）。你需要包括整个命令，从`alias`开始，到命令的引号结束。如果你想复制我的示例别名，你可以将以下几行添加到你的`.bashrc`文件中的某个位置：
- en: '[PRE20]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'There are, of course, additional time-saving tricks that we could talk about
    here, but then again, Bash is so complex that we can write an entire book about
    it (and many people have). As we go along in this chapter, I’ll give you even
    more tips. For now, here’s a final trick, which changes your working directory
    back to the previous directory you were in:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，我们还可以讨论更多节省时间的技巧，但 Bash 的复杂性足以让我们写一本书（而且很多人确实这么做了）。随着本章的进行，我会给你更多的提示。现在，给你一个最后的技巧，它会将你的工作目录切换回你之前所在的目录：
- en: '[PRE21]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: That simple command was mentioned in *Chapter 4*, *Navigating and Essential
    Commands*, but it’s worth a second mention—you’re welcome! Next, let’s take a
    look at shell variables, which allow us to store information for easy access in
    other commands.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 这个简单的命令在*第4章*，*导航和基本命令*中有提到，但值得再提一遍——不客气！接下来，让我们看看 shell 变量，它们允许我们存储信息，以便在其他命令中轻松访问。
- en: Understanding variables
  id: totrans-96
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解变量
- en: Bash is more than just a shell. You could argue that it is very similar to a
    complete programming language, and you wouldn’t be wrong. Bash has a built-in
    scripting engine (we will get into scripting later) and there are many debates
    as to what distinguishes a scripting language from a programming language, and
    that line becomes more and more blurred as new languages come out.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: Bash 不仅仅是一个 shell。你可以说它非常类似于一个完整的编程语言，这样的说法并不错误。Bash 有一个内建的脚本引擎（稍后我们将讨论脚本编写），关于脚本语言和编程语言的区别存在很多争议，随着新语言的出现，这两者之间的界限也越来越模糊。
- en: 'As with any scripting language, Bash supports variables. The concept of variables
    is very simple in Bash, but I figured I’d give it its own (relatively short) section
    to make sure you understand the basics. You can set a variable with a command
    such as the following:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 与任何脚本语言一样，Bash 也支持变量。Bash 中变量的概念非常简单，但我觉得有必要单独（相对简短地）讲解这一部分，以确保你理解基础知识。你可以通过如下命令设置变量：
- en: '[PRE22]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'When Bash encounters an equal sign after a string, it assumes you’re creating
    a variable. Here, we’re creating a variable named `myvar` and setting it equal
    to `Hello world!` Whenever we refer to a variable, though, we need to specifically
    clarify to Bash that we’re requesting a variable, and we do that by prefixing
    it with a dollar symbol (`$`). Consider this command:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 当 Bash 遇到等号后面的字符串时，它认为你正在创建一个变量。在这里，我们创建了一个名为`myvar`的变量，并将其设置为`Hello world!`然而，每次引用变量时，我们需要明确告诉
    Bash 我们正在请求一个变量，方法是用美元符号（`$`）前缀它。考虑一下这个命令：
- en: '[PRE23]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: If you’ve set the variable as I have, executing that command will print `Hello
    world!` to `stdout`. The `echo` command is very useful for printing the contents
    of variables. The key thing to remember here is that when you *set* a variable,
    you don’t include the `$` symbol, but you do when you retrieve it. Also, keep
    in mind that there’s no space on either side of the equals sign.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你像我一样设置了变量，执行该命令将会将`Hello world!`打印到`stdout`。`echo`命令在打印变量内容时非常有用。这里需要记住的关键是，当你*设置*一个变量时，不需要加`$`符号，但在获取变量时需要加上。另外，请记住等号两边不能有空格。
- en: You will see variations of variable name formats as you work with various Linux
    servers. For example, you may see variable names in all caps, camel case (`MyVar`),
    as well as other variations. These variations are all valid, and depending on
    the background of the individual creating them (developers, administrators, and
    so on), you may see different forms of variable naming. It’s also extremely common
    that built-in variables created as part of the distribution will be named in all
    upper case.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用各种 Linux 服务器时，你会看到变量名格式的不同变体。例如，你可能会看到全大写的变量名、驼峰命名法（`MyVar`）等其他变体。这些变体都是有效的，具体使用哪种形式取决于创建者的背景（开发者、管理员等），因此你可能会看到不同的变量命名方式。内建的变量通常会采用全大写的命名方式，这也非常常见。
- en: 'Variables work in other aspects of the shell as well, not just with `echo`.
    Consider this:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 变量也可以在 shell 的其他方面使用，而不仅仅是与`echo`一起。考虑一下这个：
- en: '[PRE24]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Here, we’re storing a directory name in a variable and using the `ls` command
    against it to list its contents. This may seem relatively useless, but when you’re
    scripting, this will save you time. Anytime you need to refer to something more
    than once, it should be in a variable. That way, in a script, you can change the
    contents of that variable just one time and everywhere in the script will reference
    it.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们将一个目录名称存储在变量中，并使用 `ls` 命令列出其内容。这看起来可能相对无用，但在编写脚本时，这将为你节省时间。任何你需要多次引用的内容，都应该放在变量中。这样，在脚本中，你只需修改一次该变量的内容，脚本中的所有地方都会引用到它。
- en: 'There are also variables that are automatically present in your shell that
    you did not explicitly set yourself. Enter this command for fun:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一些在你的 shell 中自动存在的变量，这些是你没有明确设置的。执行以下命令来试试看：
- en: '[PRE25]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Wow! You should see a lot of variables, especially if you enter it in a desktop
    version of Ubuntu.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 哇！你应该能看到很多变量，特别是如果你在 Ubuntu 的桌面版本中输入它的话。
- en: These variables are set by the system, but can still be accessed via `echo`
    as you would any other. Some notable ones include `$SHELL` (stores the name of
    the binary that currently handles your shell), `$USER` (stores your current username),
    and `$HOST` (stores the hostname for your device). Any of these variables can
    be accessed at any time, and may even prove beneficial in scripts.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 这些变量是由系统设置的，但仍然可以像其他变量一样通过 `echo` 访问。其中一些值得注意的包括 `$SHELL`（存储当前处理你的 shell 的二进制文件名）、`$USER`（存储当前用户名）和
    `$HOST`（存储你设备的主机名）。这些变量可以随时访问，甚至在脚本中也能发挥作用。
- en: 'We’ve already gone over **standard output** (**stdout**), **standard error**
    (**stderr**), and **standard input** (**stdin**) in the previous chapter. We’ll
    use standard input again here, when we capture input to store it as a variable.
    Try this command for example:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经在上一章讲解了**标准输出**（**stdout**）、**标准错误**（**stderr**）和**标准输入**（**stdin**）。我们在这里再次使用标准输入，当我们捕获输入并将其存储为变量时。尝试执行以下命令：
- en: '[PRE26]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'When you run this command, you’ll just be brought to a blank line, with no
    indication as to what you should be doing. Go ahead and enter your age, and then
    press *Enter*. Next, run this:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 当你运行此命令时，你会被带到一个空白行，没有任何提示说明你应该做什么。继续输入你的年龄，然后按 *Enter*。接下来，执行这个：
- en: '[PRE27]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'In a script, you would want to inform the user what they should be entering,
    so you would probably use something similar to these commands:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 在脚本中，你需要告知用户他们应该输入什么，所以你可能会使用类似于以下的命令：
- en: '[PRE28]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: We’ve discussed standard input in the previous chapter, and we can see it in
    action again here as we capture input from the user and store it in a variable.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在上一章讨论了标准输入，这里我们可以再次看到它的应用，我们从用户获取输入并将其存储在一个变量中。
- en: Automation is a subject we’ll explore multiple times throughout the remainder
    of the book, which will include more advanced subjects such as configuration management.
    Writing scripts is the simplest form of automation, which gives you the ability
    to type commands in a text file and have them all execute. That’s what we’ll explore
    next.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 自动化是我们将在本书剩余部分多次探讨的主题，其中将包括更多高级主题，如配置管理。编写脚本是最简单的自动化形式，它让你能够将命令写入文本文件并逐一执行。这就是我们接下来要探讨的内容。
- en: Writing simple scripts
  id: totrans-119
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编写简单脚本
- en: 'This is the section where everything we’ve talked about so far starts to come
    together. Writing scripts can be very fun and rewarding, as they allow you to
    automate large jobs or just simplify something that you find yourself doing over
    and over. The most important point about scripting is this: if it’s something
    you’ll be doing more than once, you really should be making it into a script.
    This is a great habit to get into.'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们到目前为止讨论的所有内容开始汇聚的部分。编写脚本既有趣又有回报，因为它们允许你自动化大任务，或简化那些你反复执行的操作。关于脚本的最重要一点是：如果是你需要做多次的事情，确实应该将其写成脚本。这是一个非常好的习惯。
- en: A script is a very simple concept; it’s just a text file that contains commands
    for your shell to execute one by one. A script written to be executed by Bash
    is known as a Bash script, and that’s what we’ll work on creating in this section.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 脚本是一个非常简单的概念；它只是一个包含 shell 要逐一执行命令的文本文件。专门为 Bash 执行编写的脚本被称为 Bash 脚本，这就是我们在本节中将要创建的脚本类型。
- en: 'At this point, I’m assuming that you’ve practiced a bit with a text editor
    in Linux. It doesn’t matter if you use Vim or Nano. Since we’ve edited text files
    before (we went over that in *Chapter 5*, *Managing Files and Directories*), I’m
    under the assumption that you already know how to create and edit files. We’ll
    be using a text editor to create a simple script as an example, using the following
    command:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，我假设你已经在 Linux 上使用过文本编辑器。不管你是使用 Vim 还是 Nano。既然我们之前已经编辑过文本文件（我们在 *第 5 章*，*文件和目录管理*
    中讲过），我假设你已经知道如何创建和编辑文件了。我们将使用文本编辑器来创建一个简单的脚本作为示例，使用以下命令：
- en: '[PRE29]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'If you weren’t already aware, a tilde (`~`) is just a shortcut for a user’s
    home directory. Therefore, on my system, the previous command would be the same
    as if I had typed:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你还不清楚，波浪线（`~`）只是指代用户主目录的快捷方式。因此，在我的系统上，前面的命令就相当于我输入了：
- en: '[PRE30]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Inside the file, type the following:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 在文件中，输入以下内容：
- en: '[PRE31]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Save the file and exit the editor. In order to run this file as a script, we
    need to mark it as executable:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 保存文件并退出编辑器。为了将此文件作为脚本运行，我们需要将它标记为可执行：
- en: '[PRE32]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'To execute it, we simply call the path to the file and the filename:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 要执行它，我们只需要调用文件的路径和文件名：
- en: '[PRE33]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'The output should look similar to the following:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 输出应该类似于以下内容：
- en: '[PRE34]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: The first line, `#!/bin/bash`, might seem strange if you haven’t seen it before.
    Normally, lines starting with a hash symbol (`#`) are ignored by the interpreter.
    The one on the first line is an exception to this. The `#!/bin/bash` entry we
    see on the first line is known as a **hash bang**, or **shebang**. Basically,
    it just tells the kernel which interpreter to use in order to run the commands
    inside the script. There are other interpreters we could be using, such as `#!/usr/bin/python`
    if we were writing a script in the Python language. Since we’re writing a Bash
    script, we used `#!/bin/bash`.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 第一行 `#!/bin/bash` 可能会让你觉得奇怪，如果你以前没见过它。通常，带有井号（`#`）符号的行会被解释器忽略。但是第一行是一个例外。我们在第一行看到的
    `#!/bin/bash` 叫做 **哈希bang** 或 **shebang**。基本上，它只是告诉内核应该使用哪个解释器来执行脚本中的命令。如果我们写的是Python脚本，可能会使用
    `#!/usr/bin/python`。但是因为我们编写的是 Bash 脚本，所以使用了 `#!/bin/bash`。
- en: The lines that followed were simple print statements. Each one used a system
    variable, so you didn’t have to declare any of those variables as they already
    existed. Here, we printed the current user’s username and home directory.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 后面的几行是简单的打印语句。每一行都使用了系统变量，所以你不需要声明这些变量，因为它们已经存在。在这里，我们打印了当前用户的用户名和主目录。
- en: 'The concept of scripting becomes more valuable when you start to think of things
    you do on a regular basis that you can instead automate. To be an effective Linux
    administrator, it’s important to adopt the automation mindset. Again, if you are
    going to do a job more than once, script it. Here’s another example script to
    help drive this concept home. This time, the script will actually be somewhat
    useful:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 脚本的概念变得更加有价值，当你开始考虑那些你日常做的事情，你可以用自动化来替代它们时。作为一名有效的 Linux 管理员，采用自动化思维方式非常重要。再说一遍，如果你需要做某项工作超过一次，那就写个脚本吧。这里有另一个示例脚本，帮助你理解这个概念。这一次，这个脚本将会稍微有点用：
- en: '[PRE35]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: What we’ve done here is theoretically scripted the setup of a web server. We
    could extend this script further by having it copy site content to `/var/www/html`,
    enable a configuration file, and so on. But from the preceding script, you can
    probably see how scripting can be useful in condensing the amount of work you
    do. This script could be an advanced web server install script that you could
    simply copy to a new server and then run.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里做的，理论上是脚本化了一个 Web 服务器的设置。我们可以进一步扩展这个脚本，让它将网站内容复制到 `/var/www/html`，启用配置文件等等。但从上面的脚本来看，你可能已经看出，脚本可以帮助你减少工作量。这个脚本可以是一个高级的
    Web 服务器安装脚本，你可以将它直接复制到新服务器上然后运行。
- en: Notice that the example uses the `-y` option with `apt`. If you weren’t already
    aware, that automatically answers *yes* to prompts that may come up as part of
    the process. Scripts are typically not interactive, meaning there may not be an
    administrator sitting in front of it to answer prompts when they appear. Also,
    using the `a2enmod` command to enable `php8.1` was not really necessary, as it
    would’ve been enabled automatically as part of installing the `libapache2-mod-php8.1`
    package. But I think you get the idea; we want to be explicit in scripts and type
    instructions for the exact state we want things to be in.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，示例中使用了`apt`的`-y`选项。如果你之前没有注意到，这会自动回答*yes*，以应对在过程中可能出现的提示。脚本通常是非交互式的，这意味着可能没有管理员在旁边处理提示问题。另外，使用`a2enmod`命令启用`php8.1`实际上并不必要，因为它在安装`libapache2-mod-php8.1`包时已经会自动启用。但我想你明白我的意思；我们希望在脚本中明确写出，给出我们希望的具体状态。
- en: 'Now, let’s get a bit more advanced with scripting. The previous script only
    installed some packages, something we probably could’ve done just as easily by
    copying and pasting the commands into the shell. Let’s take this script a bit
    further. Let’s write a conditional statement. Here’s a modified version of the
    previous script:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们更深入一点编写脚本。之前的脚本只是安装了一些包，实际上我们可能也可以通过复制和粘贴命令到 shell 中轻松完成。让我们把这个脚本做得更进一步。让我们编写一个条件语句。这是之前脚本的修改版本：
- en: '[PRE36]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Now it’s getting a bit more interesting. The first line after the hash bang
    is a comment, letting us know what the script does:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 现在它变得有趣起来了。哈希标记之后的第一行是一个注释，告诉我们脚本的作用：
- en: '[PRE37]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Comments are ignored by the interpreter, but are useful in letting us know what
    a block of code is doing.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 注释被解释器忽略，但它们有助于让我们知道代码块在做什么。
- en: 'Next, we start an `if` statement:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们开始一个`if`语句：
- en: '[PRE38]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Bash, like any scripting language, supports branching and the `if` statement
    is one way of doing that. Here, it’s checking for the existence of the `apache2`
    binary. The `-f` option here specifies that we’re looking for a file. We can change
    this to `-d` to check for the existence of a directory instead. The exclamation
    mark is an inverse. It basically means we’re checking if something is *not* present.
    If we wanted to check if something *is* present, we would omit the exclamation
    mark. Basically, we’re setting up the script to do nothing if Apache is already
    installed. In this case, inside the brackets we are just executing a shell command,
    and then the result is checked. The commands sandwiched inside the `if` statement
    are simply installing packages.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: Bash，像任何脚本语言一样，支持分支，`if`语句就是实现分支的一种方式。在这里，它正在检查`apache2`二进制文件是否存在。这里的`-f`选项表示我们正在查找一个文件。我们可以将其更改为`-d`来检查目录是否存在。感叹号表示取反。它基本上意味着我们在检查某个东西*是否*不存在。如果我们想检查某个东西*是否*存在，我们将省略感叹号。基本上，我们正在设置脚本，如果
    Apache 已经安装，就不执行任何操作。在这种情况下，在方括号中我们只是执行一个 shell 命令，然后检查结果。`if`语句中的命令只是安装包。
- en: Finally, we close out our `if` statement with the word *if* backward (`fi`).
    If you forget to do this, the script will fail.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们用*if*的反向词（`fi`）来结束我们的`if`语句。如果你忘记这么做，脚本将会失败。
- en: 'With regard to the concept of `if` statements, we can compare values as well.
    Consider the following example:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 关于`if`语句的概念，我们也可以比较值。请看以下例子：
- en: '[PRE39]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'With this script, we’re merely checking the contents of a variable, and taking
    action if it equals a certain number. Notice we didn’t use quotation marks when
    creating the variable, since we just set a number (integer) here. We would’ve
    only used quotation marks if we wanted to set the variable value to a string.
    We can also take action if the `if` statement doesn’t match:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这个脚本，我们只是检查一个变量的内容，并在其等于某个特定数字时采取行动。注意，我们在创建变量时没有使用引号，因为这里只是设置了一个数字（整数）。只有当我们想把变量值设置为字符串时，才会使用引号。如果`if`语句不匹配，我们也可以采取行动：
- en: '[PRE40]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: This was a silly example, I know, but it works as far as illustrating how to
    create an `if`/`else` logic block in Bash. The `if` statement checks to see whether
    the variable was equal to `1`. It isn’t, so the `else` block executes instead.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个愚蠢的例子，我知道，但它有助于说明如何在 Bash 中创建`if`/`else`逻辑块。`if`语句检查变量是否等于`1`。它不是，所以执行`else`块。
- en: The `-eq` portion of the command is similar to `==` in most programming languages.
    It’s checking to see whether the value is equal to something. Alternatively, we
    can use `-ne` (not equal), `-gt` (greater than), `-ge` (greater than or equal
    to), `-lt` (less than), and so on.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 命令中的`-eq`部分类似于大多数编程语言中的`==`。它是在检查某个值是否等于某个值。或者，我们可以使用`-ne`（不等于）、`-gt`（大于）、`-ge`（大于或等于）、`-lt`（小于）等。
- en: 'At this point, I recommend you take a break from reading to further practice
    scripting (practice is key to committing concepts to memory). Try the following
    challenges:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一点上，我建议你暂停阅读，进一步练习脚本编写（练习是将概念牢记在心的关键）。尝试以下挑战：
- en: Ask the user to enter input, such as their age, and save it to a variable. If
    the user enters a number less than 30, tell them they’re young. If the number
    is equal to or greater than 30, `echo` a statement telling them that they’re old.
  id: totrans-156
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要求用户输入信息，例如他们的年龄，并将其保存到一个变量中。如果用户输入的数字小于30，告诉他们他们还年轻。如果数字大于或等于30，使用`echo`打印出一个告诉他们已经老了的语句。
- en: Write a script that copies a file from one place to another. Make the script
    check to see whether that file exists first, and have an `else` statement printing
    an error if the file doesn’t exist.
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编写一个脚本，将一个文件从一个地方复制到另一个地方。让脚本先检查文件是否存在，如果文件不存在，使用`else`语句打印错误信息。
- en: Think about any topic we’ve already worked on during this book, and attempt
    to automate it.
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 想想我们在本书中已经学习过的任何主题，并尝试将其自动化。
- en: 'Now, let’s take a look at another concept, which is looping. The basic idea
    behind looping is simply doing something repeatedly until a condition has been
    met. Consider the following example script:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们来看看另一个概念，那就是循环。循环的基本思想就是反复执行某个操作，直到满足某个条件。考虑以下示例脚本：
- en: '[PRE41]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: Let’s go through the script line by line to understand what it’s doing.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们逐行分析脚本，以理解它在做什么。
- en: '[PRE42]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: With this new script, we’re creating a control variable, called `myvar`, and
    setting it equal to `1`.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这个新脚本，我们创建了一个控制变量，名为`myvar`，并将其设置为`1`。
- en: '[PRE43]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: Next, we set up a `while` loop. A `while` loop will continue until a condition
    is met. Here, we’re telling it to execute the statements in the block over and
    over until `$myvar` becomes equal to `15`. In fact, a `while` loop can continue
    forever if you enter something incorrectly, which is known as an **infinite loop**.
    An infinite loop is dangerous, and can cause your server to stop responding. If
    you used `-ge 0` instead, you would’ve created exactly that.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们设置一个`while`循环。`while`循环会持续执行，直到满足某个条件。在这里，我们告诉它重复执行代码块中的语句，直到`$myvar`等于`15`。事实上，如果你输入不正确的条件，`while`循环可能会永远执行下去，这就是所谓的**无限循环**。无限循环是危险的，可能导致服务器停止响应。如果你用了`-ge
    0`，你就创建了一个这样的循环。
- en: '[PRE44]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: With `do`, we’re telling the `for` loop to prepare itself to start doing something.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`do`，我们告诉`for`循环准备开始执行某些操作。
- en: '[PRE45]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: Here, we’re printing the current content of the `$myvar` variable—nothing surprising
    here.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们打印出当前`$myvar`变量的内容——没有什么令人惊讶的地方。
- en: '[PRE46]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: With this statement, we’re using what’s known as an incrementor to increase
    the value of our variable by `1`. The double parenthesis tells the shell that
    we’re doing an arithmetic operation, so the interpreter doesn’t think that we’re
    working with strings.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这个语句，我们使用了所谓的增量器来将变量的值增加`1`。双重括号告诉 shell 我们正在进行一个算术运算，因此解释器不会误认为我们在处理字符串。
- en: '[PRE47]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: When we’re done writing a `while` loop, we must close the block with `done`.
    If you’ve typed the script properly, it should count from `1` to `15`.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们编写完`while`循环时，必须用`done`来关闭代码块。如果你正确输入了脚本，它应该从`1`计数到`15`。
- en: 'Another type of loop is a `for` loop. A `for` loop executes a statement for
    every item in a set. For example, you can have the `for` loop execute a command
    against every file in a directory. Consider this example:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种类型的循环是`for`循环。`for`循环会对集合中的每个项执行一条语句。例如，你可以让`for`循环对目录中的每个文件执行一个命令。考虑这个例子：
- en: '[PRE48]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'Let’s take a deeper look into what we’ve done here:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们深入探讨一下我们在这里做了什么：
- en: '[PRE49]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Here, we’re creating a list and populating it with names. Each name is one
    item in the list. We’re calling this list `turtles`. We can see the contents of
    this list with `echo` as we would with any other variable:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们创建了一个列表并将其填充上名字。每个名字都是列表中的一个项目。我们将这个列表命名为`turtles`。我们可以像查看任何其他变量一样，使用`echo`查看该列表的内容：
- en: '[PRE50]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'Next, let’s look at how we set up the `for` loop:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们看看如何设置`for`循环：
- en: '[PRE51]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: Now, we’re telling the interpreter to prepare to do something for every item
    in the list. The `t` here is arbitrary, we could’ve used any letter here or even
    a longer string. We’re just setting up a temporary variable we want to use in
    order to hold the current item the script is working on.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们告诉解释器准备对列表中的每一项执行某些操作。这里的`t`是任意的，我们可以使用任何字母，甚至是更长的字符串。我们只是设置了一个临时变量，用来保存脚本正在处理的当前项。
- en: '[PRE52]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: With `do`, we’re telling the `for` loop to prepare itself to start doing something.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`do`，我们告诉`for`循环准备开始执行某些操作。
- en: '[PRE53]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: Now, we’re printing the current value of `$t` to `stdout`.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将当前`t`的值打印到`stdout`。
- en: '[PRE54]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'Just as we did with the `while` loop, we type `done` to let the interpreter
    know this is the end of the `for` loop. Effectively, we just created a `for` loop
    to print each item in a list independently:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 就像我们在使用`while`循环时做的那样，我们输入`done`来让解释器知道这是`for`循环的结束。实际上，我们刚刚创建了一个`for`循环，用来独立地打印列表中的每一项：
- en: '[PRE55]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: We included four turtle names in our list, and we were able to iterate through
    them and print them out, one by one.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在列表中包含了四个乌龟的名字，我们能够遍历它们并逐个打印出来。
- en: As much as I love turtles (especially the teenage mutant ninja variety), that
    script isn’t very practical or useful to us for server administration. Next, we’re
    going to write a script that can actually be quite useful.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管我喜欢乌龟（尤其是忍者神龟），但是这个脚本对于服务器管理来说并不是特别实用或有用。接下来，我们将编写一个实际上非常有用的脚本。
- en: Putting it all together – Writing an rsync backup script
  id: totrans-192
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 把所有内容放在一起——编写一个rsync备份脚本
- en: 'Let’s close this chapter with a Bash script that will not only prove to be
    very useful but will also help you enhance your skills. The `rsync` utility is
    one of my favorites; it’s very useful for copying data from one place to another,
    as well as being helpful for setting up a backup job. Let’s use the following
    example `rsync` command to practice automation:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们用一个Bash脚本来结束这一章，它不仅非常实用，还能帮助你提高技能。`rsync`工具是我最喜欢的工具之一；它在将数据从一个地方复制到另一个地方时非常有用，也有助于设置备份任务。让我们使用以下的`rsync`命令来练习自动化：
- en: '[PRE56]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: This example `rsync` command uses the `-a` (archive) option, which retains the
    metadata of the file(s) it copies to the target, such as the timestamp and owner.
    The `-v` option gives us verbose output, so we can see exactly what `rsync` is
    doing. The `-b` option enables backup mode, which means that if a file on the
    target will be overwritten by a file from the source, the previous version of
    that file will be renamed so it won’t be overwritten. Combining these three options,
    we simplify it to `-avb` rather than typing `-a -v -b`. The `--delete` option
    tells `rsync` to delete any files in the target that aren’t present in the source
    (since we used `-b`, any file that is deleted will be retained).
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 这个示例`rsync`命令使用了`-a`（归档）选项，它保留了文件的元数据（例如时间戳和所有者）在目标中复制的文件。`-v`选项提供了详细输出，这样我们可以准确看到`rsync`正在做什么。`-b`选项启用了备份模式，这意味着如果目标文件将被源文件覆盖，那么目标文件的旧版本将被重命名以防被覆盖。将这三个选项结合在一起，我们简化为`-avb`，而不是输入`-a
    -v -b`。`--delete`选项告诉`rsync`删除目标中不存在于源中的任何文件（由于我们使用了`-b`，被删除的文件会被保留）。
- en: The `--backup-dir` option tells `rsync` that any time a file would have been
    renamed in this way (or deleted), to instead just copy it to another directory.
    In this case, we send any files that would have been overwritten to the `/backup/incremental/08-16-2022`
    directory.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: '`--backup-dir`选项告诉`rsync`，每当一个文件会被这样重命名（或删除）时，改为将其复制到另一个目录。在这种情况下，我们将所有可能被覆盖的文件发送到`/backup/incremental/08-16-2022`目录。'
- en: 'Let’s script this `rsync` job. One problem we can fix in our script right away
    is the date that is present inside the directory we’re using for the `--backup-dir`.
    The date changes every day, so we shouldn’t be hardcoding this. Therefore, let’s
    start our script by addressing this:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们编写这个`rsync`任务的脚本。我们可以立刻修复的一个问题是目录中日期的存在，这个日期是我们在`--backup-dir`中使用的目录路径的一部分。日期每天都会变化，所以我们不应该将其写死在代码中。因此，让我们从解决这个问题开始脚本：
- en: '[PRE57]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: We’re creating a variable called `curdate`. We’re setting it equal to the output
    of the `$(date +%m-%d-%Y)` command. You can execute `date +%m-%d-%Y` in your terminal
    window to see exactly what that does. In this case, putting a command (such as
    `date`) in parentheses and a dollar symbol means that we’re executing the command
    in a **sub-shell**. The command will run, and we’re going to capture the result
    of that command and store it in the `curdate` variable.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 我们正在创建一个名为`curdate`的变量。我们将其设置为`$(date +%m-%d-%Y)`命令的输出。你可以在终端窗口中执行`date +%m-%d-%Y`来查看它具体做了什么。在这种情况下，将命令（例如`date`）放在括号中，并在前面加上美元符号意味着我们在**子Shell**中执行该命令。命令会运行，我们将捕获该命令的结果并存储在`curdate`变量中。
- en: 'Next, let’s make sure `rsync` is actually installed, and install it if it’s
    not:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们确保`rsync`已经安装，如果没有安装，则进行安装：
- en: '[PRE58]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: Here, we’re simply checking to see whether `rsync` is *not* installed. If it’s
    not, we’ll install it via `apt`. This is similar to how we checked for the existence
    of `apache2` earlier in this chapter.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们仅仅是检查是否没有安装`rsync`。如果没有安装，我们将通过`apt`进行安装。这与我们在本章前面检查`apache2`是否存在的方式类似。
- en: 'Now, we add the final line:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们添加最后一行：
- en: '[PRE59]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'You can definitely see the magic of variables in Bash now, if you haven’t already.
    We’re including `$curdate` in our command, which is set to whatever the current
    date actually is. When we put it all together, our script looks like this:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你还没有发现，Bash中的变量魔力现在肯定能让你看得清楚。我们在命令中包含了`$curdate`，它被设置为当前实际日期。当我们把这些拼凑在一起时，我们的脚本如下所示：
- en: '[PRE60]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: This script, when run, will run an `rsync` job that will copy the contents from
    `/src` to `/target`. (Be sure to change these directories to match the source
    directory you want to back up and the target where you want to copy it to.) The
    beauty of this is that `/target` can be an external hard drive or network share.
    So, in a nutshell, you can automate a nightly backup. This backup, since we used
    the `-b` option along with `--backup-dir`, will allow you to retrieve previous
    versions of a file from the `/backup/incremental` directory. Feel free to get
    creative here as far as where to place previous file versions and where to send
    the backup.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 这个脚本在运行时会执行一个`rsync`任务，将内容从`/src`复制到`/target`。（确保更改这些目录，以匹配你想要备份的源目录和目标复制目录。）这样做的好处是，`/target`可以是一个外部硬盘或网络共享。因此，简而言之，你可以实现自动化的夜间备份。由于我们使用了`-b`选项并配合`--backup-dir`，这个备份将允许你从`/backup/incremental`目录中恢复文件的先前版本。你可以自由地发挥创意，决定在哪里放置先前的文件版本，以及将备份存储在哪里。
- en: 'Of course, don’t forget to mark the script as executable, assuming it was saved
    with a name like `backup.sh`:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，不要忘记将脚本标记为可执行文件，前提是它被保存为像`backup.sh`这样的文件名：
- en: '[PRE61]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'At this point, you can put this script in a cron job to automate its run. To
    do so, it’s best to put the script in a central location where it can be found,
    such as in `/usr/local/bin`:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 此时，你可以将此脚本放入定时任务中以自动运行。为了做到这一点，最好将脚本放在一个可以找到的中心位置，比如`/usr/local/bin`：
- en: '[PRE62]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: You can consider creating a cron job for this script to be run periodically.
    We’ll cover that in *Chapter 7*, *Controlling and Monitoring Processes*, which
    is the very next chapter. With a cron job, you can set up various tasks to run
    at different times in order to make your server essentially do your work for you.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以考虑为这个脚本创建一个定时任务，使其定期运行。我们将在*第7章*，*控制和监控进程*中详细介绍这一点，紧接着就是本章内容。通过定时任务，你可以设置不同的任务在不同时间运行，从而让你的服务器基本上代替你完成工作。
- en: Summary
  id: totrans-213
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we dived into a number of more advanced concepts relating to
    shell commands, such as redirection, Bash history, command aliases, some command-line
    tricks, and more. Working with the shell is definitely something you’ll continue
    to improve upon, so don’t be worried if you have any trouble committing all of
    this knowledge to memory. After over 20 years of working with Linux, I’m still
    learning new things myself. The main takeaway in this chapter is to serve as a
    starting point to broaden your command-line techniques and also serve as the basis
    for future exploration into the subject.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们深入探讨了与Shell命令相关的一些更高级的概念，如重定向、Bash历史记录、命令别名、一些命令行技巧等等。与Shell的工作无疑是你将继续提升的技能，所以如果你在记忆这些知识时遇到困难，不必担心。在我从事Linux工作超过20年的过程中，我仍然在不断学习新的东西。本章的主要收获是为你提供一个起点，拓宽你的命令行技巧，并为未来的探索奠定基础。
- en: In the next chapter, we’ll take a look at managing processes, which will include
    job management, taming misbehaving processes, and more. See you there!
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章，我们将探讨如何管理进程，包括作业管理、驯服不良进程等内容。我们下次见！
- en: Relevant videos
  id: totrans-216
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 相关视频
- en: 'Linux Crash Course – Bash History (LearnLinuxTV): [https://linux.video/le-bash-history](https://linux.video/le-bash-history)'
  id: totrans-217
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Linux入门课程 – Bash历史（LearnLinuxTV）：[https://linux.video/le-bash-history](https://linux.video/le-bash-history)
- en: 'Linux Command-Line Tips & Tricks (LearnLinuxTV): [https://linux.video/cli-tips](https://linux.video/cli-tips)'
  id: totrans-218
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Linux命令行技巧与窍门（LearnLinuxTV）：[https://linux.video/cli-tips](https://linux.video/cli-tips)
- en: Further reading
  id: totrans-219
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 深入阅读
- en: 'Comparison operators for Bash: [https://learnlinux.link/c-ops](https://learnlinux.link/c-ops)'
  id: totrans-220
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Bash的比较运算符：[https://learnlinux.link/c-ops](https://learnlinux.link/c-ops)
- en: 'Commandlinefu: [https://learnlinux.link/c-fu](https://learnlinux.link/c-fu)'
  id: totrans-221
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Commandlinefu：[https://learnlinux.link/c-fu](https://learnlinux.link/c-fu)
- en: 'Bash reference manual: [https://learnlinux.link/bash-man](https://learnlinux.link/bash-man)'
  id: totrans-222
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Bash参考手册：[https://learnlinux.link/bash-man](https://learnlinux.link/bash-man)
- en: Join our community on Discord
  id: totrans-223
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 加入我们在Discord上的社区
- en: 'Join our community’s Discord space for discussions with the author and other
    readers:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 加入我们社区的Discord空间，与作者和其他读者讨论：
- en: '[https://packt.link/LWaZ0](https://packt.link/LWaZ0)'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://packt.link/LWaZ0](https://packt.link/LWaZ0)'
- en: '![](img/QR_Code50046724-1955875156.png)'
  id: totrans-226
  prefs: []
  type: TYPE_IMG
  zh: '![](img/QR_Code50046724-1955875156.png)'
