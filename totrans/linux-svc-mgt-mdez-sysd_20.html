<html><head></head><body>
		<div id="_idContainer076">
			<h1 id="_idParaDest-242"><em class="italic"><a id="_idTextAnchor253"/>Chapter 17</em>: Understanding systemd and Bootloaders</h1>
			<p>A bootloader is necessary for any operating system, including Linux. In this chapter, we'll look at the GRUB2 and systemd-boot bootloaders, and we'll discuss the differences between them. Becoming familiar with the material in this chapter can help you choose which bootloader is best suited for your needs, and to troubleshoot things that might go wrong.</p>
			<p>In this chapter, we will cover the following topics:</p>
			<ul>
				<li>Understanding the basic computer architecture</li>
				<li>Understanding GRUB2</li>
				<li>Understanding systemd-boot</li>
				<li>Understanding Secure Boot</li>
			</ul>
			<p>Note that there are several different bootloaders in use, some of which are specific to embedded and IoT devices. In this chapter, we'll only concentrate on GRUB2 and systemd-boot, which are used on servers and normal workstations.</p>
			<p>Now, let's get started!</p>
			<h1 id="_idParaDest-243"><a id="_idTextAnchor254"/>Technical requirements</h1>
			<p>We'll start with the same Ubuntu Server and Alma virtual machines that we have been using throughout. We'll use these to look at a normal BIOS-based GRUB2 configuration.</p>
			<p>To see how the GRUB2 bootloader works on an EFI-based machine, you'll need to create another pair of Alma and Ubuntu Server virtual machines with the EFI feature enabled. To do that, create the initial VirtualBox setup for the Alma and Ubuntu machines as you always do. Then, before you start up the machines to install the operating system, open the <strong class="bold">Settings</strong> dialog box. Under the <strong class="bold">System</strong> menu, click the <strong class="bold">Enable EFI</strong> checkbox, as shown here:</p>
			<div>
				<div id="_idContainer068" class="IMG---Figure">
					<img src="image/Figure_17.1_B17491.jpg" alt=""/>
				</div>
			</div>
			<p class="figure-caption">Figure 17.1 â€“<a id="_idTextAnchor255"/> Checking the Enable EFI box</p>
			<p>Then, install the operating system as you normally would.</p>
			<p>To look at a systemd-boot environment, you'll need to create a virtual machine with Pop!_OS Linux. Enable the EFI feature as you did for the Alma and Ubuntu machines, and install the operating system as you normally would.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">Pop!_OS Linux is built from Ubuntu source code by the System76 computer vendor. Pop!_OS is the only Linux distro I know of that uses systemd-boot by default. You can set up Clear Linux and Arch Linux with either GRUB2 or systemd-boot, but installing either of them involves more complexity than we want to deal with now.</p>
			<p class="callout">You can download Pop!_OS from here:</p>
			<p class="callout"><a href="https://pop.system76.com/">https://pop.system76.com/</a></p>
			<p>Now that you have your virtual machines, let's briefly define a few terms that we need to know about.</p>
			<p>Check out the following link to see the Code in Action video: <a href="https://bit.ly/3pkVA8D">https://bit.ly/3pkVA8D</a></p>
			<h1 id="_idParaDest-244"><a id="_idTextAnchor256"/>Understanding the basic computer architecture</h1>
			<p>Before we can talk <a id="_idIndexMarker673"/>about bootloaders, we need to define a few terms that describe the basic computer architecture:</p>
			<ul>
				<li><strong class="bold">Bootloader</strong>: The bootloader is the first software program that runs when a computer is booted. Its job is <a id="_idIndexMarker674"/>to load the Linux kernel and to start the <strong class="source-inline">init</strong> system.</li>
				<li><strong class="bold">Boot manager</strong>: When you first power on your computer, a boot manager will present you with a boot menu. If you have multiple operating systems installed, the boot manager will <a id="_idIndexMarker675"/>allow you to choose which one to boot. If a Linux distro has multiple kernels installed, the boot manager will allow you to choose which kernel to boot.</li>
				<li><strong class="bold">BIOS</strong>: The <strong class="bold">Basic Input/Output System</strong> (<strong class="bold">BIOS</strong>) is firmware that resides in a chip on a computer <a id="_idIndexMarker676"/>motherboard. It contains the basic instructions that start up a computer. After the <a id="_idIndexMarker677"/>computer is started, the BIOS will perform a <strong class="bold">Power-on Self Test</strong> (<strong class="bold">POST</strong>) to verify that the hardware is working properly. Then, the BIOS will start the bootloader. It worked well for <a id="_idIndexMarker678"/>its time but is now outdated. One problem is that it can't deal with drives of more than two terabytes in size. I mean, if you were to install a three-Terabyte  drive in a BIOS-based machine, you'd be able to use the drive, but one Terabyte of drive space would go to waste. BIOS also can't deal with the Secure Boot feature.</li>
				<li><strong class="bold">EFI/UEFI</strong>: This was <a id="_idIndexMarker679"/>originally called the <strong class="bold">Extensible Firmware Interface</strong> (<strong class="bold">EFI</strong>), but the name <a id="_idIndexMarker680"/>was changed to <strong class="bold">Unified Extensible Firmware Interface</strong> (<strong class="bold">UEFI</strong>) for the Version 2 variant. It has replaced BIOS <a id="_idIndexMarker681"/>on newer computers. Unlike <a id="_idIndexMarker682"/>BIOS, EFI/UEFI works very well with very large drives. It also works with the Secure Boot feature.</li>
				<li><strong class="bold">MBR</strong>: There are two general categories of partition types. The <strong class="bold">Master Boot Record </strong>(<strong class="bold">MBR</strong>) type is the <a id="_idIndexMarker683"/>older type. Its main flaw is that it doesn't work with partitions that are larger than <a id="_idIndexMarker684"/>two terabytes. Even if you have an EFI/UEFI-based machine that can work with large drives, MBR still limits you to these smaller partitions. What's a bit confusing is that the term <em class="italic">MBR</em> also refers to the first 512-byte sector of a drive, which is where the bootloader gets installed on BIOS-based machines.</li>
				<li><strong class="bold">GPT</strong>: The <strong class="bold">GUID Partition Table</strong> (<strong class="bold">GPT</strong>) type of partition has replaced the old MBR type. It works well <a id="_idIndexMarker685"/>with partitions that are larger than two Terabytes. (The exact maximum <a id="_idIndexMarker686"/>partition size depends on which filesystem you've used to format the partition.) On EFI/UEFI machines, you need to install the bootloaders in a GPT partition instead of in an MBR. (I'll explain why I've said <em class="italic">bootloaders</em> instead of <em class="italic">bootloader</em> later.)</li>
				<li><strong class="bold">GRUB2</strong>: The <strong class="bold">Grand Unified Bootloader Version 2</strong> (<strong class="bold">GRUB2</strong>) is currently the most popular bootloader on laptops, desktops, and servers. It works well on machines with <a id="_idIndexMarker687"/>multiple installed operating systems. It's not part of the systemd ecosystem, but it can be used on systemd machines.</li>
				<li><strong class="bold">systemd-boot</strong>: This bootloader is <a id="_idIndexMarker688"/>part of the systemd <a id="_idIndexMarker689"/>ecosystem. It isn't widely used just yet, but it could be someday. It's lighter-weight and simpler to configure than GRUB2, and it <a id="_idIndexMarker690"/>also works well for machines with multiple operating systems installed.</li>
			</ul>
			<p>Okay, now that we have the terminology nailed down, let's look at GRUB2.</p>
			<h1 id="_idParaDest-245"><a id="_idTextAnchor257"/>Understanding GRUB2</h1>
			<p>The original GRUB, which is now referred to as <em class="italic">GRUB Legacy</em>, first came on the scene in 1995 as a replacement for the old LILO bootloader. It was easy to work with because it was easy to configure <a id="_idIndexMarker691"/>and it was implemented consistently on all Linux distros that used it. Unlike LILO, it can boot non-Linux operating systems. So, you can install Windows and Linux on the same computer, and GRUB lets you choose which one to boot up. GRUB Legacy worked well on the old BIOS-based computers, but it doesn't work with the newer EFI/UEFI computers. (Well, actually, the Fedora team did create a forked version of GRUB Legacy that would work with EFI/UEFI, but they abandoned it in favor of GRUB2 in 2013.)</p>
			<p>GRUB2 isn't an update of GRUB Legacy. Instead, it's a whole new bootloader that was created from scratch. Now, I have to tell you that there are both good things and bad things about it. The good thing is that it can work with the new EFI/UEFI computers. The bad things are that it's a lot more complicated to configure, and different Linux distros implement it differently. So, things can get a bit confusing when you have to work with multiple distros.</p>
			<p>Almost all Linux distros, including the Ubuntu and Alma distros that we've been using, use GRUB2. On a BIOS-based machine, GRUB2 gets installed into the primary drive's <a id="_idIndexMarker692"/>MBR, which is the first 512-byte sector of the drive. On an EFI/UEFI machine, GRUB2 gets installed into a special EFI partition, which always has to be a GPT-type partition. (This special partition is referred to as the <strong class="bold">EFI System Partition</strong> or <strong class="bold">ESP</strong>.)</p>
			<p>Now, here's where things get a bit confusing. As I said, unlike GRUB Legacy, GRUB2 isn't implemented in the same way across all Linux distros, as we'll see in a bit. To see how this all works, let's begin by comparing the GRUB2 setup on our BIOS-based and EFI/UEFI-based AlmaLinux virtual machines.</p>
			<h2 id="_idParaDest-246"><a id="_idTextAnchor258"/>Comparing GRUB2 on BIOS and EFI/UEFI systems</h2>
			<p>On both BIOS-based and EFI/UEFI-based machines, the Linux kernel and the <strong class="source-inline">initramfs</strong> files get installed in the <strong class="source-inline">/boot</strong> partition. But this is where the similarities end. Let's see how it's done with BIOS.</p>
			<h3>GRUB2 on a BIOS-based Alma 8 machine</h3>
			<p>On a BIOS-based machine, the <strong class="source-inline">/boot</strong> partition is normally <strong class="source-inline">/dev/sda1</strong>, as we see here:</p>
			<p class="source-code">[donnie@alma-bios ~]$ mount | grep 'boot'</p>
			<p class="source-code">/dev/sda1 on /boot type xfs (rw,relatime,seclabel,attr2,inode64,logbufs=8,logbsize=32k,noquota)</p>
			<p class="source-code">[donnie@alma-bios ~]$</p>
			<p>We also see <a id="_idIndexMarker693"/>that the <strong class="source-inline">/boot</strong> partition is formatted with just a normal Linux filesystem. On RHEL-type machines, this would normally be <strong class="source-inline">xfs</strong>. On Ubuntu machines, this would normally be <strong class="source-inline">ext4</strong>.</p>
			<p>The Master Boot Record, where the bootloader is installed, isn't a partition. Rather, the MBR is just the first 512 bytes of the drive. The GRUB2 configuration file (<strong class="source-inline">grub2.cfg</strong>) is in the <strong class="source-inline">/boot/grub2/</strong> directory. On RHEL-type machines, the <strong class="source-inline">/etc/grub.cfg</strong> symbolic link points to the actual configuration file, as we see here:</p>
			<p class="source-code">[donnie@alma-bios etc]$ sudo ls -l grub2.cfg </p>
			<p class="source-code">lrwxrwxrwx. 1 root root 22 Mar 15 14:28 grub2.cfg -&gt; ../boot/grub2/grub.cfg</p>
			<p class="source-code">[donnie@alma-bios etc]$</p>
			<p>Understand though, that if you ever need to reconfigure GRUB2, you'll never edit this <strong class="source-inline">grub.cfg</strong> file. Instead, you'll edit the <strong class="source-inline">/etc/default/grub</strong> file. Then, you'll rebuild the <strong class="source-inline">grub.cfg</strong> file by doing:</p>
			<p class="source-code">[donnie@alma-bios ~]$ sudo grub2-mkconfig -o /boot/grub2/grub.cfg</p>
			<p>There is an <strong class="source-inline">efi/</strong> directory within the <strong class="source-inline">/boot/</strong> directory, but it isn't used. It contains a nest of subdirectories, but <a id="_idIndexMarker694"/>there are no files, as we see here:</p>
			<p class="source-code">[donnie@alma-bios ~]$ sudo ls -l /boot/efi/EFI/almalinux</p>
			<p class="source-code">total 0</p>
			<p class="source-code">[donnie@alma-bios ~]$</p>
			<p>Whenever we boot the machine, we see a boot menu with our different boot-up choices:</p>
			<div>
				<div id="_idContainer069" class="IMG---Figure">
					<img src="image/Figure_17.2_B17491.jpg" alt=""/>
				</div>
			</div>
			<p class="figure-caption">Figure 17.2 â€“ The GRUB2 boot menu on AlmaLinux</p>
			<p>The configuration files for these menu choices are in the <strong class="source-inline">/boot/loader/entries/</strong> directory. This directory requires root privileges to enter. So, let's make things easier on ourselves by going to the <strong class="source-inline">root</strong> shell:</p>
			<p class="source-code">[donnie@alma-bios ~]$ sudo su -</p>
			<p class="source-code">[sudo] password for donnie: </p>
			<p class="source-code">Last login: Sat Aug 28 18:09:25 EDT 2021 on pts/0</p>
			<p class="source-code">[root@alma-bios ~]# cd /boot/loader/entries/</p>
			<p class="source-code">[root@alma-bios entries]#</p>
			<p>Now, let's see what we have:</p>
			<p class="source-code">[root@alma-bios entries]# ls -l</p>
			<p class="source-code">total 16</p>
			<p class="source-code">-rw-r--r--. 1 root root 388 AprÂ Â 5 12:09 3a17f34dc2694acda37caa478a339408-0-rescue.conf</p>
			<p class="source-code">-rw-r--r--. 1 root root 368 AprÂ Â 5 13:20 3a17f34dc2694acda37caa478a339408-4.18.0-240.15.1.el8_3.x86_64.conf</p>
			<p class="source-code">-rw-r--r--. 1 root root 368 Apr 11 18:23 3a17f34dc2694acda37caa478a339408-4.18.0-240.22.1.el8_3.x86_64.conf</p>
			<p class="source-code">-rw-r--r--. 1 root root 316 AprÂ Â 5 12:09 3a17f34dc2694acda37caa478a339408-4.18.0-240.el8.x86_64.conf</p>
			<p class="source-code">[root@alma-bios entries]#</p>
			<p>These configuration <a id="_idIndexMarker695"/>files are known as <strong class="source-inline">BootLoaderSpec</strong> (<strong class="source-inline">BLS</strong>) files. Whenever you boot your machine, GRUB2 will take information from these <strong class="source-inline">BLS</strong> files and use it to populate the boot menu. A new <strong class="source-inline">BLS</strong> file will be generated automatically every time a new Linux kernel is installed, even if it's a kernel that you've compiled yourself. If you do a system update and <strong class="source-inline">dnf</strong> removes any older kernels, the <strong class="source-inline">BLS</strong> files for those older kernels will be deleted. Let's peek inside one of these files to see what's there:</p>
			<p class="source-code">[root@alma-bios entries]# cat 3a17f34dc2694acda37caa478a339408-4.18.0-240.22.1.el8_3.x86_64.conf </p>
			<p class="source-code">title AlmaLinux (4.18.0-240.22.1.el8_3.x86_64) 8.3 (Purple Manul)</p>
			<p class="source-code">version 4.18.0-240.22.1.el8_3.x86_64</p>
			<p class="source-code">linux /vmlinuz-4.18.0-240.22.1.el8_3.x86_64</p>
			<p class="source-code">initrd /initramfs-4.18.0-240.22.1.el8_3.x86_64.img $tuned_initrd</p>
			<p class="source-code">options $kernelopts $tuned_params</p>
			<p class="source-code">id almalinux-20210409120623-4.18.0-240.22.1.el8_3.x86_64</p>
			<p class="source-code">grub_users $grub_users</p>
			<p class="source-code">grub_arg --unrestricted</p>
			<p class="source-code">grub_class kernel</p>
			<p class="source-code">[root@alma-bios entries]#</p>
			<p>As we see here, this file defines which kernel and <strong class="source-inline">initramfs</strong> images to load, along with the various <a id="_idIndexMarker696"/>kernel options. But we don't see specific kernel options here. Instead, we see variable names preceded by a <strong class="source-inline">$</strong>. This just means that the kernel option information will be pulled in from the <strong class="source-inline">/boot/grub2/grub.cfg</strong> file and the <strong class="source-inline">/boot/grub2/grubenv</strong> file.</p>
			<p>If you install Linux alongside an already existing installation of another operating system, the boot menu entry for that operating system should also be created automatically. (This works even if the other operating system is Windows.) The <strong class="source-inline">/etc/grub.d/30_os-prober</strong> script is what finds the other operating systems for you.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">This is different from what you might be used to. Older Linux distros, such as the RHEL 7-type distros, don't use <strong class="source-inline">BLS</strong> files. Instead, all boot menu information is listed in the <strong class="source-inline">grub.cfg</strong> file. Red Hat first introduced <strong class="source-inline">BLS</strong> files in Fedora 30, and they're now used in all RHEL 8-type distros. (As we'll see later, even the newest Ubuntu distros still don't use them.)</p>
			<p>Now, let's look at an EFI/UEFI machine.</p>
			<h3>GRUB2 on an EFI/UEFI-based Alma machine</h3>
			<p>On our EFI/UEFI machine, the <strong class="source-inline">/boot/</strong> partition is mounted on <strong class="source-inline">/dev/sda2</strong>, while the <strong class="source-inline">/boot/efi/</strong> partition <a id="_idIndexMarker697"/>is mounted on <strong class="source-inline">/dev/sda1</strong>, as we see here:</p>
			<p class="source-code">[donnie@alma-efi ~]$ mount | grep 'boot'</p>
			<p class="source-code">/dev/sda2 on /boot type xfs (rw,relatime,seclabel,attr2,inode64,logbufs=8,logbsize=32k,noquota)</p>
			<p class="source-code">/dev/sda1 on /boot/efi type vfat (rw,relatime,fmask=0077,dmask=0077,codepage=437,iocharset=ascii,shortname=winnt,errors=remount-ro)</p>
			<p class="source-code">[donnie@alma-efi ~]$</p>
			<p>The <strong class="source-inline">/boot/efi/</strong> partition is where the bootloaders reside. We can also see that the normal boot partition is formatted with the normal <strong class="source-inline">xfs</strong> Linux filesystem, but that the <strong class="source-inline">/boot/efi/</strong> partition is formatted with the <strong class="source-inline">vfat</strong> filesystem. The <strong class="source-inline">efi</strong> partition must always be formatted with <strong class="source-inline">vfat</strong> because nothing else works.</p>
			<p>Next, we see that the symbolic link in the <strong class="source-inline">/etc/</strong> directory has a different name and that it points to the <strong class="source-inline">grub.cfg</strong> file in a different location:</p>
			<p class="source-code">[donnie@alma-efi etc]$ sudo ls -l grub2-efi.cfg </p>
			<p class="source-code">lrwxrwxrwx. 1 root root 34 Mar 15 14:28 grub2-efi.cfg -&gt; ../boot/efi/EFI/almalinux/grub.cfg</p>
			<p class="source-code">[donnie@alma-efi etc]$</p>
			<p>As before, the directories that we want to explore require root privileges to enter. Let's make things a bit easier by going to a <strong class="source-inline">root</strong> shell:</p>
			<p class="source-code">[donnie@alma-efi ~]$ sudo su -</p>
			<p class="source-code">Last login: Sat Aug 28 17:52:08 EDT 2021 on pts/0</p>
			<p class="source-code">[root@alma-efi ~]#</p>
			<p>There's still a <strong class="source-inline">/boot/grub2/</strong> directory, but the only thing it contains is a symbolic link that points to the GRUB environmental settings file:</p>
			<p class="source-code">[root@alma-efi ~]# cd /boot/grub2/</p>
			<p class="source-code">[root@alma-efi grub2]# ls -l</p>
			<p class="source-code">total 0</p>
			<p class="source-code">lrwxrwxrwx. 1 root root 28 Mar 15 14:28 grubenv -&gt; ../efi/EFI/almalinux/grubenv</p>
			<p class="source-code">[root@alma-efi grub2]#</p>
			<p>Almost everything else of importance is in the <strong class="source-inline">/boot/efi/</strong> directory:</p>
			<p class="source-code">[root@alma-efi ~]# cd /boot/efi</p>
			<p class="source-code">[root@alma-efi efi]# ls</p>
			<p class="source-code">EFI</p>
			<p class="source-code">[root@alma-efi efi]# cd EFI/</p>
			<p class="source-code">[root@alma-efi EFI]# ls</p>
			<p class="source-code">almalinuxÂ Â BOOT</p>
			<p class="source-code">[root@alma-efi EFI]#</p>
			<p>At the bottom <a id="_idIndexMarker698"/>of this nest, we see the <strong class="source-inline">/boot/efi/EFI/almalinux/</strong> and <strong class="source-inline">/boot/efi/EFI/BOOT/</strong> directories. Let's look in the <strong class="source-inline">BOOT/</strong> directory:</p>
			<p class="source-code">[root@alma-efi EFI]# ls -l BOOT/</p>
			<p class="source-code">total 1568</p>
			<p class="source-code">-rwx------. 1 root root 1237503 Mar 15 14:44 BOOTX64.EFI</p>
			<p class="source-code">-rwx------. 1 root rootÂ Â 362968 Mar 15 14:44 fbx64.efi</p>
			<p class="source-code">[root@alma-efi EFI]# </p>
			<p>The <strong class="source-inline">BOOTX64.EFI</strong> file is part of the <strong class="source-inline">shim</strong> system, which allows Linux to boot on machines that have the Secure Boot feature enabled. (We'll talk about Secure Boot at the end of this chapter.) The <strong class="source-inline">fbx64.efi</strong> file is the fallback bootloader. Its job is to recreate the boot manager options that are built into the firmware in case they somehow get deleted. It does this by scanning the <strong class="source-inline">BOOTX64.CSV</strong> files that are in the subdirectories for any operating systems that are installed.</p>
			<p>Now, here's what we see in the <strong class="source-inline">almalinux/</strong> directory:</p>
			<p class="source-code">[root@alma-efi EFI]# ls -l almalinux/</p>
			<p class="source-code">total 5444</p>
			<p class="source-code">-rwx------. 1 root rootÂ Â Â Â Â 122 Mar 15 14:44 BOOTX64.CSV</p>
			<p class="source-code">drwx------. 2 root rootÂ Â Â Â 4096 Mar 15 14:28 fonts</p>
			<p class="source-code">-rwx------. 1 root rootÂ Â Â Â 6572 Aug 26 18:13 grub.cfg</p>
			<p class="source-code">-rwx------. 1 root rootÂ Â Â Â 1024 Aug 28 17:51 grubenv</p>
			<p class="source-code">-rwx------. 1 root root 1900112 Mar 15 14:28 grubx64.efi</p>
			<p class="source-code">-rwx------. 1 root root 1171320 Mar 15 14:44 mmx64.efi</p>
			<p class="source-code">-rwx------. 1 root root 1240144 Mar 15 14:44 shimx64-almalinux.efi</p>
			<p class="source-code">-rwx------. 1 root root 1237503 Mar 15 14:44 shimx64.efi</p>
			<p class="source-code">[root@alma-efi EFI]#</p>
			<p>In addition to the normal <strong class="source-inline">GRUB2</strong> files that we'd see on a BIOS-based machine, we see several <a id="_idIndexMarker699"/>files that are specific to EFI/UEFI machines:</p>
			<ul>
				<li><strong class="source-inline">grubx64.efi</strong>: This is what makes GRUB2 work on an EFI/UEFI machine.</li>
				<li><strong class="source-inline">shim64-almalinux.efi</strong> and <strong class="source-inline">shimx64.efi</strong>: These files go along with the <strong class="source-inline">BOOTX64.EFI</strong> file to make Alma work on a Secure Boot machine.</li>
				<li><strong class="source-inline">mmx64.efi</strong>: This is part of the <em class="italic">Machine Owner Key</em> system, which also helps out with Secure Boot.</li>
				<li><strong class="source-inline">BOOTX64.CSV</strong>: This file works with the fallback bootloader and contains a boot menu entry for this installation of Alma. (If multiple operating systems were installed, they would all have their own <strong class="source-inline">BOOTX64.CSV</strong> files.) If you peek inside this file, you'll see this:<p class="source-code">[root@alma-efi almalinux]# cat BOOTX64.CSV </p><p class="source-code">Â´Â´shimx64.efi,AlmaLinux,,This is the boot entry for AlmaLinux</p><p class="source-code">[root@alma-efi almalinux]#</p><p class="callout-heading">Note</p><p class="callout">Something to keep in mind is that the <strong class="source-inline">BOOTX64.CSV</strong> file is not an ASCII text file as most Linux configuration files are. (That would explain those two funny-looking questions marks that you see in this code.) Instead, it's a UTF-16 Unicode file, as we see here:</p><p class="callout"><strong class="bold">[root@alma-efi ~]# cd /boot/efi/EFI/almalinux/</strong></p><p class="callout"><strong class="bold">[root@alma-efi almalinux]# file BOOTX64.CSV</strong></p><p class="callout"><strong class="bold">BOOTX64.CSV: Little-endian UTF-16 Unicode text, with no line terminators</strong></p><p class="callout"><strong class="bold">[root@alma-efi almalinux]#</strong></p><p class="callout">Normal text editors save files in ASCII format. So, if you ever need to manually create or edit a <strong class="source-inline">BOOTX64.CSV</strong> file, you'll need to convert it into UTF-16 format. Let's say that you've created a <strong class="source-inline">boot.csv</strong> file in your home directory. You can convert it with the <strong class="source-inline">iconv</strong> tool, like this:</p><p class="callout"><strong class="bold">[donnie@alma-efi ~]$ iconv -t UTF-16 &lt; ~/boot.csv &gt; BOOTX64.CSV</strong></p><p class="callout"><strong class="bold">[donnie@alma-efi ~]$</strong></p><p class="callout">Now, you're ready to copy the file to its proper location.</p></li>
			</ul>
			<p>Next, we have <a id="_idIndexMarker700"/>the <strong class="source-inline">BLS</strong> files for the boot menu choices, just as we had on the BIOS machine:</p>
			<p class="source-code">[donnie@alma-efi ~]$ sudo ls -l /boot/loader/entries/</p>
			<p class="source-code">[sudo] password for donnie: </p>
			<p class="source-code">total 8</p>
			<p class="source-code">-rw-r--r--. 1 root root 388 Aug 26 18:10 5a1e1f5e83004e9eb0f6e2e0a346d4e7-0-rescue.conf</p>
			<p class="source-code">-rw-r--r--. 1 root root 316 Aug 26 18:10 5a1e1f5e83004e9eb0f6e2e0a346d4e7-4.18.0-240.el8.x86_64.conf</p>
			<p class="source-code">[donnie@alma-efi ~]$</p>
			<p>When we boot an EFI/UEFI machine, we'll see that the boot menu looks somewhat different than <a id="_idIndexMarker701"/>what it does on a BIOS machine:</p>
			<div>
				<div id="_idContainer070" class="IMG---Figure">
					<img src="image/Figure_17.3_B17491.jpg" alt=""/>
				</div>
			</div>
			<p class="figure-caption">Figure 17.3 â€“ The boot menu on an EFI/UEFI machine</p>
			<p>We now see a <strong class="bold">System setup</strong> choice, which takes us into the EFI management utility we see here:</p>
			<div>
				<div id="_idContainer071" class="IMG---Figure">
					<img src="image/Figure_17.4_B17491.jpg" alt=""/>
				</div>
			</div>
			<p class="figure-caption">Figure 17.4 â€“ The EFI management utility</p>
			<p>This can do several <a id="_idIndexMarker702"/>things for us. If we select <strong class="bold">Boot Maintenance Manager</strong>, we'll see the <strong class="bold">Boot Options</strong> option. If we select that, we'll see that we can add or delete boot options, or change the default boot order:</p>
			<div>
				<div id="_idContainer072" class="IMG---Figure">
					<img src="image/Figure_17.5_B17491.jpg" alt=""/>
				</div>
			</div>
			<p class="figure-caption">Figure 17.5 â€“ The Boot Options screen</p>
			<p>This could come <a id="_idIndexMarker703"/>in handy if we ever need to boot from a DVD or USB device rather than from the default device.</p>
			<p>Under the <strong class="bold">Boot Manager</strong> option, we see the <strong class="bold">EFI Internal Shell</strong> option:</p>
			<div>
				<div id="_idContainer073" class="IMG---Figure">
					<img src="image/Figure_17.6_B17491.jpg" alt=""/>
				</div>
			</div>
			<p class="figure-caption">Figure 17.6 â€“ The Boot Manager screen</p>
			<p>This internal <a id="_idIndexMarker704"/>shell can help you troubleshoot boot-up problems and looks like this:</p>
			<div>
				<div id="_idContainer074" class="IMG---Figure">
					<img src="image/Figure_17.7_B17491.jpg" alt=""/>
				</div>
			</div>
			<p class="figure-caption">Figure 17.7 â€“ The EFI internal shell</p>
			<p>To see the commands <a id="_idIndexMarker705"/>that you can run from this shell, just type <strong class="source-inline">help</strong>. I'm not going to cover this shell in detail because it's not something that you'll use very often. However, I've linked to a good tutorial in the <em class="italic">Further reading</em> section.</p>
			<p>Okay, that covers it for GRUB2 on the AlmaLinux machine. Now, let's look at how things are a bit different on the Ubuntu machine.</p>
			<h2 id="_idParaDest-247"><a id="_idTextAnchor259"/>GRUB2 on BIOS-based and EFI/UEFI-based Ubuntu machines</h2>
			<p>The biggest difference <a id="_idIndexMarker706"/>is that Ubuntu doesn't use <strong class="source-inline">BootLoaderSpec</strong> files, as the RHEL 8-type distros do. Instead, all menu entries <a id="_idIndexMarker707"/>are defined within the <strong class="source-inline">/boot/grub/grub.cfg</strong> file. To see these menu entries, open the file and search for stanzas that begin with <strong class="source-inline">menuentry</strong>. Here's a snippet from one such menu entry:</p>
			<p class="source-code">menuentry 'Ubuntu' --class ubuntu --class gnu-linux --class gnu --class os $menuentry_id_option 'gnulinux-simple-34969a2a-6e3f-4806-8260-e62b948678e3' {</p>
			<p class="source-code">Â Â Â Â Â Â Â Â recordfail</p>
			<p class="source-code">Â Â Â Â Â Â Â Â load_video</p>
			<p class="source-code">Â Â Â Â Â Â Â Â gfxmode $linux_gfx_mode</p>
			<p class="source-code">Â Â Â Â Â Â Â Â insmod gzio</p>
			<p class="source-code">. . .</p>
			<p class="source-code">. . .</p>
			<p class="source-code">Â Â Â Â Â Â Â Â linuxÂ Â Â /boot/vmlinuz-5.4.0-81-generic root=UUID=34969a2a-6e3f-4806-8260-e62b948678e3 roÂ Â </p>
			<p class="source-code">Â Â Â Â Â Â Â Â initrdÂ Â /boot/initrd.img-5.4.0-81-generic</p>
			<p class="source-code">}</p>
			<p>The only other real difference is that there's no symbolic link to the <strong class="source-inline">grub.cfg</strong> file in the <strong class="source-inline">/etc/</strong> directory.</p>
			<p>Next, let's reboot to get to the good stuff. Let's look at <em class="italic">systemd-boot</em>.</p>
			<h1 id="_idParaDest-248"><a id="_idTextAnchor260"/>Understanding systemd-boot</h1>
			<p>The first thing to note here is the name, <em class="italic">systemd-boot</em>. It's shocking, I know. We have a systemd component whose name does <em class="italic">not</em> end in the letter <em class="italic">d</em>. But seriously, systemd-boot is a component of systemd that has some cool features. Compared to GRUB2, it's lighter-weight, easier to <a id="_idIndexMarker708"/>configure, boots faster, and works well with the modern implementations of Secure Boot. Contrary to popular belief, systemd-boot is a <em class="italic">boot manager</em>, not a <em class="italic">bootloader</em>. It can automatically probe for other operating systems on the machine and add them to the boot menu. (GRUB2 only does this when you first install the operating system, while systemd-boot does this each time you boot the machine.) Once you've booted the machine and have chosen your desired boot option, systemd-boot hands the boot operation over to a <em class="italic">real</em> bootloader.</p>
			<p>So, why isn't it more widely used? Well, it's just that systemd-boot <em class="italic">only</em> works on EFI/UEFI systems. There are still a lot of older BIOS-based computers in use, and all of them would become unusable if all operating systems were to switch to EFI/UEFI-only bootloaders.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">You can read about the various features of systemd-boot on the <strong class="source-inline">systemd-boot</strong> man page.</p>
			<p>For our demos, we'll use <strong class="bold">Pop!_OS</strong> Linux, which is a product of the System76 company. System76 is a computer vendor, so it made sense for them to produce an operating system that would <a id="_idIndexMarker709"/>only run on newer machines. It's based on Ubuntu, so you can use the same Ubuntu commands that you're used to using, other than any commands that deal with the bootloader. (At the time of writing, it was based on Ubuntu 21.04.)</p>
			<p>When I created the Pop!_OS virtual machine, I just accepted the installer's default partition setup. Here's what it looks like:</p>
			<p class="source-code">donnie@pop-os:~$ mount | grep 'sda'</p>
			<p class="source-code">/dev/sda3 on / type ext4 (rw,noatime,errors=remount-ro)</p>
			<p class="source-code">/dev/sda2 on /recovery type vfat (rw,relatime,fmask=0077,dmask=0077,codepage=437,iocharset=iso8859-1,shortname=mixed,errors=remount-ro)</p>
			<p class="source-code">/dev/sda1 on /boot/efi type vfat (rw,relatime,fmask=0077,dmask=0077,codepage=437,iocharset=iso8859-1,shortname=mixed,errors=remount-ro)</p>
			<p class="source-code">donnie@pop-os:~$</p>
			<p>Here, we see that <strong class="source-inline">/dev/sda1</strong> is mounted as <strong class="source-inline">/boot/efi/</strong>, which is the EFI system partition where the bootloaders reside. We also see a <strong class="source-inline">/recovery/</strong> partition, which is something I've never before seen on any Linux machine. This <strong class="source-inline">/recovery/</strong> partition <a id="_idIndexMarker710"/>contains a live version of Pop!_OS. Boot from this partition if you ever need to repair or even reinstall the operating system without losing users' files.</p>
			<p>Unlike GRUB2, systemd-boot does not have any configuration files in the <strong class="source-inline">/etc/</strong> directory. Instead, they're all in the <strong class="source-inline">/boot/efi/</strong> directory. As we did previously, we'll make things easier by going to a <strong class="source-inline">root</strong> shell:</p>
			<p class="source-code">donnie@pop-os:~$ sudo su -</p>
			<p class="source-code">[sudo] password for donnie: </p>
			<p class="source-code">root@pop-os:~#</p>
			<p>Here's what's inside the <strong class="source-inline">/boot/efi/</strong> directory:</p>
			<p class="source-code">root@pop-os:~# cd /boot/efi</p>
			<p class="source-code">root@pop-os:/boot/efi# ls -l</p>
			<p class="source-code">total 8</p>
			<p class="source-code">drwx------ 7 root root 4096 Aug 27 14:15 EFI</p>
			<p class="source-code">drwx------ 3 root root 4096 SepÂ Â 1 17:11 loader</p>
			<p class="source-code">root@pop-os:/boot/efi#</p>
			<p>Let's look in the <strong class="source-inline">loader/</strong> subdirectory first:</p>
			<p class="source-code">root@pop-os:/boot/efi/loader# ls -l</p>
			<p class="source-code">total 12</p>
			<p class="source-code">drwx------ 2 root root 4096 SepÂ Â 1 15:45 entries</p>
			<p class="source-code">-rwx------ 1 root rootÂ Â Â 23 SepÂ Â 1 17:11 loader.conf</p>
			<p class="source-code">-rwx------ 1 root rootÂ Â 512 Aug 27 14:15 random-seed</p>
			<p class="source-code">root@pop-os:/boot/efi/loader#</p>
			<p>We'll come back to the <a id="_idIndexMarker711"/>two files in just a bit. First, let's look into the <strong class="source-inline">entries/</strong> subdirectory:</p>
			<p class="source-code">root@pop-os:/boot/efi/loader/entries# ls -l</p>
			<p class="source-code">total 12</p>
			<p class="source-code">-rwx------ 1 root root 256 SepÂ Â 1 15:48 Pop_OS-current.conf</p>
			<p class="source-code">-rwx------ 1 root root 274 SepÂ Â 1 15:48 Pop_OS-oldkern.conf</p>
			<p class="source-code">-rwx------ 1 root root 299 Aug 27 10:13 Recovery-9C63-930A.conf</p>
			<p class="source-code">root@pop-os:/boot/efi/loader/entries#</p>
			<p>These three <strong class="source-inline">BootLoaderSpec</strong> files represent the three choices that will come up on the boot menu when you boot up your machine. (I know that you haven't seen the boot menu yet, but that's okay. We'll fix that shortly.) Just for fun, let's peek inside the <strong class="source-inline">Pop_OS-current.conf</strong> file:</p>
			<p class="source-code">root@pop-os:/boot/efi/loader/entries# cat Pop_OS-current.conf </p>
			<p class="source-code">title Pop!_OS</p>
			<p class="source-code">linux /EFI/Pop_OS-bc156c8a-fcb8-4a74-b491-089c77362828/vmlinuz.efi</p>
			<p class="source-code">initrd /EFI/Pop_OS-bc156c8a-fcb8-4a74-b491-089c77362828/initrd.img</p>
			<p class="source-code">options root=UUID=bc156c8a-fcb8-4a74-b491-089c77362828 ro quiet loglevel=0 systemd.show_status=false splash</p>
			<p class="source-code">root@pop-os:/boot/efi/loader/entries#</p>
			<p>Unlike GRUB2, there are no other files for storing the kernel options. So, they all have to be stored here. What you might think of as a bit unusual is that the kernel file that this <strong class="source-inline">BLS</strong> file calls in has a <strong class="source-inline">.efi</strong> filename extension. I'll explain why that is in just a few moments.</p>
			<p>The <strong class="source-inline">/boot/efi/loader/random-seed</strong> file stores a random seed value. (I bet you would never have guessed that.) This allows the machine to boot with a fully initialized entropy pool, which <a id="_idIndexMarker712"/>allows the <strong class="source-inline">/dev/urandom</strong> device to create better random numbers. This makes security better by allowing the system to create security keys that are harder to crack. (Note though, that this feature doesn't work on virtual machines.)</p>
			<p>Next, let's look at the <strong class="source-inline">/boot/efi/loader/loader.conf</strong> file:</p>
			<p class="source-code">root@pop-os:/boot/efi/loader# cat loader.conf </p>
			<p class="source-code">default Pop_OS-current</p>
			<p class="source-code">root@pop-os:/boot/efi/loader#</p>
			<p>Wait a minute. That's all there is to it? Well yeah. (Didn't I tell you that systemd-boot is much easier to configure than GRUB2?) I do see a slight problem here, though. It's just that the boot menu won't show up unless you quickly press the proper key after you turn on the machine. Let's edit this file to have the boot menu show for five seconds. The edited file should look like this:</p>
			<p class="source-code">default Pop_OS-current</p>
			<p class="source-code">timeout 5</p>
			<p>Okay, that was tough. I just hope that you were able to handle it. Seriously, though, there are a few more options that you can read about on the <strong class="source-inline">loader.conf</strong> man page and they're all very easy to configure. (By the way, don't reboot the machine just yet. We'll make one more change in just a bit, and then you can reboot.)</p>
			<p>In the <strong class="source-inline">/boot/efi/EFI/</strong> directory, we see these subdirectories:</p>
			<p class="source-code">root@pop-os:/boot/efi/EFI# ls -l</p>
			<p class="source-code">total 20</p>
			<p class="source-code">drwx------ 2 root root 4096 Aug 27 14:15 BOOT</p>
			<p class="source-code">drwx------ 2 root root 4096 Aug 27 14:15 Linux</p>
			<p class="source-code">drwx------ 2 root root 4096 SepÂ Â 1 15:45 Pop_OS-bc156c8a-fcb8-4a74-b491-089c77362828</p>
			<p class="source-code">drwx------ 2 root root 4096 Aug 27 14:13 Recovery-9C63-930A</p>
			<p class="source-code">drwx------ 2 root root 4096 Aug 27 14:15 systemd</p>
			<p class="source-code">root@pop-os:/boot/efi/EFI#</p>
			<p>The <strong class="source-inline">Linux/</strong> subdirectory <a id="_idIndexMarker713"/>is empty, so we won't bother looking into it. In the <strong class="source-inline">BOOT/</strong> subdirectory, we only see one file:</p>
			<p class="source-code">root@pop-os:/boot/efi/EFI/BOOT# ls -l</p>
			<p class="source-code">total 92</p>
			<p class="source-code">-rwx------ 1 root root 94079 Jul 20 14:47 BOOTX64.EFI</p>
			<p class="source-code">root@pop-os:/boot/efi/EFI/BOOT#</p>
			<p>As we saw on the Alma and Ubuntu machines, we have the <strong class="source-inline">BOOTX64.EFI</strong> file, which makes this machine work with Secure Boot. However, we don't have the fallback bootloader file.</p>
			<p>In the <strong class="source-inline">systemd/</strong> subdirectory, we see the executable file that makes systemd-boot work:</p>
			<p class="source-code">root@pop-os:/boot/efi/EFI/systemd# ls -l</p>
			<p class="source-code">total 92</p>
			<p class="source-code">-rwx------ 1 root root 94079 Jul 20 14:47 systemd-bootx64.efi</p>
			<p class="source-code">root@pop-os:/boot/efi/EFI/systemd#</p>
			<p>Finally, let's look inside the <strong class="source-inline">Pop_OS-bc156c8a-fcb8-4a74-b491-089c77362828/</strong> subdirectory:</p>
			<p class="source-code">root@pop-os:/boot/efi/EFI/Pop_OS-bc156c8a-fcb8-4a74-b491-089c77362828# ls -l</p>
			<p class="source-code">total 240488</p>
			<p class="source-code">-rwx------ 1 root rootÂ Â Â Â Â Â Â 167 SepÂ Â 1 15:48 cmdline</p>
			<p class="source-code">-rwx------ 1 root root 108913836 SepÂ Â 1 15:48 initrd.img</p>
			<p class="source-code">-rwx------ 1 root root 107842809 SepÂ Â 1 15:48 initrd.img-previous</p>
			<p class="source-code">-rwx------ 1 root rootÂ Â 14750528 SepÂ Â 1 15:48 vmlinuz.efi</p>
			<p class="source-code">-rwx------ 1 root rootÂ Â 14739488 SepÂ Â 1 15:48 vmlinuz-previous.efi</p>
			<p class="source-code">root@pop-os:/boot/efi/EFI/Pop_OS-bc156c8a-fcb8-4a74-b491-089c77362828#</p>
			<p>This is much different than what you saw on the GRUB2 machines. Here, we're using the <em class="italic">EFI Stub Loader</em> feature that's built into the Linux kernel. The <strong class="source-inline">vmlinuz.efi</strong> file is just a copy of the <strong class="source-inline">/boot/vmlinuz-5.11.0-7633-generic</strong> file, which is the newest installed Linux kernel. By renaming this kernel file with a <strong class="source-inline">.efi</strong> filename extension, systemd-boot effectively <a id="_idIndexMarker714"/>turned this kernel file into its own bootloader. (Pretty slick, eh?) The <strong class="source-inline">vmlinuz-previous.efi</strong> file is a copy of the <strong class="source-inline">/boot/vmlinuz-5.11.0-7620-generic</strong> file, which is the second oldest installed kernel. Every time we install a new kernel on this systemd-boot machine, the original copy will go into the top-level <strong class="source-inline">/boot/</strong> directory, and a copy with the <strong class="source-inline">.efi</strong> filename extension will go into this directory.</p>
			<p>Another thing to note here is that there are no <strong class="source-inline">shimx64*.efi</strong> files, as we saw on the Alma and Ubuntu machines. That's because systemd-boot doesn't need the shim system to work with Secure Boot. (I'll explain this in more detail in the <em class="italic">Understanding Secure Boot</em> section.)</p>
			<p>Okay, we don't need the root shell anymore, so type <strong class="source-inline">exit</strong> to get back to your normal user shell.</p>
			<p>The final systemd-boot component I want to show you is the <strong class="source-inline">bootctl</strong> tool. To see the status of systemd-boot, run the command without any options:</p>
			<p class="source-code">donnie@pop-os:~$ sudo bootctl</p>
			<p class="source-code">System:</p>
			<p class="source-code">Â Â Â Â Â Firmware: UEFI 2.70 (EDK II 1.00)</p>
			<p class="source-code">Â Â Secure Boot: disabled</p>
			<p class="source-code">Â Â Â Setup Mode: user</p>
			<p class="source-code"> Boot into FW: supported</p>
			<p class="source-code">Current Boot Loader:</p>
			<p class="source-code">Â Â Â Â Â Â Product: systemd-boot 247.3-3ubuntu3.4pop0~1626806865~21.04~19f7a6d</p>
			<p class="source-code">Â Â Â Â Â Features: P Boot counting</p>
			<p class="source-code">Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â P Menu timeout control</p>
			<p class="source-code">. . .</p>
			<p class="source-code">. . .</p>
			<p>Use the <strong class="source-inline">list</strong> option <a id="_idIndexMarker715"/>to view all of the boot menu entries:</p>
			<p class="source-code">donnie@pop-os:~$ sudo bootctl list</p>
			<p class="source-code">Boot Loader Entries:</p>
			<p class="source-code">Â Â Â Â Â Â Â Â title: Pop!_OS (Pop_OS-current.conf) (default)</p>
			<p class="source-code">Â Â Â Â Â Â Â Â Â Â Â id: Pop_OS-current.conf</p>
			<p class="source-code">Â Â Â Â Â Â Â source: /boot/efi/loader/entries/Pop_OS-current.conf</p>
			<p class="source-code">Â Â Â Â Â Â Â Â linux: /EFI/Pop_OS-bc156c8a-fcb8-4a74-b491-089c77362828/vmlinuz.efi</p>
			<p class="source-code">Â Â Â Â Â Â Â initrd: /EFI/Pop_OS-bc156c8a-fcb8-4a74-b491-089c77362828/initrd.img</p>
			<p class="source-code">Â Â Â Â Â Â options: root=UUID=bc156c8a-fcb8-4a74-b491-089c77362828 ro quiet loglevel=0 systemd.show_status=false splash</p>
			<p class="source-code">. . .</p>
			<p class="source-code">. . .Â Â Â Â Â Â Â Â </p>
			<p class="source-code">title: Reboot Into Firmware Interface</p>
			<p class="source-code">Â Â Â Â Â Â Â Â Â Â Â id: auto-reboot-to-firmware-setup</p>
			<p class="source-code">Â Â Â Â Â Â Â source: /sys/firmware/efi/efivars/LoaderEntries-4a67b082-0a4c-41cf-b6c7-440b29bb8c4f</p>
			<p>Use the <strong class="source-inline">set-default</strong> option to permanently change the default boot option, or the <strong class="source-inline">set-oneshot</strong> option to set the default boot option for only the next boot-up. Take the ID of the boot option <a id="_idIndexMarker716"/>that you want to use from the list output and specify it with either option, like this:</p>
			<p class="source-code">donnie@pop-os:~$ sudo bootctl set-oneshot Pop_OS-oldkern.conf</p>
			<p class="source-code">donnie@pop-os:~$</p>
			<p>Now, go ahead and reboot the machine. This time, you'll see the boot menu come up. After the five-second menu timer expires, you'll see the machine boot up on the alternate kernel that you chose with this <strong class="source-inline">bootctl set-oneshot</strong> command.</p>
			<p>There's more that you can do with <strong class="source-inline">bootctl</strong>, but I'll let you read all about it in the <strong class="source-inline">bootctl</strong> man page.</p>
			<p>Let's wrap this chapter up by briefly look at the Secure Boot feature.</p>
			<h1 id="_idParaDest-249"><a id="_idTextAnchor261"/>Understanding Secure Boot</h1>
			<p>Secure Boot is an EFI/UEFI feature that prevents computers from loading any operating system, operating system <a id="_idIndexMarker717"/>modules, or device drivers that haven't been signed by an authorized security key. It helps prevent computers from loading various types of malware, such as rootkits. To enable or disable it, boot your machine to its setup screen, as you see here on my late-model Acer machine:</p>
			<div>
				<div id="_idContainer075" class="IMG---Figure">
					<img src="image/Figure_17.8_B17491.jpg" alt=""/>
				</div>
			</div>
			<p class="figure-caption">Figure 17.8 â€“ UEFI setup screen with Secure Boot enabled</p>
			<p>For some strange reason, it's still called the <em class="italic">BIOS Setup Utility</em>, even though this machine has a UEFI. What I want you to notice is the <strong class="bold">TPM Support</strong> option, which shows as <strong class="bold">[Enabled]</strong>. <strong class="bold">TPM</strong> stands for <strong class="bold">Trusted Platform Module</strong> and is the firmware chip on the motherboard that <a id="_idIndexMarker718"/>contains the signing keys that the Secure Boot option needs.</p>
			<p>On a Windows machine, Secure Boot is a big deal, because Windows has traditionally been very susceptible to <a id="_idIndexMarker719"/>malware infections. Linux is much less susceptible, although Secure Boot could be useful even for it. Ever since Microsoft introduced Windows 8, all new computers that come with Windows have Secure Boot enabled by default. For now, it's possible to disable Secure Boot on a Windows machine if you need to. With Windows 11, that will no longer be an option.</p>
			<p>When Secure Boot first came on the market, it caused much wailing and gnashing of teeth among the Linux faithful. That's because Secure Boot works by looking at the cryptographic signature of the machine's bootloader, and then compares it to the signature list that's in the computer's TPM. Okay, that doesn't sound so bad. What is bad is that the necessary signatures and signing keys are loaded into the TPM when the computer is manufactured, and Microsoft pretty much controls which signatures and keys get loaded. So, at first, Windows was the only operating system that was guaranteed to boot on a machine with Secure Boot enabled. Linux developers had to come up with a way to make Linux work with Secure Boot. The Linux faithful wailed and gnashed their teeth even more when they learned that this would have to involve letting Microsoft issue the signing keys for Linux bootloaders. (Yeah, the same Microsoft whose CEO at the time once stated that Linux is a <em class="italic">cancer</em>.)</p>
			<p>In this chapter, although you don't realize it yet, we've seen how GRUB2 and systemd-boot handle the Secure Boot feature in different ways. GRUB2 works with the shim system, which uses pre-signed shim files. On the Alma machine, these are the <strong class="source-inline">shimx64.efi</strong> and <strong class="source-inline">shimx64-almalinux.efi</strong> files, which we saw in the <strong class="source-inline">/boot/efi/EFI/almalinux/</strong> directory. On the Ubuntu Server machine, all we have is the <strong class="source-inline">shimx64.efi </strong>file in the <strong class="source-inline">/boot/efi/EFI/ubuntu/</strong> directory. So, why do we have this shim system, instead of just signing the GRUB2 bootloader files? Well, there are two reasons. One is that GRUB2 is already rather bloated and adding the Secure Boot code to it would bloat it even more. The other reason is that the GRUB2 code is licensed under the GPL3 free-as-in-speech software license. For some reason that I don't know, Microsoft refuses to issue signing keys for anything that's under GPL3. For that reason, systemd-boot is licensed under GPL2, which Microsoft seems to like better.</p>
			<p>When we looked at Pop!_OS Linux, I pointed out that it doesn't have any <strong class="source-inline">shimx64*.efi</strong> files. Since <a id="_idIndexMarker720"/>systemd-boot is under GPL2, Microsoft will sign its files, making the shim system unnecessary.</p>
			<p>Okay, I'm reading your mind again, hopefully for the final time. You're thinking, <em class="italic">But, Donnie. What if I've created a kernel module, and I need it to load on a Secure Boot machine? And what if I install Linux on a Secure Boot machine, and then decide that I don't trust any signing keys that are issued by Microsoft? What can I do?</em></p>
			<p>Well, in both cases, it is possible to create signing keys and load them into the TPM yourself. It's a long procedure that I can't go into here, so I'll refer you to the <em class="italic">Managing EFI bootloaders for Linux</em> site that's linked in the <em class="italic">Further reading</em> section. In its <em class="italic">Table of Contents</em>, you'll see a link to the Secure Boot page, where you'll find the procedure.</p>
			<p>And that, guys and gals, is it for the bootloader chapter. Let's summarize and then wrap this baby up in swaddling clothes.</p>
			<h1 id="_idParaDest-250"><a id="_idTextAnchor262"/>Summary</h1>
			<p>As always, we've covered much ground in this chapter. We started by providing an overview of the computer architecture and then discussed how the GRUB2 bootloader works on both BIOS-based and EFI/UEFI-based computers. Then, we covered systemd-boot on the Pop!_OS Linux machine, and wrapped up with a discussion of Secure Boot.</p>
			<p>In the next chapter, which will be our final one, we'll talk about systemd-logind. I'll see you there.</p>
			<h1 id="_idParaDest-251"><a id="_idTextAnchor263"/>Questions</h1>
			<p>To test your knowledge of this chapter, answer the following questions:</p>
			<ol>
				<li value="1">Which of the following statements is true?<p>A. Only GPT partitions can be used on BIOS-based computers.</p><p>B. Only a GPT partition can be used to install GRUB2.</p><p>C. Only a GPT partition can be used to install systemd-boot.</p><p>D. Only an MBR partition can be used to install systemd-boot.</p></li>
				<li>How does GRUB2 work with Secure Boot?<p>A. It uses the shim system.</p><p>B. Its files are directly signed by Microsoft.</p><p>C. GRUB2 doesn't work with Secure Boot.</p></li>
				<li>How does systemd-boot work?<p>A. It uses the <strong class="source-inline">grubx64.efi</strong> file to activate the bootloader.</p><p>B. It copies the kernel file over to a file with a <strong class="source-inline">.efi</strong> filename extension so that the kernel can act as its own bootloader.</p><p>C. It directly calls in the Linux kernel from the <strong class="source-inline">/boot/</strong> directory.</p><p>D. It doesn't work at all.</p></li>
				<li>What is necessary to make Secure Boot work?<p>A. Nothing. It works on all computers.</p><p>B. That the machine has a BIOS chip, and that TPM is enabled.</p><p>C. That the machine has an EFI/UEFI, and that TPM is enabled.</p><p>D. Nothing. It never works.</p></li>
			</ol>
			<h1 id="_idParaDest-252"><a id="_idTextAnchor264"/>Answers</h1>
			<ol>
				<li value="1">C</li>
				<li>A</li>
				<li>B</li>
				<li>C</li>
			</ol>
			<h1 id="_idParaDest-253"><a id="_idTextAnchor265"/>Further reading</h1>
			<p>To learn more about the topics that were covered in this chapter, take a look at the following resources:</p>
			<ul>
				<li>The 15 best bootloaders for home and embedded systems: <a href="https://www.ubuntupit.com/best-linux-bootloader-for-home-and-embedded-systems/">https://www.ubuntupit.com/best-linux-bootloader-for-home-and-embedded-systems/</a></li>
				<li>The UEFI Interactive Shell: <a href="https://linuxhint.com/use-uefi-interactive-shell-and-its-common-commands/">https://linuxhint.com/use-uefi-interactive-shell-and-its-common-commands/</a></li>
				<li>What is <strong class="source-inline">vmlinux.efi</strong>?: <a href="https://askubuntu.com/questions/330541/what-is-vmlinuz-efi">https://askubuntu.com/questions/330541/what-is-vmlinuz-efi</a></li>
				<li>How to modify systemd-boot: <a href="https://www.techrepublic.com/article/how-to-modify-systemd-boot-on-linux/">https://www.techrepublic.com/article/how-to-modify-systemd-boot-on-linux/</a></li>
				<li><strong class="source-inline">Pop!_OS</strong> recovery partition: <a href="https://support.system76.com/articles/pop-recovery">https://support.system76.com/articles/pop-recovery</a></li>
				<li>Secure Boot overview: <a href="https://www.dell.com/support/kbdoc/en-us/000145423/secure-boot-overview">https://www.dell.com/support/kbdoc/en-us/000145423/secure-boot-overview</a></li>
				<li>An explanation of Secure Boot: <a href="https://docs.microsoft.com/en-us/windows-hardware/design/device-experiences/oem-secure-boot">https://docs.microsoft.com/en-us/windows-hardware/design/device-experiences/oem-secure-boot</a></li>
				<li>Secure Boot Linux: <a href="https://linuxhint.com/secure-boot-linux/">https://linuxhint.com/secure-boot-linux/</a></li>
				<li>Installing Linux with Secure Boot: <a href="https://www.linux.org/threads/installing-linux-with-secure-boot-and-friends.29454/">https://www.linux.org/threads/installing-linux-with-secure-boot-and-friends.29454/</a></li>
				<li>Changing to <strong class="source-inline">BootLoaderSpec</strong> files: <a href="https://fedoraproject.org/wiki/Changes/BootLoaderSpecByDefault">https://fedoraproject.org/wiki/Changes/BootLoaderSpecByDefault</a></li>
				<li>Managing EFI bootloaders for Linux: <a href="https://www.rodsbooks.com/efi-bootloaders/index.html">https://www.rodsbooks.com/efi-bootloaders/index.html</a></li>
				<li>Ballmer: Linux is a cancer: <a href="https://www.theregister.com/2001/06/02/ballmer_linux_is_a_cancer/">https://www.theregister.com/2001/06/02/ballmer_linux_is_a_cancer/</a></li>
			</ul>
		</div>
	</body></html>