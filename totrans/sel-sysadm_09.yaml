- en: '*Chapter 7*: Configuring Application-Specific SELinux Controls'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Several Linux services and applications enable additional SELinux controls besides
    the kernel-enforced SELinux policy. They allow the administrator to further manipulate
    and enforce policy rules through the application itself—isolating users, reducing
    data leakage risks, and mitigating the impact of malicious behavior.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will look at several SELinux-aware applications, such as
    systemd services and how they allow administrators to set up and specify target
    domains and resource labels. We'll also cover the D-Bus service, which allows
    SELinux policies to control the service binding and message communication within
    D-Bus itself. Next, we'll jump to PAM-enabled services that allow users to log
    in through them.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we'll end the chapter with `mod_selinux`, an Apache module that allows
    SELinux-specific tuning of the web server's behavior. This approach shows how
    applications that do not natively have SELinux support can still be extended to
    address the administrator's requirements.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
- en: 'We will cover the following topics in this chapter:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
- en: Tuning systemd services, logging, and device management
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Communicating over D-Bus
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Configuring PAM services
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using mod_selinux with Apache
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Check out the following video to see the Code in Action: [https://bit.ly/37jYtze](https://bit.ly/37jYtze)'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
- en: Tuning systemd services, logging, and device management
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`init` system, responsible for handling services and boot-up operations.'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
- en: 'Throughout its development phase, systemd added several other components to
    its portfolio:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
- en: D-Bus, which offers a system and session bus service allowing the use of D-Bus
    for inter-application communication, merged with systemd.
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: systemd also incorporated `udev`, which offers a flexible device-node management
    application.
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Login capabilities were added to systemd, enabling fine-grained control over
    user sessions.
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `journald` daemon joined the systemd family to provide a new approach to
    system and service logging, replacing some of the functionality of standard system
    loggers.
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `timerd` daemon provides support for the time-based execution of tasks,
    replacing some of the functionality of standard cron daemons.
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Network configurations can be managed by systemd-networkd.
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This ongoing approach of absorbing several system services into a single application
    suite has not gone unnoticed and isn't without controversy. Some distributions
    even refuse to have systemd as the default `init` system.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
- en: 'The systemd project includes SELinux support for most of its services. Applications
    such as systemd, which not only include SELinux awareness but also enforce access
    controls on specific SELinux classes and permissions (rather than relying on the
    Linux kernel), are called **userspace object managers**:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.1 — The difference between kernel-enforced, standard SELinux, and
    userspace-managed SELinux ](img/B16276_07_001.jpg)'
  id: totrans-22
  prefs: []
  type: TYPE_IMG
- en: Figure 7.1 — The difference between kernel-enforced, standard SELinux, and userspace-managed
    SELinux
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.1 — 内核强制、标准SELinux和用户空间管理SELinux之间的区别
- en: If an application enforces access controls toward certain classes and permissions,
    then it will also have its own AVC (see [*Chapter 2*](B16276_02_Final_VK.xhtml#_idTextAnchor045),
    *Understanding SELinux Decisions and Logging*, for more information about the
    AVC). Log events resulting from these applications will be identified as `USER_AVC`
    events rather than (kernel-managed) `AVC` events. The systemd application has
    support for systemd-specific classes, as we will see in the *Governing unit operation
    access* section. But before we dive into these specific details, let's first see
    what systemd is all about and what SELinux support it has.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一个应用程序实施了针对特定类和权限的访问控制，那么它也将拥有自己的AVC（有关AVC的更多信息，请参见[*第2章*](B16276_02_Final_VK.xhtml#_idTextAnchor045)，*理解SELinux决策和日志记录*）。由这些应用程序生成的日志事件将被标识为`USER_AVC`事件，而不是（内核管理的）`AVC`事件。systemd应用程序支持特定于systemd的类，正如我们在*管理单元操作访问*部分中所看到的那样。但在深入探讨这些具体细节之前，让我们先了解一下systemd是什么以及它对SELinux的支持。
- en: Service support in systemd
  id: totrans-25
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: systemd中的服务支持
- en: The main capability of the system daemon that most people know about is its
    support for system services. Unlike traditional SysV-compatible `init` systems,
    systemd does not use scripts to manage services. Instead, it uses a declarative
    approach for the various services, documenting the wanted state and configuration
    parameters while using its own logic to ensure that the right set of services
    start at the right time and in the correct order.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数人所知道的systemd主要功能是它对系统服务的支持。与传统的兼容SysV的`init`系统不同，systemd不使用脚本来管理服务。相反，它使用声明性的方法来管理各种服务，记录所需的状态和配置参数，同时使用自己的逻辑确保在正确的时间和顺序启动正确的服务。
- en: Understanding unit files
  id: totrans-27
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 理解单元文件
- en: 'systemd uses unit files to declare how a service should behave. These unit
    files use the INI-style syntax, supporting sections and key/value pairs within
    each file. A service can have multiple unit files that influence the service at
    large. It is important to remember that different unit files for the same service
    are all related:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: systemd使用单元文件来声明服务应如何运行。这些单元文件使用INI风格的语法，支持每个文件中的节和键/值对。一个服务可以有多个单元文件，它们会对该服务产生整体影响。重要的是要记住，同一个服务的不同单元文件是相关的：
- en: The `*.service` unit files define how a system service should be launched, what
    its dependencies are, how systemd should treat sudden failures, and so on.
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`*.service`单元文件定义了如何启动系统服务，它的依赖关系是什么，systemd应该如何处理突然的故障等。'
- en: The `*.socket` unit files define which socket(s) should be created and which
    permissions should be assigned to it. systemd uses this for services that can
    be launched on request rather than directly at boot.
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`*.socket`单元文件定义了应创建哪些套接字以及应分配给它的权限。systemd使用它来处理那些可以按需启动而不是在启动时直接启动的服务。'
- en: The `*.timer` unit files define at what time or frequency the service should
    be launched. Services that do not necessarily run daemonized but need to execute
    a certain logic at defined intervals can use these timer files to ensure regular
    runs. These settings are comparable to the more classic yet still widely used
    crontabs, which we briefly touch upon in *PAM services*, in the subsection called
    *Cron*.
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`*.timer`单元文件定义了服务应在何时或以何种频率启动。那些不一定以守护进程方式运行，但需要在定义的间隔内执行某些逻辑的服务，可以使用这些定时器文件来确保定期执行。这些设置与经典但仍广泛使用的crontab相似，我们在*PAM服务*的*Cron*小节中简要提到过。'
- en: Other unit files exist as well, although those have more in common with generic
    system configurations (such as slice definitions and automount settings) and less
    with runtime services.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 也存在其他单元文件，尽管它们更像是通用的系统配置（如切片定义和自动挂载设置），与运行时服务的关系较少。
- en: 'System unit files can be placed in one of three locations:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 系统单元文件可以放置在以下三个位置之一：
- en: Unit files are installed by default by the system's package manager inside `/usr/lib/systemd/system`.
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 默认情况下，单元文件由系统的包管理器安装在`/usr/lib/systemd/system`目录中。
- en: At runtime, updates can be placed inside `/run/systemd/system`, which will override
    the unit files in the default location. However, this location is transient and
    will not persist across reboots.
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在运行时，更新可以放置在`/run/systemd/system`目录中，这将覆盖默认位置的单元文件。然而，这个位置是临时的，在重启后不会保留。
- en: System administrators can override the configurations in the two locations by
    placing unit files in `/etc/systemd/system`. These unit files override previous
    definitions, so there is no need to remove the unit files from the previous locations.
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'As an example, check out the default Nginx service unit file, `nginx.service`,
    inside `/usr/lib/systemd/system`:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: This unit file declares the command to launch Nginx with and informs systemd
    that the service should be launched after successfully reaching the `network`,
    `remote-fs`, and `nss-lookup` targets (which is a milestone in the boot process,
    allowing proper dependency handling). The unit file also declares that it is a
    dependency of the `multi-user` target (which is the equivalent of the default
    run level when using SysV-style `init` services), which means the service should
    launch when the system boots.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
- en: Setting the SELinux context for a service
  id: totrans-40
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: When systemd launches a service, it executes the command defined through the
    `ExecStart=` configuration entry in the service unit file. By default, a standard
    domain transition will occur as defined through the SELinux policy.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
- en: Package developers and system administrators can, however, update the service
    unit files to have the service launched in an explicitly mentioned SELinux domain.
    To accomplish this, the `[Service]` section of the unit file can be extended with
    the `SELinuxContext=` configuration entry.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
- en: 'For instance, to ensure that Nginx launches with the `httpd_t:s0:c0.c128` context,
    you''d use this:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Of course, it is also possible to use this to have a service running with a
    different context, which can be useful when developing custom policies for daemons.
    However, keep in mind that the SELinux policy rules still apply: you cannot ask
    systemd to launch Nginx, for instance, with the `dnsmasq_t` domain without updating
    the SELinux policy so that `httpd_exec_t` (the entry point for the `httpd_t` domain)
    is also made an entry point for the `dnsmasq_t` domain.'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
- en: 'When you request systemd to explicitly use an SELinux context for a service,
    systemd will attempt to use this context for all execution-related tasks: `ExecStartPre`,
    `ExecStart`, `ExecStartPost`, `ExecStopPre`, `ExecStop`, `ExecStopPost`, and `ExecReload`.
    As these tasks often are not labeled with the right entry point label, these commands
    can fail. In that case, prefix the commands with `+` so that the SELinux context
    definition does not apply to them:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: While developing and changing unit files, the changed settings might not always
    be immediately applied to the system. Running `systemctl daemon-reload` after
    modifying unit files will ensure that the latest changes on the system are read
    by systemd.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
- en: Using transient services
  id: totrans-49
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: systemd can also be used to launch applications as if they are services and
    have them under systemd's control. Such applications are called **transient services**
    as they lack the unit files that generally declare how systemd should behave.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
- en: 'Transient services are launched through the `systemd-run` application. To show
    this, let''s create a simple Python script (one that calculates Pi up to 10,000
    digits):'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'As this takes some time, we can opt to run this Python script under systemd''s
    control:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'As transient services do not have unit files to manage, changing the SELinux
    context must be accomplished through the command line as well. Of course, this
    is only needed if the standard domain transitions defined in the policy do not
    result in the wanted behavior:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The `systemd-run` application supports this through the `--property` (or `-p`)
    option, through which unit file properties can be added. In the previous example,
    we use this option to run the script in the `guest_t` domain using the `SELinuxContext`
    property, similar to how we would define this in the unit file itself.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
- en: Requiring SELinux for a service
  id: totrans-58
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Some services should only run when SELinux is enabled or disabled. With systemd,
    this can be defined through its conditional parameters.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
- en: A service unit file can contain several conditions that need to be valid before
    systemd will consider executing the service. These conditionals can point to the
    system type (virtualized or not), kernel command-line parameters, files that do
    or don't exist, and so on. The one we are interested in is `ConditionSecurity`,
    which represents the state of the given security system—in our case, SELinux.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
- en: 'For instance, look at the `selinux-autorelabel.service` unit file inside `/usr/lib/systemd/system`:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Similarly, the Linux distribution provides the `selinux-autorelabel-mark.service`
    file. This service ensures that, if SELinux is not active when the system boots
    (and no `/.autorelabel` file exists yet), then systemd will create an empty `/.autorelabel`
    file. This file ensures that, when the system reboots with SELinux support, the
    relabeling operation occurs.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
- en: Relabeling files during service startup
  id: totrans-64
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: One of the actions that many services require is the preparation of service-specific
    runtime directories, such as `/run/httpd` for the Apache service. systemd supports
    this through `tmpfiles.d`. We have briefly covered `tmpfiles` in [*Chapter 4*](B16276_04_Final_VK.xhtml#_idTextAnchor095),
    *Using File Contexts and Process Domains*. Within `tmpfiles`, we can define the
    files and locations requested to be provided or updated immediately (at boot time)
    when these are not placed in the (persisted) filesystem.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
- en: 'For instance, the package that provides the Apache daemon installs the following
    definition as `/usr/lib/tmpfiles.d/httpd.conf` on the system:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Like the systemd unit files, the files that contain these settings should be
    declared in one of the following three locations. Each location overrides the
    settings of the previous one:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
- en: The default, package-provided location is `/usr/lib/tmpfiles.d`.
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Runtime declarations can be placed in `/run/tmpfiles.d`.
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Local system administrator-provided declarations are placed in `/etc/tmpfiles.d`.
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: These definitions can get much more specific than just directory creation. Through
    the `tmpfiles.d` application, definitions can be set to create files, empty directories
    upfront, create sub-volumes, manage special files such as symbolic links or block
    devices, set extended attributes, and more.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 这些定义可以比仅创建目录更具体。通过 `tmpfiles.d` 应用程序，可以设置定义来创建文件、预先清空目录、创建子卷、管理特殊文件（如符号链接或块设备）、设置扩展属性等。
- en: One of its features is to set the file mode and ownership, and restore the SELinux
    context on a file (`z`) or recursively against a directory (`Z`). This can be
    used to change contexts on files that have a proper context definition in the
    policy, but whose context is not properly assigned.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 其特点之一是设置文件模式和所有权，并恢复文件（`z`）或递归地针对目录（`Z`）的 SELinux 上下文。这可以用于更改具有正确上下文定义的文件的上下文，但其上下文未正确分配。
- en: 'For instance, look at the definitions in the `selinux-policy.conf` file inside
    `/usr/lib/tmpfiles.d`:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，查看 `/usr/lib/tmpfiles.d` 中的 `selinux-policy.conf` 文件中的定义：
- en: '[PRE8]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'We need to relabel files inside `/sys` because this location is labeled with
    `sysfs_t` by default and changing the context at runtime does not preserve its
    status across reboots. Yet some of its files should have a different label – the
    `/sys/devices/system/cpu/online` file, for instance, requires the `cpu_online_t`
    label:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要重新标记 `/sys` 中的文件，因为该位置默认标记为 `sysfs_t`，并且在运行时更改上下文不会在重启后保留其状态。然而，其中一些文件应该有不同的标签——例如
    `/sys/devices/system/cpu/online` 文件需要 `cpu_online_t` 标签：
- en: '[PRE9]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The definition ensures that this (pseudo) file is relabeled at boot so that
    all other processes that rely on the file labeled with `cpu_online_t` can happily
    continue working.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 该定义确保在启动时重新标记此（伪）文件，以便所有依赖于标有 `cpu_online_t` 的文件的其他进程可以顺利继续工作。
- en: The other arguments to the definition are explicitly marked with a dash in the
    previous example, meaning that no other parameters need to be configured. They
    can be used to set the mode, **User Identifier** (**UID**), **Group Identifier**
    (**GID**), age, and argument related to the rule.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 定义的其他参数在前一个示例中明确标记为破折号，意味着不需要配置其他参数。它们可以用来设置模式、**用户标识符** (**UID**)、**组标识符**
    (**GID**)、年龄以及与规则相关的参数。
- en: 'An example configuration that uses some of these other parameters with the
    `z` or `Z` state is the `systemd.conf` file:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `z` 或 `Z` 状态的这些其他参数的示例配置是 `systemd.conf` 文件：
- en: '[PRE10]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: For more information about the definition format, see `man tmpfiles.d`.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 有关定义格式的更多信息，请参见 `man tmpfiles.d`。
- en: Using socket-based activation
  id: totrans-83
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用基于套接字的激活
- en: The system daemon also supports socket-based activation. When configured, systemd
    will create the socket on which the daemon usually listens and will have the daemon
    launched when the socket is first used. This allows systems to boot quickly (as
    many daemons do not need to be launched immediately) while still ensuring that
    all required sockets are available.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 系统守护进程还支持基于套接字的激活。当配置完成时，systemd 会创建守护进程通常监听的套接字，并在第一次使用该套接字时启动守护进程。这使得系统可以快速启动（因为许多守护进程不需要立即启动），同时确保所有必需的套接字都可用。
- en: When a client only writes information to the socket (such as with the `/dev/log`
    socket), the client does not even need to wait for the daemon to be activated.
    The data is stored in a buffer until the daemon can read it. Only when the buffer
    is full will the operation block until the daemon flushes the buffer.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 当客户端仅向套接字写入信息时（例如 `/dev/log` 套接字），客户端甚至不需要等待守护进程激活。数据会存储在缓冲区中，直到守护进程能够读取它。只有当缓冲区满时，操作才会阻塞，直到守护进程刷新缓冲区。
- en: 'Take a look at the `systemd-journald.socket` unit file, available inside `/usr/lib/systemd/system`:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 查看位于 `/usr/lib/systemd/system` 中的 `systemd-journald.socket` 单元文件：
- en: '[PRE11]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: When a client uses one of the mentioned sockets, then systemd will launch the
    `systemd-journald.service` unit to accommodate the client interaction. As long
    as these sockets are not used, the service will not be started.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 当客户端使用上述套接字之一时，systemd 将启动 `systemd-journald.service` 单元来处理客户端交互。只要这些套接字未被使用，服务将不会启动。
- en: 'Inside the `[Socket]` section, an SELinux-specific entry can be defined: `SELinuxContextFromNet=true`.
    When a unit file has this entry set, systemd will obtain the MLS/MCS information
    from the client context (the application connecting to the socket) and append
    this to the context of the service. This sensitivity inheritance can be used to
    prevent any information leakage from taking place when communication is happening
    through sockets.'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `[Socket]` 部分中，可以定义一个 SELinux 特定的条目：`SELinuxContextFromNet=true`。当一个单元文件设置了这个条目时，systemd
    会从客户端上下文（连接到套接字的应用程序）中获取 MLS/MCS 信息，并将其附加到服务的上下文中。这种敏感性继承可以用来防止在通过套接字进行通信时发生信息泄露。
- en: Governing unit operation access
  id: totrans-90
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 管理单元操作访问
- en: Until now, we've looked at configuration settings related to systemd's SELinux
    support. systemd also uses SELinux to control access to services defined through
    unit files. When a user wants to perform an operation against a unit (such as
    starting a service or checking the state of a running service), systemd queries
    the SELinux policy to see whether it will allow this operation.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经查看了与 systemd 的 SELinux 支持相关的配置设置。systemd 还使用 SELinux 来控制对通过单元文件定义的服务的访问。当用户想对某个单元执行操作（例如启动服务或检查运行中的服务状态）时，systemd
    会查询 SELinux 策略，以查看是否允许此操作。
- en: 'The systemd daemon uses the service class to validate the permissions of the
    client''s domain toward the requested operation. For instance, to validate whether
    a user context, `sysadm_t`, can view the status of the service associated with
    the `sshd.service` unit file, it checks the context of this file (being `sshd_unit_file_t`)
    and then validates whether the status permission is granted:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: systemd 守护进程使用服务类来验证客户端域对请求操作的权限。例如，为了验证用户上下文 `sysadm_t` 是否可以查看与 `sshd.service`
    单元文件相关的服务状态，它会检查该文件的上下文（为 `sshd_unit_file_t`），然后验证是否授予了状态权限：
- en: '[PRE12]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Other supported permissions are `disable`, `enable`, `reload`, `start`, and
    `stop`. When a permission is not granted, a `USER_AVC` denial message will be
    visible in the audit logs (rather than an `AVC` message) as the message is not
    generated by the Linux kernel, but by systemd. So, while the rules themselves
    are part of the SELinux policy, it is systemd that enforces the access.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 其他支持的权限有 `disable`、`enable`、`reload`、`start` 和 `stop`。当权限未被授予时，审计日志中会显示 `USER_AVC`
    拒绝消息（而非 `AVC` 消息），因为该消息不是由 Linux 内核生成的，而是由 systemd 生成的。因此，虽然规则本身是 SELinux 策略的一部分，但访问控制是由
    systemd 强制执行的。
- en: 'systemd, or the client through which systemd is queried, might also provide
    additional error messages to reflect that the SELinux policy prevents the action.
    For instance, if we attempt to query systemd over D-Bus (which we cover in the
    *D-Bus communication* section) from an unprivileged user domain, then we get the
    following error:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: systemd 或通过 systemd 查询的客户端可能还会提供额外的错误信息，表明 SELinux 策略阻止了该操作。例如，如果我们尝试通过 D-Bus
    查询 systemd（我们将在 *D-Bus 通信* 部分介绍），并且从一个非特权用户域发起查询，那么我们会得到以下错误：
- en: '[PRE13]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: To facilitate troubleshooting any systemd-triggered failures, systemd also has
    an extensive logging component, called `systemd-journald`, which we'll cover next.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 为了便于故障排除，systemd 还具有一个广泛的日志记录组件，叫做 `systemd-journald`，我们将在接下来介绍。
- en: Logging with systemd
  id: totrans-98
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 systemd 进行日志记录
- en: 'systemd is not only responsible for service management: it takes up several
    other tasks as well. One of these tasks is log management, traditionally implemented
    through a system logger.'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: systemd 不仅负责服务管理，还承担着其他几个任务。其中一个任务是日志管理，传统上通过系统日志记录器来实现。
- en: While systemd still supports running with a traditional system logger, it now
    suggests the use of `systemd-journald`. One of the advantages of the journal daemon
    is that it is not limited to textual, single-line log messages. Daemons can now
    use binaries as well as multiline messages as part of its logging capabilities.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然 systemd 仍然支持使用传统的系统日志记录器，但现在建议使用 `systemd-journald`。日志守护进程的一个优势是，它不局限于文本的单行日志消息。守护进程现在可以使用二进制数据以及多行消息作为日志记录的一部分。
- en: The journal daemon also registers information about the sending process alongside
    the log messages themselves. This additional information contains ownership data
    (the process owner) including the SELinux context of the sending process.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 日志守护进程还会注册关于发送进程的信息，并与日志消息本身一起记录。这些附加信息包含了所有者数据（进程所有者），包括发送进程的 SELinux 上下文。
- en: Retrieving SELinux-related information
  id: totrans-102
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 检索与 SELinux 相关的信息
- en: 'The traditional approach to receive SELinux-related information (excluding
    the audit events we tackled before) is to `grep` through the log information.
    With the journal daemon, we can accomplish this as follows:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The `-b` option passed on to the journal control application informs the journal
    daemon that we are only interested in the log messages that originated for a specific
    boot.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
- en: Querying logs given an SELinux context
  id: totrans-106
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'A unique feature of the journal daemon is to use the information associated
    with the log messages as part of the query to be launched against the journal
    database. For instance, we can ask the journal daemon to only show those messages
    that originated from a daemon or application running in the `udev_t` context:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The available contexts can be retrieved through the Bash completion support
    on the system. After writing `_SELINUX_CONTEXT=`, press *Tab* twice to see the
    possible values.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
- en: Using setroubleshoot integration with journal
  id: totrans-110
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The SELinux troubleshoot daemon is also integrated with `systemd-journald`.
    Any alert that comes up from `setroubleshootd` is also available through the journal
    daemon.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
- en: 'This helps administrators as they will quickly find out about SELinux denials
    when investigating problems. For instance, when the Nginx web server is not working
    properly and this is due to an SELinux policy, a quick investigation of the status
    of the service will reveal that the SELinux policy is preventing some actions:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'To get more information about the message, use `journalctl`:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: As you can see, `systemd-journald` has captured environment information related
    to the service, which can provide much-needed guidance on resolving potential
    problems.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
- en: A third systemd service that has SELinux configuration possibilities is the
    device daemon.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
- en: Handling device files
  id: totrans-118
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Linux has a long history of device managers. Initially, administrators needed
    to make sure that the device nodes were already present on the filesystem (`/dev`
    was part of the persisted filesystem). Gradually, Linux adopted more dynamic approaches
    for device management.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
- en: Nowadays, device files are managed through a combination of a pseudo filesystem
    (`devtmpfs`) and a userspace device manager called udev. This device manager is
    merged in systemd as well, becoming `systemd-udevd`.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
- en: The device manager listens on a kernel socket for kernel events. These events
    inform the device manager about detected or plugged-in devices (or the removal
    of such devices) and allow the device manager to take appropriate action. For
    udev, these actions are defined in udev rules.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
- en: Using udev rules
  id: totrans-122
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Configuring the udev subsystem is mainly done through udev rules. These rules
    are one-liners that contain a matching part and an action part.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
- en: 'The matching part contains validations, executed against the event(s) that
    udev receives from the Linux kernel. This validation uses key/value pairs obtained
    from the event, and includes the following possible keys:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
- en: Kernel-provided device name (`KERNEL`)
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Device subsystem (`SUBSYSTEM`)
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Kernel driver (`DRIVER`)
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Specific attributes (`ATTR`)
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Active environment variables (`ENV`)
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The action type to inform if the device is detected or removed (`ACTION`)
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: While more match keys are possible, the preceding list is most commonly used.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
- en: 'The Linux kernel will also inform the device manager about the device hierarchy.
    This allows rules to be defined based on, for instance, the USB controller through
    which a USB device is plugged in. Alongside the information for the device itself,
    the kernel will also provide hierarchically related information through similar
    key/value pairs. These pairs, however, use a key definition in plural form: `SUBSYSTEMS`
    instead of `SUBSYSTEM`, `DRIVERS` instead of `DRIVER`, and so on.'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
- en: 'For instance, to match a USB webcam with vendor ID `05a9` and product ID `4519`,
    the match-related pairs could look like this:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: The second part of a udev rule is the action to take. The most common action
    is to create a symbolic link to the created device file, ensuring that applications
    can always reach the same device through the same symbolic link, even when the
    device from the kernel point of view has a different name. We can, for instance,
    extend the preceding example with `SYMLINK+="webcam1"` to have `/dev/webcam1`
    point to this newly detected device.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
- en: The udev application supports many more actions than just defining symbolic
    links, of course. It can associate ownership (`OWNER`) or group membership (`GROUP`)
    on the device, controlling who can access the devices. udev can also set environment
    variables (`ENV`) and even run a command (`RUN`) when the matched device is plugged
    in or detached from the system. To make sure the command is only executed when
    the device is added, we need to add an `ACTION` setting such as `ACTION=="add"`.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
- en: Important note
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
- en: udev can interpret `ENV` as both a matching key as well as an action key. The
    difference is the operation performed (a single equals sign `=` or a double `==`).
    `ENV{envvar}=="value"` is a match operation (checking whether the variable matches
    the given `value`), whereas `ENV{envvar}="value"` is an action (setting the variable
    to `value`).
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
- en: udev rules are provided by default through the `/usr/lib/udev/rules.d` location.
    Distributions and applications/drivers will store their default rules in this
    location. Additional rules or rule overrides can be placed in `/etc/udev/rules.d`.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
- en: It's important to remember that udev will continue processing rules even when
    it has already encountered a matching rule. This can be changed on a per-rule
    basis through the `OPTIONS` action, as with `OPTIONS+="last_rule"`, which informs
    udev that it can stop processing further rules for this event.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
- en: Setting an SELinux label on a device node
  id: totrans-141
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'One of the actions that udev supports is to assign an SELinux context on the
    device node. We can do this using the `SECLABEL{selinux}` action:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Note that this action only sets the context on the device node. If the rule
    also sets a symbolic link, then the symbolic link itself will inherit the default
    `device_t` context.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
- en: Placing an SELinux label on a device node is often done together with the other
    security-related permissions, so the rule often receives additional actions such
    as setting the target owner (`OWNER`), group (`GROUP`), and permission set (`MODE`).
    After all, SELinux security controls only apply *after* the regular, discretionary
    access control checks have passed, so don't forget to make sure your users have
    access to the device nodes outside of the SELinux controls as well.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
- en: All the settings we've seen so far are about systemd service management and
    system support. Another component within the systemd ecosystem is D-Bus, which
    is less about system management and more about facilitating communication and
    interaction between different applications over a programmable communication bus.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
- en: Communicating over D-Bus
  id: totrans-147
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The D-Bus daemon provides an inter-process communication channel between applications.
    Unlike traditional IPC methods, D-Bus is a higher-level communication channel
    that offers more than simple signaling or memory sharing. Applications that want
    to chat over D-Bus link with one of the many D-Bus-compatible libraries, such
    as those provided by the libdbus, sd-bus (part of systemd), GDBus, and QtDBus
    applications.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
- en: The D-Bus daemon is part of the systemd application suite.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
- en: Understanding D-Bus
  id: totrans-150
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Linux generally supports two D-Bus types – system-wide and session-specific
    D-Bus instances:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
- en: The system-wide D-Bus is the main instance used for system communication. Many
    services or daemons will associate themselves with the system D-Bus to allow others
    to communicate with them through D-Bus.
  id: totrans-152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The session-specific D-Bus is an instance running for each logged-in user. It
    is commonly used by graphical applications to communicate with each other within
    a user session.
  id: totrans-153
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Both D-Bus instances are provided through the `dbus-daemon` application. The
    system-wide D-Bus will run with the `--system` option, whereas a session-specific
    instance will run with the `--session` option.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
- en: Applications register themselves against D-Bus through a namespace. Conventionally,
    this namespace uses the domain name of the project. For instance, systemd declares
    the `org.freedesktop.systemd1` namespace, whereas D-Bus is at `org.freedesktop.DBus`.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
- en: 'The currently associated applications can be queried using Python easily:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Each application then provides objects on the bus that can be reached by other
    objects (other applications)—of course, assuming they have the privileges to do
    so. These objects are represented through a path-like syntax and generally also
    use the domain of the project as a prefix.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
- en: 'For instance, to list the objects currently associated with `org.freedesktop.systemd1`,
    we can use the `gdbus` command. To facilitate its use, we first enable auto-completion
    support, after which we can use the *Tab* key to easily add the appropriate values:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Applications can trigger methods on these objects, or send messages to the applications
    bound to these objects through these methods.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
- en: 'For instance, to get the state of the `sshd.service` unit through D-Bus, we
    invoke the `org.freedesktop.systemd1.Manager.GetUnitFileState` method on the `org.freedesktop.systemd1`
    object reachable through the `/org/freedesktop/systemd1` path, and with the `sshd.service`
    argument, like this:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: These calls can also be controlled through the SELinux policy, as we will learn
    next.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
- en: Controlling service acquisition with SELinux
  id: totrans-165
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The D-Bus application, like systemd, will query the SELinux policy to verify
    whether to allow an operation. Again, it is the D-Bus application itself that
    enforces the policy and not a Linux kernel subsystem.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
- en: The first control that administrators can enable within D-Bus is to ensure that
    only well-established domains can acquire a specified object within D-Bus. Without
    this control, malicious code could register itself as `org.freedesktop.login1`,
    for instance, and act as a system daemon on the bus. Other applications might
    mistakenly send out sensitive information to the application.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
- en: 'Applications store this policy information in files hosted in `/usr/share/dbus-1/system.d`.
    The login service, for instance (stored as `org.freedesktop.login1.conf`) has
    the following policy snippet installed:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'As the login daemon runs in the `systemd_logind_t` domain, we could enhance
    this configuration as follows:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'With this enhancement in place, D-Bus will check whether the application (which
    we presume is running in the `systemd_logind_t` context) has the `acquire_svc`
    permission (of the `dbus` class) against the `systemd_logind_t` context. By default,
    the SELinux policy does not have this permission, and as such, the registration
    fails:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'When we add the following SELinux policy rule, the registration of `systemd-logind`
    will succeed, as expected:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Load this policy (say `test.cil`) and try the `restart` operation again:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: By limiting which domains can obtain a given service, we ensure that only trusted
    applications are used. Non-trusted applications will generally not run within
    the domain of that application (end users, for instance, cannot trigger a transition
    to such a domain) even if they receive root privileges (which is another check
    that D-Bus does for the login service, as shown in the first `busconfig` snippet).
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
- en: Administrators can enhance this D-Bus configuration without having to alter
    the existing configuration files. For instance, the previously mentioned SELinux-governing
    `busconfig` snippet could very well be saved as a different file.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
- en: Governing message flows
  id: totrans-180
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A second control that D-Bus validates is which applications can communicate
    with each other. This is not configurable through the service configurations but
    is a pure SELinux policy control.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
- en: Whenever a source application is calling a method of a target application, D-Bus
    validates the `send_msg` permission between the two domains associated with the
    source and target applications.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
- en: 'For instance, communication over D-Bus between a user domain (`sysadm_t`) and
    service domain (`systemd_logind_t`) will check the following permissions:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: If these permissions are not granted, then D-Bus will not allow the communication
    to happen. If at any point, the application context cannot be obtained, then the
    bus daemon context will be used.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
- en: 'Failures will be logged as `USER_AVC` entries in the audit log. If the communication
    should be allowed, we can create a simple SELinux policy file to address this
    like so:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Store these rules in a file with the suffix `.cil` (say, `local_logind_systemd.cil`),
    and load it with `semodule`:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Let's consider a few other applications that have SELinux support, not necessarily
    built-in, but through the SELinux policy and PAM integration within the system.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
- en: Configuring PAM services
  id: totrans-191
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: systemd and D-Bus are SELinux-aware applications, with explicit SELinux support
    built in. Several other services exist on a Linux system that play nicely together
    with SELinux yet are not SELinux-aware themselves. Many of these services have
    an affinity with SELinux through their PAM integration.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
- en: We covered PAM integration in [*Chapter 3*](B16276_03_Final_VK.xhtml#_idTextAnchor071),
    *Managing User Logins*. In this section, we'll cover three example services using
    PAM, and how SELinux can be further fine-tuned to support these services.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
- en: Cockpit
  id: totrans-194
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Cockpit is a simple, browser-based management application that allows administrators
    to easily see system resources (monitoring) as well as to interact with the system.
    It also allows users to log into the system through the browser.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
- en: 'It is this browser-based terminal that we want to configure: by tuning the
    target SELinux roles for the SELinux users, we can selectively put users in a
    specific role. This effectively defines what the users can accomplish through
    this browser-based session.'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
- en: Installing Cockpit
  id: totrans-197
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The Cockpit application is readily available in the CentOS repository, so installing
    it is a breeze:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: While the application does not need additional configuration, if you do need
    tweaks, you will need to create the configuration file, `/etc/cockpit/cockpit.conf`,
    yourself as the application does not create a default configuration file. Within
    this configuration file, you can configure the TLS settings, or disable encrypted
    communication generally.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s disable the encrypted communication for this demonstration run (but
    if you intend to use Cockpit in production, you should not only keep encryption
    on but also ensure that only trusted hosts are connecting, possibly even requiring
    client certificate authentication using the `ClientCertAuthentication` directive):'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: With this set, we can continue with configuring SELinux for Cockpit.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
- en: Restricting user logins
  id: totrans-204
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Through these instructions, we will add the more restricted `user_r` role to
    the `staff_u` SELinux user, and then ensure that all logins mapped to the `staff_u`
    SELinux user are logged in using the `user_r` role when they log in through Cockpit.
    If they log in through other services, they will continue using the default `staff_r`
    role.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
- en: The use of the `user_r` role rather than the (even more restricted) `guest_r`
    role is to allow the Cockpit application to function properly. The application
    will run a service under the user's privileges, which are not sufficient for Cockpit
    if we use the `guest_t` user domain.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s first add the `user_r` role so that we can put the users in the correct
    context later:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Next, we want to update the SELinux configuration so that any Cockpit login
    by `staff_u` mapped users is going to use the `user_r` role. The Cockpit application
    has logins done through a service running in the `cockpit_session_t` context,
    which we find out by checking the context of the process first, and then logging
    in on Cockpit and checking the context of the processes again. There, we notice
    that a new process (`cockpit-session`) runs with the `cockpit_session_t` context:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'With this information now available, we can edit the `/etc/selinux/targeted/contexts/users/staff_u`
    file as follows:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: By adjusting the order of the roles listed for the `cockpit_session_t` context
    (or limiting them to only the `user_r` role), we ensure that users allowed to
    run with the `user_r` role (like the `staff_u` user we configured earlier on)
    do so through the `user_r` role. As this role is more restricted than the default
    `staff_t` user domain, logins through Cockpit are thus more isolated.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
- en: This approach can be used for all PAM-enabled services, as this solely relies
    on the `pam_selinux.so` call in the service PAM configuration. For some services,
    the SELinux policy administrators add in a few more tweaks to use, such as with
    cron and SSH, which we'll discuss next.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
- en: Cron
  id: totrans-216
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Cron services on a system allow you to run tasks or commands on predefined schedules.
    Some cron applications are explicitly made SELinux-aware (such as fcron), allowing
    them to compute the target context a job should run in. Even cron systems that
    do not have any specific SELinux logic built in can be fine-tuned.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
- en: Switching between user-specific and generic contexts
  id: totrans-218
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A common setup supported through the SELinux policy is to toggle whether user
    tasks run in the user's default context (such as `staff_t` for staff users) or
    in a default, restricted cron context (`cronjob_t`). Both approaches have their
    pros and cons.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
- en: When we configure the system to have user jobs run in the user's default context,
    then users know what the privileges are of their jobs. A guest user has guest
    privileges, a staff user has staff privileges, and so forth. This is the most
    common configuration, and the default cron system on CentOS uses the context of
    the file containing the user's tasks (located in `/var/spool/cron`) to deduce
    the target runtime context.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
- en: By running user jobs in a more restricted context such as `cronjob_t`, all users'
    cron jobs run with the same privileges, and the administrator can easily fine-tune
    the privileges for all user jobs. This also allows the administrator to grant
    specific privileges for cron jobs while keeping the user contexts free of these
    rights.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s have a simple task executed every minute, namely a 59-second sleep.
    As a regular user, create a file (let''s say `lisa.cron`) with the following content:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'This file uses the common cron syntax, where the following applies:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
- en: The first field covers the minute.
  id: totrans-225
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The second field covers the hour.
  id: totrans-226
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The third field covers the day of the month.
  id: totrans-227
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The fourth field covers the month.
  id: totrans-228
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The fifth field covers the day of the week.
  id: totrans-229
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The rest of the line is the command to execute.
  id: totrans-230
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The fields can use expressions to facilitate time definitions. For instance,
    to run every 15 minutes, you can use `*/15` in the first field. If you want to
    run only at 8 o'clock and 18 o'clock, you can use the `8,18` value in the second
    field. Another example is if you only want to run on workdays, for which you can
    use `1-5` in the fifth field (in cron, Sunday holds both 0 and 7 as valid values).
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
- en: 'By loading it with the `crontab` command, the file is checked for errors and,
    if error-free, is securely placed inside `/var/spool/cron` (the `crontab` command
    is a `setuid` command that is able to modify `/var/spool/cron` even though this
    location is inaccessible by regular users):'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'From here, the cron daemon will pick up this file, and 1 minute later we will
    see the command active in the background:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'As seen from the output, the command is running in the `staff_t` context. To
    change this to the `cronjob_t` type, rather than editing the SELinux context definition
    file as we did with the Cockpit application, use the `cron_userdomain_transition`
    SELinux boolean:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'This boolean changes the active SELinux policy behavior so that any user task
    executed from the cron system executes within the `cronjob_t` domain. You might
    need to reset the crontab definition (this depends on the cron system used), but
    afterward, we will see the job running in the `cronjob_t` domain:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: The use of SELinux booleans to allow administrators to differentiate system
    behavior as needed is commonly used. For the SSH daemon, SELinux policy administrators
    have defined something similar.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
- en: OpenSSH
  id: totrans-241
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The OpenSSH daemon is the most common secure shell daemon around. It allows
    users to remotely access systems through a terminal, as well as to securely transfer
    files, tunnel application communications, and more.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
- en: When logging in through SSH, the PAM controls apply, but the SELinux policy
    also has specific SSH controls embedded and controllable through SELinux booleans.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
- en: Directly logging in as sysadm_t
  id: totrans-244
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The first change to assess is to allow directly logging in using the `sysadm_r`
    role. Users mapped to the `staff_u` SELinux user by default log in using the (more
    restricted) `staff_r` role, and then need to explicitly switch roles to obtain
    the more privileged `sysadm_r` role.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
- en: 'The first change we need to make is to edit the `/etc/selinux/targeted/contexts/users/staff_u`
    file and adjust the order of the roles listed for the `sshd_t` context:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: However, this is not enough. The SELinux policy administrators have disabled
    direct logins through SSH to the `sysadm_r` role, forcing users to explicitly
    change roles (and thus reauthenticate). This approach is because SSH is often
    a publicly reachable and not otherwise easily controllable service (unlike services
    such as web servers, which can have reverse proxies and web application firewalls
    in front).
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
- en: 'Change the SELinux `ssh_sysadm_login` boolean to `true` to enable the wanted
    behavior:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: This boolean changes the SELinux policy behavior to allow logins to the `sysadm_r`
    role from the SSH daemon.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
- en: Chrooting Linux users
  id: totrans-252
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Another feature that SSH supports is forcing logins from selected users to be
    chrooted. A **chroot** (which is a portmanteau of **change root**) is an isolation
    method for processes, where the process no longer sees the entire filesystem but
    only a part of it.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
- en: Informational note
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
- en: Now, chroot environments are an easy way to isolate processes, but a chroot
    itself is still governed through Linux's discretionary access controls, and escaping
    chroot environments is not impossible. Using SELinux to further confine the process
    is recommended but is not in the scope of this section. For that, we refer to
    [*Chapter 14*](B16276_14_Final_VK.xhtml#_idTextAnchor354), *Dealing with New Applications*.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
- en: 'Before we configure SSH to chroot some users, we need to create a properly
    functioning environment: once we change the root for a process, all commands and
    libraries that the process wants to read or execute need to be available within
    this chroot environment.'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
- en: Let's first create a chroot environment. A nice utility that assists in creating
    the right folder structure and files is Jailkit. Jailkit is not available by default
    through the regular repositories but can be easily installed and only requires
    a working compiler and Python environment.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
- en: 'We start off by installing the necessary dependencies:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Next, we download the Jailkit source code and build it. As CentOS does not
    have a linked Python binary by default (as it requires the use of `python3` as
    the runtime), we need to tell the build scripts how to address Python. We do this
    by declaring the `PYTHONINTERPRETER` environment variable:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Once the installation is complete, you might need to remove a duplicate `includesections`
    call within the Jailkit configuration file (the `jk_init` command, which we will
    use next, will inform you about it if you don''t). The `openvpn` section in `/etc/jailkit/jk_init.ini`
    should look like this:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'With the configuration updated, we can now create the chroot environment. Let''s
    create the `/srv/chroot` directory and then populate it with the necessary files,
    directories, device nodes, and more with the `jk_init` command:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'We want to make sure that the SELinux contexts for the resources inside this
    location are equivalent to the root location, so let''s create a file context
    equivalency definition:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'With the chroot environment set, we can now update the SSH configuration to
    chroot a user:'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  id: totrans-269
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'While not applicable to all systems (as it depends on the distribution), we
    might need to tell the SELinux policy that the user domains for the users can
    chroot. This privilege (`sys_chroot`) is often not enabled by default for user
    domains:'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  id: totrans-271
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'With this set, restart the SSH daemon and see whether the chroot is successful:'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  id: totrans-273
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: Chroot environments are not only sensible for SSH access; other daemons might
    support chroot environments to further protect the resources on the system. In
    the past, chroot support was a common way to further harden the system. Namespace
    and resource isolation support has, however, largely surpassed the need for chroot
    jails. These new features have also jumpstarted the containerized ecosystem, which
    we will cover in [*Chapter 11*](B16276_11_Final_VK.xhtml#_idTextAnchor293), *Enhancing
    the Security of Containerized Workloads*.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
- en: The SELinux support for applications such as Cockpit, cron, and OpenSSH is generally
    provided through the SELinux policy and uses PAM integration to link SELinux controls
    within the application. It is, however, also possible to explicitly build in SELinux
    support in applications not intentionally SELinux-aware, but who support dynamic
    additions of logic through a modular design. As an example of this, we will look
    at Apache and the `mod_selinux` Apache module next.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
- en: Using mod_selinux with Apache
  id: totrans-276
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Applications are often web-based, exposing their interface as either a common
    website or a simple web service, and executing the bulk of logic either within
    the web server or in backend services that the web server interacts with for the
    user.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
- en: A web-based application has the huge advantage that end users often don't require
    any application or client to be installed on top of what is available by default
    on their device, be it a workstation, laptop, mobile, wristwatch, or smart TV.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
- en: However, unlike the services discussed earlier, Apache does not run individual
    user sessions through PAM logins on the system. Instead, user requests are handled
    by the web server threads and processes themselves, which makes easy SELinux-based
    controls a bit harder to accomplish.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
- en: Introducing mod_selinux
  id: totrans-280
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Apache has support for modules: dynamically loadable code that enhances the
    functionality of the web server, without having to rebuild the web server code
    itself. This modularity has given rise to the popularity of Apache, as we can
    see through its support for features such as PHP, introducing dynamic web applications
    to a server platform that was once meant to serve static content only.'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
- en: '`mod_selinux` uses the same modular support, which allows the Apache web server
    to become SELinux-aware. Once we enable `mod_selinux`, we can configure Apache
    to switch SELinux sensitivity or even SELinux domains for running code, further
    isolating the behavior of the web server and allowing SELinux policies to control
    what the web server can do. `mod_selinux` also supports user mappings, allowing
    the Apache web server to run specific user sessions in different domains.'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
- en: 'Before building the `mod_selinux` module, let''s first install the necessary
    dependencies on the system:'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  id: totrans-284
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'Once the dependencies are installed, we can download and build the `mod_selinux`
    code. The code is available on GitHub in Kaigai''s `mod_selinux` repository:'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  id: totrans-286
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'The `apxs` command is the `-c`) and installs (`-i`) the `mod_selinux` module.
    We have yet to activate it in the Apache configuration though, which we accomplish
    by creating a new module configuration file in `/etc/httpd/conf.modules.d` called
    `99-selinux.conf` (you can pick whatever name you want, but make sure it ends
    with the `.conf` suffix):'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  id: totrans-288
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: Now, while we have now installed the module, it is not ready for consumption
    yet, as we have not loaded the SELinux policy for it.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
- en: 'The `mod_selinux` repository contains the necessary SELinux policy code. However,
    it is not fully compatible with the more recent SELinux policy used by Linux distributions.
    We need to edit the `mod_selinux.if` file and remove all references to `httpd_user_script_ro_t`,
    `httpd_user_script_rw_t`, and `httpd_user_script_ra_t`, as those types are no
    longer present in current SELinux policies:'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  id: totrans-291
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'A second change – cosmetic for now – is to rename the calls from `miscfiles_read_certs`
    to `miscfiles_read_generic_certs`. These are functions used in the reference policy,
    a different – and still the most common way – of writing SELinux policies (which
    we cover in [*Chapter 15*](B16276_15_Final_VK.xhtml#_idTextAnchor373), *Using
    the Reference Policy*), and while both functions are supported at the time of
    writing, the `miscfiles_read_certs` function is no longer recommended for use
    and will disappear soon:'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  id: totrans-293
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'Once we have adjusted the policy, we can build and load it. As this policy
    is developed using the reference policy style, the installation first requires
    building the module before we load it (unlike the directly loadable CIL examples
    we''ve used so far):'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  id: totrans-295
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: With the SELinux module loaded and the `mod_selinux` Apache module installed,
    we can start configuring the Apache daemon with SELinux-specific controls.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
- en: Configuring the general Apache SELinux sensitivity
  id: totrans-297
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The simplest configuration setting that `mod_selinux` supports is to configure
    Apache to run with a specific SELinux sensitivity. Suppose we want Apache to run
    with the `s0-s0:c0.c100` sensitivity, then we need to adjust the Apache configuration
    and use the `selinuxServerDomain` directive.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
- en: 'Assuming we want to adjust the sensitivity for the default welcome site, edit
    `/etc/httpd/conf.d/welcome.conf` and add in the following code snippet:'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  id: totrans-300
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: If the Apache web server uses virtual host definitions (allowing a single web
    server definition to manage multiple websites, based on the hostname that the
    client is using to access the web content), the `selinuxDomainVal` directive needs
    to be used instead of the `selinuxServerDomain` one.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
- en: 'For instance, suppose the web server manages two virtual hosts, one for the
    `apps.genfic.local` domain, and the other for `intranet.genfic.local`, then we
    can assign each virtual host with its own sensitivity set like so:'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  id: totrans-303
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'Restart the Apache web server and validate that the setting is active:'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  id: totrans-305
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'As you can see, the web server is now running with the given sensitivity. An
    important caveat though: the `mod_selinux` code does not support `mcstransd`,
    the translation daemon we covered in [*Chapter 3*](B16276_03_Final_VK.xhtml#_idTextAnchor071),
    *Managing User Logins*, so you cannot use human-readable sensitivity definitions
    such as `SystemLow-SystemHigh`.'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
- en: Mapping end users to specific domains
  id: totrans-307
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To map users, when logged in to a web application, to a specific domain, we
    need to create a user mapping file. This mapping file is then referred to using
    the `selinuxDomainMap` directive in the web server configuration.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s first create the mapping file inside `/etc/httpd/conf.d`, naming it
    `mod_selinux.map`, with the following content:'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  id: totrans-310
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'This mapping file contains three mappings:'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
- en: The first one is for a user called `test` and is mapped to the `user_webapp_t`
    domain and `s0:c0.c100` sensitivity.
  id: totrans-312
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The second one is for any successfully authenticated user and is mapped to the
    `user_webapp_t` domain and `s0:c0,c1` sensitivity.
  id: totrans-313
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The third one is for unauthenticated users and is mapped to the `anon_webapp_t`
    domain.
  id: totrans-314
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We can then refer to this map by adjusting the previously created snippet like
    so:'
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  id: totrans-316
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: Restart the web server to apply the changes.
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
- en: Changing domains based on source
  id: totrans-318
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `mod_selinux` module also supports setting the server domain value based
    on environment variables that we have defined elsewhere in the configuration.
    For instance, we can first declare the value in an environment variable when a
    certain condition triggers, and then tell `mod_selinux` that this environment
    variable's value is to be used for the server domain setting.
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
- en: Let's make this a bit more tangible with an example. Suppose the website manages
    web applications for both local (internal) people, as well as for people that
    work from remote locations. Assuming these users enter the web server through
    different source IP addresses, we can use the source IP address to differentiate
    between the two and assign a different SELinux sensitivity value.
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
- en: We can do this in the Apache configuration with the `SetEnvIf` directive, which
    declares an environment variable but only if a request matches a particular condition.
    The condition we use is then the `Remote_Addr` directive, which checks the source
    IP address against the expression that follows.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
- en: 'Suppose local users come from `10.10.0.0/16` and remote users from a load balancer
    or reverse proxy with the IP address `10.121.12.15`, then we can differentiate
    this as follows:'
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  id: totrans-323
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: It is possible to mix and match multiple `mod_selinux` directives. The module
    will use the first successful declaration, so you could use a user mapping first,
    and if that user mapping does not result in a hit (because the user is not declared
    in the map), use the environment variable, and if that fails, fall back to a default
    setting.
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
- en: 'All we have to do to accomplish this fallback definition is to sequentially
    declare the `mod_selinux` directives, like so:'
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  id: totrans-326
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: Through these declarations, you can fine-tune the web server security using
    SELinux domains and sensitivities. While this should never replace the security
    approach within the application itself, it provides additional isolation in case
    an unauthorized or malicious user exploits an error within the application.
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-328
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we started out with an introduction to systemd and a strong
    focus on the service management capabilities that systemd offers. We learned how
    to start a service with a custom SELinux context as well as how additional files
    can be properly labeled upon boot. Alongside the service management, through systemd's
    unit files, this chapter also covered transient services and how to immediately
    associate the right SELinux context.
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
- en: Other systemd capabilities and services were touched upon as well. We saw how
    SELinux contexts are registered as part of the systemd journal and how to query
    for events using this context. We took a brief look at udev and how its rules
    can be used to support administrators in managing devices. One of its actions
    is to set the SELinux context of the device node.
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
- en: We then looked at D-Bus, how SELinux can be used to control the association
    of applications with services, and how D-Bus uses the `send_msg` permission to
    validate communications across its channels.
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
- en: After D-Bus, we looked at several services that use PAM to launch user contexts,
    and we dived into specific examples such as SSH, learning how SELinux policy developers
    have further fine-tuned support for these services.
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
- en: We finished with a look at `mod_selinux`, a dynamic module for Apache that enables
    SELinux support within Apache's configuration even though Apache itself does not
    have any SELinux specifics in it.
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will look at another SELinux-aware application, SEPostgreSQL,
    which extends the popular and robust PostgreSQL database with mandatory access
    control support through SELinux.
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  id: totrans-335
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Why should you not update unit files in `/usr/lib/systemd/system` directly?
  id: totrans-336
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What application allows resetting the SELinux context of files during boot?
  id: totrans-337
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How can we get all log events in journald associated with a given SELinux context?
  id: totrans-338
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How can you set the SELinux label for a device node created by udev?
  id: totrans-339
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Are SELinux controls always applicable to D-Bus associations?
  id: totrans-340
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How is it possible for Apache to be SELinux-aware without Apache having any
    SELinux code in it?
  id: totrans-341
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
