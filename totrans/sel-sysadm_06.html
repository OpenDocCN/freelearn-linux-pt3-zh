<html><head></head><body><div id="sbo-rt-content" class="calibre1"><div id="_idContainer022" class="calibre2">
			<h1 id="_idParaDest-136" class="calibre5"><em class="italic"><a id="_idTextAnchor138" class="pcalibre calibre6 pcalibre1"/>Chapter 5</em>: Controlling Network Communications</h1>
			<p class="calibre3">The SELinux mandatory access controls go much beyond its file and process access controls. One of the features provided by SELinux is its ability to control network communications. By default, general network access controls use the socket-based access control mechanism, but more detailed approaches are also possible.</p>
			<p class="calibre3">In this chapter, we will learn how network access controls are governed by SELinux, cover what administrators can do to further strengthen network communications using <strong class="source-inline">iptables</strong>, and describe how SELinux policies can be used for cross-system security through labeled IPsec. We'll finish the chapter with an introduction to CIPSO labeling and its integration with SELinux.</p>
			<p class="calibre3">We cover the following topics in this chapter:</p>
			<ul class="calibre8">
				<li class="calibre9">Controlling process communications</li>
				<li class="calibre9">Linux firewalling and SECMARK support</li>
				<li class="calibre9">Securing high-speed InfiniBand networks</li>
				<li class="calibre9">Understanding labeled networking</li>
				<li class="calibre9">Using labeled IPsec with SELinux</li>
				<li class="calibre9">Supporting CIPSO with NetLabel and SELinux</li>
			</ul>
			<h1 id="_idParaDest-137" class="calibre5"><a id="_idTextAnchor139" class="pcalibre calibre6 pcalibre1"/>Technical requirements</h1>
			<p class="calibre3">Not all sections in this chapter apply to all environments. For InfiniBand support, for instance, InfiniBand hardware is needed, whereas for NetLabel/CIPSO support, the network in its entirety needs to support the CIPSO (or CALIPSO in the case of IPv6) protocol for the hosts to be able to communicate with each other.</p>
			<p class="calibre3">Check out the following video to see the Code in Action: <a href="https://bit.ly/34bVDdm" class="pcalibre calibre6 pcalibre1">https://bit.ly/34bVDdm</a></p>
			<h1 id="_idParaDest-138" class="calibre5"><a id="_idTextAnchor140" class="pcalibre calibre6 pcalibre1"/>Controlling process communications</h1>
			<p class="calibre3">Linux <a id="_idIndexMarker310" class="pcalibre calibre6 pcalibre1"/>applications communicate with each other either directly or over a network. But the difference between direct communication and networked communication, from an application programmer's point of view, is not always that big. Let's <a id="_idIndexMarker311" class="pcalibre calibre6 pcalibre1"/>look at the various communication methods that Linux supports and how SELinux aligns with them.</p>
			<h2 id="_idParaDest-139" class="calibre10"><a id="_idTextAnchor141" class="pcalibre calibre6 pcalibre1"/>Using shared memory</h2>
			<p class="calibre3">The least <a id="_idIndexMarker312" class="pcalibre calibre6 pcalibre1"/>network-like method is the use of shared memory. Applications can share certain parts of the memory with each other and use those shared segments to communicate between two (or more) processes. To govern <a id="_idIndexMarker313" class="pcalibre calibre6 pcalibre1"/>access to the shared memory, application programmers can use <strong class="bold">mutual exclusions</strong> (<strong class="bold">mutexes</strong>) or <strong class="bold">semaphores</strong>. A semaphore is an atomically <a id="_idIndexMarker314" class="pcalibre calibre6 pcalibre1"/>incremented or decremented integer (ensuring that two applications do not overwrite each other's values without knowing about the value change), whereas a mutex can be interpreted as a special semaphore that only takes the values 0 or 1.</p>
			<p class="calibre3">On Linux, two implementations exist for shared memory access and control: SysV-style and POSIX-style. We will not dwell on the advantages and disadvantages of each, but rather look at how SELinux governs access to these implementations.</p>
			<p class="calibre3">SELinux controls the SysV-style primitives through specific classes: <strong class="source-inline">sem</strong> for semaphores and <strong class="source-inline">shm</strong> for shared memory. The semaphores, mutexes, and shared memory segments inherit the context of the first process that creates them.</p>
			<p class="calibre3">Administrators who want to control the SysV-style primitives can use the various <strong class="source-inline">ipc*</strong> commands: <strong class="source-inline">ipcs</strong> (to list), <strong class="source-inline">ipcrm</strong> (to remove), and <strong class="source-inline">ipcmk</strong> (to create).</p>
			<p class="calibre3">For instance, let's first list the resources and then remove the listed shared memory:</p>
			<p class="source-code"># ipcs</p>
			<p class="source-code">...</p>
			<p class="source-code">------ Shared Memory Segments ------</p>
			<p class="source-code">key		shmid	owner		perms	bytes	nattch	status</p>
			<p class="source-code">0x0052e2c1	0	postgres	600	56	6</p>
			<p class="source-code"># ipcrm -m 0</p>
			<p class="calibre3">When POSIX-style semaphores, mutexes, and shared memory segments are used, SELinux controls those operations through the file-based access controls. The POSIX-style approach uses regular files in <strong class="source-inline">/dev/shm</strong>, which is simpler for administrators to control and manage.</p>
			<h2 id="_idParaDest-140" class="calibre10"><a id="_idTextAnchor142" class="pcalibre calibre6 pcalibre1"/>Communicating locally through pipes</h2>
			<p class="calibre3">A second <a id="_idIndexMarker315" class="pcalibre calibre6 pcalibre1"/>large family of communication methods in operating systems is the use of pipes. As the name implies, pipes are generally one-way communication tunnels, with information flowing from one (or more) senders to one receiver (there are exceptions to this, such as Solaris pipes, which act as bidirectional channels, but <a id="_idIndexMarker316" class="pcalibre calibre6 pcalibre1"/>those are not supported on Linux). Another name for a pipe is <strong class="bold">first-in, first-out</strong> (<strong class="bold">FIFO</strong>).</p>
			<p class="calibre3">We have two <a id="_idIndexMarker317" class="pcalibre calibre6 pcalibre1"/>types of pipes in Linux: <strong class="bold">anonymous pipes</strong> (also known as <strong class="bold">unnamed pipes</strong>) and <strong class="bold">named pipes</strong>. The <a id="_idIndexMarker318" class="pcalibre calibre6 pcalibre1"/>difference is that a named pipe uses a file in the <a id="_idIndexMarker319" class="pcalibre calibre6 pcalibre1"/>regular filesystem as its identification, whereas anonymous pipes are constructed through the applications with no representation in the regular filesystem.</p>
			<p class="calibre3">In both <a id="_idIndexMarker320" class="pcalibre calibre6 pcalibre1"/>cases, SELinux will see the pipes as files of the <strong class="source-inline">fifo_file</strong> class. Named pipes will have their path associated with the regular filesystem and are created using the <strong class="source-inline">mknod</strong> or <strong class="source-inline">mkfifo</strong> commands (or through the <strong class="source-inline">mkfifo()</strong> function when handled within applications). Anonymous pipes, however, will be shown as part of the <strong class="source-inline">pipefs</strong> filesystem. This is a pseudo filesystem, not accessible to users, but still represented as <a id="_idIndexMarker321" class="pcalibre calibre6 pcalibre1"/> a filesystem through Linux's <strong class="bold">virtual file system</strong> (<strong class="bold">VFS</strong>) abstraction.</p>
			<p class="calibre3">From an SELinux policy point of view, the FIFO file is the target for which the access controls apply: two domains that both have the correct set of privileges toward the context of the FIFO file will be able to communicate with each other.</p>
			<p class="calibre3">Administrators can find out which process is communicating over FIFOs with other processes through tools such as <strong class="source-inline">lsof</strong>, or by querying the <strong class="source-inline">/proc</strong> filesystem (as part of the <strong class="source-inline">/proc/&lt;pid&gt;/fd</strong> listings). The <strong class="source-inline">lsof</strong> tool supports the <strong class="source-inline">-Z</strong> option to show the SELinux context of the process, and even supports wildcards:</p>
			<p class="source-code"># lsof -Z *:postfix_*</p>
			<p class="calibre3">In this example, <strong class="source-inline">lsof</strong> displays information about all processes that use a <strong class="source-inline">postfix_*</strong> label.</p>
			<h2 id="_idParaDest-141" class="calibre10"><a id="_idTextAnchor143" class="pcalibre calibre6 pcalibre1"/>Conversing over UNIX domain sockets</h2>
			<p class="calibre3">With <a id="_idIndexMarker322" class="pcalibre calibre6 pcalibre1"/>pipes supporting one-way communication only, any conversation between two processes would require two pipes. Also, true client/server-like communication with pipes is challenging to implement. To accomplish the more advanced communication flows, processes will use sockets.</p>
			<p class="calibre3">Most administrators are aware that TCP and UDP communication occurs over sockets. Applications can bind to a socket and listen for incoming communications or use the socket to connect to other, remote services. But even on a single Linux system, sockets can be used to facilitate the communication flows. There are two socket types that can be used for process communication: UNIX <a id="_idIndexMarker323" class="pcalibre calibre6 pcalibre1"/>domain sockets and netlink sockets. <strong class="bold">Netlink sockets</strong> are specific to the Linux operating system and are quite low-level, resembling the <strong class="source-inline">ioctl()</strong> system call usage. <strong class="bold">UNIX domain sockets</strong>, on the other hand, are higher-<a id="_idIndexMarker324" class="pcalibre calibre6 pcalibre1"/>level and more directly accessible by administrators, which is why we explain them here in more detail.</p>
			<p class="calibre3">We can distinguish between two UNIX domain socket definitions, as with pipes: unnamed sockets <a id="_idIndexMarker325" class="pcalibre calibre6 pcalibre1"/>and named sockets. And like pipes, the distinction is in the path used to identify a socket. Named sockets are created on the regular filesystem, while unnamed sockets are part of the <strong class="source-inline">sockfs</strong> pseudo filesystem. Similarly, sockets can be queried through utilities such as <strong class="source-inline">lsof</strong> or through the <strong class="source-inline">/proc/&lt;pid&gt;/fd</strong> listings.</p>
			<p class="calibre3">There is another distinction regarding UNIX domain sockets though, namely, the communication <a id="_idIndexMarker326" class="pcalibre calibre6 pcalibre1"/>format that the UNIX domain socket allows. UNIX domain sockets can be created as <strong class="bold">datagram sockets</strong> (data sent to the socket retains its chunk size <a id="_idIndexMarker327" class="pcalibre calibre6 pcalibre1"/>and format) or <strong class="bold">streaming sockets</strong> (data sent to the socket can be read in different-sized chunks). This has some repercussions for the SELinux policy rules.</p>
			<p class="calibre3">For SELinux, communicating over UNIX domain sockets requires both domains to have the proper communication privileges toward the socket file type (<strong class="source-inline">open</strong>, <strong class="source-inline">read</strong>, and <strong class="source-inline">write</strong>), depending on the direction of the communication.</p>
			<p class="calibre3">Additionally, the sending (client) domain requires additional privileges toward the receiving (server) domain:</p>
			<ul class="calibre8">
				<li class="calibre9">The <strong class="source-inline">connectto</strong> privilege in the <strong class="source-inline">unix_stream_socket</strong> class in the case of stream sockets</li>
				<li class="calibre9">The <strong class="source-inline">sendto</strong> privilege in the <strong class="source-inline">unix_dgram_socket</strong> class in the case of datagram sockets</li>
			</ul>
			<p class="calibre3">As you can see, the privileges depend on the communication type used across the socket.</p>
			<h2 id="_idParaDest-142" class="calibre10"><a id="_idTextAnchor144" class="pcalibre calibre6 pcalibre1"/>Understanding netlink sockets</h2>
			<p class="calibre3">Another socket <a id="_idIndexMarker328" class="pcalibre calibre6 pcalibre1"/>type that can be used for process communication is netlink. <strong class="bold">Netlink sockets</strong> are sockets that allow user space applications to <a id="_idIndexMarker329" class="pcalibre calibre6 pcalibre1"/>communicate and interact with kernel processes, and, in special cases (where network management is delegated to a user space process by the Linux kernel), also communicate with another user space application. Unlike the regular UNIX domain sockets, whose target context associates with the owner of that socket, netlink sockets are always local to the SELinux context.</p>
			<p class="calibre3">Put differently, when a domain such as <strong class="source-inline">sysadm_t</strong> wants to manipulate the kernel's routing information, it will open and communicate with the kernel through a netlink route socket, identified through the <strong class="source-inline">netlink_route_socket</strong> class:</p>
			<p class="source-code">$ sesearch -s sysadm_t -t sysadm_t -c netlink_route_socket -A</p>
			<p class="source-code">allow sysadm_t domain:netlink_route_socket getattr;</p>
			<p class="source-code">allow sysadm_t sysadm_t:netlink_route_socket { append bind ... };</p>
			<p class="calibre3">As applications gain more features, it might be that some of these features are no longer allowed by the current SELinux policy. Administrators will then need to update the SELinux policy to <a id="_idIndexMarker330" class="pcalibre calibre6 pcalibre1"/>allow the netlink communication.</p>
			<p class="calibre3">An overview of supported netlink sockets can be devised from the netlink information on the manual page (<strong class="source-inline">man netlink</strong>), from which the SELinux classes can easily be derived. For instance, the <strong class="source-inline">NETLINK_XFRM</strong> socket is supported through the SELinux <strong class="source-inline">netlink_xfrm_socket</strong> class.</p>
			<h2 id="_idParaDest-143" class="calibre10"><a id="_idTextAnchor145" class="pcalibre calibre6 pcalibre1"/>Dealing with TCP, UDP, and SCTP sockets</h2>
			<p class="calibre3">When we <a id="_idIndexMarker331" class="pcalibre calibre6 pcalibre1"/>go further up the chain, we look at <a id="_idIndexMarker332" class="pcalibre calibre6 pcalibre1"/>socket communication <a id="_idIndexMarker333" class="pcalibre calibre6 pcalibre1"/>over the network. In this case, rather than communicating directly between processes (and thus in Linux terminology between SELinux domains), the flows are from, and to, TCP, UDP, and <strong class="bold">Stream Control Transmission Protocol</strong> (<strong class="bold">SCTP</strong>) sockets.</p>
			<p class="calibre3">SELinux will <a id="_idIndexMarker334" class="pcalibre calibre6 pcalibre1"/>assign types to these ports as well, and these types are then the types to use for socket communication. For SELinux, a client application connecting to the DNS port (TCP port <strong class="source-inline">53</strong>, which receives the <strong class="source-inline">dns_port_t</strong> type in most SELinux policies) uses the <strong class="source-inline">name_connect</strong> permission within the <strong class="source-inline">tcp_socket</strong> class toward the port type. The SCTP protocol (with the <strong class="source-inline">sctp_socket</strong> class) uses the same permission. For UDP services (and thus the <strong class="source-inline">udp_socket</strong> class), <strong class="source-inline">name_connect</strong> is not used. Daemon applications use the <strong class="source-inline">name_bind</strong> privileges to bind themselves to their associated port.</p>
			<p class="callout-heading">Important note</p>
			<p class="callout">Support for SCTP has only been recently introduced in SELinux, and not all Linux distributions have updated their policies accordingly. To see whether SCTP support is active, check the value of the <strong class="source-inline">/sys/fs/selinux/policy_capabilities/extended_socket_class</strong> file. A value of <strong class="source-inline">1</strong> means that the policy has SCTP support included, whereas a value of <strong class="source-inline">0</strong> (or an absent file) means that the system does not yet support SCTP.</p>
			<p class="calibre3">Administrators can fine-tune which label to assign to which TCP, UDP, or SCTP port. For this, the <strong class="source-inline">semanage port</strong> command can be used. For instance, to list the current port definitions, you'd use this command:</p>
			<p class="source-code"># semanage port -l</p>
			<p class="source-code">SELinux Port Type	Proto	Port Number</p>
			<p class="source-code">afs3_callback_port_t	tcp	7001</p>
			<p class="source-code">...</p>
			<p class="source-code">http_port_t		tcp	80, 81, 443, 488, 8008, 8009, ...</p>
			<p class="calibre3">In this example, we see that the <strong class="source-inline">http_port_t</strong> label is assigned to a set of TCP ports. Web server domains that can bind to <strong class="source-inline">http_port_t</strong> are, as such, allowed to bind to any of the mentioned ports.</p>
			<p class="calibre3">To allow a <a id="_idIndexMarker335" class="pcalibre calibre6 pcalibre1"/>daemon, such as an SSH server, to <a id="_idIndexMarker336" class="pcalibre calibre6 pcalibre1"/>bind to other (or additional) ports, we need to tell SELinux to map this port to the appropriate label. For instance, to <a id="_idIndexMarker337" class="pcalibre calibre6 pcalibre1"/>allow the SSH server to bind to port <strong class="source-inline">10122</strong>, we first check whether this port already holds a dedicated label. This can be accomplished using the <strong class="source-inline">sepolicy</strong> command:</p>
			<p class="source-code">$ sepolicy network -p 10122</p>
			<p class="source-code">10122: udp unreserved_port_t 1024-32767</p>
			<p class="source-code">10122: tcp unreserved_port_t 1024-32767</p>
			<p class="source-code">10122: sctp unreserved_port_t 1024-32767</p>
			<p class="calibre3">The <strong class="source-inline">unreserved_port_t</strong> label is not a dedicated one, so we can assign the <strong class="source-inline">ssh_port_t</strong> label to it:</p>
			<p class="source-code"># semanage port -a -t ssh_port_t -p tcp 10122</p>
			<p class="calibre3">Removing a port definition works similarly:</p>
			<p class="source-code"># semanage port -d -t ssh_port_t -p tcp 10122</p>
			<p class="calibre3">When a specific port type is already assigned, then the utility will give the following error:</p>
			<p class="source-code"># semanage port -a -t ssh_port_t -p tcp 80</p>
			<p class="source-code">ValueError: Port tcp/80 already defined</p>
			<p class="calibre3">If this is the case and another port cannot be used, then no option exists other than to modify the SELinux policy.</p>
			<h2 id="_idParaDest-144" class="calibre10"><a id="_idTextAnchor146" class="pcalibre calibre6 pcalibre1"/>Listing connection contexts</h2>
			<p class="calibre3">Many of <a id="_idIndexMarker338" class="pcalibre calibre6 pcalibre1"/>the tools in an administrator's arsenal can display security context information. As with the core utilities, most of these tools use the <strong class="source-inline">-Z</strong> option for this. For instance, to list the running network-bound services, netstat can be used:</p>
			<p class="source-code"># netstat -naptZ | grep ':80'</p>
			<p class="source-code">tcp  0  0 0.0.0.0:80  0.0.0.0:* LISTEN 17655/nginx: master system_u:system_r:httpd_t:s0</p>
			<p class="calibre3">Even <strong class="source-inline">lsof</strong> displays the context when asked to:</p>
			<p class="source-code"># lsof -i :80 -Z</p>
			<p class="source-code">COMMAND PID   SECURITY-CONTEXT             USER FD TYPE DEVICE SIZE/OFF NODE NAME</p>
			<p class="source-code">nginx   17655 system_u:system_r:httpd_t:s0 root 8u IPv4 31230  0t0      *:http (LISTEN)</p>
			<p class="calibre3">Another <a id="_idIndexMarker339" class="pcalibre calibre6 pcalibre1"/>advanced command for querying connections is the <strong class="source-inline">ss</strong> command. Just calling <strong class="source-inline">ss</strong> will display all the connections of the current system. When adding <strong class="source-inline">-Z</strong>, it adds the context information as well.</p>
			<p class="calibre3">For instance, the following command queries for listening TCP services:</p>
			<p class="source-code"># ss -ltnZ</p>
			<p class="calibre3">More advanced queries can be called as well — consult the <strong class="source-inline">ss</strong> manual page for more information.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">The use of the <strong class="source-inline">-Z</strong> option to show SELinux context information or consider SELinux context information in the activity that is requested by the user is a general but not mandatory practice amongst application developers. It is recommended to check the manual page of the application to confirm whether, and how, SELinux is supported by a tool. For instance, to get the <strong class="source-inline">ss</strong> manual page, run <strong class="source-inline">man ss</strong>.</p>
			<p class="calibre3">All these interactions are still quite primitive in nature, with the last set (which focuses on sockets) being more network-related than the others. Once we look into interaction between systems, we might not have enough control through just the sockets though. To enable more fine-grained control, we'll look at firewall capabilities and their SECMARK support next.</p>
			<h1 id="_idParaDest-145" class="calibre5"><a id="_idTextAnchor147" class="pcalibre calibre6 pcalibre1"/>Linux firewalling and SECMARK support</h1>
			<p class="calibre3">The approach <a id="_idIndexMarker340" class="pcalibre calibre6 pcalibre1"/>with TCP, UDP, and SCTP ports has a few downsides. One of <a id="_idIndexMarker341" class="pcalibre calibre6 pcalibre1"/>them is that SELinux has no knowledge of the target host, so cannot reason about its security properties. This method also offers no way of limiting daemons from binding on any interface: in a multi-homed situation, we might want to make sure that a daemon only binds on the interface facing the internal network and not the internet-facing one, or vice versa.</p>
			<p class="calibre3">In the past, SELinux allowed <a id="_idIndexMarker342" class="pcalibre calibre6 pcalibre1"/>support for this binding issue through the <strong class="bold">interface</strong> and <strong class="bold">node</strong> labels: a domain <a id="_idIndexMarker343" class="pcalibre calibre6 pcalibre1"/>could be configured to only bind to one interface and not to any other, or even on a specific address (referred to as the node). This <a id="_idIndexMarker344" class="pcalibre calibre6 pcalibre1"/>support had its flaws though, and has been largely deprecated in favor of SECMARK filtering.</p>
			<p class="calibre3">Before <a id="_idIndexMarker345" class="pcalibre calibre6 pcalibre1"/>explaining SECMARK and how administrators can control it, let's first take a quick look at Linux's netfilter subsystem, the de facto standard for local firewall capabilities on Linux systems.</p>
			<h2 id="_idParaDest-146" class="calibre10"><a id="_idTextAnchor148" class="pcalibre calibre6 pcalibre1"/>Introducing netfilter</h2>
			<p class="calibre3">Like LSM, the Linux netfilter <a id="_idIndexMarker346" class="pcalibre calibre6 pcalibre1"/>subsystem provides hooks in various stages of its networking stack processing framework, which can then be implemented by one or more modules. For instance, <strong class="source-inline">ip_tables</strong> (which uses the <strong class="source-inline">iptables</strong> command as its control application) is one of those modules, while <strong class="source-inline">ip6_tables</strong> and <strong class="source-inline">ebtables</strong> are other examples of netfilter modules. Modules implementing a netfilter hook must inform the netfilter framework of that hook's priority. This enables controllable ordering in the execution of modules (as multiple calls for the same hook can and will be used together).</p>
			<p class="calibre3">The <strong class="source-inline">ip_tables</strong> framework is the one we will be looking at in more detail because it supports the SECMARK approach. This framework is commonly referred to as just <strong class="source-inline">iptables</strong>, which is the name of its control application. We will be using this term for the remainder of this book.</p>
			<p class="calibre3"><strong class="source-inline">iptables</strong> offers several <em class="italic">tables</em>, functionally-oriented classifications for network processing. The common ones are as follows:</p>
			<ul class="calibre8">
				<li class="calibre9">The <strong class="source-inline">filter</strong> table enables the standard network-filtering capabilities.</li>
				<li class="calibre9">The <strong class="source-inline">nat</strong> table is intended to modify routing-related information from packets, such as the source and/or destination address.</li>
				<li class="calibre9">The <strong class="source-inline">mangle</strong> table is used to modify most of a packet's fields.</li>
				<li class="calibre9">The <strong class="source-inline">raw</strong> table is enabled when administrators want to opt out certain packets/flows from the connection-tracking capabilities of netfilter.</li>
				<li class="calibre9">The <strong class="source-inline">security</strong> table is offered to allow administrators to label packets once regular processing is complete.</li>
			</ul>
			<p class="calibre3">Within each table, <strong class="source-inline">iptables</strong> offers a default set of chains. These default chains specify where in the processing flow (and thus which hook in the netfilter framework) rules are to be processed. Each chain has a default policy – the default return value if none of the rules in a chain match. Within the chain, administrators can add several rules to process sequentially. When a rule matches, the configured action applies. This action can be to allow the packet to flow through this hook in the netfilter framework, be denied, or perform additional processing.</p>
			<p class="calibre3">Commonly <a id="_idIndexMarker347" class="pcalibre calibre6 pcalibre1"/>provided chains (not all chains are offered for all tables) include the following:</p>
			<ul class="calibre8">
				<li class="calibre9">The <strong class="source-inline">PREROUTING</strong> chain, which is the first packet-processing step once a packet is received</li>
				<li class="calibre9">The <strong class="source-inline">INPUT</strong> chain, which is for processing packets meant for the local system</li>
				<li class="calibre9">The <strong class="source-inline">FORWARD</strong> chain, which is for processing packets meant to be forwarded to another remote system</li>
				<li class="calibre9">The <strong class="source-inline">OUTPUT</strong> chain, which is for processing packets originating from the local system</li>
				<li class="calibre9">The <strong class="source-inline">POSTROUTING</strong> chain, which is the last packet-processing step before a packet is sent</li>
			</ul>
			<p class="calibre3">Overly simplified, the implementation of these tables and their chains roughly associates with the priority of the calls within the netfilter framework. The chains are easily associated with the hooks provided by the netfilter framework, whereas the table tells netfilter which chain implementations are to be executed first.</p>
			<h2 id="_idParaDest-147" class="calibre10"><a id="_idTextAnchor149" class="pcalibre calibre6 pcalibre1"/>Implementing security markings</h2>
			<p class="calibre3">With packet labeling, we can use the filtering capabilities of <strong class="source-inline">iptables</strong> (and <strong class="source-inline">ip6tables</strong>) to assign labels <a id="_idIndexMarker348" class="pcalibre calibre6 pcalibre1"/>to packets and connections. The idea is that the local firewall tags packets and connections and then the kernel uses SELinux to grant (or deny) application domains the right to use those tagged packets and connections.</p>
			<p class="calibre3">This packet <a id="_idIndexMarker349" class="pcalibre calibre6 pcalibre1"/>labeling is known as <strong class="bold">SECurity MARKings</strong> (<strong class="bold">SECMARK</strong>). Although we use the term SECMARK, the framework consists of two <a id="_idIndexMarker350" class="pcalibre calibre6 pcalibre1"/>markings: one for packets (SECMARK) and one for connections, that is, <strong class="bold">CONNection MARKings</strong> (<strong class="bold">CONNMARK</strong>). The SECMARK capabilities are offered through two tables, <strong class="source-inline">mangle</strong> and <strong class="source-inline">security</strong>. Only these tables currently have the action of tagging packets and connections available in their rule set:</p>
			<ul class="calibre8">
				<li class="calibre9">The <strong class="source-inline">mangle</strong> table has a higher execution priority than most other tables. Implementing SECMARK rules on this level is generally done when all packets need to be labeled, even when many of these packets will eventually be dropped.</li>
				<li class="calibre9">The <strong class="source-inline">security</strong> table is next in execution priority after the <strong class="source-inline">filter</strong> table. This allows the regular firewall rules to be executed first, and only tag those packets allowed by the regular firewall. Using the <strong class="source-inline">security</strong> table allows the <strong class="source-inline">filter</strong> table to implement the discretionary access control rules first and have SELinux execute its mandatory access control logic only if the DAC rules are executed successfully.</li>
			</ul>
			<p class="calibre3">Once a SECMARK <a id="_idIndexMarker351" class="pcalibre calibre6 pcalibre1"/>action triggers, it will assign a packet type to the packet or communication. SELinux policy rules will then validate whether a domain is allowed to receive (<strong class="source-inline">recv</strong>) or send packets of a given type. For instance, the Firefox application (running in the <strong class="source-inline">mozilla_t</strong> domain) will be allowed to send and receive HTTP client packets:</p>
			<p class="source-code">allow mozilla_t http_client_packet_t : packet { send recv };</p>
			<p class="calibre3">Another supported permission set for SECMARK-related packets is <strong class="source-inline">forward_in</strong> and <strong class="source-inline">forward_out</strong>. These permissions are checked when using forwarding in netfilter.</p>
			<p class="calibre3">One important thing to be aware of is that once a SECMARK action is defined, then all the packets that eventually reach the operating system's applications will have a label associated with them — even if no SECMARK rule exists for the packet or connection that the kernel is inspecting. If that occurs, then the kernel applies the default <strong class="source-inline">unlabeled_t</strong> label. The default SELinux policy implemented in some distributions (such as CentOS) allows all domains to send and receive <strong class="source-inline">unlabeled_t</strong> packets, but this is not true for all Linux distributions.</p>
			<h2 id="_idParaDest-148" class="calibre10"><a id="_idTextAnchor150" class="pcalibre calibre6 pcalibre1"/>Assigning labels to packets</h2>
			<p class="calibre3">When no <a id="_idIndexMarker352" class="pcalibre calibre6 pcalibre1"/>SECMARK-related rules are loaded in the netfilter subsystem, then SECMARK is not enabled and none of the SELinux rules related to SECMARK permissions are checked. The network packets are not labeled, so no enforcement can be applied to them. Of course, the regular socket-related access controls still apply — SECMARK is just an additional control measure.</p>
			<p class="calibre3">Once a single SECMARK rule is active, SELinux starts enforcing the packet-label mechanism on all packets. This means that all the network packets now need a label on them (as SELinux can only deal with labeled resources). The default label (the initial security context) for packets is <strong class="source-inline">unlabeled_t</strong>, which means that no marking rule matches this network packet.</p>
			<p class="calibre3">Because SECMARK rules are now enforced, SELinux checks all domains that interact with network packets to see whether they are authorized to send or receive these packets. To simplify management, some distributions enable send and receive rights against the <strong class="source-inline">unlabeled_t</strong> packets for all domains. Without these rules, all network services would stop functioning properly the moment a single SECMARK rule becomes active.</p>
			<p class="calibre3">To assign a label to a packet, we need to define a set of rules that match a particular network flow, and then call the SECMARK logic (to tag the packet or communication with a label). Most rules will immediately match the <strong class="source-inline">ACCEPT</strong> target as well, to allow this particular communication to reach the system.</p>
			<p class="calibre3">Let's <a id="_idIndexMarker353" class="pcalibre calibre6 pcalibre1"/>implement two rules: </p>
			<ul class="calibre8">
				<li class="calibre9">The first is to allow communication toward websites (port <strong class="source-inline">80</strong>) and tag the related network packets with the <strong class="source-inline">http_client_packet_t</strong> type (so that web browsers are allowed to send and receive these packets).</li>
				<li class="calibre9">The second is to allow communication toward the locally running web server (port <strong class="source-inline">80</strong> as well) and tag its related network packets with the <strong class="source-inline">http_server_packet_t</strong> type (so that web servers are allowed to send and receive these packets). </li>
			</ul>
			<p class="calibre3">For each rule set, we also enable connection tracking so that related packets are automatically labeled correctly and passed.</p>
			<p class="calibre3">Use the following commands for the web server traffic:</p>
			<p class="source-code"># iptables -t filter -A INPUT -m conntrack --ctstate </p>
			<p class="source-code">ESTABLISHED,RELATED -j ACCEPT</p>
			<p class="source-code"># iptables -t filter -A INPUT -p tcp -d 192.168.100.15 --dport </p>
			<p class="source-code">80 -j ACCEPT</p>
			<p class="source-code"># iptables -t security -A INPUT -p tcp --dport 80 -j SECMARK </p>
			<p class="source-code">--selctx "system_u:object_r:http_server_packet_t:s0"</p>
			<p class="source-code"># iptables -t security -A INPUT -p tcp --dport 80 -j </p>
			<p class="source-code">CONNSECMARK --save</p>
			<p class="calibre3">Use these commands for the browser traffic:</p>
			<p class="source-code"># iptables -t filter -A OUTPUT -m conntrack --ctstate </p>
			<p class="source-code">ESTABLISHED -j ACCEPT</p>
			<p class="source-code"># iptables -t filter -A OUTPUT -p tcp --dport 80 -j ACCEPT</p>
			<p class="source-code"># iptables -t security -A OUTPUT -p tcp --dport 80 -j SECMARK </p>
			<p class="source-code">--selctx "system_u:object_r:http_client_packet_t:s0"</p>
			<p class="source-code"># iptables -t security -A OUTPUT -p tcp --dport 80 -j </p>
			<p class="source-code">CONNSECMARK --save</p>
			<p class="calibre3">Finally, to copy connection labels to the established and related packets, use the following commands:</p>
			<p class="source-code"># iptables -t security -A INPUT -m state --state </p>
			<p class="source-code">ESTABLISHED,RELATED -j CONNSECMARK --restore</p>
			<p class="source-code"># iptables -t security -A OUTPUT -m state --state </p>
			<p class="source-code">ESTABLISHED,RELATED -j CONNSECMARK --restore</p>
			<p class="calibre3">Even this simple example shows that firewall rule definitions are an art by themselves, and that the SECMARK labeling is just a small part of it. However, using the SECMARK rules makes it <a id="_idIndexMarker354" class="pcalibre calibre6 pcalibre1"/>possible to allow certain traffic while still ensuring that only well-defined domains can interact with that traffic. For instance, it can be implemented on kiosk systems to only allow one browser to communicate with the internet while all other browsers and commands aren't. Tag all browsing-related traffic with a specific label, and only allow that browser domain the <strong class="source-inline">send</strong> and <strong class="source-inline">recv</strong> permissions on that label.</p>
			<h2 id="_idParaDest-149" class="calibre10"><a id="_idTextAnchor151" class="pcalibre calibre6 pcalibre1"/>Transitioning to nftables</h2>
			<p class="calibre3">While <strong class="source-inline">iptables</strong> is still <a id="_idIndexMarker355" class="pcalibre calibre6 pcalibre1"/>one of the most widely used firewall technologies on Linux, two other contenders (<strong class="source-inline">nftables</strong> and <strong class="source-inline">bpfilter</strong>) are rising rapidly in terms of popularity. The first of these, <strong class="source-inline">nftables</strong>, has a few operational benefits over <strong class="source-inline">iptables</strong>, while retaining focus on the netfilter support in the Linux kernel:</p>
			<ul class="calibre8">
				<li class="calibre9">The code base for <strong class="source-inline">nftables</strong> and its Linux kernel support is much more streamlined.</li>
				<li class="calibre9">Error reporting is much better.</li>
				<li class="calibre9">Filtering rules can be incrementally changed rather than requiring a full reload of all rules.</li>
			</ul>
			<p class="calibre3">The <strong class="source-inline">nftables</strong> framework has recently received support for SECMARK, so let's see how to apply the <strong class="source-inline">http_server_packet_t</strong> and <strong class="source-inline">http_client_packet_t</strong> labels to the appropriate traffic.</p>
			<p class="calibre3">The most common approach for applying somewhat larger <strong class="source-inline">nftables</strong> rules is to use a configuration file with the <strong class="source-inline">nft</strong> interpreter set:</p>
			<p class="source-code">#!/usr/sbin/nft -f</p>
			<p class="source-code">flush ruleset</p>
			<p class="source-code">table inet filter {</p>
			<p class="source-code">  secmark http_server {</p>
			<p class="source-code">    "system_u:object_r:http_server_packet_t:s0"</p>
			<p class="source-code">  }</p>
			<p class="source-code">  secmark http_client {</p>
			<p class="source-code">    "system_u:object_r:http_client_packet_t:s0"</p>
			<p class="source-code">  }</p>
			<p class="source-code">  map secmapping_in {</p>
			<p class="source-code">    type inet_service : secmark</p>
			<p class="source-code">    elements = { 80 : "http_server" }</p>
			<p class="source-code">  }</p>
			<p class="source-code">  map secmapping_out {</p>
			<p class="source-code">    type inet_service : secmark</p>
			<p class="source-code">    elements = { 80 : "http_client" }</p>
			<p class="source-code">  }</p>
			<p class="source-code">  chain input {</p>
			<p class="source-code">    type filter hook input priority 0;</p>
			<p class="source-code">    ct state new meta secmark set tcp dport map @secmapping_in</p>
			<p class="source-code">    ct state new ct secmark set meta secmark</p>
			<p class="source-code">    ct state established,related meta secmark set ct secmark</p>
			<p class="source-code">  }</p>
			<p class="source-code">  chain output {</p>
			<p class="source-code">    type filter hook output priority 0;</p>
			<p class="source-code">    ct state new meta secmark set tcp dport map @secmapping_out</p>
			<p class="source-code">    ct state new ct secmark set meta secmark</p>
			<p class="source-code">    ct state established,related meta secmark set ct secmark</p>
			<p class="source-code">  }</p>
			<p class="source-code">}</p>
			<p class="calibre3">The syntax that <strong class="source-inline">nftables</strong> uses is recognizable when we compare it with <strong class="source-inline">iptables</strong>. The script starts with <a id="_idIndexMarker356" class="pcalibre calibre6 pcalibre1"/>defining the SECMARK values. After that, we create a mapping between a port (<strong class="source-inline">80</strong> in the example) and the value used for the SECMARK support. Of course, already established sessions also receive the appropriate SECMARK labeling.</p>
			<p class="calibre3">If we define multiple entries,  the <strong class="source-inline">elements</strong> variable uses commas to separate the various values:</p>
			<p class="source-code">elements = { 53 : "dns_client" , 80 : "http_client" , 443 : "http_client" }</p>
			<p class="calibre3">Next to <strong class="source-inline">nftables</strong>. A second firewall solution that is gaining traction is eBPF, which we cover next.</p>
			<h2 id="_idParaDest-150" class="calibre10"><a id="_idTextAnchor152" class="pcalibre calibre6 pcalibre1"/>Assessing eBPF</h2>
			<p class="calibre3">eBPF (and the <strong class="source-inline">bpfilter</strong> command) is completely different in nature compared to <strong class="source-inline">iptables</strong> and <strong class="source-inline">nftables</strong>, so <a id="_idIndexMarker357" class="pcalibre calibre6 pcalibre1"/>let's first see how eBPF functions before we cover the SELinux support details for it.</p>
			<h3 class="calibre12">Understanding how eBPF works</h3>
			<p class="calibre3">The <strong class="bold">extended Berkeley Packet Filter</strong> (<strong class="bold">eBPF</strong>) is a framework that uses an in-kernel virtual <a id="_idIndexMarker358" class="pcalibre calibre6 pcalibre1"/>machine that interprets and executes eBPF code, rather low-level instructions comparable to processor instruction set operations. Because of its very low-level, yet processor-agnostic language, it can be used to create very fast, highly optimized rules.</p>
			<p class="calibre3">BPF was <a id="_idIndexMarker359" class="pcalibre calibre6 pcalibre1"/>originally used for analyzing and filtering network traffic (for example, within <strong class="source-inline">tcpdump</strong>). Because of its high efficiency, it was soon found in other tools as well, growing beyond the plain network filtering and analysis capabilities. As BPF expanded toward other use cases, it became extended BPF, or eBPF.</p>
			<p class="calibre3">The eBPF framework in the Linux kernel has been successfully used for performance monitoring, where eBPF applications hook into runtime processes and kernel subsystems to measure performance and feed back the metrics to user-space applications. It, of course, also supports filtering on (network) sockets, cgroups, process scheduling, and many more — and the list is growing rapidly.</p>
			<p class="calibre3">As with the LSM framework, which uses hooks into the system calls and other security-sensitive operations in the Linux kernel, eBPF hooks into the Linux kernel as well. Occasionally it <a id="_idIndexMarker360" class="pcalibre calibre6 pcalibre1"/>can use existing hooks (as with the Linux <strong class="bold">kernel probes</strong> or <strong class="bold">kprobes</strong> framework) and thus benefit from the stability of these interfaces. We can thus expect eBPF to grow its support further in other areas of the Linux kernel as well.</p>
			<p class="calibre3">eBPF applications (<strong class="bold">eBPF programs</strong>) are <a id="_idIndexMarker361" class="pcalibre calibre6 pcalibre1"/>defined in user space, and then submitted to the Linux kernel. The kernel verifies the security and consistency of the code to ensure that the virtual machine will not attempt to break out of the boundaries it works in. If approved (possibly after the code is slightly altered, as the Linux kernel has some operations that modify eBPF code to suit the environment or security rules), the eBPF program runs in the Linux kernel (within its virtual machine) and executes its purpose.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">The Linux kernel can compile the eBPF instructions into native, processor-specific instructions, rather than having the virtual machine interpret them. However, as this leads to a higher <a id="_idIndexMarker362" class="pcalibre calibre6 pcalibre1"/>security risk, this <strong class="bold">Just-In-Time</strong> (<strong class="bold">JIT</strong>) eBPF support is sometimes disabled by Linux distributions in their Linux kernels. It can be enabled by setting <strong class="source-inline">/proc/sys/net/core/bpf_jit_enable</strong> to <strong class="source-inline">1</strong>.</p>
			<p class="calibre3">These programs <a id="_idIndexMarker363" class="pcalibre calibre6 pcalibre1"/>can load and save information in memory, called maps. These <strong class="bold">eBPF maps</strong> can be read or written to by user-space applications, and thus offer the main interface to interact with running eBPF programs. These maps are accessed through file descriptors, allowing processes to pass along and clone these file descriptors as needed.</p>
			<p class="calibre3">Various products and projects are using eBPF to create high-performance network capabilities, such <a id="_idIndexMarker364" class="pcalibre calibre6 pcalibre1"/>as software-defined network configurations, DDoS mitigation rules, load balancers, and more. Unlike the netfilter-based firewalls, which rely on a massive code base within the kernel tuned through configuration, eBPF programs are built specifically for their purpose and nothing more, and only that code is actively running.</p>
			<h3 class="calibre12">Securing eBPF programs and maps</h3>
			<p class="calibre3">The default security measures in place for eBPF programs and maps are very limited, partly because lots <a id="_idIndexMarker365" class="pcalibre calibre6 pcalibre1"/>of trust is put in the Linux kernel verifier (which verifies the eBPF code before it passes the code on to the virtual machine), and partly because the eBPF code <a id="_idIndexMarker366" class="pcalibre calibre6 pcalibre1"/>was only allowed to be loaded when the process involved has the <strong class="source-inline">CAP_SYS_ADMIN</strong> capability. And as this capability basically means full system access, additional security controls were not deemed necessary.</p>
			<p class="calibre3">Since Linux kernel 4.4, some types of eBPF programs (such as socket filtering) can be loaded even by unprivileged processes (but, of course, only toward the sockets these processes have access to). The system <a id="_idIndexMarker367" class="pcalibre calibre6 pcalibre1"/>allows loading programs to work on cgroups <strong class="bold">socket buffers</strong> (<strong class="bold">skb</strong>) if the process has the <strong class="source-inline">CAP_NET_ADMIN</strong> capability. Recently, the permission to load eBPF programs has been added to the <strong class="source-inline">CAP_BPF</strong> and <strong class="source-inline">CAP_TRACING</strong> capabilities, although not all Linux distributions offer a Linux kernel that supports these capabilities already. But Linux administrators that want more fine-grained control over eBPF can use SELinux to tune and tweak eBPF handling.</p>
			<p class="calibre3">SELinux has a <strong class="source-inline">bpf</strong> class, which governs the basic eBPF operations: <strong class="source-inline">prog_load</strong>, <strong class="source-inline">prog_run</strong>, <strong class="source-inline">map_create</strong>, <strong class="source-inline">map_read</strong>, and <strong class="source-inline">map_write</strong>. Whenever a process creates a program or map, this program or map inherits the SELinux label of this process. If the file descriptors regarding these maps or programs are leaked, the malicious application still requires the necessary privileges toward this label before it can exploit it.</p>
			<p class="calibre3">User-space operations can interact with the eBPF framework through the <strong class="source-inline">/sys/fs/bpf</strong> virtual filesystem, so some Linux distributions associate a specific SELinux label (<strong class="source-inline">bpf_t</strong>) with this location as well. This allows administrators to manage access through SELinux policy rules in relation to this type.</p>
			<p class="calibre3">While eBPF is extremely extensible, the number of simplified frameworks surrounding it is small given its very early phase. We can, however, expect that more elaborate support will come soon, as a new tool called <strong class="source-inline">bpfilter</strong> is showing off the capabilities of eBPF-based firewalling on Linux systems.</p>
			<h3 class="calibre12">Filtering traffic with bpfilter</h3>
			<p class="calibre3">The <strong class="source-inline">bpfilter</strong> application is an application that builds a new eBPF program to filter and process <a id="_idIndexMarker368" class="pcalibre calibre6 pcalibre1"/>traffic. It allows administrators to build firewall capabilities without understanding the low-level eBPF instructions, and has recently started supporting <strong class="source-inline">iptables</strong>: administrators create rules with iptables, and <strong class="source-inline">bpfilter</strong> translates and converts these into eBPF programs.</p>
			<p class="callout-heading">Important note</p>
			<p class="callout">While <strong class="source-inline">bpfilter</strong> is part of the Linux kernel tree, it should be considered a proof-of-value currently, rather than a production-ready firewall capability.</p>
			<p class="calibre3"><strong class="source-inline">bpfilter</strong> creates eBPF programs that hook inside the Linux kernel between the network device driver <a id="_idIndexMarker369" class="pcalibre calibre6 pcalibre1"/>and the TCP/IP stack in a layer called the <strong class="bold">eXpress Data Path</strong> (<strong class="bold">XDP</strong>). At this level, the eBPF programs have access to the full network packet information (including link layer protocols such as Ethernet).</p>
			<p class="calibre3">To use <strong class="source-inline">bpfilter</strong>, the Linux kernel needs to be built with the appropriate settings, including <strong class="source-inline">CONFIG_BPFILTER</strong> and <strong class="source-inline">CONFIG_BPFILTER_UMH</strong>. The latter is the <strong class="source-inline">bpfilter</strong> user mode helper that will capture <strong class="source-inline">iptables</strong>-generated firewall rules, and translate those into eBPF applications.</p>
			<p class="calibre3">Before we load the <strong class="source-inline">bpfilter</strong> user mode helper, we need to allow <strong class="source-inline">execmem</strong> permission in SELinux:</p>
			<p class="source-code"># setsebool allow_execmem on</p>
			<p class="calibre3">Next, load the <strong class="source-inline">bpfilter</strong> module, which will have the user mode helper active on the system:</p>
			<p class="source-code"># modprobe bpfilter</p>
			<p class="source-code"># dmesg | tail</p>
			<p class="source-code">...</p>
			<p class="source-code">bpfilter: Loaded bpfilter_umh pid 2109</p>
			<p class="calibre3">Now, load the <strong class="source-inline">iptables</strong> firewall using the commands listed previously. The instructions are translated into eBPF programs, as shown with <strong class="source-inline">bpftool</strong>:</p>
			<p class="source-code"># bpftool p</p>
			<p class="source-code">1: xdp  tag 8ec94a061de28c09 dev ens3</p>
			<p class="source-code">        loaded_at Apr 25/23:19  uid:0</p>
			<p class="source-code">        xlated 533B  jited 943B  memlock 4096B</p>
			<p class="calibre3">The eBPF code itself can be displayed as well, but is hardly readable at this point for administrators.</p>
			<p class="calibre3">All of the aforementioned firewall capabilities interact with the TCP/IP stack supported within <a id="_idIndexMarker370" class="pcalibre calibre6 pcalibre1"/>the Linux kernel. There are, however, networks that do not rely on TCP/IP, such as InfiniBand. Luckily, even on those more specialized network environments, SELinux can be used to control communication flows.</p>
			<h1 id="_idParaDest-151" class="calibre5"><a id="_idTextAnchor153" class="pcalibre calibre6 pcalibre1"/>Securing high-speed InfiniBand networks</h1>
			<p class="calibre3">The <strong class="bold">InfiniBand</strong> standard <a id="_idIndexMarker371" class="pcalibre calibre6 pcalibre1"/>is a relatively recent (in network history) technology that enables very high throughput and very low latency. It accomplishes this by having a very <a id="_idIndexMarker372" class="pcalibre calibre6 pcalibre1"/>low overhead on the network layer (protocol) and direct access from user applications to the network level. This direct access also has implications for SELinux, as the Linux kernel is no longer actively involved in the transport of data across an InfiniBand link.</p>
			<p class="calibre3">Let's first look at what InfiniBand looks like, after which we can see how to still apply SELinux controls to its communication flows.</p>
			<h2 id="_idParaDest-152" class="calibre10"><a id="_idTextAnchor154" class="pcalibre calibre6 pcalibre1"/>Directly accessing memory</h2>
			<p class="calibre3">One of the <a id="_idIndexMarker373" class="pcalibre calibre6 pcalibre1"/>main premises of InfiniBand is to allow user applications to have direct access to the network. By itself, InfiniBand is a popular <strong class="bold">Remote Direct Memory Access</strong> (<strong class="bold">RDMA</strong>) implementation, which has received significant <a id="_idIndexMarker374" class="pcalibre calibre6 pcalibre1"/>support from vendors. We find RDMA actively used in high-performance clusters.</p>
			<p class="calibre3">Because of the direct access, controls are only possible while setting up the access approach. Without SELinux, all that is needed to set up and manage InfiniBand communications is to have access to the device file itself. If a process can write to the InfiniBand device, then it can use InfiniBand. By default, these devices are only accessible by the <strong class="source-inline">root</strong> user.</p>
			<p class="calibre3">The InfiniBand <a id="_idIndexMarker375" class="pcalibre calibre6 pcalibre1"/>devices are the network cards or <strong class="bold">Host Channel Adapters</strong> (<strong class="bold">HCA</strong>) and can have <a id="_idIndexMarker376" class="pcalibre calibre6 pcalibre1"/>multiple ports. An InfiniBand <strong class="bold">port</strong> is the link or interface that connects to an InfiniBand subnet. The subnet is the high-speed network on which multiple machines (ports) are connected. As with regular networks, InfiniBand switches are used to facilitate communication across a subnet, and routers can be used to connect different subnets with each other.</p>
			<p class="calibre3">An InfiniBand subnet <a id="_idIndexMarker377" class="pcalibre calibre6 pcalibre1"/>is managed by a <strong class="bold">Subnet Manager</strong> (<strong class="bold">SM</strong>). This is a process that coordinates the management of the different ports within the subnet, as well as the partitions. <strong class="bold">Partitions</strong> in InfiniBand are a way to differentiate between different communications within a subnet, like <strong class="bold">Virtual Local Area Networks</strong> (<strong class="bold">VLANs</strong>) in more <a id="_idIndexMarker378" class="pcalibre calibre6 pcalibre1"/>regular networks. With partitioned <a id="_idIndexMarker379" class="pcalibre calibre6 pcalibre1"/>communication, it is the subnet manager that tells which ports can be used for which partitions of the communication.</p>
			<h2 id="_idParaDest-153" class="calibre10"><a id="_idTextAnchor155" class="pcalibre calibre6 pcalibre1"/>Protecting InfiniBand networks</h2>
			<p class="calibre3">Unlike regular <a id="_idIndexMarker380" class="pcalibre calibre6 pcalibre1"/>networks, where firewalls and switch-level access controls are the norm for preventing unauthorized access, InfiniBand has few protection measures in place. InfiniBand largely assumes that the network is within a trusted environment. However, that does not exclude us from applying more rigid controls over which process can access the InfiniBand network in SELinux.</p>
			<p class="calibre3">As the communication flow itself is directly mapped in-memory toward the devices, the Linux kernel does not have any hooks available to do packet-level controls like it can with regular TCP/UDP traffic (using the SECMARK capabilities), or even session-level controls with sockets. Instead, SELinux focuses on two main controls, as visualized in the following diagram:</p>
			<div class="calibre13">
				<div id="_idContainer019" class="img---figure">
					<img src="Images/B16276_05_001.jpg" alt="Figure 5.1 – SELinux InfiniBand controls " class="calibre23"/>
				</div>
			</div>
			<p class="figure-caption">Figure 5.1 – SELinux InfiniBand controls</p>
			<p class="calibre3">These two main controls are as follows:</p>
			<ul class="calibre8">
				<li class="calibre9">Controlling who can manage the InfiniBand subnet </li>
				<li class="calibre9">Controlling who can access an InfiniBand partition</li>
			</ul>
			<p class="calibre3">To properly govern these controls, the <strong class="source-inline">semanage</strong> application assigns the right type to the appropriate <a id="_idIndexMarker381" class="pcalibre calibre6 pcalibre1"/>InfiniBand resource. However, not all SELinux policies already contain the appropriate types, so we need to add those in as well.</p>
			<h2 id="_idParaDest-154" class="calibre10"><a id="_idTextAnchor156" class="pcalibre calibre6 pcalibre1"/>Managing the InfiniBand subnet</h2>
			<p class="calibre3">Let's start <a id="_idIndexMarker382" class="pcalibre calibre6 pcalibre1"/>with managing the InfiniBand network. With InfiniBand on Linux, this is most often accomplished using the <strong class="source-inline">opensm</strong> application. Many InfiniBand adapters have multiple ports, allowing a server to participate in multiple InfiniBand subnets. With SELinux, we can control which domain can manage a subnet by controlling access to the InfiniBand port on a device.</p>
			<p class="calibre3">First, we need to assign a label to the InfiniBand port associated with a subnet. To accomplish that, we first need to obtain the right InfiniBand device, create the appropriate label (type), and then assign it to the port.</p>
			<p class="calibre3">Let's start by querying the available InfiniBand-capable devices on the system using <strong class="source-inline">ibv_devinfo</strong>:</p>
			<p class="source-code"># ibv_devinfo</p>
			<p class="source-code">hca_id: rxe0</p>
			<p class="source-code">  transport:	InfiniBand (0)</p>
			<p class="source-code">  fw_ver:		0.0.0</p>
			<p class="source-code">  ...</p>
			<p class="source-code">  phys_port_cnt:</p>
			<p class="source-code">    port:	1</p>
			<p class="source-code">		state:	PORT_ACTIVE (4)</p>
			<p class="source-code">		...</p>
			<p class="calibre3">Next, we create a type (label) to assign to the port. This type is only used to validate the access from the <strong class="source-inline">opensm</strong> application to this port. We use the CIL language for this (which we will elaborate upon in <a href="B16276_16_Final_VK.xhtml#_idTextAnchor391" class="pcalibre calibre6 pcalibre1"><em class="italic">Chapter 16</em></a>, <em class="italic">Developing Policies with SELinux CIL</em>). Create a file with the following content (let's call it <strong class="source-inline">infiniband_subnet.cil</strong>):</p>
			<p class="source-code">(typeattribute ibendport_type)</p>
			<p class="source-code">(type local_ibendport_t)</p>
			<p class="source-code">(typeattributeset ibendport_type local_ibendport_t)</p>
			<p class="source-code">(allow opensm_t local_ibendport_t (infiniband_endport (manage_subnet)))</p>
			<p class="calibre3">In the previous code, we enhance the SELinux policy with a new type called <strong class="source-inline">local_ibendport_t</strong>, assign it the <strong class="source-inline">ibendport_type</strong> attribute, and then grant the <strong class="source-inline">opensm_t</strong> domain the <strong class="source-inline">manage_subnet</strong> privilege within the <strong class="source-inline">infiniband_endport</strong> class.</p>
			<p class="calibre3">Let's load this policy enhancement:</p>
			<p class="source-code"># semodule -i infiniband_subnet.cil</p>
			<p class="calibre3">Finally, we assign this newly created type to the InfiniBand port:</p>
			<p class="source-code"># semanage ibendport -a -t local_ibendport_t -z rxe0 1</p>
			<p class="calibre3">This command assigns the <strong class="source-inline">local_ibendport_t</strong> type to port number <strong class="source-inline">1</strong> of the <strong class="source-inline">rxe0</strong> device (as obtained from <strong class="source-inline">ibv_devinfo</strong>). Once this mapping is in place, we can query it using <strong class="source-inline">semanage</strong> as well:</p>
			<p class="source-code"># semanage ibendport -l</p>
			<p class="source-code">SELinux IB End Port Type	IB Device Name	Port Number</p>
			<p class="source-code">local_ibendport_t		rxe0			0x1</p>
			<p class="calibre3">Without <a id="_idIndexMarker383" class="pcalibre calibre6 pcalibre1"/>any mappings, the command does not display any output.</p>
			<p class="callout-heading">Important note</p>
			<p class="callout">Currently, most Linux distributions have not incorporated InfiniBand support within the SELinux policy, requiring us to create our own custom labels. We can expect that distributions will add in default types for InfiniBand resources, and that SELinux support for InfiniBand will be extended with sane defaults.</p>
			<p class="calibre3">If we use InfiniBand on an SELinux-enabled system without any port mappings, the initial security context for unlabeled classes will be used as the label for this port, namely, <strong class="source-inline">unlabeled_t</strong>. It is, however, not recommended to stick to this label, as it is more widely used for unlabeled resources. Granting any privilege to the <strong class="source-inline">unlabeled_t</strong> type should be limited to highly privileged processes, and its use should be carefully considered to ensure that logging interpretation and SELinux policy rules vis-à-vis InfiniBand resources are clear (through well-documented types).</p>
			<h2 id="_idParaDest-155" class="calibre10"><a id="_idTextAnchor157" class="pcalibre calibre6 pcalibre1"/>Controlling access to InfiniBand partitions</h2>
			<p class="calibre3">While the <a id="_idIndexMarker384" class="pcalibre calibre6 pcalibre1"/>previous section focused on allowing the management application <strong class="source-inline">opensm</strong> to manage a subnet, this section will focus on restricting access to the InfiniBand network to the right domains. As mentioned before, an InfiniBand subnet can be divided further into separate networks using InfiniBand partitions.</p>
			<p class="calibre3">Originally, these <a id="_idIndexMarker385" class="pcalibre calibre6 pcalibre1"/>partitions are used to allow <strong class="bold">Quality of Service</strong> (<strong class="bold">QoS</strong>) or specific bandwidth and performance requirements on flows. The SM defines the <a id="_idIndexMarker386" class="pcalibre calibre6 pcalibre1"/>partitions and its attributes, and applications use a <strong class="bold">Partition Key</strong> (<strong class="bold">P_Key</strong>) to inform the InfiniBand network as regards to which partition certain communications must be done.</p>
			<p class="calibre3">SELinux can govern these partitions by creating a mapping between the InfiniBand subnet plus P_Key and an SELinux type. However, as with the subnet management, we need to find the appropriate details first and create an appropriate SELinux type before we can define the mapping.</p>
			<p class="calibre3">Let's start by figuring out the subnet and partition details. Both are managed by <strong class="source-inline">opensm</strong>. If you do not have access to the <strong class="source-inline">opensm</strong> configuration, then you need to ascertain these details from the (InfiniBand) network administrator.</p>
			<p class="calibre3">Within the <strong class="source-inline">opensm</strong> partition configuration (<strong class="source-inline">/etc/rdma/partitions.conf</strong>), the subnet and prefix can be found as follows:</p>
			<p class="source-code"># grep '=0x' /etc/rdma/partitions.conf</p>
			<p class="source-code">Default=0x7fff, rate=3, mtu=4, scope=2, defmember=full;</p>
			<p class="source-code">Default=0x7fff, ipoib, rate=3, mtu=4, scope=2;</p>
			<p class="source-code">rxe0_1=0x0610, rate=7, mtu=4, scope=2, defmember=full;</p>
			<p class="source-code">rxe0_1=0x0610, ipoib, rate=7, mtu=4, scope=2;</p>
			<p class="calibre3">In this <a id="_idIndexMarker387" class="pcalibre calibre6 pcalibre1"/>example, two partitions are defined. The first one is the default partition, which needs to remain (<strong class="source-inline">0x7fff</strong>). The second partition with key <strong class="source-inline">0x0610</strong> is active on the <strong class="source-inline">rxe0</strong> device and port <strong class="source-inline">1</strong>. It is this second partition that we will protect with SELinux.</p>
			<p class="calibre3">Let's create a new type to assign to this partition. We use the CIL format again to define the policy enhancement, and store these rules in a file called <strong class="source-inline">infiniband_pkey.cil</strong>:</p>
			<p class="source-code">(typeattribute ibpkey_type)</p>
			<p class="source-code">(type local_ibpkey_t)</p>
			<p class="source-code">(typeattributeset ibpkey_type local_ibpkey_t)</p>
			<p class="source-code">(allow unconfined_t local_ibpkey_t (infiniband_pkey (access)))</p>
			<p class="calibre3">Within this example, we've created the <strong class="source-inline">local_ibpkey_t</strong> type, assigned it to the <strong class="source-inline">ibpkey_type</strong> attribute, and granted <strong class="source-inline">unconfined_t</strong> access privilege within the <strong class="source-inline">infiniband_pkey</strong> class.</p>
			<p class="calibre3">Let's load the policy:</p>
			<p class="source-code"># semodule -i infiniband_pkey.cil</p>
			<p class="calibre3">We can now create an appropriate mapping to this partition, and limit it to the <strong class="source-inline">ff12::</strong> subnet prefix:</p>
			<p class="source-code"># semanage ibpkey -a -t local_ibpkey_t -x ff12:: 0x0610</p>
			<p class="source-code"># semanage ibpkey -l</p>
			<p class="source-code">SELinux IB PKey Type	Subnet_Prefix	Pkey Number</p>
			<p class="source-code">local_ibpkey_t		ff12::		0x610</p>
			<p class="calibre3">While we can create separate types for each partition, we can also use an SELinux range to use SELinux category support:</p>
			<p class="source-code"># semanage ibpkey -a -t local_ibpkey_t -r s0-s0:c0.c4 -x ff12:: 0x0610</p>
			<p class="calibre3">With <a id="_idIndexMarker388" class="pcalibre calibre6 pcalibre1"/>categories, we can grant access based on the source domain category, something we benefit from with other network protection measures such as labeled networking, which we tackle next.</p>
			<h1 id="_idParaDest-156" class="calibre5"><a id="_idTextAnchor158" class="pcalibre calibre6 pcalibre1"/>Understanding labeled networking</h1>
			<p class="calibre3">Another approach <a id="_idIndexMarker389" class="pcalibre calibre6 pcalibre1"/>to further fine-tune access controls on the network level is to introduce labeled networking. With labeled networking, security information passes on between hosts (unlike SECMARK, which only starts when the netfilter subsystem receives the packet, and whose marking never leaves the host). This is also known as peer labeling, as the security information passes on between hosts (peers).</p>
			<p class="calibre3">The advantage of labeled networking is that security information remains across the network, allowing end-to-end enforcement on mandatory access-control settings between systems as well as retaining the sensitivity level of communication flows between systems. The major downside, however, is that this requires an additional network technology (protocol) that can manage labels on network packets or flows.</p>
			<p class="calibre3">SELinux currently supports two implementations as part of the labeled networking approach: NetLabel and labeled IPsec. With NetLabel, two implementations exist: fallback labeling and CIPSO. In both cases, only the sensitivity of the source domain is retained across the communication. Labeled IPsec supports transporting the entire security context with it.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">NetLabel actually supports loopback-enabled, full-label support. In that case, the full label (and not only the sensitivity and categories) is passed on. However, this only works for communications that go through the loopback interface and, as such, do not leave the current host.</p>
			<p class="calibre3">Quite some time ago, support for NetLabel/CIPSO and labeled IPsec merged into a common framework, which introduces three additional privilege checks in SELinux: interface checking, node checking, and peer checking. These privilege checks are only active when labeled traffic is used; without labeled traffic, these checks are simply ignored.</p>
			<h2 id="_idParaDest-157" class="calibre10"><a id="_idTextAnchor159" class="pcalibre calibre6 pcalibre1"/>Fallback labeling with NetLabel</h2>
			<p class="calibre3">The NetLabel project supports fallback labeling, where administrators can assign labels to traffic from <a id="_idIndexMarker390" class="pcalibre calibre6 pcalibre1"/>or to network locations that don't use labeled networking. By using fallback labeling, the peer controls mentioned in the next few sections can be applied even without labeled IPsec or NetLabel/CIPSO being in place.</p>
			<p class="calibre3">The <strong class="source-inline">netlabelctl</strong> command controls the NetLabel configurations. Let's create a fallback label assignment for all traffic originating from the <strong class="source-inline">192.168.100.1</strong> address:</p>
			<p class="source-code"># netlabelctl unlbl add interface:eth0 address:192.168.100.1 label:system_u:object_r:netlabel_peer_t:s0</p>
			<p class="calibre3">To list the current definitions, use the following command:</p>
			<p class="source-code"># netlabelctl -p unlbl list</p>
			<p class="source-code">Accept unlabeled packets : on</p>
			<p class="source-code">Configured NetLabel address mappings (1)</p>
			<p class="source-code"> interface: eth0</p>
			<p class="source-code">   address: 192.168.100.1/32</p>
			<p class="source-code">    label: "system_u:object_r:netlabel_peer_t:s0"</p>
			<p class="calibre3">With this rule in place, labeled networking is active. Any traffic originating from the <strong class="source-inline">192.168.100.1</strong> address will be labeled with the <strong class="source-inline">netlabel_peer_t:s0</strong> label, while all other traffic will be labeled with the (default) <strong class="source-inline">unlabeled_t:s0</strong> label. Of course, the SELinux policy must allow all domains to have the <strong class="source-inline">recv</strong> permission from either the <strong class="source-inline">unlabeled_t</strong> peers or the <strong class="source-inline">netlabel_peer_t</strong> peers. </p>
			<p class="calibre3">Fallback labeling is useful for supporting a mix of labeled networking environments and non-labeled networks, which is why we list it here before documenting the various labeled networking technologies.</p>
			<h2 id="_idParaDest-158" class="calibre10"><a id="_idTextAnchor160" class="pcalibre calibre6 pcalibre1"/>Limiting flows based on the network interface</h2>
			<p class="calibre3">The idea <a id="_idIndexMarker391" class="pcalibre calibre6 pcalibre1"/>involving interface checking is that each packet that comes into a system passes an <strong class="source-inline">ingress</strong> check on an interface, whereas a packet that goes out of a system passes an <strong class="source-inline">egress</strong> check. <strong class="source-inline">ingress</strong> and <strong class="source-inline">egress</strong> are the SELinux permissions involved, whereas interfaces are given a security context.</p>
			<p class="calibre3">Interface labels can be granted using the <strong class="source-inline">semanage</strong> tool and are especially useful for assigning sensitivity levels to interfaces in case of MLS, although assigning different labels to the interface is also possible (but requires more adjustments to the running SELinux policy to return with a working system):</p>
			<p class="source-code"># semanage interface -a -t netif_t -r s1-s1:c0.c128 eth0</p>
			<p class="calibre3">Like the other <strong class="source-inline">semanage</strong> commands, we can view the current mappings as follows:</p>
			<p class="source-code"># semanage interface -l</p>
			<p class="source-code">SELinux Interface	Context</p>
			<p class="source-code">eth0				system_u:object_r:netif_t:s1-s1:c0.c128</p>
			<p class="calibre3">Keep in mind that for inbound communications, the acting domain is the peer. With labeled IPsec, this would be the client domain initiating the connection, whereas in NetLabel/CIPSO, this is <a id="_idIndexMarker392" class="pcalibre calibre6 pcalibre1"/>the associated peer label (such as <strong class="source-inline">netlabel_peer_t</strong>).</p>
			<p class="calibre3">By default, the interface is labeled with <strong class="source-inline">netif_t</strong> and without sensitivity constraints. This will, however, not be shown in the <strong class="source-inline">semanage interface -l</strong> output as its default output is empty.</p>
			<h2 id="_idParaDest-159" class="calibre10"><a id="_idTextAnchor161" class="pcalibre calibre6 pcalibre1"/>Accepting peer communication from selected hosts</h2>
			<p class="calibre3">SELinux nodes represent specific hosts (or a network of hosts) that data is sent to (<strong class="source-inline">sendto</strong>) or <a id="_idIndexMarker393" class="pcalibre calibre6 pcalibre1"/>received from (<strong class="source-inline">recvfrom</strong>) and are handled through the SELinux node class. Just like interfaces, these can be listed and defined by the <strong class="source-inline">semanage</strong> tool. In the following example, we mark the <strong class="source-inline">10.0.0.0/8</strong> network with the <strong class="source-inline">node_t</strong> type and associate a set of categories with it:</p>
			<p class="source-code"># semanage node -a -t node_t -p ipv4 -M 255.255.255.255 -r s0-s0:c0.c128 192.168.100.1</p>
			<p class="calibre3">Again, we can list the current definitions, too:</p>
			<p class="source-code"># semanage node -l</p>
			<p class="calibre3">Like the network interface flow, the acting domain for incoming communications is the peer label. </p>
			<p class="calibre3">By default, nodes are labeled with <strong class="source-inline">node_t</strong> and without category constraints. This will, however, not be shown in the <strong class="source-inline">semanage node -l</strong> output as its default output is empty.</p>
			<h2 id="_idParaDest-160" class="calibre10"><a id="_idTextAnchor162" class="pcalibre calibre6 pcalibre1"/>Verifying peer-to-peer flow</h2>
			<p class="calibre3">The final check is a <strong class="source-inline">peer</strong> class check. For labeled IPsec, this is <a id="_idIndexMarker394" class="pcalibre calibre6 pcalibre1"/>the label of the socket sending out the data (such as <strong class="source-inline">mozilla_t</strong>). For NetLabel/CIPSO, however, the peer will be static, based on the source, as CIPSO is only able to pass on sensitivity levels. A common label seen for NetLabel is <strong class="source-inline">netlabel_peer_t</strong>.</p>
			<p class="calibre3">Unlike the interface and node checks, peer checks have the peer domain as the target rather than the source. </p>
			<p class="callout-heading">Important note</p>
			<p class="callout">In all the labeled networking use cases, the process listed in a denial has nothing to do with the denial shown in the audit logs. This is because the denial triggers from within a kernel subsystem rather than through a call made by a user process. As a result, the kernel interrupts an unrelated process to prepare and log the denial, and this process name is used in the denial event.</p>
			<p class="calibre3">To finish up, look at the following diagram, which provides an overview of these various controls and the level to which they apply:</p>
			<div class="calibre13">
				<div id="_idContainer020" class="img---figure">
					<img src="Images/B16276_05_002.jpg" alt="Figure 5.2 – Schematic overview of the various network-related SELinux controls " class="calibre24"/>
				</div>
			</div>
			<p class="figure-caption">Figure 5.2 – Schematic overview of the various network-related SELinux controls</p>
			<p class="calibre3">The top-level <a id="_idIndexMarker395" class="pcalibre calibre6 pcalibre1"/>controls are handled on the domain level (such as <strong class="source-inline">httpd_t</strong>), whereas the bottom-level controls are on the peer level (such as <strong class="source-inline">netlabel_peer_t</strong>).</p>
			<h2 id="_idParaDest-161" class="calibre10"><a id="_idTextAnchor163" class="pcalibre calibre6 pcalibre1"/>Using old-style controls</h2>
			<p class="calibre3">Most Linux <a id="_idIndexMarker396" class="pcalibre calibre6 pcalibre1"/>distributions enable the <strong class="source-inline">network_peer_control</strong> capability. This is an enhancement within the SELinux subsystem that uses the previously mentioned peer class for verifying peer-to-peer flow.</p>
			<p class="calibre3">However, SELinux policies can opt to return to the previous approach, where peer-to-peer flow is no longer controlled over the peer class, but uses the <strong class="source-inline">tcp_socket</strong> class for communication. In that case, the <strong class="source-inline">tcp_socket</strong> class will be used against the <strong class="source-inline">peer</strong> domain, and it will also use the <strong class="source-inline">recvfrom</strong> permission (on top of the existing <strong class="source-inline">tcp_socket</strong> permissions).</p>
			<p class="calibre3">The current value of the <strong class="source-inline">network_peer_control</strong> capability can be queried through the SELinux filesystem:</p>
			<p class="source-code"># cat /sys/fs/selinux/policy_capabilities/network_peer_controls</p>
			<p class="source-code">1</p>
			<p class="calibre3">If the value is <strong class="source-inline">0</strong>, then the previously mentioned peer controls will be handled through the <strong class="source-inline">tcp_socket</strong> class instead of the peer class.</p>
			<p class="calibre3">The default <a id="_idIndexMarker397" class="pcalibre calibre6 pcalibre1"/>labeled networking controls within SELinux do not pass on any process context, and the use of fallback labeling with NetLabel is most commonly used in environments where the system participates in both labeled as well as unlabeled networks. However, there is a much more common networking implementation that not only supports labeled networking, but even passes on the domain context and does not require specialized environments: labeled IPsec.</p>
			<h1 id="_idParaDest-162" class="calibre5"><a id="_idTextAnchor164" class="pcalibre calibre6 pcalibre1"/>Using labeled IPsec with SELinux</h1>
			<p class="calibre3">Although <a id="_idIndexMarker398" class="pcalibre calibre6 pcalibre1"/>setting up and maintaining an IPsec setup is far <a id="_idIndexMarker399" class="pcalibre calibre6 pcalibre1"/>beyond the scope of this book, let's look at a simple IPsec example to show how to enable labeled IPsec on a system. Remember that the labeled network controls on the interface, node, and peer levels, as mentioned earlier, are automatically enabled the moment we use labeled IPsec.</p>
			<p class="calibre3">In an IPsec setup, there are three important concepts to be aware of:</p>
			<ul class="calibre8">
				<li class="calibre9">The <strong class="bold">security policy database</strong> (<strong class="bold">SPD</strong>) contains the rules and information for the kernel <a id="_idIndexMarker400" class="pcalibre calibre6 pcalibre1"/>to know when communication should be handled by an IP policy (and, as a result, handled through a security association).</li>
				<li class="calibre9">A <strong class="bold">security association</strong> (<strong class="bold">SA</strong>) is a one-way channel between two hosts and contains <a id="_idIndexMarker401" class="pcalibre calibre6 pcalibre1"/>all the security information about the channel. When labeled IPsec is in use, it also contains the context information of the client that caused the security association to materialize.</li>
				<li class="calibre9">The <strong class="bold">security association database</strong> (<strong class="bold">SAD</strong>) contains the individual security associations. </li>
			</ul>
			<p class="calibre3">Security <a id="_idIndexMarker402" class="pcalibre calibre6 pcalibre1"/>associations with a labeled IPsec setup are no longer purely indexed by the source and target address, but also the source context. As such, a Linux system that participates in a labeled IPsec setup will easily have several dozen SAs for a single communication flow between hosts, as each SA now also represents a client domain.</p>
			<p class="calibre3">Labeled IPsec introduces a few additional access controls through SELinux:</p>
			<ul class="calibre8">
				<li class="calibre9">Individual entries in the SPD are given a context. Domains that want to obtain an SA need to have the <strong class="source-inline">polmatch</strong> privilege (part of the <strong class="source-inline">association</strong> class) against this context. Also, domains that initiate an SA need to have the <strong class="source-inline">setcontext</strong> privilege (also part of the <strong class="source-inline">association</strong> class) against the target domain.</li>
				<li class="calibre9">Only authorized domains can make modifications to the SPD, which is also governed through the <strong class="source-inline">setcontext</strong> privilege, but now also against the SPD context entries. This privilege is generally granted to IPsec tools, such as Libreswan's pluto (<strong class="source-inline">ipsec_t</strong>).</li>
				<li class="calibre9">Domains that participate in IPsec communication must have the <strong class="source-inline">sendto</strong> privilege with their own association and the <strong class="source-inline">recvfrom</strong> privilege with the association of the <strong class="source-inline">peer</strong> domain. The receiving domain also requires the <strong class="source-inline">recv</strong> privilege from the <strong class="source-inline">peer</strong> class associated with the <strong class="source-inline">peer</strong> domain.</li>
			</ul>
			<p class="calibre3">So while <a id="_idIndexMarker403" class="pcalibre calibre6 pcalibre1"/>labeled IPsec cannot govern whether <strong class="source-inline">mozilla_t</strong> can <a id="_idIndexMarker404" class="pcalibre calibre6 pcalibre1"/>communicate with <strong class="source-inline">httpd_t</strong> (as <strong class="source-inline">mozilla_t</strong> only needs to be able to send to its own association), it can control whether <strong class="source-inline">httpd_t</strong> allows or denies incoming communication from <strong class="source-inline">mozilla_t</strong> (as it requires the <strong class="source-inline">recvfrom</strong> privilege on the <strong class="source-inline">mozilla_t</strong> association). The following diagram displays this complex game of privileges:</p>
			<div class="calibre13">
				<div id="_idContainer021" class="img---figure">
					<img src="Images/B16276_05_003.jpg" alt="Figure 5.3 – Example SELinux controls for labeled IPsec " class="calibre25"/>
				</div>
			</div>
			<p class="figure-caption">Figure 5.3 – Example SELinux controls for labeled IPsec</p>
			<p class="calibre3">In the next example, we will set up a simple IPsec tunnel between two hosts using the Libreswan tool.</p>
			<h2 id="_idParaDest-163" class="calibre10"><a id="_idTextAnchor165" class="pcalibre calibre6 pcalibre1"/>Setting up regular IPsec</h2>
			<p class="calibre3">Configuring Libreswan is <a id="_idIndexMarker405" class="pcalibre calibre6 pcalibre1"/>a matter of configuring Libreswan's main configuration file (<strong class="source-inline">ipsec.conf</strong>). Most distributions will use an <strong class="source-inline">include</strong> directory (such as <strong class="source-inline">/etc/ipsec.d</strong>) where admins or applications can place connection-specific settings. Generally, this <strong class="source-inline">include</strong> directory is used for the actual IPsec configurations, whereas the general <strong class="source-inline">ipsec.conf</strong> file is for Libreswan behavior.</p>
			<p class="calibre3">To create a host-to-host connection, we first define a shared secret on both hosts. Let's call the connection <strong class="source-inline">rem1-rem2</strong> (as those are the hostnames used for the two hosts), so the shared secret will be stored as <strong class="source-inline">/etc/ipsec.d/rem1-rem2.secrets</strong>:</p>
			<p class="source-code">192.168.100.4 192.168.100.5 : PSK "somesharedkey"</p>
			<p class="calibre3">Next, we define the VPN connection in <strong class="source-inline">/etc/ipsec.d/rem1-rem2.conf</strong> as follows:</p>
			<p class="source-code">conn rem1-rem2</p>
			<p class="source-code">	left=192.168.100.4</p>
			<p class="source-code">	right=192.168.100.5</p>
			<p class="source-code">	auto=start</p>
			<p class="source-code">	authby=secret</p>
			<p class="source-code">	#labeled-ipsec=yes</p>
			<p class="source-code">	#policy-label=system_u:object_r:ipsec_spd_t:s0</p>
			<p class="calibre3">The settings <a id="_idIndexMarker406" class="pcalibre calibre6 pcalibre1"/>that enable labeled IPsec are commented out for now to first test the IPsec connection without this feature.</p>
			<p class="calibre3">Launch the IPsec service on both systems:</p>
			<p class="source-code"># systemctl start ipsec</p>
			<p class="calibre3">Verify whether the connection works, for instance, by checking the network traffic with <strong class="source-inline">tcpdump</strong>, or by checking the state with <strong class="source-inline">ip xfrm state</strong>.</p>
			<h2 id="_idParaDest-164" class="calibre10"><a id="_idTextAnchor166" class="pcalibre calibre6 pcalibre1"/>Enabling labeled IPsec</h2>
			<p class="calibre3">To use <a id="_idIndexMarker407" class="pcalibre calibre6 pcalibre1"/>labeled IPsec with Libreswan, uncomment the <strong class="source-inline">labeled-ipsec</strong> and <strong class="source-inline">policy-label</strong> directives in the <strong class="source-inline">/etc/ipsec.d/rem1-rem2.conf</strong> IPsec definition. Restart the <strong class="source-inline">ipsec</strong> service, and try the connection again.</p>
			<p class="calibre3">When <a id="_idIndexMarker408" class="pcalibre calibre6 pcalibre1"/>an application tries to communicate over IPsec with remote domains, <strong class="source-inline">pluto</strong> (or any other <strong class="bold">Internet Key Exchange version 2</strong> (<strong class="bold">IKEv2</strong>) client that supports labeled IPsec) will exchange the necessary information (including context) with the other side. Both sides will then update the SPD with the necessary SAs <a id="_idIndexMarker409" class="pcalibre calibre6 pcalibre1"/>and associate the same <strong class="bold">security policy information</strong> (<strong class="bold">SPI</strong>) with it. From that point onward, the sending side will add the agreed-upon SPI information to the IPsec packets so that the remote side can immediately associate the right context with it again.</p>
			<p class="calibre3">The huge advantage here is that the client and server contexts, including sensitivity and categories, are synchronized (they are not actually sent over the wire with each packet, but exchanged initially when the security associations are set up).</p>
			<p class="calibre3">In certain specialized or highly secure environments, labeled networking is supported within the network itself. The most common labeling technology used is CIPSO, whose SELinux support we cover next.</p>
			<h1 id="_idParaDest-165" class="calibre5"><a id="_idTextAnchor167" class="pcalibre calibre6 pcalibre1"/>Supporting CIPSO with NetLabel and SELinux</h1>
			<p class="calibre3">NetLabel/CIPSO <a id="_idIndexMarker410" class="pcalibre calibre6 pcalibre1"/>labels and transmits sensitivities across the <a id="_idIndexMarker411" class="pcalibre calibre6 pcalibre1"/>network. Unlike labeled IPsec, no other context <a id="_idIndexMarker412" class="pcalibre calibre6 pcalibre1"/>information is sent or synchronized. So, when <a id="_idIndexMarker413" class="pcalibre calibre6 pcalibre1"/>we consider the communication flows between two points, they will have a default, common SELinux type (rather than the SELinux type associated with the source or target) but will have sensitivity labels based on the sensitivity label of the remote side.</p>
			<p class="calibre3">Part of NetLabel's configuration are mapping definitions that inform the system which communication flows (from selected interfaces, or even from configured IP addresses) are for a certain <strong class="bold">Domain of Interpretation</strong> (<strong class="bold">DOI</strong>). The CIPSO standard defines the DOI as a collection <a id="_idIndexMarker414" class="pcalibre calibre6 pcalibre1"/>of systems that interpret the CIPSO label similarly, or, in our case, use the same SELinux policy and configuration of sensitivity labels.</p>
			<p class="calibre3">Once these mappings have been established, NetLabel/CIPSO will pass on the sensitivity information (and categories) between hosts. The context we will see on the communication flows will be <strong class="source-inline">netlabel_peer_t</strong>, a default context assigned to NetLabel/CIPSO-originated traffic.</p>
			<p class="calibre3">Through this approach, we can start daemons with a sensitivity range and thus only accept connections from users or clients that have the right security clearance, even on remote, NetLabel/CIPSO-enabled systems.</p>
			<h2 id="_idParaDest-166" class="calibre10"><a id="_idTextAnchor168" class="pcalibre calibre6 pcalibre1"/>Configuring CIPSO mappings</h2>
			<p class="calibre3">A preliminary <a id="_idIndexMarker415" class="pcalibre calibre6 pcalibre1"/>requirement for having a good CIPSO-enabled network is to have a common understanding of which DOI will be used and what its consequences are. Labeled networks can use different DOIs for specific purposes.</p>
			<p class="calibre3">Along with the DOI, we also need to take care of how the categories and sensitivities are passed on over the CIPSO-enabled network. The CIPSO tag controls this setting, and NetLabel supports this with the following three values:</p>
			<ul class="calibre8">
				<li class="calibre9">With <strong class="source-inline">tags:1</strong>, the categories are provided in the CIPSO package in a bitmap approach. This is the most common approach, but limits the number of supported categories to 240 (from 0 to 239).</li>
				<li class="calibre9">With <strong class="source-inline">tags:2</strong>, the categories are enumerated separately. This allows a wider range of categories (up to 65,543), but only supports at most 15 enumerated categories. Try to use <strong class="source-inline">tags:2</strong> when you have many categories but for each scope, only a few categories need to be supported.</li>
				<li class="calibre9">With <strong class="source-inline">tags:5</strong>, the categories can be mentioned in a ranged approach (lowest and highest), with at most seven such low/high pairs.</li>
			</ul>
			<p class="calibre3">Note that the CIPSO tag results are handled under the hood: system administrators only need to configure the NetLabel mapping to use a selected tag value.</p>
			<p class="calibre3">Let's assume that we have two CIPSO-enabled networks, which have <strong class="source-inline">10.1.0.0/16</strong> associated with <strong class="source-inline">doi:1</strong> and <strong class="source-inline">10.2.0.0/16</strong> associated with <strong class="source-inline">doi:2</strong>. Both use the tag value <strong class="source-inline">1</strong>. First, we enable CIPSO and allow it to pass CIPSO-labeled packages with the DOI set to either <strong class="source-inline">1</strong> or <strong class="source-inline">2</strong>. We don't perform any translations (so the category and sensitivity set on the CIPSO package is the one used by SELinux):</p>
			<p class="source-code"># netlabelctl cipsov4 add pass doi:1 tags:1</p>
			<p class="source-code"># netlabelctl cipsov4 add pass doi:2 tags:1</p>
			<p class="calibre3">If we need <a id="_idIndexMarker416" class="pcalibre calibre6 pcalibre1"/>to translate (say that we use sensitivity <strong class="source-inline">s0-s3</strong> while the CIPSO network uses sensitivity <strong class="source-inline">100-103</strong>), a command would look like so:</p>
			<p class="source-code"># netlabelctl cipsov4 add std doi:1 tags:1 </p>
			<p class="source-code">levels:0=100,1=101,2=102</p>
			<p class="calibre3">Next, we implement mapping rules, telling the NetLabel configuration which network traffic is to be associated with <strong class="source-inline">doi:1</strong> or <strong class="source-inline">doi:2</strong>:</p>
			<p class="source-code"># netlabelctl map del default</p>
			<p class="source-code"># netlabelctl map add default address:10.1.0.0/16 protocol:cipsov4,1</p>
			<p class="source-code"># netlabelctl map add default address:10.2.0.0/16 protocol:cipsov4,2</p>
			<p class="calibre3">To list the current mappings, use the <strong class="source-inline">list</strong> option:</p>
			<p class="source-code"># netlabelctl map list -p</p>
			<p class="source-code">Configured NetLabel domain mappings (2)</p>
			<p class="source-code"> domain: DEFAULT (IPv4)</p>
			<p class="source-code">   address: 10.1.0.0/16</p>
			<p class="source-code">    protocol: CIPSO, DOI = 1</p>
			<p class="source-code"> domain: DEFAULT (IPv4)</p>
			<p class="source-code">   address: 10.2.0.0/16</p>
			<p class="source-code">    protocol: CIPSO, DOI = 2</p>
			<p class="calibre3">That's it. We <a id="_idIndexMarker417" class="pcalibre calibre6 pcalibre1"/>removed the initial default mapping (as that would prevent the addition of new default mappings) and then configured NetLabel to tag traffic for the given networks with the right CIPSO configuration.</p>
			<h2 id="_idParaDest-167" class="calibre10"><a id="_idTextAnchor169" class="pcalibre calibre6 pcalibre1"/>Adding domain-specific mappings</h2>
			<p class="calibre3">NetLabel <a id="_idIndexMarker418" class="pcalibre calibre6 pcalibre1"/>can also be configured to ensure that given SELinux domains use a well-defined DOI rather than the default one configured earlier on. For instance, to have the SSH daemon (running in the <strong class="source-inline">sshd_t</strong> domain) have its network traffic labeled with CIPSO <strong class="source-inline">doi:3</strong>, we'd use this:</p>
			<p class="source-code"># netlabelctl cipsov4 add pass doi:3 tags:1</p>
			<p class="source-code"># netlabelctl map add domain:sshd_t protocol:cipsov4,3</p>
			<p class="calibre3">The mapping rules can even be more selective than that. We can tell NetLabel to use <strong class="source-inline">doi:2</strong> for SSH traffic originating from one network, use <strong class="source-inline">doi:3</strong> for SSH traffic originating from another network, and even use unlabeled network traffic when it comes from any other network:</p>
			<p class="source-code"># netlabelctl map del domain:sshd_t protocol:cipsov4,3</p>
			<p class="source-code"># netlabelctl map add domain:sshd_t address:10.1.0.0/16 protocol:cipsov4,1</p>
			<p class="source-code"># netlabelctl map add domain:sshd_t address:10.4.0.0/16 protocol:cipsov4,3</p>
			<p class="source-code"># netlabelctl map add domain:sshd_t address:0.0.0.0/0 protocol:unlbl</p>
			<p class="calibre3">The NetLabel framework will try to match the most specific rule first, so 0.0.0.0/0 is only matched when no other rule matches.</p>
			<h2 id="_idParaDest-168" class="calibre10"><a id="_idTextAnchor170" class="pcalibre calibre6 pcalibre1"/>Using local CIPSO definitions</h2>
			<p class="calibre3">As mentioned before, NetLabel, by default, only passes the sensitivity and categories. However, when <a id="_idIndexMarker419" class="pcalibre calibre6 pcalibre1"/>using local (over the loopback interface) CIPSO, it is possible to use full label controls. When enabled, peer controls will not be applied against the default <strong class="source-inline">netlabel_peer_t</strong> type, but will use the client or server domain.</p>
			<p class="calibre3">To use local CIPSO definitions, first declare the DOI for local use:</p>
			<p class="source-code"># netlabelctl cipsov4 add local doi:5</p>
			<p class="calibre3">Next, have the local communication use the defined DOI (<strong class="source-inline">5</strong> in our example):</p>
			<p class="source-code"># netlabelctl map add default address:127.0.0.1 protocol:cipsov4,5</p>
			<p class="calibre3">With this enabled, local communication will be associated with <strong class="source-inline">doi:5</strong> and use the local mapping, passing the full label to the mandatory access control system (SELinux).</p>
			<h2 id="_idParaDest-169" class="calibre10"><a id="_idTextAnchor171" class="pcalibre calibre6 pcalibre1"/>Supporting IPv6 CALIPSO</h2>
			<p class="calibre3">CIPSO is <a id="_idIndexMarker420" class="pcalibre calibre6 pcalibre1"/>an IPv4 protocol, but a similar framework exists for IPv6, named <strong class="bold">Common Architecture Label IPv6 Security Option</strong> (<strong class="bold">CALIPSO</strong>). As with CIPSO, CALIPSO <a id="_idIndexMarker421" class="pcalibre calibre6 pcalibre1"/>is supported by the NetLabel project. When we need CALIPSO support, the protocol target is <strong class="source-inline">calipso</strong> rather than <strong class="source-inline">cipsov4</strong>.</p>
			<p class="calibre3">CALIPSO has a few small differences compared to CIPSO in NetLabel:</p>
			<ul class="calibre8">
				<li class="calibre9">Only one tag type is supported (unlike CIPSO's three tag types). As a result, CALIPSO administrators do not need to specify <strong class="source-inline">tags:#</strong> anywhere.</li>
				<li class="calibre9">CALIPSO only uses pass-through mode. Translations are not supported.</li>
				<li class="calibre9">The NetLabel CALIPSO implementation currently does not support local mode, where the full label would be passed on.</li>
			</ul>
			<p class="calibre3">Beyond these differences, the use of CALIPSO is very similar to CIPSO.</p>
			<h1 id="_idParaDest-170" class="calibre5"><a id="_idTextAnchor172" class="pcalibre calibre6 pcalibre1"/>Summary</h1>
			<p class="calibre3">SELinux, by default, uses access controls based on the file representation of communication primitives or the sockets used. On InfiniBand networks, access controls are limited to accessing the InfiniBand port and partitions. For TCP, UDP, and SCTP ports, administrators have some leeway in handling the controls through the <strong class="source-inline">semanage</strong> command without resorting to SELinux policy updates. Once we go into the realms of network-based communication, more advanced communication control can be accomplished through Linux netfilter support, using SECMARK labeling, and through peer labeling.</p>
			<p class="calibre3">In the case of SECMARK labeling, local firewall rules are used to map contexts to packets, which are then governed through SELinux policy. With peer labeling, either the application context itself (labeled IPsec) or its sensitivity level (netfilter/CIPSO) identify the resources the access controls apply. This allows an almost application-to-application network flow control through SELinux policies.</p>
			<p class="calibre3">We learned that the most common firewall frameworks (<strong class="source-inline">iptables</strong> and <strong class="source-inline">nftables</strong>) support SECMARK already, while the more recent eBPF-based <strong class="source-inline">bpfilter</strong> application has yet to receive this support.</p>
			<p class="calibre3">In the next chapter, we look at how we can use common infrastructure-as-code frameworks to address the various SELinux controls in a server environment.</p>
			<h1 id="_idParaDest-171" class="calibre5"><a id="_idTextAnchor173" class="pcalibre calibre6 pcalibre1"/>Questions</h1>
			<ol class="calibre18">
				<li class="calibre9">How do you map an SELinux type to a TCP port?</li>
				<li class="calibre9">Does SECMARK labeling change the network packets as they go over the wire?</li>
				<li class="calibre9">What <strong class="source-inline">semanage</strong> subcommands are used for InfiniBand support?</li>
				<li class="calibre9">Is specialized equipment needed for labeled IPsec?</li>
			</ol>
		</div>
	</div></body></html>