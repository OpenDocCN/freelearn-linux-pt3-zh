- en: '2'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '2'
- en: Exploring PowerShell Cmdlets and Syntax
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 探索 PowerShell Cmdlet 和语法
- en: Now we’ve got PowerShell installed, it’s time to get down to using it. The power
    of PowerShell lies in the huge number of cmdlets available for it. In this chapter,
    we’re going to learn about these. First, we’ll see how the naming conventions
    work, then we will learn how to control what they do with parameters.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经安装了 PowerShell，是时候开始使用它了。PowerShell 的强大之处在于它提供了大量的 cmdlet。在本章中，我们将学习这些
    cmdlet。首先，我们将了解命名约定如何工作，然后学习如何通过参数控制它们的行为。
- en: We’ll take quite a deep dive into the syntax so that we understand exactly which
    parameters are available to a cmdlet and what information those parameters need
    to work. We’ll then look at how to get more cmdlets to work with, both from our
    local machine and from external sources.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将深入探讨语法，以便完全理解每个 cmdlet 可用的参数以及这些参数需要什么信息才能正常工作。然后我们将学习如何从本地计算机和外部资源获取更多的
    cmdlet 进行使用。
- en: Finally, we’ll talk about working interactively with PowerShell and will install
    an exciting new application for Windows that will help us do just that. By the
    end of the chapter, you will be able to confidently find and use unfamiliar cmdlets
    and be able to use the versatile Windows Terminal application.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将讨论如何与 PowerShell 进行交互式操作，并将为 Windows 安装一个令人兴奋的新应用程序，帮助我们实现这一点。到本章结束时，您将能够自信地找到并使用不熟悉的
    cmdlet，并能够使用多功能的 Windows Terminal 应用程序。
- en: 'In this chapter, we’re going to cover the following main topics:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下主要内容：
- en: What are cmdlets?
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 什么是 cmdlet？
- en: Understanding cmdlet syntax
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解 cmdlet 语法
- en: How to find more cmdlets
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何查找更多的 cmdlet
- en: Working interactively with PowerShell
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与 PowerShell 进行交互式操作
- en: Technical requirements
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: This chapter assumes you have a client machine, an internet connection, and
    have installed the latest stable version of PowerShell 7\. The last two sections
    of this chapter— *Windows Terminal – an alternative terminal emulator* and *Installing
    Windows Terminal from the Windows Store*—are specifically for Windows users. Those
    of us on Linux and macOS can feel happy that we don’t need to do these parts,
    as those operating systems already contain multi-tabbed terminals.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 本章假设您已经拥有客户端机器、互联网连接，并且安装了最新的稳定版 PowerShell 7。本章的最后两节—— *Windows Terminal –
    另一种终端模拟器* 和 *从 Windows Store 安装 Windows Terminal*——是专为 Windows 用户准备的。使用 Linux
    和 macOS 的我们可以放心，因为我们不需要做这些部分，这些操作系统已经包含了多标签终端。
- en: What are cmdlets?
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 什么是 cmdlet？
- en: '**Cmdlets** (pronounced *command-lets*) are the commands we use in PowerShell.
    They can either be entered via a terminal application or through a script. They
    may be **script-based** and constructed from other cmdlets, or they may be **binary**
    cmdlets written in **C#**. The cmdlets that install by default with PowerShell
    are binaries. Usually, cmdlets that we write ourselves or download from the internet
    will be script-based. Cmdlets take an **input object** from the pipeline, perform
    an action on it, and generally return an object for further processing. We will
    describe this in detail in [*Chapter 3*](B17600_03.xhtml#_idTextAnchor049), *The
    PowerShell Pipeline – How to String* *Cmdlets Together*.'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: '**Cmdlet**（发音为 *command-lets*）是我们在 PowerShell 中使用的命令。它们可以通过终端应用程序或脚本输入。它们可能是
    **基于脚本** 的，由其他 cmdlet 构建，或者可能是用 **C#** 编写的 **二进制** cmdlet。默认安装的 cmdlet 通常是二进制文件。通常，我们自己编写或从互联网上下载的
    cmdlet 将是基于脚本的。Cmdlet 从管道中获取 **输入对象**，对其执行操作，并通常返回一个对象以供进一步处理。我们将在 [*第 3 章*](B17600_03.xhtml#_idTextAnchor049)中详细描述这一过程，*PowerShell
    管道 – 如何将 cmdlet 串联起来*。'
- en: Exploring cmdlet structure
  id: totrans-14
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 探索 cmdlet 结构
- en: 'We’ve already used a few cmdlets, and you may have noticed that they have a
    common structure: `Get-Help`, `Get-Command`, `Get-Member`. This is a **verb-noun**
    structure, and it’s intended to help us understand what a cmdlet does. The **verb**
    at the start tells us that in each case, these cmdlets are going to *get* something:
    help, a list of commands, or a list of members. There is a list of approved verbs
    here: [https://docs.microsoft.com/en-us/powershell/scripting/developer/cmdlet/approved-verbs-for-windows-powershell-commands?view=powershell-7.2](https://docs.microsoft.com/en-us/powershell/scripting/developer/cmdlet/approved-verbs-for-windows-powershell-commands?view=powershell-7.2).'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经使用了一些 cmdlet，您可能已经注意到它们有一个共同的结构：`Get-Help`、`Get-Command`、`Get-Member`。这是一个
    **动词-名词** 结构，旨在帮助我们理解每个 cmdlet 的功能。开始的 **动词** 告诉我们，在每种情况下，这些 cmdlet 都是要 *获取* 某些东西：帮助、命令列表或成员列表。这里有一个批准的动词列表：[https://docs.microsoft.com/en-us/powershell/scripting/developer/cmdlet/approved-verbs-for-windows-powershell-commands?view=powershell-7.2](https://docs.microsoft.com/en-us/powershell/scripting/developer/cmdlet/approved-verbs-for-windows-powershell-commands?view=powershell-7.2)。
- en: Why do we need a list of approved verbs? For the sake of clarity; one of the
    primary purposes of PowerShell is to be easily understood. By limiting the number
    of verbs and clearly defining what each one means and when it should be used,
    we can tell immediately what a cmdlet will do. For instance, a cmdlet named `Delete-Item`
    might be just as obvious as `Remove-Item`, but how about `Eliminate-Item`? It’s
    possible this is going to do something unpleasant and terminal. Most well-written
    cmdlets will conform to this list; hopefully, anything we write will as well.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么我们需要一个批准的动词列表？为了清晰起见；PowerShell 的主要目的之一是易于理解。通过限制动词的数量并明确定义每个动词的含义及其使用场景，我们可以立即了解一个
    cmdlet 的作用。例如，一个名为 `Delete-Item` 的 cmdlet 可能和 `Remove-Item` 一样直观，但如果是 `Eliminate-Item`
    呢？这可能意味着它会做一些不太愉快且具有终结性质的操作。大多数写得好的 cmdlet 都会遵循这个列表；希望我们编写的代码也能符合这一点。
- en: Notice that not all the verbs in that list are actual verbs in English. `New`
    is not a verb, but for the purposes of cmdlets, we’re going to use it as one.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，列表中的并非所有动词在英语中都是实际的动词。`New` 不是一个动词，但为了 cmdlet 的目的，我们将其当作动词使用。
- en: Activity 1
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 活动 1
- en: When should we use `New`, and when should we use `Add`? Check out the preceding
    link to find out.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 我们什么时候使用 `New`，什么时候使用 `Add`？请查看前面的链接了解详细信息。
- en: The second part of the cmdlet is the `Get-Process`, never `Get-Processes`. The
    second rule is that they should be descriptive; that is, they should be immediately
    understandable. This can lead to some long cmdlet names, such as `Get-NetAdapterAdvancedProperty`.
    This is a bit of a mouthful, but it’s easily understood. Autocomplete, which we
    have already looked at in [*Chapter 1*](B17600_01.xhtml#_idTextAnchor013), *Introduction
    to PowerShell 7 – What It Is and How to Get It*, makes typing long cmdlets much
    easier. Type the first part of the noun, hit *Tab*, type the next part, hit *Tab*
    again, and so on until the cmdlet is complete. Try it with `Get-NetAdapterAdvancedProperty`.
    We only need to type `Get-NetA`, then press *Tab* twice to arrive at the right
    cmdlet. Repeatedly pressing *Tab* will cycle through the appropriate cmdlets on
    a Windows machine, or present you with a list of options on Linux and macOS.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: cmdlet 的第二部分是 `Get-Process`，而不是 `Get-Processes`。第二条规则是它们应该具有描述性；即，它们应该是立即可以理解的。这可能会导致一些较长的
    cmdlet 名称，如 `Get-NetAdapterAdvancedProperty`。这虽然有点拗口，但很容易理解。我们在 [*第 1 章*](B17600_01.xhtml#_idTextAnchor013)
    中已经看过的自动完成功能，*PowerShell 7 简介——它是什么以及如何获取*，使得输入长 cmdlet 更加容易。只需输入名词的第一部分，按 *Tab*
    键，再输入下一部分，再按 *Tab* 键，以此类推，直到完整输入 cmdlet。试试 `Get-NetAdapterAdvancedProperty`。我们只需输入
    `Get-NetA`，然后按两次 *Tab* 键就能得到正确的 cmdlet。在 Windows 机器上，反复按 *Tab* 键会在合适的 cmdlet 之间循环，或者在
    Linux 和 macOS 上呈现选项列表。
- en: There are also some standards around capitalization; **CamelCase** is preferred,
    whereby each word in the noun is capitalized. This not only makes it easier for
    us to read from the screen, but it also means that accessibility tools such as
    screen readers can handle them correctly.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 关于大小写也有一些标准；**驼峰命名法**是首选，即名词中的每个单词都要大写。这不仅使我们从屏幕上阅读更容易，而且还意味着屏幕阅读器等辅助工具可以正确处理它们。
- en: The correct use of aliases
  id: totrans-22
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 正确使用别名
- en: 'There is a way around cumbersome cmdlet names: `Get-Alias` into the command
    line. You should see a fairly long list of aliases for common cmdlets. For example,
    you should see that `man` is an alias for `Get-Help`. Try it; type in the following
    code and see what happens:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 有一种方法可以避免繁琐的 cmdlet 名称：将 `Get-Alias` 输入命令行。你应该会看到一个相当长的别名列表，列出常用 cmdlet 的别名。例如，你应该能看到
    `man` 是 `Get-Help` 的别名。试试它；输入以下代码并查看发生了什么：
- en: '[PRE0]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'There are two types of aliases, which exist for different reasons. Let’s have
    a closer look at them here:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 有两种类型的别名，分别用于不同的目的。让我们在这里仔细看一下它们：
- en: '`gci` for `Get-ChildItem`. These often require you to already know what the
    correct cmdlet is and can be quite cryptic. They are for people who know PowerShell
    and want to save time.'
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`gci` 是 `Get-ChildItem` 的别名。这些别名通常要求你已经知道正确的 cmdlet，并且可能非常简短且不直观。它们是为那些懂 PowerShell
    并希望节省时间的人准备的。'
- en: '`man` is a Unix command that calls the `ls` and `dir` are both aliases for
    `Get-ChildItem` and produce output that looks like the output you might expect
    if you are familiar with the `ls` Unix command or the `dir` Windows command. These
    are for old people like me so that years of muscle memory don’t have to be relearned.'
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`man` 是一个 Unix 命令，调用的是 `ls` 和 `dir`，它们都是 `Get-ChildItem` 的别名，并生成看起来像你熟悉的 `ls`
    Unix 命令或 `dir` Windows 命令的输出。这些是为了像我这样的老年人，以便不用重新学习多年的肌肉记忆。'
- en: Note
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: While we can type `dir` in PowerShell and get relevant output, we are not getting
    output from the `dir` command. The command switches we may be familiar with in
    `dir` won’t work in PowerShell. We are calling a cmdlet with similar functionality.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管我们可以在 PowerShell 中输入 `dir` 并获得相关输出，但我们并没有得到来自 `dir` 命令的输出。我们在 `dir` 中可能熟悉的命令选项在
    PowerShell 中不起作用。我们实际上是在调用一个具有类似功能的 cmdlet。
- en: 'We can also define our own aliases for cmdlets we use regularly using the `Set-Alias`
    cmdlet. We can do it like this:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以使用 `Set-Alias` cmdlet 为我们经常使用的 cmdlet 定义自己的别名。我们可以这样做：
- en: '[PRE1]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Try it. Type in the preceding cmdlet, and then type in `adapters`. You should
    see something like this:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试一下。输入前面的 cmdlet，然后输入 `adapters`。你应该能看到类似这样的输出：
- en: '![Figure 2.1 – Setting an alias](img/B17600_02_001.jpg)'
  id: totrans-33
  prefs: []
  type: TYPE_IMG
  zh: '![图 2.1 – 设置别名](img/B17600_02_001.jpg)'
- en: Figure 2.1 – Setting an alias
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.1 – 设置别名
- en: The drawback to doing this is that the alias you set is only available in the
    current PowerShell session. When you close the window, all your custom aliases
    are lost. You can save them in your PowerShell profile, but they’ll still only
    be available locally. I avoid using custom aliases and rely on autocomplete instead.
    It’s also poor practice to use them in a script, as this can hinder readability.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 这样做的缺点是，你设置的别名仅在当前的 PowerShell 会话中有效。当你关闭窗口时，所有自定义的别名都会丢失。你可以将它们保存在 PowerShell
    配置文件中，但它们仍然仅在本地有效。我避免使用自定义别名，而是依赖自动补全。将别名用于脚本中也是不好的做法，因为这会影响代码的可读性。
- en: Now we have an understanding of what a cmdlet is, let’s take a look at the syntax
    we need to use with them.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们了解了什么是 cmdlet，让我们看看使用它们时需要遵循的语法。
- en: Understanding cmdlet syntax
  id: totrans-37
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解 cmdlet 语法
- en: 'We’ve already seen that you can pass information to cmdlets for input, or to
    modify the output. For instance, in the previous section, we typed the following:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到，你可以向 cmdlet 传递信息作为输入，或者修改输出。例如，在上一节中，我们输入了以下内容：
- en: '[PRE2]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The cmdlet is called `Set-Alias`, but there are two bits of information after
    that: `-Name` and `-Value`. These are called `-`), which tells PowerShell that
    the following characters up to the next *space* character represent an instruction,
    rather than a value. In each of the preceding parameters we’ve passed a string—we’ve
    told `Set-Alias` that the value of `-Name` is `adapters`, and `-Value` is `Get-NetAdapter`.
    Now, when we type `adapters` at Command Prompt, PowerShell knows to substitute
    it with `Get-NetAdapter`.'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 这个 cmdlet 的名称是 `Set-Alias`，但后面有两部分信息：`-Name` 和 `-Value`。这两部分被称为 `-`，它告诉 PowerShell
    后面的字符直到下一个 *空格* 字符表示的是指令，而不是值。在前面的参数中，我们传递了一个字符串——我们告诉 `Set-Alias`，`-Name` 的值是
    `adapters`，而 `-Value` 的值是 `Get-NetAdapter`。现在，当我们在命令提示符下输入 `adapters` 时，PowerShell
    会知道用 `Get-NetAdapter` 来替换它。
- en: 'That’s great, but how do we know which parameters a cmdlet will take? Well,
    we’re going to go back to our friend `Get-Help` from [*Chapter 1*](B17600_01.xhtml#_idTextAnchor013),
    *Introduction to PowerShell 7 – What It Is and How to Get It*. Open a PowerShell
    prompt and type the following:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 太好了，但我们如何知道一个 cmdlet 会接受哪些参数呢？好吧，我们将再次回到我们的朋友 `Get-Help`，它出现在 [*第一章*](B17600_01.xhtml#_idTextAnchor013)，《PowerShell
    7 入门——它是什么以及如何获取它》中。打开一个 PowerShell 提示符，输入以下内容：
- en: '[PRE3]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'This will call up the `Get-Random` help file. We are interested in the `SYNTAX`
    section, shown next:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 这将调出`Get-Random`的帮助文件。我们关注的是下面的`SYNTAX`部分：
- en: '![Figure 2.2 – Get-Random syntax](img/B17600_02_002.jpg)'
  id: totrans-44
  prefs: []
  type: TYPE_IMG
  zh: '![图 2.2 – Get-Random 语法](img/B17600_02_002.jpg)'
- en: Figure 2.2 – Get-Random syntax
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.2 – Get-Random 语法
- en: 'Well, that’s great, but what does it all mean? The help file tells us that
    `Get-Random` can operate in three different ways; there is a set of parameters
    for each. Let’s concentrate on the first set. Remember, parameters always start
    with a dash (`-`), so we can see there are four parameters in that first set:
    `-Maximum`, `-Minimum`, `-Count`, and `-SetSeed`. As it says in the `DESCRIPTION`
    section: `You can use the parameters of Get-Random to specify the minimum and
    maximum values, the number of objects returned from a collection, or a seed number`.
    Hopefully, you completed the *Exercises* section in [*Chapter 1*](B17600_01.xhtml#_idTextAnchor013),
    *Introduction to PowerShell 7 – What It Is and How to Get It*, so you’ve seen
    this before. Let’s look at the second parameter set. There are three parameters
    there: `-InputObject`, `-Count`, and `-SetSeed`. Using these parameters makes
    `Get-Random` do something different. Instead of returning a random number, now
    it will return a random object from a list you give it in the first parameter.
    Let’s try it. In a PowerShell prompt, type the following:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，这很棒，但这到底是什么意思呢？帮助文件告诉我们，`Get-Random`可以有三种不同的操作方式；每种方式都有一组参数。让我们专注于第一个参数集。记住，参数总是以短横线（`-`）开始，因此我们可以看到第一个参数集中有四个参数：`-Maximum`、`-Minimum`、`-Count`
    和 `-SetSeed`。正如`DESCRIPTION`部分所说：`你可以使用Get-Random的参数来指定最小值和最大值、从集合中返回的对象数量，或者一个种子数字`。希望你已经完成了[《第1章》](B17600_01.xhtml#_idTextAnchor013)中的*练习*部分，*PowerShell
    7简介–它是什么以及如何获取*，因此你之前应该见过这个。让我们来看第二个参数集。那里有三个参数：`-InputObject`、`-Count`和`-SetSeed`。使用这些参数会让`Get-Random`做不同的事情。它将不再返回一个随机数字，而是返回你在第一个参数中给定的列表中的一个随机对象。让我们试试看。在PowerShell提示符下，输入以下内容：
- en: '[PRE4]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Hopefully, `Get-Random` will return a random piece of fruit from that list.
    The comma character tells PowerShell that there are more items to come in the
    list.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 希望`Get-Random`能够从这个列表中返回一个随机的水果项。逗号字符告诉PowerShell列表中还有更多项。
- en: 'The following screenshot shows some of the ways you can get this wrong:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图展示了你可能会犯的一些错误：
- en: '![Figure 2.3 – Passing a list of items the wrong way](img/B17600_02_003.jpg)'
  id: totrans-50
  prefs: []
  type: TYPE_IMG
  zh: '![图 2.3 – 错误传递项目列表](img/B17600_02_003.jpg)'
- en: Figure 2.3 – Passing a list of items the wrong way
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.3 – 错误传递项目列表
- en: In the first example, I’ve only passed a single item with a lot of double quotes.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一个示例中，我只传递了一个包含大量双引号的单一项。
- en: In the second one, I’ve passed a single item to the `-InputObject` parameter,
    and PowerShell is interpreting the second string, `pears`, as input for another
    parameter and getting confused.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 在第二个示例中，我只传递了一个项给`-InputObject`参数，PowerShell将第二个字符串`pears`解释为另一个参数的输入，结果产生了混淆。
- en: In the third example, PowerShell is waiting for the next item in the list, shown
    by the `>>` symbol. If you find yourself with this and you don’t know what to
    type next, press *Ctrl* + *C* to break out.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 在第三个示例中，PowerShell正在等待列表中的下一个项，用`>>`符号表示。如果你遇到这种情况而不确定接下来应该输入什么，按*Ctrl* + *C*可以中断操作。
- en: 'But the `SYNTAX` section tells us a lot more than just the names and sets of
    the parameters. It also tells us which parameters are mandatory, which ones accept
    more than one item, which ones need to be explicitly named, and which types of
    values each parameter will accept. Hold tight—this is going to get a bit complicated.
    Let’s look at the `SYNTAX` section of the help file for `Get-Random` again, in
    the following screenshot. Keep your eyes on the square brackets:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 但`SYNTAX`部分告诉我们的不仅仅是参数的名称和集合。它还告诉我们哪些参数是必需的，哪些参数可以接受多个项，哪些参数需要显式指定名称，以及每个参数接受的值类型。请保持专注——接下来可能会有点复杂。让我们再次查看`Get-Random`的帮助文件中的`SYNTAX`部分，见下图。请留意方括号：
- en: '![Figure 2.4 – Get-Random syntax](img/B17600_02_004.jpg)'
  id: totrans-56
  prefs: []
  type: TYPE_IMG
  zh: '![图 2.4 – Get-Random 语法](img/B17600_02_004.jpg)'
- en: Figure 2.4 – Get-Random syntax
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.4 – Get-Random 语法
- en: Our first parameter set starts with `[[-Maximum] <System.Object>]`. `-Maximum`
    is the parameter name, and `<System.Object>` is the parameter `-Maximum` parameter
    will take as input.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的第一个参数集以`[[-Maximum] <System.Object>]`开始。`-Maximum`是参数名称，而`<System.Object>`是`-Maximum`参数将接受的输入类型。
- en: 'If you type `Get-Help Get-Random -Full`, then you will see that it only accepts
    integers, floating-point numbers, or objects that can be interpreted as integers,
    such as the string `two`, as shown in *Figure 2**.5*. The outer set of square
    brackets tells us that the `-Maximum` parameter is optional; we don’t need to
    include it to get a random number. The inner set of square brackets around the
    parameter name, `[-Maximum]`, tells us that we don’t need to include the parameter
    name to pass a maximum value to the cmdlet. In the following screenshot, we can
    see that the parameter has a position value of `0`—this means that the first unnamed
    argument will be interpreted as belonging to the `-``Maximum` parameter:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你输入 `Get-Help Get-Random -Full`，你会看到它只接受整数、浮动点数，或可以解释为整数的对象，例如字符串 `two`，如*图
    2.5*所示。外部的方括号告诉我们 `-Maximum` 参数是可选的；我们不需要包括它就能得到一个随机数。参数名称周围的内部方括号 `[-Maximum]`
    告诉我们，我们不需要包含参数名称来为 cmdlet 传递最大值。在以下截图中，我们可以看到该参数的位置信息是 `0`——这意味着第一个未命名的参数会被解释为属于
    `-Maximum` 参数：
- en: '![Figure 2.5 – Detailed information about the -Maximum and -Minimum parameters](img/B17600_02_005.jpg)'
  id: totrans-60
  prefs: []
  type: TYPE_IMG
  zh: '![图 2.5 – `-Maximum` 和 `-Minimum` 参数的详细信息](img/B17600_02_005.jpg)'
- en: Figure 2.5 – Detailed information about the -Maximum and -Minimum parameters
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.5 – `-Maximum` 和 `-Minimum` 参数的详细信息
- en: We can see that for the `[-Minimum <System.Object>]` parameter, there is no
    inner set of square brackets; this means the `-Minimum` parameter must always
    be named if we’re going to use it; we actually have to type `-Minimum`. For both
    the `-Minimum` and `-Maximum` parameters, there are no square brackets around
    `<System.Object>`. This means that if we use these parameters, we must pass an
    argument to them of the type `System.Object` (specifically in this case an integer,
    floating-point number, or string that can be interpreted as a number).
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到，对于 `[-Minimum <System.Object>]` 参数，内部没有方括号；这意味着如果我们想使用 `-Minimum` 参数，它必须始终被命名；我们必须实际输入
    `-Minimum`。对于 `-Minimum` 和 `-Maximum` 参数，它们的 `<System.Object>` 周围没有方括号。这意味着如果我们使用这些参数，我们必须向它们传递一个
    `System.Object` 类型的参数（具体来说，是一个可以被解释为数字的整数、浮动点数或字符串）。
- en: 'Let’s look at the second set of parameters. It starts with `[-InputObject]
    <System.Object[]>`; this means if we want to use the second set, we must provide
    some input. The square brackets around `[-Input.Object]` tell us the name of the
    parameter is optional, however; PowerShell will interpret the first argument it
    receives as the input. How is this different from the first set? Look closely
    at the `<System.Object[]>` argument—it contains a set of square brackets at the
    end. This shows that it can contain multiple values, separated by a comma. Try
    this. Type the following:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 我们来看第二组参数。它以 `[-InputObject] <System.Object[]>` 开头；这意味着如果我们想使用第二组参数，我们必须提供一些输入。`[-InputObject]`
    周围的方括号告诉我们这个参数是可选的，不过，PowerShell 会将它接收到的第一个参数解释为输入。这和第一组参数有什么不同呢？仔细看看 `<System.Object[]>`
    参数——它的末尾有一对方括号。这表示它可以包含多个值，用逗号分隔。试试看，输入以下内容：
- en: '[PRE5]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Hopefully, you should get one of those values back. PowerShell knows it has
    received multiple values and knows not to interpret that collection as an argument
    for `-Maximum`, because `-Maximum` can only contain a single value.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 希望你能得到其中一个值的返回。PowerShell 知道它已经接收到多个值，并且知道不会将这些值集合解释为 `-Maximum` 的参数，因为 `-Maximum`
    只能包含一个单一的值。
- en: Activity 2
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 活动 2
- en: How might you provide a single numeric value to the `-``InputObject` parameter?
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 你怎么给 `-InputObject` 参数提供一个单一的数值？
- en: 'Let’s look now at the third set of parameters. At first glance, they look the
    same as the second set. They both start the same way, but notice at the end is
    this parameter: `-Shuffle`. It’s got no square brackets and no argument. This
    is a `switch` parameter. If we use it, we are automatically using the third parameter
    set; this means the `-Count` parameter is not available to us, as it’s not in
    the third set. It doesn’t take any argument because it tells PowerShell to return
    the entire list in random order.'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们来看第三组参数。乍一看，它们和第二组参数看起来一样。它们的开头是相同的，但注意结尾有一个参数：`-Shuffle`。它没有方括号，也没有参数。这是一个
    `switch` 参数。如果我们使用它，我们就自动使用了第三组参数；这意味着 `-Count` 参数对我们不可用，因为它不在第三组参数中。它不接受任何参数，因为它告诉
    PowerShell 以随机顺序返回整个列表。
- en: Each parameter set finishes with `[<CommonParameters>]`. This is a set of parameters
    that are available for any PowerShell cmdlet. You can read the `about_CommonParameters`
    help file for more information. They include variables to control the action PowerShell
    will take in the event of an error, or to produce more output from a cmdlet to
    help with troubleshooting. More on this in [*Chapter 10*](B17600_10.xhtml#_idTextAnchor201),
    *Error Handling – Oh No! It’s* *Gone Wrong!*.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 每个参数集以 `[<CommonParameters>]` 结尾。这是一组可用于任何 PowerShell cmdlet 的参数。你可以阅读 `about_CommonParameters`
    帮助文件获取更多信息。它们包括控制 PowerShell 在发生错误时采取的操作的变量，或从 cmdlet 输出更多内容以帮助故障排除。有关更多信息，请参见[*第
    10 章*](B17600_10.xhtml#_idTextAnchor201)《错误处理 – 哎呀！它出错了！》。
- en: 'Let’s summarize cmdlet syntax. There are six types of parameters, listed next:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们总结一下 cmdlet 的语法。接下来列出了六种类型的参数：
- en: '`Start-Service` has a mandatory parameter: `-DisplayName`.'
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Start-Service` 有一个必填参数：`-DisplayName`。'
- en: '`Get-Random` parameter `-InputObject` is an example of this.'
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Get-Random` 的参数 `-InputObject` 就是一个例子。'
- en: '`Get-Random` parameter `-Count` is an example of this.'
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Get-Random` 的参数 `-Count` 就是一个例子。'
- en: '`-Maximum` is an example of this in the `Get-Random` cmdlet. The whole parameter
    is enclosed in square brackets, then there is a second set enclosing just the
    parameter name.'
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-Maximum` 是 `Get-Random` cmdlet 中的一个例子。整个参数被方括号包围，然后有一对第二个方括号仅包围参数名称。'
- en: '`-Shuffle` is a good example of a mandatory switch parameter.'
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-Shuffle` 是一个强制性的开关参数的好例子。'
- en: '**Common parameters**: These are parameters that are available to all PowerShell
    cmdlets, and allow you to direct output or control error behavior.'
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**常见参数**：这些是所有 PowerShell cmdlet 都可以使用的参数，允许你控制输出或错误行为。'
- en: Parameters are organized into `Get-Random` can return a random number, a random
    item from a list, or the whole list in random order.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 参数组织成 `Get-Random` 可以返回一个随机数字、从列表中随机选取一个项目，或者按随机顺序返回整个列表。
- en: Now we understand what cmdlets and parameters are, you’re probably wondering
    where we get them. There are lots included when we download PowerShell, but it’s
    not going to be anything like enough. We’ll explore how to get more cmdlets next.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经理解了什么是 cmdlet 和参数，你可能会想知道它们从哪里来。下载 PowerShell 时会包含很多，但这远远不够。接下来我们将探索如何获取更多的
    cmdlet。
- en: How to find more cmdlets
  id: totrans-79
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何找到更多的 cmdlet
- en: Cmdlets are usually bundled together into packages called modules. We’ll cover
    module structure in detail in [*Chapter 11*](B17600_11.xhtml#_idTextAnchor218),
    *Creating Our First Module*, but for now, it is enough to know that a module is
    a collection of cmdlets with a common theme, such as interacting with a particular
    application or performing a set of similar functions. Once a module is installed
    and imported, the cmdlets become available in the shell or to a script.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: Cmdlet 通常被捆绑成一个名为模块的包。我们将在[*第 11 章*](B17600_11.xhtml#_idTextAnchor218)《创建我们的第一个模块》中详细讲解模块结构，但现在知道模块是一个包含具有共同主题的
    cmdlet 集合就足够了，主题可能是与某个特定应用程序互动或执行一组类似的功能。一旦模块被安装和导入，cmdlet 就会在 shell 或脚本中可用。
- en: Finding modules and cmdlets on your machine
  id: totrans-81
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在你的机器上查找模块和 cmdlet
- en: 'We already have a number of modules available to us. Try this; type `Get-Module`
    into your shell. Depending on how long PowerShell has been installed, how long
    the session has been open, and the platform we are working on, we should see a
    relatively short list—something like this:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经有了很多可用的模块。试试看；在命令行中输入 `Get-Module`。根据 PowerShell 的安装时间、会话的开启时长和我们正在使用的平台，应该会看到一个相对较短的列表，类似这样：
- en: '![Figure 2.6 – List of imported modules](img/B17600_02_006.jpg)'
  id: totrans-83
  prefs: []
  type: TYPE_IMG
  zh: '![图 2.6 – 已导入模块列表](img/B17600_02_006.jpg)'
- en: Figure 2.6 – List of imported modules
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.6 – 已导入模块列表
- en: 'That’s a list of modules that have been imported into the current session.
    But that’s not all the modules that we can use right now. Try running the cmdlet
    again, like this:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个当前会话中已导入模块的列表。但这并不是我们现在可以使用的所有模块。尝试像这样再次运行 cmdlet：
- en: '[PRE6]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: You should see a few more; if you’re running on Windows, you’ll see a lot more.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该会看到更多；如果你使用的是 Windows 系统，你将看到更多。
- en: 'The output of the cmdlet will be split according to the directory the modules
    are in, as shown in the following screenshot:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: cmdlet 的输出将根据模块所在的目录进行拆分，如下图所示：
- en: '![Figure 2.7 – Modules and their directories](img/B17600_02_007.jpg)'
  id: totrans-89
  prefs: []
  type: TYPE_IMG
  zh: '![图 2.7 – 模块及其目录](img/B17600_02_007.jpg)'
- en: Figure 2.7 – Modules and their directories
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.7 – 模块及其目录
- en: 'As you can see, on my machine, that cmdlet has found modules from PowerShell
    7 Preview and modules from Windows PowerShell, as well as many others. PowerShell
    uses the `PSModulePath` environment variable to know where to look for modules
    in your environment. We can check which locations are in that variable by typing
    the following:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，在我的机器上，该 cmdlet 找到了来自 PowerShell 7 Preview 和 Windows PowerShell 的模块，以及其他许多模块。PowerShell
    使用 `PSModulePath` 环境变量来知道在你的环境中在哪里查找模块。我们可以通过键入以下内容来检查该变量中包含哪些位置：
- en: '[PRE7]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: You’ll need to use a colon if you’re working on a Linux or macOS device.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在 Linux 或 macOS 设备上工作，使用冒号是必要的。
- en: 'Locations are put in that variable each time PowerShell is started, but they
    can also be added by applications, or even manually. You can see the results from
    my machine in the following screenshot. Notice the last entry is for `Microsoft
    Message Analyzer`; this was added when I installed that application:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 每次启动 PowerShell 时，这些位置会被放入该变量中，但它们也可以由应用程序或手动添加。你可以在下面的屏幕截图中看到我的机器上的结果。注意，最后一项是
    `Microsoft Message Analyzer`；这是我安装该应用程序时添加的：
- en: '![Figure 2.8 – The PSModulePath variable](img/B17600_02_008.jpg)'
  id: totrans-95
  prefs: []
  type: TYPE_IMG
  zh: '![图 2.8 – PSModulePath 变量](img/B17600_02_008.jpg)'
- en: Figure 2.8 – The PSModulePath variable
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.8 – PSModulePath 变量
- en: While we can add paths manually, for most purposes it is better to make sure
    we install modules to the default paths. There’s lots more about the `PSModulePath`
    variable in the `about_PSModulePath` help file.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然我们可以手动添加路径，但对于大多数情况来说，最好确保将模块安装到默认路径。有关 `PSModulePath` 变量的更多信息，请参阅 `about_PSModulePath`
    帮助文件。
- en: Now we know where to find modules on our machine, how do we know which cmdlets
    are in them? Notice in *Figure 2**.7* that there are properties in the `ExportedCommands`
    table; these are the cmdlets that will be available when we import the module.
    There may be cmdlets that aren’t exported and can only be used internally within
    the module; we won’t be able to type these in and use them. We can see just the
    exported cmdlets by running `Get-Command –Module`, followed by the name of the
    module.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们知道了在哪里可以找到计算机上的模块，那么如何知道它们包含哪些 cmdlet 呢？请注意在*图 2.7* 中，`ExportedCommands`
    表中有属性；这些就是我们导入模块时可用的 cmdlet。可能有一些 cmdlet 没有导出，只能在模块内部使用；我们无法直接键入这些 cmdlet 进行使用。我们可以通过运行
    `Get-Command –Module`，后跟模块名称，来查看仅导出的 cmdlet。
- en: 'Let’s try something. In [*Chapter 1*](B17600_01.xhtml#_idTextAnchor013), *Introduction
    to PowerShell 7 – What It Is and How to Get It*, we used the `Get-Command` cmdlet
    to find cmdlets. That cmdlet searches all the available modules for cmdlets, or
    we can tell it to just search imported ones. Let’s say we’re interested in cmdlets
    for manipulating modules. We might type the following to get a list of cmdlets
    that include the word `module` in the name:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们尝试一下。在[*第1章*](B17600_01.xhtml#_idTextAnchor013)《PowerShell 7简介——它是什么以及如何获取它》中，我们使用了
    `Get-Command` cmdlet 来查找 cmdlet。该 cmdlet 会搜索所有可用的模块中的 cmdlet，或者我们可以告诉它只搜索已导入的模块。假设我们对操作模块的
    cmdlet 感兴趣。我们可以键入以下内容，以获取包含 `module` 这个词的 cmdlet 列表：
- en: '[PRE8]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'However, if we type the following, then we will only get cmdlets from modules
    that we have already imported into the current session:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果我们键入以下内容，我们将只会得到已经导入到当前会话中的模块的 cmdlet：
- en: '[PRE9]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'This shows how those two cmdlets look on my machine:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 这显示了这两个 cmdlet 在我的机器上的表现：
- en: '![Figure 2.9 – Imported and installed cmdlets](img/B17600_02_009.jpg)'
  id: totrans-104
  prefs: []
  type: TYPE_IMG
  zh: '![图 2.9 – 已导入和已安装的 cmdlet](img/B17600_02_009.jpg)'
- en: Figure 2.9 – Imported and installed cmdlets
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.9 – 已导入和已安装的 cmdlet
- en: 'How do we use cmdlets from modules that haven’t been imported? In two ways,
    as follows:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 如何使用尚未导入的模块中的 cmdlet？有两种方法，如下所示：
- en: Firstly, we can use the `Import-Module` cmdlet to bring the module into the
    session, and then use the cmdlet we need.
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 首先，我们可以使用 `Import-Module` cmdlet 将模块导入会话，然后使用我们需要的 cmdlet。
- en: Or, we can just use it anyway and allow PowerShell to implicitly import it.
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 或者，我们也可以直接使用它，并允许 PowerShell 隐式地导入它。
- en: 'Try it. In *Figure 2**.6*, there is a list of imported modules for my current
    session. It doesn’t contain the `PowerShellGet` module. It’s probable that your
    current session hasn’t imported that module either, so let’s do that now. Type
    the following:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试一下。在*图 2.6* 中，有一个当前会话已导入模块的列表。它不包含 `PowerShellGet` 模块。很可能你的当前会话也没有导入该模块，因此让我们现在导入它。键入以下内容：
- en: '[PRE10]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'You’ll notice a little bit of a pause as PowerShell imports the `PowerShellGet`
    module, and then you’ll see a list of installed modules if any have been installed.
    That’s great, but the clever bit is this: type `Get-Module` again, to get a list
    of imported modules. You should see `PowerShellGet` has been imported in the background,
    as follows:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 您会注意到，当 PowerShell 导入 `PowerShellGet` 模块时会有一个小小的暂停，然后如果有已安装的模块，您会看到它们的列表。那很好，但聪明的地方在于：再次输入
    `Get-Module` 命令，来获取已导入模块的列表。您应该会看到 `PowerShellGet` 已经在后台被导入，如下所示：
- en: '![Figure 2.10 – As if by magic… the module appears](img/B17600_02_010.jpg)'
  id: totrans-112
  prefs: []
  type: TYPE_IMG
  zh: '![图 2.10 – 仿佛魔法般……模块出现了](img/B17600_02_010.jpg)'
- en: Figure 2.10 – As if by magic… the module appears
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.10 – 仿佛魔法般……模块出现了
- en: 'That leads to two questions. The first one is this: Why bother with importing
    and installing? Why not make all the cmdlets available every time, right from
    the start? The short answer is **space**. Each imported module requires a memory
    space; if we import hundreds of modules and thousands of cmdlets, then every time
    we start PowerShell, it will get incredibly unwieldy and slow, so we just import
    the modules and cmdlets we need, as we need them.'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 这引出了两个问题。第一个问题是：为什么还要导入和安装？为什么不从一开始就将所有 cmdlet 都可用呢？简短的答案是 **空间**。每个导入的模块都需要占用内存空间；如果我们导入了数百个模块和成千上万的
    cmdlet，那么每次启动 PowerShell 时，它将变得极其笨重和缓慢，因此我们只在需要时导入我们需要的模块和 cmdlet。
- en: 'The other question is this: Why do we need an `Import-Module` cmdlet if we
    can get cmdlets implicitly? We need `Import-Module` for two reasons; firstly,
    you might not install a module into one of the default paths in `PSModulePath`,
    so implicit importing won’t be available. Secondly, you might want to control
    how the module is imported. For instance, you might not want to import cmdlets
    from a module that has the same name as cmdlets you have already imported, in
    which case you would use `Import-Module` with the `-NoClobber` parameter, rather
    than import implicitly.'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个问题是：如果我们可以隐式获取 cmdlet，为什么还需要 `Import-Module` cmdlet 呢？我们需要 `Import-Module`
    有两个原因：首先，您可能没有将模块安装到 `PSModulePath` 中的默认路径之一，因此隐式导入将不可用。其次，您可能希望控制模块的导入方式。例如，您可能不想导入与已导入
    cmdlet 同名的模块，这时您应该使用带有 `-NoClobber` 参数的 `Import-Module`，而不是隐式导入。
- en: Activity 3
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 活动 3
- en: How might we import cmdlets, but change their names so that we know which module
    they are from?
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 我们如何导入 cmdlet，但改变它们的名称，以便我们知道它们来自哪个模块呢？
- en: Finding new modules and cmdlets
  id: totrans-118
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 查找新的模块和 cmdlet
- en: So far, we’ve looked at modules that are already on our system, but we have
    just now imported `PowerShellGet`, and it’s really useful because it can help
    us find modules that are held remotely, in a `PowerShellGet` connects to by default.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经查看了系统上已有的模块，但我们刚刚导入了 `PowerShellGet`，它非常有用，因为它可以帮助我们查找远程存储的模块，默认情况下，`PowerShellGet`
    会连接到远程位置。
- en: The PowerShell Gallery
  id: totrans-120
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: PowerShell Gallery
- en: 'Let’s start by looking at how we might find modules in the gallery that we
    are interested in. Try running the following:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们首先来看一下如何找到我们感兴趣的 PowerShell Gallery 中的模块。尝试运行以下命令：
- en: '[PRE11]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'This will give us a list of the cmdlets that are available in the module. We
    can see they fall into two categories—cmdlets for finding and installing resources
    such as modules and scripts, and cmdlets for managing repositories. Let’s have
    a look for a module. Try running the following:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 这将为我们提供模块中可用的 cmdlet 列表。我们可以看到它们分为两类——用于查找和安装资源（如模块和脚本）的 cmdlet，以及用于管理仓库的 cmdlet。我们来看看一个模块吧。尝试运行以下命令：
- en: '[PRE12]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'My results are shown here:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 我的结果如下所示：
- en: '![Figure 2.11 – Math-related modules in the PowerShell Gallery](img/B17600_02_011.jpg)'
  id: totrans-126
  prefs: []
  type: TYPE_IMG
  zh: '![图 2.11 – PowerShell Gallery 中与数学相关的模块](img/B17600_02_011.jpg)'
- en: Figure 2.11 – Math-related modules in the PowerShell Gallery
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.11 – PowerShell Gallery 中与数学相关的模块
- en: 'Some of those look more or less useful—I’m not sure that I need `PokerMath`,
    but you may. How do we know which cmdlets are in those modules? We can’t use `Get-Command`,
    as the modules are not present on our local machine, but `PowerShellGet` includes
    the `Find-Command` cmdlet. If we pass `Find-Command` the name of a particular
    module, then it will list out the cmdlets in that module, like this:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 其中一些看起来或多或少有用——我不确定我是否需要 `PokerMath`，但你可能需要。我们怎么知道这些模块中有哪些 cmdlet 呢？我们不能使用 `Get-Command`，因为这些模块不在本地计算机上，但是
    `PowerShellGet` 包括了 `Find-Command` cmdlet。如果我们将某个特定模块的名称传递给 `Find-Command`，它会列出该模块中的
    cmdlet，像这样：
- en: '[PRE13]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'If we run that, we can see that `psmath` contains a whole range of mathematical
    functions, from the fairly obvious—such as `Get-Math.sqrt`—to some more esoteric
    ones for **artificial intelligence** (**AI**) and statistics. To know how to use
    the functions, we will need to install the module and examine the help file. We
    can do this by typing the following:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们运行它，我们可以看到`psmath`包含整个范围的数学函数，从相当明显的——如`Get-Math.sqrt`——到一些更为深奥的人工智能（**AI**）和统计学函数。要了解如何使用这些函数，我们需要安装模块并查看帮助文件。我们可以通过输入以下内容来执行此操作：
- en: '[PRE14]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'You may see a warning that the repository is untrusted, as in the following
    screenshot. This is expected, as by default, no repositories are trusted. We need
    to explicitly trust them with the `Set-PSrepository` cmdlet:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能会看到一个警告，说明仓库是不受信任的，就像下面的屏幕截图一样。这是预期的，因为默认情况下，没有仓库是受信任的。我们需要使用`Set-PSrepository`
    cmdlet显式信任它们：
- en: '![Figure 2.12 – Do you trust this repository?](img/B17600_02_012.jpg)'
  id: totrans-133
  prefs: []
  type: TYPE_IMG
  zh: '![图 2.12 – 你信任这个仓库吗？](img/B17600_02_012.jpg)'
- en: Figure 2.12 – Do you trust this repository?
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.12 – 你信任这个仓库吗？
- en: 'Type `Y` for yes. After a few seconds of a progress bar, the Command Prompt
    will reappear. The module is now installed, but not imported. Although we’ve used
    `PowerShellGet` to install the module, it’s been installed into a location that
    isn’t in the correct path for implicitly importing it by using one of the cmdlets,
    but we can explicitly import it using the `Import-Module` cmdlet, like so:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 输入`Y`以确认。几秒钟后，进度条消失，命令提示符将重新出现。现在模块已安装，但尚未导入。尽管我们使用`PowerShellGet`安装了模块，但它已安装到一个位置，这不是隐式导入它的正确路径。但我们可以使用`Import-Module`
    cmdlet显式导入它，就像这样：
- en: '[PRE15]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'If we now type the following, we will see one of the disadvantages of community-provided
    modules:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们现在输入以下内容，我们将看到社区提供的模块的一个缺点：
- en: '[PRE16]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'A lot of authors are more excited by writing their software than documenting
    it, and the help is pretty sparse. However, we can see that `Get-Math.Sqrt` takes
    two parameters: either values or an input object. The `-Values` parameter is positional.
    Interestingly, it also takes a list of values, not only a single one. You can
    use the input object to supply the output of another cmdlet or a variable. Try
    this:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 许多作者更喜欢编写他们的软件而不是为其撰写文档，所以帮助内容相当稀少。然而，我们可以看到`Get-Math.Sqrt`接受两个参数：要么是值，要么是输入对象。`-Values`参数是位置参数。有趣的是，它还可以接受值的列表，而不仅仅是单个值。您可以使用输入对象来提供另一个cmdlet或变量的输出。尝试这个：
- en: '[PRE17]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: This will generate a random number, and then calculate the square root of it.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 这将生成一个随机数，然后计算其平方根。
- en: 'Why doesn’t `PowerShellGet` install modules in the right place? This is to
    do with scope. By default, `PowerShellGet` will install modules for the current
    user only, into a path in your `Documents` folder if you are on Windows, or into
    your home drive on Linux. We can change this by including the `-Scope` parameter
    with the `AllUsers` argument, but we would need to be running with administrator
    rights to do so. In the following screenshot, you can see the error message that
    comes up in this case. The alternative is to add the location to the `PATH` environment
    variable:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么`PowerShellGet`不能将模块安装到正确的位置？这与作用域有关。默认情况下，`PowerShellGet`会仅为当前用户安装模块，如果您使用Windows，则会安装到您的`Documents`文件夹中的路径，或者在Linux上安装到您的主目录。我们可以通过使用`-Scope`参数和`AllUsers`参数来更改此设置，但我们需要以管理员权限运行才能执行此操作。在下面的屏幕截图中，您可以看到在这种情况下出现的错误消息。另一种方法是将位置添加到`PATH`环境变量中：
- en: '![Figure 2.13 – I’m afraid I can’t do that, Dave](img/B17600_02_013.jpg)'
  id: totrans-143
  prefs: []
  type: TYPE_IMG
  zh: '![图 2.13 – 我恐怕不能这样做，戴夫](img/B17600_02_013.jpg)'
- en: Figure 2.13 – I’m afraid I can’t do that, Dave
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.13 – 我恐怕不能这样做，戴夫
- en: We can also view the PowerShell Gallery online at [https://www.powershellgallery.com/](https://www.powershellgallery.com/).
    Searching the website for `math` gives a lot more results, as it will not only
    search the module name but also any associated tags. We can get similar results
    by using the `-Filter` parameter with `Find-Module`.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以在线查看PowerShell Gallery，网址为[https://www.powershellgallery.com/](https://www.powershellgallery.com/)。在网站上搜索`math`将会得到更多结果，因为它不仅会搜索模块名称，还会搜索任何关联的标签。我们可以通过使用`-Filter`参数和`Find-Module`获取类似的结果。
- en: The PowerShell Gallery is not the only repository
  id: totrans-146
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: PowerShell Gallery不是唯一的存储库
- en: While the PowerShell Gallery is great, there are other repositories. You may
    have an internal repository where you work, or you may decide to build one for
    yourself later. The advantages of a repository are the version control and the
    automation it allows. The disadvantages are the maintenance and the potential
    for exploitation. If you need to use repositories other than the PowerShell Gallery,
    then `PowerShellGet` includes cmdlets for working with them, such as `Get-``PSRepository`,
    `Set-PSRepository`, and `Register-PSRepository`.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然 PowerShell Gallery 很棒，但也有其他仓库。你可能在工作中有一个内部仓库，或者你可能决定以后为自己建立一个。仓库的优点是版本控制和它所允许的自动化。缺点是维护以及潜在的被利用风险。如果你需要使用除
    PowerShell Gallery 外的其他仓库，那么 `PowerShellGet` 包含了一些用于与它们交互的 cmdlet，如 `Get-PSRepository`、`Set-PSRepository`
    和 `Register-PSRepository`。
- en: Other sources
  id: totrans-148
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 其他来源
- en: The main alternative to the PowerShell Gallery is GitHub, at [https://github.com](https://github.com),
    and similar online source code management tools such as GitLab. These platforms
    are not specific to PowerShell and contain code written in many other languages.
    The vast majority of the code is open source in one form or another. The GitHub
    platform is owned by Microsoft but not moderated by Microsoft, and contains everything
    ranging from the fully official PowerShell repository, with Microsoft’s own code,
    to unmaintained incomplete bits of scripts and malware. Unless you absolutely
    trust the repository owner always, *ALWAYS* read the code and understand what
    it does before downloading it.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: PowerShell Gallery 的主要替代方案是 GitHub，网址为 [https://github.com](https://github.com)，以及类似的在线源代码管理工具，如
    GitLab。这些平台不仅限于 PowerShell，还包含许多其他语言编写的代码。绝大多数代码以某种形式是开源的。GitHub 平台由微软拥有，但并未由微软管理，包含从完全官方的
    PowerShell 仓库（包括微软自己的代码），到未经维护的、不完整的脚本片段和恶意软件。除非你绝对信任仓库所有者，否则*一定*在下载之前阅读代码并理解它的作用。
- en: 'We can search GitHub for PowerShell modules by entering our search term on
    the GitHub website and adding `language:PowerShell`, as seen in the following
    screenshot:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在 GitHub 上搜索 PowerShell 模块，通过在 GitHub 网站上输入搜索词并添加 `language:PowerShell`，如下图所示：
- en: '![Figure 2.14 – 49 repositories on the GitHub website, some of which may be
    useful](img/B17600_02_014.jpg)'
  id: totrans-151
  prefs: []
  type: TYPE_IMG
  zh: '![图 2.14 – GitHub 网站上的 49 个仓库，其中一些可能有用](img/B17600_02_014.jpg)'
- en: Figure 2.14 – 49 repositories on the GitHub website, some of which may be useful
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.14 – GitHub 网站上的 49 个仓库，其中一些可能有用
- en: We can also find plenty of PowerShell scripts on the internet; it’s less likely
    we’ll find full modules, but many useful websites publish perfectly usable scripts
    outside of source-controlled platforms. The caveat still stands, however, only
    more so. Even if you trust the author, read the code, and understand what it does
    before using it. Never just blindly run something and hope it’s OK. PowerShell
    is extremely powerful, and you should always run it securely. There’ll be plenty
    more on this in [*Chapter 12*](B17600_12.xhtml#_idTextAnchor236), *Securing PowerShell*
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以在互联网上找到大量 PowerShell 脚本；尽管我们不太可能找到完整的模块，但许多有用的网站在源代码管理平台之外发布了完全可用的脚本。然而，警告依然存在，甚至更加重要。即使你信任作者，也要在使用之前阅读代码，并理解它的作用。永远不要盲目运行某些东西并指望它没问题。PowerShell
    功能非常强大，您应该始终安全地运行它。关于这一点，我们将在 [*第 12 章*](B17600_12.xhtml#_idTextAnchor236)，*保护
    PowerShell* 中详细讨论。
- en: The final way to get cmdlets, modules, and scripts is to write them yourself.
    This is easier than you might think, and we’ll cover it in the second section
    of the book, starting in [*Chapter 8*](B17600_08.xhtml#_idTextAnchor162), *Writing
    Our First Script – Turning Simple Cmdlets into* *Reusable Code*.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 获取 cmdlet、模块和脚本的最终方式是自己编写。这比你想象的要容易，我们将在本书的第二部分中介绍，从 [*第 8 章*](B17600_08.xhtml#_idTextAnchor162)，*编写我们的第一个脚本
    – 将简单的 cmdlet 转化为可重用的代码*。
- en: We should now have a good idea of the many places where we can find PowerShell
    resources, and understand their relative value. In the next section, we’ll discuss
    the most basic way to work with PowerShell, and Windows users can have some fun.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们应该对可以找到 PowerShell 资源的众多地方有了较好的了解，并且理解它们的相对价值。在下一部分，我们将讨论与 PowerShell 互动的最基本方式，Windows
    用户可以享受一些乐趣。
- en: Working interactively with PowerShell
  id: totrans-156
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 与 PowerShell 进行交互式工作
- en: PowerShell is, in my experience, unusual for a programming language, in that
    the huge number of cmdlets available make it particularly suitable for interactive
    use; open a terminal, type a line of code, and see something exciting happen.
    It is pretty difficult to do this in other interpreted languages, such as Python,
    because Python doesn’t come with many bundled commands, and it is difficult to
    import libraries into interactive sessions. Because of this, Python users very
    quickly move on to writing scripts. In the 10 years I have worked with PowerShell,
    I’ve found many of my colleagues never really progress from interactive PowerShell,
    and that’s fine. In the rest of this chapter, we’re going to recap how we’ve been
    using PowerShell, and Windows users can get to install a really useful utility
    called Windows Terminal, which will give them the same multi-tabbed terminal experience
    that Linux and macOS users can get by default.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 在我看来，PowerShell 是一种不太寻常的编程语言，因为其庞大的 cmdlet 数量使得它特别适合互动使用；打开终端，输入一行代码，就能看到一些令人兴奋的结果。在其他解释性语言中很难做到这一点，比如
    Python，因为 Python 自带的命令不多，并且将库导入到交互式会话中也很困难。因此，Python 用户很快就会转向编写脚本。我在使用 PowerShell
    的 10 年里，发现很多同事实际上并没有真正从交互式 PowerShell 进展到脚本编写，这也没问题。在本章的其余部分，我们将回顾一下我们是如何使用 PowerShell
    的，Windows 用户将能安装一个非常有用的工具，叫做 Windows Terminal，它能为他们提供与 Linux 和 macOS 用户默认拥有的相同的多标签终端体验。
- en: Each time we’ve entered a line of code, we’ve called a cmdlet. Each cmdlet is
    a mini-script or program. This is similar to shell scripting; batch scripts in
    Windows or Bash scripts in Linux, where each line of code we enter calls a defined
    program.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 每当我们输入一行代码时，我们就调用了一个 cmdlet。每个 cmdlet 都是一个迷你脚本或程序。这类似于 shell 脚本；Windows 中的批处理脚本或
    Linux 中的 Bash 脚本，其中我们输入的每一行代码都会调用一个定义好的程序。
- en: Most scripts in PowerShell are written in the same way—the script can be run
    as if it were a cmdlet, with parameters to modify the behavior and actions. This
    means we can use them interactively as well, allowing us to share our efforts
    with our less technically inclined colleagues and friends. Before we start writing
    scripts, however, it would be good to set up a way to easily use PowerShell interactively.
    The provided shell is much improved with PowerShell 7, including highlighting
    to make it easier to see what we are typing and improved copy and paste. However,
    I prefer another tool—Windows Terminal.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: PowerShell 中的大部分脚本都是以相同的方式编写的——脚本可以像 cmdlet 一样运行，带有参数来修改行为和操作。这意味着我们也可以互动使用它们，从而将我们的努力与那些技术上不太擅长的同事和朋友分享。然而，在我们开始编写脚本之前，最好先设置一个方便的方式来互动使用
    PowerShell。PowerShell 7 提供了改进的 shell，包括高亮显示，使我们更容易看清我们正在输入的内容，以及改进的复制粘贴功能。然而，我更喜欢另一个工具——Windows
    Terminal。
- en: Windows Terminal – an alternative terminal emulator
  id: totrans-160
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Windows Terminal——一个替代终端模拟器
- en: 'If you use Linux or macOS, you don’t need to do this part, as you already have
    multi-tabbed terminals, you lucky people. For Windows users, we had to open multiple
    applications; in the past, I might have had Windows Console (Command Prompt),
    Windows PowerShell, PowerShell 7, Azure Cloud Shell, PuTTY, Git Bash, and Python
    all open at once, running as separate applications. Since 2020, however, there
    is a much better choice—Windows Terminal. It can run multiple instances of any
    command-line program in separate tabs, which is enough to convince me on its own,
    but it also has support for emojis and glyphs, a split-pane function, and an allegedly
    fun new font called Cascadia Code, plus it’s open source. There are lots of details
    in this blog post if you want to know more: [https://devblogs.microsoft.com/commandline/introducing-windows-terminal/](https://devblogs.microsoft.com/commandline/introducing-windows-terminal/).'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你使用的是 Linux 或 macOS，你不需要做这一部分，因为你们已经有了多标签的终端，真是幸运的人。对于 Windows 用户，我们以前需要打开多个应用程序；过去，我可能同时打开了
    Windows Console（命令提示符）、Windows PowerShell、PowerShell 7、Azure Cloud Shell、PuTTY、Git
    Bash 和 Python，作为不同的应用程序运行。然而，自 2020 年以来，有了一个更好的选择——Windows Terminal。它可以在不同的标签页中运行任何命令行程序的多个实例，这就足以让我信服，但它还支持表情符号和字形、分屏功能，以及一个据说很有趣的新字体叫做
    Cascadia Code，另外它是开源的。如果你想了解更多细节，可以参考这篇博客：[https://devblogs.microsoft.com/commandline/introducing-windows-terminal/](https://devblogs.microsoft.com/commandline/introducing-windows-terminal/)。
- en: Windows Terminal is hosted on GitHub at [https://github.com/Microsoft/Terminal](https://github.com/Microsoft/Terminal),
    and you can download and install the `.msixbundle` file from there. You can also
    install it using Winget if you installed that earlier, or if you are on Windows
    11\. The preferred way, however, is to install it from Microsoft Store. This allows
    the application to be automatically updated—as it is open source, software updates
    are frequent and often necessary, as they include bug fixes as well as improvements.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: Windows Terminal 托管在 GitHub 上，网址是 [https://github.com/Microsoft/Terminal](https://github.com/Microsoft/Terminal)，你可以从那里下载并安装
    `.msixbundle` 文件。你也可以如果之前安装了 Winget，或者使用 Windows 11，则可以通过 Winget 安装它。然而，推荐的方式是通过
    Microsoft Store 安装，这样可以让应用自动更新——由于它是开源软件，更新频繁且通常是必要的，因为它包含了 bug 修复和改进。
- en: Installing Windows Terminal from Microsoft Store
  id: totrans-163
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 从 Microsoft Store 安装 Windows Terminal
- en: 'Installing from the Windows Store is a breeze. Here’s how to do it:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 从 Windows Store 安装非常简单。以下是安装步骤：
- en: Type `store` into your search bar in Windows and launch the Microsoft Store
    app.
  id: totrans-165
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 Windows 的搜索框中输入 `store`，然后启动 Microsoft Store 应用。
- en: Type `Windows Terminal` into the search bar in the Store app.
  id: totrans-166
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 Store 应用的搜索框中输入 `Windows Terminal`。
- en: 'Click **Get**, as shown in the following screenshot:'
  id: totrans-167
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击 **获取**，如以下截图所示：
- en: '![Figure 2.15 – Getting Windows Terminal: not suitable for toddlers](img/B17600_02_015.jpg)'
  id: totrans-168
  prefs: []
  type: TYPE_IMG
  zh: '![图 2.15 – 获取 Windows Terminal：不适合幼儿](img/B17600_02_015.jpg)'
- en: 'Figure 2.15 – Getting Windows Terminal: not suitable for toddlers'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.15 – 获取 Windows Terminal：不适合幼儿
- en: After a few minutes, Terminal will be available in your **Start** menu.
  id: totrans-170
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 几分钟后，Terminal 会出现在你的 **开始** 菜单中。
- en: 'And that’s it. Windows Terminal will now be updated automatically. Let’s start
    configuring it for our purposes. Because we’ve already installed PowerShell 7,
    Terminal will default to that when you open it; if we hadn’t, it would default
    to Windows PowerShell instead. Depending on which other applications you have
    installed on your client, it may automatically pick them up and make them available.
    Click the *down* icon in the toolbar to see what is already available and select
    an application other than the default, as illustrated in the following screenshot:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 就这样。Windows Terminal 现在会自动更新。接下来，我们开始为我们的用途进行配置。因为我们已经安装了 PowerShell 7，所以当你打开它时，Terminal
    会默认使用 PowerShell 7；如果没有安装，它将默认使用 Windows PowerShell。根据你在客户端安装的其他应用程序，它可能会自动识别并提供可用的选项。点击工具栏中的
    *向下* 图标，查看已提供的应用，并选择一个非默认的应用，如以下截图所示：
- en: '![Figure 2.16 – The basic applications available in Windows Terminal](img/B17600_02_016.jpg)'
  id: totrans-172
  prefs: []
  type: TYPE_IMG
  zh: '![图 2.16 – Windows Terminal 中可用的基本应用](img/B17600_02_016.jpg)'
- en: Figure 2.16 – The basic applications available in Windows Terminal
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.16 – Windows Terminal 中可用的基本应用
- en: 'That’s great, but it doesn’t begin to cover the number of command-line applications
    you might have. Let’s see how we can do that. I’ve got Python on my machine because
    I often enjoy a change of perspective. If you want to follow along and you don’t
    have Python installed, you can download it from here: [https://www.python.org/downloads](https://www.python.org/downloads)/.'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 这很好，但它还远远不够涵盖你可能拥有的所有命令行应用程序。让我们看看如何做到这一点。我在我的机器上安装了 Python，因为我常常喜欢换个视角。如果你想跟着一起操作，且没有安装
    Python，可以从这里下载：[https://www.python.org/downloads](https://www.python.org/downloads)/。
- en: 'Python by default installs to `C:\Users\<yourname>\AppData\Local\Programs\Python\<version
    number>`, as in the following screenshot. You’ll need to make a note of the path,
    and enable viewing hidden files in **File Explorer**:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，Python 安装在 `C:\Users\<yourname>\AppData\Local\Programs\Python\<version
    number>`，如下图所示。你需要记下这个路径，并在**文件资源管理器**中启用查看隐藏文件：
- en: '![Figure 2.17 – Where Python is](img/B17600_02_017.jpg)'
  id: totrans-176
  prefs: []
  type: TYPE_IMG
  zh: '![图 2.17 – Python 的位置](img/B17600_02_017.jpg)'
- en: Figure 2.17 – Where Python is
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.17 – Python 的位置
- en: 'To configure Windows Terminal to access Python, you’ll need to set up a new
    profile. Here’s how you can do this:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 要配置 Windows Terminal 以访问 Python，你需要设置一个新的配置文件。以下是操作步骤：
- en: Start Windows Terminal.
  id: totrans-179
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 启动 Windows Terminal。
- en: Click the *down* button on the toolbar, and select **Settings**.
  id: totrans-180
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击工具栏中的 *向下* 按钮，然后选择 **设置**。
- en: 'Select **Add a new profile** in the left-hand pane, and click on **New empty
    profile**, as shown in the following screenshot:'
  id: totrans-181
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在左侧面板中选择 **添加新配置文件**，然后点击 **新建空配置文件**，如以下截图所示：
- en: '![Figure 2.18 – Creating a new profile](img/B17600_02_018.jpg)'
  id: totrans-182
  prefs: []
  type: TYPE_IMG
  zh: '![图 2.18 – 创建新配置文件](img/B17600_02_018.jpg)'
- en: Figure 2.18 – Creating a new profile
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.18 – 创建新配置文件
- en: Fill in the name—in my case, I’m using `Python 3.10`, so I know which version
    of Python it will launch.
  id: totrans-184
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 填入名称——在我的情况下，我使用的是`Python 3.10`，这样我就知道它会启动哪个版本的 Python。
- en: Fill in the path to the `python.exe` executable file.
  id: totrans-185
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 填入 `python.exe` 可执行文件的路径。
- en: Select a starting directory, if you like. I like to put all my rubbish in one
    place.
  id: totrans-186
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择一个起始目录，如果你喜欢的话。我喜欢把所有的东西都放在一个地方。
- en: 'I like to use icons. You can find Python icons here: `C:\Users\<username>\AppData\Local\Programs\Python\Python310\Lib\test\imghdrdata`.'
  id: totrans-187
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我喜欢使用图标。你可以在这里找到 Python 图标：`C:\Users\<用户名>\AppData\Local\Programs\Python\Python310\Lib\test\imghdrdata`。
- en: Click **Save**.
  id: totrans-188
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击**保存**。
- en: 'You can see an overview of this in the following screenshot:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在以下截图中看到这个概览：
- en: '![Figure 2.19 – Creating a new profile, completed](img/B17600_02_019.jpg)'
  id: totrans-190
  prefs: []
  type: TYPE_IMG
  zh: '![图 2.19 – 创建新配置文件，完成](img/B17600_02_019.jpg)'
- en: Figure 2.19 – Creating a new profile, completed
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.19 – 创建新配置文件，完成
- en: And we’re done. Now, when you click on the *down* button in the toolbar, you’ll
    see **Python 3.10** as an option. Why have I used Python as an example here? Why
    didn’t I use the PowerShell 7 Preview version? Because Windows Terminal is pretty
    clever. If you install PowerShell 7 Preview after installing Windows Terminal,
    just restart Windows Terminal, and voilà! PowerShell 7 Preview will be an option.
    Cool, eh?
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们完成了。当你点击工具栏中的*下拉*按钮时，你将看到**Python 3.10**作为一个选项。为什么我在这里使用 Python 作为示例？为什么不使用
    PowerShell 7 预览版呢？因为 Windows Terminal 非常智能。如果你在安装 Windows Terminal 后安装了 PowerShell
    7 预览版，只需重新启动 Windows Terminal，瞧！PowerShell 7 预览版就会成为一个选项。酷吧，嗯？
- en: 'Here, you can see Python running in Windows Terminal:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，你可以看到 Python 在 Windows Terminal 中运行的画面：
- en: '![Figure 2.20 – Running Python in Windows Terminal](img/B17600_02_020.jpg)'
  id: totrans-194
  prefs: []
  type: TYPE_IMG
  zh: '![图 2.20 – 在 Windows Terminal 中运行 Python](img/B17600_02_020.jpg)'
- en: Figure 2.20 – Running Python in Windows Terminal
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.20 – 在 Windows Terminal 中运行 Python
- en: 'There’s another thing we must do. We’ve discussed the importance of being able
    to start PowerShell as an administrator; we need to do that for Windows Terminal
    as well. The easiest way to do that is to pin the Terminal app to the taskbar.
    If you right-click the icon on the taskbar, we can then right-click the **Terminal**
    icon in the pop-up menu and select **Run as administrator**, as follows:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一件事我们必须做。我们已经讨论了能够以管理员身份启动 PowerShell 的重要性；我们也需要为 Windows Terminal 做同样的事情。最简单的方法是将
    Terminal 应用程序固定到任务栏。如果你右键点击任务栏上的图标，我们可以右键点击弹出菜单中的**Terminal**图标，并选择**以管理员身份运行**，如下所示：
- en: '![Figure 2.21 – Running Windows Terminal as an administrator](img/B17600_02_021.jpg)'
  id: totrans-197
  prefs: []
  type: TYPE_IMG
  zh: '![图 2.21 – 以管理员身份运行 Windows Terminal](img/B17600_02_021.jpg)'
- en: Figure 2.21 – Running Windows Terminal as an administrator
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.21 – 以管理员身份运行 Windows Terminal
- en: If you open the settings for a profile in Windows Terminal, then you can set
    just that profile to run as an administrator. There are lots of other things you
    can do with Windows Terminal. The settings are available through the **user interface**
    (**UI**), or there is a convenient settings file in **JavaScript Object Notation**
    (**JSON**) that you can edit directly.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在 Windows Terminal 中打开一个配置文件的设置，你可以仅为该配置文件设置以管理员身份运行。Windows Terminal 还有很多其他功能可以使用。设置可以通过**用户界面**（**UI**）进行访问，或者你也可以直接编辑一个方便的**JavaScript
    对象表示法**（**JSON**）设置文件。
- en: Summary
  id: totrans-200
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we have explored cmdlets quite thoroughly. By now, we should
    understand the naming conventions, the syntax that cmdlets use, how to find out
    the parameters a cmdlet takes, and what to put in them. We then looked at some
    ways of discovering new cmdlets and modules, both on our local machine and with
    the PowerShell Gallery. Finally, we discussed working interactively with PowerShell
    and looked at an exciting new application for Windows users; Windows Terminal.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们已经相当彻底地探讨了 cmdlet。到现在为止，我们应该已经了解了命名规则、cmdlet 使用的语法、如何找出 cmdlet 所需的参数以及如何填写它们。接着，我们探索了在本地机器和
    PowerShell Gallery 上发现新 cmdlet 和模块的方法。最后，我们讨论了如何与 PowerShell 进行交互式工作，并介绍了一个适用于
    Windows 用户的全新应用程序——Windows Terminal。
- en: In the next chapter, we’re going to take a long hard look at the pipeline; how
    it works, how to string cmdlets together, how to understand what’s gone wrong,
    and what to do about it. We’ll also look at another great application for working
    with PowerShell, and this time everyone can install it, not just Windows users.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将深入研究管道；它是如何工作的，如何将 cmdlet 连接在一起，如何理解发生了什么错误，以及如何解决它。我们还将探讨另一个适用于 PowerShell
    的优秀应用程序，而且这次每个人都可以安装，而不仅仅是 Windows 用户。
- en: Exercises
  id: totrans-203
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 练习
- en: 'Which of these is the correct cmdlet to obtain the contents of a file in PowerShell:
    `Get-Content` or `Read-Content`?'
  id: totrans-204
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 PowerShell 中，获取文件内容的正确命令是 `Get-Content` 还是 `Read-Content`？
- en: What happens if you type `"alive alive" | oh` into the shell, and why?
  id: totrans-205
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果你在 shell 中输入 `"alive alive" | oh`，会发生什么？为什么？
- en: How many parameter sets does the `Get-ChildItem` cmdlet have? Which parameter
    determines which set we will use?
  id: totrans-206
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`Get-ChildItem` 命令有多少个参数集？哪个参数决定我们将使用哪个参数集？'
- en: If you see the `Get-ChildItem c:\foo *.exe` cmdlet, you can tell that `c:\foo`
    is an argument being passed to the `-Path` parameter. Which parameter is `*.exe`
    being passed to?
  id: totrans-207
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果你看到 `Get-ChildItem c:\foo *.exe` 命令，可以看出 `c:\foo` 是传递给 `-Path` 参数的一个参数。那么
    `*.exe` 被传递给哪个参数？
- en: Without actually trying it, will the `Get-ChildItem c:\foo -Filter *.exe, *.txt`
    cmdlet run? If not, why not?
  id: totrans-208
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果不实际尝试，`Get-ChildItem c:\foo -Filter *.exe, *.txt` 命令会运行吗？如果不会，为什么？
- en: How might you find cmdlets to work with **Amazon Web** **Services** (**AWS**)?
  id: totrans-209
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如何找到与 **Amazon Web** **Services** (**AWS**) 相关的 cmdlet？
- en: How might you find cmdlets to work with AliCloud?
  id: totrans-210
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如何找到与 AliCloud 相关的 cmdlet？
- en: How could you change the text size in Windows Terminal?
  id: totrans-211
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如何在 Windows Terminal 中更改文本大小？
