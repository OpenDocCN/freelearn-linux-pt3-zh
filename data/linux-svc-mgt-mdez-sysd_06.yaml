- en: '*Chapter 5*: Creating and Editing Services'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第 5 章*：创建和编辑服务'
- en: 'We''ve just seen what `systemd` services are and how to control them. Sometimes
    though, you might need to either alter the behavior of a service or create a completely
    new one. In this chapter, we''ll look at the proper way to edit services. Then,
    we''ll look at how to create a new one. The specific topics of this chapter are
    as follows:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚刚了解了`systemd`服务是什么以及如何控制它们。不过，有时你可能需要改变某个服务的行为，或者创建一个全新的服务。在这一章中，我们将学习如何正确编辑服务。接下来，我们将学习如何创建一个新的服务。本章的具体内容如下：
- en: Editing an existing service
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编辑现有服务
- en: Creating a new service
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建新服务
- en: Changing the default systemd editor
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 更改默认的 systemd 编辑器
- en: Creating a new container service with podman
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Podman 创建新的容器服务
- en: So, if you're ready, let's jump in.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你准备好了，那我们就开始吧。
- en: Technical requirements
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: As before, I'll be using an Alma Linux 8 virtual machine and an Ubuntu Server
    20.04 virtual machine. To perform the Secure Shell exercise, you'll need to go
    into the VirtualBox network settings for both virtual machines and choose `ip
    a`. That way, you'll be able to remotely log into your virtual machines from the
    command line of your host machine.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，我将使用 Alma Linux 8 虚拟机和 Ubuntu Server 20.04 虚拟机。为了进行安全 shell（Secure Shell）练习，你需要进入两台虚拟机的
    VirtualBox 网络设置，并选择`ip a`。这样，你就可以从宿主机的命令行远程登录到虚拟机。
- en: 'Check out the following link to see the Code in Action video: [https://bit.ly/3xP0yOH](https://bit.ly/3xP0yOH)'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 查看以下链接，观看“代码实战”视频：[https://bit.ly/3xP0yOH](https://bit.ly/3xP0yOH)
- en: Editing an existing service
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编辑现有服务
- en: We've seen that the unit files for our services live in the `/lib/systemd/system/`
    directory, so your first instinct might be to go there and edit files in your
    favorite text editor. You don't want to do that though, even though it would work.
    If you were to do a system update, it might overwrite the files that you edited,
    and you'd lose your changes.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到，服务的单元文件位于`/lib/systemd/system/`目录中，所以你可能首先会想到直接去那里，使用你喜欢的文本编辑器编辑文件。虽然这么做是可行的，但你不应该这样做。如果进行系统更新，它可能会覆盖你编辑的文件，从而丢失你的修改。
- en: The proper way to do this is to create edited versions of your service files
    in the `/etc/systemd/system/` directory. You can do that with your favorite text
    editor, the same as you would with any other configuration file. Indeed, that's
    the way that you *used to* have to do it. When Red Hat released RHEL 7.2, they
    added an `edit` function to the `systemctl` command, which makes life much easier.
    (Of course, that `edit` function is now available on all Linux distros that run
    `systemd`.)
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 正确的方法是在`/etc/systemd/system/`目录中创建你服务文件的编辑版。你可以像编辑其他配置文件一样，使用你喜欢的文本编辑器进行编辑。事实上，这也是你*以前*必须做的事。当
    Red Hat 发布 RHEL 7.2 时，他们在`systemctl`命令中添加了一个`edit`功能，这使得操作变得更容易。（当然，现在所有运行`systemd`的
    Linux 发行版都可以使用这个`edit`功能。）
- en: Note
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 注
- en: It has been brought to my attention that some people prefer to add their own
    custom unit files to the `/lib/systemd/system/` directory so that they'll be alongside
    the unit files that get installed by the operating system. If you're one of those
    people, please understand that this is *not* good practice. By doing this, you
    risk getting your custom unit files either deleted or overwritten when you do
    a system update. Also, keeping your custom unit files in the `/etc/systemd/system/`
    directory will make it much easier for you to keep track of which unit files you've
    added, and which ones were installed by the operating system.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 我注意到有些人喜欢将自己的自定义单元文件添加到`/lib/systemd/system/`目录中，这样它们就可以与操作系统安装的单元文件并列。如果你是其中之一，请理解这样做是*不*好的做法。这样做的风险是，在进行系统更新时，你的自定义单元文件可能会被删除或覆盖。而将自定义单元文件保存在`/etc/systemd/system/`目录中，会让你更容易跟踪哪些单元文件是你添加的，哪些是操作系统安装的。
- en: Now, you might be wondering how you can know what changes you can make to a
    service file. The most simplistic answer is to read the man pages for the various
    unit types and look at all the parameters and options that you can add, delete,
    or modify. If you're like me though, you'll start reading these man pages and
    soon find that they're the perfect cure for insomnia. Don't get me wrong, the
    man pages are definitely useful. But if you want to really learn how to make services
    sing and dance the way you want them to, the most painless way to do it is to
    look at the service files that are already on your system and see how they're
    set up. Then, look at the parameters that are listed in those files, and look
    them up in the appropriate man pages to see what they're doing for you. As we
    go through this chapter, I'll give you plenty of examples of what I'm talking
    about.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你可能会想知道如何了解可以对服务文件进行哪些更改。最简单的答案是阅读不同单元类型的 man 页面，查看可以添加、删除或修改的所有参数和选项。不过，如果像我一样，你会发现阅读这些
    man 页面很容易让人昏昏欲睡。别误会，man 页面确实很有用。但如果你真的想学会如何让服务按照你的需求“唱歌跳舞”，最轻松的办法就是查看你系统中已经存在的服务文件，看看它们是如何设置的。然后，查看这些文件中列出的参数，并查阅相应的
    man 页面，了解它们为你做了什么。我们在本章中会通过很多例子来说明这一点。
- en: When you use the `systemctl edit` function, you can either partially edit the
    file or edit the entire file. By default, you'll do a partial edit. Let's begin
    with the simplest example I can think of.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 当你使用 `systemctl edit` 功能时，可以选择部分编辑文件或编辑整个文件。默认情况下，你将进行部分编辑。让我们从我能想到的最简单的例子开始。
- en: Creating a partial edit to the [Install] section
  id: totrans-17
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 对 [Install] 部分进行部分编辑
- en: 'Let''s fire up the Ubuntu server virtual machine and add an `Alias=` line to
    the `apache2.service` file. Start by doing this:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 启动 Ubuntu 服务器虚拟机并向 `apache2.service` 文件添加一行 `Alias=`。首先这样做：
- en: '[PRE0]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'What you''ll get looks something like this:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 你看到的内容类似于这样：
- en: '![](img/Figure_5.1_B17491.jpg)'
  id: totrans-21
  prefs: []
  type: TYPE_IMG
  zh: '![](img/Figure_5.1_B17491.jpg)'
- en: Figure 5.1 – The systemd service editor on Ubuntu
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.1 – Ubuntu 上的 systemd 服务编辑器
- en: Yeah, that doesn't look like much, does it? It's just an empty file opened in
    the nano text editor. Don't worry, though. All we're going to do here is to add
    one parameter, and we don't need to see the whole service file to do that. Since
    we're working with Ubuntu, the name of the Apache service is `apache2`. Let's
    say that you've just come over from the Red Hat world, and you're used to always
    using `httpd` as the Apache service name. Consequently, you get frustrated when
    you always instinctively type the wrong service name on the Ubuntu machine. It's
    kind of like if you've been used to driving with a standard transmission all your
    life, and then you start stomping around for a clutch when you get into a car
    with an automatic transmission. (Well, that's what I do, anyway.) We can easily
    fix that, but let's first look at an example that we already have.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 是的，看起来没什么，对吧？这只是一个在 nano 编辑器中打开的空文件。不过别担心，我们在这里要做的只是添加一个参数，且不需要看到整个服务文件就能做到这一点。由于我们使用的是
    Ubuntu，Apache 服务的名称是 `apache2`。假设你刚从 Red Hat 环境过来，并且习惯了总是使用 `httpd` 作为 Apache
    服务名。因此，每当你在 Ubuntu 机器上输入错误的服务名时，就会感到很沮丧。这就像是你一辈子都习惯开手动挡车，结果一上自动挡车就开始找离合器。（嗯，反正我是这么做的。）我们可以轻松解决这个问题，但首先我们来看一个已经存在的例子。
- en: 'In another window, look at the `[Install]` section of the `ssh.service` file
    on the Ubuntu machine, as shown here:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 在另一个窗口中，查看 Ubuntu 机器上 `ssh.service` 文件的 `[Install]` 部分，如下所示：
- en: '[PRE1]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'That `Alias=` line at the end is our example. Now, over in the nano window,
    type this:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 最后的 `Alias=` 行就是我们的例子。现在，在 nano 窗口中输入以下内容：
- en: '[PRE2]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Save the file and exit the editor by doing a *Ctrl* + *X* sequence. When it
    asks if you want to save the modified buffer, hit the *y* key. Then, just hit
    the *Enter* key to accept the default filename. Next, look inside the `/etc/systemd/system/`
    directory. You''ll see that we''ve just created a new `apache2.service.d` directory:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 保存文件并通过按 *Ctrl* + *X* 键组合退出编辑器。当它询问是否保存已修改的缓冲区时，按 *y* 键。然后，按 *Enter* 键接受默认的文件名。接下来，查看
    `/etc/systemd/system/` 目录。你会看到我们刚刚创建了一个新的 `apache2.service.d` 目录：
- en: '[PRE3]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Inside that directory, you''ll see the following `override.conf` file:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 在那个目录中，你将看到以下 `override.conf` 文件：
- en: '[PRE4]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'This file contains the parameter that we''ve just added, which looks like this:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 这个文件包含了我们刚刚添加的参数，内容如下：
- en: '[PRE5]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: That's it – the entire file. When we start Apache, this parameter will get added
    to what's already in the original service file. The beauty of this is that if
    the original service file were to get replaced by a system update, you'd get the
    changes that were made by the update, and you'd still have this modification.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 就是这样——整个文件。当我们启动Apache时，这个参数将被添加到原始服务文件中已经存在的内容。其优点是，如果原始服务文件在系统更新中被替换，你将获得更新所做的更改，并且仍然保留这个修改。
- en: 'But, before you can use this modification, you''ll need to load it into the
    system. Do that by doing:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，在你使用这个修改之前，你需要将它加载到系统中。你可以通过执行以下命令来做到这一点：
- en: '[PRE6]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Any time you modify or add a service file, you''ll need to do a `daemon-reload`.
    When you add an `Alias=`, you''ll also need to create a symbolic link for it in
    the `/etc/systemd/system/` directory. You can create it manually with an `ln -s`
    command, but you don''t have to. When you add an `Alias=` line to the `[Install]`
    section of a service file, the link will get created automatically when you enable
    the service. On the Ubuntu machine, the Apache service is already enabled and
    running, so we''ll just disable it and enable it again. (Note that there''s no
    need to stop the service.) So, let''s first disable Apache, like this:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 每次修改或添加服务文件时，你都需要执行`daemon-reload`。当你添加`Alias=`时，还需要在`/etc/systemd/system/`目录中为其创建一个符号链接。你可以通过`ln
    -s`命令手动创建它，但其实不必。当你在服务文件的`[Install]`部分添加`Alias=`行时，启用服务时链接会自动创建。在Ubuntu机器上，Apache服务已经启用并正在运行，因此我们只需要禁用并重新启用它。（注意，不需要停止服务。）那么，我们先禁用Apache，像这样：
- en: '[PRE7]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Now, we''ll enable it again, like this:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将重新启用它，像这样：
- en: '[PRE8]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'You can see in the output that the `enable` command reads in the `Alias=` line
    that we inserted into the `[Install]` section, and creates an `httpd.service`
    link that points back to the original `apache2.service` file. We can verify that
    with this `ls -l` command as follows:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在输出中看到，`enable`命令读取了我们插入`[Install]`部分的`Alias=`行，并创建了一个指向原始`apache2.service`文件的`httpd.service`链接。我们可以通过以下`ls
    -l`命令来验证这一点：
- en: '[PRE9]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Now comes the moment of truth. Can we now control Apache on our Ubuntu machine
    by invoking the `httpd` service name? Let''s see:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是关键时刻了。我们能通过调用`httpd`服务名称来控制我们Ubuntu机器上的Apache吗？我们来看看：
- en: '[PRE10]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Oh, yeah. It works like a champ. (Don''t you just love it when a plan comes
    together?) To see the service file along with your new edit, use `systemctl cat`,
    like this:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 哦，没错。它运行得像冠军一样。（你难道不喜欢计划成功时的感觉吗？）要查看带有新编辑的服务文件，使用`systemctl cat`，像这样：
- en: '[PRE11]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The top part of the output shows the original service file, and the bottom part
    shows the `override.conf` file that you created.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 输出的顶部部分显示了原始的服务文件，底部部分显示了你创建的`override.conf`文件。
- en: Of course, you can also go the opposite way with this. If you're used to doing
    things the Ubuntu way and suddenly find yourself administering Apache on a RHEL-type
    machine, you can add an `Alias=apache2.service` line to the `httpd.service` file,
    and then disable and re-enable Apache in order to create the link. The only difference
    in the procedure is that on the Ubuntu machine, `systemctl edit` invokes the nano
    text editor, and on RHEL-type machines, it might invoke the vi text editor. (The
    RHEL-type distros just recently switched from vi to nano as the default systemd
    editor.)
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，你也可以走反方向。如果你习惯了Ubuntu的方式，而突然发现自己在RHEL类型的机器上管理Apache，你可以在`httpd.service`文件中添加`Alias=apache2.service`行，然后禁用并重新启用Apache来创建链接。唯一的不同之处是，在Ubuntu机器上，`systemctl
    edit`会启动nano文本编辑器，而在RHEL类型的机器上，它可能会启动vi文本编辑器。（RHEL类型的发行版最近才从vi切换为nano作为默认的systemd编辑器。）
- en: Pro tip
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 专业提示
- en: Remember that whatever changes you make to the `[Install]` section of a service
    file affects what happens whenever you enable or disable that service.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，对服务文件中`[Install]`部分所做的任何更改都会影响每次启用或禁用该服务时的行为。
- en: Okay, now that we've added a cool option to the `[Install]` section, let's add
    a few to the `[Service]` section.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，现在我们已经在`[Install]`部分添加了一个很酷的选项，让我们来添加一些到`[Service]`部分吧。
- en: Creating a partial edit to the [Service] section
  id: totrans-52
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 对`[Service]`部分进行局部编辑
- en: Let's continue on with our Ubuntu Server virtual machine, and just add to what
    we've already done. This time, we'll add a few options to the `[Service]` section
    that will beef up security a bit. Before we do that though, let's see how secure
    Apache really is. We'll do that with the `systemd-analyze` utility.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们继续操作我们的 Ubuntu 服务器虚拟机，并在已经做过的基础上再添加一些内容。这次，我们将在 `[Service]` 部分添加一些选项，稍微增强一下安全性。不过，在此之前，让我们看看
    Apache 的实际安全性如何。我们将通过 `systemd-analyze` 工具来检查。
- en: 'On the `systemd-analyze` man page, you''ll see that there are quite a few uses
    for this utility. For now, we''ll just cover the `security` option. Let''s start
    by checking the overall security profile for the services on our Ubuntu VM by
    doing:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `systemd-analyze` 的手册页上，你会看到这个工具有很多用途。目前，我们只介绍 `security` 选项。首先，通过执行以下命令来检查我们
    Ubuntu 虚拟机上服务的整体安全配置：
- en: '[PRE12]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: This command checks the security and sandboxing settings for each service and
    assigns an `EXPOSURE` score to each. The higher the score, the less safe the service
    is. So, this is like the game of golf, where you want to get the lowest score
    possible. The `HAPPY` column is supposed to show little face emoticons with varying
    degrees of happy or sad expressions, but the faces don't show when pasted into
    this book. That's okay though, because you can see them for yourself on your virtual
    machine.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 这个命令会检查每个服务的安全性和沙盒设置，并为每个服务分配一个 `EXPOSURE` 分数。分数越高，服务就越不安全。所以，这就像高尔夫比赛一样，你需要尽可能获得最低分数。`HAPPY`
    列本来应该显示不同程度的开心或难过表情符号，但粘贴到书中的时候表情符号无法显示。不过没关系，因为你可以在自己的虚拟机上看到这些表情。
- en: Now, before you get too excited about seeing that a service is marked as `UNSAFE`,
    as we see here for the Apache service, you need to understand that this only examines
    the security settings in the service files. It doesn't account for any security
    settings that might be in the service's own configuration files, security options
    that are encoded into the service executable file, or any **Mandatory Access Control**
    (**MAC**) options that might be in effect. Still, though, this is a useful tool
    for suggesting ways to enhance your security settings.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在你看到某个服务被标记为 `UNSAFE`（如我们这里看到的 Apache 服务）时，别太激动，你需要理解这只是检查了服务文件中的安全设置。它并没有考虑服务自身配置文件中的任何安全设置，也没有考虑可能嵌入在服务可执行文件中的安全选项，或者任何可能生效的**强制访问控制**（**MAC**）选项。不过，尽管如此，这仍然是一个有用的工具，可以为你提供加强安全设置的建议。
- en: 'Next, let''s look at some suggestions for the Apache service:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们来看看一些针对 Apache 服务的建议：
- en: '[PRE13]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'There''s too much output to show here in its entirety, but that''s okay. Let''s
    scroll down a bit and show some settings that are a bit more relevant to what
    we want to do:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的输出太多，无法全部显示，但没关系。让我们向下滚动一些，展示一些与我们想做的事情更相关的设置：
- en: '[PRE14]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'When you see an `X` in front of an entry, it means that an unsafe setting is
    in effect. Having a checkmark in front of an entry means that that parameter is
    configured with a safe setting. But, if you go in all willy-nilly and change the
    unsafe settings to safe ones, you''ll break the service so that it will no longer
    run. Some of these supposedly unsafe settings are necessary for the service to
    do its job. Take the `User=/DynamicUser=` setting, for example. We see here that
    not having that parameter allows the Apache service to run with root privileges.
    Is that bad? Not really, because the Apache service needs root privileges to do
    certain things that it has to do. If you set this option to a non-root user, Apache
    will fail to start. And besides, the Apache developers have already accounted
    for this. They set it up so that only the first Apache process runs with root
    privileges, and all other Apache processes—the ones to which web browsers connect—run
    without root privileges. We''ve already seen that on a RHEL-type distro, such
    as Alma Linux, the Apache processes run under the `apache` user account. On Ubuntu,
    we see here that they run under the `www-data` account:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 当你看到条目前面有一个 `X` 时，意味着这个设置是不安全的。如果条目前有一个勾选标记，表示该参数已配置为安全设置。但是，如果你胡乱地将不安全的设置更改为安全的设置，可能会导致服务无法正常运行。一些所谓的不安全设置其实是服务正常运行所必需的。以
    `User=/DynamicUser=` 设置为例。如果没有该参数，Apache 服务将以 root 权限运行。这不一定不好，因为 Apache 服务需要
    root 权限来执行某些任务。如果你将该选项设置为非 root 用户，Apache 将无法启动。而且，Apache 开发者已经考虑到了这一点。他们的设置方式是，只有第一个
    Apache 进程会以 root 权限运行，其他所有的 Apache 进程——即浏览器连接的进程——都不会以 root 权限运行。我们已经看到，在 RHEL
    类型的发行版中，比如 Alma Linux，Apache 进程是以 `apache` 用户身份运行的。而在 Ubuntu 中，我们看到它们是以 `www-data`
    账户运行的：
- en: '[PRE15]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'This non-root user is defined in the Apache configuration files. Let''s see
    if our good friend `grep` can help us find where this is set:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 这个非根用户是在 Apache 配置文件中定义的。让我们看看我们的好朋友`grep`能否帮助我们找到这个设置的位置：
- en: '[PRE16]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: So, on the Ubuntu machine, the non-root `www-data` user is defined in the `/etc/apache2/envvars`
    file and invoked in the `/etc/apache2/apache2.conf` file. (I'll leave it to you
    to find where this is set on the Alma Linux machine.) Anyway, that's enough about
    the settings that we can't change. Let's look at some settings that we *can* change.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，在 Ubuntu 机器上，非 root 的 `www-data` 用户定义在 `/etc/apache2/envvars` 文件中，并在 `/etc/apache2/apache2.conf`
    文件中调用。（关于 Alma Linux 机器上这个设置的位置，我留给你自己去找。）总之，关于我们不能更改的设置就说到这里。接下来，我们来看看一些我们*可以*更改的设置。
- en: 'Tip:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 提示：
- en: On RHEL-type machines, everything I'm about to show you is already covered by
    SELinux. But, you can still use these settings if you want double protection.
    Ubuntu and SUSE use AppArmor instead of SELinux. Unfortunately, AppArmor provides
    almost no protection at all for Apache unless you jump through the hoops of creating
    your own custom AppArmor profile. Setting up this protection in `systemd` is much
    easier.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 在 RHEL 类型的机器上，接下来我将展示的所有内容已经由 SELinux 覆盖。但如果你希望获得双重保护，仍然可以使用这些设置。Ubuntu 和 SUSE
    使用 AppArmor 而不是 SELinux。不幸的是，除非你自行创建自定义的 AppArmor 配置文件，否则 AppArmor 对 Apache 几乎没有任何保护。而在
    `systemd` 中设置这些保护则要简单得多。
- en: 'Let''s first look at protecting users'' home directories. We''ll once again
    use the `sudo systemctl edit apache2` command, which will open the `override.conf`
    file that we created previously. The `[Install]` section will still be there,
    so we''ll just add a `[Service]` section, as follows:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们来看看如何保护用户的主目录。我们将再次使用 `sudo systemctl edit apache2` 命令，这将打开我们之前创建的 `override.conf`
    文件。`[Install]` 部分仍然存在，我们只需添加一个 `[Service]` 部分，如下所示：
- en: '[PRE17]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: By default, the Apache service can read from or write to any place in the filesystem.
    The `ProtectHome=yes` setting prevents Apache from accessing the `/root/`, `/home/`,
    and the `/run/user/` directories, even if they're set up with world-readable permissions.
    We can also set this to `read-only` if users want to serve web content out of
    their own home directories while preventing Apache from writing to them.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，Apache 服务可以读取或写入文件系统中的任何位置。`ProtectHome=yes` 设置可以防止 Apache 访问 `/root/`、`/home/`
    和 `/run/user/` 目录，即使这些目录设置了全局可读权限。如果用户希望通过自己的主目录提供 Web 内容，同时防止 Apache 写入这些目录，我们还可以将此设置为
    `read-only`。
- en: 'The `ProtectSystem=strict` setting causes Apache to have read-only access to
    the entire filesystem, except for the `/dev/`, `/proc/`, and `/sys/` directories.
    Let''s save the file and restart Apache to see what we''ve got:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: '`ProtectSystem=strict` 设置会使 Apache 只能对整个文件系统进行只读访问，除了 `/dev/`、`/proc/` 和 `/sys/`
    目录。我们保存文件并重启 Apache，看看结果：'
- en: '[PRE18]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Oh, dear. This isn''t good. Let''s look at the status to see what the problem
    could be:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 哎呀，这不好。让我们检查一下状态，看看问题可能出在哪里：
- en: '[PRE19]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'So, Apache wants to write to its log file in the `/var/log/apache2/` directory,
    but it can''t. Let''s change the `ProtectSystem` setting to see if that helps:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，Apache想要写入`/var/log/apache2/`目录中的日志文件，但它不能。让我们更改`ProtectSystem`设置，看看能否解决问题：
- en: '[PRE20]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Setting `ProtectSystem=` to `full` causes Apache to have read-only access to
    the `/boot/`, `/usr/`, and `/etc/` directories. Apache normally doesn''t need
    to write to any of those directories, so it should now work. Let''s try it and
    see:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 将`ProtectSystem=`设置为`full`会使Apache对`/boot/`、`/usr/`和`/etc/`目录具有只读访问权限。通常，Apache不需要写入这些目录，所以现在它应该能正常工作。我们试试看：
- en: '[PRE21]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'There are no error messages, so that''s good. Let''s check the status:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 没有错误信息，这很好。让我们检查一下状态：
- en: '[PRE22]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Yeah, that's good. So, yee-haw! We're golden, baby! But seriously, look in the
    `systemd.exec` man page, and you'll see a lot more security settings that you
    could possibly use.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，这没问题。所以，太棒了！我们搞定了，宝贝！但说实话，看看`systemd.exec`手册页，你会看到更多你可能用得上的安全设置。
- en: Note
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: You can see here that I inadvertently used `sudo` to just look at a service
    status. Using `sudo` with `systemctl` is a force of habit with me, but fortunately,
    it doesn't hurt anything if I use it when it's not needed.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以看到，我不小心使用了`sudo`来查看服务状态。习惯性地在使用`systemctl`时加上`sudo`，但幸运的是，即使在不需要时使用它也不会造成任何问题。
- en: 'Just for fun, let''s add in a few more security options, and then check the
    security status again. This time, we''ll make our `[Service]` section look like
    this:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 仅为好玩，我们再添加一些安全选项，然后再次检查安全状态。这次，我们会让我们的`[Service]`部分看起来像这样：
- en: '[PRE23]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: I'll leave it to you to read about these new parameters in the `systemd.exec`
    man page.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 我留给你去阅读这些新参数的`systemd.exec`手册页。
- en: Once you've finished the edit, restart Apache to ensure that it will start properly.
    Then, run `systemd-analyze security apache2.service` again. You should see that
    the overall security score looks somewhat better than it did before.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 编辑完成后，重新启动Apache，确保它能正常启动。然后，再次运行`systemd-analyze security apache2.service`。你应该会看到整体的安全评分比之前有所提升。
- en: There are a lot more security-related parameters that you can set in your service
    files. Remember though, that most services require that some settings be left
    in an `UNSAFE` mode for them to function correctly. Your best bet is to play around
    with these settings for various services on a virtual machine. That way, you can
    get a good idea of which settings work for the various services. And for goodness'
    sake, thoroughly test any service modifications you want to make before you put
    them into production.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在服务文件中设置更多与安全相关的参数。不过要记住，大多数服务要求某些设置保持在`UNSAFE`模式下才能正常运行。最好的方法是，在虚拟机上尝试不同服务的这些设置。这样，你就能清楚地了解哪些设置适用于不同的服务。而且，为了安全起见，在将任何服务修改投入生产环境之前，务必进行彻底的测试。
- en: Next, let's look at doing full edits for the Secure Shell service.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们来看一下如何对Secure Shell服务进行完全编辑。
- en: Creating a full edit
  id: totrans-91
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 进行完全编辑
- en: 'Doing partial edits works great when all you want to do is add a parameter
    that isn''t already in the service file. But, it doesn''t work if you need to
    delete a parameter, change the value of a parameter, or add a parameter that conflicts
    with some other existing parameter. To do any of these things, you''ll need to
    do a full edit. The other reason for doing full edits is just that you might want
    to have the full file in front of you so that you can see what you''re really
    doing. To do a full edit of the `ssh.service` file, for example, just use the
    `--full` option, like this:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 部分编辑非常适用于当你只需要添加一个服务文件中尚未存在的参数时。但是，如果你需要删除一个参数、更改参数的值，或添加一个与其他现有参数冲突的参数，这时就需要进行完全编辑。进行完全编辑的另一个原因是，你可能希望将整个文件展现在眼前，这样你就能清楚地了解自己在做什么。例如，要对`ssh.service`文件进行完全编辑，只需使用`--full`选项，如下所示：
- en: '[PRE24]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'This time, you''ll see the entire `ssh.service` file, as shown here:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 这次，你将看到整个`ssh.service`文件，如下所示：
- en: '![](img/Figure_5.2_B17491.jpg)'
  id: totrans-95
  prefs: []
  type: TYPE_IMG
  zh: '![](img/Figure_5.2_B17491.jpg)'
- en: Figure 5.2 – Editing a service file with the --full option
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.2 – 使用--full选项编辑服务文件
- en: For our demo this time, let's set up access control for our Secure Shell service.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 这次，我们来设置Secure Shell服务的访问控制。
- en: Pro tip
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 专业提示
- en: If you've been on the Linux scene for a while, you might be familiar with the
    concept of `tcpwrappers`. It's a strange name, but the concept is simple. You
    would just configure the IP addresses that you'd want to allow to access a particular
    network service in the `/etc/hosts.allow` file, and then deny all other IP addresses
    in the `/etc/hosts.deny` file. This still works for Ubuntu, but the Red Hat folk
    have removed `tcpwrappers` from RHEL 8\. So, if you want to configure access control
    on any RHEL 8-type distro, such as the Alma Linux 8 that we're using, you'll need
    to do it by configuring the service files. On Ubuntu, you can use either method.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在Linux圈子里待了有一段时间，可能会对`tcpwrappers`这个概念有所了解。它的名字很奇怪，但概念很简单。你只需要在`/etc/hosts.allow`文件中配置希望允许访问特定网络服务的IP地址，然后在`/etc/hosts.deny`文件中拒绝所有其他IP地址。这个方法在Ubuntu中依然有效，但Red
    Hat在RHEL 8中已移除`tcpwrappers`。所以，如果你想在任何RHEL 8类型的发行版上配置访问控制（比如我们使用的Alma Linux 8），你需要通过配置服务文件来实现。在Ubuntu上，你可以使用任意一种方法。
- en: 'So, let''s say that you want to allow SSH logins to your server from only one
    particular desktop machine. To do that, we''ll use the `IPAddressAllow=` and the
    `IPAddressDeny=` parameters in the `[Service]` section of the `ssh.service` file.
    (Of course, that would be the `sshd.service` file if you want to try this on the
    Alma Linux machine.) Open the file for editing as I''ve just shown you and add
    two lines to the end of the `[Service]` section, using the IP address of your
    own host machine in the `IPAddressAllow=` line. The lines should look something
    like this:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你只想允许来自一台特定桌面机器的SSH登录。为此，我们将在`ssh.service`文件的`[Service]`部分使用`IPAddressAllow=`和`IPAddressDeny=`参数。（当然，如果你想在Alma
    Linux机器上尝试，应该是`sshd.service`文件。）像我刚才展示的那样打开文件进行编辑，并在`[Service]`部分的末尾添加两行，使用你自己主机的IP地址填写`IPAddressAllow=`行。这两行应该像这样：
- en: '[PRE25]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'The whole file should now look something like this:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 整个文件现在应该看起来像这样：
- en: '![](img/Figure_5.3_B17491.jpg)'
  id: totrans-103
  prefs: []
  type: TYPE_IMG
  zh: '![](img/Figure_5.3_B17491.jpg)'
- en: Figure 5.3 – The ssh.service file after editing
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.3 - 编辑后的ssh.service文件
- en: If you just insert the `IPAddressAllow=` line and don't insert the `IPAddressDeny=`
    line, you'll find that nothing gets blocked. So, any time you want to set up an
    access whitelist, you'll need to use both of these lines together.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你只插入`IPAddressAllow=`行，而不插入`IPAddressDeny=`行，你会发现没有任何东西被阻止。因此，每当你想设置访问白名单时，都需要同时使用这两行。
- en: Save the file and do `sudo systemctl daemon-reload`. Then, restart or reload
    the Secure Shell service. Assuming that you used the correct IP address for your
    host machine, you should be able to log in via SSH. To really test this feature
    out, edit the file again, and use an incorrect IP address for your host. This
    time, you should be blocked from doing an SSH login. Note though, that you won't
    have to do another `daemon-reload` command. This new setting will take effect
    immediately upon saving the file. So, if you're doing this remotely, you will
    get locked out if you've entered an incorrect IP address for your host. In real
    life, you'd have to fix it by entering the server room and configuring things
    correctly from the server's local terminal.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 保存文件并执行`sudo systemctl daemon-reload`。然后，重启或重新加载安全外壳服务。如果你使用了正确的主机IP地址，你应该能够通过SSH登录。为了真正测试这个功能，再次编辑文件，并使用错误的主机IP地址。这次，你应该会被阻止进行SSH登录。不过要注意，你不需要再次执行`daemon-reload`命令。这个新设置在保存文件后会立即生效。因此，如果你在远程操作，并且输入了错误的主机IP地址，你将会被锁定。在实际操作中，你需要进入服务器机房，从服务器的本地终端正确配置。
- en: 'When you do a full edit, a complete new modified copy of the original service
    file will get saved in the `/etc/systemd/system/` directory, as we can see here:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 当你进行完整编辑时，修改后的原始服务文件副本将被保存到`/etc/systemd/system/`目录，如下所示：
- en: '[PRE26]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: As long as this file exists, it will always override the original file in the
    `/lib/systemd/system/` directory.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 只要这个文件存在，它将始终覆盖`/lib/systemd/system/`目录中的原始文件。
- en: Next, let's look at creating a brand new service.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们来看一下如何创建一个全新的服务。
- en: Creating a new service
  id: totrans-111
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建一个新服务
- en: 'To create a brand new service from scratch, use the `--force` and `--full`
    options together, like this:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 要从头开始创建一个全新的服务，使用`--force`和`--full`选项组合，如下所示：
- en: '[PRE27]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: This will create a new service file in the `/etc/systemd/system/` directory,
    just as we saw previously.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 这将在`/etc/systemd/system/`目录下创建一个新的服务文件，正如我们之前看到的那样。
- en: 'For this demo, we''ll create a service that will place a periodic timestamp
    into our system log file. Our `timestamp.service` file will look like this:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个演示中，我们将创建一个服务，将定期的时间戳写入我们的系统日志文件。我们的 `timestamp.service` 文件将如下所示：
- en: '[PRE28]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Here, we see the `RestartSec=` parameter, which we haven't seen before. This
    works with the `Restart=` line and just says to wait for the designated number
    of seconds before restarting a crashed service. Here, we're saying to wait for
    20 seconds. We don't see a `Type=` line here, because we don't need it. Without
    this line, `systemd` will just go with the default of `Type=simple`, which is
    what we want. (I'll leave it to you to read about the `simple` `Type` in the `systemd.service`
    man page.)
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，我们看到 `RestartSec=` 参数，这是我们以前没有见过的。它与 `Restart=` 行一起工作，表示在重启崩溃的服务之前等待指定的秒数。在这里，我们设定等待
    20 秒。我们没有看到 `Type=` 行，因为我们不需要它。如果没有这一行，`systemd` 会使用默认的 `Type=simple`，这正是我们需要的。（我留给你去阅读
    `systemd.service` 手册页中的 `simple` `Type` 部分。）
- en: 'Next, we''ll create the `timestamp.sh` script, which will place a timestamp
    into the system log file every 60 seconds. Let''s make it look like this:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将创建 `timestamp.sh` 脚本，该脚本每 60 秒将时间戳写入系统日志文件。让我们将它做成这样：
- en: '[PRE29]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: As you can see, it's just a simple `while` loop that pipes the current time
    into the `systemd-cat` utility every 60 seconds. In turn, `systemd-cat` sends
    the `timestamp` message to the system log file. The `-p info` option marks the
    message with an `info` level priority.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，这只是一个简单的 `while` 循环，它每隔 60 秒将当前时间传递给 `systemd-cat` 工具。然后，`systemd-cat`
    将 `timestamp` 消息发送到系统日志文件。`-p info` 选项将该消息标记为 `info` 级别的优先级。
- en: 'Next, make the script file executable, and copy it to the `/usr/local/bin/`
    directory. Then, start the service:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，使脚本文件可执行，并将其复制到 `/usr/local/bin/` 目录。然后，启动服务：
- en: '[PRE30]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: You can enable the service if you really want to, but for now, we don't need
    to.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你真的想启用该服务，可以启用它，但目前我们不需要它。
- en: 'The status should look like this:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 状态应该如下所示：
- en: '[PRE31]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'To see the timestamps in the log file, do:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 要在日志文件中查看时间戳，执行以下操作：
- en: '`donnie@ubuntu20-04:~$ journalctl -xe`'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: '`donnie@ubuntu20-04:~$ journalctl -xe`'
- en: Or, you can see them getting added in real time by doing `sudo tail -f /var/log/syslog`
    on the Ubuntu machine, or `sudo tail -f /var/log/messages` on the Alma machine.
    When you've seen enough, just do *Ctrl* + *C* to quit.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，你可以通过在 Ubuntu 机器上执行 `sudo tail -f /var/log/syslog`，或在 Alma 机器上执行 `sudo tail
    -f /var/log/messages` 来实时查看它们的添加情况。当你看到足够的信息时，只需按 *Ctrl* + *C* 退出。
- en: Changing the default systemd editor
  id: totrans-129
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 更改默认的 systemd 编辑器
- en: So far, I've been showing you how to do all of this in the nano text editor,
    which is the default `systemd` editor for most modern Linux distros. But, what
    if you don't like nano, and would prefer to use something else? Let's say that
    Vim is your favorite text editor, and you want to use it instead of nano.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我一直在展示如何在 nano 文本编辑器中完成这些操作，nano 是大多数现代 Linux 发行版的默认 `systemd` 编辑器。但是，如果你不喜欢
    nano，而想使用其他编辑器呢？假设你最喜欢的文本编辑器是 Vim，你想用它来替代 nano。
- en: 'One way to use an alternate text editor is to specify the alternate editor
    each time you run a `systemctl edit` command, like this:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 使用替代文本编辑器的一种方法是每次运行 `systemctl edit` 命令时指定替代编辑器，像这样：
- en: '[PRE32]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: That works, but doing it every time you want to run a `systemctl edit` command
    could get a bit tiresome. Fortunately, changing the default editor is easy, once
    you know how to do it.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 这样可以，但每次运行 `systemctl edit` 命令时都这样做可能会有点麻烦。幸运的是，一旦你知道如何操作，修改默认编辑器非常简单。
- en: 'First, edit the `.bashrc` file that''s in your own home directory. At the very
    bottom of the file, add this line:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，编辑位于你个人主目录中的 `.bashrc` 文件。在文件的最底部，添加这一行：
- en: '[PRE33]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'After saving the file, reload the new configuration:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 保存文件后，重新加载新的配置：
- en: '[PRE34]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Next, open the `sudoers` file:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，打开 `sudoers` 文件：
- en: '[PRE35]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Scroll down to where you see the `Defaults` lines, and then add this line:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 向下滚动到你看到 `Defaults` 行的位置，然后添加这一行：
- en: '[PRE36]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Save the file, and try running a `systemctl edit` command. You should now see
    vim instead of nano.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 保存文件后，尝试运行 `systemctl edit` 命令。你现在应该看到 vim 而不是 nano。
- en: We've seen some cool stuff, but we're just getting started. For the ultimate
    in cool, let's look at using `podman` to automatically create container service
    files for us.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到了一些很酷的东西，但我们才刚刚开始。为了达到极致的酷，我们来看看如何使用 `podman` 自动为我们创建容器服务文件。
- en: Creating a new container service with podman
  id: totrans-144
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 podman 创建新的容器服务
- en: Containers have been around for a long time, but they never became all that
    popular until Docker arrived on the scene with its new container management system.
    The original Docker system is cool, all right. But, it has some shortcomings,
    especially with security. For that reason, the good folk at Red Hat developed
    their own Docker replacement, which they call `podman`. `podman` comes with greatly
    enhanced security, and with cool features that aren't in Docker. The only problem
    is that `podman` is still only available on RHEL-type and Fedora distros, and
    everyone else still uses Docker. So, we'll perform these demos on the Alma Linux
    machine.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 容器技术已经存在很长时间了，但直到 Docker 推出了其新的容器管理系统，容器才变得非常流行。原始的 Docker 系统确实很酷，但它有一些不足，尤其是在安全性方面。为此，Red
    Hat 的好心人开发了自己的 Docker 替代品，叫做 `podman`。`podman` 提供了大大增强的安全性，并且具备 Docker 中没有的酷功能。唯一的问题是，`podman`
    目前仅在 RHEL 类型和 Fedora 发行版上可用，而其他所有人仍然使用 Docker。因此，我们将在 Alma Linux 机器上演示这些操作。
- en: 'To install `podman` on your Alma machine, do:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 要在你的 Alma 机器上安装 `podman`，请执行：
- en: '[PRE37]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: This will install the `podman` package along with a shell script that invokes
    `podman` whenever you accidentally type `docker`. (Actually, that might not be
    by accident. You might have shell scripts that invoke `docker` commands, and installing
    the `podman-docker` package will prevent you from having to modify them to use
    `podman` commands.) To avoid confusion, I'll just be showing you `podman` commands
    in this demo.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 这将安装 `podman` 包，并附带一个 shell 脚本，任何时候你不小心输入 `docker` 时，它会调用 `podman`。（实际上，这可能不是偶然的。你可能有一些
    shell 脚本会调用 `docker` 命令，安装 `podman-docker` 包将避免你修改它们以使用 `podman` 命令。）为了避免混淆，接下来的演示中，我将只展示
    `podman` 命令。
- en: The `podman` utility normally doesn't need root privileges, which is one of
    its advantages over Docker. But, in order to make this work, we'll need to create
    our Docker container under the root user account. We can do that either by going
    to the root user shell and doing everything there or by staying in the normal
    user shell and prefacing the `podman` commands with `sudo`. Since I normally like
    to avoid going to the root shell unless I absolutely have to, we'll do this with
    sudo.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: '`podman` 工具通常不需要管理员权限，这是它相对于 Docker 的一个优势。但是，为了使其正常工作，我们需要在 root 用户账户下创建 Docker
    容器。我们可以通过进入 root 用户 shell 来完成这项操作，也可以在普通用户 shell 中执行 `sudo` 来运行 `podman` 命令。由于除非必要，我通常不喜欢进入
    root shell，因此我们将使用 `sudo` 来执行。'
- en: 'Let''s create a `wordpress` container, like this:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一个 `wordpress` 容器，像这样：
- en: '[PRE38]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: WordPress is a free open source blogging platform. Here, we're running a `wordpress`
    container in `detached`, or `background`, mode with the `-d` switch. Instead of
    exposing the default port `80` to the network, we're exposing port `8080`. (Note
    that if this fails to start, you might already have something listening on port
    `8080`. If that's the case, try again with another port.) The `--name` switch
    sets the container name that we'll soon be using in the command to create the
    service file.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: WordPress 是一个免费的开源博客平台。在这里，我们以 `detached`（后台）模式运行一个 `wordpress` 容器，并使用 `-d`
    参数。我们没有将默认的 `80` 端口暴露给网络，而是暴露了 `8080` 端口。（请注意，如果启动失败，可能是因为端口 `8080` 已经有其他应用在监听。如果是这种情况，请尝试使用其他端口。）`--name`
    参数设置了容器的名称，我们稍后将在命令中使用该名称来创建服务文件。
- en: 'We''ll verify that it''s running with `sudo podman ps`:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将通过 `sudo podman ps` 来验证它是否正在运行：
- en: '[PRE39]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'You can also try to access WordPress from your host machine''s web browser,
    but you''ll first need to open port `8080/tcp` on the Alma machine''s firewall,
    like this:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以尝试从主机的网页浏览器访问 WordPress，但你首先需要在 Alma 机器的防火墙上打开 `8080/tcp` 端口，方法如下：
- en: '[PRE40]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Then, go to the web browser of your host machine and navigate to port `8080`
    of the IP address of your Alma machine. The URL should look something like this:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，打开主机的网页浏览器，访问 Alma 机器的 IP 地址上的 `8080` 端口。URL 应该像这样：
- en: '[http://192.168.0.9:8080/](http://192.168.0.9:8080/)'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: '[http://192.168.0.9:8080/](http://192.168.0.9:8080/)'
- en: This should pull up the opening WordPress screen, which will lead you through
    the setup process.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 这应该会弹出 WordPress 的初始界面，引导你完成设置过程。
- en: 'Okay, that''s great, except that when you reboot the machine, the container
    won''t start back up automatically. To fix that, we''ll use the `sudo podman generate
    systemd` command to create the service file, as follows:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，这很棒，但问题是当你重启机器时，容器不会自动启动。为了解决这个问题，我们将使用 `sudo podman generate systemd` 命令来创建服务文件，方法如下：
- en: '[PRE41]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: Note that using `sudo` to do a normal redirection with the `>` symbol doesn't
    work well in the `/etc/` directory, but piping the output into the `tee` utility
    does. As you'll see, the `tee` utility sends output to both the screen and to
    a specified file.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，在 `/etc/` 目录中，使用 `sudo` 进行正常的重定向操作（使用 `>` 符号）效果不好，但将输出通过管道传递到 `tee` 工具就能正常工作。正如你所看到的，`tee`
    工具将输出发送到屏幕和指定的文件。
- en: 'Doing `systemctl cat wordpress-container` will show you the generated service
    file:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 执行 `systemctl cat wordpress-container` 将显示生成的服务文件：
- en: '![](img/Figure_5.4_B17491.jpg)'
  id: totrans-164
  prefs: []
  type: TYPE_IMG
  zh: '![](img/Figure_5.4_B17491.jpg)'
- en: Figure 5.4 – The podman-generated service file
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.4 – podman 生成的服务文件
- en: 'Now, if that isn''t slick, I don''t know what is. Let''s enable the service
    and reboot, just to see what happens:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 如果这还不够顺畅，那我就不知道什么才算顺畅了。让我们启用该服务并重启，看看会发生什么：
- en: '[PRE42]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'When the reboot is complete, a `sudo podman ps` command should show you that
    the container is running:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 重启完成后，执行 `sudo podman ps` 命令应该会显示容器正在运行：
- en: '[PRE43]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: (You'll need to use `sudo` here only because the container is running under
    the root user's account.)
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: （你这里只需要使用 `sudo`，因为容器是在 root 用户账户下运行的。）
- en: 'And of course, `systemctl status` should also show you that it''s running:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，`systemctl status` 也应该显示该服务正在运行：
- en: '[PRE44]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: Okay, that's all good. But, what if you need to create a container service that
    you want to run from your own user account without root privileges? Well, we've
    got you covered there, too. Just create the service file in your own home directory,
    and run it from there.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，一切正常。但是，如果你需要创建一个容器服务，并希望从你自己的用户账户运行，而不需要根权限呢？好吧，我们也为你提供了这种方法。只需在你自己的主目录中创建服务文件，并从那里运行。
- en: 'We''ll start as we did before, except with a different container name and from
    our normal user shell, like so:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将像之前一样开始，只是使用不同的容器名称，并从正常的用户 shell 中启动，如下所示：
- en: '[PRE45]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'We''re using a different network port this time, so that it won''t conflict
    with what we''ve already done. For now, let''s stop the container:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 这次我们使用了不同的网络端口，以避免与之前的设置冲突。现在，让我们停止容器：
- en: '[PRE46]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'We''ll next create a subdirectory within the user''s own normal home directory:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将在用户的正常主目录下创建一个子目录：
- en: '[PRE47]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'We''ll generate the service file, the same as we did before:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将生成服务文件，跟之前一样：
- en: '[PRE48]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'I forgot to point out before that there''s a slight difference in the `[Install]`
    section of these generated service files. Instead of seeing only one target listed,
    you''ll see two, as shown here:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 我之前忘了提到，这些生成的服务文件在 `[Install]` 部分有一个小的不同。你将看到两个目标，而不是只有一个，如下所示：
- en: '[PRE49]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: '`Default.target` is needed whenever you want to run a service from your own
    user account. From here on out, the management commands are mostly the same, except
    that you won''t need `sudo` and you''ll need to use the `--user` option to tell
    `systemd` that the service unit file is in your own home directory. Let''s load
    the new service file, and check the status:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: '`Default.target` 是在你希望从自己的用户账户运行服务时需要使用的。从现在开始，管理命令大致相同，唯一的区别是你不需要使用 `sudo`，而且需要使用
    `--user` 选项来告诉 `systemd` 服务单元文件位于你自己的主目录中。让我们加载新的服务文件并检查状态：'
- en: '[PRE50]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'Let''s enable it and start it, and check the status again:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们启用它并启动，然后再次检查状态：
- en: '[PRE51]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: If you have root privileges, you can open port `9080/tcp` on the firewall and
    access WordPress from an external machine, just as we did before.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你拥有根权限，可以在防火墙上打开端口 `9080/tcp`，并从外部机器访问 WordPress，就像我们之前做的那样。
- en: 'As things stand now, our rootless WordPress service won''t automatically start
    when you boot the machine. But, it will start when you log into the machine and
    will stop when you log out. Fix that by doing the following for your own user
    account:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，我们的无根 WordPress 服务在启动机器时不会自动启动。但它会在你登录机器时启动，并在你登出时停止。通过对你自己的用户账户执行以下操作来修复这个问题：
- en: '[PRE52]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: Now, the container service will remain running when I log out and will automatically
    start when I reboot the machine.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，容器服务将在我登出时继续运行，并且在我重启机器时会自动启动。
- en: Summary
  id: totrans-192
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we looked at how to edit and create service unit files. Along
    the way, we looked at various parameters that we can set, including several security-related
    ones. We also saw the importance of testing any changes that we make to the service
    files before putting them into production. And of course, there's that one thing
    that I keep pointing out, about the importance of knowing how to use the `systemd`
    man pages.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一章中，我们学习了如何编辑和创建服务单元文件。过程中，我们介绍了可以设置的各种参数，包括一些与安全相关的参数。我们还看到，在将任何修改投入生产之前，测试服务文件的更改是非常重要的。当然，我一直强调的那一点是，掌握如何使用`systemd`手册页的重要性。
- en: In the next chapter, we'll look at `systemd` targets. I'll see you there.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章，我们将讨论`systemd`目标。到时候见。
- en: Questions
  id: totrans-195
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: How would you do a partial edit of the `ssh.service` file?
  id: totrans-196
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如何对`ssh.service`文件进行部分编辑？
- en: a) `sudo systemctl edit --partial ssh.service`
  id: totrans-197
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: a) `sudo systemctl edit --partial ssh.service`
- en: b) `sudo systemctl edit ssh.service`
  id: totrans-198
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: b) `sudo systemctl edit ssh.service`
- en: c) `sudo systemedit ssh.service`
  id: totrans-199
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: c) `sudo systemedit ssh.service`
- en: d) `sudo systemedit --partial ssh.service`
  id: totrans-200
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: d) `sudo systemedit --partial ssh.service`
- en: How would you create a brand-new service?
  id: totrans-201
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如何创建一个全新的服务？
- en: a) `sudo systemctl edit --new newservice.service`
  id: totrans-202
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: a) `sudo systemctl edit --new newservice.service`
- en: b) `sudo systemctl edit --full newservice.service`
  id: totrans-203
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: b) `sudo systemctl edit --full newservice.service`
- en: c) `sudo systemctl edit --full --force newservice.service`
  id: totrans-204
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: c) `sudo systemctl edit --full --force newservice.service`
- en: d) `sudo systemctl edit newservice.service`
  id: totrans-205
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: d) `sudo systemctl edit newservice.service`
- en: How would you create an access whitelist for a service?
  id: totrans-206
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如何为服务创建访问白名单？
- en: a) Just insert an `IPAddressAllow=` directive into the `[Service]` section.
  id: totrans-207
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: a) 只需在`[Service]`部分插入`IPAddressAllow=`指令。
- en: b) Insert both an `IPAddressAllow=` directive and an `IPAddressDeny=` directive
    in the `[Service]` section.
  id: totrans-208
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: b) 在`[Service]`部分同时插入`IPAddressAllow=`指令和`IPAddressDeny=`指令。
- en: c) Just insert an `IPAddressAllow=` directive into the `[Unit]` section.
  id: totrans-209
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: c) 只需在`[Unit]`部分插入`IPAddressAllow=`指令。
- en: d) Insert both an `IPAddressAllow=` directive and an `IPAddressDeny=` directive
    in the `[Unit]` section.
  id: totrans-210
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: d) 在`[Unit]`部分同时插入`IPAddressAllow=`指令和`IPAddressDeny=`指令。
- en: Answers
  id: totrans-211
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 答案
- en: b
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: b
- en: c
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: c
- en: b
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: b
- en: Further reading
  id: totrans-215
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: 'How to create `systemd` service files: [https://linuxconfig.org/how-to-create-systemd-service-unit-in-linux](https://linuxconfig.org/how-to-create-systemd-service-unit-in-linux)'
  id: totrans-216
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何创建`systemd`服务文件：[https://linuxconfig.org/how-to-create-systemd-service-unit-in-linux](https://linuxconfig.org/how-to-create-systemd-service-unit-in-linux)
- en: 'Securing and sandboxing applications and services: [https://www.redhat.com/sysadmin/mastering-systemd](https://www.redhat.com/sysadmin/mastering-systemd)'
  id: totrans-217
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 保护和沙盒化应用程序及服务：[https://www.redhat.com/sysadmin/mastering-systemd](https://www.redhat.com/sysadmin/mastering-systemd)
- en: 'Managing containers in `podman` with `systemd` unit files: [https://youtu.be/AGkM2jGT61Y](https://youtu.be/AGkM2jGT61Y)'
  id: totrans-218
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`systemd`单元文件管理`podman`容器：[https://youtu.be/AGkM2jGT61Y](https://youtu.be/AGkM2jGT61Y)
