- en: '10'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '10'
- en: Error Handling – Oh No! It’s Gone Wrong!
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 错误处理 – 哎呀！出错了！
- en: 'There are, broadly, two types of problems that we encounter when using PowerShell:
    problems that our code encounters and problems with our code. The first type may
    be as simple as a `FileNotFound` message in response to `Get-ChildItem`. The second
    type can be much harder to understand, as it may involve problems related to scope,
    which we saw in [*Chapter 9*](B17600_09.xhtml#_idTextAnchor184), *Don’t Repeat
    Yourself – Functions and Scriptblocks*, or an unexpected divide by zero error.
    We’ll deal with problems that our code encounters in the first half of this chapter,
    and then move on to problems we may find in our code in the second half.'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用 PowerShell 时，我们通常会遇到两种类型的问题：一种是我们的代码遇到的问题，另一种是代码本身存在的问题。第一种类型的问题可能就像在执行
    `Get-ChildItem` 时，出现 `FileNotFound` 消息那样简单。第二种类型的问题则可能更难理解，因为它可能涉及到作用域等问题，正如我们在[*第9章*](B17600_09.xhtml#_idTextAnchor184)《不要重复自己
    – 函数和脚本块》中所看到的，或者是一个意外的除零错误。我们将在本章的前半部分处理代码遇到的问题，然后在后半部分讨论可能出现在代码中的问题。
- en: 'We’ll start by defining what an error is and look at the two types of errors
    our code will encounter: terminating and non-terminating errors. We will explore
    how PowerShell deals with both types, how we can change that behavior, and why
    we might want to. We will then move on to how we can catch errors so that we can
    understand them and code around them.'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从定义什么是错误开始，接着讨论我们的代码可能会遇到的两种错误：终止错误和非终止错误。我们将探讨 PowerShell 如何处理这两种错误，如何改变这种行为，以及为什么我们可能会这样做。然后我们将讨论如何捕获错误，以便我们能够理解它们并围绕它们编写代码。
- en: In the second half of the chapter, we will look at how we can identify the causes
    of errors in our code through the process of debugging and look at some of the
    options available in VS Code to make the process easier.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的后半部分，我们将探讨如何通过调试过程识别代码中的错误原因，并看看 VS Code 中的一些选项，帮助我们简化这个过程。
- en: 'These are the main topics we will cover in this chapter:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 本章我们将覆盖的主要内容：
- en: What is an error?
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 什么是错误？
- en: Understanding error actions
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解错误操作
- en: Catching errors
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 捕获错误
- en: Exploring debugging
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 探索调试
- en: Debugging with VS Code
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 VS Code 进行调试
- en: What is an error?
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 什么是错误？
- en: 'As we’ve seen repeatedly, PowerShell, as with most languages, has its own terminology
    and definitions for common words. **Error** is no exception (except… sometimes
    it is, as we’ll see. That is an extremely funny joke. You’ll laugh later, I promise.).
    An error in PowerShell is, broadly, anything that might produce red text in the
    console. Let’s look at an example. In the console, type the following:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们反复看到的，PowerShell 与大多数语言一样，有其独特的术语和对常见词汇的定义。**错误**也不例外（不过... 有时它是例外，我们稍后会看到。这是一个非常有趣的笑话，我保证你稍后会笑出来。）。在
    PowerShell 中，错误广义上是指任何可能在控制台中产生红色文本的情况。让我们看一个例子。在控制台中，输入以下命令：
- en: '[PRE0]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'We will see a red message saying `Get-ChildItem: cannot find path because it
    does` `not exist`.'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: '我们将看到一条红色消息，显示 `Get-ChildItem: cannot find path because it does` `not exist`。'
- en: PowerShell is an extremely friendly and helpful language. It will always try
    to recover from an error and continue with what it was asked to do. In the preceding
    instance, it was asked to do one thing, couldn’t do it, and delivered a helpful
    error message written in plain language describing why it was unable to do the
    thing we asked for.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: PowerShell 是一种非常友好和有帮助的语言。它会尽力从错误中恢复，并继续执行它被要求做的事情。在之前的实例中，它被要求做一件事，但未能做到，于是它提供了一条帮助性的错误消息，用通俗易懂的语言描述了为什么它无法完成我们要求的操作。
- en: There is a lot of work going on in the background here. The previous error we
    see is not just a text string; it is part of a complex error object that was generated
    when PowerShell couldn’t find the file. There is a lot more information available
    to understand what happened and help us get it working.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，后台有很多工作正在进行。我们看到的上一个错误不仅仅是一个文本字符串；它是一个复杂错误对象的一部分，当 PowerShell 找不到文件时，它会生成这个错误对象。还有很多信息可以帮助我们理解发生了什么，并帮助我们解决问题。
- en: 'The amount of information we see is determined by an automatic variable called
    `$ErrorView`. By default, in PowerShell 7, this variable is set to `ConciseView`,
    and PowerShell displays a short friendly message. When we’re researching on the
    internet, we’ll see that PowerShell can display a lot more information by setting
    the `$ErrorView` variable to the `NormalView` value, as we can see in the following
    screenshot:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 我们看到的信息量由一个自动变量 `$ErrorView` 决定。默认情况下，在 PowerShell 7 中，这个变量设置为 `ConciseView`，PowerShell
    会显示一个简短的友好消息。当我们在互联网上进行研究时，会发现通过将 `$ErrorView` 变量设置为 `NormalView` 值，PowerShell
    可以显示更多的信息，正如我们在以下截图中看到的那样：
- en: '![Figure 10.1 – Changing the $ErrorView variable](img/B17600_10_001.jpg)'
  id: totrans-18
  prefs: []
  type: TYPE_IMG
  zh: '![图 10.1 – 更改 $ErrorView 变量](img/B17600_10_001.jpg)'
- en: Figure 10.1 – Changing the $ErrorView variable
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.1 – 更改 $ErrorView 变量
- en: In the first example, *box 1*, `$ErrorView` was set to the default, `ConciseView`,
    and we only saw a friendly message. In the second example, *box 2*, we’ve changed
    the value of `$errorView` to `NormalView`, and we get additional information telling
    us where the error occurred (`line:1` and `char:1`) and what category of error
    it was (`ObjectNotFound`). `ConciseView` was introduced in PowerShell 7; Windows
    PowerShell continues to use `NormalView` as the default.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一个示例中，*框 1*，`$ErrorView` 被设置为默认的 `ConciseView`，我们只看到了一条友好的消息。在第二个示例中，*框 2*，我们已将
    `$ErrorView` 的值更改为 `NormalView`，并且获得了更多的额外信息，告诉我们错误发生的位置（`line:1` 和 `char:1`）以及它属于哪种类别的错误（`ObjectNotFound`）。`ConciseView`
    是 PowerShell 7 中引入的；Windows PowerShell 仍然使用 `NormalView` 作为默认视图。
- en: 'For the rest of this chapter, let’s set our `$ErrorView` variable to `NormalView`
    by typing the following:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的剩余部分，让我们通过输入以下命令，将 `$ErrorView` 变量设置为 `NormalView`：
- en: '[PRE1]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '`NormalView` still isn’t the whole story, though. To see the entire error object
    that was generated, type this:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，`NormalView` 仍然不是完整的故事。要查看生成的完整错误对象，请输入以下内容：
- en: '[PRE2]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'And we should see something like this:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 我们应该能看到类似下面的内容：
- en: '![Figure 10.2 – The error object](img/B17600_10_002.jpg)'
  id: totrans-26
  prefs: []
  type: TYPE_IMG
  zh: '![图 10.2 – 错误对象](img/B17600_10_002.jpg)'
- en: Figure 10.2 – The error object
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.2 – 错误对象
- en: '`Get-Error` is a PowerShell 7 cmdlet that allows us to access errors stored
    in the `$Error` variable; we won’t find this cmdlet in Windows PowerShell. Each
    error we encounter in a session is written to this variable. It consists of an
    array of error objects, up to a maximum set by the `$MaximumErrorCount` automatic
    variable. By default, this is 256 in PowerShell 7 – hopefully, that’ll be enough.
    We can use `Get-Error` with the `-Newest` parameter followed by an integer to
    get a specified number of errors, starting with the most recent. We can also access
    individual array members using the standard syntax, like this:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: '`Get-Error` 是 PowerShell 7 的一个 cmdlet，允许我们访问存储在 `$Error` 变量中的错误；我们在 Windows
    PowerShell 中找不到这个 cmdlet。每个在会话中遇到的错误都会写入这个变量。它由一组错误对象组成，最多可以达到由 `$MaximumErrorCount`
    自动变量设置的最大值。默认情况下，在 PowerShell 7 中，这个值是 256——希望这个数量足够用。我们可以使用 `Get-Error` 并加上 `-Newest`
    参数，后跟一个整数，来获取指定数量的错误，从最近的错误开始。我们也可以使用标准语法访问数组的单个成员，如下所示：'
- en: '[PRE3]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: This will get the most recent error – this is how we have to do it in Windows
    PowerShell.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 这将获取最新的错误——在 Windows PowerShell 中，我们必须这样做。
- en: Not every error we encounter will have a friendly message associated with it.
    Sometimes we will just see the error code, which is highlighted in the box indicated
    in the previous screenshot. This code is usually either 10 decimal digits, as
    in the screenshot, starting with `-2`, or it may be hexadecimal, in which case
    it will start with `0x`, followed by 8 characters. This frequently happens with
    networking errors.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 不是每个我们遇到的错误都有一个友好的消息。有时我们只会看到错误代码，如之前截图中的框中所示。这个代码通常是 10 位数字，如截图中所示，从 `-2` 开始，或者可能是十六进制的，在这种情况下它会以
    `0x` 开头，后面跟着 8 个字符。这种情况常见于网络错误。
- en: 'The code is quite cryptic, but luckily there is a tool we can use to decipher
    it, called `err.exe`. It is available as a free download on the Microsoft website;
    just do a search for `err.exe`. Once it is downloaded, we don’t need to install
    it; we can just run it as it is from the PowerShell console or from Command Prompt,
    like this:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 代码相当难懂，但幸运的是，我们有一个工具可以用来解码它，叫做`err.exe`。它可以在微软官网上免费下载；只需搜索`err.exe`即可。下载后，我们无需安装它；只需在
    PowerShell 控制台或命令提示符中直接运行即可，如下所示：
- en: '![Figure 10.3 – Running err.exe](img/B17600_10_003.jpg)'
  id: totrans-33
  prefs: []
  type: TYPE_IMG
  zh: '![图 10.3 – 运行 err.exe](img/B17600_10_003.jpg)'
- en: Figure 10.3 – Running err.exe
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.3 – 运行 err.exe
- en: As we can see, the output is only slightly less cryptic, and can be highly context-specific;
    in this case, if I received the code `0x80010002`, as seen in *Figure 10**.3*,
    while I was trying to open a file over a network, I would interpret that as `ERROR_FILE_NOT_FOUND`.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，输出信息仅稍微少一些晦涩，并且高度依赖于上下文；在这种情况下，如果我收到代码`0x80010002`，如*图 10.3*所示，在我尝试通过网络打开文件时，我会将其解释为`ERROR_FILE_NOT_FOUND`。
- en: 'Now we have a better understanding of what an error is, let’s look at the two
    types of errors we will encounter with PowerShell: terminating and non-terminating.'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们对错误有了更好的理解，接下来让我们看一下在 PowerShell 中会遇到的两种错误类型：终止性错误和非终止性错误。
- en: Terminating and non-terminating exceptions and errors
  id: totrans-37
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 终止性和非终止性异常与错误
- en: 'Programming languages have the concept of an **exception**: an anomalous condition
    requiring special handling. In general, when a piece of code encounters an exception,
    it stops what it is doing and switches to executing its exception handler: a function
    or subroutine that records what has gone wrong. For most languages, an error is
    an exception, and an exception results in an error.'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 编程语言有一个**异常**的概念：需要特殊处理的异常情况。通常，当一段代码遇到异常时，它会停止正在执行的任务，并切换到执行异常处理器：一个记录错误的函数或子程序。对于大多数语言来说，错误就是异常，异常也意味着错误。
- en: 'PowerShell is unusual in that an error isn’t always an exception (although
    an exception is always an error). PowerShell will attempt to recover from errors;
    it will try to continue what it was doing rather than stop dead. It recognizes
    two types of error: terminating and non-terminating. Terminating errors are the
    same as exceptions. PowerShell will output the error and stop what it was doing.
    Non-terminating errors mean PowerShell will record the error and then carry on
    if possible (unless we tell it otherwise).'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: PowerShell 的一个不同之处在于，错误并不总是异常（尽管异常总是错误）。PowerShell 会尝试从错误中恢复；它会尽量继续执行它正在做的事情，而不是直接停止。它识别两种类型的错误：终止性错误和非终止性错误。终止性错误与异常相同。PowerShell
    会输出错误信息并停止正在做的事情。非终止性错误意味着 PowerShell 会记录错误并在可能的情况下继续执行（除非我们告诉它停止）。
- en: PowerShell exceptions versus .NET exceptions
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: PowerShell 异常与 .NET 异常
- en: 'So, this can be confusing, and much of the information available on this is
    more so (at least, it confuses me). For instance, Don Jones, in *Learn Windows
    PowerShell in a Month of Lunches*, explains it as I have here: non-terminating
    errors are not exceptions. However, Bruce Payette, in *Windows PowerShell in Action*,
    says that every PowerShell error is an exception, both terminating and non-terminating.
    Both authors (and their books) are brilliant. I’d hate to say one is right and
    the other wrong; luckily, I don’t have to. A careful reading of pages 532, 543,
    and 546 of *Windows PowerShell in Action* suggests the following.'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，这可能会让人感到困惑，而且有关这方面的信息也常常更令人困惑（至少对我来说是这样）。例如，Don Jones 在《*Learn Windows PowerShell
    in a Month of Lunches*》中像我在这里解释的一样，认为非终止性错误不是异常。然而，Bruce Payette 在《*Windows PowerShell
    in Action*》中表示，所有 PowerShell 错误都是异常，包括终止性和非终止性错误。这两位作者（及其书籍）都很出色。我不想说一个是对的，另一个是错的；幸运的是，我不必这么做。仔细阅读《*Windows
    PowerShell in Action*》的第532、543和546页，可以得出以下结论。
- en: Every time PowerShell records an error, there is an underlying .NET exception.
    Remember, though, that PowerShell sits on top of .NET, and for a .NET exception
    to be an exception for PowerShell, then it would have to stop PowerShell and start
    an exception handler function. Non-terminating errors do not stop PowerShell,
    and the exception handling functions aren’t run, so they’re not exceptions for
    PowerShell, even though they are exceptions for .NET. Clear as mud.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 每次 PowerShell 记录错误时，都有一个底层的 .NET 异常。请记住，PowerShell 是建立在 .NET 之上的，因此要使一个 .NET
    异常成为 PowerShell 的异常，它必须停止 PowerShell 的执行并启动异常处理器函数。非终止性错误不会停止 PowerShell，异常处理函数也不会执行，因此它们对于
    PowerShell 来说不是异常，尽管对于 .NET 来说它们是异常。明白了吗？
- en: 'Let’s illustrate. In the previous section, we looked at the error we received
    when we tried to get information about a non-existent file, by running `Get-ChildItem
    -Name nosuchfile`. Let’s try it again, as part of a pipeline. In my `ch10` directory,
    I have two files: `foo.txt` and `bar.txt`. Let’s see what happens when I run the
    following:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来说明一下。在上一节中，我们查看了尝试获取一个不存在的文件信息时收到的错误，当时我们运行了`Get-ChildItem -Name nosuchfile`。现在我们再试一次，将其作为管道的一部分。在我的`ch10`目录下，我有两个文件：`foo.txt`和`bar.txt`。让我们看看当我运行以下命令时会发生什么：
- en: '[PRE4]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'We can see the results in the following screenshot:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在以下屏幕截图中看到结果：
- en: '![Figure 10.4 – A non-terminating error](img/B17600_10_004.jpg)'
  id: totrans-46
  prefs: []
  type: TYPE_IMG
  zh: '![图 10.4 – 一个非终止性错误](img/B17600_10_004.jpg)'
- en: Figure 10.4 – A non-terminating error
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.4 – 非终止性错误
- en: As we can see, PowerShell gets the details for the first item, `foo.txt`, reports
    an error for the second item, `nosuchfile`, and then continues to get information
    for the third item, `bar.txt`. This is an example of a non-terminating error.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，PowerShell 获取了第一个项 `foo.txt` 的详细信息，报告了第二个项 `nosuchfile` 的错误，然后继续获取第三个项
    `bar.txt` 的信息。这是一个非终止性错误的例子。
- en: 'So, what is a terminating error? This is an error that stops PowerShell altogether
    – an error that will stop a script or pipeline from running. A good example is
    a misspelled cmdlet, such as this:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，什么是终止性错误呢？这是一种会完全停止 PowerShell 的错误——会阻止脚本或管道继续执行的错误。一个很好的例子是拼写错误的 cmdlet，例如：
- en: '![Figure 10.5 – A terminating error](img/B17600_10_005.jpg)'
  id: totrans-50
  prefs: []
  type: TYPE_IMG
  zh: '![图 10.5 – 终止性错误](img/B17600_10_005.jpg)'
- en: Figure 10.5 – A terminating error
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.5 – 终止性错误
- en: Here, I’ve used a non-existent cmdlet, `Get-ChildItems` (remember – PowerShell
    cmdlets are always singular, never plural), and PowerShell has stopped dead in
    its tracks on the first attempt to run the cmdlet. If this were a non-terminating
    error, I would expect to see the error appear three times, once for each filename
    in the pipeline. Instead, we see it once because the pipeline has terminated altogether.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我使用了一个不存在的 cmdlet，`Get-ChildItems`（记住——PowerShell 的 cmdlet 总是单数形式，从不使用复数），PowerShell
    在第一次尝试运行该 cmdlet 时就停止了。如果这是一个非终止性错误，我会期望看到错误出现三次，每次显示管道中的一个文件名。但实际情况是，我们只看到了一次错误，因为管道已经完全终止。
- en: It’s great that PowerShell distinguishes between terminating and non-terminating
    errors; it’s extremely useful in the console environment, but when we’re running
    scripts, we’re unlikely to always be around to see the error flash up on the screen
    and then disappear. When we’re writing scripts, we are going to want to turn our
    non-terminating errors into terminating ones and turn all our errors into exceptions.
    This is so that we can set an exception handler that will do things such as log
    errors to a file. Before we look at how we can handle terminating errors, let’s
    look at how we can turn all our errors into exceptions.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: PowerShell 能够区分终止性错误和非终止性错误，这非常棒；在控制台环境中，它非常有用，但当我们运行脚本时，我们不太可能一直在场看到错误闪现然后消失。编写脚本时，我们希望将非终止性错误转化为终止性错误，并将所有错误转化为异常。这样我们可以设置异常处理程序，进行例如将错误日志记录到文件等操作。在我们学习如何处理终止性错误之前，先来看看如何将所有错误转化为异常。
- en: Understanding error actions
  id: totrans-54
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解错误处理方式
- en: 'There are two easy ways to change the way that PowerShell processes errors:
    the `$ErrorAction` **Preference** variable and the `-ErrorAction` parameter. Let’s
    look at the variable first.'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 有两种简单的方法可以改变 PowerShell 处理错误的方式：`$ErrorAction` **首选项**变量和 `-ErrorAction` 参数。我们先来看一下变量。
- en: The $ErrorActionPreference variable
  id: totrans-56
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '`$ErrorActionPreference` 变量'
- en: 'The `$ErrorActionPreference` automatic variable can be used to alter how PowerShell
    processes errors. By default, it is set to `Continue`, which means it displays
    any error and carries on. These are the more important valid settings for the
    variable:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: '`$ErrorActionPreference` 自动变量可用于更改 PowerShell 处理错误的方式。默认情况下，它设置为 `Continue`，意味着显示任何错误并继续执行。以下是该变量的几个更重要的有效设置：'
- en: '`Break`: This causes PowerShell to enter debug mode when an error occurs. More
    on debug mode in the second half of this chapter.'
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Break`：此选项会在发生错误时使 PowerShell 进入调试模式。关于调试模式的内容将在本章下半部分讲解。'
- en: '`Continue` (default): This displays the error message and continues processing.'
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Continue`（默认）：显示错误信息并继续处理。'
- en: '`Inquire`: This displays the error message and asks for permission to continue
    or stop.'
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Inquire`：此选项会显示错误信息并请求是否继续或停止。'
- en: '`SilentlyContinue`: The error message is not displayed but is added to the
    `$Error` variable. PowerShell continues processing.'
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SilentlyContinue`：错误信息不会显示，但会被添加到 `$Error` 变量中。PowerShell 继续执行。'
- en: '`Stop`: This displays the error message and stops processing. This generates
    an `Action``PreferenceStopException` exception.'
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Stop`：显示错误信息并停止处理。这会生成一个 `Action` `PreferenceStopException` 异常。'
- en: Note that the help document for preference variables (`about_Preference_Variables`)
    states that the variable is only effective for non-terminating errors; this is
    not the case. Changing the variable affects both terminating and non-terminating
    errors, although after a terminating error, `Continue` and `SilentlyContinue`
    will not force the cmdlet or script to continue; it’s still a terminating error.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，关于首选项变量（`about_Preference_Variables`）的帮助文档说明该变量仅对非终止错误有效；但事实并非如此。更改该变量会影响终止和非终止错误，尽管在终止错误之后，`Continue`
    和 `SilentlyContinue` 不会强制 cmdlet 或脚本继续执行；它仍然是一个终止错误。
- en: The `$ErrorActionPreference` variable is scoped, as we would expect. So, while
    the value for the session may be `Continue`, we can set it differently inside
    our scripts. What we must not do, though, is write `$ErrorActionPreference = 'SilentlyContinue'`
    at the top of the script, no matter how tempting it is, or how many times we see
    people do it on the internet. This suppresses all errors in our script and makes
    it incredibly difficult to troubleshoot when things go wrong, as well as making
    Don Jones (the Don of PowerShell) sad. Instead, if there is a cmdlet in our script
    that we know is going to create a lot of non-terminating errors – for instance,
    a function that tests for active machines using `Test-NetConnection` – we can
    use the `-ErrorAction` common parameter.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: '`$ErrorActionPreference` 变量的作用域正如我们预期的那样。所以，尽管会话的值可能是 `Continue`，我们可以在脚本中设置不同的值。然而，我们绝对不能在脚本顶部写
    `$ErrorActionPreference = ''SilentlyContinue''`，无论它多么诱人，或者我们在互联网上看到多少人这么做。这会抑制脚本中的所有错误，并且当出现问题时非常难以排查，还会让
    Don Jones（PowerShell 的大佬）感到难过。相反，如果脚本中有一个我们知道会产生大量非终止错误的 cmdlet —— 例如，使用 `Test-NetConnection`
    测试活动机器的函数 —— 我们可以使用 `-ErrorAction` 常见参数。'
- en: The -ErrorAction parameter
  id: totrans-65
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '`-ErrorAction` 参数'
- en: 'The `-ErrorAction` parameter is part of the common parameters available to
    all cmdlets and advanced functions. Note this will only change the actions for
    non-terminating errors. In the following screenshot, I have set `$ErrorActionPreference`
    to `Inquire`, by typing `$ErrorActionPreference = Inquire`, and I’m then using
    the `-ErrorAction` parameter to try to change the behavior:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: '`-ErrorAction` 参数是所有 cmdlet 和高级函数可用的常见参数之一。请注意，这只会改变非终止错误的处理方式。在下图中，我将 `$ErrorActionPreference`
    设置为 `Inquire`，通过输入 `$ErrorActionPreference = Inquire`，然后使用 `-ErrorAction` 参数来尝试改变行为：'
- en: '![Figure 10.6 – The -ErrorAction parameter](img/B17600_10_006.jpg)'
  id: totrans-67
  prefs: []
  type: TYPE_IMG
  zh: '![图 10.6 – `-ErrorAction` 参数](img/B17600_10_006.jpg)'
- en: Figure 10.6 – The -ErrorAction parameter
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.6 – `-ErrorAction` 参数
- en: In the first cmdlet, we’re generating a non-terminating error, and the error
    action is `Silently` **Continue**. As we can see, there is no output; the default
    value of `Continue` would display the error in red. In the second cmdlet, we’re
    generating a terminating error by getting the cmdlet name wrong, and the `-ErrorAction`
    parameter is ignored; we get a prompt for action.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一个 cmdlet 中，我们正在生成一个非终止错误，错误动作是 `Silently` **Continue**。如我们所见，没有任何输出；`Continue`
    的默认值会以红色显示错误。在第二个 cmdlet 中，我们通过错误地输入 cmdlet 名称生成了一个终止错误，`-ErrorAction` 参数被忽略；我们会看到一个操作提示。
- en: The `-ErrorAction` parameter has the same values as the `$ErrorPreference` variable.
    Let’s look at the `Ignore` value. This suppresses the error message, as with `SilentlyContinue`.
    Unlike `SilentlyContinue`, the error is not written to the `$Error` variable;
    it is completely ignored.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: '`-ErrorAction` 参数与 `$ErrorPreference` 变量有相同的值。让我们看看 `Ignore` 值。这会像 `SilentlyContinue`
    一样抑制错误消息。与 `SilentlyContinue` 不同的是，错误不会写入 `$Error` 变量，而是完全被忽略。'
- en: Activity 1
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 活动 1
- en: What is going to happen if we run the following cmdlets?
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们运行以下 cmdlet，会发生什么呢？
- en: '**$ErrorActionPreference = “****SilentlyContinue”**'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: '**$ErrorActionPreference = “SilentlyContinue”**'
- en: '**“foo.txt”, “nosuchfile”, “bar.txt” | Get-ChildItem -****ErrorAction “Stop”**'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: '**“foo.txt”，“nosuchfile”，“bar.txt” | Get-ChildItem -ErrorAction “Stop”**'
- en: Now we know how to make all our errors terminating errors, let’s look at why
    we might want to do that.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们知道如何让所有错误成为终止错误，接下来我们来看一下为什么我们可能会这么做。
- en: Catching errors
  id: totrans-76
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 捕获错误
- en: As we’ve discovered, errors contain lots of useful information we can use to
    make our code run smoothly. While `Get-Error` and the `$Error` variable are useful
    for real-time troubleshooting, we need to have another way to deal with errors
    when we are writing scripts.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所发现的，错误包含了大量有用的信息，我们可以利用这些信息让代码运行得更加顺畅。虽然 `Get-Error` 和 `$Error` 变量对于实时故障排除非常有用，但在编写脚本时，我们需要有另一种方式来处理错误。
- en: Try/Catch/Finally
  id: totrans-78
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Try/Catch/Finally
- en: The best way to handle terminating errors in PowerShell is with a `Try`/`Catch`/`Finally`
    statement. This statement allows us to set up alternate courses of action, depending
    on whether or not an error occurred. The statement consists of a mandatory `Try`
    block, which contains code that might generate an error, and then either a `Catch`
    block, a `Finally` block, or both. The `Catch` block will run if the code in the
    `Try` block generates a terminating error; this is our exception handler. The
    code in the `Finally` block will run regardless of whether an error is generated
    or not; this block is used for any code that may be required to clean up after
    the code in the `Try` block. We don’t see many instances of the `Finally` block
    – I never use it. We can write multiple `Catch` blocks to handle different errors.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 处理PowerShell中的终止错误的最佳方式是使用`Try`/`Catch`/`Finally`语句。此语句允许我们根据是否发生错误来设置备用的操作流程。语句包括一个强制性的`Try`块，其中包含可能会生成错误的代码，然后是`Catch`块、`Finally`块或两者。`Catch`块会在`Try`块中的代码生成终止错误时执行；这是我们的异常处理器。`Finally`块中的代码无论是否生成错误都会执行；该块用于在`Try`块中的代码执行后可能需要的任何清理工作。我们很少看到`Finally`块的使用——我自己从不使用它。我们可以编写多个`Catch`块来处理不同的错误。
- en: 'Let’s try an example. In a new file in VS Code, type this:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们试一个例子。在VS Code中创建一个新文件，输入以下内容：
- en: '[PRE5]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: So, here, we’re creating a function called `Get-Files`. We’re starting with
    a `PROCESS` block so that we can feed it input from the pipeline. We open a `Try`
    block on the third line and include the operating code for the function. Next,
    we create a variable called `$filename` and store the current contents of the
    pipeline in it; we might need that for the `Catch` block.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，在这里，我们创建了一个名为`Get-Files`的函数。我们从`PROCESS`块开始，这样就可以从管道中获取输入。我们在第三行打开一个`Try`块，并在其中包含函数的操作代码。接下来，我们创建一个名为`$filename`的变量，并将管道中的当前内容存储到该变量中；我们可能会在`Catch`块中用到它。
- en: Activity 2
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 活动 2
- en: Why can’t we just use the pipeline variable for the `Catch` block? Why do we
    need to store the current pipeline variable in a different variable?
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么我们不能直接使用管道变量作为`Catch`块的内容？为什么我们需要将当前的管道变量存储到另一个变量中？
- en: 'Then, we write the cmdlet that actually does the processing: `Get-ChildItem`.
    We add `-ErrorAction "Stop"` to ensure that all errors are terminating errors;
    remember that the `Catch` block will only execute for an exception.'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们编写实际执行处理的cmdlet：`Get-ChildItem`。我们添加`-ErrorAction "Stop"`以确保所有错误都是终止错误；请记住，`Catch`块仅会在捕获到异常时执行。
- en: Next, we write the `Catch` block itself. We use this block to contain code we
    want to execute if a terminating error is caught; in this case, we just want an
    onscreen error message and the current string, which we wrote to `$filename`.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们编写`Catch`块。我们使用此块来包含在捕获到终止错误时要执行的代码；在这种情况下，我们只想要一个屏幕上的错误消息以及当前字符串（我们将其写入`$filename`）。
- en: Finally, on the last line, we put our three strings in the pipeline and feed
    them to our function.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，在最后一行，我们将三个字符串放入管道并传递给我们的函数。
- en: 'This is how it all looks when we run it:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 运行时，所有内容的效果如下：
- en: '![Figure 10.7 – Using Try/Catch](img/B17600_10_007.jpg)'
  id: totrans-89
  prefs: []
  type: TYPE_IMG
  zh: '![图 10.7 – 使用 Try/Catch](img/B17600_10_007.jpg)'
- en: Figure 10.7 – Using Try/Catch
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.7 – 使用 Try/Catch
- en: As we can see in the preceding terminal, `foo.txt` and `bar.txt` are processed,
    but because `nosuchfile` can’t be found, the `Catch` block action is triggered
    – in this case, writing an error string to the screen with the filename.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在前面的终端中看到的，`foo.txt`和`bar.txt`被处理了，但由于找不到`nosuchfile`，`Catch`块的动作被触发——在这种情况下，将错误字符串和文件名写入屏幕。
- en: Writing multiple `Catch` blocks is relatively easy, but we need to know what
    sort of errors we can expect; specifically, we need to know the full .NET name,
    including the namespace. We can see from *Figure 10**.4* that the .NET exception
    name when we can’t find a file is `ItemNotFoundException`, but we also need the
    namespace; in this case, it’s `System.Management.Automation`. If we don’t know
    what the namespace for an error is, then this one is always worth a try before
    hunting around on the internet.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 编写多个`Catch`块相对容易，但我们需要知道可以预期哪些类型的错误；具体来说，我们需要知道完整的.NET名称，包括命名空间。从*图 10.4*中可以看到，当我们找不到文件时，.NET异常名称是`ItemNotFoundException`，但我们还需要知道命名空间；在这种情况下，它是`System.Management.Automation`。如果我们不知道错误的命名空间，那么在互联网上搜索之前，尝试这个命名空间总是值得的。
- en: 'We put the error type in square brackets between `Catch` and the opening brace
    (`{`), as in the following screenshot:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将错误类型放在`Catch`和大括号（`{`）之间的方括号中，如下图所示：
- en: '![Figure 10.8 – Multiple catch blocks](img/B17600_10_008.jpg)'
  id: totrans-94
  prefs: []
  type: TYPE_IMG
  zh: '![图10.8 – 多个catch块](img/B17600_10_008.jpg)'
- en: Figure 10.8 – Multiple catch blocks
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.8 – 多个catch块
- en: Our first `Catch` block starts on *line 7* and will only trigger if an error
    of the `System.Management.Automation.ItemNotFoundException` type is thrown. All
    other errors will trigger the second `Catch` block. Try it; change the cmdlet
    to `Get-ChildItems` to trigger a `CommandNotFound` error. We should see `an unspecified
    error. boo.` written three times.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的第一个`Catch`块从*第7行*开始，只有当抛出类型为`System.Management.Automation.ItemNotFoundException`的错误时，它才会触发。所有其他错误将触发第二个`Catch`块。试试看；将cmdlet更改为`Get-ChildItems`来触发`CommandNotFound`错误。我们应该看到`an
    unspecified error. boo.`被写入三次。
- en: So, what can we do with `Try`/`Catch`? Well, instead of writing to the screen,
    we can combine it with the logging function we wrote in the last chapter and use
    the `Catch` block to write the error message to the log file.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，我们可以用`Try`/`Catch`做什么呢？其实，我们可以将它与上一章中编写的日志功能结合使用，利用`Catch`块将错误消息写入日志文件，而不是直接写到屏幕上。
- en: We may see on the internet references to the `Trap` statement. This goes back
    all the way to PowerShell v1\. It’s really fiddly to use and has issues with scope,
    and the advice is that we should use the newer `Try`/`Catch` statement instead.
    As with the `Finally` block, I never use the `Trap` statement.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可能会在互联网上看到对`Trap`语句的引用。这个语句可以追溯到PowerShell v1。它真的很难使用，并且在作用域上有问题，因此建议我们应该使用更新的`Try`/`Catch`语句。和`Finally`块一样，我从不使用`Trap`语句。
- en: This almost wraps it up for errors that we might experience running our script;
    just one last scenario to consider. What about things that aren’t errors, but
    stop our script from running?
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 这几乎涵盖了我们在运行脚本时可能遇到的错误；只剩下最后一种情况需要考虑。那就是一些不是错误的事情，但会阻止我们的脚本运行。
- en: 'Consider this code:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑这段代码：
- en: '[PRE6]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: What happens if there are no `.csv` files in the directory? PowerShell won’t
    display an error; it won’t display anything at all. We might see this as an error
    for our script, though. Let’s look at how we can turn this into a terminating
    error.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 如果目录中没有`.csv`文件，会发生什么？PowerShell不会显示错误；它根本不会显示任何内容。然而，我们可能会将其视为脚本中的错误。让我们看看如何将其转换为终止错误。
- en: Creating errors
  id: totrans-103
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建错误
- en: 'A `Throw` statement is used to create a terminating error in a script so that
    the script stops at that point and an exception can be recorded – for instance,
    written to a log. Let’s look at an example. Try this in VS Code:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: '`Throw`语句用于在脚本中创建一个终止错误，使脚本在该点停止并记录异常——例如，写入日志。我们来看一个例子。请在VS Code中尝试：'
- en: '[PRE7]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'This is a pair of `Try`/`Catch` blocks. In the `Try` block, we’re creating
    a variable, `$files`, that contains the results of `Get-ChildItem -Path *.csv`:
    all the `.csv` files in the current directory.'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个`Try`/`Catch`块的配对。在`Try`块中，我们正在创建一个变量`$files`，它包含`Get-ChildItem -Path *.csv`的结果：当前目录下所有的`.csv`文件。
- en: 'Next, we’re running an `if` statement with a condition of `!($files)` – that
    is, if `$files` is `$null`, then carry out the `Throw` statement, which throws
    a `There are no CSV files here!` message. This message is wrapped into an error
    object that is passed to the `Catch` block. We can then display just the message
    by using `Write-Output $_.tostring()`, just as with a real error. Let’s see how
    it looks:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们运行一个`if`语句，条件是`!($files)`——即，如果`$files`是`$null`，则执行`Throw`语句，抛出`There
    are no CSV files here!`消息。这个消息被包装成一个错误对象，并传递到`Catch`块中。然后我们可以像处理真实错误一样，使用`Write-Output
    $_.tostring()`来仅显示消息。让我们看看它的效果：
- en: '![Figure 10.9 – Throwing our own error](img/B17600_10_009.jpg)'
  id: totrans-108
  prefs: []
  type: TYPE_IMG
  zh: '![图10.9 – 抛出我们自己的错误](img/B17600_10_009.jpg)'
- en: Figure 10.9 – Throwing our own error
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.9 – 抛出我们自己的错误
- en: 'As we can see in the red box, the `Throw` statement has produced an error that
    we can handle in exactly the same way as any other terminating error. How we can
    write a non-terminating error is something for the next section of this chapter:
    debugging.'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在红框中看到的，`Throw`语句产生了一个错误，我们可以像处理其他终止错误一样处理它。如何写一个非终止错误是本章下一节——调试的内容。
- en: That’s enough about how we handle errors. In the next section, we’ll take a
    look at debugging our code.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 关于如何处理错误的内容已经足够了。在下一节中，我们将着眼于调试我们的代码。
- en: Exploring debugging
  id: totrans-112
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 探索调试
- en: My code has bugs in it. Your code has bugs in it. We’re not bad coders; all
    code has bugs – we just haven’t found them all yet. According to Coverity (a code-quality
    scanning company), quality-controlled professionally written software has around
    1 defect (or bug) per 1,000 lines of code. Some of these bugs are never found
    because the particular set of rare circumstances where the code doesn’t behave
    as expected (an edge case, in the jargon) hasn’t occurred.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 我的代码有漏洞，你的代码也有漏洞。我们并不是糟糕的程序员，所有代码都有漏洞——只是我们还没有找到所有漏洞。根据Coverity（一家代码质量扫描公司）的数据，经过质量控制的专业编写软件每1,000行代码大约有1个缺陷（或漏洞）。其中一些漏洞永远无法被发现，因为代码没有在那些特定的、罕见的情况下表现不如预期（在行话中叫做边界情况）。
- en: 'Bugs largely consist of two types:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 错误主要分为两种类型：
- en: Syntax errors, where we’ve misspelled a cmdlet or parameter name or missed out
    a closing bracket or quotation mark. Syntax errors are basically typing errors
    – just sometimes we’ve typed the wrong thing thinking it’s the right thing. We’ve
    seen already how using VS Code can help us enormously with this, by color coding,
    syntax checking, code hints, and tab autocomplete.
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 语法错误，我们拼写错了cmdlet或参数名称，或者漏掉了闭括号或引号。语法错误基本上是打字错误——只是我们有时打错了，以为自己打的是对的。我们已经看到，使用VS
    Code可以在这方面大大帮助我们，通过颜色标注、语法检查、代码提示和标签自动完成。
- en: Logic errors, where our understanding of how PowerShell works is insufficient.
    For instance, the problems we might run into with scope would fall into this category.
    Arguably, many of the errors we have already encountered might do as well; a check
    to see whether a file exists before trying to use it would prevent an unexpected
    error from being thrown at all, as we’ve just seen when we discussed the `Throw`
    statement.
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 逻辑错误，我们对PowerShell工作原理的理解不足。例如，我们可能遇到的作用域问题就属于这一类。可以说，许多我们已经遇到的错误也可以归到这一类；例如，在尝试使用文件之前检查文件是否存在，可以防止抛出意外的错误，就像我们在讨论`Throw`语句时看到的那样。
- en: 'In this section, we are going to have a whistlestop tour through the various
    features of PowerShell 7 that can help us find and understand the bugs in our
    code. Before we get into the fun stuff, though, we should remind ourselves of
    the cardinal rules of troubleshooting:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将快速浏览PowerShell 7的各个功能，看看它们如何帮助我们发现并理解代码中的漏洞。不过，在进入有趣的部分之前，我们应该提醒自己故障排除的基本规则：
- en: '`FileNotFound`, don’t start troubleshooting the network connection until we’ve
    gone and confirmed with our own eyes that the file is actually where we think
    it is.'
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`FileNotFound`，在我们亲自确认文件确实位于我们认为的地方之前，不要开始排查网络连接问题。'
- en: '**Read the help file**: Have we got the names of the parameters correct? Does
    the cmdlet do what we think it does?'
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**阅读帮助文件**：我们有没有正确获取参数名称？这个cmdlet是否做我们认为它应该做的事情？'
- en: '**Understand how expectation and reality differ**: We need to read the script
    that we are troubleshooting and understand exactly what we expect it to do and
    what it is actually doing. An example – I have recently been working with a customer
    who was having trouble putting his servers into a quiescent state so that he could
    perform maintenance on them. He believed the script he was using would do that
    for him, but when we examined it, it did something slightly different. There was
    nothing wrong with the script; it was his expectation that needed adjusting.'
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**理解期望与现实的差异**：我们需要阅读正在故障排除的脚本，准确理解我们期望它做什么以及它实际做了什么。举个例子——我最近与一个客户合作，他在将服务器置于静默状态以便进行维护时遇到了问题。他认为自己使用的脚本可以做到这一点，但我们检查后发现它做的事情稍有不同。脚本本身没有问题；需要调整的是他的期望。'
- en: That said, let’s look at how we can provide some script instrumentation.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 话虽如此，让我们来看一下如何为脚本提供一些仪表化支持。
- en: Script instrumentation
  id: totrans-122
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 脚本仪表化
- en: 'Script instrumentation refers to pieces of code embedded within our scripts
    to give us information about what a script is doing and how well it is doing it.
    It can mean the progress bars we see when loading modules, messages to say how
    many times a loop has completed, how many objects were found, or simply how long
    a portion of the script took to run. In this section, we’re going to look at how
    we can use some of the `write-*` cmdlets to provide us with troubleshooting information.
    In [*Chapter 8*](B17600_08.xhtml#_idTextAnchor162), *Writing Our First Script
    – Turning Simple Cmdlets into Reusable Code*, we looked in some detail at the
    `Write-Verbose` cmdlet, and in [*Chapter 3*](B17600_03.xhtml#_idTextAnchor049),
    *The PowerShell Pipeline – How to String Cmdlets Together*, we looked at standard
    streams and the `Write-*` cmdlets associated with each stream. Let’s remind ourselves
    of them here:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 脚本仪表化是指嵌入到脚本中的代码片段，旨在向我们提供关于脚本正在做什么以及它做得如何的信息。它可以是我们在加载模块时看到的进度条，表示循环完成了多少次的信息，找到的对象数量，或者仅仅是脚本的某个部分运行了多长时间。在本节中，我们将讨论如何使用一些
    `write-*` cmdlet 来为我们提供故障排除信息。在 [*第 8 章*](B17600_08.xhtml#_idTextAnchor162) 中，*编写我们的第一个脚本
    – 将简单的 Cmdlet 转换为可重用的代码*，我们详细介绍了 `Write-Verbose` cmdlet，而在 [*第 3 章*](B17600_03.xhtml#_idTextAnchor049)
    中，*PowerShell 管道 – 如何将 Cmdlet 串联起来*，我们讨论了标准流以及与每个流相关的 `Write-*` cmdlet。让我们在这里重新回顾一下它们：
- en: '| **Stream #** | **Description** | **Cmdlet** | **Common Parameters** |'
  id: totrans-124
  prefs: []
  type: TYPE_TB
  zh: '| **流编号** | **描述** | **Cmdlet** | **常用参数** |'
- en: '| 1 | Success | `Write-Output` | None – this is the default output |'
  id: totrans-125
  prefs: []
  type: TYPE_TB
  zh: '| 1 | 成功 | `Write-Output` | 无 – 这是默认输出 |'
- en: '| 2 | Error | `Write-Error` | `-ErrorAction` and `-``ErrorVariable` |'
  id: totrans-126
  prefs: []
  type: TYPE_TB
  zh: '| 2 | 错误 | `Write-Error` | `-ErrorAction` 和 `-ErrorVariable` |'
- en: '| 3 | Warning | `Write-Warning` | `-WarningAction` and `-``WarningPreference`
    |'
  id: totrans-127
  prefs: []
  type: TYPE_TB
  zh: '| 3 | 警告 | `Write-Warning` | `-WarningAction` 和 `-WarningPreference` |'
- en: '| 4 | Verbose | `Write-Verbose` | `-``Verbose` |'
  id: totrans-128
  prefs: []
  type: TYPE_TB
  zh: '| 4 | 冗长 | `Write-Verbose` | `-Verbose` |'
- en: '| 5 | Debug | `Write-Debug` | `-``Debug` |'
  id: totrans-129
  prefs: []
  type: TYPE_TB
  zh: '| 5 | 调试 | `Write-Debug` | `-Debug` |'
- en: '| 6 | Information | `Write-Information` | `-InformationAction` and `-``InformationVariable`
    |'
  id: totrans-130
  prefs: []
  type: TYPE_TB
  zh: '| 6 | 信息 | `Write-Information` | `-InformationAction` 和 `-InformationVariable`
    |'
- en: Table 10.1 – PowerShell streams
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 表 10.1 – PowerShell 流
- en: These streams are intended for different communities; `Write-Output`, `Write-Warning`,
    `Write-Error`, and `Write-Verbose` are intended for the end user of a script.
    `Write-Information` is for script operators, and `Write-Debug` is for developers;
    that’s us.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 这些流针对不同的群体；`Write-Output`、`Write-Warning`、`Write-Error` 和 `Write-Verbose` 是为脚本的最终用户设计的。`Write-Information`
    是为脚本操作员设计的，`Write-Debug` 是为开发人员设计的；也就是我们。
- en: 'We’ve used `Write-Output` and `Write-Verbose` previously; we’ll not cover them
    again here. They provide different levels of information for the person running
    the script. `Write-Error`, however, is new. We can use the `Write-Error` cmdlet
    to produce a non-terminating error, much the same as we can use `Throw` to generate
    a terminating error. In the `Write-Error.ps1` script shown next, I’ve set `$ErrorActionPreference`
    to the default and replaced the `Throw` message we were using previously with
    a `Write-Error` cmdlet:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 我们之前使用过 `Write-Output` 和 `Write-Verbose`；在这里我们不再重新介绍它们。它们为运行脚本的人提供不同层次的信息。然而，`Write-Error`
    是新的。我们可以使用 `Write-Error` cmdlet 来生成一个非终止错误，就像我们使用 `Throw` 来生成终止错误一样。在接下来的 `Write-Error.ps1`
    脚本中，我将 `$ErrorActionPreference` 设置为默认值，并用 `Write-Error` cmdlet 替换了我们之前使用的 `Throw`
    信息：
- en: '![Figure 10.10 – The Write-Error cmdlet](img/B17600_10_010.jpg)'
  id: totrans-134
  prefs: []
  type: TYPE_IMG
  zh: '![图 10.10 – Write-Error cmdlet](img/B17600_10_010.jpg)'
- en: Figure 10.10 – The Write-Error cmdlet
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.10 – Write-Error cmdlet
- en: On *line 4*, I’ve replaced the `Throw` statement with `Write-Error "There are
    no CSV files here"` and added a `Write-Output` cmdlet on *line 9*, inside the
    `try` statement that opens on *line 1*.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 在 *第 4 行*，我用 `Write-Error "没有找到 CSV 文件"` 替换了 `Throw` 语句，并在 *第 9 行* 添加了一个 `Write-Output`
    cmdlet，它位于 *第 1 行* 打开的 `try` 语句内部。
- en: When we run it, we can see that the `Write-Error` cmdlet outputs a message in
    red to the console. We can see that it is a non-terminating error because the
    `Write-Output` cmdlet on *line 9* also runs and produces a `the script continues`
    string in the console. As we can see from the console window in the screenshot,
    the error is also written to the `$Error` variable. We control its display with
    the same `$ErrorActionPreference` variable we saw earlier in the chapter.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们运行它时，可以看到 `Write-Error` cmdlet 会将一条红色信息输出到控制台。我们可以看到它是一个非终止错误，因为 *第 9 行*
    的 `Write-Output` cmdlet 也会执行并在控制台中输出 `脚本继续` 字符串。从截图中的控制台窗口可以看到，错误也被写入了 `$Error`
    变量。我们通过之前在本章看到的同一个 `$ErrorActionPreference` 变量来控制它的显示。
- en: So, when do we use `Write-Error`, and when do we use `Throw`? `Write-Error`
    is when we want to tell the user that something is wrong but let the script continue
    with what it is doing. `Throw` is for when we want the script to stop what it’s
    doing and process the error.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，什么时候使用 `Write-Error`，什么时候使用 `Throw`？`Write-Error` 是当我们想告诉用户某些东西出错了，但让脚本继续执行时使用的；`Throw`
    则是在我们希望脚本停止当前操作并处理错误时使用的。
- en: '`Write-Warning` is a cmdlet that I almost never use. It writes text to the
    warning stream, which is output as yellow text. That’s it. It produces yellow
    text. We can use the `$WarningActionPreference` variable and the `-WarningAction`
    parameter to force the script to stop or silently continue when something is written
    to the warning stream, but it seems to me this is needless redundancy; better
    to use `Write-Error` and write the output to the `$Error` variable as well. Other
    opinions are available.'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: '`Write-Warning` 是我几乎从不使用的一个 cmdlet。它将文本写入警告流，输出为黄色文本。就是这样，它只会产生黄色文本。我们可以使用
    `$WarningActionPreference` 变量和 `-WarningAction` 参数来强制脚本在写入警告流时停止或悄悄继续，但我觉得这是不必要的冗余；最好使用
    `Write-Error` 并将输出写入 `$Error` 变量。其他意见也是存在的。'
- en: '`Write-Information` is generally used to provide details of what our script
    has done; it is useful when we’re working with log aggregators that target the
    information stream, for instance, but I generally don’t bother with it.'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: '`Write-Information` 通常用于提供我们脚本已执行的详细信息；当我们与针对信息流的日志聚合器工作时，它非常有用，但我通常不太使用它。'
- en: '`Write-Debug` is the cmdlet we’re interested in here. This writes to the debug
    stream and can be accessed by making sure our script is an advanced script, using
    the `CmdletBinding` attribute we saw in [*Chapter 8*](B17600_08.xhtml#_idTextAnchor162),
    *Writing Our First Script – Turning Simple Cmdlets into Reusable Code*. If we’ve
    used that attribute, then we have access to the `-``Debug` parameter.'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: '`Write-Debug` 是我们在这里感兴趣的 cmdlet。它写入调试流，并且可以通过确保我们的脚本是高级脚本来访问，使用我们在 [*第 8 章*](B17600_08.xhtml#_idTextAnchor162)
    中看到的 `CmdletBinding` 属性，*编写我们的第一个脚本——将简单的 cmdlet 转化为可重用的代码*。如果我们使用了这个属性，那么我们就可以访问
    `-Debug` 参数。'
- en: 'When should we use `Write-Verbose` and when should we use `Write-Debug`? The
    `Write-Verbose` output is for the user, and we use it to tell the user what the
    script is doing – for example, a message such as loading files when we have a
    loop to process and ingest files from a directory. We use `Write-Debug` inside
    the loop to enumerate the files that we are loading. Consider the following short
    script:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 我们什么时候使用 `Write-Verbose`，什么时候使用 `Write-Debug`？`Write-Verbose` 的输出是为用户提供的，我们使用它来告诉用户脚本正在做什么——例如，当我们有一个循环从目录中处理并加载文件时，可能会显示类似“加载文件”的消息。我们在循环内部使用
    `Write-Debug` 来列出我们正在加载的文件。考虑以下简短脚本：
- en: '![Figure 10.11 – Write-Verbose versus Write-Debug](img/B17600_10_011.jpg)'
  id: totrans-143
  prefs: []
  type: TYPE_IMG
  zh: '![图 10.11 – Write-Verbose 与 Write-Debug](img/B17600_10_011.jpg)'
- en: Figure 10.11 – Write-Verbose versus Write-Debug
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.11 – Write-Verbose 与 Write-Debug
- en: This contains a `Write-Verbose` message on *line 7*, outside the `foreach` loop,
    and a `Write-Debug` message inside the loop on *line 9*. The `Write-Verbose` message
    targets script users and tells them that the script is doing something, even if
    they think it isn’t. The `Write-Debug` message is targeted at us and tells us
    exactly what the script is doing and which file it is processing. `Write-Debug`
    and `Write-Host` actions are controlled by the `$DebugPreference` and `$VerbosePreference`
    variables, respectively. These variables are both set to `SilentlyContinue` by
    default and are overridden by their respective `-Debug` and `-Verbose` switch
    parameters, as we can see in the console output in the preceding screenshot.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 这包含了在 *第 7 行* 外部的 `Write-Verbose` 消息和在 *第 9 行* 循环内的 `Write-Debug` 消息。`Write-Verbose`
    消息面向脚本用户，告诉他们脚本正在做某件事，即使他们觉得它没有做什么。`Write-Debug` 消息则面向我们，精确地告诉我们脚本正在做什么，以及它正在处理哪个文件。`Write-Debug`
    和 `Write-Host` 操作分别受 `$DebugPreference` 和 `$VerbosePreference` 变量的控制。这些变量默认都设置为
    `SilentlyContinue`，并通过各自的 `-Debug` 和 `-Verbose` 开关参数被覆盖，正如我们在前面的控制台输出中看到的那样。
- en: This is all very well, but this only tells us how to deal with errors we anticipate.
    What happens when we don’t know what’s going wrong? We turn to the debugging cmdlets.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 这些都很好，但这只告诉我们如何处理我们预期的错误。那当我们不知道出了什么问题时呢？我们会转向调试 cmdlet。
- en: Debugging cmdlets
  id: totrans-147
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 调试 cmdlet
- en: 'Debugging is hugely complex, and as we dig into it, we quickly come to realize
    we need a pretty good grasp of computer science to understand it thoroughly. That
    doesn’t mean that a working knowledge of the more common cmdlets isn’t incredibly
    useful. In this section, we’re going to look at how to use breakpoints in the
    console when running scripts. A breakpoint will pause a script from running and
    start the built-in PowerShell debugger. The cmdlets that set and manipulate them
    all use the `PSBreakpoint` noun. These are the `PSBreakpoint` cmdlets that we
    should be aware of:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 调试非常复杂，随着我们深入研究，我们很快意识到，要彻底理解它，我们需要对计算机科学有相当好的掌握。这并不意味着对常见 cmdlet 的工作知识不非常有用。在这一节中，我们将讨论如何在控制台中使用断点调试脚本。当断点被触发时，脚本将暂停运行，并启动内置的
    PowerShell 调试器。设置和操作断点的 cmdlet 都使用 `PSBreakpoint` 作为名词。我们应该关注以下这些 `PSBreakpoint`
    cmdlet：
- en: '`Set-PSBreakpoint` enables a breakpoint at a particular line of a script, variable,
    or command'
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Set-PSBreakpoint` 在脚本、变量或命令的特定行启用一个断点'
- en: '`Get-PSBreakpoint` lists the breakpoints that are set in a session'
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Get-PSBreakpoint` 列出会话中设置的所有断点'
- en: '`Remove-PSBreakpoint` removes the specified breakpoint'
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Remove-PSBreakpoint` 移除指定的断点'
- en: '`Disable-PSBreakpoint` stops a breakpoint from triggering but doesn’t remove
    it'
  id: totrans-152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Disable-PSBreakpoint` 停止断点触发，但不移除它'
- en: '`Enable-PSBreakpoint` enables a disabled breakpoint'
  id: totrans-153
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Enable-PSBreakpoint` 启用一个被禁用的断点'
- en: 'Let’s use the previous `debugVsVerbose.ps1` script. If you haven’t already,
    create a new file, save it as `debugVsVerbose.ps1`, and add this content. You’ll
    need to change the `$path` variable to a location where you’ve got some files:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用之前的 `debugVsVerbose.ps1` 脚本。如果你还没有创建，创建一个新的文件，将其保存为 `debugVsVerbose.ps1`，并添加以下内容。你需要将
    `$path` 变量更改为你存放文件的路径：
- en: '[PRE8]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Now, in the console, *not* in VS Code, navigate to the directory where you
    saved it, and type the following:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在控制台中，而**不是**在 VS Code 中，导航到你保存脚本的目录，并输入以下命令：
- en: '[PRE9]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: This tells PowerShell that when the `debugVsVerbose.ps1` script is run, start
    the debugger when the value of the `$file` variable is read. Remember – the variable
    name doesn’t include the preceding dollar sign (`$`).
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 这告诉 PowerShell，当运行 `debugVsVerbose.ps1` 脚本时，在读取 `$file` 变量的值时启动调试器。记住——变量名不包括前面的美元符号（`$`）。
- en: 'Now, run the script to enter debug mode when the variable is read:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，运行脚本以便在读取变量时进入调试模式：
- en: '[PRE10]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Once we are in debug mode, we can check the values of variables, run cmdlets,
    interrogate the call stack, display the script, and do lots of other things. Try
    it; get the current value of `$file` by typing the following:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦进入调试模式，我们可以检查变量的值、运行 cmdlet、查看调用堆栈、显示脚本，并做很多其他操作。试试这个；输入以下命令获取 `$file` 的当前值：
- en: '[PRE11]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'You should see the name of the first file in your location. It should all look
    something like this:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该能看到你所在位置的第一个文件名。它应该看起来像这样：
- en: '![Figure 10.12 – Using the console debugger](img/B17600_10_012.jpg)'
  id: totrans-164
  prefs: []
  type: TYPE_IMG
  zh: '![图 10.12 – 使用控制台调试器](img/B17600_10_012.jpg)'
- en: Figure 10.12 – Using the console debugger
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.12 – 使用控制台调试器
- en: We can see here that in the first command, I set the breakpoint to trigger when
    `$file` is read. The next command is to run the script. The console tells us that
    we’ve hit a variable breakpoint in yellow and tells us where in the script that
    breakpoint is. The prompt then switches to the debug mode prompt `[DBG]`. I type
    `$file`, and the contents of the variable are displayed.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到，在第一条命令中，我设置了一个断点，当读取 `$file` 时触发。下一条命令是运行脚本。控制台会告诉我们已经在黄色中触发了变量断点，并且指出了脚本中断点的位置。然后，提示符切换到调试模式提示符
    `[DBG]`。我输入 `$file`，然后变量的内容被显示出来。
- en: The last command I type is `h`, which is a debugger command, not part of the
    debugging process. Try this.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 我输入的最后一个命令是 `h`，这是一个调试器命令，不是调试过程的一部分。试试看。
- en: 'Type `h` to get the help contents. This will show us a list of the commands
    we can use inside the debugger:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 输入 `h` 以查看帮助内容。它将显示我们可以在调试器中使用的命令列表：
- en: '| **Command** | **Effect** |'
  id: totrans-169
  prefs: []
  type: TYPE_TB
  zh: '| **命令** | **效果** |'
- en: '| --- | --- |'
  id: totrans-170
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `s`, `stepInto` | Single step (step into functions, scripts, and so on).
    |'
  id: totrans-171
  prefs: []
  type: TYPE_TB
  zh: '| `s`, `stepInto` | 单步执行（进入函数、脚本等）。 |'
- en: '| `v`, `stepOver` | Step to the next statement (step over functions, scripts,
    etc.). This will run a function or script block as a single step. |'
  id: totrans-172
  prefs: []
  type: TYPE_TB
  zh: '| `v`, `stepOver` | 执行到下一条语句（跳过函数、脚本等）。这将作为单步执行运行一个函数或脚本块。 |'
- en: '| `o`, `stepOut` | Step out of the current function, script, and so on. |'
  id: totrans-173
  prefs: []
  type: TYPE_TB
  zh: '| `o`, `stepOut` | 跳出当前函数、脚本等。 |'
- en: '| `c`, `continue` | Continue the operation. |'
  id: totrans-174
  prefs: []
  type: TYPE_TB
  zh: '| `c`, `continue` | 继续操作。 |'
- en: '| `q`, `quit` | Stop the operation and exit the debugger. |'
  id: totrans-175
  prefs: []
  type: TYPE_TB
  zh: '| `q`, `quit` | 停止操作并退出调试器。 |'
- en: '| `d`, `detach` | Continue the operation and detach the debugger. |'
  id: totrans-176
  prefs: []
  type: TYPE_TB
  zh: '| `d`, `detach` | 继续操作并分离调试器。 |'
- en: '| `k`, `Get-PSCallStack` | Display the call stack. |'
  id: totrans-177
  prefs: []
  type: TYPE_TB
  zh: '| `k`, `Get-PSCallStack` | 显示调用堆栈。 |'
- en: '|  |  |'
  id: totrans-178
  prefs: []
  type: TYPE_TB
  zh: '|  |  |'
- en: '| `l`, `list` | List the source code for the current script. |'
  id: totrans-179
  prefs: []
  type: TYPE_TB
  zh: '| `l`, `list` | 列出当前脚本的源代码。 |'
- en: '|  | Use `list` to start from the current line, `list <m>` to start from line
    `<m>`, and `list <m> <n>` to list `<n>` lines starting from line `<m>`. |'
  id: totrans-180
  prefs: []
  type: TYPE_TB
  zh: '|  | 使用 `list` 从当前行开始，`list <m>` 从第 `<m>` 行开始，`list <m> <n>` 从第 `<m>` 行开始列出
    `<n>` 行。 |'
- en: '| *Enter* | Repeat the last command if it was `stepInto`, `stepOver`, or `list`.
    |'
  id: totrans-181
  prefs: []
  type: TYPE_TB
  zh: '| *Enter* | 如果上一个命令是 `stepInto`、`stepOver` 或 `list`，则重复该命令。 |'
- en: '| `?`, `h` | Displays the help message. |'
  id: totrans-182
  prefs: []
  type: TYPE_TB
  zh: '| `?`, `h` | 显示帮助信息。 |'
- en: Table 10.2 – PowerShell debugger commands
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 表 10.2 – PowerShell 调试器命令
- en: 'There are a number of commands that help us navigate through our script and
    need a little more explanation, as follows:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 有一些命令可以帮助我们在脚本中导航，需要进一步解释，如下所示：
- en: '`StepOver` will take us to the next statement; if that statement is a function,
    the debugger will just run the function. It won’t work through it line by line.'
  id: totrans-185
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`StepOver` 会带我们到下一条语句；如果该语句是一个函数，调试器只会运行该函数，而不会逐行执行。'
- en: '`StepInto` will take us to the next line of code after the breakpoint and run
    it. It will step into functions and run them line by line, rather than just running
    the function.'
  id: totrans-186
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`StepInto` 会让我们跳到断点之后的下一行代码并执行它。它会进入函数并逐行执行，而不是仅仅运行函数。'
- en: '`StepOut` will complete a function if we are in it and take us to the next
    statement after the function.'
  id: totrans-187
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`StepOut` 会在我们处于某个函数时完成该函数，并将我们带到该函数之后的下一条语句。'
- en: '`Continue` will run the script, either to the end or to the next breakpoint.'
  id: totrans-188
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Continue` 会运行脚本，直到结束或者下一个断点。'
- en: '`Get-PSCallStack` will show us where we are in terms of scripts and functions.
    For instance, if we press the *K* key in our preceding debugger, it will show
    us that we are in the `debugVsVerbose.ps1` script, at *line 9*. If we were in
    a function in a script, it would show us the function name and our location within
    it, followed by the script name and location.'
  id: totrans-189
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Get-PSCallStack` 会显示我们当前在脚本和函数中的位置。例如，如果我们在前面的调试器中按下 *K* 键，它会显示我们当前在 `debugVsVerbose.ps1`
    脚本中的 *第 9 行*。如果我们在脚本中的某个函数内，它会显示函数名及我们在其中的位置，后面跟着脚本名和位置。'
- en: '`List` will show us the script, from whichever line we choose.'
  id: totrans-190
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`List` 会显示我们选择的脚本内容，从任意一行开始。'
- en: Finally, `quit` will exit the debugger.
  id: totrans-191
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后，`quit` 将退出调试器。
- en: In my experience, it’s not very often we’ll need to debug at the command line.
    Generally, debugging is easier in an editor such as VS Code. Let’s have a look
    at how we can do that.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 根据我的经验，我们并不常常需要在命令行中进行调试。通常，在像 VS Code 这样的编辑器中调试要容易得多。让我们看看如何操作。
- en: Debugging with VS Code
  id: totrans-193
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 VS Code 调试
- en: VS Code is probably the best tool for debugging PowerShell. It has all the debugging
    features most people will need, such as remote debugging capabilities for connecting
    to other machines; far too many to cover here. This section is going to cover
    the basics and show how we can use VS Code to perform the basic debugging procedures
    we’ve just covered in the command line.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: VS Code 可能是调试 PowerShell 最好的工具。它具有大多数人需要的调试功能，例如远程调试能力，可以连接到其他机器；功能繁多，无法在此一一列举。本节将涵盖基础内容，并展示如何使用
    VS Code 执行我们刚刚在命令行中介绍的基本调试流程。
- en: 'In a new VS Code session, press *Ctrl* + *Shift* + *P* to open the Command
    Palette and type `exam`; you should see a link for the PowerShell extension examples
    folder, as shown here:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 在新的 VS Code 会话中，按 *Ctrl* + *Shift* + *P* 打开命令面板并输入 `exam`；你应该能看到一个指向 PowerShell
    扩展示例文件夹的链接，如下所示：
- en: '![Figure 10.13 – The PowerShell extension examples folder shortcut](img/B17600_10_013.jpg)'
  id: totrans-196
  prefs: []
  type: TYPE_IMG
  zh: '![图 10.13 – PowerShell 扩展示例文件夹快捷方式](img/B17600_10_013.jpg)'
- en: Figure 10.13 – The PowerShell extension examples folder shortcut
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.13 – PowerShell 扩展示例文件夹快捷方式
- en: In the File Explorer in the left-hand pane, double-click the `DebugTest.ps1`
    file to open it.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 在左侧面板的文件资源管理器中，双击 `DebugTest.ps1` 文件以打开它。
- en: This is quite a short tutorial script that is provided with the PowerShell VS
    Code extension. It consists of two functions, `Do-Work` and `Write-Item`. Neither
    function does very much; `Do-Work` writes two lines of text, using two different
    cmdlets, `Write-Output` and `Write-Host`, and also calls the `Write-Item` function.
    `Write-Item` is a counting function that will count up to the value of the `$Count`
    variable, outputting a string each time, with a short delay between each iteration.
    `Do-Work` is called by the final line of the script, *line 28*.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个相当简短的教程脚本，随 PowerShell VS Code 扩展提供。它由两个函数组成，`Do-Work` 和 `Write-Item`。这两个函数都没有做太多的事情；`Do-Work`
    使用两个不同的 cmdlet，`Write-Output` 和 `Write-Host`，写入两行文本，并且调用了 `Write-Item` 函数。`Write-Item`
    是一个计数函数，它将计数到 `$Count` 变量的值，每次输出一个字符串，并在每次迭代之间有短暂的延迟。`Do-Work` 在脚本的最后一行，*第 28
    行* 被调用。
- en: 'Now, let’s set a breakpoint. Either select *line 15* by clicking on it and
    pressing *F9* or hover the mouse to the left of the line number and click. The
    dull red dot seen in the following screenshot will become bright red:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们设置一个断点。可以通过点击 *第 15 行* 并按 *F9*，或者将鼠标悬停在行号左侧并点击。以下截图中看到的暗红色圆点将变成亮红色：
- en: '![Figure 10.14 – Setting a breakpoint](img/B17600_10_014.jpg)'
  id: totrans-201
  prefs: []
  type: TYPE_IMG
  zh: '![图 10.14 – 设置断点](img/B17600_10_014.jpg)'
- en: Figure 10.14 – Setting a breakpoint
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.14 – 设置断点
- en: 'Now we have a breakpoint set, we can start the debugger. The easiest way to
    do this is to press *Ctrl* + *Shift* + *D*, or we can select **Run** from the
    **View** menu:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经设置了断点，可以开始调试器。最简单的方式是按 *Ctrl* + *Shift* + *D*，或者从 **视图** 菜单中选择 **运行**：
- en: '![Figure 10.15 – The VS Code Debug interface](img/B17600_10_015.jpg)'
  id: totrans-204
  prefs: []
  type: TYPE_IMG
  zh: '![图 10.15 – VS Code 调试界面](img/B17600_10_015.jpg)'
- en: Figure 10.15 – The VS Code Debug interface
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.15 – VS Code 调试界面
- en: The **Debug** view is quite complex, and we’ll need to run the file to the breakpoint
    to see what it does. In the top-left corner, press the green arrow next to **RUN
    AND DEBUG** (number *1* in *Figure 10**.15*). The script will run to the breakpoint
    on *line 15* and stop. Let’s explore the interface. Firstly, we have the run controls
    (*2*). From left to right, these are *continue*, *step over*, *step in*, *step
    out*, *restart*, and *stop*, and are analogous to the controls in the console
    debugger in the last section. If we hover the mouse over them, we can see the
    associated keyboard shortcuts; for instance, we can also continue by pressing
    *F5*. These commands are also available from the **Run** menu in the top toolbar.
    We can see the breakpoint we’ve stopped at highlighted in the script (*3*).
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: '**调试** 视图相当复杂，我们需要运行文件到断点处以查看它的作用。在左上角，按下绿色箭头，位于 **运行和调试** 旁边（图 10.15 中的 *1*）。脚本会运行到
    *第 15 行* 的断点并停止。让我们来探索这个界面。首先，我们有运行控制按钮 (*2*)。从左到右分别是 *继续*、*单步跳过*、*单步进入*、*单步跳出*、*重启*
    和 *停止*，这些与上一节中的控制台调试器中的控制按钮类似。如果将鼠标悬停在它们上面，可以看到相应的快捷键；例如，我们也可以按 *F5* 来继续执行。这些命令也可以通过顶部工具栏中的
    **运行** 菜单找到。我们可以看到在脚本中被高亮显示的断点 (*3*)。'
- en: 'The panel on the left contains some really interesting tools in three windows,
    `Write-Item` function, and the variables are `$i`, `$str`, and `$itemCount`. If
    we hover the mouse over them, we can see the type of the variable. Ironically,
    `Write-Item`. If we click the arrow to the left of the word `$args` and `$MyInvocation`.
    If we expand `$PSBoundParameters`, we can see the parameter associated with `Write-Item`:
    `[itemCount]`.'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 左侧的面板包含一些非常有趣的工具，三个窗口，`Write-Item` 函数，变量有 `$i`、`$str` 和 `$itemCount`。如果我们将鼠标悬停在它们上面，可以看到变量的类型。讽刺的是，`Write-Item`。如果我们点击
    `$args` 和 `$MyInvocation` 左侧的箭头，展开 `$PSBoundParameters`，我们可以看到与 `Write-Item` 相关的参数：`[itemCount]`。
- en: '`$i` variable exists in the local scope, but not in the script or global scopes.'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: '`$i` 变量存在于局部作用域中，但不存在于脚本或全局作用域中。'
- en: Let’s move on to the `<ScriptBlock>`, here. This runs to *line 28* and calls
    the `Do-Work` function, which runs to *line 24* and calls the `Write-Item` function,
    which runs to the breakpoint on *line 15*. This allows us to trace the flow of
    execution through the script. If we click on the items in the call stack, we can
    see that the variable values in the top pane change to show their values in the
    relevant scope. For instance, if we select `Do-Work` instead of `Write-Item`,
    we can see that `$PSBoundParameter` now contains `[workCount]`.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们继续讨论 `<ScriptBlock>`。它运行到 *第28行*，并调用 `Do-Work` 函数，该函数运行到 *第24行* 并调用 `Write-Item`
    函数，该函数运行到 *第15行* 的断点。这使我们能够跟踪脚本的执行流程。如果我们点击调用堆栈中的项，可以看到顶部面板中的变量值发生变化，显示它们在相关作用域中的值。例如，如果我们选择
    `Do-Work` 而不是 `Write-Item`，我们可以看到 `$PSBoundParameter` 现在包含 `[workCount]`。
- en: Finally, we have the `$i*2` and press *Enter*. We should see the expression
    evaluated to `4`. If we now press the `6`.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们输入 `$i*2` 并按 *Enter*。我们应该能看到该表达式的结果是 `4`。如果我们现在按下 `6`。
- en: We’ve barely scratched the surface of debugging with VS Code, but we’ve done
    enough to see how we can use it to understand why our code isn’t behaving as we
    think it should. Debugging is an incredibly complex topic and the best way to
    learn it is to do it. VS Code can make that task a lot easier, though. Let’s summarize
    what we’ve covered in this chapter.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 我们才刚刚触及使用 VS Code 调试的表面，但已经足够让我们了解如何利用它来理解为什么我们的代码没有按照预期运行。调试是一个非常复杂的话题，学习它的最佳方式就是亲自实践。不过，VS
    Code 可以让这一任务变得更加容易。让我们总结一下本章的内容。
- en: Summary
  id: totrans-212
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: We started this chapter by looking at what an error actually is and covered
    some computer science that is applicable to most programming languages. We saw
    how PowerShell is different from many languages by having the concept of terminating
    and non-terminating errors, and how this is a feature of it being an interpreted
    language that sits on top of .NET.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 本章开始时，我们探讨了错误到底是什么，并介绍了一些适用于大多数编程语言的计算机科学知识。我们看到了 PowerShell 与许多语言的不同之处，它有终止错误和非终止错误的概念，并且这也是它作为一种解释型语言、建立在
    .NET 上的一个特性。
- en: Once we understood what errors are, we looked at different ways in which PowerShell
    can handle those errors using the `$ErrorActionPreference` variable and the`-ErrorAction`
    parameter.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们理解了什么是错误，我们就探讨了 PowerShell 使用 `$ErrorActionPreference` 变量和 `-ErrorAction`
    参数处理错误的不同方式。
- en: We saw how we must turn errors into terminating errors so that we can use the
    most common way of trapping errors, the `Try`/`Catch`/`Finally` family of statements.
    We also learned how we can use those statements to provide custom error-handling
    routines.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 我们看到，如何将错误转化为终止错误，以便我们使用最常见的捕捉错误的方式——`Try`/`Catch`/`Finally` 语句族。我们还学习了如何使用这些语句提供自定义的错误处理流程。
- en: Having seen how we work with errors, we learned how we can use a `Throw` statement
    to generate our own terminating errors when we encounter situations that are undesirable
    but don’t naturally cause an error.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 在了解了如何处理错误之后，我们学会了如何使用 `Throw` 语句在遇到不希望发生但不会自然导致错误的情况时生成我们自己的终止错误。
- en: Having explored how we deal with errors, we looked at the art of debugging in
    the second half of the chapter. We started by looking at the concept of script
    instrumentation using `Write-Debug`, and how we can use it to generate insights
    into what our code is doing when we use the `-Debug` parameter to access the debug
    output stream.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 在探讨了如何处理错误后，我们在本章后半部分研究了调试的艺术。我们从使用 `Write-Debug` 进行脚本仪器化的概念开始，了解了如何通过使用 `-Debug`
    参数访问调试输出流，来生成关于代码执行情况的洞察。
- en: We moved on to looking at how we can perform interactive debugging on our scripts
    using debugging cmdlets such as `Set-PSBreakPoint` to access the built-in PowerShell
    debugger. After seeing how difficult that is, we concluded the chapter by looking
    at a far more powerful and much easier way of interactively debugging our scripts
    using VS Code.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 我们继续研究了如何使用调试 cmdlet 进行交互式调试，使用 `Set-PSBreakPoint` 等命令访问内置的 PowerShell 调试器。在了解了这一点的困难后，我们通过使用
    VS Code 这种更强大、更简单的方式来进行交互式调试，结束了本章。
- en: In the next chapter, we’re going to be looking at how we can distribute our
    code so that others can use it in a flexible fashion, by turning our scripts into
    modules. Can’t wait!
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将探讨如何分发我们的代码，以便其他人能以灵活的方式使用它，通过将脚本转化为模块。迫不及待了！
- en: Exercises
  id: totrans-220
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 练习
- en: In terms of running a script, what is the main difference between terminating
    and non-terminating errors?
  id: totrans-221
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在运行脚本时，终止性错误和非终止性错误的主要区别是什么？
- en: How can we access detailed information about errors?
  id: totrans-222
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们如何访问关于错误的详细信息？
- en: What is the purpose of the `-ErrorActionPreference` variable in PowerShell?
  id: totrans-223
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`-ErrorActionPreference` 变量在 PowerShell 中的作用是什么？'
- en: What is the purpose of the `Write-Error` cmdlet in PowerShell?
  id: totrans-224
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`Write-Error` cmdlet 在 PowerShell 中的作用是什么？'
- en: Why might we want to use a `Throw` statement?
  id: totrans-225
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为什么我们可能想要使用 `Throw` 语句？
- en: How can we display debug messages in a script?
  id: totrans-226
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们如何在脚本中显示调试消息？
- en: How can we write debug messages in a script, and who are we writing them for?
  id: totrans-227
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们如何在脚本中编写调试消息，我们是为谁写这些消息的？
- en: What is a breakpoint in PowerShell?
  id: totrans-228
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: PowerShell 中的断点是什么？
- en: What is the purpose of the `stepOver` debugger command?
  id: totrans-229
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`stepOver` 调试命令的作用是什么？'
- en: Further reading
  id: totrans-230
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: 'If debugging interests you, the best way to learn is by doing it. However,
    you can get a head start by reading *The Science of Debugging*, by Matt Telles
    and Yuan Hsieh:'
  id: totrans-231
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果你对调试感兴趣，最好的学习方法就是通过实践。然而，你可以通过阅读Matt Telles和Yuan Hsieh的*调试科学*来提前开始学习：
- en: '*The Science of Debugging*, *Matt Telles* and *Yuan Hsieh*, *2001*, *Coriolis
    Group*'
  id: totrans-232
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '*调试科学*，*Matt Telles* 和 *Yuan Hsieh*，*2001*，*Coriolis Group*'
- en: 'There are some good docs on debugging PowerShell with VS Code that go into
    far more detail:'
  id: totrans-233
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这里有一些关于使用 VS Code 调试 PowerShell 的优秀文档，内容更加详尽：
- en: '[https://devblogs.microsoft.com/scripting/debugging-powershell-script-in-visual-studio-code-part-1/](https://devblogs.microsoft.com/scripting/debugging-powershell-script-in-visual-studio-code-part-1/)'
  id: totrans-234
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://devblogs.microsoft.com/scripting/debugging-powershell-script-in-visual-studio-code-part-1/](https://devblogs.microsoft.com/scripting/debugging-powershell-script-in-visual-studio-code-part-1/)'
- en: '[https://devblogs.microsoft.com/scripting/debugging-powershell-script-in-visual-studio-code-part-2/](https://devblogs.microsoft.com/scripting/debugging-powershell-script-in-visual-studio-code-part-2/)'
  id: totrans-235
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://devblogs.microsoft.com/scripting/debugging-powershell-script-in-visual-studio-code-part-2/](https://devblogs.microsoft.com/scripting/debugging-powershell-script-in-visual-studio-code-part-2/)'
- en: 'And here is a more general link about the VS Code debugger:'
  id: totrans-236
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这是一个关于 VS Code 调试器的更通用链接：
- en: '[https://code.visualstudio.com/Docs/editor/debugging](https://code.visualstudio.com/Docs/editor/debugging)'
  id: totrans-237
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '[https://code.visualstudio.com/Docs/editor/debugging](https://code.visualstudio.com/Docs/editor/debugging)'
- en: 'This article has lots of interesting links, although some of them are a little
    old now:'
  id: totrans-238
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这篇文章有很多有趣的链接，尽管其中一些现在已经有些过时：
- en: '[https://learn.microsoft.com/en-us/powershell/scripting/dev-cross-plat/vscode/using-vscode?view=powershell-7.3](https://learn.microsoft.com/en-us/powershell/scripting/dev-cross-plat/vscode/using-vscode?view=powershell-7.3'
  id: totrans-239
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '[https://learn.microsoft.com/en-us/powershell/scripting/dev-cross-plat/vscode/using-vscode?view=powershell-7.3](https://learn.microsoft.com/en-us/powershell/scripting/dev-cross-plat/vscode/using-vscode?view=powershell-7.3)'
- en: )
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: )
