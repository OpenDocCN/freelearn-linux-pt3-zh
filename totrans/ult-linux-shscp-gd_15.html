<html><head></head><body>
  <div id="_idContainer198" class="Basic-Text-Frame">
    <h1 class="chapterNumber"><span class="koboSpan" id="kobo.1.1">15</span></h1>
    <h1 id="_idParaDest-317" class="chapterTitle"><span class="koboSpan" id="kobo.2.1">Using awk – Part 2</span></h1>
    <p class="normal"><span class="koboSpan" id="kobo.3.1">In this chapter, we’ll continue the discussion about </span><code class="inlineCode"><span class="koboSpan" id="kobo.4.1">awk</span></code><span class="koboSpan" id="kobo.5.1">, but from a different perspective. </span><span class="koboSpan" id="kobo.5.2">In the previous chapter, I showed you the basics of creating one-line </span><code class="inlineCode"><span class="koboSpan" id="kobo.6.1">awk</span></code><span class="koboSpan" id="kobo.7.1"> commands that you can use in your normal shell scripts. </span><span class="koboSpan" id="kobo.7.2">In this chapter, I’ll show you a bit about how to write </span><code class="inlineCode"><span class="koboSpan" id="kobo.8.1">awk</span></code><span class="koboSpan" id="kobo.9.1"> scripts in the </span><code class="inlineCode"><span class="koboSpan" id="kobo.10.1">awk</span></code><span class="koboSpan" id="kobo.11.1"> language. </span><span class="koboSpan" id="kobo.11.2">Topics in this chapter include:</span></p>
    <ul>
      <li class="bulletList"><span class="koboSpan" id="kobo.12.1">Basic </span><code class="inlineCode"><span class="koboSpan" id="kobo.13.1">awk</span></code><span class="koboSpan" id="kobo.14.1"> script construction</span></li>
      <li class="bulletList"><span class="koboSpan" id="kobo.15.1">Using conditional statements</span></li>
      <li class="bulletList"><span class="koboSpan" id="kobo.16.1">Using a </span><code class="inlineCode"><span class="koboSpan" id="kobo.17.1">while</span></code><span class="koboSpan" id="kobo.18.1"> construct and setting variables</span></li>
      <li class="bulletList"><span class="koboSpan" id="kobo.19.1">Using for loops and arrays</span></li>
      <li class="bulletList"><span class="koboSpan" id="kobo.20.1">Using floating point math and </span><code class="inlineCode"><span class="koboSpan" id="kobo.21.1">printf</span></code></li>
      <li class="bulletList"><span class="koboSpan" id="kobo.22.1">Working with multi-line records</span></li>
    </ul>
    <p class="normal"><span class="koboSpan" id="kobo.23.1">If you’re ready, let’s dig in.</span></p>
    <h1 id="_idParaDest-318" class="heading 1"><span class="koboSpan" id="kobo.24.1">Technical Requirements</span></h1>
    <p class="normal"><span class="koboSpan" id="kobo.25.1">You can use either a Fedora or Debian virtual machine for this. </span><span class="koboSpan" id="kobo.25.2">And, as always, you can grab the scripts by doing:</span></p>
    <pre class="programlisting gen"><code class="hljs-con"><span class="koboSpan" id="kobo.26.1">git clone https://github.com/PacktPublishing/The-Ultimate-Linux-Shell-Scripting-Guide.git
</span></code></pre>
    <h1 id="_idParaDest-319" class="heading 1"><span class="koboSpan" id="kobo.27.1">Basic awk Script Construction</span></h1>
    <p class="normal"><span class="koboSpan" id="kobo.28.1">Let’s begin</span><a id="_idIndexMarker952"/><span class="koboSpan" id="kobo.29.1"> with the simplest </span><code class="inlineCode"><span class="koboSpan" id="kobo.30.1">awk</span></code><span class="koboSpan" id="kobo.31.1"> script that you can imagine, which we’ll call </span><code class="inlineCode"><span class="koboSpan" id="kobo.32.1">awk_kernel1.awk</span></code><span class="koboSpan" id="kobo.33.1">. </span><span class="koboSpan" id="kobo.33.2">It looks like this:</span></p>
    <pre class="programlisting gen"><code class="hljs-con"><span class="koboSpan" id="kobo.34.1">/kernel/
</span></code></pre>
    <p class="normal"><span class="koboSpan" id="kobo.35.1">As you’ve likely guessed, this script will look through a specified file to search for all lines that contain the text string </span><code class="inlineCode"><span class="koboSpan" id="kobo.36.1">kernel</span></code><span class="koboSpan" id="kobo.37.1">. </span><span class="koboSpan" id="kobo.37.2">You already know that </span><code class="inlineCode"><span class="koboSpan" id="kobo.38.1">{print $0}</span></code><span class="koboSpan" id="kobo.39.1"> is the default action if no action is specified. </span><span class="koboSpan" id="kobo.39.2">So, this script will print out every line that contains the specified text string. </span></p>
    <p class="normal"><span class="koboSpan" id="kobo.40.1">In actual </span><code class="inlineCode"><span class="koboSpan" id="kobo.41.1">awk</span></code><span class="koboSpan" id="kobo.42.1"> scripts, there’s no need to preface every command with </span><code class="inlineCode"><span class="koboSpan" id="kobo.43.1">awk</span></code><span class="koboSpan" id="kobo.44.1">, and there’s no need to surround the commands with pairs of single quotes, as you have to do when embedding </span><code class="inlineCode"><span class="koboSpan" id="kobo.45.1">awk</span></code><span class="koboSpan" id="kobo.46.1"> commands in normal shell scripts. </span><span class="koboSpan" id="kobo.46.2">I didn’t put a shebang line into this script, so there’s no need to set the executable permission. </span><span class="koboSpan" id="kobo.46.3">Instead, just invoke the script like this:</span></p>
    <pre class="programlisting gen"><code class="hljs-con"><span class="koboSpan" id="kobo.47.1">donnie@fedora:~$ sudo awk -f awk_kernel1.awk /var/log/messages
Jan 11 16:17:55 fedora kernel: audit: type=1334 audit(1705007875.578:35): prog-id=60 op=LOAD
Jan 11 16:18:00 fedora kernel: msr: Write to unrecognized MSR 0x17f by mcelog (pid: 856).
</span><span class="koboSpan" id="kobo.47.2">Jan 11 16:18:00 fedora kernel: msr: See https://git.kernel.org/pub/scm/linux/kernel/git/tip/tip.git/about for details.
</span><span class="koboSpan" id="kobo.47.3">. </span><span class="koboSpan" id="kobo.47.4">. </span><span class="koboSpan" id="kobo.47.5">.
</span><span class="koboSpan" id="kobo.47.6">. </span><span class="koboSpan" id="kobo.47.7">. </span><span class="koboSpan" id="kobo.47.8">.
</span><span class="koboSpan" id="kobo.47.9">Jan 11 17:15:28 fedora kernel: fwupdmgr[1779]: memfd_create() called without MFD_EXEC or MFD_NOEXEC_SEAL set
donnie@fedora:~$
</span></code></pre>
    <p class="normal"><span class="koboSpan" id="kobo.48.1">Sure, that works. </span><span class="koboSpan" id="kobo.48.2">But, wouldn’t you really rather have a stand-alone, executable script? </span><span class="koboSpan" id="kobo.48.3">That’s easy enough to do. </span><span class="koboSpan" id="kobo.48.4">Just add the shebang line, like this:</span></p>
    <pre class="programlisting gen"><code class="hljs-con"><span class="koboSpan" id="kobo.49.1">#!/usr/bin/awk -f
/kernel/
</span></code></pre>
    <p class="normal"><span class="koboSpan" id="kobo.50.1">Then, make the script executable, the same as you would do with normal </span><code class="inlineCode"><span class="koboSpan" id="kobo.51.1">bash</span></code><span class="koboSpan" id="kobo.52.1"> scripts.</span></p>
    <p class="normal"><span class="koboSpan" id="kobo.53.1">There </span><a id="_idIndexMarker953"/><span class="koboSpan" id="kobo.54.1">are two things that I want you to notice about this shebang line. </span><span class="koboSpan" id="kobo.54.2">First, is that I’m using </span><code class="inlineCode"><span class="koboSpan" id="kobo.55.1">/usr/bin/</span></code><span class="koboSpan" id="kobo.56.1"> instead of </span><code class="inlineCode"><span class="koboSpan" id="kobo.57.1">/bin/</span></code><span class="koboSpan" id="kobo.58.1"> as the path to the </span><code class="inlineCode"><span class="koboSpan" id="kobo.59.1">awk</span></code><span class="koboSpan" id="kobo.60.1"> executable. </span><span class="koboSpan" id="kobo.60.2">That’s because I want to make this script portable, so that it will run on Linux, Unix, and Unix-like systems such as FreeBSD and macOS.</span></p>
    <div class="note">
      <p class="normal"><span class="koboSpan" id="kobo.61.1">The </span><code class="inlineCode"><span class="koboSpan" id="kobo.62.1">/bin/</span></code><span class="koboSpan" id="kobo.63.1"> path that you’re used to seeing in shebang lines is an artifact that’s been carried over from older Linux systems. </span><span class="koboSpan" id="kobo.63.2">On current Linux systems, </span><code class="inlineCode"><span class="koboSpan" id="kobo.64.1">/bin/</span></code><span class="koboSpan" id="kobo.65.1"> is a symbolic link that points to </span><code class="inlineCode"><span class="koboSpan" id="kobo.66.1">/usr/bin/</span></code><span class="koboSpan" id="kobo.67.1">. </span><span class="koboSpan" id="kobo.67.2">On older Linux systems, </span><code class="inlineCode"><span class="koboSpan" id="kobo.68.1">/bin/</span></code><span class="koboSpan" id="kobo.69.1"> and </span><code class="inlineCode"><span class="koboSpan" id="kobo.70.1">/usr/bin/</span></code><span class="koboSpan" id="kobo.71.1"> used to be two separate directories, which each contained two separate sets of program files. </span><span class="koboSpan" id="kobo.71.2">That’s no longer the case. </span><span class="koboSpan" id="kobo.71.3">Nowadays, you’ll find the </span><code class="inlineCode"><span class="koboSpan" id="kobo.72.1">awk</span></code><span class="koboSpan" id="kobo.73.1"> executable in </span><code class="inlineCode"><span class="koboSpan" id="kobo.74.1">/usr/bin/</span></code><span class="koboSpan" id="kobo.75.1"> on all Linux systems.</span></p>
      <p class="normal"><span class="koboSpan" id="kobo.76.1">FreeBSD still uses separate </span><code class="inlineCode"><span class="koboSpan" id="kobo.77.1">/bin/</span></code><span class="koboSpan" id="kobo.78.1"> and </span><code class="inlineCode"><span class="koboSpan" id="kobo.79.1">/usr/bin/</span></code><span class="koboSpan" id="kobo.80.1"> directories with different sets of program files. </span><span class="koboSpan" id="kobo.80.2">But, </span><code class="inlineCode"><span class="koboSpan" id="kobo.81.1">awk</span></code><span class="koboSpan" id="kobo.82.1"> is in </span><code class="inlineCode"><span class="koboSpan" id="kobo.83.1">/usr/bin/</span></code><span class="koboSpan" id="kobo.84.1">, and there’s no symbolic link for it in </span><code class="inlineCode"><span class="koboSpan" id="kobo.85.1">/bin/</span></code><span class="koboSpan" id="kobo.86.1">. </span><span class="koboSpan" id="kobo.86.2">So, just use </span><code class="inlineCode"><span class="koboSpan" id="kobo.87.1">#!/usr/bin/awk</span></code><span class="koboSpan" id="kobo.88.1">, and you’ll be good-to-go for most operating systems.</span></p>
    </div>
    <p class="normal"><span class="koboSpan" id="kobo.89.1">The second thing to notice is that I still have to invoke </span><code class="inlineCode"><span class="koboSpan" id="kobo.90.1">awk</span></code><span class="koboSpan" id="kobo.91.1"> with the </span><code class="inlineCode"><span class="koboSpan" id="kobo.92.1">-f</span></code><span class="koboSpan" id="kobo.93.1"> option, which causes </span><code class="inlineCode"><span class="koboSpan" id="kobo.94.1">awk</span></code><span class="koboSpan" id="kobo.95.1"> to read the program file. </span><span class="koboSpan" id="kobo.95.2">If you leave out the </span><code class="inlineCode"><span class="koboSpan" id="kobo.96.1">-f</span></code><span class="koboSpan" id="kobo.97.1">, the script won’t work.</span></p>
    <p class="normal"><span class="koboSpan" id="kobo.98.1">Now that you’ve seen the basic structure of an </span><code class="inlineCode"><span class="koboSpan" id="kobo.99.1">awk</span></code><span class="koboSpan" id="kobo.100.1"> script, let’s look at some </span><code class="inlineCode"><span class="koboSpan" id="kobo.101.1">awk</span></code><span class="koboSpan" id="kobo.102.1"> programming constructs.</span></p>
    <h1 id="_idParaDest-320" class="heading 1"><span class="koboSpan" id="kobo.103.1">Using Conditional Statements</span></h1>
    <p class="normal"><span class="koboSpan" id="kobo.104.1">You’ve</span><a id="_idIndexMarker954"/><span class="koboSpan" id="kobo.105.1"> already been using </span><code class="inlineCode"><span class="koboSpan" id="kobo.106.1">if</span></code><span class="koboSpan" id="kobo.107.1"> constructs without even knowing it. </span><span class="koboSpan" id="kobo.107.2">That’s because you don’t have to explicitly declare them as such. </span><span class="koboSpan" id="kobo.107.3">The simple </span><code class="inlineCode"><span class="koboSpan" id="kobo.108.1">/kernel/</span></code><span class="koboSpan" id="kobo.109.1"> command that you just saw in the </span><code class="inlineCode"><span class="koboSpan" id="kobo.110.1">awk_kernel1.awk</span></code><span class="koboSpan" id="kobo.111.1"> script means that if the </span><em class="italic"><span class="koboSpan" id="kobo.112.1">kernel</span></em><span class="koboSpan" id="kobo.113.1"> string is found on a line, then print that line. </span><span class="koboSpan" id="kobo.113.2">However, </span><code class="inlineCode"><span class="koboSpan" id="kobo.114.1">awk</span></code><span class="koboSpan" id="kobo.115.1"> also offers the whole array of programming constructs that you would expect to see in other languages. </span><span class="koboSpan" id="kobo.115.2">For example, let’s create the </span><code class="inlineCode"><span class="koboSpan" id="kobo.116.1">awk_kernel2.awk</span></code><span class="koboSpan" id="kobo.117.1"> script, which will look like this:</span></p>
    <pre class="programlisting gen"><code class="hljs-con"><span class="koboSpan" id="kobo.118.1">#!/usr/bin/awk -f
{
        if (/kernel/) {
                print $0
        }
}
</span></code></pre>
    <p class="normal"><span class="koboSpan" id="kobo.119.1">This is </span><a id="_idIndexMarker955"/><span class="koboSpan" id="kobo.120.1">somewhat different from what you’re used to seeing in </span><code class="inlineCode"><span class="koboSpan" id="kobo.121.1">bash</span></code><span class="koboSpan" id="kobo.122.1"> scripts, because in </span><code class="inlineCode"><span class="koboSpan" id="kobo.123.1">awk</span></code><span class="koboSpan" id="kobo.124.1"> there’s no need to use </span><code class="inlineCode"><span class="koboSpan" id="kobo.125.1">then</span></code><span class="koboSpan" id="kobo.126.1"> or </span><code class="inlineCode"><span class="koboSpan" id="kobo.127.1">fi</span></code><span class="koboSpan" id="kobo.128.1"> statements. </span><span class="koboSpan" id="kobo.128.2">This is because </span><code class="inlineCode"><span class="koboSpan" id="kobo.129.1">awk</span></code><span class="koboSpan" id="kobo.130.1"> uses C language syntax for its programming constructs. </span><span class="koboSpan" id="kobo.130.2">So, if you’re used to programming in C, rejoice!</span></p>
    <p class="normal"><span class="koboSpan" id="kobo.131.1">Also, note how you need to surround the pattern with a pair of parentheses, and how you have to surround the entire multi-line script with a pair of curly braces. </span><span class="koboSpan" id="kobo.131.2">At any rate, just specify the name and location of your log file when running the script, like this:</span></p>
    <pre class="programlisting gen"><code class="hljs-con"><span class="koboSpan" id="kobo.132.1">donnie@fedora:~$ sudo ./awk_kernel2.awk /var/log/messages
</span></code></pre>
    <p class="normal"><span class="koboSpan" id="kobo.133.1">Now, you’re probably wondering why anyone would want to do the extra typing to create a full-blown </span><code class="inlineCode"><span class="koboSpan" id="kobo.134.1">if</span></code><span class="koboSpan" id="kobo.135.1"> construct when just typing </span><code class="inlineCode"><span class="koboSpan" id="kobo.136.1">/kernel/</span></code><span class="koboSpan" id="kobo.137.1"> will do the job. </span><span class="koboSpan" id="kobo.137.2">Well, it’s so that you can create full-blown </span><code class="inlineCode"><span class="koboSpan" id="kobo.138.1">if. </span><span class="koboSpan" id="kobo.138.2">.else</span></code><span class="koboSpan" id="kobo.139.1"> constructs, like this one in the </span><code class="inlineCode"><span class="koboSpan" id="kobo.140.1">awk_kernel3.awk</span></code><span class="koboSpan" id="kobo.141.1"> script:</span></p>
    <pre class="programlisting gen"><code class="hljs-con"><span class="koboSpan" id="kobo.142.1">#!/usr/bin/awk -f
{
        if ($5 ~ /kernel/) {
                print "Kernel here in Field 5"
        }
        else if ($5 ~ /systemd/) {
                print "Systemd here in Field 5"
        }
        else {
                print "No kernel or systemd in Field 5"
        }
}
</span></code></pre>
    <p class="normal"><span class="koboSpan" id="kobo.143.1">Now, let’s see how many times each type of message shows up in the log file:</span></p>
    <pre class="programlisting gen"><code class="hljs-con"><span class="koboSpan" id="kobo.144.1">donnie@fedora:~$ sudo ./awk_kernel3.awk /var/log/messages | sort | uniq -c
  25795 Kernel here in Field 5
  38580 No kernel or systemd in Field 5
  35506 Systemd here in Field 5
donnie@fedora:~$
</span></code></pre>
    <p class="normal"><span class="koboSpan" id="kobo.145.1">Cool, it works.</span></p>
    <p class="normal"><span class="koboSpan" id="kobo.146.1">For our final </span><code class="inlineCode"><span class="koboSpan" id="kobo.147.1">if</span></code><span class="koboSpan" id="kobo.148.1"> trick, let’s create the </span><code class="inlineCode"><span class="koboSpan" id="kobo.149.1">awk_kernel4.awk</span></code><span class="koboSpan" id="kobo.150.1"> script, like this:</span></p>
    <pre class="programlisting gen"><code class="hljs-con"><span class="koboSpan" id="kobo.151.1">#!/usr/bin/awk -f
{
        if ($5 ~ /kernel/) {
                print "Kernel here in Field 5 on line " NR
        }
        else if ($5 ~ /systemd/) {
                print "Systemd here in Field 5 on line " NR
        }
        else {
                print "No kernel or systemd in Field 5 on line " NR
        }
}
</span></code></pre>
    <p class="normal"><span class="koboSpan" id="kobo.152.1">The </span><a id="_idIndexMarker956"/><span class="koboSpan" id="kobo.153.1">Number of Records (</span><code class="inlineCode"><span class="koboSpan" id="kobo.154.1">NR</span></code><span class="koboSpan" id="kobo.155.1">) built-in variable causes the line numbers to print out along with the messages. </span><span class="koboSpan" id="kobo.155.2">There will be lots of output, so you might want to pipe it into </span><code class="inlineCode"><span class="koboSpan" id="kobo.156.1">less</span></code><span class="koboSpan" id="kobo.157.1">, like this:</span></p>
    <pre class="programlisting gen"><code class="hljs-con"><span class="koboSpan" id="kobo.158.1">donnie@fedora:~$ sudo ./awk_kernel4.awk /var/log/messages | less
</span></code></pre>
    <p class="normal"><span class="koboSpan" id="kobo.159.1">Here’s a sample of the output:</span></p>
    <pre class="programlisting gen"><code class="hljs-con"><span class="koboSpan" id="kobo.160.1">Kernel here in Field 5 on line 468
Systemd here in Field 5 on line 469
Systemd here in Field 5 on line 470
No kernel or systemd in Field 5 on line 471
No kernel or systemd in Field 5 on line 472
No kernel or systemd in Field 5 on line 473
No kernel or systemd in Field 5 on line 474
No kernel or systemd in Field 5 on line 475
No kernel or systemd in Field 5 on line 476
Systemd here in Field 5 on line 477
</span></code></pre>
    <p class="normal"><span class="koboSpan" id="kobo.161.1">Okay, I think</span><a id="_idIndexMarker957"/><span class="koboSpan" id="kobo.162.1"> you get the idea. </span><span class="koboSpan" id="kobo.162.2">Other than the different syntax, it’s really no different from using </span><code class="inlineCode"><span class="koboSpan" id="kobo.163.1">if</span></code><span class="koboSpan" id="kobo.164.1"> in normal </span><code class="inlineCode"><span class="koboSpan" id="kobo.165.1">bash</span></code><span class="koboSpan" id="kobo.166.1"> scripts. </span><span class="koboSpan" id="kobo.166.2">So, let’s move on for a while.</span></p>
    <h1 id="_idParaDest-321" class="heading 1"><span class="koboSpan" id="kobo.167.1">Using a while Construct and Setting Variables</span></h1>
    <p class="normal"><span class="koboSpan" id="kobo.168.1">In this section, I’ll show you two new concepts at once. </span><span class="koboSpan" id="kobo.168.2">You’ll see how to use a </span><code class="inlineCode"><span class="koboSpan" id="kobo.169.1">while</span></code><span class="koboSpan" id="kobo.170.1"> loop, and </span><a id="_idIndexMarker958"/><span class="koboSpan" id="kobo.171.1">how to use </span><code class="inlineCode"><span class="koboSpan" id="kobo.172.1">awk</span></code><span class="koboSpan" id="kobo.173.1"> programming variables. </span><span class="koboSpan" id="kobo.173.2">Let’s begin </span><a id="_idIndexMarker959"/><span class="koboSpan" id="kobo.174.1">with something simple.</span></p>
    <h2 id="_idParaDest-322" class="heading 2"><span class="koboSpan" id="kobo.175.1">Summing Numbers in a Line</span></h2>
    <p class="normal"><span class="koboSpan" id="kobo.176.1">In this scenario, we</span><a id="_idIndexMarker960"/><span class="koboSpan" id="kobo.177.1"> have a file with several lines of numbers. </span><span class="koboSpan" id="kobo.177.2">We want to add the numbers on each line and show the sum for each line. </span><span class="koboSpan" id="kobo.177.3">First, create the input file and make it look something like this </span><code class="inlineCode"><span class="koboSpan" id="kobo.178.1">numbers_fields.txt</span></code><span class="koboSpan" id="kobo.179.1"> file:</span></p>
    <pre class="programlisting gen"><code class="hljs-con"><span class="koboSpan" id="kobo.180.1">38 87 389 3 3432
34 13
38976 38 198378 38 3
3878538 38
38
893 18 3 384 352 3892 10921 10 384
348 35 293
93 1 2
1 2 3 4 5
</span></code></pre>
    <p class="normal"><span class="koboSpan" id="kobo.181.1">This looks like quite a challenging task because each line has a different number of fields. </span><span class="koboSpan" id="kobo.181.2">But, it’s actually quite easy. </span><span class="koboSpan" id="kobo.181.3">Here’s the </span><code class="inlineCode"><span class="koboSpan" id="kobo.182.1">add_fields.awk</span></code><span class="koboSpan" id="kobo.183.1"> script that does the job:</span></p>
    <pre class="programlisting gen"><code class="hljs-con"><span class="koboSpan" id="kobo.184.1">#!/usr/bin/awk -f
{
addend=1
sum=0
while (addend &lt;= NF) {
sum = sum + $addend
addend++
       		      }
print "Line " NR " Sum is " sum
}
</span></code></pre>
    <p class="normal"><span class="koboSpan" id="kobo.185.1">The first thing I’ve done is to initialize the </span><code class="inlineCode"><span class="koboSpan" id="kobo.186.1">addend</span></code><span class="koboSpan" id="kobo.187.1"> and </span><code class="inlineCode"><span class="koboSpan" id="kobo.188.1">sum</span></code><span class="koboSpan" id="kobo.189.1"> variables. </span><span class="koboSpan" id="kobo.189.2">The </span><code class="inlineCode"><span class="koboSpan" id="kobo.190.1">addend </span></code><span class="koboSpan" id="kobo.191.1">variable represents the field numbers. </span><span class="koboSpan" id="kobo.191.2">By initializing it to a value of </span><code class="inlineCode"><span class="koboSpan" id="kobo.192.1">1</span></code><span class="koboSpan" id="kobo.193.1">, the script will always </span><a id="_idIndexMarker961"/><span class="koboSpan" id="kobo.194.1">begin at the first field of every line. </span><span class="koboSpan" id="kobo.194.2">The </span><code class="inlineCode"><span class="koboSpan" id="kobo.195.1">sum</span></code><span class="koboSpan" id="kobo.196.1"> variable is initialized to </span><code class="inlineCode"><span class="koboSpan" id="kobo.197.1">0</span></code><span class="koboSpan" id="kobo.198.1">, for obvious reasons. </span><span class="koboSpan" id="kobo.198.2">The </span><code class="inlineCode"><span class="koboSpan" id="kobo.199.1">while (addend &lt;= NF)</span></code><span class="koboSpan" id="kobo.200.1"> line causes the </span><code class="inlineCode"><span class="koboSpan" id="kobo.201.1">while</span></code><span class="koboSpan" id="kobo.202.1"> loop to execute until it reaches the last field in a line. </span><span class="koboSpan" id="kobo.202.2">(The built-in </span><code class="inlineCode"><span class="koboSpan" id="kobo.203.1">NF</span></code><span class="koboSpan" id="kobo.204.1"> variable holds the number of fields in a given line.) In the next line, using </span><code class="inlineCode"><span class="koboSpan" id="kobo.205.1">$addend</span></code><span class="koboSpan" id="kobo.206.1"> is the same as listing a field number, such as </span><code class="inlineCode"><span class="koboSpan" id="kobo.207.1">$1</span></code><span class="koboSpan" id="kobo.208.1"> or </span><code class="inlineCode"><span class="koboSpan" id="kobo.209.1">$2</span></code><span class="koboSpan" id="kobo.210.1">. </span><span class="koboSpan" id="kobo.210.2">So, as you might expect, </span><code class="inlineCode"><span class="koboSpan" id="kobo.211.1">$addend</span></code><span class="koboSpan" id="kobo.212.1"> returns the value that’s contained in a given field. </span><span class="koboSpan" id="kobo.212.2">By using a variable in place of a hard-coded field number, we can use the </span><code class="inlineCode"><span class="koboSpan" id="kobo.213.1">addend++</span></code><span class="koboSpan" id="kobo.214.1"> command in the next line to advance to the next field in a line. </span><span class="koboSpan" id="kobo.214.2">(This </span><code class="inlineCode"><span class="koboSpan" id="kobo.215.1">variable++</span></code><span class="koboSpan" id="kobo.216.1"> construct increments the value of the variable by 1, the same as it does in C.)</span></p>
    <div class="note">
      <p class="normal"><span class="koboSpan" id="kobo.217.1">If you’re a bit confused by this, allow me to clarify.</span></p>
      <p class="normal"><span class="koboSpan" id="kobo.218.1">Unlike in normal shell scripting, in </span><code class="inlineCode"><span class="koboSpan" id="kobo.219.1">awk</span></code><span class="koboSpan" id="kobo.220.1">, you don’t preface the name of a variable with a </span><code class="inlineCode"><span class="koboSpan" id="kobo.221.1">$</span></code><span class="koboSpan" id="kobo.222.1"> to call back its value. </span><span class="koboSpan" id="kobo.222.2">In </span><code class="inlineCode"><span class="koboSpan" id="kobo.223.1">awk</span></code><span class="koboSpan" id="kobo.224.1">, the </span><code class="inlineCode"><span class="koboSpan" id="kobo.225.1">$</span></code><span class="koboSpan" id="kobo.226.1"> is instead used to reference the number of a field. </span><span class="koboSpan" id="kobo.226.2">So, prefacing a variable name with a </span><code class="inlineCode"><span class="koboSpan" id="kobo.227.1">$</span></code><span class="koboSpan" id="kobo.228.1"> in </span><code class="inlineCode"><span class="koboSpan" id="kobo.229.1">awk</span></code><span class="koboSpan" id="kobo.230.1"> just means that you’re referencing the field number that’s been assigned to that variable.</span></p>
    </div>
    <p class="normal"><span class="koboSpan" id="kobo.231.1">After the </span><code class="inlineCode"><span class="koboSpan" id="kobo.232.1">while</span></code><span class="koboSpan" id="kobo.233.1"> loop finishes, the script prints out its message, with the sum of all the numbers on a line. </span><span class="koboSpan" id="kobo.233.2">Then, it returns to the beginning of the script and keeps going until all lines in the file have been processed. </span><span class="koboSpan" id="kobo.233.3">Here’s what the output looks like:</span></p>
    <pre class="programlisting gen"><code class="hljs-con"><span class="koboSpan" id="kobo.234.1">donnie@fedora:~$ ./add_fields.awk numbers_fields.txt
Line 1 Sum is 3949
Line 2 Sum is 47
Line 3 Sum is 237433
Line 4 Sum is 3878576
Line 5 Sum is 38
Line 6 Sum is 16857
Line 7 Sum is 676
Line 8 Sum is 96
Line 9 Sum is 15
donnie@fedora:~$
</span></code></pre>
    <p class="normal"><span class="koboSpan" id="kobo.235.1">It works, so </span><a id="_idIndexMarker962"/><span class="koboSpan" id="kobo.236.1">everything is cool. </span><span class="koboSpan" id="kobo.236.2">Now, let’s fancy things up a bit. </span><span class="koboSpan" id="kobo.236.3">Let’s add a line that will produce the average of the numbers on each line and format the output. </span><span class="koboSpan" id="kobo.236.4">Name the file </span><code class="inlineCode"><span class="koboSpan" id="kobo.237.1">average_fields.awk</span></code><span class="koboSpan" id="kobo.238.1">, and make it look like this:</span></p>
    <pre class="programlisting gen"><code class="hljs-con"><span class="koboSpan" id="kobo.239.1">#!/usr/bin/awk -f
{
addend=1
sum=0
while (addend &lt;= NF) {
        sum = sum + $addend
        addend++
}
print "Line " NR "\n\t" "Sum: " sum "\n\t" "Average: " sum/NF
}
</span></code></pre>
    <p class="normal"><span class="koboSpan" id="kobo.240.1">What’s so cool about this is that I can use the </span><code class="inlineCode"><span class="koboSpan" id="kobo.241.1">NF</span></code><span class="koboSpan" id="kobo.242.1"> built-in variable in math operations. </span><span class="koboSpan" id="kobo.242.2">In this case, I’m just dividing the sum of each line by the number of fields in each line. </span><span class="koboSpan" id="kobo.242.3">The output looks like this:</span></p>
    <pre class="programlisting gen"><code class="hljs-con"><span class="koboSpan" id="kobo.243.1">donnie@fedora:~$ ./average_fields.awk numbers_fields.txt
Line 1
	Sum: 3949
	Average: 789.8
Line 2
	Sum: 47
	Average: 23.5
. </span><span class="koboSpan" id="kobo.243.2">. </span><span class="koboSpan" id="kobo.243.3">.
</span><span class="koboSpan" id="kobo.243.4">. </span><span class="koboSpan" id="kobo.243.5">. </span><span class="koboSpan" id="kobo.243.6">.
</span><span class="koboSpan" id="kobo.243.7">Line 9
	Sum: 15
	Average: 3
donnie@fedora:~$
</span></code></pre>
    <div class="note">
      <p class="normal"><span class="koboSpan" id="kobo.244.1">If you’re used to C programming, understand that there’s a difference between how </span><code class="inlineCode"><span class="koboSpan" id="kobo.245.1">awk</span></code><span class="koboSpan" id="kobo.246.1"> and C use variables. </span><span class="koboSpan" id="kobo.246.2">Unlike in C, it’s not necessary to declare </span><code class="inlineCode"><span class="koboSpan" id="kobo.247.1">awk</span></code><span class="koboSpan" id="kobo.248.1"> variables before you use them. </span><span class="koboSpan" id="kobo.248.2">But, it is sometimes necessary to initialize them to a certain value before you use them. </span><span class="koboSpan" id="kobo.248.3">Also, unlike in C, there’s only one variable type in </span><code class="inlineCode"><span class="koboSpan" id="kobo.249.1">awk</span></code><span class="koboSpan" id="kobo.250.1">. </span><span class="koboSpan" id="kobo.250.2">All </span><code class="inlineCode"><span class="koboSpan" id="kobo.251.1">awk</span></code><span class="koboSpan" id="kobo.252.1"> variables are of the string type, and all </span><code class="inlineCode"><span class="koboSpan" id="kobo.253.1">awk</span></code><span class="koboSpan" id="kobo.254.1"> math operators automatically recognize numerical values that these variables might represent.</span></p>
    </div>
    <p class="normal"><span class="koboSpan" id="kobo.255.1">Next, let’s look at something a bit more complex.</span></p>
    <h2 id="_idParaDest-323" class="heading 2"><span class="koboSpan" id="kobo.256.1">Finding the CPU Generation</span></h2>
    <p class="normal"><span class="koboSpan" id="kobo.257.1">Let’s </span><a id="_idIndexMarker963"/><span class="koboSpan" id="kobo.258.1">consider another scenario. </span><span class="koboSpan" id="kobo.258.2">You have an old server that’s powered by an AMD Opteron CPU. </span><span class="koboSpan" id="kobo.258.3">You just tried to install Red Hat Enterprise Linux 9 (RHEL 9) on it, and you can’t get it to work. </span><span class="koboSpan" id="kobo.258.4">What could be the problem?</span></p>
    <p class="normal"><span class="koboSpan" id="kobo.259.1">Well, it’s just that your trusty Opteron CPU is too old, which means that it lacks certain capabilities that newer CPUs have. </span><span class="koboSpan" id="kobo.259.2">Ever since AMD created the first 64-bit x86 CPUs in 2003, both AMD and Intel have kept adding new capabilities to their newer models. </span><span class="koboSpan" id="kobo.259.3">In 2020, representatives from Intel, AMD, Red Hat, and SUSE got together and defined the four generations of x86_64. </span><span class="koboSpan" id="kobo.259.4">Each successive generation has capabilities that aren’t in the previous generations. </span><span class="koboSpan" id="kobo.259.5">Here’s a list of when each generation was introduced:</span></p>
    <ul>
      <li class="bulletList"><span class="koboSpan" id="kobo.260.1">Generation 1: 2003</span></li>
      <li class="bulletList"><span class="koboSpan" id="kobo.261.1">Generation 2: 2009</span></li>
      <li class="bulletList"><span class="koboSpan" id="kobo.262.1">Generation 3: 2013 for Intel, 2015 for AMD</span></li>
      <li class="bulletList"><span class="koboSpan" id="kobo.263.1">Generation 4: 2017 for Intel, 2022 for AMD</span></li>
    </ul>
    <p class="normal"><span class="koboSpan" id="kobo.264.1">Software</span><a id="_idIndexMarker964"/><span class="koboSpan" id="kobo.265.1"> that was created for a first generation x86_64 CPU will also run fine on the three newer generations. </span><span class="koboSpan" id="kobo.265.2">But, if you have a newer CPU, you can make things run faster by using software that was optimized for it. </span><span class="koboSpan" id="kobo.265.3">Of course, that means that it won’t run on the older CPUs. </span><span class="koboSpan" id="kobo.265.4">So, if you’re still running a first generation x86_64 CPU, you won’t be able to run either RHEL 9 or any of its clones. </span><span class="koboSpan" id="kobo.265.5">(Rumor has it that RHEL 10, which should be out sometime in 2025, will require at least a third generation x86_64 CPU. </span><span class="koboSpan" id="kobo.265.6">You’ll find a link to the rumor in the </span><em class="chapterRef"><span class="koboSpan" id="kobo.266.1">Further Reading</span></em><span class="koboSpan" id="kobo.267.1"> section.) That’s actually okay, because Red Hat’s target customers are the large enterprises that upgrade their gear on a regular basis. </span></p>
    <p class="normal"><span class="koboSpan" id="kobo.268.1">This makes it very unlikely that any of them still run any of these first generation machines. </span><span class="koboSpan" id="kobo.268.2">This doesn’t really affect normal home users of desktop Linux, because very few home users use either RHEL or a RHEL clone for that purpose, and most non-RHEL distros still support the old machines. </span><span class="koboSpan" id="kobo.268.3">So, how do you know which generation your CPU is? </span><span class="koboSpan" id="kobo.268.4">That’s easy. </span><span class="koboSpan" id="kobo.268.5">Just write a script.</span></p>
    <p class="normal"><span class="koboSpan" id="kobo.269.1">To get an idea of how this works, look in the </span><code class="inlineCode"><span class="koboSpan" id="kobo.270.1">/proc/cpuinfo</span></code><span class="koboSpan" id="kobo.271.1"> file, and scroll down to the </span><code class="inlineCode"><span class="koboSpan" id="kobo.272.1">flags</span></code><span class="koboSpan" id="kobo.273.1"> section. </span><span class="koboSpan" id="kobo.273.2">What you’ll see depends upon which generation of x86_64 CPU is in your machine. </span><span class="koboSpan" id="kobo.273.3">Here on my 2012-model Dell workstation with an Intel Xeon CPU that’s of the second generation x86_64 variety, the </span><code class="inlineCode"><span class="koboSpan" id="kobo.274.1">flags</span></code><span class="koboSpan" id="kobo.275.1"> section looks like this:</span></p>
    <pre class="programlisting gen"><code class="hljs-con"><span class="koboSpan" id="kobo.276.1">flags           : fpu vme de pse tsc msr pae mce cx8 apic sep mtrr pge mca cmov pat pse36 clflush mmx fxsr sse sse2 ht syscall nx rdtscp lm constant_tsc rep_good nopl xtopology nonstop_tsc cpuid tsc_known_freq pni pclmulqdq ssse3 cx16 sse4_1 sse4_2 x2apic popcnt aes xsave avx hypervisor lahf_lm pti md_clear flush_l1d
</span></code></pre>
    <p class="normal"><span class="koboSpan" id="kobo.277.1">On my vintage 2009-model Hewlett-Packard machine with a pair of first generation Opteron CPUs, the </span><code class="inlineCode"><span class="koboSpan" id="kobo.278.1">flags</span></code><span class="koboSpan" id="kobo.279.1"> section looks like this:</span></p>
    <pre class="programlisting gen"><code class="hljs-con"><span class="koboSpan" id="kobo.280.1">flags           : fpu vme de pse tsc msr pae mce cx8 apic sep mtrr pge mca cmov pat pse36 clflush mmx fxsr sse sse2 ht syscall nx mmxext fxsr_opt pdpe1gb rdtscp lm 3dnowext 3dnow constant_tsc rep_good nopl nonstop_tsc cpuid extd_apicid pni monitor cx16 popcnt lahf_lm cmp_legacy svm extapic cr8_legacy abm sse4a misalignsse 3dnowprefetch osvw ibs skinit wdt hw_pstate vmmcall npt lbrv svm_lock nrip_save
</span></code></pre>
    <p class="normal"><span class="koboSpan" id="kobo.281.1">You see </span><a id="_idIndexMarker965"/><span class="koboSpan" id="kobo.282.1">here that the second generation CPU in my Dell has newer capabilities, such as </span><code class="inlineCode"><span class="koboSpan" id="kobo.283.1">sse4_1</span></code><span class="koboSpan" id="kobo.284.1">, </span><code class="inlineCode"><span class="koboSpan" id="kobo.285.1">sse4_2</span></code><span class="koboSpan" id="kobo.286.1">, and a few others that aren’t in the old Opterons. </span><span class="koboSpan" id="kobo.286.2">On a Linux system, you can create either a </span><code class="inlineCode"><span class="koboSpan" id="kobo.287.1">bash</span></code><span class="koboSpan" id="kobo.288.1"> script or an </span><code class="inlineCode"><span class="koboSpan" id="kobo.289.1">awk</span></code><span class="koboSpan" id="kobo.290.1"> script that will automatically parse the </span><code class="inlineCode"><span class="koboSpan" id="kobo.291.1">/proc/cpuinfo</span></code><span class="koboSpan" id="kobo.292.1"> file to determine the generation to which your CPU belongs. </span><span class="koboSpan" id="kobo.292.2">Here’s the </span><code class="inlineCode"><span class="koboSpan" id="kobo.293.1">x86_64_check.awk</span></code><span class="koboSpan" id="kobo.294.1"> script, which I borrowed from a post on the StackExchange site:</span></p>
    <pre class="programlisting gen"><code class="hljs-con"><span class="koboSpan" id="kobo.295.1">#!/usr/bin/awk -f
BEGIN {
    while (!/flags/) if (getline &lt; "/proc/cpuinfo" != 1) exit 1
    if (/cmov/&amp;&amp;/cx8/&amp;&amp;/fpu/&amp;&amp;/fxsr/&amp;&amp;/mmx/&amp;&amp;/syscall/&amp;&amp;/sse2/) level = 1
    if (level == 1 &amp;&amp; /cx16/&amp;&amp;/lahf/&amp;&amp;/popcnt/&amp;&amp;/sse4_1/&amp;&amp;/sse4_2/&amp;&amp;/ssse3/) level = 2
    if (level == 2 &amp;&amp; /avx/&amp;&amp;/avx2/&amp;&amp;/bmi1/&amp;&amp;/bmi2/&amp;&amp;/f16c/&amp;&amp;/fma/&amp;&amp;/abm/&amp;&amp;/movbe/&amp;&amp;/xsave/) level = 3
    if (level == 3 &amp;&amp; /avx512f/&amp;&amp;/avx512bw/&amp;&amp;/avx512cd/&amp;&amp;/avx512dq/&amp;&amp;/avx512vl/) level = 4
    if (level &gt; 0) { print "CPU supports x86-64-v" level; exit level + 1 }
    exit 1
}
</span></code></pre>
    <p class="normal"><span class="koboSpan" id="kobo.296.1">The first thing to note is that the whole script needs to be part of a </span><code class="inlineCode"><span class="koboSpan" id="kobo.297.1">BEGIN</span></code><span class="koboSpan" id="kobo.298.1"> block. </span><span class="koboSpan" id="kobo.298.2">That’s because we need to process the whole </span><code class="inlineCode"><span class="koboSpan" id="kobo.299.1">cpuinfo</span></code><span class="koboSpan" id="kobo.300.1"> file at once, instead of just one line at a time as </span><code class="inlineCode"><span class="koboSpan" id="kobo.301.1">awk</span></code><span class="koboSpan" id="kobo.302.1"> would normally do. </span><span class="koboSpan" id="kobo.302.2">The </span><code class="inlineCode"><span class="koboSpan" id="kobo.303.1">BEGIN</span></code><span class="koboSpan" id="kobo.304.1"> block helps us out with that.</span></p>
    <p class="normal"><span class="koboSpan" id="kobo.305.1">Then, note that this script uses a different style for the </span><code class="inlineCode"><span class="koboSpan" id="kobo.306.1">if</span></code><span class="koboSpan" id="kobo.307.1"> constructs. </span><span class="koboSpan" id="kobo.307.2">Instead of formatting them in the C language style as I showed you before, the author instead placed each </span><code class="inlineCode"><span class="koboSpan" id="kobo.308.1">if</span></code><span class="koboSpan" id="kobo.309.1"> construct on its own line. </span><span class="koboSpan" id="kobo.309.2">Each style works equally well, and I’ll leave it to you to decide which one you like better. </span><span class="koboSpan" id="kobo.309.3">Anyway, here’s the breakdown of how</span><a id="_idIndexMarker966"/><span class="koboSpan" id="kobo.310.1"> it all works.</span></p>
    <ul>
      <li class="bulletList"><span class="koboSpan" id="kobo.311.1">At the end of each of the first four </span><code class="inlineCode"><span class="koboSpan" id="kobo.312.1">if</span></code><span class="koboSpan" id="kobo.313.1"> statements, the </span><code class="inlineCode"><span class="koboSpan" id="kobo.314.1">level</span></code><span class="koboSpan" id="kobo.315.1"> variable is set to a new value.</span></li>
      <li class="bulletList"><span class="koboSpan" id="kobo.316.1">The first </span><code class="inlineCode"><span class="koboSpan" id="kobo.317.1">if</span></code><span class="koboSpan" id="kobo.318.1"> statement looks for capabilities that are in the first generation, and then assigns </span><code class="inlineCode"><span class="koboSpan" id="kobo.319.1">1</span></code><span class="koboSpan" id="kobo.320.1"> as the value of </span><code class="inlineCode"><span class="koboSpan" id="kobo.321.1">level</span></code><span class="koboSpan" id="kobo.322.1">.</span></li>
      <li class="bulletList"><span class="koboSpan" id="kobo.323.1">The second </span><code class="inlineCode"><span class="koboSpan" id="kobo.324.1">if </span></code><span class="koboSpan" id="kobo.325.1">statement verifies that the CPU contains level 1 capabilities, looks for another set of capabilities that are in second generation CPUs, and then assigns </span><code class="inlineCode"><span class="koboSpan" id="kobo.326.1">2</span></code><span class="koboSpan" id="kobo.327.1"> as the value of </span><code class="inlineCode"><span class="koboSpan" id="kobo.328.1">level</span></code><span class="koboSpan" id="kobo.329.1">.</span></li>
      <li class="bulletList"><span class="koboSpan" id="kobo.330.1">The process repeats for the third and fourth </span><code class="inlineCode"><span class="koboSpan" id="kobo.331.1">if</span></code><span class="koboSpan" id="kobo.332.1"> statements, in order to detect either third or fourth generation CPUs.</span></li>
      <li class="bulletList"><span class="koboSpan" id="kobo.333.1">Finally, the fifth </span><code class="inlineCode"><span class="koboSpan" id="kobo.334.1">if</span></code><span class="koboSpan" id="kobo.335.1"> statement verifies that the value of </span><code class="inlineCode"><span class="koboSpan" id="kobo.336.1">level</span></code><span class="koboSpan" id="kobo.337.1"> is greater than </span><code class="inlineCode"><span class="koboSpan" id="kobo.338.1">0</span></code><span class="koboSpan" id="kobo.339.1">, prints out the message, and then exits the script with an exit code that’s the value of </span><code class="inlineCode"><span class="koboSpan" id="kobo.340.1">level</span></code><span class="koboSpan" id="kobo.341.1"> plus 1.</span></li>
      <li class="bulletList"><span class="koboSpan" id="kobo.342.1">The </span><code class="inlineCode"><span class="koboSpan" id="kobo.343.1">exit 1 </span></code><span class="koboSpan" id="kobo.344.1">line at the end causes the script to exit with exit code </span><code class="inlineCode"><span class="koboSpan" id="kobo.345.1">1</span></code><span class="koboSpan" id="kobo.346.1"> if the script fails to run correctly for whatever reason. </span><span class="koboSpan" id="kobo.346.2">(The </span><code class="inlineCode"><span class="koboSpan" id="kobo.347.1">level + 1</span></code><span class="koboSpan" id="kobo.348.1"> command at the end of the fourth </span><code class="inlineCode"><span class="koboSpan" id="kobo.349.1">if</span></code><span class="koboSpan" id="kobo.350.1"> statement prevents a successful run of the program from returning a </span><code class="inlineCode"><span class="koboSpan" id="kobo.351.1">1</span></code><span class="koboSpan" id="kobo.352.1"> for the exit code. </span><span class="koboSpan" id="kobo.352.2">Remember, </span><code class="inlineCode"><span class="koboSpan" id="kobo.353.1">1</span></code><span class="koboSpan" id="kobo.354.1"> is normally an exit code for a program that doesn’t run correctly.)</span></li>
    </ul>
    <p class="normal"><span class="koboSpan" id="kobo.355.1">An interesting thing about </span><code class="inlineCode"><span class="koboSpan" id="kobo.356.1">awk</span></code><span class="koboSpan" id="kobo.357.1"> variables is that all of them are string variables, which greatly simplifies the coding process. </span><span class="koboSpan" id="kobo.357.2">If you assign the value of </span><code class="inlineCode"><span class="koboSpan" id="kobo.358.1">1</span></code><span class="koboSpan" id="kobo.359.1"> to the </span><code class="inlineCode"><span class="koboSpan" id="kobo.360.1">level</span></code><span class="koboSpan" id="kobo.361.1"> variable, the value is stored as a string instead of as an integer. </span><span class="koboSpan" id="kobo.361.2">But, when you use variables to perform math operations in </span><code class="inlineCode"><span class="koboSpan" id="kobo.362.1">awk</span></code><span class="koboSpan" id="kobo.363.1">, everything works correctly because </span><code class="inlineCode"><span class="koboSpan" id="kobo.364.1">awk</span></code><span class="koboSpan" id="kobo.365.1"> automatically recognizes when a string is really a number. </span><span class="koboSpan" id="kobo.365.2">Also, unlike </span><code class="inlineCode"><span class="koboSpan" id="kobo.366.1">bash</span></code><span class="koboSpan" id="kobo.367.1">, </span><code class="inlineCode"><span class="koboSpan" id="kobo.368.1">awk</span></code><span class="koboSpan" id="kobo.369.1"> can natively perform floating point math operations. </span><span class="koboSpan" id="kobo.369.2">So, you can perform math operations much easier and faster in </span><code class="inlineCode"><span class="koboSpan" id="kobo.370.1">awk</span></code><span class="koboSpan" id="kobo.371.1"> than you can in either </span><code class="inlineCode"><span class="koboSpan" id="kobo.372.1">bash</span></code><span class="koboSpan" id="kobo.373.1"> scripting or a normal programming language. </span><span class="koboSpan" id="kobo.373.2">To demonstrate this, let’s run this script on my both of the workstations that I currently have running. </span><span class="koboSpan" id="kobo.373.3">Here’s what it looks like on my old Opteron-powered Hewlett-Packard:</span></p>
    <pre class="programlisting gen"><code class="hljs-con"><span class="koboSpan" id="kobo.374.1">donnie@opensuse:~&gt; ./x86-64-level_check.awk
CPU supports x86-64-v1
donnie@opensuse:~&gt; echo $?
</span><span class="koboSpan" id="kobo.374.2">2
donnie@opensuse:~&gt;
</span></code></pre>
    <p class="normal"><span class="koboSpan" id="kobo.375.1">As expected, the </span><a id="_idIndexMarker967"/><span class="koboSpan" id="kobo.376.1">script shows that this is a first generation x86_64 machine. </span><span class="koboSpan" id="kobo.376.2">The </span><code class="inlineCode"><span class="koboSpan" id="kobo.377.1">echo $?</span></code><span class="koboSpan" id="kobo.378.1"> command shows the exit code, which was created by the </span><code class="inlineCode"><span class="koboSpan" id="kobo.379.1">level + 1</span></code><span class="koboSpan" id="kobo.380.1"> command in the script. </span><span class="koboSpan" id="kobo.380.2">Now, here’s how it looks on my Xeon-powered Dell:</span></p>
    <pre class="programlisting gen"><code class="hljs-con"><span class="koboSpan" id="kobo.381.1">donnie@fedora:~$ ./x86-64-level_check.awk
CPU supports x86-64-v2
donnie@fedora:~$ echo $?
</span><span class="koboSpan" id="kobo.381.2">3
donnie@fedora:~$
</span></code></pre>
    <p class="normal"><span class="koboSpan" id="kobo.382.1">So yeah, everything works fine.</span></p>
    <p class="normal"><span class="koboSpan" id="kobo.383.1">Ah, but wait. </span><span class="koboSpan" id="kobo.383.2">We’re not done yet, because I haven’t yet explained the </span><code class="inlineCode"><span class="koboSpan" id="kobo.384.1">while</span></code><span class="koboSpan" id="kobo.385.1"> construct. </span><span class="koboSpan" id="kobo.385.2">It’s a bit tricky, so I saved it for last.</span></p>
    <p class="normal"><span class="koboSpan" id="kobo.386.1">I’ve already shown you that in the </span><code class="inlineCode"><span class="koboSpan" id="kobo.387.1">/proc/cpuinfo</span></code><span class="koboSpan" id="kobo.388.1"> file, the strings that you seek are in the stanza with the text string </span><code class="inlineCode"><span class="koboSpan" id="kobo.389.1">flags</span></code><span class="koboSpan" id="kobo.390.1"> in the first field. </span><span class="koboSpan" id="kobo.390.2">But, the </span><code class="inlineCode"><span class="koboSpan" id="kobo.391.1">while (!/flags/)</span></code><span class="koboSpan" id="kobo.392.1"> statement makes it appear that we’re </span><em class="italic"><span class="koboSpan" id="kobo.393.1">not</span></em><span class="koboSpan" id="kobo.394.1"> looking for the </span><code class="inlineCode"><span class="koboSpan" id="kobo.395.1">flags</span></code><span class="koboSpan" id="kobo.396.1"> stanza. </span><span class="koboSpan" id="kobo.396.2">(Remember that the </span><code class="inlineCode"><span class="koboSpan" id="kobo.397.1">!</span></code><span class="koboSpan" id="kobo.398.1"> is a negation operator.) To understand what’s really going on, view the entire </span><code class="inlineCode"><span class="koboSpan" id="kobo.399.1">cpuinfo</span></code><span class="koboSpan" id="kobo.400.1"> file by entering </span><code class="inlineCode"><span class="koboSpan" id="kobo.401.1">cat /proc/cpuinfo</span></code><span class="koboSpan" id="kobo.402.1">. </span><span class="koboSpan" id="kobo.402.2">You’ll see that the same set of information prints out once for every CPU core in your system. </span><span class="koboSpan" id="kobo.402.3">For example, my Dell workstation is running with an octo-core Xeon. </span><span class="koboSpan" id="kobo.402.4">Hyperthreading is enabled, which means that I have a total of 16 virtual CPU cores. </span><span class="koboSpan" id="kobo.402.5">So, running </span><code class="inlineCode"><span class="koboSpan" id="kobo.403.1">cat /proc/cpuinfo</span></code><span class="koboSpan" id="kobo.404.1"> causes the same CPU information to print 16 times. </span><span class="koboSpan" id="kobo.404.2">You’ll also see that several more stanzas of information print out after the </span><code class="inlineCode"><span class="koboSpan" id="kobo.405.1">flags</span></code><span class="koboSpan" id="kobo.406.1"> stanza. </span><span class="koboSpan" id="kobo.406.2">To understand how this </span><code class="inlineCode"><span class="koboSpan" id="kobo.407.1">while</span></code><span class="koboSpan" id="kobo.408.1"> loop works, run the following one-line </span><code class="inlineCode"><span class="koboSpan" id="kobo.409.1">awk</span></code><span class="koboSpan" id="kobo.410.1"> command:</span></p>
    <pre class="programlisting gen"><code class="hljs-con"><span class="koboSpan" id="kobo.411.1">donnie@fedora:~$ awk 'BEGIN {while (!/flags/) if (getline &lt;"/proc/cpuinfo" == 1) print $0}'
processor	: 0
vendor_id	: GenuineIntel
. </span><span class="koboSpan" id="kobo.411.2">. </span><span class="koboSpan" id="kobo.411.3">.
</span><span class="koboSpan" id="kobo.411.4">. </span><span class="koboSpan" id="kobo.411.5">. </span><span class="koboSpan" id="kobo.411.6">.
</span><span class="koboSpan" id="kobo.411.7">wp		: yes
flags		: fpu vme de pse tsc msr pae mce cx8 apic sep mtrr pge mca cmov pat pse36 clflush dts acpi mmx fxsr sse sse2 ss ht tm pbe syscall nx pdpe1gb rdtscp lm constant_tsc arch_perfmon pebs bts rep_good nopl xtopology nonstop_tsc cpuid aperfmperf pni pclmulqdq dtes64 monitor ds_cpl vmx smx est tm2 ssse3 cx16 xtpr pdcm pcid dca sse4_1 sse4_2 x2apic popcnt tsc_deadline_timer aes xsave avx lahf_lm epb pti ssbd ibrs ibpb stibp tpr_shadow flexpriority ept vpid xsaveopt dtherm ida arat pln pts vnmi md_clear flush_l1d
donnie@fedora:~$
</span></code></pre>
    <p class="normal"><span class="koboSpan" id="kobo.412.1">The </span><code class="inlineCode"><span class="koboSpan" id="kobo.413.1">flags</span></code><span class="koboSpan" id="kobo.414.1"> stanza is actually just a single long line that wraps around on both your terminal and on</span><a id="_idIndexMarker968"/><span class="koboSpan" id="kobo.415.1"> the printed page. </span><span class="koboSpan" id="kobo.415.2">So, </span><code class="inlineCode"><span class="koboSpan" id="kobo.416.1">awk</span></code><span class="koboSpan" id="kobo.417.1"> treats the </span><code class="inlineCode"><span class="koboSpan" id="kobo.418.1">flags</span></code><span class="koboSpan" id="kobo.419.1"> line as a single record. </span><span class="koboSpan" id="kobo.419.2">The </span><code class="inlineCode"><span class="koboSpan" id="kobo.420.1">while (!/flags/)</span></code><span class="koboSpan" id="kobo.421.1"> statement in this command causes </span><code class="inlineCode"><span class="koboSpan" id="kobo.422.1">getline</span></code><span class="koboSpan" id="kobo.423.1"> to read the </span><code class="inlineCode"><span class="koboSpan" id="kobo.424.1">cpuinfo</span></code><span class="koboSpan" id="kobo.425.1"> file until it encounters the first </span><code class="inlineCode"><span class="koboSpan" id="kobo.426.1">flags</span></code><span class="koboSpan" id="kobo.427.1"> string. </span><span class="koboSpan" id="kobo.427.2">This means that the CPU information for only the first CPU core will show up, and any information that comes after the first </span><code class="inlineCode"><span class="koboSpan" id="kobo.428.1">flags </span></code><span class="koboSpan" id="kobo.429.1">line will not show up. </span><span class="koboSpan" id="kobo.429.2">(Yeah, it looks a bit confusing, but it makes total sense when you think about it.)</span></p>
    <p class="normal"><span class="koboSpan" id="kobo.430.1">In the original script, the </span><code class="inlineCode"><span class="koboSpan" id="kobo.431.1">if (getline &lt; "/proc/cpuinfo" != 1) exit 1</span></code><span class="koboSpan" id="kobo.432.1"> that’s within the </span><code class="inlineCode"><span class="koboSpan" id="kobo.433.1">while</span></code><span class="koboSpan" id="kobo.434.1"> loop does two things for us. </span><span class="koboSpan" id="kobo.434.2">First, it uses the </span><code class="inlineCode"><span class="koboSpan" id="kobo.435.1">!=1</span></code><span class="koboSpan" id="kobo.436.1"> parameter to check for the existence of the </span><code class="inlineCode"><span class="koboSpan" id="kobo.437.1">cpuinfo</span></code><span class="koboSpan" id="kobo.438.1"> file. </span><span class="koboSpan" id="kobo.438.2">If </span><code class="inlineCode"><span class="koboSpan" id="kobo.439.1">!=1</span></code><span class="koboSpan" id="kobo.440.1">, which is the same as saying </span><em class="italic"><span class="koboSpan" id="kobo.441.1">not true</span></em><span class="koboSpan" id="kobo.442.1">, evaluates to </span><em class="italic"><span class="koboSpan" id="kobo.443.1">true,</span></em><span class="koboSpan" id="kobo.444.1"> then the script will exit with exit code </span><code class="inlineCode"><span class="koboSpan" id="kobo.445.1">1</span></code><span class="koboSpan" id="kobo.446.1">.</span></p>
    <p class="normal"><span class="koboSpan" id="kobo.447.1">If the </span><code class="inlineCode"><span class="koboSpan" id="kobo.448.1">!=1</span></code><span class="koboSpan" id="kobo.449.1"> parameter evaluates to </span><em class="italic"><span class="koboSpan" id="kobo.450.1">false</span></em><span class="koboSpan" id="kobo.451.1">, which would mean that the file exists, then </span><code class="inlineCode"><span class="koboSpan" id="kobo.452.1">getline</span></code><span class="koboSpan" id="kobo.453.1">, a built-in </span><code class="inlineCode"><span class="koboSpan" id="kobo.454.1">awk</span></code><span class="koboSpan" id="kobo.455.1"> function, will read in the </span><code class="inlineCode"><span class="koboSpan" id="kobo.456.1">cpuinfo</span></code><span class="koboSpan" id="kobo.457.1"> file. </span><span class="koboSpan" id="kobo.457.2">This way, if you run this script on an operating system that doesn’t have a </span><code class="inlineCode"><span class="koboSpan" id="kobo.458.1">/proc/cpuinfo</span></code><span class="koboSpan" id="kobo.459.1"> file, such as FreeBSD, it will gracefully exit.</span></p>
    <p class="normal"><span class="koboSpan" id="kobo.460.1">Now, some of you might prefer using C-style syntax to make the script a bit more readable. </span><span class="koboSpan" id="kobo.460.2">Fortunately, that’s easy to do. </span><span class="koboSpan" id="kobo.460.3">Changing the style makes the script too long to show here in its entirety, but I can show you a snippet:</span></p>
    <pre class="programlisting gen"><code class="hljs-con"><span class="koboSpan" id="kobo.461.1">#!/usr/bin/awk -f
BEGIN {
        while (!/flags/) {
                if (getline &lt; "/proc/cpuinfo" !=1) {
                        exit 1
                        }
                }
. </span><span class="koboSpan" id="kobo.461.2">. </span><span class="koboSpan" id="kobo.461.3">.
</span><span class="koboSpan" id="kobo.461.4">. </span><span class="koboSpan" id="kobo.461.5">. </span><span class="koboSpan" id="kobo.461.6">.
</span><span class="koboSpan" id="kobo.461.7">if (level &gt; 0) {
                { print "CPU supports x86-64-v" level; exit level + 1 }
        }
        exit 1
}
</span></code></pre>
    <p class="normal"><span class="koboSpan" id="kobo.462.1">If you want </span><a id="_idIndexMarker969"/><span class="koboSpan" id="kobo.463.1">to see the converted script in its entirety, just download the </span><code class="inlineCode"><span class="koboSpan" id="kobo.464.1">x86-64-level_check2.awk</span></code><span class="koboSpan" id="kobo.465.1"> file from GitHub.</span></p>
    <p class="normal"><span class="koboSpan" id="kobo.466.1">I believe that we’re done with this script. </span><span class="koboSpan" id="kobo.466.2">Let’s see what we can do with a </span><code class="inlineCode"><span class="koboSpan" id="kobo.467.1">for</span></code><span class="koboSpan" id="kobo.468.1"> loop and an array.</span></p>
    <h1 id="_idParaDest-324" class="heading 1"><span class="koboSpan" id="kobo.469.1">Using for loops and Arrays</span></h1>
    <p class="normal"><span class="koboSpan" id="kobo.470.1">Certain</span><a id="_idIndexMarker970"/><span class="koboSpan" id="kobo.471.1"> languages, such as Spanish and French, have the concept </span><a id="_idIndexMarker971"/><span class="koboSpan" id="kobo.472.1">of masculine and feminine nouns. </span><span class="koboSpan" id="kobo.472.2">For this demo, we’ll work with a list of English nouns, their Spanish equivalents, and the gender designations for the Spanish nouns.</span></p>
    <div class="note">
      <p class="normal"><span class="koboSpan" id="kobo.473.1">Why is someone with a French last name creating a list of Spanish words? </span><span class="koboSpan" id="kobo.473.2">Well, it’s just that despite my French ancestry, I chose to learn Spanish instead of French in high school. </span><span class="koboSpan" id="kobo.473.3">So, I do know some Spanish, but I don’t know French. </span><span class="koboSpan" id="kobo.473.4">(I know, I’m weird.) Also, I realize that the Spanish word </span><em class="italic"><span class="koboSpan" id="kobo.474.1">camiόn</span></em><span class="koboSpan" id="kobo.475.1"> has an accent over the last syllable. </span><span class="koboSpan" id="kobo.475.2">Alas, inserting accents with an English-language keyboard isn’t easily done in a plain-text file, at least not without messing up how the </span><code class="inlineCode"><span class="koboSpan" id="kobo.476.1">awk</span></code><span class="koboSpan" id="kobo.477.1"> script works.</span></p>
    </div>
    <p class="normal"><span class="koboSpan" id="kobo.478.1">To begin, create the </span><code class="inlineCode"><span class="koboSpan" id="kobo.479.1">spanish_words.txt</span></code><span class="koboSpan" id="kobo.480.1"> file, and make it look like this:</span></p>
    <pre class="programlisting gen"><code class="hljs-con"><span class="koboSpan" id="kobo.481.1">ENGLISH:SPANISH:GENDER
cat:gato:M
table:mesa:F
bed:cama:F
bus:camion:M
house:casa:F
</span></code></pre>
    <p class="normal"><span class="koboSpan" id="kobo.482.1">As you see, we’re </span><a id="_idIndexMarker972"/><span class="koboSpan" id="kobo.483.1">using colons as field separators, and using either M or F to </span><a id="_idIndexMarker973"/><span class="koboSpan" id="kobo.484.1">designate if a word is masculine or feminine. </span><span class="koboSpan" id="kobo.484.2">The first line is a header, so we’ll need to take that into account when we process the file.</span></p>
    <p class="normal"><span class="koboSpan" id="kobo.485.1">Next, create the </span><code class="inlineCode"><span class="koboSpan" id="kobo.486.1">masc-fem.awk</span></code><span class="koboSpan" id="kobo.487.1"> script, like this:</span></p>
    <pre class="programlisting gen"><code class="hljs-con"><span class="koboSpan" id="kobo.488.1">#!/usr/bin/awk -f
BEGIN {FS=":"}
NR==1 {next}
$3 == "M" {masc[$2]=$1}
$3 == "F" {fem[$2]=$1}
END {
        print "\nMasculine Nouns\n----";
                for (m in masc)
                        {print m "--" masc[m]; count++}
        print "\nFeminine Nouns\n----";
                for (f in fem)
                        {print f "--" fem[f]; count2++}
        print "\nThere are " count " masculine nouns and " count2 " feminine nouns."
</span><span class="koboSpan" id="kobo.488.2">}
</span></code></pre>
    <p class="normal"><span class="koboSpan" id="kobo.489.1">In the </span><code class="inlineCode"><span class="koboSpan" id="kobo.490.1">BEGIN</span></code><span class="koboSpan" id="kobo.491.1"> section, we’re setting the </span><code class="inlineCode"><span class="koboSpan" id="kobo.492.1">:</span></code><span class="koboSpan" id="kobo.493.1"> as the field separator. </span><span class="koboSpan" id="kobo.493.2">The </span><code class="inlineCode"><span class="koboSpan" id="kobo.494.1">NR == 1 {next}</span></code><span class="koboSpan" id="kobo.495.1"> line means to ignore line 1 and move on to the next line. </span><span class="koboSpan" id="kobo.495.2">The next two lines build the </span><code class="inlineCode"><span class="koboSpan" id="kobo.496.1">masc</span></code><span class="koboSpan" id="kobo.497.1"> and </span><code class="inlineCode"><span class="koboSpan" id="kobo.498.1">fem</span></code><span class="koboSpan" id="kobo.499.1"> arrays. </span><span class="koboSpan" id="kobo.499.2">Any line that has an </span><code class="inlineCode"><span class="koboSpan" id="kobo.500.1">M</span></code><span class="koboSpan" id="kobo.501.1"> in field 3 goes into the </span><code class="inlineCode"><span class="koboSpan" id="kobo.502.1">masc</span></code><span class="koboSpan" id="kobo.503.1"> array, and any line that has an </span><code class="inlineCode"><span class="koboSpan" id="kobo.504.1">F</span></code><span class="koboSpan" id="kobo.505.1"> in field 3 goes into the </span><code class="inlineCode"><span class="koboSpan" id="kobo.506.1">fem</span></code><span class="koboSpan" id="kobo.507.1"> array. </span><span class="koboSpan" id="kobo.507.2">The </span><code class="inlineCode"><span class="koboSpan" id="kobo.508.1">END</span></code><span class="koboSpan" id="kobo.509.1"> section contains code that will run after the code in the main body has finished building the arrays. </span><span class="koboSpan" id="kobo.509.2">The two </span><code class="inlineCode"><span class="koboSpan" id="kobo.510.1">for</span></code><span class="koboSpan" id="kobo.511.1"> loops work the same as you saw with the normal shell scripting </span><code class="inlineCode"><span class="koboSpan" id="kobo.512.1">for</span></code><span class="koboSpan" id="kobo.513.1"> loops, except that we’re now using C language syntax. </span><span class="koboSpan" id="kobo.513.2">The first loop prints out the list of masculine nouns and uses the </span><code class="inlineCode"><span class="koboSpan" id="kobo.514.1">count</span></code><span class="koboSpan" id="kobo.515.1"> variable to add up the total of masculine nouns. </span><span class="koboSpan" id="kobo.515.2">The second loop does the same for the feminine nouns, except that it uses the </span><code class="inlineCode"><span class="koboSpan" id="kobo.516.1">count2</span></code><span class="koboSpan" id="kobo.517.1"> variable to total the number of feminine nouns. </span><span class="koboSpan" id="kobo.517.2">Running</span><a id="_idIndexMarker974"/><span class="koboSpan" id="kobo.518.1"> the</span><a id="_idIndexMarker975"/><span class="koboSpan" id="kobo.519.1"> script looks like this:</span></p>
    <pre class="programlisting gen"><code class="hljs-con"><span class="koboSpan" id="kobo.520.1">donnie@fedora:~$ ./masc-fem.awk spanish_words.txt
Masculine Nouns
----
gato--cat
camion--bus
Feminine Nouns
----
mesa--table
casa--house
cama--bed
There are 2 masculine nouns and 3 feminine nouns.
</span><span class="koboSpan" id="kobo.520.2">donnie@fedora:~$
</span></code></pre>
    <p class="normal"><span class="koboSpan" id="kobo.521.1">And, that’s all there is to it. </span><span class="koboSpan" id="kobo.521.2">Easy, right?</span></p>
    <p class="normal"><span class="koboSpan" id="kobo.522.1">For our next trick, let’s do some floating-point math.</span></p>
    <h1 id="_idParaDest-325" class="heading 1"><span class="koboSpan" id="kobo.523.1">Using Floating Point Math and printf</span></h1>
    <p class="normal"><span class="koboSpan" id="kobo.524.1">For</span><a id="_idIndexMarker976"/><span class="koboSpan" id="kobo.525.1"> some strange reason, you’ve found yourself working a job that requires you to keep track of weather-related statistics. </span><span class="koboSpan" id="kobo.525.2">Your boss has just sent you a text file that contains a list of temperatures. </span><span class="koboSpan" id="kobo.525.3">Some of the temperatures are Celsius temperatures, and some are Fahrenheit temperatures. </span><span class="koboSpan" id="kobo.525.4">Your assigned task is to convert the Fahrenheit temperatures to Celsius temperatures. </span><span class="koboSpan" id="kobo.525.5">You can</span><a id="_idIndexMarker977"/><span class="koboSpan" id="kobo.526.1"> do that the hard way by using a calculator to manually convert each Fahrenheit temperature, or you can write a script that will automate the process. </span><span class="koboSpan" id="kobo.526.2">You’ve decided that it would be easier to write a script. </span><span class="koboSpan" id="kobo.526.3">The list of temperatures is in the </span><code class="inlineCode"><span class="koboSpan" id="kobo.527.1">temps.txt</span></code><span class="koboSpan" id="kobo.528.1"> file, which looks like this:</span></p>
    <pre class="programlisting gen"><code class="hljs-con"><span class="koboSpan" id="kobo.529.1">Temperature Celsius_or_Fahrenheit
32 F
212 F
-40 F
-14.7 F
24.6111 C
75.8 F
55.21 F
23.9444 C
29.8 F
104.34 F
98.6 F
23.1 C
</span></code></pre>
    <p class="normal"><span class="koboSpan" id="kobo.530.1">The first three temperatures are checks to verify that the script works correctly. </span><span class="koboSpan" id="kobo.530.2">We know that 32 degrees F equals 0 degrees C, that 212 degrees F equals 100 degrees C, and finally that -40 degrees F equals -40 degrees C. </span><span class="koboSpan" id="kobo.530.3">If the script converts those three temperatures correctly, we can be reasonably sure that the rest of the temperatures are getting converted correctly.</span></p>
    <div class="note">
      <p class="normal"><span class="koboSpan" id="kobo.531.1">Be sure that you haven’t inserted a blank line after the last temperature line, or else the script will insert non-sense information after the last actual line of output data.</span></p>
    </div>
    <p class="normal"><span class="koboSpan" id="kobo.532.1">There are two ways to express the conversion formula. </span><span class="koboSpan" id="kobo.532.2">Here’s one way:</span></p>
    <pre class="programlisting gen"><code class="hljs-con"><span class="koboSpan" id="kobo.533.1">(($1-32)*5) / 9
</span></code></pre>
    <p class="normal"><span class="koboSpan" id="kobo.534.1">Here’s the other way:</span></p>
    <pre class="programlisting gen"><code class="hljs-con"><span class="koboSpan" id="kobo.535.1">($1-32)/1.8
</span></code></pre>
    <p class="normal"><span class="koboSpan" id="kobo.536.1">The </span><code class="inlineCode"><span class="koboSpan" id="kobo.537.1">$1</span></code><span class="koboSpan" id="kobo.538.1"> represents the field that holds the original Fahrenheit temperature. </span><span class="koboSpan" id="kobo.538.2">So, we begin by subtracting 32 from the Fahrenheit value.</span></p>
    <p class="normal"><span class="koboSpan" id="kobo.539.1">Either </span><a id="_idIndexMarker978"/><span class="koboSpan" id="kobo.540.1">formula works equally well, so it really doesn’t matter which one we use. </span><span class="koboSpan" id="kobo.540.2">Just for fun, I’ll use the first method in the </span><code class="inlineCode"><span class="koboSpan" id="kobo.541.1">fahrenheit_to_celsius.awk</span></code><span class="koboSpan" id="kobo.542.1"> script, which looks like this:</span></p>
    <pre class="programlisting gen"><code class="hljs-con"><span class="koboSpan" id="kobo.543.1">#!/usr/bin/awk -f
NR==1 ; NR&gt;1{print ($2=="F" ? </span><span class="koboSpan" id="kobo.543.2">(($1-32)*5) / 9 : $1)"\t\t Celsius"}
</span></code></pre>
    <p class="normal"><span class="koboSpan" id="kobo.544.1">As you see, it’s just a simple one-liner. </span><span class="koboSpan" id="kobo.544.2">The </span><code class="inlineCode"><span class="koboSpan" id="kobo.545.1">NR==1</span></code><span class="koboSpan" id="kobo.546.1"> causes the header to print out, and the </span><code class="inlineCode"><span class="koboSpan" id="kobo.547.1">NR&gt;1</span></code><span class="koboSpan" id="kobo.548.1"> ensures that the conversions are performed only on the lines that contain actual </span><a id="_idIndexMarker979"/><span class="koboSpan" id="kobo.549.1">data. </span><span class="koboSpan" id="kobo.549.2">The combination of the </span><code class="inlineCode"><span class="koboSpan" id="kobo.550.1">?</span></code><span class="koboSpan" id="kobo.551.1"> and the </span><code class="inlineCode"><span class="koboSpan" id="kobo.552.1">:</span></code><span class="koboSpan" id="kobo.553.1"> in the </span><code class="inlineCode"><span class="koboSpan" id="kobo.554.1">print</span></code><span class="koboSpan" id="kobo.555.1"> action is known as a </span><strong class="keyWord"><span class="koboSpan" id="kobo.556.1">ternary operator</span></strong><span class="koboSpan" id="kobo.557.1">. </span><span class="koboSpan" id="kobo.557.2">If the first term (</span><code class="inlineCode"><span class="koboSpan" id="kobo.558.1">$2=="F"</span></code><span class="koboSpan" id="kobo.559.1">) evaluates to true, then the original value of field 1 will be replaced by the value that’s between the </span><code class="inlineCode"><span class="koboSpan" id="kobo.560.1">?</span></code><span class="koboSpan" id="kobo.561.1"> and the </span><code class="inlineCode"><span class="koboSpan" id="kobo.562.1">:</span></code><span class="koboSpan" id="kobo.563.1">. </span><span class="koboSpan" id="kobo.563.2">In this case, the new value is derived from performing the conversion calculation. </span><span class="koboSpan" id="kobo.563.3">After the new temperature value on each line, we want to print out a pair of tabs, followed by the word Celsius. </span><span class="koboSpan" id="kobo.563.4">Here’s what happens when I run the script:</span></p>
    <pre class="programlisting gen"><code class="hljs-con"><span class="koboSpan" id="kobo.564.1">donnie@fedora:~$ ./fahrenheit_to_celsius.awk temps.txt
Temperature Celsius_or_Fahrenheit
0		 Celsius
100		 Celsius
-40		 Celsius
-25.9444		 Celsius
24.6111	 Celsius
24.3333	 Celsius
12.8944	 Celsius
23.9444	 Celsius
-1.22222		 Celsius
40.1889	 Celsius
37		 Celsius
23.1		 Celsius
donnie@fedora:~$
</span></code></pre>
    <p class="normal"><span class="koboSpan" id="kobo.565.1">That doesn’t look so good, because some of the Celsius values are longer than the others, which causes the second column of those lines to not line up correctly. </span><span class="koboSpan" id="kobo.565.2">We’ll fix this by using </span><code class="inlineCode"><span class="koboSpan" id="kobo.566.1">printf </span></code><span class="koboSpan" id="kobo.567.1">instead of </span><code class="inlineCode"><span class="koboSpan" id="kobo.568.1">print</span></code><span class="koboSpan" id="kobo.569.1">.</span></p>
    <p class="normal"><span class="koboSpan" id="kobo.570.1">The </span><code class="inlineCode"><span class="koboSpan" id="kobo.571.1">printf</span></code><span class="koboSpan" id="kobo.572.1"> command</span><a id="_idIndexMarker980"/><span class="koboSpan" id="kobo.573.1"> allows you to customize the output in ways that you can’t do with </span><code class="inlineCode"><span class="koboSpan" id="kobo.574.1">print</span></code><span class="koboSpan" id="kobo.575.1">. </span><span class="koboSpan" id="kobo.575.2">It works </span><a id="_idIndexMarker981"/><span class="koboSpan" id="kobo.576.1">pretty much the same way in </span><code class="inlineCode"><span class="koboSpan" id="kobo.577.1">awk</span></code><span class="koboSpan" id="kobo.578.1"> as it does in C, so once again you C programmers can rejoice. </span><span class="koboSpan" id="kobo.578.2">Here’s how the solution works in the </span><code class="inlineCode"><span class="koboSpan" id="kobo.579.1">fahrenheit_to_celsius2.awk</span></code><span class="koboSpan" id="kobo.580.1"> script:</span></p>
    <pre class="programlisting gen"><code class="hljs-con"><span class="koboSpan" id="kobo.581.1">#!/usr/bin/awk -f
NR==1; NR&gt;1{printf("%-11s %s\n",($2=="F" ? </span><span class="koboSpan" id="kobo.581.2">(($1-32)*5) / 9 : $1), "Celsius")}
</span></code></pre>
    <p class="normal"><span class="koboSpan" id="kobo.582.1">The </span><code class="inlineCode"><span class="koboSpan" id="kobo.583.1">%</span></code><span class="koboSpan" id="kobo.584.1"> signs in the </span><code class="inlineCode"><span class="koboSpan" id="kobo.585.1">printf</span></code><span class="koboSpan" id="kobo.586.1"> command represent formatting directives. </span><span class="koboSpan" id="kobo.586.2">Let’s take the </span><code class="inlineCode"><span class="koboSpan" id="kobo.587.1">%-11s</span></code><span class="koboSpan" id="kobo.588.1"> directive, which formats the first field in each line. </span><span class="koboSpan" id="kobo.588.2">The </span><code class="inlineCode"><span class="koboSpan" id="kobo.589.1">-</span></code><span class="koboSpan" id="kobo.590.1"> tells </span><code class="inlineCode"><span class="koboSpan" id="kobo.591.1">printf</span></code><span class="koboSpan" id="kobo.592.1"> to left-justify the output. </span><span class="koboSpan" id="kobo.592.2">(By default, the output is right-justified.) The </span><code class="inlineCode"><span class="koboSpan" id="kobo.593.1">11s</span></code><span class="koboSpan" id="kobo.594.1"> tells </span><code class="inlineCode"><span class="koboSpan" id="kobo.595.1">printf</span></code><span class="koboSpan" id="kobo.596.1"> to allocate 11 spaces for the first field of output. </span><span class="koboSpan" id="kobo.596.2">If the string in any given line is less than 11 characters long, then </span><code class="inlineCode"><span class="koboSpan" id="kobo.597.1">printf</span></code><span class="koboSpan" id="kobo.598.1"> will pad the output with enough blank spaces to make up the difference. </span><span class="koboSpan" id="kobo.598.2">Finally, </span><code class="inlineCode"><span class="koboSpan" id="kobo.599.1">%s\n</span></code><span class="koboSpan" id="kobo.600.1"> causes </span><code class="inlineCode"><span class="koboSpan" id="kobo.601.1">printf</span></code><span class="koboSpan" id="kobo.602.1"> to print out the designated text string as the second field, followed by a newline. </span><span class="koboSpan" id="kobo.602.2">(Unlike </span><code class="inlineCode"><span class="koboSpan" id="kobo.603.1">print</span></code><span class="koboSpan" id="kobo.604.1">, </span><code class="inlineCode"><span class="koboSpan" id="kobo.605.1">printf</span></code><span class="koboSpan" id="kobo.606.1"> doesn’t automatically add a newline at the end of a line.) Anyway, here’s the output:</span></p>
    <pre class="programlisting gen"><code class="hljs-con"><span class="koboSpan" id="kobo.607.1">donnie@fedora:~$ ./fahrenheit_to_celsius2.awk temps.txt
Temperature Celsius_or_Fahrenheit
0           Celsius
100         Celsius
-40         Celsius
-25.9444    Celsius
24.6111     Celsius
24.3333     Celsius
12.8944     Celsius
23.9444     Celsius
-1.22222    Celsius
40.1889     Celsius
37          Celsius
23.1        Celsius
donnie@fedora:~$
</span></code></pre>
    <p class="normal"><span class="koboSpan" id="kobo.608.1">Yes, that looks </span><a id="_idIndexMarker982"/><span class="koboSpan" id="kobo.609.1">much better. </span><span class="koboSpan" id="kobo.609.2">But, what if you don’t need to see all of those decimal places? </span><span class="koboSpan" id="kobo.609.3">Easy, just use a different formatting directive for the first field, as you see here in the </span><code class="inlineCode"><span class="koboSpan" id="kobo.610.1">fahrenheit_to_celsius3.awk</span></code><span class="koboSpan" id="kobo.611.1"> script:</span></p>
    <pre class="programlisting gen"><code class="hljs-con"><span class="koboSpan" id="kobo.612.1">#!/usr/bin/awk -f
NR==1; NR&gt;1{printf("%.2f %s\n",($2=="F" ? </span><span class="koboSpan" id="kobo.612.2">(($1-32)*5) / 9 : $1), "Celsius")}
</span></code></pre>
    <p class="normal"><span class="koboSpan" id="kobo.613.1">Here, I’m using </span><code class="inlineCode"><span class="koboSpan" id="kobo.614.1">%.2f</span></code><span class="koboSpan" id="kobo.615.1"> to format the output as a floating point number with only two digits after the decimal point. </span><span class="koboSpan" id="kobo.615.2">Here’s how the output looks:</span></p>
    <pre class="programlisting gen"><code class="hljs-con"><span class="koboSpan" id="kobo.616.1">donnie@fedora:~$ ./fahrenheit_to_celsius3.awk temps.txt
Temperature Celsius_or_Fahrenheit
0.00 Celsius
100.00 Celsius
-40.00 Celsius
-25.94 Celsius
24.61 Celsius
24.33 Celsius
12.89 Celsius
23.94 Celsius
-1.22 Celsius
40.19 Celsius
37.00 Celsius
23.10 Celsius
donnie@fedora:~$
</span></code></pre>
    <p class="normal"><span class="koboSpan" id="kobo.617.1">The only slight catch is that now the second column doesn’t line up correctly. </span><span class="koboSpan" id="kobo.617.2">You can’t use two directives together for a single field, so we’ll just have to live with it like this. </span><span class="koboSpan" id="kobo.617.3">That’s okay though, because if you decide to redirect this output into a file, you’ll still be able to import it into a spreadsheet program.</span></p>
    <p class="normal"><span class="koboSpan" id="kobo.618.1">With a slight</span><a id="_idIndexMarker983"/><span class="koboSpan" id="kobo.619.1"> change in the formula, you can also change Celsius temperatures to Fahrenheit. </span><span class="koboSpan" id="kobo.619.2">Here’s the </span><code class="inlineCode"><span class="koboSpan" id="kobo.620.1">celsius_to_fahrenheit2.awk</span></code><span class="koboSpan" id="kobo.621.1"> script that does that:</span></p>
    <pre class="programlisting gen"><code class="hljs-con"><span class="koboSpan" id="kobo.622.1">#!/usr/bin/awk -f
NR==1; NR&gt;1{printf("%-11s %s\n",($2=="C" ? </span><span class="koboSpan" id="kobo.622.2">(($1+32)*9) / 5 : $1),"Fahrenheit")}
</span></code></pre>
    <p class="normal"><span class="koboSpan" id="kobo.623.1">And, here’s the output:</span></p>
    <pre class="programlisting gen"><code class="hljs-con"><span class="koboSpan" id="kobo.624.1">donnie@fedora:~$ ./celsius_to_fahrenheit2.awk temps.txt
Temperature Celsius_or_Fahrenheit
32            Fahrenheit
212           Fahrenheit
-40           Fahrenheit
-14.7         Fahrenheit
101.9         Fahrenheit
75.8          Fahrenheit
55.21         Fahrenheit
100.7         Fahrenheit
29.8          Fahrenheit
104.34        Fahrenheit
98.6          Fahrenheit
99.18         Fahrenheit
donnie@fedora:~$
</span></code></pre>
    <p class="normal"><span class="koboSpan" id="kobo.625.1">Next, let’s say that we don’t care about seeing the list of temperatures, and only want to see the average. </span><span class="koboSpan" id="kobo.625.2">Well, here’s the </span><code class="inlineCode"><span class="koboSpan" id="kobo.626.1">average_temp.awk </span></code><span class="koboSpan" id="kobo.627.1">script which does that:</span></p>
    <pre class="programlisting gen"><code class="hljs-con"><span class="koboSpan" id="kobo.628.1">#!/usr/bin/awk -f
BEGIN{temp_sum=0; total_records=0; print "Calculate the average temperature."}
$2=="F"{temp_sum += ($1-32) / 1.8; total_records += 1;}
$2=="C" {temp_sum += $1; total_records += 1}
END {average_temp = temp_sum/total_records; print "The average temperature is: \n\t " average_temp " Celsius."}
</span></code></pre>
    <p class="normal"><span class="koboSpan" id="kobo.629.1">This time, I decided to use the alternate formula for converting from Fahrenheit to Celsius. </span><span class="koboSpan" id="kobo.629.2">In</span><a id="_idIndexMarker984"/><span class="koboSpan" id="kobo.630.1"> both of the </span><code class="inlineCode"><span class="koboSpan" id="kobo.631.1">$2==</span></code><span class="koboSpan" id="kobo.632.1"> lines, I’m using the </span><code class="inlineCode"><span class="koboSpan" id="kobo.633.1">+=</span></code><span class="koboSpan" id="kobo.634.1"> operator to sum the temperatures in the first field and to increment the </span><code class="inlineCode"><span class="koboSpan" id="kobo.635.1">total_records</span></code><span class="koboSpan" id="kobo.636.1"> variable. </span><span class="koboSpan" id="kobo.636.2">Here’s the output:</span></p>
    <pre class="programlisting gen"><code class="hljs-con"><span class="koboSpan" id="kobo.637.1">donnie@fedora:~$ ./average_temp.awk temps.txt
Calculate the average temperature.
</span><span class="koboSpan" id="kobo.637.2">The average temperature is:
	 18.2421 Celsius.
</span><span class="koboSpan" id="kobo.637.3">donnie@fedora:~$
</span></code></pre>
    <p class="normal"><span class="koboSpan" id="kobo.638.1">To verify that it’s giving you accurate averages, play around with different temperature values in the </span><code class="inlineCode"><span class="koboSpan" id="kobo.639.1">temps.txt</span></code><span class="koboSpan" id="kobo.640.1"> file to see what happens.</span></p>
    <p class="normal"><span class="koboSpan" id="kobo.641.1">The final thing I’ll say on this topic is that </span><code class="inlineCode"><span class="koboSpan" id="kobo.642.1">awk</span></code><span class="koboSpan" id="kobo.643.1"> offers the full range of math operators, as well as a good selection of math functions. </span><span class="koboSpan" id="kobo.643.2">You can find out more by following the links in the </span><em class="chapterRef"><span class="koboSpan" id="kobo.644.1">Further Reading</span></em><span class="koboSpan" id="kobo.645.1"> section.</span></p>
    <p class="normal"><span class="koboSpan" id="kobo.646.1">Next, let’s see what we can do with multi-line records.</span></p>
    <h1 id="_idParaDest-326" class="heading 1"><span class="koboSpan" id="kobo.647.1">Working with Multi-Line Records</span></h1>
    <p class="normal"><span class="koboSpan" id="kobo.648.1">So far, we’ve</span><a id="_idIndexMarker985"/><span class="koboSpan" id="kobo.649.1"> been using </span><code class="inlineCode"><span class="koboSpan" id="kobo.650.1">awk</span></code><span class="koboSpan" id="kobo.651.1"> to parse text files in which each line is its own distinct record. </span><span class="koboSpan" id="kobo.651.2">Sometimes though, you might have to work with files that have each record spread across several lines. </span><span class="koboSpan" id="kobo.651.3">For example, look at this </span><code class="inlineCode"><span class="koboSpan" id="kobo.652.1">inventory.txt</span></code><span class="koboSpan" id="kobo.653.1"> file:</span></p>
    <pre class="programlisting gen"><code class="hljs-con"><span class="koboSpan" id="kobo.654.1">Kitchen spatula
$4.99
Housewares
Raincoat
$36.99
Clothing
On Sale!
</span><span class="koboSpan" id="kobo.654.2">Claw hammer
$7.99
Tools
</span></code></pre>
    <p class="normal"><span class="koboSpan" id="kobo.655.1">The first and third records each consist of three lines, and the second record consists of four lines. </span><span class="koboSpan" id="kobo.655.2">Each record is separated by a blank space. </span><span class="koboSpan" id="kobo.655.3">Now, let’s say that we need to import this information into a spreadsheet. </span><span class="koboSpan" id="kobo.655.4">That won’t work well with</span><a id="_idIndexMarker986"/><span class="koboSpan" id="kobo.656.1"> multi-line records, so we’ll need to find an easy way to convert it into a spreadsheet-friendly format. </span><span class="koboSpan" id="kobo.656.2">Once again, </span><code class="inlineCode"><span class="koboSpan" id="kobo.657.1">awk</span></code><span class="koboSpan" id="kobo.658.1"> to the rescue! </span><span class="koboSpan" id="kobo.658.2">Here’s the </span><code class="inlineCode"><span class="koboSpan" id="kobo.659.1">inventory.awk</span></code><span class="koboSpan" id="kobo.660.1"> script that helps us out:</span></p>
    <pre class="programlisting gen"><code class="hljs-con"><span class="koboSpan" id="kobo.661.1">#!/usr/bin/awk -f
BEGIN {
        FS="\n"
        RS=""
        ORS=""
}
{
        count=1
        while (count&lt;NF) {
                print $count "\t"
                count++
        }
        print $NF "\n"
}
</span></code></pre>
    <p class="normal"><span class="koboSpan" id="kobo.662.1">The </span><code class="inlineCode"><span class="koboSpan" id="kobo.663.1">BEGIN</span></code><span class="koboSpan" id="kobo.664.1"> block defines the newline (</span><code class="inlineCode"><span class="koboSpan" id="kobo.665.1">\n</span></code><span class="koboSpan" id="kobo.666.1">) as the field separator, which means that each line in a record is its own field. </span><span class="koboSpan" id="kobo.666.2">The record separator (</span><code class="inlineCode"><span class="koboSpan" id="kobo.667.1">RS</span></code><span class="koboSpan" id="kobo.668.1">) and the output record separator (</span><code class="inlineCode"><span class="koboSpan" id="kobo.669.1">ORS</span></code><span class="koboSpan" id="kobo.670.1">) are each defined as a null value (</span><code class="inlineCode"><span class="koboSpan" id="kobo.671.1">""</span></code><span class="koboSpan" id="kobo.672.1">). </span><span class="koboSpan" id="kobo.672.2">The </span><code class="inlineCode"><span class="koboSpan" id="kobo.673.1">RS</span></code><span class="koboSpan" id="kobo.674.1"> variable interprets the null value as a blank line, but the </span><code class="inlineCode"><span class="koboSpan" id="kobo.675.1">ORS</span></code><span class="koboSpan" id="kobo.676.1"> variable doesn’t. </span><span class="koboSpan" id="kobo.676.2">In this case, having </span><code class="inlineCode"><span class="koboSpan" id="kobo.677.1">ORS</span></code><span class="koboSpan" id="kobo.678.1"> defined as a null value just prevents the </span><code class="inlineCode"><span class="koboSpan" id="kobo.679.1">print</span></code><span class="koboSpan" id="kobo.680.1"> command in the </span><code class="inlineCode"><span class="koboSpan" id="kobo.681.1">while</span></code><span class="koboSpan" id="kobo.682.1"> loop from adding a newline at the end of each field.</span></p>
    <p class="normal"><span class="koboSpan" id="kobo.683.1">There’s not much in the </span><code class="inlineCode"><span class="koboSpan" id="kobo.684.1">while</span></code><span class="koboSpan" id="kobo.685.1"> loop that you haven’t seen before. </span><span class="koboSpan" id="kobo.685.2">It just uses the </span><code class="inlineCode"><span class="koboSpan" id="kobo.686.1">count</span></code><span class="koboSpan" id="kobo.687.1"> variable to hold the number of the field that’s being processed. </span><span class="koboSpan" id="kobo.687.2">The value of this </span><code class="inlineCode"><span class="koboSpan" id="kobo.688.1">count </span></code><span class="koboSpan" id="kobo.689.1">variable gets incremented by 1 after each iteration of the </span><code class="inlineCode"><span class="koboSpan" id="kobo.690.1">while</span></code><span class="koboSpan" id="kobo.691.1"> loop. </span><span class="koboSpan" id="kobo.691.2">You might think it strange that the loop parameter is defined as </span><code class="inlineCode"><span class="koboSpan" id="kobo.692.1">count&lt;NF</span></code><span class="koboSpan" id="kobo.693.1"> instead of </span><code class="inlineCode"><span class="koboSpan" id="kobo.694.1">count&lt;=NF</span></code><span class="koboSpan" id="kobo.695.1">. </span><span class="koboSpan" id="kobo.695.2">I mean, wouldn’t we want to process the last field in every record? </span><span class="koboSpan" id="kobo.695.3">Well, we do process that last field with the </span><code class="inlineCode"><span class="koboSpan" id="kobo.696.1">print $NF "\n"</span></code><span class="koboSpan" id="kobo.697.1"> command that comes after the </span><code class="inlineCode"><span class="koboSpan" id="kobo.698.1">while</span></code><span class="koboSpan" id="kobo.699.1"> loop. </span><span class="koboSpan" id="kobo.699.2">As I said, defining the </span><code class="inlineCode"><span class="koboSpan" id="kobo.700.1">OFS</span></code><span class="koboSpan" id="kobo.701.1"> as </span><code class="inlineCode"><span class="koboSpan" id="kobo.702.1">""</span></code><span class="koboSpan" id="kobo.703.1"> prevents the </span><code class="inlineCode"><span class="koboSpan" id="kobo.704.1">print</span></code><span class="koboSpan" id="kobo.705.1"> command</span><a id="_idIndexMarker987"/><span class="koboSpan" id="kobo.706.1"> from adding a newline character at the end of each field. </span><span class="koboSpan" id="kobo.706.2">So, in order to have each record on a separate line, we have to have a separate </span><code class="inlineCode"><span class="koboSpan" id="kobo.707.1">print</span></code><span class="koboSpan" id="kobo.708.1"> command for the final field, and specify that it will add a newline at the end of the line. </span><span class="koboSpan" id="kobo.708.2">At any rate, here’s how things look when I use the script to parse the </span><code class="inlineCode"><span class="koboSpan" id="kobo.709.1">inventory.txt </span></code><span class="koboSpan" id="kobo.710.1">file:</span></p>
    <pre class="programlisting gen"><code class="hljs-con"><span class="koboSpan" id="kobo.711.1">donnie@fedora:~$ ./inventory.awk inventory.txt
Kitchen spatula	$4.99		Housewares
Raincoat		$36.99		Clothing	On Sale!
</span><span class="koboSpan" id="kobo.711.2">Claw hammer		$7.99		Tools
donnie@fedora:~$
</span></code></pre>
    <p class="normal"><span class="koboSpan" id="kobo.712.1">Of course, you can redirect the output into a </span><code class="inlineCode"><span class="koboSpan" id="kobo.713.1">.tsv</span></code><span class="koboSpan" id="kobo.714.1"> file that you can open in your favorite spreadsheet program. </span><span class="koboSpan" id="kobo.714.2">If you’d rather use a </span><code class="inlineCode"><span class="koboSpan" id="kobo.715.1">.csv</span></code><span class="koboSpan" id="kobo.716.1"> file, just replace the print </span><code class="inlineCode"><span class="koboSpan" id="kobo.717.1">$count "\t"</span></code><span class="koboSpan" id="kobo.718.1"> line in the </span><code class="inlineCode"><span class="koboSpan" id="kobo.719.1">while</span></code><span class="koboSpan" id="kobo.720.1"> loop with print </span><code class="inlineCode"><span class="koboSpan" id="kobo.721.1">$count ","</span></code><span class="koboSpan" id="kobo.722.1">. </span><span class="koboSpan" id="kobo.722.2">The output will then look like this:</span></p>
    <pre class="programlisting gen"><code class="hljs-con"><span class="koboSpan" id="kobo.723.1">donnie@fedora:~$ ./inventory.awk inventory.txt
Kitchen spatula,$4.99,Housewares
Raincoat,$36.99,Clothing,On Sale!
</span><span class="koboSpan" id="kobo.723.2">Claw hammer,$7.99,Tools
donnie@fedora:~$
</span></code></pre>
    <p class="normal"><span class="koboSpan" id="kobo.724.1">The beauty of this script is that it doesn’t matter how many fields you have in each record. </span><span class="koboSpan" id="kobo.724.2">The </span><code class="inlineCode"><span class="koboSpan" id="kobo.725.1">NF</span></code><span class="koboSpan" id="kobo.726.1"> built-in variable keeps track of how many fields there are, and the </span><code class="inlineCode"><span class="koboSpan" id="kobo.727.1">while</span></code><span class="koboSpan" id="kobo.728.1"> loop processes each record accordingly.</span></p>
    <p class="normal"><span class="koboSpan" id="kobo.729.1">Okay, I think that this will pretty much wrap up our introduction to </span><code class="inlineCode"><span class="koboSpan" id="kobo.730.1">awk</span></code><span class="koboSpan" id="kobo.731.1"> scripting. </span><span class="koboSpan" id="kobo.731.2">So, let’s summarize and move on.</span></p>
    <h1 id="_idParaDest-327" class="heading 1"><span class="koboSpan" id="kobo.732.1">Summary</span></h1>
    <p class="normal"><span class="koboSpan" id="kobo.733.1">The </span><code class="inlineCode"><span class="koboSpan" id="kobo.734.1">awk</span></code><span class="koboSpan" id="kobo.735.1"> scripting language is exceedingly useful for anyone who needs to extract meaningful data from plain-text files. </span><span class="koboSpan" id="kobo.735.2">I began this chapter by showing you the basic construction of an </span><code class="inlineCode"><span class="koboSpan" id="kobo.736.1">awk</span></code><span class="koboSpan" id="kobo.737.1"> script. </span><span class="koboSpan" id="kobo.737.2">Then, I showed you how to use </span><code class="inlineCode"><span class="koboSpan" id="kobo.738.1">if</span></code><span class="koboSpan" id="kobo.739.1"> and </span><code class="inlineCode"><span class="koboSpan" id="kobo.740.1">if..else</span></code><span class="koboSpan" id="kobo.741.1"> to create conditional commands, how to use </span><code class="inlineCode"><span class="koboSpan" id="kobo.742.1">while</span></code><span class="koboSpan" id="kobo.743.1"> loops, and how to parse text files with multi-line records. </span><span class="koboSpan" id="kobo.743.2">For the demos, I showed you various </span><code class="inlineCode"><span class="koboSpan" id="kobo.744.1">awk</span></code><span class="koboSpan" id="kobo.745.1"> scripts that do the types of jobs that you might encounter in real life.</span></p>
    <p class="normal"><span class="koboSpan" id="kobo.746.1">Unfortunately, there’s no way that I can do complete justice with this presentation of </span><code class="inlineCode"><span class="koboSpan" id="kobo.747.1">awk</span></code><span class="koboSpan" id="kobo.748.1">. </span><span class="koboSpan" id="kobo.748.2">It’s another of those topics about which entire books have been written, so the best I can do here is to just whet your appetite.</span></p>
    <p class="normal"><span class="koboSpan" id="kobo.749.1">In the next chapter, we’ll get back to the main topic of shell scripting, by looking at a couple of utilities that allow you to create user interfaces for your scripts. </span><span class="koboSpan" id="kobo.749.2">I’ll see you there.</span></p>
    <h1 id="_idParaDest-328" class="heading 1"><span class="koboSpan" id="kobo.750.1">Questions</span></h1>
    <ol>
      <li class="numberedList" value="1"><span class="koboSpan" id="kobo.751.1">For the best portability, which of the following shebang lines should you place in your </span><code class="inlineCode"><span class="koboSpan" id="kobo.752.1">awk</span></code><span class="koboSpan" id="kobo.753.1"> scripts?</span><ol>
          <li class="alphabeticList level 2" value="1"><code class="inlineCode"><span class="koboSpan" id="kobo.754.1">#!/bin/awk</span></code></li>
          <li class="alphabeticList level 2"><code class="inlineCode"><span class="koboSpan" id="kobo.755.1">#!/usr/bin/awk -f</span></code></li>
          <li class="alphabeticList level 2"><code class="inlineCode"><span class="koboSpan" id="kobo.756.1">#!/bin/awk -f</span></code></li>
          <li class="alphabeticList level 2"><code class="inlineCode"><span class="koboSpan" id="kobo.757.1">#!/usr/bin/awk</span></code></li>
        </ol>
      </li>
      <li class="numberedList"><span class="koboSpan" id="kobo.758.1">Which of the following statements is true?</span><ol>
          <li class="alphabeticList level 2" value="1"><span class="koboSpan" id="kobo.759.1">All </span><code class="inlineCode"><span class="koboSpan" id="kobo.760.1">awk</span></code><span class="koboSpan" id="kobo.761.1"> programming variables must be declared before you use them.</span></li>
          <li class="alphabeticList level 2"><span class="koboSpan" id="kobo.762.1">There are various types of </span><code class="inlineCode"><span class="koboSpan" id="kobo.763.1">awk</span></code><span class="koboSpan" id="kobo.764.1"> variables, such as integer, floating-point, and string.</span></li>
          <li class="alphabeticList level 2"><span class="koboSpan" id="kobo.765.1">All </span><code class="inlineCode"><span class="koboSpan" id="kobo.766.1">awk</span></code><span class="koboSpan" id="kobo.767.1"> programming variables are string-type variables.</span></li>
          <li class="alphabeticList level 2"><span class="koboSpan" id="kobo.768.1">You must convert string-type variables to either integer or floating-point variables before using them in math operations.</span></li>
        </ol>
      </li>
      <li class="numberedList"><span class="koboSpan" id="kobo.769.1">Within an </span><code class="inlineCode"><span class="koboSpan" id="kobo.770.1">awk</span></code><span class="koboSpan" id="kobo.771.1"> script, how would you define the comma as the field separator?</span><ol>
          <li class="alphabeticList level 2" value="1"><code class="inlineCode"><span class="koboSpan" id="kobo.772.1">-F=,</span></code></li>
          <li class="alphabeticList level 2"><code class="inlineCode"><span class="koboSpan" id="kobo.773.1">-F=","</span></code></li>
          <li class="alphabeticList level 2"> <code class="inlineCode"><span class="koboSpan" id="kobo.774.1">FS=,</span></code></li>
          <li class="alphabeticList level 2"><span class="koboSpan" id="kobo.775.1">. </span><code class="inlineCode"><span class="koboSpan" id="kobo.776.1">FS=","</span></code></li>
        </ol>
      </li>
      <li class="numberedList"><span class="koboSpan" id="kobo.777.1">You have a text file with several lines of numbers, with blank spaces between the numbers. </span><span class="koboSpan" id="kobo.777.2">Each line has a different number of numbers. </span><span class="koboSpan" id="kobo.777.3">You want to sum the numbers on each line. </span><span class="koboSpan" id="kobo.777.4">When you write an </span><code class="inlineCode"><span class="koboSpan" id="kobo.778.1">awk</span></code><span class="koboSpan" id="kobo.779.1"> script to create these sums, how would you account for the fact that each line has a different number of fields?</span><ol>
          <li class="alphabeticList level 2" value="1"><span class="koboSpan" id="kobo.780.1">Create a variable array to hold the number of fields in each line, and use a </span><code class="inlineCode"><span class="koboSpan" id="kobo.781.1">for</span></code><span class="koboSpan" id="kobo.782.1"> loop to build the array.</span></li>
          <li class="alphabeticList level 2"><span class="koboSpan" id="kobo.783.1">Use the </span><code class="inlineCode"><span class="koboSpan" id="kobo.784.1">NF</span></code><span class="koboSpan" id="kobo.785.1"> built-in variable.</span></li>
          <li class="alphabeticList level 2"><span class="koboSpan" id="kobo.786.1">Use the </span><code class="inlineCode"><span class="koboSpan" id="kobo.787.1">NR</span></code><span class="koboSpan" id="kobo.788.1"> built-in variable.</span></li>
          <li class="alphabeticList level 2"><span class="koboSpan" id="kobo.789.1">You can only do this when each line has the same number of fields.</span></li>
        </ol>
      </li>
      <li class="numberedList"><span class="koboSpan" id="kobo.790.1">Which of the following </span><code class="inlineCode"><span class="koboSpan" id="kobo.791.1">printf</span></code><span class="koboSpan" id="kobo.792.1"> directives would you use to ensure that a floating-point number always displays with four digits after the decimal point?</span><ol>
          <li class="alphabeticList level 2" value="1"><code class="inlineCode"><span class="koboSpan" id="kobo.793.1">%.4f</span></code></li>
          <li class="alphabeticList level 2"><code class="inlineCode"><span class="koboSpan" id="kobo.794.1">%4</span></code></li>
          <li class="alphabeticList level 2"><code class="inlineCode"><span class="koboSpan" id="kobo.795.1">#4.f</span></code></li>
          <li class="alphabeticList level 2"><code class="inlineCode"><span class="koboSpan" id="kobo.796.1">#4</span></code></li>
        </ol>
      </li>
    </ol>
    <h1 id="_idParaDest-329" class="heading 1"><span class="koboSpan" id="kobo.797.1">Further Reading</span></h1>
    <ul>
      <li class="bulletList"><span class="koboSpan" id="kobo.798.1">How do I check if my CPU supports x86_v2?: </span><a href="https://unix.stackexchange.com/questions/631217/how-do-i-check-if-my-cpu-supports-x86-64-v2"><span class="url"><span class="koboSpan" id="kobo.799.1">https://unix.stackexchange.com/questions/631217/how-do-i-check-if-my-cpu-supports-x86-64-v2</span></span></a></li>
      <li class="bulletList"><span class="koboSpan" id="kobo.800.1">Exploring x86-64-v3 for Red Hat Enterprise Linux 10: </span><a href="https://developers.redhat.com/articles/2024/01/02/exploring-x86-64-v3-red-hat-enterprise-linux-10"><span class="url"><span class="koboSpan" id="kobo.801.1">https://developers.redhat.com/articles/2024/01/02/exploring-x86-64-v3-red-hat-enterprise-linux-10</span></span></a></li>
      <li class="bulletList"><span class="koboSpan" id="kobo.802.1">x86_64 Levels: </span><a href="mailto:https://medium.com/@BetterIsHeather/x86-64-levels-944e92cd6d83"><span class="url"><span class="koboSpan" id="kobo.803.1">https://medium.com/@BetterIsHeather/x86-64-levels-944e92cd6d83</span></span></a></li>
      <li class="bulletList"><span class="koboSpan" id="kobo.804.1">How the awk Command Made Me a 10x Engineer: </span><a href="https://youtu.be/FbSpuZVb164?si=ri9cnjBh1sxM_STz"><span class="url"><span class="koboSpan" id="kobo.805.1">https://youtu.be/FbSpuZVb164?si=ri9cnjBh1sxM_STz</span></span></a></li>
      <li class="bulletList"><span class="koboSpan" id="kobo.806.1">Ternary Operators: </span><a href="https://www.tutorialspoint.com/awk/awk_ternary_operators.htm"><span class="url"><span class="koboSpan" id="kobo.807.1">https://www.tutorialspoint.com/awk/awk_ternary_operators.htm</span></span></a></li>
      <li class="bulletList"><span class="koboSpan" id="kobo.808.1">printf Examples: </span><a href="https://www.gnu.org/software/gawk/manual/html_node/Printf-Examples.html"><span class="url"><span class="koboSpan" id="kobo.809.1">https://www.gnu.org/software/gawk/manual/html_node/Printf-Examples.html</span></span></a></li>
      <li class="bulletList"><span class="koboSpan" id="kobo.810.1">Doing math with awk: </span><a href="https://www.networkworld.com/article/942538/doing-math-with-awk.html"><span class="url"><span class="koboSpan" id="kobo.811.1">https://www.networkworld.com/article/942538/doing-math-with-awk.html</span></span></a></li>
      <li class="bulletList"><span class="koboSpan" id="kobo.812.1">Numeric functions in awk: </span><a href="https://www.gnu.org/software/gawk/manual/html_node/Numeric-Functions.html"><span class="url"><span class="koboSpan" id="kobo.813.1">https://www.gnu.org/software/gawk/manual/html_node/Numeric-Functions.html</span></span></a></li>
    </ul>
    <h1 id="_idParaDest-330" class="heading 1"><span class="koboSpan" id="kobo.814.1">Answers</span></h1>
    <ol>
      <li class="numberedList" value="1"><span class="koboSpan" id="kobo.815.1">b</span></li>
      <li class="numberedList"><span class="koboSpan" id="kobo.816.1">c</span></li>
      <li class="numberedList"><span class="koboSpan" id="kobo.817.1">d</span></li>
      <li class="numberedList"><span class="koboSpan" id="kobo.818.1">b</span></li>
      <li class="numberedList"><span class="koboSpan" id="kobo.819.1">a</span></li>
    </ol>
    <h1 id="_idParaDest-331" class="heading 1"><span class="koboSpan" id="kobo.820.1">Join our community on Discord!</span></h1>
    <p class="normal"><span class="koboSpan" id="kobo.821.1">Read this book alongside other users, Linux experts, and the author himself. </span></p>
    <p class="normal"><span class="koboSpan" id="kobo.822.1">Ask questions, provide solutions to other readers, chat with the author via Ask Me Anything sessions, and much more. </span><span class="koboSpan" id="kobo.822.2">Scan the QR code or visit the link to join the community.</span></p>
    <p class="normal"><a href="https://packt.link/SecNet"><span class="url"><span class="koboSpan" id="kobo.823.1">https://packt.link/SecNet</span></span></a></p>
    <p class="normal"><span class="koboSpan" id="kobo.824.1"><img src="../Images/QR_Code10596186092701843.png" alt=""/></span></p>
  </div>
</body></html>