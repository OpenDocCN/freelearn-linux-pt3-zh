- en: '11'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '11'
- en: Creating Our First Module
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建我们的第一个模块
- en: Most programming languages include the concept of a library – an object that
    contains code, documentation, programming objects such as classes, message templates,
    and a host of other things. These libraries extend what we can do with that language
    by helping us to use other people’s code and reuse our own. In this chapter, we’re
    going to explore PowerShell modules – a convenient way of distributing PowerShell
    code.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数编程语言都包含库的概念——它是一个包含代码、文档、编程对象（如类）、消息模板以及许多其他内容的对象。这些库通过帮助我们使用他人的代码和重用我们自己的代码，扩展了我们可以用该语言做的事情。在本章中，我们将探讨
    PowerShell 模块——一种分发 PowerShell 代码的便捷方式。
- en: We’ll start by briefly recapping how to work with modules and the cmdlets we
    use to do that. Then, we’ll look at the components of a module. We’ll learn how
    to write a module manually, before wrapping up with a brief look at using a module
    scaffolding application called **Plaster**.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从简要回顾如何使用模块以及用于此的 cmdlet 开始。接下来，我们将查看模块的组成部分。我们将学习如何手动编写模块，然后简单介绍一下使用一个名为
    **Plaster** 的模块脚手架应用程序。
- en: 'The main topics we will cover in this chapter are as follows:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 本章我们将涵盖的主要主题如下：
- en: Working with modules
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用模块
- en: Writing a simple module
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编写一个简单的模块
- en: Module manifests
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 模块清单
- en: Using scaffolding tools such as Plaster
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用如 Plaster 这样的脚手架工具
- en: Working with modules
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用模块
- en: Back in [*Chapter 2*](B17600_02.xhtml#_idTextAnchor034), *Exploring PowerShell
    Cmdlets and Syntax*, we spent some time exploring how we can use modules to find
    new cmdlets. In this chapter, we’ll be writing modules, but first, let’s recap
    what we learned previously and place it in some sort of context.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 回到[*第二章*](B17600_02.xhtml#_idTextAnchor034)，*探索 PowerShell Cmdlet 和语法*，我们花了一些时间探讨了如何使用模块来查找新的
    cmdlet。在本章中，我们将编写模块，但首先，让我们回顾一下之前所学的内容，并将其放置在某种上下文中。
- en: Modules allow us to reuse and distribute code so that it can be easily automated
    by including the cmdlets that manipulate modules in our scripts. So, if we need
    a cmdlet from the PowerShell math module in our script, then we can programmatically
    import that module (or just the required cmdlet) and use it. We can do this in
    a predictable and controllable fashion, without user intervention.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 模块允许我们重用和分发代码，以便通过将操作模块的 cmdlet 包含在我们的脚本中轻松实现自动化。所以，如果我们需要在脚本中使用 PowerShell
    数学模块的 cmdlet，我们可以通过编程方式导入该模块（或仅导入所需的 cmdlet）并使用它。我们可以以可预测且可控的方式进行，而无需用户干预。
- en: 'Modules fulfill three basic functions:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 模块履行三个基本功能：
- en: '**Configuring the environment**: They provide a repeatable custom work environment
    – for example, the PowerShell module for Exchange, as well as Exchange-specific
    cmdlets – configuring the PowerShell environment to work in a particular way with
    Exchange'
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**配置环境**：它们提供一个可重复的自定义工作环境——例如，Exchange 的 PowerShell 模块，以及特定于 Exchange 的 cmdlet——将
    PowerShell 环境配置为以特定方式与 Exchange 协同工作。'
- en: '**Code reuse**: They provide libraries of functions that we or other people
    can use, such as the math module'
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**代码重用**：它们提供函数库，供我们或他人使用，例如数学模块。'
- en: '**Solution engineering**: Because modules can be nested inside other modules,
    whole groups of modules may be distributed to create an application for redistribution
    – this is common in Windows administration environments'
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**解决方案工程**：因为模块可以嵌套在其他模块中，所以可以将一整组模块分发出去，创建一个应用程序进行再分发——这在 Windows 管理环境中很常见。'
- en: We can find modules on the internet, in places such as GitHub, where they’ve
    been distributed with software, in a public repository such as the PowerShell
    Gallery or internal repositories in our workplace or school, or via friends and
    colleagues.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在互联网上找到模块，例如 GitHub，这里有软件发布的模块；也可以在公共仓库（如 PowerShell Gallery）或我们工作场所或学校的内部仓库中找到，或者通过朋友和同事获得。
- en: By installing the modules in standard locations, we can control access to them
    on a given machine, or we can add to the default list of places that PowerShell
    will search for modules. Let’s start by looking at the common locations for modules
    on our client device.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 通过将模块安装到标准位置，我们可以控制在特定机器上的访问权限，或者我们可以将 PowerShell 搜索模块的默认位置列表进行扩展。让我们从查看客户端设备上模块的常见位置开始。
- en: Module locations
  id: totrans-18
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 模块位置
- en: 'There are three default locations for modules. These are shown in the following
    table:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 模块有三个默认位置。这些位置如下表所示：
- en: '|  | **Windows** | **Linux** |'
  id: totrans-20
  prefs: []
  type: TYPE_TB
  zh: '|  | **Windows** | **Linux** |'
- en: '| **System** | None for PowerShell 7, but Windows PowerShell uses `C:\WINDOWS\system32\WindowsPowerShell\v1.0\Modules\`
    | `/``opt/Microsoft/PowerShell/7/Modules` |'
  id: totrans-21
  prefs: []
  type: TYPE_TB
  zh: '| **系统** | PowerShell 7没有此位置，但Windows PowerShell使用`C:\WINDOWS\system32\WindowsPowerShell\v1.0\Modules\`
    | `/opt/Microsoft/PowerShell/7/Modules` |'
- en: '| **AllUsers** |'
  id: totrans-22
  prefs: []
  type: TYPE_TB
  zh: '| **所有用户** |'
- en: '`C:\Program Files\PowerShell\Modules`'
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`C:\Program Files\PowerShell\Modules`'
- en: '`C:\Program Files\PowerShell\7\Modules`'
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`C:\Program Files\PowerShell\7\Modules`'
- en: '| `/``usr/local/share/PowerShell/Modules` |'
  id: totrans-25
  prefs: []
  type: TYPE_TB
  zh: '| `/usr/local/share/PowerShell/Modules` |'
- en: '| **User** | `C:\Users\<user name>\Documents\PowerShell\Modules` | `/``home/<username>/.local/share/PowerShell/Modules`
    |'
  id: totrans-26
  prefs: []
  type: TYPE_TB
  zh: '| **用户** | `C:\Users\<用户名>\Documents\PowerShell\Modules` | `/home/<用户名>/.local/share/PowerShell/Modules`
    |'
- en: Table 11.1 – Default module locations in Windows and Linux
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 表11.1 – Windows和Linux中的默认模块位置
- en: The System location is reserved for Microsoft modules. The User location does
    not exist by default in Windows and will need to be created before it can be used.
    The AllUsers location was introduced in PowerShell v4 to provide a location for
    non-Microsoft modules that need to run under the system account. This also gives
    us a place to install modules for any user on the client to use. Modules downloaded
    from the PowerShell Gallery are placed here by default.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 系统位置保留给微软模块。用户位置在Windows中默认不存在，需要先创建才能使用。`AllUsers`位置在PowerShell v4中引入，提供了一个用于需要在系统账户下运行的非微软模块的位置。这也为我们提供了一个为客户端上任何用户安装模块的地方。从PowerShell
    Gallery下载的模块默认放在这里。
- en: 'As we saw in [*Chapter 2*](B17600_02.xhtml#_idTextAnchor034), *Exploring PowerShell
    Cmdlets and Syntax*, we can add locations where we may install modules by manipulating
    the `$ENV:PSModulePath` variable. Locations should be separated by a semicolon
    (`;`) in Windows and a colon (`:`) in Linux, as shown here:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在[*第二章*](B17600_02.xhtml#_idTextAnchor034)中看到的，*探索PowerShell Cmdlet和语法*，我们可以通过操作`$ENV:PSModulePath`变量来添加可能安装模块的位置。位置应在Windows中用分号（`;`）分隔，在Linux中用冒号（`:`）分隔，如下所示：
- en: '![Figure 11.1 – The $env:PSModulePath variable in Linux](img/B17600_11_001.jpg)'
  id: totrans-30
  prefs: []
  type: TYPE_IMG
  zh: '![图11.1 – Linux中的$env:PSModulePath变量](img/B17600_11_001.jpg)'
- en: Figure 11.1 – The $env:PSModulePath variable in Linux
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.1 – Linux中的$env:PSModulePath变量
- en: We can make this listing tidier by calling the `$env:PSModulePath -Split ":"`
    variable, which will output each location on a separate line. Obviously, on a
    Windows client, the separator should be a semicolon (`;`). Paths often get added
    to this variable when installing applications.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过调用`$env:PSModulePath -Split ":"`变量使此列表更整洁，这将把每个位置输出为单独的一行。显然，在Windows客户端上，分隔符应为分号（`;`）。路径在安装应用程序时通常会被添加到此变量中。
- en: Module autoloading
  id: totrans-33
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 模块自动加载
- en: 'We can load modules automatically under certain circumstances. Modules in correctly
    named folders in the module paths defined in `$env:PSModulePath` are automatically
    discovered by PowerShell. We can do this by doing the following:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些情况下，我们可以自动加载模块。位于`$env:PSModulePath`定义的模块路径中，并且文件夹命名正确的模块会被PowerShell自动发现。我们可以通过以下方法做到这一点：
- en: Running a cmdlet from the module
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从模块中运行cmdlet
- en: Using `Get-Command` for a cmdlet in the module
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`Get-Command`获取模块中的cmdlet
- en: Using `Get-Help` for a cmdlet in the module
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`Get-Help`获取模块中的cmdlet
- en: 'Module autoloading is great for when we’re working interactively in the shell,
    but we shouldn’t rely on it in a script. The recommended way to load modules inside
    a script is with the `using` keyword, like this:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 模块自动加载在我们交互式地使用Shell时非常有用，但在脚本中不应依赖它。推荐的加载模块的方式是在脚本中使用`using`关键字，如下所示：
- en: '[PRE0]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Here’s an example:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个示例：
- en: '[PRE1]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Note that some caveats on this are covered in the *Nested* *modules* section.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，关于此内容的一些注意事项已在*嵌套* *模块*部分中讨论。
- en: Importing modules
  id: totrans-43
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 导入模块
- en: 'Autoloading modules is convenient, but it’s not particularly controlled. For
    instance, it loads everything in the module, some of which we might not need,
    and we cannot control the version of the module that is loaded. It can also consume
    a lot of memory. Therefore, we might choose to manually import modules into a
    session using the `Import-Module` cmdlet, which gives us several options to control
    how and what we import:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 自动加载模块非常方便，但它并不是特别可控。例如，它会加载模块中的所有内容，其中一些我们可能不需要，而且我们无法控制加载的模块版本。它还可能占用大量内存。因此，我们可能会选择使用`Import-Module`
    cmdlet手动将模块导入会话，这样可以给我们提供几个选项来控制导入的方式和内容：
- en: '`-Name`: Use this to specify the name of the module to import. We can also
    include a path here if the module is not in the module path specified in `$ENV:PSModulePath`.'
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-Name`：用来指定要导入的模块名称。如果模块不在`$ENV:PSModulePath`指定的模块路径中，我们还可以在此处包含路径。'
- en: '`-Cmdlet`: This allows us to import a selection of cmdlets from an array of
    strings. Similar parameters, such as `-Alias`, `-Function`, and `-Variable`, have
    the expected effect.'
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-Cmdlet`：这个参数允许我们从一个字符串数组中导入一组 cmdlet。类似的参数，如 `-Alias`、`-Function` 和 `-Variable`，也有预期的效果。'
- en: '`-Force`: This forces a module to reload completely. By default, if a module
    is already loaded, then `Import-Module` does not reimport it. This is useful if
    we are developing a module and need to test it repeatedly.'
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-Force`：这个参数强制模块完全重新加载。默认情况下，如果模块已经加载，则 `Import-Module` 不会重新导入它。如果我们在开发模块并需要反复测试它时，这个参数非常有用。'
- en: '`-RequiredVersion`: Use this to specify the version of the module to be imported.'
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-RequiredVersion`：使用此参数指定要导入的模块版本。'
- en: '`-Prefix`: This parameter adds a prefix to the nouns in cmdlets that are imported
    from the module, to prevent confusion with cmdlets that already exist in the session.'
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-Prefix`：这个参数会为从模块导入的 cmdlet 中的名词添加前缀，以避免与当前会话中已存在的 cmdlet 混淆。'
- en: '`-NoClobber`: This prevents cmdlets from being imported if they have the same
    name as cmdlets that already exist in the session.'
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-NoClobber`：如果 cmdlet 与当前会话中已存在的 cmdlet 同名，这个参数会阻止它们被导入。'
- en: There are several other parameters, but we won’t consider them here.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 还有其他一些参数，但我们在这里不考虑它们。
- en: We can unload a module using the `Remove-Module` cmdlet. Why might we want to
    do that? Well, when we first import a module, we import all the nested modules
    that it requires as well. However, if we then use `Import-Module -Force` to reload
    the module, it only reloads the named module, not the nested modules. `Remove-Module`
    also removes the nested modules. In practice, of course, just starting a new session
    is often quicker and cleaner.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用 `Remove-Module` cmdlet 卸载一个模块。为什么我们可能需要这么做呢？因为当我们第一次导入一个模块时，所有它所依赖的嵌套模块也会被一并导入。然而，如果我们随后使用
    `Import-Module -Force` 来重新加载该模块，它只会重新加载指定的模块，而不会重新加载嵌套模块。`Remove-Module` 也会移除嵌套模块。当然，在实际使用中，通常直接启动一个新的会话会更快捷、更清洁。
- en: Very often, we’ll see scripts on the internet using the `Import-Module` cmdlet
    to make module contents available inside a script. I do this too, despite it not
    being the recommended way of doing it; it just feels more readable to me. Microsoft
    recommends we do this with the `using` keyword, though. My doctor recommends I
    eat less salt; I tend to ignore that advice as well.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 我们经常会在互联网上看到使用 `Import-Module` cmdlet 使模块内容在脚本中可用的脚本。我自己也这么做，尽管这不是推荐的做法；对我来说，这样看起来更易读。微软推荐我们使用
    `using` 关键字来实现这个功能，尽管我也常常忽略这个建议，就像我的医生推荐我少吃盐一样，我也倾向于忽视他的建议。
- en: PowerShellGet
  id: totrans-54
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: PowerShellGet
- en: Microsoft has a module called `PowerShellGet` that includes a lot of resources
    for working with repositories and modules. This module is included in PowerShell
    7\. It allows us to work easily with the PowerShell Gallery so that we can find,
    register, and unregister other repositories, which allows us to find, install,
    and uninstall modules and scripts in repositories, as well as manipulate those
    modules and scripts. We covered the basic uses of `PowerShellGet` at some length
    in [*Chapter 2*](B17600_02.xhtml#_idTextAnchor034),*Exploring PowerShell Cmdlets*
    *and Syntax*.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: Microsoft 有一个名为 `PowerShellGet` 的模块，其中包含了大量用于操作仓库和模块的资源。这个模块包含在 PowerShell 7
    中。它使我们能够轻松地使用 PowerShell Gallery，这样我们就可以查找、注册和注销其他仓库，从而找到、安装和卸载仓库中的模块和脚本，并且操作这些模块和脚本。我们在[*第
    2 章*](B17600_02.xhtml#_idTextAnchor034)《探索 PowerShell Cmdlets 和语法》中详细介绍了 `PowerShellGet`
    的基本用法。
- en: From PowerShell 7.4 onwards, the PowerShellGet v2.2.5 module will be accompanied
    by version 3\. The version 3 module is called `Microsoft.Powershell.PSResourceGet`
    and replaces the `Install-Module` and `Install-Script` cmdlets with the single
    `Install-PSResource` cmdlet, among many other changes. In PowerShell 7.4, the
    two modules will ship side by side, allowing any current resources that use `PowerShellGet`
    to continue working. However, no compatibility layer will be included, so scripts
    written for v2.2.5 and earlier won’t work with version 3 unless we use the separate
    `CompatPowerShellGet` module that will be included in PowerShell 7.5.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 从 PowerShell 7.4 开始，PowerShellGet v2.2.5 模块将与版本 3 一同发布。版本 3 的模块名为 `Microsoft.Powershell.PSResourceGet`，它将用一个单一的
    `Install-PSResource` cmdlet 替代 `Install-Module` 和 `Install-Script` cmdlet，并做出许多其他更改。在
    PowerShell 7.4 中，这两个模块将并行发布，允许任何当前使用 `PowerShellGet` 的资源继续工作。然而，不会包含兼容层，因此，除非我们使用将在
    PowerShell 7.5 中提供的独立 `CompatPowerShellGet` 模块，否则为 v2.2.5 及更早版本编写的脚本将无法与版本 3 一起使用。
- en: Next, we’ll learn how to create a module, but first, a word of caution. There
    is a PowerShell cmdlet called `New-Module`. This creates a very specific type
    of module – a `New-Module`, either.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将学习如何创建一个模块，但首先有一个警告。PowerShell中有一个cmdlet叫做`New-Module`。这个命令创建的是一种非常特定类型的模块——`New-Module`。
- en: Writing a simple module
  id: totrans-58
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编写一个简单的模块
- en: 'A module, at its most basic, is a script file containing functions, saved with
    a `.psm1` extension. That’s it. That’s the simplest possible module. Try it –
    save the following lines as a `.psm1` file, in a folder with the same name as
    the file, inside your `\users\<username>\documents\powershell\modules` folder
    (or the `home/<user>/.local/share/powershell/Modules` folder in Linux):'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 模块最基本的形式是一个包含函数的脚本文件，文件扩展名为`.psm1`。就这么简单。这是最简单的模块。试试看——将以下内容保存为`.psm1`文件，放在一个与文件同名的文件夹内，位置为你的`\\users\\<username>\\documents\\powershell\\modules`文件夹（或Linux中的`home/<user>/.local/share/powershell/Modules`文件夹）：
- en: '[PRE2]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'It doesn’t matter what you call the file, so long as the file and folder name
    are the same, and the folder is in the module path so that PowerShell can find
    it, like this:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 文件名无关紧要，只要文件和文件夹的名称相同，并且文件夹在模块路径中，以便PowerShell能够找到它，就像这样：
- en: '![Figure 11.2 – Saving a module in the module path correctly](img/B17600_11_002.jpg)'
  id: totrans-62
  prefs: []
  type: TYPE_IMG
  zh: '![图11.2 – 正确地将模块保存到模块路径中](img/B17600_11_002.jpg)'
- en: Figure 11.2 – Saving a module in the module path correctly
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.2 – 正确地将模块保存到模块路径中
- en: 'Now, if we start a PowerShell session, we can type the following:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果我们启动一个PowerShell会话，可以输入以下内容：
- en: '[PRE3]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'PowerShell will load it. Once it is loaded, we can use the functions inside,
    like this:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: PowerShell将加载它。一旦加载完成，我们就可以使用模块内的函数，如下所示：
- en: '![Figure 11.3 – Using our first module](img/B17600_11_003.jpg)'
  id: totrans-67
  prefs: []
  type: TYPE_IMG
  zh: '![图11.3 – 使用我们的第一个模块](img/B17600_11_003.jpg)'
- en: Figure 11.3 – Using our first module
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.3 – 使用我们的第一个模块
- en: As you can see, the `Import-Module` cmdlet produces no output, but the function
    inside the module is available. If we run `Remove-Module`, the function disappears
    as well. Or does it?
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，`Import-Module` cmdlet没有输出，但模块内的函数是可用的。如果我们运行`Remove-Module`，函数也会消失。或者它真的消失了吗？
- en: Activity 1
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 活动1
- en: Try running `Remove-Module` to get rid of the module we’ve just installed, and
    then running `Get-Square`. What happens? Why does this happen?
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试运行`Remove-Module`来移除我们刚才安装的模块，然后再运行`Get-Square`。会发生什么？为什么会这样？
- en: Before we look at ways to create modules, let’s talk about the earliest method
    of building libraries in PowerShell – dot-sourcing.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们研究如何创建模块之前，让我们先谈谈PowerShell中最早构建库的方法——点来源。
- en: A word of caution – dot-sourcing
  id: totrans-73
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 提醒一下 – 点来源
- en: 'In the very first version of PowerShell, there was only one way to include
    the functions in one script inside another: `Dot-Source.ps1` in a suitable folder
    – I’m using `c:\temp\poshbook\ch11`:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 在PowerShell的第一个版本中，只有一种方法可以在一个脚本中包含另一个脚本中的函数：将`Dot-Source.ps1`放在适当的文件夹中——我使用的是`c:\\temp\\poshbook\\ch11`：
- en: '[PRE4]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'It should be obvious that if we run this, it isn’t going to work. There is
    no cmdlet called `Write-Message`, and the script doesn’t define one. Let’s create
    a `Write-Message` function in another script, and save it as `Write-Message.ps1`:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 很明显，如果我们运行这个，肯定无法工作。没有名为`Write-Message`的cmdlet，而且脚本中也没有定义一个。让我们在另一个脚本中创建一个`Write-Message`函数，并将其保存为`Write-Message.ps1`：
- en: '[PRE5]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Now, let’s go back to `Dot-Source.ps1` and add this line at the start:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们回到`Dot-Source.ps1`，并在开头添加这一行：
- en: '[PRE6]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Change the path to reflect the location where you saved `Write-Message.ps1`.
    Now, when we run `Dot-Source.ps1`, our message should be displayed, as shown here:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 更改路径以反映你保存`Write-Message.ps1`的位置。现在，当我们运行`Dot-Source.ps1`时，我们的消息应该会显示出来，如下所示：
- en: '![Figure 11.4 – Using dot-sourcing in a script](img/B17600_11_004.jpg)'
  id: totrans-81
  prefs: []
  type: TYPE_IMG
  zh: '![图11.4 – 在脚本中使用点来源](img/B17600_11_004.jpg)'
- en: Figure 11.4 – Using dot-sourcing in a script
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.4 – 在脚本中使用点来源
- en: 'We can do this interactively as well, in a PowerShell session, just by dot-sourcing
    the script, as shown here:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以通过交互式方式在PowerShell会话中做到这一点，只需点来源脚本，如下所示：
- en: '![Figure 11.5 – Interactive dot-sourcing](img/B17600_11_005.jpg)'
  id: totrans-84
  prefs: []
  type: TYPE_IMG
  zh: '![图11.5 – 交互式点来源](img/B17600_11_005.jpg)'
- en: Figure 11.5 – Interactive dot-sourcing
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.5 – 交互式点来源
- en: So, if dot-sourcing is so straightforward, why should we bother with modules
    at all? The reason is the management problems that dot-sourcing introduces. When
    we dot-source a script, we bring the members of that script, as well as the variables
    and functions, into the parent scope. We can see this in the preceding screenshot;
    if we call the `$text` variable, then we get the `default message` string. Remember,
    the concept of scope was introduced to protect us from ambiguously written code;
    by dot-sourcing code, we remove that protection. When we interactively dot-sourced
    `Write-Message.ps1`, we brought a function into the global scope that we now have
    no easy way of removing. Any variables in that script outside the function would
    be brought in as well. If those variables are poorly named, they may conflict
    with important existing variables, leading to, as they say, hilarious consequences.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，如果点源（dot-sourcing）这么简单，为什么我们还需要使用模块呢？原因是点源带来的管理问题。当我们进行点源时，我们将脚本的成员以及变量和函数引入到父作用域中。我们可以在前面的截图中看到这一点；如果我们调用`$text`变量，就会得到`default
    message`字符串。记住，作用域的概念是为了保护我们免受不明确代码的影响；通过点源代码，我们去除了这种保护。当我们交互式地点源`Write-Message.ps1`时，我们将一个函数带入了全局作用域，而现在我们没有简单的方法将其删除。该脚本中函数外的任何变量也会被引入。如果这些变量命名不当，可能会与现有的重要变量发生冲突，导致“可笑的后果”。
- en: 'If we are unsure where a function has come from, we can use the `File` property
    on the object to check, like this:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们不确定一个函数的来源，可以使用对象的`File`属性进行检查，像这样：
- en: '[PRE7]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'This will give us the path of the file that contains that function. We can
    also remove it from a session with the `Remove-Item` cmdlet, as shown here:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 这将给我们该函数所在文件的路径。我们还可以使用`Remove-Item` cmdlet从会话中删除它，如下所示：
- en: '![Figure 11.6 – Finding the source of functions and removing them](img/B17600_11_006.jpg)'
  id: totrans-90
  prefs: []
  type: TYPE_IMG
  zh: '![图 11.6 – 查找函数来源并删除它们](img/B17600_11_006.jpg)'
- en: Figure 11.6 – Finding the source of functions and removing them
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.6 – 查找函数来源并删除它们
- en: Modules allow us to control what functions and variables are exported from our
    code, and to control those as a group. Let’s see how we can turn an existing script
    into a module.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 模块允许我们控制从代码中导出的函数和变量，并将它们作为一个整体进行控制。让我们看看如何将现有的脚本转换为模块。
- en: Turning a script into a module
  id: totrans-93
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将脚本转换为模块
- en: As we saw at the start of this section, the basic process for turning a script
    into a module is to change the file extension from `.ps1` to `.psm1`. Let’s do
    that now with the `Write-Message.ps1` script we wrote previously, and save a copy
    of it as `Write-Message.psm1`.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在本节开始时看到的，将脚本转换为模块的基本过程是将文件扩展名从`.ps1`更改为`.psm1`。现在，我们来处理之前写的`Write-Message.ps1`脚本，并将其保存为`Write-Message.psm1`。
- en: 'Now, we can open a new session and import our module into the session with
    the following command:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以打开一个新的会话，并使用以下命令将我们的模块导入到会话中：
- en: '[PRE8]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Let’s take a look at this module in detail:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们详细查看这个模块：
- en: '![Figure 11.7 – Details of the Write-Message module](img/B17600_11_007.jpg)'
  id: totrans-98
  prefs: []
  type: TYPE_IMG
  zh: '![图 11.7 – `Write-Message`模块的详细信息](img/B17600_11_007.jpg)'
- en: Figure 11.7 – Details of the Write-Message module
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.7 – `Write-Message`模块的详细信息
- en: 'In the first line, we imported the module. We used the full path because we
    haven’t saved it in a location included in the module path. This is to prevent
    PowerShell from autoloading it. Now, let’s run the following command:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一行中，我们导入了模块。我们使用了完整路径，因为我们没有将其保存到包含在模块路径中的位置。这是为了防止PowerShell自动加载它。现在，让我们运行以下命令：
- en: '[PRE9]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'We’ll see a script module, its location, and the exported command – that is,
    `Write-Module`. Now, let’s run the following command:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将看到一个脚本模块、它的位置以及导出的命令——也就是`Write-Module`。现在，让我们运行以下命令：
- en: '[PRE10]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: We will see that only the function is exported, not the variable.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将看到只有函数被导出，而不是变量。
- en: We can check the details of the `Write-Message` function with `Get-Command`
    and see that the source is the `Write-Message` module.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用`Get-Command`检查`Write-Message`函数的详细信息，查看其来源是`Write-Message`模块。
- en: 'Let’s try some other things with this module. Open the module file and add
    the following code:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们尝试使用这个模块做一些其他事情。打开模块文件并添加以下代码：
- en: '[PRE11]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Import the module again, using the `-Force` parameter to reload it. Now, we
    have two functions in our module. If we run `Get-Module` again, we’ll see that
    they are both visible:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 再次导入模块，使用`-Force`参数重新加载它。现在，我们的模块中有两个函数。如果我们再次运行`Get-Module`，我们会看到它们都已经显示出来：
- en: '![Figure 11.8 – Multiple exports](img/B17600_11_008.jpg)'
  id: totrans-109
  prefs: []
  type: TYPE_IMG
  zh: '![图 11.8 – 多重导出](img/B17600_11_008.jpg)'
- en: Figure 11.8 – Multiple exports
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.8 – 多重导出
- en: 'As you can see, the `setMessage` cmdlet is available for us to use. What happens
    if we don’t want that? The name we’ve used doesn’t conform with cmdlet naming
    conventions and is generally one we’d use to signify a private function; something
    that we need to be available to the other functions within the module, but not
    something we want available for use outside those functions. We can control access
    using the `Export-ModuleMember` cmdlet. Add the following line to the bottom of
    `Write-Message.psm1`:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，`setMessage` cmdlet现在对我们可用了。如果我们不希望这样会发生什么呢？我们使用的名称不符合cmdlet命名约定，通常我们会使用这种命名来表示一个私有函数；它是我们需要在模块内部的其他函数中使用的，但我们不希望它对外部函数可用。我们可以使用`Export-ModuleMember`
    cmdlet来控制访问权限。在`Write-Message.psm1`的底部添加以下行：
- en: '[PRE12]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Then, import the module again with the `-Force` parameter. The results are
    shown in the following screenshot:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，使用`-Force`参数再次导入模块。结果如下图所示：
- en: '![Figure 11.9 – Controlling exported functions](img/B17600_11_009.jpg)'
  id: totrans-114
  prefs: []
  type: TYPE_IMG
  zh: '![图11.9 – 控制导出的函数](img/B17600_11_009.jpg)'
- en: Figure 11.9 – Controlling exported functions
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.9 – 控制导出的函数
- en: 'Now, only the `Write-Message` function is exported, and when we try and run
    `setMessage`, this time, we get an error. We can also use `Export-ModuleMember`
    to export variables and aliases from the module, which aren’t exported by default,
    like this:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，只有`Write-Message`函数被导出，当我们尝试运行`setMessage`时，这次我们会收到一个错误。我们还可以使用`Export-ModuleMember`来导出模块中的变量和别名，这些默认情况下是不会被导出的，像这样：
- en: '[PRE13]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: If we don’t explicitly use `Export-ModuleMember`, all the functions in a module
    will be exported, but nothing other than functions.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们没有显式使用`Export-ModuleMember`，模块中的所有函数都会被导出，但除函数外，其他任何内容都不会被导出。
- en: 'In the introduction to this chapter, we mentioned one of the use cases for
    modules: building applications and solutions. To do this, we will often call a
    module from within another module – this is called nesting modules, and that’s
    what we’re going to look at next.'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的介绍中，我们提到过模块的一个使用场景：构建应用程序和解决方案。为了实现这一点，我们通常会从一个模块内部调用另一个模块——这就叫做模块嵌套，接下来我们将详细探讨这一点。
- en: Nested modules
  id: totrans-120
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 嵌套模块
- en: 'In [*Chapter 9*](B17600_09.xhtml#_idTextAnchor184), *Don’t Repeat Yourself
    – Functions and Scriptblocks*, we looked at some functions for writing output
    to log files. It would be useful to write those functions in a module so that
    we could just call them when we needed them, rather than having to write them
    in every script we create. These are great examples of functions we would want
    to keep private, rather than export them for general use. Let’s do this. Copy
    the `Write-Log.ps1` script we wrote previously to a module file called `Write-Log.psm1`
    in a suitable location. We’ll need to edit the `.psm1` file to remove the following
    line:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 在[*第9章*](B17600_09.xhtml#_idTextAnchor184)《不要重复自己——函数与脚本块》中，我们查看了一些用于将输出写入日志文件的函数。将这些函数写入模块是非常有用的，这样我们在需要时就可以调用它们，而不是每次创建脚本时都要重新编写。这些是我们希望保持私有的函数，而不是为一般用途导出的好例子。我们来做一下这个操作。将之前编写的`Write-Log.ps1`脚本复制到一个名为`Write-Log.psm1`的模块文件中，并放置在合适的位置。我们需要编辑`.psm1`文件，删除以下行：
- en: '[PRE14]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'This is how my module file looks:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我的模块文件的样子：
- en: '![Figure 11.10 – The Write-Log.psm1 module](img/B17600_11_010.jpg)'
  id: totrans-124
  prefs: []
  type: TYPE_IMG
  zh: '![图11.10 – Write-Log.psm1模块](img/B17600_11_010.jpg)'
- en: Figure 11.10 – The Write-Log.psm1 module
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.10 – Write-Log.psm1模块
- en: As we can see, I’ve remarked line 11, rather than deleting it. We are left with
    two functions and a variable – that is, `Write-Log`, `Remove-Log`, and `$LogFile`.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，我注释了第11行，而不是删除它。剩下的两个函数和一个变量是`Write-Log`、`Remove-Log`和`$LogFile`。
- en: 'We can now add a couple of lines to our `Write-Message.psm1` module so that
    we can call the `Write-Log` module and run one of the functions in it. Edit your
    `Write-Message` function, like this:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以在`Write-Message.psm1`模块中添加几行代码，以便调用`Write-Log`模块并运行其中的某个函数。像这样编辑你的`Write-Message`函数：
- en: '[PRE15]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'I’ve added the first line to import the `Write-Log` module and the fifth line
    to call the `Write-Log` function from it. I’ve also removed the `Export-ModuleMember`
    line. Now, let’s see what happens when we import the `Write-Message` module:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 我已添加了第一行来导入`Write-Log`模块，第五行用于从中调用`Write-Log`函数。我还删除了`Export-ModuleMember`行。现在，让我们看看当我们导入`Write-Message`模块时会发生什么：
- en: '![Figure 11.11 – Nested modules](img/B17600_11_011.jpg)'
  id: totrans-130
  prefs: []
  type: TYPE_IMG
  zh: '![图11.11 – 嵌套模块](img/B17600_11_011.jpg)'
- en: Figure 11.11 – Nested modules
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.11 – 嵌套模块
- en: As we can see, the module is imported as before and works as we expect. We can
    see from the output of `Get-Module` that there are four exported functions – two
    from `Write-Message` and two from `Write-Log` – and we can see that the `Write-Log`
    module is nested. When we attempt to access it with `Get-Command`, however, we
    don’t see any loaded functions, and `Get-Module Write-Log` returns nothing. However,
    if we check the log file that was created, we’ll see a message stating `nested
    module test`, so it is working.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，模块如之前一样被导入并按预期工作。我们可以从 `Get-Module` 的输出中看到有四个导出的函数——两个来自 `Write-Message`，两个来自
    `Write-Log`——并且我们可以看到 `Write-Log` 模块是嵌套的。然而，当我们尝试通过 `Get-Command` 访问它时，我们看不到任何已加载的函数，且
    `Get-Module Write-Log` 不返回任何内容。不过，如果检查创建的日志文件，我们会看到一条消息，表明 `nested module test`，所以它是有效的。
- en: 'This is because nested modules are only visible to the calling module, so we
    can’t access `Write-Log` directly. However, because we removed the `Export-ModuleMember`
    line, all functions are exported, including the functions from nested modules;
    they appear as functions of the calling module. We’ll be able to see the `Write-Log`
    module if we use `Get-Module -All`, though, and we can find the real location
    of the `Write-Log` function as before – that is, by calling the `File` property:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 这是因为嵌套模块仅对调用模块可见，因此我们不能直接访问 `Write-Log`。然而，由于我们移除了 `Export-ModuleMember` 这一行，所有函数都会被导出，包括嵌套模块中的函数；它们将作为调用模块的函数出现。如果我们使用
    `Get-Module -All`，我们将能够看到 `Write-Log` 模块，并且可以像以前一样找到 `Write-Log` 函数的实际位置——即通过调用
    `File` 属性：
- en: '![Figure 11.12 – Finding nested modules](img/B17600_11_012.jpg)'
  id: totrans-134
  prefs: []
  type: TYPE_IMG
  zh: '![图 11.12 – 查找嵌套模块](img/B17600_11_012.jpg)'
- en: Figure 11.12 – Finding nested modules
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.12 – 查找嵌套模块
- en: As we can see, the `Write-Log` function is defined in the `write-log.psm1` file.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，`Write-Log` 函数定义在 `write-log.psm1` 文件中。
- en: 'Sometimes, we may not want nested modules to be hidden like this; if that’s
    the case, then we can use the `-Global` parameter of `Import-Module`, like this:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，我们可能不希望嵌套模块像这样被隐藏；如果是这样，我们可以使用 `Import-Module` 的 `-Global` 参数，像这样：
- en: '[PRE16]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The `Write-Log` module will be imported at the same top level as the `Write-Message`
    module.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: '`Write-Log` 模块将与 `Write-Message` 模块处于同一顶级导入状态。'
- en: Now, let’s look at some other types of modules, including binary and manifest
    modules.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们来看一些其他类型的模块，包括二进制模块和清单模块。
- en: More modules
  id: totrans-141
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 更多模块
- en: 'You may have noticed that when we create a function in a module, we use it
    like a cmdlet, but it’s still called a function. It will behave as a cmdlet, with
    parameters, help, members, and so on, but it’s not a cmdlet. Consider the following:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能注意到，当我们在模块中创建一个函数时，我们像使用 cmdlet 一样使用它，但它仍然被称为函数。它会像 cmdlet 一样行为，具有参数、帮助、成员等等，但它并不是
    cmdlet。考虑以下内容：
- en: '![Figure 11.13 – Functions and cmdlets](img/B17600_11_013.jpg)'
  id: totrans-143
  prefs: []
  type: TYPE_IMG
  zh: '![图 11.13 – 函数和 cmdlet](img/B17600_11_013.jpg)'
- en: Figure 11.13 – Functions and cmdlets
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.13 – 函数和 cmdlet
- en: As we can see, `Write-Message` is of the `Function` type, whereas the Microsoft
    `Get-Service` command is of the `Cmdlet` type.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，`Write-Message` 是 `Function` 类型，而微软的 `Get-Service` 命令是 `Cmdlet` 类型。
- en: To write custom cmdlets, we need to write a binary module. Remember that PowerShell
    is based on .NET and is an interpreted language, written in a compiled language,
    usually C#, in the same way that Python is an interpreted language written in
    C.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 要编写自定义 cmdlet，我们需要编写一个二进制模块。请记住，PowerShell 基于 .NET，是一种解释型语言，通常使用编译语言（如 C#）编写，就像
    Python 是一种解释型语言但用 C 编写一样。
- en: We’re not going to cover writing modules in C# here, but we will discuss how
    they work and how they are used.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不会在这里讨论如何编写 C# 模块，但我们会讨论它们是如何工作的以及如何使用它们。
- en: 'A binary module does not have a `.psm1` extension – it is a .NET assembly compiled
    from code such as C# and has a `.dll` extension. We can create it by writing our
    C# code within a `Here-String` declaration, a block of multi-line text inside
    the `@" "@` construct, and then use the `Add-Type -OutputAssembly` cmdlet to compile
    it:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 二进制模块没有 `.psm1` 扩展名 —— 它是一个从 C# 等代码编译而成的 .NET 程序集，具有 `.dll` 扩展名。我们可以通过在 `@"
    "@` 结构中的 `Here-String` 声明中编写 C# 代码，然后使用 `Add-Type -OutputAssembly` cmdlet 来编译它：
- en: '[PRE17]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Other than that, we can import it in the same way as a script module with `Import-Module`:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 除此之外，我们可以像使用脚本模块一样，使用 `Import-Module` 导入它：
- en: '[PRE18]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: If we were to run `Get-Module` on our fictional `MyBinaryModule`, we would see
    that `ModuleType` is `Binary` and that it has exported cmdlets, rather than exported
    functions.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们运行 `Get-Module` 来查看虚构的 `MyBinaryModule`，我们会看到 `ModuleType` 是 `Binary`，并且它导出了
    cmdlet，而不是导出函数。
- en: The main difference between binary modules and script modules is that once they’re
    loaded into a session, they can’t be unloaded. If we need to make a change to
    a binary module we are writing, we will need to close PowerShell first.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 二进制模块和脚本模块之间的主要区别在于，一旦它们被加载到会话中，就无法卸载。如果我们需要更改正在编写的二进制模块，则需要先关闭 PowerShell。
- en: We may also see PowerShell modules written in CDXML, an XML wrapper for Common
    Information Model commands. This used to be quite common for Windows administration
    modules, but it is largely deprecated now since modules written this way are slower
    to load and run than script modules due to the extra effort required to parse
    the XML into PowerShell, which then itself needs parsing. In the words of the
    official documentation, “*Avoid CDXML.*” Similarly, we may see references to PowerShell
    SnapIns. These are deprecated forms of Windows PowerShell that aren’t supported
    in PowerShell 7, so we don’t need to worry about them.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可能还会看到用 CDXML 编写的 PowerShell 模块，CDXML 是一种用于公共信息模型命令的 XML 包装器。这种方式在 Windows
    管理模块中曾经很常见，但现在已经大多被弃用，因为用这种方式编写的模块比脚本模块加载和运行速度慢，因为需要额外的工作将 XML 解析到 PowerShell
    中，然后 PowerShell 还需要进一步解析。正如官方文档所言，"*避免使用 CDXML*。"类似地，我们可能会看到有关 PowerShell SnapIns
    的引用。这些是 Windows PowerShell 的已弃用形式，在 PowerShell 7 中不再支持，因此我们不需要担心它们。
- en: There’s one more type of module for us to consider – the manifest module. A
    manifest module is a script or binary module that includes a module manifest.
    That’s what we’re going to look at in the next section.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一种模块类型需要我们考虑——清单模块。清单模块是一个包含模块清单的脚本或二进制模块。接下来我们将讨论这个内容。
- en: Module manifests
  id: totrans-156
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 模块清单
- en: 'The script modules we’ve been playing with so far are monolithic single files,
    either standalone or nested. That’s fine for hobbyist use, but it’s not great
    in a production environment, where we might want to split our functions into separate
    files and include version information and a whole bunch of other metadata and
    resources, such as XML formatting files or binaries. To organize a more complex
    module, we need a document that explains how it is to be loaded and implemented;
    this document is called a module manifest, and it is a hash table saved with a
    `.psd1` extension. Let’s have a look at an example. if we browse to the PowerShellGet
    module in `C:\Program Files\PowerShell\7\Modules` (or `/opt/microsoft/PowerShell/7/Modules`
    in Linux), we will see the following files and folders:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止我们操作的脚本模块是单一文件，要么是独立的，要么是嵌套的。这对于个人使用来说没有问题，但在生产环境中，这样做就不太合适了，因为我们可能需要将函数拆分成多个文件，并且包括版本信息和其他大量的元数据与资源，如
    XML 格式文件或二进制文件。为了组织一个更复杂的模块，我们需要一个文档来说明如何加载和实现它；这个文档被称为模块清单，它是一个哈希表，保存为 `.psd1`
    扩展名的文件。让我们来看一个例子。如果我们浏览到 `C:\Program Files\PowerShell\7\Modules`（或者在 Linux 上是
    `/opt/microsoft/PowerShell/7/Modules`）中的 PowerShellGet 模块，我们将看到以下文件和文件夹：
- en: '![Figure 11.14 – The PowerShellGet module](img/B17600_11_014.jpg)'
  id: totrans-158
  prefs: []
  type: TYPE_IMG
  zh: '![图 11.14 – PowerShellGet 模块](img/B17600_11_014.jpg)'
- en: Figure 11.14 – The PowerShellGet module
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.14 – PowerShellGet 模块
- en: As we can see, there are four files and three folders. These folders contain
    several `.psm1` and `.psd1` files that define functions and manifests for nested
    modules. The main code for the module is in `PSModule.psm1`. `PSGet.Format.ps1xml`
    contains formatting information for displaying the output of functions. `PowerShellGet.psd1`
    is the module manifest. `PSGet.Resource.psd1` is a set of output strings for the
    module to use; we won’t worry about it here. If we open the `PSModule.psm1` file,
    we will see it is written in PowerShell, not C#, so it is a script module. It’s
    a big file, with a lot of functions defined in it. Let’s take a look at the `PowerShellGet.psd1`
    file.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，有四个文件和三个文件夹。这些文件夹包含几个 `.psm1` 和 `.psd1` 文件，用于定义函数和嵌套模块的清单。模块的主要代码在 `PSModule.psm1`
    中。`PSGet.Format.ps1xml` 包含用于显示函数输出的格式化信息。`PowerShellGet.psd1` 是模块清单。`PSGet.Resource.psd1`
    是模块使用的一组输出字符串；我们在此不做过多考虑。如果我们打开 `PSModule.psm1` 文件，会看到它是用 PowerShell 编写的，而不是 C#，因此它是一个脚本模块。这是一个较大的文件，定义了很多函数。我们来看看
    `PowerShellGet.psd1` 文件。
- en: The first thing to note is that it is given the same name as the folder it’s
    housed in. This is deliberate; if there is a manifest present in a module folder,
    it must have the same name as the folder; otherwise, the module won’t load. Giving
    the same name to the `.psm1` file, in the absence of a manifest, allows PowerShell
    to easily find it for autoloading, but otherwise, this doesn’t matter. It’s different
    for manifests.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 首先要注意的是，它被赋予了与其所在文件夹相同的名称。这是故意的；如果在模块文件夹中存在清单文件，它必须与文件夹的名称相同；否则模块将无法加载。如果没有清单，`.psm1`
    文件也采用相同的名称，这允许 PowerShell 容易地找到它并自动加载，但除此之外这并不重要。清单文件则不同。
- en: 'Let’s open it up and look inside:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们打开它，看看里面是什么：
- en: '![Figure 11.15 – The PowerShellGet manifest](img/B17600_11_015.jpg)'
  id: totrans-163
  prefs: []
  type: TYPE_IMG
  zh: '![图 11.15 – PowerShellGet 清单](img/B17600_11_015.jpg)'
- en: Figure 11.15 – The PowerShellGet manifest
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.15 – PowerShellGet 清单
- en: On line 1, we can see that this is a hash table from `@{`, and that everything
    after that takes the format of a key-value pair. As we can see, this is a long
    file with a lot of information in it; over 200 lines, although much of this is
    a big blob of text with the `ReleaseNotes` key.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 在第 1 行，我们可以看到这是一个从 `@{` 开始的哈希表，之后的内容都采用键值对格式。如我们所见，这是一个长文件，包含了大量信息；超过 200 行，尽管其中许多部分是包含
    `ReleaseNotes` 键的大段文本。
- en: A manifest consists of up to 37 different key-value pairs that may contain strings
    or arrays. We can add additional code to a manifest, including comparison and
    arithmetic operators, basic data types, and the `if` statement, but we’re not
    going to cover that here; I’ve never needed to do it. Let’s create a new manifest
    for ourselves and see what’s in it.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 一个清单由多达 37 个不同的键值对组成，这些键值对可能包含字符串或数组。我们可以向清单中添加额外的代码，包括比较运算符、算术运算符、基本数据类型和 `if`
    语句，但我们在这里不涉及这些内容；我从未需要这么做。让我们为自己创建一个新的清单，看看里面有什么。
- en: 'In a suitable directory, create a folder called `ManifestModule`. Now, open
    a PowerShell session and type the following cmdlet:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 在合适的目录中创建一个名为 `ManifestModule` 的文件夹。现在，打开 PowerShell 会话并输入以下 cmdlet：
- en: '[PRE19]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'At the prompt, supply the path and the name of the new manifest file, like
    this:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 在提示符下，提供新清单文件的路径和名称，如下所示：
- en: '[PRE20]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'That’s it – this creates a new manifest file for a module called `ManifestModule`.
    Let’s open it up in VS Code:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 就是这样——这将为名为 `ManifestModule` 的模块创建一个新的清单文件。让我们在 VS Code 中打开它：
- en: '![Figure 11.16 – A basic module manifest](img/B17600_11_016.jpg)'
  id: totrans-172
  prefs: []
  type: TYPE_IMG
  zh: '![图 11.16 – 基本模块清单](img/B17600_11_016.jpg)'
- en: Figure 11.16 – A basic module manifest
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.16 – 基本模块清单
- en: The first thing to notice is that some of the values have been generated for
    you. `ModuleVersion` is `0.0.1`, there is an autogenerated `GUID` to ensure that
    this module can be differentiated from any other modules with the same name, and
    the `Author`, `CompanyName`, and `Copyright` keys are populated. Other than that,
    everything is empty and generally remarked out.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 首先需要注意的是，一些值已经为你生成。`ModuleVersion` 是 `0.0.1`，还有一个自动生成的 `GUID` 用以确保这个模块与同名的其他模块可以区分开，且
    `Author`、`CompanyName` 和 `Copyright` 键已被填充。除此之外，其他部分为空，且通常已被注释掉。
- en: 'The keys in a manifest fall into three groups that cover the following aspects:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 清单中的键分为三组，涵盖以下几个方面：
- en: '**Production data**: Who wrote it, when, who for, and what sort of systems
    it will run on.'
  id: totrans-176
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**生产数据**：谁编写了它，何时编写，给谁用，及其运行的系统类型。'
- en: '`RootModule` defines the main module file that calls everything else – the
    main `.``psm1` file.'
  id: totrans-177
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`RootModule` 定义了调用其他所有内容的主模块文件——主 `.psm1` 文件。'
- en: '**Module content**: These are lists of all the modules, files, and other assets
    that are included in the module. These keys are optional, but generally, they
    should be populated accurately.'
  id: totrans-178
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**模块内容**：这些是模块中包含的所有模块、文件和其他资产的列表。这些键是可选的，但通常应该准确地填充。'
- en: 'We can populate the keys when we call the `New-ModuleManifest` cmdlet, by adding
    the key name as a parameter:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过调用 `New-ModuleManifest` cmdlet 并将键名作为参数来填充这些键：
- en: '[PRE21]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'The alternative is to edit the manifest file directly in a text editor or VS
    Code. If we edit it directly, there is always the possibility of mistyping something
    and breaking the file, so it’s a good idea to test our edited manifest, like this:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种方法是直接在文本编辑器或 VS Code 中编辑清单文件。如果我们直接编辑，始终有可能打错某些内容并破坏文件，因此最好像这样测试我们编辑过的清单：
- en: '[PRE22]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'We can see the results in the following figure:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在下图中看到结果：
- en: '![Figure 11.17 – Testing a module manifest file](img/B17600_11_017.jpg)'
  id: totrans-184
  prefs: []
  type: TYPE_IMG
  zh: '![图 11.17 – 测试模块清单文件](img/B17600_11_017.jpg)'
- en: Figure 11.17 – Testing a module manifest file
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.17 – 测试模块清单文件
- en: If the module’s information is returned, then the file has been formatted correctly.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 如果返回了模块的信息，那么文件已经正确格式化。
- en: As we’ve seen, module construction can get complicated pretty quickly. Let’s
    finish this chapter by taking a look at a tool that can make it very much easier
    – Plaster.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所看到的，模块构建可能会迅速变得复杂。让我们通过查看一个可以让它变得简单得多的工具——Plaster，来结束这一章。
- en: Using scaffolding tools such as Plaster
  id: totrans-188
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用诸如 Plaster 之类的脚手架工具
- en: If we are working long-term on a module, or collaborating with other people,
    then it’s a really good idea to use a framework that splits everything up into
    separate files and assets. This is where a scaffolding tool comes in. My choice
    of tool is Plaster, a module that was originally produced by Microsoft but is
    now maintained by PowerShell.Org, one of the most prolific online PowerShell communities.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们长期在一个模块上工作，或者与他人协作，那么使用一个将所有内容拆分成单独文件和资产的框架是一个非常好的主意。这就是脚手架工具发挥作用的地方。我的选择是
    Plaster，这是一个最初由 Microsoft 制作的模块，现在由 PowerShell.Org 维护，PowerShell.Org 是一个最具影响力的
    PowerShell 社区之一。
- en: 'Plaster uses a template file that consists of a manifest (similar to the module
    manifest) and a set of content files and directories. The template is written
    in XML and is highly customizable. The manifest has three sections:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: Plaster 使用一个模板文件，该文件由一个清单（类似于模块清单）和一组内容文件及目录组成。模板使用 XML 编写，且高度可定制。清单文件分为三个部分：
- en: Metadata, which contains information about the template, such as its name, version,
    and author
  id: totrans-191
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 元数据，包含有关模板的信息，如名称、版本和作者
- en: Parameters, which defines choices that the user can make about their module
    structure – what files and folders to create and include
  id: totrans-192
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 参数，定义了用户可以在模块结构中做出的选择——创建和包含哪些文件和文件夹
- en: Content, which specifies the actions that Plaster will perform – copying files,
    modifying files, and checking that required modules are installed.
  id: totrans-193
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 内容，指定 Plaster 将执行的操作——复制文件、修改文件、检查是否已安装必要的模块。
- en: 'Let’s start by installing the module from the PowerShell gallery. Type the
    following to download the module:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从 PowerShell Gallery 安装模块。输入以下内容以下载模块：
- en: '[PRE23]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'We may need to acknowledge that the PowerShell gallery is an untrusted repository.
    Now, let’s import the module:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可能需要确认 PowerShell gallery 是一个不受信任的仓库。现在，让我们导入模块：
- en: '[PRE24]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'And that’s it – we’re ready to go. Let’s see what we’ve got:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 就这样——我们已经准备好了。让我们看看我们得到了什么：
- en: '![Figure 11.18 – Examining the Plaster module](img/B17600_11_018.jpg)'
  id: totrans-199
  prefs: []
  type: TYPE_IMG
  zh: '![图 11.18 – 检查 Plaster 模块](img/B17600_11_018.jpg)'
- en: Figure 11.18 – Examining the Plaster module
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.18 – 检查 Plaster 模块
- en: 'As we can see, we’ve installed version 1.1.4 of the module, and we’ve got four
    new commands to play with:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所看到的，我们已安装了版本 1.1.4 的模块，并且有了四个新的命令可以使用：
- en: '`Get-PlasterTemplate`: This lists the existing templates available for us to
    use. We can write or download templates as XML files. Only two are included, and
    the one we need is `NewPowerShellScriptModule`.'
  id: totrans-202
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Get-PlasterTemplate`：列出我们可以使用的现有模板。我们可以编写或下载 XML 格式的模板文件。这里只包含了两个模板，而我们需要的是
    `NewPowerShellScriptModule`。'
- en: '`Invoke-Plaster`: This runs the Plaster scaffolding tool.'
  id: totrans-203
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Invoke-Plaster`：运行 Plaster 脚手架工具。'
- en: '`New-PlasterManifest`: This command creates a new manifest.'
  id: totrans-204
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`New-PlasterManifest`：此命令创建一个新的清单文件。'
- en: '`Test-PlasterManifest`: This command tests that the manifest is formatted correctly.'
  id: totrans-205
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Test-PlasterManifest`：此命令测试清单文件是否正确格式化。'
- en: 'Let’s run it and see what we get:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们运行它，看看会得到什么：
- en: '[PRE25]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Then, copy the path for `NewPowerShellScriptModule`. Now, type the following:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，复制 `NewPowerShellScriptModule` 的路径。现在，输入以下内容：
- en: '[PRE26]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: You’ll be asked for the path to the default template and then a destination
    path; this needs to be a folder, not a file.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 系统会询问你默认模板的路径以及目标路径；这个路径需要是文件夹，而不是文件。
- en: 'You’ll also be asked to provide the module’s name and version, as well as whether
    you want to set VS Code as the default editor. Here’s how it looked for me:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 你还需要提供模块的名称和版本，以及是否希望将 VS Code 设置为默认编辑器。对我而言，它是这样的：
- en: '![Figure 11.19 – Invoking Plaster](img/B17600_11_019.jpg)'
  id: totrans-212
  prefs: []
  type: TYPE_IMG
  zh: '![图 11.19 – 调用 Plaster](img/B17600_11_019.jpg)'
- en: Figure 11.19 – Invoking Plaster
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.19 – 调用 Plaster
- en: As we can see, one of the required modules, Pester, is missing from my sandbox
    machine. Pester is a module that makes it a breeze to do unit testing and test-driven
    development, but it’s a bit beyond the scope of this book.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所看到的，我的沙箱机器缺少一个必要的模块——Pester。Pester 是一个让单元测试和测试驱动开发变得非常简单的模块，但这超出了本书的范围。
- en: 'Let’s see what has been created in the destination path:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看目标路径中创建了什么：
- en: '![Figure 11.20 – A module created with the default Plaster template](img/B17600_11_020.jpg)'
  id: totrans-216
  prefs: []
  type: TYPE_IMG
  zh: '![图11.20 – 使用默认Plaster模板创建的模块](img/B17600_11_020.jpg)'
- en: Figure 11.20 – A module created with the default Plaster template
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.20 – 使用默认Plaster模板创建的模块
- en: As we can see, Plaster has created two files – a script module file and a module
    manifest file – a folder for test scripts, and a folder for VS Code settings.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，Plaster已经创建了两个文件——一个脚本模块文件和一个模块清单文件——一个用于测试脚本的文件夹，以及一个用于VS Code设置的文件夹。
- en: 'The `NewPlasterModule.psm1` file looks like this:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: '`NewPlasterModule.psm1`文件如下所示：'
- en: '![Figure 11.21 – A basic module file generated by Plaster](img/B17600_11_021.jpg)'
  id: totrans-220
  prefs: []
  type: TYPE_IMG
  zh: '![图11.21 – 一个由Plaster生成的基础模块文件](img/B17600_11_021.jpg)'
- en: Figure 11.21 – A basic module file generated by Plaster
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.21 – 一个由Plaster生成的基础模块文件
- en: As we can see, it’s very simple, but it includes a great trick – if the functions
    in the file are named with standard cmdlet naming conventions, such as `Verb-Noun`,
    then they will be exported. If they are not, like the `setMessage` function we
    wrote earlier in this chapter, then they will not be exported. Neat.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，这非常简单，但它包含了一个很棒的技巧——如果文件中的函数按照标准的cmdlet命名约定命名，比如`Verb-Noun`，那么它们将被导出。如果不是，比如我们在本章前面写的`setMessage`函数，那么它们将不会被导出。很整洁。
- en: The beauty of Plaster is how extensible it is; it’s easy to write templates
    to create folder structures for public and private functions and classes, and
    it can all be done in a repeatable way. To get some idea of how versatile Plaster
    is, have a look at Kevin Marquette’s blog at [https://powershellexplained.com/2017-05-12-Powershell-Plaster-adventures-in/](https://powershellexplained.com/2017-05-12-Powershell-Plaster-adventures-in/)
    and his GitHub page at [https://github.com/KevinMarquette/PlasterTemplates](https://github.com/KevinMarquette/PlasterTemplates).
    Have a play with his example templates.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: Plaster的美妙之处在于它的可扩展性；编写模板来创建公共和私有函数及类的文件夹结构非常简单，并且这一切都可以以可重复的方式完成。为了了解Plaster的多功能性，可以查看Kevin
    Marquette的博客：[https://powershellexplained.com/2017-05-12-Powershell-Plaster-adventures-in/](https://powershellexplained.com/2017-05-12-Powershell-Plaster-adventures-in/)以及他的GitHub页面：[https://github.com/KevinMarquette/PlasterTemplates](https://github.com/KevinMarquette/PlasterTemplates)。不妨尝试一下他的示例模板。
- en: That is as much as we’re going to cover regarding Plaster – there are several
    other scaffolding modules available, so if you don’t like Plaster, take a look
    at some of the others. That also wraps up this chapter; let’s recap what we’ve
    done.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是我们将要涉及的关于Plaster的内容——还有其他几种脚手架模块可用，如果你不喜欢Plaster，可以看看其他的模块。这也标志着本章的结束；让我们回顾一下我们所做的。
- en: Summary
  id: totrans-225
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: We started this chapter by reminding ourselves of what we learned in earlier
    chapters regarding modules and placing that into a more formal context. We looked
    at the standard module locations and how we can add locations by editing the `$ENV:PSModulePath`
    variable. We saw how PowerShell uses these locations to facilitate autoloading,
    and we saw how sometimes, we might not want that to happen. Then, we looked at
    how we can manually import modules and finished up our review by looking at the
    `PowerShellGet` module.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从回顾前几章关于模块的内容开始，并将其放入一个更正式的背景中。我们查看了标准的模块位置，并学习了如何通过编辑`$ENV:PSModulePath`变量来添加位置。我们了解了PowerShell如何利用这些位置来促进自动加载，以及有时我们可能不希望发生这种情况。接着，我们研究了如何手动导入模块，并通过查看`PowerShellGet`模块结束了我们的复习。
- en: After, we started to write our own modules. We began by looking at the earliest
    method for importing code, known as dot-sourcing, and saw why that could be a
    bad idea. Then, we created our first module by writing a script and converting
    it. Next, we looked at how we can build applications by nesting modules, before
    discussing some other types of modules, such as binary modules.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，我们开始编写自己的模块。我们从查看最早的代码导入方法——点源（dot-sourcing）开始，并了解了为什么这可能是一个糟糕的主意。接着，我们通过编写脚本并将其转换，创建了我们的第一个模块。然后，我们研究了如何通过嵌套模块来构建应用程序，接着讨论了其他类型的模块，如二进制模块。
- en: Then, we looked at the most common complex module type – the manifest module.
    We saw how the manifest file controls what is loaded and exported, and how to
    write and test a manifest file. Finally, we looked at a tool that can make writing
    modules much simpler – Plaster.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们研究了最常见的复杂模块类型——清单模块。我们了解了清单文件如何控制加载和导出的内容，以及如何编写和测试清单文件。最后，我们看了一个可以使编写模块变得更加简单的工具——Plaster。
- en: In the next chapter, we are going to look at the security aspects of PowerShell,
    and how we can best go about making ourselves and our colleagues and users safe
    with such a powerful tool.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将讨论 PowerShell 的安全性方面，以及如何最好地保护自己、同事和用户，使用如此强大的工具。
- en: Exercises
  id: totrans-230
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 练习题
- en: 'Here are the exercises for this chapter:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是本章的练习题：
- en: How can you list all imported modules in the current PowerShell session?
  id: totrans-232
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如何列出当前 PowerShell 会话中所有已导入的模块？
- en: What is the purpose of the `-Global` parameter when importing a module?
  id: totrans-233
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导入模块时，`-Global` 参数的作用是什么？
- en: How do we import a module that isn’t in a path specified in the `$``ENV:PSModulePath`
    variable?
  id: totrans-234
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如何导入一个不在 `$ENV:PSModulePath` 变量指定路径中的模块？
- en: We want to import a module that contains functions that have the same name as
    cmdlets that already exist in our session. What are two ways we can get around
    this?
  id: totrans-235
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们想导入一个包含与我们会话中已存在的 cmdlet 同名的函数的模块。我们可以通过哪两种方式解决这个问题？
- en: By default, all the functions of a module are exported. What are two ways we
    can control what functions are exported?
  id: totrans-236
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 默认情况下，模块的所有函数都会被导出。我们可以通过哪两种方式控制导出的函数？
- en: What is the purpose of the `HelpInfoURI` key in a module manifest?
  id: totrans-237
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 模块清单中 `HelpInfoURI` 键的作用是什么？
- en: What might be in a file with the`.ps1xml` extension?
  id: totrans-238
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 扩展名为 `.ps1xml` 的文件可能包含什么内容？
- en: If we load a module with the `.dll` extension, what sort of commands will we
    get?
  id: totrans-239
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果我们加载一个扩展名为 `.dll` 的模块，我们会得到什么样的命令？
- en: Why don’t we write CDXML modules?
  id: totrans-240
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为什么我们不编写 CDXML 模块？
- en: Further reading
  id: totrans-241
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: 'To learn more about the topics that were covered in this chapter, take a look
    at the following resources:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解更多本章涵盖的主题，请查看以下资源：
- en: '`PowerShellGet` and its replacement:'
  id: totrans-243
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`PowerShellGet` 及其替代品：'
- en: '[https://devblogs.microsoft.com/powershell/powershellget-in-powershell-7-4-updates/](https://devblogs.microsoft.com/powershell/powershellget-in-powershell-7-4-updates/)'
  id: totrans-244
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://devblogs.microsoft.com/powershell/powershellget-in-powershell-7-4-updates/](https://devblogs.microsoft.com/powershell/powershellget-in-powershell-7-4-updates/)'
- en: '[https://learn.microsoft.com/en-us/powershell/module/microsoft.powershell.psresourceget/?view=powershellget-3.x](https://learn.microsoft.com/en-us/powershell/module/microsoft.powershell.psresourceget/?view=powershellget-3.x)'
  id: totrans-245
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://learn.microsoft.com/zh-cn/powershell/module/microsoft.powershell.psresourceget/?view=powershellget-3.x](https://learn.microsoft.com/zh-cn/powershell/module/microsoft.powershell.psresourceget/?view=powershellget-3.x)'
- en: '[https://learn.microsoft.com/en-us/powershell/module/powershellget/?view=powershellget-2.x](https://learn.microsoft.com/en-us/powershell/module/powershellget/?view=powershellget-2.x)'
  id: totrans-246
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://learn.microsoft.com/zh-cn/powershell/module/powershellget/?view=powershellget-2.x](https://learn.microsoft.com/zh-cn/powershell/module/powershellget/?view=powershellget-2.x)'
- en: 'Writing module manifests: [https://learn.microsoft.com/en-us/powershell/scripting/developer/module/how-to-write-a-powershell-module-manifest](https://learn.microsoft.com/en-us/powershell/scripting/developer/module/how-to-write-a-powershell-module-manifest)'
  id: totrans-247
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编写模块清单：[https://learn.microsoft.com/zh-cn/powershell/scripting/developer/module/how-to-write-a-powershell-module-manifest](https://learn.microsoft.com/zh-cn/powershell/scripting/developer/module/how-to-write-a-powershell-module-manifest)
- en: 'Plaster: [https://powershellexplained.com/2017-05-12-Powershell-Plaster-adventures-in/#template-folder-and-file-structure](https://powershellexplained.com/2017-05-12-Powershell-Plaster-adventures-in/#template-folder-and-file-structure)'
  id: totrans-248
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'Plaster: [https://powershellexplained.com/2017-05-12-Powershell-Plaster-adventures-in/#template-folder-and-file-structure](https://powershellexplained.com/2017-05-12-Powershell-Plaster-adventures-in/#template-folder-and-file-structure)'
