- en: '12'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '12'
- en: Automating Tasks with Shell Scripts
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Shell 脚本自动化任务
- en: 'Sometimes, you’ll find yourself repeating the same few commands over and over,
    perhaps with slight variations. You reach the point of frustration, and say, “That’s
    it; I’m scripting this.” Being a CLI wizard, you do the following:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 有时候，你会发现自己一遍又一遍地重复相同的几条命令，可能只是稍微有些变化。你会感到沮丧，然后说：“算了，我来写个脚本吧。”作为一个 CLI 大师，你做了如下操作：
- en: Run `tail -n 20 ~/.bash_history > myscript.sh` to create a file that contains
    the last 20 Bash commands you ran.
  id: totrans-3
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行 `tail -n 20 ~/.bash_history > myscript.sh` 来创建一个文件，包含你最后运行的 20 条 Bash 命令。
- en: Then run `bash myscript.sh` to execute it.
  id: totrans-4
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后运行 `bash myscript.sh` 来执行脚本。
- en: Although this isn’t the recommended procedure (we’ll get to that in this chapter),
    it’s a perfectly valid way to create and run a Bash script.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这不是推荐的做法（我们将在本章中讨论这个问题），但它是创建和运行 Bash 脚本的一种完全有效的方法。
- en: This chapter is a Bash scripting crash course. Like any programming crash course,
    it is completely useless unless you actually follow along, type in all the code
    yourself, and run it in your own Linux environment. In addition to showing you
    the subset of Bash’s syntax which is considered modern and best-practice, we’ll
    give you plenty of tips from our hard-earned experience over the years, calling
    out common pitfalls and sharp edges.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 本章是一个 Bash 脚本速成课程。像任何编程速成课程一样，除非你实际跟着做，自己敲代码并在自己的 Linux 环境中运行，否则它完全没有用。除了向你展示被认为是现代且最佳实践的
    Bash 语法子集外，我们还会分享多年来积累的经验，指出常见的陷阱和尖锐的边缘。
- en: Bash isn’t our favorite language, but sometimes it’s exactly the right tool
    for the problem you face. We’ll try to give you an understanding of this as well.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然 Bash 不是我们最喜欢的语言，但有时它正是解决你面对的问题的最佳工具。我们也会尽量帮助你理解这一点。
- en: 'In this chapter, we will cover the following:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下内容：
- en: Bash scripting basics
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Bash 脚本基础
- en: Bash versus other shells
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Bash 与其他 Shell 的对比
- en: Shebangs and executable text files
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Shebang 和可执行文本文件
- en: Testing
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 测试
- en: Conditionals
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 条件语句
- en: Why you need Bash scripting basics
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为什么你需要掌握 Bash 脚本基础
- en: 'Shell scripts are an indispensable tool for any developer; even if you’re not
    writing scripts on a weekly basis, you’ll be reading them. In this chapter, we’ll
    cover the basics you need to know so that you feel comfortable when, for example:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: Shell 脚本是任何开发者不可或缺的工具；即使你不是每周都编写脚本，你也会阅读脚本。在本章中，我们将介绍你需要了解的基础知识，这样你就能在例如以下情况时感到得心应手：
- en: You’re confronted by a shell script that someone wrote a few years ago, for
    example “Can you check to see if we can reuse the automation scripts that Steve
    wrote before he left for Google?”
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你会面对别人几年前写的 Shell 脚本，例如“你能检查一下我们能否重用 Steve 在离开谷歌之前写的自动化脚本吗？”
- en: You see an opportunity to write your own shell script, when you have a job that
    existing shell programs already solve (filtering, searching, sorting output, and
    feeding one program’s output into another one).
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当你看到有机会编写自己的 Shell 脚本，处理已经有现成 Shell 程序可以解决的工作（如过滤、搜索、排序输出，或者将一个程序的输出传递给另一个程序）时，你就会有这样的想法。
- en: You want to control precisely what goes into each Docker layer as you build
    up an image.
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你希望在构建镜像时精确控制每个 Docker 层中包含的内容。
- en: 'You need to coordinate other software in the context of a Linux server’s operating
    system: startup ordering, error checking, aborting early between programs, and
    so on.'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你需要在 Linux 服务器的操作系统环境中协调其他软件：启动顺序、错误检查、程序间的提前中止等等。
- en: There are innumerable use cases where a shell script is *just* the right size
    and shape for your problem space. After this chapter, you’ll have the skills you
    need to write that custom script.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 有无数的使用案例，Shell 脚本*恰好*是解决你问题空间的最佳工具。完成本章后，你将具备编写自定义脚本所需的技能。
- en: Basics
  id: totrans-21
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 基础
- en: Bash can be learned like any other programming language. It’s got an environment
    (Unix or Linux), a kind of standard library (any CLI-driven program installed
    on the system), variables, control flow (loops, testing, and iteration), interpolation,
    a few built-in data structures (arrays, strings, and booleans – sort of), and
    more.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: Bash 可以像学习任何其他编程语言一样学习。它有一个环境（Unix 或 Linux）、一种标准库（系统上安装的任何 CLI 驱动程序）、变量、控制流（循环、测试和迭代）、插值、一些内置的数据结构（数组、字符串和布尔值——算是吧）等等。
- en: This entire book assumes that you’re a software developer and, therefore, know
    how to program, so rather than teach you about these standard programming-language
    features, we’ll simply show you what they look like in Bash, along with some advice
    on idiomatic use (or common misuse).
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 本书假设你是一个软件开发人员，因此知道如何编程，因此我们不会向你教授这些标准的编程语言特性，而是简单地展示它们在 Bash 中的表现，并提供一些习惯用法（或常见误用）的建议。
- en: Variables
  id: totrans-24
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 变量
- en: Like any programming language, Bash has variables that can either be empty or
    set to a value. Unset variables are simply “empty,” and Bash will happily use
    them without panicking unless you set the `-u` (error on unset variables) option
    via `set -u`.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 像其他编程语言一样，Bash 有可以为空或设置为某个值的变量。未设置的变量就是“空的”，除非你通过`set -u`设置了`-u`选项（在未设置变量时产生错误），否则
    Bash 会愉快地使用它们而不会慌张。
- en: Setting
  id: totrans-26
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 设置
- en: To set a variable, use the equals sign.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 设置变量时，使用等号。
- en: '`FOOBAR=nice` will set the `FOOBAR` variable to the value `nice`.'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: '`FOOBAR=nice` 将把 `FOOBAR` 变量的值设置为 `nice`。'
- en: There are no types in Bash – it’s about as untyped as a programming language
    can get.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: Bash 没有类型——它几乎是最不具类型的编程语言。
- en: A variable symbol itself can contain letters, numbers, and underscores, but
    may not start with a number.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 变量符号本身可以包含字母、数字和下划线，但不能以数字开头。
- en: 'It is common practice to use uppercase variable names for environment variables
    and lowercase ones inside of Bash scripts. These variable names typically use
    underscores to separate individual words. When using numbers inside of variable
    names, avoid starting with digits. Bash forbids this. As with other languages,
    it’s a good practice for names to indicate what a variable is used for and whether
    it is a constant, or use a plural name for an array:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 通常的做法是，环境变量使用大写字母命名，而 Bash 脚本中的变量使用小写字母命名。这些变量名通常使用下划线来分隔单词。当在变量名中使用数字时，避免以数字开头。Bash
    不允许这样做。和其他语言一样，命名时最好让变量名能表示它的用途，并指示它是否是常量，或者对于数组使用复数名称：
- en: 'Illegal: `%foo&bar=bad`'
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不合法：`%foo&bar=bad`
- en: 'Illegal: `2foo_bar=bad`'
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不合法：`2foo_bar=bad`
- en: 'Legal but bad: `foo_BAR123=still_very_bad`'
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 合法但不推荐：`foo_BAR123=still_very_bad`
- en: 'Good environment variable: `PORT=443`'
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 正确的环境变量：`PORT=443`
- en: 'Good: `local_var=512`'
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 正确示例：`local_var=512`
- en: 'Good environment variable: `FOO_BAR123=good`'
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 正确的环境变量：`FOO_BAR123=good`
- en: 'Good local array var: `words=(foo bar baz)`'
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 正确的本地数组变量：`words=(foo bar baz)`
- en: Getting
  id: totrans-39
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 获取
- en: 'To use a variable, reference it with the `$` character:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用变量，可以通过`$`符号引用它：
- en: '[PRE0]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Bash versus other shells
  id: totrans-42
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Bash 与其他 shell 的比较
- en: A huge variety of shell programs exist for Unix-like environments; you could
    argue that one of the major reasons for Unix’s popularity is the fact that it’s
    always been an environment with essentially no barriers to scripting and automation.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 在类 Unix 环境中存在着各种各样的 shell 程序；你可以认为，Unix 的流行原因之一就是它一直是一个几乎没有障碍的脚本和自动化环境。
- en: This chapter teaches you how to write your own scripts in Bash. Much of what
    you’ll learn here will also work on other shells (for example, `ksh` and other
    common minimal shells that you’ll find at `/bin/sh`), but we’re focused on Bash
    here.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将教你如何用 Bash 编写自己的脚本。你在这里学到的很多内容也可以在其他 shell（例如 `ksh` 和你在 `/bin/sh` 找到的其他常见最小化
    shell）上使用，但我们这里关注的是 Bash。
- en: If you’re writing a shell script, Bash strikes the perfect balance between wide
    availability and a language feature set that’s large enough to make it comfortable
    to write small programs.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在编写 shell 脚本，Bash 在广泛可用性和足够大的语言功能集之间取得了完美的平衡，足以让你编写小型程序时感到舒适。
- en: Shebangs and executable text files, aka scripts
  id: totrans-46
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Shebang 和可执行文本文件，也就是脚本
- en: In Unix-like systems, a “script” is just an executable plaintext file. The operating
    system (often called “the kernel” in Linux) looks at the very first line to determine
    which interpreter to feed the file’s content into.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 在类 Unix 系统中，“脚本”只是一个可执行的纯文本文件。操作系统（在 Linux 中通常被称为“内核”）查看第一行，以确定将文件的内容传递给哪个解释器。
- en: 'That first line is the so-called “shebang” (or hashbang), and it consists of
    a hash and an exclamation mark (`#!`) character, followed by the path to the interpreter
    that is used to execute the file’s code. Here’s an example shebang line:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 第一行是所谓的“shebang”（或称hashbang），由一个井号和一个感叹号（`#!`）字符组成，后面跟着用于执行文件代码的解释器的路径。以下是一个示例的shebang行：
- en: '[PRE1]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: When the kernels of Unix-like systems run a file with the executable bit set,
    they’ll take a look at the first bytes. This might contain a magic number. This
    number can be part of binary files or some human-readable character, like in the
    shebang. The kernel uses this information to know whether there is a proper way
    to execute it. This, for example, prevents situations where the kernel would try
    to execute an image file and crash. Depending on the system, the kernel or the
    shell will make sure that the command following is executed. The `env` program
    will run the command and take the `PATH` environment variable into account to
    find and execute `bash`.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 当Unix类系统的内核运行一个具有可执行位的文件时，它们会查看文件的前几个字节。这可能包含一个魔术数字。这个数字可以是二进制文件的一部分，或者是像shebang中那样的人类可读字符。内核使用这些信息来判断是否有适当的方式执行它。例如，这可以防止内核尝试执行一个图像文件并崩溃。根据系统的不同，内核或shell会确保随后的命令被执行。`env`程序将运行该命令，并考虑`PATH`环境变量来查找并执行`bash`。
- en: 'While a hash denotes a comment in most scripting languages and would, therefore,
    be ignored by the interpreter, this special comment at the beginning of a file
    tells the operating system which command to run to interpret the rest of the file.
    Here are some common examples you’ll see:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然井号在大多数脚本语言中表示注释，因此会被解释器忽略，但文件开头的这个特殊注释告诉操作系统应该运行哪个命令来解释文件的其余部分。这里是你会看到的一些常见示例：
- en: '`#!/bin/sh`: use this specific shell program at this specific filesystem location'
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`#!/bin/sh`：在这个特定的文件系统位置使用这个特定的shell程序'
- en: '`#!/usr/bin/python3`: use this specific Python binary'
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`#!/usr/bin/python3`：使用这个特定的Python二进制文件'
- en: '`#!/usr/bin/env python`: use the `env` program to figure out which Python binary
    to use in this environment (different systems may have different versions of the
    same program installed, at different paths)'
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`#!/usr/bin/env python`：使用`env`程序来确定在该环境中使用哪个Python二进制文件（不同的系统可能会在不同的路径下安装同一个程序的不同版本）'
- en: While you will see all of these variants, the best option is to always use `/usr/bin/env`
    for portability. `/bin/sh` is the exception here, since every POSIX-compatible
    system is required to have a POSIX-compatible shell in this location.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然你会看到所有这些变体，但最佳选择始终是使用`/usr/bin/env`以确保可移植性。`/bin/sh`是一个例外，因为每个符合POSIX的系统都必须在该位置提供一个符合POSIX的shell。
- en: Common Bash settings (options/arguments)
  id: totrans-56
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 常见的Bash设置（选项/参数）
- en: Since the shebang line is executed as a command, arguments may also be passed.
    And while it can be a good idea to keep things simple, a common theme is to pass
    extra arguments to shells, especially to Bash, which is often used for large scripts
    because it has extra features compared to the smaller shells usually found at
    `/bin/sh`.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 由于shebang行作为命令执行，因此也可以传递参数。虽然保持简单通常是一个好主意，但一个常见的做法是向shell传递额外的参数，特别是对于Bash来说，它常用于大型脚本，因为与通常位于`/bin/sh`的较小shell相比，Bash提供了更多的特性。
- en: 'In Bash scripts, you will often see the `-e`, `-u`, `-x`, `-o pipefail` arguments
    passed. You may find these arguments in the shebang line itself:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 在Bash脚本中，你会经常看到传递的`-e`、`-u`、`-x`、`-o pipefail`等参数。你可能会在shebang行本身看到这些参数：
- en: '[PRE2]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Or, as the next statement, using the `set` command in Bash, which sets arguments
    or options:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，使用Bash中的`set`命令设置参数或选项，正如下一个语句所示：
- en: '[PRE3]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Setting these options makes Bash behave a bit more like the programming languages
    you’re used to, by:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 设置这些选项使得Bash的行为更像你习惯的编程语言，具体包括：
- en: Exiting immediately if any component of a command pipeline fails, and
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果命令管道的任何组成部分失败，立即退出，并且
- en: Treating unset variables as fatal errors.
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将未设置的变量视为致命错误。
- en: 'Here’s a breakdown of the documentation for these options, along with a useful
    debug option (`-x`) as a bonus:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 这是这些选项的文档拆解，并附带一个有用的调试选项（`-x`）作为额外内容：
- en: '`-o pipefail`: When using pipes, this will make sure that errors happening
    in the pipeline will be passed on. If more than one error happens, the rightmost
    will be used.'
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-o pipefail`：在使用管道时，这将确保管道中发生的错误会被传递。如果发生多个错误，将使用最右侧的错误。'
- en: '`-e`: If there is an error or a command fails, this will make sure that the
    shell script exits immediately.'
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-e`：如果出现错误或命令失败，这将确保shell脚本立即退出。'
- en: '`-u`: throw an error if any unset variables are used.'
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-u`：如果使用任何未设置的变量，将抛出错误。'
- en: 'For debugging, `-x` is useful:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 对于调试，`-x`非常有用：
- en: '`-x`: This will enable tracing. This means that each command will be written
    to standard error before executing it.'
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-x`：这将启用跟踪。这意味着每个命令将在执行之前写入标准错误。'
- en: 'All arguments, except `–o pipefail`, can be found in most Unix shells. For
    more information on the options that Bash contains, see its manual page: [https://manpages.org/bash](https://manpages.org/bash).'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 除了 `–o pipefail` 外，所有参数都可以在大多数 Unix shell 中找到。有关 Bash 选项的更多信息，请参阅其手册页：[https://manpages.org/bash](https://manpages.org/bash)。
- en: /usr/bin/env
  id: totrans-72
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: /usr/bin/env
- en: 'Here’s something to keep in mind: `/bin/sh` is a standardized path in POSIX
    leading to any POSIX-compatible shell. You can count on it to be there on ANY
    Linux or Unix system. Typically, this is not bash, but a more minimal shell, offering
    just enough functionality to satisfy the POSIX standard, which allows you to write
    very portable shell scripts. For all other shells and interpreters your script
    might need, it’s best practice to use the `#!/usr/bin/env` prefix for any other
    case. This makes sure that the correct path from `PATH` is used, and it will prevent
    a “command not found” error when the binary isn’t located in `/usr/bin/`.'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 记住一件事：`/bin/sh` 是一个 POSIX 标准路径，指向任何 POSIX 兼容的 shell。你可以放心它在任何 Linux 或 Unix 系统上都会存在。通常这不是
    Bash，而是一个更简约的 shell，提供足够的功能以满足 POSIX 标准，使你能够编写非常便携的 shell 脚本。对于脚本可能需要的所有其他 shell
    和解释器，最佳实践是使用 `#!/usr/bin/env` 前缀，这样可以确保使用 `PATH` 中的正确路径，并防止当二进制文件没有在 `/usr/bin/`
    中时出现“命令未找到”错误。
- en: 'There are various scenarios in which `/usr/bin/bash` or `/bin/bash` wouldn’t
    be the right path. For example:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 有多种情况可能导致 `/usr/bin/bash` 或 `/bin/bash` 不是正确的路径。例如：
- en: A package manager or company-specific configuration scripts will often install
    the interpreter in a different place than it would be on your development system.
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 包管理器或公司特定的配置脚本通常会将解释器安装在与开发系统不同的地方。
- en: Someone installing software manually, for example, to work around or reproduce
    a bug, often places the resulting binary in `/usr/local`.
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 手动安装软件的人，例如，为了绕过或重现一个 bug，通常会将生成的二进制文件放在 `/usr/local`。
- en: Virtual environments of various scripting languages will put binaries into a
    subdirectory of each source code `project/repository`.
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 各种脚本语言的虚拟环境将会把二进制文件放到每个源代码 `project/repository` 的子目录中。
- en: People installing the interpreter without root permissions, for example, in
    their home directory.
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 没有 root 权限的用户安装解释器，例如，在他们的主目录中。
- en: People using a version manager for the interpreter (rvm, nvm, and so on).
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用解释器版本管理器的人（例如，rvm、nvm 等）。
- en: Various Unix-like operating systems and some Linux distributions don’t install
    third-party packages into `/usr/`.
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 各种类 Unix 操作系统和一些 Linux 发行版不会将第三方软件包安装到 `/usr/` 目录。
- en: While many people can’t imagine their script ever ending up in such a non-standard
    place, chances are good that you’ll run into this eventually. Instead of risking
    your software breaking in these cases, it’s a good idea to simply get into the
    habit of writing `/usr/bin/env bash` (or whatever interpreter your code is written
    for) in your scripts. This prevents someone else – or your very tired future self,
    woken up by a pager at 3 in the morning – from having to notice, troubleshoot,
    find, or make such changes on source files when they break due to a minor change
    in the environment.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管很多人无法想象他们的脚本最终会出现在如此不标准的位置，但你最终很可能会遇到这种情况。与其冒着软件因环境的轻微变化而崩溃的风险，不如养成在脚本中写入
    `/usr/bin/env bash`（或你的代码所使用的解释器）的习惯。这样可以防止其他人——或者在凌晨 3 点被 pager 叫醒的你——不得不注意、排除故障、查找或在源文件中做出这样的更改。
- en: Special characters and escaping
  id: totrans-82
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 特殊字符与转义
- en: One special character you should use often is the hash symbol (`#`), which makes
    everything on the line following the symbol a comment that the interpreter ignores.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该经常使用的一个特殊字符是哈希符号（`#`），它会使该行符号后面的所有内容成为注释，解释器会忽略它们。
- en: 'Other characters have special meaning in Bash, and they need to be escaped
    with a forward slash (`\`) when you use them as part of a variable’s value. Here
    are some of them:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 其他字符在 Bash 中有特殊含义，当你将它们作为变量的值的一部分使用时，需要用正斜杠（`\`）转义。以下是一些例子：
- en: Quotes (`"` and `'`)
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 引号（`"` 和 `'`）
- en: Brackets and parentheses (`{`, `}`, `[`, `]`, and `(`, `)`)
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 括号和圆括号（`{`、`}`、`[`、`]` 和 `(`、`)`）
- en: Carets (`<` and `>`)
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 插入符号（`<` 和 `>`）
- en: 'Tilde: `~`'
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 波浪线：`~`
- en: 'Asterisk (the “glob character” in Bash): `*`'
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 星号（Bash 中的“通配符”字符）：`*`
- en: 'Ampersand: `&`'
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 和号：`&`
- en: 'Question mark: `?`'
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 问号：`?`
- en: 'Common operators: `!`, `=`, `|`, and so on'
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 常见操作符：`!`、`=`、`|` 等
- en: 'Escape them like you do in most other programming languages:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 像在大多数其他编程语言中一样转义它们：
- en: '[PRE4]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Command substitution
  id: totrans-95
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 命令替换
- en: 'One of the benefits and major use cases of shell scripting is that any command
    is easily accessible. A very common example of this is command substitution. This
    is useful when you want to use the output of one or more commands. You can do
    this with command substitution:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: Shell 脚本的一个优势和主要用例是任何命令都很容易访问。一个非常常见的例子是命令替换。当你想要使用一个或多个命令的输出时，这非常有用。你可以通过命令替换来做到这一点：
- en: '[PRE5]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'This executes those commands – in this case, just `date`, but it could also
    be a complex expression that you’ve piped together. Another way to do the same
    is to use backticks. The following example will have the same output:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 这将执行这些命令 —— 在这个例子中只是 `date`，但它也可以是你通过管道连接起来的复杂表达式。另一种做法是使用反引号。以下示例将产生相同的输出：
- en: '[PRE6]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Testing
  id: totrans-100
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试
- en: The testing commands shown here are usually used along with `if/else` control
    flow statements. Both the string testing function (`[[`) and the arithmetic testing
    function (`((`) return 0 if the test evaluates to a `true` value, or 1 if the
    test evaluates to `false`. This is due to the 0 exit code of commands indicating
    success, and it is different from other programming languages you might know that
    typically evaluate a zero value as false. There is no native `boolean` data type
    in Bash; the integers 0 and 1 are used in boolean contexts like this one. Sometimes,
    the variables `true` and `false` are initialized and used throughout a script.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 这里显示的测试命令通常与 `if/else` 控制流语句一起使用。字符串测试函数（`[[`）和算术测试函数（`((`）如果测试结果为 `true`，则返回
    0；如果结果为 `false`，则返回 1。这是因为命令的退出代码 0 表示成功，这与你可能熟悉的其他编程语言不同，后者通常将零值评估为 false。Bash
    中没有原生的 `boolean` 数据类型；整数 0 和 1 在布尔上下文中被使用。在脚本中，有时会初始化并使用变量 `true` 和 `false`。
- en: Testing operators
  id: totrans-102
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 测试运算符
- en: 'Here are some basic boolean operators that you can use to construct statements
    in Bash – essentially, what you’re used to from other languages:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是一些你可以在 Bash 中用来构造语句的基本布尔运算符 —— 本质上就是你在其他编程语言中已经习惯的运算符：
- en: '`!` – not (negation)'
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`!` – 非（否定）'
- en: '`&&` – and'
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`&&` – 且'
- en: '`||` – or'
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`||` – 或'
- en: 'These operators can be used with both string and arithmetic test types:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 这些运算符可以与字符串和算术测试类型一起使用：
- en: '`==` – is equal to'
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`==` – 等于'
- en: '!= is not equal to'
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '!= 表示不等于'
- en: '[[ file and string testing ]]'
  id: totrans-110
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '[[ 文件和字符串测试 ]]'
- en: The `[[` compound command allows you to perform (and combine) “string” comparisons.
    As mentioned before, Bash doesn’t have the kind of strict data types that you’re
    used to from other programming languages, so we’re calling them “string” or “string-like”
    comparisons because that’s a familiar concept to software developers.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: '`[[` 复合命令允许你执行（并结合）“字符串”比较。如前所述，Bash 没有你在其他编程语言中习惯的严格数据类型，因此我们将其称为“字符串”或“类似字符串”的比较，因为这对软件开发人员来说是一个熟悉的概念。'
- en: 'If the user’s home directory does not exist, create it:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 如果用户的主目录不存在，创建它：
- en: '[PRE7]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: That `!` character is a Bash negation, so you can read the first line of this
    example as `if NOT (test) is-a-directory $HOME, then…`.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 那个 `!` 字符是 Bash 的否定运算符，因此你可以将这个示例的第一行理解为 `if NOT (test) is-a-directory $HOME,
    then…`。
- en: 'Here’s a slightly more complicated example. If the user’s home directory does
    not exist, `OR` if the `ALWAYSCREATE` variable is set to `yes`, create the home
    directory:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个稍微复杂一点的示例。如果用户的主目录不存在，`或者` 如果 `ALWAYSCREATE` 变量设置为 `yes`，则创建主目录：
- en: '[PRE8]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Useful operators for string testing
  id: totrans-117
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 有用的字符串测试运算符
- en: '`-z` is unset (used for variables)'
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-z` 是未设置（用于变量）'
- en: '`-n` is non-zero (`set` – used for variables)'
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-n` 是非零的（`set` – 用于变量）'
- en: '`=~` is a left operand that matches a regular expression (right operand), for
    example `[[ foobar =~ f*bar ]]`'
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`=~` 是一个左操作数，用于匹配正则表达式（右操作数），例如 `[[ foobar =~ f*bar ]]`'
- en: Useful operators for file testing
  id: totrans-121
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 文件测试的有用运算符
- en: '`-d`: a directory'
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-d`: 目录'
- en: '`-e`: exists'
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-e`: 存在'
- en: '`-f`: a regular file'
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-f`: 一个常规文件'
- en: '`-S`: a socket file'
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-S`: 一个套接字文件'
- en: '`-w`: writable, from the perspective of this Bash process'
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-w`: 可写，从这个 Bash 进程的角度来看'
- en: (( arithmetic testing ))
  id: totrans-127
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: (( 算术测试 ))
- en: 'Arithmetic evaluated in a `((` test will set the test’s exit value to 1 if
    the expression evaluates to 0; otherwise, it will return an exit status of 0\.
    This makes testing quite intuitive, using operators you already know from virtually
    every other programming language:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `((` 测试中进行的算术评估如果表达式的结果为 0，将把测试的退出值设置为 1；否则，它将返回退出状态 0。使用你在几乎所有其他编程语言中都知道的运算符，这使得测试变得非常直观：
- en: '`>` and `>=` – greater-than and greater-than or equal-to'
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`>` 和 `>=` – 大于和大于或等于'
- en: '`<` and `<=` – less-than and less-than or equal-to'
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`<` 和 `<=` – 小于和小于或等于'
- en: '`==` – test equality'
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`==` – 测试相等性'
- en: '`(( $SOME_NUMBER == 24 ))` is a fairly straightforward arithmetic test. Let’s
    see how it behaves.'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: '`(( $SOME_NUMBER == 24 ))` 是一个相当直接的算术测试。让我们看看它的行为。'
- en: 'For the number 24:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 对于数字 24：
- en: '[PRE9]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'The “`echo $?`" command prints out the exit status of the previous command,
    which lets us see what the arithmetic test actually evaluated to. For other values,
    including non-numeric ones:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: “`echo $?`” 命令输出上一个命令的退出状态，这让我们能够看到算术测试实际评估的结果。对于其他值，包括非数字值：
- en: '[PRE10]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'If `$SOME_NUMBER` is unset (for example, `[[ -z $SOME_NUMBER ]]` ):'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 `$SOME_NUMBER` 未设置（例如，`[[ -z $SOME_NUMBER ]]`）：
- en: '[PRE11]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'So, to review:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，总结一下：
- en: '`(( $SOME_NUMBER == 24 ))` will evaluate to 0 if the `SOME_NUMBER` variable
    is set to 24.'
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`(( $SOME_NUMBER == 24 ))` 如果 `SOME_NUMBER` 变量设置为 24，将评估为 0。'
- en: If `$SOME_NUMBER` is set to a value `OTHER THAN 24` (including a non-numeric
    value), it will evaluate to 1.
  id: totrans-141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果 `$SOME_NUMBER` 设置为一个 `不是 24` 的值（包括非数字值），它将评估为 1。
- en: If `$SOME_NUMBER` is *unset*, you’ll get an error because your arithmetic test
    doesn’t have a left operand to use for the comparison.
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果 `$SOME_NUMBER` 被 *未设置*，你将会得到一个错误，因为你的算术测试没有左操作数可以用于比较。
- en: 'Conditionals: if/then/else'
  id: totrans-143
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 条件语句：if/then/else
- en: 'A Bash `if` statement is usually found in this form:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 一个 Bash `if` 语句通常以这种形式出现：
- en: '`if [[ $TEST ]]; then $STATEMENTS else $OTHER_STATEMENTS fi`'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: '`if [[ $TEST ]]; then $STATEMENTS else $OTHER_STATEMENTS fi`'
- en: 'Remember a few things about this form before we look at examples:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们查看示例之前，记住这个形式的一些事项：
- en: '`if` and `fi` begin and terminate the `if` block, respectively.'
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`if` 和 `fi` 分别用于开始和结束 `if` 块。'
- en: '`;` delimits statements in Bash; add one right after the test.'
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`;` 用于分隔 Bash 中的语句；在测试后加一个分号。'
- en: '`[[` and `]]` delimit your test expression.'
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`[[` 和 `]]` 用于分隔你的测试表达式。'
- en: The `else` clause is optional.
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`else` 子句是可选的。'
- en: 'Here’s what the `if` statement looks like in Bash:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是 Bash 中 `if` 语句的样子：
- en: '[PRE12]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: ifelse
  id: totrans-153
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: ifelse
- en: If you want to tack an `else` clause onto this structure, you can!
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想在这个结构中加上 `else` 子句，当然可以！
- en: '[PRE13]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Loops
  id: totrans-156
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 循环
- en: Bash loops come in the general format `for / do / done`. They also support `break`
    and `continue` statements, which break out of the loop and skip to the next iteration,
    respectively.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: Bash 循环的一般格式是 `for / do / done`。它们还支持 `break` 和 `continue` 语句，分别用来跳出循环和跳到下一个迭代。
- en: C-style loops
  id: totrans-158
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: C 风格的循环
- en: 'Bash supports C-style loops, with an initializer expression, a conditional
    expression, and a counting expression:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: Bash 支持 C 风格的循环，包括初始化表达式、条件表达式和计数表达式：
- en: '[PRE14]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: for…in
  id: totrans-161
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: for…in
- en: 'Let’s talk about iteration with `for...in` loops. Try running the following
    in your shell:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来谈谈使用 `for...in` 循环的迭代。试着在你的Shell中运行以下命令：
- en: '[PRE15]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Here’s a loop with some control flow inside:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个包含一些控制流的循环：
- en: '[PRE16]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: While
  id: totrans-166
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: While
- en: Another common control structure you might be familiar with from other programming
    languages is the `while` loop. In Bash, this works very similarly. To break out
    of a loop, the `break` statement can be used.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个你可能在其他编程语言中熟悉的常见控制结构是 `while` 循环。在 Bash 中，这个语法非常相似。要跳出循环，可以使用 `break` 语句。
- en: 'The following script will read the `lines.txt` file line by line until it encounters
    the `STOP` line. The last line also shows how you can pipe a file into a loop.
    The `read` command will take care of processing the file line by line:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 以下脚本将逐行读取 `lines.txt` 文件，直到遇到 `STOP` 行。最后一行还展示了如何将文件通过管道传递给循环。`read` 命令将逐行处理文件：
- en: '[PRE17]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Variable exporting
  id: totrans-170
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 变量导出
- en: Exporting a variable by prefixing it with `export` ensures that any subshells
    spawned from your script’s process will also have access to that variable’s value.
    It’s a way of ensuring that a variable is propagated down to any future sub-scopes
    (or sub-namespaces) of your current shell’s variable scope or namespace.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 通过在变量前加上 `export` 来导出一个变量，确保从你脚本的进程派生出来的任何子Shell也能访问该变量的值。这是一种确保变量能够传递到当前Shell变量作用域或命名空间的任何未来子作用域（或子命名空间）中的方法。
- en: 'Set a variable in your shell:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 在你的 Shell 中设置一个变量：
- en: '[PRE18]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Create and run this script (warning: this will fail!):'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 创建并运行这个脚本（警告：这将失败！）：
- en: '[PRE19]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'You’ll see an error, `ls: /Documents: No such file or directory`, because running
    this script spawned a subshell that did not have access to unexported variables
    in its parent shell (the shell that spawned it, in other words your interactive
    shell). Letting subshells access your variables must be done explicitly, via the
    `export` keyword:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: '你会看到一个错误，`ls: /Documents: No such file or directory`，因为运行这个脚本启动了一个子Shell，而该子Shell无法访问父Shell中未导出的变量（换句话说，就是你交互式Shell的父Shell）。让子Shell访问你的变量必须通过
    `export` 关键字明确地进行：'
- en: '[PRE20]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Rerun the example script now that you’ve exported the variable, and you’ll see
    that it can now access the `MYDIR` variable.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 导出变量后重新运行示例脚本，你会发现它现在可以访问`MYDIR`变量。
- en: Functions
  id: totrans-179
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 函数
- en: We generally recommend that by the time you find yourself needing Bash functions,
    you will have found another language to write your growing program in. However,
    sometimes Bash is still the right language for a problem, and we want to show
    you the absolute basics, with a strong bias toward how we recommend using them.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通常建议，当你发现自己需要使用Bash函数时，应该已经找到一种其他语言来编写你日益增长的程序。然而，有时Bash仍然是解决问题的正确语言，我们希望向你展示最基本的内容，尤其是我们推荐的使用方式。
- en: 'Define a function by using the `function` keyword:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`function`关键字来定义一个函数：
- en: '[PRE21]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Call functions by simply invoking their name:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 通过简单地调用函数的名称来调用函数：
- en: '[PRE22]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Prefer local variables
  id: totrans-185
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 偏好使用本地变量
- en: Bash works with a more-or-less global scope – more accurately, per (sub)shell.
    Many modern programming languages give you a separate function scope to work with,
    so function state doesn’t pollute global state after a function exits.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: Bash工作在更或少是全局作用域——更准确地说，是每个（子）Shell的作用域。许多现代编程语言提供了独立的函数作用域，这样函数状态在函数退出后不会污染全局状态。
- en: 'Using `local` variables in your functions will protect you from this, and we
    recommend you use them:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 在函数中使用`local`变量可以防止这种情况发生，我们建议你使用它们：
- en: '[PRE23]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Run this code yourself and see the difference that using local `vars` makes.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 运行这段代码，自己看看使用本地`vars`带来的不同。
- en: Input and output redirection
  id: totrans-190
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 输入和输出重定向
- en: 'When you run scripts, you’ll often want to redirect their output:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 当你运行脚本时，你通常会希望将它们的输出重定向：
- en: To another program (via a pipe – `|` – see *Chapter 11*, *Pipes and Redirection*,
    for more details)
  id: totrans-192
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 重定向到另一个程序（通过管道`|`——更多细节见*第11章*，*管道和重定向*）
- en: To a regular file (like a log file)
  id: totrans-193
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 重定向到常规文件（如日志文件）
- en: To a special location like `/dev/null`, which can act as a kind of black hole
    for data you don’t need
  id: totrans-194
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 重定向到一个特殊位置，如`/dev/null`，它可以作为一个“黑洞”，用于存放你不需要的数据
- en: Aside from pipes, here are the most common input/output redirection tricks you’ll
    see in the wild.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 除了管道外，以下是你在实际中最常见的输入/输出重定向技巧：
- en: '<: input redirection'
  id: totrans-196
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '`<`：输入重定向'
- en: 'This is often used to grab input from a file, instead of from the shell spawning
    a process:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 这通常用于从文件中获取输入，而不是通过Shell启动进程：
- en: '[PRE24]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'and >>: output redirection'
  id: totrans-199
  prefs:
  - PREF_H2
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 和`>>`：输出重定向
- en: 'The `>` symbol will stream output to wherever you point it, overwriting anything
    that’s already there if it’s a regular file:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: '`>`符号会将输出流重定向到你指定的地方，如果它是一个常规文件，将覆盖已有的内容：'
- en: '[PRE25]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Every time you run this, the output of `ps aux | grep foo` will be written to
    `/var/log/foo_overwrite.log`, overwriting any existing file content.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 每次运行这个命令时，`ps aux | grep foo`的输出会被写入`/var/log/foo_overwrite.log`，并覆盖任何现有的文件内容。
- en: 'Using `>>` instead will *append* to the output file, leaving any existing content
    intact. This is usually what you want for log files:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`>>`代替会*附加*到输出文件，保留现有内容不变。这通常是你处理日志文件时需要的：
- en: '[PRE26]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Use 2>&1 to redirect STDERR and STDOUT
  id: totrans-205
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用`2>&1`来重定向`STDERR`和`STDOUT`
- en: 'Sometimes, you want to redirect both standard output and standard error to
    a file:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，你可能希望将标准输出和标准错误都重定向到一个文件：
- en: '[PRE27]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: This command runs Hashicorp’s Consul in `dev-mode` and backgrounds the process
    (the `&` symbol at the end), redirecting standard output to a log file. `2>&1`
    tells Bash to “redirect file descriptor 2 (`STDERR`) to the same place as 1 (`STDOUT`)”
    – in this case, that’s `/var/log/consul.log`.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 这个命令以`dev-mode`模式运行Hashicorp的Consul，并将进程放到后台（结尾的`&`符号），将标准输出重定向到日志文件。`2>&1`告诉Bash“将文件描述符2（`STDERR`）重定向到和1（`STDOUT`）相同的位置”——在这种情况下，就是`/var/log/consul.log`。
- en: You already know about file descriptors – `STDIN`, `STDOUT`, and `STDERR`. What
    if you only want to redirect a standard error to a *different* file than a standard
    output?
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 你已经了解了文件描述符——`STDIN`、`STDOUT`和`STDERR`。如果你只想将标准错误重定向到一个*不同*的文件，而不是标准输出呢？
- en: Variable interpolation syntax – ${}
  id: totrans-210
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 变量插值语法——`${}`
- en: To accomplish what’s known as “string interpolation” in most programming languages
    – substituting part of a string with the value of a variable – you want Bash’s
    variable interpolation, `${}`.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 为了在大多数编程语言中实现“字符串插值”——用变量的值替换字符串的一部分——你需要使用Bash的变量插值，`${}`。
- en: 'Try it yourself:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 自己尝试一下：
- en: '[PRE28]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: There are other ways to interpolate variables in Bash, but this is our favorite
    way, since it has the lowest chance of breaking your program due to unexpectedly-shaped
    input (spaces, special characters, and so on).
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 在Bash中还有其他方法可以插入变量，但这是我们最喜欢的方式，因为它在处理形状不确定的输入（空格、特殊字符等）时，最不容易让程序崩溃。
- en: 'If you are going to use a variable as a string-like value, use this syntax
    – even if that variable is by itself and doesn’t really need to be interpolated
    into another string:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你打算将一个变量用作类似字符串的值，请使用这种语法——即使该变量本身并不需要插入到其他字符串中：
- en: '[PRE29]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: This will prevent many strange bugs and behaviors with Bash, so it’s a good
    habit to get into.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 这将防止出现许多奇怪的Bug和Bash中的异常行为，所以这是一个值得养成的好习惯。
- en: '**Note**'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: When working with variable interpolation, you’ll almost always want to run Bash
    with the `-u` option (either by calling it with `-u`, or by using `set -euo pipefail`
    at the beginning of your scripts, as we recommend). This will prevent you from
    having to check for zero values before you use a variable.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 在处理变量插值时，你几乎总是会希望以`-u`选项运行Bash（可以通过`-u`调用它，或者在脚本开头使用`set -euo pipefail`，如我们建议的那样）。这将防止你在使用变量之前需要检查其是否为零值。
- en: Limitations of shell scripts
  id: totrans-220
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Shell脚本的局限性
- en: Bash has innumerable features, many of which we’re not covering here. If you
    need to dig deeper into the Bash language and environment, there are many books
    and tons of free resources on the web. The Bash manpage (`man bash`) is a good
    start too, now that you’re oriented.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: Bash有无数功能，许多我们在这里没有涵盖。如果你需要深入了解Bash语言和环境，有许多书籍和大量免费的网络资源可供参考。Bash手册页（`man bash`）也是一个很好的起点，既然你已经有了基本的了解。
- en: We expect you to encounter many Bash scripts over the course of your career.
    However, it’s very likely that you’ll spend more time reading and deciphering
    existing scripts than writing large new Bash programs. Bash is an amazing fit
    for small problems and system tasks that lend themselves to being solved with
    existing software, which just needs to be tied together into a solution. It’s
    often a *terrible* fit for large problems that extend beyond tying together standard
    Linux and Unix programs.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 我们预期你在职业生涯中会遇到许多Bash脚本。然而，很可能你花更多时间阅读和解读现有脚本，而不是编写大型新的Bash程序。Bash非常适合解决小问题和系统任务，尤其是那些可以通过现有软件解决的问题，只需要将它们拼接成一个解决方案。对于超出标准Linux和Unix程序组合的大问题，它通常是一个*糟糕*的选择。
- en: 'With Bash, we find that:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Bash时，我们发现：
- en: Small is better than large
  id: totrans-224
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 小巧优于庞大
- en: Clear is better than clever
  id: totrans-225
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 清晰优于巧妙
- en: Safe is better than sorry
  id: totrans-226
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 安全总比后悔好
- en: It’s not uncommon to replace Bash scripts with tools written in a different
    programming language (often Python) as they grow. That’s not a dig against Bash!
    It’s perfect at filling the niche that it occupies, which is why it’s been so
    widespread for so long. If you occasionally stop to ask yourself, “Is a Bash script
    still the right solution for this problem?” you’ll be just fine.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 用不同编程语言（通常是Python）编写的工具替代Bash脚本并不少见，尤其是当脚本变得庞大时。这并不是说Bash不好！它在其所占据的领域内非常完美，这也是它能长期广泛使用的原因。如果你偶尔停下来问自己，“Bash脚本仍然是解决这个问题的正确方案吗？”你会没问题的。
- en: Conclusion
  id: totrans-228
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 结论
- en: This chapter was a no-punches-pulled, drink-from-the-fire-hydrant Bash scripting
    crash course. It’s dense, but it covers all the basics you need to become an effective
    Bash scripter. Work through it more than once if you have to. In addition to the
    syntax, we covered what we think are best practices that make writing readable,
    maintainable real-world scripts easier (or at least possible).
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 本章是一个不留情面的、从消防栓中喝水般的Bash脚本速成课程。内容密集，但它涵盖了成为高效Bash脚本编写者所需的所有基础知识。如果有必要，多看几遍。除了语法外，我们还介绍了我们认为的最佳实践，使得编写可读、可维护的实际脚本变得更容易（或者至少是可能的）。
- en: Practice, practice, practice – preferably on real-world problems you have, not
    just toy examples. There’s no faster way to get good.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 多加练习，多加练习，多加练习——最好是在你遇到的实际问题上练习，而不仅仅是玩具示例。没有比这更快的提升方式了。
- en: Citations
  id: totrans-231
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 引用
- en: '*Bash Test and Comparison Functions*. Used for [[ and (( option tables. Accessed
    Sept 25, 2022 [https://developer.ibm.com/tutorials/l-bash-test/](https://developer.ibm.com/tutorials/l-bash-test/).'
  id: totrans-232
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*Bash测试和比较函数*。用于[[和((选项表。访问日期：2022年9月25日 [https://developer.ibm.com/tutorials/l-bash-test/](https://developer.ibm.com/tutorials/l-bash-test/))。'
- en: Learn more on Discord
  id: totrans-233
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在Discord上了解更多
- en: 'To join the Discord community for this book – where you can share feedback,
    ask questions to the author, and learn about new releases – follow the QR code
    below:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 要加入本书的 Discord 社区——在这里你可以分享反馈、向作者提问，并了解新版本的发布——请扫描下面的二维码：
- en: '[https://packt.link/SecNet](https://packt.link/SecNet)'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://packt.link/SecNet](https://packt.link/SecNet)'
- en: '![](img/QR_Code1768422420210094187.png)'
  id: totrans-236
  prefs: []
  type: TYPE_IMG
  zh: '![](img/QR_Code1768422420210094187.png)'
