- en: '5'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '5'
- en: PowerShell Control Flow – Conditionals and Loops
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: PowerShell控制流 – 条件语句与循环
- en: So far, everything we have done has been one thing after another, to paraphrase
    Arnold Toynbee. That’s fine, but it doesn’t reflect how we want things to happen
    in the real world. Most of the time, we want our code to do different things depending
    on the circumstances, and sometimes we want it to do something a number of times.
    This is where control flow is necessary. In this chapter, we are going to look
    at how to make PowerShell do different things in a script, depending on what it
    finds – these are called **conditionals**. Then we are going to look at how to
    make PowerShell repeat a process, both for a predetermined number of times and
    for an indefinite number. Because an indefinite number may be effectively infinite,
    we are going to look at how to break out of and continue looping behavior.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们所做的一切都像阿诺德·汤因比所说的那样，一个接一个。这没问题，但它并没有反映出我们希望在现实世界中发生的情况。大多数时候，我们希望我们的代码根据不同的情况执行不同的操作，有时我们希望它执行某些操作若干次。这就是需要控制流的地方。在本章中，我们将探讨如何让PowerShell根据发现的内容在脚本中执行不同的操作——这些称为**条件语句**。接下来，我们将探讨如何让PowerShell重复执行某个过程，不管是预定的次数还是不定的次数。由于不定次数可能会是无限的，我们将讨论如何中断和继续循环行为。
- en: Doing this effectively requires writing multiple lines of code, so first, we
    are going to talk about **Integrated Development Environments** (**IDEs**) and
    then install the one that is recommended for PowerShell 7, Visual Studio Code.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 高效地完成这些操作需要编写多行代码，因此我们首先将讨论**集成开发环境**（**IDEs**），然后安装推荐用于PowerShell 7的编辑器，Visual
    Studio Code。
- en: 'In this chapter, we are going to cover the following main topics:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主要内容：
- en: An introduction to IDEs and VS Code
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: IDE和VS Code简介
- en: Conditional control – `if`, `else`, `elseif`, and `switch`
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 条件控制 – `if`、`else`、`elseif` 和 `switch`
- en: Loops – `foreach`, `do while`, `do until`, `while`, and `for`
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 循环 – `foreach`、`do while`、`do until`、`while` 和 `for`
- en: Breaking and continuing
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 中断与继续
- en: Let’s play a game
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 玩个游戏
- en: An introduction to IDEs and VS Code
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: IDE和VS Code简介
- en: The console is great for running a line or two of code or for quickly checking
    whether an idea will work, but it cannot save our code, and we can’t edit it.
    We need an editor. The simplest editor is whichever text editor we have installed
    on our machine, for instance, Notepad on Windows or Vi on Linux. These will do
    the bare minimum in that we can write our code, save it, and come back and edit
    it. They won’t do any more than that, though, and there are much better options
    available.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 控制台非常适合运行一两行代码，或者快速检查某个想法是否可行，但它无法保存我们的代码，也不能编辑它。我们需要一个编辑器。最简单的编辑器就是我们机器上安装的任何文本编辑器，例如Windows上的记事本或Linux上的Vi。它们能做的最基本的事情就是让我们写代码、保存代码并返回编辑。但是它们仅能做到这些，还有许多更好的选择可用。
- en: An IDE will highlight commands and keywords and do some syntax checking, and
    the good ones will also come with a built-in console to allow us to test our code
    by running short sections of it, sometimes just a line or the whole thing at once.
    They also usually have some sort of debugging facility, allowing us to stop our
    code at certain points and check the contents of variables. Most languages come
    with some form of IDE, for instance, Python has **IDLE**, the **Integrated Development
    and Learning Environment**, but I don’t know many people who use it for their
    work, and Windows PowerShell has the **Integrated Scripting Environment**, or
    **ISE**, which is excellent, but has not been made available for PowerShell 7\.
    Instead, the recommended IDE for PowerShell 7 is **Visual Studio Code** (**VS
    Code**), an open source JavaScript-based environment from Microsoft.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: IDE将高亮显示命令和关键字，并进行一些语法检查，好的IDE通常还会内置控制台，让我们通过运行短小的代码片段（有时是一行或者一次运行整个程序）来测试代码。它们通常还具有某种调试功能，允许我们在特定位置停止代码，并检查变量的内容。大多数编程语言都有某种形式的IDE，例如Python有**IDLE**，即**集成开发与学习环境**，但我不知道有多少人会用它来工作，而Windows
    PowerShell有**集成脚本环境**（**ISE**），它非常优秀，但未被移植到PowerShell 7中。因此，推荐用于PowerShell 7的IDE是**Visual
    Studio Code**（**VS Code**），这是一个由微软开发的基于JavaScript的开源环境。
- en: VS Code is highly extensible (translation – lots of people have written add-ons
    for it) and can be used with a wide range of languages. All we need to do is download
    our choice of language modules. There are also add-ons that check syntax, allow
    us to use code snippets, connect us to code repositories, such as Git, integrate
    testing, and generally do anything we could do with a far more expensive IDE,
    such as Eclipse. Rather than talk about it, let’s get it installed.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: VS Code是高度可扩展的（意思是——很多人已经为它编写了插件），并且可以支持多种语言。我们需要做的就是下载我们选择的语言模块。还有一些插件可以检查语法，允许我们使用代码片段，连接到代码仓库，如Git，集成测试，并且做任何我们在更昂贵的IDE（如Eclipse）中能做的事。不如不再多说，让我们开始安装吧。
- en: Installing VS Code
  id: totrans-14
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 安装VS Code
- en: VS Code can be installed on Windows, Linux, macOS, and Raspberry Pi – that’s
    right, there’s a Raspbian install. It’s pretty simple. Go to the VS Code download
    page at [https://code.visualstudio.com/download](https://code.visualstudio.com/download),
    and click on the relevant package for the machine and operating system we are
    working on; so for a Raspberry Pi, we would select the `.deb` ARM download. Once
    it’s downloaded, change to the folder or directory where we’ve saved the package.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: VS Code可以安装在Windows、Linux、macOS和Raspberry Pi上——没错，这里有Raspbian安装。其实很简单。访问VS Code下载页面：[https://code.visualstudio.com/download](https://code.visualstudio.com/download)，然后点击适合我们正在使用的机器和操作系统的相关安装包；对于Raspberry
    Pi，我们选择`.deb` ARM下载。下载完成后，切换到保存包的文件夹或目录。
- en: Linux
  id: totrans-16
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Linux
- en: 'VS Code is a graphical tool, so we need to use a desktop environment with Linux.
    For Ubuntu and other Debian-based versions, we just need to run the following
    commands:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: VS Code是一个图形化工具，所以我们需要在Linux上使用桌面环境。对于Ubuntu及其他基于Debian的版本，我们只需要运行以下命令：
- en: '[PRE0]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'For Raspbian, it’s easier still:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 对于Raspbian，过程更简单：
- en: '[PRE1]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: These commands will do it.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 这些命令会完成它。
- en: 'Things are a little more complicated for Red Hat distros. The easiest way is
    probably with snapd, in which case the following will work:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 对于Red Hat发行版，事情稍微复杂一些。最简单的方法可能是使用snapd，在这种情况下，以下命令会有效：
- en: '[PRE2]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: There are more detailed instructions on installing VS Code for Linux at [https://code.visualstudio.com/docs/setup/linux](https://code.visualstudio.com/docs/setup/linux).
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 在[https://code.visualstudio.com/docs/setup/linux](https://code.visualstudio.com/docs/setup/linux)上可以找到更详细的Linux安装VS
    Code的说明。
- en: macOS
  id: totrans-25
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: macOS
- en: To install VS Code on macOS, download the relevant Mac installer `.zip` file
    and extract the contents. Drag the `Visual Studio Code.app` to the `Applications`
    folder, which will make VS Code available in **Launchpad**.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 在macOS上安装VS Code，下载相关的Mac安装包`.zip`文件并解压其内容。将`Visual Studio Code.app`拖到`应用程序`文件夹，这样VS
    Code就能在**Launchpad**中使用了。
- en: Windows
  id: totrans-27
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Windows
- en: 'In Windows, we have a choice of user or system installations. If we follow
    the user install option, the application gets installed by default in `C:\Users\<username>\AppData\Local\Programs\Microsoft
    VS Code` and is only available for the user who installed it. If we use the system
    installer, then it gets installed in `C:\Program Files\Microsoft VS Code` and
    requires administrator privileges to install. Automatic updates are easier if
    we install the user installation package, so let’s go ahead and download that
    one:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 在Windows中，我们可以选择用户安装或系统安装。如果选择用户安装，应用程序默认安装在`C:\Users\<username>\AppData\Local\Programs\Microsoft
    VS Code`，仅对安装它的用户可用。如果使用系统安装程序，则会安装在`C:\Program Files\Microsoft VS Code`，并且需要管理员权限来安装。如果我们安装的是用户安装包，那么自动更新会更容易一些，所以我们就下载那个包吧：
- en: Once it’s downloaded, browse to the `Download` location and double-click the
    `.``exe` file.
  id: totrans-29
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下载完成后，浏览到`下载`位置并双击`.exe`文件。
- en: Accept the **End-User License Agreement** (**EULA**) and click **Next**.
  id: totrans-30
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接受**最终用户许可协议**（**EULA**）并点击**下一步**。
- en: Change the installation location if you want, and click **Next**.
  id: totrans-31
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果需要，可以更改安装位置，然后点击**下一步**。
- en: Decide whether you want a *Start* menu folder, and click **Next**.
  id: totrans-32
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 决定是否需要一个*开始*菜单文件夹，并点击**下一步**。
- en: 'On the `PATH` environment variable and registering code as an editor for supported
    file types. Click **Next**:'
  id: totrans-33
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 设置`PATH`环境变量，并将code注册为支持的文件类型的编辑器。点击**下一步**：
- en: '![Figure 5.1 – Select Additional Tasks for the VS Code installation](img/B17600_05_01.jpg)'
  id: totrans-34
  prefs: []
  type: TYPE_IMG
  zh: '![图5.1 – 选择VS Code安装的附加任务](img/B17600_05_01.jpg)'
- en: Figure 5.1 – Select Additional Tasks for the VS Code installation
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.1 – 选择VS Code安装的附加任务
- en: Review the installation options and click **Install**.
  id: totrans-36
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 审查安装选项并点击**安装**。
- en: Click **Finish** and admire your new VS Code installation.
  id: totrans-37
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击**完成**，然后欣赏你刚刚安装的VS Code。
- en: A really quick way for Windows
  id: totrans-38
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: Windows用户的快速安装方式
- en: 'If we’ve got the `PowerShellGet` module installed, then we can run the following:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们安装了`PowerShellGet`模块，我们就可以运行以下命令：
- en: '[PRE3]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Press `Y` to agree `Yes`, and that’s it. This method is great for when we know
    what we’re doing with VS Code, but if this is our first time with it, let’s do
    things manually so we can see exactly what’s going on.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 按`Y`表示同意`Yes`，就这样。这个方法非常适合我们已经熟悉 VS Code 的使用，但如果这是我们第一次使用它，我们可以手动操作，以便准确了解每个步骤的发生。
- en: Configuring VS Code for PowerShell
  id: totrans-42
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 配置 VS Code 以支持 PowerShell
- en: 'Now we’ve got VS Code installed, we need to tell it to recognize the PowerShell
    language. On installation VS Code has no idea about PowerShell. We need to install
    an extension. Open VS Code, if it isn’t already open, by typing `Code` in the
    search bar and selecting the application in the results. In the main window, click
    on the *Extensions* icon on the far-left edge of the window – it looks like a
    pile of boxes:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经安装了 VS Code，需要告诉它识别 PowerShell 语言。在安装时，VS Code 并不支持 PowerShell。我们需要安装一个扩展。打开
    VS Code，如果它尚未打开，可以在搜索栏中输入`Code`并从搜索结果中选择该应用程序。在主窗口中，点击窗口最左边的*扩展*图标——它看起来像一堆盒子：
- en: '![Figure 5.2 – Finding the PowerShell extension for VS Code](img/B17600_05_02.jpg)'
  id: totrans-44
  prefs: []
  type: TYPE_IMG
  zh: '![图 5.2 – 查找 VS Code 的 PowerShell 扩展](img/B17600_05_02.jpg)'
- en: Figure 5.2 – Finding the PowerShell extension for VS Code
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.2 – 查找 VS Code 的 PowerShell 扩展
- en: 'Type `powershell` in the extensions search bar. We want the PowerShell extension
    by Microsoft; it’s the first result, as shown in the following screenshot. Click
    on it, and then click the blue **Install** button in the main pane:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 在扩展搜索栏中输入`powershell`。我们需要的是由 Microsoft 提供的 PowerShell 扩展，它是第一个搜索结果，如下图所示。点击它，然后在主面板中点击蓝色的**安装**按钮：
- en: '![Figure 5.3 – Installing the PowerShell extension for VS Code](img/B17600_05_03.jpg)'
  id: totrans-47
  prefs: []
  type: TYPE_IMG
  zh: '![图 5.3 – 安装 VS Code 的 PowerShell 扩展](img/B17600_05_03.jpg)'
- en: Figure 5.3 – Installing the PowerShell extension for VS Code
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.3 – 安装 VS Code 的 PowerShell 扩展
- en: Let’s get started. Press *Ctrl* + *N* to open a new file. We’ll be asked to
    select a language. We don’t have to do this, but doing so means we have assistance
    ready from the start; we can type without specifying a language, but the syntax
    checking and highlighting won’t be available until we save our file as a PowerShell
    script by using the `.ps1` file extension. Go ahead and click to select **PowerShell**
    from the dropdown. We can change the language at any time by clicking on the language
    name in the bottom-right corner; if we haven’t selected a language then it says
    **Plain Text**.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 开始吧。按*Ctrl* + *N*来打开一个新文件。系统会要求我们选择语言。我们不必这样做，但这样做意味着从一开始就能得到帮助；我们可以不指定语言进行输入，但在将文件保存为
    PowerShell 脚本并使用`.ps1`文件扩展名时，语法检查和高亮显示才会启用。点击下拉菜单选择**PowerShell**。我们可以随时通过点击右下角的语言名称来更改语言；如果我们没有选择语言，它会显示**纯文本**。
- en: The first thing we should see after selecting PowerShell is that the PowerShell
    integrated terminal has started at the bottom of the screen. We can run PowerShell
    cmdlets in there, and when we run our code from the top window, the results will
    appear in the terminal. Try this – in the top window, type `write-outp`.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先看到的应该是 PowerShell 集成终端在屏幕底部启动了。我们可以在其中运行 PowerShell cmdlet，并且当我们从顶部窗口运行代码时，结果会显示在终端中。尝试这样做——在顶部窗口中输入`write-outp`。
- en: 'You should see VS Code give you a helpful autocomplete option like this:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该会看到 VS Code 提供一个有用的自动补全选项，像这样：
- en: '![Figure 5.4 – Autocomplete in VS Code](img/B17600_05_04.jpg)'
  id: totrans-52
  prefs: []
  type: TYPE_IMG
  zh: '![图 5.4 – 在 VS Code 中自动补全](img/B17600_05_04.jpg)'
- en: Figure 5.4 – Autocomplete in VS Code
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.4 – 在 VS Code 中自动补全
- en: 'Not only does it autocomplete for you, but it also gives hints about how the
    cmdlet is used; if you hover over the suggestion, you will see a `.ps1`; I’ve
    used `HelloWorld.ps1`. Now click the play icon (arrow) at the top right of the
    window to run the code. It should look something like this:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 它不仅会为你提供自动补全，还会提示如何使用 cmdlet；如果你将鼠标悬停在建议上，你会看到一个`.ps1`；我使用的是`HelloWorld.ps1`。现在点击窗口右上角的播放图标（箭头）来运行代码。它应该是这样的：
- en: '![Figure 5.5 – Running PowerShell in VS Code](img/B17600_05_05.jpg)'
  id: totrans-55
  prefs: []
  type: TYPE_IMG
  zh: '![图 5.5 – 在 VS Code 中运行 PowerShell](img/B17600_05_05.jpg)'
- en: Figure 5.5 – Running PowerShell in VS Code
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.5 – 在 VS Code 中运行 PowerShell
- en: If you get an output that looks like the preceding screenshot, congratulations.
    You’ve run your first script!
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你看到的输出像前面的截图，恭喜你！你已经成功运行了第一个脚本！
- en: Top tip for switching terminal environments
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 切换终端环境的技巧
- en: If you’re running on Windows, you’ve probably got at least two different versions
    of PowerShell installed – PowerShell 7 and Windows PowerShell. How do you swap
    between them? Click on the curly braces (`PATH` environment variable. You can
    use the `$PSVersionTable` variable to check which version you’re running.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你使用的是Windows系统，你可能至少安装了两个不同版本的PowerShell——PowerShell 7和Windows PowerShell。你如何在它们之间切换呢？点击大括号（`PATH`环境变量）。你可以使用`$PSVersionTable`变量来检查你正在运行的版本。
- en: 'VS Code is incredibly powerful and has hundreds of features and extensions,
    meaning we can spend a good chunk of our day using it, but this has a few drawbacks
    to be aware of:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: VS Code功能强大，拥有数百个功能和扩展，这意味着我们可以花费大量时间使用它，但也有几个需要注意的缺点：
- en: Because it is open source and frequently updated, blog articles and tutorials
    on the internet (or, heaven forfend, a book on PowerShell programming) can become
    rapidly out of date. We need to carefully research how to use a feature or understand
    why something doesn’t work and be wary of any source more than a year or two old.
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由于它是开源并且经常更新，互联网上的博客文章和教程（或者说，天哪，PowerShell编程书籍）可能会迅速过时。我们需要仔细研究如何使用某个功能，或者理解为什么某些东西不起作用，并且要小心任何超过一两年历史的资料来源。
- en: Because it is open source and extensible, there can be quite a steep learning
    curve. As we go through the book, we’ll cover quite a few of the common use cases
    and features, but we’ll barely scratch the surface of the things we can do with
    this software. The official Microsoft documentation is up to date, if not particularly
    user-friendly. We should supplement our reading with trustworthy articles and
    useful websites, such as Stack Overflow and Spiceworks.
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由于它是开源且可扩展的，因此学习曲线可能相当陡峭。在本书中，我们会介绍一些常见的使用案例和功能，但我们几乎只触及了使用该软件的表面。官方的Microsoft文档是最新的，但不太适合用户使用。我们应该通过可信的文章和有用的网站来补充我们的阅读，比如Stack
    Overflow和Spiceworks。
- en: Because it is open source and extensible, anyone can write extensions for it.
    This means that sometimes extensions will be brilliant, and sometimes they will
    be less useful. It can also be the case that an extension that was marvelous two
    years ago has now fallen into disrepair because the author wrote it as a fun project
    and is now concentrating on other things.
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由于它是开源且可扩展的，任何人都可以为其编写扩展。这意味着有时扩展会非常棒，但有时则不太有用。也可能是两年前一个非常出色的扩展，现在因为作者将其当作一个有趣的项目编写，而现在集中精力做其他事情，导致它已被搁置。
- en: These drawbacks aside, VS Code is incredibly useful. When we come across something
    that makes us wince in frustration, we should pause, be kind, and work around
    it. Better still, fix it; that is part of the joy of open source software.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管有这些缺点，VS Code仍然非常有用。当我们遇到让我们烦恼的事情时，我们应该暂停一下，保持耐心，并找到解决办法。更好的做法是，修复它；这正是开源软件的乐趣所在。
- en: Now we have VS Code installed and ready to use, let’s move on to the actual
    topic of the chapter; PowerShell control flow. We are going to start with conditionals.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经安装好了VS Code并准备好使用，让我们进入本章的实际主题——PowerShell控制流程。我们将从条件语句开始。
- en: Conditional control – if, else, elseif, and switch
  id: totrans-66
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 条件控制——if, else, elseif和switch
- en: 'Conditional control flow is based on a simple statement. If this thing is true,
    then do that thing. The first part is a Boolean expression. The second part is
    an action based on the resolution of the Boolean. A Boolean expression will resolve
    to one of two values: true or false. We discussed Boolean operators in [*Chapter
    3*](B17600_03.xhtml#_idTextAnchor049), *The PowerShell Pipeline – How to String
    Cmdlets Together*, in the *Understanding Where-Object advanced syntax* section.
    Consider the following two statements:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 条件控制流程基于一个简单的语句。如果这个条件为真，那么执行某个操作。第一部分是一个布尔表达式。第二部分是基于布尔表达式结果的一个动作。布尔表达式会解析为两种值之一：真或假。我们在[*第3章*](B17600_03.xhtml#_idTextAnchor049)，*PowerShell管道——如何将命令结合在一起*，以及*理解Where-Object高级语法*章节中讨论了布尔运算符。考虑以下两个语句：
- en: '[PRE4]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The first one resolves to the Boolean-type object true. The second one resolves
    to false. Try it if you don’t believe me. It’s not often that we need to check
    whether 1 is the same as 2, but we frequently need to compare variables:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个解析为布尔类型的真值。第二个解析为假值。如果你不相信，试试看。虽然我们不常检查1是否等于2，但我们经常需要比较变量：
- en: '![Figure 5.6 – Just checking](img/B17600_05_06.jpg)'
  id: totrans-70
  prefs: []
  type: TYPE_IMG
  zh: '![图 5.6 – 只是检查](img/B17600_05_06.jpg)'
- en: Figure 5.6 – Just checking
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.6 – 只是检查
- en: That covers the first part of our logic; next, we need to be able to perform
    an action based on the result of our test. Let’s get VS Code ready for some fun.
    Let’s close VS Code for now.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 这涵盖了我们逻辑的第一部分；接下来，我们需要根据测试结果执行某个操作。让我们为一些有趣的操作准备好 VS Code。现在先关闭 VS Code。
- en: 'Go to your PowerShell prompt (not the one in VS Code) and type the following
    to create a working directory, move to it, and start VS Code inside it:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 转到 PowerShell 提示符（不是 VS Code 中的提示符），并输入以下内容以创建工作目录，移动到该目录，并在其中启动 VS Code：
- en: '[PRE5]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The period after `Code` is important. Don’t miss it, or you will be working
    in the wrong location. VS Code will start and ask whether you want to trust the
    authors of the files in this folder. We probably do, as we are going to be the
    authors. We’re going to need a new file to work in, so press *Ctrl* + *N* to create
    a new file and select `Conditionals.ps1`. We have our blank canvas. Let’s go to
    work.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: '`Code` 后面的句点很重要。不要漏掉它，否则你会在错误的位置工作。VS Code 启动后，会询问是否信任该文件夹中的文件作者。我们大概会信任，因为我们将成为作者。我们需要创建一个新的文件来进行工作，所以按
    *Ctrl* + *N* 创建一个新文件并选择 `Conditionals.ps1`。我们有了空白画布。现在开始工作。'
- en: The if statement
  id: totrans-76
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: if 语句
- en: 'The first conditional we’ll look at is the simplest – the `if` statement. We
    can use this to perform an action based on whether an expression is true or false.
    Type this in the script pane:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先查看最简单的条件语句——`if` 语句。我们可以根据表达式是否为真来执行某个操作。请在脚本窗格中输入以下内容：
- en: '[PRE6]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The brackets contain an expression that needs to be evaluated. The curly braces
    contain a scriptblock that will run if the expression resolves to true. Now, highlight
    your lines and press *F8*. Your code will run, and you should see the output in
    the terminal window:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 括号中包含需要被评估的表达式。大括号中包含一个脚本块，当表达式为 true 时，它会运行。现在，选中你的代码行并按 *F8*。代码会运行，你应该能在终端窗口看到输出：
- en: '![Figure 5.7 – The if statement](img/B17600_05_07.jpg)'
  id: totrans-80
  prefs: []
  type: TYPE_IMG
  zh: '![图 5.7 – if 语句](img/B17600_05_07.jpg)'
- en: Figure 5.7 – The if statement
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.7 – if 语句
- en: Be careful to use single quotes; review [*Chapter 4*](B17600_04.xhtml#_idTextAnchor071),
    *PowerShell Variables and Data Structures*, to understand why. If you use double
    quotes in the action, then you will see the output `5 is bigger than 4`, because
    you’ve expanded the `$``x` variable.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 小心使用单引号；请查看 [*第 4 章*](B17600_04.xhtml#_idTextAnchor071)，*PowerShell 变量与数据结构*，以了解原因。如果在操作中使用双引号，则会看到输出
    `5 is bigger than 4`，因为你扩展了`$``x`变量。
- en: Top tip
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 提示
- en: After you type `if`, pause for a second to let VS Code catch up. It will offer
    you a choice of cmdlets and keywords. Click on `if` in the list, and it will construct
    the statement for you, as shown in lines 7 to 9 in *Figure 5**.7*. All you need
    to do is fill in the condition and the action.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 在输入 `if` 后，停顿一下，让 VS Code 赶上进度。它会为你提供 cmdlet 和关键字的选择。点击列表中的 `if`，它会为你构建该语句，如
    *图 5.7* 中第 7 行到第 9 行所示。你需要做的只是填入条件和操作。
- en: Look at the green text on lines 3 and 8\. Those are comments. We use them to
    make our code more readable and to clarify what we are doing. A single-line comment
    is started with `#`; everything after the `#` will be ignored by PowerShell. A
    multi-line comment starts with `<#` and ends with `#>`. These comments were autogenerated
    by VS Code; we can leave them in or delete them. It makes no difference to how
    the code runs.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 查看第 3 行和第 8 行的绿色文本。它们是注释。我们使用它们来使代码更易读，并澄清我们的操作。单行注释以 `#` 开头；`#` 后面的内容会被 PowerShell
    忽略。多行注释以 `<#` 开头，以 `#>` 结束。这些注释是 VS Code 自动生成的，我们可以保留或删除它们，这对代码的运行没有影响。
- en: 'We can test whether a statement is false as well. Type this below line 9:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以测试一个语句是否为假。在第 9 行下输入此内容：
- en: '[PRE7]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'We’re using`!` as a `-not` operator there. We could write line 11 as follows:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里使用了`!`作为`-not`运算符。我们可以将第 11 行改写为如下：
- en: '[PRE8]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'But you won’t see the `-not` operator written out like that very often – most
    people use `!`. If you highlight that code and press *F8* then you get the output
    `$x is bigger than` `4`, again:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 但你不会经常看到像那样写出的`-not`运算符——大多数人使用`!`。如果你选中这段代码并按 *F8*，你会再次看到输出 `$x is bigger than`
    `4`：
- en: '![Figure 5.8 – Reversing a condition with the -not operator](img/B17600_05_08.jpg)'
  id: totrans-91
  prefs: []
  type: TYPE_IMG
  zh: '![图 5.8 – 使用 -not 运算符反转条件](img/B17600_05_08.jpg)'
- en: Figure 5.8 – Reversing a condition with the -not operator
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.8 – 使用 -not 运算符反转条件
- en: If `$x` is smaller than 4, we will get no output, and the script will move on
    to the next line after the `if` statement – we don’t need to do anything else.
    What happens if we want the script to do one thing if a statement is true and
    something else if a statement is false?
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 `$x` 小于 4，我们将不会得到任何输出，脚本会继续执行 `if` 语句后的下一行——我们不需要做其他任何事。如果我们希望脚本在某个语句为真时执行一件事，而在语句为假时执行另一件事，会发生什么呢？
- en: The else statement
  id: totrans-94
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: else 语句
- en: 'We can use the `else` statement to specify a second action if the test condition
    for the `if` statement isn’t true. Type this starting on line 15 – use the autocomplete
    for the `else` statement and notice we are using `-lt` in the condition, not `-gt`:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用 `else` 语句来指定当 `if` 语句的测试条件不为真时的第二个动作。从第 15 行开始输入这个内容——使用自动完成功能来补全 `else`
    语句，并注意我们在条件中使用的是 `-lt`，而不是 `-gt`：
- en: '[PRE9]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Now select lines 15-22 and hit *F8*:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 现在选择第 15 到 22 行并按 *F8*：
- en: '![Figure 5.9 – Using the else statement](img/B17600_05_09.jpg)'
  id: totrans-98
  prefs: []
  type: TYPE_IMG
  zh: '![图 5.9 – 使用 else 语句](img/B17600_05_09.jpg)'
- en: Figure 5.9 – Using the else statement
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.9 – 使用 else 语句
- en: 'Notice the remark on line 20 from autocompleting the `else` statement: `Action
    when all if and elseif conditions are false`. The `else` statement is a catch-all
    if no conditions are true. But how do we test for multiple conditions? We could
    write multiple `if` statements, one after another, but each statement would execute
    regardless of the statement before. We could nest `if` statements inside each
    other, but that would be a lot of work.'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 注意第 20 行自动完成 `else` 语句时的备注：`当所有 if 和 elseif 条件为假时的操作`。`else` 语句是当没有条件为真时的兜底方案。但我们如何测试多个条件呢？我们可以一个接一个地写多个
    `if` 语句，但每个语句都会执行，不管前一个语句的结果如何。我们也可以把 `if` 语句嵌套在一起，但那样会非常繁琐。
- en: The elseif statement
  id: totrans-101
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: elseif 语句
- en: 'We can use `elseif` to specify multiple conditions to test for multiple conditions
    within a single `if` statement. Type this on line 24\. Use autocomplete to help
    get everything right:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用 `elseif` 来在单个 `if` 语句内指定多个条件进行测试。在第 24 行输入这个内容。使用自动完成功能来确保正确：
- en: '[PRE10]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Highlight the code you’ve just entered and hit *F8*. You should see the output
    as follows:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 高亮显示你刚刚输入的代码并按 *F8*。你应该看到如下输出：
- en: '![Figure 5.10 – Using the elseif statement](img/B17600_05_10.jpg)'
  id: totrans-105
  prefs: []
  type: TYPE_IMG
  zh: '![图 5.10 – 使用 elseif 语句](img/B17600_05_10.jpg)'
- en: Figure 5.10 – Using the elseif statement
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.10 – 使用 elseif 语句
- en: 'You can have as many `elseif` statements as you need, but once one is true,
    the parent `if` statement will exit. Try this:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以根据需要添加任意数量的 `elseif` 语句，但一旦某个语句为真，父级的 `if` 语句将会退出。试试这个：
- en: '[PRE11]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: We get the output `$x is less than 6`. The `else` statement never gets to run.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 我们得到的输出是 `$x is less than 6`。`else` 语句没有执行。
- en: The ternary operator
  id: totrans-110
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 三元运算符
- en: 'PowerShell 7 has a new operator that allows us to construct simple `if`/`else`
    statement pairs in a single line. On line 15 of our code, we have the following
    example:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: PowerShell 7 引入了一个新运算符，允许我们在单行中构造简单的 `if`/`else` 语句对。在我们代码的第 15 行，有如下示例：
- en: '[PRE12]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'We can rewrite this with the ternary operator like so:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以像这样用三元运算符重写它：
- en: '[PRE13]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: This is great and will save a lot of typing, but it’s also less readable. The
    question mark character (`?)` can also be used as an alias for the `Where-Object`
    cmdlet, but it’s not being used that way here. Remember that our code will be
    read many more times than it is written.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 这样很棒，可以节省很多输入，但也会使代码的可读性降低。问号字符 (`?`) 也可以作为 `Where-Object` cmdlet 的别名，但在这里并没有以这种方式使用。请记住，我们的代码会被阅读的次数远远超过编写的次数。
- en: What happens if multiple statements are true? Let’s look at a way we can handle
    that.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 如果多个语句为真，会发生什么？让我们看看如何处理这种情况。
- en: The switch statement
  id: totrans-117
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: switch 语句
- en: 'We could test for multiple conditions with multiple `if` statements, but that
    might get complicated, so there is a special statement to test for multiple true
    conditions – `switch`. The `switch` statement tests each condition and executes
    the associated scriptblock for that condition. Every condition that is true will
    execute. Let’s see how it works. On a new line, type the following:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用多个 `if` 语句来测试多个条件，但这样可能会变得复杂，因此有一个特殊的语句可以用来测试多个为真的条件——`switch`。`switch`
    语句会测试每个条件，并为该条件执行相关的脚本块。每个为真的条件都会被执行。让我们看看它是如何工作的。在新的一行中，输入以下内容：
- en: '[PRE14]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'If you select the code and press *F8* you should see the following output:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你选择代码并按 *F8*，你应该会看到以下输出：
- en: '![Figure 5.11 – Using the switch statement](img/B17600_05_11.jpg)'
  id: totrans-121
  prefs: []
  type: TYPE_IMG
  zh: '![图 5.11 – 使用 switch 语句](img/B17600_05_11.jpg)'
- en: Figure 5.11 – Using the switch statement
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.11 – 使用 switch 语句
- en: 'There are lots of things we can do with the `switch` statement. Consider the
    following example:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `switch` 语句可以做很多事情。请考虑以下示例：
- en: '[PRE15]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Here, we are running through a string. We’ve used the `-Wildcard` and `-CaseSensitive`
    parameters to check for matching portions of the string and make sure that the
    cases match as well. We’re evaluating a property of the string, not just the content,
    and finally, we are setting a default output:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们正在遍历一个字符串。我们使用了 `-Wildcard` 和 `-CaseSensitive` 参数来检查字符串中匹配的部分，并确保大小写也匹配。我们评估的是字符串的属性，而不仅仅是内容，最后，我们设置了一个默认输出：
- en: '![Figure 5.12 – Switch options](img/B17600_05_12.jpg)'
  id: totrans-126
  prefs: []
  type: TYPE_IMG
  zh: '![图 5.12 – Switch 选项](img/B17600_05_12.jpg)'
- en: Figure 5.12 – Switch options
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.12 – Switch 选项
- en: 'Let’s have a look at the lines of code in the screenshot:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看截图中的代码行：
- en: In line 75, we’re setting parameters for the `switch` statement – notice they
    have to come before the expression to be evaluated that is enclosed in brackets.
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在第 75 行，我们为 `switch` 语句设置了参数——请注意，它们必须在要评估的表达式之前，并且该表达式需要用括号括起来。
- en: In line 76, we’re asking whether the string contains the integer `7`. In lines
    77 and 78, we’re demonstrating the use of the `-``CaseSensitive` parameter.
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在第 76 行，我们在检查字符串是否包含整数 `7`。在第 77 行和第 78 行，我们演示了 `-CaseSensitive` 参数的使用。
- en: In line 80, we’re evaluating a property of the string, its length. Notice that
    this has to go in a scriptblock, so it needs curly braces, not brackets.
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在第 80 行，我们在评估字符串的一个属性，它的长度。请注意，这需要放在一个脚本块中，因此它需要使用大括号，而不是括号。
- en: Finally, on line 81, we are setting a default output – this will only be produced
    if no other conditions in the `switch` statement get matched.
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后，在第 81 行，我们设置了一个默认输出——只有在 `switch` 语句中的其他条件没有匹配时，才会输出这个结果。
- en: Activity 1
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 活动 1
- en: Why doesn’t the output produce the line `contains 7`?
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么输出没有产生 `contains 7` 这一行？
- en: We can also use a `-Regex` parameter to evaluate against a regular expression.
    This can’t be used with the `-Wildcard` or `-Exact` parameter. The `-Exact` parameter
    is the opposite of `-Wildcard` and is the default.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以使用 `-Regex` 参数来与正则表达式进行匹配。这不能与 `-Wildcard` 或 `-Exact` 参数一起使用。`-Exact` 参数与
    `-Wildcard` 参数相反，并且是默认值。
- en: Loops – foreach, do while, do until, while, for
  id: totrans-136
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 循环 – foreach、do while、do until、while、for
- en: Automation theory tells us that machines are better than people at performing
    repetitive tasks; they will perform the task any number of times in exactly the
    same way each time. When we are writing code, we call this iteration or looping.
    We’re going to look at four examples of looping in PowerShell that are relatively
    common. We’ll start with the `foreach` loop, before looking at `do while` and
    its counterpart, `do until`. We’ll then look at the more generalized `while` statement
    and finish with a look at the `for` statement and see how it differs from `foreach`.
    Let’s get started by creating a new file, setting it as a PowerShell file, and
    saving it as `loops.ps1`.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 自动化理论告诉我们，机器在执行重复任务时比人类更擅长；它们可以以完全相同的方式重复执行任务任意次。当我们编写代码时，我们称之为迭代或循环。接下来我们将查看
    PowerShell 中四种常见的循环示例。我们将从 `foreach` 循环开始，然后再看看 `do while` 及其对等的 `do until`。接着，我们会讨论更通用的
    `while` 语句，并最后讨论 `for` 语句，看看它与 `foreach` 的不同之处。让我们开始吧，首先创建一个新文件，将其设置为 PowerShell
    文件，并保存为 `loops.ps1`。
- en: The foreach loop statement
  id: totrans-138
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: foreach 循环语句
- en: 'This is the most common loop statement. We’ve seen `foreach` before, when we
    looked at the `Foreach-Object` cmdlet in [*Chapter 3*](B17600_03.xhtml#_idTextAnchor049),
    *The PowerShell Pipeline – How to String Cmdlets Together*. They’re similar in
    function, but not the same, and have very different syntax. `foreach` loops have
    the following syntax:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 这是最常见的循环语句。我们之前在 [*第 3 章*](B17600_03.xhtml#_idTextAnchor049)《PowerShell 管道——如何将
    cmdlet 连接在一起》中提到过 `foreach`，当时我们讨论了 `Foreach-Object` cmdlet。它们的功能相似，但并不完全相同，并且语法差异很大。`foreach`
    循环具有以下语法：
- en: '[PRE16]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'If `foreach` is at the start of a statement, then PowerShell will treat it
    as the `foreach` loop statement, not an alias for `ForEach-Object`. We can see
    this happening in the following screenshot:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 `foreach` 出现在语句的开头，PowerShell 会将其视为 `foreach` 循环语句，而不是 `ForEach-Object` 的别名。我们可以在以下截图中看到这种情况：
- en: '![Figure 5.13 – The foreach statement and foreach as an alias for ForEach-Object](img/B17600_05_13.jpg)'
  id: totrans-142
  prefs: []
  type: TYPE_IMG
  zh: '![图 5.13 – foreach 语句和 foreach 作为 ForEach-Object 的别名](img/B17600_05_13.jpg)'
- en: Figure 5.13 – The foreach statement and foreach as an alias for ForEach-Object
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.13 – foreach 语句和 foreach 作为 ForEach-Object 的别名
- en: In line 1, `foreach` is at the start of the line, or statement, and in line
    2 it comes after a pipeline character. `PSScriptAnalyzer`, part of the PowerShell
    extension for VS Code, has recognized `foreach` as an alias of `ForEach-Object`
    in line 2 and given it a wavy yellow underline to denote poor practice, but not
    in line 1\. If we hover the mouse over `foreach` in line 2, we can see that it
    is moaning because we have used an alias, and it’s right. What else is going on
    in that image?
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 在第1行，`foreach`出现在行首或语句前，而在第2行，它出现在管道符后面。`PSScriptAnalyzer`，作为VS Code中PowerShell扩展的一部分，已识别出第2行中的`foreach`是`ForEach-Object`的别名，并为它加上了波浪形的黄色下划线，表示这不是好的做法，但第1行则没有。如果我们将鼠标悬停在第2行的`foreach`上，可以看到它发出了警告，因为我们使用了别名，事实上这是正确的。那张图中还有什么信息呢？
- en: In line 1, we’ve got a `foreach` statement – it consists of the `foreach` keyword,
    a grouped expression in brackets, and a scriptblock in curly braces. The grouped
    expression takes the format `($element` `in [expression])` and produces a collection
    of objects. Once the collection is complete, the scriptblock operates on each
    object in turn. In this case, we are collecting all the objects in the current
    directory that end in `.ps1`. We then perform an operation on them – we get their
    length (`$f.length`) and add it to the `$l` variable using the compound operator,
    `+=`. It doesn’t matter what variable we use to denote the elements in the collection
    so long as it isn’t an automatic variable or a variable we are using elsewhere.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 在第1行，我们有一个`foreach`语句 —— 它由`foreach`关键字、一个括号中的分组表达式和一个大括号中的脚本块组成。分组表达式的格式是`($element
    in [expression])`，它生成一个对象集合。一旦集合完成，脚本块会依次作用于每个对象。在这个例子中，我们正在收集当前目录中所有以`.ps1`结尾的对象。然后我们对它们执行操作——获取它们的长度（`$f.length`）并通过复合运算符`+=`将其加到`$l`变量中。无论我们用什么变量来表示集合中的元素，只要它不是自动变量或我们在其他地方使用的变量，都没关系。
- en: In the second line, we are using the `ForEach-Object` cmdlet to do exactly the
    same thing. What’s the difference?
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 在第二行，我们使用`ForEach-Object` cmdlet来做完全相同的事情。有什么不同呢？
- en: When we use the `foreach` keyword to create a loop, the expression is run to
    produce an array, which is held in memory. Each element is then run into the scriptblock
    one at a time. If your expression creates a very large array then you may experience
    memory issues.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们使用`foreach`关键字创建一个循环时，表达式会被运行以生成一个数组，并将其保存在内存中。然后每个元素会一次性进入脚本块。如果你的表达式生成了一个非常大的数组，可能会出现内存问题。
- en: When we use the `ForEach-Object` cmdlet as part of a pipeline, each element
    in the array created by `Get-ChildItem *.ps1` passes through the entire pipeline
    one at a time; this means it uses a lot less memory, as the whole array doesn’t
    exist in memory, just single elements. The downside is it may well take longer
    to process.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们将`ForEach-Object` cmdlet作为管道的一部分使用时，由`Get-ChildItem *.ps1`生成的数组中的每个元素都会一次性通过整个管道；这意味着它使用的内存要少得多，因为整个数组并不存在于内存中，只有单个元素。缺点是它可能需要更长的时间来处理。
- en: 'Let’s try a `foreach` loop for ourselves. Type the following:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们自己尝试一个`foreach`循环。输入以下内容：
- en: '[PRE17]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: That’s not quite the same as the line in *Figure 5**.13*. We’re using a semicolon
    (`;`) as a statement separator; this allows us to put multiple statements on one
    line instead of splitting it over multiple lines. This is easier to type but not
    easier to read. Let’s go through the command;
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 这与*图 5.13*中的那行代码不完全相同。我们使用了分号（`;`）作为语句分隔符；这使我们能够将多个语句写在一行中，而不是将它们分开写成多行。这虽然输入更容易，但不太容易阅读。我们来逐一分析这个命令；
- en: Our first statement is `$l = 0 ;`. This creates the `$l` variable and sets it
    to `0`. This means each time we run the whole line, it will reset `$l` to `0`.
  id: totrans-152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们的第一个语句是`$l = 0 ;`。这创建了变量`$l`并将其设置为`0`。这意味着每次我们运行整行代码时，`$l`都会被重置为`0`。
- en: The second statement is `Foreach ($i in Get-ChildItem *.ps1) {$l += $i.length}
    ;`. This is where we create our array and loop through each element of it.
  id: totrans-153
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第二个语句是`Foreach ($i in Get-ChildItem *.ps1) {$l += $i.length} ;`。在这里我们创建了数组并遍历其中的每个元素。
- en: Our final statement is just `$l` – this returns the value of `$l` at the end
    of the loop.
  id: totrans-154
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们的最后一个语句只是`$l` —— 它返回`$l`在循环结束时的值。
- en: 'We can see how this looks in the following screenshot:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过以下截图看到它的样子：
- en: '![Figure 5.14 – The foreach loop and statement separator](img/B17600_05_14.jpg)'
  id: totrans-156
  prefs: []
  type: TYPE_IMG
  zh: '![图 5.14 – foreach 循环和语句分隔符](img/B17600_05_14.jpg)'
- en: Figure 5.14 – The foreach loop and statement separator
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.14 – foreach 循环和语句分隔符
- en: We’ll be using `foreach` loops quite a lot, as they are the most common type
    of loop. Let’s move on to the next types, `do while` and `do until`.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将经常使用`foreach`循环，因为它是最常见的循环类型。接下来我们来看看`do while`和`do until`循环。
- en: The do while and do until loop statements
  id: totrans-159
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: do while 和 do until 循环语句
- en: 'The `do while` and `do until` loops share the same syntax, which puts the scriptblock
    first:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: '`do while`和`do until`循环共享相同的语法，先写脚本块：'
- en: '[PRE18]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Because the condition is last, they will always execute the scriptblock at least
    once.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 因为条件放在最后，所以它们会至少执行一次脚本块。
- en: 'Try this. Type the following:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试一下，输入以下内容：
- en: '[PRE19]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Let’s take a closer look at what we’ve just done:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 我们来仔细看看刚刚做的事情：
- en: In the first line, we’re creating a `$number` variable and setting it to `0`.
  id: totrans-166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在第一行，我们创建了一个`$number`变量，并将其设置为`0`。
- en: In the second line, we are starting a `do while` loop with the `do` keyword,
    opening a scriptblock with a curly brace, `{`, and incrementing by 1 the `$number`
    variable using the `++` increment operator.
  id: totrans-167
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在第二行，我们使用`do`关键字开始一个`do while`循环，用大括号`{`打开一个脚本块，并使用`++`递增操作符将`$number`变量增加1。
- en: In the third line, we’re performing another operation, writing output to the
    screen.
  id: totrans-168
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在第三行，我们执行了另一个操作，将输出写到屏幕上。
- en: In the final line, we are closing the scriptblock with a curly brace, `}`, then
    using the `while` keyword to supply the condition, in brackets. In this case,
    it is while `$number` is not equal to `5`.
  id: totrans-169
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在最后一行，我们用大括号`}`关闭脚本块，然后使用`while`关键字来提供条件，条件放在括号中。在这种情况下，条件是`$number`不等于`5`。
- en: 'What is your last line of output? For me, it is `The number is 5`. This is
    because the scriptblock is run before the condition is evaluated. Try this:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 你的最后一行输出是什么？对我来说，是`The number is 5`。这是因为脚本块在条件评估之前就被运行。试试这个：
- en: '[PRE20]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: As we can see in the following screenshot, the scriptblock has been executed
    even though the condition is false.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在下面的截图中看到的，脚本块即使条件为假也已经执行。
- en: '![Figure 5.15 – The computer is lying to you](img/B17600_05_15.jpg)'
  id: totrans-173
  prefs: []
  type: TYPE_IMG
  zh: '![图 5.15 – 计算机在骗你](img/B17600_05_15.jpg)'
- en: Figure 5.15 – The computer is lying to you
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.15 – 计算机在骗你
- en: 'The `do until` loop works the same way, but until the condition is true:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: '`do until`循环的工作方式与此相同，只是直到条件成立时：'
- en: '[PRE21]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Let’s see how those loops look next to each other:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 我们来看看这两种循环放在一起的样子：
- en: '![Figure 5.16 – do while and do until](img/B17600_05_16.jpg)'
  id: totrans-178
  prefs: []
  type: TYPE_IMG
  zh: '![图 5.16 – do while 和 do until](img/B17600_05_16.jpg)'
- en: Figure 5.16 – do while and do until
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.16 – do while 和 do until
- en: Generally, we use `do until` loops when the test condition is expected to be
    positive and `do while` loops when the test condition is expected to be negative.
    It is not `while` or `until` that determines true or false, but the condition
    associated with it. You can just as easily have “not equals” (negative) with `until`
    and “equals” (positive) with `while`. Remember, though, that the scriptblock will
    execute the first time the condition is not met. What can we do about that?
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 一般来说，当测试条件预计为正时，我们使用`do until`循环，而当测试条件预计为负时，我们使用`do while`循环。并不是`while`或`until`决定真假，而是与之关联的条件决定。你可以轻松地在`until`中使用“不等于”（负）并在`while`中使用“等于”（正）。不过请记住，当条件不满足时，脚本块会执行第一次。那么我们该怎么处理呢？
- en: The while loop
  id: totrans-181
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: while 循环
- en: 'The `while` loop turns the `do while` loop back to front and puts the condition
    before the scriptblock:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: '`while`循环把`do while`循环反过来，并将条件放在脚本块之前：'
- en: '[PRE22]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: This means if the condition is not true, then the scriptblock never executes.
    There is no `until` statement.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着如果条件不成立，那么脚本块将永远不会执行。没有`until`语句。
- en: 'Try it. Type this:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试一下，输入如下内容：
- en: '[PRE23]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Activity 2
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 活动 2
- en: This produces the same output as our `do while` example. Why? How would you
    prove that the scriptblock doesn’t execute when the condition is true?
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 这与我们的`do while`示例产生了相同的输出。为什么？你怎么证明当条件成立时脚本块没有执行？
- en: Let’s look at our final loop next, the `for` loop.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来我们来看最后一种循环：`for`循环。
- en: The for loop
  id: totrans-190
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: for 循环
- en: 'Despite its name, the `for` loop is more like a `while` loop than a `foreach`
    loop. It’s a counting loop that depends on a condition being true, like `while`,
    but it is much more flexible. The syntax is more complicated as well:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管名为`for`循环，但它更像`while`循环而非`foreach`循环。它是一个计数循环，依赖于条件为真，就像`while`，但它更灵活。语法也更复杂：
- en: '[PRE24]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'The iterator is the variable we’re going to iterate, similar to the `$number`
    variable we used previously when we looked at the `while` loop. The condition
    is the same as the `while` loop condition, and the iteration is the action we
    perform on the iterator each time we go round the loop. Try this:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 迭代器是我们将要迭代的变量，类似于我们之前在研究`while`循环时使用的`$number`变量。条件与`while`循环的条件相同，迭代是在每次循环时对迭代器执行的操作。试试这个：
- en: '[PRE25]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'That’s not hugely exciting; it just looks like a complicated way to do exactly
    the same as the `while` loop previously. However, the `for` loop allows us to
    index the element of the loop and move around based on that index. Try this:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 这并不特别令人兴奋；它看起来只是以一种复杂的方式做了和之前的`while`循环一样的事情。然而，`for`循环让我们能够索引循环中的元素，并根据该索引进行移动。试试这个：
- en: '[PRE26]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'You should see the output shown in the following screenshot:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该看到以下截图中的输出：
- en: '![Figure 5.17 – Ordering fruit around with a for loop](img/B17600_05_17.jpg)'
  id: totrans-198
  prefs: []
  type: TYPE_IMG
  zh: '![图 5.17 – 使用for循环排列水果](img/B17600_05_17.jpg)'
- en: Figure 5.17 – Ordering fruit around with a for loop
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.17 – 使用for循环排列水果
- en: 'Here’s another thing we can do with a `for` loop that makes it special. We
    can change the contents of our array. Try this:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们可以使用`for`循环做的另一件特别的事情。我们可以改变数组的内容。试试这个：
- en: '[PRE27]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Well, that didn’t work. We might have hoped that by changing `$fruit` it would
    affect the original array, but it doesn’t, because the `foreach` loop operates
    on copies of the elements in the array. We can use the `for` loop to do it though:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 好吧，这并没有成功。我们可能希望通过改变`$fruit`来影响原始数组，但并没有实现，因为`foreach`循环操作的是数组元素的副本。不过，我们可以使用`for`循环来实现这一点：
- en: '[PRE28]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'And we should see the output as follows:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们应该看到如下的输出：
- en: '![Figure 5.18 – Using a for loop to make fruit tasty](img/B17600_05_18.jpg)'
  id: totrans-205
  prefs: []
  type: TYPE_IMG
  zh: '![图 5.18 – 使用for循环让水果变得美味](img/B17600_05_18.jpg)'
- en: Figure 5.18 – Using a for loop to make fruit tasty
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.18 – 使用for循环让水果变得美味
- en: We’re doing something new in line 50, there. We’re using `$()`, the sub-expression
    symbol, to make sure PowerShell correctly interprets what we mean. While we can
    expand simple variables inside double quotes, more complex expressions need a
    little more. Without wrapping `$fruits[$i]` in a pair of brackets preceded by
    a dollar sign, PowerShell won’t correctly unpack it.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 在第50行，我们做了一些新的事情。我们使用了`$()`，这是子表达式符号，确保PowerShell正确解释我们的意图。虽然我们可以在双引号中展开简单的变量，但更复杂的表达式需要更多的操作。如果不将`$fruits[$i]`用一对括号包裹并加上美元符号，PowerShell将无法正确解包它。
- en: We’re nearly done with loops. We’ve looked at the `foreach` loop, which performs
    an operation for each element in an array. We’ve looked at `do while` and `while`,
    which repeat an operation while a condition is true. Then we looked at `do until`,
    which performs an operation until a condition becomes true. Finally, we looked
    at the more complicated `for` loop, which repeats an operation a predetermined
    number of times. What we need next is a way of controlling our loops. What happens
    if the condition in a `while` loop never becomes false? Let’s look at loop control
    with `break` and `continue`.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 我们快完成对循环的介绍了。我们已经看过了`foreach`循环，它对数组中的每个元素执行操作。我们看过`do while`和`while`，它们在条件为真时重复执行操作。接着我们看了`do
    until`，它直到条件为真才执行操作。最后，我们看了更复杂的`for`循环，它会重复执行操作预定的次数。接下来我们需要的是控制循环的方式。如果`while`循环中的条件永远不变为假，会发生什么呢？让我们看看使用`break`和`continue`来控制循环。
- en: Breaking and continuing
  id: totrans-209
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 中断和继续
- en: The `break` and `continue` statements are related and allow us to control how
    our loops behave. We can also use them in `switch` statements. It’s important
    not to use them outside of loops or `switch` statements as they can lead to unpredictable
    behavior. A `break` statement can be used to stop a loop iterating altogether,
    while `continue` can be used to stop an iteration and move on to the next one.
    Let’s look at `break` first.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: '`break`和`continue`语句是相关的，它们允许我们控制循环的行为。我们也可以在`switch`语句中使用它们。重要的是不要在循环或`switch`语句之外使用它们，因为这样会导致不可预测的行为。`break`语句可以用来完全停止循环的迭代，而`continue`语句可以用来停止当前的迭代并跳到下一个迭代。我们先来看`break`语句。'
- en: The break statement
  id: totrans-211
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: break语句
- en: 'Let’s play with the trusty `while` loop. Type this:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来玩一下可靠的`while`循环。输入以下内容：
- en: '[PRE29]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Hopefully, you’ll see that the last number printed is `2`. The conditional `if`
    statement says to stop looping if `$number` is `3`. The `break` statement only
    acts on the loop it is nested inside.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 希望你会看到最后打印出的数字是`2`。条件语句`if`会在`$number`为`3`时停止循环。`break`语句只会作用于它嵌套的循环。
- en: The continue statement
  id: totrans-215
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: continue语句
- en: 'The `continue` statement stops the current iteration of the loop, not the whole
    loop, and moves on to the next iteration. Try this:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: '`continue`语句会停止当前循环的迭代，而不是整个循环，然后进入下一次迭代。试试这个：'
- en: '[PRE30]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'This time, the loop prints out the numbers `1` to `5`, but omits `3`. It breaks
    out of the current iteration before it reaches the `Write-Host` statement, and
    starts the next one. You should see the result in the following screenshot:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 这次，循环会输出数字`1`到`5`，但会省略`3`。它在到达`Write-Host`语句之前就会跳出当前迭代，并开始下一个迭代。你应该能在下图中看到结果：
- en: '![Figure 5.19 – Using continue](img/B17600_05_19.jpg)'
  id: totrans-219
  prefs: []
  type: TYPE_IMG
  zh: '![图5.19 – 使用continue](img/B17600_05_19.jpg)'
- en: Figure 5.19 – Using continue
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.19 – 使用continue
- en: 'We can also use `break` and `continue` in `switch` statements, like this:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以在`switch`语句中使用`break`和`continue`，就像这样：
- en: '[PRE31]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: This is similar to the `switch` block we used earlier in the chapter, in the
    *The switch statement* section. The difference is we are now passing an array
    of strings, not a single one. The `continue` statement in line 7 means that the
    `long string` and `No powershell here` outputs are never executed; instead, the
    `switch` statement moves on to the next element in the array, `python`. Now replace
    `continue` with `break`. We can see that the entire `switch` statement stops –
    `python` is never processed.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 这与我们在本章*开关语句*部分早些时候使用的`switch`块类似。不同之处在于，现在我们传递的是一个字符串数组，而不是单个字符串。第7行的`continue`语句意味着`long
    string`和`No powershell here`的输出永远不会被执行；相反，`switch`语句会继续处理数组中的下一个元素`python`。现在将`continue`替换为`break`。我们可以看到整个`switch`语句会停止——`python`永远不会被处理。
- en: That’s enough for now on loops. We’ll be using them a lot in the rest of the
    book. Let’s have some fun now, instead.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 目前关于循环的内容就讲到这里。我们将在本书的后续部分频繁使用它们。现在，我们来点轻松的内容吧。
- en: Let’s play a game
  id: totrans-225
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 让我们来玩个游戏
- en: We’re all familiar with number-guessing games. Let’s use what we’ve learned
    in this chapter to write a game in PowerShell. This is a common challenge set
    in many programming tutorials, so we’re not going to be any different. In the
    UK, it is sometimes called the Brucie Game because of its similarity to the popular
    UK TV gameshow Bruce Forsyth’s Play Your Cards Right. The Brucie bonus here is
    that we get to learn something.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 我们都很熟悉猜数字游戏。让我们运用本章所学来编写一个PowerShell游戏。这是许多编程教程中的常见挑战，我们也不例外。在英国，这个游戏有时被称为Brucie游戏，因为它与流行的英国电视游戏节目《Bruce
    Forsyth’s Play Your Cards Right》类似。这里的Brucie奖金就是我们可以学到一些东西。
- en: 'The program generates a random integer between 1 and 100\. We then need to
    get user input in the form of another integer. We compare the guess with the hidden
    number and decide whether it’s right. If it is, we go to the end of the program.
    If it isn’t, then we need to decide whether it is too high or too low and output
    an appropriate message before going back and asking for another guess. We can
    represent this as a flow chart, which will be helpful when it comes to writing
    our code:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 程序会生成一个1到100之间的随机整数。接着我们需要获取用户输入的另一个整数。我们将猜测值与隐藏的数字进行比较，并判断是否正确。如果正确，我们将结束程序。如果不正确，我们需要判断它是太高还是太低，并输出相应的消息，然后返回继续让用户猜测。我们可以将其表示为一个流程图，这在编写代码时会很有帮助：
- en: '![Figure 5.20 – Flow chart for the Brucie game](img/B17600_05_20.jpg)'
  id: totrans-228
  prefs: []
  type: TYPE_IMG
  zh: '![图5.20 – Brucie游戏的流程图](img/B17600_05_20.jpg)'
- en: Figure 5.20 – Flow chart for the Brucie game
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.20 – Brucie游戏的流程图
- en: The first thing we need to do is open a new file; mine is called `Brucie.ps1`.
    Let’s go to work.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要做的第一件事是打开一个新文件；我的文件名为`Brucie.ps1`。让我们开始工作吧。
- en: 'The first box calls for a random integer between 1 and 100\. That’s easy:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个框要求生成一个1到100之间的随机整数。这很简单：
- en: '[PRE32]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Now we need to tell the player what to do, and get an input from them:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们需要告诉玩家该做什么，并获取他们的输入：
- en: '[PRE33]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Now we have our two numbers in variables called `$Hidden` and `$guess`. We
    need to compare them. The best way to do this is to use an `if`-`else` statement.
    If the number is wrong, we do one thing, else we print `You Win!`:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了两个变量`$Hidden`和`$guess`，存储了我们的两个数字。我们需要比较它们。最好的方法是使用`if`-`else`语句。如果数字不对，我们做一件事，否则打印`You
    Win!`：
- en: '[PRE34]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'What action do we need to perform? We need to see whether it is higher or lower.
    We’ll need another `if`-`else` there:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要执行什么操作？我们需要查看数字是更大还是更小。我们需要再加一个`if`-`else`语句：
- en: '[PRE35]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: And that is that. Wait, no it isn’t. We need to give them multiple guesses.
    We need a loop. We could use all sorts of loops here, but probably the easiest
    is a `while` loop. Have a think about how you might do it before moving on and
    seeing how I did it.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 就是这样，等一下，不对。我们需要给他们多个猜测机会。我们需要一个循环。我们可以在这里使用各种类型的循环，但可能最简单的是`while`循环。在继续往下看我怎么做之前，先思考一下你可能怎么做。
- en: Don’t peek. Think.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 不要偷看，思考一下。
- en: 'OK. Here’s my solution:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，这是我的解决方案：
- en: '[PRE36]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Here’s the whole thing working:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 这是完整的实现：
- en: '![Figure 5.21 – The Brucie game](img/B17600_05_21.jpg)'
  id: totrans-244
  prefs: []
  type: TYPE_IMG
  zh: '![图 5.21 – 布鲁西游戏](img/B17600_05_21.jpg)'
- en: Figure 5.21 – The Brucie game
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.21 – 布鲁西游戏
- en: On line 4, I’ve initialized `$guess` as `0` so that the loop has something to
    work with.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 在第4行，我将`$guess`初始化为`0`，这样循环就有了可以操作的对象。
- en: On line 5, I’ve changed my first `if` statement to a `while` statement. I’ve
    also closed the loop with a curly brace and made `Write-Host "You Win"` the final
    statement of the program.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 在第5行，我把第一个`if`语句改成了`while`语句。我还用大括号结束了循环，并且将`Write-Host "You Win"`作为程序的最后一条语句。
- en: On line 6, I’ve brought my input-gathering statement inside the loop. Try leaving
    it outside. That gets old quickly because we’re never changing the value of `$guess`
    from 0.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 在第6行，我将获取输入的语句放进了循环中。你可以试着把它放在外面。那样很快就会显得乏味，因为我们永远不会改变`$guess`的值，从0开始。
- en: The only other change I made was on line 9, where I replaced `else` with an
    `elseif` statement, otherwise the loop prints `Lower!` even when we’re right.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 我做的唯一其他更改是在第9行，我用`elseif`语句替代了`else`，否则即便我们猜对了，循环也会输出`Lower!`。
- en: And that’s it. Make sure you save a working copy of the game so we can work
    with it later. We’ve covered a lot of ground in this chapter; let’s summarize.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 就这些。确保你保存一份游戏的工作副本，以便我们以后继续使用。我们在本章中覆盖了很多内容，让我们来总结一下。
- en: Summary
  id: totrans-251
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: We started the chapter by looking at IDEs and installing the recommended environment
    for PowerShell 7, VS Code. VS Code is a large and ever-changing application. We
    need to spend time familiarizing ourselves with it and keep regularly updated
    as the features and capabilities change frequently. We have seen that it is easy
    to use and very powerful.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从本章开始时先了解了 IDEs，并安装了 PowerShell 7 推荐的环境：VS Code。VS Code 是一个庞大且不断变化的应用程序。我们需要花时间熟悉它，并且随着功能和能力的频繁变化，保持更新。我们已经看到它非常易于使用且功能强大。
- en: 'We then looked at the two main ways of controlling flow within a program: conditionals
    and loops. We spent a lot of time on the `if`, `else`, and `elseif` conditional
    statements and then looked at the related `switch` statement.'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们看了控制程序流程的两种主要方式：条件语句和循环语句。我们花了很多时间在`if`、`else`和`elseif`条件语句上，接着又看了相关的`switch`语句。
- en: After that, we looked at loops. We started with a loop that will iterate through
    all the elements in an array – the `foreach` loop – and explored how it differs
    from the `ForEach-Object` cmdlet. We looked at `do while` and `do until`, which
    will repeat a loop while a condition is true or false, and then we looked at the
    `while` loop, which swaps the position of the condition and the scriptblock. The
    last loop we looked at in this section was a counting loop – `for`.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们看了循环。我们从一个遍历数组所有元素的循环——`foreach` 循环开始，探讨了它与 `ForEach-Object` cmdlet 的区别。我们还了解了
    `do while` 和 `do until` 循环，它们会在条件为真或为假时重复执行循环，接着我们看了 `while` 循环，它将条件和脚本块的位置互换。在本节中我们最后探讨了一个计数循环——`for`。
- en: Finally, we finished this chapter by writing a short number-guessing game in
    PowerShell, the Brucie game. I hope you enjoyed doing this, as this sort of exercise
    will really cement how to write code in PowerShell.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们通过编写一个简单的数字猜谜游戏——布鲁西游戏，来结束这一章。我希望你在做这个练习时有所收获，因为这种练习会让你更加扎实地掌握如何编写 PowerShell
    代码。
- en: In the next chapter, we’re going to be looking at how PowerShell can be used
    to interact with files. We’re going to be reading content, writing content, and
    generally playing around.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将会看看如何使用 PowerShell 与文件进行交互。我们将要读取内容、写入内容，并进行一些操作。
- en: Exercises
  id: totrans-257
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 练习
- en: What output will `$x = 4 ; IF ($x -gt 4) {Write-Host '$x is larger than` `4'}`
    produce?
  id: totrans-258
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`$x = 4 ; IF ($x -gt 4) {Write-Host ''$x is larger than` `4''}` 这段代码会产生什么输出？'
- en: Write a statement that will produce an output for the line `$x = 4 ; IF ($x
    -gt 4) {Write-Host '$x is larger than 4'}` when `$x` is not larger than 4.
  id: totrans-259
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 写一个语句，当`$x`不大于4时，产生输出`$x = 4 ; IF ($x -gt 4) {Write-Host '$x is larger than
    4'}`。
- en: Write a statement that will produce output from `$x = 4 ; IF ($x -gt 4) {Write-Host
    '$x is larger than 4'}` when `$x` is exactly 4.
  id: totrans-260
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 写一个语句，当`$x = 4 ; IF ($x -gt 4) {Write-Host '$x is larger than 4'}`时，`$x`正好等于4时，产生输出。
- en: Write a statement that will produce an output for the line `$x = 4 ; IF ($x
    -gt 4) {Write-Host '$x is larger than 4'}` when `$x` is not larger than 4, as
    in question 2, but this time use the `ternary` operator.
  id: totrans-261
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 写一个语句，当`$x = 4 ; IF ($x -gt 4) {Write-Host '$x is larger than 4'}`时，如果`$x`不大于4（如问题2所示），但是这次使用`ternary`运算符时产生输出。
- en: What is going wrong here?
  id: totrans-262
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这里出了什么问题？
- en: '[PRE37]'
  id: totrans-263
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Rewrite `$number = 0 ; Do {$number ++ ; Write-Host "Number is $number"} While
    ($number -eq 5)` so that it works, but without using a d`o` `until` loop.
  id: totrans-264
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 重写`$number = 0 ; Do {$number ++ ; Write-Host "Number is $number"} While ($number
    -eq 5)`使其正常工作，但不使用`do` `until`循环。
- en: 'Make this statement work: `For ($i = 0 ; $i -lt 5 ) {``Write-Host $i}`.'
  id: totrans-265
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使这个语句工作：`For ($i = 0 ; $i -lt 5 ) {``Write-Host $i}`。
- en: We should only use `break` and `continue` statements in loops and one other
    place. Where?
  id: totrans-266
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们应该仅在循环和另一个地方使用`break`和`continue`语句。那是什么地方？
- en: How would you make it so the Brucie game limits the number of guesses a user
    could make?
  id: totrans-267
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你会怎么做才能让Brucie游戏限制用户的猜测次数？
- en: Further reading
  id: totrans-268
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: 'This was a big chapter, so there is plenty of further reading here:'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个大章节，因此这里有很多进一步阅读的内容：
- en: 'Developing PowerShell with VS Code: [https://docs.microsoft.com/en-us/powershell/scripting/dev-cross-plat/vscode/using-vscode](https://docs.microsoft.com/en-us/powershell/scripting/dev-cross-plat/vscode/using-vscode)'
  id: totrans-270
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用VS Code开发PowerShell：[https://docs.microsoft.com/en-us/powershell/scripting/dev-cross-plat/vscode/using-vscode](https://docs.microsoft.com/en-us/powershell/scripting/dev-cross-plat/vscode/using-vscode)
- en: 'About `if`: [https://docs.microsoft.com/en-us/powershell/module/microsoft.powershell.core/about/about_if](https://docs.microsoft.com/en-us/powershell/module/microsoft.powershell.core/about/about_if)'
  id: totrans-271
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 关于`if`：[https://docs.microsoft.com/en-us/powershell/module/microsoft.powershell.core/about/about_if](https://docs.microsoft.com/en-us/powershell/module/microsoft.powershell.core/about/about_if)
- en: 'About `switch`: [https://docs.microsoft.com/en-us/powershell/module/microsoft.powershell.core/about/about_switch](https://docs.microsoft.com/en-us/powershell/module/microsoft.powershell.core/about/about_switch)'
  id: totrans-272
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 关于`switch`：[https://docs.microsoft.com/en-us/powershell/module/microsoft.powershell.core/about/about_switch](https://docs.microsoft.com/en-us/powershell/module/microsoft.powershell.core/about/about_switch)
- en: 'About `foreach`: [https://docs.microsoft.com/en-us/powershell/module/microsoft.powershell.core/about/about_foreach](https://docs.microsoft.com/en-us/powershell/module/microsoft.powershell.core/about/about_foreach)'
  id: totrans-273
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 关于`foreach`：[https://docs.microsoft.com/en-us/powershell/module/microsoft.powershell.core/about/about_foreach](https://docs.microsoft.com/en-us/powershell/module/microsoft.powershell.core/about/about_foreach)
- en: 'About `do`: [https://docs.microsoft.com/en-us/powershell/module/microsoft.powershell.core/about/about_do](https://docs.microsoft.com/en-us/powershell/module/microsoft.powershell.core/about/about_do)'
  id: totrans-274
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 关于`do`：[https://docs.microsoft.com/en-us/powershell/module/microsoft.powershell.core/about/about_do](https://docs.microsoft.com/en-us/powershell/module/microsoft.powershell.core/about/about_do)
- en: 'About `while`: [https://docs.microsoft.com/en-us/powershell/module/microsoft.powershell.core/about/about_while](https://docs.microsoft.com/en-us/powershell/module/microsoft.powershell.core/about/about_while)'
  id: totrans-275
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 关于`while`：[https://docs.microsoft.com/en-us/powershell/module/microsoft.powershell.core/about/about_while](https://docs.microsoft.com/en-us/powershell/module/microsoft.powershell.core/about/about_while)
- en: 'About `for`: [https://docs.microsoft.com/en-us/powershell/module/microsoft.powershell.core/about/about_for](https://docs.microsoft.com/en-us/powershell/module/microsoft.powershell.core/about/about_for)'
  id: totrans-276
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 关于`for`：[https://docs.microsoft.com/en-us/powershell/module/microsoft.powershell.core/about/about_for](https://docs.microsoft.com/en-us/powershell/module/microsoft.powershell.core/about/about_for)
- en: 'About `break`: [https://docs.microsoft.com/en-us/powershell/module/microsoft.powershell.core/about/about_break](https://docs.microsoft.com/en-us/powershell/module/microsoft.powershell.core/about/about_break)'
  id: totrans-277
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 关于`break`：[https://docs.microsoft.com/en-us/powershell/module/microsoft.powershell.core/about/about_break](https://docs.microsoft.com/en-us/powershell/module/microsoft.powershell.core/about/about_break)
- en: 'About `continue`: [https://docs.microsoft.com/en-us/powershell/module/microsoft.powershell.core/about/about_continue](https://docs.microsoft.com/en-us/powershell/module/microsoft.powershell.core/about/about_continue)'
  id: totrans-278
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 关于`continue`：[https://docs.microsoft.com/en-us/powershell/module/microsoft.powershell.core/about/about_continue](https://docs.microsoft.com/en-us/powershell/module/microsoft.powershell.core/about/about_continue)
