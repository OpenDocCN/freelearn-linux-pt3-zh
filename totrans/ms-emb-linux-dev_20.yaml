- en: '16'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '16'
- en: Deploying Container Images
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 部署容器镜像
- en: In this chapter, I will introduce the principles of the DevOps movement and
    demonstrate how to apply them to embedded Linux. First, we will learn how to use
    Docker to bundle a Python application together with its user-space environment
    inside a container image. Next, we will set up a Docker-based **continuous integration
    and continuous delivery** (**CI/CD**) pipeline for a Python Bluetooth server application.
    Then I will demonstrate how to quickly add Docker to a Yocto image for the Raspberry
    Pi 4\. Lastly, we will deploy a containerized software update to a Raspberry Pi
    4 running Docker.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我将介绍DevOps运动的基本原则，并展示如何将它们应用到嵌入式Linux中。首先，我们将学习如何使用Docker将Python应用和其用户空间环境打包成一个容器镜像。接下来，我们将为Python蓝牙服务器应用设置一个基于Docker的**持续集成和持续交付**（**CI/CD**）管道。然后，我将演示如何将Docker快速添加到Raspberry
    Pi 4的Yocto镜像中。最后，我们将部署一个容器化的软件更新到运行Docker的Raspberry Pi 4上。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: What is DevOps?
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 什么是DevOps？
- en: DevOps and embedded Linux
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: DevOps与嵌入式Linux
- en: Deploying Python applications with Docker
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Docker部署Python应用
- en: Setting up a CI/CD pipeline for a Python application
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为Python应用设置CI/CD管道
- en: Adding Docker to a Yocto image
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将Docker添加到Yocto镜像中
- en: Updating software with Docker
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Docker更新软件
- en: Technical requirements
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'To follow along with the examples, make sure you have the following:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 为了跟随示例，请确保你拥有以下内容：
- en: An Ubuntu 24.04 or later LTS host system with at least 90 GB of free disk space
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一台至少有90GB可用磁盘空间的Ubuntu 24.04或更高版本的LTS主机系统
- en: A user account with admin or sudo privileges on the host system
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在主机系统上具有管理员或sudo权限的用户帐户
- en: Yocto 5.0 (Scarthgap) LTS release
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Yocto 5.0（Scarthgap）LTS版本
- en: A microSD card reader and card
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一台microSD卡读卡器和卡
- en: '`balenaEtcher` for Linux'
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`balenaEtcher` for Linux'
- en: An Ethernet cable and router with an available port for network connectivity
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一根以太网电缆和带有可用端口的路由器以提供网络连接
- en: A Raspberry Pi 4
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一台Raspberry Pi 4
- en: A 5 V USB-C power supply capable of delivering 3 A
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一台能够提供3A电流的5V USB-C电源
- en: You should have already built the 5.0 (Scarthgap) LTS release of Yocto in [*Chapter
    6*](Chapter_04.xhtml#_idTextAnchor110). If you have not, then please refer to
    the *Compatible Linux Distribution* and *Build Host Packages* sections of the
    *Yocto Project Quick Build* guide ([https://docs.yoctoproject.org/brief-yoctoprojectqs/](https://docs.yoctoproject.org/brief-yoctoprojectqs/))
    before building Yocto on your Linux host according to the instructions in [*Chapter
    6*](Chapter_04.xhtml#_idTextAnchor110).
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该已经在[*第6章*](Chapter_04.xhtml#_idTextAnchor110)构建了5.0（Scarthgap）LTS版本的Yocto。如果没有，请参考*兼容的Linux发行版*和*构建主机软件包*部分，按照[*Yocto项目快速构建*](https://docs.yoctoproject.org/brief-yoctoprojectqs/)指南中的说明在Linux主机上构建Yocto。
- en: 'The code used in this chapter can be found in the chapter folder in this book’s
    GitHub repository: [https://github.com/PacktPublishing/Mastering-Embedded-Linux-Development/tree/main/Chapter16](https://github.com/PacktPublishing/Mastering-Embedded-Linux-Development/tree/main/Chapter16).'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中使用的代码可以在本书的GitHub仓库的章节文件夹中找到：[https://github.com/PacktPublishing/Mastering-Embedded-Linux-Development/tree/main/Chapter16](https://github.com/PacktPublishing/Mastering-Embedded-Linux-Development/tree/main/Chapter16)。
- en: Getting Docker
  id: totrans-22
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 获取Docker
- en: 'To install Docker on Ubuntu 24.04 LTS:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 在Ubuntu 24.04 LTS上安装Docker：
- en: 'Update the package repositories:'
  id: totrans-24
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更新软件包仓库：
- en: '[PRE0]'
  id: totrans-25
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Install Docker:'
  id: totrans-26
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 安装Docker：
- en: '[PRE1]'
  id: totrans-27
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Start the Docker daemon and enable it to start at boot time:'
  id: totrans-28
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 启动Docker守护进程并启用其在启动时自动启动：
- en: '[PRE2]'
  id: totrans-29
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Add yourself to the `docker` group:'
  id: totrans-30
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将自己添加到`docker`组：
- en: '[PRE3]'
  id: totrans-31
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Restart the Docker daemon:'
  id: totrans-32
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 重启Docker守护进程：
- en: '[PRE4]'
  id: totrans-33
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Replace `<username>` in *step 4* with your username. I recommend creating your
    own Ubuntu user account rather than using the default `ubuntu` user account, which
    is supposed to be reserved for administrative tasks.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 在*步骤4*中将`<username>`替换为你的用户名。我建议创建你自己的Ubuntu用户帐户，而不是使用默认的`ubuntu`用户帐户，因为该帐户应该保留用于管理任务。
- en: What is DevOps?
  id: totrans-35
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 什么是DevOps？
- en: Since its inception in 2009, the **DevOps movement** has taken the software
    industry by storm. Patrick Debois coined the term **DevOps** after seeing the
    2009 Velocity Conference presentation *10 Deploys per Day*. Patrick is one of
    the four co-authors of *The DevOps Handbook* along with Gene Kim, Jez Humble,
    and John Willis. The *DevOps Handbook* was first published in 2016 and codifies
    the principles of the movement. These ideas originate from the Lean manufacturing
    and Agile software development communities. DevOps practices are closely aligned
    with Agile methodologies like Scrum and Kanban. The goal of all these approaches
    is always to ship quality products to customers faster.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 自2009年起，**DevOps运动**已席卷软件行业。Patrick Debois在观看2009年Velocity大会的演讲《*每天部署10次*》后，创造了**DevOps**这一术语。Patrick是《*DevOps手册*》的四位共同作者之一，其他三位作者是Gene
    Kim、Jez Humble和John Willis。《*DevOps手册*》首次出版于2016年，系统地阐述了这一运动的原则。这些理念源自精益生产和敏捷软件开发社区。DevOps实践与敏捷方法论如Scrum和Kanban紧密相关。这些方法的目标始终是更快速地将高质量的产品交付给客户。
- en: DevOps strives to integrate the development and operations teams within an organization.
    Historically, the people who operate software at a company are separate from the
    people who develop that same software. Sometimes there is a dedicated team of
    system administrators (IT) responsible for provisioning servers and deploying
    scheduled software releases. This separation of concerns combined with big bang
    deployments inevitably leads to lengthy delays and outages. The relationship between
    development and operations becomes adversarial as finger-pointing ensues amid
    failures. By contrast, DevOps encourages close collaboration, rapid iteration,
    and experimentation. Mistakes are how we learn.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: DevOps力图将组织内的开发和运维团队融合在一起。在历史上，公司中负责操作软件的人与开发这些软件的人是分开的。有时会有一支专门的系统管理员（IT）团队，负责配置服务器和部署计划中的软件发布。这样的职责分离，再加上“大爆炸式”部署，往往会导致长时间的延迟和故障。开发与运维之间的关系会变得对立，失败时大家相互指责。相反，DevOps鼓励密切合作、快速迭代和实验。错误是我们学习的方式。
- en: Continuous integration and continuous deployment
  id: totrans-38
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 持续集成和持续部署
- en: Two core concepts of Lean manufacturing are the notions of a **value stream**
    and the **lead time** associated with that. The Lean philosophy comes from the
    automotive industry, specifically the Toyota Production System. If a value stream
    is a factory assembly line, then the lead time is the time from when a customer
    request is submitted to when it is fulfilled. Lead time is one of the metrics
    by which the performance of a value stream is measured. Reducing lead time enables
    factories to build cars faster. The same idea applies to software.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 精益生产的两个核心概念是**价值流**和与之相关的**交付时间**。精益哲学源自汽车工业，尤其是丰田生产系统。如果把价值流看作工厂的生产线，那么交付时间就是从客户提出需求到需求得到满足的时间。交付时间是衡量价值流表现的指标之一。减少交付时间使工厂能够更快地生产汽车。这个理念同样适用于软件。
- en: In software, we can think of lead time as the time from when a feature request
    is submitted to when that finished feature is deployed to production. Every time
    a developer commits and pushes a change to the software an automated build is
    kicked off. A suite of unit tests is run against this newly changed code as part
    of the automated build. A code change can only be merged to the main branch if
    the build succeeds and the test suite passes. All these checks are scripted and
    performed automatically. The longer it takes to build the software and execute
    the tests, the longer the lead time is.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 在软件中，我们可以将交付时间看作从提交功能请求到该功能部署到生产环境的时间。每次开发人员提交并推送代码更改时，自动化构建过程会被触发。自动化构建会对新更改的代码运行一组单元测试。只有当构建成功并且测试套件通过时，代码更改才能合并到主分支。这些检查都是通过脚本自动执行的。构建软件和执行测试所需的时间越长，交付时间也就越长。
- en: Integrating code is only part of the value stream. To deliver value to customers,
    software must be deployed to production. That typically means tagging a release,
    spinning up servers in the cloud, and installing the new release onto those servers.
    There are several techniques to ensure deployments go smoothly. Run integration
    tests first. Roll releases out incrementally across your fleet of servers. Roll
    back to a prior release in the event of a bad software update. Maximum developer
    productivity can only be achieved when software is deployed to production multiple
    times a day. The value stream is the **CI/CD** pipeline.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 集成代码只是价值流的一部分。要向客户交付价值，软件必须部署到生产环境中。这通常意味着标记一个版本、在云端启动服务器，并将新版本安装到这些服务器上。为了确保部署顺利进行，可以采用几种技术。首先运行集成测试。在整个服务器集群上逐步推出版本。如果软件更新出现问题，可以回滚到先前的版本。只有当软件每天多次部署到生产环境中时，才能最大化开发人员的生产力。价值流即是**CI/CD**流水线。
- en: Infrastructure as code
  id: totrans-42
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 基础设施即代码
- en: We need more than source code to build and deploy most software. Today, most
    modern software development involves Docker. An application typically requires
    a Dockerfile, makefile, and shell scripts to build and bundle the software for
    release. These items are invoked by a YAML file at different stages of the CI/CD
    pipeline. Since they aren’t part of the actual software, we may not think of these
    items as code per se. Still, they reside inside version control along with the
    source code and likewise need to be reviewed and maintained. Because the building
    and bundling of the software is entirely scripted, the task is easily repeatable.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要的不仅仅是源代码来构建和部署大多数软件。如今，现代软件开发大多涉及 Docker。一个应用程序通常需要一个 Dockerfile、makefile
    和 shell 脚本来构建和打包软件以供发布。在 CI/CD 流水线的不同阶段，这些项会由一个 YAML 文件来调用。由于它们并不是实际软件的一部分，我们可能不会将这些项视为代码。然而，它们与源代码一起存储在版本控制中，同样需要进行审查和维护。由于软件的构建和打包完全由脚本控制，因此这一任务是可以轻松重复的。
- en: The amount of YAML involved increases during deployment. Cloud-native tools
    like Terraform and CloudFormation are YAML-based. We provision cloud infrastructure
    and deploy software release artifacts onto it with these tools by applying declarative
    YAML files. Deployment is driven by the same top-level YAML file used for building
    and bundling. That way, the whole process is automated from end to end. While
    they may not look like it, YAML files are indeed code and should adhere to the
    same standards of quality as code written in high-level programming languages
    like Python.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 在部署过程中，涉及的 YAML 文件量会增加。像 Terraform 和 CloudFormation 这样的云原生工具是基于 YAML 的。我们通过应用声明式的
    YAML 文件，使用这些工具来配置云基础设施并将软件版本发布工件部署到其中。部署由与构建和打包相同的顶级 YAML 文件驱动。这样，整个过程可以实现端到端自动化。尽管它们看起来不像代码，但
    YAML 文件实际上是代码，应该遵循与高层编程语言（如 Python）编写的代码相同的质量标准。
- en: Security is a shared responsibility
  id: totrans-45
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 安全是共同责任
- en: When time to market is everything, security takes a back seat. Like deployments,
    security is often relegated to operations. High-profile incidents like the Log4j
    vulnerability of 2022 and the `xz` backdoor of 2024 demonstrate how critical security
    is to day-to-day business. DevOps argues that security is a concern at every stage
    of development, not an afterthought. Intellectual property and customer data are
    always encrypted. Secrets like keys and passphrases are stored safely outside
    of version control. Security best practices are everyone’s responsibility and
    need to be enforced from the outset.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 当市场时间至关重要时，安全常常被放在次要位置。与部署类似，安全往往被委托给运维部门。像 2022 年的 Log4j 漏洞和 2024 年的 `xz` 后门等高调事件，展示了安全对日常业务至关重要。DevOps
    认为，安全问题在开发的每个阶段都应该考虑，而不是事后才想到。知识产权和客户数据始终是加密的。像密钥和密码等机密信息会安全地存储在版本控制之外。安全最佳实践是每个人的责任，必须从一开始就加以执行。
- en: Monitoring and observability
  id: totrans-47
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 监控与可观察性
- en: Gathering telemetry in the form of system stats, logs, and traces provides us
    with visibility into the health and performance of our applications. Once we have
    telemetry, it can be displayed on a Grafana dashboard for analysis. That way,
    we can detect performance regressions, resource leaks, and other systemic problems
    before they result in a costly service outage. Real-time insights trigger rapid
    incident responses and resolutions. More importantly, telemetry gives us quick
    unfiltered feedback on how we are doing as developers so that we can learn and
    improve.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 通过系统统计、日志和追踪收集遥测数据，让我们能够了解应用程序的健康状况和性能。一旦获取了遥测数据，可以将其显示在Grafana仪表盘上进行分析。这样，我们可以在问题导致昂贵的服务中断之前，及时发现性能回退、资源泄漏等系统性问题。实时洞察能够触发快速响应和解决问题。更重要的是，遥测数据为我们提供了关于我们作为开发者表现的即时反馈，让我们能够学习和改进。
- en: Continuous improvement
  id: totrans-49
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 持续改进
- en: Lean manufacturing espouses short lead times, small changes, and rapid iteration.
    *The Lean Startup* by Eric Ries popularized the notion of a **minimum viable product**
    (**MVP**). An MVP is a version of a product with just enough functionality that
    initial customers can offer feedback on said product. This feedback is reviewed,
    and improvements are made to the next version in rapid succession. A software
    CI/CD pipeline cranks out MVPs faster than a factory assembly line.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 精益制造提倡短周期、小变动和快速迭代。埃里克·里斯的《*精益创业*》推广了**最小可行产品**（**MVP**）的概念。MVP是具有足够功能的产品版本，初步用户可以就该产品提供反馈。这些反馈会被审查，并迅速做出改进以推出下一个版本。软件的CI/CD流水线能比工厂生产线更快地推出MVP。
- en: Continuous feedback incentivizes developers to ship small incremental improvements
    with greater frequency. An MVP approach enables teams to see what works and what
    doesn’t before committing more time and resources. This way, adjustments can be
    made so that more value is delivered to users. DevOps argues that integrating
    small changes sooner results in better outcomes. This is in stark contrast to
    having a lone developer toil away on a long-lived feature branch without any feedback
    from users.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 持续反馈激励开发者更频繁地发布小规模的增量改进。MVP方法让团队能够在投入更多时间和资源之前，看到哪些有效，哪些无效。通过这种方式，可以进行调整，确保为用户提供更多的价值。DevOps认为，尽早整合小的改动会带来更好的结果。这与让单一开发者在没有用户反馈的情况下，孤军奋战于长期存在的功能分支是完全不同的做法。
- en: Transparency
  id: totrans-52
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 透明度
- en: Collaboration is unlikely if an organization’s culture discourages it. Fear
    pervades dysfunctional organizations. Individuals act strategically by hiding
    information away from others who could benefit from it. This behavior leads to
    silos where all communication happens in private meetings and chats on a need-to-know
    basis. Mistakes are hidden for fear of punishment (e.g., leadership “shoots the
    messenger”). The DevOps mindset is one of openness. Successes, failures, and ideas
    are shared across the organization to promote best practices. If you are struggling
    with a task, then you ask your team for help.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一个组织的文化不鼓励合作，那么合作就不太可能发生。恐惧充斥着功能失调的组织。个人通过隐藏信息来采取战略性行动，防止别人受益。这种行为导致了信息孤岛，所有的沟通只能在私人会议和需要知道的情况下进行。错误被隐藏，因为害怕惩罚（例如，领导“杀信使”）。DevOps心态是开放的。成功、失败和创意会在组织内分享，以促进最佳实践。如果你在某个任务上遇到困难，你应该向团队求助。
- en: DevOps and Embedded Linux
  id: totrans-54
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: DevOps 和嵌入式 Linux
- en: Hardware is hard. PCB layout, contract manufacturing, and board revisions cost
    time and money. The risks are bigger than with software. Lead times are longer,
    and mistakes can be catastrophic. Embedded Linux forms the bridge between hardware
    and software.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 硬件很难。PCB 布局、合同制造和板卡修订需要消耗大量时间和金钱。与软件相比，硬件的风险更大。交货周期更长，错误可能会带来灾难性后果。嵌入式 Linux
    作为硬件和软件之间的桥梁。
- en: Embedded Linux engineers work closely with electrical engineers during board
    bring-up, troubleshooting issues as they arise. It’s not uncommon to ask an electrical
    engineer to rewire a component or add a pull-up resistor. PCB layout is extremely
    complex. Nobody is perfect, so a new board rarely ever boots the first time around.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 嵌入式 Linux 工程师与电气工程师紧密合作，处理板子启动过程中出现的问题。要求电气工程师重新布线或添加上拉电阻并不罕见。PCB 布局非常复杂。没有人是完美的，因此新板子在第一次启动时几乎不会成功。
- en: With such high stakes, it might seem like DevOps principles are a bad fit for
    hardware products. Industry trends like **test-driven development** (**TDD**)
    are often dismissed as impractical by experienced embedded developers. Automated
    testing is harder when dealing with real hardware but not impossible. Investing
    time and energy in establishing a CI/CD pipeline pays dividends once features
    begin landing in rapid succession. Management may question why you are doing so
    much process work up front, but their tune will change when new products begin
    to be delivered ahead of schedule.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 鉴于如此高的风险，DevOps原则似乎并不适用于硬件产品。像**测试驱动开发**（**TDD**）这样的行业趋势，经常被经验丰富的嵌入式开发人员认为不切实际。在处理真实硬件时，自动化测试更加困难，但并非不可能。一旦功能开始快速交付，投入时间和精力建立CI/CD管道将带来丰厚的回报。管理层可能会质疑你为何在前期做这么多流程工作，但当新产品提前交付时，他们的态度会发生变化。
- en: Continuous integration and cross-compilation
  id: totrans-58
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 持续集成与交叉编译
- en: Linux and much of the middleware on top of it is written mostly in C. This means
    it must be compiled natively for the target’s **instruction set architecture**
    (**ISA**). In the cloud, that ISA is usually x86-64 running on Intel or AMD CPUs.
    On embedded devices capable of running Linux, it is increasingly 64-bit Arm. Since
    most cloud infrastructure runs on Intel and AMD CPUs, building software for embedded
    Linux requires a cross-compiling toolchain. However, cross-compilation is not
    a common use case for cloud-based CI/CD services like GitHub Actions or GitLab
    CI.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: Linux及其上层的大多数中间件是主要用C语言编写的，这意味着它必须针对目标的**指令集架构**（**ISA**）进行本地编译。在云端，这个ISA通常是运行在Intel或AMD
    CPU上的x86-64架构。而在能够运行Linux的嵌入式设备上，ISA越来越倾向于64位Arm架构。由于大多数云基础设施运行在Intel和AMD的CPU上，为嵌入式Linux构建软件需要一个交叉编译工具链。然而，交叉编译并不是GitHub
    Actions或GitLab CI等云端CI/CD服务的常见用例。
- en: Buildroot and Yocto are both designed to cross-compile embedded Linux images,
    but running these tools in the cloud can be challenging. They require lots of
    disk space and the extended build times are prohibitive. Build times can be improved
    by employing incremental builds and intelligent caching (e.g., Yocto’s shared
    `sstate-cache`). Alternatively, you can use Docker in conjunction with QEMU to
    cross-compile container images for 64-bit Arm. This containerized approach works
    great for user space but emulating the target architecture slows down compilation.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: Buildroot和Yocto都旨在交叉编译嵌入式Linux镜像，但在云端运行这些工具可能会遇到挑战。它们需要大量的磁盘空间，且较长的构建时间让人望而却步。通过采用增量构建和智能缓存（例如Yocto的共享`
    sstate-cache`），可以提高构建效率。另一种方法是将Docker与QEMU结合使用，为64位Arm交叉编译容器镜像。这种容器化的方式对用户空间很有效，但模拟目标架构会减慢编译速度。
- en: Automated testing on real hardware
  id: totrans-61
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在真实硬件上的自动化测试
- en: One of the biggest challenges involved in shipping hardware is implementing
    **hardware-in-the-loop** (**HIL**) testing. Like cross-compilation, automated
    testing can be done easily in the cloud with QEMU, but there is no substitute
    for testing software on its intended hardware. When safety is a concern, HIL testing
    is an obligation, not a cautionary measure. The challenge is in how to automate
    it. This is why HIL testing often requires as much effort as coding the software.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 交付硬件时面临的最大挑战之一是实现**硬件在环**（**HIL**）测试。像交叉编译一样，自动化测试可以通过QEMU在云端轻松完成，但没有什么能替代在预定硬件上进行软件测试。当安全性成为问题时，HIL测试不仅仅是一个预防性措施，而是一项必要的工作。挑战在于如何实现自动化，这也是为什么HIL测试往往需要投入与编写软件同等的努力。
- en: The most effective form of HIL testing is to simulate the real world. Hardware
    interacts with the real world through sensors and actuators. It receives input
    from sensors and sends output to actuators via communications interfaces like
    I2C, SPI, and CAN. We simulate the real world by modeling it with software. This
    software model runs on a separate Linux machine. It sends and receives messages
    over the various comms interfaces just like the sensors and actuators in the actual
    system. For example, to test an EV charger we would connect a PCB on a test bench
    to a mock battery running our model.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 最有效的HIL测试形式是模拟现实世界。硬件通过传感器和执行器与现实世界进行交互。它从传感器接收输入，并通过I2C、SPI和CAN等通信接口将输出发送到执行器。我们通过软件建模来模拟现实世界。这个软件模型运行在独立的Linux机器上。它像实际系统中的传感器和执行器一样，通过各种通信接口发送和接收消息。例如，为了测试电动汽车充电器，我们会将PCB连接到测试台上的模拟电池，并运行我们的模型进行测试。
- en: Continuous delivery and OTA updates
  id: totrans-64
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 持续交付与OTA更新
- en: When a deployment fails in the cloud, we simply delete the problem servers and
    spin up new instances. We don’t need to worry about bricking servers because we
    can always just start over from scratch. Reprovisioning servers is relatively
    quick and painless to do in the cloud. The same cannot be said for consumer devices
    out in the field. If a device cannot boot, then it is useless. Similarly, if a
    connected device suddenly becomes disconnected from the internet, then it cannot
    receive critical OTA updates.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 当云中的部署失败时，我们只需删除有问题的服务器并启动新的实例。我们不需要担心服务器砖化，因为我们可以随时从头开始。在云中，重新配置服务器是相对快速且不痛苦的。对于现场的消费类设备则无法如此处理。如果设备无法启动，那么它就没用了。同样，如果一个连接的设备突然与互联网断开，那么它就无法接收关键的OTA更新。
- en: OTA updates are how the continuous delivery of software happens in embedded
    systems. OTA updates need to be fail-safe in the face of accidental power loss.
    A failed OTA update cannot result in a partial or unknown flash image. Otherwise,
    the device may be rendered unbootable. Buildroot and Yocto support fail-safe OTA
    update solutions like Mender, RAUC, and SWUpdate. Even though these tools will
    save you from bricking your fleet, you should still test your software releases
    thoroughly before a full rollout. Nothing sinks a new product launch quicker than
    a bad user experience.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: OTA更新是嵌入式系统中软件持续交付的方式。OTA更新需要在意外断电的情况下具备容错性。失败的OTA更新不能导致部分或未知的闪存镜像。否则，设备可能会变得无法启动。Buildroot和Yocto支持像Mender、RAUC和SWUpdate这样的容错OTA更新解决方案。尽管这些工具可以防止你的设备群被砖化，但你仍然应该在全面发布之前充分测试软件版本。没有什么比糟糕的用户体验更能快速葬送新产品发布了。
- en: Infrastructure as code and build systems
  id: totrans-67
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 基础设施即代码和构建系统
- en: Buildroot relies on makefiles. Yocto consists of BitBake recipes. Like the YAML
    files that define your cloud infrastructure, this build metadata also qualifies
    as code and should be kept in version control. That includes board defconfigs
    and package definitions for Buildroot. For Yocto, the build metadata is comprised
    of BSP and distro layers. It also pays to containerize your embedded Linux build
    environment by defining a Dockerfile for it. This makes it easier to spin up a
    CI/CD pipeline to build images for your target device. It also makes it easier
    for others to reproduce your build environment so that they can develop locally
    on their machines.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: Buildroot依赖于makefile。Yocto由BitBake食谱组成。就像定义云基础设施的YAML文件一样，这些构建元数据也可以视为代码，应当存储在版本控制中。这包括Buildroot的板定义配置和包定义。对于Yocto，构建元数据包括BSP和发行版层。通过定义Dockerfile将你的嵌入式Linux构建环境容器化也很有益。这可以更容易地启动CI/CD管道，为你的目标设备构建镜像，也让其他人更容易重现你的构建环境，从而在他们的机器上进行本地开发。
- en: Securing edge devices
  id: totrans-69
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 保护边缘设备
- en: The internet is full of danger. The infamous Mirai botnet was started by kids
    wanting to knock out rival Minecraft servers. The idea evolved into large-scale
    **distributed denial-of-service** (**DDoS**) attacks. Mirai hijacks consumer IoT
    devices like webcams and home routers and points them at selected websites. Securing
    the boot and OTA update processes prevents malware like Mirai from running on
    users’ devices. The mechanisms for securing the boot and OTA update processes
    are described in [*Chapter 10*](Chapter_10.xhtml#_idTextAnchor341). Security is
    table stakes at the edge because once your fleet is hijacked, you can’t get it
    back.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 互联网充满了危险。臭名昭著的Mirai僵尸网络最初是由一些想要攻击竞争Minecraft服务器的孩子们发起的。这个想法演变成了大规模的**分布式拒绝服务**（**DDoS**）攻击。Mirai劫持了消费者的物联网设备，如网络摄像头和家用路由器，并将它们指向选定的网站。确保启动和OTA更新过程的安全性可以防止像Mirai这样的恶意软件在用户设备上运行。有关如何确保启动和OTA更新过程安全性的机制，请参见[*第10章*](Chapter_10.xhtml#_idTextAnchor341)。在边缘设备上，安全性至关重要，因为一旦你的设备群被劫持，你是无法找回它们的。
- en: Secure boot means that a device will only boot from an image that has been cryptographically
    signed by the device manufacturer. A signature verification step is inserted at
    boot time to ensure the authenticity of the latest image applied by an OTA update.
    Users also expect all data to be encrypted on their devices for privacy. Auto-unlocking
    an encrypted volume requires a passphrase on startup. Any keys or passphrases
    needed by a device at runtime should be stored safely inside a TPM or secure element.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 安全启动意味着设备只能从由设备制造商加密签名的镜像启动。启动时会插入签名验证步骤，以确保通过OTA更新应用的最新镜像的真实性。用户还希望所有设备上的数据都能加密以保护隐私。自动解锁加密卷需要在启动时输入密码。设备在运行时所需的任何密钥或密码应安全地存储在TPM或安全元件中。
- en: Monitoring and observability of edge devices
  id: totrans-72
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 边缘设备的监控与可观测性
- en: Gathering telemetry from consumer devices is difficult because they are deployed
    in people’s homes and offices. Like all other devices connected to the internet,
    any new product that wants to stream telemetry up to the cloud will need to get
    past the firewall. This typically requires a user to open an outgoing port on
    their Wi-Fi router. Users may not be network savvy enough or object to doing this
    for privacy. While standard IoT protocols for telemetry like MQTT exist, they
    are not always a good fit for every application. There is still much room for
    innovation in this space by startups like Golioth and Memfault.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 从消费设备收集遥测数据非常困难，因为这些设备部署在用户的家中和办公室里。像所有其他连接到互联网的设备一样，任何想要将遥测数据传输到云端的新产品都必须通过防火墙。这通常需要用户在
    Wi-Fi 路由器上打开一个外向端口。用户可能不够了解网络，或者出于隐私原因反对这样做。尽管像 MQTT 这样的标准 IoT 协议可以用于遥测，但它们并不总是适合每一个应用场景。在这个领域，像
    Golioth 和 Memfault 这样的初创公司仍有很大的创新空间。
- en: Enough theory and rationale. Let’s put these principles into practice. We’ll
    start by performing a containerized software deployment. You should have already
    installed Docker on your Linux host according to the instructions in the *Getting
    Docker* section.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 够多的理论和理论依据了。现在让我们将这些原则付诸实践。我们将从执行一个容器化的软件部署开始。您应该已经根据《*获取 Docker*》部分的说明，在您的
    Linux 主机上安装了 Docker。
- en: Deploying Python applications with Docker
  id: totrans-75
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Docker 部署 Python 应用程序
- en: Docker offers another way to bundle Python code with software written in other
    languages. The idea behind Docker is that instead of packaging and installing
    your application onto a preconfigured server environment, you build and ship a
    container image with your application and all its runtime dependencies. A container
    image is more like a virtual environment than a virtual machine. A virtual machine
    is a complete system image including a kernel and an operating system. A container
    image is a minimal user-space environment that only comes with the binaries needed
    to run your application.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: Docker 提供了另一种将 Python 代码与其他语言编写的软件捆绑的方法。Docker 背后的理念是，您不需要将应用程序打包并安装到一个预配置的服务器环境中，而是构建并分发一个包含您的应用程序及其所有运行时依赖的容器镜像。容器镜像更像是一个虚拟环境，而非虚拟机。虚拟机是一个完整的系统镜像，包括内核和操作系统。而容器镜像是一个最小的用户空间环境，只包含运行应用程序所需的二进制文件。
- en: 'Virtual machines run on top of a hypervisor that emulates hardware. Containers
    run directly on top of the host operating system. Unlike virtual machines, containers
    are able to share the same operating system and kernel without the use of hardware
    emulation. Instead, they rely on two special features of the Linux kernel for
    isolation: namespaces and cgroups. Docker did not invent container technology,
    but they were the first to build tooling that made them easy to use. The tired
    excuse of “works on my machine” no longer flies now that Docker makes it so simple
    to build and deploy container images.'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 虚拟机运行在模拟硬件的虚拟机监控器上，而容器则直接运行在主机操作系统之上。与虚拟机不同，容器能够共享相同的操作系统和内核，而无需使用硬件模拟。容器依赖于
    Linux 内核的两个特殊功能来实现隔离：命名空间和控制组。Docker 并没有发明容器技术，但他们是第一个构建使容器易于使用的工具的公司。由于 Docker
    使构建和部署容器镜像变得如此简单，曾经的“在我的机器上能运行”这一借口不再成立。
- en: Anatomy of a Dockerfile
  id: totrans-78
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Dockerfile 的结构
- en: A **Dockerfile** describes the contents of a Docker image. Every Dockerfile
    contains a set of instructions specifying what environment to use and which commands
    to run. Instead of writing a Dockerfile from scratch, we will use an existing
    Dockerfile for a project template. This Dockerfile generates a Docker image for
    a very simple Flask web application that you can extend to fit your needs. The
    Docker image is built on top of Debian Bookworm. Besides Flask, the Docker image
    also includes uWSGI and Nginx for better performance.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 一个 **Dockerfile** 描述了 Docker 镜像的内容。每个 Dockerfile 都包含一组指令，指定使用哪个环境以及要运行哪些命令。我们将使用一个现有的项目模板中的
    Dockerfile，而不是从零开始编写 Dockerfile。这个 Dockerfile 为一个非常简单的 Flask Web 应用程序生成 Docker
    镜像，您可以扩展该镜像以满足自己的需求。该 Docker 镜像是基于 Debian Bookworm 构建的。除了 Flask，Docker 镜像还包括 uWSGI
    和 Nginx，以提高性能。
- en: Start by pointing your web browser at the `uwsgi-nginx-flask-docker` project
    on GitHub ([https://github.com/tiangolo/uwsgi-nginx-flask-docker](https://github.com/tiangolo/uwsgi-nginx-flask-docker)).
    Then, click on the link to the `python-3.12` Dockerfile from the `README.md` file.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，在浏览器中打开GitHub上的`uwsgi-nginx-flask-docker`项目页面（[https://github.com/tiangolo/uwsgi-nginx-flask-docker](https://github.com/tiangolo/uwsgi-nginx-flask-docker)）。然后，点击`README.md`文件中的`python-3.12`
    Dockerfile链接。
- en: 'Now, look at the first line in that Dockerfile:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，查看该Dockerfile中的第一行：
- en: '[PRE5]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'This `FROM` command tells Docker to pull an image named `uwsgi-nginx` from
    the `tiangolo` namespace with `python3.12` from Docker Hub. Docker Hub is a public
    registry where people publish their Docker images for others to fetch and deploy.
    You can set up your own image registry using a service such as AWS ECR or Quay
    if you prefer. You will need to insert the name of your registry service in front
    of your namespace like this:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 这个`FROM`命令告诉Docker从Docker Hub的`tiangolo`命名空间拉取一个名为`uwsgi-nginx`的镜像，并且包含`python3.12`。Docker
    Hub是一个公共注册中心，用户可以在其中发布自己的Docker镜像供他人获取和部署。如果你愿意，也可以使用像AWS ECR或Quay这样的服务设置自己的镜像注册中心。你需要在命名空间前面插入注册中心服务的名称，像这样：
- en: '[PRE6]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Otherwise, Docker defaults to fetching images from Docker Hub. `FROM` is like
    an `include` statement in a Dockerfile. It inserts the contents of another Dockerfile
    into yours so that you have something to build on top of. I like to think of this
    approach as layering images. Debian Bookworm is the base layer, followed by Python
    3.12, then uWSGI plus Nginx, and finally your Flask application. You can learn
    more about how image layering works by digging into the `python3.12` Dockerfile
    at [https://hub.docker.com/r/tiangolo/uwsgi-nginx](https://hub.docker.com/r/tiangolo/uwsgi-nginx).
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 否则，Docker会默认从Docker Hub拉取镜像。`FROM`就像Dockerfile中的`include`语句，它将另一个Dockerfile的内容插入到你的Dockerfile中，以便你可以在其基础上构建。我喜欢把这种方式看作是图层化镜像。Debian
    Bookworm是基础层，接着是Python 3.12，然后是uWSGI加Nginx，最后是你的Flask应用程序。你可以通过深入研究[https://hub.docker.com/r/tiangolo/uwsgi-nginx](https://hub.docker.com/r/tiangolo/uwsgi-nginx)上的`python3.12`
    Dockerfile来了解更多有关镜像图层化的工作原理。
- en: 'Here is the next line of interest in the Dockerfile:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 这是Dockerfile中下一个值得注意的行：
- en: '[PRE7]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: A `RUN` instruction runs a command. Docker executes the `RUN` instructions contained
    in the Dockerfile sequentially in order to build the resulting Docker image. If
    you look at the `requirements.txt` file in the Git repo, you will see that this
    `RUN` instruction installs Flask in the system `site-packages` directory. We know
    that `pip` is available because the `uwsgi-nginx` base image also includes Python
    3.12.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: '`RUN`指令用于运行命令。Docker会按顺序执行Dockerfile中的`RUN`指令，以构建最终的Docker镜像。如果你查看Git仓库中的`requirements.txt`文件，你会看到这个`RUN`指令会在系统的`site-packages`目录中安装Flask。我们知道`pip`可用，因为`uwsgi-nginx`基础镜像也包括了Python
    3.12。'
- en: 'Let’s skip over Nginx’s environment variables and go straight to copying:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 我们跳过Nginx的环境变量，直接进入复制操作：
- en: '[PRE8]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: This particular Dockerfile is located inside a Git repo along with several other
    files and subdirectories. The `COPY` instruction copies a directory from the host
    Docker runtime environment (usually a Git clone of a repo) into the container
    being built.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 这个特定的Dockerfile位于一个Git仓库中，并与其他几个文件和子目录一起存放。`COPY`指令将主机Docker运行环境中的一个目录（通常是仓库的Git克隆）复制到正在构建的容器中。
- en: 'The `python3.12.dockerfile` file you are looking at resides in a `docker-images`
    subdirectory of the `tiangolo/uwsgi-nginx-flask-docker` repo. Inside that `docker-images`
    directory is an `app` subdirectory containing a Hello World Flask web application.
    This `COPY` instruction copies the `app` directory from the example repo into
    the root directory of the Docker image:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 你正在查看的`python3.12.dockerfile`文件位于`tiangolo/uwsgi-nginx-flask-docker`仓库的`docker-images`子目录中。在`docker-images`目录中，有一个名为`app`的子目录，里面包含一个Hello
    World Flask Web应用程序。这个`COPY`指令将`app`目录从示例仓库复制到Docker镜像的根目录：
- en: '[PRE9]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The `WORKDIR` instruction tells Docker which directory to work from inside the
    container. In this example, the `/app` directory that it just copied becomes the
    working directory. If the target working directory does not exist, then `WORKDIR`
    creates it. Any subsequent non-absolute paths that appear in this Dockerfile are
    hence relative to the `/app` directory.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: '`WORKDIR`指令告诉Docker从容器内的哪个目录开始工作。在这个例子中，它刚刚复制的`/app`目录成为工作目录。如果目标工作目录不存在，`WORKDIR`会创建它。Dockerfile中后续出现的任何非绝对路径都将相对于`/app`目录。'
- en: 'Now let’s see how an environment variable gets set inside the container:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们来看一下如何在容器内设置一个环境变量：
- en: '[PRE10]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '`ENV` tells Docker that what follows is an environment variable definition.
    `PYTHONPATH` is an environment variable that expands into a list of colon-delimited
    paths where the Python interpreter looks for modules and packages.'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: '`ENV`指令告诉Docker后面的内容是环境变量定义。`PYTHONPATH`是一个环境变量，它扩展成一个以冒号分隔的路径列表，Python解释器会在这些路径中查找模块和包。'
- en: 'Next, let’s jump a few lines down to the second `RUN` instruction:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们跳到第二个`RUN`指令：
- en: '[PRE11]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The `RUN` instruction tells Docker to run a command from the shell. In this
    case, the command being run is `chmod`, which changes file permissions. Here,
    it renders the `/entrypoint.sh` executable.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: '`RUN`指令告诉Docker从Shell运行一个命令。在这个例子中，运行的命令是`chmod`，它用于更改文件权限。在这里，它使`/entrypoint.sh`变为可执行文件。'
- en: 'The next line in this Dockerfile is optional:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: Dockerfile中的下一行是可选的：
- en: '[PRE12]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '`ENTRYPOINT` is the most interesting instruction in this Dockerfile. It exposes
    an executable to the Docker host command line when starting the container. This
    lets you pass arguments from the command line down to the executable inside the
    container. You can append these arguments after `docker run` `<image>` on the
    command line. If there is more than one `ENTRYPOINT` instruction in a Dockerfile,
    then only the last `ENTRYPOINT` is executed.'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: '`ENTRYPOINT`是这个Dockerfile中最有趣的指令。当启动容器时，它会暴露一个可执行文件到Docker主机的命令行。这允许你从命令行将参数传递给容器内的可执行文件。你可以在命令行中`docker
    run` `<image>`后附加这些参数。如果Dockerfile中有多个`ENTRYPOINT`指令，那么只有最后一个`ENTRYPOINT`会被执行。'
- en: 'The last line in the Dockerfile is:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: Dockerfile中的最后一行是：
- en: '[PRE13]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Like `ENTRYPOINT` instructions, `CMD` instructions execute at container start
    time rather than build time. When an `ENTRYPOINT` instruction is defined in a
    Dockerfile, a `CMD` instruction defines default arguments to be passed to that
    `ENTRYPOINT`. In this instance, the `/start.sh` path is the argument passed to
    `/entrypoint.sh`. The last line in `/entrypoint.sh` executes `/start.sh`:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 与`ENTRYPOINT`指令类似，`CMD`指令在容器启动时执行，而非构建时执行。当在Dockerfile中定义了`ENTRYPOINT`指令时，`CMD`指令定义了要传递给`ENTRYPOINT`的默认参数。在这个例子中，`/start.sh`路径是传递给`/entrypoint.sh`的参数。`/entrypoint.sh`中的最后一行执行`/start.sh`：
- en: '[PRE14]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The `/start.sh` script comes from the `uwsgi-nginx` base image. `/start.sh`
    starts Nginx and uWSGI after `/entrypoint.sh` has configured the container runtime
    environment for them. When `CMD` is used in conjunction with `ENTRYPOINT`, the
    default arguments set by `CMD` can be overridden from the Docker host command
    line.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: '`/start.sh`脚本来自`uwsgi-nginx`基础镜像。`/start.sh`在`/entrypoint.sh`配置完容器运行环境后启动Nginx和uWSGI。当`CMD`与`ENTRYPOINT`一起使用时，`CMD`设置的默认参数可以通过Docker主机命令行进行覆盖。'
- en: 'Most Dockerfiles do not have an `ENTRYPOINT` instruction, so the last line
    of a Dockerfile is usually a `CMD` instruction that runs in the foreground instead
    of default arguments. You can use this Dockerfile trick to keep a general-purpose
    Docker container running for development:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数Dockerfile中没有`ENTRYPOINT`指令，因此Dockerfile的最后一行通常是一个`CMD`指令，它会在前台运行，而不是使用默认参数。你可以利用这个Dockerfile技巧保持一个通用的Docker容器在开发时运行：
- en: '[PRE15]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Except for `ENTRYPOINT` and `CMD`, all of the instructions in this example `python-3.12`
    Dockerfile only execute when the container is being built.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 除了`ENTRYPOINT`和`CMD`外，这个`python-3.12` Dockerfile中的所有指令只在容器构建时执行。
- en: Building a Docker image
  id: totrans-112
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 构建一个Docker镜像
- en: Before we can build a Docker image, we need a Dockerfile. You may already have
    some Docker images on your system.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们能够构建Docker镜像之前，我们需要一个Dockerfile。你可能已经在系统中拥有一些Docker镜像。
- en: 'To see a list of Docker images:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看Docker镜像的列表：
- en: '[PRE16]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Now, let’s fetch and build the Dockerfile we just dissected:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们获取并构建我们刚刚分析过的Dockerfile：
- en: 'Clone the repo containing the Dockerfile:'
  id: totrans-117
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 克隆包含Dockerfile的仓库：
- en: '[PRE17]'
  id: totrans-118
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Switch to the `docker-images` subdirectory inside the repo:'
  id: totrans-119
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 切换到仓库中的`docker-images`子目录：
- en: '[PRE18]'
  id: totrans-120
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Copy `python3.12.dockerfile` to a file named `Dockerfile`:'
  id: totrans-121
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`python3.12.dockerfile`复制到名为`Dockerfile`的文件中：
- en: '[PRE19]'
  id: totrans-122
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Build an image from the Dockerfile:'
  id: totrans-123
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从Dockerfile构建一个镜像：
- en: '[PRE20]'
  id: totrans-124
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Once the image is done building, it will appear in your list of local Docker
    images:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 镜像构建完成后，它会出现在你的本地Docker镜像列表中：
- en: '[PRE21]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: The newly built my-image should appear in the list.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 新构建的`my-image`应该出现在列表中。
- en: Running a Docker image
  id: totrans-128
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 运行一个Docker镜像
- en: We now have a Docker image built that we can run as a container.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经构建了一个Docker镜像，可以将其作为容器运行。
- en: 'To get a list of running containers on your system:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 要获取系统上运行中的容器列表：
- en: '[PRE22]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'To run a container based on `my-image`:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 要运行基于`my-image`的容器：
- en: '[PRE23]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'If the preceding command fails because port `80` is busy, then substitute port
    `8080` for `80`. Now observe the status of your running container:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 如果前面的命令因端口 `80` 被占用而失败，则将端口 `80` 替换为 `8080`。现在查看你运行中的容器的状态：
- en: '[PRE24]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: You should see a container named `my-container` based on an image named `my-image`
    in the list. The `-p` option in the `docker run` command maps a container port
    to a host port. So, container port `80` maps to host port `80` in this example.
    This port mapping allows the Flask web server running inside the container to
    service HTTP requests.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该在列表中看到一个名为 `my-container` 的容器，它基于一个名为 `my-image` 的镜像。`docker run` 命令中的 `-p`
    选项将容器端口映射到主机端口。所以，在这个例子中，容器端口 `80` 映射到主机端口 `80`。这种端口映射允许在容器内运行的 Flask Web 服务器处理
    HTTP 请求。
- en: 'To stop `my-container`:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 停止 `my-container`：
- en: '[PRE25]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Now check the status of your running container again:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 现在再次检查你运行中的容器的状态：
- en: '[PRE26]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: '`my-container` should no longer appear in the list of running containers. Is
    the container gone? No, it is only stopped. You can still see `my-container` and
    its status by adding the `-a` option to the `docker` `ps` command:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: '`my-container` 应该不再出现在运行中的容器列表中。容器消失了吗？没有，它只是停止了。你仍然可以通过在 `docker` `ps` 命令中添加
    `-a` 选项来查看 `my-container` 及其状态：'
- en: '[PRE27]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: We’ll look at how to delete containers we no longer need a bit later.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 稍后我们将看看如何删除不再需要的容器。
- en: Fetching a Docker image
  id: totrans-144
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 拉取 Docker 镜像
- en: Earlier in this section, I touched on image registries such as Docker Hub, AWS
    ECR, and Quay. As it turns out, the Docker image that we built locally from a
    cloned Git repo is already published on Docker Hub. It is much quicker to fetch
    the prebuilt image from Docker Hub than to build it yourself on your system. The
    Docker images for the project can be found at [https://hub.docker.com/r/tiangolo/uwsgi-nginx-flask](https://hub.docker.com/r/tiangolo/uwsgi-nginx-flask).
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节前面，我提到过 Docker Hub、AWS ECR 和 Quay 等镜像注册表。事实证明，我们从克隆的 Git 仓库构建的本地 Docker 镜像已经发布在
    Docker Hub 上。从 Docker Hub 拉取预构建的镜像比在本地系统上自己构建它更快。该项目的 Docker 镜像可以在 [https://hub.docker.com/r/tiangolo/uwsgi-nginx-flask](https://hub.docker.com/r/tiangolo/uwsgi-nginx-flask)
    上找到。
- en: 'To pull the same Docker image that we built as `my-image` from Docker Hub:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 从 Docker Hub 拉取我们构建的名为 `my-image` 的相同 Docker 镜像：
- en: '[PRE28]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Now look at your list of Docker images again:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 现在再次查看你的 Docker 镜像列表：
- en: '[PRE29]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: You should see a new `uwsgi-nginx-flask` image in the list.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该在列表中看到一个新的`uwsgi-nginx-flask`镜像。
- en: 'To run this newly fetched image:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 要运行这个新拉取的镜像：
- en: '[PRE30]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: You can substitute the full image name (`repo:tag`) in the preceding `docker
    run` command with the corresponding image ID (hash) from `docker images` if you
    prefer not to type out the full image name.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你不想键入完整的镜像名称，你可以用 `docker images` 中对应的镜像 ID（哈希值）替换前面的 `docker run` 命令中的完整镜像名称（`repo:tag`）。
- en: Publishing a Docker image
  id: totrans-154
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 发布 Docker 镜像
- en: 'To publish a Docker image to Docker Hub, you must first have an account and
    log in to it. You can create an account on Docker Hub by going to the [https://hub.docker.com](https://hub.docker.com)
    website and signing up. Once you have an account, then you can push an existing
    image to your Docker Hub repository:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 要将 Docker 镜像发布到 Docker Hub，你必须首先拥有一个账户并登录。你可以通过访问 [https://hub.docker.com](https://hub.docker.com)
    网站创建一个账户并注册。注册成功后，你就可以将现有镜像推送到你的 Docker Hub 仓库：
- en: 'Log in to the Docker Hub image registry from the command line:'
  id: totrans-156
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从命令行登录 Docker Hub 镜像注册表：
- en: '[PRE31]'
  id: totrans-157
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Enter your Docker Hub username and password when prompted.
  id: totrans-158
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在提示时输入你的 Docker Hub 用户名和密码。
- en: 'Tag an existing image with a new name that starts with the name of your repository:'
  id: totrans-159
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 给一个已有的镜像打上一个新标签，标签名以你的仓库名称开头：
- en: '[PRE32]'
  id: totrans-160
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Replace `<repository>` in the preceding command with the name of your repository
    (the same as your username) on Docker Hub. You can also substitute the name of
    another existing image you wish to push for `my-image:latest`.
  id: totrans-161
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将前面命令中的 `<repository>` 替换为你在 Docker Hub 上的仓库名称（与用户名相同）。你也可以将要推送的另一个已有镜像名称替换为
    `my-image:latest`。
- en: 'Push the image to the Docker Hub image registry:'
  id: totrans-162
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将镜像推送到 Docker Hub 镜像注册表：
- en: '[PRE33]'
  id: totrans-163
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Again, make the same replacements as you did for *step 3*.
  id: totrans-164
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 再次进行与*步骤 3*相同的替换。
- en: Images pushed to Docker Hub are publicly available by default. To visit the
    web page for your newly published image, go to [https://hub.docker.com/repository/docker/<repository>/my-image](https://hub.docker.com/repository/docker/repository/my-image).
    Replace `<repository>` in the preceding URL with the name of your repository (the
    same as your username) on Docker Hub. You can also substitute the name of the
    actual image you pushed for `my-image:latest` if different. If you click on the
    **Tags** tab on that web page, you should see the `docker pull` command for fetching
    that image.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，推送到Docker Hub的镜像是公开可用的。要访问你新发布镜像的网页，请访问[https://hub.docker.com/repository/docker/<repository>/my-image](https://hub.docker.com/repository/docker/repository/my-image)。将前面URL中的`<repository>`替换为你在Docker
    Hub上的仓库名称（与用户名相同）。如果实际推送的镜像名称不同，也可以将`my-image:latest`替换为该镜像的名称。如果你点击网页上的**Tags**标签，你应该能看到获取该镜像的`docker
    pull`命令。
- en: Cleaning up
  id: totrans-166
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 清理
- en: 'We know that `docker images` lists images and `docker ps` lists containers.
    Before we can delete a Docker image, we must first delete any containers that
    reference it. To delete a Docker container, you first need to know the container’s
    name or ID:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 我们知道`docker images`列出镜像，`docker ps`列出容器。在删除Docker镜像之前，我们必须先删除所有引用该镜像的容器。要删除Docker容器，首先需要知道容器的名称或ID：
- en: 'Find the target Docker container’s name:'
  id: totrans-168
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 查找目标Docker容器的名称：
- en: '[PRE34]'
  id: totrans-169
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Stop the container if it is running:'
  id: totrans-170
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果容器正在运行，请停止它：
- en: '[PRE35]'
  id: totrans-171
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Delete the Docker container:'
  id: totrans-172
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 删除Docker容器：
- en: '[PRE36]'
  id: totrans-173
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Replace `flask-container` in the two preceding commands with the container name
    or ID from *step 1*. Every container that appears under `docker ps` also has an
    image name or ID associated with it. Once you have deleted all the containers
    that reference an image, you can then delete the image.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 将前面两个命令中的`flask-container`替换为*步骤1*中的容器名称或ID。每个出现在`docker ps`中的容器也都有与之相关联的镜像名称或ID。一旦你删除了所有引用该镜像的容器，就可以删除该镜像。
- en: 'Docker image names (`repo:tag`) can get quite long (for example, `tiangolo/uwsgi-nginx-flask:python3.12`).
    For that reason, I find it easier to just copy and paste an image’s ID (hash)
    when deleting:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: Docker镜像名称（`repo:tag`）可能会很长（例如，`tiangolo/uwsgi-nginx-flask:python3.12`）。因此，我发现删除镜像时直接复制并粘贴镜像的ID（哈希值）更方便：
- en: 'Find the Docker image’s ID:'
  id: totrans-176
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 查找Docker镜像的ID：
- en: '[PRE37]'
  id: totrans-177
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Delete the Docker image:'
  id: totrans-178
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 删除Docker镜像：
- en: '[PRE38]'
  id: totrans-179
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Replace `<image-ID>` in the preceding command with the image ID from *step 1*.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 将前面的命令中的`<image-ID>`替换为*步骤1*中的镜像ID。
- en: 'If you simply want to blow away all the containers and images that you are
    no longer using on your system:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你仅仅想清除系统中不再使用的所有容器和镜像：
- en: '[PRE39]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: '`docker system prune` deletes all stopped containers and dangling images.'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: '`docker system prune`会删除所有已停止的容器和悬挂镜像。'
- en: We’ve seen how `pip` can be used to install a Python application’s dependencies.
    You simply add a `RUN` instruction that calls `pip install` to your Dockerfile.
    Because containers are sandboxed environments, they offer many of the same benefits
    that virtual environments do. But unlike `conda` and `venv` virtual environments,
    Buildroot and Yocto both have support for Docker containers. Buildroot has the
    `docker-engine` and `docker-cli` packages. Yocto has the `meta-virtualization`
    layer. If your device needs isolation because of Python package conflicts, then
    you can achieve that with Docker.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到如何使用`pip`来安装Python应用程序的依赖项。你只需在Dockerfile中添加一个调用`pip install`的`RUN`指令。由于容器是沙箱环境，它们提供了许多与虚拟环境相同的好处。但与`conda`和`venv`虚拟环境不同，Buildroot和Yocto都支持Docker容器。Buildroot有`docker-engine`和`docker-cli`软件包。Yocto有`meta-virtualization`层。如果你的设备由于Python包冲突需要隔离，你可以通过Docker实现这一点。
- en: The `docker run` command provides options for exposing operating system resources
    to containers. Specifying a bind mount allows a file or directory on the host
    machine to be mounted inside a container for reading and writing. By default,
    containers publish no ports to the outside world. When you ran your `my-container`
    image, you used the `-p` option to publish port `80` from the container to port
    `80` on the host. The `--device` option adds a host device file under `/dev` to
    an unprivileged container. If you wish to grant access to all devices on the host,
    then use the `--privileged` option.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: '`docker run`命令提供了将操作系统资源暴露给容器的选项。指定绑定挂载允许将主机上的文件或目录挂载到容器内，以供读写。默认情况下，容器不会向外界发布任何端口。当你运行`my-container`镜像时，你使用了`-p`选项将容器的端口`80`发布到主机的端口`80`。`--device`选项将主机设备文件添加到非特权容器中的`/dev`目录。如果你希望授予对主机上所有设备的访问权限，可以使用`--privileged`选项。'
- en: What containers excel at is deployment. Being able to push a Docker image that
    can then be easily pulled and run on any of the major cloud platforms has revolutionized
    the DevOps movement. Docker is also making inroads in the embedded Linux space
    thanks to OTA update solutions such as balena. One of the downsides of Docker
    is the storage footprint and memory overhead of the runtime. The Go binaries are
    a bit bloated, but Docker runs on quad-core 64-bit Arm SBCs like the Raspberry
    Pi 4 and BeaglePlay just fine. If your target device has enough power, then run
    Docker on it. Your software development team will thank you.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 容器的强项在于部署。能够推送一个 Docker 镜像，然后在任何主要的云平台上轻松拉取并运行，这一功能彻底改变了 DevOps 运动。由于像 balena
    这样的 OTA 更新解决方案，Docker 在嵌入式 Linux 领域也在取得进展。Docker 的一个缺点是运行时的存储占用和内存开销。Go 二进制文件有点臃肿，但
    Docker 在四核 64 位 Arm 单板计算机（如 Raspberry Pi 4 和 BeaglePlay）上运行得很好。如果你的目标设备有足够的性能，那么就在上面运行
    Docker。你的软件开发团队会感谢你的。
- en: '**IMPORTANT NOTE**'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: '**重要提示**'
- en: Podman is an alternative to Docker that offers a lighter, daemonless architecture.
    Unlike Docker, Podman does not require a service to be continuously running in
    the background, making it more resource-efficient. Its support for rootless containers
    enhances security and its compatibility with OCI standards ensures flexibility.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: Podman 是 Docker 的替代品，提供了一个更轻量的无守护进程架构。与 Docker 不同，Podman 不需要一个持续在后台运行的服务，这使得它更加高效。它对无根容器的支持增强了安全性，并且它与
    OCI 标准的兼容性确保了灵活性。
- en: Setting up a CI/CD pipeline for a Python application
  id: totrans-189
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为 Python 应用设置 CI/CD 流水线
- en: Docker is not just for deploying software to the cloud. Cloud-based CI/CD services
    can build and publish 64-bit Arm container images for deploying to edge devices.
    Containerized software updates are less disruptive than full A/B image updates
    because they don’t require a reboot. Users get nervous when they see their devices
    fall offline even if just for a moment.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: Docker 不仅仅是为了将软件部署到云端。基于云的 CI/CD 服务可以构建并发布 64 位 Arm 容器镜像，以便部署到边缘设备。容器化的软件更新比完整的
    A/B 镜像更新更不具破坏性，因为它们不需要重启。即使只是片刻，用户看到他们的设备掉线时也会感到紧张。
- en: Containerized software updates are also less risky than full A/B image updates
    because they don’t include a Linux kernel. An edge device may fail to boot because
    of a bad kernel update. Unless there is a fail-safe mechanism in place, the device
    is effectively bricked. Upstream kernel modules fall into disrepair as hardware
    ages out. Kernel upgrades are especially dangerous because they can introduce
    kernel panics.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 容器化软件更新的风险比完整的 A/B 镜像更新小，因为它们不包括 Linux 内核。边缘设备可能因为内核更新错误而无法启动。如果没有 fail-safe
    机制，设备实际上就会变砖。随着硬件老化，上游内核模块会失修。内核升级尤其危险，因为它们可能导致内核崩溃。
- en: Back in the *Building on top of an existing BSP* section of [*Chapter 7*](Chapter_05.xhtml#_idTextAnchor151),
    we added a custom layer for a Python Bluetooth server application to a Yocto image
    for the Raspberry Pi 4\. We can deploy the same application to a fleet of Raspberry
    Pi 4s using Docker.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 在[*第 7 章*](Chapter_05.xhtml#_idTextAnchor151)的*基于现有 BSP 构建*一节中，我们为 Raspberry
    Pi 4 的 Yocto 镜像添加了一个用于 Python 蓝牙服务器应用的自定义层。我们可以使用 Docker 将相同的应用部署到一批 Raspberry
    Pi 4 上。
- en: The source code for the Python Bluetooth server resides in a public Git repo
    ([https://github.com/fvasquez/gattd](https://github.com/fvasquez/gattd)). GitHub
    Actions can attempt to build and publish a container image every time a commit
    is pushed to the repo.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: Python 蓝牙服务器的源代码存放在一个公开的 Git 仓库中（[https://github.com/fvasquez/gattd](https://github.com/fvasquez/gattd)）。每当提交推送到该仓库时，GitHub
    Actions 可以尝试构建并发布容器镜像。
- en: Creating a Dockerfile
  id: totrans-194
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建 Dockerfile
- en: To run `gattd` inside a container, we first need a Dockerfile. Since `gattd`
    is a **Bluetooth Low Energy** (**BLE**) GATT server, it depends on working Bluetooth
    hardware and software being available at runtime. Fortunately, the Raspberry Pi
    4 comes with Bluetooth built in, so there is robust kernel support for BLE already
    in place. Our `gattd` container image needs to include the BlueZ software stack
    to take advantage of all this Bluetooth support. BlueZ in turn requires D-Bus
    so that must be included in our image as well. **D-Bus** is message-based middleware
    that enables communication between multiple processes running on the same computer.
    The *D* in D-Bus stands for *desktop* but servers also rely on it for inter-process
    communication. D-Bus supports both request-response and publish/subscribe messaging
    and is deeply integrated into `systemd`.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 要在容器内运行 `gattd`，首先需要一个 Dockerfile。由于 `gattd` 是一个 **蓝牙低能耗** (**BLE**) GATT 服务器，它依赖于在运行时可用的蓝牙硬件和软件。幸运的是，Raspberry
    Pi 4 内置了蓝牙，因此已经有了完善的内核支持来支持 BLE。我们的 `gattd` 容器镜像需要包含 BlueZ 软件栈，以便利用所有这些蓝牙支持。BlueZ
    又依赖于 D-Bus，因此它也必须包含在我们的镜像中。**D-Bus** 是一种基于消息的中间件，能够实现同一计算机上多个进程之间的通信。D-Bus 中的
    *D* 代表 *desktop*（桌面），但服务器也依赖它进行进程间通信。D-Bus 支持请求-响应和发布/订阅消息，并且与 `systemd` 深度集成。
- en: Since `gattd` is a Python application, the Dockerfile does not have a compilation
    step. The Python distribution is not compiled by Yocto. It is part of the underlying
    Linux distribution or base layer specified at the top of the Dockerfile. I chose
    Ubuntu as my base layer because Ubuntu LTS releases are tested thoroughly against
    real hardware like the Raspberry Pi 4.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 `gattd` 是一个 Python 应用，Dockerfile 中没有编译步骤。Python 发行版并不是通过 Yocto 编译的，而是 Dockerfile
    顶部指定的基础 Linux 发行版或基础层的一部分。我选择了 Ubuntu 作为我的基础层，因为 Ubuntu LTS 版本经过充分的实际硬件测试，比如 Raspberry
    Pi 4。
- en: Relying on Ubuntu for user space eliminates the need to build your own distro
    and perform all the testing that goes along with that. Why go through all the
    trouble of maintaining a Linux distro layer when Canonical already does that for
    you? Choosing Ubuntu saves precious development time. The rest of your software
    team does not need to get up to speed on Yocto or install the eSDK. Ubuntu is
    a known entity.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 依赖 Ubuntu 作为用户空间省去了构建自己发行版和进行所有相关测试的麻烦。既然 Canonical 已经为你做好了这件事，为什么还要费心维护一个 Linux
    发行版层呢？选择 Ubuntu 可以节省宝贵的开发时间。你的软件团队不需要再学习 Yocto 或安装 eSDK。Ubuntu 是一个成熟的系统。
- en: 'Here is the Dockerfile I committed to the root level of the `gattd` repo:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我提交到 `gattd` 仓库根目录的 Dockerfile：
- en: '[PRE40]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: '**Docker Official Images** (**DOI**) are hosted on Docker Hub. One of the primary
    goals of the DOI program is to publish container images for architectures other
    than amd64\. One of the architectures DOI supports is arm64v8, which is the ISA
    for the Raspberry Pi 4\. The Docker Hub `arm64v8` organization publishes and maintains
    scores of container images on behalf of the DOI program. These include official
    arm64v8 container images for Debian, Ubuntu, and Python. 24.04 was the most recent
    LTS release of Ubuntu when I wrote this Dockerfile.'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: '**Docker 官方镜像** (**DOI**) 托管在 Docker Hub 上。DOI 计划的主要目标之一是发布针对 amd64 以外架构的容器镜像。DOI
    支持的一个架构是 arm64v8，这是 Raspberry Pi 4 的指令集架构 (ISA)。Docker Hub 上的 `arm64v8` 组织代表 DOI
    计划发布和维护大量容器镜像，其中包括 Debian、Ubuntu 和 Python 的官方 arm64v8 容器镜像。当我编写这个 Dockerfile 时，24.04
    是最新的 Ubuntu LTS 版本。'
- en: The `gattd` application relies primarily on the Python standard library. The
    only other Python package dependencies are bindings for D-Bus and bindings for
    the GObject introspection libraries. These two packages do not justify an additional
    `pip install` step since there are Ubuntu packages readily available for both.
    Unlike JavaScript, which has a very limited standard library, Python ships with
    “batteries included” so your application may not need another package manager
    besides `apt`.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: '`gattd` 应用主要依赖于 Python 标准库。唯一的其他 Python 包依赖是 D-Bus 的绑定和 GObject introspection
    库的绑定。这两个包不需要额外的 `pip install` 步骤，因为 Ubuntu 上已有现成的包可用。与 JavaScript 不同，后者标准库非常有限，Python
    提供了“随附电池”功能，因此你的应用可能不需要除 `apt` 外的其他包管理器。'
- en: Remember that the `COPY` instruction copies source files from the Git repo into
    the container being built. I will talk about the `entrypoint.sh` script after
    I explain how container images are published for `gattd`.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，`COPY` 指令将源文件从 Git 仓库复制到正在构建的容器中。等我解释完 `gattd` 容器镜像的发布方式后，我会再讲解 `entrypoint.sh`
    脚本。
- en: Creating a GitHub Actions workflow
  id: totrans-203
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建 GitHub Actions 工作流
- en: GitHub Actions is the free CI/CD service offered by GitHub. GitHub Actions can
    build a container image and publish it to **GitHub Container Registry** (**GHCR**)
    whenever a change is pushed to the `gattd` repo. **GitHub Packages** is GitHub’s
    software package hosting service for software releases. GHCR is part of GitHub
    Packages so no additional steps are needed to access GHCR other than using a repo
    owned by you or your organization. I own the `gattd` repo, which I forked from
    [https://github.com/Jumperr-labs/python-gatt-server](https://github.com/Jumperr-labs/python-gatt-server).
    The Python code was written by Dan Shemesh and dates back to 2017.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: GitHub Actions 是 GitHub 提供的免费 CI/CD 服务。每当向 `gattd` 仓库推送更改时，GitHub Actions 可以构建容器镜像并将其发布到
    **GitHub 容器注册表**（**GHCR**）。**GitHub Packages** 是 GitHub 的软件包托管服务，用于软件发布。GHCR 是
    GitHub Packages 的一部分，因此除了使用属于你或你所在组织的仓库之外，访问 GHCR 不需要额外的步骤。我拥有 `gattd` 仓库，它是我从
    [https://github.com/Jumperr-labs/python-gatt-server](https://github.com/Jumperr-labs/python-gatt-server)
    叉出来的。Python 代码由 Dan Shemesh 编写，追溯到 2017 年。
- en: Like most CI/CD services, GitHub Actions workflows are defined as YAML files.
    The default workflow file is named `main.yml`. Changes to workflow files are committed
    to the `.github/workflows` directory of the repo. Since these files reside in
    version control along with the source code they build and deploy, workflow files
    constitute infrastructure as code.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 像大多数 CI/CD 服务一样，GitHub Actions 工作流是作为 YAML 文件定义的。默认的工作流文件名为 `main.yml`。对工作流文件的更改会被提交到仓库的
    `.github/workflows` 目录中。由于这些文件与它们构建和部署的源代码一起存储在版本控制中，因此工作流文件构成了基础设施即代码。
- en: 'Here are the contents of the `main.yml` workflow file I defined for the `gattd`
    repo:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是我为 `gattd` 仓库定义的 `main.yml` 工作流文件的内容：
- en: '[PRE41]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: This `main.yml` file is also included in the `Chapter16` folder of the book’s
    Git repo.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 该 `main.yml` 文件也包含在书籍 Git 仓库的 `Chapter16` 文件夹中。
- en: A simple three-step workflow is all that is needed to publish a container image
    to GHCR. The workflow is triggered every time a commit is pushed to the `master`
    branch of the repo.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 一个简单的三步工作流就足以将容器镜像发布到 GHCR。每当将提交推送到仓库的 `master` 分支时，工作流都会被触发。
- en: '**IMPORTANT NOTE**'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: '**重要提示**'
- en: Make sure to replace `master` with `main` in the `branches` list of your `main.yml`
    file when creating a GitHub Actions workflow for one of your own repos. Otherwise,
    the workflow will fail if no branch named `master` exists. Even though `main`
    is now the name of the default branch on GitHub, `master` is still the name of
    the default branch in Git when you create a new repository.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 在为你自己的仓库创建 GitHub Actions 工作流时，确保在 `main.yml` 文件的 `branches` 列表中将 `master` 替换为
    `main`。否则，如果没有名为 `master` 的分支，工作流将失败。尽管 `main` 现在是 GitHub 上默认分支的名称，但当你创建新仓库时，Git
    中的默认分支仍然是 `master`。
- en: 'Another point of interest is `runs-on: ubuntu-24.04-arm`, which instructs GitHub
    Actions to leverage arm64-hosted runners for this workflow. This means that any
    hosted runners GitHub spins up for this workflow will run on real 64-bit Arm CPU
    cores, eliminating the need for cross-compilation or emulation.'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: '另一个需要注意的点是 `runs-on: ubuntu-24.04-arm`，它指示 GitHub Actions 为此工作流使用 arm64 托管的运行器。这意味着
    GitHub 为此工作流启动的任何托管运行器都将在真实的 64 位 Arm CPU 核心上运行，从而无需进行交叉编译或仿真。'
- en: '*Step 3* of the workflow builds and pushes the container image defined by the
    repo’s Dockerfile. Notice that only `linux/arm64` is specified for `platforms`.
    The `platforms` element is for building multi-platform container images using
    Docker `buildx`. Docker `buildx` leverages QEMU to compile container images for
    non-native architectures, aka “platforms.” Since `gattd` is targeted at the Raspberry
    Pi 4, a container image only needs to be built for the native `linux/arm64` platform.
    Docker `buildx` is under active development. Learn more about the plugin and building
    multi-platform images at [https://github.com/docker/buildx](https://github.com/docker/buildx).'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 工作流的 *Step 3* 会构建并推送由仓库的 Dockerfile 定义的容器镜像。注意，`platforms` 只指定了 `linux/arm64`。`platforms`
    元素用于使用 Docker `buildx` 构建多平台容器镜像。Docker `buildx` 利用 QEMU 为非本地架构（即“平台”）编译容器镜像。由于
    `gattd` 针对 Raspberry Pi 4，因此只需要为本地的 `linux/arm64` 平台构建容器镜像。Docker `buildx` 正在积极开发中。了解更多关于该插件以及构建多平台镜像的信息，请访问
    [https://github.com/docker/buildx](https://github.com/docker/buildx)。
- en: 'To create a GitHub Actions workflow:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 创建 GitHub Actions 工作流：
- en: From your repo, click on the **Actions** icon in the top bar.
  id: totrans-215
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从你的仓库，点击顶部栏中的 **Actions** 图标。
- en: Below **Get started with GitHub Actions**, click **Skip this and set up a workflow
    yourself**.
  id: totrans-216
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 **Get started with GitHub Actions** 下，点击 **Skip this and set up a workflow
    yourself**。
- en: Paste the contents of `main.yml` into the **Edit** window.
  id: totrans-217
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`main.yml`的内容粘贴到**编辑**窗口中。
- en: Click the green **Commit changes...** button.
  id: totrans-218
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击绿色的**提交更改...**按钮。
- en: From the **Commit changes** dialog, click the green **Commit changes** button.
  id: totrans-219
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**提交更改**对话框中，点击绿色的**提交更改**按钮。
- en: '![Figure 16.1 – Commit changes](img/B18466_16_01.png)'
  id: totrans-220
  prefs: []
  type: TYPE_IMG
  zh: '![图16.1 – 提交更改](img/B18466_16_01.png)'
- en: Figure 16.1 – Commit changes
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 图16.1 – 提交更改
- en: Clicking the green **Commit changes** button triggers the GitHub Actions workflow.
    GitHub then spins up a hosted runner to build the repo’s Dockerfile and push any
    resulting container image to GHCR. If everything goes as planned, you will see
    a status of **Success** for the commit and a white check mark inside of a green
    circle next to the **build-and-push** job. This workflow took 58 seconds to complete
    the first time I ran it and now triggers every time a commit is pushed to the
    `master` branch.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 点击绿色的**提交更改**按钮会触发GitHub Actions工作流。GitHub随后会启动一个托管运行器来构建仓库的Dockerfile，并将任何生成的容器镜像推送到GHCR。如果一切顺利，你会看到提交的状态为**成功**，并且在**构建并推送**任务旁边会有一个绿色圆圈中的白色勾号。这项工作流我第一次运行时花了58秒，现在每当提交推送到`master`分支时都会触发。
- en: Pulling and running the latest image
  id: totrans-223
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 拉取并运行最新镜像
- en: Docker needs space to write the container images that it pulls. Most embedded
    Linux filesystems are either read-only or too small to store container images
    like `gattd:latest`. That is why you want to install a general-purpose Linux distribution
    like Ubuntu Server on your Raspberry Pi 4 for this exercise. The easiest way to
    do that is with the official Raspberry Pi Imager available from raspberrypi.org.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: Docker需要空间来写入它拉取的容器镜像。大多数嵌入式Linux文件系统要么是只读的，要么太小，无法存储像`gattd:latest`这样的容器镜像。这就是为什么你需要在树莓派
    4上安装一个通用的Linux发行版，比如Ubuntu Server，以便进行本练习。最简单的方法是使用来自raspberrypi.org的官方树莓派映像工具。
- en: First, download and install the Raspberry Pi Imager onto your Linux host. Directions
    on how to do that can be found online at raspberrypi.com.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，将树莓派映像工具下载并安装到你的Linux主机。有关如何操作的说明可以在raspberrypi.com上找到。
- en: 'To download and install Ubuntu Server onto a microSD card:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 要将Ubuntu Server下载并安装到microSD卡：
- en: Insert a microSD card into your Linux host machine.
  id: totrans-227
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将microSD卡插入你的Linux主机。
- en: Launch Raspberry Pi Imager.
  id: totrans-228
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 启动树莓派映像工具。
- en: Select **Raspberry Pi 4** as your **Raspberry Pi Device**.
  id: totrans-229
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择**树莓派 4**作为你的**树莓派设备**。
- en: Select **Other general-purpose OS** as your operating system.
  id: totrans-230
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择**其他通用操作系统**作为你的操作系统。
- en: From the **Operating System** menu, select **Ubuntu**.
  id: totrans-231
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**操作系统**菜单中，选择**Ubuntu**。
- en: Then select **Ubuntu Server 24.04.1 LTS** (64-bit) or the closest available
    equivalent.
  id: totrans-232
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后选择**Ubuntu Server 24.04.1 LTS**（64位）或最接近的可用版本。
- en: Click the **Edit Settings** button when asked **Would you like to apply OS customization
    settings?**
  id: totrans-233
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当询问**是否应用操作系统自定义设置？**时，点击**编辑设置**按钮。
- en: 'Enter a username and password on the **GENERAL** page as shown:'
  id: totrans-234
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如图所示，在**一般设置**页面输入用户名和密码：
- en: '![Figure 16.2 – GENERAL](img/B18466_16_02.png)'
  id: totrans-235
  prefs: []
  type: TYPE_IMG
  zh: '![图16.2 – 一般设置](img/B18466_16_02.png)'
- en: Figure 16.2 – GENERAL
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 图16.2 – 一般设置
- en: Replace `frank` with your desired username.
  id: totrans-237
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`frank`替换为你想要的用户名。
- en: 'Check **Enable SSH** on the **SERVICES** page as shown:'
  id: totrans-238
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**服务**页面勾选**启用 SSH**，如图所示：
- en: '![Figure 16.3 – SERVICES](img/B18466_16_03.png)'
  id: totrans-239
  prefs: []
  type: TYPE_IMG
  zh: '![图16.3 – 服务](img/B18466_16_03.png)'
- en: Figure 16.3 – SERVICES
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 图16.3 – 服务
- en: Click the red **SAVE** button.
  id: totrans-241
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击红色的**保存**按钮。
- en: Select the microSD card as your storage.
  id: totrans-242
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择microSD卡作为存储设备。
- en: Write the Ubuntu Server image to the microSD card. This takes several minutes
    because Raspberry Pi Imager formats all the available space on the microSD card.
  id: totrans-243
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将Ubuntu Server镜像写入microSD卡。由于树莓派映像工具会格式化microSD卡上的所有可用空间，这个过程需要几分钟时间。
- en: Eject the microSD card when Raspberry Pi Imager is done writing.
  id: totrans-244
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在树莓派映像工具完成写入后，弹出microSD卡。
- en: Insert the microSD card into your Raspberry Pi 4.
  id: totrans-245
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将microSD卡插入你的树莓派 4。
- en: Apply power to the Raspberry Pi 4 by way of its USB-C port.
  id: totrans-246
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过USB-C端口为树莓派 4供电。
- en: 'To SSH into the Raspberry Pi 4:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 要通过SSH连接到树莓派 4：
- en: '[PRE42]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: Replace `<username>` with the username for the account you created when installing
    Ubuntu Server. Log in with the password you created with that account when prompted.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 将`<username>`替换为你在安装Ubuntu Server时创建的账户用户名。登录时，使用该账户创建的密码。
- en: 'To install and configure Docker on the Raspberry Pi 4:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 要在树莓派 4上安装并配置Docker：
- en: 'Update the package metadata:'
  id: totrans-251
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更新软件包元数据：
- en: '[PRE43]'
  id: totrans-252
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Install the Docker daemon:'
  id: totrans-253
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 安装Docker守护进程：
- en: '[PRE44]'
  id: totrans-254
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Configure the system to start the Docker daemon on power up:'
  id: totrans-255
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 配置系统在启动时启动Docker守护进程：
- en: '[PRE45]'
  id: totrans-256
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Add the user to the `Docker` group:'
  id: totrans-257
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将用户添加到`Docker`组：
- en: '[PRE46]'
  id: totrans-258
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE46]'
- en: Replace `<frank>` with the username for the account you created when installing
    Ubuntu Server.
  id: totrans-259
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 用你在安装 Ubuntu Server 时创建的账户用户名替换 `<frank>`。
- en: 'Restart the Docker daemon:'
  id: totrans-260
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 重启 Docker 守护进程：
- en: '[PRE47]'
  id: totrans-261
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Close the session:'
  id: totrans-262
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 关闭会话：
- en: '[PRE48]'
  id: totrans-263
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE48]'
- en: SSH into the Raspberry Pi 4 again.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 再次通过 SSH 连接到 Raspberry Pi 4。
- en: 'To pull the latest `gattd` container image from GHCR:'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 从 GHCR 拉取最新的 `gattd` 容器镜像：
- en: '[PRE49]'
  id: totrans-266
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'To run the latest `gattd` container image:'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 要运行最新的 `gattd` 容器镜像：
- en: '[PRE50]'
  id: totrans-268
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'Here is the `entrypoint.sh` script that executes when the `gattd` container
    image is run:'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 这是当运行 `gattd` 容器镜像时执行的 `entrypoint.sh` 脚本：
- en: '[PRE51]'
  id: totrans-270
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: This `entrypoint.sh` file comes from a Medium blog post that Thomas Huffert
    wrote on how to run containerized Bluetooth applications with BlueZ. A link to
    his original post is included in the *Further study* section at the end of the
    chapter.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 这个 `entrypoint.sh` 文件来自 Thomas Huffert 在 Medium 上写的一篇博文，内容是如何使用 BlueZ 运行容器化的蓝牙应用程序。链接到他的原始文章包含在本章结尾的
    *进一步学习* 部分。
- en: Adding Docker to a Yocto image
  id: totrans-272
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将 Docker 添加到 Yocto 镜像
- en: We don’t need to install Ubuntu on a Raspberry Pi 4 to take advantage of Docker.
    Buildroot and Yocto are both able to build Docker for embedded targets. Adding
    Docker to a Yocto image is straightforward. Simply append the package to an existing
    image. We will leverage the `rpi-test-image` from the *Building on top of an existing
    BSP* section of [*Chapter 7*](Chapter_05.xhtml#_idTextAnchor151).
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不需要在 Raspberry Pi 4 上安装 Ubuntu 就能利用 Docker。Buildroot 和 Yocto 都能够为嵌入式目标构建 Docker。将
    Docker 添加到 Yocto 镜像是非常简单的。只需将软件包附加到现有镜像中即可。我们将利用 [*第7章*](Chapter_05.xhtml#_idTextAnchor151)中
    *在现有BSP基础上构建* 部分的 `rpi-test-image`。
- en: Adding the meta-virtualization layer
  id: totrans-274
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 添加 `meta-virtualization` 层
- en: Yocto’s `meta-virtualization` layer contains recipes to enable support for cloud
    tooling. Over time, the project’s emphasis has moved away from virtualization
    technologies like Xen, KVM, and libvirt to more popular containerization tools.
    Bruce Ashfield has led the maintenance of `meta-virtualization` for more than
    a decade, working tirelessly to stay abreast of the latest innovations in cloud
    computing.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: Yocto 的 `meta-virtualization` 层包含启用云工具支持的配方。随着时间的推移，项目的重点已经从虚拟化技术（如 Xen、KVM
    和 libvirt）转向了更受欢迎的容器化工具。Bruce Ashfield 已经领导了 `meta-virtualization` 的维护超过十年，致力于跟上云计算领域的最新创新。
- en: There are so many competing containerization tools to choose from, it’s hard
    to know where to start. The `meta-virtualization` layer is agnostic with respect
    to the choice of container runtime in that Docker, Podman, containerd, and Kubernetes
    are all fully supported. I made the conscious decision to focus on Docker because
    it remains the most popular tool for deploying container images.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 选择容器化工具时，有如此多的竞争者，很难知道从哪里开始。`meta-virtualization` 层对于容器运行时的选择是中立的，Docker、Podman、containerd
    和 Kubernetes 都得到完全支持。我决定专注于 Docker，因为它仍然是部署容器镜像的最流行工具。
- en: The following exercises assume you have already completed the *Building an existing
    BSP* exercise from [*Chapter 7*](Chapter_05.xhtml#_idTextAnchor151) and the directory
    where `poky` was cloned is in your home directory.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 以下练习假设你已经完成了 [*第7章*](Chapter_05.xhtml#_idTextAnchor151)中 *构建现有BSP* 的练习，并且 `poky`
    克隆的目录位于你的主目录中。
- en: 'To add the `meta-virtualization` layer:'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 要添加 `meta-virtualization` 层：
- en: 'First, navigate one level above the directory where you cloned `poky`:'
  id: totrans-279
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，导航到克隆 `poky` 的目录上一级：
- en: '[PRE52]'
  id: totrans-280
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'Next, set up your BitBake work environment:'
  id: totrans-281
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，设置你的 BitBake 工作环境：
- en: '[PRE53]'
  id: totrans-282
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE53]'
- en: This sets up a bunch of environment variables and puts you back in the `build-rpi`
    directory where you previously built `rpi-test-image`.
  id: totrans-283
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 该脚本设置了一些环境变量，并将你带回之前构建 `rpi-test-image` 的 `build-rpi` 目录。
- en: 'Then, add the `meta-virtualization` layer to your image:'
  id: totrans-284
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，将 `meta-virtualization` 层添加到你的镜像中：
- en: '[PRE54]'
  id: totrans-285
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE54]'
- en: This command will clone the `meta-virtualization` layer and all its dependency
    layers into your home directory.
  id: totrans-286
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 该命令将克隆 `meta-virtualization` 层及其所有依赖层到你的主目录。
- en: 'Verify that all the necessary layers have been added to the image:'
  id: totrans-287
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 验证所有必要的层是否已被添加到镜像中：
- en: '[PRE55]'
  id: totrans-288
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'The output of the command should look like this:'
  id: totrans-289
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 命令的输出应该如下所示：
- en: '[PRE56]'
  id: totrans-290
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE56]'
- en: If your output is missing layers from `meta-raspberrypi` upwards, then return
    to [*Chapter 7*](Chapter_05.xhtml#_idTextAnchor151)and repeat the *Building an
    existing BSP* exercise before reattempting to add the `meta-virtualization` layer.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你的输出缺少 `meta-raspberrypi` 层及以上层次的内容，则返回到 [*第7章*](Chapter_05.xhtml#_idTextAnchor151)，重复
    *构建现有BSP* 练习，然后再试添加 `meta-virtualization` 层。
- en: Installing Docker
  id: totrans-292
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 安装 Docker
- en: The `meta-virtualization` layer contains the recipes needed to build and install
    Docker. Once the layer has been added, we can then append the `docker` package
    to a Yocto image. There are several ways to achieve this goal, including creating
    a custom image recipe or distro layer. I chose to piggyback on top of `rpi-test-image`
    and modify the `conf/local.conf` file in the `build-rpi` directory. I did this
    solely for expediency. Changing `conf/local.conf` is not maintainable.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: '`meta-virtualization`层包含了构建和安装Docker所需的配方。一旦该层被添加，我们可以将`docker`包追加到Yocto镜像中。有多种方法可以实现这一目标，包括创建自定义镜像配方或发行版层。我选择在`rpi-test-image`的基础上进行修改，并在`build-rpi`目录中的`conf/local.conf`文件进行更改。这样做纯粹是为了方便。修改`conf/local.conf`并不是一种可维护的方式。'
- en: The Docker daemon relies on SSL certificates to verify the authenticity of image
    registries. SSL certificates have set lifespans, so some measure of accurate time
    is needed. Most computers update their system clocks on startup according to time
    received from the internet via **Network Time Protocol** (**NTP**). So, not only
    do you need to install Docker on your target, but you also need some way to synchronize
    the system clock before you can pull a container image.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: Docker守护进程依赖SSL证书来验证镜像注册表的真实性。SSL证书有设定的有效期限，因此需要某种准确的时间源。大多数计算机在启动时会根据从互联网获取的**网络时间协议**（**NTP**）来更新系统时钟。因此，除了需要在目标设备上安装Docker之外，你还需要一种同步系统时钟的方式，才能拉取容器镜像。
- en: 'To install Docker on `rpi-test-image`:'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 在`rpi-test-image`上安装Docker：
- en: 'Add the following line to your `conf/local.conf` file:'
  id: totrans-296
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将以下行添加到你的`conf/local.conf`文件中：
- en: '[PRE57]'
  id: totrans-297
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'Add the following lines to your `conf/local.conf` file:'
  id: totrans-298
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将以下行添加到你的`conf/local.conf`文件中：
- en: '[PRE58]'
  id: totrans-299
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'Build the image:'
  id: totrans-300
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 构建镜像：
- en: '[PRE59]'
  id: totrans-301
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE59]'
- en: '*Step 2* creates a group named `docker` and adds the `root` user to that group.
    This allows us to run Docker commands when we log in as `root`. The `rpi-test-image`
    permits `root` logins via SSH. There is no password required. This image is for
    demonstration only.'
  id: totrans-302
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '*第2步*创建了一个名为`docker`的组，并将`root`用户添加到该组中。这样，我们就可以在以`root`身份登录时运行Docker命令。`rpi-test-image`允许通过SSH进行`root`登录，无需密码。此镜像仅用于演示。'
- en: 'Once the image has finished building, there should be a file named `rpi-test-image-raspberrypi4-64.rootfs.wic.bz2`
    in the `tmp/deploy/images/raspberrypi4-64` directory. Write that image to a microSD
    card using Etcher and boot it on your Raspberry Pi 4:'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦镜像构建完成，`tmp/deploy/images/raspberrypi4-64`目录中应该会有一个名为`rpi-test-image-raspberrypi4-64.rootfs.wic.bz2`的文件。使用Etcher将该镜像写入microSD卡，并将其在你的Raspberry
    Pi 4上启动：
- en: Insert a microSD card into your host machine.
  id: totrans-304
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将microSD卡插入主机。
- en: Launch Etcher.
  id: totrans-305
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 启动Etcher。
- en: Click **Flash from file** from Etcher.
  id: totrans-306
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Etcher中点击**Flash from file**。
- en: Locate the `wic.bz2` image that you built for the Raspberry Pi 4 and open it.
  id: totrans-307
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定位到你为Raspberry Pi 4构建的`wic.bz2`镜像并打开它。
- en: Click **Select target** from Etcher.
  id: totrans-308
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Etcher中点击**Select target**。
- en: Select the microSD card that you inserted in *step 1*.
  id: totrans-309
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择你在*第1步*中插入的microSD卡。
- en: Click **Flash** from Etcher to write the image.
  id: totrans-310
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Etcher中点击**Flash**以写入镜像。
- en: Eject the microSD card when Etcher is done flashing.
  id: totrans-311
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当Etcher完成闪存写入时，弹出microSD卡。
- en: Insert the microSD card into your Raspberry Pi 4.
  id: totrans-312
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将microSD卡插入你的Raspberry Pi 4。
- en: Apply power to the Raspberry Pi 4 by way of its USB-C port.
  id: totrans-313
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过Raspberry Pi 4的USB-C端口为其供电。
- en: Confirm that your Pi 4 booted successfully by plugging it into your Ethernet
    and observing that the network activity lights blink.
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 通过将Raspberry Pi 4连接到以太网，并观察网络活动灯是否闪烁，来确认Pi 4是否成功启动。
- en: Verifying the Docker daemon is running
  id: totrans-315
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 验证Docker守护进程是否在运行
- en: 'In the previous exercise, we built a bootable image for the Raspberry Pi 4
    that includes Docker. Now that the device has booted and connected to your local
    network via Ethernet, let’s verify the Docker daemon is running. Follow these
    steps:'
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一个练习中，我们为Raspberry Pi 4构建了一个包含Docker的可启动镜像。现在设备已经启动并通过以太网连接到本地网络，接下来我们来验证Docker守护进程是否在运行。请按以下步骤操作：
- en: 'The image we built has a hostname of `raspberrypi4-64`, so you should be able
    to SSH into the device as `root`:'
  id: totrans-317
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们构建的镜像的主机名为`raspberrypi4-64`，所以你应该可以通过SSH以`root`身份登录到设备：
- en: '[PRE60]'
  id: totrans-318
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE60]'
- en: Enter `yes` when asked if you want to continue connecting. You will not be prompted
    for a password. If no host is found at `raspberrypi4-64.local`, use a tool such
    as `arp-scan` to locate the IP address of your Raspberry Pi 4 and SSH into that
    instead of doing so by hostname.
  id: totrans-319
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在系统提示是否继续连接时输入`yes`。不会提示输入密码。如果在`raspberrypi4-64.local`没有找到主机，可以使用`arp-scan`等工具定位你的Raspberry
    Pi 4的IP地址，然后通过该IP地址SSH连接，而不是通过主机名连接。
- en: 'To list information about the version of Docker that is running:'
  id: totrans-320
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 列出当前正在运行的Docker版本信息：
- en: '[PRE61]'
  id: totrans-321
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'To update the system clock:'
  id: totrans-322
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更新系统时钟：
- en: '[PRE62]'
  id: totrans-323
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'To pull and run a `hello-world` container image:'
  id: totrans-324
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 拉取并运行`hello-world`容器镜像：
- en: '[PRE63]'
  id: totrans-325
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE63]'
- en: Most modern Linux distributions rely on `systemd-timesyncd` to update the system
    clock automatically. This eliminates the need to install and run `ntp-utils`.
    Yocto’s Poky reference distro defaults to SysVinit as its init system. To take
    advantage of `systemd-timesyncd`, we need to switch from SysVinit to `systemd`
    for startup. If you want to use systemd with Poky, then select `"poky-altcfg"`
    as your distro in `conf/local.conf`.
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数现代Linux发行版依赖于`systemd-timesyncd`来自动更新系统时钟。这消除了安装和运行`ntp-utils`的需要。Yocto的Poky参考发行版默认使用SysVinit作为其初始化系统。为了利用`systemd-timesyncd`，我们需要将启动系统从SysVinit切换到`systemd`。如果你希望在Poky中使用systemd，请在`conf/local.conf`中选择`"poky-altcfg"`作为你的发行版配置。
- en: There are more reasons to switch from `SysVinit` to `systemd` than just time
    synchronization. Since it was designed for process supervision, `systemd` is well-suited
    to monitoring microservices. A microservice is typically deployed as a container.
    It makes sense to use `systemd` together with Docker to start, stop, and restart
    containers on a Linux system. Alternatively, you can also use Docker Compose to
    run multi-container applications, but that requires adding another tool to your
    Yocto image.
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 从`SysVinit`切换到`systemd`的原因不仅仅是为了时间同步。由于`systemd`是为进程监控而设计的，因此它非常适合监控微服务。微服务通常以容器的形式部署。将`systemd`与Docker结合使用来启动、停止和重启Linux系统上的容器是有意义的。或者，你也可以使用Docker
    Compose来运行多容器应用，但这需要在你的Yocto镜像中添加另一个工具。
- en: Updating software with Docker
  id: totrans-328
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Docker更新软件
- en: Balena uses Docker containers to deploy software updates. Devices run balenaOS,
    a Yocto-based Linux distribution that comes with balenaEngine, balena’s Docker-compatible
    container engine. OTA updates occur automatically by way of releases pushed from
    balenaCloud, a hosted service for managing fleets of devices. Balena can also
    operate in **local mode** so that updates originate from a server running on your
    local host machine rather than the cloud. We will stick to local mode for the
    following exercises.
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: Balena使用Docker容器来部署软件更新。设备运行balenaOS，这是一个基于Yocto的Linux发行版，内置有balenaEngine，这是balena兼容Docker的容器引擎。OTA更新会通过balenaCloud自动推送，balenaCloud是一个托管服务，用于管理设备的队列。Balena也可以在**本地模式**下操作，这样更新就来自于你本地主机上运行的服务器，而不是来自云端。我们将在接下来的练习中坚持使用本地模式。
- en: Balena is written and supported by balena.io ([https://balena.io](https://balena.io)).
    Like Mender, balenaCloud is a paid OTA update service. Your first ten devices
    are free, but you must adopt a monthly or yearly billing plan for anything beyond
    that. There is much more information about the software in the **Reference** section
    of the online docs at balena.io. We won’t dig into how balena works since our
    goal is to deploy and automatically update software on a small fleet of devices
    for fast development.
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: Balena由balena.io编写和支持（[https://balena.io](https://balena.io)）。与Mender类似，balenaCloud是一个付费的OTA更新服务。前十台设备免费，但如果超过此数量，你必须选择按月或按年计费的计划。关于该软件的更多信息，可以在balena.io的**参考**部分找到在线文档。由于我们的目标是部署并自动更新少量设备的软件以加速开发，因此我们不会深入探讨balena的工作原理。
- en: Balena provides prebuilt balenaOS images for popular dev boards such as the
    Raspberry Pi 4 and BeaglePlay. Downloading these images requires a balenaCloud
    account.
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: Balena为流行的开发板（如Raspberry Pi 4和BeaglePlay）提供了预构建的balenaOS镜像。下载这些镜像需要一个balenaCloud账户。
- en: Creating an account
  id: totrans-332
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建账户
- en: 'The first thing you need to do even if you only intend to operate in local
    mode is to sign up for a balenaCloud account. You do this by visiting [https://dashboard.balenacloud.com/signup](https://dashboard.balenacloud.com/signup)
    and entering your email address and a password, as shown:'
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 即使你只打算在本地模式下操作，首先需要做的就是注册一个balenaCloud账户。你可以通过访问[https://dashboard.balenacloud.com/signup](https://dashboard.balenacloud.com/signup)并输入你的电子邮件地址和密码来完成注册，如下所示：
- en: '![Figure 16.4 – balenaCloud signup](img/B18466_16_04.png)'
  id: totrans-334
  prefs: []
  type: TYPE_IMG
  zh: '![图16.4 – balenaCloud注册](img/B18466_16_04.png)'
- en: Figure 16.4 – balenaCloud signup
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 图16.4 – balenaCloud注册
- en: Click the **Submit** button to submit the form and once it is done processing,
    you will be prompted to enter your profile details. You may choose to skip this
    form, at which point you will enter the **balenaCloud** dashboard under your new
    account.
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 点击**提交**按钮提交表单，处理完成后，你将被提示输入个人资料信息。你也可以选择跳过此表单，届时你将进入**balenaCloud**仪表盘，使用新账户查看。
- en: If you sign out or your session expires, you can log back in to the dashboard
    by navigating to [https://dashboard.balena-cloud.com/login](https://dashboard.balena-cloud.com/login)
    and entering the email address and password you signed up with.
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您退出登录或会话过期，您可以通过导航到[https://dashboard.balena-cloud.com/login](https://dashboard.balena-cloud.com/login)，并输入您注册时使用的电子邮件地址和密码，重新登录到仪表板。
- en: Creating an application
  id: totrans-338
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建应用程序
- en: Before we can add a Raspberry Pi 4 to a balenaCloud account, we first need to
    create a fleet.
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们将 Raspberry Pi 4 添加到 balenaCloud 帐户之前，我们首先需要创建一个舰队。
- en: '![Figure 16.5 – Create fleet](img/B18466_16_05.png)'
  id: totrans-340
  prefs: []
  type: TYPE_IMG
  zh: '![图 16.5 – 创建舰队](img/B18466_16_05.png)'
- en: Figure 16.5 – Create fleet
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 图 16.5 – 创建舰队
- en: 'Here are the steps for creating a fleet for the Raspberry Pi 4 on balenaCloud:'
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是在 balenaCloud 上为 Raspberry Pi 4 创建舰队的步骤：
- en: Log in to the **balenaCloud** dashboard with your email address and password.
  id: totrans-343
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用您的电子邮件地址和密码登录**balenaCloud**仪表板。
- en: Click on the **Create fleet** button in the upper-left corner, next to **Fleets**,
    to open the **Create fleet** dialog.
  id: totrans-344
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击位于左上角的**创建舰队**按钮，在**舰队**旁边，打开**创建舰队**对话框。
- en: Enter a name for your new fleet and select **Raspberry Pi 4 (using 64bit OS)**
    for **Default device type**.
  id: totrans-345
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为新舰队输入名称，并选择**Raspberry Pi 4 (使用 64 位操作系统)**作为**默认设备类型**。
- en: Click on the **Create new fleet** button in the **Create fleet** dialog to submit
    the form.
  id: totrans-346
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击**创建新舰队**按钮在**创建舰队**对话框中提交表单。
- en: Your new fleet should appear in the **balenaCloud** dashboard on the **Fleets**
    page.
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 新的舰队应该出现在**balenaCloud**仪表板的**舰队**页面上。
- en: Adding a device
  id: totrans-348
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 添加设备
- en: 'Now that we have a fleet on balenaCloud, let’s add a Raspberry Pi 4 to it:'
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们在 balenaCloud 上有了一个舰队，让我们向其中添加一个 Raspberry Pi 4：
- en: Log in to the **balenaCloud** dashboard with your email address and password.
  id: totrans-350
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用您的电子邮件地址和密码登录**balenaCloud**仪表板。
- en: Click on the new fleet we created.
  id: totrans-351
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击我们创建的新舰队。
- en: Click on the **Add device** button from the fleet **Summary** page.
  id: totrans-352
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在舰队**摘要**页面上点击**添加设备**按钮。
- en: Clicking on the button will bring up the **Add new device** dialog.
  id: totrans-353
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击按钮会弹出**添加新设备**对话框。
- en: Ensure that **Raspberry Pi 4 (using 64bit OS)** is the selected device type.
    That option should already be selected since you created the application with
    **Raspberry Pi 4 (using 64bit OS)** as the default device type.
  id: totrans-354
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确保选择的设备类型为**Raspberry Pi 4 (使用 64 位操作系统)**。由于您已将应用程序创建为**Raspberry Pi 4 (使用
    64 位操作系统)**作为默认设备类型，因此应已选择该选项。
- en: Ensure that **balenaOS** is the selected OS.
  id: totrans-355
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确保选择的操作系统为**balenaOS**。
- en: Ensure that the selected version of balenaOS is the latest. That option should
    already be selected since **Add new device** defaults to the latest available
    version of balenaOS, which it designates as **RECOMMENDED**.
  id: totrans-356
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确保选择的 balenaOS 版本是最新的。由于**添加新设备**默认为最新可用版本的 balenaOS，并将其标记为**推荐**，所以应该已经选择了该选项。
- en: Select **Development** as the edition of balenaOS. A development image is required
    to enable local mode for better testing and troubleshooting.
  id: totrans-357
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将**开发**选为 balenaOS 的版本。需要开发映像以启用更好的测试和故障排除的本地模式。
- en: '![Figure 16.6 – Add new device](img/B18466_16_06.png)'
  id: totrans-358
  prefs: []
  type: TYPE_IMG
  zh: '![图 16.6 – 添加新设备](img/B18466_16_06.png)'
- en: Figure 16.6 – Add new device
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 图 16.6 – 添加新设备
- en: Select **Wifi + Ethernet** for **Network**. You could choose **Ethernet only**
    but auto-connecting to Wi-Fi is a very convenient feature.
  id: totrans-360
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择**Wifi + Ethernet**作为**网络**。您也可以选择**仅以太网**，但自动连接到 Wi-Fi 是一个非常方便的功能。
- en: 'Enter your Wi-Fi router’s SSID and passphrase in their respective fields. Replace
    **ATTCXR2Xjn** in the following screenshot with your Wi-Fi router’s SSID:'
  id: totrans-361
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在相应的字段中输入您的 Wi-Fi 路由器的 SSID 和密码。请在以下截图中用您的 Wi-Fi 路由器的 SSID 替换**ATTCXR2Xjn**：
- en: '![Figure 16.7 – Wifi + Ethernet](img/B18466_16_07.png)'
  id: totrans-362
  prefs: []
  type: TYPE_IMG
  zh: '![图 16.7 – Wifi + Ethernet](img/B18466_16_07.png)'
- en: Figure 16.7 – Wifi + Ethernet
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: 图 16.7 – Wifi + Ethernet
- en: Click the down arrow on the **Flash** button.
  id: totrans-364
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击**Flash**按钮上的下箭头。
- en: Save the zipped image file to your host machine.
  id: totrans-365
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将压缩的镜像文件保存到您的主机上。
- en: We now have a microSD card image we can use to provision any number of Raspberry
    Pi 4s for your test fleet.
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有一个 microSD 卡镜像可以用来为您的测试舰队中的任意数量的 Raspberry Pi 4 进行配置。
- en: The steps for provisioning a Raspberry Pi 4 from your host machine should be
    familiar by now. Locate the balenaOS `img.zip` file that you downloaded from balenaCloud
    and use Etcher to write it to a microSD card. Insert the microSD card into your
    Raspberry Pi 4 and power it up by way of the USB-C port.
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: 从您的主机机器为 Raspberry Pi 4 配置舰队的步骤现在应该已经很熟悉了。找到从 balenaCloud 下载的 balenaOS `img.zip`
    文件，并使用 Etcher 将其写入 microSD 卡。将 microSD 卡插入 Raspberry Pi 4，并通过 USB-C 端口上电。
- en: 'It will take a minute or two for the Raspberry Pi 4 to appear on the **Devices**
    page of your balenaCloud dashboard:'
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 16.8 – Devices](img/B18466_16_08.png)'
  id: totrans-369
  prefs: []
  type: TYPE_IMG
- en: Figure 16.8 – Devices
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have connected a Raspberry Pi 4 to a balena application, we need
    to enable local mode so that we can deploy OTA updates to it from a nearby host
    machine rather than the cloud:'
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
- en: Click on your target Raspberry Pi 4 from the **Devices** page of your balenaCloud
    dashboard. My device is named **evil-tree**. Yours will have a different name.
  id: totrans-372
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click on **Settings** for your Raspberry Pi 4.
  id: totrans-373
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Enable **Local mode** from the **Settings** page:'
  id: totrans-374
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 16.9 – Enable local mode](img/B18466_16_09.png)'
  id: totrans-375
  prefs: []
  type: TYPE_IMG
- en: Figure 16.9 – Enable local mode
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
- en: Once local mode is enabled, the **Logs** panel is no longer available on the
    device **Summary** page.
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
- en: With local mode now enabled on our target device, we are almost ready to deploy
    some code to it. Before we can do that, we need to install the balena CLI.
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
- en: Installing the CLI
  id: totrans-379
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Here are the instructions for installing the balena CLI on a Linux host machine:'
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
- en: Open a web browser and navigate to the latest balena CLI release page at [https://github.com/balena-io/balena-cli/releases/latest](https://github.com/balena-io/balena-cli/releases/latest).
  id: totrans-381
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click on the latest ZIP file for Linux to download it. Look for a filename of
    the form `balena-cli-vX.Y.Z-linux-x64-standalone.zip`, substituting major, minor,
    and patch version numbers for X, Y, and Z.
  id: totrans-382
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Extract the ZIP file contents to your home directory:'
  id: totrans-383
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE64]'
  id: totrans-384
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE64]'
- en: The extracted contents are enclosed in a `balena-cli` directory.
  id: totrans-385
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add the `balena-cli` directory to your `PATH` environment variable:'
  id: totrans-386
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE65]'
  id: totrans-387
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE65]'
- en: Add a line like this to the `.bashrc` file in your home directory if you want
    these changes to your `PATH` variable to persist.
  id: totrans-388
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Verify that the installation was successful:'
  id: totrans-389
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE66]'
  id: totrans-390
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE66]'
- en: The latest version of the balena CLI at the time of writing was 20.2.9.
  id: totrans-391
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now that we have a working balena CLI, let’s scan the local network for the
    Raspberry Pi 4 we provisioned:'
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  id: totrans-393
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: Notice the hostname of `bf04eba.local` and the IP address of `192.168.1.83`
    in the scan output. The hostname and IP address of your Raspberry Pi 4 will vary.
    Record these two pieces of information because we will need them for the remaining
    exercises.
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
- en: Pushing a project
  id: totrans-395
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let’s push a Python project to the Raspberry Pi over the local network:'
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
- en: 'Clone a project for a simple “Hello World!” Python web server:'
  id: totrans-397
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE68]'
  id: totrans-398
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'Navigate into the project directory:'
  id: totrans-399
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE69]'
  id: totrans-400
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'Push the code to your Raspberry Pi 4:'
  id: totrans-401
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE70]'
  id: totrans-402
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE70]'
- en: Substitute your device’s IP address for the `192.168.1.183` argument.
  id: totrans-403
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Wait for the Docker image to finish building and starting and let the application
    run in the foreground so that it logs to `stdout`.
  id: totrans-404
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Issue a request to the web server at `http://192.168.1.183` from a web browser.
    Substitute your device’s IP address for `192.168.1.183`.
  id: totrans-405
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The web server running on the Raspberry Pi 4 should display a splash page with
    **Welcome to balena** and a line like the following should appear in the live
    output from `balena push`:'
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  id: totrans-407
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: The IP address in the log entry should be that of the machine from which you
    issued the web request. A new log entry should appear every time you refresh the
    web page. To stop tailing the logs and return to the shell, enter *Ctrl + C*.
    The container will continue running on the target device and the web server will
    continue to service requests.
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
- en: 'We can restart tailing the logs at any time by issuing the following command:'
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  id: totrans-410
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: Substitute your device’s IP address for the `192.168.1.183` argument.
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
- en: 'The HTML for this simple web server can be found in a file named `index.html`
    within the project directory:'
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  id: totrans-413
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: 'Now let’s make a slight modification to the project source code and redeploy:'
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
- en: Open `views/index.html` in your favorite editor.
  id: totrans-415
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Replace `Welcome to balena!` with `Welcome to banana!` and save your changes.
  id: totrans-416
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The following `git diff` output captures the changes:'
  id: totrans-417
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE74]'
  id: totrans-418
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE74]'
- en: 'Push the new code to your Raspberry Pi 4:'
  id: totrans-419
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE75]'
  id: totrans-420
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE75]'
- en: Substitute your device’s IP address for the `192.168.1.183` argument.
  id: totrans-421
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Wait for the Docker image to update. The process should be much quicker this
    time around because of an intelligent caching feature called **Livepush** that
    is unique to local mode.
  id: totrans-422
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Issue a request to the web server at `http://192.168.1.183` from a web browser.
    Substitute your device’s IP address for `192.168.1.183`.
  id: totrans-423
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The web server running on the Raspberry Pi 4 should display **Welcome to banana!**
  id: totrans-424
  prefs: []
  type: TYPE_NORMAL
- en: 'We can SSH into a local target device by IP address:'
  id: totrans-425
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  id: totrans-426
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: Substitute your device’s IP address for `192.168.1.183`. This is not especially
    useful because the application is running inside a Docker container.
  id: totrans-427
  prefs: []
  type: TYPE_NORMAL
- en: 'To SSH into the container where the Python web server is running and observe
    what it’s doing, we need to include the service name in the `balena` `ssh` command:'
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  id: totrans-429
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: The service name for this starter application is `balena-hello-world` as seen
    in the live logs output.
  id: totrans-430
  prefs: []
  type: TYPE_NORMAL
- en: Congratulations! You have successfully created a balenaOS image and host development
    environment that you and your team can use to iterate on project code and quickly
    redeploy to a target device. This is no small feat. Pushing code changes in the
    form of a Docker container is a common development workflow that full-stack engineers
    are very accustomed to. With balena, they can now use the techniques they are
    familiar with to develop embedded Linux applications on actual hardware.
  id: totrans-431
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-432
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We accomplished a lot in this chapter. You now know how to create Dockerfiles
    and YAML workflows for your software projects. CI/CD pipelines use this infrastructure
    as code to automatically build and push containerized software updates out to
    edge devices. You also leveraged containers to develop locally on real hardware
    before pushing your changes out to the rest of the world. Modern DevOps practices
    like these enable software teams to move faster without breaking things.
  id: totrans-433
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will look in detail at the Linux process model and describe
    what a process really is, how it relates to threads, how they cooperate, and how
    they are scheduled. Understanding these things is important if you want to create
    a robust and maintainable embedded system.
  id: totrans-434
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章，我们将详细探讨Linux进程模型，描述什么是进程，进程与线程的关系，线程如何协作以及如何进行调度。如果你想创建一个稳健且可维护的嵌入式系统，理解这些内容非常重要。
- en: Further study
  id: totrans-435
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步学习
- en: '*The DevOps Handbook, Second Edition*, by Gene Kim, Jez Humble, Patrick Debois,
    and John Willis'
  id: totrans-436
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*DevOps手册，第二版*，作者：Gene Kim、Jez Humble、Patrick Debois 和 John Willis'
- en: '*Docker Docs*, Docker Inc. – [https://docs.docker.com/reference/cli/docker/](https://docs.docker.com/reference/cli/docker/%0D%0A)'
  id: totrans-437
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*Docker文档*，Docker公司 – [https://docs.docker.com/reference/cli/docker/](https://docs.docker.com/reference/cli/docker/%0D%0A)'
- en: '*How to run containerized Bluetooth applications with BlueZ*, by Thomas Huffert
    – [https://medium.com/omi-uulm/how-to-run-containerized-bluetooth-applications-with-bluez-dced9ab767f6](https://medium.com/omi-uulm/how-to-run-containerized-bluetooth-applications-with-bluez-dced9ab767f6)'
  id: totrans-438
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*如何运行容器化的蓝牙应用程序与BlueZ*，作者：Thomas Huffert – [https://medium.com/omi-uulm/how-to-run-containerized-bluetooth-applications-with-bluez-dced9ab767f6](https://medium.com/omi-uulm/how-to-run-containerized-bluetooth-applications-with-bluez-dced9ab767f6)'
