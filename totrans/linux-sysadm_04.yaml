- en: '4'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Processes and Process Control
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The main role of an operating system is to allow applications to run on a computer
    and use its resources. A lot of the time, the role of the systems administrator
    boils down to making sure that the right processes are running and diagnosing
    if they are not running. Thus, it is important to understand how the operating
    system starts and handles processes and how to start, stop, and monitor them.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Executables versus processes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Process termination, exit codes, and signals
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The process tree
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Process search and monitoring
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Executables versus processes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Programs are distributed as *executable files*. In many historical operating
    systems, programs would be loaded from files directly into memory byte by byte.
    That approach was certainly simple to implement, but it has many limitations (most
    notably, the requirement to have a fixed memory layout and the inability to store
    any metadata), so later systems invented special formats for executable files.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, if we inspect the **Bourne Again Shell** (**Bash**) executable
    with the file command, we’ll see something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: If you use a Linux distribution other than Debian or Red Hat derivatives (which
    are the main focus of this book) and the preceding command fails for you, you
    can find the location of the bash executable with `which bash`, or choose a different
    executable, such as `cat`or `ls`.
  prefs: []
  type: TYPE_NORMAL
- en: '**ELF** stands for **Executable and Linkable Format**. It’s the default executable
    file format on Linux and many other Unix-like operating systems (**LSB** means
    **Linux Standard Base**). An ELF file stores executable code of programs – machine
    instructions that are loaded into memory to be executed by the CPU. However, it
    can also store debug information, such as associations between machine instructions
    and lines in the program source code they were compiled from. ELF files can also
    be *linked* with other ELF files, known as *shared libraries* – files that contain
    executable code but aren’t meant to run as programs and only serve as collections
    of reusable functions.'
  prefs: []
  type: TYPE_NORMAL
- en: 'You can see the library linkage information with the `ldd` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'If you run `file` on `libc.so.6`, the standard library for the C programming
    language, you will see that it’s also an ELF file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Finally, ELF stores metadata such as the target operating system and CPU architecture.
    The file command doesn’t guess that files from the examples earlier are for Linux
    on x86-64, and simply gets them from the ELF file header.
  prefs: []
  type: TYPE_NORMAL
- en: In the output of `file /bin/bash`, you might have noticed an unusual field –
    `interpreter /lib64/ld-linux-x86-64.so.2`. Bash is written in C, which is a compiled
    language, and shouldn’t need any interpreter. Indeed, that executable contains
    machine code, and the Linux kernel knows how to load ELF files; if it didn’t,
    it couldn’t load that `ld-linux` interpreter, resulting in a chicken-and-egg problem.
  prefs: []
  type: TYPE_NORMAL
- en: 'The role of `ld-linux.so` is not to interpret the executable itself but, instead,
    to correctly resolve references to functions that come from shared libraries.
    If you run `file` on it, you will see that it’s `static-pie linked` rather than
    `dynamically linked`, unlike `/bin/bash` — `static-pie` means `static` `position-independent
    executable`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: The kernel knows nothing about programs’ library function dependencies and can
    only load statically linked ELF executables directly. To load dynamically linked
    executables, it relies on the `ld-linux.so` helper but reuses a general interpreter
    association mechanism for it, instead of inventing something custom just for that
    case.
  prefs: []
  type: TYPE_NORMAL
- en: Programs written in interpreted languages such as Python, Ruby, or shell require
    an actual interpreter to be loaded first. This is specified using a *shebang line*
    that starts with `#!`.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can try it yourself by creating a simple shell script:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: If a file has an executable bit (`+x`) on it and starts with a shebang line,
    the kernel will first load its interpreter (in this case, `/bin/bash`) and then
    give it the executable as an argument.
  prefs: []
  type: TYPE_NORMAL
- en: Once an executable file is loaded, directly by the kernel itself or with help
    from an interpreter, it becomes a running *process*.
  prefs: []
  type: TYPE_NORMAL
- en: Process termination and exit codes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: All processes have to eventually terminate, and there are many situations when
    process execution cannot continue, either due to errors in its own program logic
    or problems with the environment (such as missing files, for example). The user
    may also need to terminate processes by hand, either to make changes to the system,
    or to prevent a misbehaving process from taking up resources or interfering with
    the system’s functioning.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we will learn how to examine the exit code of a terminated
    process to guess the possible reasons for its termination, and how to communicate
    with processes and force their termination.
  prefs: []
  type: TYPE_NORMAL
- en: Exit codes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Most processes are short-lived – they do their job and terminate by themselves.
    Every process terminates with an *exit code* – a numeric value that indicates
    whether it exited normally or terminated due to an error. By convention, a zero
    exit code means success, and any non-zero exit code indicates an error. There
    are no standard meanings for non-zero exit codes – exact meanings vary between
    programs and operating systems, and many programs simply exit with `1` if they
    encounter an error, no matter what that error is.
  prefs: []
  type: TYPE_NORMAL
- en: 'In bash, you can find the exit code of the last command in a special variable
    named `$?`. There’s a pair of Unix commands whose sole purpose is to exit with
    success and error codes respectively, `true` and `false`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Most of the time, programs set their exit codes themselves. For example, in
    a shell script, you can use `exit 1` to signal an error. In C, you can use `return
    1` in your `main()` function to the same effect. For programs that can be executed
    non-interactively from scripts, it’s critically important to exit with a non-zero
    code on errors; otherwise, script authors will have no way to know whether their
    script steps succeeded or failed.
  prefs: []
  type: TYPE_NORMAL
- en: 'All standard commands do this. For example, let’s try to create a file in `/etc/`
    from a normal user and see what it leaves in the `$?` variable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'The simplest use case for exit codes is chaining commands with the `||` and
    `&&` operators. They can be called *on error* and *on success* – in `cmd1 || cmd2`,
    the shell will execute `cmd2` if `cmd1` fails (that is, exits with a non-zero
    code). In `cmd1 && cmd2`, it’s the other way around – `cmd2` is only executed
    if `cmd1` succeeds (exits with zero code):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: On errors such as the file permission error in our example, the kernel simply
    does not do what the program asks it to do and, instead, allows the program to
    continue running as usual. The reasoning is that such errors often occur due to
    incorrect user input while the program logic is correct, so the program needs
    to be able to handle them and notify the user. However, in other cases, the kernel
    will interrupt a process by generating a *signal*.
  prefs: []
  type: TYPE_NORMAL
- en: Signals
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A signal is a special condition that may occur during process execution. There
    are many signals defined in the POSIX standard. Some are associated with specific
    program logic errors, such as `SIGILL` — *illegal instruction* (caused, for example,
    by attempts to divide by zero) — or `SIGSEV` — *segmentation violation* (caused
    by trying to read or modify memory that wasn’t allocated to the process). Other
    signals are generated on external conditions to force a process to handle them,
    such as `SIGPIPE`, which is generated when a network socket or a local pipe is
    closed by the other end. These signals are only of interest to software developers,
    but some are designed as process control tools for administrators, such as `SIGINT`
    (which interrupts a process), `SIGTERM` (which asks the process to clean up its
    state and terminate), and `SIGKILL` (which tells the kernel to forcibly terminate
    a process). It’s said that a signal is *sent to a process*. That terminology is
    a good abstraction for users, but in reality, it’s the kernel that has execution
    control when a signal is generated, not the process. Programmers may anticipate
    certain signals and register *signal handlers* for them. For example, many interpreters
    for high-level programming languages handle the `SIGILL` signal and convert it
    into exceptions such as `ZeroDivisionError` in Python. However, if a programmer
    forgot or chose not to register a handler for `SIGILL` and the program attempts
    to divide by zero, the kernel will terminate the process.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you have **GNU Compiler Collection** (**GCC**) installed, you can see it
    for yourself with a simple C program:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: GCC helpfully warns you that your program is incorrect, but if you still try
    to run it, the kernel forcibly terminates it and sets the error code to a non-zero
    value.
  prefs: []
  type: TYPE_NORMAL
- en: Signals such as `SIGILL` or `SIGPIPE` occur regardless of the user’s wishes,
    but there’s also a class of signals that is meant to be initiated by users (or
    by processes on their behalf).
  prefs: []
  type: TYPE_NORMAL
- en: The kill command
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The command for sending signals to processes is called **kill**. That name is
    also somewhat misleading; most often, it’s indeed used to forcibly terminate processes,
    but it can also send other signals as well.
  prefs: []
  type: TYPE_NORMAL
- en: 'To illustrate its usage, let’s learn how to send a process to the background.
    In bash, you can do that by appending an ampersand to a command. Using the `jobs`
    command, you can see a list of background processes, and by using `fg <job number>`,
    you can bring a job with a certain number to the foreground. Here’s how you can
    send a `cat` process to the background and then bring it back:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'When you press *Ctrl* + *C* to terminate a process in the shell, you actually
    ask your shell to send it a `SIGINT` signal – a signal to interrupt execution.
    If a process is in the background, we cannot use *Ctrl* + *C* to interrupt it.
    However, with `kill`, we can send it manually:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Here’s what happened – when we ran `cat &`, the shell told us its *background
    job number* (`1`) and also its `22739`, but it can be any number. We then used
    `kill 22739` to send the process a signal, and indeed, when we tried to bring
    it to the foreground, the shell told us that it terminated while it was in the
    background.
  prefs: []
  type: TYPE_NORMAL
- en: By default, the `kill` command sends a `SIGTERM` signal. Both `SIGINT` and `SIGTERM`
    can be caught or ignored by a process. By sending them to a process, you ask it
    to terminate; a well-behaved process should comply and may use it as a chance
    to finalize its current task before terminating – for example, to finish writing
    data to a file. That means that neither the *Ctrl* + *C* key combination in the
    shell nor the `kill` command with default options is suitable for forcibly terminating
    a misbehaving process.
  prefs: []
  type: TYPE_NORMAL
- en: To force a process to quit, you should use `kill -SIGKILL <PID>` instead, or
    its numeric equivalent, `kill -9 <PID>`. However, it should be your last resort
    since the kernel will simply end the process immediately, and that may leave its
    files in an inconsistent state.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you run `kill -l`, you will see a long list of available signals:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Some of those signals have no predefined meanings and, instead, are specific
    to applications. For example, in `SIGUSR1` and `SIGUSR2`, `USR` stands for *user-defined*.
    Most processes ignore them, but some use them to allow system administrators to
    force a config reload or another operation.
  prefs: []
  type: TYPE_NORMAL
- en: Now, we know how to examine the error codes of terminated processes and get
    an idea of whether they exited normally or failed. We also learned how the operating
    system kernel communicates with processes using signals, and how we can use the
    `kill` command to ask the kernel to either tell a process to exit or terminate
    a misbehaving process forcibly. Now, let’s learn how to explore the running processes
    and relationships between them.
  prefs: []
  type: TYPE_NORMAL
- en: The process tree
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We’ve seen that the shell knows the PIDs of the commands you run and can send
    them signals to terminate when you press *Ctrl* + *C*. That implies that it has
    certain control over the processes you ask it to launch. Indeed, everything you
    launch from your shell becomes a *child process* of that shell process.
  prefs: []
  type: TYPE_NORMAL
- en: The shell itself is a child process — either of your terminal emulator if you
    are on a Linux desktop, or of the OpenSSH daemon if you connect remotely over
    SSH. However, is there a parent of all processes, or can there be multiple processes
    without parents?
  prefs: []
  type: TYPE_NORMAL
- en: In fact, there is a parent of all processes, and all running process relationships
    form a tree with a single root (PID = 1). For historical reasons, the parent of
    all processes is often called the *init process*. For a long time in general-purpose
    Linux distributions, that process was System V init, hence the term.
  prefs: []
  type: TYPE_NORMAL
- en: The PID=1 process can be anything. When you boot a Linux system, you can tell
    it which executable to load as PID=1\. For example, one way to boot a system in
    rescue mode is to append `init=/bin/bash` to the GRUB command line (but you are
    better off using a built-in rescue option in your distro’s boot menu item because
    it may pass additional useful parameters). That will make your kernel drop into
    a single-user shell session instead of initiating its normal boot process. Some
    embedded systems that use Linux just as a hardware abstraction layer may start
    custom processes instead. However, normally, the process with PID=1 serves as
    a service manager.
  prefs: []
  type: TYPE_NORMAL
- en: The System V init served as the de facto standard service manager for over two
    decades, but most modern distributions use systemd instead, while some opt for
    other alternatives to the old System V init, such as OpenRC.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `init` process is the only process that is launched directly by the kernel.
    Everything else is launched by the `init` process instead: login managers, the
    SSH daemon, web servers, database systems – everything you can think of. You can
    view the full process tree with the `pstree` command. Here’s a tree from a small
    web server:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Here, you can see that `pstree` was a child process of a bash session, which
    in turn was a child of `sshd` (an OpenSSH process), which was itself a child of
    `systemd` – the root of the process tree.
  prefs: []
  type: TYPE_NORMAL
- en: However, most of the time, you will be interested in finding specific processes
    and their resource usage.
  prefs: []
  type: TYPE_NORMAL
- en: Process search and monitoring
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `pstree` command is a great way to visualize all running processes and relationships
    between them, but in practice, most of the time administrators look for specific
    processes or need to learn about their resource usage, rather than their mere
    existence. Let’s learn about the tools for those tasks – the `ps` command to search
    processes, the `top` command to monitor resource usage in real time, and the underlying
    kernel interface that those tools use.
  prefs: []
  type: TYPE_NORMAL
- en: The ps command
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**PS** is an abbreviation for **process selection** or **process snapshot**.
    It’s a utility that allows you to retrieve and filter information about running
    processes.'
  prefs: []
  type: TYPE_NORMAL
- en: Running `ps` without any arguments will get you a very limited selection – only
    processes that run from your user and that are attached to a *terminal* (that
    is, aren’t processes that run with all input and output closed and only communicate
    with other processes through network or local sockets — usually daemons, but GUI
    programs may behave the same way).
  prefs: []
  type: TYPE_NORMAL
- en: 'Somewhat confusingly, `ps` itself always shows up in such lists because, when
    it gathers that information, it’s indeed a running process:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: The `PID` field is, of course, a process identifier – a unique number that the
    kernel assigns to every process when that process is launched. If present, the
    `TTY` field is a terminal – it can be a real serial console (usually `ttyS*` or
    `ttyUSB*`), a virtual console on a physical display (`tty*`), or a purely virtual
    pseudo-terminal associated with an SSH connection or a terminal emulator (`pts/*`).
  prefs: []
  type: TYPE_NORMAL
- en: The CMD field shows the command that was used to launch a process with its arguments,
    if any were used.
  prefs: []
  type: TYPE_NORMAL
- en: The `ps` command has a large number of options. Two options you should learn
    about right away are `a` and `x` — options that remove *owned by me* and *have
    a* *terminal* restrictions.
  prefs: []
  type: TYPE_NORMAL
- en: 'A common command to view every process on the system is `ps ax`. Let’s try
    to run it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: The `STAT` field tells us the process state. The `S` state means a process is
    in the interruptible sleep state – it waits for external events. Processes that
    currently do something can be seen in the `R` state – running. The `I` state is
    special; it is for idle kernel threads. The most concerning state is `D` – uninterruptible
    sleep. Processes are in the uninterruptible sleep state if they actively wait
    for input/output operations to complete, so if there is a large number of such
    processes, it may mean that the input/output systems are overloaded.
  prefs: []
  type: TYPE_NORMAL
- en: Note that there are mysterious processes with command names in square brackets
    that you don’t see in the output of `pstree`. Those are, in fact, kernel services
    that are made to look like processes for ease of monitoring, or for their own
    internal reasons.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you want to also see what user owns each of those processes, you may want
    to add `u` to your command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: There are many more selection and formatting options, which you can find in
    the official documentation.
  prefs: []
  type: TYPE_NORMAL
- en: Process monitoring tools
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `ps` command gives you a static picture of processes, CPU and memory consumption.
    If you want to find out what causes CPU usage spikes, that’s very inconvenient
    – you need to be lucky to run `ps` exactly when a spike occurs. That’s why people
    wrote tools that monitor processes continuously and can display them sorted by
    resource consumption.
  prefs: []
  type: TYPE_NORMAL
- en: One of the oldest tools in this class is called `top`. It’s widely available
    in Linux distribution repositories and may even be installed by default in your
    system. It displays an interactive process list, with processes that consume the
    largest amount of resources automatically floating to the top.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.1 – The top command output](img/B18575_04_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.1 – The top command output
  prefs: []
  type: TYPE_NORMAL
- en: There are other tools inspired by it, such as `htop`, which offers different
    user interfaces and additional functionality. There are also tools that monitor
    resource usage types that `top` or `htop` don’t, such as `iotop`, a tool to monitor
    the input/output activity of processes.
  prefs: []
  type: TYPE_NORMAL
- en: The /proc filesystem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Finally, let’s examine the lowest-level interface to process information – the
    `/proc` filesystem. It’s an example of a *virtual filesystem* and a good illustration
    of the *everything is a file* principle widely used by Unix-like operating systems.
  prefs: []
  type: TYPE_NORMAL
- en: 'To users, `/proc` looks like a directory with files. Some of those files have
    nothing to do with processes and contain other system information instead – for
    example, `/proc/version` contains the running kernel version. Here’s an example
    from a Fedora 35 system:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: However, those files aren’t files on disk, and not even the root user can write
    to them or delete them. The kernel simply makes them look like files so that users
    can use familiar tools to read them.
  prefs: []
  type: TYPE_NORMAL
- en: 'Whenever a process is launched, the kernel adds a subdirectory named `/proc/<PID>/`.
    For example, let’s peek into the directory of the `init` process:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'That interface is too low-level for an end user most of the time. For example,
    environment variables passed to a process on launch can be found in a file named
    `environ`, but let’s try to read it and see:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: That output appears to be garbled – variables have no separators. In reality,
    it’s not a bug; that file simply contains the process environment data exactly
    as it appears in its memory, with variable pairs separated by non-printable null
    characters, as per the C programming language convention.
  prefs: []
  type: TYPE_NORMAL
- en: 'The same applies to `/proc/1/cmdline` – the file that contains a full command
    that was used to launch that process:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'However, it’s recognizable, and it’s exactly where `ps` takes the process command;
    it just inserts spaces in place of null bytes to make it correct and readable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Thus, it’s good to know about the raw `/proc` interface, but it’s impractical
    to use it as a source of process information. Tools such as `ps` and `pstree`
    can present it in a much more readable form and allow you to filter it. However,
    it’s also important to understand that those tools don’t use any special kernel
    interfaces other than `/proc`, and in an emergency situation, you can always get
    the same information from there without any tools at all.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we learned that process startup is not a trivial operation,
    and even native code binaries are not simply loaded into memory byte by byte.
    We learned how to explore the process tree with the `pstree` command, how to force
    processes to terminate or reload with `kill`, and how to examine and interpret
    exit codes.
  prefs: []
  type: TYPE_NORMAL
- en: We also learned that the kernel communicates with running processes using POSIX
    signals, that different signals have different meanings, and that there are more
    signals than what the `kill` command allows the user to send. Apart from `SIGTERM`
    or `SIGKILL`, which are sent by users or userspace tools, there are many signals
    that the kernel uses to indicate programming errors and special conditions. Among
    them are `SIGILL`, for programs that attempt to execute illegal CPU instructions,
    and `SIGPIPE`, for cases when a connection is closed by the other side.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will learn how to discover and examine the hardware
    installed in a machine running Linux.
  prefs: []
  type: TYPE_NORMAL
