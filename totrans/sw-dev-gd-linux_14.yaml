- en: '14'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '14'
- en: Version Control with Git
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Git 进行版本控制
- en: '**Git** is a **distributed version control system** (**DVCS**) that, over the
    last two decades, has become the most widely used version control system in the
    world. Although it is very likely that you already know the basics of how to use
    Git, you might not be familiar with common command-line patterns, or some of its
    more rarely used (but powerful!) features. We’ll cover those here. This chapter
    will also give you some background knowledge so that commonly used Git terms make
    more sense and commonly referenced concepts are clear.'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: '**Git** 是一个 **分布式版本控制系统**（**DVCS**），在过去的二十年里，它已经成为全球使用最广泛的版本控制系统。虽然你很可能已经知道如何使用
    Git 的基础知识，但你可能不熟悉常见的命令行模式，或者一些它的较少使用（但强大的！）功能。我们将在这里讲解这些内容。本章还将提供一些背景知识，使得常用的
    Git 术语更易理解，常被提及的概念更加清晰。'
- en: 'Here’s what you’ll learn about:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 你将学到的内容包括：
- en: The basics of Git and distributed version control
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Git 和分布式版本控制的基础
- en: First-time Git setup
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第一次 Git 设置
- en: Basic Git commands
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基本的 Git 命令
- en: Common Git terminology
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 常见的 Git 术语
- en: 'Two powerful and slightly more advanced Git concepts: bisecting and rebasing'
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 两个强大且稍微复杂一点的 Git 概念：二分查找和变基
- en: Git best practices, especially around using commit messages effectively
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Git 最佳实践，尤其是在有效使用提交信息方面
- en: Useful Git shell aliases that will save you lots of typing
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有用的 Git Shell 别名，它们能帮你节省大量打字时间
- en: GUI tools that you can use to interact with Git
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可以用来与 Git 交互的 GUI 工具
- en: 'Finally, the *Poor man’s GitHub* section presents a small but legitimately
    useful project that you can do to practice and integrate the Linux skills you’ve
    learned up to this point. We hope you’ll try it out: if you do, your comfort and
    skill on the command line will benefit tremendously.'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，*穷人的 GitHub* 部分介绍了一个小而有用的项目，你可以通过这个项目来练习并整合你迄今为止学到的 Linux 技能。我们希望你能试试看：如果你这么做了，你在命令行上的熟练度和舒适度将会有极大的提升。
- en: Some background on Git
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Git 的一些背景知识
- en: Git is a DVCS developed by Linus Torvalds, the creator of the Linux kernel.
    The origin of Git dates back to 2005 when the relationship between the Linux kernel
    community and a proprietary distributed version control system called *BitKeeper*
    broke down.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: Git 是一个由 Linux 内核创建者 Linus Torvalds 开发的 DVCS。Git 的起源可以追溯到 2005 年，当时 Linux 内核社区与一个名为
    *BitKeeper* 的专有分布式版本控制系统的关系破裂。
- en: In response to this, Torvalds sought to create a free, open-source DVCS that
    would meet the needs of the Linux kernel development process. Within just a few
    days, he conceptualized and laid the foundation for Git.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 为此，Torvalds 旨在创建一个免费的开源 DVCS，满足 Linux 内核开发过程的需求。仅仅几天内，他就构思并奠定了 Git 的基础。
- en: Prioritizing performance, security, flexibility, and non-linear development
    (supporting thousands of parallel branches), Git quickly gained traction within
    the software development community. Its design, which emphasizes speed, data integrity,
    and support for distributed workflows, made it a favorite among developers, and
    it has since become the de facto standard for version control in the software
    industry.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: Git 优先考虑性能、安全性、灵活性和非线性开发（支持成千上万的并行分支），因此迅速在软件开发社区中获得了广泛的关注。它的设计强调速度、数据完整性和支持分布式工作流，这使得它成为开发者的最爱，随后它也成为了软件行业版本控制的事实标准。
- en: What is a distributed version control system?
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 什么是分布式版本控制系统？
- en: Traditional version control systems (like **concurrent versions system** (**CVS**)
    and others) use a central server that maintains a single, coherent repository
    state at all times. These systems let developers push and fetch code and allowed
    the use of branches, tags, and other familiar mechanisms. The important point
    is that these version control systems were designed with a central authority in
    mind.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 传统的版本控制系统（如 **并发版本系统**（**CVS**）等）使用中央服务器，始终保持单一、统一的仓库状态。这些系统允许开发者推送和拉取代码，并支持使用分支、标签等常见机制。重要的一点是，这些版本控制系统的设计是以中央权限为核心的。
- en: Git and other DVCSs, like **Mercurial** and **Fossil**, use a different approach.
    Each developer has their own complete repository. Other developers, instead of
    going through a central server, pull from each others’ repositories to fetch changes.
    In the case of the Linux project, there are hundreds of independent repositories
    in use by developers. Once a developer feels that the state of one of these repositories
    is ready, they will ask for the changes to be pulled into the main kernel. This
    is where the term **pull request** comes from.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: Git 和其他分布式版本控制系统（如 **Mercurial** 和 **Fossil**）采用不同的方法。每个开发者都有自己完整的仓库。其他开发者则不是通过一个中央服务器，而是从彼此的仓库中拉取更改。在
    Linux 项目的情况下，有数百个开发者独立使用的仓库。一旦开发者认为其中某个仓库的状态已经准备好，他们会请求将更改拉取到主内核中。这就是 **pull request**（拉取请求）一词的来源。
- en: While GitHub, GitLab, sourcehut, and others provide centralized hosting for
    Git, taking care of things like user authorization and providing many other features
    surrounding the development of software projects, Git works well without any of
    these and provides many mechanisms to do so. It is even possible to send and receive
    patches and groups of commits using email, without ever leaving the command line
    and Git. This allows for easy collaboration, even when a contributor has nothing
    but an email address to send a patch to.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然 GitHub、GitLab、sourcehut 等提供了 Git 的集中式托管，处理用户授权等事务，并提供许多与软件项目开发相关的其他功能，但 Git
    本身在没有这些托管的情况下也能很好地工作，并提供多种机制来实现这一点。甚至可以通过电子邮件发送和接收补丁和一组提交，而无需离开命令行和 Git。这使得即使贡献者只有一个电子邮件地址，也可以轻松地进行协作，发送补丁。
- en: Git basics
  id: totrans-21
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Git 基础
- en: Here is a quick refresher on the most important Git command-line basics. These
    are provided as a reference, not as step-by-step instructions – although we’ve
    written them so that you can follow along if you want to practice.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是对最重要的 Git 命令行基础的快速回顾。这些内容作为参考提供，而不是逐步指导—尽管我们已经将它们编写成你可以跟着操作的格式，以便如果你想练习时能够使用。
- en: First-time setup
  id: totrans-23
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 首次设置
- en: 'First things first: if you’re running Git for the first time on a machine,
    you may want to set a few global config options.'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，如果你在机器上第一次运行 Git，你可能想设置一些全局配置选项。
- en: 'Set the default branch name to `main`:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 将默认分支名称设置为 `main`：
- en: '[PRE0]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Now configure your default name and email (attached to all of your commits):'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 现在配置你的默认用户名和电子邮件（与所有提交相关联）：
- en: '[PRE1]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Now you can initialize a new Git repository.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你可以初始化一个新的 Git 仓库。
- en: Initialize a new Git repository
  id: totrans-30
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 初始化一个新的 Git 仓库
- en: 'Create a directory and enter it:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个目录并进入它：
- en: '[PRE2]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Now tell Git you want to initialize this directory as a new Git repository:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 现在告诉 Git 你希望将这个目录初始化为一个新的 Git 仓库：
- en: '[PRE3]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Make and see changes
  id: totrans-35
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建并查看更改
- en: 'Create a file with some simple content, and show the resulting change that
    Git detects:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个包含一些简单内容的文件，并展示 Git 检测到的变化：
- en: '[PRE4]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Stage and commit changes
  id: totrans-38
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 暂存并提交更改
- en: 'Stage the change you made to be committed, and observe how the output of `git
    status` has changed:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 将你做出的更改暂存起来，以便提交，并观察 `git status` 的输出如何变化：
- en: '[PRE5]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Show the staged content:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 显示分阶段的内容：
- en: '[PRE6]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Commit the staged changes:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 提交暂存的更改：
- en: '[PRE7]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: This is the short form of the `commit` command, which specifies the message
    (`-m`) directly. There is an interactive version of the `commit` command, which
    you’d get by running just `git commit`.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 这是 `commit` 命令的简短形式，直接指定消息（`-m`）。`commit` 命令也有一个交互式版本，你可以通过仅运行 `git commit`
    来使用它。
- en: The interactive version of this command (without the `–m` option) will open
    the text editor specified in your shell’s `EDITOR` environment variable, and once
    the file is saved and the editor exits – that is, when the `$EDITOR` command returns
    – the commit will be written.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 该命令的交互式版本（没有 `–m` 选项）会打开你在 shell 中指定的 `EDITOR` 环境变量所指定的文本编辑器，一旦文件保存并且编辑器退出——也就是说，当
    `$EDITOR` 命令返回时——提交将被写入。
- en: 'Optional: add a remote Git repository'
  id: totrans-47
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 可选：添加一个远程 Git 仓库
- en: The following command will add a remote repository with the local name `origin`
    that Git can push to and pull from. This might look similar to the SSH login command
    that we covered in *Chapter 13*, *Secure Remote Access with SSH*, because that’s
    exactly what Git will use in this case. Git also supports other protocols, such
    as HTTPS.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 以下命令将添加一个名为 `origin` 的远程仓库，Git 可以向其推送和拉取数据。这可能看起来像我们在 *第13章*，*使用 SSH 进行安全远程访问*
    中讲解的 SSH 登录命令，因为 Git 在这种情况下确实会使用 SSH。Git 还支持其他协议，如 HTTPS。
- en: '[PRE8]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: This is just an example, but when you’re working on a real repository – for
    example, one that exists on GitHub – you’ll change the hostname and `repo-path`
    to match the repository you want to add. GitHub and other source-hosting tools
    all have clear documentation on how to do this for repositories hosted there.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 这只是一个例子，但当你在真实的仓库上工作时——例如，存在于 GitHub 上的一个仓库——你需要更改主机名和 `repo-path` 来匹配你想要添加的仓库。GitHub
    和其他源代码托管工具都有清晰的文档说明如何为其托管的仓库执行此操作。
- en: Pushing and pulling
  id: totrans-51
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 推送和拉取
- en: 'Push changes from your current branch to the remote Git repository:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 推送当前分支的更改到远程 Git 仓库：
- en: '[PRE9]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Pull changes from the remote branch:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 从远程分支拉取更改：
- en: '[PRE10]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Cloning a repository
  id: totrans-56
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 克隆仓库
- en: 'Let’s clone a remote repository – all of the code for a project-based Linux
    course I created:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们克隆一个远程仓库——我创建的一个基于 Linux 课程的项目的所有代码：
- en: '[PRE11]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: This will pull down the Git history for the codebase and set the origin of the
    remote repository to the URL specified. Then you can work on the codebase using
    all of the Git commands you’ve already learned in this chapter.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 这将下载代码库的 Git 历史记录，并将远程仓库的源设置为指定的 URL。然后你可以使用本章中已学习的所有 Git 命令来操作代码库。
- en: 'As before, you can check the status of the repository:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，你可以检查仓库的状态：
- en: '[PRE12]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: While this command is typically used to check what was modified, it will also
    provide you with information on ongoing merges, show affected files during a merge
    conflict, and help you when bisecting code and in various other situations. It’s
    worthwhile to check `git status` when you are not sure what is going on; chances
    are that you are in a special Git state that you either want to get out of or
    finish before continuing.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管此命令通常用于检查修改的内容，它也会提供有关正在进行的合并、显示合并冲突期间受影响的文件，并在二分代码和其他各种情况下帮助你。当你不确定发生了什么时，检查
    `git status` 是值得的；很可能你处于一个特殊的 Git 状态中，你要么想要退出这种状态，要么在继续之前完成它。
- en: Now that we’ve covered the commands you’ll use most often, let’s get you comfortable
    with some of the terminology that often confuses people who are new to working
    with Git.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经介绍了你经常使用的命令，让我们帮助你熟悉一些术语，这些术语常常让刚开始使用 Git 的人感到困惑。
- en: Terms you might come across
  id: totrans-64
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 你可能会遇到的术语
- en: It can be very helpful to get a basic understanding of Git’s vocabulary. Although
    it can be confusing when other software mixes these terms up, knowing what they
    mean in the Git world allows you to work a lot more confidently, for example,
    when troubleshooting and reading error messages.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 在理解 Git 词汇的基础上会非常有帮助。虽然其他软件混合使用这些术语可能会令人困惑，但了解它们在 Git 世界中的含义可以让你在故障排除和阅读错误消息时更加自信地工作。
- en: Here is an overview of the most common terms and what they mean.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是最常见术语的概述及其含义。
- en: Repository
  id: totrans-67
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 仓库
- en: This is essentially a “project,” the root directory of the code that is being
    managed and tracked by version control – the one containing the `.git` directory.
    A repository holds your source code and its history and changes.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 这本质上是一个“项目”，由版本控制管理和跟踪的代码的根目录——包含 `.git` 目录的项目。仓库保存了你的源代码及其历史和更改。
- en: Bare repository
  id: totrans-69
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 裸仓库
- en: This has a similar meaning, only that the code is not checked out. It matches
    what the `.git` directory contains. On servers hosting the repositories, such
    as GitHub, GitLab, sourcehut, or your company’s Gogs or Gitea instances, these
    are usually in a directory named `project-name.git` containing only what you’d
    see in a checked-out (cloned) repository found in `project-name/.git`.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 这具有类似的意义，只是代码未被检出。它匹配 `.git` 目录中的内容。在托管仓库的服务器上，比如 GitHub、GitLab、sourcehut，或者你公司的
    Gogs 或 Gitea 实例中，这些通常在名为 `project-name.git` 的目录中，只包含你在 `project-name/.git` 中看到的内容。
- en: Branch
  id: totrans-71
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 分支
- en: If you imagine the first commit as the seed of a new repository, a project is
    made up of various branches. There is a main branch (described below), and often
    one or more side branches, containing other directions a project is taking.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你将第一个提交想象为新仓库的种子，那么一个项目由各种分支组成。有一个主分支（下文有描述），通常还有一个或多个侧分支，包含项目正在采取的其他方向。
- en: These might be major version branches, which have bug fixes applied to them
    but will never be merged back into the main branch. They could be experiments
    that may or may not ever be merged back into the main branch. Or, they could be
    new features or bug fix branches that are still in development but will be merged
    as soon as they’re ready – the possibilities are endless.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 这些可能是主要版本分支，已经修复了其中的错误，但永远不会再合并回主分支。它们也可能是实验性分支，这些分支可能永远不会被合并回主分支。或者，它们可能是正在开发中的新特性或错误修复分支，一旦准备好就会被合并——可能性是无穷无尽的。
- en: Main/master branch
  id: totrans-74
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 主分支（Main/Master）
- en: This is the default branch, which will be used when initializing or cloning
    a repository. Depending on the project, it usually contains either the latest
    (in development) or the latest stable code.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 这是默认分支，当初始化或克隆一个仓库时将使用它。根据项目的不同，它通常包含最新的（正在开发中的）或最新的稳定代码。
- en: HEAD
  id: totrans-76
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: HEAD
- en: This is the latest commit on a branch. It’s also sometimes referred to as the
    “tip” of a branch. On the command line, `HEAD` is also commonly used in combination
    with relative commits.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 这是分支上的最新提交。它有时也被称为分支的“尖端”。在命令行中，`HEAD` 通常与相对提交一起使用。
- en: 'For example, `HEAD~2` references two commits back; therefore, the following
    command would show you the log up to two commits ago:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，`HEAD~2` 表示回退到两个提交；因此，以下命令会显示直到两个提交之前的日志：
- en: '[PRE13]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: In scripts and daily usage, it can also be used as an alternative to the current
    branch, because it is the tip of the current branch.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 在脚本和日常使用中，它也可以作为当前分支的替代，因为它是当前分支的尖端。
- en: Tag
  id: totrans-81
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 标签
- en: Unlike branches, tags are a way to mark specific commits, for example, to create
    (and later reference) a specific version of the codebase.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 与分支不同，标签是一种标记特定提交的方式，例如，用来创建（并随后引用）代码库的特定版本。
- en: Shallow
  id: totrans-83
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 浅层
- en: Usually, “shallow” is used to describe checkouts that contain no – or very little
    – history. Shallow checkouts are used when Git is only used as a means to obtain
    code, rather than the full repository and its history. This, however, might prevent
    certain commands and tools that depend on more history from working.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，“浅层”用来描述没有或几乎没有历史记录的检出。浅层检出用于当 Git 仅作为获取代码的手段，而不是完整的仓库及其历史记录时。然而，这可能会导致某些依赖更多历史记录的命令和工具无法工作。
- en: Merging
  id: totrans-85
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 合并
- en: Merging is the process of integrating code from one branch into another branch.
    This can happen in various scenarios, such as merging a feature branch into the
    main branch, pulling changes from a remote branch, retrieving code from the Git
    stash, and so on. These merges can happen in a fully automated way. Sometimes,
    as in the case of merge conflicts, a merge might need manual intervention.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 合并是将一个分支的代码集成到另一个分支的过程。这种情况可能发生在多种场景中，比如将功能分支合并到主分支、从远程分支拉取更改、从 Git 存储区获取代码等等。这些合并通常是完全自动化的。有时，如在合并冲突的情况下，合并可能需要手动干预。
- en: Merge commit
  id: totrans-87
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 合并提交
- en: This is a commit that results from code being merged. When merging code, that
    merge itself becomes a commit. When there is a merge conflict, this merge commit
    will have changes resolving that conflict. While technically possible, it’s not
    a good idea to add any other changes (such as additional bug fixes) to such a
    commit. Merge commits should contain only the changes that are needed to make
    that specific merge work.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 这是由于代码合并所产生的提交。当合并代码时，合并本身会变成一个提交。当出现合并冲突时，这个合并提交将包含解决该冲突的更改。虽然技术上是可能的，但在这种提交中添加其他更改（如额外的错误修复）并不是一个好主意。合并提交应该仅包含使特定合并能够工作的所需更改。
- en: In the case of conflict-free merges that Git handles automatically, it’s common
    to just commit them without any manual changes to the code or the message.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 Git 自动处理的无冲突合并，通常只需提交它们，而不对代码或提交消息进行任何手动修改。
- en: Merge conflict
  id: totrans-90
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 合并冲突
- en: When Git is not sure how to merge incoming code, this will result in a merge
    conflict that you need to manually resolve, usually with a merge tool. Such conflicts
    can occur when code is being pulled, when code is applied from the stash, when
    merging branches, or during any other activity that acts on your currently checked-out
    code. Merge conflicts need to be resolved and then committed. `git status` will
    usually tell you how to proceed.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 当 Git 无法确定如何合并即将合并的代码时，就会导致合并冲突，你需要手动解决，通常使用合并工具。在拉取代码、应用代码存储、合并分支或进行任何其他对当前检出的代码进行操作的活动时，都可能发生这种冲突。合并冲突需要解决并提交。`git
    status` 通常会告诉你如何继续。
- en: Stash
  id: totrans-92
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 存储区
- en: Sometimes it is necessary to put changes away for later retrieval. Git provides
    a mechanism for this, called the stash. The stash is structured like a stack,
    making it easy to incrementally apply changes in order by `git stash pop`-ping
    from it.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 有时需要将变更保存起来，稍后再取用。Git 提供了一个机制来实现这一点，称为 stash。stash 像栈一样结构化，使得可以通过 `git stash
    pop` 逐步应用变更。
- en: Pull request
  id: totrans-94
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Pull 请求
- en: Git is a distributed version control system, which means that every developer
    has their own full repository and, therefore, can work independently of other
    developers working on the same project.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: Git 是一个分布式版本控制系统，这意味着每个开发者都有自己的完整仓库，因此可以独立于其他开发者进行工作，即便他们在同一个项目中。
- en: Imagine a developer, Steve, who makes some changes to the code in his repository.
    He wants another developer, Sarah, to integrate these changes into the codebase
    before an upcoming software release. Steve requests Sarah to pull these changes
    into her repository – as we saw earlier in the chapter, this is where the term
    “pull request” comes from.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 假设有一个开发者 Steve，他在自己的仓库中做了一些修改。他希望另一位开发者 Sarah 在即将发布的软件版本之前，将这些修改整合到代码库中。Steve
    请求 Sarah 拉取这些修改到她的仓库中——正如我们在本章之前所看到的，这就是“pull request”这一术语的来源。
- en: Since many companies and projects do not use Git as a DVCS, preferring a central,
    authoritative code repository that all developers pull from and push to, the term
    “pull request” is now usually used to describe a request to add code to that authoritative
    repository (or sometimes just into the main branch of a repository).
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 由于许多公司和项目并不使用 Git 作为 DVCS，而是偏好使用一个中心化的、权威的代码仓库，所有开发者都从中拉取和推送代码，因此“pull request”这个术语现在通常用来描述请求将代码添加到该权威仓库（或有时只是添加到仓库的主分支）中的操作。
- en: '**Note**'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: 'Because this concept deviates from Git’s decentralized nature, there is no
    native Git word for it. Different products that implement this workflow (updating
    the authoritative, central version of the codebase) have different names for it:
    GitHub calls it a “pull request,” while Launchpad calls it a “merge proposal”
    and GitLab calls it a “merge request.”'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 因为这个概念偏离了 Git 的去中心化特性，所以 Git 本身并没有对应的术语来描述它。实现这一工作流的不同产品（更新代码库的权威中心版本）有不同的命名：GitHub
    称之为“pull request”，而 Launchpad 称其为“merge proposal”，GitLab 则称其为“merge request”。
- en: Cherry-picking
  id: totrans-100
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 挑选提交
- en: Sometimes it makes sense to only obtain individual changes (commits) from a
    different branch. A typical example is bug fixes in a development branch, like
    a feature branch that should be added to a stable branch to be released. This
    can be done by cherry-picking. Unlike merges where the whole branch is merged,
    cherry-picking allows you to specify individual commits to add.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 有时只需要从其他分支获取单个变更（提交）。一个典型的例子是开发分支中的 bug 修复，比如一个功能分支应该被添加到稳定分支中发布。这可以通过挑选提交（cherry-picking）来完成。与合并整个分支不同，挑选提交允许你指定单个的提交进行添加。
- en: Bisecting
  id: totrans-102
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Bisect 操作
- en: '`git bisect` is a way to quickly find a commit causing a change, typically
    used to identify which commit introduced a certain bug. To do so, one specifies
    a known “bad” and a known “good” commit. The bad commit contains a bug and the
    good one is still fine. Git will now present you with commits that you can use
    to test for the bug. Here is an example:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: '`git bisect` 是一种快速定位引起变更的提交的方法，通常用于确定哪个提交引入了特定的 bug。为此，你需要指定一个已知的“坏”提交和一个已知的“好”提交。坏的提交包含
    bug，而好的提交仍然正常。Git 会向你展示可以用来测试 bug 的提交。以下是一个例子：'
- en: '[PRE14]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The first line starts the bisect. In the second one, we tell Git that the current
    version is bad, so it contains the bug. Since we know that commit `a0634a0` is
    still good, we specify that on the third line. Of course, this doesn’t have to
    be a commit but can also be a tag or a branch. Git will then let us know how many
    versions will still have to be checked.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 第一行开始进行 bisect。在第二行，我们告诉 Git 当前版本有问题，因此包含了 bug。由于我们知道提交 `a0634a0` 仍然是正常的，所以在第三行指定了它。当然，这不一定非得是提交，也可以是标签或分支。Git
    将会告知我们还需要检查多少个版本。
- en: Now it’s time to test the code for the bug we are trying to find. If it’s present,
    we type in `git bisect bad`, otherwise, `git bisect good`. Rinse and repeat. Eventually,
    you will end up with the exact commit that introduced the bug.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是测试我们试图找出 bug 的代码的时候。如果存在 bug，我们输入 `git bisect bad`，否则输入 `git bisect good`。反复进行，直到最终定位到引入
    bug 的具体提交。
- en: If you want to get out of this mode and back to the state you were in before,
    typing `git bisect reset` will do so.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想退出这种模式，回到之前的状态，输入 `git bisect reset` 即可。
- en: Depending on what you are trying to find, “good” and “bad” are not the best
    words and can be confusing when trying to find any other kind of behavior change.
    So it’s possible to use “old” and “new” instead, to find the commit introducing
    the new behavior. Keep in mind it’s not possible to mix these terms. It’s either
    *good* and *bad*, or *old* and *new*.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 根据你要查找的内容，"好"和"坏"不是最佳词汇，在查找任何其他类型的行为变化时可能会引起混淆。因此，可以改用"旧"和"新"，以找到引入新行为的提交。请记住，这两个术语不能混用。它要么是*好*和*坏*，要么是*旧*和*新*。
- en: 'There are also ways to speed this process up, such as specifying files or directories,
    if you know where the behavior was introduced. If you know that a change has to
    be related to the contents of `some/directory` or `some/other/directory`, you
    can narrow down your search like this:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一些方法可以加快这个过程，比如指定文件或目录，如果你知道行为是如何引入的。如果你知道某个更改与`some/directory`或`some/other/directory`的内容有关，你可以这样缩小搜索范围：
- en: '[PRE15]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Git will make sure to consider only commits that make changes to these paths.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: Git 会确保只考虑对这些路径做出更改的提交。
- en: There are even more ways to speed this process up, like specifying multiple
    good commits or even passing a test script that, depending on the exit code, will
    automatically find the commit. A look into `man git-bisect` is also helpful if
    you need to go through a lot of commits.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 还有更多方法可以加快这个过程，比如指定多个好的提交，或者甚至传递一个测试脚本，根据退出代码，自动找到提交。如果你需要检查大量提交，查看`man git-bisect`也很有帮助。
- en: Rebasing
  id: totrans-113
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 变基
- en: A `git rebase` is a common way to keep commit histories easy to follow by “replaying”
    (really, recreating) a given set of changes (like a feature branch) onto a new
    base commit, rather than the base commit where they really diverged.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: '`git rebase` 是一种常用的方式，通过“重放”（实际上是重新创建）一组给定的更改（如功能分支）到一个新的基础提交上，而不是它们真正分岔的基础提交，从而保持提交历史易于跟踪。'
- en: 'Because development is usually distributed, you may have a “true” commit history
    like this:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 因为开发通常是分布式的，你可能会有这样的“真实”提交历史：
- en: '![](img/B19251_14_01.png)'
  id: totrans-116
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B19251_14_01.png)'
- en: 'Figure 14.1: “real” commit history'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 图 14.1：“真实”提交历史
- en: Having multiple feature branch histories intermingled in the history is often
    more confusing than it is useful, so Git’s `rebase` feature is used to streamline
    these feature commits as they are merged.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 多个功能分支的历史交织在一起，通常比有用更令人困惑，因此 Git 的`rebase`功能用于在合并时精简这些功能提交。
- en: 'Feature 1 is merged first, so it uses the original base commit. The history
    now looks like this:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 特性 1 先合并，所以它使用了原始的基础提交。历史现在看起来是这样的：
- en: '![](img/B19251_14_02.png)'
  id: totrans-120
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B19251_14_02.png)'
- en: 'Figure 14.2: Feature 1 rebased/merged Jan 13th'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 图 14.2：特性 1 已变基/合并 1月13日
- en: 'Feature 3 is the next to be rebased and merged, so now the history looks like
    this:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 特性 3 是下一个需要变基并合并的分支，所以现在历史看起来是这样的：
- en: '![](img/B19251_14_03.png)'
  id: totrans-123
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B19251_14_03.png)'
- en: 'Figure 14.3: Feature 3 rebased/merged Jan 14th'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 图 14.3：特性 3 已变基/合并 1月14日
- en: 'Finally, Feature 2 is rebased, resulting in its base commit changing to the
    Jan. 14th Feature 3 commit. Now we have a nice, streamlined history like this:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 最终，特性 2 被变基，导致其基础提交更改为 1月14日的特性 3 提交。现在我们得到了一个简洁流畅的历史，如下所示：
- en: '![](img/B19251_14_04.png)'
  id: totrans-126
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B19251_14_04.png)'
- en: 'Figure 14.4: Feature 2 rebased/merged Jan 15th'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 图 14.4：特性 2 已变基/合并 1月15日
- en: 'GitHub and other centralized Git repository hosts have features that automate
    this process when merging, so you’ll rarely have to rebase manually on the command
    line. However, here’s the process for doing so:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: GitHub 和其他集中式 Git 仓库托管服务在合并时具有自动化此过程的功能，因此你很少需要在命令行上手动变基。然而，下面是执行此操作的过程：
- en: 'Create a new branch and add a commit:'
  id: totrans-129
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新分支并添加一个提交：
- en: '[PRE16]'
  id: totrans-130
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Presuming the base branch is named `main`, and some commits have been added
    since you started developing your branch, you can now “rebase on main”:'
  id: totrans-131
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 假设基础分支名为`main`，并且自从你开始开发分支以来已经有一些提交，你现在可以“基于 main 进行变基”：
- en: '[PRE17]'
  id: totrans-132
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: This will modify the Git history to rebase your branch’s commits on the latest
    `main` commit, as you saw in the graphic above. Because you’re changing existing
    history, this may require force-pushing to the authoritative repository (such
    as the GitHub repository), which can cause other users to have conflicts. Please
    be aware of this when rebasing.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 这将修改 Git 历史，将你分支的提交变基到最新的`main`提交，如上图所示。由于你正在更改现有历史，这可能需要强制推送到权威仓库（例如 GitHub
    仓库），这可能会导致其他用户出现冲突。请在进行变基时注意这一点。
- en: Now that we have identified some of the key terminology and concepts that you
    will come across when using Git, we can overview some good practices for writing
    effective commit messages.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经确定了一些你在使用 Git 时会遇到的关键术语和概念，我们可以概述一些编写有效提交信息的良好实践。
- en: Best practices for commit messages
  id: totrans-135
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 提交信息的最佳实践
- en: As a general rule, “one change per commit, and one commit per change” is the
    way to keep your Git commits – and history – useful.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 一般来说，“每次提交一个更改，每个更改对应一次提交”是保持 Git 提交及历史记录有用的方式。
- en: 'There are many situations where you might only work on one major change, but
    also add a few minor (unrelated) corrections and improvements to the code. These
    unrelated changes should generally be committed separately, though. It’s a good
    idea to keep individual commits focused on the one specific thing you are trying
    to accomplish: a minor fix, fixing a typo, changing style, adding a (single) feature,
    and so on. Even if you end up making multiple interrelated changes at once, it
    might still make sense to split them up into multiple commits later. Committing
    more frequently can make this process a lot easier.'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 有很多情况你可能只处理一个主要的更改，但同时还对代码做了一些小的（无关的）修正和改进。这些无关的更改一般应单独提交。保持每次提交专注于你想要完成的具体任务：小修复、修正拼写错误、改变样式、添加一个（单一的）功能等等，即使你最终一次性做了多个相互关联的更改，稍后将它们拆分成多个提交仍然有意义。更频繁的提交可以使这个过程变得更加简单。
- en: There are many reasons for this rule. One of the most practical reasons is that
    when your commits are small, individual changes can be easily cherry-picked or
    reverted should it become necessary (even if you never expected it while changing
    the code). Having small, tightly focused commits is also helpful when someone
    uses `git blame` to understand a change.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 这个规则有很多原因。最实际的原因之一是，当你的提交很小时，个别的更改可以很容易地被挑选出来或撤销（即使你在修改代码时没有预见到这种需求）。保持小而集中的提交在别人使用`git
    blame`理解更改时也很有帮助。
- en: Good commit messages
  id: totrans-139
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 良好的提交信息
- en: Sometimes, vague suggestions, for example, “keep the commit message short when
    using `git commit`,” can be confusing and hard to follow. For context, it makes
    sense to explain how Git is intended to be used. Git, being a DVCS, allows for
    patches to be sent as emails. As a result, commit messages themselves – in a way
    – take the form of emails. The first line is considered the subject line, giving
    a brief overview of what is done, followed by an empty line and a more verbose
    summary of what was changed.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，一些模糊的建议，例如“在使用`git commit`时保持提交信息简短”，可能会让人困惑且难以遵循。为了更好地理解，首先有必要解释 Git 的使用目的。Git
    作为一个分布式版本控制系统（DVCS），允许通过电子邮件发送补丁。因此，提交信息本身在某种程度上呈现出电子邮件的形式。第一行被视为主题行，简要概述所做的更改，后面跟着一个空行以及对更改的更详细总结。
- en: 'Because this is a very open-ended schema, there are some commonly agreed-upon
    rules. Like all such rules, they may be overridden on a per-project or per-organization
    basis, but here is an overview of what many well-established open-source projects
    do:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这是一个非常开放的框架，因此有一些普遍公认的规则。像所有此类规则一样，它们可以根据项目或组织的不同而被覆盖，但以下是许多知名开源项目的概述做法：
- en: Keep the first line short. It should be a summary using 72 characters or less.
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 保持第一行简短，最好在 72 个字符以内，用于总结。
- en: Make the first line an imperative verb (such as `Add`…, `Fix`…).
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使第一行使用祈使动词（例如`Add`…，`Fix`…）。
- en: Capitalize the subject line.
  id: totrans-144
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使主题行首字母大写。
- en: If you need more than that, add an empty line and a full summary.
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果需要更多内容，可以添加一个空行并提供完整的总结。
- en: Use the body to explain *why* you have made this change. This can be very helpful
    for any future reader using `git blame`.
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用正文部分来解释你为什么进行此更改。这对于未来使用`git blame`的读者来说非常有帮助。
- en: Make sure to describe how you came to your conclusion/implementation, and why
    it is relevant. This is especially important for complex commits and for commits
    that might not immediately make sense to someone who is looking only at the code.
    This can be a tremendous help when tracking down bugs, removing obsolete code
    later, rewriting systems, or just getting into understanding the code.
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 确保描述你是如何得出结论或实现的，以及为什么它相关。这对于复杂的提交尤其重要，特别是那些对仅查看代码的人来说可能并不马上显而易见的提交。这在跟踪错误、删除过时的代码、重写系统或理解代码时可以提供极大的帮助。
- en: Consider whether some of what you’re writing in your commit message might not
    be better added to code comments.
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 考虑一下你在提交信息中写的内容是否可以更好地放到代码注释中。
- en: Imagine a reviewer or future reader having no context at all. Make sure that
    the code changes can be easily understood.
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 假设审阅者或未来的读者完全没有上下文。确保代码更改可以被轻松理解。
- en: With this advice in mind, you should be able to make clear and organized commit
    messages. Next, we will look at some further advice for easily and effectively
    using Git.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这些建议，你应该能够编写清晰且有条理的提交信息。接下来，我们将探讨一些关于如何轻松高效使用 Git 的进一步建议。
- en: GUIs
  id: totrans-151
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 图形用户界面（GUIs）
- en: While this book is strongly focused on building up your command-line skills,
    it’s worth mentioning that there are some graphical tools available that can make
    interacting with Git easier for some use cases.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管本书强烈关注提升你的命令行技能，但值得一提的是，确实有一些图形化工具可以在某些使用场景下让与 Git 的交互更加容易。
- en: '`tig` and `gitk` are two examples of graphical repository browsers, which give
    you a Git interface that’s similar to what many IDEs provide. To try them out,
    simply navigate to a repository using `cd` and run `gitk` or `tig`. You’ll likely
    have to install these tools via your package manager; many Unix flavors (including
    popular Linux distributions and macOS) don’t have them installed by default.'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: '`tig` 和 `gitk` 是两个图形化仓库浏览工具，它们为你提供一个类似许多 IDE 提供的 Git 界面。要尝试它们，只需使用 `cd` 导航到仓库并运行
    `gitk` 或 `tig`。你可能需要通过包管理器安装这些工具；许多 Unix 系统（包括流行的 Linux 发行版和 macOS）默认没有安装它们。'
- en: Useful shell aliases
  id: totrans-154
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 有用的 shell 别名
- en: 'Here are a few useful shell aliases for common Git commands. Feel free to add
    these to your `~/.bash_aliases` file (presuming you’re using Bash):'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一些常用 Git 命令的有用 shell 别名。你可以将这些别名添加到你的`~/.bash_aliases`文件中（假设你正在使用 Bash）：
- en: '[PRE18]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: If you’re typing in `git status` dozens of times each day, it can be a huge
    improvement to add an alias that enables you to type `gs` instead. Feel free to
    change these to something even more convenient – that’s what customization is
    for!
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你每天都要敲很多次 `git status`，那么添加一个别名让你只需输入 `gs` 可能会带来巨大的改善。你可以随意将这些别名更改为更方便的名称——这正是自定义的意义所在！
- en: 'Now let’s zoom out a bit and see how we can practically apply all of this knowledge
    while building a small Linux server project: your very own private Git server.'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们稍微 zoom out（拉远视角），看看如何在构建一个小型 Linux 服务器项目时实际应用所有这些知识：你自己的私人 Git 服务器。
- en: Poor man’s GitHub
  id: totrans-159
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 穷人的 GitHub
- en: In this section, we’ll show you how to set up a remote Git repository for yourself.
    You only need an SSH account on the remote machine and a Git binary on your local
    machine (as in, the Git command itself). If Git is already installed on the remote
    machine, you won’t even need root access.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一部分，我们将向你展示如何为自己设置一个远程 Git 仓库。你只需要一个远程机器上的 SSH 账户和本地机器上的 Git 二进制文件（即 Git 命令本身）。如果远程机器上已经安装了
    Git，你甚至不需要 root 权限。
- en: This is a fun project that will make you comfortable with the basic OS-facing
    concepts involved with Git. This setup is not necessarily suggested for production
    use; rather, it will show you that there’s absolutely no magic when it comes to
    Git. Like everything else in Linux, it’s just files (in this case, remote files
    and an SSH tunnel).
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个有趣的项目，它会让你熟悉 Git 所涉及的基本操作系统概念。这个设置不一定适合生产环境使用；相反，它会告诉你 Git 并没有什么神奇之处。就像
    Linux 中的其他一切一样，它只是文件（在这个案例中，是远程文件和一个 SSH 隧道）。
- en: Considerations
  id: totrans-162
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 注意事项
- en: Depending on whether you have root access and whether you want to share the
    repository with others, you might want to consider creating a specific user for
    your shared Git service. This is completely optional.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 根据你是否有 root 权限以及是否希望与他人共享仓库，你可能需要考虑为共享的 Git 服务创建一个专用用户。这是完全可选的。
- en: We will use an SSH account for authentication, so if you share the Git repository,
    the person you share it with will have the same permissions as that user on the
    remote machine. It might make sense to create a separate user on the remote machine
    for this project (named `git`) if you don’t fully trust your fellow programmers
    to have access to this account.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用一个 SSH 账户进行身份验证，因此，如果你共享 Git 仓库，与你共享的人将拥有该用户在远程机器上的相同权限。如果你不完全信任其他程序员访问此账户，可能需要在远程机器上为此项目创建一个单独的用户（命名为
    `git`）。
- en: 'This project assumes you’re comfortable setting up SSH and connecting to a
    server – if you’re a bit rusty on the details, check out the previous chapter:
    *Chapter 13*, *Secure Remote Access with SSH*.'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 本项目假设你能熟练地设置 SSH 并连接到服务器——如果你对细节有些生疏，可以参考上一章：*第十三章*，*使用 SSH 进行安全远程访问*。
- en: 1\. Connect to your server
  id: totrans-166
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 1\. 连接到你的服务器
- en: 'Connect to the server, using the account you want your repository to belong
    to (such as git, or your own user):'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 使用你希望仓库属于的帐户连接到服务器（例如 git 或你的用户帐户）：
- en: '[PRE19]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 2\. Install Git
  id: totrans-169
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 2\. 安装 Git
- en: 'First, check if Git is already installed by running:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，通过运行以下命令检查 Git 是否已经安装：
- en: '[PRE20]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: This should output the version of Git that is installed on your server. If you
    receive a message like `command not found`, then Git is not installed on your
    system.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 这应该会输出安装在服务器上的 Git 版本。如果你收到类似`command not found`的消息，那么说明 Git 并没有安装在你的系统上。
- en: 'To install Git, simply use your system’s package manager to install the `git`
    package. On Ubuntu, you’d run:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 要安装 Git，只需使用系统的包管理器安装`git`包。在 Ubuntu 上，你可以运行以下命令：
- en: '[PRE21]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 3\. Initialize a repository
  id: totrans-175
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 3\. 初始化仓库
- en: 'Now you can initialize a new bare repository. In this case, we will call it
    `my-project`. You can create this wherever you want. For the sake of simplicity,
    we will assume that it is your home directory:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你可以初始化一个新的裸仓库。在这种情况下，我们将其命名为`my-project`。你可以在任何你想要的位置创建它。为了简便起见，我们假设它位于你的主目录下：
- en: '[PRE22]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: This will create a directory called `my-project.git`. It is not a file, but
    a directory structure that Git considers a repository. We won’t go into detail
    here and it will probably be quite a while before you need to change something.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 这将创建一个名为`my-project.git`的目录。它不是一个文件，而是 Git 认为是仓库的目录结构。我们在这里不深入讨论，实际上在很长一段时间内，你可能不需要做任何更改。
- en: Believe it or not, that’s actually all you need to do!
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 信不信由你，其实这就是你需要做的所有步骤！
- en: You can now disconnect from the server (*Ctrl*+*D* if you’re connected via SSH).
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你可以断开与服务器的连接（如果你通过 SSH 连接，可以按 *Ctrl*+*D*）。
- en: 4\. Clone the repository
  id: totrans-181
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 4\. 克隆仓库
- en: 'Despite it being completely empty, you can already clone the repository. After
    disconnecting from your server, run the following command from your local machine:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管仓库完全为空，你已经可以克隆它了。在断开与服务器的连接后，从本地机器运行以下命令：
- en: '[PRE23]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: As mentioned earlier, this assumes that you created the repository in the home
    directory of the `myuser` user. Starting after the `example.com` hostname (this
    might also just be your server’s IP address if you haven’t set up DNS), the path
    is relative to the user’s home directory. If you want to specify a full (absolute)
    path, just start with a slash. In other words, using the command `git clone myuser@example.com:/home/myuser/my-project.git`
    would lead to the same directory being cloned.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，这假设你在`myuser`用户的主目录下创建了仓库。从`example.com`主机名后开始（如果你没有设置 DNS，这可能只是服务器的 IP
    地址），路径是相对于用户主目录的。如果你想指定完整（绝对）路径，只需从斜杠开始。换句话说，使用命令`git clone myuser@example.com:/home/myuser/my-project.git`也会克隆相同的目录。
- en: Git will warn you that you cloned an empty repository. But since this is what
    we expect, there’s no need to worry.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: Git 会警告你克隆了一个空仓库。但由于这是我们预期的结果，所以无需担心。
- en: 5\. Edit the project and push your changes
  id: totrans-186
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 5\. 编辑项目并推送你的更改
- en: 'We can now switch to the cloned directory and start working on the project:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以切换到克隆的目录并开始进行项目工作：
- en: '[PRE24]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Now that we have our first commit, we can push it. The very first push has
    a minor caveat to be aware of: because the repository is still completely empty,
    it doesn’t know any branches yet, not even the master branch. Git will tell you
    this if you only run `git push`. So just make sure to tell Git the branch when
    pushing to a new repository for the very first time:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了第一次提交，可以将其推送到远程仓库。第一次推送有一个小注意事项：由于仓库仍然是完全空的，它还没有任何分支，甚至连 master 分支都没有。如果你仅仅运行`git
    push`，Git 会告诉你这一点。所以，在第一次推送到一个新仓库时，只需确保告诉 Git 分支信息：
- en: '[PRE25]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: That’s it!
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 就是这样！
- en: Now you or someone else with access to your SSH account can clone, push to,
    and pull from this repository. You can even set up hooks and do other fun things.
    Git is a very powerful tool with a huge variety of features. It can take a while
    to get used to them, so just consider this your starting point.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你或其他有权限访问你 SSH 帐户的人可以克隆、推送和拉取这个仓库。你甚至可以设置钩子并做其他有趣的事情。Git 是一个非常强大的工具，拥有丰富的功能。可能需要一段时间才能习惯这些功能，所以就把这当作你的起点吧。
- en: The possibilities are endless, and I’m always excited to hear about people using
    Git for interesting or unique use cases. Have fun!
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 可能性是无限的，我总是很高兴听到人们使用 Git 来处理有趣或独特的用例。祝你玩得开心！
- en: Conclusion
  id: totrans-194
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 结论
- en: In this chapter, you learned the basic concepts, commands, and workflows that
    you need to use Git effectively. Some of the often-used advanced features and
    terminology should be clearer to you now, and we passed on some advice for “soft”
    Git skills like writing good commit messages.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你学习了使用 Git 的基本概念、命令和工作流程。现在你应该对一些常用的高级功能和术语有了更清晰的了解，我们还传授了一些关于“软” Git 技能的建议，例如如何写好提交信息。
- en: The shell aliases we showed you save us hundreds of keystrokes in a day of programming;
    we hope they are as useful to you as they have been to us, and that you’ll use
    command aliases for all the hard-to-remember or hard-to-type commands you run
    daily.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 我们展示的 shell 别名在一天的编程中为我们节省了数百个击键；我们希望它们对你也同样有用，并且你会为所有那些难以记住或难以输入的命令使用命令别名。
- en: We also hope that you followed along with the *Poor man’s GitHub* project! Running
    the commands only takes a few minutes, but if you take an afternoon and really
    try it out (rent a Linux VM for a few hours, set up a remote repository there,
    and push some example commits), you’ll get a feel for how powerful and effective
    your newfound Linux skills can be when they’re combined to solve real-world problems.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还希望你能跟随 *贫民版 GitHub* 项目一起操作！运行这些命令只需要几分钟，但如果你花一个下午时间深入尝试（租一台 Linux 虚拟机几个小时，在上面设置一个远程仓库并推送一些示例提交），你会感受到当你将新学的
    Linux 技能结合起来解决实际问题时，它们是多么强大和高效。
- en: Learn more on Discord
  id: totrans-198
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在 Discord 上了解更多
- en: 'To join the Discord community for this book – where you can share feedback,
    ask questions to the author, and learn about new releases – follow the QR code
    below:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 要加入本书的 Discord 社区——在这里你可以分享反馈、向作者提问并了解新版本——请扫描下面的二维码：
- en: '[https://packt.link/SecNet](https://packt.link/SecNet)'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://packt.link/SecNet](https://packt.link/SecNet)'
- en: '![](img/QR_Code1768422420210094187.png)'
  id: totrans-201
  prefs: []
  type: TYPE_IMG
  zh: '![](img/QR_Code1768422420210094187.png)'
