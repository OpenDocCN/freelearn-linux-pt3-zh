<html><head></head><body><div id="book-content"><div id="sbo-rt-content"><div id="_idContainer015" class="Basic-Text-Frame">
    <h1 class="chapterNumber"><a id="_idTextAnchor016"/>1</h1>
    <h1 id="_idParaDest-15" class="chapterTitle"><a id="_idTextAnchor017"/>Starting Out</h1>
    <p class="normal">You are about to begin working on your next project, and this time, it is going to run Linux. What should you think about before you put finger to keyboard? Let’s begin with a high-level look at embedded Linux and see why it is popular, what the implications of open source licenses are, and what kind of hardware you need to run it.</p>
    <p class="normal">Linux first became a viable choice for embedded devices around 1999. That was when AXIS released the 2100 Network <a id="_idIndexMarker000"/>Camera and TiVo released their first <strong class="keyWord">Digital Video Recorder</strong> (<strong class="keyWord">DVR</strong>). Both were the first Linux-powered devices in their category. Since 1999, Linux has become increasingly popular to the point that today it is the <strong class="keyWord">Operating System</strong> (<strong class="keyWord">OS</strong>) of choice for <a id="_idIndexMarker001"/>many classes of product. In 2024, there were over three billion devices running Linux. That includes all the smartphones running Android, which uses a Linux kernel, and hundreds of millions of set-top boxes, smart TVs, and Wi-Fi routers. We must not forget other devices, such as vehicle diagnostics, industrial equipment, and medical monitoring units, that ship in smaller volumes.</p>
    <p class="normal">In this chapter, we will cover the following topics:</p>
    <ul>
      <li class="bulletList">Choosing Linux</li>
      <li class="bulletList">When not to choose Linux</li>
      <li class="bulletList">Meeting the players</li>
      <li class="bulletList">Moving through the project life cycle</li>
      <li class="bulletList">Navigating open source</li>
      <li class="bulletList">Selecting hardware for embedded Linux</li>
      <li class="bulletList">Obtaining the hardware for this book</li>
      <li class="bulletList">Provisioning your development environment</li>
    </ul>
    <h1 id="_idParaDest-16" class="heading-1"><a id="_idTextAnchor018"/>Choosing Linux</h1>
    <p class="normal">Why is Linux so pervasive? And why does something as simple as a TV need to run something as complex as Linux just to display streaming video on a screen?</p>
    <p class="normal">The simple <a id="_idIndexMarker002"/>answer is <strong class="keyWord">Moore’s law</strong>. Gordon Moore, cofounder of Intel, observed in 1965 that the density of components on a chip doubles approximately every two years. That applies to the devices that we design and use in our everyday lives just as much as it does <a id="_idIndexMarker003"/>to desktops, laptops, and servers. At the heart of most embedded devices is a highly integrated chip that contains one or more processor cores and interfaces with main memory, mass storage, and peripherals of many types. This is referred to as a <strong class="keyWord">System on Chip</strong> (<strong class="keyWord">SoC</strong>). SoCs are <a id="_idIndexMarker004"/>increasing in complexity in accordance with Moore’s law. A typical SoC has a technical reference manual that stretches to thousands of pages.</p>
    <p class="normal">Your TV isn’t simply displaying a video stream like the analog sets of old. The stream is digital, possibly encrypted, and needs processing to produce an image. Your TV is (or soon will be) connected to the internet. It can receive content from smartphones, tablets, laptops, desktops, and home media servers. It can be used to play games, stream video, and display live feeds from security cameras. You need a full OS to manage this degree of complexity.</p>
    <p class="normal">Here are some points that drive the adoption of Linux:</p>
    <ul>
      <li class="bulletList">Linux has the necessary functionality. It has a good scheduler, a good network stack, support for USB, Wi-Fi, Bluetooth, many kinds of storage media, multimedia devices, and so on. It ticks all the boxes.</li>
      <li class="bulletList">Linux has been ported to a wide range of processor architectures, including some that are very commonly found in SoC designs – Arm, RISC-V, x86, PowerPC, and MIPS.</li>
      <li class="bulletList">Linux is open source, so you have the freedom to get the source code and modify it to meet your needs. You or someone working on your behalf can create a board support package for your device. You can add protocols, features, and technologies that may be missing from the mainline source code. You can remove features that you don’t need to reduce memory and storage requirements. Linux is flexible.</li>
      <li class="bulletList">Linux has an active community (in the case of the Linux kernel, very active). There is a new release of the kernel every 8 to 10 weeks, and each release contains code from more than 1,000 developers. An active community means that Linux is up to date and supports current hardware, protocols, and standards. The Linux Foundation is a non-profit organization with backing from big tech. </li>
    </ul>
    <p class="normal">The foundation acts as a steward for several major open source projects besides Linux, including Kubernetes and PyTorch. It also hosts yearly events around the world like the Open Source Summit and Linux Plumbers Conference.</p>
    <ul>
      <li class="bulletList">Open source licenses guarantee that you have access to the source code. There is no vendor lock-in.</li>
    </ul>
    <p class="normal">For these reasons, Linux is an <a id="_idIndexMarker005"/>ideal choice for complex devices. But there are a few caveats I should mention here. Complexity makes it harder to understand. Coupled with the fast-moving development process and the decentralized structures of open source, you need to put some effort into learning how to use it and to keep on re-learning as it changes. I hope that this book helps in the process.</p>
    <h1 id="_idParaDest-17" class="heading-1"><a id="_idTextAnchor019"/>When not to choose Linux</h1>
    <p class="normal">Is Linux suitable for your project? Linux works well where the problem being solved justifies the complexity. It is <a id="_idIndexMarker006"/>especially good where connectivity, robustness, and complex user interfaces are required. However, it cannot solve every problem, so here are some things to consider before you jump in:</p>
    <ul>
      <li class="bulletList">Is your <a id="_idIndexMarker007"/>hardware up to the job? Compared to a traditional <strong class="keyWord">Real-Time Operating System</strong> (<strong class="keyWord">RTOS</strong>) such as VxWorks or QNX, Linux requires a lot more resources. It needs at least a 32-bit processor and lots more memory. I will go into more detail in the <em class="italic">Selecting hardware for embedded Linux</em> section.</li>
      <li class="bulletList">Do you have the right skill set? The early parts of a project, the board bring-up, require detailed knowledge of Linux and how it relates to your hardware. Likewise, when debugging and tuning your application you will need to be able to interpret the results. If you don’t have the skills in-house you may want to outsource some of the work. Of course, reading this book helps!</li>
      <li class="bulletList">Is your system real time? Linux can handle many real-time activities as long as you pay attention to certain details, which I cover in depth in <a href="Chapter_19.xhtml#_idTextAnchor654"><em class="italic">Chapter 21</em></a>.</li>
      <li class="bulletList">Will your code require regulatory approval (medical, automotive, aerospace, and so on)? The burden of regulatory verification and validation might make another OS a better choice. Even if you do choose Linux for use in these environments, it may make sense to purchase a commercially available distribution from a company that has supplied Linux for existing products like the one you are building. These commercial Linux vendors include Siemens, Timesys, and Wind River.</li>
    </ul>
    <p class="normal">Consider these <a id="_idIndexMarker008"/>points carefully. Probably the best indicator of success is to look around for similar products that run Linux and see how they did it, and follow best practices.</p>
    <h1 id="_idParaDest-18" class="heading-1"><a id="_idTextAnchor020"/>Meeting the players</h1>
    <p class="normal">Where does open source software come from? Who writes it? In particular, how does it relate to <a id="_idIndexMarker009"/>the key components of embedded development – the toolchain, bootloader, kernel, and basic utilities found in the root filesystem?</p>
    <ul>
      <li class="bulletList"><strong class="keyWord">Open source community</strong>: This, after all, is the engine that generates the software you are going to be using. The community is a loose alliance of developers many of whom are funded in some way by a non-profit organization, an academic institution, or a commercial company. They work together to further the aims of the various projects. There are many of them – some small, some large. Some that we will make use of are Linux itself, U-Boot, BusyBox, Buildroot, The Yocto Project, and the many projects under the GNU umbrella.</li>
      <li class="bulletList"><strong class="keyWord">CPU architects</strong>: These are the organizations that design the CPUs we use. The important ones here are Arm/Linaro (Arm Cortex-A), Intel (x86 and x86-64), SiFive (RISC-V), and IBM (PowerPC). They implement or at the very least influence support for the basic CPU architecture.</li>
      <li class="bulletList"><strong class="keyWord">SoC vendors</strong>: These include Broadcom, Intel, Microchip, NXP, Qualcomm, TI, and many others. They take the kernel and toolchain from the CPU architects and modify them to support their chips. They also create reference boards: designs that are used by the next level down to create development boards and working products.</li>
      <li class="bulletList"><strong class="keyWord">Board vendors and OEMs</strong>: These people take the reference designs from SoC vendors and build them into specific products like set-top boxes or cameras. They also <a id="_idIndexMarker010"/>create more general-purpose development boards such as those from Advantech and Kontron. An important category is the cheap <strong class="keyWord">Single-Board Computers</strong> (<strong class="keyWord">SBCs</strong>) such as BeagleBoard and Raspberry Pi, which have created their own ecosystems of software and hardware add-ons.</li>
      <li class="bulletList"><strong class="keyWord">Commercial Linux vendors</strong>: Companies such as Siemens, Timesys, and Wind River offer commercial Linux distributions that have undergone strict regulatory verification and validation across multiple industries (medical, automotive, aerospace, and so on).</li>
    </ul>
    <p class="normal">These form a chain, with your project usually at the end, which means that you do not have a free choice of components. You cannot simply take the latest kernel from kernel.org, except in rare cases, because it does not have support for the chip or board that you are using.</p>
    <p class="normal">This is an <a id="_idIndexMarker011"/>ongoing problem with embedded development. Ideally, the developers at each link in the chain would push their changes upstream but they don’t. Developers are under constant time pressure and getting patches accepted into the Linux kernel takes major effort. It is not uncommon to find a kernel that has many thousands of patches that are not merged. In addition, SoC vendors tend to actively develop open source components only for their latest chips, meaning that support for any chip more than a couple of years old will be frozen and not receive any updates.</p>
    <p class="normal">The consequence is that most embedded designs are based on old versions of software. They do not receive security fixes, performance enhancements, or features that are in newer versions. Problems such as Heartbleed (a bug in the OpenSSL library) and Shellshock (a bug in the Bash shell) go unfixed.</p>
    <p class="normal">What can you do about it? First, ask questions of your vendors (NXP, TI, and Xilinx to name just a few): what is their update policy, how often do they revise kernel versions, what is the current kernel version, what was the one before that, and what is their policy for merging changes upstream? Some vendors are making great strides in this direction. You should prefer their chips.</p>
    <p class="normal">Secondly, you can take steps to make yourself more self-sufficient. The chapters in <em class="italic">Part 1</em> explain the dependencies in more detail and show you where you can help yourself. Don’t just take the package offered to you by the SoC or board vendor and use it blindly without considering the alternatives.</p>
    <h1 id="_idParaDest-19" class="heading-1"><a id="_idTextAnchor021"/>Moving through the project life cycle</h1>
    <p class="normal">This book is <a id="_idIndexMarker012"/>divided into five sections that reflect the phases of a project. The phases are not necessarily sequential. Usually, they overlap, and you will need to jump back to revisit things that were done previously. However, they are representative of a developer’s preoccupations as the project progresses:</p>
    <ul>
      <li class="bulletList"><em class="italic">Elements of Embedded Linux (Chapters 1 to 5)</em> will help you set up the development environment and create a working platform for the later phases. It is often <a id="_idIndexMarker013"/>referred to as the <strong class="keyWord">board bring-up</strong> phase.</li>
      <li class="bulletList"><em class="italic">Building Embedded Linux Images (Chapters 6 to 8)</em> shows you how to automate the process of building an embedded Linux image by leveraging a build system like Buildroot or The Yocto Project. Automating complex build tasks accelerates the project life cycle so that teams can deliver higher-quality products in less time.</li>
      <li class="bulletList"><em class="italic">System Architecture and Design Choices (Chapters 9 to 14)</em> will inform some of the design <a id="_idIndexMarker014"/>decisions you will have to make concerning the storage of programs and data, how to divide work between kernel device drivers and applications, and how to initialize the system.</li>
      <li class="bulletList"><em class="italic">Developing Applications (Chapters 15 to 18)</em> shows you how to package and deploy Python applications, make effective use of the Linux process and thread model, and manage memory in a resource-constrained device. What do packaging and deploying Python applications have to do with embedded Linux? The answer is “not much”, but bear in mind that the word “development” also happens to be in the title of this book. And <em class="italic">Chapters 15 and 16</em> have everything to do with modern-day software development.</li>
      <li class="bulletList"><em class="italic">Debugging and Optimizing Performance (Chapters 19 to 21)</em> describes how to trace, profile, and debug your code in both the application and the kernel. The last chapter explains how to design for real-time behavior when required.</li>
    </ul>
    <p class="normal">Now, let’s focus on the four basic elements of embedded Linux that comprise the first section of the book.</p>
    <h1 id="_idParaDest-20" class="heading-1"><a id="_idTextAnchor022"/>The four elements of embedded Linux</h1>
    <p class="normal">Every project begins by obtaining, customizing, and deploying these four elements: the toolchain, the <a id="_idIndexMarker015"/>bootloader, the kernel, and the root filesystem. This is the topic of the first section of this book.</p>
    <ul>
      <li class="bulletList"><strong class="keyWord">Toolchain</strong>: This is <a id="_idIndexMarker016"/>the cross compiler and other tools needed to create code for your target device. A cross compiler generates machine code for a target CPU architecture while running on a different host CPU architecture.</li>
      <li class="bulletList"><strong class="keyWord">Bootloader</strong>: This is a <a id="_idIndexMarker017"/>bare metal program that initializes the board and the Linux kernel. The term “bare metal” means the program runs directly on the CPU, not on top of an OS.</li>
      <li class="bulletList"><strong class="keyWord">Kernel</strong>: This is the <a id="_idIndexMarker018"/>heart of the system, managing system resources and interfacing with the hardware.</li>
      <li class="bulletList"><strong class="keyWord">Root filesystem</strong>: This contains <a id="_idIndexMarker019"/>the libraries and programs that are run once the kernel has completed its initialization.</li>
    </ul>
    <p class="normal">There is also a fifth element not mentioned here. That is the collection of programs specific to your embedded application that make the device do whatever it is supposed to do, be it weighing groceries, displaying movies, controlling a robot, or flying a drone.</p>
    <p class="normal">Typically, you will be <a id="_idIndexMarker020"/>offered some or all of these elements as a package when you buy your SoC or board. But for the reasons mentioned earlier, they may not be the best choices for you. In the first eight chapters, I will give you the background to make the right selection and introduce two tools that automate the whole process for you: Buildroot and The Yocto Project.</p>
    <h1 id="_idParaDest-21" class="heading-1"><a id="_idTextAnchor023"/>Navigating open source</h1>
    <p class="normal">The components <a id="_idIndexMarker021"/>of embedded Linux are <em class="italic">open source</em> so now is a good time to consider what that means, why open source licenses work the way they do, and how this affects the often proprietary embedded device you will be creating from it.</p>
    <h2 id="_idParaDest-22" class="heading-2"><a id="_idTextAnchor024"/>Licenses</h2>
    <p class="normal">When talking about open source the word <em class="italic">free</em> is often used. People new to the subject often take it to mean <em class="italic">nothing to pay</em> and open source software licenses do indeed guarantee that you can <a id="_idIndexMarker022"/>use the software to develop and deploy systems for no charge. However, the more important meaning here is freedom since you are free to obtain the source code, modify it in any way you see fit, and redeploy it in other systems. Open source licenses give you this right, but some also require you to share these changes with the public.</p>
    <p class="normal">Compare that with freeware licenses, which allow you to copy the binaries for no cost but do not give you the source code. Other licenses allow you to use the software for free under certain circumstances, for example, for personal use, but not commercial. These are not open source.</p>
    <p class="normal">I will provide the following comments in the interest of helping you understand the implications of working with open source licenses, but I would like to point out that I am an engineer and not a lawyer. What follows is my understanding of the licenses and how they are interpreted.</p>
    <p class="normal">Open source licenses <a id="_idIndexMarker023"/>fall broadly into two categories:</p>
    <ul>
      <li class="bulletList"><em class="italic">Copyleft</em> licenses <a id="_idIndexMarker024"/>such as <a id="_idIndexMarker025"/>the GNU<strong class="keyWord"> General Public License</strong> (<strong class="keyWord">GPL</strong>)</li>
      <li class="bulletList">Permissive <a id="_idIndexMarker026"/>licenses <a id="_idIndexMarker027"/>such as the <strong class="keyWord">BSD</strong> and <strong class="keyWord">MIT</strong> licenses</li>
    </ul>
    <p class="normal">The permissive <a id="_idIndexMarker028"/>licenses say, in essence, that you may modify the source code and <a id="_idIndexMarker029"/>use it in systems of your own choosing as long as you do not modify the terms of the license in any way. In other words, apart from that one restriction, you can do with it what you want, including building it into possibly proprietary systems.</p>
    <p class="normal">The GPL licenses are similar but have clauses that compel you to pass the rights to obtain and modify the software on to your end users. In other words, you share your source code. One option is to make it completely public by putting it onto a public server. Another is to offer it only to your end users by means of a written offer to provide the code when requested.</p>
    <p class="normal">The GPL goes <a id="_idIndexMarker030"/>further to say that you cannot incorporate GPL code into proprietary programs. Any attempt to do so would make the GPL apply to the whole. In other words, you cannot combine GPL and proprietary code in the same program. Aside from the Linux kernel, the GNU Compiler Collection and GNU Debugger, as well as many other freely available tools associated with the GNU project, fall under the umbrella of the GPL.</p>
    <p class="normal">So, what about libraries? If they are licensed with the GPL, any program linked with them becomes GPL also. However, most <a id="_idIndexMarker031"/>libraries are licensed under the GNU<strong class="keyWord"> Lesser General Public License</strong> (<strong class="keyWord">LGPL</strong>). If this is the case, you are allowed to link with them from a proprietary program.</p>
    <div class="note">
      <p class="normal"><strong class="keyWord">IMPORTANT NOTE</strong></p>
      <p class="normal">All of the preceding descriptions relate specifically to the GPL v2 and LGPL v2. I should mention the latest versions of the GPL v3 and LGPL v3. These are controversial and I will admit that I don’t fully understand the implications. However, the intention is to ensure that the GPL v3 and LGPL v3 components in any system can be replaced by the end user, which is in the spirit of open source software for everyone.</p>
    </div>
    <p class="normal">The GPL v3 and LGPL v3 have their problems though. There are security issues. If the owner of a device has access to the system code, then so might an unwelcome intruder. Often the defense is to have kernel images signed by an authority such as the vendor so that unauthorized updates are not possible. Is that an infringement of my right to modify my device? Opinions differ.</p>
    <div class="note">
      <p class="normal"><strong class="keyWord">IMPORTANT NOTE</strong></p>
      <p class="normal">The TiVo set-top box is an important part of this debate. It uses a Linux kernel, which is licensed under the GPL v2. TiVo has released the source code of their version of the kernel in compliance with the license. TiVo also has a bootloader that will only load a kernel binary that is signed by them. Consequently, you can build a modified kernel for a TiVo box, but you cannot load it on the hardware.</p>
      <p class="normal">The <strong class="keyWord">Free Software Foundation</strong> (<strong class="keyWord">FSF</strong>) takes the <a id="_idIndexMarker032"/>position that this is not in the spirit of open source software and refers to this procedure as <strong class="keyWord">tivoization</strong>. The GPL v3 and LGPL v3 were written explicitly to prevent this from happening. Some projects, the Linux kernel in particular, have been reluctant to adopt the GPL version 3 licenses because of the restrictions they place on device manufacturers.</p>
    </div>
    <h1 id="_idParaDest-23" class="heading-1"><a id="_idTextAnchor025"/>Selecting hardware for embedded Linux</h1>
    <p class="normal">If you are <a id="_idIndexMarker033"/>designing or selecting hardware for an embedded Linux project, what do you look out for?</p>
    <ul>
      <li class="bulletList">First, a CPU architecture that is supported by the kernel – unless you plan to add a new architecture yourself of course! Looking at the source code for Linux 5.15 there are 23 architectures each represented by a subdirectory in the <code class="inlineCode">arch/</code> directory. They are all 32-or 64-bit architectures, most with an MMU, but some without. The ones <a id="_idIndexMarker034"/>most often found in embedded devices are Arm, RISC-V, PowerPC, MIPS, and x86 each in 32-and 64-bit variants all of which have <strong class="keyWord">Memory Management Units</strong> (<strong class="keyWord">MMUs</strong>).</li>
      <li class="bulletList">Most of this book is written with this class of processor in mind. There is another group that <a id="_idIndexMarker035"/>doesn’t have an MMU and that runs a subset of Linux <a id="_idIndexMarker036"/>known as a <strong class="keyWord">microcontroller Linux</strong> or <strong class="keyWord">uClinux</strong>. These processor architectures include <strong class="keyWord">ARC</strong> (<strong class="keyWord">Argonaut RISC Core</strong>), Blackfin, MicroBlaze, and Nios. I will mention uClinux from time to time, but I will not go into detail because it is a rather specialized type.</li>
      <li class="bulletList">Second, you will need a reasonable amount of RAM. 16 MB is a good minimum, although it is quite possible to run Linux using half of that. It is even possible to run Linux with 4 MB if you are prepared to go to the trouble of optimizing every part of the system. It may even be possible to get lower, but there comes a point at which it is no longer Linux.</li>
      <li class="bulletList">Third, there is non-volatile storage, usually flash memory. 8 MB is enough for a simple device such as a webcam or basic router. As with RAM, you can create a workable Linux system with less storage if you really want to, but the lower you go the harder it becomes. Linux has extensive support for flash storage devices, including raw NOR and NAND flash chips, and managed flash in the form of SD cards, eMMC chips, USB flash memory, and so on.</li>
      <li class="bulletList">Fourth, a serial port is very useful, preferably a UART-based serial port. It does not have to be fitted on production boards but makes board bring-up, debugging, and development much easier.</li>
      <li class="bulletList">Fifth, you need some means of loading software when starting from scratch. Many <a id="_idIndexMarker037"/>microcontroller boards are fitted with a <strong class="keyWord">Joint Test Action Group</strong> (<strong class="keyWord">JTAG</strong>) interface for this purpose. Modern SoCs can also load boot code directly from the removable media, especially SD and microSD cards, or serial interfaces such as QSPI or USB.</li>
    </ul>
    <p class="normal">In addition <a id="_idIndexMarker038"/>to these basics, there are interfaces to the specific bits of hardware your device needs to get its job done. Mainline Linux comes with open source drivers for many thousands of different devices, and there are drivers available (of variable quality) from the SoC manufacturer and from the OEMs of third-party chips that may be included in the design.</p>
    <p class="normal">Remember my comments on the commitment and ability of some manufacturers. As a developer of embedded systems, you will find that you spend quite a lot of time evaluating and adapting third-party code, if you have it, or liaising with the manufacturer if you don’t. Finally, you will have to write the device support for the interfaces that are unique to the device or find someone to do it for you.</p>
    <h1 id="_idParaDest-24" class="heading-1"><a id="_idTextAnchor026"/>Obtaining the hardware for this book</h1>
    <p class="normal">The examples in this book are intended to be generic. To make them relevant and easy to follow I have <a id="_idIndexMarker039"/>had to choose specific hardware. I have chosen three exemplary devices: the Raspberry Pi 4, BeaglePlay, and QEMU. The first is by far the most popular Arm-based SBC on the market. The second is a widely available SBC that can also be used in serious embedded hardware. The third is a machine emulator that can be used to create a range of systems that are typical of embedded hardware.</p>
    <p class="normal">It was tempting to use QEMU exclusively, but like all emulations, it is not quite the same as the real thing. Using the Raspberry Pi 4 and BeaglePlay, you have the satisfaction of interacting with real hardware and seeing real LEDs flash. The BeaglePlay, like the BeagleBone Black before it, is <em class="italic">open source hardware</em>, unlike the Raspberry Pi 4. This means that the board design materials are freely available for anyone to build the BeaglePlay or a derivative into their products.</p>
    <p class="normal">In any case, I encourage you to try out as many of the examples as you can, using either of these three platforms or any embedded hardware you may have on hand.</p>
    <h2 id="_idParaDest-25" class="heading-2"><a id="_idTextAnchor027"/>The Raspberry Pi 4</h2>
    <p class="normal">From June 2019 until October 2023, the Raspberry Pi 4 Model B was the flagship SBC produced by <a id="_idIndexMarker040"/>the Raspberry Pi Foundation. The Raspberry Pi 4’s technical <a id="_idIndexMarker041"/>specs include the following:</p>
    <ul>
      <li class="bulletList">A Broadcom BCM2711 1.5 GHz quad-core Cortex-A72 (Arm v8) 64-bit SoC</li>
      <li class="bulletList"><a id="_idTextAnchor028"/>2, 4, or 8 GB DDR4 RAM</li>
      <li class="bulletList">2.4 GHz and 5 GHz 802.11ac wireless, Bluetooth 5.0, BLE</li>
      <li class="bulletList">A serial port for debugging and development</li>
      <li class="bulletList">A microSD slot, which can be used as a boot device</li>
      <li class="bulletList">A USB-C connector to power the board</li>
      <li class="bulletList">Two full-size USB 3.0 and two full-size USB 2.0 host ports</li>
      <li class="bulletList">A Gigabit Ethernet port</li>
      <li class="bulletList">Two micro HDMI ports for video and audio output</li>
    </ul>
    <p class="normal">In addition, there is a 40-pin expansion header for which there are a great variety of daughter <a id="_idIndexMarker042"/>boards known as <strong class="keyWord">Hardware Attached on Top </strong>(<strong class="keyWord">HATs</strong>) that allow you to adapt the board to do many different things. However, you will not need any HATs for the examples in this book.</p>
    <p class="normal">In addition to the board itself you will require the following:</p>
    <ul>
      <li class="bulletList">A microSD card and a means of writing to it from your development PC or laptop</li>
      <li class="bulletList">A USB-to-TTL serial cable with a 3.3 V logic level</li>
      <li class="bulletList">A 5 V USB-C power supply capable of delivering 3 A</li>
      <li class="bulletList">An Ethernet cable and a router to plug it into as some of the examples require network connectivity</li>
    </ul>
    <h2 id="_idParaDest-26" class="heading-2"><a id="_idTextAnchor029"/>The BeaglePlay</h2>
    <p class="normal">The BeaglePlay is an open source hardware <a id="_idIndexMarker043"/>design for an SBC produced by the <a id="_idIndexMarker044"/>BeagleBoard.org Foundation. The main points of the specification are:</p>
    <ul>
      <li class="bulletList">A TI AM6254 1.4 GHz Arm quad-core Cortex-A53 (Arm v8) 64-bit Sitara SoC</li>
      <li class="bulletList">2 GB DDR4 RAM</li>
      <li class="bulletList"><a id="_idTextAnchor030"/>16 GB eMMC on-board flash</li>
      <li class="bulletList">2.4 GHz and 5 GHz MIMO Wi-Fi, BLE, Zigbee</li>
      <li class="bulletList">A serial port for debugging and development</li>
      <li class="bulletList">A microSD slot, which can be used as a boot device</li>
      <li class="bulletList">A USB-C connector to power the board</li>
      <li class="bulletList">A full-size USB 2.0 host port</li>
      <li class="bulletList">A Gigabit Ethernet port</li>
      <li class="bulletList">A full-size HDMI port for video and audio output</li>
    </ul>
    <p class="normal">Instead of a <a id="_idIndexMarker045"/>large expansion header, the BeaglePlay has mikroBUS, Grove, and Qwiic interfaces for connecting add-on boards.</p>
    <p class="normal">In addition <a id="_idIndexMarker046"/>to the board itself, you will require the following:</p>
    <ul>
      <li class="bulletList">A microSD card and a means of writing to it from your development PC or laptop</li>
      <li class="bulletList">A USB-to-TTL serial cable with a 3.3 V logic level</li>
      <li class="bulletList">A 5 V USB-C power supply capable of delivering 3 A</li>
      <li class="bulletList">An Ethernet cable and a router to plug it into as some of the examples require network connectivity</li>
    </ul>
    <p class="normal">In addition to the above,<em class="italic"> </em><a href="Chapter_04.xhtml#_idTextAnchor126"><em class="italic">Chapter 12</em></a> also requires the following:</p>
    <ul>
      <li class="bulletList">A MikroE-5764 GNSS 7 Click add-on board </li>
      <li class="bulletList">An external active GNSS antenna with an SMA connector</li>
      <li class="bulletList">A MikroE-5546 Environment Click add-on board</li>
      <li class="bulletList">A MikroE-5545 OLED C Click add-on board</li>
    </ul>
    <h2 id="_idParaDest-27" class="heading-2"><a id="_idTextAnchor031"/>QEMU</h2>
    <p class="normal">QEMU is a machine <a id="_idIndexMarker047"/>emulator. It comes in different flavors, each of which can emulate <a id="_idIndexMarker048"/>a processor architecture and various boards built using that architecture. For example, we have the following:</p>
    <ul>
      <li class="bulletList"><code class="inlineCode">qemu-system-arm</code>: 32-bit Arm</li>
      <li class="bulletList"><code class="inlineCode">qemu-system-aarch64</code>: 64-bit Arm</li>
      <li class="bulletList"><code class="inlineCode">qemu-system-mips</code>: MIPS</li>
      <li class="bulletList"><code class="inlineCode">qemu-system-ppc</code>: Power PC</li>
      <li class="bulletList"><code class="inlineCode">qemu-system-x86</code>: x86 and x86-64</li>
    </ul>
    <p class="normal">For each architecture, QEMU emulates a range of hardware that you can see by using the <code class="inlineCode">-machine help</code> option. Each architecture emulates most of the hardware that would normally be found on that board. There are options to link hardware to local resources, such as using a local file for the emulated disk drive. Here is a concrete example:</p>
    <pre class="programlisting con"><code class="hljs-con">$ qemu-system-arm -machine vexpress-a9 -m 256M -drive file=rootfs.ext4,sd -net nic -net use -kernel zImage -dtb vexpress-v2p-ca9.dtb -append "console=ttyAMA0,115200 root=/dev/mmcblk0" -serial stdio -net nic,model=lan9118 -net tap,ifname=tap0
</code></pre>
    <div class="note">
      <p class="normal"><strong class="keyWord">IMPORTANT NOTE</strong></p>
      <p class="normal">The preceding command is not meant to be executed and will fail since <code class="inlineCode">qemu-system-arm</code> is not installed and the <code class="inlineCode">rootfs.ext4.sd</code>, <code class="inlineCode">zImage</code>, and <code class="inlineCode">vexpress-v2p-ca9.dtb</code> files do not exist on your host system. It is just an example for us to expand on.</p>
    </div>
    <p class="normal">The options <a id="_idIndexMarker049"/>used in <a id="_idIndexMarker050"/>the preceding command line are as follows:</p>
    <ul>
      <li class="bulletList"><code class="inlineCode">-machine vexpress -a9</code>: Creates an emulation of an Arm Versatile Express development board with a Cortex-A9 processor.</li>
      <li class="bulletList"><code class="inlineCode">-m 256M</code>: Populates it with 256 MB of RAM.</li>
      <li class="bulletList">-<code class="inlineCode">drive file=rootfs.ext4,sd</code>: Connects the SD interface to the local <code class="inlineCode">rootfs.ext4</code> file, which contains a filesystem image.</li>
      <li class="bulletList"><code class="inlineCode">-kernel zImage</code>: Loads the Linux kernel from the local file named <code class="inlineCode">zImage</code>.</li>
      <li class="bulletList"><code class="inlineCode">-dtb vexpress-v2p-ca9.dtb</code>: Loads the device tree from the local <code class="inlineCode">vexpress-v2p-ca9.dtb</code> file.</li>
      <li class="bulletList"><code class="inlineCode">-append "…"</code>: Appends the string in quotes as the kernel command line.</li>
      <li class="bulletList"><code class="inlineCode">-serial stdio</code>: Connects the serial port to the terminal that launched QEMU so that you can log on to the emulated machine via the serial console.</li>
      <li class="bulletList"><code class="inlineCode">-net nic,model=lan9118</code>: Creates a network interface.</li>
      <li class="bulletList"><code class="inlineCode">-net tap,ifname=tap0</code>: Connects the network interface to the virtual network interface <code class="inlineCode">tap0</code>.</li>
    </ul>
    <p class="normal">To configure <a id="_idIndexMarker051"/>the host side of the network you need the <code class="inlineCode">tunctl</code> command from the <strong class="keyWord">User Mode Linux</strong> (<strong class="keyWord">UML</strong>) project. On Debian and Ubuntu, the package is named <code class="inlineCode">uml-utilities</code>:</p>
    <pre class="programlisting con"><code class="hljs-con">$ sudo tunctl -u $(whoami) -t tap0
</code></pre>
    <p class="normal">This creates a network interface named <code class="inlineCode">tap0</code> that is connected to the network controller in the emulated QEMU machine. You configure <code class="inlineCode">tap0</code> the same way as any other network interface.</p>
    <p class="normal">All these options are described in the following chapters. I will be using Versatile Express for most of my examples, but it should be easy to use a different machine or architecture.</p>
    <h1 id="_idParaDest-28" class="heading-1"><a id="_idTextAnchor032"/>Provisioning your development environment</h1>
    <p class="normal">I have only used open source software for both the development tools and the target OS/applications. I assume you will be using Linux on your development system.</p>
    <p class="normal">I tested all <a id="_idIndexMarker052"/>the host commands using Ubuntu 24.04 LTS, so I recommend using that version throughout the book to prevent any unexpected problems.</p>
    <p class="normal">Besides Ubuntu, The Yocto Project only supports a select few Linux distributions: Fedora, Debian, openSUSE, AlmaLinux, and Rocky. If you absolutely cannot use Ubuntu, then make sure to choose one of those supported distros for The Yocto Project exercises.</p>
    <h1 id="_idParaDest-29" class="heading-1"><a id="_idTextAnchor033"/>Summary</h1>
    <p class="normal">Embedded hardware continues to get more complex following the trajectory set by Moore’s law. Linux has the power and flexibility to make use of hardware in an efficient way. Together, we will learn how to harness that power so we can build robust products that delight our users. This book will take you through the five phases of an embedded project’s life cycle, beginning with the four elements of embedded Linux.</p>
    <p class="normal">The sheer variety of embedded platforms and the fast pace of development lead to isolated pools of software. In many cases, you will become dependent on this software, especially the Linux kernel that is provided by your SoC or board vendor, and to a lesser extent, the toolchain.</p>
    <p class="normal">Some SoC manufacturers are getting better at pushing their changes upstream and the maintenance of these changes is getting easier. Despite these improvements, selecting the right hardware for your embedded Linux project is still an exercise fraught with peril. Open source license compliance is another topic you need to be aware of when building products atop the embedded Linux ecosystem.</p>
    <p class="normal">In this chapter, you were introduced to the hardware and some of the software you will use throughout this book (namely QEMU). Later on, we will examine some powerful tools that can help you create and maintain the software for your device. We cover Buildroot and dig deep into The Yocto Project. Before we tackle these build tools, we will deconstruct the four elements of embedded Linux, which you can apply to all embedded Linux projects regardless of how they are built.</p>
    <h1 id="_idParaDest-30" class="heading-1"><a id="_idTextAnchor034"/>Join our community on Discord</h1>
    <p class="normal">Join our community’s Discord space for discussions with the authors and other readers: <span class="url">https://packt.link/embeddedsystems</span></p>
    <p class="normal"><img src="../Images/QR_Code12308107448340296.png" alt="" role="presentation" width="354" height="354"/></p>
  </div>
</div></div></body></html>