

# 管理已安装的软件

在各种 Linux 或 Unix 环境中工作时，你需要添加或移除软件。通常通过包管理器完成，尽管在紧急情况下，你可能需要使用其他方法。

你很可能熟悉在编程环境中管理库的工具——`npm`、`gem`、`pip`、`go get`、`maven`、`gradle` 等。这些包管理器都遵循与 Linux 和 Unix 中的包管理器相同的原理。

软件**包管理器**抽象了构成软件的众多配置和二进制文件，让你可以使用一个整洁的“包”来进行操作。如果你来自 Windows（`.exe` 或 `.msi` 安装程序）或 macOS（`.dmg` 安装程序），这应该很熟悉。

此外，大多数 Linux 包管理器在过程中增加了一层安全性，通过：

+   使用安全传输（TLS）下载。

+   使用包本身的加密签名，以证明作者至少是他们所声称的那样（无论你是否信任他们）。

各种 Linux 发行版还开创了可搜索的软件包仓库的理念，帮助用户找到可以下载的软件，这一理念也启发了如今的 Apple 和 Microsoft “应用商店”。

在本章中，我们将涵盖以下内容：

+   什么是包管理器

+   你最常见的包管理器

+   你需要执行的最重要的包管理操作和各个命令，跨包管理器“翻译”——这就是你在实践中需要知道的 90%内容。

+   一种常见的下载并执行自定义安装脚本的过程。

+   快速的实际介绍，教你如何自己构建和安装软件。

如果你正在寻找 Docker 中安装软件的说明，请查阅*第十五章*，*使用 Docker 容器化应用程序*。

首先：作为开发者，当你想做一些常见的事情时，你会使用包管理命令：

+   安装新的软件包，例如，应用程序期望在其执行环境中可用的依赖项。

+   检查已安装的软件包（例如，“nginx web 服务器是否已经安装在此系统上？”）。

+   更新当前安装的软件包集合，确保你拥有所有软件的最新版本。这通常用于修复已发现的漏洞，或确保你拥有软件的所有最新功能。

+   移除一个包——即从系统中卸载它。

让我们深入了解如何实现这些实际目标，并查看你将要使用的实际命令。

# 使用软件包

在我们深入实际命令之前，你应该了解，你将使用的确切命令会根据你使用的 Unix 版本（或 Linux 发行版）有所不同。不同的 Linux 发行版使用不同的包管理器，尽管它们的语法稍有差异，*恰好*足以让人感到烦恼，但它们的工作方式几乎完全相同。常见的包管理器包括：

+   `homebrew`（macOS）

+   `apt`（可靠地出现在 Ubuntu 和基于 Debian 的系统中，即使是没有安装 aptitude 的最小系统）

+   `pacman`（Arch）

+   `apk`（Alpine）

在接下来的实践部分中，我们将介绍我们想要实现的高级目标（例如“安装特定软件包”），然后展示使用我们刚才提到的流行包管理器来完成该任务的确切命令。

## 更新本地仓库状态缓存

在安装或删除软件包之前，你需要确保本地软件包缓存（你系统中记录的可用软件包信息）是最新的。

例如，如果你正在尝试安装 `nginx` 网页服务器，而上次更新本地软件包缓存的时间已经过去一个月，那么你可能会不小心安装一个过时的版本，而不是这周的新版本。

要更新缓存，找到下面列表中的包管理器并运行相应的命令：

| **包管理器** | **命令** |
| --- | --- |
| `homebrew` | `brew update` |
| `apt` | `apt update` |
| `pacman` | `pacman -Sy` |
| `apk` | `apk update` |

本地可用软件包缓存将被更新，更新完成后你就可以开始激动人心的工作——查找和安装软件包。

## 搜索软件包

并非所有软件包的名称都与它们包含的软件相同。Firefox 可能在 `firefox` 包中提供，但如果你尝试安装 `ag`（包名：`silversearcher-ag`），你可能会失望。使用以下包管理器命令搜索你考虑安装的软件包的描述：

| **包管理器** | **命令** |
| --- | --- |
| `homebrew` | `brew search $PACKAGENAME` |
| `apt` | `apt-cache search $PACKAGENAME` |
| `pacman` | `pacman -Ss $PACKAGENAME` |
| `apk` | `apk search $PACKAGENAME` |

这是一个确认你所期望内容是否正确的好方法，但它也可以用来扩展你的搜索范围，寻找与问题相关的通用软件。例如，在 Ubuntu 上，我可以使用 `apt-cache search grep` 来搜索类似 grep 的工具。任何包含 grep 的软件包名称或描述都会显示出来。

## 安装软件包

最终的高潮！现在我们的仓库缓存已更新，*并且*我们已经明确知道要安装哪个软件包，让我们运行 `install` 命令：

| **包管理器** | **命令** |
| --- | --- |
| `homebrew` | `brew install $PACKAGENAME` |
| `apt` | `apt install $PACKAGENAME` |
| `pacman` | `pacman -Sy $PACKAGENAME` |
| `apk` | `apk add $PACKAGENAME` |

如果你的包管理器提示确认，回应提示后，你的包就会被安装（同时也会安装它依赖的其他包）。

由于这些命令在安装包之前会提示确认，它们可能会阻塞脚本。当你使用脚本自动化任务并且需要安装包时，确保阅读相应包管理器的手册，了解如何以非交互式的方式安装包。这通常通过环境变量或命令的额外参数来完成。

## 升级所有有可用更新的包

在长期运行的系统上，你可能需要偶尔将已安装的包升级到最新版本。这可以修复已知的漏洞，获取最新的功能，并防止不同系统因配置时间的不同而导致状态不一致：

| **包管理器** | **命令** |
| --- | --- |
| `homebrew` | `brew upgrade` |
| `apt` | `apt dist-upgrade` |
| `pacman` | `pacman -Syu` |
| `apk` | `apk upgrade` |

这些命令也会提示确认，因此如果你在脚本中使用它们，同样的建议是：可以添加一个选项让它们不再交互式。例如，`apt –y dist-upgrade` 将不会等待手动确认，而是直接执行升级。

## 移除一个包（以及它的所有依赖，前提是其他包不再需要它们）

有时候你可能想要卸载一个包：也许你只是试用它，或者你的应用需求发生了变化，亦或是它被认为存在漏洞且没有修复方案。所有包管理器都有用于移除已安装包的命令：

| **包管理器** | **命令** |
| --- | --- |
| `homebrew` | `brew remove $PACKAGENAME` |
| `apt` | `apt remove $PACKAGENAME` |
| `pacman` | `pacman -Rs $PACKAGENAME` |
| `apk` | `apk del $PACKAGENAME` |

在移除包之前或之后，你可能需要验证该包是否已经安装。让我们现在来看一下如何操作。

## 查询已安装的包

如果你需要列出当前系统上所有已安装的包，你可以通过一个命令完成：

| **包管理器** | **命令** |
| --- | --- |
| `homebrew` | `brew list` |
| `apt` | `dpkg –l` |
| `pacman` | `pacman -Qi` |
| `apk` | `apk info` |

因为这个列表通常有数百或数千个包，所以它可能有些笨重。通过将输出传递给像 `grep` 这样的搜索命令来缩小范围，找出你所需要的内容：

```
dpkg -l | grep silversearcher
ii  silversearcher-ag 2.2.0+git20200805-1 arm64 very fast grep-like program, alternative to ack-grep 
```

如果你不明白我们是如何使用管道将 `dpkg` 的输出传递给 `grep` 命令的，参见*第一章*，*命令行工作原理*，了解如何使用管道字符（|）将命令串联起来。我们还将在即将到来的*第十一章*，*管道与重定向*中深入探讨这一机制。

既然我们已经介绍了你在 90% 时间内使用的基本包管理命令，现在是时候展示一些当你想安装的软件没有现成包时你会使用的模式。

# 注意事项 – curl | bash

有时你找不到需要的软件的预构建包。没关系！许多在线资源——即使是像 macOS 上的 homebrew 这样值得信赖且流行的资源——也推荐类似这样的命令行安装过程：

```
curl $SOMEURL | bash 
```

这使用 `curl` 命令从网络上下载内容，然后将该内容作为输入（`|`，管道符号，我们在*第一章*《命令行工作原理》中讲过）来运行 Bash。当你这样做时，你实际上是在运行一个网络上的脚本，而不是一个本地文件。这可以是安装软件的一个非常方便的方法，但请*务必*确保它来自一个可信的来源。

我们建议始终至少*查看*脚本源代码，你可以通过访问该命令的脚本网址（在下面的示例中表示为`$SOMEURL`）在浏览器中查看，或者将单个 `curl $URL | bash` 命令拆分成多个命令，以便你可以：

+   下载脚本。

+   在本地文本编辑器中阅读脚本，确认它没有做任何恶意操作，必要时编辑脚本以满足你的需求。

+   运行脚本，前提是你已经验证过它只会执行你想要它执行的操作。

要将类似 `curl $URL | bash` 的模式拆分成多个命令，你需要执行以下步骤：

```
# Download the installer and name the resulting file installer.sh
curl $SOMEURL -o installer.sh
# Read and optionally modify the script using a text editor like vim
vim installer.sh
# Make the script executable and run it
chmod +x installer.sh
./installer.sh 
```

通过将这一步骤拆分成多个步骤，而不是直接下载一个不可信的脚本并立即运行，我们给自己留出了时间来审查我们即将执行的代码并确认它是安全的。最终结果是一样的（安装脚本会运行），但这种方法使我们有更多的控制权，并且需要更少的盲目信任。

还有另一种在系统上安装软件的方法，即使没有现成的安装脚本可用。

# 从源代码编译第三方软件

这是在系统上安装软件最手动、最传统的方法——手动编译和安装！它没有像包管理器那样的许多优点，比如速度、可重复性、管理已安装软件的简便性以及对安装的二进制软件的加密验证。

但在紧急情况下，它仍然是安装软件最可靠的方式，除了你作为开发者已经熟悉的基本软件工具（编译器、链接器和 make 脚本），没有其他真正的外部依赖。

当你遇到以下情况时，你可能会手动编译和安装软件：

+   包管理器中没有预打包版本的软件。例如，如果你使用的是轻量级容器发行版（如 Alpine），可能在包管理器中找不到所需的软件。在这种情况下，你可以从源代码编译自己的二进制文件，并将其添加到容器镜像中。

+   你需要将自己的（或其他自定义的）软件添加到 Docker 容器中。

+   当你需要一个软件的绝对最新、前沿版本，而包管理器尚未提供时，你会选择这种方式。这种情况通常出现在进展较慢的项目中，这些项目不会及时提供新的软件包，或者在需要紧急修复关键漏洞之前，需要立即发布热补丁。*立即*，在热补丁通过打包流程之前。

这个过程涉及几个步骤，具体步骤会因软件而异。

通常情况下，这包括：

1.  使用 `curl` 或 `wget` 下载压缩软件存档。

1.  运行 `tar zxf downloadname` 或 `unzip downloadname` 解压刚刚下载的源代码目录。

1.  切换到你下载的源代码目录，并阅读包含的 `README` 文件。这里会告诉你构建软件所需的确切步骤，以及与我们描述的规范有所偏差的任何内容。

1.  运行 `./configure`，然后是 `make`，再接着是 `sudo make install` 来构建并安装二进制文件。

与其他安装软件的方式一样，无论是手动还是通过包管理器，记住 `configure` 和 `make` 都会按设计执行任意代码。这意味着以 root 身份运行 `make install` 将导致所有此类任意代码以 `root` 身份运行。这应该让你担心。确保验证软件源代码的可信度，并从可信任的来源下载。

## 示例：编译和安装 htop

为了演示这一过程，我们将下载、编译和安装 `htop`，这是一个小巧而非常实用的系统监视工具（类似于内置的 `top` 命令，但功能更强大）。需要说明的是，几乎所有 Linux 发行版的包管理器都可以轻松获取到它，但我们将假装它是一个难以获取的自定义程序，不通过包管理器广泛分发。

我们正在使用的系统是 Ubuntu 22.04 Linux 服务器，如果你想跟随操作而不必自行解决问题，请使用该系统。

首先，我们在这里的官方 GitHub 仓库检查最新版本发布情况：[`github.com/htop-dev/htop/releases`](https://github.com/htop-dev/htop/releases) —— 在撰写本文时，最新版本是 3.2.2。

现在，你应该为这次构建创建一个目录，以保持整洁 —— 我建议在 `/tmp` 目录中创建一个，这个目录保存临时文件，在系统启动时会清空其内容：

```
mkdir /tmp/htopbuild && cd /tmp/htopbuild 
```

这样一来，一旦构建完成，我们可以删除所有文件，避免系统堆积旧构建的垃圾文件。现在我们准备好开始了。

### 安装前提条件

首先，我们需要安装基本的 C 开发工具链（编译器、链接器、make 及其他工具——你在 Linux 上编译 C 代码所需的所有东西）。在 Ubuntu 上，可以通过安装一个*元包*——一个多个其他软件包的别名——`build-essential`来实现：

```
sudo apt install build-essential 
```

我们还将安装其他一些工具：`wget`用于从网络下载文件，`ncurses`开发库，`htop`用它来提供响应式的命令行界面：

```
sudo apt install wget libncurses-dev 
```

### 下载、验证并解压源代码

首先，我们将下载源代码并验证其加密签名，以确保它是由开发者的密钥签署的正版发布：

```
wget https://github.com/htop-dev/htop/releases/download/3.2.2/htop-3.2.2.tar.xz 
```

这为我们提供了压缩的源代码目录，我们将把它编译成二进制文件。

现在让我们通过检查签名来确保我们有一个开发者批准的发布版本，签名就是源代码的`sha256`哈希值。

下载包含此版本预期哈希值的文件并将其打印到终端：

```
wget https://github.com/htop-dev/htop/releases/download/3.2.2/htop-3.2.2.tar.xz.sha256
cat htop-3.2.2.tar.xz.sha256 
```

如果你和我们在这个示例中使用的是相同版本，你会看到这个哈希值：

```
bac9e9ab7198256b8802d2e3b327a54804dc2a19b77a5f103645b11c12473dc8  htop-3.2.2.tar.xz 
```

现在，使用`sha256sum`工具对我们下载的源代码进行哈希处理，验证哈希值是否匹配：

```
sha256sum htop-3.2.2.tar.xz
bac9e9ab7198256b8802d2e3b327a54804dc2a19b77a5f103645b11c12473dc8  htop-3.2.2.tar.xz 
```

太好了！我们现在知道我们拥有的软件与我们想要下载的官方版本是相同的。接下来，让我们解压源代码目录并进入其中：

```
tar xf htop-3.2.2.tar.xz
cd htop-3.2.2 
```

如果你有兴趣，现在是时候阅读`Readme`文件（关于程序的一般信息）和`INSTALL`文件（关于如何构建和安装程序的说明）。

现在我们准备好开始配置和编译这个软件了！

### 配置并编译 htop

在源代码目录内部，现在是时候运行`./configure`脚本了。这个脚本确保我们安装了编译所需的依赖项（共享库、工具等），并为接下来的编译做好配置：

```
./configure 
```

这将在脚本运行时产生输出，检查各种依赖项，并确保你的环境满足编译所需的所有条件。

如果这个脚本产生错误，请仔细阅读：通常它会清楚地告诉你问题所在——可能是缺少库或操作系统设置有问题。在修复它报告的问题后，重新运行它。当它成功运行完毕后，你就可以开始编译`htop`二进制文件了：

```
make 
```

这将在编译脚本运行时产生大量输出。如果你对 makefile 完全陌生，它们是一个非常有用的自动化工具，开发者广泛使用。这里有一个很棒的教程：[`makefiletutorial.com/`](https://makefiletutorial.com/)

一旦编译完成，我们就可以安装刚才创建的`htop`二进制文件（它会在主源目录中，名为`htop`）。通常，有一种自动化的方式可以完成此操作：

```
sudo make install 
```

需要使用`sudo`，因为你正在将编译好的二进制文件移动到一个受保护（root 拥有）的目录。之后，你可以通过输入以下命令来验证`htop`是否已经安装并正常运行：

```
htop 
```

你应该会看到一个美观的基于终端的图形用户界面（得益于`ncurses`库），显示系统当前的 CPU 负载、内存使用情况和进程列表。

对于没有提供完整功能`install`命令的程序，你可以依赖 Linux 没有什么魔法的事实，直接通过将二进制文件移动到`/user/local/bin/`目录下来安装它，这里是本地编译的二进制文件的存放位置：

```
mv htop /usr/local/bin/ 
```

通过看到这个过程有多么简单，你现在已经掌握了所有必要的知识，能够继续进行编译！

# 结论

在本章中，你学习了如何管理已安装的 Linux 环境中的软件基础知识。首先，我们看到了如何通过你最有可能遇到的包管理器轻松完成这项工作。虽然这种方法应该能满足你 90%的需求，但接着你还了解了针对最后 10%的情况所需要采用的程序——谨慎筛选，接着使用自定义安装脚本或手动编译和安装。

希望你跟随了实际的编译示例，并试用了`htop`系统监视器。幸运的是，`htop`在各大包管理器中都有提供——它是一个非常有用的工具，许多系统管理员在长期运行的生产系统中觉得它不可或缺。

你现在应该对有效使用许多 Unix 和 Linux 系统（无论是在开发还是生产环境中）所需的高层次概念和实用命令感到熟悉。

# 在 Discord 上了解更多

要加入本书的 Discord 社区——在这里你可以分享反馈、向作者提问并了解新版本——请扫描下面的二维码：

[`packt.link/SecNet`](https://packt.link/SecNet)

![](img/QR_Code1768422420210094187.png)
