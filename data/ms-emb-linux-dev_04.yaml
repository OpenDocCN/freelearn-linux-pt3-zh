- en: '3'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '3'
- en: All about Bootloaders
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 所有关于引导加载程序的内容
- en: The bootloader is the second element of embedded Linux. It is the part that
    starts the system and loads the operating system kernel. In this chapter, we will
    look at the role of the bootloader and how it passes control from itself to the
    kernel using a data structure called a **device tree**, also known as a **flattened
    device tree** or **FDT**.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 引导加载程序是嵌入式 Linux 的第二个元素。它是启动系统并加载操作系统内核的部分。在本章中，我们将探讨引导加载程序的作用，以及它如何通过一个名为**设备树**的数据结构将控制权从自己传递给内核，设备树也称为**扁平设备树**或**FDT**。
- en: I will cover the basics of device trees so that you will be able to follow the
    connections described in a device tree and relate them to real hardware. I will
    focus on a popular open source bootloader known as U-Boot and show you how to
    use it to boot a target device. I will also show you how to customize U-Boot to
    run on a new device using BeaglePlay as an example.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 我将介绍设备树的基础知识，以便您能够理解设备树中描述的连接并将其与实际硬件关联起来。我将重点介绍一个流行的开源引导加载程序 U-Boot，并展示如何使用它启动目标设备。我还将展示如何使用
    BeaglePlay 作为示例，自定义 U-Boot 以便在新设备上运行。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下内容：
- en: What does a bootloader do?
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 引导加载程序的作用是什么？
- en: Boot sequence
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 启动顺序
- en: Moving from the bootloader to the kernel
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从引导加载程序到内核的过渡
- en: Introducing device trees
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 介绍设备树
- en: U-Boot
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: U-Boot
- en: Technical requirements
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'To work through the examples, make sure you have the following:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 要进行示例操作，请确保您拥有以下内容：
- en: An Ubuntu 24.04 or later LTS host system with `device-tree-compiler`, `git`,
    `make`, `patch`, and `u-boot-tools` installed
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一台安装有 `device-tree-compiler`、`git`、`make`、`patch` 和 `u-boot-tools` 的 Ubuntu
    24.04 或更高版本 LTS 主机系统
- en: A Bootlin toolchain for BeaglePlay from [*Chapter 2*](Chapter_01.xhtml#_idTextAnchor028)
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个来自[*第二章*](Chapter_01.xhtml#_idTextAnchor028)的 BeaglePlay Bootlin 工具链
- en: A microSD card reader and card
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个 microSD 卡读卡器和卡片
- en: A USB-to-TTL serial cable with a 3.3 V logic level
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一条 3.3 V 逻辑电平的 USB 到 TTL 串口电缆
- en: BeaglePlay
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: BeaglePlay
- en: A 5 V USB-C power supply capable of delivering 3 A
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一款能够提供 3 A 电流的 5 V USB-C 电源
- en: 'All of the code for this chapter can be found in the `Chapter03` folder from
    the book’s GitHub repository: [https://github.com/PacktPublishing/Mastering-Embedded-Linux-Development/tree/main/Chapter03](https://github.com/PacktPublishing/Mastering-Embedded-Linux-Development/tree/main/Chapter03).'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的所有代码可以在书籍的 GitHub 仓库中的 `Chapter03` 文件夹中找到：[https://github.com/PacktPublishing/Mastering-Embedded-Linux-Development/tree/main/Chapter03](https://github.com/PacktPublishing/Mastering-Embedded-Linux-Development/tree/main/Chapter03)。
- en: What does a bootloader do?
  id: totrans-19
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 引导加载程序的作用是什么？
- en: 'In an embedded Linux system, the bootloader has two main jobs: initializing
    the system to a basic level and loading the kernel. In fact, the first job is
    somewhat subsidiary to the second in that it is only necessary to get as much
    of the system working as is needed to load the kernel.'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 在嵌入式 Linux 系统中，引导加载程序有两个主要任务：将系统初始化到基本状态并加载内核。实际上，第一个任务在某种程度上是从属于第二个任务的，因为它只需要将系统启动到足以加载内核的程度。
- en: When the first lines of the bootloader code are executed, following a power-on
    or reset, the system is in a very minimal state. The **Dynamic Random Access Memory**
    (**DRAM**) controller is not set up, so the main memory is not accessible. Likewise,
    other interfaces are not configured, so storage that’s accessed via **NAND** (**NOT
    AND**) **flash** controllers, **MultiMediaCard** (**MMC**) controllers, and so
    on is unavailable. Typically, the only resources that are operational at the beginning
    are a single CPU core, some on-chip **Static Random Access Memory** (**SRAM**),
    and the boot **Read-Only Memory** (**ROM**).
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 当引导加载程序的第一行代码在开机或重启后执行时，系统处于非常简化的状态。**动态随机存取内存**（**DRAM**）控制器尚未设置，因此主内存不可访问。同样，其他接口也没有配置，因此通过**NAND**（**非与**）**闪存**控制器、**多媒体卡**（**MMC**）控制器等访问的存储也不可用。通常，开始时唯一可用的资源是一个
    CPU 核心、一些片上**静态随机存取内存**（**SRAM**）和引导**只读存储器**（**ROM**）。
- en: A system bootstrap consists of several phases of code, each bringing more of
    the system into operation. The final act of the bootloader is to load the kernel
    into RAM and create an execution environment for it. The details of the interface
    between the bootloader and the kernel are architecture-specific, but in each case,
    it has to do two things. First, the bootloader has to pass a pointer to a structure
    containing information about the hardware configuration. Second, it has to pass
    a pointer to the kernel command line.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 系统启动包括几个阶段的代码，每个阶段使系统的更多部分投入运行。引导加载程序的最后一步是将内核加载到RAM中，并为其创建一个执行环境。引导加载程序与内核之间的接口细节是架构特定的，但在每种情况下，它需要做两件事。首先，引导加载程序必须传递一个指针，指向包含硬件配置相关信息的结构。其次，它必须传递一个指针，指向内核命令行。
- en: The kernel command line is a text string that controls the behavior of Linux.
    Once the kernel has begun executing, the bootloader is no longer needed and all
    the memory it was using can be reclaimed.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 内核命令行是一个文本字符串，用于控制Linux的行为。一旦内核开始执行，引导加载程序就不再需要，所有它所占用的内存可以被回收。
- en: A subsidiary job of the bootloader is to provide a maintenance mode for updating
    boot configurations, loading new boot images into memory, and maybe running diagnostics.
    This is usually controlled by a simple command-line user interface, commonly over
    a serial console.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 引导加载程序的一个辅助任务是提供一个维护模式，用于更新引导配置、将新的引导映像加载到内存中，甚至可能执行诊断。通常通过一个简单的命令行用户界面来控制，通常是通过串行控制台。
- en: Boot sequence
  id: totrans-25
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 启动序列
- en: 'Some years ago, we only needed to place the bootloader in non-volatile memory
    at the reset vector of the processor. **NOR** (**NOT OR**) **flash** memory was
    common at that time and, since it can be mapped directly into the address space,
    it was the ideal method of storage. The following diagram shows such a configuration
    with the **reset vector** at `0xfffffffc` at the top end of an area of flash memory:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 几年前，我们只需要将引导加载程序放置在处理器的复位矢量处的非易失性存储器中。当时**NOR**（**非或**）**闪存**存储器很常见，并且由于它可以直接映射到地址空间，因此是理想的存储方法。以下图示展示了这样一种配置，其中**复位矢量**位于`0xfffffffc`，位于闪存区域的顶部：
- en: '![Figure 3.1 – NOR flash](img/B18466_03_01.png)'
  id: totrans-27
  prefs: []
  type: TYPE_IMG
  zh: '![图3.1 – NOR闪存](img/B18466_03_01.png)'
- en: Figure 3.1 – NOR flash
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.1 – NOR闪存
- en: The bootloader is linked so that there is a jump instruction at that location
    that points to the start of the bootloader code. From that point on, the bootloader
    code running in NOR flash memory can initialize the DRAM controller so that the
    main memory – the **DRAM** – becomes available, and then it copies itself into
    the DRAM. Once fully operational, the bootloader can load the kernel from flash
    memory into DRAM and transfer control to it.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 引导加载程序被链接，以便在该位置有一个跳转指令，指向引导加载程序代码的起始位置。从那时起，运行在NOR闪存中的引导加载程序代码可以初始化DRAM控制器，使得主内存——**DRAM**——变得可用，然后它将自己复制到DRAM中。引导加载程序完全运行后，可以将内核从闪存加载到DRAM中，并将控制权转交给内核。
- en: However, once you move away from a simple linearly addressable storage medium
    such as NOR flash, the boot sequence becomes a complex, multi-stage procedure.
    The details are very specific to each SoC, but they generally go through the following
    phases.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，一旦你远离像NOR闪存这样简单的线性可寻址存储介质，启动序列就会变成一个复杂的多阶段过程。具体细节因每个SoC而异，但它们通常会经过以下几个阶段。
- en: Phase 1 – ROM code
  id: totrans-31
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 阶段1 – ROM代码
- en: In the absence of reliable external memory, the code that runs immediately after
    a reset or power-on is stored on-chip in the SoC. This is known as **ROM code**.
    It is loaded into the chip when it is manufactured, and hence the ROM code is
    proprietary and cannot be replaced by an open source equivalent.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 在没有可靠外部存储器的情况下，复位或开机后立即运行的代码存储在SoC芯片上。这被称为**ROM代码**。它在芯片制造时就被加载，因此ROM代码是专有的，不能被开源等效物替代。
- en: ROM code does not include code to initialize the memory controller because DRAM
    configurations are highly device-specific, and so it can only use SRAM, which
    does not require a memory controller. Most embedded SoC designs have a small amount
    of SRAM on chip, varying in size from as little as 4 KB to several hundred KB.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: ROM代码不包括初始化内存控制器的代码，因为DRAM的配置高度依赖于设备，因此只能使用不需要内存控制器的SRAM。大多数嵌入式SoC设计在芯片上都有少量的SRAM，大小从最小的4
    KB到几百KB不等。
- en: '![Figure 3.2 – Phase 1 – ROM code](img/B18466_03_02.png)'
  id: totrans-34
  prefs: []
  type: TYPE_IMG
  zh: '![图3.2 – 阶段1 – ROM代码](img/B18466_03_02.png)'
- en: Figure 3.2 – Phase 1 – ROM code
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.2 – 阶段1 – ROM代码
- en: The ROM code can load a small chunk of code from one of several pre-programmed
    locations into SRAM. As an example, TI Sitara chips try to load code from the
    first few pages of NAND flash memory, or from flash memory connected through a
    **Serial Peripheral Interface** (**SPI**). They also try to load code from the
    first sectors of an MMC device like an eMMC chip or SD card, or from a file named
    **MLO** (**Memory Loader**) on the first partition of an MMC device. If reading
    from all these memory devices fails, then it tries reading a byte stream from
    Ethernet, USB, or UART. The latter is provided mainly as a way to load code into
    flash memory at production rather than for use in normal operation.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: ROM代码可以从多个预编程位置之一加载一小段代码到SRAM中。例如，TI Sitara芯片尝试从NAND闪存的前几页或通过**串行外设接口**（**SPI**）连接的闪存加载代码。它们还尝试从像eMMC芯片或SD卡这样的MMC设备的第一个分区中名为**MLO**（**Memory
    Loader**）的文件中加载代码。如果从所有这些存储设备读取失败，则尝试从以太网、USB或UART读取字节流。后者主要用于在生产中将代码加载到闪存中，而不是用于正常操作。
- en: Most embedded SoCs have ROM code that works in a similar way. In SoCs where
    the SRAM is not large enough to load a full bootloader such as U-Boot, there needs
    to be an intermediate loader called the **Secondary Program Loader** (**SPL**).
    At the end of the ROM code phase, the SPL is present in the SRAM and the ROM code
    jumps to the beginning of that code.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数嵌入式SoC都有类似方式工作的ROM代码。在SRAM不足以加载诸如U-Boot之类的完整引导加载程序的SoC中，需要有一个称为**次级程序加载器**（**SPL**）的中间加载器。在ROM代码阶段结束时，SPL存在于SRAM中，并且ROM代码跳转到该代码的开头。
- en: Phase 2 – Secondary Program Loader
  id: totrans-38
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第2阶段 – 次级程序加载器
- en: The SPL must set up the memory controller and other essential parts of the system
    in preparation for loading the **Tertiary Program Loader** (**TPL**) into DRAM.
    The functionality of the SPL is limited by the size of the SRAM. It can read a
    program from a list of storage devices, as can the ROM code, once again using
    pre-programmed offsets from the start of a flash device.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: SPL必须设置内存控制器和系统的其他重要部分，以准备将**第三级程序加载器**（**TPL**）加载到DRAM中。SPL的功能受SRAM大小的限制。它可以像ROM代码一样从存储设备列表中读取程序，再次使用从闪存设备起始处的预编程偏移量。
- en: 'If the SPL has filesystem drivers built into it, it can read well-known filenames
    such as `u-boot.img` from a disk partition. The SPL usually doesn’t allow any
    user interaction, but it may print version information and progress messages that
    you can see on the console. The following diagram displays the phase 2 architecture:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 如果SPL内置文件系统驱动程序，它可以从磁盘分区读取像`u-boot.img`这样的众所周知的文件名。通常SPL不允许用户交互，但它可能会打印版本信息和进度消息，您可以在控制台上看到。以下图显示了第2阶段的架构：
- en: '![Figure 3.3 – Phase 2 – SPL](img/B18466_03_03.png)'
  id: totrans-41
  prefs: []
  type: TYPE_IMG
  zh: '![图3.3 – 第2阶段 – SPL](img/B18466_03_03.png)'
- en: Figure 3.3 – Phase 2 – SPL
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.3 – 第2阶段 – SPL
- en: The preceding diagram shows the jump from ROM code to SPL. As the SPL executes
    within SRAM, it loads the TPL into DRAM. At the end of the second phase, the TPL
    is present in DRAM and the SPL can make a jump to that area.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的图显示了从ROM代码到SPL的跳转。当SPL在SRAM中执行时，它将TPL加载到DRAM中。第二阶段结束时，TPL存在于DRAM中，SPL可以跳转到该区域。
- en: The SPL may be open source, as is the case with Atmel AT91Bootstrap, but it
    is quite common for it to contain proprietary code that is supplied by the manufacturer
    as a binary blob.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: SPL可能是开源的，例如Atmel AT91Bootstrap就是如此，但它通常包含供应商提供的作为二进制blob的专有代码。
- en: Phase 3 – Tertiary Program Loader
  id: totrans-45
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第3阶段 – 第三级程序加载器
- en: 'At this point, we are running a full bootloader, such as U-Boot, which we will
    learn about a bit later in this chapter. Usually, there is a simple command-line
    user interface that lets you perform maintenance tasks such as loading new boot
    and kernel images into flash storage, as well as a way to load the kernel automatically
    without user intervention. The following diagram explains the phase 3 architecture:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 此时，我们正在运行一个完整的引导加载程序，例如U-Boot，稍后我们将在本章中详细了解。通常，有一个简单的命令行用户界面，可以让您执行维护任务，例如将新的引导和内核映像加载到闪存中，以及自动加载内核而无需用户干预。以下图解释了第3阶段的架构：
- en: '![Figure 3.4 – Phase 3 – TPL](img/B18466_03_04.png)'
  id: totrans-47
  prefs: []
  type: TYPE_IMG
  zh: '![图3.4 – 第3阶段 – TPL](img/B18466_03_04.png)'
- en: Figure 3.4 – Phase 3 – TPL
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.4 – 第3阶段 – TPL
- en: The preceding diagram shows the jump from SPL in SRAM to TPL in DRAM. As the
    TPL executes, it loads the kernel into DRAM. We also have the choice of appending
    an FDT and/or initial RAM disk to the image in DRAM if we want. Either way, at
    the end of the third phase, there is a kernel in memory waiting to be started.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 上面的图示展示了从SRAM中的SPL到DRAM中的TPL的跳转。当TPL执行时，它将内核加载到DRAM中。如果需要，我们还可以选择将FDT和/或初始RAM磁盘附加到DRAM中的镜像中。无论哪种方式，在第三阶段结束时，内存中都有一个等待启动的内核。
- en: Embedded bootloaders usually disappear from memory once the kernel is running
    and have no further part in the operation of the system. Before that happens,
    the TPL needs to hand off control of the boot process to the kernel.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 嵌入式引导加载程序通常在内核运行后从内存中消失，不再参与系统的操作。在此之前，TPL需要将引导过程的控制权交给内核。
- en: Moving from the bootloader to the kernel
  id: totrans-51
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从引导加载程序到内核的过渡
- en: 'When the bootloader passes control to the kernel, it has to pass some basic
    information, which includes the following:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 当引导加载程序将控制权交给内核时，它必须传递一些基本信息，包括以下内容：
- en: The machine number, which is used on PowerPC and Arm platforms without support
    for a device tree, to identify the type of the SoC
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 机器号，在没有设备树支持的PowerPC和Arm平台上，用来标识SoC的类型
- en: Basic details of the hardware that’s been detected so far, including (at the
    very least) the size and location of the physical RAM and the CPU’s clock speed
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 目前已检测到的硬件的基本信息，包括（至少）物理RAM的大小和位置以及CPU的时钟速度
- en: The kernel command line
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 内核命令行
- en: Optionally, the location and size of a device tree binary
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可选地，设备树二进制文件的位置和大小
- en: Optionally, the location and size of an initial RAM disk, called the **initial
    RAM file system** (**initramfs**)
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可选地，初始RAM磁盘的位置和大小，称为**初始RAM文件系统**（**initramfs**）
- en: The kernel command line is a plain ASCII string that controls the behavior of
    Linux by giving it, for example, the name of the device that contains the root
    filesystem. We will look at the kernel command line in detail in the next chapter.
    It is common to provide the root filesystem as a RAM disk, in which case it is
    the responsibility of the bootloader to load the RAM disk image into memory. We
    will cover how to create initial RAM disks in [*Chapter 5*](Chapter_05.xhtml#_idTextAnchor138).
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 内核命令行是一个纯ASCII字符串，通过它可以控制Linux的行为，例如，指定包含根文件系统的设备名称。我们将在下一章详细介绍内核命令行。通常会提供根文件系统作为RAM磁盘，在这种情况下，引导加载程序的责任是将RAM磁盘镜像加载到内存中。我们将在[*第5章*](Chapter_05.xhtml#_idTextAnchor138)中介绍如何创建初始RAM磁盘。
- en: The way this information is passed is dependent on the architecture and has
    changed in recent years. For instance, with PowerPC, the bootloader simply used
    to pass a pointer to a board information structure, whereas with Arm, it passed
    a pointer to a list of A tags. There is a good description of the format of A
    tags in the kernel source tree at `Documentation/arch/arm/booting.rst`. Browse
    the kernel source tree at [https://github.com/torvalds/linux](https://github.com/torvalds/linux).
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 这种信息传递方式取决于架构，并且近年来发生了变化。例如，在PowerPC中，引导加载程序通常只会传递指向板级信息结构的指针，而在Arm中，它传递指向A标签列表的指针。关于A标签格式的详细描述可以在内核源代码树中的`Documentation/arch/arm/booting.rst`找到。你可以浏览内核源代码树：[https://github.com/torvalds/linux](https://github.com/torvalds/linux)。
- en: In both cases, the amount of information being passed is very limited, leaving
    the bulk to be discovered at runtime or hard-coded into the kernel as **platform
    data**. The widespread use of platform data meant that each board had to have
    a kernel configured and modified for that platform. A better way was needed, and
    that way is the device tree.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 在这两种情况下，传递的信息量都非常有限，剩下的部分要么在运行时发现，要么作为**平台数据**硬编码到内核中。平台数据的广泛使用意味着每块开发板都必须有一个为该平台配置和修改过的内核。需要一种更好的方法，而这种方法就是设备树。
- en: In the Arm world, the move away from A tags began in earnest in February 2013
    with the release of Linux 3.8\. Today, almost all Arm systems use device trees
    to gather information about the specifics of the hardware platform. This allows
    a single kernel binary to run on a wide range of Arm platforms.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 在Arm领域，摆脱A标签的转变始于2013年2月，当时Linux 3.8发布。今天，几乎所有Arm系统都使用设备树来收集硬件平台的具体信息。这使得单一内核二进制文件可以在多种Arm平台上运行。
- en: Now that we’ve learned what a bootloader does, what the stages of the boot sequence
    are, and how it passes control to the kernel, let’s learn how to configure a bootloader
    so that it runs on popular embedded SoCs.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经了解了引导加载程序的作用、引导序列的各个阶段以及它如何将控制权交给内核，接下来让我们学习如何配置一个引导加载程序，以便它能够在流行的嵌入式
    SoC 上运行。
- en: Introducing device trees
  id: totrans-63
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍设备树
- en: If you are working with Arm or PowerPC SoCs, you are almost certainly going
    to encounter device trees at some point. This section aims to give you a quick
    overview of what they are and how they work. We will revisit the topic of device
    trees repeatedly throughout the course of this book.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您正在使用 Arm 或 PowerPC SoC，您几乎可以肯定在某个时刻会遇到设备树。本节旨在为您提供一个快速概述，了解设备树是什么以及它们如何工作。我们将在本书的后续章节中反复讨论设备树的话题。
- en: A device tree is a flexible way of defining the hardware components of a computer
    system. Bear in mind that a device tree is just static data, not executable code.
    Usually, the device tree is loaded by the bootloader and passed to the kernel,
    although it is possible to bundle the device tree with the kernel image itself
    to cater to bootloaders that are not capable of loading them separately.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 设备树是一种灵活的定义计算机系统硬件组件的方式。请记住，设备树只是静态数据，而不是可执行代码。通常，设备树由引导加载程序加载并传递给内核，尽管也可以将设备树与内核镜像捆绑在一起，以便支持那些无法单独加载设备树的引导加载程序。
- en: The format is derived from a Sun Microsystems bootloader known as **OpenBoot**,
    which was formalized as the Open Firmware specification (IEEE standard IEEE1275-1994).
    It was used in PowerPC-based Macintosh computers and so was a logical choice for
    the PowerPC Linux port. Since then, it has been adopted at a large scale by the
    many Arm Linux implementations and, to a lesser extent, by MIPS, MicroBlaze, ARC,
    and other architectures.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 该格式源自 Sun Microsystems 的引导加载程序 **OpenBoot**，并被正式化为 Open Firmware 规范（IEEE 标准
    IEEE1275-1994）。它曾被用于基于 PowerPC 的 Macintosh 计算机，因此是 PowerPC Linux 移植的一个合乎逻辑的选择。从那时起，它已被大量采用，广泛用于许多
    Arm Linux 实现，并在较小范围内应用于 MIPS、MicroBlaze、ARC 和其他架构。
- en: I recommend visiting [https://www.devicetree.org](https://www.devicetree.org)
    for more information.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 我建议访问 [https://www.devicetree.org](https://www.devicetree.org) 获取更多信息。
- en: Device tree basics
  id: totrans-68
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 设备树基础
- en: The Linux kernel contains a large number of device tree source files in `arch/$ARCH/boot/dts`,
    and this is a good starting point for learning about device trees. Additionally,
    the U-Boot source code contains a smaller number of sources in `arch/$ARCH/dts`.
    If you acquired your hardware from a third party, the `dts` file forms part of
    the board support package, so you should expect to receive one along with the
    other source files.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: Linux 内核包含大量的设备树源文件，位于 `arch/$ARCH/boot/dts` 目录下，这里是学习设备树的一个很好的起点。此外，U-Boot
    源代码包含较少的源文件，位于 `arch/$ARCH/dts` 目录下。如果您从第三方获得了硬件，`dts` 文件是板卡支持包的一部分，因此您应该预期会收到它以及其他源文件。
- en: 'The device tree represents a computer system as a collection of components
    joined together in a hierarchy. Every device tree begins with a root node represented
    by a forward slash, `/`, which contains subsequent child nodes describing the
    hardware of the system. Each node has a name and contains several properties in
    the form `name = "value"`. Here is a simple example:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 设备树将计算机系统表示为一个层次结构中连接在一起的组件集合。每个设备树以一个根节点开始，该根节点由一个斜杠（`/`）表示，后续的子节点描述了系统的硬件。每个节点都有一个名称，并包含多个以
    `name = "value"` 形式的属性。以下是一个简单的示例：
- en: '[PRE0]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Here, we have a root node that contains a `cpus` node and a `memory` node. The
    `cpus` node contains a single CPU node named `cpu@0`. The names of these nodes
    often include an `@` followed by an address that distinguishes the node from other
    nodes of the same type. `@` is required if the node has a `reg` property.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们有一个根节点，它包含一个 `cpus` 节点和一个 `memory` 节点。`cpus` 节点包含一个名为 `cpu@0` 的单一 CPU
    节点。这些节点的名称通常包括一个 `@`，后面跟着一个地址，用以区分同类型的其他节点。如果节点有 `reg` 属性，则必须使用 `@`。
- en: Both the root and CPU nodes have a `compatible` property. The Linux kernel uses
    this property to find a matching device driver by comparing it with the strings
    that are exported by each device driver in an `of_device_id` structure (more on
    this in [*Chapter 11*](Chapter_11.xhtml#_idTextAnchor373)).
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 根节点和 CPU 节点都有一个 `compatible` 属性。Linux 内核使用这个属性通过将其与每个设备驱动程序在 `of_device_id`
    结构中导出的字符串进行比较，从而找到匹配的设备驱动程序（更多内容请参见 [*第 11 章*](Chapter_11.xhtml#_idTextAnchor373)）。
- en: '**IMPORTANT NOTE**'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: '**重要提示**'
- en: It is a convention that the value of the `compatible` property is composed of
    a manufacturer name and a component name to reduce confusion between similar devices
    made by different manufacturers, hence `ti,am33xx` and `arm,cortex-a8`. It is
    also quite common to have more than one value for the `compatible` property when
    there is more than one driver that can handle this device. They are listed with
    the most suitable mentioned first.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 传统上，`compatible` 属性的值由制造商名称和组件名称组成，以减少由不同制造商制造的类似设备之间的混淆，因此有 `ti,am33xx` 和 `arm,cortex-a8`。当有多个驱动程序可以处理此设备时，`compatible`
    属性具有多个值是非常常见的。它们按照最适合的顺序列出。
- en: The CPU node and the memory node have a `device_type` property that describes
    the class of the device. The node name is often derived from `device_type`.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: CPU 节点和内存节点都有一个 `device_type` 属性，用于描述设备的类别。节点名称通常来源于 `device_type`。
- en: reg property
  id: totrans-77
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '`reg` 属性'
- en: The `memory` and `cpu` nodes shown earlier have a `reg` property, which refers
    to a range of units in a register space. A `reg` property consists of two values
    representing the real physical address and the size (length) of the range. Both
    are written as zero or more 32-bit integers called cells. Hence, the previous
    `memory` node refers to a single bank of memory that begins at `0x80000000` and
    is `0x20000000` bytes long.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 先前显示的 `memory` 和 `cpu` 节点具有 `reg` 属性，该属性引用寄存器空间中的一系列单元。`reg` 属性由两个值组成，表示实际物理地址和范围的大小（长度）。两者都写成零或多个称为单元的
    32 位整数。因此，先前的 `memory` 节点引用了从 `0x80000000` 开始、长度为 `0x20000000` 字节的内存单元。
- en: 'Understanding `reg` properties becomes more complex when the address or size
    values cannot be represented in 32 bits. For example, on a device with 64-bit
    addressing, you need two cells for each:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 当地址或大小值无法用 32 位表示时，理解 `reg` 属性变得更加复杂。例如，在具有 64 位寻址的设备上，每个地址或大小值需要两个单元：
- en: '[PRE1]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The information about the number of cells required is held in the `#address-cells`
    and `#size_cells` properties in an ancestor node. In other words, to understand
    a `reg` property, you have to look backward down the node hierarchy until you
    find `#address-cells` and `#size_cells`. If there are none, the default values
    are `1` for each – but it is bad practice for device tree writers to depend on
    defaults. Default values may or may not be obvious, so being explicit prevents
    any misunderstandings.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 关于所需单元数的信息存储在祖先节点的 `#address-cells` 和 `#size_cells` 属性中。换句话说，要理解 `reg` 属性，你必须向节点层次结构向后查找，直到找到
    `#address-cells` 和 `#size_cells`。如果没有，则默认值为每个都是 `1` —— 但依赖默认值是设备树编写者的不良实践。默认值可能明显，也可能不明显，因此明确表示可以避免任何误解。
- en: Now, let’s return to the `cpu` and `cpus` nodes. CPUs have addresses as well.
    In a quadcore device, they might be addressed as `0`, `1`, `2`, and `3`. That
    can be thought of as a one-dimensional array without any depth, so the size is
    zero. Therefore, you can see that we have `#address-cells = <1>` and `#size-cells
    = <0>` in the `cpus` node. And in the child node, `cpu@0`, we assign a single
    value to the `reg` property with `reg = <0>`.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们回到 `cpu` 和 `cpus` 节点。CPU 也有地址。在四核设备中，它们可能被寻址为 `0`、`1`、`2` 和 `3`。可以将其视为一个没有深度的一维数组，因此大小为零。因此，你可以看到在
    `cpus` 节点中我们有 `#address-cells = <1>` 和 `#size-cells = <0>`。在子节点 `cpu@0` 中，我们通过
    `reg = <0>` 为 `reg` 属性分配了一个单一值。
- en: Labels and interrupts
  id: totrans-83
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 标签和中断
- en: The structure of the device tree described so far assumes that there is a single
    hierarchy of components when there are, in fact, several. Besides the obvious
    data connection between a component and other parts of the system, a node might
    also be connected to an interrupt controller, to a clock source, and to a voltage
    regulator.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止描述的设备树结构假设存在单一的组件层次结构，实际上可能有几个。除了组件与系统其他部分之间的明显数据连接外，节点还可能连接到中断控制器、时钟源和电压调节器。
- en: To express these connections, we can add a label to a node and reference the
    label from other nodes. These labels are sometimes referred to as **phandles**
    because when the device tree is compiled, nodes with a reference from another
    node are assigned a unique numerical value in a property called `phandle`.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 为了表达这些连接，我们可以向节点添加标签，并从其他节点引用该标签。这些标签有时被称为**phandles**，因为在编译设备树时，具有从另一个节点引用的节点会在称为
    `phandle` 的属性中被分配一个唯一的数值。
- en: 'You can see phandles if you decompile the device tree binary. Take as an example
    a system containing an LCD controller that can generate `interrupts` and an `interrupt-controller`:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你反编译设备树二进制文件，你可以看到phandle。以包含一个可以生成`interrupts`和`interrupt-controller`的LCD控制器的系统为例：
- en: '[PRE2]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Here, we have the `interrupt-controller@48200000` node with a label of `intc`.
    The `interrupt-controller` property identifies it as an interrupt controller.
    Like all interrupt controllers, it has an `#interrupt-cells` property, which tells
    us how many cells are needed to represent an interrupt source. In this case, there
    is only one that represents the **Interrupt Request** (**IRQ**) number.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，我们有一个`interrupt-controller@48200000`节点，标签为`intc`。`interrupt-controller`属性将其标识为一个中断控制器。像所有中断控制器一样，它有一个`#interrupt-cells`属性，告诉我们表示中断源需要多少个单元。在这个例子中，只有一个单元表示**中断请求**（**IRQ**）编号。
- en: Other interrupt controllers may use additional cells to characterize the interrupt,
    for example, to indicate whether it is edge or level triggered. The number of
    interrupt cells and their meanings are described in the bindings for each interrupt
    controller. The device tree bindings can be found in the Linux kernel source in
    the `Documentation/devicetree/bindings` directory.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 其他中断控制器可能会使用附加的单元来表征中断，例如，指示它是边沿触发还是电平触发。中断单元的数量及其含义在每个中断控制器的绑定文件中有所描述。设备树绑定可以在Linux内核源代码中的`Documentation/devicetree/bindings`目录下找到。
- en: Looking at the `lcdc@4830e000` node, it has an `interrupt-parent` property,
    which references the interrupt controller it is connected to using the label.
    It also has an `interrupts` property, which is `36` in this case. Note that this
    node has its own label, `lcdc`, which is used elsewhere. Any node can have a label.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 查看`lcdc@4830e000`节点，它有一个`interrupt-parent`属性，引用了它所连接的中断控制器，并使用标签。它还有一个`interrupts`属性，这里为`36`。注意，这个节点有自己的标签`lcdc`，该标签在其他地方也会使用。任何节点都可以有标签。
- en: Device tree include files
  id: totrans-91
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 设备树包含文件
- en: '[PRE3]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '[PRE4]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Look through the `.dts` files in the kernel and you will find an alternative
    `include` statement that is borrowed from C; for example, this is in `am335x-boneblack.dts`:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 浏览内核中的`.dts`文件，你会发现一个借用自C语言的替代`include`语句；例如，这在`am335x-boneblack.dts`中：
- en: '[PRE5]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Here is another example from `am33xx.dtsi`:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 这是来自`am33xx.dtsi`的另一个例子：
- en: '[PRE6]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Lastly, `include/dt-bindings/pinctrl/am33xx.h` contains normal C macros:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，`include/dt-bindings/pinctrl/am33xx.h`包含了普通的C宏：
- en: '[PRE7]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: All of this is resolved if the device tree sources are built using the Kbuild
    system, which runs them through the C preprocessor, CPP. CPP processes the `#include`
    and `#define` statements into text that is suitable for the device tree compiler.
    The motivation is illustrated by the previous example. It means that the device
    tree sources can use the same definitions of constants as the kernel code.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 如果使用Kbuild系统构建设备树源文件，所有这些问题都可以得到解决，Kbuild系统会通过C预处理器（CPP）处理它们。CPP将`#include`和`#define`语句处理成适合设备树编译器的文本。动机通过之前的例子进行了说明。这意味着设备树源文件可以使用与内核代码相同的常量定义。
- en: 'When we include files using either syntax, the nodes are overlaid on top of
    one another to create a composite tree in which the outer layers extend or modify
    the inner ones. For example, `am33xx.dtsi`, which is general to all `am33xx` SoCs,
    defines the first MMC controller interface like this:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们使用任何语法包含文件时，节点会彼此重叠，创建一个复合树，其中外层扩展或修改内层。例如，`am33xx.dtsi`是针对所有`am33xx` SoC的通用文件，它像这样定义了第一个MMC控制器接口：
- en: '[PRE8]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Note that `status` is `disabled`, meaning that no device driver should be bound
    to it, and that it has a label of `mmc1`.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，`status`为`disabled`，这意味着没有设备驱动程序应该绑定到它，而且它的标签为`mmc1`。
- en: 'Both BeagleBone and BeagleBone Black have a microSD card interface attached
    to `mmc1`. This is why, in `am335x-bone-common.dtsi`, the same node is referenced
    by an ampersand and its label, `&mmc1`:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: BeagleBone和BeagleBone Black都有一个连接到`mmc1`的microSD卡接口。这就是为什么在`am335x-bone-common.dtsi`中，通过与符号`&`一起使用它的标签`&mmc1`来引用相同的节点：
- en: '[PRE9]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Referencing a node by an ampersand and its label lets us overwrite properties
    from previous `mmc1` entries. Here, the `status` property is set to `okay`, which
    causes the MMC device driver to bind with this interface at runtime on both variants
    of BeagleBone. Also, a reference to a label is added to the pin control configuration,
    `mmc1_pins`. Alas, there is not sufficient space here to describe pin control
    and pin multiplexing. The Linux kernel source contains some information in the
    `Documentation/devicetree/bindings/pinctrl` directory.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用与标签关联的符号（&）来引用节点，可以覆盖之前 `mmc1` 条目的属性。在这里，`status` 属性被设置为 `okay`，这使得 MMC
    设备驱动程序在 BeagleBone 的两个变种上都在运行时与该接口绑定。此外，还在引脚控制配置 `mmc1_pins` 中添加了对标签的引用。遗憾的是，本文没有足够的篇幅来描述引脚控制和引脚复用。有关更多信息，可以参考
    Linux 内核源代码中 `Documentation/devicetree/bindings/pinctrl` 目录下的文档。
- en: 'However, the `mmc1` interface is connected to a different voltage regulator
    on BeagleBone Black. This is expressed in `am335x-boneblack.dts`, where you will
    see another reference to `mmc1`, which associates it with the voltage regulator
    via the `vmmcsd_fixed` label:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，BeagleBone Black 上的 `mmc1` 接口连接到一个不同的电压调节器。这在 `am335x-boneblack.dts` 文件中有所体现，你会看到另一个对
    `mmc1` 的引用，它通过 `vmmcsd_fixed` 标签将其与电压调节器关联：
- en: '[PRE10]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: So, layering the device tree source files like this gives us flexibility and
    reduces the need for duplicated code.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，以这种方式分层设备树源文件为我们提供了灵活性，并减少了重复代码的需要。
- en: Compiling a device tree
  id: totrans-110
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 编译设备树
- en: The bootloader and kernel require a binary representation of the device tree,
    so it has to be compiled using the device tree compiler, that is, `dtc`. The result
    is a file ending with `.dtb`, which is referred to as a device tree binary or
    a device tree blob.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 引导加载程序和内核需要设备树的二进制表示形式，因此必须使用设备树编译器 `dtc` 来编译。编译后的结果是一个以 `.dtb` 结尾的文件，这被称为设备树二进制文件或设备树
    Blob。
- en: 'There is a copy of `dtc` in the Linux source in `scripts/dtc/dtc`, and it is
    also available as a package on many Linux distributions. You can use it to compile
    a simple device tree (one that does not use `#include`) like this:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Linux 源代码中的 `scripts/dtc/dtc` 目录里有 `dtc` 的副本，而且它也可以作为包在许多 Linux 发行版中使用。你可以用它来编译一个简单的设备树（不使用
    `#include`）：
- en: '[PRE11]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Be wary of the fact that `dtc` does not give helpful error messages and makes
    no checks other than on the basic syntax of the language. This means that debugging
    a typing error in a device tree source file can be a lengthy process.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，`dtc` 并不会提供有用的错误信息，只会检查语言的基本语法。因此，调试设备树源文件中的输入错误可能是一个漫长的过程。
- en: To build more complex examples, you will have to use the Kbuild kernel as shown
    in [*Chapter 4*](Chapter_04.xhtml#_idTextAnchor096).
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 要构建更复杂的示例，您必须使用 Kbuild 内核，如 [*第4章*](Chapter_04.xhtml#_idTextAnchor096) 所示。
- en: Like the kernel, the bootloader can use a device tree to initialize an embedded
    SoC and its peripherals. This device tree is critical when you’re loading the
    kernel from a mass storage device such as a QSPI flash. While embedded Linux offers
    a choice of bootloaders, we will only cover one. Let’s dig deep into that bootloader
    next.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 与内核类似，引导加载程序可以使用设备树来初始化嵌入式 SoC 及其外设。当你从如 QSPI 闪存等大容量存储设备加载内核时，设备树至关重要。虽然嵌入式
    Linux 提供了多种引导加载程序的选择，但我们这里只讨论其中一个。接下来我们将深入研究这个引导加载程序。
- en: U-Boot
  id: totrans-117
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: U-Boot
- en: We are going to focus on U-Boot exclusively because it supports a good number
    of processor architectures and most individual boards and devices. U-Boot, or
    to give its full name, **Das U-Boot**, began life as an open source bootloader
    for embedded PowerPC boards. Then, it was ported to Arm-based boards and later
    to other architectures, including **Microprocessor without Interlocked Pipeline
    Stages** (**MIPS**) and **SuperH** (**SH**).
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将专注于 U-Boot，因为它支持多种处理器架构以及大多数单板和设备。U-Boot，或其全名 **Das U-Boot**，最初作为一个开源的嵌入式
    PowerPC 板的引导加载程序诞生。随后，它被移植到基于 Arm 的板子，后来又移植到其他架构，包括 **无锁管道阶段的微处理器**（**MIPS**）和
    **SuperH**（**SH**）。
- en: U-Boot has been around for a long time and has a good community. The project
    is hosted and maintained by DENX Software Engineering. There is plenty of information
    available on it, and a good place to start is [https://u-boot.readthedocs.io](https://u-boot.readthedocs.io).
    There is also a mailing list at [u-boot@lists.denx.de](https://u-boot@lists.denx.de)
    that you can subscribe to by filling out and submitting the form provided at [https://lists.denx.de/listinfo/u-boot](https://lists.denx.de/listinfo/u-boot).
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: U-Boot 已经存在很长时间，并且有一个活跃的社区。该项目由 DENX Software Engineering 主办并维护。有大量关于 U-Boot
    的信息，好的入门点是 [https://u-boot.readthedocs.io](https://u-boot.readthedocs.io)。此外，还有一个邮件列表
    [u-boot@lists.denx.de](https://u-boot@lists.denx.de)，你可以通过填写并提交 [https://lists.denx.de/listinfo/u-boot](https://lists.denx.de/listinfo/u-boot)
    上的表格来订阅。
- en: Building U-Boot
  id: totrans-120
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 构建 U-Boot
- en: 'Begin by getting the source code. As with most projects, the recommended way
    is to clone the Git repository and check out the tag you intend to use:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 首先获取源代码。像大多数项目一样，推荐的方式是克隆 Git 仓库，并检查你打算使用的标签：
- en: '[PRE12]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Alternatively, you can download a tarball from [https://ftp.denx.de/pub/u-boot/](https://ftp.denx.de/pub/u-boot/).
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，你可以从 [https://ftp.denx.de/pub/u-boot/](https://ftp.denx.de/pub/u-boot/) 下载一个
    tarball。
- en: There are more than 1,000 configuration files for common development boards
    and devices in the `configs` directory. In most cases, you can take a good guess
    regarding which to use based on the filename. But you can get more detailed information
    by looking through the `.rst` files in the `doc/board` directory. Or you can find
    information in an appropriate web tutorial or forum.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: '`configs` 目录中有超过 1,000 个用于常见开发板和设备的配置文件。在大多数情况下，你可以根据文件名大致猜测使用哪个配置文件。但你可以通过查看
    `doc/board` 目录下的 `.rst` 文件获取更详细的信息。或者，你也可以在适当的网页教程或论坛中查找相关信息。'
- en: 'Taking BeaglePlay as an example, we will find that there is a configuration
    file named `am62x_evm_a53_defconfig` in the `configs` directory. In that same
    directory, there is another configuration file named `am62x_evm_r5_defconfig`
    that is for BeaglePlay’s Arm Cortex-R5F microcontroller. The ROM code runs on
    the Arm Cortex-R5F microcontroller and the TPL runs on the main Arm Cortex-A53
    CPU. There are two U-Boot SPLs: one that runs on the R5 and another that runs
    on the main CPU. There is a sequence diagram explaining BeaglePlay’s unique boot
    flow in detail inside `doc/board/beagle/am62x_beagleplay.rst`. Take a close look
    at this sequence diagram and make sure you understand it. As you progress through
    the remainder of this chapter, refer to this diagram for clarification.'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 以 BeaglePlay 为例，我们会发现 `configs` 目录下有一个名为 `am62x_evm_a53_defconfig` 的配置文件。在同一目录中，还有一个名为
    `am62x_evm_r5_defconfig` 的配置文件，它是针对 BeaglePlay 的 Arm Cortex-R5F 微控制器的。ROM 代码运行在
    Arm Cortex-R5F 微控制器上，而 TPL 运行在主 Arm Cortex-A53 CPU 上。这里有两个 U-Boot SPL：一个运行在 R5
    上，另一个运行在主 CPU 上。在 `doc/board/beagle/am62x_beagleplay.rst` 文件中有一个顺序图，详细解释了 BeaglePlay
    独特的启动流程。仔细查看这个顺序图，确保你理解它。在本章的后续内容中，遇到不明确的地方，可以参考这个图进行澄清。
- en: Building U-Boot for BeaglePlay is a multi-stage process. The Arm Cortex-M4F
    and Cortex-R5F in BeaglePlay’s `am62x` SoC are 32-bit processors, so they require
    a 32-bit toolchain. A software component called **TI Foundational Security** (**TIFS**)
    runs on the M4\. TIFS starts the R5 and asks it to load a firmware image to the
    TIFS core. That means we need to bundle a TIFS binary firmware image for the M4
    together with a U-Boot SPL when generating a bootloader image for the R5\. Next,
    we need to build **Trusted Firmware-A** (**TF-A**) for the main A53 CPU using
    a 64-bit toolchain. Lastly, we configure and build a U-Boot SPL and TPL for the
    main CPU.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 为 BeaglePlay 构建 U-Boot 是一个多阶段的过程。BeaglePlay 的 `am62x` SoC 中的 Arm Cortex-M4F
    和 Cortex-R5F 是 32 位处理器，因此它们需要一个 32 位的工具链。一个名为 **TI Foundational Security**（**TIFS**）的软件组件运行在
    M4 上。TIFS 启动 R5，并要求其加载一个固件映像到 TIFS 核心中。这意味着，在为 R5 生成启动加载器映像时，我们需要将 TIFS 二进制固件映像与
    U-Boot SPL 一起捆绑。接下来，我们需要使用 64 位工具链为主 A53 CPU 构建 **Trusted Firmware-A**（**TF-A**）。最后，我们为主
    CPU 配置并构建 U-Boot SPL 和 TPL。
- en: Obtaining a 32-bit toolchain
  id: totrans-127
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 获取 32 位工具链
- en: 'Point your web browser at [https://developer.arm.com/downloads/-/arm-gnu-toolchain-downloads](https://developer.arm.com/downloads/-/arm-gnu-toolchain-downloads).
    Search for **Downloads: 13.2.Rel1** and click on the plus sign in front to expand
    that section. Then click on the `arm-gnu-toolchain-13.2.rel1-x86_64-arm-none-eabi.tar.xz`
    file under x86_64 Linux hosted cross toolchains **AArch32 bare-metal target**(**arm-none-eabi**)
    to download the toolchain.'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: '打开您的浏览器，访问[https://developer.arm.com/downloads/-/arm-gnu-toolchain-downloads](https://developer.arm.com/downloads/-/arm-gnu-toolchain-downloads)。搜索**Downloads:
    13.2.Rel1**，点击前面的加号展开该部分。然后点击`arm-gnu-toolchain-13.2.rel1-x86_64-arm-none-eabi.tar.xz`文件，在x86_64
    Linux宿主的交叉工具链**AArch32裸机目标**(**arm-none-eabi**)下下载工具链。'
- en: The following R5 exercises were successfully performed with that version of
    the Arm GNU toolchain. I recommend downloading the same version from that web
    page (if it is still available) to prevent any problems.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 以下R5练习已使用该版本的Arm GNU工具链成功执行。我建议从该网页下载相同版本的工具链（如果它仍然可用），以避免任何问题。
- en: 'Install the 32-bit toolchain in your home directory:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 在您的主目录中安装32位工具链：
- en: '[PRE13]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Add the 32-bit toolchain to your `PATH` environment variable:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 将32位工具链添加到您的`PATH`环境变量中：
- en: '[PRE14]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: You are now ready to build U-Boot for the R5\. Make sure to replace `13.2.rel1`
    and `13.2.Rel1` in the preceding commands with the actual version of the 32-bit
    toolchain you downloaded.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，您可以为R5构建U-Boot了。确保将前述命令中的`13.2.rel1`和`13.2.Rel1`替换为您下载的32位工具链的实际版本。
- en: Building U-Boot SPL for R5
  id: totrans-135
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 为R5构建U-Boot SPL
- en: Support for BeaglePlay in mainline U-Boot was very new back in November 2023
    when I wrote this. For this reason, I have instead opted to use BeagleBoard.org’s
    U-Boot fork for BeaglePlay. I suggest building the U-Boot source from the same
    Git repo (if it is still available) to prevent any problems.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 当我在2023年11月编写这篇文章时，主线U-Boot对BeaglePlay的支持还很新。因此，我选择使用BeagleBoard.org为BeaglePlay提供的U-Boot分支。我建议从相同的Git仓库（如果仍然可用）构建U-Boot源代码，以避免任何问题。
- en: 'Clone the U-Boot fork to your home directory and check out a stable commit:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 将U-Boot分支克隆到您的主目录，并检出一个稳定的提交：
- en: '[PRE15]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Install the packages needed to build U-Boot for BeaglePlay:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 安装为BeaglePlay构建U-Boot所需的包：
- en: '[PRE16]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Configure and build U-Boot for the R5:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 为R5配置并构建U-Boot：
- en: 'First, create a build directory for the R5 one level up to share build artifacts
    across builds:'
  id: totrans-142
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，为R5创建一个构建目录，向上一层共享构建产物：
- en: '[PRE17]'
  id: totrans-143
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Next, set the `ARCH` and `CROSS_COMPILE` environment variables for 32-bit Arm:'
  id: totrans-144
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，为32位Arm设置`ARCH`和`CROSS_COMPILE`环境变量：
- en: '[PRE18]'
  id: totrans-145
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Select `am62x_evm_r5_defconfig` for building:'
  id: totrans-146
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择`am62x_evm_r5_defconfig`进行构建：
- en: '[PRE19]'
  id: totrans-147
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Run `make menuconfig` to configure U-Boot further for building:'
  id: totrans-148
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行`make menuconfig`进一步配置U-Boot以进行构建：
- en: '[PRE20]'
  id: totrans-149
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Drill down into the **Environment** submenu.
  id: totrans-150
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 进入**环境**子菜单。
- en: Select **Environment is in a EXT4 filesystem**.
  id: totrans-151
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 选择**环境位于EXT4文件系统中**。
- en: '![Figure 3.5 – Selecting Environment is in a EXT4 fileystem](img/B18466_03_05.png)'
  id: totrans-152
  prefs: []
  type: TYPE_IMG
  zh: '![图 3.5 – 选择环境位于EXT4文件系统中](img/B18466_03_05.png)'
- en: Figure 3.5 – Selecting Environment is in a EXT4 fileystem
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.5 – 选择环境位于EXT4文件系统中
- en: Deselect any other options (e.g., MMC, NAND, and SPI) for environment storage
    on that menu page.
  id: totrans-154
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在该菜单页面上取消选择任何其他选项（例如，MMC、NAND和SPI）作为环境存储。
- en: Enter `mmc` in the **Name of the block device for the environment** text field.
  id: totrans-155
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**环境的块设备名称**文本字段中输入`mmc`。
- en: '![Figure 3.6 – Name of the block device for the environment](img/B18466_03_06.png)'
  id: totrans-156
  prefs: []
  type: TYPE_IMG
  zh: '![图 3.6 – 环境的块设备名称](img/B18466_03_06.png)'
- en: Figure 3.6 – Name of the block device for the environment
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.6 – 环境的块设备名称
- en: Enter `1:2` in the **Device and partition for where to store the environment
    in EXT4** text field.
  id: totrans-158
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**EXT4中存储环境的设备和分区**文本字段中输入`1:2`。
- en: '![Figure 3.7 – Device and partition for where to store the environment in EXT4](img/B18466_03_07.png)'
  id: totrans-159
  prefs: []
  type: TYPE_IMG
  zh: '![图 3.7 – EXT4中存储环境的设备和分区](img/B18466_03_07.png)'
- en: Figure 3.7 – Device and partition for where to store the environment in EXT4
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.7 – EXT4中存储环境的设备和分区
- en: Ensure `/uboot.env` is the **Name of the EXT4 file to use for the environment**
    text field.
  id: totrans-161
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确保`/uboot.env`是**用于环境的EXT4文件名**文本字段。
- en: '![Figure 3.8 – Environment](img/B18466_03_08.png)'
  id: totrans-162
  prefs: []
  type: TYPE_IMG
  zh: '![图 3.8 – 环境](img/B18466_03_08.png)'
- en: Figure 3.8 – Environment
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.8 – 环境
- en: Back out of the **Environment** submenu.
  id: totrans-164
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 退出**环境**子菜单。
- en: Drill down into the **SPL/TPL** submenu.
  id: totrans-165
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 进入**SPL/TPL**子菜单。
- en: Select **Support EXT filesystems**.
  id: totrans-166
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择**支持EXT文件系统**。
- en: '![Figure 3.9 – Select Support EXT4 filesystems](img/B18466_03_09.png)'
  id: totrans-167
  prefs: []
  type: TYPE_IMG
  zh: '![图 3.9 – 选择支持EXT4文件系统](img/B18466_03_09.png)'
- en: Figure 3.9 – Select Support EXT4 filesystems
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.9 – 选择支持EXT4文件系统
- en: Back out of the **SPL/TPL** submenu.
  id: totrans-169
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 退出**SPL/TPL**子菜单。
- en: Drill down into the **Boot Options** submenu.
  id: totrans-170
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 进入**Boot Options**子菜单。
- en: Select **Enable a default value for bootcmd**.
  id: totrans-171
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择**启用bootcmd的默认值**。
- en: '![Figure 3.10 – Select Enable a default value for bootcmd](img/B18466_03_10.png)'
  id: totrans-172
  prefs: []
  type: TYPE_IMG
  zh: '![图3.10 – 选择启用bootcmd的默认值](img/B18466_03_10.png)'
- en: Figure 3.10 – Select Enable a default value for bootcmd
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.10 – 选择启用bootcmd的默认值。
- en: Enter `echo 'no bootcmd yet'` in the **bootcmd value** text field.
  id: totrans-174
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**bootcmd value**文本字段中输入`echo 'no bootcmd yet'`。
- en: '![Figure 3.11 – bootcmd value](img/B18466_03_11.png)'
  id: totrans-175
  prefs: []
  type: TYPE_IMG
  zh: '![图 3.11 – bootcmd value](img/B18466_03_11.png)'
- en: Figure 3.11 – bootcmd value
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.11 – bootcmd value。
- en: '![Figure 3.12 – Boot options](img/B18466_03_12.png)'
  id: totrans-177
  prefs: []
  type: TYPE_IMG
  zh: '![图3.12 – 启动选项](img/B18466_03_12.png)'
- en: Figure 3.12 – Boot options
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.12 – 启动选项。
- en: Exit out of `menuconfig` and choose **Yes** when asked to save your new configuration.
  id: totrans-179
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 退出`menuconfig`，并在询问是否保存新配置时选择**是**。
- en: 'Lastly, build the U-Boot for the R5:'
  id: totrans-180
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，为R5构建U-Boot：
- en: '[PRE21]'
  id: totrans-181
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: When U-Boot is done building, there should be an SPL binary for the R5 in `../build_uboot/r5/spl`.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 当U-Boot构建完成时，应该在`../build_uboot/r5/spl`目录下找到R5的SPL二进制文件。
- en: Refer to the boot flow sequence diagram in `doc/board/beagle/am62x_beagleplay.rst`.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 请参考`doc/board/beagle/am62x_beagleplay.rst`中的启动流程序列图。
- en: Generating an image for the R5
  id: totrans-184
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 为R5生成镜像。
- en: Recall that the TIFS firmware image that gets loaded into the M4 needs to be
    bundled together with the U-Boot SPL for the R5\. We obtain the binary TIFS firmware
    image directly from TI.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 回顾一下，加载到M4中的TIFS固件镜像需要与R5的U-Boot SPL一起打包。我们直接从TI获取二进制TIFS固件镜像。
- en: 'Clone the TI firmware repo to your home directory:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 将TI固件仓库克隆到你的主目录：
- en: '[PRE22]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Bundling the TIFS firmware image for the M4 together with the U-Boot SPL for
    the R5 requires a tool named `k3-image-gen`.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 将M4的TIFS固件镜像与R5的U-Boot SPL一起打包，需要一个名为`k3-image-gen`的工具。
- en: 'Clone the `k3-image-gen` repo to your home directory:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 将`k3-image-gen`仓库克隆到你的主目录：
- en: '[PRE23]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Generate the combined image for the R5 by running `make` in the `k3-image-gen`
    directory with paths to the U-Boot SPL and TIFS firmware image passed in as arguments:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 通过在`k3-image-gen`目录中运行`make`并将U-Boot SPL和TIFS固件镜像的路径作为参数传递，生成R5的合并镜像：
- en: '[PRE24]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: There should now be a `tiboot3.bin` file in the `k3-image-gen` directory.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，`k3-image-gen`目录中应该有一个`tiboot3.bin`文件。
- en: Refer to the boot flow sequence diagram in `doc/board/beagle/am62x_beagleplay.rst`.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 请参考`doc/board/beagle/am62x_beagleplay.rst`中的启动流程序列图。
- en: Building TF-A for the main A53 CPU
  id: totrans-195
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 为主A53 CPU构建TF-A。
- en: The A53 in BeaglePlay’s `am62x` SoC is a 64-bit CPU, so we must switch to a
    64-bit toolchain to cross-compile source code for it. We will use the same 64-bit
    Bootlin toolchain from [*Chapter 2*](Chapter_01.xhtml#_idTextAnchor028) that you
    installed in your home directory.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: BeaglePlay中`am62x` SoC的A53是64位CPU，因此我们必须切换到64位工具链，以交叉编译源代码。我们将使用你在主目录中安装的[*第2章*](Chapter_01.xhtml#_idTextAnchor028)中的相同64位Bootlin工具链。
- en: 'Add that 64-bit Bootlin toolchain to your `PATH` environment variable:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 将该64位Bootlin工具链添加到你的`PATH`环境变量中：
- en: '[PRE25]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Make sure to replace `2024.02-1` in the preceding commands with the actual version
    of the 64-bit toolchain you downloaded.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 确保将前述命令中的`2024.02-1`替换为你下载的实际64位工具链版本。
- en: 'Clone the TF-A source code to your home directory and check out a stable release
    tag:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 将TF-A源代码克隆到你的主目录，并检出一个稳定的发布标签：
- en: '[PRE26]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Configure and build TF-A for the A53:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 为A53配置并构建TF-A：
- en: 'Set the `ARCH` and `CROSS_COMPILE` environment variables for 64-bit Arm:'
  id: totrans-203
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为64位Arm设置`ARCH`和`CROSS_COMPILE`环境变量：
- en: '[PRE27]'
  id: totrans-204
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Build TF-A for the A53 specifying `k3` as the platform and `lite` as the target
    board:'
  id: totrans-205
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为A53构建TF-A，并指定`k3`作为平台，`lite`作为目标板：
- en: '[PRE28]'
  id: totrans-206
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: When TF-A is done building, there should be a `bl31.bin` for the A53 in `./build/k3/lite/release`.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 当TF-A构建完成时，应该在`./build/k3/lite/release`目录下找到A53的`bl31.bin`文件。
- en: Refer to the boot flow sequence diagram in `doc/board/beagle/am62x_beagleplay.rst`.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 请参考`doc/board/beagle/am62x_beagleplay.rst`中的启动流程序列图。
- en: Building U-Boot for the main A53 CPU
  id: totrans-209
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 为主A53 CPU构建U-Boot。
- en: All the build steps performed up until now are unique to the `am62x` SoC in
    BeaglePlay. Building U-Boot for most targets only requires compiling an SPL and
    TPL for the main CPU. We will use the same 64-bit Bootlin toolchain from [*Chapter
    2*](Chapter_01.xhtml#_idTextAnchor028)that you installed in your home directory.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止执行的所有构建步骤都是BeaglePlay中`am62x` SoC特有的。为大多数目标构建U-Boot只需要为主CPU编译SPL和TPL。我们将使用你在主目录中安装的[*第2章*](Chapter_01.xhtml#_idTextAnchor028)中的相同64位Bootlin工具链。
- en: 'Add that 64-bit Bootlin toolchain to your `PATH` environment variable:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 将该64位Bootlin工具链添加到你的`PATH`环境变量中：
- en: '[PRE29]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Make sure to replace `2024.02-1` in the preceding commands with the actual version
    of the 64-bit toolchain you downloaded.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 确保在上述命令中将`2024.02-1`替换为你下载的64位工具链的实际版本。
- en: 'Configure and build U-Boot for the A53:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 配置并为A53构建U-Boot：
- en: 'First, navigate back to the `u-boot` source tree for BeaglePlay:'
  id: totrans-215
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，导航回BeaglePlay的`u-boot`源代码树：
- en: '[PRE30]'
  id: totrans-216
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Next, create a build directory for the A53 one level up:'
  id: totrans-217
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，在上一层级创建A53的构建目录：
- en: '[PRE31]'
  id: totrans-218
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Set the `ARCH` and `CROSS_COMPILE` environment variables for 64-bit Arm:'
  id: totrans-219
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 设置`ARCH`和`CROSS_COMPILE`环境变量为64位Arm：
- en: '[PRE32]'
  id: totrans-220
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Select `am62x_evm_a53_defconfig` for building:'
  id: totrans-221
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择`am62x_evm_a53_defconfig`进行构建：
- en: '[PRE33]'
  id: totrans-222
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Run `make menuconfig` to configure U-Boot further for building:'
  id: totrans-223
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行`make menuconfig`进一步配置U-Boot以进行构建：
- en: '[PRE34]'
  id: totrans-224
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Drill down into the **Environment** submenu.
  id: totrans-225
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 进入**环境**子菜单。
- en: Select **Environment is in a EXT4 filesystem**.
  id: totrans-226
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择**环境在EXT4文件系统中**。
- en: Deselect any other options (e.g., MMC, NAND, and SPI) for environment storage
    on that menu page.
  id: totrans-227
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 取消选择该菜单页面上的其他选项（例如MMC、NAND和SPI）作为环境存储。
- en: Enter `mmc` in the **Name of the block device for the environment** text field.
  id: totrans-228
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**环境的块设备名称**文本框中输入`mmc`。
- en: Enter `1:2` in the **Device and partition for where to store the environment
    in EXT4** text field.
  id: totrans-229
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**为EXT4存储环境的设备和分区**文本框中输入`1:2`。
- en: Ensure `/uboot.env` is entered in the **Name of the EXT4 file to use for the
    environment** text field.
  id: totrans-230
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确保在**用于环境的EXT4文件名称**文本框中输入`/uboot.env`。
- en: Back out of the **Environment** submenu.
  id: totrans-231
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 退出**环境**子菜单。
- en: Drill down into the **SPL/TPL** submenu.
  id: totrans-232
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 进入**SPL/TPL**子菜单。
- en: Select **Support EXT filesystems**.
  id: totrans-233
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择**支持EXT文件系统**。
- en: Back out of the **SPL/TPL** submenu.
  id: totrans-234
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 退出**SPL/TPL**子菜单。
- en: Drill down into the **Boot Options** submenu.
  id: totrans-235
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 进入**启动选项**子菜单。
- en: Select **Enable a default value for bootcmd**.
  id: totrans-236
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择**启用默认的bootcmd值**。
- en: Enter `echo 'no bootcmd yet'` in the **bootcmd value** text field.
  id: totrans-237
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**bootcmd值**文本框中输入`echo 'no bootcmd yet'`。
- en: Exit out of `menuconfig` and choose **Yes** when asked to save your new configuration.
  id: totrans-238
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 退出`menuconfig`并在被询问是否保存新配置时选择**是**。
- en: 'Lastly, build U-Boot for the A53 passing paths to TI’s TF-A and DM firmware
    as arguments to `make`:'
  id: totrans-239
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，构建U-Boot以A53为目标，并将TI的TF-A和DM固件路径作为参数传递给`make`：
- en: '[PRE35]'
  id: totrans-240
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE35]'
- en: '**IMPORTANT NOTE**'
  id: totrans-241
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '**重要说明**'
- en: Always use absolute paths as opposed to relative `./` paths to point to the
    `ATF` and `DM` firmware in your `make` command. Otherwise, the resulting SPL and
    U-Boot binaries will be incorrect in size and content.
  id: totrans-242
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在`make`命令中始终使用绝对路径，而非相对路径`./`，指向`ATF`和`DM`固件。否则，生成的SPL和U-Boot二进制文件在大小和内容上都会不正确。
- en: 'The results of the compilation are as follows:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 编译结果如下：
- en: '`u-boot`: U-Boot in ELF format, suitable for use with a debugger'
  id: totrans-244
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`u-boot`：U-Boot的ELF格式，适用于调试器'
- en: '`u-boot.map`: The symbol table'
  id: totrans-245
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`u-boot.map`：符号表'
- en: '`u-boot.bin`: U-Boot in raw binary format, suitable for running on your device'
  id: totrans-246
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`u-boot.bin`：U-Boot的原始二进制格式，适合在你的设备上运行'
- en: '`u-boot.img`: `u-boot.bin` with a U-Boot header added, suitable for uploading
    to a running copy of U-Boot'
  id: totrans-247
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`u-boot.img`：`u-boot.bin`加上U-Boot头部，适合上传到运行中的U-Boot副本'
- en: '`u-boot.srec`: U-Boot in Motorola S-record (**SRECORD** or **SRE**) format,
    suitable for transferring over a serial connection'
  id: totrans-248
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`u-boot.srec`：U-Boot的摩托罗拉S记录格式（**SRECORD**或**SRE**），适合通过串行连接传输'
- en: 'BeaglePlay also requires an SPL, as described earlier. This is built at the
    same time and is named `tispl.bin` (the boot flow sequence diagram in `doc/board/beagle/am62x_beagleplay.rst`):'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: BeaglePlay还需要一个SPL，如前所述。它与U-Boot同时构建，并命名为`tispl.bin`（在`doc/board/beagle/am62x_beagleplay.rst`中的启动流程图）：
- en: '[PRE36]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: The procedure is similar for other targets.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 其他目标的过程类似。
- en: Installing U-Boot
  id: totrans-252
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 安装U-Boot
- en: Installing a bootloader on a board for the first time requires some manual intervention.
    If the board has a hardware debug interface, such as a **Joint Test Action Group**
    (**JTAG**), it is usually possible to load a copy of U-Boot directly into RAM
    and get it running. From that point, you can use U-Boot commands so that it copies
    itself into flash memory. The details are very board-specific and outside the
    scope of this book.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 第一次在板上安装引导加载程序需要一些手动干预。如果板子有硬件调试接口，比如**联合测试动作组**（**JTAG**），通常可以直接将U-Boot的副本加载到RAM中并使其运行。之后，你可以使用U-Boot命令将其复制到闪存中。具体细节因板子而异，超出了本书的范围。
- en: Many SoC designs have a boot ROM built in that can be used to read boot code
    from various external sources, such as SD cards, serial interfaces, or USB mass
    storage. This is the case with the `am62x` chip in the Beagle, which makes it
    easy to try out new software.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 许多 SoC 设计内置了一个启动 ROM，可以用来从各种外部源读取启动代码，例如 SD 卡、串行接口或 USB 大容量存储。这正是 Beagle 上的
    `am62x` 芯片的情况，它使得尝试新软件变得非常容易。
- en: 'You will need a microSD card reader to write the images to a card. There are
    two types: external readers that plug into a USB port and the internal SD readers
    that are present on many laptops. A device name is assigned by Linux when a card
    is plugged into the reader. The `lsblk` command is a useful tool for finding out
    which device has been allocated. For example, this is what I see when I plug a
    nominal 32 GB microSD card into my card reader:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 您需要一个 microSD 卡读卡器来将镜像写入卡中。读卡器有两种类型：外接读卡器，通过 USB 端口连接，以及许多笔记本电脑上内置的 SD 读卡器。Linux
    会在插入卡片时为其分配一个设备名称。`lsblk` 命令是一个有用的工具，可以帮助您查找分配到哪个设备。例如，当我将一张名义上是 32 GB 的 microSD
    卡插入读卡器时，看到的输出如下：
- en: '[PRE37]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: In this case, `nvme0n1` is my 512 GB hard drive and `sda` is the microSD card.
    It has a single partition, `sda1`, which is mounted as the `/media/frank/6662-6262`
    directory.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，`nvme0n1` 是我的 512 GB 硬盘，`sda` 是 microSD 卡。它只有一个分区，`sda1`，挂载为 `/media/frank/6662-6262`
    目录。
- en: 'If I use the built-in SD card slot, I see this:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我使用内置的 SD 卡槽，我会看到如下：
- en: '[PRE38]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: In this case, the microSD card appears as `mmcblk0`, and the partition is `mmcblk0p1`.
    Note that the microSD card you use may have been formatted differently than this
    one, so you may see a different number of partitions with different mount points.
    When formatting an SD card, it is very important to be sure of its device name.
    You really don’t want to mistake your hard drive for an SD card and format that
    instead.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，microSD 卡显示为 `mmcblk0`，分区为 `mmcblk0p1`。请注意，您使用的 microSD 卡可能与此卡格式不同，因此可能会看到不同数量的分区以及不同的挂载点。在格式化
    SD 卡时，非常重要的一点是要确保它的设备名称。你绝对不想把硬盘当作 SD 卡误格式化了。
- en: 'This has happened to me more than once. So, I have provided a shell script
    in this book’s code repo named `MELD/format-sdcard.sh`, which has a reasonable
    number of checks to prevent you (and me) from using the wrong device name. The
    parameter is the device name of the microSD card, which would be `sda` in the
    first example and `mmcblk0` in the second. Here is an example of its use:'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 这种情况我不止一次遇到过。所以，在本书的代码仓库中，我提供了一个名为 `MELD/format-sdcard.sh` 的 shell 脚本，其中包含了足够的检查，以防止您（和我）使用错误的设备名称。参数是
    microSD 卡的设备名称，第一个例子中的设备名称是 `sda`，第二个例子中的设备名称是 `mmcblk0`。以下是它的使用示例：
- en: '[PRE39]'
  id: totrans-262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: The script creates two partitions. The first is 128 MB and formatted as FAT32,
    and it will contain the bootloader, while the second is 1 GB and formatted as
    ext4, which you will use in [*Chapter 5*](Chapter_05.xhtml#_idTextAnchor138).
    The script aborts when it’s applied to any drive greater than 128 GB so be prepared
    to modify it if you are using larger microSD cards.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 该脚本创建了两个分区。第一个分区为 128 MB，格式化为 FAT32，用来存放引导加载程序；第二个分区为 1 GB，格式化为 ext4，您将在 [*第
    5 章*](Chapter_05.xhtml#_idTextAnchor138) 中使用。该脚本会在应用到任何大于 128 GB 的驱动器时中止，因此如果您使用的是更大的
    microSD 卡，请准备修改脚本。
- en: Once you have formatted the microSD card, remove it from the card reader and
    then reinsert it. Roll over and click on one of the USB stick icons that appears
    to the left of the Ubuntu desktop so that a window opens for the `boot` partition.
    On current versions of Ubuntu, the two partitions are mounted as `/media/<user>/boot`
    and `/media/<user>/rootfs`.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 格式化完 microSD 卡后，将其从读卡器中取出，然后重新插入。将鼠标移动到并点击显示在 Ubuntu 桌面左侧的 USB 驱动器图标之一，以便打开
    `boot` 分区的窗口。在当前版本的 Ubuntu 中，这两个分区会挂载为 `/media/<user>/boot` 和 `/media/<user>/rootfs`。
- en: 'Copy `tiboot3.bin`, `tispl.bin` and `u-boot.img` to the `boot` partition like
    this:'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 将 `tiboot3.bin`、`tispl.bin` 和 `u-boot.img` 复制到 `boot` 分区，像这样：
- en: '[PRE40]'
  id: totrans-266
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Right-click on either of the two USB stick icons and select **Eject** to unmount
    the microSD card. Lastly, remove the microSD card from your host machine’s card
    reader.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 右键点击两个 USB 驱动器图标中的任意一个，选择 **弹出** 来卸载 microSD 卡。最后，从主机的读卡器中取出 microSD 卡。
- en: 'To boot BeaglePlay from your newly prepared microSD card:'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 要从新准备的 microSD 卡启动 BeaglePlay：
- en: With no power on BeaglePlay, insert the microSD card into BeaglePlay’s reader.
  id: totrans-269
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 BeaglePlay 没有通电的情况下，将 microSD 卡插入 BeaglePlay 的读卡器。
- en: Plug the USB side of your USB-to-TTL serial cable into your host machine. Make
    sure your cable has a 3.3 V logic level.
  id: totrans-270
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 USB 到 TTL 串行线的 USB 端插入您的主机。确保您的电缆具有 3.3 V 的逻辑电平。
- en: The three-pin UART connector is right next to the USB-C connector on BeaglePlay.
    Do not connect a fourth red wire from your cable. A red wire typically indicates
    power, which is unnecessary in this instance and could damage the board.
  id: totrans-271
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 三针 UART 连接器位于 BeaglePlay 的 USB-C 连接器旁边。不要将电缆的第四根红线连接上。红线通常表示电源，而在这种情况下不需要，且可能会损坏板子。
- en: Connect the TX wire from the cable to the RX pin on BeaglePlay.
  id: totrans-272
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将电缆中的 TX 线连接到 BeaglePlay 的 RX 引脚。
- en: Connect the RX wire from the cable to the TX pin on BeaglePlay.
  id: totrans-273
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将电缆中的 RX 线连接到 BeaglePlay 的 TX 引脚。
- en: Connect the GND (black) wire from the cable to the GND pin on BeaglePlay.
  id: totrans-274
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将电缆中的 GND（黑色）线连接到 BeaglePlay 的 GND 引脚。
- en: A serial port should appear on your PC as `/dev/ttyUSB0`.
  id: totrans-275
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一个串口应该会在你的 PC 上显示为 `/dev/ttyUSB0`。
- en: 'Start a suitable terminal program, like `gtkterm`, `minicom`, or `picocom`,
    and attach it to the port at 115,200 **bits per second** (**bps**) with no flow
    control. `gtkterm` is probably the easiest to set up and use:'
  id: totrans-276
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 启动一个合适的终端程序，如`gtkterm`、`minicom`或`picocom`，并将其连接到115,200 **比特每秒** (**bps**)
    的端口，且不使用流控制。`gtkterm`可能是最容易设置和使用的：
- en: '[PRE41]'
  id: totrans-277
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE41]'
- en: If you get a permissions error, then you may need to add yourself to the `dialout`
    group to use this port or launch `gtkterm` with `sudo`. If garbled or no output
    appears on the serial console, then swap the wires connected to the RX and TX
    pins on BeaglePlay.
  id: totrans-278
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果你遇到权限错误，可能需要将自己添加到 `dialout` 组中才能使用该端口，或者用 `sudo` 启动 `gtkterm`。如果串口控制台上没有输出或出现乱码，可以交换
    BeaglePlay 上 RX 和 TX 引脚连接的线。
- en: Press and hold the USR button on BeaglePlay.
  id: totrans-279
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按住 BeaglePlay 上的 USR 按钮。
- en: Power up the board using USB-C.
  id: totrans-280
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 USB-C 启动开发板。
- en: Release the button after about 5 seconds.
  id: totrans-281
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 大约 5 秒后松开按钮。
- en: 'You should see some output followed by a U-Boot prompt on the serial console:'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该在串口控制台上看到一些输出，后跟一个 U-Boot 提示符：
- en: '[PRE42]'
  id: totrans-283
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: Hit any key on your keyboard to stop U-Boot from autobooting with the default
    environment. Now that we have a U-Boot prompt in front of us, let’s put U-Boot
    through its paces.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 按下键盘上的任意键以停止 U-Boot 在默认环境下自动启动。现在我们面前有了一个 U-Boot 提示符，让我们开始使用 U-Boot。
- en: Using U-Boot
  id: totrans-285
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 U-Boot
- en: In this section, I describe some of the common tasks that can be performed with
    U-Boot.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我将描述一些可以使用 U-Boot 执行的常见任务。
- en: U-Boot provides a command-line interface over a serial port. It provides a command
    prompt that is customized for each board. In these examples, I use `=>` for the
    command prompt. Typing `help` prints out all the commands that have been configured
    in this version of U-Boot. Typing `help <command>` prints out more information
    about a particular command.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: U-Boot 提供一个串口命令行界面，提供一个为每个板定制的命令提示符。在这些示例中，我使用`=>`作为命令提示符。输入`help`会列出当前版本的 U-Boot
    中配置的所有命令。输入`help <command>`会列出关于某个特定命令的更多信息。
- en: The default command interpreter for BeaglePlay is quite simple. You cannot do
    command-line editing by pressing the left or right keys. There is no command completion
    by pressing the *Tab* key, and there is no command history by pressing the up
    arrow key. Pressing any of these keys will disrupt the command you are currently
    trying to type, and you will have to type *Ctrl + C* and start all over again.
    The only line editing key you can safely use is the backspace.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: BeaglePlay的默认命令解释器相当简单。你无法通过按左箭头或右箭头键来编辑命令行。按*Tab*键也无法完成命令输入，按上箭头键也无法查看命令历史。按下这些键中的任何一个会打断你当前输入的命令，你需要按*Ctrl
    + C*并重新开始。你唯一可以安全使用的行编辑键是退格键。
- en: As an option, you can configure a different command shell called **Hush**, which
    has more sophisticated interactive support, including command-line editing.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 作为可选项，你可以配置一个不同的命令外壳程序叫做**Hush**，它具有更复杂的交互支持，包括命令行编辑。
- en: 'The default number format is hexadecimal. Consider the following command:'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 默认的数字格式是十六进制。考虑以下命令：
- en: '[PRE43]'
  id: totrans-291
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: This will read `0x200000` bytes from offset `0x400000` from the start of the
    NAND flash memory into RAM address `0x82000000`.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 这将从 NAND 闪存的 `0x400000` 偏移处读取 `0x200000` 字节数据到 RAM 地址 `0x82000000`。
- en: Environment variables
  id: totrans-293
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 环境变量
- en: 'U-Boot uses environment variables extensively to store and pass information
    between functions and even to create scripts. Environment variables are simple
    `name=value` pairs that are stored in an area of memory. The initial population
    of variables may be coded in the board configuration header file like this:'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: U-Boot广泛使用环境变量来存储并传递信息，甚至用于创建脚本。环境变量是简单的`name=value`对，存储在内存区域中。变量的初始值可能在板级配置头文件中这样编写：
- en: '[PRE44]'
  id: totrans-295
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: You can create and modify variables from the U-Boot command line using `setenv`.
    For example, `setenv foo bar` creates the `foo` variable with the `bar` value.
    Note that there is no `=` sign between the variable name and the value. You can
    delete a variable by setting it to a null string using `setenv foo`. You can print
    all the variables to the console using `printenv`, or you can print a single variable
    using `printenv foo`.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过 U-Boot 命令行使用 `setenv` 创建和修改变量。例如，`setenv foo bar` 创建名为 `foo` 的变量，并赋值为
    `bar`。请注意，变量名和值之间没有 `=` 符号。你可以通过设置变量为空字符串来删除该变量，例如使用 `setenv foo`。你可以使用 `printenv`
    命令打印所有变量到控制台，或使用 `printenv foo` 打印单个变量。
- en: If U-Boot has been configured with space to store the environment, you can use
    the `saveenv` command to save it. If there is raw NAND or NOR flash, then an erase
    block can be reserved for this purpose, often with another erase block being used
    as a redundant copy to guard against corruption. If there is eMMC or SD card storage,
    it can be stored in a reserved array of sectors, or in a file named `uboot.env`
    in a partition of the disk. Other options include storing it in serial **Electrical
    Erasable Programmable Read Only Memory** (**EEPROM**) connected via an I2C or
    SPI interface or non-volatile RAM.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 U-Boot 配置了存储环境的空间，你可以使用 `saveenv` 命令保存环境变量。如果是原始的 NAND 或 NOR 闪存，那么可以为此目的保留一个擦除块，通常还会使用另一个擦除块作为冗余副本，以防止损坏。如果有
    eMMC 或 SD 卡存储，可以将其存储在保留的扇区阵列中，或存储在磁盘分区中的名为 `uboot.env` 的文件中。其他选项包括通过 I2C 或 SPI
    接口连接的串行**电可擦可编程只读存储器**（**EEPROM**）或非易失性 RAM。
- en: Boot image format
  id: totrans-298
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 启动镜像格式
- en: 'U-Boot doesn’t have a filesystem. Instead, it tags blocks of information with
    a 64-byte header so that it can track the contents. We prepare files for U-Boot
    using the `mkimage` command-line tool, which comes bundled with the `u-boot-tools`
    package on Ubuntu. You can also get `mkimage` by running `make tools` from within
    the U-Boot source tree and then invoke it as `tools/mkimage`. Here is a summary
    of the command’s usage:'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: U-Boot 没有文件系统。相反，它通过一个 64 字节的头部标记信息块，以便跟踪内容。我们使用 `mkimage` 命令行工具为 U-Boot 准备文件，该工具随
    `u-boot-tools` 包一起提供，适用于 Ubuntu。你也可以通过在 U-Boot 源代码树中运行 `make tools` 来获取 `mkimage`，然后通过
    `tools/mkimage` 来调用它。以下是该命令的用法概述：
- en: '[PRE45]'
  id: totrans-300
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'For example, to prepare a kernel image for a 32-bit Arm processor, you can
    use the following command:'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，要为 32 位 Arm 处理器准备内核镜像，你可以使用以下命令：
- en: '[PRE46]'
  id: totrans-302
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: In this instance, the architecture is `arm`, the operating system is `linux`,
    and the image type is `kernel`. Additionally, the compression scheme is `gzip`,
    the load address is `0x80008000`, and the entry point is the same as the load
    address. Lastly, the image name is `Linux`, the image datafile is named `zImage`,
    and the image being generated is named `uImage`.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，架构是 `arm`，操作系统是 `linux`，镜像类型是 `kernel`。此外，压缩方案是 `gzip`，加载地址是 `0x80008000`，入口点与加载地址相同。最后，镜像名称是
    `Linux`，镜像数据文件名为 `zImage`，正在生成的镜像名为 `uImage`。
- en: Loading images
  id: totrans-304
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 加载镜像
- en: 'Usually, you load images from removable storage such as an SD card or over
    a network. SD cards are handled in U-Boot by the MMC driver. Here is an example
    of loading a file from a microSD card into memory:'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，你从可移动存储设备（如 SD 卡）或通过网络加载镜像。SD 卡在 U-Boot 中由 MMC 驱动程序处理。以下是从 microSD 卡加载文件到内存的示例：
- en: '[PRE47]'
  id: totrans-306
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'The `mmc rescan` command re-initializes the MMC driver, perhaps to detect that
    an SD card has recently been inserted. Next, `fatload` is used to read a file
    from a FAT-formatted partition on the SD card. Note that `tiboot3.bin` is the
    firmware image for the R5, not a Linux kernel image, so it cannot be executed
    at this point in the boot sequence. The format for the `fatload` command is as
    follows:'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: '`mmc rescan` 命令会重新初始化 MMC 驱动程序，可能是为了检测最近插入的 SD 卡。接下来，使用 `fatload` 从 SD 卡的 FAT
    格式分区读取文件。请注意，`tiboot3.bin` 是 R5 的固件镜像，而不是 Linux 内核镜像，因此在此启动序列阶段无法执行它。`fatload`
    命令的格式如下：'
- en: '[PRE48]'
  id: totrans-308
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: If `<interface>` is `mmc`, as in our case, then `<dev:part>` is the device number
    of the MMC interface counting from zero and the partition number counting from
    one. Hence, `<1:1>` is the first partition on the second device, which is `mmc
    1` for the microSD card on BeaglePlay (the onboard eMMC is `mmc 0`). The chosen
    memory location of `0x80000000` is in an area of RAM that is not being used at
    this moment.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 `<interface>` 是 `mmc`，如我们的例子，那么 `<dev:part>` 是从零开始计数的 MMC 接口设备号和从一开始计数的分区号。因此，`<1:1>`
    是第二个设备的第一个分区，对于 BeaglePlay 来说，`mmc 1` 是 microSD 卡（板载 eMMC 是 `mmc 0`）。选择的内存位置 `0x80000000`
    位于当前未使用的 RAM 区域。
- en: To load kernel image files over a network, you must use the **Trivial File Transfer
    Protocol** (**TFTP**). This requires you to install `tftpd` (a TFTP daemon) on
    your development system and start running it. You must also configure any firewalls
    between your PC and the target board to allow the TFTP protocol on UDP port `69`
    to pass through.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 要通过网络加载内核镜像文件，必须使用**简单文件传输协议**（**TFTP**）。这需要你在开发系统上安装`tftpd`（TFTP守护进程）并启动它。你还需要配置PC与目标开发板之间的任何防火墙，允许TFTP协议通过UDP端口`69`。
- en: 'The default configuration of TFTP only allows access to the `/var/lib/tftpboot`
    directory. The next step is to copy the files you want to transfer to the target
    into that directory. Then, assuming that you are using a pair of static IP addresses,
    which removes the need for further network administration, the sequence of commands
    to load a kernel image file looks like this:'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: TFTP的默认配置只允许访问`/var/lib/tftpboot`目录。接下来的步骤是将你要传输到目标的文件复制到该目录中。然后，假设你使用了一对静态IP地址，这样就不需要进一步的网络管理，加载内核镜像文件的命令序列如下所示：
- en: '[PRE49]'
  id: totrans-312
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Finally, let’s look at how to program images into NAND flash memory and read
    them back. This is handled by the `nand` command. This example loads a kernel
    image via TFTP and programs it into flash:'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，让我们看看如何将镜像写入NAND闪存并读取它们。这是通过`nand`命令来处理的。以下示例通过TFTP加载内核镜像并将其写入闪存：
- en: '[PRE50]'
  id: totrans-314
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'Now, you can load the kernel from flash memory using the `nand read` command:'
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你可以使用`nand read`命令从闪存加载内核：
- en: '[PRE51]'
  id: totrans-316
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: Once the kernel has been loaded into RAM, we can boot it.
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦内核加载到RAM中，我们就可以启动它。
- en: Booting Linux
  id: totrans-318
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 启动Linux
- en: 'The `bootm` command starts a kernel image running. The syntax is as follows:'
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: '`bootm`命令启动内核镜像。其语法如下：'
- en: '[PRE52]'
  id: totrans-320
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'The address of the kernel image is necessary, but the addresses of the `ramdisk`
    and `dtb` can be omitted if the kernel configuration does not need them. If there
    is a `dtb` but no `initramfs`, then the second address can be replaced with a
    dash. That would look like this:'
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 内核镜像的地址是必要的，但如果内核配置不需要`ramdisk`和`dtb`，则可以省略它们的地址。如果有`dtb`但没有`initramfs`，则第二个地址可以用破折号代替。示例如下：
- en: '[PRE53]'
  id: totrans-322
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: Typing a long series of commands to boot your board each time it is powered
    up is clearly not acceptable. Let’s look at how to automate the boot process.
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 每次开机时输入一长串命令来启动开发板显然是不可接受的。让我们来看看如何自动化启动过程。
- en: Automating the boot with U-Boot scripts
  id: totrans-324
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用U-Boot脚本自动化启动
- en: U-Boot stores a sequence of commands in environment variables. If a special
    variable named `bootcmd` contains a script, then it is run at power-up after a
    delay of `bootdelay` seconds. If you watch this on the serial console, you will
    see the delay counting down to zero. You can press any key during this period
    to terminate the countdown and enter an interactive session with U-Boot.
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: U-Boot将一系列命令存储在环境变量中。如果名为`bootcmd`的特殊变量包含脚本，那么它将在开机后经过`bootdelay`秒的延迟后运行。如果你在串口控制台上观察，你会看到延迟倒计时到零。你可以在此期间按下任意键来终止倒计时，并进入U-Boot的交互式会话。
- en: 'The way that you create scripts is simple, though it’s not easy to read. You
    simply append commands separated by semicolons, which must be preceded by a *\*
    escape character. For example, to load a kernel image from an offset in flash
    memory and boot it, you might use the following command:'
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 创建脚本的方式很简单，尽管不易阅读。你只需要将命令通过分号连接，每个命令前都必须加上一个*\\*转义字符。例如，要从闪存中的某个偏移位置加载内核镜像并启动，你可以使用如下命令：
- en: '[PRE54]'
  id: totrans-327
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: We now know how to boot a kernel on BeaglePlay using U-Boot. But how do we port
    U-Boot to a new board that has no BSP? We’ll cover that in the remainder of this
    chapter.
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们知道如何在BeaglePlay上使用U-Boot启动内核。那么如何将U-Boot移植到一个没有BSP的新开发板上呢？我们将在本章剩余部分讨论这个问题。
- en: Porting U-Boot to a new board
  id: totrans-329
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将U-Boot移植到新开发板
- en: Let’s assume that your hardware department has created a new board called **Nova**
    that is based on BeaglePlay and that you need to port U-Boot to it. You will need
    to understand the layout of the U-Boot code and how the board configuration mechanism
    works. In this section, I will show you how to create a variant of an existing
    board – BeaglePlay – which you could go on to use as the basis for further customizations.
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你的硬件部门已经创建了一个名为**Nova**的新开发板，该板基于BeaglePlay，并且你需要将U-Boot移植到该板上。你需要了解U-Boot代码的布局以及板卡配置机制的工作原理。在本节中，我将向你展示如何创建一个现有开发板的变体——BeaglePlay——并将其作为进一步定制的基础。
- en: 'There are quite a few files that need to be changed. I have put them together
    into a patch file at `MELD/Chapter03/0001-BSP-for-Nova.patch` in the book’s code
    repo. You can simply apply that patch to a clean copy of the U-Boot fork for BeaglePlay
    and rebuild it like this:'
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 有相当多的文件需要修改。我已经将它们汇总成一个补丁文件，存放在书本代码库中的 `MELD/Chapter03/0001-BSP-for-Nova.patch`。你只需将该补丁应用到
    BeaglePlay 的干净 U-Boot 分支副本上，并像下面这样重新构建：
- en: '[PRE55]'
  id: totrans-332
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'If you want to use a different version of U-Boot, you will have to regenerate
    the patch yourself for it to apply cleanly. The remainder of this section describes
    how the patch was created. To skip these details, run the preceding commands and
    jump to the end of the *Building and testing* portion of this section. To follow
    along step by step, you will need a clean copy of the U-Boot fork for BeaglePlay
    without the Nova BSP patch applied. The main directories we will be dealing with
    are as follows:'
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想使用不同版本的 U-Boot，你需要自己重新生成补丁，以确保它能够顺利应用。本节的其余部分描述了补丁是如何创建的。如果你想跳过这些细节，可以直接运行前面的命令，然后跳到本节
    *构建与测试* 部分的结尾。若想按步骤跟着做，你需要一个没有应用 Nova BSP 补丁的干净 U-Boot 分支副本。我们将要处理的主要目录如下：
- en: '`arch`: Contains code that’s specific to each supported architecture in the
    `arm`, `mips`, and `powerpc` directories. Within each architecture, there is a
    subdirectory for each member of the family. For example, in `arch/arm/cpu` there
    are directories for the various architecture variants, including `arm926ejs`,
    `armv7`, and `armv8`.'
  id: totrans-334
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`arch`：包含特定于每个支持的架构的代码，这些代码位于 `arm`、`mips` 和 `powerpc` 目录中。在每个架构下，都有一个子目录对应架构家族中的每个成员。例如，在
    `arch/arm/cpu` 中，有多个架构变体的目录，包括 `arm926ejs`、`armv7` 和 `armv8`。'
- en: '`board`: Contains code that’s specific to a board. Where there are several
    boards from the same vendor, they are collected into a subdirectory. Hence, the
    code for the `am62x` EVM board, which BeaglePlay is based on, is in `board/ti/am62x`.'
  id: totrans-335
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`board`：包含特定于某个开发板的代码。如果有多个来自同一厂商的开发板，它们会被收集到一个子目录中。因此，基于 BeaglePlay 的 `am62x`
    EVM 开发板的代码位于 `board/ti/am62x`。'
- en: '`common`: Contains core functions including the command shells and the commands
    that can be called from them each in a file named `cmd_<command name>.c`.'
  id: totrans-336
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`common`：包含核心功能，包括命令外壳以及可以从中调用的每个命令，每个命令都在一个名为 `cmd_<command name>.c` 的文件中。'
- en: '`doc`: Contains several `.rst` files describing various aspects of U-Boot.
    If you are wondering how to proceed with your U-Boot port, this is a good place
    to start.'
  id: totrans-337
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`doc`：包含多个 `.rst` 文件，描述了 U-Boot 的各个方面。如果你不知道如何继续进行 U-Boot 移植，这是一个很好的起点。'
- en: '`include`: In addition to many shared header files, this contains the important
    `include/configs` subdirectory, where you will find the majority of the board
    configuration settings.'
  id: totrans-338
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`include`：除了许多共享的头文件外，还包含一个重要的 `include/configs` 子目录，在这里你会找到大多数开发板的配置设置。'
- en: 'The way that `Kconfig` extracts configuration information from `Kconfig` files
    and stores the total system configuration in a file named `.config` will be described
    in some detail in [*Chapter 4*](Chapter_04.xhtml#_idTextAnchor096). Each board
    has a default configuration stored in `configs/<board name>_defconfig`. For the
    Nova board, we can begin by making a copy of the configuration for the EVM:'
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: '`Kconfig` 如何从 `Kconfig` 文件中提取配置信息，并将整个系统配置存储在一个名为 `.config` 的文件中，将在 [*第4章*](Chapter_04.xhtml#_idTextAnchor096)
    中详细描述。每个开发板都有一个默认的配置，存储在 `configs/<board name>_defconfig` 中。对于 Nova 开发板，我们可以从
    EVM 的配置开始进行复制：'
- en: '[PRE56]'
  id: totrans-340
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'Now, edit `configs/nova_defconfig` and replace `CONFIG_TARGET_AM625_A53_EVM=y`
    with `CONFIG_TARGET_NOVA=y` as shown here:'
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，编辑 `configs/nova_defconfig`，将 `CONFIG_TARGET_AM625_A53_EVM=y` 替换为 `CONFIG_TARGET_NOVA=y`，如下面所示：
- en: '[PRE57]'
  id: totrans-342
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: Note that `CONFIG_ARM=y` causes the contents of `arch/arm/Kconfig` to be included.
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，`CONFIG_ARM=y` 会导致包含 `arch/arm/Kconfig` 的内容。
- en: We are now done modifying `configs/nova_defconfig`.
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在完成了对 `configs/nova_defconfig` 的修改。
- en: Board-specific files
  id: totrans-345
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 开发板特定文件
- en: 'Each board has a subdirectory named `board/<board name>` or `board/<vendor>/<board
    name>` that should contain the following:'
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 每个开发板都有一个名为 `board/<board name>` 或 `board/<vendor>/<board name>` 的子目录，应该包含以下内容：
- en: '`Kconfig`: Contains the configuration options for the board.'
  id: totrans-347
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Kconfig`：包含开发板的配置选项。'
- en: '`MAINTAINERS`: Contains a record of whether the board is currently maintained
    and, if so, by whom.'
  id: totrans-348
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`MAINTAINERS`：记录开发板是否目前正在维护，以及由谁维护。'
- en: '`Makefile`: Used to build the board-specific code.'
  id: totrans-349
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Makefile`：用于构建特定于开发板的代码。'
- en: In addition, there may be source files for board-specific functions.
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，可能还会有一些用于开发板特定功能的源文件。
- en: 'Our Nova board is based on BeaglePlay, which in turn is based on a TI `am62x`
    EVM. So, we should make copies of the `am62x` board files:'
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的 Nova 开发板基于 BeaglePlay，而 BeaglePlay 又基于 TI 的 `am62x` EVM。因此，我们应该复制 `am62x`
    开发板的文件：
- en: '[PRE58]'
  id: totrans-352
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'First, modify `board/ti/nova/Makefile` so that `nova.c` is compiled instead
    of `evm.c`:'
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，修改 `board/ti/nova/Makefile`，使得编译的是 `nova.c` 而不是 `evm.c`：
- en: '[PRE59]'
  id: totrans-354
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: Duplicating `evm.c` as `nova.c` lets you change how U-Boot interacts with your
    custom board.
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 将 `evm.c` 复制为 `nova.c` 让你可以改变 U-Boot 如何与自定义开发板交互。
- en: 'Next, edit `board/ti/nova/Kconfig`:'
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，编辑 `board/ti/nova/Kconfig`：
- en: Change the `"TI K3 AM62x based boards"` string under `prompt` to say `"TI K3
    AM62x based Nova! board"`.
  id: totrans-357
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将 `prompt` 下的 `"TI K3 AM62x based boards"` 字符串更改为 `"TI K3 AM62x based Nova!
    board"`。
- en: Rename `TARGET_AM625_A53_EVM` to `TARGET_NOVA`.
  id: totrans-358
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将 `TARGET_AM625_A53_EVM` 重命名为 `TARGET_NOVA`。
- en: Delete `TARGET_AM625_R5_EVM` along with all its items.
  id: totrans-359
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 删除 `TARGET_AM625_R5_EVM` 及其所有项。
- en: Set `SYS_BOARD` to `"nova"` so that it will build the files in `board/ti/nova`.
  id: totrans-360
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将 `SYS_BOARD` 设置为 `"nova"`，这样它就会构建 `board/ti/nova` 中的文件。
- en: Set `SYS_CONFIG_NAME` to `"nova"` so that it will use `include/configs/nova.h`
    as the configuration file.
  id: totrans-361
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将 `SYS_CONFIG_NAME` 设置为 `"nova"`，以便它使用 `include/configs/nova.h` 作为配置文件。
- en: 'The modified `board/ti/nova/Konfig` should look as follows:'
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: 修改后的 `board/ti/nova/Konfig` 应该如下所示：
- en: '[PRE60]'
  id: totrans-363
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'Now we need to link the `Kconfig` file for Nova into the chain of `Kconfig`
    files. First, edit `arch/arm/Kconfig` and insert `source "board/ti/nova/Kconfig"`
    after `source "board/tcl/sl50/Kconfig"`, as shown here:'
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们需要将 Nova 的 `Kconfig` 文件链接到 `Kconfig` 文件链中。首先，编辑 `arch/arm/Kconfig`，并在 `source
    "board/tcl/sl50/Kconfig"` 后插入 `source "board/ti/nova/Kconfig"`，如下所示：
- en: '[PRE61]'
  id: totrans-365
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: Now that we have copied and modified the board-specific files for our Nova board,
    let’s move on to the header files.
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经复制并修改了 Nova 开发板的特定文件，接下来处理头文件。
- en: Configuring header files
  id: totrans-367
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 配置头文件
- en: 'Each board has a header file in `include/configs` that contains most of the
    configuration information. The file is named by the `SYS_CONFIG_NAME` identifier
    in the board’s `Kconfig` file. The format of this file is described in detail
    in the `README` file at the top level of the U-Boot source tree. For the purposes
    of our Nova board, simply copy `include/configs/am62x_evm.h` into `include/configs/nova.h`
    and make a few changes, as shown here:'
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: 每个开发板在 `include/configs` 中都有一个头文件，包含了大部分的配置资料。该文件的名称由开发板的 `Kconfig` 文件中的 `SYS_CONFIG_NAME`
    标识符决定。该文件的格式在 U-Boot 源码树顶层的 `README` 文件中有详细描述。对于我们的 Nova 开发板，只需将 `include/configs/am62x_evm.h`
    复制到 `include/configs/nova.h` 并做一些修改，如下所示：
- en: '[PRE62]'
  id: totrans-369
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: First, replace `__CONFIG_AM625_EVM_H` with `__CONFIG_NOVA_H`. Next, redefine
    `CONFIG_SYS_PROMPT` so that we can identify this bootloader at runtime. Lastly,
    replace `CONFIG_TARGET_AM625_A53_EVM` with `CONFIG_TARGET_NOVA` so that `CONFIG_SPL_MAX_SIZE`
    and `CONFIG_SYS_INIT_SP_ADDR` are defined correctly.
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，将 `__CONFIG_AM625_EVM_H` 替换为 `__CONFIG_NOVA_H`。接下来，重新定义 `CONFIG_SYS_PROMPT`，以便我们能够在运行时识别该引导加载程序。最后，将
    `CONFIG_TARGET_AM625_A53_EVM` 替换为 `CONFIG_TARGET_NOVA`，确保 `CONFIG_SPL_MAX_SIZE`
    和 `CONFIG_SYS_INIT_SP_ADDR` 被正确地定义。
- en: With the source tree fully modified, we are now ready to build U-Boot for our
    custom board.
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: 在源树完全修改后，我们现在准备为自定义开发板构建 U-Boot。
- en: Building and testing
  id: totrans-372
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 构建和测试
- en: 'To build U-Boot for the Nova board:'
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: 为了为 Nova 开发板构建 U-Boot：
- en: 'First, navigate back to the U-Boot source tree for BeaglePlay:'
  id: totrans-374
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，返回到 BeaglePlay 的 U-Boot 源代码树：
- en: '[PRE63]'
  id: totrans-375
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'Next, set the `ARCH` and `CROSS_COMPILE` environment variables for 64-bit Arm:'
  id: totrans-376
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，为 64 位 Arm 设置 `ARCH` 和 `CROSS_COMPILE` 环境变量：
- en: '[PRE64]'
  id: totrans-377
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'Clean out any previous build artifacts:'
  id: totrans-378
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 清除任何先前的构建产物：
- en: '[PRE65]'
  id: totrans-379
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'Select `nova_defconfig` for building:'
  id: totrans-380
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择 `nova_defconfig` 来进行构建：
- en: '[PRE66]'
  id: totrans-381
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'Run `make menuconfig` to configure U-Boot further for building:'
  id: totrans-382
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行 `make menuconfig` 来进一步配置 U-Boot，以便进行构建：
- en: '[PRE67]'
  id: totrans-383
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE67]'
- en: Drill down into the **Environment** submenu.
  id: totrans-384
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 进入 **Environment** 子菜单。
- en: Select **Environment is in a EXT4 filesystem**.
  id: totrans-385
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择 **环境位于 EXT4 文件系统中**。
- en: Deselect any other options (e.g., MMC, NAND, and SPI) for environment storage
    on that menu page.
  id: totrans-386
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在该菜单页中，取消选择任何其他环境存储选项（例如，MMC、NAND 和 SPI）。
- en: Enter `mmc` in the **Name of the block device for the environment** text field.
  id: totrans-387
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 **环境的块设备名称** 文本框中输入 `mmc`。
- en: Enter `1:2` in the **Device and partition for where to store the environment
    in EXT4** text field.
  id: totrans-388
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 **存储环境的 EXT4 设备和分区** 文本框中输入 `1:2`。
- en: Ensure `/uboot.env` is entered in the **Name of the EXT4 file to use for the
    environment** text field.
  id: totrans-389
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确保在 **要用于环境的 EXT4 文件的名称** 文本框中输入 `/uboot.env`。
- en: Back out of the **Environment** submenu.
  id: totrans-390
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 退出 **Environment** 子菜单。
- en: Drill down into the **SPL/TPL** submenu.
  id: totrans-391
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 进入 **SPL/TPL** 子菜单。
- en: Select **Support EXT filesystems**.
  id: totrans-392
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择 **支持 EXT 文件系统**。
- en: Back out of the **SPL/TPL** submenu.
  id: totrans-393
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 退出 **SPL/TPL** 子菜单。
- en: Drill down into the **Boot Options** submenu.
  id: totrans-394
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 进入 **启动选项** 子菜单。
- en: Select **Enable a default value for bootcmd**.
  id: totrans-395
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择**启用 bootcmd 的默认值**。
- en: Enter `echo 'no bootcmd yet'` in the **bootcmd value** text field.
  id: totrans-396
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 **bootcmd 值**文本字段中输入 `echo 'no bootcmd yet'`。
- en: Exit out of `menuconfig` and choose **Yes** when asked to save your new configuration.
  id: totrans-397
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 退出 `menuconfig`，并在被问及是否保存新配置时选择**是**。
- en: 'Save the modified `defconfig`:'
  id: totrans-398
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存修改后的 `defconfig`：
- en: '[PRE68]'
  id: totrans-399
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'Update `nova_defconfig` with your changes:'
  id: totrans-400
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用你的更改更新 `nova_defconfig`：
- en: '[PRE69]'
  id: totrans-401
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'Lastly, build U-Boot for the A53, passing paths to TI’s TF-A and DM firmware
    as arguments to `make`:'
  id: totrans-402
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，为 A53 构建 U-Boot，并将 TI 的 TF-A 和 DM 固件路径作为参数传递给 `make`：
- en: '[PRE70]'
  id: totrans-403
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'Copy `tispl.bin` and `u-boot.img` to the `boot` partition of the microSD card
    you created earlier:'
  id: totrans-404
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 `tispl.bin` 和 `u-boot.img` 复制到你之前创建的 microSD 卡的 `boot` 分区：
- en: '[PRE71]'
  id: totrans-405
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'Reinsert the microSD card into BeaglePlay and reapply power while holding down
    the USR button. You should see output like this (note the custom command prompt)
    on the serial console:'
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
  zh: 将 microSD 卡重新插入 BeaglePlay，并在按住 USR 按钮的同时重新供电。你应该在串口控制台看到类似这样的输出（注意自定义命令提示符）：
- en: '[PRE72]'
  id: totrans-407
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 'You can create a patch for all these changes by checking them into Git and
    using the `git format-patch` command:'
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过将这些更改提交到 Git 并使用 `git format-patch` 命令来创建一个补丁：
- en: '[PRE73]'
  id: totrans-409
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: Generating this patch concludes our coverage of U-Boot as a TPL. U-Boot can
    also be configured to bypass the TPL stage of the boot process altogether. Next,
    let’s examine this alternate approach to booting Linux.
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
  zh: 生成这个补丁完成了我们对 U-Boot 作为 TPL 的覆盖。U-Boot 也可以配置为完全跳过启动过程中的 TPL 阶段。接下来，让我们看看这种替代的
    Linux 启动方式。
- en: Falcon mode
  id: totrans-411
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Falcon 模式
- en: We are used to the idea that booting a modern embedded processor involves the
    boot ROM loading an SPL, which loads `u-boot.bin`, which then loads a Linux kernel.
    You may be wondering if there is a way to reduce the number of steps, thereby
    simplifying and speeding up the boot process. The answer is U-Boot Falcon mode.
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经习惯了现代嵌入式处理器启动的概念，即启动 ROM 加载 SPL，接着加载 `u-boot.bin`，然后再加载 Linux 内核。你可能在想，是否有办法减少步骤，从而简化并加速启动过程。答案是
    U-Boot 的 Falcon 模式。
- en: 'The idea is simple: have the SPL load a kernel image directly skipping over
    `u-boot.bin`. There is no user interaction and there are no scripts. It just loads
    a kernel from a known location in flash memory or eMMC into memory, passes it
    a pre-prepared parameter block, and starts running it. The details of configuring
    Falcon mode are beyond the scope of this book.'
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
  zh: 这个想法很简单：让 SPL 直接加载内核镜像，跳过 `u-boot.bin`。没有用户交互，也没有脚本。它只是从闪存或 eMMC 中的已知位置加载内核到内存，传递一个预先准备好的参数块，并开始运行。配置
    Falcon 模式的细节超出了本书的范围。
- en: '**IMPORTANT NOTE**'
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
  zh: '**重要提示**'
- en: Falcon mode is named after the peregrine falcon, which is the fastest bird of
    all, capable of reaching speeds of more than 200 miles per hour in a dive.
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
  zh: Falcon 模式的名称来源于游隼，它是所有鸟类中最快的，能够在俯冲时达到每小时超过 200 英里的速度。
- en: Summary
  id: totrans-416
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: Every system needs a bootloader to bring the hardware to life and to load a
    kernel. U-Boot has found favor with many developers because it supports a useful
    range of hardware, and it is fairly easy to port to a new device.
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
  zh: 每个系统都需要一个引导加载程序来激活硬件并加载内核。U-Boot 受到了许多开发者的青睐，因为它支持多种有用的硬件，并且相对容易移植到新设备。
- en: In this chapter, we learned how to inspect and drive U-Boot interactively from
    the command line over a serial console. These command-line exercises included
    loading a kernel over a network using TFTP for rapid iteration. Lastly, we learned
    how to port U-Boot to a new device by generating a patch for our Nova board.
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一章节中，我们学习了如何通过串口控制台从命令行交互式地检查和驱动 U-Boot。这些命令行练习包括使用 TFTP 通过网络加载内核，以便进行快速迭代。最后，我们学习了如何通过为我们的
    Nova 板生成补丁，将 U-Boot 移植到新设备上。
- en: Over the last few years, the complexity and ever-increasing variety of embedded
    hardware has led to the introduction of the device tree as a way of describing
    hardware. The device tree is simply a textual representation of a system that
    is compiled into a device tree binary, which is passed to the kernel when it loads.
    It is up to the kernel to interpret the device tree and to load and initialize
    drivers for the devices it finds there.
  id: totrans-419
  prefs: []
  type: TYPE_NORMAL
  zh: 近年来，嵌入式硬件的复杂性和种类不断增加，这导致了设备树的引入，作为描述硬件的一种方式。设备树仅仅是系统的文本表示，经过编译成设备树二进制文件，并在内核加载时传递给内核。由内核来解释设备树，并加载和初始化它在设备树中找到的设备驱动程序。
- en: U-Boot is very flexible, allowing images to be loaded from mass storage, flash
    memory, or a network and then booted. Having covered some of the intricacies of
    booting Linux, in the next chapter, we will cover the next stage of the process.
    This is the third element of your embedded project – the kernel.
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
  zh: U-Boot 非常灵活，可以从大容量存储、闪存或网络加载映像并进行引导。经过了 Linux 引导过程的一些复杂细节后，在下一章，我们将讨论该过程的下一阶段。这是你嵌入式项目的第三个元素——内核。
