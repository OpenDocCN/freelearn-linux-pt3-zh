- en: '*Chapter 8*: Using the Command Line to Find, Extract, and Manipulate Text Content'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第 8 章*：使用命令行查找、提取和操作文本内容'
- en: Manipulating text is an everyday job for a full-time system administrator. It
    can happen for a variety of reasons – for example, you could just be trying to
    find a service option that you saw somewhere in some configuration file, without
    remembering what the name of the configuration file is. You know, those moments
    on Monday morning when you haven't had two cups of your favorite pick-me-up drink
    and your CPU hasn't booted properly yet? Or, maybe, when you're working with a
    text file that has a lot of content, but needs specific changes to be made, such
    as changing some configuration options from off to on, true to false, 0 to 1,
    and so on. This chapter is going to act as a prequel to one of the later chapters
    discussing shell scripting examples.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 操作文本是全职系统管理员的日常工作。这可能出于多种原因——例如，你可能只是想找到你在某个配置文件中看到的某个服务选项，却记不起该配置文件的名字。你知道吗，那种星期一早晨，你还没喝上两杯提神饮料，CPU
    还没正确启动的时候？或者，也许当你在处理一个包含大量内容的文本文件时，但需要做一些特定的修改，比如将一些配置选项从关闭改为打开、从真改为假、从 0 改为 1
    等等。本章将作为后续章节讨论 Shell 脚本示例的前奏。
- en: 'In this chapter, we are going to learn about the following:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将学习以下内容：
- en: Using text commands to merge file content
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用文本命令合并文件内容
- en: Converting DOS text to Linux text and vice versa
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将 DOS 文本转换为 Linux 文本，反之亦然
- en: Using `cut`
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `cut`
- en: Using `egrep`
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `egrep`
- en: Using `sed`
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `sed`
- en: Technical requirements
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: For these recipes, we're going to use one Linux machine – we can use `client1`
    from our previous recipes. It doesn't really matter which virtual machine gets
    used as all the commands that we are going to discuss in these recipes work the
    same way on all Linux distributions.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这些操作，我们将使用一台 Linux 机器——我们可以使用之前食谱中的 `client1`。实际上，使用哪台虚拟机并不重要，因为我们在这些食谱中讨论的所有命令在所有
    Linux 发行版上都以相同的方式工作。
- en: Using text commands to merge file content
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用文本命令合并文件内容
- en: Let's start with something simple – which is merging file content. Of course,
    we are only discussing text content here as merging binary files would be pointless.
    Our goal is to learn how to use two commands – `paste` and `cat` – to do simple
    things, such as concatenation and merging line by line. Let's start!
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 我们先从简单的开始——即合并文件内容。当然，这里我们只讨论文本内容，因为合并二进制文件是没有意义的。我们的目标是学习如何使用两个命令——`paste`
    和 `cat`——来做一些简单的事情，比如拼接和逐行合并。让我们开始吧！
- en: Getting ready
  id: totrans-12
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: We just need one Ubuntu and one CentOS machine for this recipe. Here, we are
    going to use `cli1` and `cli2` to master these commands.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 我们只需要一台 Ubuntu 和一台 CentOS 机器来完成这个操作。在这里，我们将使用 `cli1` 和 `cli2` 来掌握这些命令。
- en: How to do it…
  id: totrans-14
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作…
- en: 'Starting with the simplest command for this chapter – `cat` – let''s see some
    examples of what it does. If we type in a command such as `cat filename.txt` –
    if a file named `filename.txt` exists – we are going to get the content of that
    file on display. Let''s check an example of this:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 从本章最简单的命令开始——`cat`——我们来看一些它的使用示例。如果我们输入类似 `cat filename.txt` 这样的命令——前提是存在名为
    `filename.txt` 的文件——我们将看到该文件的内容。我们来看看这个例子：
- en: '![Figure 8.1 – Using the cat command on a text file'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 8.1 – 在文本文件上使用 `cat` 命令'
- en: '](img/Figure_8.1_B16269.jpg)'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_8.1_B16269.jpg)'
- en: Figure 8.1 – Using the cat command on a text file
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.1 – 在文本文件上使用 `cat` 命令
- en: 'So, we used the `cat` command to show the content of an `auth.log` file located
    in the `/var/log` directory. If we have been using this machine for a while, there
    will be other files with `auth.log` as a prefix, then a number, and the `gz` extension.
    Let''s check:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们使用 `cat` 命令显示位于 `/var/log` 目录下的 `auth.log` 文件的内容。如果我们已经使用这台机器一段时间，可能会有其他以
    `auth.log` 为前缀、后跟一个数字和 `gz` 扩展名的文件。我们来检查一下：
- en: '![Figure 8.2 – Finding content that we are going to use'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 8.2 – 查找我们将要使用的内容'
- en: '](img/Figure_8.2_B16269.jpg)'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_8.2_B16269.jpg)'
- en: Figure 8.2 – Finding content that we are going to use
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.2 – 查找我们将要使用的内容
- en: 'So, for the purpose of this recipe, let''s use the `auth.log` and `auth.log.1`
    files. What happens if we want to have one file that contains both `auth.log`
    and `auth.log.1` content? We''d either open a text editor and do a bit of copy-pasting,
    or we can use `cat` to do that for us. The `cat` command can be used with multiple
    files at the same time, such as `cat auth.log auth.log.1`, which would show us
    the content of the first file followed by the content of the second file. The
    only thing that we need to do is to redirect the text output from that command
    to a new file, which we can easily do by using the `>` sign. Let''s say that we
    want to save the output of this command to a file in the `/root` directory called
    `auth-full.log`. Here''s how we''d do that:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，为了这个教程的目的，我们使用`auth.log`和`auth.log.1`文件。如果我们想要一个文件同时包含`auth.log`和`auth.log.1`的内容，会发生什么呢？我们可以打开文本编辑器进行复制粘贴，或者使用`cat`命令来完成。`cat`命令可以同时处理多个文件，比如`cat
    auth.log auth.log.1`，这会显示第一个文件的内容，然后是第二个文件的内容。我们需要做的唯一事情是将该命令的文本输出重定向到一个新文件，这可以通过使用`>`符号轻松实现。假设我们想将命令的输出保存到`/root`目录下的`auth-full.log`文件中，下面是实现的方法：
- en: '![Figure 8.3 – Using the cat command to concatenate files'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 8.3 – 使用cat命令连接文件'
- en: '](img/Figure_8.3_B16269.jpg)'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_8.3_B16269.jpg)'
- en: Figure 8.3 – Using the cat command to concatenate files
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.3 – 使用cat命令连接文件
- en: '`cat` actually displays text files line by line, which is a property that we
    will heavily use in our chapters relating to shell script examples.'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: '`cat`实际上是逐行显示文本文件，这是我们将在与Shell脚本示例相关的章节中大量使用的一个特性。'
- en: 'If for some reason we wanted to merge files line by line, we could''ve used
    the `paste` command. Let''s see how that would work. Seeing that these files are
    just way too big, we are going to create two files. Let''s say that the first
    file (named `first.txt`) will have the following content:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 如果由于某种原因我们想逐行合并文件，可以使用`paste`命令。让我们来看一下它是如何工作的。由于这些文件太大，我们将创建两个文件。假设第一个文件（命名为`first.txt`）包含以下内容：
- en: '[PRE0]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The second file (named `second.txt`) will have this content:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个文件（命名为`second.txt`）将包含以下内容：
- en: '[PRE1]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Now, let''s use the `paste` command and check the result:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们使用`paste`命令并查看结果：
- en: '![Figure 8.4 – Using the paste command to combine text files line by line'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 8.4 – 使用paste命令逐行合并文本文件'
- en: '](img/Figure_8.4_B16269.jpg)'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_8.4_B16269.jpg)'
- en: Figure 8.4 – Using the paste command to combine text files line by line
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.4 – 使用paste命令逐行合并文本文件
- en: As we can see, the `paste` command combines two files line by line, by putting
    them one next to the other.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所看到的，`paste`命令通过将两个文件并排放置来逐行合并它们。
- en: How it works…
  id: totrans-37
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的……
- en: 'These two commands are rather simple in operation:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个命令的操作非常简单：
- en: By default, `cat` displays the complete content of a file or set of files, line
    by line.
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 默认情况下，`cat`会逐行显示文件或多个文件的完整内容。
- en: By default, `paste` combines files line by line, side by side.
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 默认情况下，`paste`命令是逐行并排合并文件的。
- en: These are two very different approaches to text manipulation, both with real-life
    use cases.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 这两种方法在文本处理上完全不同，但都具有实际应用场景。
- en: Our next recipe is a simple one as well – how to deal with a situation when
    we transfer text files from Microsoft OSs to Linux in terms of making them usable
    in Linux. As we are going to see, there are some fundamental differences with
    `.txt` formats between Microsoft OSs and Linux, which makes the next recipe a
    necessity. Stay tuned for it!
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的下一个教程也很简单——当我们将文本文件从Microsoft操作系统转移到Linux时，如何处理使它们在Linux中可用。正如我们将看到的，Microsoft操作系统和Linux之间在`.txt`格式上存在一些根本性的差异，这使得下一个教程成为必需。敬请期待！
- en: There's more…
  id: totrans-43
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多……
- en: 'If you need more information about using `cat` or `paste`, make sure that you
    check out the following:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你需要更多关于使用`cat`或`paste`的信息，确保查看以下内容：
- en: 'Basic `cat` command examples in Linux: [https://www.tecmint.com/13-basic-cat-command-examples-in-linux/](https://www.tecmint.com/13-basic-cat-command-examples-in-linux/%0D)'
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Linux中的基本`cat`命令示例：[https://www.tecmint.com/13-basic-cat-command-examples-in-linux/](https://www.tecmint.com/13-basic-cat-command-examples-in-linux/%0D)
- en: 'The `paste` command in Linux (merge lines): [https://linuxize.com/post/paste-command-in-linux/](https://linuxize.com/post/paste-command-in-linux/%0D)'
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Linux中的`paste`命令（合并行）：[https://linuxize.com/post/paste-command-in-linux/](https://linuxize.com/post/paste-command-in-linux/%0D)
- en: Converting DOS text to Linux text and vice versa
  id: totrans-47
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将DOS文本转换为Linux文本，反之亦然
- en: This is a strange idea – you might have thought a `.txt` file is a `.txt` file,
    right? Wrong.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 这个想法很奇怪——你可能会认为`.txt`文件就是`.txt`文件，对吗？错了。
- en: There are subtle differences between `.txt` file formats in DOS/Windows and
    Linux. Sometimes, those differences can make you mad in a matter of seconds. We've
    had our fair share of experiences of that – scripts not working as input files
    were prepared on Windows, not on Linux; different treatment of CSV files in Excel
    *by design*... sometimes it's just too funny when, after hours of deliberation,
    you realize that something as simple as a `.txt` file created on another OS can
    make such a mess. Let's explain what the problem is and work through it.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: DOS/Windows 和 Linux 中的 `.txt` 文件格式之间有细微的差异。有时，这些差异可能让你在几秒钟内抓狂。我们也有过类似的经历——脚本不能正常工作，因为输入文件是在
    Windows 而不是 Linux 上准备的；Excel 中的 CSV 文件 *按设计* 被不同地处理…有时候，经过几个小时的思考，当你意识到像在另一个操作系统上创建的
    `.txt` 文件这样的简单问题造成了这么大的混乱时，真是太好笑了。让我们解释一下问题是什么，并一起来解决它。
- en: Getting ready
  id: totrans-50
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'We just need one Ubuntu machine for this recipe. Let''s say we are going to
    continue using `cli1` to master these commands. Furthermore, we need to install
    one package, called `dos2unix`. So, if we are using `cli1` (Ubuntu), we need to
    type in the following command:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 我们只需要一台 Ubuntu 机器来完成这个教程。假设我们将继续使用 `cli1` 来掌握这些命令。此外，我们需要安装一个名为 `dos2unix` 的软件包。所以，如果我们使用的是
    `cli1`（Ubuntu），我们需要输入以下命令：
- en: '[PRE2]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: After this package is installed, we are ready to do our recipe.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 安装好这个软件包后，我们就可以开始做我们的教程了。
- en: How to do it…
  id: totrans-54
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是怎么做的…
- en: 'Let''s say that we created a `.txt` file called `txtsample.txt` in Notepad
    on Windows, which has the following content:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们在 Windows 上使用 Notepad 创建了一个名为 `txtsample.txt` 的 `.txt` 文件，其中包含以下内容：
- en: '[PRE3]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Then, we upload this file to our `cli1` machine and open it in vi or vim to
    check its content. This is what it looks like:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们将这个文件上传到我们的 `cli1` 机器，并在 vi 或 vim 中打开它来检查其内容。它看起来是这样的：
- en: '![Figure 8.5 – What our file seems to look like'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 8.5 – 我们的文件看起来像什么'
- en: '](img/Figure_8.5_B16269.jpg)'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_8.5_B16269.jpg)'
- en: Figure 8.5 – What our file seems to look like
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.5 – 我们的文件看起来像什么
- en: 'Everything seems fine, right? Now, let''s do the same thing all over again,
    but this time, start vi or vim with the `-b` option. For example, use the `vi`
    `-b txtsample.txt` command and check the file content now. It should look like
    this:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 一切看起来正常，对吧？现在，让我们重新做一遍相同的事情，但这次从 vi 或 vim 中使用 `-b` 选项启动。例如，使用 `vi` `-b txtsample.txt`
    命令并检查文件内容。现在应该是这样的：
- en: '![Figure 8.6 – What our file actually looks like'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 8.6 – 我们的文件实际样子'
- en: '](img/Figure_8.6_B16269.jpg)'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_8.6_B16269.jpg)'
- en: Figure 8.6 – What our file actually looks like
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.6 – 我们的文件实际样子
- en: We can see `^M` characters) in the vi/vim editor now. This is one of those subtle
    differences between the way Notepad and Linux text editors treat `.txt` files.
    Linux shell commands aren't necessarily going to treat this type of text in a
    friendly manner, and sometimes scripts will not work properly because of these
    *extra* characters that Linux commands don't need.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以在 vi/vim 编辑器中看到 `^M` 字符。这是 Notepad 和 Linux 文本编辑器处理 `.txt` 文件时的细微差别之一。Linux
    的 shell 命令不一定会以友好的方式处理这种文本，有时脚本因为这些 Linux 命令不需要的 *额外* 字符而无法正常工作。
- en: 'The solution to this problem is a simple package and command called `dos2unix`
    that we installed in the *Getting ready* step of this recipe. After that, it''s
    a simple procedure of typing in the following command:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 这个问题的解决方案是一个简单的软件包和命令，叫做 `dos2unix`，我们在本教程的 *准备工作* 步骤中已经安装了它。之后，只需输入以下命令：
- en: '[PRE4]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Let''s open this file in vi with the same `-b` option now and check the file
    content:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们在 vi 中用相同的 `-b` 选项打开这个文件，并检查文件内容：
- en: '![Figure 8.7 – End result – a file that''s stripped of CRs'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 8.7 – 结果 – 一个去除 CR 的文件'
- en: '](img/Figure_8.7_B16269.jpg)'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_8.7_B16269.jpg)'
- en: Figure 8.7 – End result – a file that's stripped of CRs
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.7 – 结果 – 一个去除 CR 的文件
- en: Now that's much better.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 现在好多了。
- en: There are other examples of this approach – end-of-file characters, *invisible*
    characters that sometimes appear out of nowhere in Excel-exported CSV files. So,
    we have to make sure that we are aware of this problem and its simple solution.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 还有其他类似的例子——文件结束字符，*看不见* 的字符，有时会在 Excel 导出的 CSV 文件中突然出现。因此，我们必须确保我们意识到这个问题及其简单的解决方法。
- en: 'We could also use tools such as `tr`, `awk`, and `perl` to do the same thing.
    Let''s use `tr` as an example:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以使用 `tr`、`awk` 和 `perl` 等工具来做同样的事情。以 `tr` 为例：
- en: '[PRE5]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Let's now explain how this works and why it's such a problem.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们解释一下这个过程是如何工作的，以及它为什么会成为一个问题。
- en: How it works…
  id: totrans-77
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: A CR is a character that has been used through the years as a control mechanism
    to set the end of a line, and, as a result, start a new line of text. For those
    of us old enough to remember the old typewriter machines, the CR on a mechanical
    typewriter machine would be that funny lever that we had to pull to get to a new
    line. By extension, this is a part of ASCII code that helps with cursor positioning
    (beginning of the next line).
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: CR是一个控制字符，它多年来被用来标识行尾，并因此开始新的一行。对于我们这些还记得旧打字机的人来说，打字机上的CR就是那个奇怪的杠杆，我们必须拉动它才能跳到下一行。它实际上是ASCII码的一部分，用于帮助定位光标（指向下一行的开始位置）。
- en: If we don't clear our `.txt` files of these characters (and others), we might
    have problems with scripting. In our last two chapters of this book with shell
    script examples, we're going to have multiple example scripts that use the `cat`
    command to input something from a `.txt` file into a loop. These characters might
    mess that procedure up, and we don't want that.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们不清理`.txt`文件中的这些字符（以及其他字符），在编写脚本时可能会遇到问题。在本书的最后两章中，我们将提供多个示例脚本，这些脚本使用`cat`命令从`.txt`文件中读取内容并传入循环。这些字符可能会干扰这个过程，我们可不希望这样。
- en: '`dos2unix` and the mentioned `tr` command strip the input file of CRs. We might
    debate which method is better, but at the end of the day, it''s about results,
    and both methods work. We prefer the `dos2unix` method; but, of course, you might
    prefer the `tr` way.'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: '`dos2unix`和前面提到的`tr`命令可以去除输入文件中的CR字符。我们可以辩论哪种方法更好，但最终重要的是结果，两者都能奏效。我们更倾向于使用`dos2unix`方法；当然，你也可以选择`tr`方法。'
- en: There's more…
  id: totrans-81
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多…
- en: 'If you need more information about converting DOS `.txt` files to Linux, refer
    to the following links:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你需要更多关于将DOS格式`.txt`文件转换为Linux格式的信息，请参考以下链接：
- en: '`dos2unix` man page: [https://linux.die.net/man/1/dos2unix](https://linux.die.net/man/1/dos2unix%0D)'
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`dos2unix`手册页：[https://linux.die.net/man/1/dos2unix](https://linux.die.net/man/1/dos2unix%0D)'
- en: '`yr` man page: [https://linux.die.net/man/1/tr](https://linux.die.net/man/1/tr%0D)'
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`yr`手册页：[https://linux.die.net/man/1/tr](https://linux.die.net/man/1/tr%0D)'
- en: Using cut
  id: totrans-85
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用cut
- en: There are tools in IT that get elevated to greatness by the simple fact that
    they are great tools. The next three tools that we are going to use are tools
    that fit the description of some of the greatest CLI tools ever invented. For
    us, `cut` is the second greatest CLI command of all time; if you want to find
    out which command takes the coveted *#1* spot, stay tuned for the next recipes.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 有一些工具在IT领域因其出色的功能而被推崇。接下来我们要使用的三个工具正是符合一些最伟大的命令行工具的标准。对我们来说，`cut`是历史上第二伟大的CLI命令；如果你想知道哪个命令摘得*第一*的位置，请继续关注接下来的教程。
- en: '`cut` is a tool that can make our lives a lot easier if we''re working with
    preformatted input. For example, it will easily work with CSV, as that''s a formatted
    type of content that can be easily digested by `cut`. Let''s learn about `cut`
    by doing some examples next.'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: '`cut`是一个非常有用的工具，它能让我们在处理预格式化输入时事半功倍。例如，它可以轻松处理CSV格式文件，因为这种格式的内容可以被`cut`轻松解析。接下来我们将通过一些示例来学习如何使用`cut`。'
- en: Getting ready
  id: totrans-88
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: We just need one Ubuntu machine for this recipe, so let's keep using `cli1`.
    The `cut` command is a standard part of any Linux distribution and that's how
    it should be, as it's more important than other commands, such as `ls`, `mkdir`,
    and `ps`.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 我们只需要一台Ubuntu机器来执行这个任务，所以继续使用`cli1`。`cut`命令是任何Linux发行版的标准工具，它的重要性不亚于其他命令，比如`ls`、`mkdir`和`ps`。
- en: How to do it…
  id: totrans-90
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作…
- en: 'Let''s first create a sample CSV file. For example, we are going to create
    a CSV file with user data, and use `cut` on top of that file. Here''s what we
    used for this recipe (CSV file content):'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先创建一个示例CSV文件。例如，我们将创建一个包含用户数据的CSV文件，并在这个文件上使用`cut`。以下是我们为这个任务所使用的CSV文件内容：
- en: '![Figure 8.8 – Sample input CSV file'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: '![Figure 8.8 – 示例输入CSV文件](img/Figure_8.8_B16269.jpg)'
- en: '](img/Figure_8.8_B16269.jpg)'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_8.8_B16269.jpg)'
- en: Figure 8.8 – Sample input CSV file
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: Figure 8.8 – 示例输入CSV文件
- en: 'We are now going to check what we can do with this file and the `cut` command.
    Let''s start with some simple things. For example, first we are going to extract
    just names from this file, which translates to the first field (before the first
    comma sign):'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们来看看如何使用这个文件和`cut`命令。首先从一些简单的操作开始。例如，我们将从这个文件中提取出名字，也就是提取第一个字段（第一个逗号前的内容）：
- en: '![Figure 8.9 – Extracting the first field from a standard-format file'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: '![Figure 8.9 – 从标准格式文件中提取第一个字段](img/Figure_8.9_B16269.jpg)'
- en: '](img/Figure_8.9_B16269.jpg)'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_8.9_B16269.jpg)'
- en: Figure 8.9 – Extracting the first field from a standard-format file
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.9 – 从标准格式文件中提取第一个字段
- en: 'By using the `cut` command and two switches, we were able to easily extract
    names from the CSV file. Now, let''s add a bit more to the process. Let''s extract
    the name and login (first and third fields):'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用 `cut` 命令和两个开关，我们能够轻松地从 CSV 文件中提取名称。现在，让我们对这个过程再做一点扩展。让我们提取名称和登录名（第一个和第三个字段）：
- en: '![Figure 8.10 – Extracting the first and third fields from our sample file'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 8.10 – 从示例文件中提取第一个和第三个字段'
- en: '](img/Figure_8.10_B16269.jpg)'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_8.10_B16269.jpg)'
- en: Figure 8.10 – Extracting the first and third fields from our sample file
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.10 – 从示例文件中提取第一个和第三个字段
- en: 'Furthermore, let''s now extract the first three fields – name, surname, and
    login:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，现在让我们提取前三个字段——姓名、姓氏和登录名：
- en: '![Figure 8.11 – Extracting a range of fields from our sample file'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 8.11 – 从示例文件中提取字段范围'
- en: '](img/Figure_8.11_B16269.jpg)'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_8.11_B16269.jpg)'
- en: Figure 8.11 – Extracting a range of fields from our sample file
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.11 – 从示例文件中提取字段范围
- en: 'We could also choose to sort that output alphabetically:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以选择按字母顺序对输出进行排序：
- en: '![Figure 8.12 – Sorting output from a cut file'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 8.12 – 从切割文件中排序输出'
- en: '](img/Figure_8.12_B16269.jpg)'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_8.12_B16269.jpg)'
- en: Figure 8.12 – Sorting output from a cut file
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.12 – 从切割文件中排序输出
- en: 'One other classic example is using `cut` to output fields from one specific
    field onward – for example, from the second field to the last field:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个经典的例子是使用 `cut` 从某个特定字段开始输出字段——例如，从第二个字段到最后一个字段：
- en: '![Figure 8.13 – Extracting fields from the second field onward'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 8.13 – 从第二个字段开始提取字段'
- en: '](img/Figure_8.13_B16269.jpg)'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_8.13_B16269.jpg)'
- en: Figure 8.13 – Extracting fields from the second field onward
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.13 – 从第二个字段开始提取字段
- en: If you're heavily into Microsoft PowerShell, this will kind of remind you of
    the `Import-Csv` PowerShell cmdlet, although the similarities end there, seeing
    as PowerShell is an object-based shell language.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你熟悉 Microsoft PowerShell，这个操作可能会让你联想到 `Import-Csv` PowerShell cmdlet，尽管相似之处仅此而已，因为
    PowerShell 是基于对象的 shell 语言。
- en: As you can see from these examples, the `cut` command is very useful for situations
    where we have an input file that's in some sort of standard format that uses some
    character as a delimiter between fields. We can easily use it to extract content
    from our text files and to prepare text-based input for other actions that might
    follow using `cut` in a shell script.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，`cut` 命令在处理一些标准格式的输入文件时非常有用，这些文件使用某些字符作为字段之间的分隔符。我们可以轻松地使用它从文本文件中提取内容，并为后续的操作准备基于文本的输入，这些操作可能会使用
    `cut` 在 shell 脚本中进行。
- en: How it works…
  id: totrans-117
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: '`cut` is a straightforward command that has only one prerequisite – we need
    to have an input file that''s formatted in some sort of standard format. That
    translates to having a file with fields delimited by the same character. If that
    criterion is met, we can easily use `cut` to do wonders in one-liner commands
    and shell scripts.'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: '`cut` 是一个简单的命令，只有一个前提条件——我们需要有一个格式化为某种标准格式的输入文件。这意味着文件的字段由相同的字符分隔。如果满足此条件，我们可以轻松使用
    `cut` 在一行命令和 shell 脚本中发挥作用。'
- en: 'Most commonly, we use two parameters with the `cut` command:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 最常用的是，我们在使用 `cut` 命令时会使用两个参数：
- en: The `-f` parameter is used to select which field(s) or field range we are going
    to use to be extracted by using the `cut` command.
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-f` 参数用于选择我们要提取的字段或字段范围。'
- en: The `-d` parameter is used to select a delimiter, a character that separates
    our text strings.
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-d` 参数用于选择分隔符，一个分隔我们文本字符串的字符。'
- en: We can also use it in conjunction with other commands, such as `sort`, `tr`,
    and `uniq`, to do further manipulation of the output extracted by using the `cut`
    command. We can even use its parameter called `--output-delimiter` to change the
    input delimiter to some other output delimiter.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以将其与其他命令一起使用，如 `sort`、`tr` 和 `uniq`，对使用 `cut` 命令提取的输出进行进一步操作。我们甚至可以使用其名为
    `--output-delimiter` 的参数，将输入分隔符更改为其他输出分隔符。
- en: This was a warmup exercise before the big star of the show – the `egrep` command
    – as its significance can't be overstated. Let's talk about `egrep` next.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个热身练习，为了之后的明星命令——`egrep` 命令——做准备，因为它的重要性无法过分强调。接下来我们来讨论 `egrep`。
- en: There's more…
  id: totrans-124
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多…
- en: 'If you need more information about networking in CentOS and Ubuntu, make sure
    that you check out the following:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你需要更多关于 CentOS 和 Ubuntu 网络的信息，请确保查看以下内容：
- en: 'The `cut` man page: [https://man7.org/linux/man-pages/man1/cut.1.html](https://man7.org/linux/man-pages/man1/cut.1.html%0D)'
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`cut`命令手册页：[https://man7.org/linux/man-pages/man1/cut.1.html](https://man7.org/linux/man-pages/man1/cut.1.html%0D)'
- en: 'Bash `cut` command examples: [https://linuxhint.com/bash-cut-command-examples/](https://linuxhint.com/bash-cut-command-examples/%0D)'
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Bash `cut`命令示例：[https://linuxhint.com/bash-cut-command-examples/](https://linuxhint.com/bash-cut-command-examples/%0D)
- en: Using egrep
  id: totrans-128
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用`egrep`
- en: Using `egrep`, and regular expressions in general, is something like page one,
    chapter one stuff from the never-written *How to be both cool and incredibly useful*
    IT manual. It is, without a shadow of a doubt, the most useful command that was
    ever invented in the UNIX/Linux world for system administration. It doesn't really
    matter whether we're looking for a specific string in a file or set of directories,
    whether we're trying to find a line in a big text file where a specific string
    is located, or whether we're trying to find where a specific string isn't, `egrep`
    can do all of that for us. We are focusing on `egrep` specifically, as it supports
    both concepts that are behind this command – regular expressions and extended
    regular expressions. That's where we are going to start – first, by explaining
    the merits of using regular expressions, and then moving on from that to explain
    why `egrep` is such an important command. So, buckle up and get ready to go!
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`egrep`和正则表达式通常类似于《如何成为既酷又超级实用的IT手册》第一页、第一章的内容，尽管这本书从未写成过。毫无疑问，这是UNIX/Linux世界中为系统管理发明的最有用的命令。无论我们是在文件或一组目录中查找特定字符串，还是在大文本文件中找到包含特定字符串的行，或者查找特定字符串不存在的位置，`egrep`都能做到这一切。我们特别关注`egrep`，因为它支持该命令背后的两个概念——正则表达式和扩展正则表达式。这就是我们开始的地方——首先解释使用正则表达式的优点，然后进一步解释为什么`egrep`是如此重要的命令。所以，系好安全带，准备出发！
- en: Getting ready
  id: totrans-130
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: We are going to use two virtual machines for this recipe – the Ubuntu-based
    `cli1` and CentOS-based `cli2`. That's going to enable us to have more examples
    as logging configuration on Ubuntu is a bit different from CentOS, and CentOS's
    logging configuration makes it easier to drive some points home. So, start both
    of these virtual machines and let's get going.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用两台虚拟机进行这个教程——基于Ubuntu的`cli1`和基于CentOS的`cli2`。这样做可以为我们提供更多的示例，因为Ubuntu上的日志配置与CentOS略有不同，而CentOS的日志配置则更容易帮助我们理解一些要点。所以，请启动这两台虚拟机，准备开始吧。
- en: How to do it…
  id: totrans-132
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作…
- en: Using regular expressions comes naturally to everyone if we take some time to
    get to know how to use them. By extension, our first *frontend* to regular expressions
    is using the `grep` or `egrep` command. These commands enable us to find a text
    string inside a text file or text input.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们花点时间了解如何使用正则表达式，使用它对每个人来说都会变得非常自然。由此，我们与正则表达式的第一个*前端*就是使用`grep`或`egrep`命令。这些命令使我们能够在文本文件或文本输入中找到特定的文本字符串。
- en: Let's use a simple example. In [*Chapter 4*](B16269_04_Final_PD_ePub.xhtml#_idTextAnchor077),
    *Using Shell to Configure and Troubleshoot Network*, we used the `ps` command
    to display running processes. Let's say that we want to do this now, but by using
    regular expressions. For example, we need to list all the processes on our Linux
    server that were started by user `student`.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用一个简单的例子。在[*第4章*](B16269_04_Final_PD_ePub.xhtml#_idTextAnchor077)《使用Shell配置和故障排除网络》中，我们使用了`ps`命令来显示正在运行的进程。假设我们现在也想这样做，但是使用正则表达式。例如，我们需要列出在Linux服务器上由用户`student`启动的所有进程。
- en: 'If we start with the `ps` command first – for example, if we use the `ps auwwx`
    command – we are going to get an output like this:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们首先使用`ps`命令——例如，使用`ps auwwx`命令——我们会得到如下输出：
- en: '![Figure 8.14 – ps auwwx input, cut short for formatting reasons'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 8.14 – ps auwwx 输入，因格式化原因被截断'
- en: '](img/Figure_8.14_B16269.jpg)'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_8.14_B16269.jpg)'
- en: Figure 8.14 – ps auwwx input, cut short for formatting reasons
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.14 – ps auwwx 输入，因格式化原因被截断
- en: Now, let's discuss the fact that this is a text output for just a second – it
    has a lot of letters and numbers. Also, let's focus on the fact that all processes
    running on our system are represented by a line in the `ps` command output – a
    line that, as seen in the figure, starts with the `root, www-data` string, or
    some other string that represents the user that owns the process. How about if
    we figure out a way of using that as a property to filter the `ps` command output
    as text, by using the idea of *line starts with* `student` for it?
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们简单讨论一下这只是一个文本输出的事实——它包含了大量的字母和数字。此外，我们还需要关注一个事实，即系统上运行的所有进程在 `ps` 命令的输出中都由一行表示——这一行，如图所示，以
    `root, www-data` 字符串开头，或者其他代表拥有该进程的用户的字符串。那么，如果我们想办法利用这一点作为属性来过滤 `ps` 命令的文本输出呢？我们可以通过使用*以`student`开头*来进行过滤。
- en: 'If we wanted to do that, we would use a simple command: `ps auwwx | grep ^student`.
    As we discussed previously, the `|` sign means *we want to send the output of
    the first command to the second command*. Furthermore, `grep` means *we want to
    filter something out*. And this `^student` thing? That''s what we call a regular
    expression pattern, with the `^` character being a regular expression symbol.
    Specifically, it''s an anchor, which when used with `grep` or some other regular
    expression-aware command means *line starts with* the character, or a set of characters
    that follow. Let''s put that theory into practice:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想要做到这一点，我们可以使用一个简单的命令：`ps auwwx | grep ^student`。正如我们之前讨论的，`|` 符号表示*我们希望将第一个命令的输出传递给第二个命令*。此外，`grep`
    表示*我们希望过滤某些内容*。而这个 `^student` 是什么呢？它是我们所称的正则表达式模式，其中 `^` 字符是正则表达式符号。具体来说，它是一个锚点，当与
    `grep` 或其他支持正则表达式的命令一起使用时，意味着*行以*该字符或其后的一组字符开始。让我们把这个理论付诸实践：
- en: '![Figure 8.15 – Using our first regular expression'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 8.15 – 使用我们的第一个正则表达式'
- en: '](img/Figure_8.15_B16269.jpg)'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_8.15_B16269.jpg)'
- en: Figure 8.15 – Using our first regular expression
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.15 – 使用我们的第一个正则表达式
- en: So, here we go, we filtered our output by using the `student` string as a filter.
    We can also see that each appearance of that string is marked in red. This comes
    from the fact that `grep` commands use the `--color` option by default – an option
    that highlights the string that we were using as a condition for filtering.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，我们通过使用 `student` 字符串作为过滤条件来过滤输出。我们还可以看到每次出现该字符串时，都会用红色标出。这是因为 `grep` 命令默认使用了
    `--color` 选项——这个选项会高亮显示我们用作过滤条件的字符串。
- en: 'Let''s say that now we want to find all lines in our `ps auwwx` output that
    end with the `bash` string. We can easily use regular expressions for that. Here''s
    how we''d do that:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 假设现在我们想要查找所有在 `ps auwwx` 输出中以 `bash` 字符串结尾的行。我们可以轻松地使用正则表达式来实现这一点。下面是我们如何操作：
- en: '![Figure 8.16 – Using a regular expression to find a string at the end of a
    line'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 8.16 – 使用正则表达式查找位于行尾的字符串'
- en: '](img/Figure_8.16_B16269.jpg)'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_8.16_B16269.jpg)'
- en: Figure 8.16 – Using a regular expression to find a string at the end of a line
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.16 – 使用正则表达式查找位于行尾的字符串
- en: 'So far, we''ve used the `ps` command as it''s convenient and familiar. Let''s
    now move on to other examples that are going to use text files as a basis. The
    first one that comes to mind is `/usr/share/dict/words`, a dictionary text file
    that contains more than 100,000 words. The format of that file is *one word per
    line*, so more than 100,000 words equals more than 100,000 lines. Let''s try to
    find all the lines that have the `parrot` string in them. Here''s the command
    and result:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经使用过 `ps` 命令，因为它方便且熟悉。接下来，我们将转向其他示例，这些示例将以文本文件为基础。首先想到的是 `/usr/share/dict/words`，这是一个包含超过
    100,000 个单词的字典文本文件。该文件的格式是*每行一个单词*，所以超过 100,000 个单词就意味着超过 100,000 行。我们来尝试找到所有包含
    `parrot` 字符串的行。下面是命令和结果：
- en: '![Figure 8.17 – Using grep directly on a text file'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 8.17 – 直接在文本文件上使用 grep'
- en: '](img/Figure_8.17_B16269.jpg)'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_8.17_B16269.jpg)'
- en: Figure 8.17 – Using grep directly on a text file
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.17 – 直接在文本文件上使用 grep
- en: So, the `grep` command can also be directly used on a text file, which is very
    useful when dealing with scripts, input files into scripts, and so on.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，`grep` 命令也可以直接用于文本文件，这在处理脚本、输入文件到脚本等情况时非常有用。
- en: 'So far, so good. Let''s make things a bit more complicated. Let''s say that
    we need to find all lines in the same file (`/usr/share/dict/words`) that contain
    a string conforming to these rules:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，一切顺利。让我们把事情变得更复杂一点。假设我们需要找到同一个文件（`/usr/share/dict/words`）中所有符合以下规则的字符串：
- en: The line needs to start with `p`.
  id: totrans-155
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这一行需要以 `p` 开头。
- en: The letter `p` needs to be *followed by a vowel*.
  id: totrans-156
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 字母`p`后面需要*跟着一个元音*。
- en: A vowel needs to be followed by the `ta` string.
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 元音字母后面需要跟着`ta`字符串。
- en: 'All of a sudden, things get much more complicated. Imagine having to find these
    words using a regular text editor. Writing down all these combinations would lead
    us to the following words that we''re looking for:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 突然间，事情变得更加复杂。试想一下，必须使用常规文本编辑器来查找这些单词。写下所有这些组合将导致我们找到以下我们正在寻找的单词：
- en: '`pata`, followed by anything'
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`pata`，后面跟着任何东西'
- en: '`peta`, followed by anything'
  id: totrans-160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`peta`，后面跟着任何东西'
- en: '`pita`, followed by anything'
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`pita`，后面跟着任何东西'
- en: '`pota`, followed by anything'
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`pota`，后面跟着任何东西'
- en: '`puta`, followed by anything'
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`puta`，后面跟着任何东西'
- en: In a regular text editor, it would take us five different sequential finds to
    find all the words, and even then, we'd have to press *next-next-next* for all
    the next appearances in case one of these string samples can be matched multiple
    times.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 在常规文本编辑器中，我们需要五次不同的连续查找来找到所有单词，即便如此，我们还需要按*下一步-下一步-下一步*来查找每个出现的地方，以防这些字符串样本可以多次匹配。
- en: 'This is where regular expressions can be of great help. We could do this:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是正则表达式大有用处的地方。我们可以这样做：
- en: '![Figure 8.18 – Finding a more complex string sample'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 8.18 – 查找更复杂的字符串示例'
- en: '](img/Figure_8.18_B16269.jpg)'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_8.18_B16269.jpg)'
- en: Figure 8.18 – Finding a more complex string sample
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.18 – 查找更复杂的字符串示例
- en: By using the `^p[aeiou]ta` regular expression, we were able to find all of the
    words matching that criterion easily. When using these square brackets to input
    a regular expression sample, we are basically saying to the regular expression-aware
    command to search for *either a, or e, or i, or o, or u* as a character inside
    the regular expression string.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用`^p[aeiou]ta`正则表达式，我们能够轻松找到所有符合该标准的单词。当我们使用这些方括号输入正则表达式时，实际上是在告诉支持正则表达式的命令去查找*字符a、e、i、o或u*，作为正则表达式字符串中的一个字符。
- en: 'As we can see, getting to know regular expressions can be quite useful. Let''s
    add some more of them with a short explanation:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所看到的，了解正则表达式是非常有用的。让我们再添加一些正则表达式，并简要解释一下：
- en: '![Table 8.1 – Commonly used regular expression symbols and their meaning'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: '![表 8.1 – 常用正则表达式符号及其含义'
- en: '](img/B16269_08_Table_1.jpg)'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16269_08_Table_1.jpg)'
- en: Table 8.1 – Commonly used regular expression symbols and their meaning
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 表 8.1 – 常用正则表达式符号及其含义
- en: There are many more regular expressions that we can use, but let's just start
    with these and then move on to more complex examples – for example, extended regular
    expressions.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用更多的正则表达式，但我们先从这些开始，然后再转向更复杂的例子——例如，扩展正则表达式。
- en: How about matching numbers? Matching numbers with regular expressions is, let's
    say, *fun*. Especially if we need to find a number range – things get really complicated
    real soon if that's the case. Let's discuss this by using three examples – one
    for a single-digit number range, one for a simple double-digit number range, and
    one for a more complex double-digit number range. We can extrapolate how this
    logic would work on larger numbers. Let's start with a simpler example – for example,
    a number range from 0 to 5 – and just work with regular expressions, forgetting
    the `grep` command for a second. In regular expression terms, that would be `[0-5]`.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，如何匹配数字呢？用正则表达式匹配数字可以说是*有趣*的，特别是当我们需要查找数字范围时——如果是这种情况，事情很快就会变得非常复杂。我们通过三个示例来讨论这个问题——一个是单个数字范围，一个是简单的两位数字范围，还有一个是更复杂的两位数字范围。我们可以推断出这种逻辑如何应用于更大的数字范围。我们从一个简单的例子开始——例如，0到5的数字范围——仅使用正则表达式，暂时忘记`grep`命令。在正则表达式中，这将是`[0-5]`。
- en: For our next example, let's use a simple double-digit number range – let's say,
    14-19\. In regular expression terms, we'd write that as `1[4-9]`.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 对于下一个例子，我们使用一个简单的两位数字范围——假设是14-19\。在正则表达式中，我们可以写作`1[4-9]`。
- en: This means 1 as a leading number (tens), and then the number range from 4 to
    9, which equals 14-19\.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着1作为前导数字（十位数），然后是从4到9的数字范围，即14-19\。
- en: So far, we specifically chose to use the `grep` command to do these first examples
    as it works with basic regular expressions. We need to add a `-E` switch to the
    `grep` command or start using the `egrep` command if we want to move on to extended
    regular expressions. So far, we've covered some basics, so it's time to make things
    a bit more complicated. Everything that we've discussed so far is what we call
    `\?` and `\|` get replaced in EREs with `?` and `|`. That makes the syntax cleaner
    and easier on the eye, so to speak. Let's work on some examples, first by continuing
    our *using regular expressions to match numbers* discussion.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们特意选择使用 `grep` 命令做这些第一个示例，因为它适用于基本正则表达式。如果我们想要使用扩展正则表达式，我们需要在 `grep`
    命令中添加 `-E` 参数，或者开始使用 `egrep` 命令。到目前为止，我们已经涵盖了一些基础内容，接下来是让事情变得复杂一些。到目前为止，我们讨论的所有内容中，`\?`
    和 `\|` 在扩展正则表达式（ERE）中被替换为 `?` 和 `|`。这使得语法更简洁，视觉效果也更好。让我们继续举些例子，首先继续我们的 *使用正则表达式匹配数字*
    的讨论。
- en: 'What happens if we need to find a number range, for example, 37-94? Regular
    expressions can''t work with multiple-digit numbers in ranges – we need to slice
    that into ones, tens, hundreds, and so on. And then, we need to use a very well-known
    concept called the union of a set (of ranges) to combine all of the ranges into
    one range that fits the regular expression that we wanted to find. Keeping in
    mind that we are going to need a set – a set of numbers, in this example – we
    are going to do this by using EREs. Let''s see how that works with minimization
    in mind – we want to have a regular expression that''s as short as possible. Knowing
    the fact that we need to use the union of a set, the simplest way to do this number
    range would be as follows:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们需要找到一个数字范围，例如 37-94，该怎么办？正则表达式不能处理范围内的多位数字——我们需要将其分割为个位、十位、百位等等。然后，我们需要使用一个非常著名的概念——集合的并集（范围集合）来将所有范围组合成一个符合我们想要的正则表达式的范围。记住，我们需要一个集合——在这个例子中是一个数字集合——我们将通过使用扩展正则表达式（ERE）来实现这一点。让我们看看在最小化的前提下是如何工作的——我们希望得到尽可能短的正则表达式。知道我们需要使用集合的并集，最简单的实现这个数字范围的方法如下：
- en: 37-39
  id: totrans-180
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 37-39
- en: 40-89
  id: totrans-181
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 40-89
- en: 90-94
  id: totrans-182
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 90-94
- en: 'In regular expression terms, those sets would be as follows:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 在正则表达式中，这些集合会是如下形式：
- en: '`3[7-9]` for 37-39'
  id: totrans-184
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`3[7-9]` 代表 37-39'
- en: '`[4-8][0-9]` for 40-89'
  id: totrans-185
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`[4-8][0-9]` 代表 40-89'
- en: '`9[0-4]` for 90-94'
  id: totrans-186
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`9[0-4]` 代表 90-94'
- en: 'As a regular expression, we''d write it like this:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 作为正则表达式，我们会这样写：
- en: '`3[7-9]|[4-8][0-9]|9[0-4]`'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: '`3[7-9]|[4-8][0-9]|9[0-4]`'
- en: Here, the `|` sign basically stands for *or*. This is a way of implementing
    a union set when using regular expressions.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，`|` 符号基本上表示 *或*。这是使用正则表达式时实现并集的一种方式。
- en: 'Keeping in mind that Ubuntu''s version of the `/usr/share/dict/words` file
    doesn''t have a single number in it, we added a couple of numbers to the top of
    this file just so that we have something to test with. For example, we added the
    following to the top of this file:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，Ubuntu 版本的 `/usr/share/dict/words` 文件中没有任何数字，我们在文件顶部添加了一些数字，以便进行测试。例如，我们在文件顶部添加了以下内容：
- en: '`41`'
  id: totrans-191
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`41`'
- en: '`58`'
  id: totrans-192
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`58`'
- en: '`36`'
  id: totrans-193
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`36`'
- en: '`95`'
  id: totrans-194
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`95`'
- en: '`94`'
  id: totrans-195
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`94`'
- en: 'We deliberately chose these numbers as they contain both numbers that are conformant
    to the regular expression that we made (41, 58, and 94 will be a match) and numbers
    that aren''t (36 and 95). If we use `grep` with our regular expression on this
    file with added numbers, we will get the following output:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 我们故意选择了这些数字，因为它们既包含符合我们所做正则表达式的数字（41、58 和 94 会匹配），也包含不符合的数字（36 和 95）。如果我们在这个包含数字的文件上使用带有正则表达式的`grep`，我们将得到以下输出：
- en: '![Figure 8.19 – Using a union set works and we found our matches'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 8.19 – 使用并集可以找到我们的匹配项'
- en: '](img/Figure_8.19_B16269.jpg)'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_8.19_B16269.jpg)'
- en: Figure 8.19 – Using a union set works and we found our matches
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.19 – 使用并集可以找到我们的匹配项
- en: As we grow the number of digits that we're looking for, regular expressions
    get more and more complex. We should always minimize as much as we can, but there
    will be situations where we must make a lot of union sets to find something that
    we are looking for. That's just the name of the game, nothing to be scoffed at.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 随着我们要查找的数字位数的增加，正则表达式变得越来越复杂。我们应该尽量简化，但在某些情况下，我们必须使用大量并集来找到我们正在寻找的内容。这就是规则，没有什么值得嘲笑的。
- en: 'Our next example is going to find words (non-numbered only) that are 19 to
    20 characters long, made of letters only. We''re still using the same file as
    before, so let''s see how we do that:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的下一个例子是查找长度为 19 到 20 个字符的单词（仅限字母），我们依然使用之前的文件，来看如何做到这一点：
- en: '![Figure 8.20 – Finding words of specific length'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 8.20 – 查找特定长度的单词'
- en: '](img/Figure_8.20_B16269.jpg)'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_8.20_B16269.jpg)'
- en: Figure 8.20 – Finding words of specific length
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.20 – 查找特定长度的单词
- en: Easy, right? We matched all the lowercase and uppercase characters and then
    said *words need to have 19 to 20 of those*.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 很简单，对吧？我们匹配了所有的小写和大写字母，然后说*单词需要包含 19 到 20 个这样的字母*。
- en: Things tend to get even more complicated when you're trying to create a regular
    expression for some words that are common, yet different, especially if word length
    is variable, and even more so if number ranges are involved. But all of that doesn't
    bring us closer to explaining what the practical point, the real value of regular
    expressions, is. Everything that we did so far seems like general hocus pocus,
    *trying to find some text – why should we care about that?* Generally speaking,
    we were only describing the principle, as using generic examples helps. Realistically,
    there's absolutely no way to learn regular expressions by reading 10-15 pages
    of text. But we are now going to make an educated effort to move this story along
    to real-life, practical uses of regular expressions.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 当你试图为一些既常见又不同的单词创建正则表达式时，事情往往变得更加复杂，特别是当单词的长度可变时，更加困难的是，如果涉及到数字范围，情况会更加复杂。但是所有这些并没有帮助我们更接近解释正则表达式的实际用途——即其真正的价值所在。到目前为止，我们所做的一切看起来像是一般的“胡说八道”，*尝试找一些文本——为什么我们要在乎这些呢？*
    一般来说，我们只是描述了原理，因为使用通用的示例有助于理解。实际上，通过阅读 10-15 页的文本是绝对无法学会正则表达式的。但现在，我们将努力将这个故事推进到正则表达式在实际生活中的应用。
- en: There are some common services that use `grep` and/or regular expressions constantly.
    We have to keep in mind that this recipe is about `grep` as a command, not about
    regular expressions only.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 有一些常见的服务不断使用 `grep` 和/或正则表达式。我们必须记住，这个食谱是关于 `grep` 命令的，而不仅仅是正则表达式。
- en: For example, regular expressions are heavily used for mail filtering. Checking
    the body of an email – basically text content – is easy if you have a regular
    expression-enabled mail filter. From an everyday system administrator standpoint,
    regular expressions are constantly used for parsing through log files and finding
    valuable information in them. Let's make that point now by using regular expressions
    on log files, as that's one of the most commonly used practices that's been happening
    for decades now.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，正则表达式在邮件过滤中被广泛使用。检查电子邮件的正文——基本上是文本内容——如果你有一个支持正则表达式的邮件过滤器，这就很容易了。从日常系统管理员的角度来看，正则表达式被不断用于解析日志文件并从中找到有价值的信息。让我们通过对日志文件使用正则表达式来阐明这一点，因为这已经是几十年来最常用的做法之一。
- en: 'Let''s now switch to `cli2`, our CentOS-based system, and use `/var/log/messages`
    for the next examples. This file contains the main system log on CentOS, so it''s
    perfectly suitable to use regular expressions to find something in it. Let''s
    start with the simple stuff. For example, let''s say that we need to find all
    log entries in `/var/log/messages` that were made on October 6, and even more
    specifically, at the ninth hour, by a service called `PackageKit`. Let''s first
    check the structure of this log file – it looks like this:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们切换到 `cli2`，我们的基于 CentOS 的系统，并使用 `/var/log/messages` 作为接下来的示例。这个文件包含了 CentOS
    上的主要系统日志，因此它非常适合使用正则表达式来查找其中的内容。我们从简单的开始。例如，假设我们需要查找 `/var/log/messages` 中所有在
    10 月 6 日创建的日志条目，更具体地说，是在第九个小时，由名为 `PackageKit` 的服务创建的日志。首先，我们检查一下这个日志文件的结构 – 它看起来像这样：
- en: '![Figure 8.21 – Format of a file that we''re going to use grep on'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 8.21 – 我们将使用 `grep` 的文件格式'
- en: '](img/Figure_8.21_B16269.jpg)'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_8.21_B16269.jpg)'
- en: Figure 8.21 – Format of a file that we're going to use grep on
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.21 – 我们将使用 `grep` 的文件格式
- en: As we were discussing in our previous recipe about the `cut` command, we can
    see that this file *kind of* has a standard format. There's a timestamp at the
    beginning, the hostname after that, the service and PID after that, and then some
    kind of text message. Also, notice the fact that the timestamp part has a very
    cool addition – its format is not `Oct 6` with a single space between; it has
    two spaces. This is very important as it keeps the date format a fixed length
    when we get to double-digit dates, such as `Oct` `15`. It just makes everything
    formatted nicely, which is cool.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在之前的食谱中讨论的关于`cut`命令的内容，我们可以看到这个文件*大致上*有一个标准的格式。开头是时间戳，之后是主机名，再之后是服务和PID，最后是某种文本消息。此外，请注意时间戳部分有一个非常酷的附加功能——其格式不是`Oct
    6`，而是两个空格分隔，这非常重要，因为当我们遇到两位数日期（比如`Oct` `15`）时，这种格式能够保持日期长度一致。这样使得格式化更加整齐，非常棒。
- en: 'So, the simple fact is that we can easily output this by using `grep`. Let''s
    do it:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，简单的事实是，我们可以轻松地通过使用`grep`来输出这个结果。让我们来做做看：
- en: '![Figure 8.22 – Filtering out data that we wanted to filter out'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: '![图8.22 – 过滤掉我们想要过滤的数据'
- en: '](img/Figure_8.22_B16269.jpg)'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_8.22_B16269.jpg)'
- en: Figure 8.22 – Filtering out data that we wanted to filter out
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.22 – 过滤掉我们想要过滤的数据
- en: The first part of the command greps out all messages from `Oct 6` that starts
    with `09` in the hour part of the timestamp; then, we piped that out to another
    `grep` command that searches for the `PackageKit` string.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 命令的第一部分从`Oct 6`中筛选出所有以`09`开头的时间戳消息；然后，我们将其通过管道传递给另一个`grep`命令，用于搜索`PackageKit`字符串。
- en: 'The next example – and this one becomes more common as we get older – is, let''s
    say that we can''t remember the name of a file where the `firewall` string is
    used. We remember that it was somewhere in the `/etc/sysconfig` folder, but we
    can''t seem to remember what the filename was – one of those *it''s early Monday
    morning, I haven''t had time to wake up* moments. This is what we could do by
    using `grep`:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个例子——随着年龄的增长，这种情况变得越来越常见——假设我们记不住文件名，而文件中使用了`firewall`字符串。我们记得它在`/etc/sysconfig`文件夹中，但就是记不住文件名——那种*星期一早晨，我还没来得及清醒*的时刻。我们可以通过使用`grep`来做到这一点：
- en: '![Figure 8.23 – Using grep on a stack of files all at once'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: '![图8.23 – 在一堆文件中同时使用grep'
- en: '](img/Figure_8.23_B16269.jpg)'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_8.23_B16269.jpg)'
- en: Figure 8.23 – Using grep on a stack of files all at once
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.23 – 在一堆文件中同时使用grep
- en: The `grep` option `-r` means *recursive* and the `-i` option means *case insensitive*.
    Also, the `-r` option ignores any symbolic links as it recursively moves through
    subdirectories. If we want that behavior to change, we can use the `-r` option,
    which will take symbolic links into account. As we have the capability to use
    recursive search through file contents, that means `grep` is going to dive into
    subdirectories and go through all files. That means we must add one caveat to
    our discussion – we really, *really shouldn't* use this on binary files, for obvious
    reasons. It would make a big mess on our terminal output, if nothing else.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: '`grep`选项`-r`表示*递归*，而`-i`选项表示*不区分大小写*。此外，`-r`选项会忽略任何符号链接，因为它在递归地遍历子目录时会跳过这些链接。如果我们希望该行为发生变化，可以使用`-r`选项，这样符号链接就会被考虑进来。由于我们可以递归地搜索文件内容，这意味着`grep`将深入子目录并浏览所有文件。这也意味着我们必须在讨论中加入一个警告——我们真的，*真的不应该*在二进制文件上使用它，原因显而易见。如果什么都不发生，它只会让我们的终端输出变得一团糟。'
- en: 'Let''s end this recipe by using `egrep` for a much more complex scenario involving
    EREs and different text patterns on text input, the caveat being that we want
    to see a bit of *context* around our text pattern matches. Let''s say that we''re
    trying to go through our `dmesg` boot log, and we are searching for all the hard
    disks – all the `/dev/hd*` and `/dev/sd` devices. We could use the following command
    for that purpose:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过使用`egrep`来结束这个食谱，处理一个更复杂的场景，涉及ERE和不同的文本模式匹配，前提是我们希望看到一些*上下文*，以便更好地理解文本模式的匹配结果。假设我们正在浏览`dmesg`启动日志，并且我们正在搜索所有硬盘——所有`/dev/hd*`和`/dev/sd`设备。我们可以使用以下命令来完成这个任务：
- en: '[PRE6]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Let''s check what the output would look like:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们查看输出结果会是什么样子的：
- en: '[PRE7]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: If we take a look at the end of this output, we can see that the last two lines
    don't match our regular expression used to filter data. That's because we used
    the `-C2` parameter with `egrep`, and that option enables `egrep` to show two
    lines preceding and two lines following our pattern match. We can divide that
    option into options `-A` and `-B` (after and before the match, respectively) if
    we want to specify a custom number of lines to appear after and before our pattern
    match. There are many more `grep` options available, but these are enough to get
    us started. We will add some more examples of using regular expressions and some
    topics we didn't cover here in the next recipe, about the `sed` command.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们查看这个输出的结尾部分，可以看到最后两行并不符合我们用来过滤数据的正则表达式。这是因为我们使用了`-C2`参数与`egrep`，该选项允许`egrep`显示模式匹配前后各两行。如果我们希望自定义显示匹配前后的行数，我们可以将该选项分解为`-A`和`-B`选项（分别表示匹配之后和之前的行数）。`grep`还有更多选项可供使用，但这些已经足够让我们入门。在下一篇食谱中，我们将介绍更多使用正则表达式的例子，以及一些我们在这里没有涉及到的主题，关于`sed`命令。
- en: How it works…
  id: totrans-229
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: '`grep` is a pattern-matching command that can work in a variety of different
    ways – either as a standalone command that takes text files as input or as something
    that we pipe input to in a command set. Its purpose is clear – find specific text
    patterns in a large set of text. A couple of years ago, its default output changed
    a little bit as it used to show the lines matching our search pattern, while now
    it does that and it does it in color, by marking the found search pattern in red.'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: '`grep`是一个模式匹配命令，可以通过多种方式工作——它可以作为一个独立命令，接受文本文件作为输入，也可以作为我们在命令集中的输入管道。它的目的是明确的——在大量文本中查找特定的文本模式。几年前，它的默认输出有所变化，之前它只显示与我们搜索模式匹配的行，而现在，它不仅做到了这一点，还以彩色的方式显示，将找到的搜索模式标记为红色。'
- en: '`grep` works by implementing the idea of text pattern search into a programmable
    command that''s a regular part of shell scripts, as we''ll explain in the last
    two chapters with practical examples of scripting. As such, it''s an irreplaceable
    part of a system administrator''s toolkit as it enables us to find important text
    data from one or many files, therefore bringing a sort of chaos into order.'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: '`grep`通过将文本模式搜索的思想融入到一个可编程的命令中来工作，这个命令是shell脚本中的常规部分，正如我们将在最后两章通过脚本的实际例子来解释的那样。因此，它是系统管理员工具包中不可或缺的一部分，因为它使我们能够从一个或多个文件中找到重要的文本数据，从而将混乱转化为秩序。'
- en: 'The most commonly used options are as follows:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 最常用的选项如下：
- en: '`-E` (or `egrep`): By default, `grep` recognizes BREs only. If we use the `-E`
    parameter, it works with EREs.'
  id: totrans-233
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-E`（或`egrep`）：默认情况下，`grep`只识别BRE。如果我们使用`-E`参数，它将支持ERE。'
- en: '`-i`: Case-insensitive search.'
  id: totrans-234
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-i`：不区分大小写的搜索。'
- en: '`-v`: Invert match, find the opposite of our search pattern: `A`, `-B`, `-C`
    – options providing *context* to our output, by showing A number of lines after,
    B number of lines before, or C number of lines before and after our pattern match.'
  id: totrans-235
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-v`：反向匹配，查找与搜索模式相反的内容；`-A`，`-B`，`-C`——这些选项提供*上下文*，显示模式匹配前后A行、B行或C行的内容。'
- en: '`-n`: Show the line number where the pattern match appears.'
  id: totrans-236
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-n`：显示模式匹配出现的行号。'
- en: Let's continue our quest to use CLI-based utilities that can do important things
    on text content by moving on to look at the `sed` command in our next recipe.
    That will also give us some more scope to further our knowledge about regular
    expressions, as `sed` can use them to be even more useful than its usual, vanilla
    self.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们继续使用基于命令行界面的工具来处理文本内容，接下来我们将看看`sed`命令。这也将为我们提供更多的机会来扩展对正则表达式的理解，因为`sed`可以使用正则表达式，使它比常规的功能更为强大。
- en: There's more…
  id: totrans-238
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多内容…
- en: 'If you need more information about `grep` in Linux, you can check out the following
    links:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你需要更多关于Linux中`grep`的信息，可以查看以下链接：
- en: '`grep` man page: [https://man7.org/linux/man-pages/man1/grep.1p.html](https://man7.org/linux/man-pages/man1/grep.1p.html%0D)'
  id: totrans-240
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`grep`手册页面：[https://man7.org/linux/man-pages/man1/grep.1p.html](https://man7.org/linux/man-pages/man1/grep.1p.html%0D)'
- en: '20 useful `grep` command examples in Linux: [https://www.linuxbuzz.com/grep-command-examples-linux/](https://www.linuxbuzz.com/grep-command-examples-linux/%0D)'
  id: totrans-241
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Linux中20个有用的`grep`命令示例：[https://www.linuxbuzz.com/grep-command-examples-linux/](https://www.linuxbuzz.com/grep-command-examples-linux/%0D)
- en: 'Regular expressions in `grep`: [https://linuxize.com/post/regular-expressions-in-grep/](https://linuxize.com/post/regular-expressions-in-grep/%0D)'
  id: totrans-242
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`grep`中的正则表达式：[https://linuxize.com/post/regular-expressions-in-grep/](https://linuxize.com/post/regular-expressions-in-grep/%0D)'
- en: 'Stanford''s regular expression cheat sheet: [http://stanford.edu/~wpmarble/webscraping_tutorial/regex_cheatsheet.pdf](http://stanford.edu/~wpmarble/webscraping_tutorial/regex_cheatsheet.pdf%0D)'
  id: totrans-243
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 斯坦福大学的正则表达式备忘单：[http://stanford.edu/~wpmarble/webscraping_tutorial/regex_cheatsheet.pdf](http://stanford.edu/~wpmarble/webscraping_tutorial/regex_cheatsheet.pdf%0D)
- en: Using sed
  id: totrans-244
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用sed
- en: In addition to our discussion about manipulating text, we absolutely must discuss
    `sed`. It's a go-to tool to solve so many problems where quick solutions are needed
    and a lot of text is involved. I can list more than a few examples just from the
    past couple of years where it saved my skin. For example, I had a couple of projects
    that required migrating WordPress sites from one domain to another. As it was
    something that needed to be done in a flash, testing migration modules wasn't
    an option. The simpler way was to just export the MySQL database, change *domain1*
    to *domain2*, and check whether it worked. Later, I had a couple more projects
    like that where it wasn't just a domain name change; subdomain name changes were
    needed too, and so on. Keeping in mind that it would take me weeks to do this
    manually on a database that was gigabytes in size – yes, `sed` really helped me
    out in those jams. Let's discuss the merits of using `sed` and learn by working
    on a couple of examples. In the last two chapters of this book, we're also going
    to go through some of these WordPress-based examples so that we can see how that's
    done in a jiffy.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 除了我们讨论的文本处理问题，我们还必须讨论一下`sed`。它是一个解决许多需要快速处理大量文本问题的得力工具。过去几年里，我有不少案例，`sed`在其中帮了我大忙。例如，我有几个项目需要将WordPress网站从一个域名迁移到另一个域名。由于这项工作必须快速完成，测试迁移模块不可行。更简单的办法是直接导出MySQL数据库，将*domain1*改为*domain2*，然后检查是否有效。后来，我又做了几个类似的项目，这次不仅是域名的变更，还需要更改子域名等。考虑到如果手动处理一个几GB大小的数据库可能需要几周时间——是的，`sed`在这些困境中确实帮了我不少忙。让我们讨论一下使用`sed`的优点，并通过一些实例来学习。在本书的最后两章，我们还会通过一些基于WordPress的实例，快速演示如何使用`sed`来处理这些任务。
- en: Getting ready
  id: totrans-246
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: Let's continue using the `cli2` machine from the previous recipe. If it's shut
    down, turn it back on so that we can learn about using `sed`.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 继续使用前面配方中的`cli2`机器。如果它已经关闭，重新启动它，让我们学习如何使用`sed`。
- en: How to do it…
  id: totrans-248
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作…
- en: When we're using `cut`, we are working with standard-formatted input that needs
    to be transformed in some way. When we're using `grep`, we are looking to find
    a text sample just for the purpose of finding that text sample. What happens if
    we need to find some text sample and change it to something else?
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们使用`cut`时，我们处理的是需要转换的标准格式输入。当我们使用`grep`时，我们只是为了找到某个文本样本而进行搜索。如果我们需要找到某个文本样本并将其替换为其他内容呢？
- en: For most users, the answer is, *I'm going to open my favorite editor and do
    a search and replace*.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 对大多数用户来说，答案是，*我会打开我最喜欢的编辑器，进行查找和替换*。
- en: Precisely. And that's what `sed` is mostly about, especially if we have a file
    that's really big, gigabytes and more in size. It's about having the capability
    to do a search and replace, based on text patterns and regular expressions, without
    having to open an editor.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 没错。这就是`sed`的主要功能，尤其是当我们处理一个非常大的文件，大小达到几GB甚至更大时。它的关键在于能够基于文本模式和正则表达式进行查找和替换，而无需打开编辑器。
- en: Have you ever tried to open a 1 GB text file in Notepad or Wordpad to do search
    and replace, and if so, how did that work out for you? Let alone having to read
    multiple large files on multiple systems, especially non-Windows systems?
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 你有没有尝试过在记事本或Wordpad中打开一个1GB的文本文件，进行查找和替换？如果试过，你觉得效果如何？更不用说需要在多个系统上阅读多个大型文件，尤其是在非Windows系统上？
- en: 'Let''s do some simple, a bit complicated, and more complicated scenarios with
    `sed`. The first scenario is going to be related to inserting and appending a
    bit of text:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过一些简单的、稍复杂的和更复杂的场景来练习`sed`。第一个场景将涉及插入和附加一些文本：
- en: '[PRE8]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Let''s check the result of this command:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们检查一下这个命令的结果：
- en: '![Figure 8.24 – First example of using the sed command'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: '![Figure 8.24 – 使用sed命令的第一个示例'
- en: '](img/Figure_8.24_B16269.jpg)'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_8.24_B16269.jpg)'
- en: Figure 8.24 – First example of using the sed command
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: Figure 8.24 – 使用sed命令的第一个示例
- en: The `-i` switch in this command does inline replacement. Keeping in mind that
    we used `sed` without any additional options, it didn't replace anything with
    anything, just inserted the line before the `echo` command, although logic suggests
    that the `echo` command's output should've been first.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 此命令中的 `-i` 开关执行内联替换。记住，我们在没有任何额外选项的情况下使用 `sed`，它并没有进行任何替换，只是在 `echo` 命令之前插入了该行，尽管逻辑上应该是
    `echo` 命令的输出应该最先出现。
- en: 'Generally speaking, `sed` has the following syntax:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 一般来说，`sed` 具有以下语法：
- en: '[PRE9]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'As we can see, in our previous example, we didn''t use any options at the beginning
    or end of the `sed` quotes; we only used source text. `sed` can also be used to
    extract specific lines from a file. For example, let''s say that we want to extract
    lines 5-10 from the `/var/log/messages` file in our `cli2` CentOS machine:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，在之前的示例中，我们在 `sed` 引号的开始和结束处没有使用任何选项；我们只使用了源文本。`sed` 还可以用来从文件中提取特定的行。例如，假设我们要从
    `cli2` CentOS 机器中的 `/var/log/messages` 文件中提取第 5 到第 10 行：
- en: '![Figure 8.25 – Using sed to extract a specific part of a text file'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 8.25 – 使用 sed 提取文本文件的特定部分'
- en: '](img/Figure_8.25_B16269.jpg)'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_8.25_B16269.jpg)'
- en: Figure 8.25 – Using sed to extract a specific part of a text file
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.25 – 使用 sed 提取文本文件的特定部分
- en: The default way of operation for `sed` is to print every line, and if there
    is a substitution being made by our source/destination text configuration, it
    will print the substituted text instead of printing the original one. That's why
    we have `-n`, as we don't want to print any new lines as we're not doing any kind
    of substitution. `'5,10p'` means print from lines 5 to 10.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: '`sed` 的默认操作方式是打印每一行，如果源/目标文本配置中有替换操作，它将打印替换后的文本，而不是打印原始文本。这就是为什么我们使用 `-n`，因为我们不想打印任何新行，毕竟我们没有做任何替换。`''5,10p''`
    表示打印第 5 到第 10 行。'
- en: 'We can also do the opposite of that – let''s say, we want to print all lines
    from a file, and delete lines 5 to 10\. We can use the following command to do
    that:'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以做相反的操作 —— 假设我们想打印文件中的所有行，并删除第 5 到第 10 行。我们可以使用以下命令来实现：
- en: '[PRE10]'
  id: totrans-268
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'We can also use `sed` to display some lines that are not successive in a text
    file, for example, display lines 20-25 and 40-100 in `somefile.txt` (`-e` used
    per expression):'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以使用 `sed` 来显示文本文件中不连续的某些行，例如，显示 `somefile.txt` 中的第 20-25 行和第 40-100 行（每个表达式使用
    `-e`）：
- en: '[PRE11]'
  id: totrans-270
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: But that's all just using `sed` for some very pedestrian stuff. Let's now start
    using it for what we'd mostly use it for, which is string replacement.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 但这仅仅是用 `sed` 做一些非常基础的操作。现在让我们开始使用它来进行我们通常会使用它的任务——字符串替换。
- en: 'Let''s say that we have a text file called `sample.txt` with the following
    content:'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们有一个名为 `sample.txt` 的文本文件，内容如下：
- en: '*This camera produces some weird sounds. Sometimes it buzzes, sometimes it
    squeals, and always manages to somehow produce un-camera-like high-pitched squeal
    that should only be audible to dolphins and whales. As a camera, it''s good. As
    a camera with ability to record sound, it''s useless. So, we need a camera.*'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: '*这台相机会发出一些奇怪的声音。有时它会发出嗡嗡声，有时会尖叫，总是能够发出某种不符合相机特征的高频尖叫声，只有海豚和鲸鱼才能听到。作为相机，它不错；作为一台能录制声音的相机，它没用。所以，我们需要一台相机。*'
- en: 'Our first `sed`-based task is going to be to replace all instances of `camera`
    with `microphone`. For that, we need to use the following command:'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的第一个基于 `sed` 的任务是将所有出现的 `camera` 替换为 `microphone`。为此，我们需要使用以下命令：
- en: '[PRE12]'
  id: totrans-275
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'As expected, the word `camera` gets replaced with the word `microphone` in
    the console, and the end result looks like this:'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 正如预期的那样，`camera` 被替换成了 `microphone`，在控制台中显示，最终结果如下：
- en: '![Figure 8.26 – Using sed to replace words without saving these changes to
    our original file'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 8.26 – 使用 sed 替换单词，但不将这些更改保存到我们的原始文件中'
- en: '](img/Figure_8.26_B16269.jpg)'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_8.26_B16269.jpg)'
- en: Figure 8.26 – Using sed to replace words without saving these changes to our
    original file
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.26 – 使用 sed 替换单词，但不将这些更改保存到我们的原始文件中
- en: 'If we want to replace `camera` with `microphone` and for these changes to be
    saved to the original file, we need to use the following command:'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们希望将 `camera` 替换为 `microphone`，并且希望这些更改保存到原始文件中，我们需要使用以下命令：
- en: '[PRE13]'
  id: totrans-281
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'As expected, this is the end result:'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 正如预期的那样，最终结果如下：
- en: '![Figure 8.27 – Using sed to replace words and saving those changes to the
    original file'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 8.27 – 使用 sed 替换单词并将更改保存到原始文件中'
- en: '](img/Figure_8.27_B16269.jpg)'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_8.27_B16269.jpg)'
- en: Figure 8.27 – Using sed to replace words and saving those changes to the original
    file
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.27 – 使用 sed 替换单词并将更改保存到原始文件中
- en: The `sed` options `s` and `g` are for searching for a word or regular expression
    and then replacing it globally. By using the `-i` switch, we made that replacement
    operation in place, which means saving replacement changes to the original file.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: '`sed`选项`s`和`g`用于搜索一个单词或正则表达式，然后全局替换它。通过使用`-i`开关，我们使得替换操作在原地进行，这意味着将替换的更改保存到原始文件中。'
- en: 'Some more examples are as follows:'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是一些更多的示例：
- en: 'a) Insert blank lines for each non-empty line in the original file:'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: a) 为每个原始文件中的非空行插入空白行：
- en: '[PRE14]'
  id: totrans-289
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'b) Keep the original file content by creating a backup file and do an inline
    replacement in the original file:'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: b) 通过创建一个备份文件来保留原始文件内容，并在原始文件中进行内联替换：
- en: '[PRE15]'
  id: totrans-291
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'c) Replace the word `somethingtochange` with `somethingtobechangedto` when
    the `practice` string appears in the line:'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: c) 当`practice`字符串出现在行中时，将`somethingtochange`替换为`somethingtobechangedto`：
- en: '[PRE16]'
  id: totrans-293
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'd) Negation of the previous statement: Replace `somethingtochange` with `somethingtochangeto`
    and only replace it if the `practice` string does not appear in the line:'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: d) 否定前述语句：将`somethingtochange`替换为`somethingtochangeto`，并且仅在`practice`字符串不出现在该行时才进行替换：
- en: '[PRE17]'
  id: totrans-295
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'e) We can delete the line that matches some pattern:'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: e) 我们可以删除与某些模式匹配的行：
- en: '[PRE18]'
  id: totrans-297
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'f) Let''s search for a number inline and append a currency symbol before the
    number (regular expression for finding numbers used, as well as a backslash for
    proper quoting):'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: f) 让我们在内联中搜索一个数字，并在数字前面加上货币符号（这里使用了查找数字的正则表达式，并且为了正确引用使用了反斜杠）：
- en: '[PRE19]'
  id: totrans-299
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'g) Let''s replace `/bin/bash` with `/bin/tcsh` in `/etc/password` (a regular
    expression isn''t needed here, but we have to use the `\` character for correct
    interpretation of the `/` character as the `/` character is a special character):'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: g) 让我们将`/bin/bash`替换为`/bin/tcsh`，在`/etc/password`中（这里不需要正则表达式，但我们必须使用`\`字符来正确解释`/`字符，因为`/`是一个特殊字符）：
- en: '[PRE20]'
  id: totrans-301
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: As we can see, `sed` is a very powerful tool that can be used to do a lot of
    changes *on the fly*. We are going to show some more examples of using `sed` in
    scripts later in this book, specifically in the last two chapters with shell script
    examples. That will give us further insight into `sed` and its usefulness in everyday
    work.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，`sed`是一个非常强大的工具，可以用来进行许多*即时*的更改。稍后在本书的最后两章中，我们将展示一些在脚本中使用`sed`的更多示例，特别是使用Shell脚本的示例。这将进一步加深我们对`sed`的理解，以及它在日常工作中的实用性。
- en: How it works…
  id: totrans-303
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的……
- en: As a command-line text replacement utility, `sed` requires us to *explain* what
    we want to do to it. That's the reason why the structure of `sed` commands seems
    a bit *descriptive* – that's just because it is. It also has a lot of options
    and switches, which add to the overall usability and possible usage scenarios.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 作为一个命令行文本替换工具，`sed`要求我们*解释*我们想要做的事情。这就是为什么`sed`命令的结构看起来有点*描述性*——那是因为它本来就是这样。它还有很多选项和开关，增加了其整体的可用性和可能的使用场景。
- en: 'The basic command structure is usually something like this:'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 基本的命令结构通常是这样的：
- en: '[PRE21]'
  id: totrans-306
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Or, it might be like this:'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，可能是这样的：
- en: '[PRE22]'
  id: totrans-308
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Of course, `sed` is often used in scripts, either standalone or as a part of
    a serial pipeline, something like this:'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，`sed`通常在脚本中使用，无论是独立脚本还是作为串行管道的一部分，类似这样：
- en: '[PRE23]'
  id: totrans-310
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Whichever way we use `sed`, it's essential to learn at least some of its switches
    and settings, starting with the most commonly used ones – `s` and `g` inside `sed`
    expressions and `-i` as a command-line parameter.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 无论我们如何使用`sed`，至少学习一些它的开关和设置都是必要的，从最常用的开始——`sed`表达式中的`s`和`g`以及作为命令行参数的`-i`。
- en: 'Say we have a command such as the following:'
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们有如下命令：
- en: '[PRE24]'
  id: totrans-313
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Obviously, this has multiple important options. The `-i` option, as we mentioned,
    is all about interactive change that's going to implement our search-and-replace
    criteria in the original file. Without it, we are going to get results from our
    `sed` command to the screen, basically results written to the console. Options
    inside the quotes – `s` and `g` – are the most-used `sed` options, and they mean
    search and globally replace, that is, in the whole file.
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，这里有多个重要的选项。正如我们之前提到的，`-i`选项就是实现我们搜索和替换标准的交互式更改，它将直接在原始文件中应用。如果没有它，我们会看到`sed`命令的结果输出到屏幕上，基本上是结果写入控制台。引号内的选项——`s`和`g`——是最常用的`sed`选项，表示搜索并全局替换，即在整个文件中进行替换。
- en: 'We could do the same thing without the `-i` option, by doing this:'
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以不使用`-i`选项，做如下操作：
- en: '[PRE25]'
  id: totrans-316
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: But, as you might imagine, this requires more typing and is generally more complicated.
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，正如你可能想象的那样，这需要更多的输入，一般来说会更复杂。
- en: The `sed` command-line option `-n` can be used to suppress output to the terminal,
    and that's the reason why it's used often. If we have a large text file that we're
    modifying and we aren't using the `-i` option, this might be the go-to option
    to use if we don't want our console filled with text data.
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: '`sed` 命令行选项 `-n` 可以用来抑制终端输出，这也是它经常被使用的原因。如果我们有一个大文本文件需要修改，并且没有使用 `-i` 选项，那么如果我们不想让控制台被文本数据填满，这可能是我们首选的选项。'
- en: 'One more very useful option is the `-f` option, as it allows us to use an input
    `sed` file with replacement definitions. Say we run the following command:'
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个非常有用的选项是 `-f` 选项，它允许我们使用带有替换定义的输入 `sed` 文件。假设我们运行以下命令：
- en: '[PRE26]'
  id: totrans-320
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'We create a `seddefinitionfile.sed` file that contains this:'
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建了一个名为 `seddefinitionfile.sed` 的文件，内容如下：
- en: '[PRE27]'
  id: totrans-322
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: We can use these options to do multiple `sed` transformations in one command.
    We just need to create `sed` definitions in the file and use it.
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用这些选项在一个命令中进行多个 `sed` 转换。我们只需要在文件中创建 `sed` 定义并使用它。
- en: The next chapter in this book is going to introduce us to the world of shell
    scripting – and the whole second half of the book is about shell scripting. We
    will get to use all the tools that we discussed up to now there, and combine them
    to create shell scripts, some of the most used programming-based administration
    tools ever. Take a short break and get ready to shell script!
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 本书的下一章将向我们介绍 Shell 脚本的世界——整本书的后半部分都将涉及 Shell 脚本。我们将使用到迄今为止讨论过的所有工具，并将它们结合起来创建
    Shell 脚本，这些脚本是最常用的基于编程的管理工具之一。休息一下，准备好进行 Shell 脚本编写吧！
- en: There's more…
  id: totrans-325
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多……
- en: 'If you need more information about networking in CentOS and Ubuntu, make sure
    that you check out the following:'
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你需要更多关于 CentOS 和 Ubuntu 网络方面的信息，确保查看以下内容：
- en: '`sed` manual page: [https://man7.org/linux/man-pages/man1/sed.1p.html](https://man7.org/linux/man-pages/man1/sed.1p.html%0D)'
  id: totrans-327
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`sed` 手册页面: [https://man7.org/linux/man-pages/man1/sed.1p.html](https://man7.org/linux/man-pages/man1/sed.1p.html%0D)'
- en: '50 `sed` command examples: [https://linuxhint.com/50_sed_command_examples/](https://linuxhint.com/50_sed_command_examples/%0D)'
  id: totrans-328
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '50 个 `sed` 命令示例: [https://linuxhint.com/50_sed_command_examples/](https://linuxhint.com/50_sed_command_examples/%0D)'
- en: '`sed` quick reference guide: https://kwiki.kryptsec.com/books/sed-editor/page/sed-quick-reference-guide'
  id: totrans-329
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`sed` 快速参考指南: [https://kwiki.kryptsec.com/books/sed-editor/page/sed-quick-reference-guide](https://kwiki.kryptsec.com/books/sed-editor/page/sed-quick-reference-guide)'
