- en: '*Chapter 6*: Shell-Based Software Management'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第 6 章*：基于 Shell 的软件管理'
- en: Copying content over a network is usually done as a manual process – for example,
    we just use `scp` or `FTP` to transfer a file and that's that. But what happens
    if we need to make this process a permanent one? We then need to figure out a
    way to perform file/directory synchronization, which is what `rsync` is all about.
    That being said, with all of the security-related incidents in the past 5+ years,
    it's always a good idea to implement some kind of encryption, so using `ssh` and
    `scp` seems like a reasonable approach. And that's exactly what we are going to
    do.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 通过网络复制内容通常是一个手动过程——例如，我们可以使用 `scp` 或 `FTP` 传输文件，仅此而已。但如果我们需要将此过程变为常规操作呢？我们就需要找到一种方法来执行文件/目录同步，这正是
    `rsync` 的作用。话虽如此，考虑到过去 5 年以上的安全事件，实施某种加密始终是一个好主意，所以使用 `ssh` 和 `scp` 看起来是合理的做法。这正是我们接下来要做的。
- en: 'In this chapter, we are going to learn about the following topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将学习以下主题：
- en: Using `dnf` and `apt` for package management
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `dnf` 和 `apt` 进行包管理
- en: Using additional repositories, streams, and profiles
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用额外的仓库、流和配置文件
- en: Creating custom repositories
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建自定义仓库
- en: Compiling third-party software
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编译第三方软件
- en: Technical requirements
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: For these recipes, we're going to use two Linux machines – we can use the `cli1`
    and `cli2` virtual machines from our previous recipes. These recipes are doable
    both on CentOS and/or Ubuntu, so there is no reason to use separate virtual machines
    for these scenarios.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这些教程，我们将使用两台 Linux 机器——可以使用我们之前教程中的`cli1`和`cli2`虚拟机。这些教程在 CentOS 和/或 Ubuntu
    上都能进行，因此没有必要为这些场景使用不同的虚拟机。
- en: So, let's start our virtual machines, and let's get cracking!
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，让我们启动虚拟机，开始吧！
- en: Using dnf and apt for package management
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 dnf 和 apt 进行包管理
- en: Packages and package groups are different ways of deploying software to our
    CentOS and Ubuntu virtual machines. A package is nothing more than a stack of
    files that can be installed on our machine in an automated fashion, without our
    manual input. Package groups are more of a RedHat/CentOS concept. Just like the
    term suggests, they are a way of grouping packages into larger groups so that
    we can use these groups to install multiple packages without manually specifying
    every single package from the group. Let's learn how to use them to our benefit,
    specifically, for deployment purposes.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 包和包组是两种不同的软件部署方式，用于将软件安装到我们的 CentOS 和 Ubuntu 虚拟机上。一个包就是一堆可以自动化安装到我们机器上的文件，无需人工干预。包组更多是
    RedHat/CentOS 的概念。顾名思义，它们是将多个包分组的一种方式，方便我们一次性安装多个包，而不需要手动指定每一个包。让我们学习如何利用它们来达到我们的目的，特别是在部署方面。
- en: Getting ready
  id: totrans-12
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备就绪
- en: Let's continue using our `cli1` and `cli2` machines for this one, so make sure
    that they're powered on and ready to go. We are going to use `cli1` for the `apt`
    part of this recipe, and `cli2` for the `yum/dnf` part, as `cli1` is Ubuntu-based
    and `cli2` is CentOS-based.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将继续使用 `cli1` 和 `cli2` 机器进行本教程，请确保它们已经开机并准备就绪。我们将使用 `cli1` 进行 `apt` 部分的操作，使用
    `cli2` 进行 `yum/dnf` 部分的操作，因为 `cli1` 基于 Ubuntu，而 `cli2` 基于 CentOS。
- en: How to do it…
  id: totrans-14
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作……
- en: 'Let''s start with the basics of `yum` and `dnf` for CentOS on cli2\. Let''s
    list all the available packages on the system:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从 `yum` 和 `dnf` 在 cli2 上的基本操作开始。首先，我们列出系统上所有可用的包：
- en: '[PRE0]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The output should look like this (abbreviated):'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 输出应如下所示（已简化）：
- en: '![Figure 6.1 – Shortened yum list output'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 6.1 – 简化的 yum 列表输出'
- en: '](img/Figure_6.1_B16269.jpg)'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_6.1_B16269.jpg)'
- en: Figure 6.1 – Shortened yum list output
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.1 – 简化的 yum 列表输出
- en: We've shortened this screenshot in *Figure 6.1* as it contains thousands of
    packages. There are three columns in this output. Going from left to right, the
    first column is the package name, the second column is the package version, and
    the third one is the package repository where that specific package is located.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经在 *图 6.1* 中简化了此截图，因为它包含了成千上万的包。这个输出中有三列。按照从左到右的顺序，第一列是包的名称，第二列是包的版本，第三列是该包所在的包仓库。
- en: 'If we want to find out more details about a package, we can use `yum info`
    (or `dnf info`), for example:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想了解更多有关某个包的详细信息，可以使用 `yum info`（或 `dnf info`），例如：
- en: '![Figure 6.2 – Getting information regarding a package'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 6.2 – 获取包信息'
- en: '](img/Figure_6.2_B16269.jpg)'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_6.2_B16269.jpg)'
- en: Figure 6.2 – Getting information regarding a package
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.2 – 获取包信息
- en: By using this command, we get much more information about the package. Also,
    please note that we didn't use `x86_64` in the package name, as it's not necessary.
    Bearing in mind the fact that we're using a 64-bit distribution, it becomes understandable
    that using *architecture* in the package name is almost always unnecessary.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用此命令，我们可以获取更多关于该软件包的信息。另外，请注意，我们没有在软件包名称中使用`x86_64`，因为它不是必须的。考虑到我们使用的是64位发行版，可以理解在软件包名称中使用*架构*几乎总是不必要的。
- en: 'Let''s now install a package, for example, `mc` (Midnight Commander):'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们安装一个软件包，例如`mc`（Midnight Commander）：
- en: '![Figure 6.3 – Installing a package'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 6.3 – 安装软件包](img/Figure_6.3_B16269.jpg)'
- en: '](img/Figure_6.3_B16269.jpg)'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_6.3_B16269.jpg)'
- en: Figure 6.3 – Installing a package
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.3 – 安装软件包
- en: The beauty of Linux package systems is evident here. It's not only about the
    fact that a package gets installed without hassle – dependencies get installed
    by default, as well, and that's really useful. Back in the days when we only had
    the `rpm` command to install packages in CentOS, it was much more difficult to
    resolve dependencies. We had to deploy them before deploying the package that
    we wanted to deploy, and in a specific order, which complicated the deployment
    process.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: Linux软件包系统的美妙之处在于此处显现出来。它不仅仅是关于软件包可以毫不费力地安装——依赖项也会默认安装，这非常有用。在过去，当我们只能使用`rpm`命令在CentOS中安装软件包时，解决依赖关系要困难得多。我们必须先部署它们，然后再部署我们想要部署的软件包，而且必须按特定顺序，这使得部署过程更加复杂。
- en: 'We can remove that package by using the following command:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用以下命令来删除该软件包：
- en: '[PRE1]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'If we want to find which package installed a specific file, we can use the
    `yum provides` or `dnf provides` command:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想查找哪个软件包安装了特定文件，可以使用`yum provides`或`dnf provides`命令：
- en: '![Figure 6.4 – Checking which package installed a specific file'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 6.4 – 检查哪个软件包安装了特定文件](img/Figure_6.4_B16269.jpg)'
- en: '](img/Figure_6.4_B16269.jpg)'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_6.4_B16269.jpg)'
- en: Figure 6.4 – Checking which package installed a specific file
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.4 – 检查哪个软件包安装了特定文件
- en: 'If we need to find package dependencies (which package depends on which package),
    we can use the following command:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们需要查找软件包依赖关系（哪个软件包依赖于哪个软件包），可以使用以下命令：
- en: '![Figure 6.5 – Checking package dependencies'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 6.5 – 检查软件包依赖关系](img/Figure_6.5_B16269.jpg)'
- en: '](img/Figure_6.5_B16269.jpg)'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_6.5_B16269.jpg)'
- en: Figure 6.5 – Checking package dependencies
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.5 – 检查软件包依赖关系
- en: We used `bash` in this example, but we could have used any package name for
    this query.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这个示例中使用了`bash`，但我们可以使用任何软件包名称来进行查询。
- en: 'We can also use `dnf` and `yum` to download and install packages locally. Let''s
    say that we want to download and install the `joe` editor locally. This is how
    we''d do it:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以使用`dnf`和`yum`来本地下载和安装软件包。假设我们想要在本地下载并安装`joe`编辑器，我们可以这样操作：
- en: '![Figure 6.6 – Downloading and installing a package manually from a local disk'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 6.6 – 从本地磁盘手动下载并安装软件包](img/Figure_6.6_B16269.jpg)'
- en: '](img/Figure_6.6_B16269.jpg)'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_6.6_B16269.jpg)'
- en: Figure 6.6 – Downloading and installing a package manually from a local disk
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.6 – 从本地磁盘手动下载并安装软件包
- en: 'We can, of course, search for packages by using the `yum search` or `dnf search`
    command:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 我们当然可以使用`yum search`或`dnf search`命令来搜索软件包：
- en: '![Figure 6.7 – Using the yum/dnf search command'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 6.7 – 使用yum/dnf搜索命令](img/Figure_6.7_B16269.jpg)'
- en: '](img/Figure_6.7_B16269.jpg)'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_6.7_B16269.jpg)'
- en: Figure 6.7 – Using the yum/dnf search command
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.7 – 使用yum/dnf搜索命令
- en: Sometimes, the list of these packages is going to be quite long, so additional
    filtering might be required.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，这些软件包的列表可能会非常长，因此可能需要额外的筛选。
- en: 'Let''s now talk a bit about package groups, starting with the `dnf grouplist`
    command:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们谈谈软件包组，从`dnf grouplist`命令开始：
- en: '![Figure 6.8 – Using dnf group list commands gives us a list of package groups'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 6.8 – 使用dnf group list命令可以得到软件包组列表](img/Figure_6.8_B16269.jpg)'
- en: '](img/Figure_6.8_B16269.jpg)'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_6.8_B16269.jpg)'
- en: Figure 6.8 – Using dnf group list commands gives us a list of package groups
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.8 – 使用dnf group list命令可以得到软件包组列表
- en: 'The output of that command is going to give us the names of **package groups**
    that we can use for much *larger* package deployments. For example, let''s check
    what''s going to happen if we install the **Development Tools** package group
    by issuing the following command:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 该命令的输出将显示我们可以用于更*大规模*软件包部署的**软件包组**名称。例如，让我们检查如果我们安装**开发工具**软件包组，执行以下命令时会发生什么：
- en: '[PRE2]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'This command will ask us whether we want to download and deploy more than 100
    packages. If we answer *yes*, that''s exactly what''s going to happen (the screenshot
    is rendered smaller on purpose, just to show the end of the command output):'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 此命令将询问我们是否要下载并部署超过 100 个软件包。如果我们回答*是*，那么这正是即将发生的事情（截图故意渲染得较小，仅显示命令输出的结尾）：
- en: '![Figure 6.9 – Installing a package group'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 6.9 – 安装软件包组'
- en: '](img/Figure_6.9_B16269.jpg)'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_6.9_B16269.jpg)'
- en: Figure 6.9 – Installing a package group
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.9 – 安装软件包组
- en: As we can see, having the ability to deploy package groups greatly increases
    the speed of package deployment.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，能够部署软件包组大大提高了包的部署速度。
- en: 'The next step in our process is to cover everything that we''ve covered in
    this recipe, but to deliver it on Ubuntu. So, let''s switch to our `cli1` machine
    and start from scratch. First, let''s describe a couple of commands that we''re
    interested in:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 我们过程中的下一步是覆盖我们在这个配方中涉及的所有内容，但将其应用于 Ubuntu。所以，让我们切换到我们的 `cli1` 机器并从头开始。首先，我们来描述几个我们感兴趣的命令：
- en: '`apt-get` or `apt`: Commands used to install, remove, upgrade, and update packages'
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`apt-get` 或 `apt`：用于安装、移除、升级和更新包的命令'
- en: '`apt-cache`: Mostly used to search and find information about packages'
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`apt-cache`：主要用于搜索和查找有关包的信息'
- en: 'Let''s now learn to use them. First, we are going to discuss regular operations
    – installing, removing, purging, updating, and upgrading. Let''s install a package,
    for example, `mc`:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们学习如何使用它们。首先，我们将讨论常规操作——安装、移除、清除、更新和升级。我们来安装一个包，例如 `mc`：
- en: '![Figure 6.10 – Using apt-get to install a package'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 6.10 – 使用 apt-get 安装包'
- en: '](img/Figure_6.10_B16269.jpg)'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_6.10_B16269.jpg)'
- en: Figure 6.10 – Using apt-get to install a package
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.10 – 使用 apt-get 安装包
- en: 'Now, let''s remove it:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们移除它：
- en: '![Figure 6.11 – Using apt-get to remove a package'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 6.11 – 使用 apt-get 移除包'
- en: '](img/Figure_6.11_B16269.jpg)'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_6.11_B16269.jpg)'
- en: Figure 6.11 – Using apt-get to remove a package
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.11 – 使用 apt-get 移除包
- en: 'We can see that we have a standard situation – the package *was* removed, but
    some of its dependencies weren''t. We can do that, as well, by using the `apt-get
    autoremove` command:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到，我们处于标准情况——包*已*移除，但它的一些依赖项没有被移除。我们也可以使用 `apt-get autoremove` 命令来完成这项工作：
- en: '![Figure 6.12 – Removing packages that are no longer needed'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 6.12 – 移除不再需要的包'
- en: '](img/Figure_6.12_B16269.jpg)'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_6.12_B16269.jpg)'
- en: Figure 6.12 – Removing packages that are no longer needed
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.12 – 移除不再需要的包
- en: This is very useful as we're reducing the attack surface of our server (for
    security breaches) by removing unnecessary software packages.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 这非常有用，因为我们通过删除不必要的软件包来减少服务器的攻击面（防止安全漏洞）。
- en: 'Now let''s check what happens if we use the `update` option:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们检查一下使用 `update` 选项时会发生什么：
- en: '![Figure 6.13 – Updating repository and package info'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 6.13 – 更新仓库和软件包信息'
- en: '](img/Figure_6.13_B16269.jpg)'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_6.13_B16269.jpg)'
- en: Figure 6.13 – Updating repository and package info
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.13 – 更新仓库和软件包信息
- en: 'As we can see, `apt` refreshed its package list before the upgrade process
    could happen – these steps are mostly used in sequence – `update` followed by
    `upgrade`:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，`apt` 在升级过程之前刷新了软件包列表——这些步骤大多数是顺序执行的——`update` 后接 `upgrade`：
- en: '![Figure 6.14 – Upgrading available packages – this time, no upgrades are necessary'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 6.14 – 升级可用的包 – 这次不需要升级'
- en: '](img/Figure_6.14_B16269.jpg)'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_6.14_B16269.jpg)'
- en: Figure 6.14 – Upgrading available packages – this time, no upgrades are necessary
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.14 – 升级可用的包 – 这次不需要升级
- en: Interestingly enough, no packages were installed, which is a very rare situation,
    to be honest. Usually, we'd have at least a few packages to be upgraded.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 有趣的是，没有包被安装，这种情况其实非常罕见。通常，我们至少会有一些包需要升级。
- en: Note
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Before we get into the topic of doing dist-upgrade, we are absolutely *NOT*
    recommending this for a production server. Using `dist-upgrade` and `do-release-upgrade`
    is something that we *can* do, but shouldn't. Migration is always a better idea,
    however much time it might take.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们进入 dist-upgrade 主题之前，我们绝对*不*推荐在生产服务器上使用此操作。使用 `dist-upgrade` 和 `do-release-upgrade`
    是我们*可以*做的，但不应该做。迁移总是一个更好的选择，无论它花费多少时间。
- en: 'Let''s now push this situation to the extreme by trying to do `dist-upgrade`,
    followed by `do-release-upgrade`. What the `dist-upgrade apt` option does is simple
    in theory – it tries to prepare our current distribution so that it''s possible
    to upgrade it to the latest one in the branch. At first, it might just be getting
    a couple of new packages. Usually, these packages contain new repositories and
    information about locations, from which `apt` will upgrade our distribution to
    the latest one. Here''s an example:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们通过尝试做`dist-upgrade`，然后再做`do-release-upgrade`来将这种情况推向极限。`dist-upgrade apt`选项的作用理论上很简单——它尝试准备当前的发行版，使其能够升级到分支中的最新版本。起初，它可能只会获取几个新的软件包。通常，这些软件包包含新的仓库和位置信息，`apt`将从这些位置升级我们的发行版到最新版本。以下是一个例子：
- en: '![Figure 6.15 – Using dist-upgrade to get information about new distribution
    versions'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: '![图6.15 – 使用 dist-upgrade 获取新发行版版本信息'
- en: '](img/Figure_6.15_B16269.jpg)'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_6.15_B16269.jpg)'
- en: Figure 6.15 – Using dist-upgrade to get information about new distribution versions
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.15 – 使用 dist-upgrade 获取新发行版版本信息
- en: 'The next step after that one is to use `do-release-upgrade`, a standalone command
    that''s not an `apt` subcommand. We need to remember that this is not an `apt`
    option (there''s no `apt do-release-upgrade`, it''s just `do-release-upgrade`).
    After executing it, our system is going to ask us whether we want to continue
    with the distribution release upgrade:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来的步骤是使用`do-release-upgrade`，这是一个独立的命令，不是`apt`的子命令。我们需要记住，这不是`apt`选项（没有`apt
    do-release-upgrade`，它只是`do-release-upgrade`）。执行后，系统会询问我们是否继续进行发行版升级：
- en: '![Figure 6.16 – Using do-release-upgrade, not to be recommended in production
    environments'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: '![图6.16 – 使用 do-release-upgrade，不建议在生产环境中使用'
- en: '](img/Figure_6.16_B16269.jpg)'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_6.16_B16269.jpg)'
- en: Figure 6.16 – Using do-release-upgrade, not to be recommended in production
    environments
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.16 – 使用 do-release-upgrade，不建议在生产环境中使用
- en: 'If we confirm, the process is going to start, and it''s going to take a while.
    The end result should be an Ubuntu machine that''s fully updated to the latest
    version, with all of the latest package versions. Remember, we specifically mentioned
    that this shouldn''t be done in production – it''s just an extreme example of
    using `apt` capabilities to do a system-wide package upgrade. Hundreds, perhaps
    thousands of packages, will get updated if we do something like that, and the
    process isn''t reversible, so it carries a lot of risk. Try it out on some test
    virtual machine just for practice. If successful, this procedure will upgrade
    to the latest Ubuntu version. The end result, at the time of writing, looks like
    this:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们确认，过程就会开始，并且会持续一段时间。最终结果应该是一个完全更新到最新版本的 Ubuntu 系统，所有的包都更新到最新版本。记住，我们特别提到过，这不应该在生产环境中进行——这只是一个使用`apt`能力进行系统范围包升级的极端例子。如果我们这样做，可能会更新数百甚至数千个软件包，而且这个过程不可逆转，因此风险很大。最好在一些测试虚拟机上练习一下。如果成功，这个过程将升级到最新的
    Ubuntu 版本。写作时，最终结果看起来是这样的：
- en: '![Figure 6.17 – The end result of do-release-upgrade, and in our experience,
    we got lucky this time!'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: '![图6.17 – do-release-upgrade的最终结果，在我们的经验中，这次我们运气不错！'
- en: '](img/Figure_6.17_B16269.jpg)'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_6.17_B16269.jpg)'
- en: Figure 6.17 – The end result of do-release-upgrade, and in our experience, we
    got lucky this time!
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.17 – do-release-upgrade的最终结果，在我们的经验中，这次我们运气不错！
- en: Notice that our Ubuntu machine was upgraded to the latest (21.04) version.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们的 Ubuntu 系统已经升级到最新的（21.04）版本。
- en: 'There are a few more important `apt` commands – for example, for a package
    search, we can use the `apt-cache showpkg package_name` command. Let''s use it,
    for example, on `mc`, a package we installed previously:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一些重要的`apt`命令——例如，进行包搜索时，我们可以使用`apt-cache showpkg package_name`命令。让我们举个例子，使用它来查看我们之前安装的`mc`包：
- en: '![Figure 6.18 – Using apt-get to get package info'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: '![图6.18 – 使用 apt-get 获取包信息'
- en: '](img/Figure_6.18_B16269.jpg)'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_6.18_B16269.jpg)'
- en: Figure 6.18 – Using apt-get to get package info
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.18 – 使用 apt-get 获取包信息
- en: 'There is a somewhat shorter version of the same thing if we use the `apt` command:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们使用`apt`命令，有一个稍短的版本来完成相同的事情：
- en: '![Figure 6.19 – Using apt to get package info – somewhat shorter and more concise'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: '![图6.19 – 使用 apt 获取包信息 – 略短且更简洁'
- en: '](img/Figure_6.19_B16269.jpg)'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_6.19_B16269.jpg)'
- en: Figure 6.19 – Using apt to get package info – somewhat shorter and more concise
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.19 – 使用 apt 获取包信息 – 略短且更简洁
- en: 'If we need to add repositories, we can use the `add-apt-repository` command.
    Let''s say that we want to add an unofficial repository, such as **Personal Package
    Archives** (**PPA**), that is hosted on Launchpad. Generally speaking, we should
    only add *reputable* repositories, and not just *any* repository just because
    it has a certain package that we might need. We are going to use an example here
    – let''s say that we need to install the latest PHP 7.4 version on our Ubuntu
    machine. We can do it like this:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们需要添加仓库，可以使用 `add-apt-repository` 命令。假设我们想要添加一个非官方仓库，如 **个人软件包档案**（**PPA**），它托管在
    Launchpad 上。一般来说，我们应该只添加 *有信誉的* 仓库，而不是因为某个仓库中有我们需要的包就随便添加。我们在这里用一个例子 – 假设我们需要在
    Ubuntu 机器上安装最新的 PHP 7.4 版本。我们可以这样做：
- en: '[PRE3]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'This should be the result if we started `php` from the shell:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们从 shell 启动`php`，应该会得到以下结果：
- en: '![Figure 6.20 – The end result of us using the ppa repository to deploy the
    latest release of PHP 7.4'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 6.20 – 使用 ppa 仓库部署最新 PHP 7.4 版本的最终结果'
- en: '](img/Figure_6.20_B16269.jpg)'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_6.20_B16269.jpg)'
- en: Figure 6.20 – The end result of us using the ppa repository to deploy the latest
    release of PHP 7.4
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.20 – 使用 ppa 仓库部署最新 PHP 7.4 版本的最终结果
- en: This covers all the necessary commands we need for both Ubuntu and CentOS. Let's
    now explain some background information about where some of the more important
    information is stored – for both CentOS (`dnf`/`yum`) and Ubuntu (`apt`/`apt-get`).
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 这涵盖了我们在 Ubuntu 和 CentOS 中需要的所有命令。现在让我们解释一些背景信息，关于一些更重要信息的存储位置 – 适用于 CentOS（`dnf`/`yum`）和
    Ubuntu（`apt`/`apt-get`）。
- en: How it works…
  id: totrans-118
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: '`yum` and `dnf` work in tandem with files located in `/etc/yum.repos.d` repository
    files, as well as the `/etc/yum.conf` configuration file. We covered repository
    files, so let''s now discuss `/etc/yum.conf` and a couple of important configuration
    options that we can use from it. This is a global configuration file for `dnf`
    and `yum` commands.'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: '`yum` 和 `dnf` 与位于 `/etc/yum.repos.d` 仓库文件和 `/etc/yum.conf` 配置文件的文件协同工作。我们已经涵盖了仓库文件，现在让我们来讨论
    `/etc/yum.conf` 以及我们可以从中使用的几个重要配置选项。这是 `dnf` 和 `yum` 命令的全局配置文件。'
- en: 'There are a couple of really useful configuration items that we can manage
    in it. Let''s just illustrate that point by using two commonly used examples.
    Let''s add these two options to it:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个配置文件中，我们可以管理一些非常有用的配置项。让我们通过两个常用的例子来说明这一点。让我们向其中添加这两个选项：
- en: '[PRE4]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: By using these two commands, we instructed `yum`/`dnf` to exclude all `kernel`
    and `open-vm` packages (by name) in any kind of operation, such as a `yum` update
    (which updates all packages on the machine). `gpgcheck=0` sets a global policy
    that tells `yum` and `dnf` *not* to use GPG key checking when working with packages.
    This can also be managed in `/etc/yum.repos.d`, as discussed in our recipe.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这两个命令，我们指示 `yum`/`dnf` 在任何操作中（如 `yum` 更新，它会更新机器上的所有包）排除所有 `kernel` 和 `open-vm`
    包（按名称）。`gpgcheck=0` 设置了一个全局策略，告诉 `yum` 和 `dnf` 在处理包时 *不* 使用 GPG 密钥检查。这也可以在 `/etc/yum.repos.d`
    中进行管理，正如我们在本配方中所讨论的。
- en: 'Ubuntu has a very similar principle; it''s just that directories are different
    as well as the file structure, somewhat. The most important information regarding
    the software repository location is kept in the /`etc/apt` directory, specifically,
    in the `/etc/apt/sources.list` file. Here''s an excerpt:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: Ubuntu 有一个非常相似的原理；只是目录结构和文件结构有所不同。关于软件仓库位置的最重要信息保存在 `/`etc/apt` 目录下，具体来说，是在
    `/etc/apt/sources.list` 文件中。以下是摘录：
- en: '![Figure 6.21 – Main apt configuration file called sources.list'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 6.21 – 主要的 apt 配置文件，名为 sources.list'
- en: '](img/Figure_6.21_B16269.jpg)'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_6.21_B16269.jpg)'
- en: Figure 6.21 – Main apt configuration file called sources.list
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.21 – 主要的 apt 配置文件，名为 sources.list
- en: 'The general structure is simple enough. The second part of our `apt` equation
    is located in the `/etc/apt/sources.list.d` directory. A couple of steps ago,
    we added the PPA repository, and, sure enough, we have a configuration file for
    that repository configuration file there, called `ondrej-ubuntu-php-groovy.list`:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 一般结构足够简单。我们 `apt` 命令的第二部分位于 `/etc/apt/sources.list.d` 目录下。几步前，我们添加了 PPA 仓库，果不其然，我们在这里有一个用于该仓库配置文件的配置文件，叫做
    `ondrej-ubuntu-php-groovy.list`：
- en: '![Figure 6.22 – Additional apt configuration file located at /etc/apt/sources.list.d'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 6.22 – 额外的 apt 配置文件位于 /etc/apt/sources.list.d'
- en: '](img/Figure_6.22_B16269.jpg)'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_6.22_B16269.jpg)'
- en: Figure 6.22 – Additional apt configuration file located at /etc/apt/sources.list.d
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.22 – 额外的 apt 配置文件位于 /etc/apt/sources.list.d
- en: That covers our package and package groups recipe. Let's now move on to the
    next recipe, which is about using modules and module streams.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 这涵盖了我们的软件包和软件包组的配方。接下来让我们进入下一个配方，关于使用模块和模块流。
- en: There's more…
  id: totrans-132
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多……
- en: 'If you need more information about networking in CentOS and Ubuntu, make sure
    that you check out the following resources:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你需要更多关于 CentOS 和 Ubuntu 网络的资料，确保查阅以下资源：
- en: '`https://access.redhat.com/sites/default/files/attachments/rh_yum_cheatsheet_1214_jcs_print-1.pdf`'
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`https://access.redhat.com/sites/default/files/attachments/rh_yum_cheatsheet_1214_jcs_print-1.pdf`'
- en: '`https://fedoraproject.org/wiki/Yum_to_DNF_Cheatsheet`'
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`https://fedoraproject.org/wiki/Yum_to_DNF_Cheatsheet`'
- en: '`https://packagecloud.io/blog/apt-cheat-sheet/`'
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`https://packagecloud.io/blog/apt-cheat-sheet/`'
- en: Using additional repositories, streams, and profiles
  id: totrans-137
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用额外的仓库、流和配置文件
- en: Repositories are the most important objects/locations to manage as they provide
    us with packages and package groups that we can install on our CentOS machine.
    Let's now learn how to manage repositories by using `yum-config-manager` and `dnf`.
    Also, let's get to know some configuration files that are key for this process.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 仓库是最重要的对象/位置，因为它们为我们提供了可以在 CentOS 机器上安装的软件包和软件包组。现在让我们学习如何通过使用`yum-config-manager`和`dnf`来管理仓库。同时，让我们了解一些对这个过程至关重要的配置文件。
- en: Adding to the idea of package groups, which group packages into larger groups,
    `dnf` introduced the idea of additional modularity. It's all about package organization
    – we want to have simple ways of deploying software – runtimes, applications,
    bits and pieces of software. These concepts also enable us to have control over
    *versions of software* that we want to install, which is really handy. For example,
    let's say that you need to deploy PHP 7.2 and 7.3 on the machine. Doing that manually
    isn't going to be much fun. As we're going to demonstrate by using an example,
    this is much more easily done if we use a module stream.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 在软件包组的基础上，`dnf` 引入了附加模块化的概念。这一切都是关于软件包的组织——我们希望有简单的方式来部署软件——运行时、应用程序、软件的零件。这些概念还使我们能够控制*我们想安装的软件的版本*，这非常方便。例如，假设你需要在机器上部署
    PHP 7.2 和 7.3。手动操作可不会有多么愉快。正如我们通过示例展示的那样，如果使用模块流，这将变得更加简单。
- en: Profiles act as quasi-repositories, without actually being repositories, within
    the `httpd` module has a couple of profiles (`minimal`, `devel`, `common`). The
    minimal profile means just the minimum number of packages that need to be installed
    for `httpd` to work. Unlike that, common is a default profile that's ready for
    production and additionally treated in terms of security (hardened).
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 配置文件作为准仓库存在，实际上并不是仓库，`httpd`模块中有几个配置文件（`minimal`，`devel`，`common`）。minimal 配置文件意味着只安装运行`httpd`所需的最小软件包。与之不同的是，common
    是一个默认配置文件，已准备好生产使用，并且在安全性方面有额外的处理（加固）。
- en: Getting ready
  id: totrans-141
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: Start the `cli2` virtual machine created in the previous recipes. We're going
    to use it to work with streams and profiles on our CentOS machine.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 启动在前面的示例中创建的`cli2`虚拟机。我们将用它来在 CentOS 机器上操作流和配置文件。
- en: How to do it…
  id: totrans-143
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做……
- en: To manage repositories, we have to learn to use two commands – `yum-config-manager`
    and `dnf`. Also, we need to look into the `/etc/yum.conf` file, as well as the
    `/etc/yum.repos.d` directory. `Yum.conf` gives us global `yum` command configuration
    options, and the `/etc/yum.repos.d` directory contains configuration files with
    repository locations.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 为了管理仓库，我们需要学习使用两个命令——`yum-config-manager`和`dnf`。此外，我们还需要查看`/etc/yum.conf`文件，以及`/etc/yum.repos.d`目录。`yum.conf`提供了全局的`yum`命令配置选项，而`/etc/yum.repos.d`目录包含了仓库位置的配置文件。
- en: How it works…
  id: totrans-145
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的……
- en: Let's look at `yum-config-manager` first. This command was introduced in Red
    Hat Enterprise Linux/CentOS 7 to easily add additional repositories to your Red
    Hat Enterprise Linux or CentOS machine. And it does just that – it lets us skip
    the whole manual repository configuration and get straight to business. If we
    didn't have this command, we would need to learn the configuration file options
    for `/etc/yum.repos.d` directory files.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先来看一下`yum-config-manager`。这个命令是在 Red Hat Enterprise Linux/CentOS 7 中引入的，用来方便地将额外的仓库添加到你的
    Red Hat Enterprise Linux 或 CentOS 机器上。它的功能就是让我们跳过繁琐的手动仓库配置，直接开始工作。如果没有这个命令，我们就需要学习`/etc/yum.repos.d`目录文件的配置选项。
- en: 'If we go to the first virtual machine that we installed (source), and list
    the content of the `/etc/yum.repos.d` directory, this is what we''ll get:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们访问第一个安装的虚拟机（源），并列出`/etc/yum.repos.d`目录的内容，这就是我们将看到的内容：
- en: '![Figure 6.23 – /etc/yum.repos.d directory content'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 6.23 – /etc/yum.repos.d 目录内容](img/Figure_6.23_B16269.jpg)'
- en: '](img/Figure_6.23_B16269.jpg)'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_6.23_B16269.jpg)'
- en: Figure 6.23 – /etc/yum.repos.d directory content
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.23 – /etc/yum.repos.d 目录内容
- en: 'Let''s say that we want to add a custom repository, `url`, to our machine.
    We can do this in three different ways. The first approach involves using `yum-package-manager`,
    and that tool requires the `yum-utils` package (`url` is the location of the repository
    that we want to use):'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们想要将一个自定义仓库 `url` 添加到我们的机器中。我们可以通过三种不同的方式来完成这项操作。第一种方法是使用 `yum-package-manager`，该工具需要
    `yum-utils` 包（`url` 是我们想要使用的仓库地址）：
- en: '[PRE5]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'We can also check the list of currently configured repositories by using the
    following command:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以使用以下命令检查当前已配置的仓库列表：
- en: '[PRE6]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'If we need to find the list of currently disabled (unused) repositories, we
    can use the following command:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们需要查找当前被禁用（未使用）仓库的列表，可以使用以下命令：
- en: '[PRE7]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'If we need to enable a disabled repository, we can use the following (`repository_id`
    is a parameter that you can get from the `yum repolist all` command):'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们需要启用一个已禁用的仓库，可以使用以下命令（`repository_id` 是你可以从 `yum repolist all` 命令中获取的参数）：
- en: '[PRE8]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The most obvious problem with using `yum-config-manager` is the fact that there
    are some parameters that we can't assign via that command itself. This is where
    the manual editing of `/etc/yum.repos.d` configuration files comes in handy.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `yum-config-manager` 时最明显的问题是，某些参数无法通过该命令本身分配。这时，手动编辑 `/etc/yum.repos.d`
    配置文件就显得非常有用。
- en: 'This command is being phased out little by little and redirected to its new
    `dnf` counterparts (`dnf config-manager`), just like `yum` is being used in parallel
    with the `dnf` command. If we want to do the same job by using `dnf` tools, we
    can do this:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 这个命令正在逐步淘汰，并重定向到新的 `dnf` 命令（`dnf config-manager`），就像 `yum` 和 `dnf` 命令是并行使用的。如果我们想使用
    `dnf` 工具完成相同的工作，可以这样做：
- en: '[PRE9]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: That will create a new configuration file in the `/etc/yum.repos.d` directory
    with the repository definition and enable it by default.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 这将会在 `/etc/yum.repos.d` 目录下创建一个新的配置文件，并默认启用该仓库。
- en: 'Our next step is going to be to learn a bit about these configuration files,
    as they''re really not all that difficult to understand. Let''s use a repository
    configuration file to explain their concept, for example, `/etc/yum.repos.d/CentOS-Sources.repo`:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来的步骤是了解这些配置文件，它们其实并不难理解。我们可以用一个仓库配置文件来解释它们的概念，例如 `/etc/yum.repos.d/CentOS-Sources.repo`：
- en: '![Figure 6.24 – Part of the /etc/yum.repos.d/CentOS-Sources.repo file'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 6.24 – /etc/yum.repos.d/CentOS-Sources.repo 文件的一部分](img/Figure_6.24_B16269.jpg)'
- en: '](img/Figure_6.24_B16269.jpg)'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_6.24_B16269.jpg)'
- en: Figure 6.24 – Part of the /etc/yum.repos.d/CentOS-Sources.repo file
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.24 – /etc/yum.repos.d/CentOS-Sources.repo 文件的一部分
- en: 'Let''s explain these configuration parameters:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们解释这些配置参数：
- en: '`[BaseOS-Source]`is the repository ID. This is what we use in `yum-config-manager`
    or `dnf` to reference repositories.'
  id: totrans-168
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`[BaseOS-Source]` 是仓库 ID。我们在 `yum-config-manager` 或 `dnf` 中使用它来引用仓库。'
- en: The `name` parameter is a description of that repository.
  id: totrans-169
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`name` 参数是该仓库的描述。'
- en: The `baseurl` parameter describes *where* the location of this repository is,
    and it can use a variety of different options – `http`, `https`, `ftp`, or `file`.
    If we create a *local* repository (mount it somewhere on our CentOS machine),
    then the `file` statement will be used to access it.
  id: totrans-170
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`baseurl` 参数描述了*这个*仓库的地址，它可以使用多种不同的协议：`http`、`https`、`ftp` 或 `file`。如果我们创建一个*本地*仓库（将其挂载到
    CentOS 机器上的某个位置），则将使用 `file` 协议来访问它。'
- en: The `gpgcheck` parameter tells `yum/dnf` whether or not to check the `gpg` key
    against the package signatures. If it's `1`, that means that checking is mandatory.
  id: totrans-171
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`gpgcheck` 参数告诉 `yum/dnf` 是否检查 `gpg` 密钥与软件包签名的一致性。如果它是 `1`，则表示检查是强制性的。'
- en: The `enabled` parameter tells `yum/dnf` whether this repository is enabled,
    which means whether `dnf/yum` can use it to get packages. We can also use `yum
    --enablerepo` to enable a certain defined repository by name, or `yum --disablerepo`
    to do the opposite.
  id: totrans-172
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`enabled` 参数告诉 `yum/dnf` 这个仓库是否启用，这意味着 `dnf/yum` 是否可以使用它来获取软件包。我们也可以通过 `yum
    --enablerepo` 启用某个定义的仓库，或者通过 `yum --disablerepo` 禁用它。'
- en: The `gpgkey` parameter tells `yum/dnf` where the `gpg` key for `gpgcheck` is
    located.
  id: totrans-173
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`gpgkey` 参数告诉 `yum/dnf` `gpgcheck` 的 `gpg` 密钥存放位置。'
- en: Let's now move on to the idea of streams and profiles, the logical next step
    in our recipe.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们继续讨论流和配置文件的概念，这是我们操作的逻辑下一步。
- en: 'After we log in to the source machine, let''s use an example to describe what
    streams and profiles are all about. So, let''s use a module stream and profile
    to remove and re-deploy `httpd`. In the first step, we''re going to use the following
    command:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 在登录到源机器后，让我们通过一个示例来描述流和配置文件到底是什么。因此，让我们使用一个模块流和配置文件来删除并重新部署 `httpd`。第一步，我们将使用以下命令：
- en: '[PRE10]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'After the process is complete, let''s do the opposite:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 过程完成后，让我们做相反的操作：
- en: '[PRE11]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Let''s now check the output of the second command:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们检查第二个命令的输出：
- en: '![Figure 6.25 – Using streams and profiles'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 6.25 – 使用流和配置文件'
- en: '](img/Figure_6.25_B16269.jpg)'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_6.25_B16269.jpg)'
- en: Figure 6.25 – Using streams and profiles
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.25 – 使用流和配置文件
- en: We can see that the deployment process automatically defaulted to using the
    `httpd/common` profile and the default stream (**AppStream**) repository.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到，部署过程自动默认使用了 `httpd/common` 配置文件和默认流 (**AppStream**) 仓库。
- en: 'Let''s do another example. We can check the list of all available modules by
    using the following command:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们做另一个示例。我们可以使用以下命令查看所有可用模块的列表：
- en: '[PRE12]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'This will give us the following result:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 这将为我们提供以下结果：
- en: '![Figure 6.26 – dnf module list, with versions and profiles; abridged output'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 6.26 – dnf 模块列表，包含版本和配置文件；简化输出'
- en: '](img/Figure_6.26_B16269.jpg)'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_6.26_B16269.jpg)'
- en: Figure 6.26 – dnf module list, with versions and profiles; abridged output
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.26 – dnf 模块列表，包含版本和配置文件；简化输出
- en: 'Let''s say that we want to install `container-tools` version 2.0\. We can do
    it this way:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们想安装 `container-tools` 版本 2.0。我们可以这样做：
- en: '![Figure 6.27 – Deploying a specific module version by using the dnf command'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 6.27 – 使用 dnf 命令部署特定模块版本'
- en: '](img/Figure_6.27_B16269.jpg)'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_6.27_B16269.jpg)'
- en: Figure 6.27 – Deploying a specific module version by using the dnf command
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.27 – 使用 dnf 命令部署特定模块版本
- en: As you can see, the result of this action is going to be quite extensive. Sometimes,
    when we deploy a set of packages from modules and streams, our machine is going
    to deploy hundreds of packages. So, be prepared to wait for a bit of time to see
    whether it happens.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，这个操作的结果将非常庞大。有时，当我们从模块和流中部署一组包时，我们的机器将部署数百个包。因此，准备好等待一段时间，看是否会发生这种情况。
- en: In one of our examples, we deployed the `httpd` package by using the default
    profile and stream. Every one of these streams can have multiple profiles for
    our convenience. If the stream has multiple profiles, one of them can be used
    as the default one (and marked as such). This is not mandatory, but it's a good
    practice.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的一个示例中，我们使用默认的配置文件和流部署了 `httpd` 包。每个流都可以有多个配置文件，供我们方便使用。如果一个流有多个配置文件，可以将其中一个设置为默认配置文件（并标记为默认）。这不是强制性的，但这是一个好习惯。
- en: In terms of modules, there are 60+ modules available already, with various versions
    of Python, PHP, PostgreSQL, nginx, and so on, to name a few commonly used services.
    We can use a module from that list to deploy it. Also, the output of the command
    gives us details about profiles, which we can then use to deploy a specific module
    profile.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 在模块方面，已有超过 60 个模块可用，其中包括 Python、PHP、PostgreSQL、nginx 等多个版本，可以列举一些常用服务。我们可以使用该列表中的模块进行部署。此外，命令的输出还会提供有关配置文件的详细信息，我们可以根据这些信息部署特定的模块配置文件。
- en: By using these capabilities, we can modularize our approach to deploy specific
    packages. The overall idea of modularization via streams and profiles is a good
    one, although it's a bit clunky and unfinished in terms of upgrades. That being
    said, it's something that is going to be around in the future, so it's a worthwhile
    investment of our time to learn about it.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用这些功能，我们可以将部署特定包的方式模块化。通过流和配置文件进行模块化的总体思路是不错的，尽管在升级方面有些笨拙且未完成。话虽如此，它仍然是未来会存在的一种方法，因此学习它是值得的。
- en: We're done with advanced repository management for the time being. Let's now
    learn how to create custom repositories.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 我们暂时完成了高级仓库管理的部分。接下来我们学习如何创建自定义仓库。
- en: Creating custom repositories
  id: totrans-199
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建自定义仓库
- en: Sometimes, it's necessary to create your own private repository of packages.
    Whatever the reason might be – no internet access, low deployment speed – it's
    a completely normal usage model that's often used all over the world. We are going
    to show examples for both CentOS and Ubuntu so that we cover everything necessary
    for most Linux administrators. Let's roll up our sleeves and start!
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，创建自己的私有包仓库是必要的。不管是什么原因——没有网络访问、低部署速度——这都是一种完全正常的使用模式，全球范围内都经常使用。我们将为 CentOS
    和 Ubuntu 提供示例，以涵盖大多数 Linux 管理员所需的一切。让我们挽起袖子，开始吧！
- en: Getting ready
  id: totrans-201
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 做好准备
- en: 'Keep the `cli1` virtual machine powered on and let''s continue using our shell.
    Let''s make sure that the necessary packages are installed by using our standard
    commands. So, let''s use this command:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 保持`cli1`虚拟机开机，让我们继续使用我们的终端。通过标准命令确保所需的包已安装。于是，让我们使用以下命令：
- en: '[PRE13]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: That should be all in terms of preparation, so let's do it.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 这应该是所有的准备工作，所以让我们开始吧。
- en: How to do it…
  id: totrans-205
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作……
- en: Setting up a custom CentOS repository is actually quite a simple affair. The
    first step involves downloading some packages. We are going to download a few
    of them and place them in the same directory. Then, we are going to make that
    directory available via the network by using `vsftpd`. A more detailed explanation
    of `vsftpd` can be found in the next chapter of this book, which is about network-based
    file synchronization. Here, we are just going to do a *Formula 1* qualifying lap
    through `vsftpd` to create a repository.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 设置一个自定义 CentOS 仓库其实是相当简单的。第一步是下载一些包。我们将下载一些包，并将它们放在同一个目录中。然后，我们将通过`vsftpd`使该目录在网络上可用。关于`vsftpd`的更详细说明，可以在本书的下一章中找到，下一章讲解的是基于网络的文件同步。在这里，我们将通过`vsftpd`进行一个*一级方程式*资格赛圈，以创建仓库。
- en: 'Let''s say that we want to create a local repository (hosted on our `cli2`
    machine) that''s going to have two packages in it – the `joe` editor and `desktop-backgrounds-basic`.
    We need to put them in a directory, `/var/ftp/pub/repository`, so that they''re
    nice and handy inside the `vsftpd` folder structure. We could do it like this:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们想要创建一个本地仓库（托管在我们的`cli2`机器上），其中将包含两个包——`joe`编辑器和`desktop-backgrounds-basic`。我们需要将它们放入一个目录`/var/ftp/pub/repository`，这样它们就能方便地存放在`vsftpd`文件夹结构中。我们可以这样做：
- en: '![Figure 6.28 – Downloading a few packages and getting ready for repository
    configuration'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 6.28 – 下载一些包并为仓库配置做准备'
- en: '](img/Figure_6.28_B16269.jpg)'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_6.28_B16269.jpg)'
- en: Figure 6.28 – Downloading a few packages and getting ready for repository configuration
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.28 – 下载一些包并为仓库配置做准备
- en: 'Since we already installed the `createrepo` package in the introduction to
    this recipe, we just need to use the `createrepo` command to create the necessary
    inventory information:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们在本章的介绍中已经安装了`createrepo`包，我们只需使用`createrepo`命令来创建必要的清单信息：
- en: '![Figure 6.29 – Creating a repository out of a directory with RPM packages'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 6.29 – 从包含 RPM 包的目录创建仓库'
- en: '](img/Figure_6.29_B16269.jpg)'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_6.29_B16269.jpg)'
- en: Figure 6.29 – Creating a repository out of a directory with RPM packages
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.29 – 从包含 RPM 包的目录创建仓库
- en: 'The next step is to allow this directory to be used via `vsftpd`. Again, we
    have already installed `vsftpd` and, by default, we just need to change one option
    in its configuration file to allow anonymous FTP. Let''s open the configuration
    file, `/etc/vsftpd/vsftpd.conf`, and locate the offending option:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是允许通过`vsftpd`使用此目录。再一次，我们已经安装了`vsftpd`，并且默认情况下，我们只需要在其配置文件中更改一个选项来允许匿名 FTP。让我们打开配置文件`/etc/vsftpd/vsftpd.conf`，并找到需要修改的选项：
- en: '[PRE14]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'And change it to the following:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 并将其更改为以下内容：
- en: '[PRE15]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'We can now start and enable the service:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以启动并启用该服务：
- en: '[PRE16]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Then, let''s try to log in to it to verify whether everything is ready:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们尝试登录以验证一切是否就绪：
- en: '![Figure 6.30 – Checking whether the vsftpd configuration works'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 6.30 – 检查 vsftpd 配置是否有效'
- en: '](img/Figure_6.30_B16269.jpg)'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_6.30_B16269.jpg)'
- en: Figure 6.30 – Checking whether the vsftpd configuration works
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.30 – 检查 vsftpd 配置是否有效
- en: 'Everything is now ready from the service perspective. Now we just need to explain
    to `yum/dnf` that they need to use this as a repository. So, let''s head to the
    `/etc/yum.repos.d` directory and create a repository configuration file there.
    Let''s say we''ll call it `localrepo.repo`. The name is irrelevant, it''s just
    that it needs to have the `.repo` extension. Let''s add the following options
    to it and save it:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 从服务角度来看，一切现在都已准备就绪。接下来，我们只需要告诉`yum/dnf`它们需要使用这个仓库。于是，让我们进入`/etc/yum.repos.d`目录，并在其中创建一个仓库配置文件。假设我们将其命名为`localrepo.repo`。名称无关紧要，关键是它必须以`.repo`结尾。接下来，我们添加以下选项并保存：
- en: '[PRE17]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Let''s verify whether this repository definition now works. We need to use
    `yum` or `dnf` for that, with the `repolist` keyword:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们验证一下这个仓库定义是否现在有效。我们需要使用`yum`或`dnf`来验证，使用`repolist`关键字：
- en: '![Figure 6.31 – Checking whether our repository is correctly configured via
    its repo config file'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: '![图6.31 – 通过仓库配置文件检查我们的仓库是否已正确配置](img/Figure_6.31_B16269.jpg)'
- en: '](img/Figure_6.31_B16269.jpg)'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_6.31_B16269.jpg)'
- en: Figure 6.31 – Checking whether our repository is correctly configured via its
    repo config file
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.31 – 通过仓库配置文件检查我们的仓库是否已正确配置
- en: 'As we can see, `MyLocalRepo` is defined and ready to be used. Let''s test it
    by trying to install the `desktop-backgrounds-basic` package:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所看到的，`MyLocalRepo`已定义并准备好使用。让我们通过尝试安装`desktop-backgrounds-basic`软件包来进行测试：
- en: '[PRE18]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'This should be the result:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 这应该是最终结果：
- en: '![Figure 6.32 – Installing a package from our custom repository'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: '![图6.32 – 从我们的自定义仓库安装软件包](img/Figure_6.32_B16269.jpg)'
- en: '](img/Figure_6.32_B16269.jpg)'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_6.32_B16269.jpg)'
- en: Figure 6.32 – Installing a package from our custom repository
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.32 – 从我们的自定义仓库安装软件包
- en: We can clearly see the relevant information here – the repository used was called
    `MyLocalRepo`, so both `vsftpd` and our repository configuration file work without
    any problems.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以清楚地看到相关信息——所使用的仓库名为`MyLocalRepo`，因此`vsftpd`和我们的仓库配置文件都能正常工作。
- en: Note
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 注释
- en: Ubuntu tends to be much, much richer in terms of custom repositories; for example,
    repositories that are hosted on launchpad.net, and so on. It also tends to be
    a bit more internet-reliant than CentOS, but, that being said, it's easy enough
    to create repositories on either one of these distributions.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: Ubuntu在自定义仓库方面通常更为丰富，例如，托管在launchpad.net上的仓库等。它还比CentOS更依赖互联网，但话虽如此，在这两个发行版上创建仓库都很容易。
- en: Let's dive into a short explanation about how this all works in CentOS, and
    then it's time for another recipe!
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们简要解释一下这一切在CentOS中是如何工作的，然后是时候进行另一个方法的学习了！
- en: How it works…
  id: totrans-241
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的……
- en: 'There are two aspects to this recipe:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 这个方法有两个方面：
- en: Understanding how creating a repository works
  id: totrans-243
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解创建仓库的工作原理
- en: Understanding how using a *custom-created* repository works from the service
    and `yum/dnf` perspective
  id: totrans-244
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从服务和`yum/dnf`的角度理解使用*自定义创建*仓库的工作原理
- en: As always, we need to understand both of these concepts so that we can make
    them work for us. Let's start with the repository creation part.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 和往常一样，我们需要理解这两个概念，以便让它们为我们工作。让我们从仓库创建部分开始。
- en: 'Obviously, when creating a repository, we have to have some packages for that
    repository. So, a logical first step would always be to either create some packages
    or download them. There''s just one key point to be made here – there *might*
    be problems if you download some packages *without* their dependencies. We deliberately
    chose two packages that don''t have any dependencies so that we can have something
    to start our work with. That problem can be solved in either of the following
    two ways:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，在创建仓库时，我们必须有一些包用于该仓库。所以，一个合乎逻辑的第一步通常是创建一些包或下载它们。这里有一个关键点——如果你在*没有*下载其依赖项的情况下下载一些包，可能会遇到问题。我们故意选择了两个没有依赖项的软件包，这样我们就有一些东西可以开始工作。这个问题可以通过以下两种方式解决：
- en: We download all of the necessary dependencies for the packages that we're creating
    a repository for.
  id: totrans-247
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们下载所有必要的依赖项，以便为我们正在创建仓库的软件包使用。
- en: We set up our repositories so that some other repository has all of the necessary
    dependencies for the packages we're creating our repository for.
  id: totrans-248
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们设置了仓库，以便某个其他仓库包含我们为其创建仓库的软件包所需的所有依赖项。
- en: 'Generally speaking, we''ll go a long way in solving this problem by just enabling
    the EPEL repository for our CentOS version, so, generally speaking, we should
    install the EPEL `rpm` as it''s going to help us with dependencies for almost
    anything:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 一般来说，通过仅启用适用于我们 CentOS 版本的 EPEL 仓库，我们就可以大大简化解决这个问题的过程。因此，我们通常应该安装 EPEL `rpm`，因为它能帮助我们处理几乎所有依赖关系：
- en: '[PRE19]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Then, it all just becomes a matter of creating a directory, placing packages
    there, and using `createrepo` to create the necessary XML files so that the directory
    with packages can be used as a repository. Without `createrepo`, we are going
    to get an error, so we should always install it and use it prior to using our
    custom repository.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，所有的工作就变成了创建一个目录，将软件包放进去，然后使用 `createrepo` 来生成必要的 XML 文件，这样带有软件包的目录就能作为一个仓库使用。如果没有
    `createrepo`，我们会遇到错误，因此我们应该在使用自定义仓库之前，始终先安装并使用它。
- en: The second aspect is related to a wider picture – that is, how to make this
    repository available to other machines on the network and how to configure those
    machines to use it. That's why we strategically selected `vsftpd` as a delivery
    service, as its configuration for this scenario is really easy. We could have
    used the Apache web server as well, but seeing that our next chapter is related
    to `vsftpd`, we thought it would be a fun way to get an introduction to `vsftpd`
    out of the way by seeing it in action.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个方面涉及到更广泛的图景——也就是说，如何使该仓库对网络上的其他机器可用，并如何配置这些机器以使用它。这就是为什么我们战略性地选择了 `vsftpd`
    作为传输服务，因为它在这种场景下的配置非常简单。我们本来也可以使用 Apache Web 服务器，但考虑到我们下一章的内容与 `vsftpd` 相关，我们觉得通过实践操作
    `vsftpd` 来作为对它的入门介绍会很有趣。
- en: A part of this process is to work on `repo` files from the repository client
    perspective – that is, all of the machines that are going to be using our custom
    repository. It's just a couple of configuration lines that cover the repository's
    unique name and description, location, and some general settings, such as whether
    that repository is enabled on a client and if we're using signed packages and
    verifying their signature. Usually, people tend to skip over this, although it's
    quite important. If we enable the `gpgcheck` option, we need to install a `gpg`
    key that a repository is using to sign its packages, as well. We can do that with
    the `gpg --import file_name.gpg` command, after we download the `gpg` file.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 这个过程的一部分是从仓库客户端的角度来操作 `repo` 文件——也就是所有将要使用我们自定义仓库的机器。这些文件只需要配置几行，涵盖仓库的唯一名称和描述、位置以及一些通用设置，例如是否启用该仓库，以及我们是否使用签名包并验证其签名。通常，人们往往忽视这一部分，尽管它非常重要。如果我们启用了
    `gpgcheck` 选项，我们还需要安装一个仓库用来签署其包的 `gpg` 密钥。我们可以通过下载 `gpg` 文件后，使用 `gpg --import
    file_name.gpg` 命令来完成此操作。
- en: Let's now get ready for the last part of this chapter, which is all about compiling
    software from the source code. We're going to use some familiar, usual suspects
    to do that and learn how to do it along the way.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们准备进入本章的最后部分，这部分内容完全是关于如何从源代码编译软件。我们将使用一些熟悉的、常见的工具来完成这项任务，并在过程中学习如何操作。
- en: There's more…
  id: totrans-255
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多内容……
- en: 'If we need to learn more about `vsftpd`, make sure that you check the following
    links:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们需要了解更多关于 `vsftpd` 的内容，确保查看以下链接：
- en: '**yum:** [https://access.redhat.com/documentation/en-us/red_hat_enterprise_linux/6/html/deployment_guide/ch-yum](https://access.redhat.com/documentation/en-us/red_hat_enterprise_linux/6/html/deployment_guide/ch-yum%0D)'
  id: totrans-257
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**yum:** [https://access.redhat.com/documentation/en-us/red_hat_enterprise_linux/6/html/deployment_guide/ch-yum](https://access.redhat.com/documentation/en-us/red_hat_enterprise_linux/6/html/deployment_guide/ch-yum%0D)'
- en: '**Install Anonymous FTP server on CentOS 8**: [https://www.centlinux.com/2020/02/install-anonymous-ftp-server-on-centos-8.html](https://www.centlinux.com/2020/02/install-anonymous-ftp-server-on-centos-8.html%0D)'
  id: totrans-258
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**在 CentOS 8 上安装匿名 FTP 服务器**：[https://www.centlinux.com/2020/02/install-anonymous-ftp-server-on-centos-8.html](https://www.centlinux.com/2020/02/install-anonymous-ftp-server-on-centos-8.html%0D)'
- en: '**Create Local Repos**: [https://wiki.centos.org/HowTos/CreateLocalRepos](https://wiki.centos.org/HowTos/CreateLocalRepos%0D)'
  id: totrans-259
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**创建本地仓库**：[https://wiki.centos.org/HowTos/CreateLocalRepos](https://wiki.centos.org/HowTos/CreateLocalRepos%0D)'
- en: '**Configuring yum and yum repositories**: [https://access.redhat.com/documentation/en-us/red_hat_enterprise_linux/6/html/deployment_guide/sec-configuring_yum_and_yum_repositories](https://access.redhat.com/documentation/en-us/red_hat_enterprise_linux/6/html/deployment_guide/sec-configuring_yum_and_yum_repositories%0D)'
  id: totrans-260
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**配置 yum 和 yum 仓库**: [https://access.redhat.com/documentation/en-us/red_hat_enterprise_linux/6/html/deployment_guide/sec-configuring_yum_and_yum_repositories](https://access.redhat.com/documentation/en-us/red_hat_enterprise_linux/6/html/deployment_guide/sec-configuring_yum_and_yum_repositories%0D)'
- en: Compiling third-party software
  id: totrans-261
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编译第三方软件
- en: Sometimes, a package for a certain application is just not available – either
    nobody bothered to create it, or that application is so old that it's obsolete
    and nobody wants to do it. Either way, if an application is useful to us, there's
    no reason why we shouldn't try to find its source code and compile it.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 有时候，某个应用程序的包根本不可用——要么是没有人愿意创建它，要么是该应用程序太旧，已经过时且没有人愿意再做。无论哪种情况，如果某个应用程序对我们有用，我们完全可以去尝试找到它的源代码并进行编译。
- en: Compiling software from source code can sometimes be like dark magic, and we
    have a good example coming up very soon. Sometimes it works without any real effort,
    and we are going to show you an example of that, too. The main distinction between
    those two scenarios seems to be the all-important dependencies and their version.
    Also, there's a lot of software for Linux that needs to be compiled in a specific
    sequence. A perfect example of that is the LAMP stack. After installing Linux,
    if you want to compile Apache, MySQL, and PHP, you had better do it in the correct
    order. Otherwise, your keyboard might find its way to the garbage can sooner than
    you planned. Let's see what we can do about this so that it doesn't happen.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 从源代码编译软件有时就像黑魔法一样，而我们很快就会给出一个很好的例子。有时候它可以毫不费力地工作，我们也将展示这样的一个例子。两种情况之间的主要区别似乎在于至关重要的依赖项及其版本。另外，很多
    Linux 软件需要按照特定顺序进行编译。一个典型的例子就是 LAMP 堆栈。安装 Linux 后，如果你想编译 Apache、MySQL 和 PHP，最好按正确的顺序进行。否则，你的键盘可能比你计划的更早送进垃圾桶。让我们看看如何避免这种情况发生。
- en: Getting ready
  id: totrans-264
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备就绪
- en: We can use any machine for this recipe, but the most common scenario is a default
    installation of some Linux distribution with a lot of packages missing. So, let's
    install a fresh Ubuntu machine, and let's call it `compile1`, just for fun. So,
    this one is going to be just a Vanilla Ubuntu installation that will need all
    of the configurations in order for the compilation process to work.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用任何机器来执行这个过程，但最常见的情况是默认安装了某个 Linux 发行版，且缺少许多软件包。所以，让我们安装一台全新的 Ubuntu 机器，并给它取个名字`compile1`，纯粹为了好玩。这台机器将仅仅是一个原生的
    Ubuntu 安装，需要进行所有配置才能完成编译过程。
- en: How to do it…
  id: totrans-266
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作…
- en: 'We''ll start with an easy example of a package that''s very easy to compile
    and won''t give us a massive headache. Let''s compile the `joe` editor and show
    you what we''re talking about. We''ll start with the usual procedure:'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从一个简单的例子开始，这是一个非常容易编译的包，不会让我们头疼。我们将编译`joe`编辑器，并展示我们所说的内容。我们从常规程序开始：
- en: '[PRE20]'
  id: totrans-268
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Just to be on the safe side, to get our machine ready for the compilation process,
    let''s use this command to install a large selection of packages:'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 为了保险起见，为了让我们的机器准备好进行编译过程，让我们使用这个命令安装大量的软件包：
- en: '[PRE21]'
  id: totrans-270
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'As a result, our Ubuntu machine should now be ready for any compilation effort.
    Let''s now download `joe` source:'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 结果是，我们的 Ubuntu 机器现在应该已经准备好进行任何编译工作。接下来让我们下载`joe`源代码：
- en: '[PRE22]'
  id: totrans-272
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'We prefer to keep things tidy in the root''s home directory, so let''s just
    create a folder for compilation purposes. Let''s call it `source` and move `joe`
    source there, and then open its `tar.gz` file with the source code:'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 我们喜欢保持根目录下的文件整洁，所以让我们创建一个用于编译的文件夹。我们叫它`source`，然后将`joe`源代码移到那里，再打开它的`tar.gz`文件以查看源代码：
- en: '[PRE23]'
  id: totrans-274
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'The last command (`tar`) is going to open another subfolder (`joe-4.6`) with
    all the necessary files for the compilation process located there. So, let''s
    change the directory to `joe-4.6` and start the configuration process:'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一个命令（`tar`）将会打开另一个子文件夹（`joe-4.6`），其中包含所有必要的编译文件。现在，让我们切换到 `joe-4.6` 目录并开始配置过程：
- en: '[PRE24]'
  id: totrans-276
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'If everything goes well, we should have something like this as a result (shortened
    for formatting reasons):'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一切顺利，我们应该得到如下结果（由于格式原因，已简化）：
- en: '![Figure 6.33 – Configuration step concluded successfully'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: '![图6.33 – 配置步骤成功完成'
- en: '](img/Figure_6.33_B16269.jpg)'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_6.33_B16269.jpg)'
- en: Figure 6.33 – Configuration step concluded successfully
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.33 – 配置步骤成功完成
- en: 'The configuration process has finished successfully. Let''s now continue with
    the actual compilation process, for which we need the `make` command (hence the
    reason why we installed all of those packages, `make` being one of them), and
    we can use some additional options to speed the process up. My Ubuntu machine
    has four processors, so we can use `make -j4` to speed the process up (so that
    the compilation process takes all of the available cores, not just one). After
    a couple of seconds, the compilation process should finish similar to this:'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 配置过程已经成功完成。现在，让我们继续实际的编译过程，我们需要使用`make`命令（这也是我们安装所有这些包的原因之一，`make`就是其中之一），并且我们可以使用一些额外的选项来加速这个过程。我的
    Ubuntu 机器有四个处理器，因此我们可以使用`make -j4`来加速进程（这样编译过程将使用所有可用的核心，而不仅仅是一个核心）。几秒钟后，编译过程应该会类似于这样完成：
- en: '![Figure 6.34 – Compilation process also concluded successfully'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 6.34 – 编译过程也成功结束'
- en: '](img/Figure_6.34_B16269.jpg)'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_6.34_B16269.jpg)'
- en: Figure 6.34 – Compilation process also concluded successfully
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.34 – 编译过程也成功结束
- en: 'The final step in this process is to install our compiled application. We do
    that by using the following command:'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 这个过程的最后一步是安装我们编译的应用程序。我们可以通过使用以下命令来完成：
- en: '[PRE25]'
  id: totrans-286
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: After this command finishes its job and installs `joe` system-wide, we should
    be able to start `joe` from the command line and edit our files. We can also create
    a `deb` package out of this installation by using the `checkinstall` package.
    When we run it, it's going to ask us for a package description. We can type in
    something like `Joe editor v4.6` and be done with it. At the end of this process,
    we're going to get a `deb` package with installation files that are required to
    deploy `joe` on other Ubuntu servers.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 在该命令完成并将`joe`系统范围安装后，我们应该能够从命令行启动`joe`并编辑我们的文件。我们还可以使用`checkinstall`包创建一个`deb`安装包。当我们运行它时，它会要求我们输入包描述。我们可以输入类似`Joe
    editor v4.6`的描述，然后完成安装。经过这个过程，我们将获得一个`deb`包，其中包含在其他 Ubuntu 服务器上部署`joe`所需的安装文件。
- en: That wasn't so bad, was it? Yes, we had a couple of steps to do, but overall,
    it was a very simple process.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 这还不算太糟糕，是吧？是的，我们做了几个步骤，但总体来说，这还是一个非常简单的过程。
- en: 'Now let''s do another example that''s the complete opposite of what we''d call
    a *very simple process*. Let''s try to compile the Apache web server. We''re going
    to use the latest version at the time of writing (2.4.49), located at `https://dlcdn.apache.org//httpd/httpd-2.4.49.tar.gz`,
    by using the same procedure – download the source to our source directory, open
    the source archive, and start with the configuration process. Let''s see what
    happens:'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们做一个与我们所说的*非常简单的过程*完全相反的例子。我们来尝试编译 Apache 网络服务器。我们将使用写作时的最新版本（2.4.49），该版本位于`https://dlcdn.apache.org//httpd/httpd-2.4.49.tar.gz`，并按照相同的程序操作——将源代码下载到我们的源代码目录，打开源代码归档文件，然后开始配置过程。让我们看看会发生什么：
- en: '![Figure 6.35 – configure script in action – Missing dependencies – Example
    1'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 6.35 – 配置脚本执行过程 – 缺失依赖 – 示例 1'
- en: '](img/Figure_6.35_B16269.jpg)'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_6.35_B16269.jpg)'
- en: Figure 6.35 – configure script in action – Missing dependencies – Example 1
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.35 – 配置脚本执行过程 – 缺失依赖 – 示例 1
- en: 'Oops! Not going to happen. So then, we go to Dr. Google and check what to do
    if the message received is *APR is not found*. We''ll end up finding some articles
    that state that we should install some additional packages, so let''s do that:'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 哎呀！这不可能实现。那么，我们去问问谷歌，看看当收到*找不到 APR*的消息时该怎么做。最终我们会找到一些文章，说明我们需要安装一些额外的包，因此我们来安装它们：
- en: '[PRE26]'
  id: totrans-294
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Try to run the `configure` script again, and check the results:'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试重新运行`configure`脚本，并检查结果：
- en: '![Figure 6.36 – configure script in action – Missing dependencies – Example
    2'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 6.36 – 配置脚本执行过程 – 缺失依赖 – 示例 2'
- en: '](img/Figure_6.36_B16269.jpg)'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_6.36_B16269.jpg)'
- en: Figure 6.36 – configure script in action – Missing dependencies – Example 2
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.36 – 配置脚本执行过程 – 缺失依赖 – 示例 2
- en: 'Another package seems to be missing. And when we – just as an example – try
    to find a package such as `libpcre` in the `apt` cache, this is what we''re going
    to get:'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个包似乎也缺失了。当我们——仅举个例子——尝试在`apt`缓存中查找`libpcre`包时，我们会得到如下结果：
- en: '![Figure 6.37 – Trying to figure out which package is missing'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 6.37 – 试图找出缺失的包'
- en: '](img/Figure_6.37_B16269.jpg)'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_6.37_B16269.jpg)'
- en: Figure 6.37 – Trying to figure out which package is missing
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.37 – 试图找出缺失的包
- en: 'Now the question becomes how to know which packages to install from this list?
    What usually happens is that people lose patience and write a command such as
    this:'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 现在的问题是如何知道从这个列表中安装哪些软件包？通常情况下，人们会失去耐心，写下这样的命令：
- en: '[PRE27]'
  id: totrans-304
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'And that''s going to install more than 200 packages on our machine. If we''re
    security-conscious, that''s really not the way to go. It''s easy for people like
    us as we''ve done this a thousand times, but for normal people, this gets really
    frustrating really quick. So, let''s now install the required package and its
    dependencies:'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 这将在我们的机器上安装超过200个软件包。如果我们关注安全性，这并不是一个好方法。对于像我们这样做过无数次的人来说，这很容易，但对于普通人来说，这会非常令人沮丧。所以，现在让我们安装所需的软件包及其依赖项：
- en: '[PRE28]'
  id: totrans-306
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Before we do the actual configuration/compiling, we do have to mention one thing.
    Nowadays, a lot of the app code is shared via concepts such as Git. Most of these
    repositories are hosted by app coders, and usually have additional instructions
    for dependencies and how to deploy them. However, if we download a source code
    from a non-Git-like resource, we usually get more information about compiling
    that source code in files such as `INSTALL` after we extract the source archive.
    So, we need to make sure that we check these resources prior to trying to compile
    an app from some source code.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们进行实际的配置/编译之前，我们必须提一点。如今，许多应用程序代码是通过Git等概念共享的。大多数这些存储库都是由应用程序编码者托管的，并且通常具有有关依赖项和如何部署它们的额外说明。然而，如果我们从非Git类资源下载源代码，通常在我们解压缩源代码后，可以在诸如`INSTALL`文件中获取更多有关编译该源代码的信息。因此，在尝试编译应用程序之前，我们需要确保检查这些资源。
- en: 'Run the rest of our procedure in a serial fashion:'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 依序运行我们的其余步骤：
- en: '[PRE29]'
  id: totrans-309
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Luckily, there will be no more questions, as we can see in the following screenshot:'
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，不会再有更多问题，因为我们可以在下面的截图中看到：
- en: '![Figure 6.38 – Compilation and installation completed successfully'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: '![Figure 6.38 – Compilation and installation completed successfully'
- en: '](img/Figure_6.38_B16269.jpg)'
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: '![Figure 6.38 – Compilation and installation completed successfully'
- en: Figure 6.38 – Compilation and installation completed successfully
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: Figure 6.38 – 编译和安装成功完成
- en: We deliberately chose a package that's *a bit* annoying, but not *over-the-top*
    annoying. There are applications out there that can make us spend hours and hours
    figuring out all of the dependencies so that we can compile a single package.
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 我们特意选择了一个*稍微*烦人的软件包，但不至于*过分*烦人。市面上有一些应用程序会让我们花费数小时来解决所有依赖关系，以便编译一个单独的软件包。
- en: How it works…
  id: totrans-315
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理...
- en: Now that we have got the step-by-step process out of the way, let's discuss
    the specifics of how all of this works and fits together. It's pretty obvious
    that there are multiple steps to the process and that each and every one of them
    is significant. And it is – one can't be done without the other. So, let's now
    discuss all of the commands that we used and describe how they work.
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经完成了逐步流程，让我们讨论具体的工作原理及其如何协调和完美结合。很明显，这个过程包含多个步骤，每一个步骤都非常重要。而且这些步骤是紧密联系的，一个都不能少。所以，现在让我们讨论一下我们使用的所有命令，并描述它们的工作原理。
- en: The first phase in our compilation process starts with the `./configure` command.
    It's actually not a command *per se*; it's a `shell` script that almost all source
    code packages have. This script is there to make sure that the environment is
    ready for the compilation process – check included files, libraries, dependencies,
    everything needed for the source code compilation process. It checks for the necessary
    compiler and its libraries to make sure that the stage is set up for the next
    part of the process. It also writes down some configuration files that are going
    to be used by `make` when the build process starts.
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 编译过程中的第一个阶段始于`./configure`命令。它实际上不是一个具体的命令；它是一个`shell`脚本，几乎所有的源代码包都会有这个脚本。这个脚本的作用是确保环境准备就绪，用于编译过程
    - 检查包含的文件、库、依赖项，以及编译源代码过程所需的一切。它检查必要的编译器及其库，确保为后续过程做好准备。它还会写入一些配置文件，这些文件将在构建过程启动时由`make`使用。
- en: The next part of the process involves using the `make` command. By using the
    configuration files created by the `configure` script and other files, it starts
    compiling source code. One of these files is called `Makefile`, and it contains
    a lot of information about what `make` needs to do – which files to compile and
    how, which compiler flags to use, how to link all of the compiled code into the
    resulting binaries, and more besides.
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 过程的下一部分涉及使用`make`命令。通过使用`configure`脚本创建的配置文件和其他文件，它开始编译源代码。其中一个文件叫做`Makefile`，它包含了许多关于`make`需要执行的任务的信息——需要编译哪些文件，如何编译，使用哪些编译器标志，如何将所有编译后的代码链接成最终的二进制文件，等等。
- en: The last part of the process is not compiling a source code *per se* – it's
    about installing the compiled code on our Linux machine. By using relevant information
    in the configuration files, `make install` installs all of the files necessary
    for our command to work – libraries, binaries, man pages, documentation, and so
    on. If the compilation process from the previous part concludes successfully,
    installation is just about making sure that the compiled application is available
    to be used.
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 过程的最后部分不是编译源代码*本身*——而是将编译后的代码安装到我们的Linux机器上。通过使用配置文件中的相关信息，`make install`会安装所有使得我们的命令能够正常运行的文件——库文件、二进制文件、手册页、文档等等。如果前一部分的编译过程成功结束，安装过程就是确保编译好的应用程序能够被使用。
- en: That was the last recipe in this chapter. The next chapter is about network-based
    file synchronization, and as part of those recipes, we are going to go much deeper
    into the inner workings of `vsftpd`, which we just kind of touched on in this
    chapter without giving it much time or space. Also, we are going to discuss `ssh`
    and `scp`, two ways of securely connecting to servers and transferring files between
    servers, and `rsync`, a file synchronization methodology. Stay tuned for the next
    chapter.
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 这是本章的最后一个示例。下一章将讨论基于网络的文件同步，在这些示例中，我们将深入探讨`vsftpd`的内部工作原理，而在本章中我们只是稍微提到了一下，并没有给它太多的时间或篇幅。此外，我们还将讨论`ssh`和`scp`，它们是两种安全连接到服务器并在服务器之间传输文件的方法，以及`rsync`，一种文件同步方法。敬请期待下一章。
- en: There's more…
  id: totrans-321
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多内容…
- en: 'If you need to learn more about `vsftpd`, make sure that you check out the
    following links:'
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你需要了解更多关于`vsftpd`的信息，确保你查看以下链接：
- en: '**How to compile and run C/C++ code in Linux**: [https://www.cyberciti.biz/faq/howto-compile-and-run-c-cplusplus-code-in-linux/](https://www.cyberciti.biz/faq/howto-compile-and-run-c-cplusplus-code-in-linux/%0D)'
  id: totrans-323
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**如何在Linux中编译和运行C/C++代码**：[https://www.cyberciti.biz/faq/howto-compile-and-run-c-cplusplus-code-in-linux/](https://www.cyberciti.biz/faq/howto-compile-and-run-c-cplusplus-code-in-linux/%0D)'
- en: '**Compiling things on Ubuntu the easy way**: [https://help.ubuntu.com/community/CompilingEasyHowTo](https://help.ubuntu.com/community/CompilingEasyHowTo%0D)'
  id: totrans-324
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**在Ubuntu上轻松编译程序**：[https://help.ubuntu.com/community/CompilingEasyHowTo](https://help.ubuntu.com/community/CompilingEasyHowTo%0D)'
