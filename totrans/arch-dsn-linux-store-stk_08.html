<html><head></head><body>
<div id="_idContainer082">
<h1 class="chapter-number" id="_idParaDest-119"><a id="_idTextAnchor134"/><span class="koboSpan" id="kobo.1.1">8</span></h1>
<h1 id="_idParaDest-120"><a id="_idTextAnchor135"/><span class="koboSpan" id="kobo.2.1">Illustrating the Layout of Physical Media</span></h1>
<p class="author-quote"><a id="_idTextAnchor136"/><a id="_idTextAnchor137"/><span class="koboSpan" id="kobo.3.1">“If I had asked people what they wanted, they would have said faster horses.” </span><span class="koboSpan" id="kobo.3.2">– Henry Ford</span></p>
<p><span class="koboSpan" id="kobo.4.1">In the first seven chapters of this book, we explored the organization of storage hierarchy in the Linux kernel, the organization of different layers, the different abstraction methods, and the representation of physical storage devices. </span><span class="koboSpan" id="kobo.4.2">We’re now done with explaining the software side of things in the storage stack, which means it’s time to take a look at the actual hardware and see what lies beneath. </span><span class="koboSpan" id="kobo.4.3">I thought it would be best if we got to look at the different types of storage media so that we could not only understand their operations but also see why the Linux kernel uses different schedulers and techniques to handle the different types of drives. </span><span class="koboSpan" id="kobo.4.4">In short, getting to know the internals of disk drives will make the information presented earlier in this book a lot </span><span class="No-Break"><span class="koboSpan" id="kobo.5.1">more relevant.</span></span></p>
<p><span class="koboSpan" id="kobo.6.1">The choice of a hardware medium has evolved over the last few years, as there are now considerable options available in the market, not only for enterprise storage but also for personal use. </span><span class="koboSpan" id="kobo.6.2">These different storage options are suited to specific environments and workload types. </span><span class="koboSpan" id="kobo.6.3">For instance, in some scenarios, people look for capacity-oriented solutions, while in others, maximizing performance is the ultimate concern. </span><span class="koboSpan" id="kobo.6.4">Either way, there is a solution available for every scenario. </span><span class="koboSpan" id="kobo.6.5">For enterprise environments, vendors offer storage arrays that can implement a hybrid solution and contain a mix of </span><span class="No-Break"><span class="koboSpan" id="kobo.7.1">these options.</span></span></p>
<p><span class="koboSpan" id="kobo.8.1">Most protocols and systems were built and designed with spinning hard drives in mind. </span><span class="koboSpan" id="kobo.8.2">The storage stack in Linux is no exception to this rule. </span><span class="koboSpan" id="kobo.8.3">When discussing scheduling in the block layer, we saw how techniques such as merging and coalescing are geared toward mechanical drives so that the number of sequential operations can be increased. </span><span class="koboSpan" id="kobo.8.4">As this chapter is all about the physical layout and structure of different types of drives, we’ll see in detail why spinning drives are slower than </span><span class="No-Break"><span class="koboSpan" id="kobo.9.1">the rest.</span></span></p>
<p><span class="koboSpan" id="kobo.10.1">We’ll start by introducing the traditional and oldest form of storage available today, the rotating hard drive. </span><span class="koboSpan" id="kobo.10.2">We’ll discuss its physical structure, design, and working principles. </span><span class="koboSpan" id="kobo.10.3">After that, we’ll move on to solid-state drives and see what makes them different from mechanical drives. </span><span class="koboSpan" id="kobo.10.4">We’ll discuss their internal structure and layout, and explain their operating principles. </span><span class="koboSpan" id="kobo.10.5">We’ll also briefly discuss the concept of drive endurance and see how it differs for both mechanical and solid-state drives. </span><span class="koboSpan" id="kobo.10.6">Finally, we’ll discuss the </span><strong class="bold"><span class="koboSpan" id="kobo.11.1">Non-Volatile Memory Express</span></strong><span class="koboSpan" id="kobo.12.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.13.1">NVMe</span></strong><span class="koboSpan" id="kobo.14.1">) interface, which has revolutionized the performance of </span><span class="No-Break"><span class="koboSpan" id="kobo.15.1">solid-state drives.</span></span></p>
<p><span class="koboSpan" id="kobo.16.1">We’re going to discuss the following </span><span class="No-Break"><span class="koboSpan" id="kobo.17.1">main topics:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.18.1">Understanding mechanical </span><span class="No-Break"><span class="koboSpan" id="kobo.19.1">hard drives</span></span></li>
<li><span class="koboSpan" id="kobo.20.1">Explaining the architecture of </span><span class="No-Break"><span class="koboSpan" id="kobo.21.1">solid-state drives</span></span></li>
<li><span class="koboSpan" id="kobo.22.1">Understanding </span><span class="No-Break"><span class="koboSpan" id="kobo.23.1">drive endurance</span></span></li>
<li><span class="koboSpan" id="kobo.24.1">Reinventing SSDs </span><span class="No-Break"><span class="koboSpan" id="kobo.25.1">with NVMe</span></span></li>
</ul>
<h1 id="_idParaDest-121"><a id="_idTextAnchor138"/><span class="koboSpan" id="kobo.26.1">Technical requirements</span></h1>
<p><span class="koboSpan" id="kobo.27.1">The material presented in this chapter is operating system-agnostic. </span><span class="koboSpan" id="kobo.27.2">As such, there aren’t any commands or concepts that are specifically tied to Linux. </span><span class="koboSpan" id="kobo.27.3">However, it will help if you have some basic knowledge about the different types of storage media options </span><span class="No-Break"><span class="koboSpan" id="kobo.28.1">available today.</span></span></p>
<h1 id="_idParaDest-122"><a id="_idTextAnchor139"/><span class="koboSpan" id="kobo.29.1">Understanding mechanical hard drives</span></h1>
<p><span class="koboSpan" id="kobo.30.1">Mechanical drives, also known as hard disks, magnetic disks, rotating disks, or spinning disks, are the only mechanical component in a modern computer system. </span><span class="koboSpan" id="kobo.30.2">We’ve often addressed them, or, as some might say, </span><em class="italic"><span class="koboSpan" id="kobo.31.1">degraded</span></em><span class="koboSpan" id="kobo.32.1"> them, in this book by calling them slower or legacy drives. </span><span class="koboSpan" id="kobo.32.2">The truth is that even though the use of mechanical drives has declined in recent years, they are still commonly seen in today’s enterprise environments, in a slightly different role. </span><span class="koboSpan" id="kobo.32.3">Since there are better storage options available for performance-sensitive applications, hard drives are mostly used for cold data storage. </span><span class="koboSpan" id="kobo.32.4">Because of higher capacities and lower costs, mechanical drives are still an integral part of </span><span class="No-Break"><span class="koboSpan" id="kobo.33.1">any environment.</span></span></p>
<p><span class="koboSpan" id="kobo.34.1">Let’s briefly describe the major components of a </span><span class="No-Break"><span class="koboSpan" id="kobo.35.1">mechanical drive:</span></span></p>
<ul>
<li><strong class="bold"><span class="koboSpan" id="kobo.36.1">Platter</span></strong><span class="koboSpan" id="kobo.37.1">: A hard disk consists of multiple thin circular disks, known as platters. </span><span class="koboSpan" id="kobo.37.2">All data on a hard drive is recorded on these platters. </span><span class="koboSpan" id="kobo.37.3">To maximize capacity, data can be read from and written to both the top and bottom sides of the platter surface. </span><span class="koboSpan" id="kobo.37.4">The surface of the platter is magnetized from both ends. </span><span class="koboSpan" id="kobo.37.5">The total number of these platters and their storage capacities determine the total capacity of the </span><span class="No-Break"><span class="koboSpan" id="kobo.38.1">hard disk.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.39.1">Spindle</span></strong><span class="koboSpan" id="kobo.40.1">: The drive platters rotate under the power of the drive spindle motor, which is designed to maintain constant speeds. </span><span class="koboSpan" id="kobo.40.2">The hard disk platter rotates at a rate of several thousand </span><strong class="bold"><span class="koboSpan" id="kobo.41.1">revolutions per minute</span></strong><span class="koboSpan" id="kobo.42.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.43.1">rpm</span></strong><span class="koboSpan" id="kobo.44.1">), with standard spindle speeds being 5,400 rpm, 7,200 rpm, 10,000 rpm, and 15,000 rpm, as all platters are connected to a single spindle motor. </span><span class="koboSpan" id="kobo.44.2">Therefore, they all spin at the same time and rotate at the </span><span class="No-Break"><span class="koboSpan" id="kobo.45.1">same speed.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.46.1">R/W (R/W)</span></strong> <strong class="bold"><span class="koboSpan" id="kobo.47.1">head</span></strong><span class="koboSpan" id="kobo.48.1">: As a novice, I was under the impression that data is etched on the hard drive in expressed or written form. </span><span class="koboSpan" id="kobo.48.2">Well, to burst that bubble, data is expressed by the pattern of a magnetic signal on moving media. </span><span class="koboSpan" id="kobo.48.3">Drives have two R/W heads per platter, one each for the top and bottom sides. </span><span class="koboSpan" id="kobo.48.4">During data writing, the R/W head modifies the magnetic orientation on the platter’s surface, while in data reading mode, the head detects the magnetic orientation on the surface of the platter. </span><span class="koboSpan" id="kobo.48.5">It’s fascinating to note that the R/W head never touches the surface of </span><span class="No-Break"><span class="koboSpan" id="kobo.49.1">the platter.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.50.1">Actuator arms</span></strong><span class="koboSpan" id="kobo.51.1">: The actuator arm assembly is responsible for mounting the </span><strong class="bold"><span class="koboSpan" id="kobo.52.1">R/W</span></strong><span class="koboSpan" id="kobo.53.1"> heads. </span><span class="koboSpan" id="kobo.53.2">The actuator arms play a crucial role in the accurate positioning of the R/W heads to the specific locations where data is to be read from or </span><span class="No-Break"><span class="koboSpan" id="kobo.54.1">written to.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.55.1">Controller</span></strong><span class="koboSpan" id="kobo.56.1">: The disk controller is a vital component that oversees the operation of the components mentioned earlier, and it interacts with the host system. </span><span class="koboSpan" id="kobo.56.2">It carries out instructions from the host, manages the R/W heads, and controls the </span><span class="No-Break"><span class="koboSpan" id="kobo.57.1">actuator arms.</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.58.1">Now that we’re familiar with the major components of a mechanical drive, let’s take a look at the geometry of </span><span class="No-Break"><span class="koboSpan" id="kobo.59.1">mechanical drives.</span></span></p>
<h2 id="_idParaDest-123"><a id="_idTextAnchor140"/><span class="koboSpan" id="kobo.60.1">Looking at the physical layout and addressing</span></h2>
<p><span class="koboSpan" id="kobo.61.1">The geometry of a hard drive describes how data is organized on the platters. </span><span class="koboSpan" id="kobo.61.2">This organization is based on dividing the platter surface into concentric rings called tracks. </span><span class="koboSpan" id="kobo.61.3">A cylinder is a vertical section that intersects the corresponding ring across all platters and is used to refer to specific locations on the disk. </span><span class="koboSpan" id="kobo.61.4">A cylinder consists of the same track number on each platter. </span><span class="koboSpan" id="kobo.61.5">Each track is further divided into smaller units known as sectors. </span><span class="koboSpan" id="kobo.61.6">The sector is the smallest addressable unit on a hard drive. </span><span class="koboSpan" id="kobo.61.7">We discussed the concept of block sizes in </span><a href="B19430_03.xhtml#_idTextAnchor053"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.62.1">Chapter 3</span></em></span></a><span class="koboSpan" id="kobo.63.1">. </span><span class="koboSpan" id="kobo.63.2">A block is a group of sectors and is a property of a filesystem. </span><span class="koboSpan" id="kobo.63.3">A sector is the physical property of the drive, and its structure is created by the drive manufacturer during initial formatting. </span><span class="koboSpan" id="kobo.63.4">Initially, the most common sector size used was 512 bytes. </span><span class="koboSpan" id="kobo.63.5">However, some modern drives also use 4 KB sectors. </span><span class="koboSpan" id="kobo.63.6">The following is an illustration of the physical arrangement of the </span><span class="No-Break"><span class="koboSpan" id="kobo.64.1">mechanical drive:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer076">
<span class="koboSpan" id="kobo.65.1"><img alt="Figure 8.1 – The mechanical drive structure" src="image/B19430_08_01.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.66.1">Figure 8.1 – The mechanical drive structure</span></p>
<p><span class="koboSpan" id="kobo.67.1">There are a couple of techniques used to address the physical locations on the hard drive. </span><span class="koboSpan" id="kobo.67.2">One such technique is known as </span><strong class="bold"><span class="koboSpan" id="kobo.68.1">cylinders, heads, and sectors</span></strong><span class="koboSpan" id="kobo.69.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.70.1">CHS</span></strong><span class="koboSpan" id="kobo.71.1">). </span><span class="koboSpan" id="kobo.71.2">The physical geometry of a hard disk is usually expressed in terms of CHS. </span><span class="koboSpan" id="kobo.71.3">A combination of the CHS numbers can be used to identify any location on the disk. </span><span class="koboSpan" id="kobo.71.4">To locate an address on the drive, the host operating system had to be aware of the CHS geometry of </span><span class="No-Break"><span class="koboSpan" id="kobo.72.1">the disk.</span></span></p>
<p><span class="koboSpan" id="kobo.73.1">CHS has now been replaced by </span><strong class="bold"><span class="koboSpan" id="kobo.74.1">logical block addressing</span></strong><span class="koboSpan" id="kobo.75.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.76.1">LBA</span></strong><span class="koboSpan" id="kobo.77.1">). </span><span class="koboSpan" id="kobo.77.2">LBA is another form of disk addressing that simplifies address management on the operating system side. </span><span class="koboSpan" id="kobo.77.3">LBA uses a linear addressing scheme to access physical data blocks. </span><span class="koboSpan" id="kobo.77.4">When using LBA, instead of addressing sectors through CHS, each sector is assigned a unique logical number. </span><span class="koboSpan" id="kobo.77.5">Using it, the hard disk is simply addressed as a single, large device, which simply counts the existing sectors starting at 0. </span><span class="koboSpan" id="kobo.77.6">It is then the job of the disk controller to translate LBA addresses into CHS addresses. </span><span class="koboSpan" id="kobo.77.7">The host operating system needs to know only the size of the disk drive in terms of the number of logical </span><span class="No-Break"><span class="koboSpan" id="kobo.78.1">block addresses.</span></span></p>
<h2 id="_idParaDest-124"><a id="_idTextAnchor141"/><span class="koboSpan" id="kobo.79.1">Looking at bad sectors</span></h2>
<p><span class="koboSpan" id="kobo.80.1">Bad sectors or blocks are areas on the drive that can no longer be written to or read from, either because they have been corrupted or become damaged. </span><span class="koboSpan" id="kobo.80.2">In such cases, the drive controller will remap the logical sector to a different physical sector. </span><span class="koboSpan" id="kobo.80.3">This can be done transparently, without the knowledge of the host </span><span class="No-Break"><span class="koboSpan" id="kobo.81.1">operating system.</span></span></p>
<p><span class="koboSpan" id="kobo.82.1">There are two different types of bad sectors – hard bad sectors and soft bad sectors. </span><span class="koboSpan" id="kobo.82.2">A </span><strong class="bold"><span class="koboSpan" id="kobo.83.1">hard bad sector</span></strong><span class="koboSpan" id="kobo.84.1"> will have suffered physical damage, such as from a physical impact or a manufacturing defect. </span><span class="koboSpan" id="kobo.84.2">A hard error is usually uncorrectable, and such a sector cannot be used for further storage of data. </span><span class="koboSpan" id="kobo.84.3">A </span><strong class="bold"><span class="koboSpan" id="kobo.85.1">soft bad sector</span></strong><span class="koboSpan" id="kobo.86.1"> is a location on the hard drive that is identified as problematic by the host operating system. </span><span class="koboSpan" id="kobo.86.2">Such a sector can be identified by the operating system if the </span><strong class="bold"><span class="koboSpan" id="kobo.87.1">error-correcting code</span></strong><span class="koboSpan" id="kobo.88.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.89.1">ECC</span></strong><span class="koboSpan" id="kobo.90.1">) of the sector does not match the information that is written to that location. </span><span class="koboSpan" id="kobo.90.2">If an application attempts to retrieve data from a sector and discovers that the ECC does not match the sector’s content, this may indicate the presence of a soft sector error. </span><span class="koboSpan" id="kobo.90.3">These errors can be rectified and resolved by using </span><span class="No-Break"><span class="koboSpan" id="kobo.91.1">various methods.</span></span></p>
<h2 id="_idParaDest-125"><a id="_idTextAnchor142"/><span class="koboSpan" id="kobo.92.1">Looking at hard drive performance</span></h2>
<p><span class="koboSpan" id="kobo.93.1">We’ve often used the term </span><em class="italic"><span class="koboSpan" id="kobo.94.1">seeking</span></em><span class="koboSpan" id="kobo.95.1"> or </span><em class="italic"><span class="koboSpan" id="kobo.96.1">seek time</span></em><span class="koboSpan" id="kobo.97.1"> while highlighting the performance limitations of mechanical drives. </span><span class="koboSpan" id="kobo.97.2">The seek time of a drive refers to the time taken to position the R/W head across the platter surface, over the correct track. </span><span class="koboSpan" id="kobo.97.3">As repeatedly pointed out, random access operations are very costly for mechanical drives. </span><span class="koboSpan" id="kobo.97.4">When accessing data on random tracks, the seek time will increase, as the R/W head will have to be continuously moved. </span><span class="koboSpan" id="kobo.97.5">The lower the seek time of a drive, the faster the servicing of the </span><span class="No-Break"><span class="koboSpan" id="kobo.98.1">I/O requests.</span></span></p>
<p><span class="koboSpan" id="kobo.99.1">Once the R/W head has been positioned over the correct track, the next task is to position the required sector under the head. </span><span class="koboSpan" id="kobo.99.2">To achieve this, the platter is spun to position the requested sector under the R/W head. </span><span class="koboSpan" id="kobo.99.3">The total time taken to complete this task is known as rotational latency. </span><span class="koboSpan" id="kobo.99.4">This operation is dependent on the speed of the spindle motor. </span><span class="koboSpan" id="kobo.99.5">The higher the RPM of the motor, the lower will be the rotational latency. </span><span class="koboSpan" id="kobo.99.6">Again, if requests are for adjacent sectors on a track, the rotational latency will be on the lower side. </span><span class="koboSpan" id="kobo.99.7">To read and write data on random sectors, the rotational latency will </span><span class="No-Break"><span class="koboSpan" id="kobo.100.1">be higher.</span></span></p>
<p><span class="koboSpan" id="kobo.101.1">The drive heads require alignment over a specific area of the spinning disk to read or write data, resulting in a delay before data can be accessed. </span><span class="koboSpan" id="kobo.101.2">To launch a program or load a file, the drive may have to read from various locations, which can lead to multiple delays as the platters need to spin into the correct position </span><span class="No-Break"><span class="koboSpan" id="kobo.102.1">each time.</span></span></p>
<h2 id="_idParaDest-126"><a id="_idTextAnchor143"/><span class="koboSpan" id="kobo.103.1">Understanding where mechanical drives lag</span></h2>
<p><span class="koboSpan" id="kobo.104.1">E</span><a id="_idTextAnchor144"/><span class="koboSpan" id="kobo.105.1">ver since their inception, it was quite clear that mechanical drives could not possibly match the speeds at which CPUs operate. </span><span class="koboSpan" id="kobo.105.2">Response times for mechanical drives are measured in milliseconds, as compared to nanoseconds for CPUs. </span><span class="koboSpan" id="kobo.105.3">The presence of mechanical components in the design also limits the performance. </span><span class="koboSpan" id="kobo.105.4">It is not that efforts were not made to improve the physical structure of hard drives. </span><span class="koboSpan" id="kobo.105.5">For instance, hard drives were equipped with a small on-disk cache to improve performance. </span><span class="koboSpan" id="kobo.105.6">Over the years, the speed of the spindle motor has increased from a few hundred rpm to as high as 15,000 rpm. </span><span class="koboSpan" id="kobo.105.7">Smaller platter surfaces were also designed for performance improvement. </span><span class="koboSpan" id="kobo.105.8">All these factors have contributed to significantly improving the performance of mechanical drives. </span><span class="koboSpan" id="kobo.105.9">However, despite all this, e</span><a id="_idTextAnchor145"/><span class="koboSpan" id="kobo.106.1">ven the fastest rotating drives are still far too slow compared to a CPU. </span><span class="koboSpan" id="kobo.106.2">A major portion of time is spent on the movement of </span><span class="No-Break"><span class="koboSpan" id="kobo.107.1">mechanical parts.</span></span></p>
<p><span class="koboSpan" id="kobo.108.1">Because of the limitations in the speed of mechanical components, the performance of hard drives falls short in comparison with some modern storage options. </span><span class="koboSpan" id="kobo.108.2">The performance of a hard drive is deeply dependent on the read-and-write patterns of the applications. </span><span class="koboSpan" id="kobo.108.3">For sequential operations, the performance is significantly better. </span><span class="koboSpan" id="kobo.108.4">However, for random access operations, the hard drive performance deteriorates as these operations involve the frequent movement of the R/W head and the continuous rotation of the platter surface. </span><span class="koboSpan" id="kobo.108.5">However, despite these drawbacks, mechanical drives are still considered an important part of any enterprise environment. </span><span class="koboSpan" id="kobo.108.6">The lower per-gigabyte cost of mechanical drives makes them an excellent choice for cases where capacity is the </span><span class="No-Break"><span class="koboSpan" id="kobo.109.1">primary concern.</span></span></p>
<p><span class="koboSpan" id="kobo.110.1">Now that we have a fundamental understanding of mechanical drives, let’s explore solid-state drives and examine how they differ from traditional </span><span class="No-Break"><span class="koboSpan" id="kobo.111.1">rotating media.</span></span></p>
<h1 id="_idParaDest-127"><a id="_idTextAnchor146"/><span class="koboSpan" id="kobo.112.1">Explaining the architecture of solid-state drives</span></h1>
<p><span class="koboSpan" id="kobo.113.1">The performance of enterprise storage took a huge leap with the introduction of </span><strong class="bold"><span class="koboSpan" id="kobo.114.1">SSDs</span></strong><span class="koboSpan" id="kobo.115.1">. </span><span class="koboSpan" id="kobo.115.2">SSDs are so-called since they are based on semiconductor materials. </span><span class="koboSpan" id="kobo.115.3">Unlike rotating drives, SSDs do not have any mechanical parts and use non-volatile memory chips to store data. </span><span class="koboSpan" id="kobo.115.4">Given the absence of moving components, it is no surprise that SSDs are way faster than mechanical drives. </span><span class="koboSpan" id="kobo.115.5">They offer a significant upgrade over traditional drives and have gradually replaced mechanical drives as the first-choice </span><span class="No-Break"><span class="koboSpan" id="kobo.116.1">storage media.</span></span></p>
<p><span class="koboSpan" id="kobo.117.1">SSDs make use of flash memory chips for the permanent storage of data. </span><span class="koboSpan" id="kobo.117.2">There are two options in this regard, NAND and NOR flash. </span><span class="koboSpan" id="kobo.117.3">Most SSDs use NAND flash chips, as they offer faster write and erasure times. </span><span class="koboSpan" id="kobo.117.4">At the risk of diving too much into electronics (my least favorite subject in college), a NAND flash is made up of floating-gate transistors, and electrons are stored in a floating gate. </span><span class="koboSpan" id="kobo.117.5">When the floating gate contains a charge, it is read as zero. </span><span class="koboSpan" id="kobo.117.6">This signifies that data is stored in a cell, contrary to what we typically think (you can see why I didn’t </span><span class="No-Break"><span class="koboSpan" id="kobo.118.1">like electronics).</span></span></p>
<p><span class="koboSpan" id="kobo.119.1">The primary components of an SSD are displayed </span><span class="No-Break"><span class="koboSpan" id="kobo.120.1">as follows:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer077">
<span class="koboSpan" id="kobo.121.1"><img alt="Figure 8.2 – Architecture of an SSD" src="image/B19430_08_02.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.122.1">Figure 8.2 – Architecture of an SSD</span></p>
<p><span class="koboSpan" id="kobo.123.1">The SSD controller performs a variety of functions and presents the raw storage in the NAND flash to </span><span class="No-Break"><span class="koboSpan" id="kobo.124.1">the host.</span></span></p>
<h2 id="_idParaDest-128"><a id="_idTextAnchor147"/><span class="koboSpan" id="kobo.125.1">Looking at the physical layout and addressing</span></h2>
<p><span class="koboSpan" id="kobo.126.1">Each NAND flash memory in an SSD consists of the </span><span class="No-Break"><span class="koboSpan" id="kobo.127.1">following components:</span></span></p>
<ul>
<li><strong class="bold"><span class="koboSpan" id="kobo.128.1">Gates</span></strong><span class="koboSpan" id="kobo.129.1">: Floating-gate transistors are a crucial component of SSDs, responsible for the conduction, retention, and release of the electrical charge in the cells, using the electrons stored within the </span><span class="No-Break"><span class="koboSpan" id="kobo.130.1">floating gate.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.131.1">Cell</span></strong><span class="koboSpan" id="kobo.132.1">: A cell is a basic unit of storage that can contain a single piece of data, with its electrical charge representing the value of the bit(s). </span><span class="koboSpan" id="kobo.132.2">As we will see shortly, cells can hold either a single level or multiple levels </span><span class="No-Break"><span class="koboSpan" id="kobo.133.1">of charge.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.134.1">Byte</span></strong><span class="koboSpan" id="kobo.135.1">: A single byte comprises </span><span class="No-Break"><span class="koboSpan" id="kobo.136.1">eight cells.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.137.1">Page</span></strong><span class="koboSpan" id="kobo.138.1">: In SSDs, a page is comparable to a sector on a hard drive and represents the smallest unit that can be written to and read from. </span><span class="koboSpan" id="kobo.138.2">Typically, a page has a size of 4 KB, although it can be larger than </span><span class="No-Break"><span class="koboSpan" id="kobo.139.1">this value.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.140.1">Block</span></strong><span class="koboSpan" id="kobo.141.1">: A block is a collection of pages in an SSD. </span><span class="koboSpan" id="kobo.141.2">Erase operations in SSDs are carried out in terms of blocks, which means that all pages within a block must be </span><span class="No-Break"><span class="koboSpan" id="kobo.142.1">erased together.</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.143.1">Internally, bits in an SSD are stored in cells, which are then organized into pages. </span><span class="koboSpan" id="kobo.143.2">Pages are grouped into blocks, which are in turn encapsulated in a plane, as illustrated in </span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.144.1">Figure 8</span></em></span><em class="italic"><span class="koboSpan" id="kobo.145.1">.3</span></em><span class="koboSpan" id="kobo.146.1">. </span><span class="koboSpan" id="kobo.146.2">A die chip typically consists of </span><span class="No-Break"><span class="koboSpan" id="kobo.147.1">multiple planes:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer078">
<span class="koboSpan" id="kobo.148.1"><img alt="Figure 8.3 – A die layout in SSDs" src="image/B19430_08_03.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.149.1">Figure 8.3 – A die layout in SSDs</span></p>
<p><span class="koboSpan" id="kobo.150.1">The terms </span><em class="italic"><span class="koboSpan" id="kobo.151.1">SLC</span></em><span class="koboSpan" id="kobo.152.1"> and </span><em class="italic"><span class="koboSpan" id="kobo.153.1">MLC</span></em><span class="koboSpan" id="kobo.154.1"> describe the number of bits that are stored per cell. </span><span class="koboSpan" id="kobo.154.2">In addition to SLC and MLC, there are also </span><strong class="bold"><span class="koboSpan" id="kobo.155.1">triple-level cell</span></strong><span class="koboSpan" id="kobo.156.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.157.1">TLC</span></strong><span class="koboSpan" id="kobo.158.1">) and </span><strong class="bold"><span class="koboSpan" id="kobo.159.1">quad-level cell</span></strong><span class="koboSpan" id="kobo.160.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.161.1">QLC</span></strong><span class="koboSpan" id="kobo.162.1">) flash drives. </span><span class="koboSpan" id="kobo.162.2">Adding more bits per cell of NAND has a significant impact on the performance of a NAND flash. </span><span class="koboSpan" id="kobo.162.3">As the number of bits stored per cell increases, the performance of the flash decreases, while the available capacity increases. </span><a id="_idTextAnchor148"/><span class="koboSpan" id="kobo.163.1">With </span><strong class="source-inline"><span class="koboSpan" id="kobo.164.1">SLC NAND</span></strong><span class="koboSpan" id="kobo.165.1">, the flash controller only needs to know whether the bit is 0 or 1. </span><span class="koboSpan" id="kobo.165.2">With </span><strong class="source-inline"><span class="koboSpan" id="kobo.166.1">MLC NAND</span></strong><span class="koboSpan" id="kobo.167.1">, the cell can have four values – </span><strong class="source-inline"><span class="koboSpan" id="kobo.168.1">00</span></strong><span class="koboSpan" id="kobo.169.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.170.1">01</span></strong><span class="koboSpan" id="kobo.171.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.172.1">10</span></strong><span class="koboSpan" id="kobo.173.1">, or </span><strong class="source-inline"><span class="koboSpan" id="kobo.174.1">11</span></strong><span class="koboSpan" id="kobo.175.1">. </span><span class="koboSpan" id="kobo.175.2">Similarly, with </span><strong class="source-inline"><span class="koboSpan" id="kobo.176.1">TLC NAND</span></strong><span class="koboSpan" id="kobo.177.1">, the cell can have </span><strong class="source-inline"><span class="koboSpan" id="kobo.178.1">8</span></strong><span class="koboSpan" id="kobo.179.1"> values, and QLC can have </span><strong class="source-inline"><span class="koboSpan" id="kobo.180.1">16</span></strong><span class="koboSpan" id="kobo.181.1"> values. </span><span class="koboSpan" id="kobo.181.2">The following diagram displays the relationship between various types </span><span class="No-Break"><span class="koboSpan" id="kobo.182.1">of SSDs:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer079">
<span class="koboSpan" id="kobo.183.1"><img alt="Figure 8.4 – A comparison of SLC, MLC, TLC, and QLC flash" src="image/B19430_08_04.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.184.1">Figure 8.4 – A comparison of SLC, MLC, TLC, and QLC flash</span></p>
<p><span class="koboSpan" id="kobo.185.1">Like a mechanical drive, SSDs also use LBA to address physical locations, but there are some extra components involved in this process. </span><span class="koboSpan" id="kobo.185.2">A NAND flash uses a </span><strong class="bold"><span class="koboSpan" id="kobo.186.1">flash translation layer</span></strong><span class="koboSpan" id="kobo.187.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.188.1">FTL</span></strong><span class="koboSpan" id="kobo.189.1">) to map logical block addresses to physical pages. </span><span class="koboSpan" id="kobo.189.2">The FTL hides the inner complexities of the NAND flash memory and only exposes an array of logical block addresses to the host. </span><span class="koboSpan" id="kobo.189.3">This is deliberately done to emulate a mechanical drive, as most of the stack on the operating system side is optimized to work with </span><span class="No-Break"><span class="koboSpan" id="kobo.190.1">mechanical drives.</span></span></p>
<h2 id="_idParaDest-129"><a id="_idTextAnchor149"/><span class="koboSpan" id="kobo.191.1">Looking at reads and writes</span></h2>
<p><span class="koboSpan" id="kobo.192.1">Unlike a hard drive, where a sector is a fundamental unit for all operations, SSDs use different units to perform different operations. </span><span class="koboSpan" id="kobo.192.2">The SSDs read and write data at the page level, while all erase operations are performed at the block level. </span><span class="koboSpan" id="kobo.192.3">The sectors in mechanical drives can be rewritten repeatedly, whereas pages in SSDs can never be overwritten, and as we’ll see in the subsequent section, there is a good reason </span><span class="No-Break"><span class="koboSpan" id="kobo.193.1">for that.</span></span></p>
<p><span class="koboSpan" id="kobo.194.1">The equivalent of sectors in SSDs is pages. </span><span class="koboSpan" id="kobo.194.2">It is not possible to read a single cell individually. </span><span class="koboSpan" id="kobo.194.3">Read operations align with the native page size of the device. </span><span class="koboSpan" id="kobo.194.4">For instance, given a page size of 4 KB, if you want to read 2 KB of data, the flash controller will fetch the full 4 KB page. </span><span class="koboSpan" id="kobo.194.5">Similarly, writes also follow the same routine. </span><span class="koboSpan" id="kobo.194.6">The write operations align on a page and occur by page size. </span><span class="koboSpan" id="kobo.194.7">Given a page size of 4 KB, writing 6 KB of data will use two 4 </span><span class="No-Break"><span class="koboSpan" id="kobo.195.1">KB pages.</span></span></p>
<h2 id="_idParaDest-130"><a id="_idTextAnchor150"/><span class="koboSpan" id="kobo.196.1">Erasing, garbage collection, and the illusion of available space</span></h2>
<p><span class="koboSpan" id="kobo.197.1">When an application writes to a NAND flash, the flash must allocate a new blank page for the new data. </span><span class="koboSpan" id="kobo.197.2">Erasing NAND flash memory requires a high voltage, and if performed at the page level, it can negatively impact neighboring cells and limit their lifespan. </span><span class="koboSpan" id="kobo.197.3">Therefore, SSDs erase data at the block level to mitigate this issue, though it increases the complexity of the erase operation. </span><span class="koboSpan" id="kobo.197.4">The erase operation is a crucial factor in determining the lifespan of a NAND flash. </span><span class="koboSpan" id="kobo.197.5">The term </span><strong class="bold"><span class="koboSpan" id="kobo.198.1">Program and Erase Cycle</span></strong><span class="koboSpan" id="kobo.199.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.200.1">P/E</span></strong><span class="koboSpan" id="kobo.201.1">) reflects the life of an SSD, based on the number of P/E cycles the NAND flash can endure. </span><span class="koboSpan" id="kobo.201.2">When a block is written to and erased, that is counted as one cycle. </span><span class="koboSpan" id="kobo.201.3">This is important because blocks can be written to a finite number of times, beyond which they cannot write new </span><span class="No-Break"><span class="koboSpan" id="kobo.202.1">data anymore.</span></span></p>
<p><span class="koboSpan" id="kobo.203.1">So, how does an SSD erase data? </span><span class="koboSpan" id="kobo.203.2">Let’s say that we write some data to an SSD. </span><span class="koboSpan" id="kobo.203.3">The write operation, also called the program operation, takes place at the page level. </span><span class="koboSpan" id="kobo.203.4">After some time, we realize that the previously written data needs to be updated with some new content. </span><span class="koboSpan" id="kobo.203.5">There are two </span><span class="No-Break"><span class="koboSpan" id="kobo.204.1">cases here:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.205.1">Enough free pages are available </span><span class="No-Break"><span class="koboSpan" id="kobo.206.1">in blocks</span></span></li>
<li><span class="koboSpan" id="kobo.207.1">Enough free pages are available, but all blocks contain a mix of free, used, and stale pages, or a mix of used and </span><span class="No-Break"><span class="koboSpan" id="kobo.208.1">stale pages</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.209.1">Let’s say that there are free pages available. </span><span class="koboSpan" id="kobo.209.2">The flash controller will write the updated data to any free empty pages, and the older pages will be marked as stale. </span><span class="koboSpan" id="kobo.209.3">The pages that are marked as stale are part of a block. </span><span class="koboSpan" id="kobo.209.4">It is quite possible that some of the other pages in the same block contain data that is in use. </span><span class="koboSpan" id="kobo.209.5">When a page in a block needs to be updated, the flash controller reads the contents of the entire block (which contains the said page) in its memory and computes the updated value of the page. </span><span class="koboSpan" id="kobo.209.6">Then, it performs an erase operation on that block. </span><span class="koboSpan" id="kobo.209.7">This block erase operation erases the contents of the entire block, including the pages, other than the one that was to be updated. </span><a id="_idTextAnchor151"/><span class="koboSpan" id="kobo.210.1">The flash controller then writes the previous contents of the block and the updated value of said page. </span><span class="koboSpan" id="kobo.210.2">This entire process is called write amplification. </span><span class="koboSpan" id="kobo.210.3">Write amplification refers to a situation where the number of write operations performed by the storage device is more than the number of operations performed by the </span><span class="No-Break"><span class="koboSpan" id="kobo.211.1">host device.</span></span></p>
<p><span class="koboSpan" id="kobo.212.1">As all erase operations are performed at the block level, how can we reclaim space occupied by stale pages? </span><span class="koboSpan" id="kobo.212.2">Surely, the controller will not wait for all pages in a block to become stale before erasing them? </span><span class="koboSpan" id="kobo.212.3">If that’s the case, then the drive will run out of free pages very soon. </span><span class="koboSpan" id="kobo.212.4">Clearly, this approach can have some dangerous consequences. </span><span class="koboSpan" id="kobo.212.5">This brings us to the second point – how will an SSD cope with a situation when there aren’t enough free pages available to accommodate new writes, or all the blocks contain a combination of used and stale pages? </span><span class="koboSpan" id="kobo.212.6">To reclaim stale pages, the erase operation needs to be applied at the block level, but where do we put all the pages that are currently in use? </span><span class="koboSpan" id="kobo.212.7">The following figure highlights this </span><span class="No-Break"><span class="koboSpan" id="kobo.213.1">specific scenario:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer080">
<span class="koboSpan" id="kobo.214.1"><img alt="Figure 8.5 – Where do we write incoming data?" src="image/B19430_08_05.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.215.1">Figure 8.5 – Where do we write incoming data?</span></p>
<p><span class="koboSpan" id="kobo.216.1">That’s where the illusion of over-provisioning comes in. </span><span class="koboSpan" id="kobo.216.2">There’s a lot more space in a flash drive than is visible to the end user. </span><span class="koboSpan" id="kobo.216.3">This unallocated space is reserved by the SSD controller for operations such as wear leveling and garbage collection. </span><span class="koboSpan" id="kobo.216.4">That extra space comes in handy in situations such as when there</span><a id="_idIndexMarker207"/><span class="koboSpan" id="kobo.217.1"> is a need to free up stale blocks. </span><span class="koboSpan" id="kobo.217.2">The process of cleaning up stale blocks is known as garbage collection. </span><span class="koboSpan" id="kobo.217.3">Usually, SSDs can have 20-40% extra capacity than advertised. </span><span class="koboSpan" id="kobo.217.4">Flash drive vendors use this trick across the board, from SSDs</span><a id="_idIndexMarker208"/><span class="koboSpan" id="kobo.218.1"> used for personal systems to SSDs</span><a id="_idIndexMarker209"/><span class="koboSpan" id="kobo.219.1"> used in enterprise storage arrays. </span><span class="koboSpan" id="kobo.219.2">This extra</span><a id="_idIndexMarker210"/><span class="koboSpan" id="kobo.220.1"> space contributes to improving the endurance and write performance of </span><span class="No-Break"><span class="koboSpan" id="kobo.221.1">the SSD.</span></span></p>
<h2 id="_idParaDest-131"><a id="_idTextAnchor152"/><span class="koboSpan" id="kobo.222.1">Looking at wear leveling</span></h2>
<p><span class="koboSpan" id="kobo.223.1">Given the limited number of P/E cycles, the purpose</span><a id="_idIndexMarker211"/><span class="koboSpan" id="kobo.224.1"> of the wear-leveling operation is to increase an SSD lifespan by making sure that data is distributed evenly across the pages. </span><span class="koboSpan" id="kobo.224.2">When data in a particular cell needs to be modified, the wear-leveling process informs the FTL to remap the LBA to point to the new block. </span><span class="koboSpan" id="kobo.224.3">Wear-leveling marks the old data as stale. </span><span class="koboSpan" id="kobo.224.4">As explained earlier, the current block does not have to be erased. </span><span class="koboSpan" id="kobo.224.5">All these decisions are taken to extend the life of a cell. </span><span class="koboSpan" id="kobo.224.6">For instance, if a host application frequently updates values in a single cell, and the flash controller modifies the same block again and again, the insulators of this cell will wear</span><a id="_idIndexMarker212"/><span class="koboSpan" id="kobo.225.1"> out </span><span class="No-Break"><span class="koboSpan" id="kobo.226.1">more quickly.</span></span></p>
<h2 id="_idParaDest-132"><a id="_idTextAnchor153"/><span class="koboSpan" id="kobo.227.1">Looking at bad block management</span></h2>
<p><span class="koboSpan" id="kobo.228.1">As each cell can only</span><a id="_idIndexMarker213"/><span class="koboSpan" id="kobo.229.1"> go through a finite number of P/E cycles, it is important to keep track of cells that have become defective and cannot be programmed or erased anymore. </span><span class="koboSpan" id="kobo.229.2">From this point, the cell is considered to be a bad block. </span><span class="koboSpan" id="kobo.229.3">The controller keeps a table of all the bad blocks. </span><span class="koboSpan" id="kobo.229.4">If pages in the block contain valid data, then existing data in the block is copied over to a new block, and the bad block table </span><span class="No-Break"><span class="koboSpan" id="kobo.230.1">is updated.</span></span></p>
<h2 id="_idParaDest-133"><a id="_idTextAnchor154"/><span class="koboSpan" id="kobo.231.1">Looking at SSD performance</span></h2>
<p><span class="koboSpan" id="kobo.232.1">The use of NAND flash</span><a id="_idIndexMarker214"/><span class="koboSpan" id="kobo.233.1"> in SSDs makes SSDs really fast. </span><span class="koboSpan" id="kobo.233.2">Although the performance is still nowhere near as fast as the main memory, it's multiple orders of magnitude faster than a spinning hard drive. </span><span class="koboSpan" id="kobo.233.3">The absence of any mechanical components ensures that an SSD is not pinned down by the factors that limit a mechanical drive’s performance. </span><span class="koboSpan" id="kobo.233.4">Random access operations, which are the Achilles heel of a mechanical drive, are no longer a worry when </span><span class="No-Break"><span class="koboSpan" id="kobo.234.1">using SSDs.</span></span></p>
<h2 id="_idParaDest-134"><a id="_idTextAnchor155"/><span class="koboSpan" id="kobo.235.1">Understanding where SSDs lag</span></h2>
<p><span class="koboSpan" id="kobo.236.1">The thing with electronic devices</span><a id="_idIndexMarker215"/><span class="koboSpan" id="kobo.237.1"> is that they’re mostly designed to last for a certain period of time. </span><span class="koboSpan" id="kobo.237.2">This is also the case with SSDs; there is a certain life expectancy associated with them. </span><span class="koboSpan" id="kobo.237.3">Again, to keep the physics and electronics stuff short and sweet, the write process in SSDs stores electrons, and the erase process drains the voltage in the floating-gate transistor. </span><span class="koboSpan" id="kobo.237.4">This sequence of events is known as the P/E cycle. </span><span class="koboSpan" id="kobo.237.5">Each NAND cell contains</span><a id="_idIndexMarker216"/><span class="koboSpan" id="kobo.238.1"> insulators that help to retain voltage in a cell. </span><span class="koboSpan" id="kobo.238.2">Every time a cell goes through a P/E cycle, the insulator goes through some damage. </span><span class="koboSpan" id="kobo.238.3">The extent of this damage is limited in nature, but over time, this builds up, and eventually, the insulators will lose their capabilities. </span><span class="koboSpan" id="kobo.238.4">This may result in voltage leakage, which can result in a change between voltage states. </span><span class="koboSpan" id="kobo.238.5">After this, the cell will be considered defective and can no longer be used for storage. </span><span class="koboSpan" id="kobo.238.6">If too many cells reach their fate, the drive will cease to work properly. </span><span class="koboSpan" id="kobo.238.7">This is why mechanical hard drives have better endurance </span><span class="No-Break"><span class="koboSpan" id="kobo.239.1">than SSDs.</span></span></p>
<p><span class="koboSpan" id="kobo.240.1">You’ll often see that the specification sheet for an SSD will contain the number of P/E cycles that it can endure. </span><span class="koboSpan" id="kobo.240.2">However, this does not mean that SSDs cannot be used for long-term storage. </span><span class="koboSpan" id="kobo.240.3">Although there is a limit associated with their life expectancy, that limit is usually quite long. </span><span class="koboSpan" id="kobo.240.4">It can continue to be used for years. </span><span class="koboSpan" id="kobo.240.5">There are a lot of tools out there that can check the health and wear level of an SSD. </span><em class="italic"><span class="koboSpan" id="kobo.241.1">Table 8.1</span></em><span class="koboSpan" id="kobo.242.1"> highlights some common drive operations</span><a id="_idIndexMarker217"/><span class="koboSpan" id="kobo.243.1"> for mechanical drives and SSDs, showing their </span><span class="No-Break"><span class="koboSpan" id="kobo.244.1">fundamental units:</span></span></p>
<table class="No-Table-Style _idGenTablePara-1" id="table001-6">
<colgroup>
<col/>
<col/>
<col/>
</colgroup>
<tbody>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.245.1">Drive</span></strong></span></p>
</td>
<td class="No-Table-Style">
<p><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.246.1">Operation</span></strong></span></p>
</td>
<td class="No-Table-Style">
<p><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.247.1">Unit</span></strong></span></p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style" rowspan="5">
<p><span class="No-Break" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.248.1">Mechanical disk</span></span></p>
</td>
<td class="No-Table-Style">
<p><span class="No-Break" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.249.1">Read</span></span></p>
</td>
<td class="No-Table-Style">
<p><span class="No-Break" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.250.1">Sector</span></span></p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><span class="No-Break" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.251.1">Write</span></span></p>
</td>
<td class="No-Table-Style">
<p><span class="No-Break" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.252.1">Sector</span></span></p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><span class="No-Break" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.253.1">Update</span></span></p>
</td>
<td class="No-Table-Style">
<p><span class="No-Break" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.254.1">Sector</span></span></p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><span class="No-Break" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.255.1">Erase</span></span></p>
</td>
<td class="No-Table-Style">
<p><span class="No-Break" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.256.1">Sector</span></span></p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><span lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.257.1">Bad </span></span><span class="No-Break" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.258.1">block management</span></span></p>
</td>
<td class="No-Table-Style">
<p><span class="No-Break" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.259.1">Sector</span></span></p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style" rowspan="5">
<p><span class="No-Break" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.260.1">SSD</span></span></p>
</td>
<td class="No-Table-Style">
<p><span class="No-Break" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.261.1">Read</span></span></p>
</td>
<td class="No-Table-Style">
<p><span class="No-Break" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.262.1">Page</span></span></p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><span class="No-Break" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.263.1">Write</span></span></p>
</td>
<td class="No-Table-Style">
<p><span class="No-Break" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.264.1">Page</span></span></p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><span class="No-Break" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.265.1">Update</span></span></p>
</td>
<td class="No-Table-Style">
<p><span class="No-Break" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.266.1">Block</span></span></p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><span class="No-Break" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.267.1">Erase</span></span></p>
</td>
<td class="No-Table-Style">
<p><span class="No-Break" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.268.1">Block</span></span></p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><span lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.269.1">Bad </span></span><span class="No-Break" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.270.1">block management</span></span></p>
</td>
<td class="No-Table-Style">
<p><span class="No-Break" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.271.1">Block</span></span></p>
</td>
</tr>
</tbody>
</table>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.272.1">Table 8.1 – The operational units of SSDs and HDDs</span></p>
<p><span class="koboSpan" id="kobo.273.1">In terms of performance, SSDs offer huge benefits compared to traditional mechanical drives. </span><span class="koboSpan" id="kobo.273.2">They have far lower latencies, which has pushed applications toward new performance thresholds. </span><span class="koboSpan" id="kobo.273.3">They have now become common not only in enterprise environments but also in personal systems. </span><span class="koboSpan" id="kobo.273.4">They do not have any mechanical components, and most drives make use of the NAND flash for persistent storage of data. </span><span class="koboSpan" id="kobo.273.5">They have far more complex internal structures and policies than a rotating drive. </span><span class="koboSpan" id="kobo.273.6">They are more expensive than mechanical drives but outperform</span><a id="_idIndexMarker218"/><span class="koboSpan" id="kobo.274.1"> them in almost every </span><span class="No-Break"><span class="koboSpan" id="kobo.275.1">other aspect.</span></span></p>
<p><span class="koboSpan" id="kobo.276.1">Let’s briefly touch on the topic of drive endurance before we delve into the world of </span><span class="No-Break"><span class="koboSpan" id="kobo.277.1">NVMe drives.</span></span></p>
<h1 id="_idParaDest-135"><a id="_idTextAnchor156"/><span class="koboSpan" id="kobo.278.1">Understanding drive endurance</span></h1>
<p><span class="koboSpan" id="kobo.279.1">There is usually an endurance rating</span><a id="_idIndexMarker219"/><span class="koboSpan" id="kobo.280.1"> associated with both mechanical drives and SSDs. </span><span class="koboSpan" id="kobo.280.2">The endurance</span><a id="_idIndexMarker220"/><span class="koboSpan" id="kobo.281.1"> of a drive defines multiple things, such as its maximum performance, workload limits, and its </span><strong class="bold"><span class="koboSpan" id="kobo.282.1">mean time between failures</span></strong><span class="koboSpan" id="kobo.283.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.284.1">MBTF</span></strong><span class="koboSpan" id="kobo.285.1">). </span><span class="koboSpan" id="kobo.285.2">Owing to their contrasting natures, the endurance</span><a id="_idIndexMarker221"/><span class="koboSpan" id="kobo.286.1"> of mechanical drives and SSDs is measured in </span><span class="No-Break"><span class="koboSpan" id="kobo.287.1">differing ways.</span></span></p>
<p><span class="koboSpan" id="kobo.288.1">The endurance ratings for both types of drives are expressed in different ways. </span><span class="koboSpan" id="kobo.288.2">As explained earlier, cells in the NAND flash can go through a finite number of P/E cycles. </span><span class="koboSpan" id="kobo.288.3">Once this limit is reached, the cell will become defective. </span><span class="koboSpan" id="kobo.288.4">The endurance rating for SSDs is a function of the number of P/E cycles for which the NAND is rated. </span><span class="koboSpan" id="kobo.288.5">It is important to note that NAND cells only wear out for write (program) and erase operations. </span><span class="koboSpan" id="kobo.288.6">For read operations, this overhead is negligible. </span><span class="koboSpan" id="kobo.288.7">The metrics</span><a id="_idIndexMarker222"/><span class="koboSpan" id="kobo.289.1"> to measure the endurance of SSDs are </span><span class="No-Break"><span class="koboSpan" id="kobo.290.1">as follows:</span></span></p>
<ul>
<li><strong class="bold"><span class="koboSpan" id="kobo.291.1">Drive Writes per Day</span></strong><span class="koboSpan" id="kobo.292.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.293.1">DWPD</span></strong><span class="koboSpan" id="kobo.294.1">): The DWPD rating shows how many times you can overwrite</span><a id="_idIndexMarker223"/><span class="koboSpan" id="kobo.295.1"> an entire SSD each day of </span><span class="No-Break"><span class="koboSpan" id="kobo.296.1">its life</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.297.1">Terabytes written</span></strong><span class="koboSpan" id="kobo.298.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.299.1">TBW</span></strong><span class="koboSpan" id="kobo.300.1">): The TBW rating represents</span><a id="_idIndexMarker224"/><span class="koboSpan" id="kobo.301.1"> how much data can be written to a drive across its entire life, before you may need to </span><span class="No-Break"><span class="koboSpan" id="kobo.302.1">replace it</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.303.1">If you have an SSD of 100 GB, with a warranty period of three years and a DWPD rating of 1, that means you can write 100 GB of data to the drive every single day, for the next three years, which means your TBW rating will be </span><span class="No-Break"><span class="koboSpan" id="kobo.304.1">109 TBW:</span></span></p>
<p><em class="italic"><span class="koboSpan" id="kobo.305.1">100 GB x 365 days x 3 years ≈</span></em><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.306.1">109 TB</span></em></span></p>
<p><span class="koboSpan" id="kobo.307.1">Mechanical hard drives are different, as they are not impacted by P/E cycles. </span><span class="koboSpan" id="kobo.307.2">The magnetic platter surface on mechanical drives supports the overwriting of data. </span><span class="koboSpan" id="kobo.307.3">If there is already data in the physical location to be written, the existing data can be directly overwritten with new data. </span><span class="koboSpan" id="kobo.307.4">However, while SSD ratings are affected only by write operations and not by the number of read operations, mechanical drives on the other hand are affected by both read and write operations. </span><span class="koboSpan" id="kobo.307.5">Hence, the rating for mechanical drives is specified in terms of the number of bytes written and/or read. </span><span class="koboSpan" id="kobo.307.6">This workload limit does not have an official term, but going by the terms</span><a id="_idIndexMarker225"/><span class="koboSpan" id="kobo.308.1"> used for SSD, this can be unofficially called </span><strong class="bold"><span class="koboSpan" id="kobo.309.1">Drive Writes/Read per Day</span></strong><span class="koboSpan" id="kobo.310.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.311.1">DWRPD</span></strong><span class="koboSpan" id="kobo.312.1">). </span><span class="koboSpan" id="kobo.312.2">The impact of read and write operations on drive endurance is illustrated in </span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.313.1">Table 8.2</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.314.1">:</span></span></p>
<table class="No-Table-Style _idGenTablePara-1" id="table002">
<colgroup>
<col/>
<col/>
<col/>
<col/>
</colgroup>
<tbody>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.315.1">Drive type</span></strong></span></p>
</td>
<td class="No-Table-Style">
<p><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.316.1">Workload rating</span></strong></span></p>
</td>
<td class="No-Table-Style">
<p><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.317.1">Operation</span></strong></span></p>
</td>
<td class="No-Table-Style">
<p><strong class="bold"><span class="koboSpan" id="kobo.318.1">Effect </span></strong><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.319.1">on endurance</span></strong></span></p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style" rowspan="2">
<p><span class="No-Break" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.320.1">Mechanical disk</span></span></p>
</td>
<td class="No-Table-Style" rowspan="2">
<p><span class="No-Break" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.321.1">DWPD</span></span></p>
</td>
<td class="No-Table-Style">
<p><span class="No-Break" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.322.1">Read</span></span></p>
</td>
<td class="No-Table-Style">
<p><span class="No-Break" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.323.1">Decreases</span></span></p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><span class="No-Break" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.324.1">Write</span></span></p>
</td>
<td class="No-Table-Style">
<p><span class="No-Break" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.325.1">Decreases</span></span></p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style" rowspan="2">
<p><span class="No-Break" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.326.1">SSD</span></span></p>
</td>
<td class="No-Table-Style" rowspan="2">
<p><span class="No-Break" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.327.1">DWRPD</span></span></p>
</td>
<td class="No-Table-Style">
<p><span class="No-Break" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.328.1">Read</span></span></p>
</td>
<td class="No-Table-Style">
<p><span class="No-Break" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.329.1">Negligible impact</span></span></p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><span class="No-Break" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.330.1">Write</span></span></p>
</td>
<td class="No-Table-Style">
<p><span class="No-Break" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.331.1">Decreases</span></span></p>
</td>
</tr>
</tbody>
</table>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.332.1">Table 8.2 – Drive endurance</span></p>
<p><em class="italic"><span class="koboSpan" id="kobo.333.1">Table 8.2</span></em><span class="koboSpan" id="kobo.334.1"> summarizes the effect of read and write operations on both types of drives. </span><span class="koboSpan" id="kobo.334.2">The actual warranted values will differ across the different storage vendors. </span><span class="koboSpan" id="kobo.334.3">The workload limits for mechanical drives are also expressed in terms of the TB of data that can be read/written per year. </span><span class="koboSpan" id="kobo.334.4">When checking for endurance, keep in mind that terms such as DWPD and TBW are just numbers. </span><span class="koboSpan" id="kobo.334.5">It is critical to understand that the warranty period is the key to determining the actual endurance. </span><span class="koboSpan" id="kobo.334.6">It’s best to use both the warranty period and DWPD when choosing </span><span class="No-Break"><span class="koboSpan" id="kobo.335.1">a drive.</span></span></p>
<p><span class="koboSpan" id="kobo.336.1">Now, let’s explore how the NVMe interface has revolutionized </span><span class="No-Break"><span class="koboSpan" id="kobo.337.1">traditional SSDs.</span></span></p>
<h1 id="_idParaDest-136"><a id="_idTextAnchor157"/><span class="koboSpan" id="kobo.338.1">Reinventing SSDs with NVMe</span></h1>
<p><span class="koboSpan" id="kobo.339.1">There are several transport protocols that are used to access mechanical and SSDs. </span><span class="koboSpan" id="kobo.339.2">Protocols such as SATA, SCSI, and SAS were originally designed for mechanical drives. </span><span class="koboSpan" id="kobo.339.3">Hence, these are more geared toward leveraging the potential of rotating drives. </span><span class="koboSpan" id="kobo.339.4">With the inception of SSDs, these protocols began to be used for these types of drives as well. </span><span class="koboSpan" id="kobo.339.5">Most SSDs, especially in the earlier days, used SATA and SAS ports, just like any other mechanical drive. </span><span class="koboSpan" id="kobo.339.6">They would easily fit into existing mechanical drive slots and get connected to the system through a SATA or SAS controller. </span><span class="koboSpan" id="kobo.339.7">Despite the major performance gains when using SSDs, the fact that the interfaces, protocols, and command sets that were originally written for mechanical drives were being used for SSDs was considered an overhead, and it was widely thought that this somewhat restricted flash drives from unleashing their </span><span class="No-Break"><span class="koboSpan" id="kobo.340.1">full potential.</span></span></p>
<p><span class="koboSpan" id="kobo.341.1">The NVMe interface was designed specifically for technologies such as the NAND flash. </span><span class="koboSpan" id="kobo.341.2">NVMe is often confused as a new type of drive, but technically, it’s not. </span><span class="koboSpan" id="kobo.341.3">The NVMe is a storage access and transport protocol for SSDs. </span><span class="koboSpan" id="kobo.341.4">It acts as a communication interface that operates directly over a PCIe interface. </span><span class="koboSpan" id="kobo.341.5">A standard SSD is a drive with SATA or SAS interfaces. </span><span class="koboSpan" id="kobo.341.6">These drives are accessed by the host operating system through traditional SCSI protocols. </span><span class="koboSpan" id="kobo.341.7">An NVMe SSD uses the M2 physical form factor and uses the NVMe logical interface, developed specifically for these types of drives. </span><span class="koboSpan" id="kobo.341.8">The NVMe drive is accessed solely using a PCIe interface. </span><span class="koboSpan" id="kobo.341.9">On the host operating system, separate drivers and protocols are used to access NVMe drives. </span><span class="koboSpan" id="kobo.341.10">In short, remember </span><span class="No-Break"><span class="koboSpan" id="kobo.342.1">the following:</span></span></p>
<p><em class="italic"><span class="koboSpan" id="kobo.343.1">Every NVMe drive is an SSD, but not every SSD is an </span></em><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.344.1">NVMe drive.</span></em></span></p>
<p><span class="koboSpan" id="kobo.345.1">NVMe skips the route taken by traditional SSDs and connects directly to the CPU through the PCIe interface, utilizing PCIe slots on the motherboard. </span><span class="koboSpan" id="kobo.345.2">The smaller the signal path between storage and CPU, the better the performance. </span><span class="koboSpan" id="kobo.345.3">Additionally, PCIe uses four lanes for storage devices, resulting in data exchange that is four times faster than a SATA connection, which only has one lane. </span><span class="koboSpan" id="kobo.345.4">When combined with an NVMe SSD, there is an exponential increase </span><span class="No-Break"><span class="koboSpan" id="kobo.346.1">in performance.</span></span></p>
<p><span class="koboSpan" id="kobo.347.1">The performance boost doesn’t happen only because of the powerful hardware. </span><span class="koboSpan" id="kobo.347.2">The software stack also needs optimization to take full advantage of the hardware. </span><span class="koboSpan" id="kobo.347.3">Sometimes, a hardware component can only be as good as the software controlling it. </span><span class="koboSpan" id="kobo.347.4">For instance, the SATA and SAS interfaces support a single queue with 32 and 256 commands respectively. </span><span class="koboSpan" id="kobo.347.5">On the other hand, NVMe has 64,000 queues and 64,000 commands per queue. </span><span class="koboSpan" id="kobo.347.6">That’s a difference of a staggering magnitude. </span><span class="koboSpan" id="kobo.347.7">There is a separate command set written for the NVMe interface, which is entirely different from all the older SATA and SCSI protocols. </span><span class="koboSpan" id="kobo.347.8">The older protocols were designed specifically for mechanical drives and had a large software footprint. </span><span class="koboSpan" id="kobo.347.9">NVMe only has a handful of commands, which ensures that a very small number of CPU cycles are spent when processing </span><span class="No-Break"><span class="koboSpan" id="kobo.348.1">I/O requests.</span></span></p>
<p><span class="koboSpan" id="kobo.349.1">As NVMe defines both the communication interface and the method through which storage is presented to the system, this allows for the use of a single driver in the software stack to control the device. </span><span class="koboSpan" id="kobo.349.2">For legacy protocols, every vendor is required to develop a driver for every single device to support the required functionality. </span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.350.1">Figure 8</span></em></span><em class="italic"><span class="koboSpan" id="kobo.351.1">.6</span></em><span class="koboSpan" id="kobo.352.1"> represents a summarized hierarchy of the storage stack, while highlighting the overhead differences when using the NVMe and </span><span class="No-Break"><span class="koboSpan" id="kobo.353.1">SCSI protocols:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer081">
<span class="koboSpan" id="kobo.354.1"><img alt="Figure 8.6 – NVMe versus the SCSI stack" src="image/B19430_08_06.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.355.1">Figure 8.6 – NVMe versus the SCSI stack</span></p>
<p><span class="koboSpan" id="kobo.356.1">When it comes to performance, NVMe drives easily offer the fastest transfer speeds for any available SSD. </span><span class="koboSpan" id="kobo.356.2">The read and write performance</span><a id="_idIndexMarker226"/><span class="koboSpan" id="kobo.357.1"> of NVMe SSDs are far superior</span><a id="_idIndexMarker227"/><span class="koboSpan" id="kobo.358.1"> to any standard SSD. </span><span class="koboSpan" id="kobo.358.2">Due to their exceptional performance, NVMe SSDs are priced significantly higher than standard SSDs, which is not unexpected, since the NVMe interface and protocol were designed to fully utilize the capabilities </span><span class="No-Break"><span class="koboSpan" id="kobo.359.1">of SSDs.</span></span></p>
<h1 id="_idParaDest-137"><a id="_idTextAnchor158"/><span class="koboSpan" id="kobo.360.1">Summary</span></h1>
<p><span class="koboSpan" id="kobo.361.1">After spending most of our time examining the software side of things, this chapter focused solely on the actual physical hardware. </span><span class="koboSpan" id="kobo.361.2">Because of this, almost all of the information presented in this chapter can be considered platform-agnostic. </span><span class="koboSpan" id="kobo.361.3">The hardware capabilities are the same; it’s up to the software that drives the hardware to make it reach its </span><span class="No-Break"><span class="koboSpan" id="kobo.362.1">full potential.</span></span></p>
<p><span class="koboSpan" id="kobo.363.1">We discussed the three most common storage options available on the market today – rotating hard drives, SSDs, and NVMe drives. </span><span class="koboSpan" id="kobo.363.2">The spinning mechanical drive is one of the oldest forms of storage media available on the market today. </span><span class="koboSpan" id="kobo.363.3">It has gone through a few changes over the last few decades, which have improved its performance to some extent. </span><span class="koboSpan" id="kobo.363.4">As it consists of several mechanical components, there is a hard limit associated with its performance. </span><span class="koboSpan" id="kobo.363.5">After all, the spindle motor that spins its platter surface can only spin so fast. </span><span class="koboSpan" id="kobo.363.6">Because of limitations in the hard drive’s performance, SSDs came into existence. </span><span class="koboSpan" id="kobo.363.7">SSDs do not have any mechanical parts and consist solely of electronic components. </span><span class="koboSpan" id="kobo.363.8">They use a NAND flash for permanent storage of data, which makes them extremely fast compared to rotating drives. </span><span class="koboSpan" id="kobo.363.9">As the write and erase processes apply and drain voltage from cells, SSDs can endure a limited number of program and erase cycles, which somewhat limits their </span><span class="No-Break"><span class="koboSpan" id="kobo.364.1">life span.</span></span></p>
<p><span class="koboSpan" id="kobo.365.1">Previously, SSDs were limited by the use of protocols and interfaces that were originally designed for mechanical drives. </span><span class="koboSpan" id="kobo.365.2">However, with the emergence of NVMe, this limitation was overcome. </span><span class="koboSpan" id="kobo.365.3">NVMe was specifically developed for the NAND flash and serves as a storage access and transport protocol for SSDs. </span><span class="koboSpan" id="kobo.365.4">Unlike traditional SSDs, NVMe operates directly over a PCIe interface, which makes it </span><span class="No-Break"><span class="koboSpan" id="kobo.366.1">significantly faster.</span></span></p>
<p><span class="koboSpan" id="kobo.367.1">We have now reached the end of </span><em class="italic"><span class="koboSpan" id="kobo.368.1">Part 3</span></em><span class="koboSpan" id="kobo.369.1"> of this book. </span><span class="koboSpan" id="kobo.369.2">I hope you found the information in it useful. </span><span class="koboSpan" id="kobo.369.3">In </span><em class="italic"><span class="koboSpan" id="kobo.370.1">Part 4</span></em><span class="koboSpan" id="kobo.371.1">, we’ll discuss and explore some tools and techniques for troubleshooting and analyzing </span><span class="No-Break"><span class="koboSpan" id="kobo.372.1">storage performance.</span></span></p>
</div>


<div class="Content" id="_idContainer083">
<h1 id="_idParaDest-138"><a id="_idTextAnchor159"/><span class="koboSpan" id="kobo.1.1">Part 4: Analyzing and Troubleshooting Storage Performance</span></h1>
<p><span class="koboSpan" id="kobo.2.1">This part will focus on the different criteria that can be used to evaluate and gauge storage performance. </span><span class="koboSpan" id="kobo.2.2">We’ll present the different metrics for assessing performance and discuss the different tools and techniques that can be used to investigate performance in each layer of the storage stack. </span><span class="koboSpan" id="kobo.2.3">We’ll also present some recommended practices that can help to improve </span><span class="No-Break"><span class="koboSpan" id="kobo.3.1">storage performance.</span></span></p>
<p><span class="koboSpan" id="kobo.4.1">This part contains the </span><span class="No-Break"><span class="koboSpan" id="kobo.5.1">following chapters:</span></span></p>
<ul>
<li><a href="B19430_09.xhtml#_idTextAnchor160"><em class="italic"><span class="koboSpan" id="kobo.6.1">Chapter 9</span></em></a><span class="koboSpan" id="kobo.7.1">, </span><em class="italic"><span class="koboSpan" id="kobo.8.1">Analyzing Physical Storage Performance</span></em></li>
<li><a href="B19430_10.xhtml#_idTextAnchor184"><em class="italic"><span class="koboSpan" id="kobo.9.1">Chapter 10</span></em></a><span class="koboSpan" id="kobo.10.1">, </span><em class="italic"><span class="koboSpan" id="kobo.11.1">Analyzing Filesystems and the Block Layer</span></em></li>
<li><a href="B19430_11.xhtml#_idTextAnchor199"><em class="italic"><span class="koboSpan" id="kobo.12.1">Chapter 11</span></em></a><span class="koboSpan" id="kobo.13.1">, </span><em class="italic"><span class="koboSpan" id="kobo.14.1">Tuning the I/O Stack</span></em></li>
</ul>
</div>
<div>
<div class="Basic-Graphics-Frame" id="_idContainer084">
</div>
</div>
<div>
<div id="_idContainer085">
</div>
</div>
</body></html>