<html><head></head><body>
		<div id="_idContainer091">
			<h1 id="_idParaDest-71" class="chapter-number"><a id="_idTextAnchor071"/>4</h1>
			<h1 id="_idParaDest-72"><a id="_idTextAnchor072"/>PowerShell Variables and Data Structures</h1>
			<p><a id="_idTextAnchor073"/>It’s time to really understand what we mean when we talk about variables. Variables are a common concept in computer science and mathematics, so it’s important to have a good grasp of what they are and how they are used <span class="No-Break">in PowerShell.</span></p>
			<p>We’ll start by exploring what a variable is, both literally and metaphorically. We will look at how we can use them in PowerShell and contrast the way PowerShell works with other languages. We will explore the concept of primitives, the basic building blocks of data, before moving on to the common data structures that PowerShell uses. Finally, we’ll have some fun with splatting, an important and useful technique for <span class="No-Break">simplifying cmdlets.</span></p>
			<p>In this chapter, we’re going to cover the following <span class="No-Break">main topics.</span></p>
			<ul>
				<li>Understanding <span class="No-Break">PowerShell variables</span></li>
				<li>Exploring <span class="No-Break">object types</span></li>
				<li>Discovering <span class="No-Break">value types</span></li>
				<li><span class="No-Break">Typing explained</span></li>
				<li>Navigating <span class="No-Break">reference types</span></li>
				<li>Splatting – using hashtables for fun <span class="No-Break">and profit</span></li>
			</ul>
			<h1 id="_idParaDest-73"><a id="_idTextAnchor074"/>Understanding PowerShell variables</h1>
			<p>A variable is like a box. We<a id="_idIndexMarker204"/> can put stuff in it. We can take that stuff out and put something else in it. The box may contain one thing, or it may contain many things. It may contain multiple things of the same type, for instance, 30 pairs of socks, or it can be like my kitchen drawer, and contain all sorts of different things, including string. We can organize the things it contains in different ways or not organize them, like my kitchen drawer. It may contain nothing <span class="No-Break">at all.</span></p>
			<p>A variable is really a label for a region of memory. That’s all it is – a name and an address in memory. When you tell PowerShell to use the contents of a variable, you’re telling it to go to that area of memory and use what it finds there. Using a label gives us two advantages; firstly, it saves a lot of typing, especially if the variable contains many objects. Secondly, it allows us to assign meaning, something that tells us, and other people reading our code, what the purpose of the variable is, and a clue as to what it likely contains. This is far <a id="_idIndexMarker205"/>more important and useful than it may appear <span class="No-Break">right now.</span></p>
			<div>
				<div id="_idContainer066" class="IMG---Figure">
					<img src="image/B17600_04_01.jpg" alt="Figure 4.1 – Ceci n’est pas une variable. With apologies to Magritte"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.1 – Ceci n’est pas une variable. With apologies to Magritte</p>
			<p>PowerShell is intended to be easy to use, so variables can be created dynamically, unlike some languages, such as Java, where we must declare the variable before we can put something in it. What do I mean? Consider this line of code; don’t type it, just think <span class="No-Break">about it:</span></p>
			<pre class="source-code">
$MyVariable = 'some stuff'</pre>			<p>What am I doing there? I’m dynamically creating a variable with <strong class="source-inline">some stuff</strong> <span class="No-Break">in it.</span></p>
			<p>If I were to do that in a more Java-like style, I would <span class="No-Break">write this:</span></p>
			<pre class="source-code">
New-Variable -Name MyVariable
Set-Variable -Name MyVariable -Value 'some stuff'</pre>			<p>Which creates a variable, gives it a name, and then we put a value in it. In practice, this is very rare. Most people, in most situations, create variables on <span class="No-Break">the fly.</span></p>
			<p>If you read those lines of code closely, you will see that the first example contains <strong class="source-inline">$MyVariable</strong>, and in <a id="_idIndexMarker206"/>the second one, it’s <strong class="source-inline">MyVariable</strong>, without the <strong class="source-inline">$</strong> sign. Let’s talk <span class="No-Break">about why.</span></p>
			<h2 id="_idParaDest-74"><a id="_idTextAnchor075"/>Variables are not their contents</h2>
			<p>We very rarely want<a id="_idIndexMarker207"/> to manipulate a variable. Going back to the box metaphor, unless we are five years old, we’re usually more interested in the contents of the box, not the box itself. <strong class="source-inline">MyVariable</strong> is the name assigned to the variable, the label that we can use to refer to it. <strong class="source-inline">$MyVariable</strong> refers to the contents of the variable. This is the stuff we are interested in. <span class="No-Break">Let’s demonstrate.</span></p>
			<div>
				<div id="_idContainer067" class="IMG---Figure">
					<img src="image/B17600_04_02.jpg" alt="Figure 4.2 – MyVariable is not $MyVariable"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.2 – MyVariable is not $MyVariable</p>
			<p>In the first line in <span class="No-Break"><em class="italic">Figure 4</em></span><em class="italic">.2</em>, we’re dynamically creating a variable called <strong class="source-inline">MyVariable</strong> and putting <strong class="source-inline">some stuff</strong> <span class="No-Break">into it:</span></p>
			<pre class="console">
$MyVariable = "some stuff"</pre>			<p>In the second line, we ask PowerShell for the contents of <strong class="source-inline">MyVariable</strong> by typing <strong class="source-inline">$MyVariable</strong>, and we get <strong class="source-inline">some </strong><span class="No-Break"><strong class="source-inline">stuff</strong></span><span class="No-Break"> back.</span></p>
			<p>In the third line, we’ve just typed the name of the variable, <strong class="source-inline">MyVariable</strong>, and PowerShell has not understood what <span class="No-Break">we want.</span></p>
			<p>In the fourth line, we explicitly ask for <strong class="source-inline">MyVariable</strong> with the <strong class="source-inline">Get-Variable</strong> cmdlet, and again we get the <strong class="source-inline">some stuff</strong> string, but we also get some other stuff that isn’t part of the string; the <strong class="source-inline">Get-Variable</strong> cmdlet has returned a <strong class="source-inline">PSVariable</strong> object, not the contents of the variable, which is the <strong class="source-inline">some stuff</strong> string. We can confirm what sort of variable it is by using <strong class="source-inline">Get-Member</strong>. Type <span class="No-Break">the following:</span></p>
			<pre class="console">
Get-Variable MyVariable | Get-Member</pre>			<p>In the fifth line, PowerShell quite reasonably tells us we don’t have a variable called <strong class="source-inline">some stuff</strong> – we’re passing the contents of <strong class="source-inline">MyVariable</strong> to <strong class="source-inline">Get-Variable</strong> here, not the name of <span class="No-Break">the variable.</span></p>
			<p>In the sixth line, it may look like we’re passing a variable to <strong class="source-inline">Write-Output</strong>, but we’re not. We’re passing a string with the value <strong class="source-inline">MyVariable</strong>, not the contents <span class="No-Break">of </span><span class="No-Break"><strong class="source-inline">MyVariable</strong></span><span class="No-Break">.</span></p>
			<p>The seventh line passes the contents of <strong class="source-inline">MyVariable</strong> to <strong class="source-inline">Write-Output</strong> correctly by referring <span class="No-Break">to </span><span class="No-Break"><strong class="source-inline">$MyVariable</strong></span><span class="No-Break">.</span></p>
			<p>In practice, if we always preface our variable names with a <strong class="source-inline">$</strong> sign, we’ll almost always be right. This brings <a id="_idIndexMarker208"/>us to names; what is a good variable name, and what <span class="No-Break">is not?</span></p>
			<h2 id="_idParaDest-75"><a id="_idTextAnchor076"/>Naming variables</h2>
			<p>There are two things <a id="_idIndexMarker209"/>we should consider when naming a variable. Firstly, names we can use, and secondly, names we <span class="No-Break"><em class="italic">should</em></span><span class="No-Break"> use.</span></p>
			<h3>Names we can (and can’t) use</h3>
			<p>Variable names can contain any combination of letters, numbers, question marks, and the underscore symbol, <strong class="source-inline">_</strong>. They are not case sensitive. We can use other characters as well if we enclose the variable name in curly braces <strong class="source-inline">{}</strong>, but we don’t do this. Really – it makes life difficult, and there’s almost never any need for it. Examples of good and bad names are listed in the <span class="No-Break">following table:</span></p>
			<table id="table001-3" class="T---Table _idGenTablePara-1">
				<colgroup>
					<col/>
					<col/>
				</colgroup>
				<thead>
					<tr class="T---Table">
						<td class="T---Table T---Body T---Header">
							<p><strong class="bold">Possible </strong><span class="No-Break"><strong class="bold">Variable Name</strong></span></p>
						</td>
						<td class="T---Table T---Body T---Header">
							<p><strong class="bold">Impossible </strong><span class="No-Break"><strong class="bold">Variable Name</strong></span></p>
						</td>
					</tr>
				</thead>
				<tbody>
					<tr class="T---Table">
						<td class="T---Table T---Body T---Body">
							<p><span class="No-Break"><strong class="source-inline">Z54</strong></span></p>
						</td>
						<td class="T---Table T---Body T---Body">
							<p><span class="No-Break"><strong class="source-inline">z54!</strong></span></p>
						</td>
					</tr>
					<tr class="T---Table">
						<td class="T---Table T---Body T---Body">
							<p><span class="No-Break"><strong class="source-inline">ComputerName</strong></span></p>
						</td>
						<td class="T---Table T---Body T---Body">
							<p><strong class="source-inline">$</strong><span class="No-Break"><strong class="source-inline">ComputerName</strong></span></p>
						</td>
					</tr>
					<tr class="T---Table">
						<td class="T---Table T---Body T---Body">
							<p><span class="No-Break"><strong class="source-inline">Computer_Name</strong></span></p>
						</td>
						<td class="T---Table T---Body T---Body">
							<p><span class="No-Break"><strong class="source-inline">Computer-Name</strong></span></p>
						</td>
					</tr>
					<tr class="T---Table">
						<td class="T---Table T---Body T---Body">
							<p><strong class="source-inline">{</strong><span class="No-Break"><strong class="source-inline">Computer Name}</strong></span></p>
						</td>
						<td class="T---Table T---Body T---Body">
							<p><span class="No-Break"><strong class="source-inline">Computer Name</strong></span></p>
						</td>
					</tr>
					<tr class="T---Table">
						<td class="T---Table T---Body T---Body">
							<p><span class="No-Break"><strong class="source-inline">ComputerName?</strong></span></p>
						</td>
						<td class="T---Table T---Body T---Body">
							<p><strong class="source-inline">{</strong><span class="No-Break"><strong class="source-inline">Computer Name{}}</strong></span></p>
						</td>
					</tr>
				</tbody>
			</table>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Table 4.1 – Names we can and can’t use</p>
			<p>Now that we know what sort of names we <em class="italic">can</em> use, what sort of names <em class="italic">should</em> <span class="No-Break">we use?</span></p>
			<h3>Names we should (and shouldn’t) use</h3>
			<p>One of the purposes of using variables is to assign meaning. We do this by making the names meaningful; a variable name should give some clue as to the variable’s contents or purpose. While <strong class="source-inline">MyVariable</strong> is a perfectly legal and suitable name when we’re typing one or two lines of code, when we write a script, it doesn’t give us any clue as to what it contains or how we wanted it to be used; it just tells us that it’s a variable and that <span class="No-Break">it’s </span><span class="No-Break"><em class="italic">mine</em></span><span class="No-Break">.</span></p>
			<p>My day job often involves debugging code written by other people. I have nightmares caused by scripts with 20 or 30 variables called <strong class="source-inline">a</strong>, <strong class="source-inline">I</strong>, <strong class="source-inline">x</strong>, <strong class="source-inline">y</strong>, <strong class="source-inline">ii</strong>, <strong class="source-inline">x3</strong>, <strong class="source-inline">agtd</strong>, and so on. I don’t know what they mean, and I bet the original author doesn’t remember, either. When naming variables, we should understand that our code will be read many more times than it is written, often by us, sometimes years after we wrote it. Let’s do ourselves a favor and write meaningful <span class="No-Break">variable names.</span></p>
			<p>We should also use consistent names, such as <strong class="source-inline">ComputerName1</strong>, <strong class="source-inline">ComputerName2</strong>, and <strong class="source-inline">ComputerName3</strong>, not <strong class="source-inline">ComputerName1</strong>, <strong class="source-inline">computer_name2</strong>, and <strong class="source-inline">ComputerNameThree</strong>. The PowerShell best practice guidelines suggest using Pascal case widely, where each word is capitalized, as this is easy to read and works well with screen readers. Other languages, such as Python, suggest variable names should be all lowercase and the words separated with underscores: <strong class="source-inline">computer_name</strong>. Whichever we choose, being consistent will make our <span class="No-Break">lives easier.</span></p>
			<p>We don’t use question marks, either. It’s scruffy, and it can <span class="No-Break">cause complications.</span></p>
			<p>Finally, we should<a id="_idIndexMarker210"/> avoid trying to use the names of automatic or preference variables. <span class="No-Break">Wait, what?</span></p>
			<h2 id="_idParaDest-76"><a id="_idTextAnchor077"/>The three common types of PowerShell variable</h2>
			<p>So far, we’ve been<a id="_idIndexMarker211"/> talking about a particular type of PowerShell variable – <strong class="bold">user-created variables</strong>. There <a id="_idIndexMarker212"/>are two<a id="_idIndexMarker213"/> other<a id="_idIndexMarker214"/> types: <strong class="bold">automatic variables</strong> and <strong class="bold">preference variables</strong>. User-created variables only exist for as long as the session or script that generated them is running; once we close our PowerShell window, those variables are destroyed. This is<a id="_idIndexMarker215"/> called <strong class="bold">scope</strong>, and we’ll cover it in <a href="B17600_08.xhtml#_idTextAnchor162"><span class="No-Break"><em class="italic">Chapter 8</em></span></a>, <em class="italic">Writing Our First Script – Turning Simple Cmdlets into Reusable Code</em>. Automatic and preference variables exist for every session <span class="No-Break">or script.</span></p>
			<h3>Automatic variables</h3>
			<p>These are used <a id="_idIndexMarker216"/>internally by PowerShell. We’ve <a id="_idIndexMarker217"/>already used one: <strong class="source-inline">$PSItem</strong> , or <strong class="source-inline">$_</strong>, which refers to the current object in the pipeline. We can assign a value to it if we like, but PowerShell will clear it when the current running pipeline completes, as in <span class="No-Break"><em class="italic">Figure 4</em></span><span class="No-Break"><em class="italic">.3</em></span><span class="No-Break">:</span></p>
			<div>
				<div id="_idContainer068" class="IMG---Figure">
					<img src="image/B17600_04_03.jpg" alt="Figure 4.3 – Don’t use the names of automatic variables"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.3 – Don’t use the names of automatic variables</p>
			<p>After setting <strong class="source-inline">$PSItem</strong> to <strong class="source-inline">"some stuff"</strong>, the pipeline completes, and the variable is cleared, losing the information we were trying to store. Happily, most automatic variables are protected, as in <span class="No-Break"><em class="italic">Figure 4</em></span><span class="No-Break"><em class="italic">.4</em></span><span class="No-Break">:</span></p>
			<div>
				<div id="_idContainer069" class="IMG---Figure">
					<img src="image/B17600_04_04.jpg" alt="Figure 4.4 – You can’t overwrite some automatic variables"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.4 – You can’t overwrite some automatic variables</p>
			<p>You can see a list of <a id="_idIndexMarker218"/>the automatic<a id="_idIndexMarker219"/> variables in the help topic <strong class="source-inline">about_Automatic_Variables</strong>, or you can see them online <span class="No-Break">at </span><a href="https://docs.microsoft.com/en-us/powershell/module/microsoft.powershell.core/about/about_automatic_variables"><span class="No-Break">https://docs.microsoft.com/en-us/powershell/module/microsoft.powershell.core/about/about_automatic_variables</span></a><span class="No-Break">.</span></p>
			<h3>Preference variables</h3>
			<p>Preference<a id="_idIndexMarker220"/> variables<a id="_idIndexMarker221"/> store information about how PowerShell works, enabling us to customize how PowerShell behaves. For instance, we could use a preference variable to ensure the <strong class="source-inline">-WhatIf</strong> parameter is applied by default to all cmdlets we run (that support it). Let’s see how that works in <span class="No-Break"><em class="italic">Figure 4</em></span><span class="No-Break"><em class="italic">.5</em></span><span class="No-Break">:</span></p>
			<div>
				<div id="_idContainer070" class="IMG---Figure">
					<img src="image/B17600_04_05.jpg" alt="Figure 4.5 – Using preference variables"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.5 – Using preference variables</p>
			<p>In the first line, we <a id="_idIndexMarker222"/>check the value of the <strong class="source-inline">WhatIfPreference</strong> variable; it’s <strong class="source-inline">False</strong>, the default. That makes sense because we’ve just<a id="_idIndexMarker223"/> started the PowerShell session. In the second line, we assign the value <strong class="source-inline">True</strong> by setting <strong class="source-inline">$whatIfPreference = $</strong><span class="No-Break"><strong class="source-inline">true</strong></span><span class="No-Break">.</span></p>
			<p>Then we check the value again. Sure enough, it’s now <strong class="source-inline">True</strong>. Let’s see how things work now. We run <strong class="source-inline">Get-Process</strong> to get the <strong class="source-inline">Id</strong> parameter of a suitable process; in this case, I’m going to get the ID of the <strong class="source-inline">pwsh</strong> process, <strong class="source-inline">407</strong>. Now, when we run <strong class="source-inline">Stop-Process -Id 407</strong>, we would normally expect the <strong class="source-inline">pwsh</strong> session to end; it doesn’t because, by default, now all processes run with the <strong class="source-inline">-WhatIf</strong> parameter set <span class="No-Break">to </span><span class="No-Break"><strong class="source-inline">True</strong></span><span class="No-Break">.</span></p>
			<p>Changing preference variables this way only persists while the current session or script is running. If you stop and restart PowerShell, they’re all set back to the defaults. If you need to persist a preference, you can change your PowerShell profile, a PowerShell script that can be found by querying the <strong class="source-inline">PROFILE</strong> variable by typing <strong class="source-inline">$PROFILE</strong>. You’ll learn about editing scripts in <a href="B17600_08.xhtml#_idTextAnchor162"><span class="No-Break"><em class="italic">Chapter 8</em></span></a>, <em class="italic">Writing Our First Script – Turning Simple Cmdlets into </em><span class="No-Break"><em class="italic">Reusable Code</em></span><span class="No-Break">.</span></p>
			<p>There’s a full explanation of each of the preference variables in the help topic <strong class="source-inline">About_Preference_Variables</strong>, or you can read more about them online <span class="No-Break">at </span><a href="https://docs.microsoft.com/en-us/powershell/module/microsoft.powershell.core/about/about_preference_variables"><span class="No-Break">https://docs.microsoft.com/en-us/powershell/module/microsoft.powershell.core/about/about_preference_variables</span></a><span class="No-Break">.</span></p>
			<p>Finally, we can see the current values held in all variables by typing <strong class="source-inline">Get-Variable</strong> with <span class="No-Break">no parameters.</span></p>
			<p>Now that we <a id="_idIndexMarker224"/>understand a bit about the variable – the box – we <a id="_idIndexMarker225"/>can start looking at what we can put in there. Let’s have a look at <span class="No-Break">object types.</span></p>
			<h1 id="_idParaDest-77"><a id="_idTextAnchor078"/>Exploring object types</h1>
			<p>In the last section, we<a id="_idIndexMarker226"/> talked about types of variables. Now, we’re going to talk about <strong class="bold">object types</strong> – the things that go in the box. The type of the object in the variable tells the computer what to do with it – what properties it has and what we can do with it. Type <span class="No-Break">the following:</span></p>
			<pre class="console">
$MyVariable = "some stuff"
$MyVariable | Get-Member</pre>			<p>We should see something like the output in <span class="No-Break"><em class="italic">Figure 4</em></span><span class="No-Break"><em class="italic">.6</em></span><span class="No-Break">:</span></p>
			<div>
				<div id="_idContainer071" class="IMG---Figure">
					<img src="image/B17600_04_06.jpg" alt="Figure 4.6 – It’s a string"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.6 – It’s a string</p>
			<p>We’ve put a string in there, and we know this because we’re told it – <strong class="source-inline">TypeName</strong> is <strong class="source-inline">System.String</strong>. At the moment, <strong class="source-inline">MyVariable</strong> contains a string. We can change what the type is by assigning something else to it. Try typing the following without <span class="No-Break">quotation marks:</span></p>
			<pre class="console">
$MyVariable = 4.2</pre>			<p>Then, use <strong class="source-inline">Get-Member</strong> to check the contents. Now we’ve got a <strong class="source-inline">System.Double</strong> object type in there, a <span class="No-Break">floating-point number.</span></p>
			<p>We can do even better things. Type the following, and check the contents of the variable <span class="No-Break">with </span><span class="No-Break"><strong class="source-inline">Get-Member</strong></span><span class="No-Break">:</span></p>
			<pre class="console">
$MyVariable = (Get-Process)
$MyVariable | Get-Member</pre>			<p>Now we have the output of <strong class="source-inline">Get-Process</strong> held in our variable, and the contents have a type <span class="No-Break">of </span><span class="No-Break"><strong class="source-inline">System.Diagnostics.Process</strong></span><span class="No-Break">.</span></p>
			<p>Variables can hold any type of object. Remember, everything in PowerShell is an object. We<a id="_idIndexMarker227"/> covered some of the specifics of PowerShell objects in <a href="B17600_03.xhtml#_idTextAnchor049"><span class="No-Break"><em class="italic">Chapter 3</em></span></a>, <em class="italic">The PowerShell Pipeline – How to String Cmdlets Together</em>, but it is a good idea to review them from a more generic <span class="No-Break">programming perspective.</span></p>
			<h2 id="_idParaDest-78"><a id="_idTextAnchor079"/>What is an object? – redux</h2>
			<p>Picture a bicycle. What<a id="_idIndexMarker228"/> color is it? What sort of handlebars does it have? What is the wheel diameter? My bike has ape hanger handlebars, 15” wheels, and is a scuffed red glitter. Your bike may be a more sensible item altogether, with riser handlebars, 20” wheels, and in a serviceable black. My son Tom’s bike has pursuit handlebars, 22” wheels, and <span class="No-Break">is white.</span></p>
			<p>That’s three objects, there, of the (non-existent) <strong class="source-inline">TypeName Imaginary.Bike</strong>. We can list the objects in <em class="italic">Table 4.2</em>. All the objects have the <a id="_idIndexMarker229"/>same set of <strong class="bold">properties</strong>: Name, Handlebar, Wheel (inch), and Color properties. In each instance, they have different values for the properties. Other properties may include a basket, lights, and so on. Some of those properties may be optional, but some are not; a bicycle will always have two wheels of a fixed diameter, and <span class="No-Break">a color.</span></p>
			<table id="table002-1" class="T---Table _idGenTablePara-1">
				<colgroup>
					<col/>
					<col/>
					<col/>
					<col/>
				</colgroup>
				<thead>
					<tr class="T---Table">
						<td class="T---Table T---Body T---Header">
							<p><span class="No-Break"><strong class="bold">Name</strong></span></p>
						</td>
						<td class="T---Table T---Body T---Header">
							<p><span class="No-Break"><strong class="bold">MyBike</strong></span></p>
						</td>
						<td class="T---Table T---Body T---Header">
							<p><span class="No-Break"><strong class="bold">YourBike</strong></span></p>
						</td>
						<td class="T---Table T---Body T---Header">
							<p><span class="No-Break"><strong class="bold">TomsBike</strong></span></p>
						</td>
					</tr>
				</thead>
				<tbody>
					<tr class="T---Table">
						<td class="T---Table T---Body T---Body">
							<p><span class="No-Break"><strong class="bold">Handlebar</strong></span></p>
						</td>
						<td class="T---Table T---Body T---Body">
							<p><span class="No-Break">Ape hanger</span></p>
						</td>
						<td class="T---Table T---Body T---Body">
							<p><span class="No-Break">Riser</span></p>
						</td>
						<td class="T---Table T---Body T---Body">
							<p><span class="No-Break">Pursuit</span></p>
						</td>
					</tr>
					<tr class="T---Table">
						<td class="T---Table T---Body T---Body">
							<p><span class="No-Break"><strong class="bold">Wheel (inch)</strong></span></p>
						</td>
						<td class="T---Table T---Body T---Body">
							<p><span class="No-Break">15</span></p>
						</td>
						<td class="T---Table T---Body T---Body">
							<p><span class="No-Break">20</span></p>
						</td>
						<td class="T---Table T---Body T---Body">
							<p><span class="No-Break">22</span></p>
						</td>
					</tr>
					<tr class="T---Table">
						<td class="T---Table T---Body T---Body">
							<p><span class="No-Break"><strong class="bold">Color</strong></span></p>
						</td>
						<td class="T---Table T---Body T---Body">
							<p><span class="No-Break">Red</span></p>
						</td>
						<td class="T---Table T---Body T---Body">
							<p><span class="No-Break">Black</span></p>
						</td>
						<td class="T---Table T---Body T---Body">
							<p><span class="No-Break">White</span></p>
						</td>
					</tr>
				</tbody>
			</table>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Table 4.2 – Our bikes</p>
			<p>We can create those bikes in PowerShell, list out the properties of each, and we can see that they are objects of the <strong class="source-inline">Imaginary.Bike</strong> type by <span class="No-Break">using </span><span class="No-Break"><strong class="source-inline">Get-Member</strong></span><span class="No-Break">:</span></p>
			<div>
				<div id="_idContainer072" class="IMG---Figure">
					<img src="image/B17600_04_07.jpg" alt="Figure 4.7 – Three imaginary bikes"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.7 – Three imaginary bikes</p>
			<p>Our bikes also have a <a id="_idIndexMarker230"/>common set of things we can do with them. We can pedal them to make them speed up. We can use the brakes to make them slow down. These are <strong class="bold">methods</strong>, and we looked at them when we covered <strong class="source-inline">Get-Member</strong> in <a href="B17600_01.xhtml#_idTextAnchor013"><span class="No-Break"><em class="italic">Chapter 1</em></span></a>, <em class="italic">Introduction to PowerShell 7 – What It Is and How to Get It</em>. We would expect objects of the same type to have the same methods as <span class="No-Break">each other.</span></p>
			<p>This concept of an object is common to most modern programming languages, and most programming languages handle them in similar ways. The imaginary exercise we have just gone through is as relevant in Python as it is in PowerShell. Here are the same three imaginary bikes <span class="No-Break">in Python:</span></p>
			<div>
				<div id="_idContainer073" class="IMG---Figure">
					<img src="image/B17600_04_08.jpg" alt="Figure 4.8 – Three imaginary bikes in another language"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.8 – Three imaginary bikes in another language</p>
			<p>The difference in PowerShell is everything is an object. With that in mind, let’s explore some common types<a id="_idIndexMarker231"/> of objects that we will want to put in variables. Let’s start with <span class="No-Break">value types.</span></p>
			<h1 id="_idParaDest-79"><a id="_idTextAnchor080"/>Discovering value types</h1>
			<p><strong class="bold">Value types</strong> are the<a id="_idIndexMarker232"/> building blocks of programming in PowerShell. Other languages <a id="_idIndexMarker233"/>have <strong class="bold">primitive</strong> types that derive from the base classes of the relevant language; PowerShell does not because (all together now) everything is an object and is derived from the <strong class="source-inline">System.Object</strong> class in .NET. In general, value types in PowerShell are analogous to (but not exactly the same as) primitives. The memory location that holds a value-type object holds the actual data. There are also reference types, which we’ll look at later, that hold a reference to the actual data; the data is held elsewhere, possibly in multiple locations. Value-type data is a fixed size, in bits. Value types have a single value. To illustrate, let’s look at some value types. We’ll start with the simplest value <a id="_idIndexMarker234"/>type, the <span class="No-Break"><strong class="bold">Boolean</strong></span><span class="No-Break"> type.</span></p>
			<p class="callout-heading">Memory locations – CompSci101 alert!</p>
			<p class="callout">Data is stored in two different <a id="_idIndexMarker235"/>places in <a id="_idIndexMarker236"/>memory, the <strong class="bold">stack,</strong> and the <strong class="bold">heap</strong>. The stack is for static allocations (things that don’t change), and the heap is dynamic. The heap stores global information and is exactly like it sounds; it’s just a heap of data with a tree-like structure. It’s not of fixed size and allows random access. Access to the data can be quite slow, and the heap becomes fragmented <span class="No-Break">over time.</span></p>
			<p class="callout">The stack is an orderly memory space of fixed size. It has a linear structure, where the last bit of data to be put on the stack is the first bit to be removed. Access to information is much quicker than in the heap. However, because space is limited, we occasionally get a stack overflow where we try to put more data into a stack than it can hold – the computer science equivalent of crossing the streams (Ghostbusters reference). Each thread of a running application has its own stack, but they all share the <span class="No-Break">application heap.</span></p>
			<p class="callout">When we create a variable, it goes in the stack. The data the variable refers to may be in the stack (for a value-type variable), or it may be in the heap (for a reference-type variable), but the <a id="_idIndexMarker237"/>variable is always in <span class="No-Break">the stack.</span></p>
			<h2 id="_idParaDest-80"><a id="_idTextAnchor081"/>Booleans</h2>
			<p>A Boolean-type <a id="_idIndexMarker238"/>variable can hold <a id="_idIndexMarker239"/>one of two values; true or false. That’s it. It’s called a <strong class="source-inline">System.Boolean</strong> or <strong class="source-inline">[bool]</strong>. <strong class="source-inline">[bool]</strong> is an accelerator and saves us from having to type a much longer class name; it’s an alias for the type <strong class="source-inline">System.Boolean</strong>. Booleans are easy to assign; we use the automatic variables <strong class="source-inline">$True</strong> and <strong class="source-inline">$False</strong>. Try <span class="No-Break">the following:</span></p>
			<pre class="console">
$MyBoolean = $True
$MyBoolean | Get-Member</pre>			<p>We can see that the type is <strong class="source-inline">System.Boolean</strong>. Variables with this type are useful in scripting, as we will see in <a href="B17600_05.xhtml#_idTextAnchor096"><span class="No-Break"><em class="italic">Chapter 5</em></span></a>, <em class="italic">PowerShell Control Flow – Conditionals and Loops</em>. In that chapter, we’ll also see a similar but subtly different value type, the <strong class="source-inline">[switch]</strong> type – that can also only be true or false but has a different set <span class="No-Break">of members.</span></p>
			<h2 id="_idParaDest-81"><a id="_idTextAnchor082"/>Integers</h2>
			<p>Integers are <a id="_idIndexMarker240"/>whole <a id="_idIndexMarker241"/>numbers, that is, numbers without a decimal point. There are three main integer types, <strong class="source-inline">[int32]</strong>, <strong class="source-inline">[int64]</strong>, and <strong class="source-inline">[byte]</strong>. <strong class="source-inline">[int32]</strong> is the default type and is a signed value 32 bits long, meaning it can hold decimal values between -2,147,483,648 and +2,147,483,647. If we create a variable that holds a whole number between those values, then PowerShell will give it the <span class="No-Break">type </span><span class="No-Break"><strong class="source-inline">[int32]</strong></span><span class="No-Break">:</span></p>
			<pre class="console">
$MyNumber = 42
$MyNumber | Get-Member</pre>			<p>If we try and assign a number outside that range, then PowerShell will give it the <strong class="source-inline">[int64]</strong> type, which is 64 bits long and can hold numbers between -9, 223, 372, 036, 854, 775, 808 and +9, 223, 372, 036, 854, <span class="No-Break">775, 807.</span></p>
			<p>We will sometimes see <strong class="source-inline">[int]</strong> and <strong class="source-inline">[long]</strong> in books and on web pages instead of <strong class="source-inline">[int32]</strong> and <strong class="source-inline">[int64]</strong> – the terms <span class="No-Break">are interchangeable.</span></p>
			<p><strong class="source-inline">[byte]</strong> is a special type of integer; it has no sign and is a whole number between 0 and 255, making it 8 bits long – <span class="No-Break">1 byte.</span></p>
			<p class="callout-heading">Activity one</p>
			<p class="callout">Why not have <a id="_idIndexMarker242"/>a single<a id="_idIndexMarker243"/> integer type – <strong class="source-inline">[int64]</strong>? Why bother <span class="No-Break">complicating things?</span></p>
			<h2 id="_idParaDest-82"><a id="_idTextAnchor083"/>Real numbers</h2>
			<p>In mathematics, real <a id="_idIndexMarker244"/>numbers are <a id="_idIndexMarker245"/>numbers that exist – they can be whole numbers (42), decimals (3.1), fractions (1/3), or irrational numbers (pi, the square root of two). Imaginary numbers like the square root of -1 are not real numbers, although they are incredibly useful. In PowerShell, whole numbers are expressed using the integer types we’ve just discussed, and common irrational numbers are served by the <strong class="source-inline">[math]</strong> type. We mostly use real number types to express floating <span class="No-Break">point numbers.</span></p>
			<p>There are three common variable types for working with real numbers, <strong class="source-inline">[single]</strong> (or <strong class="source-inline">[float]</strong>), <strong class="source-inline">[double]</strong> (or <strong class="source-inline">[long]</strong>), and <strong class="source-inline">[decimal]</strong>. The <strong class="source-inline">[single]</strong> variable type is 32 bits and has seven digits of precision (the numbers to the right of the decimal point). The <strong class="source-inline">[double]</strong> variable type is 64 bits and has 15 or 16 digits of precision. By default, PowerShell creates variables of the type <strong class="source-inline">[double]</strong> when you use a <span class="No-Break">decimal number:</span></p>
			<pre class="console">
$MyRealNumber = 42.0
$MyRealNumber | Get-Member</pre>			<p>The <strong class="source-inline">[Decimal]</strong> type is 128 bits long and has a sliding scale of precision up to 28 digits. This is used in scientific and <span class="No-Break">financial calculations.</span></p>
			<h2 id="_idParaDest-83"><a id="_idTextAnchor084"/>Char</h2>
			<p>The <strong class="source-inline">[char]</strong> type<a id="_idIndexMarker246"/> describes a<a id="_idIndexMarker247"/> single character, a member of the UTF-16 character set that we’re currently using. It’s a 16-bit value that corresponds to a symbol in the current character map. Try <span class="No-Break">the following:</span></p>
			<pre class="console">
[char]$MyChar = 24
$MyChar</pre>			<p>On my machine, I see an up-arrow <strong class="source-inline">↑</strong>. You may see something different. What you won’t see is <strong class="source-inline">24</strong>. We did something new there; we preceded the variable with a type accelerator. To<a id="_idIndexMarker248"/> understand <a id="_idIndexMarker249"/>why, we need to talk <span class="No-Break">about typing.</span></p>
			<h1 id="_idParaDest-84"><a id="_idTextAnchor085"/>Typing explained</h1>
			<p>Now we understand some basic types, we need to cover typing and how languages, particularly PowerShell, manipulate the type of the object in the variable. How does a computer know what type of object it is? Languages can be divided into those that only support <strong class="bold">static typing</strong>, where <a id="_idIndexMarker250"/>the object type the variable can hold is declared when the variable is created and doesn’t change, and those that support <strong class="bold">dynamic typing</strong>, where<a id="_idIndexMarker251"/> the contents of the variable determine what the type is. In dynamically typed languages, the type of the variable can change. Try <span class="No-Break">the following:</span></p>
			<pre class="console">
$MyVariable = 'some stuff'
$MyVariable | Get-Member
$MyVariable = 42
$MyVariable | Get-Member</pre>			<p>We can see that the object type of <strong class="source-inline">$MyVariable</strong> changes depending on what is inside it, making PowerShell a dynamically typed language. In fact, PowerShell is described as <strong class="bold">Type-Promiscuous</strong> by<a id="_idIndexMarker252"/> Bruce Payette in <em class="italic">PowerShell in Action</em>, because it will try to make the thing that we put in a variable do whatever we want. So long as the object in the variable has the right sort of property, PowerShell doesn’t care what type it is. Let’s <span class="No-Break">play around.</span></p>
			<h2 id="_idParaDest-85"><a id="_idTextAnchor086"/>Dynamic versus static typing</h2>
			<p>If we <a id="_idIndexMarker253"/>type <strong class="source-inline">$x = '4'</strong>, we <a id="_idIndexMarker254"/>get <strong class="source-inline">[string]</strong>. If we type <strong class="source-inline">$x = 4</strong> without the quotes, we <span class="No-Break">get </span><span class="No-Break"><strong class="source-inline">[int32]</strong></span><span class="No-Break">.</span></p>
			<p>Now, let’s see what happens if we type <span class="No-Break">the following:</span></p>
			<pre class="console">
$x = '4' + 4</pre>			<p>Try it, and pipe <strong class="source-inline">$x</strong> to <strong class="source-inline">Get-Member</strong> just to confirm the type. PowerShell has tried its best to interpret what you want. It’s chosen to treat the second <strong class="source-inline">4</strong> as a string and added the two strings together, giving <strong class="source-inline">44</strong>. Amazing, right? Try it the other <span class="No-Break">way around:</span></p>
			<pre class="console">
$x = 4 + '4'</pre>			<p>Now it’s treating the second <strong class="source-inline">'4'</strong> as an integer and returns <strong class="source-inline">8</strong>. This does not work in <span class="No-Break">most languages:</span></p>
			<div>
				<div id="_idContainer074" class="IMG---Figure">
					<img src="image/B17600_04_09.jpg" alt="Figure 4.9 – Python is not promiscuous"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.9 – Python is not promiscuous</p>
			<p>In Python, we<a id="_idIndexMarker255"/> can <a id="_idIndexMarker256"/>add strings<a id="_idIndexMarker257"/> together, called <strong class="bold">concatenating</strong>, and we can add integers<a id="_idIndexMarker258"/> together (called <strong class="bold">adding</strong>), and Python will happily dynamically type the variable contents as either a string or an integer. We cannot, however, mix strings and integers together; Python throws <span class="No-Break">an error.</span></p>
			<p>This is mostly a blessing, but sometimes it’s a mixed blessing. Because PowerShell works so hard trying to do what we want, it will sometimes do things we don’t want. It may be that we always want the contents to be a string, but some data entry error or an ill-defined operation puts an integer in there. This affects what we can do with that variable afterward because it has changed the object type to an integer. In a less-accommodating<a id="_idIndexMarker259"/> language, we get an error that tells us exactly <a id="_idIndexMarker260"/>what has gone wrong, but PowerShell may give us unexpected results, which take an age to debug if we’re lucky or cause a disaster if <span class="No-Break">we’re not.</span></p>
			<h2 id="_idParaDest-86"><a id="_idTextAnchor087"/>Casting variables</h2>
			<p>Luckily, we can <a id="_idIndexMarker261"/>make PowerShell act more like a statically typed language by defining the contents of the variable when we create it by using an <span class="No-Break">accelerator, </span><span class="No-Break"><strong class="source-inline">[int32]</strong></span><span class="No-Break">:</span></p>
			<pre class="console">
[int32]$MyNewVariable = '42'
$MyNewVariable | Get-Member</pre>			<p>And it’s an <strong class="source-inline">[int32]</strong> type, even though we gave it a string. Note this won’t work if we give it something that is less easy to interpret as <span class="No-Break">an integer:</span></p>
			<pre class="console">
[int32]$MyNewVariable = 'Forty Two'</pre>			<p>This throws an error. Importantly, it will throw an error even if we just type <span class="No-Break">the following:</span></p>
			<pre class="console">
$MyNewVariable = 'Forty Two'</pre>			<p>Because when we created <strong class="source-inline">MyNewVariable</strong> a few lines previously, we defined it as the <strong class="source-inline">[Int32]</strong> type, and so now that is all it can ever hold. This can also lead to some <span class="No-Break">confusing results.</span></p>
			<p>We might expect this cmdlet to throw an error as we try to put a floating-point number <span class="No-Break">into </span><span class="No-Break"><strong class="source-inline">MyNewVariable</strong></span><span class="No-Break">:</span></p>
			<pre class="console">
$MyNewVariable = 4.2</pre>			<p>But no. PowerShell just picks the closest integer and uses <span class="No-Break">that instead:</span></p>
			<div>
				<div id="_idContainer075" class="IMG---Figure">
					<img src="image/B17600_04_10.jpg" alt="Figure 4.10 – PowerShell doing as it’s told"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.10 – PowerShell doing as it’s told</p>
			<p>We can cast the variable, though, to a new type, <span class="No-Break">like this:</span></p>
			<pre class="console">
[single]$MyNewVariable = 4.2</pre>			<p>And we now have the correct value in there. Casting is an incredibly useful technique that we’ll be using a lot later, especially in <a href="B17600_07.xhtml#_idTextAnchor140"><span class="No-Break"><em class="italic">Chapter 7</em></span></a>, <em class="italic">PowerShell and the Web – HTTP, REST, and JSON</em>. It allows us to take a collection of strings and turn them into XML and JSON objects that can be used to interact with <span class="No-Break">web-based applications.</span></p>
			<p>There are a couple of common ways of using casting to change the type of a variable’s contents. Firstly, we can create a new variable by copying the contents as a defined type. Let’s create a variable we know contains <span class="No-Break">an integer:</span></p>
			<pre class="console">
[int32]$MyVariable = 42</pre>			<p>We can cast that to a new variable as <span class="No-Break">a string:</span></p>
			<pre class="console">
$MyString = [string]$MyVariable
$MyString | Get-Member</pre>			<p>We can do it the<a id="_idIndexMarker262"/> other way around, <span class="No-Break">as well:</span></p>
			<pre class="console">
[string]$MyOtherString = $MyVariable</pre>			<p class="callout-heading">Activity two</p>
			<p class="callout">What is the difference between <strong class="source-inline">$myString</strong> <span class="No-Break">and </span><span class="No-Break"><strong class="source-inline">$MyOtherString</strong></span><span class="No-Break">?</span></p>
			<p class="callout">Hint: what types of objects can we subsequently put in <span class="No-Break">each variable?</span></p>
			<p>Secondly, we can do it without creating a new variable; we can just use <strong class="source-inline">[string]$MyVariable</strong> in our code, and PowerShell will treat the contents as an object of the correct type if <span class="No-Break">it can.</span></p>
			<p>That’s as much as we need to do on simple value types, and how PowerShell uses dynamic and static<a id="_idIndexMarker263"/> typing. It’s time to look at the more complex compound variable types – <span class="No-Break">reference types.</span></p>
			<h1 id="_idParaDest-87"><a id="_idTextAnchor088"/>Navigating reference types</h1>
			<p>Now we understand <a id="_idIndexMarker264"/>a bit about typing, and how value types work, we can talk about the other main type of object – <strong class="bold">reference types</strong>. We compared value type objects to primitives in other languages in the previous section, <em class="italic">Discovering value types</em>. Reference-type objects are the equivalent of data structures. Reference-type objects only hold a reference in the stack to more data in the heap; this is important because reference-type objects do not have a defined size. In general, a reference type may hold up to 2 GB of data. To prove it, I turned the Shakespeare play Hamlet into a string, by downloading it as a text file from <span class="No-Break">Project Gutenberg:</span></p>
			<div>
				<div id="_idContainer076" class="IMG---Figure">
					<img src="image/B17600_04_11.jpg" alt="Figure 4.11 – Stringifying Hamlet"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.11 – Stringifying Hamlet</p>
			<p>As we can see, there are around 197,000 characters in the <span class="No-Break">whole string.</span></p>
			<p>I did two interesting things there; I used the <strong class="source-inline">length</strong> property of the string type to see how long my string was, in characters, but I also used the <strong class="source-inline">GetType()</strong> method to check the object type <a id="_idIndexMarker265"/>rather than using the pipeline to pass it to <strong class="source-inline">Get-Member</strong>. Before we talk more about properties and methods and the other exciting things we can do with strings, I want to start with a simple reference-type object, <span class="No-Break">the array.</span></p>
			<h2 id="_idParaDest-88"><a id="_idTextAnchor089"/>Arrays</h2>
			<p>An array is a<a id="_idIndexMarker266"/> data structure of fixed length that contains a collection of <a id="_idIndexMarker267"/>objects. They don’t have to be the same type of object, and they are not necessarily sorted or ordered. An array can contain zero or more objects. We can tell PowerShell we want to create an array by either casting the variable as an array implicitly using the comma character <strong class="source-inline">,</strong> or explicitly with <strong class="source-inline">[array]</strong>. Try <span class="No-Break">the following:</span></p>
			<pre class="console">
$MyArray = 1,2,3
$MyArray.GetType()</pre>			<p>Did you try it? You do need to. As we go through this section, I’ll be calling back to the arrays we create here. It would be awful if you got to the end of the section and had to come back and start again because you didn’t create the array the first <span class="No-Break">time around.</span></p>
			<p>To create a single-item array, you can do <span class="No-Break">the following:</span></p>
			<pre class="console">
$number = ,1
[Array]$MyTinyArray = 1</pre>			<p>The output can be seen in the <span class="No-Break">following screenshot:</span></p>
			<div>
				<div id="_idContainer077" class="IMG---Figure">
					<img src="image/B17600_04_12.jpg" alt="Figure 4.12 – Two single-element arrays"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.12 – Two single-element arrays</p>
			<p>We can see that we create <strong class="source-inline">Object[]</strong> of <strong class="source-inline">BaseType</strong> as <strong class="source-inline">System.Array</strong> <span class="No-Break">each time.</span></p>
			<p>We can also create arrays using the range operator (<strong class="source-inline">..</strong>). Try <span class="No-Break">the following:</span></p>
			<pre class="console">
$NewArray = 1..10</pre>			<p>We should get an array containing all the numbers from 1 to <span class="No-Break">10, inclusive.</span></p>
			<p>Finally, we can use the array <span class="No-Break">operator </span><span class="No-Break"><strong class="source-inline">@()</strong></span><span class="No-Break">:</span></p>
			<pre class="console">
$AnotherArray = @(1..5; "some stuff")</pre>			<p>Note we have to use a semicolon, not a comma, when separating different types of objects and<a id="_idIndexMarker268"/> using<a id="_idIndexMarker269"/> expressions. This is useful when we start scripting and using the splatting technique, which we’ll cover in the last section of <span class="No-Break">this chapter.</span></p>
			<h3>Array basics</h3>
			<p>Each object in the array is called an element. We can list the elements by calling the whole array (<strong class="source-inline">$NewArray</strong>), like any <span class="No-Break">other variable:</span></p>
			<div>
				<div id="_idContainer078" class="IMG---Figure">
					<img src="image/B17600_04_13.jpg" alt="Figure 4.13 – Listing the elements of an array"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.13 – Listing the elements of an array</p>
			<p>We can choose to call a single element in an array by passing its index. This gets the <span class="No-Break">first element:</span></p>
			<pre class="console">
$NewArray[0]</pre>			<p>This will get the <span class="No-Break">second-to-last element:</span></p>
			<pre class="console">
$NewArray[-2]</pre>			<p>We can call <span class="No-Break">multiple elements:</span></p>
			<pre class="console">
$NewArray[0,2,5,7]</pre>			<p>And we can call a range <span class="No-Break">of elements:</span></p>
			<pre class="console">
$NewArray[6..9]</pre>			<p>We can change the<a id="_idIndexMarker270"/> values of elements of an array by assigning <span class="No-Break">them directly:</span></p>
			<pre class="console">
$NewArray[5] = 5</pre>			<p>We can add elements to an array by using the <strong class="source-inline">+=</strong> <span class="No-Break">operator:</span></p>
			<pre class="console">
$NewArray += 11</pre>			<p>But it’s tricky to delete an element from an array; instead, create a new array that only holds the elements <span class="No-Break">you want.</span></p>
			<p>By default, an array can hold objects of <span class="No-Break">multiple types:</span></p>
			<pre class="console">
$ScruffyArray = 1, 'socks', (Get-Process)</pre>			<p>We can constrain the type of the objects in an array so that it can only hold objects of <span class="No-Break">one type:</span></p>
			<pre class="console">
[Int32[]]$IntArray = 1..5</pre>			<p>Now try <span class="No-Break">the following:</span></p>
			<pre class="console">
$IntArray += 'socks'</pre>			<p>Oops. We get <span class="No-Break">an error:</span></p>
			<div>
				<div id="_idContainer079" class="IMG---Figure">
					<img src="image/B17600_04_14.jpg" alt="Figure 4.14 – You can’t leave that in there"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.14 – You can’t leave that in there</p>
			<p>If we have a look, we <a id="_idIndexMarker271"/>can see that the type of the <strong class="source-inline">IntArray</strong> object is <strong class="source-inline">[int32[]]</strong> with a base type of <strong class="source-inline">System.Array</strong>, and the type of the elements is <strong class="source-inline">[Int32]</strong>. We saw this syntax in <a href="B17600_02.xhtml#_idTextAnchor034"><span class="No-Break"><em class="italic">Chapter 2</em></span></a>, <em class="italic">Exploring PowerShell Cmdlets and Syntax</em>, when we were looking at the <strong class="source-inline">Get-Help</strong> cmdlet. An empty pair of square brackets denotes a parameter that can take multiple values; in other words, <span class="No-Break">an array:</span></p>
			<div>
				<div id="_idContainer080" class="IMG---Figure">
					<img src="image/B17600_04_15.jpg" alt="Figure 4.15 – System.String accepts an array"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.15 – System.String accepts an array</p>
			<p>Finally, we can add <span class="No-Break">arrays together:</span></p>
			<pre class="console">
$BigArray  = $NewArray + $IntArray</pre>			<p>That’s the basics <a id="_idIndexMarker272"/>covered. Let’s look at the properties and methods we can use <span class="No-Break">with arrays.</span></p>
			<h3>Properties and methods of arrays</h3>
			<p>It is difficult <a id="_idIndexMarker273"/>to use <strong class="source-inline">Get-Member</strong> to see the properties and methods available on an array. PowerShell does not pass the array into the pipeline; it passes each element in the array in order. Try it by typing <span class="No-Break">the following:</span></p>
			<pre class="console">
$NewArray | Get-Member</pre>			<p>All we get back are the properties and methods for the <strong class="source-inline">[</strong><span class="No-Break"><strong class="source-inline">Int32]</strong></span><span class="No-Break"> type.</span></p>
			<p>To see the properties and methods of the array type, you’ll need to either go to the help topic <strong class="source-inline">about_Arrays</strong> or look online <span class="No-Break">here: </span><a href="https://docs.microsoft.com/en-us/powershell/module/microsoft.powershell.core/about/about_arrays"><span class="No-Break">https://docs.microsoft.com/en-us/powershell/module/microsoft.powershell.core/about/about_arrays</span></a><span class="No-Break">.</span></p>
			<p>Let’s have a brief look at some of the more <span class="No-Break">important ones.</span></p>
			<h4>Count, Length, and Rank</h4>
			<p>These are <a id="_idIndexMarker274"/>common<a id="_idIndexMarker275"/> properties<a id="_idIndexMarker276"/> of arrays. <strong class="source-inline">Count</strong> is an alias for <strong class="source-inline">Length</strong>. They both tell us how many elements are in the array. <strong class="source-inline">$NewArray.Count</strong> and <strong class="source-inline">$NewArray.Length</strong> are the same. This is back to the muscle memory thing of old admins, again. You’ll see both in the <span class="No-Break">PowerShell literature.</span></p>
			<p><strong class="source-inline">Rank</strong> is interesting if you’re working with datasets. All the arrays we have been working with are <strong class="bold">one-dimensional</strong> and have<a id="_idIndexMarker277"/> a rank of 1. The objects in the array exist on an imaginary line – even <strong class="source-inline">$ScruffyArray</strong>, which contains the output of <strong class="source-inline">Get-Process</strong>. Most arrays you are likely to work with in PowerShell are one-dimensional. In data science, however, we quite often need to use multidimensional arrays; they’re complicated, and I haven’t seen a good PowerShell module for manipulating them. If you are really interested, have a look at the <strong class="source-inline">about_Arrays</strong> help topic. Just know it’s possible if you need to do a little bit with <span class="No-Break">multidimensional arrays.</span></p>
			<h4>Clear, ForEach, and Where</h4>
			<p>These are common <a id="_idIndexMarker278"/>methods of arrays. Where <a id="_idIndexMarker279"/>the <a id="_idIndexMarker280"/>element of an array supports the <strong class="source-inline">Clear</strong> method, you can use it on the array to clear all the elements. If the element doesn’t support it, though, you’ll get <span class="No-Break">an error.</span></p>
			<div>
				<div id="_idContainer081" class="IMG---Figure">
					<img src="image/B17600_04_16.jpg" alt="Figure 4.16 – Some methods are more useful than others"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.16 – Some methods are more useful than others</p>
			<p>The <strong class="source-inline">ForEach</strong> method allows us to iterate through each element in an array and perform an operation on it. Type the following in to get the squares of the numbers in <span class="No-Break">the array:</span></p>
			<pre class="console">
@(0..3).ForEach({$_ * $_})</pre>			<p>Personally, I find this type of code golf willfully complicated and it goes against PowerShell’s best practices. It’s fine if we’re doing a couple of lines, but I wouldn’t put it in a script. We’ll cover how to do this in a more readable way in <a href="B17600_05.xhtml#_idTextAnchor096"><span class="No-Break"><em class="italic">Chapter 5</em></span></a>, <em class="italic">PowerShell Control Flow – Conditionals </em><span class="No-Break"><em class="italic">and Loops</em></span><span class="No-Break">.</span></p>
			<p>The <strong class="source-inline">Where</strong> method is similar, although more useful in one-liners. To get the elements of <strong class="source-inline">$NewArray</strong> greater than 5, we could type <span class="No-Break">the following:</span></p>
			<pre class="console">
$NewArray.where({$_ -gt 5})</pre>			<p>It’s functionally the same <span class="No-Break">as this:</span></p>
			<pre class="console">
$NewArray | Where-Object {$_ -gt 5}</pre>			<p>And arguably less readable. We covered <strong class="source-inline">Where-Object</strong> in <a href="B17600_03.xhtml#_idTextAnchor049"><span class="No-Break"><em class="italic">Chapter 3</em></span></a>, <em class="italic">The PowerShell Pipeline – How to String Cmdlets Together</em>. Remember, PowerShell will output each member of an array into the pipeline in turn. So, why have these as methods at all? If we are working with very large arrays, then using the method on the array rather than using the pipeline is faster. The following cmdlet takes about 300 ms to complete on <span class="No-Break">my laptop:</span></p>
			<pre class="console">
Measure-Command {@(0..100000).ForEach({$_ * $_})}</pre>			<p>The following cmdlet takes about <span class="No-Break">400 ms:</span></p>
			<pre class="console">
Measure-Command {@(0..100000) | ForEach-Object{$_ * $_}}</pre>			<p>So, it depends on where we want to save time. If the fastest possible code is our aim, then use the<a id="_idIndexMarker281"/> method <a id="_idIndexMarker282"/>on the<a id="_idIndexMarker283"/> array. If we want our code to be quickly understood when we return to it, then use <span class="No-Break">the pipeline.</span></p>
			<h3>Array performance</h3>
			<p>One place where it is<a id="_idIndexMarker284"/> worth saving time, however, is in our manipulation of arrays. While it looks like we can change arrays by adding elements, this is not actually the case. Arrays are a fixed size. Every time we add an element, we create a new array. Let’s say we see something <span class="No-Break">like this:</span></p>
			<pre class="console">
$SlowArray = @()
1..10000 | Foreach-Object { $Slowarray += $_ }</pre>			<p>We’re actually creating and discarding 10,000 arrays. A lot of the documentation will tell us that the alternative is to use a .NET type instead of arrays – <strong class="source-inline">[System.Collections.ArrayList]</strong>, <span class="No-Break">like this:</span></p>
			<pre class="console">
$ArrayList = [System.Collections.ArrayList]@()
1..10000 | ForEach-Object { $Null = $ArrayList.Add($_) }</pre>			<p>Here we have the same sort of programming style, where we create the array variable and then add to it, but we have to call a non-PowerShell type and then use the <strong class="source-inline">Add()</strong> method. It works, but it’s quite complicated, especially when we’re just <span class="No-Break">starting out.</span></p>
			<p>Another alternative is to be clever about how we create our array and construct it <span class="No-Break">like this:</span></p>
			<pre class="console">
$AutoArray = (1..10000 | ForEach-Object {$_})</pre>			<p>This produces the same array as the other two with the speed of the <strong class="source-inline">ArrayList</strong> object type, but with the simplicity of using all PowerShell code. I ran these three cmdlets inside <strong class="source-inline">Measure-Command</strong>, so you can see <span class="No-Break">the difference:</span></p>
			<div>
				<div id="_idContainer082" class="IMG---Figure">
					<img src="image/B17600_04_17.jpg" alt="Figure 4.17 – Three ways of creating the same array"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.17 – Three ways of creating the same array</p>
			<p>I first came across this observation on Tobias Weltner’s excellent blog, <a href="https://PowerShell.one">https://PowerShell.one</a>. I thoroughly<a id="_idIndexMarker285"/> recommend reading <span class="No-Break">his articles.</span></p>
			<h3>Copying arrays</h3>
			<p>Now we have a pretty<a id="_idIndexMarker286"/> good idea of what an array is, we can look at one of the key differences between value types and reference types: how copying variables works. <span class="No-Break">Try this:</span></p>
			<pre class="console">
$a = 42
$b = $a
$a = 'socks'</pre>			<p>Without typing any more – what is in <strong class="source-inline">$b</strong>? If you said <strong class="source-inline">42</strong>, you would be right. Of course it is. The value of <strong class="source-inline">$a</strong> is held in the stack, so when we create <strong class="source-inline">$b</strong>, we copy the value <strong class="source-inline">42</strong> to the top of the stack and call it <strong class="source-inline">$b</strong> (if you got an error saying <strong class="source-inline">'socks' isn't of type [Int32]</strong>, close your PowerShell session and start a <span class="No-Break">new one).</span></p>
			<p>Copying arrays doesn’t work like that. Try <span class="No-Break">the following:</span></p>
			<pre class="console">
$Array1 = 1,2,3
$Array2 = $Array1
$Array1[2] = 5
$Array2</pre>			<p>Argh! What happened there? <strong class="source-inline">Array2</strong> contains the updated value! That’s because all we did when we copied <strong class="source-inline">Array1</strong> to <strong class="source-inline">Array2</strong> was copy the reference to the data in the heap, the process storage area. When we then changed the element, we didn’t create a new array; we just changed the data in the old location. The references remain the same, so all copies of <strong class="source-inline">Array1</strong> will also reference the <span class="No-Break">new data.</span></p>
			<p>How do we get around this? Easy. At least, easyish. Have a go by doing <span class="No-Break">the following:</span></p>
			<pre class="console">
$Array1 = 1,2,3
$Array2 = $Array1 | ForEach-Object {$_}</pre>			<p>And, voilà, we can now make changes to <strong class="source-inline">Array1</strong> without it <span class="No-Break">affecting </span><span class="No-Break"><strong class="source-inline">Array2</strong></span><span class="No-Break">:</span></p>
			<pre class="console">
$Array1[2] = 5
$Array2</pre>			<p>We made PowerShell put each element in <strong class="source-inline">Array1</strong> into the pipeline and pipe it into <strong class="source-inline">Array2</strong>, creating a separate array of data. It’s a bit slow and clunky, but it works, and <span class="No-Break">it’s simple.</span></p>
			<p>That’s enough about <a id="_idIndexMarker287"/>arrays for now. We’ll be doing lots more with them throughout the book. Let’s look at the second reference type we’re going to <span class="No-Break">cover: strings.</span></p>
			<h2 id="_idParaDest-89"><a id="_idTextAnchor090"/>Strings</h2>
			<p>A string is a <a id="_idIndexMarker288"/>sequenced <a id="_idIndexMarker289"/>collection of <strong class="source-inline">[char]</strong> type objects – it’s text. As we saw at the start of this section on reference types, strings are a reference type, and they are immutable – read-only. If you want to change a string, you need to create a new string and destroy the <span class="No-Break">old one.</span></p>
			<p>Strings have two properties, <strong class="source-inline">Chars</strong> and <strong class="source-inline">Length</strong>. <strong class="source-inline">Chars</strong> returns the <strong class="source-inline">[char]</strong> object at the <span class="No-Break">given index:</span></p>
			<pre class="console">
$String = "PowerShell"
$String.Chars(0)</pre>			<p><strong class="source-inline">Chars</strong> is a parameterized property – we must give it a value, known as an <strong class="bold">overload</strong>. It takes a single <strong class="source-inline">[int32]</strong>; anything else will throw an error. We can pass it a variable that contains a single <strong class="source-inline">[int32]</strong>, however. The <strong class="source-inline">Length</strong> property returns the length of the string object <span class="No-Break">in characters:</span></p>
			<pre class="console">
$String.Length</pre>			<p>See the following screenshot for how this <span class="No-Break">all looks:</span></p>
			<div>
				<div id="_idContainer083" class="IMG---Figure">
					<img src="image/B17600_04_18.jpg" alt="Figure 4.18 – Properties of strings"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.18 – Properties of strings</p>
			<p>Strings have a lot of <a id="_idIndexMarker290"/>methods. Where most of the methods on value types involve changing the object type, there are a lot of methods on strings to change the formatting. Have a look <span class="No-Break">at this:</span></p>
			<pre class="console">
$String | Get-Member -MemberType Method | Measure-Object</pre>			<p>And we’ll see there are 52 methods available on strings. We’ll not cover them all here, but let’s try a few of the common ones. Remember, each time we use these methods, we’re manipulating the output of the string, not the contents of <span class="No-Break">the string.</span></p>
			<p>To get the string all <span class="No-Break">in uppercase:</span></p>
			<pre class="console">
$String.ToUpper()</pre>			<p>To get it all <span class="No-Break">in lowercase:</span></p>
			<pre class="console">
$String.ToLower()</pre>			<p>To output the string as an array of <span class="No-Break">single characters:</span></p>
			<pre class="console">
$String.ToCharArray()</pre>			<p>To replace a<a id="_idIndexMarker291"/> character in <span class="No-Break">a string:</span></p>
			<pre class="console">
$String.Replace('o','X')</pre>			<p>After all that, type and see that the actual content of the variable <span class="No-Break">is unchanged:</span></p>
			<pre class="console">
$String</pre>			<p><strong class="source-inline">Replace()</strong>, along with <strong class="source-inline">Join()</strong> and <strong class="source-inline">Split()</strong>, are also available as PowerShell <span class="No-Break">string operators:</span></p>
			<pre class="console">
$List = 'one,two,three,four'
$List.Split(',')</pre>			<p>This can also be written as <span class="No-Break">the following:</span></p>
			<pre class="console">
$List -Split ','</pre>			<p>This is shown in the <span class="No-Break">following screenshot:</span></p>
			<div>
				<div id="_idContainer084" class="IMG---Figure">
					<img src="image/B17600_04_19.jpg" alt="Figure 4.19 – Two ways to split"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.19 – Two ways to split</p>
			<p>Quite often we find we have a date, but it’s in text format and ends up as a string. The <strong class="source-inline">ToDateTime</strong> method allows us to capture that string as a <strong class="source-inline">[DateTime]</strong> type, but we need to supply the culture we want as part of the method. We can do it <span class="No-Break">like this:</span></p>
			<pre class="console">
$Culture = Get-Culture
[String]$DateString = '1/5/2024'
$ImportantDate = $DateString.ToDateTime($Culture)</pre>			<p>We can<a id="_idIndexMarker292"/> see in<a id="_idIndexMarker293"/> the following screenshot that <strong class="source-inline">$ImportantDate</strong> is a <strong class="source-inline">[</strong><span class="No-Break"><strong class="source-inline">DateTime]</strong></span><span class="No-Break"> object:</span></p>
			<div>
				<div id="_idContainer085" class="IMG---Figure">
					<img src="image/B17600_04_20.jpg" alt="Figure 4.20 – Converting a string to a DateTime object"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.20 – Converting a string to a DateTime object</p>
			<p>Even easier, though, if we have the chance, is to use the <strong class="source-inline">[DateTime]</strong> value type accelerator <a id="_idIndexMarker294"/>and cast the<a id="_idIndexMarker295"/> variable as the right type <span class="No-Break">of object:</span></p>
			<pre class="console">
[DateTime]$Anniversary = '1/5/2024'</pre>			<h3>Single and double quote marks</h3>
			<p>In PowerShell, single and <a id="_idIndexMarker296"/>double quote marks behave differently. They can both be used to define a string, but they have different purposes. <span class="No-Break">Try this:</span></p>
			<pre class="console">
$MyName = 'Nick'
Write-Output 'My Name is $MyName'
Write-Output "My Name is $MyName"</pre>			<p>We can see in the following screenshot that the output is <span class="No-Break">very different:</span></p>
			<div>
				<div id="_idContainer086" class="IMG---Figure">
					<img src="image/B17600_04_21.jpg" alt="Figure 4.21 – Single and double quotes"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.21 – Single and double quotes</p>
			<p>Double quotes tell PowerShell to expand the variables it finds before processing. The shell alerts us to what it is going to do by coloring the variable green when we use <span class="No-Break">double quotes.</span></p>
			<p>To print the contents of a variable when it’s going to be immediately followed by another character, enclose the variable name in <span class="No-Break">curly braces:</span></p>
			<pre class="console">
"${MyName}: Engineer"</pre>			<p>To print the variable, and not the contents of the variable, use the backtick <span class="No-Break">character </span><span class="No-Break"><strong class="source-inline">`</strong></span><span class="No-Break">:</span></p>
			<pre class="console">
Write-Output "The value of `$MyName is $MyName"</pre>			<p>We’ll be doing plenty<a id="_idIndexMarker297"/> with strings as we go through the book, but now we should look at another important reference type, <span class="No-Break">the hashtable.</span></p>
			<h2 id="_idParaDest-90"><a id="_idTextAnchor091"/>Hashtables</h2>
			<p>A hashtable is a<a id="_idIndexMarker298"/> PowerShell implementation of a type of data structure called<a id="_idIndexMarker299"/> a dictionary. They consist of a list of <strong class="bold">key-value</strong> pairs. We use hashtables to look up values for a given key or check which key holds a given value; they are basically lookup tables. Let’s create a hashtable and play around <span class="No-Break">with it:</span></p>
			<pre class="console">
$Hash = @{}</pre>			<p>We’re using <strong class="source-inline">@{}</strong> to create a hashtable there. We shouldn’t confuse it with <strong class="source-inline">@()</strong>, which will create an array. Now we’ve got our hashtable, we should put something in it. We can do this when we create the hashtable, <span class="No-Break">like this:</span></p>
			<pre class="console">
$MyBike = @{HandleBar = "ApeHanger"; Color = "Red"; Wheel = 15}</pre>			<p>Note that we use a semicolon to separate the pairs, not a comma as we do <span class="No-Break">in arrays:</span></p>
			<div>
				<div id="_idContainer087" class="IMG---Figure">
					<img src="image/B17600_04_22.jpg" alt="Figure 4.22 – Creating and populating hashtables"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.22 – Creating and populating hashtables</p>
			<p>We can add key-value pairs to the hashtable using the <strong class="source-inline">add</strong> method <span class="No-Break">as follows:</span></p>
			<pre class="console">
$MyBike.Add('Bell', $True)</pre>			<p>The <strong class="source-inline">add</strong> method requires two parameters separated by a comma; the first is the key and must be in quotes, and the second is the value. If this is a string, it must also be <span class="No-Break">in quotes:</span></p>
			<pre class="console">
$MyBike.Add('Condition','Poor')</pre>			<p>Note that, unlike an array, PowerShell treats a hashtable as a <span class="No-Break">single object:</span></p>
			<pre class="console">
$MyBike | Measure-Object</pre>			<p>Compare this with <span class="No-Break">the following:</span></p>
			<pre class="console">
$NewList = @(1,2,3,4)
$NewList | Measure-Object</pre>			<p>However, we can use the <strong class="source-inline">Count</strong> property to return the number of <span class="No-Break">key-value pairs:</span></p>
			<pre class="console">
$MyBike.Count</pre>			<p>Now that we have our<a id="_idIndexMarker300"/> hashtable, what can we do with it? The obvious use is to look <span class="No-Break">up values:</span></p>
			<pre class="console">
$MyBike.condition</pre>			<p>And it returns the value <strong class="source-inline">poor</strong>. We can also use the key like we would use an index in <span class="No-Break">an array:</span></p>
			<pre class="console">
$MyBike['Wheel']</pre>			<p>We can use this method to add key-value pairs <span class="No-Break">as well:</span></p>
			<pre class="console">
$MyBike['Gears'] = 'Fixed'</pre>			<p>The big advantage of using the square brackets is it allows us to pass an array of keys and get the <span class="No-Break">values back:</span></p>
			<pre class="console">
$MyBike['HandleBar', 'Condition', 'Gears']</pre>			<p>Or, we can use a variable to hold <span class="No-Break">the array:</span></p>
			<pre class="console">
$BikeDetails = 'HandleBar', 'Condition', 'Gears'
$MyBike[$BikeDetails]</pre>			<p>We can list out <a id="_idIndexMarker301"/>all the key-value pairs in the hashtable one at a time with the <span class="No-Break"><strong class="source-inline">GetEnumerator()</strong></span><span class="No-Break"> method:</span></p>
			<pre class="console">
$MyBike.GetEnumerator()</pre>			<p>Hold on. Can’t we do that just by typing <strong class="source-inline">$MyBike</strong>? No. If we try to do that, we get the whole hashtable as a single object. It will look like key-value pairs, but it won’t behave like a set of separate ones. Try <span class="No-Break">the following:</span></p>
			<pre class="console">
$MyBike | ForEach-Object {[Array]$BikeProperties += $_}
$BikeProperties.Count
$MyBike.GetEnumerator() | ForEach-Object {[Array]$NewBikeProperties += $_}
$NewBikeProperties.Count</pre>			<p>We can see there that only one object passed through the pipeline in the <span class="No-Break">first line.</span></p>
			<p>We can remove key-value pairs as well with the <span class="No-Break"><strong class="source-inline">remove</strong></span><span class="No-Break"> method:</span></p>
			<pre class="console">
$MyBike.Remove('Gears')</pre>			<p>We can test for the presence of <span class="No-Break">a key:</span></p>
			<pre class="console">
$MyBike.ContainsKey('HandleBar')</pre>			<p>And we can<a id="_idIndexMarker302"/> test for<a id="_idIndexMarker303"/> the presence of <span class="No-Break">a value:</span></p>
			<pre class="console">
$MyBike.ContainsValue('poor')</pre>			<h3>Ordered hashtables</h3>
			<p>By default, hashtables<a id="_idIndexMarker304"/> are not ordered, and this doesn’t really matter<a id="_idIndexMarker305"/> because we’re only ever looking for the values they contain in the key-value pairs. Sometimes, however, we want our hashtable to be arranged in a particular way. We can use the <strong class="source-inline">[ordered]</strong> keyword to do this. Note this doesn’t go before the variable; it goes on the <span class="No-Break">right-hand side:</span></p>
			<pre class="console">
$OrderedHash = [ordered]@{a=10;b=20;c=30}</pre>			<p>And you can see the difference in the <span class="No-Break">following screenshot:</span></p>
			<div>
				<div id="_idContainer088" class="IMG---Figure">
					<img src="image/B17600_04_23.jpg" alt="Figure 4.23 – Ordered hashtable"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.23 – Ordered hashtable</p>
			<p>Notice that it’s now a different type – <strong class="source-inline">OrderedDictionary</strong>. We can still get values by passing the key, but because it is ordered, we can also now just pass the index of the <span class="No-Break">key pair:</span></p>
			<pre class="console">
$OrderedHash.c
$OrderedHash[1]</pre>			<p>Finally, you may <a id="_idIndexMarker306"/>have<a id="_idIndexMarker307"/> noticed that we’re back to bikes again. That’s because there’s another cool thing we can do with hashtables – we can turn them <span class="No-Break">into objects:</span></p>
			<pre class="console">
$MyImaginaryBike = [PSCustomObject]$MyBike</pre>			<p>As you can see from the following screenshot, we now have a <strong class="source-inline">PSCustomObject</strong> called <strong class="source-inline">$MyImaginaryBike</strong> with a set of properties matching the original hashtable <span class="No-Break">key-value pairs:</span></p>
			<div>
				<div id="_idContainer089" class="IMG---Figure">
					<img src="image/B17600_04_24.jpg" alt="Figure 4.24 – Turning a hashtable into an object"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.24 – Turning a hashtable into an object</p>
			<p>Cool, eh? We’ll be using hashtables a lot in the rest of the book because they’re such a <span class="No-Break">useful type.</span></p>
			<p>There are other reference types as well that cover other types of data structures, such as queues and<a id="_idIndexMarker308"/> stacks, but we don’t tend to use them as much, certainly<a id="_idIndexMarker309"/> not in everyday PowerShell. Before we finish this chapter, we’ll cover one final use for <span class="No-Break">hashtables: splatting.</span></p>
			<h1 id="_idParaDest-91"><a id="_idTextAnchor092"/>Splatting – a cool use for hashtables</h1>
			<p>Some<a id="_idIndexMarker310"/> PowerShell<a id="_idIndexMarker311"/> cmdlets take a lot of parameters, and it can be confusing to feed them all into the cmdlet one at a time, all on the same line. Hashtables to the rescue. Try <span class="No-Break">the following:</span></p>
			<pre class="console">
$Colors = @{
ForegroundColor = 'red'
BackgroundColor = 'white'
}
Write-Host 'all the pretty colors' @Colors</pre>			<p>Notice that we don’t use <strong class="source-inline">$Colors</strong>; we use <strong class="source-inline">@Colors</strong>. Also, notice it doesn’t matter which way round we <span class="No-Break">use it:</span></p>
			<pre class="console">
Write-Host @Colors 'OK, just red and white, then'</pre>			<p>This will work as well, because we’ve explicitly named the parameters in <span class="No-Break">the hashtable:</span></p>
			<div>
				<div id="_idContainer090" class="IMG---Figure">
					<img src="image/B17600_04_25.jpg" alt="Figure 4.25 – ﻿A basic example of splatting"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.25 – A basic example of splatting</p>
			<p>We could use an array, but that will only work for positional parameters; the first value in the array will be the first positional parameter, the second value will be the second, and so on. Because most cmdlets don’t have more than one or two positional parameters, this is nothing like as useful as <span class="No-Break">a hashtable.</span></p>
			<p>We’ll be<a id="_idIndexMarker312"/> using <a id="_idIndexMarker313"/>splatting a lot as we go on, but for this chapter, that’s it. Time to summarize what <span class="No-Break">we’ve covered.</span></p>
			<h1 id="_idParaDest-92"><a id="_idTextAnchor093"/>Summary</h1>
			<p>This has been a long chapter, but we’ve learned a lot. We started by looking at variables and how they are used in PowerShell. After that, we took another look at objects from a computer science perspective and learned about their properties and methods. This gave us a grounding to start exploring object types, and we looked at some of the value types, which are equivalent to the computer science concept of primitives. From there, we saw how value types can be grouped together into data structures or reference types. Finally, for a bit of fun, we looked at how splatting can save us time <span class="No-Break">and effort.</span></p>
			<p>In the next chapter, we are going to be looking at flow control in PowerShell, conditional statements such as <strong class="source-inline">if</strong> and <strong class="source-inline">else</strong>, and loops using <strong class="source-inline">ForEach</strong> and <strong class="source-inline">While</strong>. We’ll also be installing more software because that’s the fun <span class="No-Break">stuff, right?</span></p>
			<h1 id="_idParaDest-93"><a id="_idTextAnchor094"/>Exercises</h1>
			<ol>
				<li>What’s wrong with the variable <span class="No-Break"><strong class="source-inline">My Variable</strong></span><span class="No-Break">?</span></li>
				<li>Without trying the code, what <strong class="source-inline">TypeName</strong> will this <span class="No-Break">cmdlet return?</span><pre class="source-code">
New-Variable -Name MyVariable -Value "somestuff"
Get-Variable MyVariable | Get-Member</pre></li>				<li>How can we change the view of the errors PowerShell <span class="No-Break">shows us?</span></li>
				<li>What automatic variable can we use to clear the contents of an array <span class="No-Break">or hashtable?</span></li>
				<li>How might we compare <span class="No-Break">two integers?</span></li>
				<li>What is the object type of <span class="No-Break"><strong class="source-inline">MyVariable</strong></span><span class="No-Break"> here?</span><pre class="source-code">
$MyVariable = ,1</pre></li>				<li>How would we get each character in a string into <span class="No-Break">an array?</span></li>
				<li>What’s going to go wrong here, <span class="No-Break">and why?</span><pre class="source-code">
Write-Output 'My Name is $MyName'</pre></li>				<li>How can we create an object of <span class="No-Break">type </span><span class="No-Break"><strong class="source-inline">OrderedDictionary</strong></span><span class="No-Break">?</span></li>
			</ol>
			<h1 id="_idParaDest-94"><a id="_idTextAnchor095"/>Further reading</h1>
			<p>There is a lot of reading for this chapter because we’ve only really brushed the surface of the subject. We really should read the help topics associated with what we’ve been doing in this chapter, and some of the official PowerShell <span class="No-Break">language documentation:</span></p>
			<ul>
				<li><span class="No-Break"><strong class="source-inline">about_Variables</strong></span><span class="No-Break">: </span><a href="https://docs.microsoft.com/en-us/powershell/module/microsoft.powershell.core/about/about_variables"><span class="No-Break">https://docs.microsoft.com/en-us/powershell/module/microsoft.powershell.core/about/about_variables</span></a></li>
				<li><span class="No-Break"><strong class="source-inline">about_Automatic_Variables</strong></span><span class="No-Break">: </span><a href="https://docs.microsoft.com/en-us/powershell/module/microsoft.powershell.core/about/about_automatic_variables"><span class="No-Break">https://docs.microsoft.com/en-us/powershell/module/microsoft.powershell.core/about/about_automatic_variables</span></a></li>
				<li><span class="No-Break"><strong class="source-inline">about_Preference_Variables</strong></span><span class="No-Break">: </span><a href="https://docs.microsoft.com/en-us/powershell/module/microsoft.powershell.core/about/about_preference_variables"><span class="No-Break">https://docs.microsoft.com/en-us/powershell/module/microsoft.powershell.core/about/about_preference_variables</span></a></li>
				<li><span class="No-Break"><strong class="source-inline">about_Objects</strong></span><span class="No-Break">: </span><a href="https://docs.microsoft.com/en-us/powershell/module/microsoft.powershell.core/about/about_objects"><span class="No-Break">https://docs.microsoft.com/en-us/powershell/module/microsoft.powershell.core/about/about_objects</span></a></li>
				<li>PowerShell <span class="No-Break">types: </span><a href="https://docs.microsoft.com/en-us/powershell/scripting/lang-spec/chapter-04"><span class="No-Break">https://docs.microsoft.com/en-us/powershell/scripting/lang-spec/chapter-04</span></a></li>
				<li>PowerShell <span class="No-Break">Variables: </span><a href="https://docs.microsoft.com/en-us/powershell/scripting/lang-spec/chapter-05"><span class="No-Break">https://docs.microsoft.com/en-us/powershell/scripting/lang-spec/chapter-05</span></a></li>
				<li><span class="No-Break"><strong class="source-inline">about_Booleans</strong></span><span class="No-Break">: </span><a href="https://docs.microsoft.com/en-us/powershell/module/microsoft.powershell.core/about/about_booleans"><span class="No-Break">https://docs.microsoft.com/en-us/powershell/module/microsoft.powershell.core/about/about_booleans</span></a></li>
				<li><span class="No-Break"><strong class="source-inline">about_Arrays</strong></span><span class="No-Break">: </span><a href="https://docs.microsoft.com/en-us/powershell/module/microsoft.powershell.core/about/about_arrays"><span class="No-Break">https://docs.microsoft.com/en-us/powershell/module/microsoft.powershell.core/about/about_arrays</span></a></li>
				<li>PowerShell <span class="No-Break">Arrays: </span><a href="https://docs.microsoft.com/en-us/powershell/scripting/lang-spec/chapter-09"><span class="No-Break">https://docs.microsoft.com/en-us/powershell/scripting/lang-spec/chapter-09</span></a></li>
				<li><span class="No-Break"><strong class="source-inline">about_HashTables</strong></span><span class="No-Break">: </span><a href="https://docs.microsoft.com/en-us/powershell/module/microsoft.powershell.core/about/about_hash_tables"><span class="No-Break">https://docs.microsoft.com/en-us/powershell/module/microsoft.powershell.core/about/about_hash_tables</span></a></li>
				<li>PowerShell <span class="No-Break">hashtables: </span><a href="https://docs.microsoft.com/en-us/powershell/scripting/lang-spec/chapter-10"><span class="No-Break">https://docs.microsoft.com/en-us/powershell/scripting/lang-spec/chapter-10</span></a></li>
				<li><span class="No-Break"><strong class="source-inline">about_Splatting</strong></span><span class="No-Break">: </span><a href="https://docs.microsoft.com/en-us/powershell/module/microsoft.powershell.core/about/about_splatting"><span class="No-Break">https://docs.microsoft.com/en-us/powershell/module/microsoft.powershell.core/about/about_splatting</span></a></li>
			</ul>
		</div>
	</body></html>