- en: Enterprise Repository Management with Pulp
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Pulp 进行企业级仓库管理
- en: So far in this book, we have covered several tasks related to the build and
    configuration of Linux servers for deployment in an Enterprise environment. While
    much of the work we have completed scales well to cover most scenarios, it must
    be noted that so far we have only installed packages from one of two sources—either
    the upstream public package repositories corresponding to each Linux distribution
    we are using or, in the case of our PXE booting chapter, from an ISO image we
    downloaded.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，本书已涵盖了与 Linux 服务器的构建和配置相关的多个任务，旨在用于企业环境中的部署。虽然我们完成的许多工作能够很好地扩展，适用于大多数场景，但必须指出的是，到目前为止，我们只从两种来源之一安装了软件包——要么是与我们使用的每个
    Linux 发行版相对应的上游公共软件包仓库，要么是在我们的 PXE 启动章节中，来自我们下载的 ISO 镜像。
- en: Needless to say, this presents several challenges, especially when it comes
    to creating repeatable, manageable builds of Linux. We will explore these in greater
    depth in the section titled *Installing Pulp for patch management*, but suffice
    to say, using the publicly available repositories means that two builds being
    performed on two different weekdays could be different! The ISO installation method
    presents the other end of the spectrum and always produces consistent builds regardless
    of when they are performed, but in this case, no security (or other) updates are
    received! What is required is a compromise between these two extremes, and thankfully,
    one exists in the form of a software package called **Pulp**.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 不用说，这带来了几个挑战，特别是在创建可重复、可管理的 Linux 构建时。我们将在名为*用于补丁管理的 Pulp 安装*的部分中更深入地探讨这些问题，但可以简单地说，使用公共可用的仓库意味着两次在不同工作日进行的构建可能是不同的！ISO
    安装方法则呈现了另一端的情况，总是产生一致的构建，无论何时执行，但在这种情况下，无法接收安全（或其他）更新！需要的是这两者之间的折衷方案，幸运的是，**Pulp**
    就是这种折衷方案。
- en: 'We shall explore Pulp in this chapter, specifically covering the following:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将探讨 Pulp，具体内容包括：
- en: Installing Pulp for patch management
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用于补丁管理的 Pulp 安装
- en: Building repositories in Pulp
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 Pulp 中构建仓库
- en: Patching processes with Pulp
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Pulp 的补丁管理过程
- en: Technical requirements
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'This chapter includes examples based on the following technologies:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 本章包括基于以下技术的示例：
- en: Ubuntu Server 18.04 LTS
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Ubuntu Server 18.04 LTS
- en: CentOS 7.6
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: CentOS 7.6
- en: Ansible 2.8
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Ansible 2.8
- en: To run through these examples, you will need access to two servers or virtual
    machines running one of each of the operating systems listed previously and Ansible.
    Note that the examples provided in this chapter may be destructive in nature and
    if run as-is are only intended to be run in an isolated test environment.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 要完成这些示例，你将需要访问两台服务器或虚拟机，分别运行前面列出的操作系统之一，并安装 Ansible。请注意，本章提供的示例可能具有破坏性，且如果按原样运行，仅建议在隔离的测试环境中执行。
- en: 'All example code discussed in this chapter is available on GitHub at the following
    URL: [https://github.com/PacktPublishing/Hands-On-Enterprise-Automation-on-Linux/tree/master/chapter08](https://github.com/PacktPublishing/Hands-On-Enterprise-Automation-on-Linux/tree/master/chapter08).'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 本章讨论的所有示例代码都可以在 GitHub 上获取，网址为：[https://github.com/PacktPublishing/Hands-On-Enterprise-Automation-on-Linux/tree/master/chapter08](https://github.com/PacktPublishing/Hands-On-Enterprise-Automation-on-Linux/tree/master/chapter08)。
- en: Installing Pulp for patch management
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 用于补丁管理的 Pulp 安装
- en: Before we delve into the practical aspects of installing Pulp, let's take a
    more in-depth look at why you would use it. Throughout this book, we have advocated
    building a Linux environment that is standardized and features high degrees of
    repeatability, audibility, and predictability. These are important not just as
    a foundation for automation, but also serves as good practice in the enterprise.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们深入探讨如何安装 Pulp 的实际操作之前，让我们更深入地了解一下为何要使用它。在整本书中，我们一直提倡构建一个标准化的 Linux 环境，并具备高重复性、可审计性和可预测性。这些不仅是自动化的基础，也是在企业中良好的实践。
- en: 'Let''s assume that you build a server and deploy a new service to it with Ansible,
    as we have set out earlier in this book. So far, so good—the Ansible playbooks
    provide documentation on the build standard and ensure the build can be accurately
    repeated at a later date. There is a catch, however. Let''s say that, a few months
    later, you return to create another server—perhaps to scale an application or
    for a **Disaster Recovery** (**DR**) scenario. Depending on the source for your
    packages, one of two things will happen:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你构建了一台服务器，并用 Ansible 部署了一个新的服务，正如我们在本书前面所描述的那样。到目前为止，一切顺利——Ansible playbook
    提供了构建标准的文档，并确保构建在以后能够准确重复。然而，有一个问题。假设几个月后，你需要再创建一台服务器——也许是为了扩展应用程序或进行**灾难恢复**（**DR**）场景。根据你获取软件包的来源，可能会发生以下两种情况：
- en: If you install from the public internet-facing repositories, both builds will
    have the latest versions of all the packages that were installed on the date they
    were built. This difference may be significant, and if time has been put into
    testing and qualifying software on a given build of Linux, you may not be able
    to guarantee this with different package versions. Sure, everything is up to date,
    and you will have all of the latest security patches and bug fixes, but every
    time you perform this build on a different day, you are prone to getting different
    package versions. This causes problems with repeatability, especially when ensuring
    that code that has been tested in one environment works in another.
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果你从面向公共互联网的仓库中安装，那么这两个构建将包含在构建时日期安装的所有软件包的最新版本。这种差异可能非常显著，如果你已经投入时间在某个特定 Linux
    构建版本上进行测试和验证，使用不同的软件包版本可能无法保证这一点。当然，一切都是最新的，你会得到所有最新的安全补丁和 bug 修复，但每次你在不同的日期执行这个构建时，可能会得到不同的软件包版本。这会导致可重复性问题，尤其是在确保在一个环境中测试过的代码能够在另一个环境中正常工作时。
- en: At the other end of the scale is the ISO build repositories that we used in [Chapter
    6](0c3b40ef-5f31-4fd1-b05f-d549444db163.xhtml), *Custom Builds with PXE Booting*.
    These never change (unless someone downloads a newer ISO and extracts it over
    the old one), and so while it produces builds that are of a completely known quantity
    (and hence support our repeatability goal), they never receive any security updates.
    This in itself may be a problem.
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 另一端是我们在[第六章](0c3b40ef-5f31-4fd1-b05f-d549444db163.xhtml)《使用 PXE 启动进行自定义构建》中使用的
    ISO 构建仓库。这些仓库从不变化（除非有人下载了更新的 ISO 并将其覆盖到旧的 ISO 上），因此它虽然生成完全已知数量的构建（从而支持我们的可重复性目标），但它们永远不会收到任何安全更新。这本身可能是一个问题。
- en: The compromise is, of course, to find a middle ground between these two extremes.
    What if it were possible to create our own repositories of packages that were
    a snapshot of a given point in time of a public repository? Hence, they remain
    static when we need them to (thus ensuring consistent builds), and yet can be
    updated on demand if an important security fix comes out. The Pulp project comes
    to our rescue here and is capable of doing exactly these things. It is also a
    component in some of the more complex infrastructure management solutions such
    as Katello, as we shall see in the next chapter.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 妥协的地方，当然是要在这两者之间找到一个中间地带。如果能够创建我们自己的软件包仓库，并且这个仓库是某一时刻公共仓库的快照会怎样？这样，当我们需要它们时，它们保持静态（从而确保构建的一致性），而如果出现重要的安全修复，仍然可以按需更新。Pulp
    项目正是为我们解决了这个问题，能够做正是这些事情。它也是一些更复杂的基础设施管理解决方案中的一个组件，例如 Katello，正如我们在下一章中将看到的那样。
- en: However, for installations where a **Graphical User Interface** (**GUI**) is
    not a requirement, Pulp meets our needs perfectly. Let's take a look at how we
    might install it.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，对于不需要**图形用户界面**（**GUI**）的安装，Pulp 完全满足我们的需求。让我们来看看如何安装它。
- en: Installing Pulp
  id: totrans-21
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 安装 Pulp
- en: As we discussed in [Chapter 1](c7596fb8-4971-44d7-943a-7660c5eecb17.xhtml),
    *Building a Standard Operating Environment on Linux*, in this book, there will
    be times when even though you may have built a standardized operating environment
    around a given Linux distribution such as Ubuntu Server, you have to create an
    exception. Pulp is such a case, for although it can manage both `.rpm` and `.deb`
    packages (hence handling repository requirements for a wide variety of Linux distributions),
    it is only packaged for (and therefore is easiest to install) on CentOS, Fedora,
    and RHEL-based operating systems. You can still manage your Ubuntu Server estate
    with Pulp—you just need to install it on CentOS (or your preferred Red Hat variant).
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在[第1章](c7596fb8-4971-44d7-943a-7660c5eecb17.xhtml)中讨论的*在Linux上构建标准操作环境*，在本书中，有时即使您可能已经围绕像Ubuntu
    Server这样的特定Linux发行版构建了标准化操作环境，您仍然需要创建一个例外情况。 Pulp就是这样一个例子，尽管它可以管理`.rpm`和`.deb`软件包（因此可以处理各种Linux发行版的存储库要求），但它只针对CentOS、Fedora和基于RHEL的操作系统打包（因此安装起来最简单）。您仍然可以使用Pulp管理您的Ubuntu
    Server环境，只需在CentOS（或您喜欢的Red Hat变体）上安装它。
- en: There are several facets to the Pulp installation. For example, Pulp relies
    on a MongoDB installation, which may be external if desired. Similarly, it also
    relies on a message bus, and it is possible to use either RabbitMQ or Qpid as
    preferred. Most organizations will have their own standards for these things,
    and so it is left as an exercise to you to define the architecture best suited
    to your enterprise. In this chapter, we will perform a very simple installation
    of Pulp on a single server to demonstrate the steps involved.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: Pulp安装有几个方面。例如，Pulp依赖于MongoDB安装，如果需要的话可以是外部的。同样，它还依赖于消息总线，可以根据需要使用RabbitMQ或Qpid。大多数组织将对这些事物有自己的标准，因此你可以根据你企业的需求来定义最适合的架构。在本章中，我们将在单个服务器上执行一个非常简单的Pulp安装，以演示涉及的步骤。
- en: 'Given the relative complexity of installing Pulp, it is recommended that you
    create an Ansible Playbook for your Pulp installation. However, in this chapter,
    we will complete the installation manually to demonstrate the work involved—there
    is no one-size-fits-all Pulp installation:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 鉴于安装Pulp的相对复杂性，建议您为Pulp安装创建一个Ansible Playbook。但是，在本章中，我们将完成手动安装，以演示所涉及的工作量——因为没有适合所有情况的Pulp安装：
- en: 'Before we can begin the installation, we must build a virtual (or physical)
    server to host our Pulp repositories. For our example, we will base this on CentOS
    7.6, which is the latest supported version for Pulp at the time of writing. Also,
    note the following filesystem requirements:'
  id: totrans-25
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在我们开始安装之前，我们必须构建一个虚拟（或物理）服务器来托管我们的Pulp存储库。在我们的示例中，我们将基于CentOS 7.6进行操作，这是撰写本文时Pulp支持的最新版本。另外，请注意以下文件系统要求：
- en: '`/var/lib/mongodb`: We will build our example Pulp server with MongoDB on the
    same host. The MongoDB database can grow to over 10 GB in size, and it is recommended
    to mount this path on a dedicated LVM backed filesystem so that it can be easily
    grown if required, and so that if it ever does fill up, it doesn''t halt the rest
    of the system.'
  id: totrans-26
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`/var/lib/mongodb`：我们将在同一主机上使用MongoDB构建我们的示例Pulp服务器。MongoDB数据库的大小可以增长到超过10
    GB，并建议将此路径挂载在专用的LVM支持的文件系统上，以便在需要时可以轻松扩展，并且如果它真的填满了，不会使系统的其余部分停止工作。'
- en: '`/var/lib/pulp`: This directory is where the Pulp repositories are housed,
    and again it should be on a dedicated LVM backed filesystem. The size will be
    determined by the repositories you wish to create—for example, if you want to
    mirror a 20 GB upstream repository, then `/var/lib/pulp` needs to be a minimum
    of 20 GB in size. This filesystem also must be XFS-based—if created on `ext4`,
    you run the risk of running out of inodes.'
  id: totrans-27
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`/var/lib/pulp`：这个目录是Pulp存储库的所在地，同样应该在专用的LVM支持的文件系统上。其大小将由您希望创建的存储库决定——例如，如果您想要镜像一个20
    GB的上游存储库，则`/var/lib/pulp`的最小大小应为20 GB。此文件系统还必须基于XFS——如果在`ext4`上创建，您可能会用尽索引节点。'
- en: 'Once these requirements are met, we must install the EPEL repository as the
    Pulp install will draw packages from here:'
  id: totrans-28
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 满足了这些要求后，我们必须安装EPEL存储库，因为Pulp安装将从这里获取软件包：
- en: '[PRE0]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'We then need to install the Pulp repository file:'
  id: totrans-30
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后我们需要安装Pulp存储库文件：
- en: '[PRE1]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Next, we set up the MongoDB server—this must be completed before we proceed
    with the Pulp installation. It is expected that most enterprises will have some
    internal standards for the database servers that they will follow—here, we will
    suffice with a default installation with SSL encryption:'
  id: totrans-32
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们设置MongoDB服务器——这必须在继续进行Pulp安装之前完成。预计大多数企业会有一些关于数据库服务器的内部标准，他们会遵循这些标准——在这里，我们将使用带有SSL加密的默认安装：
- en: '[PRE2]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Again, it is fair to say that most enterprises will have their own certificate
    authority, be it internal or otherwise. For our example server, we will generate
    a simple self-signed certificate with the following command:'
  id: totrans-34
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 再次说，公平地讲，大多数企业会有自己的证书授权机构，无论是内部的还是其他的。对于我们的示例服务器，我们将使用以下命令生成一个简单的自签名证书：
- en: '[PRE3]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'We then need to concatenate the private key and certificate into one file for
    MongoDB to pick up:'
  id: totrans-36
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后我们需要将私钥和证书合并成一个文件，供MongoDB使用：
- en: '[PRE4]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'With this complete, we must reconfigure MongoDB to pick up the newly created
    certificate file and enable SSL. Edit the `/etc/mongod.conf` file and configure
    the following parameters (any other parameters in the file can be left at their
    defaults):'
  id: totrans-38
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 完成此步骤后，我们必须重新配置MongoDB以使用新创建的证书文件并启用SSL。编辑`/etc/mongod.conf`文件，并配置以下参数（文件中的其他参数可以保留默认值）：
- en: '[PRE5]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'At this stage, we can now enable the MongoDB service to start on boot and start
    it:'
  id: totrans-40
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在此阶段，我们现在可以启用MongoDB服务，使其在启动时自动启动，并启动它：
- en: '[PRE6]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'With our Mongo database server running, we now need to install the message
    bus. Again, most enterprises will have corporate standards for this and it is
    recommended to adhere to these where they are defined. The following example is
    the minimum required set of steps for a functional demo—it should not be considered
    fully secured, but it is functional for the sake of testing and evaluating pulp.
    Here, we simply install the required packages and then enable and start the services:'
  id: totrans-42
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在我们的Mongo数据库服务器运行后，我们现在需要安装消息总线。同样，大多数企业会有关于这方面的公司标准，建议遵循这些标准（如果已定义）。以下示例是功能性演示所需的最低步骤——它不应被视为完全安全，但为了测试和评估Pulp，它是可用的。在这里，我们仅安装所需的包，然后启用并启动服务：
- en: '[PRE7]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'With our underlying infrastructure completed, we can now install Pulp itself.
    The initial steps are to install the base packages:'
  id: totrans-44
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 完成底层基础设施后，我们现在可以安装Pulp本身。初步步骤是安装基础包：
- en: '[PRE8]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Pulp uses a plugin-based architecture to host the various repositories it is
    capable of serving. At the time of writing, Pulp is capable of hosting the following:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: Pulp采用基于插件的架构来托管它能够提供的各种仓库。写作时，Pulp能够托管以下内容：
- en: RPM-based repositories (for example, CentOS, RHEL, and Fedora)
  id: totrans-47
  prefs:
  - PREF_UL
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基于RPM的仓库（例如，CentOS、RHEL和Fedora）
- en: DEB-based repositories (for example, Debian and Ubuntu)
  id: totrans-48
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基于DEB的仓库（例如，Debian和Ubuntu）
- en: Python modules (for example, for mirroring PyPI content)
  id: totrans-49
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: Python模块（例如，用于镜像PyPI内容）
- en: Puppet manifests
  id: totrans-50
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: Puppet清单
- en: Docker images
  id: totrans-51
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: Docker镜像
- en: OSTree content
  id: totrans-52
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: OSTree内容
- en: Unfortunately, this chapter does not allow us space to go into all of these
    modules in detail—however, it is safe to say that, at a high-level, Pulp operates
    in the same manner across all these different technologies. Whether working with
    Python modules, Docker images, or RPM packages, you can create a central repository
    that is stable and can be version controlled to ensure an up-to-date environment
    can be maintained without losing control of what that environment contains.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，本章没有空间让我们详细讲解所有这些模块——不过可以说，在高层次上，Pulp在这些不同技术中的运作方式是相同的。无论是处理Python模块、Docker镜像，还是RPM包，你都可以创建一个稳定的中央仓库，并且可以进行版本控制，以确保能够维持一个最新的环境，同时又不会失去对该环境中内容的控制。
- en: 'As our use case is Pulp for serving out Linux packages, we will install the
    RPM- and DEB-based plugins:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们的用例是使用Pulp提供Linux包，我们将安装基于RPM和DEB的插件：
- en: '[PRE9]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'With Pulp installed, we must configure the core services. This is performed
    by editing `/etc/pulp/server.conf`—most of the default settings are fine for a
    simple demo such as ours—however, as we enabled SSL support on our MongoDB backend,
    we must tell the Pulp server we have done this and disable SSL verification as
    we are using self-signed certificates. The `[database]` section of the aforementioned
    file should look like this:'
  id: totrans-56
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 安装完Pulp后，我们必须配置核心服务。通过编辑`/etc/pulp/server.conf`来执行此操作——大多数默认设置对于我们这样的简单演示来说已经足够——然而，由于我们在MongoDB后端启用了SSL支持，我们必须告诉Pulp服务器我们已经这样做，并禁用SSL验证，因为我们使用的是自签名证书。上述文件的`[database]`部分应该如下所示：
- en: '[PRE10]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'If you examine this file, you will see there is a great deal of configuration
    that can be carried out, all of which is well documented with comments. Specifically,
    you can customize the following sections:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您查看此文件，您会看到可以进行大量配置，所有这些都有文档和注释。具体来说，您可以自定义以下部分：
- en: '`[email]`: This is off by default but if you want your Pulp server to send
    email reports, you would configure this here.'
  id: totrans-59
  prefs:
  - PREF_UL
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`[email]`：默认情况下这是关闭的，但如果您希望 Pulp 服务器发送电子邮件报告，您可以在此进行配置。'
- en: '`[database]`: We have simply turned on SSL support in this section, but if
    the database was on an external server or required more advanced parameters, these
    would be specified here.'
  id: totrans-60
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`[database]`：在这一部分，我们仅启用了 SSL 支持，但如果数据库在外部服务器上，或者需要更多高级参数，这些都将在此指定。'
- en: '`[messaging]`: For communication between different Pulp components, the default
    Qpid message broker requires no further configuration here, but if you are using
    RabbitMQ and/or have turned on authentication/SSL support, then that will need
    to be configured here.'
  id: totrans-61
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`[messaging]`：用于不同 Pulp 组件之间的通信，默认的 Qpid 消息代理无需在此进一步配置，但如果您使用 RabbitMQ 和/或启用了身份验证/SSL
    支持，则需要在此进行配置。'
- en: '`[tasks]`: Pulp can have separate message brokers for inter-component communication
    and its asynchronous tasks, and the broker for the latter can be configured here.
    As we are using the same Qpid instance for both functions, nothing further is
    required for this example.'
  id: totrans-62
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`[tasks]`：Pulp 可以为不同组件之间的通信和异步任务使用独立的消息代理，后者的代理可以在此配置。由于我们为这两个功能使用了相同的 Qpid
    实例，因此此示例中无需进一步配置。'
- en: '`[server]`: This is used to configure the server''s default credentials, hostname,
    and such.'
  id: totrans-63
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`[server]`：用于配置服务器的默认凭据、主机名等。'
- en: 'Once the Pulp server is configured, we must generate the RSA key pair and CA
    certificate for Pulp using the following two commands:'
  id: totrans-64
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 配置完 Pulp 服务器后，我们必须使用以下两条命令生成 Pulp 的 RSA 密钥对和 CA 证书：
- en: '[PRE11]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Pulp uses Apache to serve its HTTP(S) content, and so we must configure this.
    First of all, we initialize the backend database by running the following command
    (note it is run as the `apache` user):'
  id: totrans-66
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Pulp 使用 Apache 来提供其 HTTP(S) 内容，因此我们必须进行配置。首先，我们通过运行以下命令初始化后台数据库（注意它是以`apache`用户身份运行的）：
- en: '[PRE12]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'If you are intending to use SSL transport with Apache, be sure to configure
    it to your enterprise requirements. CentOS installs a self-signed certificate
    for Apache SSL by default, but you may want to replace this with a certificate
    signed by your Enterprise CA. Also, be sure to disable the insecure SSL protocols—as
    a minimum, it is recommended to place the following two settings into `/etc/httpd/conf.d/ssl.conf`:'
  id: totrans-68
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果您打算在 Apache 中使用 SSL 传输，请确保根据您的企业要求进行配置。CentOS 默认为 Apache SSL 安装了自签名证书，但您可能想用企业
    CA 签发的证书替换它。此外，务必禁用不安全的 SSL 协议——至少建议将以下两个设置添加到`/etc/httpd/conf.d/ssl.conf`中：
- en: '[PRE13]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: This, of course, is only a guide, and most enterprises will have their own security
    standards that should be adhered to here.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，这只是一个指南，大多数企业会有自己的安全标准，必须遵守这些标准。
- en: As new vulnerabilities are discovered, these requirements may change. The preceding
    configuration is believed to be good practice at the time of writing, but could
    change at any time without notice. It is up to you to check any and all security-related
    settings for your environment.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 随着新漏洞的发现，这些要求可能会发生变化。上述配置在写作时被认为是最佳实践，但可能会随时发生变化，恕不另行通知。您有责任检查您环境中的所有安全相关设置。
- en: 'With Apache configured, set it to start on boot and start it up:'
  id: totrans-72
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 配置完 Apache 后，设置它在启动时自动启动并启动它：
- en: '[PRE14]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Pulp has several other backend services that are required for it to be operational.
    Each of these can be configured and tuned as required, but again, for the sake
    of our example server, it is sufficient to enable and start each in turn:'
  id: totrans-74
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Pulp 还有其他一些后台服务，启动这些服务是其正常运行所必需的。每个服务都可以根据需要进行配置和调整，但再次说明，为了我们的示例服务器，依次启用并启动每个服务就足够了：
- en: '[PRE15]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Our final task is to install the administrative components of Pulp so that
    we can manage our server:'
  id: totrans-76
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们的最终任务是安装 Pulp 的管理组件，以便我们能够管理我们的服务器：
- en: '[PRE16]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'There is one final task to complete for our server. Pulp is designed to be
    administered remotely, and as such, it communicates over SSL to ensure the security
    of all transactions. Although we have created an *all-in-one* host and throughout
    this chapter will perform the server admin from the same host, we need to tell
    the Pulp admin client that we are using self-signed certificates—otherwise, SSL
    validation will fail. To do this, edit `/etc/pulp/admin/admin.conf`, and in the `[server]` section,
    define the following parameter:'
  id: totrans-78
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于我们的服务器，还有一个最后的任务需要完成。Pulp设计为远程管理，因此它通过SSL进行通信，以确保所有交易的安全性。尽管我们创建了一个*一体化*主机，并且在本章中将从同一主机执行服务器管理，但我们需要告诉Pulp管理员客户端我们正在使用自签名证书——否则SSL验证将失败。为此，编辑`/etc/pulp/admin/admin.conf`，并在`[server]`部分定义以下参数：
- en: '[PRE17]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Finally, we can test that our Pulp server is operational by logging in to it.
    Although Pulp supports multiple user accounts, and even integration with LDAP
    backends, a simple installation such as ours comes with one administrator account,
    where the username and password are both `admin`.
  id: totrans-80
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们可以通过登录到Pulp服务器来测试它是否正常运行。虽然Pulp支持多个用户账户，甚至与LDAP后端的集成，但像我们这样简单的安装只提供一个管理员账户，其中用户名和密码均为`admin`。
- en: 'If all goes well, you should see output similar to the following and be able
    to query to server status (note that the output has been truncated to save space):'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一切顺利，你应该能看到类似于以下的输出，并能够查询服务器状态（请注意，输出已被截断以节省空间）：
- en: '![](img/666b7da6-ad6b-40e4-933e-4021fe49b930.png)'
  id: totrans-82
  prefs: []
  type: TYPE_IMG
  zh: '![](img/666b7da6-ad6b-40e4-933e-4021fe49b930.png)'
- en: Now that we have a fully operational Pulp server, we shall demonstrate the process
    of creating repositories for managed stable updates and system builds using our
    newly built Pulp system.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们已经有了一个完全可操作的Pulp服务器，我们将展示如何使用我们新建的Pulp系统创建用于管理稳定更新和系统构建的仓库。
- en: Building repositories in Pulp
  id: totrans-84
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在Pulp中构建仓库
- en: Although in this chapter we will only be using a subset of the features available
    in Pulp, it is intended that a viable workflow is demonstrated here that showcases
    why you might choose Pulp to manage Enterprise repositories, rather than rolling
    your own solution (for example, copying packages off an ISO as we did in [Chapter 6](0c3b40ef-5f31-4fd1-b05f-d549444db163.xhtml),
    *Custom Builds with PXE Booting*).
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然在本章中我们只会使用Pulp中可用功能的一个子集，但我们希望展示一个可行的工作流，展示为什么你可能会选择Pulp来管理企业仓库，而不是自己开发解决方案（例如，像我们在[第六章](0c3b40ef-5f31-4fd1-b05f-d549444db163.xhtml)中所做的那样，*使用PXE启动进行自定义构建*）。
- en: The process for handling RPM-based package repositories and DEB-based ones is
    broadly similar.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 处理基于RPM的软件包仓库和基于DEB的软件包仓库的过程大致相似。
- en: Let's start by exploring how to create and manage RPM-based repositories.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从探索如何创建和管理基于RPM的仓库开始。
- en: Building RPM-based repositories in Pulp
  id: totrans-88
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在Pulp中构建基于RPM的仓库
- en: Although installing Pulp is quite a complex process, once it is installed, the
    process of managing repositories is incredibly straightforward. However, it does
    require a little knowledge of the repository structure for your chosen Linux distribution.
    Let's continue with the CentOS 7 build that we have been using as an example throughout
    this book.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管安装Pulp的过程相当复杂，但一旦安装完成，管理仓库的过程就非常简单。不过，这确实需要了解你所选择的Linux发行版的仓库结构。让我们继续使用本书中一直作为示例的CentOS
    7版本。
- en: The core CentOS 7 repositories are split into two—first of all, there is the OS repository;
    this contains all of the files for the latest point release of CentOS 7—which,
    at the time of writing, is 7.6\. This was last updated in November 2018 and will
    remain static until CentOS 7.7 is released. The updates for this release are then
    contained in a separate repository, and so to build a fully functional mirror
    for CentOS 7 in our Pulp server, we need to mirror both of these paths.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 核心的CentOS 7仓库分为两部分——首先是OS仓库；它包含CentOS 7最新点版本的所有文件——截至写作时，最新版本是7.6。该版本在2018年11月更新过一次，并将在CentOS
    7.7发布之前保持静态状态。此版本的更新将包含在一个单独的仓库中，因此，要在我们的Pulp服务器上构建一个完整的CentOS 7镜像，我们需要镜像这两个路径。
- en: 'Let''s start by creating a mirror of the base operating system:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从创建基础操作系统的镜像开始：
- en: 'The first step is to log into the `pulp-admin` client, as we demonstrated at
    the end of the previous section. Then, from there, we run the following command
    to create a new repository:'
  id: totrans-92
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 第一步是登录到`pulp-admin`客户端，正如我们在上一节的结尾所展示的。然后，在此基础上，我们运行以下命令来创建一个新的仓库：
- en: '[PRE18]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Let''s break that command down:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来拆解一下这个命令：
- en: '`rpm repo create`: This set of keywords tells the Pulp server to create a new
    RPM-based repository definition. Note that nothing is synchronized or published
    at this stage—this is simply creating metadata for a new repository.'
  id: totrans-95
  prefs:
  - PREF_UL
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`rpm repo create`：这组关键字告诉Pulp服务器创建一个新的基于RPM的仓库定义。请注意，在此阶段并不会同步或发布任何内容——这只是为新仓库创建元数据。'
- en: '`--repo-id=''centos76-os''`: This tells Pulp that the ID of our new repository
    is `centos76-os`—this is like a unique key and should be used to differentiate
    your new repository from others.'
  id: totrans-96
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`--repo-id=''centos76-os''`：这告诉Pulp我们的新仓库的ID是`centos76-os`——这类似于一个唯一的标识符，应当用来区分你的新仓库与其他仓库。'
- en: '`--relative-url=''centos76-os''`: This instructs Pulp where to publish the
    repository—RPM-based repositories are published at `http(s)://pulp-server-address/pulp/repos/<relative-url>`.'
  id: totrans-97
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`--relative-url=''centos76-os''`：这指示Pulp将仓库发布到何处——基于RPM的仓库发布地址为`http(s)://pulp-server-address/pulp/repos/<relative-url>`。'
- en: '`--feed=http://mirror.centos.org/centos/7/os/x86_64/`:   This is the upstream
    location from which RPM-based content will be synchronized.'
  id: totrans-98
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`--feed=http://mirror.centos.org/centos/7/os/x86_64/`：这是将同步RPM内容的上游位置。'
- en: 'With our repository definition created, the next step is to synchronize the
    packages from the upstream server. This is as simple as running this command:'
  id: totrans-99
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在创建好我们的仓库定义后，下一步是从上游服务器同步软件包。只需运行以下命令即可：
- en: '[PRE19]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'This kicks off an asynchronous command that runs in the background on the server—you
    can check the status at any time using this command:'
  id: totrans-101
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这将启动一个异步命令，在服务器后台运行——你可以随时使用以下命令检查状态：
- en: '[PRE20]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Finally, once the synchronization is completed, the repository must be published—this
    effectively makes the synchronized content available over the Apache web server
    installed as part of the Pulp installation earlier:'
  id: totrans-103
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，一旦同步完成，必须发布该仓库——这实际上是通过Pulp安装时配置的Apache Web服务器，使同步的内容可以访问：
- en: '[PRE21]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Now, with this completed, you have an internal snapshot of the upstream CentOS
    7.6 OS repository defined by the `--feed` parameter, which will remain constant
    on our Pulp server even when CentOS 7.7 is released.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，完成此步骤后，你将拥有由`--feed`参数定义的上游CentOS 7.6操作系统仓库的内部快照，即使在CentOS 7.7发布时，这个快照也会在我们的Pulp服务器上保持不变。
- en: Now, of course, we also need updates to ensure we get the latest security patches,
    bug fixes, and so on. The frequency of updates of your repositories will depend
    upon your patching cycle, internal security policies, and so on. Hence, we will
    define a second repository to house the update packages.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，当然，我们还需要更新，以确保获取最新的安全补丁、错误修复等。仓库的更新频率将取决于你的补丁周期、内部安全政策等。因此，我们将定义第二个仓库来存放更新包。
- en: 'We will issue an almost identical set of commands to the preceding ones to
    create the updates repository, only this time there are two key differences:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将发出一组与之前几乎相同的命令来创建更新仓库，只是这次有两个关键的区别：
- en: We are using the `/updates/` path for the feed rather than `/os/`.
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们使用`/updates/`路径来获取源内容，而不是`/os/`。
- en: 'We have put a date stamp into `repo-id` and `relative-url`—you could, of course,
    adopt your own versioning scheme here—however, as this repository will be a snapshot
    of all CentOS 7 updates to August 7, 2019, using the date of the snapshot as an
    identifier is one sensible approach:'
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们在`repo-id`和`relative-url`中加入了日期戳——当然，你也可以采用自己的版本控制方案——然而，由于这个仓库将是2019年8月7日之前所有CentOS
    7更新的快照，使用快照日期作为标识符是一个合理的做法：
- en: '[PRE22]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: With this run, we can then use the `pulp-admin` client to inspect the repositories
    and inspect the disk usage. At present, we can see that the Pulp filesystem has
    33 GB used, though not all of this is for CentOS as there are other repositories
    on this test system. This level of usage will become important in a minute.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 通过运行此命令，我们可以使用`pulp-admin`客户端来检查仓库并查看磁盘使用情况。目前，我们可以看到Pulp文件系统已经使用了33GB的空间，虽然并不是全部用于CentOS，因为这个测试系统上还有其他仓库。稍后，这个使用情况将变得重要。
- en: In an enterprise environment, a good practice would be to build or update a
    set of test CentOS 7 systems to this August 7 snapshot and perform the requisite
    testing on them to ensure confidence in the build. This is especially important
    in physical systems where kernel changes could cause issues. Once confidence has
    been established in this build, it becomes the baseline for all CentOS 7 systems.
    The great thing about this for an enterprise scenario is that all systems (provided
    they use the Pulp repository) will have the same versions of all packages. This,
    combined with good automation practices, as we have discussed throughout this
    book so far, brings almost Docker-like stability and platform confidence to a
    Linux environment.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 在企业环境中，一个好的做法是构建或更新一组测试用的 CentOS 7 系统到这次 8 月 7 日的快照，并在其上进行必要的测试，以确保对构建的信心。对于物理系统来说，这一点尤其重要，因为内核变更可能会引发问题。一旦建立了对这个构建的信心，它就成为所有
    CentOS 7 系统的基准。对于企业场景来说，最棒的一点是，所有系统（只要它们使用 Pulp 仓库）将拥有所有软件包的相同版本。这与我们在本书中讨论的良好自动化实践结合，能为
    Linux 环境带来几乎像 Docker 一样的稳定性和平台信心。
- en: Building on this scenario, suppose that overnight a critical security patch
    is released for CentOS 7\. As important it is to apply this patch in a timely
    manner, it also is important to perform testing on it to ensure it doesn't break
    any existing services. As a result, we do not wish to update our `centos7-07aug19` repository
    mirror, as this is a known stable snapshot (in other words, we have tested it
    and are happy with it—it is stable within our enterprise environment).
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 基于这个场景，假设过夜发布了一个关键的安全补丁，针对的是 CentOS 7。尽管及时应用这个补丁非常重要，但同样重要的是进行测试，确保它不会破坏任何现有服务。因此，我们不希望更新我们的
    `centos7-07aug19` 仓库镜像，因为这是一个已知的稳定快照（换句话说，我们已经测试过它并且满意——它在我们的企业环境中是稳定的）。
- en: If we were just using the upstream internet-facing repositories, then we would
    have no control over this and our CentOS 7 servers would blindly pick up the patch
    the next time an update was run. Equally, if we were manually building repository
    mirrors using a tool such as `reposync`, we would have one of two choices. First,
    we could update our existing mirror, which would cost us little disk space, but
    would bring the same problems as using the upstream repositories (that is, all
    servers pick up the new patch as soon as an update is run). Alternatively, we
    could create a second snapshot for testing purposes. I estimated that mirroring
    the CentOS 7 updates on the Pulp server required approximately 16 GB of disk space
    and so creating a second snapshot would require around 32 GB of disk space. As
    time goes on, more snapshots would require more and more disk space, which is
    incredibly inefficient.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们只是使用上游的面向互联网的仓库，那么我们将无法控制这一点，我们的 CentOS 7 服务器会在下一次更新时盲目地获取这个补丁。同样，如果我们手动使用像
    `reposync` 这样的工具来构建仓库镜像，我们将有两个选择。首先，我们可以更新现有的镜像，这样我们会节省一些磁盘空间，但这会带来与使用上游仓库相同的问题（即所有服务器在运行更新时都会立刻获取新的补丁）。另外，我们可以创建第二个快照进行测试。我估算，在
    Pulp 服务器上镜像 CentOS 7 更新大约需要 16 GB 的磁盘空间，因此创建第二个快照需要大约 32 GB 的磁盘空间。随着时间的推移，更多的快照将需要越来越多的磁盘空间，这显然非常低效。
- en: 'This is where Pulp really shines—not only can it create and manage RPM-based
    repositories in an efficient manner, but it also knows not to download packages
    that it already has on a sync operation and not to duplicate packages on a publish—hence,
    it is very efficient in terms of both bandwidth and disk usage. Due to this, we
    can issue the following command set to create a new snapshot of the CentOS 7 updates
    on August 8:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 这正是 Pulp 真正出色的地方——它不仅能够高效地创建和管理基于 RPM 的仓库，而且还知道在同步操作中不下载已存在的包，并且在发布时不会重复包——因此，它在带宽和磁盘使用方面非常高效。基于此，我们可以执行以下命令集来创建一个新的
    CentOS 7 更新快照，日期为 8 月 8 日：
- en: '[PRE23]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'You will recognize the similarity with the commands we ran earlier in this
    section to create the August 7, 2019 snapshot—they are, in fact, identical except
    for the new repository ID (`--repo-id`) and URL (`--relative-url`), which carry
    the new date in to differentiate it from our earlier one. This process will run
    as before, as shown in the following screenshot—it appears that all packages are
    downloaded and at this stage, there is little clue as to what goes on behind the
    scenes:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 你会发现，这与我们在本节中早些时候运行的命令非常相似，用于创建2019年8月7日的快照——它们实际上是相同的，除了新的仓库 ID（`--repo-id`）和
    URL（`--relative-url`），这些参数带有新的日期，用来与我们之前的快照区分开。这个过程将像以前一样运行，如下图所示——看起来所有包都被下载了，在此阶段，几乎没有任何线索说明后台发生了什么：
- en: '![](img/35ae2ab6-0b63-4f93-a0a2-8dc28039fd0c.png)'
  id: totrans-118
  prefs: []
  type: TYPE_IMG
  zh: '![](img/35ae2ab6-0b63-4f93-a0a2-8dc28039fd0c.png)'
- en: 'However, let''s now examine the disk usage:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，现在让我们检查一下磁盘使用情况：
- en: '![](img/133bb03b-d5a6-47e3-a3ce-e277eb7f3a58.png)'
  id: totrans-120
  prefs: []
  type: TYPE_IMG
  zh: '![](img/133bb03b-d5a6-47e3-a3ce-e277eb7f3a58.png)'
- en: Here, we can see that the disk usage has been rounded up to 34 GB—we would likely
    find the usage considerably less if we used a more fine-grained measure. In this
    way, Pulp allows us to create snapshots almost as we require them, without consuming
    vast amounts of disk space, while retaining older ones for stability purposes
    until new ones are proved, at which point redundant snapshots can be deleted.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们可以看到磁盘使用量已被精确到34GB——如果我们使用更细粒度的测量，可能会发现使用量要少得多。通过这种方式，Pulp 使我们几乎可以根据需要创建快照，而不会消耗大量磁盘空间，同时保持旧的快照以保证稳定性，直到新的快照通过验证，此时可以删除多余的快照。
- en: It is worth saying in this regard that deleting a repository from Pulp does
    not necessarily free up disk space. The reason for this is that the package de-duplication
    at the backend must be careful not to delete any packages that are still required.
    In our example, more than 99% of the packages from our August 7 snapshot are also
    in the August 8 one, and so it is important that if we delete either of these,
    that the other remains intact.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里值得一提的是，从 Pulp 中删除仓库不一定会释放磁盘空间。原因是后台的包去重操作必须小心，避免删除任何仍然需要的包。在我们的例子中，2019年8月7日的快照中超过99%的包也出现在8月8日的快照中，因此，如果我们删除其中之一，另一个必须保持完好。
- en: In Pulp, this process is called orphan recovery, and it is the very process
    of finding packages that no longer belong to any repository (presumably because
    the repository was deleted) and tidying them up.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Pulp 中，这个过程被称为孤立包恢复，它是寻找那些不再属于任何仓库（大概是因为仓库已被删除）并整理它们的过程。
- en: 'Completing our current example, suppose that we tested our August 8 snapshot
    and the updated packages in it caused problems in testing. From this, we have
    determined that this snapshot is not suitable for production and that we will
    delete it, pending creation of a new snapshot when a fix becomes available:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 完成我们当前的例子，假设我们测试了2019年8月8日的快照，并且其中更新的包在测试中导致了问题。由此，我们确定该快照不适合生产环境，因此我们将删除它，等待修复发布时创建一个新的快照：
- en: 'First of all, we must delete the repository itself:'
  id: totrans-125
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们必须删除该仓库本身：
- en: '[PRE24]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: This removes the repository definition and the published URL on the Apache server
    so that it can no longer be used.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 这将移除仓库定义和 Apache 服务器上的发布 URL，使其不再可用。
- en: 'To clean up any orphan packages, we can then issue the following command:'
  id: totrans-128
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要清理任何孤立的包，我们可以执行以下命令：
- en: '[PRE25]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'This command is a general cleanup that removes all orphans from across the
    entire Pulp server and is a good general maintenance step. However, the command
    can receive more fine-grained control to remove only a specific type of orphan
    (for example, you could clean out all orphan RPMs, but not DEB packages):'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 这个命令是一个通用的清理操作，会从整个 Pulp 服务器中移除所有孤立包，是一个很好的常规维护步骤。然而，该命令也可以接受更细粒度的控制，仅移除特定类型的孤立包（例如，你可以清除所有孤立的
    RPM 包，但不清除 DEB 包）：
- en: '![](img/024a3646-89cc-40da-b766-091b2db4e84e.png)'
  id: totrans-131
  prefs: []
  type: TYPE_IMG
  zh: '![](img/024a3646-89cc-40da-b766-091b2db4e84e.png)'
- en: 'Once this step is completed, we will see that our additional disk space used
    by the new snapshot has been recovered:'
  id: totrans-132
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 完成此步骤后，我们将看到由新快照占用的额外磁盘空间已被回收：
- en: '![](img/32b4b4fd-9aa2-4f55-b0f1-d270f76b8f3e.png)'
  id: totrans-133
  prefs: []
  type: TYPE_IMG
  zh: '![](img/32b4b4fd-9aa2-4f55-b0f1-d270f76b8f3e.png)'
- en: In this section, so far we have stepped through all the Pulp commands and activities
    manually—this has been done to provide you with a good understanding of the steps
    required in setting up Pulp and the accompanying repositories. In regular services,
    best practice would dictate that these steps are performed with Ansible—however,
    there are no native Ansible modules to cover all of the tasks we have performed
    in this chapter.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，到目前为止，我们已经手动执行了所有Pulp命令和活动——这样做是为了让你充分了解设置Pulp和相应仓库所需的步骤。在常规服务中，最佳实践是通过Ansible来执行这些步骤，然而，目前并没有原生的Ansible模块来覆盖我们在本章中执行的所有任务。
- en: For example, the `pulp_repo` module (introduced to Ansible in version 2.3) is
    capable of creating and deleting repositories, as we have done so far in this
    chapter with `pulp-admin rpm repo create`. However, it cannot perform orphan clean-up,
    and so this command would need to be issued using the `shell` or `command` Ansible
    modules. Full automation with Ansible is left as an exercise for you.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，`pulp_repo`模块（在Ansible 2.3版本中引入）能够创建和删除仓库，就像我们在本章中使用`pulp-admin rpm repo
    create`所做的那样。然而，它不能执行孤儿清理，因此需要通过`shell`或`command` Ansible模块来发出此命令。完整的自动化操作将留给你作为练习。
- en: Once our repos are set up, the final step is to put them into use on our Enterprise
    Linux servers, and we will cover this in the next section of this chapter.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们的仓库设置完成，最后一步就是在我们的企业Linux服务器上使用它们，接下来我们将在本章的下一部分中介绍这一内容。
- en: First, though, we will look at some of the nuances of managing DEB packages
    in Pulp in contrast to RPM-based management.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 不过，在此之前，我们将对比管理Pulp中的DEB包与RPM管理之间的一些细节。
- en: Building DEB-based repositories in Pulp
  id: totrans-138
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在Pulp中构建基于DEB的仓库
- en: 'Although there are some subtle differences in the command-line structure between
    the RPM repository plugin for Pulp and the DEB one, the overall process is the
    same. As before, some prior knowledge is also required of the repository structure
    to create an effective mirror. In this book, we have worked with Ubuntu Server
    18.04 LTS as an example, and the default repository set that is configured on
    this is as follows:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然Pulp的RPM仓库插件和DEB仓库插件之间在命令行结构上存在一些细微差异，但整体流程是相同的。如同之前一样，创建有效镜像需要一些先前的仓库结构知识。本书中，我们以Ubuntu
    Server 18.04 LTS为例，配置的默认仓库集如下：
- en: '`bionic`: This is the baseline repository for the release of Ubuntu Server
    18.04 (codename Bionic Beaver), and as with the OS repository for CentOS 7, does
    not change following the release of the operating system'
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`bionic`：这是Ubuntu Server 18.04（代号Bionic Beaver）发布的基础仓库，和CentOS 7的操作系统仓库一样，发布操作系统后不会发生变化。'
- en: '`bionic-security`: These are security-specific updates for the bionic operating
    system built post-release'
  id: totrans-141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`bionic-security`：这些是针对bionic操作系统的安全更新，发布后提供。'
- en: '`bionic-updates`: These are non-security updates for the bionic operating system
    release'
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`bionic-updates`：这些是针对bionic操作系统版本的非安全更新。'
- en: There are other repositories too, such as `backports`, and in addition to the `main` component
    (which we will concern ourselves with here), there is a wide array of packages
    available in the `restricted`, `universe`, and `multiverse` components. Going
    into greater detail about the Ubuntu repository structure is beyond the scope
    of this book, but suffice to say there is a wide array of documentation available
    on this subject. The following link is a good place to start reading about the
    different Ubuntu repositories you may wish to mirror: [https://wiki.ubuntu.com/SecurityTeam/FAQ#Repositories_and_Updates](https://wiki.ubuntu.com/SecurityTeam/FAQ#Repositories_and_Updates).
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 还有其他仓库，如`backports`，除了`main`组件（我们在这里关注的组件）外，`restricted`、`universe`和`multiverse`组件中也有大量的可用包。深入了解Ubuntu仓库结构超出了本书的范围，但可以肯定的是，有大量的文档可供参考。以下链接是了解你可能想要镜像的不同Ubuntu仓库的一个好起点：[https://wiki.ubuntu.com/SecurityTeam/FAQ#Repositories_and_Updates](https://wiki.ubuntu.com/SecurityTeam/FAQ#Repositories_and_Updates)。
- en: 'For now, let''s suppose we are updating a minimal build of Ubuntu Server 18.04
    LTS. For this, we are only interested in packages in the `main` component, but
    we do need a snapshot of all the security fixes and updates at a given point in
    time, just like one we had for our CentOS 7 build:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，假设我们正在更新一个最小化构建的Ubuntu Server 18.04 LTS。在这种情况下，我们只关注`main`组件中的包，但我们确实需要在某个时刻的所有安全修复和更新的快照，就像我们在CentOS
    7构建中所做的那样：
- en: 'First of all, having ensured we are logged in to the `pulp-admin` client as
    before, we will create a repository in Pulp for the `main` component and the operating
    system release packages:'
  id: totrans-145
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，在确保我们像之前一样登录到`pulp-admin`客户端后，我们将在Pulp中为`main`组件和操作系统发布包创建一个仓库：
- en: '[PRE26]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: As you can see, the preceding command is very similar to our RPM repository
    creation command. We specify `repo-id` and `relative-url` in the same manner as
    before and specify an upstream `feed` URL. This time, though, we are specifying
    the Ubuntu `releases`, `components`, and `architectures` as command-line options
    whereas, in our CentOS 7 example, these were implicit in the URL we mirrored.
    In addition to these DEB-specific configuration parameters, we are now also specifying
    the `--serve-http` option. By default, Pulp serves all repository content over
    HTTPS only. However, owing to some limitations around package signing for DEB
    packages in Pulp, which will be discussed later in this chapter, we must enable
    the serving of repository content over plain HTTP.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，前面的命令与我们的RPM仓库创建命令非常相似。我们以与之前相同的方式指定`repo-id`和`relative-url`，并指定上游的`feed`
    URL。不过，这次我们在命令行选项中指定了Ubuntu的`releases`、`components`和`architectures`，而在我们的CentOS
    7示例中，这些选项是在我们镜像的URL中隐含的。除了这些DEB特有的配置参数外，我们现在还指定了`--serve-http`选项。默认情况下，Pulp仅通过HTTPS提供所有仓库内容。然而，由于Pulp在处理DEB包的签名时存在一些限制（将在本章稍后讨论），我们必须启用通过普通HTTP提供仓库内容。
- en: Note that, as the plural naming of the `--releases` option implies, more than
    one release may be specified here. Although this works at repository creation
    time, the sync process is, at the time of writing, broken, and so one separate
    Pulp repository must be created for each Ubuntu release we wish to mirror. This
    is expected to be fixed at a future date.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，正如`--releases`选项的复数命名所示，这里可以指定多个发布版本。尽管这在仓库创建时有效，但在写作时，同步过程存在问题，因此必须为我们希望镜像的每个Ubuntu发布版本创建一个单独的Pulp仓库。预计这个问题将在未来某个时候修复。
- en: 'Having done this, we will create two more repositories for the `security` and `updates` repositories:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 完成此操作后，我们将为`security`和`updates`仓库创建另外两个仓库：
- en: '[PRE27]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'With our repository creation completed, we can run our sync processes, just
    like we did previously:'
  id: totrans-151
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 完成了我们的仓库创建后，我们可以像之前一样运行同步过程：
- en: '[PRE28]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Finally, we publish the repositories:'
  id: totrans-153
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们发布这些仓库：
- en: '[PRE29]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: It is worth noting that Ubuntu repositories tend to be much larger than their
    CentOS counterparts, especially the `updates` and `security` ones. During the
    sync process, the packages are downloaded into `/var/cache/pulp` temporarily before
    they are archived into the `/var/lib/pulp` directory. If `/var/cache/pulp` is
    on your root filesystem, there is a significant danger of your root filesystem
    filling up, and as such, it may be best to create a new volume for this purpose
    and mount at `/var/cache/pulp` to prevent a disk full situation from stopping
    your Pulp server.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 值得注意的是，Ubuntu仓库通常比CentOS仓库大，尤其是`updates`和`security`仓库。在同步过程中，软件包会暂时下载到`/var/cache/pulp`，然后再归档到`/var/lib/pulp`目录。如果`/var/cache/pulp`位于你的根文件系统上，存在根文件系统填满的重大风险，因此，最好为此创建一个新卷，并将其挂载到`/var/cache/pulp`，以防磁盘空间不足导致Pulp服务器停止运行。
- en: The DEB plugin for Pulp features the same package deduplication as its RPM counterpart
    and publishes packages over HTTPS (and optionally HTTP) in the same manner. With
    a few changes to the syntax of the commands, we can effectively create snapshots
    of upstream Linux repositories for most of the major distributions that are found
    in enterprise environments.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: Pulp的DEB插件具有与其RPM对应插件相同的软件包去重功能，并且以相同的方式通过HTTPS（并可选择HTTP）发布软件包。通过对命令语法进行一些更改，我们可以有效地为大多数企业环境中常见的主要Linux发行版创建上游仓库的快照。
- en: As a result of completing this section, you have learned how to create your
    own repository mirrors for both RPM- and DEB-based content in Pulp, which may
    be treated as stable and unchanging and hence provide an excellent basis for patch
    management in an enterprise.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 完成本节内容后，你已经学会了如何在Pulp中为基于RPM和DEB的内容创建自己的仓库镜像，这些镜像可以视为稳定且不变的，因此为企业中的补丁管理提供了一个优秀的基础。
- en: In the next section of this chapter, we will look at how to deploy these repositories
    to two different types of Linux server.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的下一节中，我们将学习如何将这些仓库部署到两种不同类型的Linux服务器上。
- en: Patching processes with Pulp
  id: totrans-159
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Pulp进行补丁处理
- en: It is worth mentioning at the outset of this section that Pulp supports two
    main methods for the distribution of packages from the repositories created within
    it. The first is a kind of push-based distribution that uses something called
    the **Pulp Consumer**.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 本节开始时值得提到的是，Pulp 支持两种主要的方法来分发从其中创建的仓库中的软件包。第一种是基于推送的分发方式，使用一种叫做 **Pulp Consumer**
    的工具。
- en: 'We will not be exploring this in this chapter for the following reasons:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不会在本章中探讨这一点，原因如下：
- en: The Pulp Consumer only works with RPM-based repositories and distributions,
    and at the time of writing, there is no equivalent client available for Ubuntu
    or Debian. This means that our processes cannot be uniform across the enterprise,
    which, in an ideal world, they would be.
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Pulp Consumer 仅适用于基于 RPM 的仓库和发行版，目前没有适用于 Ubuntu 或 Debian 的等效客户端。这意味着我们的流程不能在整个企业中统一，在理想情况下，它们应该是统一的。
- en: Using the Pulp Consumer means we would have two overlapping means of automation.
    Distributing packages to nodes using the consumer is a task that can be performed
    with Ansible, and if we use Ansible for this task, then we have an approach that
    is common across all of our platforms. This supports the principles of automation
    in an enterprise context that we established earlier in this book around lowering
    barriers to entry, ease of use, and so on.
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Pulp Consumer 意味着我们将有两种重叠的自动化方式。使用消费者将软件包分发到节点是一个可以通过 Ansible 完成的任务，如果我们使用
    Ansible 来执行这个任务，那么我们就有了一种跨平台通用的方法。这支持我们在本书早些时候所建立的企业自动化原则，旨在降低进入门槛、简化使用等。
- en: As such, we will build out separate Ansible-based examples for managing repositories
    and updates using the repositories we created in the previous section, entitled *Building
    repositories in Pulp*. These can be managed along with all the other Ansible playbooks
    and can be run through a platform such as AWX to ensure a single pane of glass
    is used wherever possible for all tasks.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们将为管理仓库和更新构建单独的基于 Ansible 的示例，使用前一部分中创建的仓库，名为 *在 Pulp 中构建仓库*。这些可以与所有其他 Ansible
    playbook 一起管理，并可以通过像 AWX 这样的平台运行，以确保尽可能在所有任务中使用统一的管理界面。
- en: Let's get started by looking at how to patch RPM-based systems using a combination
    of Ansible and Pulp.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始吧，看看如何通过结合使用 Ansible 和 Pulp 来修补基于 RPM 的系统。
- en: RPM-based patching with Pulp
  id: totrans-166
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 基于 RPM 的 Pulp 补丁
- en: In the previous section of this chapter, we created two repositories for our
    CentOS 7 build—one for the operating system release and another to contain the
    updates.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的前一部分，我们为 CentOS 7 构建创建了两个仓库——一个用于操作系统版本，另一个用于存放更新。
- en: 'The process of updating a CentOS 7 build from these repositories is, at a high
    level, done as follows:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 从这些仓库更新 CentOS 7 构建的过程，从高层次来看，按照以下步骤进行：
- en: Move aside any existing repository definitions in `/etc/yum.repos.d` to ensure
    we only load repositories from the Pulp server.
  id: totrans-169
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 `/etc/yum.repos.d` 中的任何现有仓库定义移开，以确保只加载来自 Pulp 服务器的仓库。
- en: Deploy the appropriate configuration using Ansible.
  id: totrans-170
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 Ansible 部署适当的配置。
- en: Employ Ansible to pull the updates (or any required packages) from the Pulp
    server using the new configuration.
  id: totrans-171
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 Ansible 从 Pulp 服务器拉取更新（或任何所需的包），使用新配置进行操作。
- en: 'Before we proceed with creating the appropriate playbooks, let''s take a look
    at what the repository definition file would look like on our CentOS 7 machine
    if we created it by hand. Ideally, we want it to look something like this:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 在继续创建适当的 playbook 之前，先看看如果我们手动创建仓库定义文件，它在 CentOS 7 机器上的样子。理想情况下，我们希望它看起来像这样：
- en: '[PRE30]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: There's nothing particularly unique about this configuration—we are using the `relative-url` we
    created earlier with our repository using `pulp-admin`. We are using GPG checking
    of package integrity, along with the CentOS 7 RPM GPG key, which we know will
    already be installed on our CentOS 7 machine. The only tweak we've had to make
    to this otherwise standard configuration is to turn off SSL verification since
    our demo Pulp server features a self-signed certificate. Of course, if we are
    using an enterprise certificate authority and the CA certificates are installed
    on each machine, then this problem goes away.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 这个配置没有什么特别之处——我们使用的是之前通过 `pulp-admin` 创建的仓库的 `relative-url`。我们使用 GPG 校验包完整性，并使用
    CentOS 7 的 RPM GPG 密钥，我们知道它已经安装在 CentOS 7 机器上。我们唯一需要调整的地方是关闭 SSL 验证，因为我们的示范 Pulp
    服务器使用了自签名证书。当然，如果我们使用企业级证书颁发机构，并且每台机器上都安装了 CA 证书，那么这个问题就不复存在。
- en: Given the power of Ansible, we can be a bit clever about how we do this. There's
    no point creating and deploying static configuration files when we know that,
    at some point, we're going to update the repository—meaning, at the very least,
    that `baseurl` might change.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 Ansible 的强大功能，我们可以在做这件事时更加灵活。当我们知道在某个时刻会更新仓库时（至少`baseurl`可能会变化），就没有必要创建和部署静态配置文件了。
- en: 'Let''s start off by creating a role called `pulpconfig` to deploy the correct
    configuration—`tasks/main.yml` should look like this:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从创建一个名为`pulpconfig`的角色开始，部署正确的配置——`tasks/main.yml`应该如下所示：
- en: '[PRE31]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'The accompanying `templates/centos-pulp.repo.j2` template should look like
    this:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 随附的`templates/centos-pulp.repo.j2`模板应该如下所示：
- en: '[PRE32]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Notice the variable substitutions at the end of each of the `baseurl` lines—these
    allow us to keep the same template (which should be common for most purposes)
    but change the repository URL over time to adapt to updates.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 注意每个`baseurl`行末尾的变量替换——这些替换使我们能够保持相同的模板（对于大多数用途应该是通用的），但随着时间的推移更改仓库 URL 以适应更新。
- en: 'Next, we will define a second role specifically for updating the kernel—this
    will be very simple for our example and `tasks/main.yml` will contain the following:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将定义一个专门用于更新内核的第二个角色——对于我们的示例来说，这将非常简单，`tasks/main.yml`将包含以下内容：
- en: '[PRE33]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Finally, we will define `site.yml` at the top level of the playbook structure
    to pull all of this together. We could, as we discussed previously, define the
    variables for the relative URLs in a whole host of places, but for the sake of
    this example, we will put them in the `site.yml` playbook itself:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将在剧本结构的顶层定义`site.yml`，将所有这些整合在一起。正如我们之前讨论的那样，我们可以在许多地方定义相对 URL 的变量，但为了本示例的方便，我们将它们放在`site.yml`剧本中：
- en: '[PRE34]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Now, if we run this in the usual manner, we will see output similar to the
    following:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果我们以通常的方式运行它，我们将看到类似以下的输出：
- en: '![](img/3ca9b23c-7687-4ddf-b54d-6a6039dab28f.png)'
  id: totrans-186
  prefs: []
  type: TYPE_IMG
  zh: '![](img/3ca9b23c-7687-4ddf-b54d-6a6039dab28f.png)'
- en: So far, so good—the `changed` statuses from the preceding play tell us that
    the new configuration was applied successfully.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，一切顺利——前面的剧本中的`changed`状态告诉我们新配置已成功应用。
- en: Those with a keen eye will have observed the warning on the `Clean out yum database` tasks—Ansible
    detects when a raw shell command is being used that has overlapping functionality
    with a module and recommends that you use the module instead for reasons of repeatability
    and idempotency, as we discussed earlier. However, as we want to ensure all traces
    of any earlier `yum` databases are removed (which can present problems), I have
    adopted a *brute force* method here to clean up the old databases.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 眼尖的读者可能已经注意到`清理 yum 数据库`任务中的警告——Ansible 检测到使用了与模块功能重叠的原始 shell 命令，并建议为了重复性和幂等性，最好使用模块。正如我们之前讨论的那样，然而，由于我们希望确保彻底清除任何早期的`yum`数据库（因为它们可能会造成问题），所以我采用了*暴力清理*的方法来清理旧的数据库。
- en: 'Now, as I''m sure you will have spotted, the great thing about this approach
    is that if, say, we want to test our `08aug19` repository snapshot that we created
    in the previous section, all we have to do is modify the `vars:` block of `site.yml` so
    that it looks like this:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，正如你肯定已经发现的，这种方法的一个优点是，如果我们想测试在上一节中创建的`08aug19`仓库快照，我们只需要修改`site.yml`中的`vars:`块，使其看起来像这样：
- en: '[PRE35]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Hence, we can reuse the same playbook, roles, and templates in a variety of
    scenarios simply by changing one or two variable values. In an environment such
    as AWX, these variables could even be overridden using the GUI, making the whole
    process even easier.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们可以通过仅仅改变一个或两个变量值，在各种场景中重用相同的剧本、角色和模板。在像 AWX 这样的环境中，这些变量甚至可以通过图形界面（GUI）被覆盖，从而使整个过程更加简单。
- en: In this way, combining Ansible with Pulp lends itself to a really stable enterprise
    framework for managing and distributing (and even testing) updates. However, before
    we look at this process on Ubuntu, a word on rollbacks. In the previous section,
    we hypothesized an example where our `08aug19` snapshot failed testing and so
    had to be deleted. As far as CentOS 7 servers are concerned, rollbacks are not
    as straightforward as simply installing the earlier repository definitions and
    performing an update since the update will detect newer packages that have been
    installed and take no action.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这种方式，将Ansible与Pulp结合起来，为管理和分发（甚至测试）更新提供了一个非常稳定的企业框架。然而，在我们讨论Ubuntu上的这个过程之前，先说几句关于回滚的内容。在上一节中，我们假设了一个例子，其中我们的`08aug19`快照在测试中失败，因此必须删除。就CentOS
    7服务器而言，回滚并不像简单地安装早期的仓库定义并执行更新那样直接，因为更新将检测到已安装的更新软件包，并不会执行任何操作。
- en: The Pulp repository does, of course, provide a stable base to roll back to—however,
    rollbacks are generally quite a manual process as you must identify the transaction
    ID in the `yum` database that you want to roll back to and validate the actions
    to be performed and then roll back to it. This, of course, can be automated, provided
    you have a reliable way of retrieving the transaction ID.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，Pulp仓库提供了一个稳定的基础，可以回滚到之前的版本——然而，回滚通常是一个相当手动的过程，因为你必须在`yum`数据库中找到要回滚的事务ID，验证将要执行的操作，然后回滚到该版本。当然，如果你有可靠的方法来获取事务ID，这一过程是可以自动化的。
- en: 'The following screenshot shows a simple example of identifying the transaction
    ID for the kernel update we just automated and establishing the details of the
    change that was performed:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图展示了一个简单的例子，如何识别我们刚刚自动化的内核更新的事务ID，并建立执行的更改的详细信息：
- en: '![](img/23b9467c-1cc1-453c-9f97-a11cf42a8071.png)'
  id: totrans-195
  prefs: []
  type: TYPE_IMG
  zh: '![](img/23b9467c-1cc1-453c-9f97-a11cf42a8071.png)'
- en: 'Then, we can (if we so choose) roll back the transaction using the command
    shown in the following screenshot:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，如果我们愿意，可以使用以下截图中的命令来回滚事务：
- en: '![](img/b2a07d83-c7b1-4c53-a864-4f904ba65b1e.png)'
  id: totrans-197
  prefs: []
  type: TYPE_IMG
  zh: '![](img/b2a07d83-c7b1-4c53-a864-4f904ba65b1e.png)'
- en: Using this simple process and the playbooks offered here as a guide, it should
    be possible to establish a solid, stable, automated update platform for any RPM-based
    Linux distribution.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这个简单的过程，以及这里提供的playbook作为指南，应该能够为任何基于RPM的Linux发行版建立一个稳固、稳定、自动化的更新平台。
- en: In the next section, we will look at the method we can use to perform the same
    set of tasks, except for DEB-based systems such as Ubuntu.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将探讨如何使用相同的方法来执行一系列任务，除了像Ubuntu这样的基于DEB的系统。
- en: DEB-based patching with Pulp
  id: totrans-200
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 基于DEB的补丁管理与Pulp
- en: At a high level, the process of managing updates on Ubuntu from our Pulp server
    is exactly the same as it is for managing the RPM based updates for CentOS (save
    for the fact that we have no option regarding the use of the Pulp Consumer and
    must use Ansible for the update process).
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 从高层次来看，从我们的Pulp服务器上管理Ubuntu的更新过程与管理CentOS的RPM更新过程完全相同（只是我们没有选择使用Pulp Consumer的选项，必须使用Ansible进行更新过程）。
- en: 'There are, however, a couple of limitations when it comes to the use of Pulp
    with Ubuntu''s APT repository system:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，使用Pulp与Ubuntu的APT仓库系统时，有几个限制：
- en: At the time of writing, there is an issue whereby the Pulp sync process does
    not mirror the signing keys from the upstream Ubuntu repository. This means that
    even though the upstream repository features `Release.gpg`, it is not mirrored
    on the Pulp server. Hopefully, in the future, this will be fixed, but in this
    chapter, we will work around this by adding implicit trust to the packages.
  id: totrans-203
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在撰写本文时，存在一个问题，即Pulp同步过程无法从上游Ubuntu仓库镜像签名密钥。这意味着即使上游仓库中包含`Release.gpg`，它也不会在Pulp服务器上镜像。希望未来这个问题能够解决，但在本章中，我们将通过为软件包添加隐式信任来解决这个问题。
- en: HTTPS support on Ubuntu is configured not to accept updates from unverifiable
    (that is, self-signed) certificates by default. Although we can turn off SSL verification
    as we did on CentOS, Ubuntu's APT package manager then goes in search of an `InRelease` file
    (which should have the aforementioned GPG key embedded). As we discussed in the
    previous point, the Pulp DEB plugin does not support the signing of mirrored repositories,
    and so right now, the only workaround for this is to use unencrypted HTTP traffic.
    Hopefully, in a future release, these two issues will be fixed—however, at the
    time of writing, there appears to be no documented fix or workaround for them.
  id: totrans-204
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Ubuntu 上的 HTTPS 支持默认配置为不接受来自不可验证（即自签名）证书的更新。虽然我们可以像在 CentOS 上一样关闭 SSL 验证，但 Ubuntu
    的 APT 包管理器随后会寻找一个`InRelease`文件（该文件应包含上述的 GPG 密钥）。正如我们在前面讨论的，Pulp DEB 插件不支持镜像仓库的签名，因此目前唯一的解决方法是使用未加密的
    HTTP 流量。希望在未来的版本中，这两个问题能得到解决——然而，截至本文编写时，似乎没有公开的修复或解决方法。
- en: 'With these two limitations understood, we can define our APT sources file for
    the repository set we created earlier. Following on from the examples in the previous
    section, our `/etc/apt/sources.list` file could look like this:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 了解了这两个限制后，我们可以为之前创建的仓库集定义我们的 APT 源文件。根据上一节的示例，我们的 `/etc/apt/sources.list` 文件可能如下所示：
- en: '[PRE36]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'The `[trusted=yes]` string tells the APT package manager to ignore the lack
    of package signing. The file structure itself is incredibly simple, and so just
    as with our CentOS example, we can create a template file so that the relative
    URL can be populated using a variable:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: '`[trusted=yes]` 字符串告诉 APT 包管理器忽略缺少包签名的情况。文件结构本身非常简单，因此与我们的 CentOS 示例一样，我们可以创建一个模板文件，以便使用变量填充相对
    URL：'
- en: 'First, we''ll create a role called `pulpconfig` and create the following `templates/sources.list.j2` template:'
  id: totrans-208
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们将创建一个名为 `pulpconfig` 的角色，并创建以下 `templates/sources.list.j2` 模板：
- en: '[PRE37]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Then, we will create some tasks with the role to install this template and
    move aside any old configuration for APT:'
  id: totrans-210
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们将创建一些任务，使用该角色来安装此模板，并移除任何旧的 APT 配置：
- en: '[PRE38]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Finally, we will define a role to update the kernel, but this time using APT:'
  id: totrans-212
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们将定义一个角色来更新内核，但这次使用 APT：
- en: '[PRE39]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Our `site.yml` playbook for Ubuntu systems now looks like this—save for the
    variable differences, it is almost identical to the CentOS 7 one, once again highlighting
    the value in using Ansible as an automation platform:'
  id: totrans-214
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们的 `site.yml` Ubuntu 系统的 playbook 现在如下所示——除了变量的不同，几乎与 CentOS 7 的版本完全相同，再次突显了使用
    Ansible 作为自动化平台的价值：
- en: '[PRE40]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Now, after putting this all together and running it, we should see output similar
    to what can be seen in the following screenshot:'
  id: totrans-216
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，整理好这些内容并运行后，我们应该看到类似以下屏幕截图的输出：
- en: '![](img/866e4066-b61c-493e-a2ad-59507ea55947.png)'
  id: totrans-217
  prefs: []
  type: TYPE_IMG
  zh: '![](img/866e4066-b61c-493e-a2ad-59507ea55947.png)'
- en: Putting aside the security limitations present in the current Pulp Debian support,
    this provides a neat space-efficient solution for managing Ubuntu updates across
    an enterprise infrastructure in a manner that is repeatable and lends itself well
    to automation. As with our earlier CentOS-based example, it would be very easy
    to test packages from a new snapshot by simply changing the variable definitions
    passed to our roles.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 摒除当前 Pulp Debian 支持中的安全限制，这为在企业基础设施中以可重复和适合自动化的方式管理 Ubuntu 更新提供了一个简洁且节省空间的解决方案。与我们之前基于
    CentOS 的示例一样，通过简单地更改传递给角色的变量定义，测试新快照中的包将变得非常容易。
- en: As with CentOS, should a new package set not be suitable for production use,
    Ansible makes it easy to restore the previous repository configuration. However,
    rolling back packages on Ubuntu (and other Debian-based distributions) is a much
    more manual process than we saw in the previous section. Fortunately, there is
    a great deal of history regarding package transactions kept in `/var/log/dpkg.log` and `/var/log/apt/history.log*`, which
    can be used to determine which packages were installed and/or upgraded and when.
    The `apt-get` command can then be used to install a specific version of a package
    using the `apt-get install <packagename>=<version>` syntax. There are many elegant
    scripted solutions to this problem on the internet, and so it is left as an exercise
    for you to determine the one best suited to your needs and environment.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 与 CentOS 一样，如果新的一组软件包不适合用于生产环境，Ansible 使得恢复之前的仓库配置变得简单。然而，在 Ubuntu（以及其他基于 Debian
    的发行版）上回滚软件包比我们在上一节中看到的过程要手动得多。幸运的是，`/var/log/dpkg.log` 和 `/var/log/apt/history.log*`
    中保存了大量关于软件包事务的历史记录，可以用来确定哪些软件包被安装和/或升级，以及何时进行的。然后，可以使用 `apt-get` 命令，通过 `apt-get
    install <packagename>=<version>` 语法安装特定版本的软件包。网络上有很多优雅的脚本化解决方案，因此这部分将留给你作为练习，自己决定哪种解决方案最适合你的需求和环境。
- en: Summary
  id: totrans-220
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: Managing package repositories in an enterprise setting can present numerous
    challenges, especially when it comes to efficient storage, conservation of internet
    bandwidth, and ensuring build consistency. Fortunately, the Pulp software package
    provides an elegant solution to these challenges for most of the common Linux
    distributions and lends itself well to effective management in the enterprise.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 在企业环境中管理软件包仓库可能会面临许多挑战，尤其是在高效存储、节省互联网带宽和确保构建一致性方面。幸运的是，Pulp 软件包为大多数常见的 Linux
    发行版提供了一个优雅的解决方案，并且非常适合在企业环境中的有效管理。
- en: In this chapter, you learned how to install Pulp to begin patching an Enterprise
    Linux environment. You then learned how to build repositories in Pulp for both
    RPM-based and DEB-based Linux distributions through hands-on examples, before
    gaining practical knowledge of deploying the appropriate Pulp configuration and
    updating packages using Ansible.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你学习了如何安装 Pulp 以开始修补企业 Linux 环境。接着，你通过实践示例学习了如何在 Pulp 中为基于 RPM 和 DEB 的 Linux
    发行版构建仓库，并获得了使用 Ansible 部署适当的 Pulp 配置和更新软件包的实用知识。
- en: In the next chapter, we will explore how the Katello software tools complement
    Pulp in enterprise environment management.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将探索 Katello 软件工具如何在企业环境管理中与 Pulp 相辅相成。
- en: Questions
  id: totrans-224
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: Why would you want to create a repository with Pulp rather than just a simple
    mirror of files that you could download manually?
  id: totrans-225
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为什么要使用 Pulp 创建一个仓库，而不是仅仅创建一个可以手动下载的文件镜像？
- en: What are the issues around building and testing Linux patch repositories in
    an enterprise environment?
  id: totrans-226
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在企业环境中构建和测试 Linux 补丁仓库时会遇到哪些问题？
- en: What components does Pulp need to run?
  id: totrans-227
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Pulp 需要哪些组件才能运行？
- en: Specify the filesystem requirements for successfully installing Pulp.
  id: totrans-228
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 指定成功安装 Pulp 所需的文件系统要求。
- en: How would you patch an RPM-based system from a Pulp repository you created previously?
  id: totrans-229
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如何从你之前创建的 Pulp 仓库修补一个基于 RPM 的系统？
- en: Why would you use Ansible to deploy patches from a Pulp repository rather than
    the Pulp Consumer?
  id: totrans-230
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为什么使用 Ansible 从 Pulp 仓库部署补丁，而不是使用 Pulp Consumer？
- en: Does the removal of a Pulp repository free up disk space? If not, how is this
    performed?
  id: totrans-231
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 删除 Pulp 仓库是否释放磁盘空间？如果没有，如何执行此操作？
- en: Further reading
  id: totrans-232
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 延伸阅读
- en: For more in-depth details on the Pulp project and how to make use of this tool,
    please refer to the official documentation ([https://pulpproject.org/](https://pulpproject.org/)).
  id: totrans-233
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 欲了解更多关于 Pulp 项目及如何使用该工具的详细信息，请参考官方文档（[https://pulpproject.org/](https://pulpproject.org/)）。
