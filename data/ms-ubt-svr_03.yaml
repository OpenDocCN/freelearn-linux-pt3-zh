- en: '3'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '3'
- en: Managing Software Packages
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 管理软件包
- en: Now that you have a server installation set up, and you know how to manage users
    on it, it’s time to cover the management of software. The Ubuntu platform has
    a huge range of software available, featuring packages for everything from server
    administration to games. In fact, as of the time I’m writing this chapter, there
    are over 60,000 packages in Ubuntu’s repositories. That’s a lot of software packages,
    and in this chapter, we’ll take a look at how to manage them. We’ll cover how
    to install, remove, and update packages, as well as the use of related tools.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经设置好了服务器安装，并且知道如何管理服务器上的用户，是时候来了解如何管理软件了。Ubuntu 平台提供了大量的软件，从服务器管理到游戏应有尽有。事实上，在我写这章内容的时候，Ubuntu
    的仓库中已经有超过 60,000 个软件包。这是非常多的软件包，在这一章里，我们将看看如何管理它们。我们将介绍如何安装、卸载和更新软件包，以及如何使用相关的工具。
- en: 'As we go through these concepts, we will cover:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们讲解这些概念时，我们将涵盖：
- en: Understanding Linux package management
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解 Linux 包管理
- en: Understanding the differences between Debian and Snap packages
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解 Debian 包和 Snap 包的区别
- en: Installing and removing software
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 安装和卸载软件
- en: Searching for packages
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 查找软件包
- en: Managing package repositories
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 管理软件包仓库
- en: Backing up and restoring Debian packages
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 备份和恢复 Debian 软件包
- en: Cleaning up orphaned APT packages
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 清理孤立的 APT 软件包
- en: Taking advantage of hardware enablement updates
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 利用硬件启用更新
- en: To get started, let’s build an understanding of how software packages are distributed
    in Ubuntu, and the basic principles of the concept of package management.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 为了开始，让我们了解一下 Ubuntu 中软件包的分发方式，以及包管理概念的基本原理。
- en: Understanding Linux package management
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解 Linux 包管理
- en: Nowadays, *app stores* are all the rage on most platforms; typically, you’ll
    have one central location from which to retrieve applications, allowing you to
    install them on your device. Even phones and tablets utilize a central software
    repository in which software is curated and made available. The Android platform
    has Google Play, Apple has its App Store, and so on. For those that have used
    Linux for a while, this concept isn’t new. The concept of software repositories
    is similar to that of app stores and has been around within the Linux community
    since long before cellular phones even had color screens.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 如今，*应用商店*在大多数平台上都非常流行；通常，你会有一个集中位置来获取应用程序，从中安装到你的设备上。即便是手机和平板电脑也利用一个集中的软件仓库，在其中软件被策划并提供。Android
    平台有 Google Play，Apple 有它的 App Store，等等。对于那些已经使用 Linux 一段时间的人来说，这个概念并不新鲜。软件仓库的概念与应用商店类似，并且早在移动电话还没有彩屏之前，Linux
    社区就已经有了这个概念。
- en: Linux has had package management since the ‘90s, initially popularized by **Debian**
    and then **Red Hat**. Software repositories are generally made available in the
    form of **mirrors**, to which your server subscribes. Mirrors are available across
    a multitude of geographic areas, so, typically, your installation of Ubuntu Server
    would subscribe to the mirror closest to you. These mirrors are populated with
    software packages that you’ll be able to install. Many packages depend on other
    packages, so various tools on the Linux platform exist to automatically handle
    these dependencies for you. Not all distributions of Linux feature package management
    and dependency resolution, but Ubuntu certainly does, benefiting from the groundwork
    already built by Debian.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: Linux 从90年代开始就有了包管理功能，最初由**Debian**推广，然后是**Red Hat**。软件仓库通常以**镜像**的形式提供，服务器会订阅这些镜像。镜像在多个地理区域都有提供，所以通常情况下，你的
    Ubuntu Server 安装会订阅离你最近的镜像。这些镜像里包含了你可以安装的软件包。许多软件包依赖其他软件包，因此在 Linux 平台上有各种工具可以自动处理这些依赖关系。并不是所有
    Linux 发行版都具有包管理和依赖关系解决功能，但 Ubuntu 当然具备，因为它继承了 Debian 已经打下的基础。
- en: Packages contained within these mirrors are constantly changing. Traditionally,
    an individual known as a **package maintainer** is responsible for one or more
    packages and ships new versions to the repositories for approval and, eventually,
    distribution to mirrors. Specific to Ubuntu’s repositories, a group of developers,
    rather than just a single maintainer, is responsible for maintaining packages.
    Most of the time, the new version of a package is provided in order to patch a
    security vulnerability, but otherwise it contains no new features. With the majority
    of Ubuntu’s packages being open source, anyone is able to look at the source code,
    find problems, and report issues. When vulnerabilities are found, the responsible
    team will review the claim and then release an updated version to correct it.
    This process happens very quickly, and I’ve seen severe vulnerabilities patched
    even on the same day that they were reported in some cases. Ubuntu developers
    are definitely on top of their game in terms of taking care of security issues.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 这些镜像中的软件包在不断变化。传统上，一个被称为**软件包维护者**的个人负责一个或多个软件包，并将新版本提交到软件库进行审批，最终分发到镜像中。对于
    Ubuntu 的软件库来说，负责维护软件包的是一组开发人员，而不仅仅是一个维护者。大多数情况下，软件包的新版本是为了修复安全漏洞，但没有其他新功能。由于 Ubuntu
    的大多数软件包都是开源的，任何人都可以查看源代码，发现问题并报告。发现漏洞后，负责的团队会审查报告并发布更新版本进行修复。这个过程非常迅速，我曾见过在漏洞报告当天就发布了修复版本。可以说，Ubuntu
    的开发人员在处理安全问题方面非常专业。
- en: New versions of packages are also sometimes feature updates, which are updates
    released to introduce new features not necessarily tied to a security vulnerability.
    This could be a new version of a desktop application such as Firefox or a server
    package such as MySQL. Most of the time, though, new versions of packages that
    are vastly different are held for the next Ubuntu release. The reason for this
    is that too much change can cause your server to not be as stable, and experience
    application or even entire OS-level crashes. Instead, known working and stable
    packages are preferred; however, given the fact that Ubuntu releases every six
    months, you don’t have to wait very long.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 软件包的新版本有时也是功能更新，这些更新发布是为了引入一些新功能，这些新功能不一定与安全漏洞有关。这可能是桌面应用程序的新版本，例如 Firefox，或者服务器软件包的新版本，例如
    MySQL。然而，大多数时候，版本差异较大的新软件包会等到下一个 Ubuntu 版本发布时才会推出。原因在于，过多的变化可能导致你的服务器不够稳定，可能会出现应用程序甚至整个操作系统崩溃的情况。相比之下，已知的稳定软件包是首选；然而，由于
    Ubuntu 每六个月发布一次，你不必等得太久。
- en: Specifically, feature updates in an Ubuntu release must go through an approval
    process before being made available in the default repositories, and these feature
    updates are specifically referred to as **Stable Release Updates** (**SRUs**).
    There’s an entire process around how these updates are approved, but the general
    takeaway is that there should be a good reason to implement a major version change
    in a stable, long-term Ubuntu release.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 具体来说，Ubuntu 版本中的功能更新必须经过审批流程，才能在默认的软件库中发布，这些功能更新被特别称为**稳定发布更新**（**SRUs**）。关于这些更新的审批流程有一个完整的过程，但总体的理解是，在一个稳定的长期支持
    Ubuntu 版本中，进行大版本更新应该有充分的理由。
- en: As a server administrator, you’ll often need to make a choice between security
    and feature updates. Security updates are the most important of all and allow
    you to patch your servers in response to security vulnerabilities. Sometimes,
    feature updates become required in your organization because it’s decided that
    new features may benefit you or may become required for current objectives. In
    this chapter, we won’t focus on installing security updates (we’ll take care of
    that in *Chapter 21*, *Securing Your Server*), but it’s important to understand
    the reasons new packages are made available to you.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 作为服务器管理员，你经常需要在安全性和功能更新之间做出选择。安全更新是最重要的，它允许你在面对安全漏洞时修补服务器。有时，功能更新会在你的组织中变得必要，因为决定新增的功能可能会对你有所帮助，或者可能成为当前目标所必需的。在这一章中，我们不会重点讨论安装安全更新（我们会在*第21章*，*保护你的服务器*中处理这部分内容），但理解为什么会有新的软件包发布给你是非常重要的。
- en: Package management is typically very convenient in Ubuntu, with security updates
    and bug fixes coming regularly. With just one command (which we’ll get to shortly),
    you can install a package along with all of its dependencies. Having performed
    manual dependency resolution myself, I can tell you first-hand that having dependencies
    handled automatically is a wonderful thing.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Ubuntu 中，软件包管理通常非常方便，安全更新和漏洞修复定期发布。只需一条命令（我们稍后会介绍），你就可以安装一个软件包及其所有依赖项。亲自处理过手动依赖解决的我可以告诉你，自动处理依赖项是非常棒的事情。
- en: The main benefit of how packages are maintained on a Linux server is that you
    generally don’t have to search the internet for packages to download, as Ubuntu’s
    repositories contain most of the ones you’ll ever need. As we continue through
    this chapter, you’ll come to know everything you need in order to manage this
    software.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Linux 服务器上维护软件包的主要好处是，通常你不需要在互联网上搜索下载软件包，因为 Ubuntu 的仓库包含了你所需的大多数软件包。随着本章的深入，你将了解管理这些软件所需的一切。
- en: Understanding the differences between Debian and Snap packages
  id: totrans-22
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解 Debian 和 Snap 软件包之间的区别
- en: Now, before we get into the ins and outs of managing packages, there are actually
    two completely different types of packages available to you, and you should understand
    the differences between them. As of the time of writing, we’re at a kind of crossroads
    regarding the way in which software is managed in Linux.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在我们深入了解如何管理软件包之前，实际上有两种完全不同类型的软件包可供选择，你应该理解它们之间的区别。撰写本文时，Linux 中的软件管理方式正处于一个十字路口。
- en: Traditionally, each distribution has its own package format and its own utilities
    to manage them. Ubuntu utilizes **Debian packages** (with package names ending
    in `.deb`) as the main package format, which Ubuntu inherits from the Debian distribution
    (Ubuntu is forked from Debian, which means that it uses Debian as a foundation).
    Ubuntu and Debian utilize the `apt` and `dpkg` commands to manage packages. On
    the other hand, distributions such as CentOS and Red Hat use **RPM packages**
    for their distributions, and the `dnf` command to manage them. There are other
    distributions and package formats as well, but for this book, we’ll stick with
    what’s available in Ubuntu. First, let’s discuss Debian packages.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 传统上，每个发行版都有自己的软件包格式和用于管理它们的工具。Ubuntu 使用 **Debian 软件包**（软件包名以 `.deb` 结尾）作为主要的软件包格式，这一格式是
    Ubuntu 从 Debian 发行版继承而来的（Ubuntu 是从 Debian 分支出来的，这意味着它以 Debian 为基础）。Ubuntu 和 Debian
    使用 `apt` 和 `dpkg` 命令来管理软件包。另一方面，CentOS 和 Red Hat 等发行版使用 **RPM 软件包** 及 `dnf` 命令来管理它们。还有其他的发行版和软件包格式，但在本书中，我们将主要讨论
    Ubuntu 中的内容。首先，让我们讨论一下 Debian 软件包。
- en: Debian packages
  id: totrans-25
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Debian 软件包
- en: '**Debian packages** have been the main type of package in Ubuntu for the entire
    existence of the distribution so far. When you search online for how to install
    something in Ubuntu, chances are, you’re going to be installing a Debian package.
    These packages are known as Debian packages because Ubuntu is built from Debian
    sources and utilizes the same commands in order to install these packages. So
    even though Ubuntu is not Debian (Debian is a completely different distribution),
    they both use the same package format primarily.'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: '**Debian 软件包**一直是 Ubuntu 中的主要软件包类型，至今为止 Ubuntu 的整个版本都在使用这种类型。当你在线搜索如何在 Ubuntu
    中安装某个软件时，通常你会安装一个 Debian 软件包。这些软件包之所以被称为 Debian 软件包，是因为 Ubuntu 是基于 Debian 源构建的，并且使用相同的命令来安装这些软件包。所以，尽管
    Ubuntu 不是 Debian（Debian 是一个完全不同的发行版），它们主要使用相同的软件包格式。'
- en: The naming may be confusing for newcomers, because if Ubuntu is considered a
    different distribution than Debian, then why refer to its packages as “Debian”
    packages? Debian packages have a filename that ends in `.deb`, and this package
    format originated in Debian. Ubuntu didn’t develop its own package type; it uses
    the same package format as Debian. Therefore, whether we are installing packages
    in Debian or Ubuntu using a command such as `apt`, Debian packages are the type
    of packages used for both.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 对于新手来说，命名可能会让人感到困惑，因为如果 Ubuntu 被认为是一个与 Debian 不同的发行版，那为什么要把它的软件包称为“Debian”软件包呢？Debian
    软件包的文件名以 `.deb` 结尾，这种软件包格式起源于 Debian。Ubuntu 并没有开发自己的软件包类型；它使用与 Debian 相同的软件包格式。因此，无论我们是在
    Debian 还是 Ubuntu 中安装软件包，使用像 `apt` 这样的命令时，Debian 软件包都是两者使用的软件包类型。
- en: If you’ve worked with Ubuntu before reading this book, then chances are, you’ve
    already used the `apt` series of commands to carry out some package management.
    Debian packages are great because when paired with the `apt` command, they are
    easy to use and handle dependency resolution for you. However, they present some
    challenges and major drawbacks.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在阅读本书之前已经使用过 Ubuntu，那么很可能你已经使用过 `apt` 系列命令来进行包管理。Debian 包非常适合与 `apt` 命令配合使用，因为它们易于操作，并且能够帮助你处理依赖关系的解析。然而，它们也带来了一些挑战和重大缺点。
- en: First, the majority of the distribution is made up of Debian packages. This
    means that the Linux kernel, system packages, libraries, and security updates
    are all Debian packages that are installed when you install Ubuntu Server. When
    you install security updates, Debian packages are installed. The reason this may
    be a problem is that other software you’ll be installing, such as Apache, MariaDB,
    and so on, are also Debian packages, and may conflict with system packages when
    one package requires a pre-requisite package that conflicts with another.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，发行版的大部分内容由 Debian 包组成。这意味着 Linux 内核、系统包、库和安全更新都是在你安装 Ubuntu Server 时安装的 Debian
    包。当你安装安全更新时，实际上是安装了 Debian 包。这个问题的原因在于，你将要安装的其他软件（例如 Apache、MariaDB 等）也是 Debian
    包，这可能与系统包发生冲突，尤其是当一个包需要一个与另一个包冲突的前置包时。
- en: This can lead to a situation where you can’t install packages at all. Package
    maintainers are generally good at avoiding this scenario, so conflicts aren’t
    incredibly common nowadays.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 这可能会导致无法安装任何软件包的情况。软件包维护者通常能够避免这种情况，因此如今冲突并不常见。
- en: However, with Debian packages, if a system library gets corrupted, literally
    every piece of software that depends on it will fail. Ubuntu developers pay a
    great deal of attention to this, so you shouldn’t run into issues. But the truth
    is, this is a lot of work for the maintainers of Ubuntu to deal with.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，使用 Debian 包时，如果系统库遭到损坏，实际上所有依赖于它的软件都会出现故障。Ubuntu 开发者对此非常关注，因此你通常不会遇到问题。但事实上，这对于
    Ubuntu 的维护者来说是一项巨大的工作。
- en: Another concern with Debian packages is software availability. When a new major
    version of a package is released, it generally will not be offered to you until
    the next release of the distribution. This means that if you want a version of
    PHP, Apache, or some other piece of software that’s newer than what your current
    release of Ubuntu features, you generally will not have it offered to you. Instead,
    you typically wait until the next release of the entire distribution. There are
    some exceptions to this, such as Firefox in the desktop version of Ubuntu. As
    mentioned before, new major package versions are exceptions to the rule and come
    from the SRU approval process. While having tried-and-true software available
    that has been extensively tested offers better stability, sometimes you may require
    a newer version of particular software than what is available, which may lead
    you to consider alternative sources. After all, you don’t have to install a new
    version of Windows or macOS just to install newer applications!
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个与 Debian 包相关的问题是软件的可用性。当一个包的新主版本发布时，通常不会在下一次发行版发布之前提供给你。这意味着，如果你需要比当前 Ubuntu
    版本中提供的更新版本的 PHP、Apache 或其他软件，通常是无法获得的。你通常需要等待下一次整个发行版的更新发布。有些例外情况，例如桌面版本的 Ubuntu
    中的 Firefox。正如之前所提到的，新的主要包版本是规则的例外，来自 SRU 审批过程。虽然可用经过广泛测试的成熟软件能够提供更好的稳定性，但有时你可能需要比现有版本更新的软件，这可能会促使你考虑其他来源。毕竟，你不需要为了安装更新的应用程序而重新安装新版的
    Windows 或 macOS！
- en: '**Universal packages** are a new concept for Linux and are intended to be a
    single package format that multiple distributions recognize. The idea is that
    a developer only has to compile one package (instead of a separate package for
    each distribution) and users would only need to download a single package regardless
    of their chosen Linux flavor. The next section will discuss a type of universal
    package called Snaps.'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: '**通用包**是 Linux 的一个新概念，旨在提供一种多种发行版都能识别的单一包格式。其理念是开发者只需要编译一个包（而不是为每个发行版编译独立的包），用户则只需下载一个包，而无需考虑其选择的
    Linux 发行版。下一节将讨论一种名为 Snaps 的通用包类型。'
- en: Snap packages
  id: totrans-34
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Snap 包
- en: As it stands today, developers would need to create multiple package types to
    support Linux. Perhaps they’ll create Debian packages for Debian itself and Ubuntu,
    and then RPM packages for CentOS, Red Hat Enterprise Linux, and SuSE. And while
    you may think that having to create two package types isn’t all that bad, consider
    that each of the RPM-based distributions needs its own specific RPM package, and
    you can see how it might be tedious to a developer to have to create five or more
    different packages for any one release of their software.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 当前，开发者需要创建多种包类型来支持 Linux。也许他们会为 Debian 本身和 Ubuntu 创建 Debian 包，然后为 CentOS、Red
    Hat Enterprise Linux 和 SuSE 创建 RPM 包。虽然你可能认为需要创建两种包类型并不算太糟糕，但考虑到每个基于 RPM 的发行版需要其特定的
    RPM 包，你就能理解开发者每次发布软件时，需要创建五个或更多不同包的情况会是多么繁琐。
- en: As a result of this, there’s a push to adopt a single package format that each
    distribution can install that is independent of the system package type. This
    concept is known as **universal packages**, and the idea is to have a standard
    package type that can be installed on any Linux distribution. As a result, developers
    would only have to create one package to have their application work on all the
    popular distros.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，推动采用一种单一的包格式，每个发行版都可以安装，并且这种格式与系统包类型无关。这个概念被称为 **通用包**，其目的是拥有一个标准的包格式，可以在任何
    Linux 发行版上安装。因此，开发者只需要创建一个包，就能让他们的应用程序在所有流行的发行版上运行。
- en: The Linux community commonly uses the word *distro* as a contraction of the
    term *distribution*.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: Linux 社区通常使用 *distro* 这个词作为 *distribution*（发行版）的缩写。
- en: Another benefit of universal packages is that they have all of their dependencies
    built in, so conflicts are less likely to occur; everything the application needs
    would be contained in one single package. This is great because the likelihood
    of you running into package conflicts with universal packages is next to non-existent.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 通用包的另一个好处是，它们内置了所有依赖项，因此冲突发生的可能性较小；应用程序所需的一切都包含在一个单独的包中。这非常好，因为使用通用包时，发生包冲突的可能性几乎是不存在的。
- en: As with all things in the IT industry, we can’t collectively be satisfied and
    decide on the proper technology. As such, there is debate among the community
    regarding which one of the multiple types of universal packages is the most suitable.
    I won’t get into the political debates in this book, as each has its strengths
    and weaknesses. But even easier for us in regards to Ubuntu Server, only one of
    them is ideal for server installations anyway. The competing technologies for
    universal packages include Flatpak, AppImage, and Snap packages.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 就像 IT 行业中的一切一样，我们无法集体满足并决定哪种技术是最合适的。因此，社区中对于多种类型的通用包哪一种最合适存在争论。我在本书中不会深入政治性讨论，因为每种技术都有其优缺点。但对于我们来说，尤其是关于
    Ubuntu Server，实际上只有一种适合服务器安装的技术。用于通用包的竞争技术包括 Flatpak、AppImage 和 Snap 包。
- en: Canonical, the makers of Ubuntu, understand the pain points that developers
    and users experience, and have been making a great effort to change how packages
    are managed. The type of universal package they’ve developed to address these
    concerns is known as the **Snap package**. Like all universal packages, Snap packages
    (or more simply, *Snaps*) have no impact on the underlying Debian packages at
    all and are completely independent, thus removing the possibility of conflicts
    with your system packages. This allows you to have a newer version of an application
    installed than what would otherwise be made available. Since Snaps are installed
    separately and independently from the underlying Debian packages, there’s no reason
    to withhold them. Snap packages are better in just about every way and are a great
    concept. The only downside might be that they are larger packages, since they
    include not only the application itself but also all the libraries they require
    in one single package. However, they’re really not that large and shouldn’t cause
    an issue with disk space. These packages are no bigger than a typical application
    on macOS or Windows.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: Ubuntu 的开发商 Canonical 理解开发人员和用户在使用过程中遇到的痛点，并且一直在努力改变包管理的方式。为了解决这些问题，他们开发的通用包类型被称为
    **Snap 包**。像所有通用包一样，Snap 包（或更简洁地称为 *Snaps*）对底层的 Debian 包没有任何影响，且是完全独立的，从而避免了与系统包发生冲突的可能性。这使得你可以安装比原本可用版本更新的应用版本。由于
    Snaps 是与底层 Debian 包独立安装的，因此没有理由不安装它们。Snap 包在各方面都表现得更好，是一个很棒的概念。唯一的缺点可能是它们是较大的包，因为它们不仅包括应用程序本身，还将所有必需的库包含在一个单独的包中。然而，它们其实并没有那么大，不会导致磁盘空间问题。这些包的大小与
    macOS 或 Windows 上的典型应用程序差不多。
- en: So, which should you choose? It really just depends on your use case. Each of
    the universal package types is good at some things but has downsides. Flatpaks
    and AppImages are also great technologies, but where they fall behind for our
    use case is that they don’t support server (non-**Graphical User Interface**,
    or non-**GUI**) applications as well. This means that these package types are
    best for installing applications you’d normally find on a desktop Ubuntu installation,
    such as music players, browsers, graphical text editors, and so on. Snap packages
    target *both* GUI and non-GUI apps. Since server installations normally don’t
    contain a GUI at all, this makes our choice for us. It could be the case that
    Flatpaks and AppImages start supporting non-GUI apps better in the future, but
    for now, the choice of universal package format is simple.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，应该选择哪一个呢？其实这取决于你的使用场景。每种通用包类型在某些方面都表现得很好，但也有其缺点。Flatpaks 和 AppImages 也是很好的技术，但对于我们的使用场景，它们的短板在于不太支持服务器（非**图形用户界面**，即非**GUI**）应用程序。这意味着，这些包类型最适合安装你通常会在桌面版
    Ubuntu 上找到的应用程序，例如音乐播放器、浏览器、图形化文本编辑器等等。Snap 包则支持*图形用户界面*和非图形用户界面应用。由于服务器安装通常根本没有图形用户界面，这就决定了我们的选择。或许未来
    Flatpaks 和 AppImages 会更好地支持非 GUI 应用，但目前，选择通用包格式的问题非常简单。
- en: As it stands today, though, the majority of the packages we’ll be installing
    are going to be Debian packages, as Snap packages are a bit slow to catch on.
    They’re making steady progress, but it remains to be seen how well the industry
    will embrace them. For now, it’s probably best to evaluate Snap packages when
    they’re available and to choose the most appropriate package type based on availability,
    security, version, and support.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，现阶段，我们安装的大多数软件包将是 Debian 包，因为 Snap 包的普及有些缓慢。它们在稳步进展，但行业如何接受它们还需观察。目前，最好是在
    Snap 包可用时进行评估，并根据可用性、安全性、版本和支持情况选择最合适的包类型。
- en: With the differences between Snaps and Debian packages out of the way, let’s
    work through some examples of how to actually manage the software on our server.
    We’ll look at commands to search for available packages, and then we’ll install
    them and remove them.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 在了解了 Snaps 和 Debian 包之间的区别后，让我们通过一些例子来实际管理我们服务器上的软件。我们将查看搜索可用软件包的命令，然后我们将安装和卸载它们。
- en: Installing and removing software
  id: totrans-44
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 安装和卸载软件
- en: Before we begin, we will want to research a bit regarding the application we
    want to install. In Ubuntu, there are multiple ways of installing software, so
    the best way to find out how to get started is by simply checking the documentation
    on the website for the application we want to install. Typically, a Google search
    will do (just make sure you check the domain and are on the correct site). Most
    software will have installation instructions for various platforms, including
    Ubuntu. Most of the time, it will just tell you to download the Debian package
    format via the `apt install` command. Other times, the software may have a Snap
    available, or even a PPA repository (we’ll discuss PPA repositories later on in
    this chapter). Let’s start our package management journey by taking a look at
    the `apt` commands that are used to install Debian packages.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始之前，我们需要对想要安装的应用程序进行一些研究。在Ubuntu中，安装软件有多种方法，所以最好的方法是通过访问我们想要安装的应用程序的官方网站来查看文档。通常，Google搜索就能找到（只要确保检查域名并访问正确的网站）。大多数软件会提供适用于各种平台的安装说明，包括Ubuntu。通常，它会告诉你通过`apt
    install`命令下载Debian软件包格式。其他时候，软件可能会提供Snap格式，甚至是PPA仓库（我们将在本章后面讨论PPA仓库）。让我们通过查看用于安装Debian软件包的`apt`命令，来开始我们的包管理之旅。
- en: Managing Debian packages with apt
  id: totrans-46
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用apt管理Debian软件包
- en: '**APT**, or **Advanced Package Tool**, is a suite of tools that allows us to
    install, remove, and update Debian packages. There are various sub-commands that
    make up this suite, which we’ll go over now. The most popular variation of the
    `apt` command is `apt install`. If you’ve ever read instructions for how to do
    something in Ubuntu, chances are you’ve already run that command to install a
    package. And that’s exactly what it does: it allows you to install packages for
    Ubuntu over the command line. For example, the following command will install
    the `openssh-server` package:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: '**APT**，即**高级包管理工具**，是一套允许我们安装、删除和更新Debian软件包的工具。这个工具套件由多个子命令组成，接下来我们将逐一介绍。`apt`命令中最常用的变体是`apt
    install`。如果你曾经阅读过在Ubuntu上执行某些操作的说明，可能已经运行过这个命令来安装软件包。这正是它的功能：通过命令行安装Ubuntu的软件包。例如，以下命令将安装`openssh-server`软件包：'
- en: '[PRE0]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'You can also install multiple packages at a time by separating each with a
    space, instead of installing each package one at a time. The following example
    will install three different packages:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以通过用空格分隔每个软件包来一次性安装多个软件包，而不必一个个地安装。以下示例将安装三个不同的软件包：
- en: '[PRE1]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: In some books, blogs, and articles, you may see longer versions of `apt` commands,
    such as `apt-get install` instead of just `apt install`. Being able to shorten
    commands such as `apt-get install` to `apt install` is a relatively new feature
    of `apt` in Debian and Ubuntu. Both methods are perfectly valid, but simplifying
    APT commands down to just `apt` is preferred going forward.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 在一些书籍、博客和文章中，你可能会看到更长版本的`apt`命令，比如`apt-get install`，而不仅仅是`apt install`。能够将诸如`apt-get
    install`这样的命令简化为`apt install`是Debian和Ubuntu中`apt`的一个相对较新的特性。两种方法都是有效的，但未来推荐使用简化后的`apt`命令。
- en: So, what actually happens when you install a package with `apt`? If you’ve run
    through the process before, you’re probably accustomed to it already. But, typically,
    the process begins with `apt` calculating dependencies. The majority of packages
    require other packages to function, so `apt` will check to ensure that the package
    you’re requesting is available and that its dependencies are available as well.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，当你使用`apt`安装软件包时，究竟发生了什么？如果你之前已经执行过这个过程，你可能已经习惯了。但通常情况下，这个过程从`apt`计算依赖开始。大多数软件包需要其他软件包才能正常工作，因此`apt`会检查确保你请求的软件包以及它的依赖项都可用。
- en: 'First, you’ll see a summary of the changes that `apt` wants to make to your
    server. In the case of installing the `apache2` package on an unconfigured Ubuntu
    Server, I enter the following command:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，你会看到`apt`希望对你的服务器进行的更改的总结。以在未配置的Ubuntu服务器上安装`apache2`软件包为例，我输入以下命令：
- en: '[PRE2]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'I see the following output on my system when it starts to install:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 当它开始安装时，我在系统上看到以下输出：
- en: '![](img/B18425_03_01.png)'
  id: totrans-56
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B18425_03_01.png)'
- en: 'Figure 3.1: Installing Apache on an example server'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.1：在示例服务器上安装Apache
- en: Even though I only asked for `apache2`, `apt` informs me that it also needs
    to install `apache2-bin`, `apache2-data`, `apache2-utils`, and `libapr1` (and
    others) in order to satisfy the dependencies for the `apache2` package. `apt`
    also suggests that I install `apache2-doc`, `apache2-suexec-pristine`, and a few
    others, though they are optional and are not required. You can install the suggested
    packages by adding the `--install-suggests` option to the `apt install` command,
    but that isn’t always a good idea as it may install a large number of packages
    that you may not need. You can, of course, cherry-pick the suggested packages
    individually by using the `apt` command to install any one or more of them manually.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 即使我只要求安装`apache2`，`apt`仍然会通知我，它还需要安装`apache2-bin`、`apache2-data`、`apache2-utils`和`libapr1`（以及其他一些软件包），以满足`apache2`软件包的依赖。`apt`还建议我安装`apache2-doc`、`apache2-suexec-pristine`以及其他一些软件包，尽管它们是可选的，并不必要。你可以通过在`apt
    install`命令中添加`--install-suggests`选项来安装这些建议的软件包，但这并不总是一个好主意，因为它可能会安装许多你不需要的软件包。当然，你也可以通过使用`apt`命令单独选择性安装某些建议的软件包。
- en: Most of the time, though, you probably won’t want to do this; it’s usually better
    to keep your installed packages to a lean minimum and install only the packages
    you need. As we’ll discuss in *Chapter 21*, *Securing Your Server*, the fewer
    packages you install, the smaller the attack surface of your server.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，大多数时候，你可能不想这样做；通常，最好将已安装的软件包保持在最小范围，只安装你需要的软件包。正如我们在*第21章*《保护你的服务器》中将讨论的那样，安装的软件包越少，服务器的攻击面就越小。
- en: 'While installing or updating packages via `apt`, you might see a message come
    up that asks you whether or not you’re comfortable with having background services
    restarted as part of the process:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 在通过`apt`安装或更新软件包时，你可能会看到一个消息，询问你是否愿意在过程中重启后台服务：
- en: '![](img/B18425_03_02.png)'
  id: totrans-61
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B18425_03_02.png)'
- en: 'Figure 3.2: Service restart prompt during package installation/upgrade'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.2：软件包安装/升级过程中的服务重启提示
- en: We’ll cover concepts around process management in *Chapter 7*, *Controlling
    and Managing Processes*, so it’s not something you should focus on right now.
    For a quick description in order to hold you over until then, there’s services
    running in the background on all Linux servers, and each one provides a particular
    function. Restarting a service will ensure it restarts with all the latest patches
    and tweaks applied, but any user connected to one of the services you restart
    will get disconnected. For now, you can simply press Enter to accept the defaults
    anytime you see this message.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在*第7章*《控制和管理进程》中讨论进程管理相关的概念，所以现在不必太关注这个问题。为了让你暂时了解一下，所有Linux服务器上都在后台运行服务，每个服务提供特定的功能。重启服务将确保它以最新的补丁和调整重新启动，但任何连接到你重启的服务的用户都会被断开。现在，你可以在看到这个消息时随时按回车接受默认设置。
- en: Another option that is common with installing packages via `apt` is the `-y`
    option, which assumes *yes* to the confirmation prompt where you choose if you
    want to continue or not. For example, my previous output included the line `Do
    you want to continue? [Y/n]`. If we had used `-y`, the command would have proceeded
    to install the package without any confirmation. This can be useful for administrators
    in a hurry, though I personally don’t see the need for this unless you are scripting
    your package installations. In fact, it can sometimes be a bad idea, because by
    assuming *yes*, you may be confirming something you’d later regret.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个常见的通过`apt`安装软件包时的选项是`-y`选项，它假定你选择*是*，自动跳过确认提示，询问你是否继续。例如，我之前的输出中包括了`Do you
    want to continue? [Y/n]`这一行。如果使用了`-y`选项，命令将会在没有任何确认的情况下继续安装软件包。这对于急于操作的管理员来说可能很有用，尽管我个人认为除非你在脚本中进行软件包安装，否则没有必要使用这个选项。事实上，有时它可能是一个不好的主意，因为假定*是*可能意味着你确认了一些你之后会后悔的操作。
- en: Another neat default in Ubuntu Server is that it automatically configures most
    packages to make their daemons start up and also be enabled so that they start
    with each boot. Using the earlier example of `apache2`, the `apache2` service
    will start and the application will automatically start running as soon as you
    install the package.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: Ubuntu Server的另一个巧妙的默认设置是，它会自动配置大多数软件包，使其守护进程启动并启用，以便在每次启动时自动启动。以之前提到的`apache2`为例，一旦你安装了该软件包，`apache2`服务将启动，应用程序也会自动运行。
- en: This may seem like a good idea for the sake of convenience, but not everyone
    prefers this automation. As I’ve mentioned, the more packages installed on your
    server, the higher the attack surface, but running services (also known as daemons,
    or units) are each a method of entry for miscreants should there be a security
    vulnerability. Therefore, some distributions don’t enable and start daemons automatically
    when you install packages. The way I see it, though, you should only install packages
    you actually intend to use, so it stands to reason that if you go through the
    trouble of manually installing a package such as `apache2`, you probably want
    to start using it.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 为了方便起见，这可能看起来是个不错的主意，但并非每个人都偏好这种自动化。如我所提到的，服务器上安装的包越多，攻击面就越大，而正在运行的服务（也称为守护进程或单元）每个都可能成为恶意分子入侵的途径，前提是存在安全漏洞。因此，一些发行版在安装包时不会自动启用和启动守护进程。然而，我个人认为，你只应安装那些你打算实际使用的包，因此，如果你特意去安装像`apache2`这样的包，那你大概率是希望开始使用它的。
- en: 'When you install a package with the `apt` command, it searches its local database
    for the package you named. If it doesn’t find it, it will throw an error. Sometimes,
    this error may be because the package isn’t available or perhaps the version that
    `apt` wants to install no longer exists. Ubuntu’s repositories move very quickly;
    new versions of packages are added almost daily. When a new version of a package
    is added, its older equivalent may be removed. For this reason, it’s recommended
    that you update your package sources from time to time. Doing so is easy, using
    the following command:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 当你使用`apt`命令安装包时，它会在本地数据库中查找你指定的包。如果没有找到，它会抛出一个错误。有时，这个错误可能是因为该包不可用，或者`apt`希望安装的版本已经不存在。Ubuntu的仓库更新速度非常快；新版本的包几乎每天都会被添加。当一个包的新版本被添加时，它的旧版本可能会被删除。因此，建议你定期更新包源。这样做很简单，只需要使用以下命令：
- en: '[PRE3]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: This command doesn’t actually update any packages; it merely checks in with
    your local mirror to see if any packages have been added or removed and updates
    your local index. This command is useful because installations of packages can
    fail if your sources aren’t up to date. In most cases, the symptom will be that
    `apt` errors out of the process when it can’t find a package it’s looking for,
    something that would’ve been available normally.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 这个命令实际上并不会更新任何包；它仅仅是与本地镜像进行对接，查看是否有新的包被添加或移除，并更新本地索引。这个命令很有用，因为如果源不更新，包的安装可能会失败。在大多数情况下，症状表现为当`apt`在查找某个包时无法找到时，进程会报错，而这个包通常是正常情况下可用的。
- en: 'Removing packages is also very easy and follows a very similar syntax; you
    would only need to replace the `install` keyword with `remove`:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 移除包也非常简单，语法与安装包非常相似；你只需要将`install`关键字替换为`remove`即可：
- en: '[PRE4]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'And, just like with the `install` option, you can remove multiple packages
    at the same time. The following example will remove three packages:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 就像使用`install`选项一样，你也可以同时移除多个包。以下示例将移除三个包：
- en: '[PRE5]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'If you’d like to not only remove a package but also wipe out its configuration,
    you can use the `--purge` option:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你不仅想移除一个包，还希望删除它的配置文件，你可以使用`--purge`选项：
- en: '[PRE6]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: This will not only remove the package but wipe out its configuration directory
    (applications typically store their configuration files in a sub-directory of
    `/etc`).
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 这不仅会移除包，还会删除它的配置目录（应用程序通常会将它们的配置文件存储在`/etc`的子目录中）。
- en: So, that concludes the basics of managing Debian packages with `apt`. Now, let’s
    move on to managing Snaps.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，这就总结了使用`apt`管理Debian包的基础知识。现在，让我们继续学习如何管理Snap包。
- en: Managing Snap packages with snap
  id: totrans-78
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用snap管理Snap包
- en: To manage Snap packages, we use the `snap` command. The `snap` command features
    several options we can use to search for, install, and remove Snap packages from
    our server or workstation.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 要管理Snap包，我们使用`snap`命令。`snap`命令有几个选项，允许我们搜索、安装和移除服务器或工作站上的Snap包。
- en: 'To begin, we can use the `snap find` command along with a keyword to display
    a list of Snap packages available to us that match that keyword:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们可以使用`snap find`命令配合关键字来显示与该关键字匹配的可用Snap包列表：
- en: '[PRE7]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Basically, you just simply type the `snap find` command along with a search
    term to look for. One example could be the `nmap` application, which is a useful
    tool to have if we’re managing a network:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 基本上，你只需要简单地输入`snap find`命令并加上搜索词来查找。例如，`nmap`应用程序就是一个很有用的工具，尤其是当我们在管理网络时：
- en: '[PRE8]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'In the case of `nmap`, this utility is available in Ubuntu’s default repositories,
    so you don’t need to use the Snap package to install it. Typically, though, the
    Snap version will be newer and have more features than what is available in the
    APT repositories. If we wish to install the Snap version, we can use the following
    command to do so:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 对于`nmap`，该工具在 Ubuntu 的默认仓库中可用，因此你无需使用 Snap 包进行安装。然而，通常 Snap 版本会比 APT 仓库中提供的版本更新，并且具有更多功能。如果我们希望安装
    Snap 版本，可以使用以下命令：
- en: '[PRE9]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: With the `install` option, we need to use `sudo` since the act of installing
    a package makes changes on the server. For a simple `find`, we can omit `sudo`.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`install`选项时，我们需要使用`sudo`，因为安装包的操作会对服务器进行更改。而对于简单的`find`命令，则可以省略`sudo`。
- en: 'Now that we have `nmap` installed, we can check the location of the `nmap`
    binary with the `which` command. We can use the `which` command to find the location
    of the binary file for commands that are available—it will show the path to the
    binary if the appropriate package is installed. If the command is not available,
    the `which` command will show no output. So, if we run the following command,
    we should now see the path of that binary printed to the screen:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已安装了`nmap`，可以使用`which`命令检查`nmap`二进制文件的位置。我们可以使用`which`命令查找命令的二进制文件位置——如果安装了相应的包，它将显示二进制文件的路径。如果命令不可用，`which`命令将没有输出。因此，如果我们运行以下命令，我们现在应该能看到该二进制文件的路径打印到屏幕上：
- en: '[PRE10]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'This will return the following output, showing that the Snap version of `nmap`
    is run from a special place:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 这将返回以下输出，显示`nmap`的 Snap 版本是从一个特殊位置运行的：
- en: '![](img/B18425_03_03.png)'
  id: totrans-90
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B18425_03_03.png)'
- en: 'Figure 3.3: Checking the location of the nmap binary'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.3：检查 nmap 二进制文件的位置
- en: Now, when we run `nmap`, we’re actually running it from `/snap/bin/nmap`. If
    we were to install `nmap` via `apt`, it would run from `/usr/bin/nmap` instead.
    If we also have the `nmap` utility installed from Ubuntu’s APT repositories, then
    we can run either one at any time by calling out the full path to the binary we
    want to run, since Snap packages are independent of the APT packages. For example,
    if we had `nmap` installed via both `snap` and `apt`, we could run Ubuntu’s version
    by running `/usr/bin/nmap` and the Snap version by running `/snap/bin/nmap`.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，当我们运行`nmap`时，实际上是从`/snap/bin/nmap`运行的。如果我们通过`apt`安装`nmap`，它将从`/usr/bin/nmap`运行。如果我们还从
    Ubuntu 的 APT 仓库安装了`nmap`工具，那么我们可以随时通过指定要运行的二进制文件的完整路径来运行任意一个，因为 Snap 包与 APT 包是独立的。例如，如果我们通过`snap`和`apt`都安装了`nmap`，我们可以通过运行`/usr/bin/nmap`来运行
    Ubuntu 的版本，通过运行`/snap/bin/nmap`来运行 Snap 版本。
- en: 'Removing an installed Snap package is easy. We simply use the `remove` option:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 移除已安装的 Snap 包很容易。我们只需使用`remove`选项：
- en: '[PRE11]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: If we issue that command, then `nmap` (or whichever Snap package we designate)
    is removed from the system.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们执行该命令，那么`nmap`（或我们指定的任何 Snap 包）将从系统中移除。
- en: 'To update a package, we use the `refresh` option along with the name of a package
    to update:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 要更新一个包，我们使用`refresh`选项，并指定要更新的包名：
- en: '[PRE12]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'With that command, the package will be updated to the newest version available.
    Going even further, we can attempt to update every Snap on our server with the
    same command (without specifying a package):'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 使用该命令，包将更新到最新版本。如果进一步操作，我们还可以尝试使用相同的命令更新服务器上的所有 Snap 包（无需指定包名）：
- en: '[PRE13]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: As you can see, managing Snap packages is fairly straightforward. Using the
    `snap` suite of commands, we can install, update, or remove packages from our
    server or workstation. The `snap find` command allows us to find new Snap packages
    to install. Perhaps as the technology matures, we may find ourselves installing
    more Snap packages than Debian packages, but that remains to be seen. For now,
    it’s a nice benefit to have two options to consider when installing new software.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，管理 Snap 包相当简单。使用`snap`命令套件，我们可以从服务器或工作站安装、更新或移除包。`snap find`命令允许我们查找新的
    Snap 包以供安装。也许随着技术的发展，我们将会比安装 Debian 包更多地安装 Snap 包，但这仍有待观察。现在，有两个安装新软件的选择是一个不错的优势。
- en: In addition to being able to install packages, there are some additional tips
    and considerations around searching for packages. After all, you can’t install
    a package if you don’t know what’s available. We’ll explore searching for packages
    in the next section.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 除了能够安装包之外，还有一些额外的技巧和注意事项，帮助我们搜索包。毕竟，如果你不知道有哪些包可用，你是无法安装的。我们将在下一节探讨如何搜索包。
- en: Searching for packages
  id: totrans-102
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 搜索包
- en: Unfortunately, the naming conventions used for packages in Ubuntu Server aren’t
    always obvious. Worse, package names are often very different from one distribution
    to another even for the same piece of software. While this book and other tutorials
    online will outline the exact steps needed to install software, if you’re ever
    on your own, it really doesn’t help much if you don’t know the name of the package
    you want to install. In this section, I’ll try to take some of the mystery out
    of searching for packages.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，Ubuntu Server 中软件包的命名约定并不总是显而易见。更糟糕的是，即使是同一软件，不同的发行版中的软件包名称也往往大相径庭。尽管本书和其他在线教程会列出安装软件的确切步骤，但如果你独立操作，而不知道要安装的软件包的名称，那就没什么帮助了。在本节中，我将尽量揭开搜索软件包的神秘面纱。
- en: 'In the previous section, we went over searching for Snap packages, so I won’t
    repeat that here. The APT suite of utilities also has a means of searching for
    packages as well, which is the `apt search` command. We can use the following
    command to search for packages, by providing a keyword:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一节中，我们已经讲解了如何搜索 Snap 软件包，所以这里就不再重复了。APT 工具套件也提供了搜索软件包的功能，使用的命令是`apt search`。我们可以使用以下命令，通过提供关键字来搜索软件包：
- en: '[PRE14]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'The output from this command will show a list of packages that match your search
    criteria, with their names and descriptions. If, for example, you wanted to install
    the PHP plugin for Apache and you didn’t already know the name of the associated
    package, the following would narrow it down:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 该命令的输出将显示与搜索条件匹配的软件包列表，包括它们的名称和描述。例如，如果你想安装 Apache 的 PHP 插件，但还不知道关联的包名，以下命令可以帮助你缩小范围：
- en: '[PRE15]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: In the output, we will get a list of more than a handful of packages, but we
    can deduce from the package descriptions in the output that `libapache2-mod-php`
    is most likely the one we want. We can proceed to install it using `apt`, as we
    would normally do.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 在输出中，我们会看到一个不止一项的软件包列表，但我们可以从输出中的软件包描述中推测出`libapache2-mod-php`很可能是我们需要的那个。然后，我们可以像平常一样使用`apt`安装它。
- en: 'If we’re not sure whether or not this is truly the package we want, we can
    view more information regarding this (or any other) package with the `apt-cache
    show` command:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们不确定这是否是我们想要的真正软件包，我们可以使用`apt-cache show`命令查看关于这个（或任何其他）软件包的更多信息：
- en: '[PRE16]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'The output of this command is illustrated in the following screenshot:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 该命令的输出在以下截图中进行了展示：
- en: '![](img/B18425_03_04.png)'
  id: totrans-112
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B18425_03_04.png)'
- en: 'Figure 3.4: Showing the info of a Debian package'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.4：展示 Debian 软件包的信息
- en: With this command, we can see additional details regarding the package we’re
    considering installing. In this case, we learn that the `libapache2-mod-php` package
    also depends on PHP itself, so that means if we install this package, we’ll get
    the PHP plugin as well as PHP itself.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这个命令，我们可以看到关于我们考虑安装的软件包的更多细节。在这个例子中，我们了解到`libapache2-mod-php`软件包还依赖于 PHP 本身，这意味着如果我们安装这个软件包，我们不仅会得到
    PHP 插件，还会安装 PHP 本身。
- en: Another method of searching for a package (if you have a web browser available)
    is to connect to the *Ubuntu Packages Search* page at [https://packages.ubuntu.com/](https://packages.ubuntu.com/),
    where you can navigate through the packages from their database for any currently
    supported version of Ubuntu. You won’t always have access to a web browser while
    working on your servers, but, when you do, this is a very useful way to search
    through packages, view their dependencies, descriptions, and more.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种搜索软件包的方法（如果你有可用的网页浏览器）是访问*Ubuntu 软件包搜索*页面：[https://packages.ubuntu.com/](https://packages.ubuntu.com/)，你可以通过该页面在其数据库中浏览当前支持版本的
    Ubuntu 所有的软件包。虽然在工作中你不总是能访问网页浏览器，但当你能够使用时，这是一个非常有用的方式来搜索软件包、查看它们的依赖关系、描述等信息。
- en: Using the `apt search` command, as well as the `snap find` command, should get
    you quite far in the process of determining the name of the packages you want
    to install. Package management skills come over time, so don’t expect to automatically
    know which packages to install right away. When in doubt, just perform a Google
    search, research the documentation of the software you want to run, and learn
    how to install it in Ubuntu. Typically, the instructions will lead you to the
    correct commands to use. The examples we’ll go over during the course of this
    book will guide you through the most common use cases for Ubuntu Server.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `apt search` 命令以及 `snap find` 命令，应该能帮助你在确定要安装的包名时走得更远。软件包管理技能需要随着时间积累，因此不要指望立即就能知道应该安装哪些包。如果有疑问，只需进行
    Google 搜索，研究你要运行的软件的文档，学习如何在 Ubuntu 上安装它。通常，安装说明会引导你使用正确的命令。本书中我们将讲解的示例，将引导你完成
    Ubuntu Server 最常见的使用案例。
- en: At this point, we should have a solid understanding of the different types of
    packages available and how to manage them. However, it’s sometimes the case that
    we need to run software on our server for which there is no package available
    within the standard repositories. Therefore, in the next section, we’ll learn
    how to add additional repositories from which to install software.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一点上，我们应该已经对不同类型的软件包及其管理方式有了清晰的理解。然而，有时我们需要在服务器上运行一些软件，而这些软件在标准仓库中没有可用的包。因此，在下一部分，我们将学习如何添加额外的仓库，从中安装软件。
- en: Managing package repositories
  id: totrans-118
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 管理软件包仓库
- en: Often, the repositories that come pre-installed with Ubuntu will suffice for
    the majority of the Debian packages you’ll install via APT. Every now and then,
    though, you may need to install an additional repository in order to take advantage
    of software not normally provided by Ubuntu, or versions of packages newer than
    what you would normally have available. Adding additional repositories allows
    you to subscribe to additional sources of software and install packages from them
    in the same way as you would from any other source.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，Ubuntu 自带的仓库已经足够满足大多数通过 APT 安装的 Debian 包。但偶尔，你可能需要安装一个额外的仓库，以便使用 Ubuntu 通常不提供的软件，或者是比你通常能获取到的软件包版本更新的版本。添加额外的仓库允许你订阅额外的软件源，并像从其他源一样安装软件包。
- en: Adding additional repositories should be considered a last resort, however.
    When you install an additional repository, you’re effectively trusting the author
    of that repository with your organization’s server. Although I haven’t ever seen
    this happen first-hand, it’s theoretically possible for authors of software to
    include back doors or malware in software packages (intentionally or unintentionally),
    and then make them available for others via a software repository. Therefore,
    you should only add repositories from sources that you have reason to trust.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，添加额外的仓库应当被视为最后的手段。当你安装额外的仓库时，实际上是在将你组织的服务器交给该仓库的作者信任。尽管我亲眼未曾见过这种情况，但理论上，软件作者可能会在软件包中加入后门或恶意软件（无论是有意还是无意的），并通过软件仓库提供给其他人。因此，你应该仅添加那些你有理由信任的来源的仓库。
- en: In addition, it sometimes happens that a maintainer of a repository simply gives
    up on it and disappears. This I have seen happen first-hand. In this situation,
    the repository may go offline (which would show errors during `apt` transactions,
    indicating that it’s not able to connect to the repository), or worse, the repository
    stays online, but security updates are never made available, causing your server
    to become vulnerable to attack. Sometimes, you just don’t have a way around it.
    You need a specific application and Ubuntu doesn’t offer it by default. Your only
    option may be to compile an application from source or add a repository. The decision
    is yours, but just keep security in mind whenever possible. When in doubt, avoid
    adding a repository unless it’s the only way to obtain what you’re looking for.
    If you do add an additional repository and you haven’t seen packages from it updated
    in a decent amount of time, consider that a red flag and investigate whether or
    not the repository is abandoned. Repositories that are abandoned should be removed,
    and an alternative used in its place.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，有时会发生仓库的维护者干脆放弃维护该仓库并消失。我亲眼见过这种情况。在这种情况下，仓库可能会下线（这会在`apt`事务中显示错误，表示无法连接到仓库），更糟糕的是，仓库保持在线，但从未提供安全更新，导致你的服务器易受到攻击。有时，你可能别无选择。你需要一个特定的应用程序，而Ubuntu默认并未提供。你唯一的选择可能是从源代码编译一个应用程序或添加一个仓库。这个决定由你做，但尽可能时要考虑安全问题。如果有疑虑，除非这是获取你所需内容的唯一方法，否则避免添加仓库。如果你添加了一个额外的仓库，且长时间没有看到来自该仓库的包更新，考虑这是一个红旗，调查该仓库是否已被弃用。已弃用的仓库应被移除，替换为其他可用仓库。
- en: Adding additional repositories
  id: totrans-122
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 添加额外的仓库
- en: Software repositories are essentially URLs in a text file, stored in one of
    two places. The main Ubuntu repository list is stored in `/etc/apt/sources.list`.
    Inside that file, you’ll find a multitude of repositories for Ubuntu’s package
    manager to pull packages from. In addition, files with an extension of `.list`
    are read from the `/etc/apt/sources.list.d/` directory and are also used whenever
    you use `apt`. I’ll demonstrate both methods.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 软件仓库本质上是一个存储在文本文件中的URL，存储在两个地方之一。主Ubuntu仓库列表存储在`/etc/apt/sources.list`中。在该文件中，你会找到多个仓库，供Ubuntu的包管理器拉取包。此外，扩展名为`.list`的文件会从`/etc/apt/sources.list.d/`目录中读取，并且在你使用`apt`时也会被使用。我将演示这两种方法。
- en: 'A typical repository line in either of these two files will look similar to
    the following:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个文件中的典型仓库行会类似于以下内容：
- en: '[PRE17]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: The first section of each line will be either `deb` or `deb-src`, which references
    whether the `apt` command will find binary packages (`deb`) or source packages
    (`deb-src`) there. Next, we have the actual URL that `apt` will use in order to
    reach the repository. In the third section, we have the codename of the release;
    in this case, it’s `jammy` (which refers to the codename for Ubuntu 22.04, `Jammy
    Jellyfish`).
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 每行的第一部分将是`deb`或`deb-src`，指示`apt`命令是否会在那里找到二进制包（`deb`）或源代码包（`deb-src`）。接下来是`apt`用来访问仓库的实际URL。在第三部分，我们有发行版的代号；在这个例子中，它是`jammy`（指的是Ubuntu
    22.04的代号，`Jammy Jellyfish`）。
- en: If you weren’t already aware, the codename for each Ubuntu release is based
    on an animal. Often, the animal chosen for a release will be rare. For example,
    the previous LTS release featured the fossa, which is an animal from Madagascar
    that somewhat resembles a cat but with curved ears. This time around, the chosen
    animal is the jellyfish, which I’m sure the majority of my readers are already
    familiar with.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你还不知道，每个Ubuntu发行版的代号都是基于一种动物。通常，所选的动物会比较稀有。例如，上一个LTS版本的代号是“fossa”，它是一种来自马达加斯加的动物，长得像猫，但耳朵是弯曲的。这次的代号是“jellyfish”，我相信大多数读者已经熟悉这种动物。
- en: Continuing, the fourth section of each repository line refers to the `Component`,
    which references whether or not the repository contains software that is free
    and open source, and is supported officially by Canonical (the company that oversees
    Ubuntu’s development). The component can be `main`, `restricted`, `universe`,
    or `multiverse`. Repositories with a `main` component include officially supported
    software. This generally means that the software packages have source code available,
    so Ubuntu developers are able to fix bugs. Software marked `restricted` is still
    supported but may have a questionable license. `universe` packages are supported
    by the community, not Canonical themselves. Finally, `multiverse` packages contain
    software that is neither free nor supported, which you would be using at your
    own risk.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，每个仓库行的第四部分是`Component`，它表示该仓库是否包含自由和开源的软件，并且是否得到Canonical（负责Ubuntu开发的公司）的官方支持。该组件可以是`main`、`restricted`、`universe`或`multiverse`。带有`main`组件的仓库包含官方支持的软件，这通常意味着这些软件包有源代码可用，因此Ubuntu开发者能够修复bug。标记为`restricted`的软件仍然得到支持，但可能存在有问题的许可。`universe`软件包由社区提供支持，而不是Canonical本身。最后，`multiverse`软件包包含既不自由也不受支持的软件，使用这些软件需要自行承担风险。
- en: As you can see from looking at the `/etc/apt/sources.list` file on your server,
    it’s possible for a repository line to feature software from more than one component.
    Each repository URL may include packages from several components, and the way
    you differentiate them is to only subscribe to the components you need for that
    repository. In our previous example, the repository line included both `main`
    and `restricted` components. This means that, for that particular example, the
    `apt` utility will index both free (`main`) and non-free (`restricted`) packages
    from that repository.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您从查看服务器上的`/etc/apt/sources.list`文件中看到的那样，一个仓库行可以包含来自多个组件的软件。每个仓库URL可能包含来自多个组件的软件包，而您区分它们的方法是只订阅该仓库所需的组件。在我们之前的示例中，仓库行同时包括`main`和`restricted`组件。这意味着，在这个特定示例中，`apt`工具将从该仓库索引自由（`main`）和非自由（`restricted`）软件包。
- en: You can add new repositories to the `/etc/apt/sources.list` file (and it will
    function just fine), but that’s not typically the preferred method. Instead, as
    I mentioned earlier, `apt` will scan the `/etc/apt/sources.list.d/` directory
    for text files ending with the `.list` extension. These text files are formatted
    the same as the `/etc/apt/sources.list` file in the sense that you include one
    additional repository per line, but this method allows you to add a new repository
    by simply creating a file for it, and you can remove the repository by simply
    deleting that file.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以将新的仓库添加到`/etc/apt/sources.list`文件中（它仍然可以正常工作），但这通常不是首选方法。正如我之前提到的，`apt`会扫描`/etc/apt/sources.list.d/`目录，查找以`.list`扩展名结尾的文本文件。这些文本文件的格式与`/etc/apt/sources.list`文件相同，即每行包含一个额外的仓库，但这种方法使您能够通过创建文件来轻松添加新仓库，也可以通过删除该文件来删除仓库。
- en: This is safer than editing the `/etc/apt/sources.list` file directly, since
    there’s always a chance you can make a typo and disrupt your ability to download
    packages from even the official repositories.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法比直接编辑`/etc/apt/sources.list`文件更安全，因为直接编辑时总有可能打错字，导致您无法从甚至官方仓库下载软件包。
- en: In addition, you may need to install a **GNU Privacy Guard** (**GnuPG**) key
    for a new repository, but this process differs from one application to another.
    Typically, the documentation will outline the entire process. This key basically
    protects you in that it makes sure that you’re installing signed packages. Not
    all developers protect their applications this way, but it’s definitely a good
    thing to do.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，您可能需要为新的仓库安装**GNU隐私保护**（**GnuPG**）密钥，但此过程因应用程序而异。通常，文档会概述整个过程。此密钥的作用是保护您，确保您正在安装签名的软件包。并非所有开发者都以这种方式保护他们的应用程序，但这绝对是一种值得做的好事。
- en: 'Once you have the repository (and possibly the key) installed on your server,
    you’ll need to run the following command to update your package index:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦您在服务器上安装了仓库（以及可能的密钥），您需要运行以下命令来更新软件包索引：
- en: '[PRE18]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: As mentioned earlier in this chapter, this command updates your local cache
    as to which packages are available on the remote server. APT is only aware of
    packages that are in its database, so you will need to sync this with that command
    before you’ll be able to actually install the software contained within the repository.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 如本章前面所提到的，这个命令更新你本地的缓存，显示远程服务器上有哪些可用的软件包。APT只知道它数据库中的软件包，所以你需要在使用这个命令之前同步它，这样才能实际安装仓库中的软件。
- en: Adding Personal Package Archives
  id: totrans-136
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 添加个人软件包存档
- en: On the Ubuntu platform, there also exists another type of repository, known
    as a **Personal Package Archive** (**PPA**). PPAs are essentially another form
    of APT repository, and you’ll even interact with their packages with the `apt`
    command, as you would normally. PPAs are usually very small repositories, often
    including a single application that serves a single purpose. Think of PPAs as
    *mini-repositories*. A PPA is common in situations where a vendor doesn’t make
    their software available with their own repository and may only make their application
    available in the form of source code you would need to manually download, compile,
    and install. With the PPA platform, anyone can compile a package from source and
    easily make it available for others to download.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 在Ubuntu平台上，还有另一种类型的仓库，称为**个人软件包存档**（**PPA**）。PPA本质上是APT仓库的另一种形式，你仍然可以像平常一样使用`apt`命令与它们的包进行交互。PPA通常是非常小的仓库，通常只包含一个应用程序，服务于一个特定的用途。可以把PPA看作是*迷你仓库*。当一个厂商没有提供自己的仓库，而只将应用程序以源代码的形式提供，用户需要手动下载、编译并安装时，PPA非常常见。通过PPA平台，任何人都可以从源代码编译一个包，并轻松地将其提供给其他人下载。
- en: PPAs suffer from the same security concerns as regular repositories (you need
    to trust the vendor and so on), but are a bit worse considering that the software
    typically isn’t audited at all. In addition, if the PPA was to ever go down, you’d
    stop getting security updates for the application you install from it. Only use
    PPAs when you absolutely need to.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: PPAs和常规仓库一样，也存在相同的安全问题（你需要信任供应商等），但考虑到软件通常根本没有经过审计，它们的安全性可能更差。此外，如果PPA服务器出现故障，你将停止收到从中安装的应用程序的安全更新。只有在确实需要时，才使用PPA。
- en: There is one use case for PPAs that may be compelling, specifically for a server
    platform that standard repositories aren’t able to handle very well, and that
    is software versioning. As I mentioned earlier, a major server component such
    as PHP or MySQL may be locked to a specific major version with each Ubuntu Server
    release. What do you do if you need to use Ubuntu Server, but the application
    you need to run is not available in the version your organization requires? In
    the past, you would literally need to choose between the distribution and the
    package, with some organizations even using a different distribution of Linux
    just to satisfy the need to have a specific application at a specific version.
    You can always compile the application from source (assuming its source code is
    available), but that can cause additional headaches in the sense that you’d be
    responsible for compiling new security patches yourself whenever they’re made
    available. PPAs potentially give you access to applications not normally available
    in the default repositories, and/or access to newer versions of packages than
    what is normally provided. This gives you, the server administrator, the ability
    to choose the approach that is best for your goal.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 有一个可能非常有吸引力的PPA用例，特别适用于那些标准仓库无法很好处理的服务器平台，尤其是在软件版本管理方面。正如我之前提到的，像PHP或MySQL这样的主要服务器组件，可能会随着每次Ubuntu
    Server的发布而锁定在特定的主版本中。如果你需要使用Ubuntu Server，但所需的应用程序版本在你组织要求的版本中不可用时，该怎么办？过去，你基本上只能在发行版和软件包之间做出选择，一些组织甚至会使用不同的Linux发行版，仅仅是为了满足在特定版本下运行特定应用程序的需求。你当然可以从源代码编译应用程序（假设源代码是可用的），但这样会带来额外的麻烦，因为你需要负责自己编译新的安全补丁，每当有新补丁发布时。PPAs可以让你访问那些通常在默认仓库中不可用的应用程序，和/或访问比通常提供的版本更新的软件包。这使得你，作为服务器管理员，能够选择最适合自己目标的方式。
- en: 'PPAs are generally added to your server with the `apt-add-repository` command.
    The syntax generally uses the `apt-add-repository` command, with a colon, followed
    by a username, and then the PPA name. The following command is a hypothetical
    example:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: PPAs通常通过`apt-add-repository`命令添加到你的服务器中。语法通常是使用`apt-add-repository`命令，后接冒号，再跟上用户名，最后是PPA名称。以下命令是一个假设的示例：
- en: '[PRE19]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: To begin the process, you would start your search by visiting Ubuntu’s PPA website,
    which is available at [https://launchpad.net/ubuntu/+ppas](https://launchpad.net/ubuntu/+ppas).
    There, you can search among the available PPAs.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 要开始这个过程，你可以访问Ubuntu的PPA网站，网址是[https://launchpad.net/ubuntu/+ppas](https://launchpad.net/ubuntu/+ppas)。在那里，你可以在可用的PPA中进行搜索。
- en: Before adding a PPA to your server, it’s best to first research whether or not
    it’s being maintained well. For example, if the PPA hasn’t had any updated packages
    in a very long time, that’s cause for concern—security fixes are fairly common
    with most packages. If a package isn’t being regularly updated and has therefore
    gone “stale,” it may be best to avoid it as it may cause more harm than good.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 在将PPA添加到服务器之前，最好先研究一下它是否得到了良好的维护。例如，如果PPA很长时间没有更新软件包，那么这就值得关注——大多数软件包都会有安全修复。如果一个软件包没有定期更新，已经变得“过时”，那么最好避免使用它，因为它可能会带来更多的负面影响。
- en: Once you find a PPA you would like to add to your server, you can add it simply
    by finding the name of the PPA and then adding it to your server with the `apt-add-repository`
    command.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你找到一个想要添加到服务器的PPA，你可以通过找到PPA的名称，然后使用 `apt-add-repository` 命令将其添加到你的服务器中。
- en: You should take a look at the page for the PPA, though, in case there are different
    instructions. For the most part, the `apt-add-repository` command should work
    fine for you. Each PPA typically has a set of instructions attached, so there
    shouldn’t be any guesswork required here.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，你应该查看一下PPA的页面，以防有不同的说明。大部分情况下，`apt-add-repository` 命令应该能够正常工作。每个PPA通常都有一套附带的说明，因此这里不需要进行猜测。
- en: So, what exactly does the `apt-add-repository` command do? Honestly, it’s not
    all that amazing. When you install a PPA, it’s essentially automating the process
    of adding a repository file to your `/etc/apt/sources.list.d` directory and installing
    its key. Therefore, you can uninstall a PPA by simply deleting its file.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，`apt-add-repository` 命令到底做了什么呢？说实话，它并不特别神奇。当你安装PPA时，它本质上是自动化了将一个仓库文件添加到 `/etc/apt/sources.list.d`
    目录并安装其密钥的过程。因此，你可以通过简单地删除其文件来卸载PPA。
- en: PPAs are a very useful feature if harnessed with care. PPAs offer Ubuntu a flexible
    way of adding additional software that wouldn’t normally be made available, though
    you will need to keep an eye on such repositories to ensure they are properly
    patched when vulnerabilities arise and are used only when absolutely necessary.
    Always prefer packages from Ubuntu’s default repositories as well as Snaps, but
    PPAs offer you another option in case you can’t find what you need anywhere else.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 如果谨慎使用，PPA是一个非常有用的功能。PPA为Ubuntu提供了一种灵活的方式来添加通常不会提供的额外软件，尽管你需要关注这些仓库，确保它们在出现漏洞时得到妥善修补，并且仅在绝对必要时使用。始终优先选择来自Ubuntu默认仓库以及Snaps的软件包，但PPA为你提供了另一种选择，以防你在其他地方找不到所需的软件。
- en: After you’ve maintained a server for a while, or finished setting it up for
    a particular goal, you’ll have installed a plethora of packages to suit its purpose.
    Exporting a list of installed packages can make it easier to rebuild a server
    should the need arise, and we’ll look at one method of doing that in the next
    section.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 在你维护服务器一段时间后，或者完成了为特定目标设置服务器的工作，你会安装大量的软件包以适应其目的。导出已安装的软件包列表可以让你在需要时更容易地重建服务器，下一部分我们将讨论一种实现方法。
- en: Backing up and restoring Debian packages
  id: totrans-149
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 备份和恢复Debian软件包
- en: As you maintain your server, your list of installed packages will grow. If,
    for some reason, you needed to rebuild your server, you would need to reproduce
    exactly what you had installed before, which can be a pain. It’s always recommended
    that you document all changes made to your server via a change control process,
    but, at the very least, keeping track of which packages are installed is an absolute
    must. In some cases, a server may only include one or two extra packages in order
    to meet its goal, but, in other cases, you may need an exact combination of software
    and libraries in order to get things working like they were. Thankfully, the `dpkg`
    command allows us to export and import a list of packages to install.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 随着你维护服务器，已安装的软件包列表会不断增加。如果因为某些原因，你需要重建服务器，你需要精确复现之前安装的所有内容，这可能会非常麻烦。通常建议你通过变更控制流程记录所有对服务器的修改，但至少，跟踪已安装的软件包是绝对必须的。在某些情况下，服务器可能只包含一两个额外的软件包来实现目标，但在其他情况下，你可能需要一个特定的软件和库组合才能让服务器像之前一样工作。幸运的是，`dpkg`
    命令允许我们导出和导入要安装的软件包列表。
- en: 'To export a list of installed packages, we can use the following command:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 要导出已安装包的列表，我们可以使用以下命令：
- en: '[PRE20]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'This command will dump a list of package selections to a standard text file.
    If you open it, you’ll see a list of your installed packages, one per line. A
    typical line within the exported file will look similar to the following:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 此命令将把包选择列表导出到一个标准文本文件。如果你打开它，你将看到已安装包的列表，每行一个。导出的文件中的典型行如下所示：
- en: '[PRE21]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'With this list, we can import our selections back into the server if we need
    to reinstall Ubuntu Server, or into a new server that will serve a similar purpose.
    First, before we manage any packages, we should update our index:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这个列表，我们可以将选择的包重新导入到服务器中，如果我们需要重新安装Ubuntu Server，或者导入到一个新服务器中，使其执行类似的功能。首先，在管理任何包之前，我们应该更新索引：
- en: '[PRE22]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Next, we’ll need to ensure we have the `dselect` package installed. The `dselect`
    package provides us with additional features when managing Debian packages. Its
    finer points are beyond the scope of this chapter, but for our current goal, we
    can use it to restore packages from our exported list. At your shell prompt, type
    `which dselect` and you should see output similar to the following:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要确保安装了`dselect`包。`dselect`包在管理Debian包时提供了额外的功能。它的细节超出了本章的范围，但对于我们当前的目标，我们可以使用它从导出的列表中恢复包。在你的命令行提示符下，键入`which
    dselect`，你应该会看到类似如下的输出：
- en: '[PRE23]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'If you don’t see the output, you’ll need to install the `dselect` package with
    `apt`:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你没有看到输出，你需要使用`apt`安装`dselect`包：
- en: '[PRE24]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Once that’s complete, you can now import your previously saved package list,
    and have the missing packages reinstalled on your server. The following commands
    will complete the process:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 完成后，你可以导入之前保存的包列表，并重新安装服务器上缺失的包。以下命令将完成此过程：
- en: '[PRE25]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Normally, we simply use `apt` instead of `apt-get` nowadays, but oddly enough,
    the `dselect-upgrade` command only works with `apt-get`.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，我们现在使用`apt`而不是`apt-get`，但奇怪的是，`dselect-upgrade`命令仅在`apt-get`下有效。
- en: After you have run those commands, the packages that are contained in your packages
    list but aren’t already installed will be installed once you confirm the changes.
    This method allows you to easily restore the packages previously installed on
    your server, if for some reason you need to rebuild it, as well as setting up
    a new server to be configured in a similar way to an existing one.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 在你执行了这些命令后，包列表中包含但尚未安装的包将在你确认更改后安装。这种方法可以让你轻松地恢复之前在服务器上安装的包，如果因为某些原因需要重建服务器时，也可以为新服务器的配置提供相似的设置。
- en: Now that we have an understanding of how to export and import a list of installed
    packages, we can also take a look at how to clean up unneeded packages to ensure
    our server is as free as possible from unnecessary bloat.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经了解了如何导出和导入已安装包的列表，我们还可以看看如何清理不需要的包，确保我们的服务器尽可能不含多余的臃肿。
- en: Cleaning up orphaned apt packages
  id: totrans-166
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 清理孤立的apt包
- en: As you manage packages on your server, you’ll eventually run into a situation
    where you’ll have packages on your system that are installed but not needed by
    anything. This occurs either when removing a package that has dependencies, or
    when the dependencies on an installed package change. As you’ll remember, when
    you install a package that requires other packages, those dependencies are also
    installed. But if you remove the package that required them, the dependencies
    will not be removed automatically.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 当你在服务器上管理包时，最终会遇到这样一种情况：系统中有一些已安装但没有被任何东西需要的包。这种情况发生在移除具有依赖关系的包时，或者安装包的依赖关系发生变化时。你可能还记得，当你安装一个需要其他包的包时，这些依赖包也会一并安装。但是，如果你删除了那个需要它们的包，这些依赖包不会被自动移除。
- en: 'To illustrate this situation, if I remove the `apache2` package from one of
    my servers, I will see the following extra information if I then try to install
    something else:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 为了说明这种情况，如果我从我的一台服务器上移除`apache2`包，当我尝试安装其他东西时，会看到以下额外信息：
- en: '![](img/B18425_03_05.png)'
  id: totrans-169
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B18425_03_05.png)'
- en: 'Figure 3.5: Output with orphaned packages shown'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.5：显示孤立包的输出
- en: In this example, I removed `apache2` (that was done before the screenshot was
    taken), then I went on to install `tmux`. The package I was trying to install
    is arbitrary; the important part is the text you see in the screenshot where it
    says `The following packages were automatically installed and are no longer required`.
    Basically, if you have orphaned packages on your system, Ubuntu will remind you
    periodically as you use the APT suite of tools. In this case, I removed `apache2`
    so all of the dependencies that were installed to support the `apache2` package
    were no longer needed.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我移除了`apache2`（这是在截图前完成的），然后我安装了`tmux`。我尝试安装的包是任意的；重要的是你在截图中看到的文字，那里写着`The
    following packages were automatically installed and are no longer required`。基本上，如果你的系统上有孤立的包，Ubuntu
    会在你使用 APT 工具套件时定期提醒你。在这种情况下，我移除了`apache2`，因此所有为了支持`apache2`包而安装的依赖包都不再需要。
- en: In the screenshot, I’m shown a list of packages that APT doesn’t think I need
    anymore. It may be right, but this is something we would need to investigate.
    As instructed in the output, we can use the `apt autoremove` command as `root`
    or with `sudo` to remove them. This is a great way of keeping our installed packages
    clean but should be used with care. If you’ve just recently removed a package,
    it’s probably safe to do the cleanup manually.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 在截图中，我看到了一些APT认为我不再需要的包列表。它可能是对的，但我们需要进一步调查。按照输出中的指示，我们可以以`root`身份或使用`sudo`命令来移除这些包。这是保持已安装包清洁的好方法，但需要小心使用。如果你最近刚刚移除了某个包，手动清理可能是安全的。
- en: Although we haven’t walked through updating packages (we’ll do that in *Chapter
    21*, *Securing Your Server*), a situation that may come up later is one in which
    you have outdated kernels that can be cleaned with the `autoremove` option. These
    will appear in the same way as the example orphans I was shown in the previous
    screenshot, but the names will contain `linux-image`. Take care with these; you
    should never remove outdated kernels from your server until you verify that the
    newly installed kernel is working correctly and the server doesn’t exhibit any
    unwanted or unexpected behavior. Generally, you would probably want to wait at
    least a week before running `apt autoremove` when kernel packages are involved.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然我们还没有讲解更新包的内容（我们将在*第21章*，*保护你的服务器*中进行讲解），但以后可能会遇到一种情况，你的内核版本过旧，可以通过`autoremove`选项进行清理。这些内核包会以与前面截图中显示的孤立包相同的方式显示，但名称中会包含`linux-image`。处理这些时要小心；在你验证新安装的内核工作正常并且服务器没有出现任何不必要或意外的行为之前，绝不要移除过时的内核。通常来说，当涉及到内核包时，你可能会想至少等一周才执行`apt
    autoremove`。
- en: When it comes to other packages, they are generally safe to remove with the
    `apt autoremove` command, since the majority of them will be packages that were
    installed as a dependency of another package that is no longer present on the
    system. However, double-check that you really do want to remove each of the packages
    before you do so. You can always reinstall a package if you didn’t mean to remove
    it, and as an added benefit, if you reinstall a package that was marked for auto-removal,
    it won’t show up in the output as an orphan package in the future.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 对于其他包，通常可以安全地通过`apt autoremove`命令移除，因为它们大多数是作为另一个已不在系统中的包的依赖而安装的。然而，在移除这些包之前，请务必仔细检查你是否真的想要移除它们。如果你不小心移除了某个包，可以随时重新安装它，并且作为附加好处，如果你重新安装了一个标记为自动移除的包，它以后不会再在输出中显示为孤立包。
- en: As you’ve seen so far, there are a lot of options when it comes to managing
    software in Ubuntu, and as an administrator, you are able to choose the best possible
    method for your goal. Another special type of update is available, that can improve
    hardware support in a situation where your hardware is newer than your Ubuntu
    version, or provide compatibility for hardware that didn’t previously have support
    available.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，Ubuntu 在管理软件方面有许多选项，作为管理员，你可以选择最适合你的目标的方法。还有一种特殊类型的更新可以提高硬件支持，适用于硬件比你的
    Ubuntu 版本更新的情况，或者为以前没有支持的硬件提供兼容性。
- en: Taking advantage of hardware enablement updates
  id: totrans-176
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 利用硬件启用更新
- en: One issue in the Linux industry has been hardware support. This is problematic
    in various Linux distributions because you may find yourself in a situation where
    you’re using a server (or even a desktop or laptop) that was released with the
    latest processor and chipset, but no newer version of your Linux distribution
    has been released yet that includes updated drivers that support it. Unlike platforms
    such as Windows, hardware drivers are typically built right into the Linux kernel.
    So, if you have an old release (which would contain an older kernel), you might
    be out of luck for hardware support until the next version of your Linux distribution
    is released.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: Linux行业的一个问题是硬件支持。在各种Linux发行版中，这是一个问题，因为你可能会遇到这样的情况：你正在使用一台发布时配备了最新处理器和芯片组的服务器（甚至是台式机或笔记本），但你的Linux发行版还没有发布包含更新驱动程序的新版，无法支持它。与Windows等平台不同，硬件驱动通常直接集成在Linux内核中。所以，如果你使用的是旧版（该版本包含较旧的内核），你可能就无法获得硬件支持，直到下一个Linux发行版发布。
- en: Thankfully, Ubuntu has come up with a system to address this problem, and it’s
    one of the many things that set it apart from other distributions. Ubuntu features
    a set of updates known as the **hardware enablement** (**HWE**) stack, which is
    an exclusive feature of **long-term support** (**LTS**) releases. We discussed
    the difference between LTS and regular releases back in *Chapter 1*, *Deploying
    Ubuntu Server*. HWE updates are optional, but they add additional compatibility
    with newer hardware that was released after the current LTS version was made available.
    A new HWE stack typically includes a new kernel and driver packages. However,
    since drivers are often built right into the Linux kernel, you’ll also get added
    support for things other than new video cards as well, such as newly released
    network cards.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，Ubuntu想出了一个系统来解决这个问题，这也是它与其他发行版不同的许多优点之一。Ubuntu提供了一组称为**硬件启用**（**HWE**）堆栈的更新，这是**长期支持**（**LTS**）版本的独有功能。我们在*第1章*、*部署Ubuntu服务器*中讨论过LTS版本和常规版本的区别。HWE更新是可选的，但它们为当前LTS版本发布之后的较新硬件提供了额外的兼容性。新的HWE堆栈通常包括新的内核和驱动包。然而，由于驱动程序通常是直接集成到Linux内核中的，因此你还将获得对新视频卡以外的其他硬件（例如新发布的网卡）的支持。
- en: HWE updates are generally made available from the second point release of an
    LTS version, and then again with each subsequent point release until the next
    LTS release becomes available. The new compatibility stack is **backported** from
    the most recent non-LTS release, which means that you get the same compatibility
    of the latest non-LTS release while being able to stay on an LTS release. For
    example, when Ubuntu 20.04.2 was released on February 4, 2021, it contained the
    kernel and driver packages backported from Ubuntu 20.10\. This means that you
    were able to take advantage of the newer hardware support of Ubuntu 20.10 while
    being able to remain on 20.04 LTS and benefit from the longer support cycle of
    the LTS release.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: HWE更新通常从LTS版本的第二个点发布开始提供，然后每次随后的点发布中都会提供，直到下一个LTS版本发布。新的兼容性堆栈是从最新的非LTS版本**回溯**过来的，这意味着你可以在保持LTS版本的同时，享受最新非LTS版本的兼容性。例如，当Ubuntu
    20.04.2在2021年2月4日发布时，它包含了从Ubuntu 20.10回溯过来的内核和驱动包。这意味着你可以在保持20.04 LTS的同时，利用Ubuntu
    20.10的较新硬件支持，并享受LTS版本的更长支持周期。
- en: At the time of writing, Ubuntu 22.04 is the latest LTS release of Ubuntu, so
    hardware enablement hasn’t been added yet. Historically, it’s most likely the
    case that hardware enablement will play out in 22.04 LTS the same way as it has
    in previous releases. If that’s the case, then the updated packages will be made
    available once Ubuntu 22.04.2 is released.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 截至撰写时，Ubuntu 22.04是最新的LTS版本，因此尚未添加硬件启用。根据历史经验，硬件启用可能会像以往版本一样在22.04 LTS中展开。如果是这样，那么更新的包将在Ubuntu
    22.04.2发布后提供。
- en: Once the new HWE stack is made available, you can choose to install it or to
    remain on the original 22.04 kernel with no change. On the desktop version of
    Ubuntu, people that enjoy computer games can really benefit from these updates,
    as the new drivers enable better performance when it comes to video cards and
    support newer gaming hardware. When it comes to the scope of this book, the new
    hardware enablement benefits us a bit less than desktop users. The reason is that
    if your server is running fine with no issues, then there really isn’t any reason
    to install the new hardware enablement unless the updated kernel contains new
    features you’d like to take advantage of.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦新的硬件启用堆栈（HWE）可用，你可以选择安装它，或者继续使用原来的 22.04 内核而不做任何更改。对于 Ubuntu 桌面版来说，喜欢玩电脑游戏的人会从这些更新中受益匪浅，因为新的驱动程序能在显卡方面提供更好的性能，并且支持更新的游戏硬件。就本书的范围而言，新的硬件启用对我们来说的好处比桌面用户少一些。原因是，如果你的服务器运行正常没有问题，那么实际上没有必要安装新的硬件启用堆栈，除非更新的内核包含你希望利用的新特性。
- en: A frustrating experience that sometimes comes up is having Ubuntu complain that
    there are no network cards available, even though you do actually have one. I’ve
    seen this most often when purchasing a new physical server that contains the latest
    hardware. It can be very frustrating to power on a brand-new server, only to realize
    you can’t get a network connection at all. This is a classic symptom of needing
    an updated compatibility stack. Perhaps your network card was released after the
    release date of the current Ubuntu release. This scenario is a good example of
    why hardware enablement updates exist, and why you will probably end up using
    them sooner or later.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 有时会遇到一个让人沮丧的情况，那就是 Ubuntu 报告说没有可用的网络卡，尽管你实际上有一张。通常在购买新服务器，特别是包含最新硬件的物理服务器时，我遇到这种情况最为频繁。当你启动一台崭新的服务器时，却发现根本无法建立网络连接，这种情况非常让人沮丧。这是需要更新兼容性堆栈的经典症状。也许你的网络卡是在当前
    Ubuntu 版本发布之后才发布的。这种情况正好说明了硬件启用更新存在的原因，也解释了为什么你迟早可能需要使用它们。
- en: If you don’t opt in to the HWE updates, your server will always have the same
    hardware enablement (kernel, drivers, and so on) as it did when your installed
    LTS release was first published. In that case, your kernel and related packages
    will only be updated when you install new security updates. At a later date, you
    can opt in to HWE updates manually if you wish. Generally, you only do this if
    you’ve added new hardware to a physical server that requires a new kernel. If
    your server is working perfectly fine and you haven’t added new hardware, there’s
    probably no reason to install a new HWE stack.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你没有选择硬件启用更新，你的服务器将始终保持与首次发布你所安装的 LTS 版本时相同的硬件启用（内核、驱动程序等）。在这种情况下，只有在安装新的安全更新时，才会更新内核和相关软件包。稍后，你可以手动选择是否安装硬件启用更新。通常，只有当你向物理服务器添加了需要新内核的新硬件时，才会这样做。如果你的服务器运行正常，并且没有添加新硬件，那么可能没有必要安装新的硬件启用堆栈。
- en: 'If you do decide to utilize these updates, there are two ways to do so. You
    can opt in to the newer HWE stack while installing Ubuntu Server, or you can manually
    install the required packages. At the time of writing, Ubuntu 22.04 is new to
    the scene, so it remains to be seen if the updated packages will be made available
    with 22.04.2, but it’s very likely given Ubuntu’s history. The following screenshot
    shows the first screen of the installer for Ubuntu 20.04.4\. Assuming Ubuntu 22.04
    follows the same plan, you’ll most likely see an option such as the one in the
    following screenshot once 22.04.2 is released:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你决定使用这些更新，有两种方法可以实现。你可以在安装 Ubuntu Server 时选择更新的硬件启用堆栈，或者手动安装所需的软件包。在撰写本文时，Ubuntu
    22.04 刚刚发布，因此是否会在 22.04.2 发布时提供更新的软件包尚未可知，但鉴于 Ubuntu 的历史，这种可能性很大。以下截图展示了 Ubuntu
    20.04.4 安装程序的第一个界面。假设 Ubuntu 22.04 按照相同的计划进行，届时你很可能会看到类似下图所示的选项，一旦 22.04.2 发布：
- en: '![](img/B18425_03_06.png)'
  id: totrans-185
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B18425_03_06.png)'
- en: 'Figure 3.6: Main menu of the installer for Ubuntu 20.04.4'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.6：Ubuntu 20.04.4 安装程序的主菜单
- en: Notice the **Install Ubuntu Server with the HWE kernel** option. If you choose
    this option, then your installation of Ubuntu Server will contain the new HWE
    packages immediately.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意**使用 HWE 内核安装 Ubuntu Server**选项。如果你选择此选项，那么你的 Ubuntu Server 安装将立即包含新的 HWE
    软件包。
- en: 'If you’ve already installed Ubuntu Server and you’d like to install the HWE
    updates afterward, you can do so from the terminal. In Ubuntu 20.04, for example,
    you were able to switch to the HWE kernel with the following command:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你已经安装了 Ubuntu 服务器，并且希望之后安装 HWE 更新，可以通过终端进行安装。例如，在 Ubuntu 20.04 中，你可以使用以下命令切换到
    HWE 内核：
- en: '[PRE26]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: When Ubuntu 22.04 releases its newer HWE stack, a similar command will likely
    be used to install it. If you need a newer HWE kernel, refer to the instructions
    in Ubuntu’s documentation pages when that time comes.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 当 Ubuntu 22.04 发布更新的 HWE 堆栈时，很可能会使用类似的命令来安装它。如果你需要更新的 HWE 内核，请在那个时候参考 Ubuntu
    文档页面中的说明。
- en: Summary
  id: totrans-191
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 概述
- en: In this chapter, we have taken a crash course in the world of package management.
    As you can see, Ubuntu Server offers an amazing number of software packages and
    various tools that we can use to manage them. We began the chapter with a discussion
    of how package management with Ubuntu works, then we worked through installing
    packages, searching for packages, and managing repositories. Snap packages were
    also covered, which is a newer technology that aims to enhance software distribution
    on Ubuntu.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们对包管理的世界进行了快速入门。正如你所看到的，Ubuntu 服务器提供了大量的软件包和各种工具，我们可以利用它们来管理这些包。我们从讨论
    Ubuntu 的包管理如何工作开始，接着介绍了安装软件包、搜索软件包和管理仓库的过程。同时，我们还涉及了 Snap 包，这是一种较新的技术，旨在增强 Ubuntu
    上的软件分发。
- en: In *Chapter 4*, *Navigating and Essential Commands*, we’ll take a look at foundational
    commands for navigating the Linux Shell, understanding the filesystem layout,
    and more.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 在*第 4 章*，*导航与基础命令*中，我们将探讨一些基础命令，用于导航 Linux Shell，了解文件系统布局等。
- en: Relevant video
  id: totrans-194
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 相关视频
- en: 'Linux Crash Course - APT (LearnLinuxTV): [https://linux.video/lcc-apt](https://linux.video/lcc-apt)'
  id: totrans-195
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'Linux 快速入门 - APT (LearnLinuxTV): [https://linux.video/lcc-apt](https://linux.video/lcc-apt)'
- en: Further reading
  id: totrans-196
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: 'LTSEnablementStack (Ubuntu wiki): [https://learnlinux.link/lts-es](https://learnlinux.link/lts-es)'
  id: totrans-197
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'LTSEnablementStack (Ubuntu wiki): [https://learnlinux.link/lts-es](https://learnlinux.link/lts-es)'
- en: 'Ubuntu Server Guide: [https://ubuntu.com/server/docs](https://ubuntu.com/server/docs)'
  id: totrans-198
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'Ubuntu 服务器指南: [https://ubuntu.com/server/docs](https://ubuntu.com/server/docs)'
- en: Join our community on Discord
  id: totrans-199
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 加入我们的 Discord 社区
- en: 'Join our community’s Discord space for discussions with the author and other
    readers:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 加入我们社区的 Discord 频道，与作者和其他读者讨论：
- en: '[https://packt.link/LWaZ0](https://packt.link/LWaZ0)'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://packt.link/LWaZ0](https://packt.link/LWaZ0)'
- en: '![](img/QR_Code50046724-1955875156.png)'
  id: totrans-202
  prefs: []
  type: TYPE_IMG
  zh: '![](img/QR_Code50046724-1955875156.png)'
